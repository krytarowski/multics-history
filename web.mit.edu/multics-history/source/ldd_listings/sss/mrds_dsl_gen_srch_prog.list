	COMPILATION LISTING OF SEGMENT mrds_dsl_gen_srch_prog
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/01/88  1339.5 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
       15*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
       16*     This entry is being made to cover the change made on 85-06-14 by Thanh
       17*     Nguyen. (see mrds #136 and #139, phx19906)
       18*  2) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
       19*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
       20*     This entry is being made to cover the change made on 85-10-13 by John
       21*     Hergert. (see mrds #138, phx19901)
       22*  3) change(86-06-13,Dupuis), approve(86-08-05,MCR7491), audit(86-08-08,Blair),
       23*     install(86-08-15,MR12.0-1127):
       24*     Added the word "aligned" to the declaration of current_scope_flags
       25*     (mrds #155).
       26*  4) change(87-01-22,Hergert), approve(88-07-11,MCR7903),
       27*     audit(88-05-23,Dupuis), install(88-08-01,MR12.2-1073):
       28*     For new parser, modified the way the values of range_ptr and ti_ptr are
       29*     set.  These values are now passed in and need not be calculated from
       30*     ss_ptr.
       31*                                                   END HISTORY COMMENTS */
       32 
       33 
       34 mrds_dsl_gen_srch_prog: proc (dbcb_ptr, path_var_ptr, sv_ptr, so_ptr, code);
       35 
       36 /* 
       37*   BEGIN_DESCRIPTION
       38*   This  procedure  generates the search operator tables necessary to evaluate
       39*   an and group.  Input is the path structure produced by calc_cost and output
       40*   is  the  search_vars and search_ops structures, which are the "program" for
       41*   mrds_dsl_search.
       42*
       43*
       44*   DEBUG SWITCHES:
       45*
       46*   bit 1 - - for possible additional key searches after the  initial
       47*   tuple  access via long key head, short key head, or indexed attr,
       48*   use comparisons, rather than more key searches  if  this  bit  is
       49*   one.
       50*
       51*   bit 2 - - the opposite of bit 1, it forces  key  searches  rather
       52*   than compares, regardless of the strategy for deciding when to do
       53*   key searches versus compares.
       54*
       55*   bit 3 - 9 - - - unused.
       56*   END_DESCRIPTION
       57*
       58*   HISTORY:
       59*
       60*   79-02-01 J. A. Weeldreyer: Initially written.
       61*
       62*   79-04-24 Al Kepner: Modified to initialize ti_ntuples_init.
       63*
       64*   79-04-25  Al  Kepner: Modified to make pvp a local ptr so the corresponding
       65*   input parameter won't get changed.
       66*
       67*   79-05-24  Al  Kepner:  Modified  to  initialize index.mbz to "0"b and to do
       68*   primary  initialization of move_info by setting the whole structure to zero
       69*   in alloc_move_info.
       70*
       71*   79-06-08 Al Kepner: Modified to use select_area.
       72*
       73*   79-06-29  Al  Kepner:  Modified  to  provide  for comparing values within a
       74*   single tuple.
       75*
       76*   79-07-03  Al  Kepner:  Modified to use provide descriptors in move_info for
       77*   use by mu_convert.
       78*
       79*   79-09-07  Davids:  Modified  so  that move_info.t_ptr will now point to the
       80*   structure  ind_sel_info  when move_info.encd_index = "1"b.  For the case of
       81*   unique  index  a  ind_sel_info  structure  will  also  be allocated and the
       82*   init_info.val_ptr   will   point   at   the  ind_sel_info.key  rather  then
       83*   ind_sel_info.
       84*
       85*   79-10-26   Davids:  init_info.val_ptr  will  now  point  to  the  structure
       86*   ind_sel_info  rather than ind_sel_info.key.  Why it was not done originally
       87*   is a good question.
       88*
       89*   80-01-19  Davids:  key  search lists are now built only for cases were they
       90*   can  be  used  i.e.  r,key < r.index cannot be used since there is no value
       91*   for either key or index.
       92*
       93*   80-02-13  Davids: internal procedure extract_attr now sets move_info.s_desc
       94*   for  varying  attributes.   non-varying  attributes seem to work without it
       95*   being  set so i haven't done anything about them (don't mess with a working
       96*   system).
       97*
       98*   80-05-07 Davids: modified assignments of tuple_num_atts and tuple_nvar_atts
       99*   to  take  values from rm_rel_info.model_num_attr and model_nvar_atts rather
      100*   than  rm_rel_info.num_attr  and  nvar_atts.  This was to fix a problem with
      101*   submodels were the submodel view did not contain a varying string attribute
      102*   and the model did.
      103*
      104*   81-05-06  Rickie  E.   Brinegar:  Modified to use the change rm_domain_info
      105*   structure.
      106*
      107*   81-05-22 Jim Gray : filled in descriptor information to move_info
      108*   for  case  of  nonvarying attribute, in the extract_attr routine.
      109*   This is needed in the case of a r1.key =  r2.key,  but  the  data
      110*   types  differ.  Also  changed  build_ksl  to  know the difference
      111*   between the key, and moving attr  descriptors,  and  to  force  a
      112*   conversion type move_info, when the data types disagree.
      113*
      114*   81-05-23 Jim Gray : commented out code referencing unsed parts of
      115*   tuple  structure,  in  process  of  removing  them from the tuple
      116*   structure.
      117*
      118*   81-06-01 Jim Gray : changed to use new resultant structure,  thus
      119*   blocked file code was deleted.
      120*
      121*   81-06-12 Jim Gray : moved setting  of  rai_ptr  and  rdi_ptr  (to
      122*   rm_attr_info  and rm_domain_info) inside of condition loop in the
      123*   attr loop in the build_select_op routine. This was  done  because
      124*   the  call  to complete_comparison_item was resetting these values
      125*   from  the  attribute  being  comapred  against  to  one  of   the
      126*   attributes   targeted   for  comparison.  This  caused  selection
      127*   expressions such as -where ((r1.key = "x") & (((r1.key = r2.data)
      128*   &  (r1.key  =  r3.data))  & (r2.data = r3.data))) to fail because
      129*   after the keyed tuple is found, and r2's matching tuple is found,
      130*   then two compares must be done against the one r3.data attribute,
      131*   one for the r1.key value, and the other for the r2.data attribute
      132*   value.  Of course if MRDS was smart, it would know it only had to
      133*   make one of these comparisons because of  the  r1.key  =  r2.data
      134*   clause.
      135*
      136*   81-06-17 Jim Gray : added call to  mu_open_iocb_manager  so  that
      137*   iocbs are obtained on an as needed basis.
      138*
      139*   81-06-30 Jim Gray  :  changed  build_vfile_select_init_info  to  make  only  one
      140*   init_info  for  the  case  10  <  x  < 20, so that a range on one
      141*   attriubte could be done in one call to vfile select,  instead  of
      142*   two.
      143*
      144*   81-07-01 Jim Gray : modified  process_ind_hd  to  recognize  case
      145*   when  the  first  N of M key attrs have only the "=" condition on
      146*   them, and can thus be used as a pure key head.
      147*
      148*   81-07-07 Jim Gray : changed  to  use  new  path_var.access_method
      149*   encodings
      150*
      151*   81-07-09 Jim Gray : changed logic, so  that  gen_srch_prog  could
      152*   not  build  search  program  using  key_head  (if available) when
      153*   permute said to use index attr instead.
      154*
      155*   81-07-18 Jim Gray  :  changed  build_ksl  to  use  the  condition
      156*   selected  by permute, rather than doing it's own thing. Also made
      157*   it the only logic to do the removal of  a  key  search  condition
      158*   from  further consideration. ALso removed routine proc_ind_hd, as
      159*   it's job is done in permute. Renamed  the  finish_ind_hd  routine
      160*   build_vfile_select_init_info,   and   gave   it  some  parameters
      161*   (finish_ind_hd had none). Made separate logic  for  each  of  the
      162*   vfile  select  access methods (long_key_head, short_key_head, and
      163*   indexed_attr). Made each get it's  info  from  that  supplied  by
      164*   permute,  on  which  attributes and conditions to be used for the
      165*   access. Also  added  routine  check_for_additional_key_search  to
      166*   find  out  if  it  is  cheaper  to do another vfile select on any
      167*   conditions remaining against keys, or to leave  these  conditions
      168*   to   be   handled   by   mu_compare_values,   as   specified   by
      169*   build_select_op. Also put the  logic  for  doing  a  primary  key
      170*   search  into  the  routine  build_vfile_seek_key_init_info. Added
      171*   debug switch 1, to allow additional key conditions to  be  forced
      172*   into being done via comparisons in mu_compare_values instead.
      173*
      174*   81-07-19  Jim  Gray   :   added   logic   to   not   generate   a
      175*   move-init-select  set of opreations for a tuple variable that has
      176*   no effect on the select set. Previously this caused  not  in  and
      177*   group  tuple varibles to be cross product with the results of the
      178*   and group, even if they were not select. This way  the  user  can
      179*   specify  if  he  wants  the  cross  product or not. Also, a tuple
      180*   variable can particate in 1 of N and groups, not be in the select
      181*   clause, and still not considered a no_tuple_effect T.V.
      182*
      183*   81-07-21 Jim Gray :  added  logic  to  allow  use  of  a  permute
      184*   specified range of values on a short key head or an indexed attr.
      185*
      186*   81-07-22 Jim Gray :  added  a  simple  strategy  to  avoid  doing
      187*   additional  key  searches  when  the number of primary key access
      188*   tuples was small, thus improving performance  by  avoiding  vfile
      189*   select  overhead  for small sets of data. The number used was put
      190*   into a mrds data item.
      191*
      192*   82-09-02 Mike Kubicar : added changes necessary to use the simple
      193*   vector structure in place of the tuple structure.
      194*
      195*   82-09-21 Davids: deleted references to file_io_array which was used
      196*   to keep track of which solt in the rm_rel_info.iocb_ptr array an
      197*   iocb was in. deleted the call to mu_open_iocb_manager and added a
      198*   call to mu_cursor_manager_$get.
      199*
      200*   82-10-01 Davids: changes to use the new search specification structure.
      201*   This included creation of two new internal procedures.
      202*   build_key_or_index_init_info took the place of build_vfile_seek_key_init_info
      203*   and build_vfile_select_init_info. build_key_values_list takes the
      204*   place of build_ksl the difference is that all conditions on the attributes
      205*   that are part of the key are recorded and the flag is set indicating that
      206*   the attributes have no more conditions on them. references to key_src_list
      207*   have been removed and replaced with key_values_list. The key_values_list is
      208*   what is actually passed to the search program, the search spec is created
      209*   by the code that needs it.
      210*
      211*   82-10-12 Davids: modifications so that the module will compile. Removed 
      212*   the assignment to file_id which is no longer used. Removed from internal
      213*   proc extract_attr references to rm_attr_info.varying which no longer
      214*   exists. move_info.bit_move and move_info.var_move are no longer set
      215*   in that routine. 
      216*
      217*   82-10-25 Davids: In the internal proc alloc_init_info assigned
      218*   init_info.val_ptr = null (). In the internal proc build_key_values_list
      219*   assign key_values_list.fwd_ptr = null () after the structure is allocated.
      220*   This assures that tests for null pointers will work.
      221*
      222*   82-10-26 Davids: Modified so that long key head and short key head init
      223*   infos correctly record their type instead of recording a type of total
      224*   primary key. This required using the type parameter in the
      225*   build_key_or_index_init_info internal proc that was there but not used.
      226*   Also changed the collection_index for ordered sequential to be the rel_id
      227*   instead of the primary_key id so that there is now no difference between
      228*   ordered and unordered sequential (the implementation of 
      229*   mu_sec_get_tuple$next requires the rel_id collection to be used).
      230*   Also so that the new element in the search_vars.info structure,
      231*   record_collection_cursor_ptr, is set. The record collection cursor is
      232*   needed to do relation manager get_tuple_by_id calls. Both the cursor 
      233*   pointed to by the cursor_ptr and the cursor pointed to by the 
      234*   record_collection_cursor_ptr can be over the same tuple variable
      235*   since the record_collection_cursor will not be used until the cursor
      236*   has located all the tuples.
      237*
      238*   82-10-27 Davids: changed the calls to build_key_or_index_init_info
      239*   for the short key head  and index cases to pass a pointer to the
      240*   array instead of the first element in the array which was incorrect.
      241*
      242*   82-10-29 Added the assignment of move_info.bit_move and var_move
      243*   in the internal proc extract_attr. These assignments were incorrected
      244*   removed on 82-10-12. Since rm_attr_info.varying no longer exists a
      245*   call to mu_data_class$varying in made instead.
      246*
      247*   82-11-01 Davids: added code to set move_info.sbit_len in the extract_attr
      248*   internal proc. This was inadvertenly removed eariler.
      249*
      250*   82-11-11 Mike Kubicar: Put back code to make a distinction between ordered
      251*   and unordered searches.  Due to a vrm_relmgr_ bug, primary key index ids
      252*   must be used for ordered searches.
      253*
      254*   83-02-28 Davids: explicitly declared variables that were declared by
      255*   context of implication and removed declarations to variables that
      256*   were never referenced.
      257*
      258*   83-04-04 Mike Kubicar : Took out the distinction code again.  This time
      259*   for sure.
      260*
      261*   83-04-24 Mike Kubicar : Significant changes to the way search programs
      262*   are generated have been added.  In addition to a comparason list,
      263*   this module will now also generate a search specification.  This search
      264*   spec will be given to relation manager when the searching task is being
      265*   done.  The search spec is built by procedure "build_select_op".
      266*   During the loop which counts the number of conditions on attributes,
      267*   the condition is checked to see if it can be passed directly to relation
      268*   manager.  If so, this is noted and the condition removed from the
      269*   "attr_list" structure.  After the loop, a search spec is built in addition
      270*   to the comparison list.  Also, since the search spec built is better than
      271*   the one generated from key lists, "build_key_values_list" and
      272*   "build_key_or_index_init_info" have been removed.  A search spec will
      273*   be built which can retrieve keyed (indexed) tuples efficiently during
      274*   a mrds_dsl_search "select" operation.
      275*
      276*   83-05-24 R. Harvey: added the build_vectors routine which will build a
      277*   simple_typed_vector and an id_list for each tuple variable based upon
      278*   what is being returned to the caller and what is needed by MRDS for
      279*   comparisons.
      280*
      281*   83-05-31 Mike Kubicar : Updated to use the new (version 4) search spec
      282*   and relation cursors.
      283*
      284*   83-08-04 Mike Kubicar : Added code to set up all the element id lists
      285*   needed by the search program.  The element_id_list_segment is evenly
      286*   divided among all the tuple variables.
      287*
      288*   84-07-08 Thanh Nguyen : Added code to set the c_ai_ptrs (attribute ptrs)
      289*   of the comp_val_list.  These pointers make the rm_attr_info and then the
      290*   rm_domain_info to be accessible for checking on the decoding of an
      291*   attribute.
      292*
      293*   85-01-06 Thanh Nguyen : Modified code to set the output descriptor to be
      294*   the same as the user_desc when decode_declare is in used, and c_ai_ptrs
      295*   for each element (of array not the entire array) in the comp_val_list.
      296*
      297*   85-04-08 Thanh Nguyen - Added code to set the max_tids to be either 
      298*   max_tids_returned_per_call or max_safe_tids_returned_per_call depending on 
      299*   the scope of the relation is shared or not.
      300*
      301*   85-06-14 Thanh Nguyen - Added code to set max_tids to be 
      302*   max_tids_returned_per_call and not to check for the scope flags if the
      303*   relation is temporary (rm_rel_info.file_type = 3).  Also rewrote
      304*   the calculation method for the size of the element_id_list structure.
      305*
      306*   85-10-13 John Hergert: Modified the fix of 84-07-08 to fix TR's phx19901
      307*   and phx11536. This included adding code to find out that if an attribute
      308*   that is being compared in a qualifier is being compared to an expression,
      309*   the attribute should be decoded.
      310**/
      311 
      312 	rdbi_ptr = dbcb.rdbi_ptr;			/* initialize */
      313 	num_dims = 0;
      314 
      315 	pvp = path_var_ptr;
      316 
      317 	range_ptr = dbcb.range_ptr;
      318 	ti_ptr = dbcb.ti_ptr;
      319 
      320 	ti_ntuples_init = tuple_info.num_tuples;
      321 
      322 	pa_ptr = null;
      323 	select_area_ptr = dbcb.select_area_ptr;
      324 	/* We start on a new select expression, so turn scopes_changed flag and shared mode flag off. */
      325 	dbcb.scopes_changed = "0"b;
      326 	dbcb.non_shared_to_shared = "0"b;
      327 
      328 
      329 	sv_nvars_init = range.num_vars;		/* init search vars for and group */
      330 	allocate search_vars in (select_area);		/* select_area allocs never freed. It
      331*						   is re-init at the start of each new S.E.. */
      332 	string (search_vars.new_val) = "0"b;
      333 
      334 	so_nops_init = 3 * range.num_vars + 3;		/* set up search ops */
      335 	allocate search_ops in (select_area);		/* select_area allocs never freed. It
      336*						   is re-init at the start of each new S.E.. */
      337 
      338 	search_ops.ic = 1;
      339 	search_ops.nops = 1;
      340 
      341 	search_ops.op.code (1) = PICKUP_SVP;		/* first op is to pick up search vars */
      342 	search_ops.op.info_ptr (1) = sv_ptr;
      343 	search_ops.op.var_ind (1) = 0;
      344 	search_ops.op.good_xfer (1) = 1;
      345 	search_ops.op.err_xfer = 0;
      346 
      347 	i = 0;
      348 	allocate pvp_array in (select_area);		/* select_area allocs never freed. It
      349*						   is re-init at the start of each new S.E.. */
      350 	do xp = pvp repeat xp -> path_var.fwd_thd while (xp ^= null);
      351 	     i = i + 1;
      352 	     pvp_array (i) = xp;			/* build array of path var ptrs */
      353 	end;
      354 	max_pv = i;
      355 	next_element_id_list_ptr = dbcb.element_id_list_segment_ptr;
      356 
      357 	do i = max_pv by -1 to 1;			/* process variables in determination order */
      358 
      359 	     pvp = pvp_array (i);
      360 	     vind = path_var.var_index;
      361 	     alp = path_var.alp;
      362 	     elp = path_var.elp;
      363 	     rmri_ptr,
      364 		search_vars.info.ri_ptr (vind) = range.tup_var.ri_ptr (vind); /* fill in search var info */
      365 
      366 	     search_vars.info.ntids (vind),
      367 		search_vars.info.ctid (vind) = 0;
      368 	     current_max_tids_per_call = mrds_data_$max_tids_returned_per_call;
      369 	     if rm_rel_info.file_type ^= 3 then do;
      370 		/* file_type = 3 only when the relation is temporary */
      371 		current_scope_ptr = rm_rel_info.scope_flags_ptr;
      372 		if current_scopes_flags.permits.read_attr |
      373 		   current_scopes_flags.permits.delete_tuple |
      374 		   current_scopes_flags.permits.modify_attr then
      375 		   if ^current_scopes_flags.prevents.modify_attr |
      376 		     (^current_scopes_flags.prevents.append_tuple &
      377 		      ^current_scopes_flags.prevents.delete_tuple) then
      378 		      current_max_tids_per_call = mrds_data_$max_safe_tids_returned_per_call;
      379 	     end;
      380 	     search_vars.info.maxtids(vind) = current_max_tids_per_call;
      381 	     search_vars.info.ta_ptr (vind) = next_element_id_list_ptr;
      382 	     next_element_id_list_ptr = addrel (search_vars.info.ta_ptr (vind),
      383 		current_max_tids_per_call + 2);	
      384 	     /* There are two words of header in an element id list */
      385 	     element_id_list_ptr = search_vars.info.ta_ptr (vind);
      386 	     element_id_list.version = ELEMENT_ID_LIST_VERSION_1;
      387 	     element_id_list.number_of_elements = 0;
      388 
      389 	     if path_var.in_select_clause | path_var.in_and_group then do; /* ignore un-used T.V.'s */
      390 
      391 		     mi = search_ops.nops + 1;	/* set up the search operators */
      392 		     ii = search_ops.nops + 2;
      393 		     search_ops.nops,
      394 			si = search_ops.nops + 3;
      395 
      396 		     search_ops.op.code (mi) = MOVE;
      397 		     search_ops.op.code (ii) = INIT;
      398 		     search_ops.op.code (si) = SEL;
      399 		     search_ops.op.var_ind (mi),
      400 			search_ops.op.var_ind (ii),
      401 			search_ops.op.var_ind (si) = vind;
      402 		     search_ops.op.good_xfer (mi),
      403 			search_ops.op.good_xfer (ii),
      404 			search_ops.op.good_xfer (si) = 1;
      405 		     search_ops.op.err_xfer (mi) = 0;
      406 		     search_ops.op.err_xfer (ii) = -2;
      407 		     search_ops.op.err_xfer (si) = -3;
      408 		     search_ops.op.info_ptr (mi),
      409 			search_ops.op.info_ptr (ii),
      410 			search_ops.op.info_ptr (si),
      411 			cur_mi_ptr,
      412 			cur_ii_ptr = null;
      413 
      414 		     go to process_var (path_var.access_method); /* go do stuff depend. on determ. method */
      415 
      416 
      417 process_var (1):					/* total primary key */
      418 
      419 		     j = rm_rel_info.nkey_attr;
      420 		     aip_ptr = addr (rm_rel_info.key_attr_ptrs (1));
      421 		     collection_index = rm_rel_info.primary_key_index_id;
      422 		     go to cont2;
      423 
      424 process_var (2):					/* long key head */
      425 
      426 		     opr_ind = 0;
      427 		     j = path_var.attr_index;		/* set number of key head attrs used */
      428 		     aip_ptr = addr (rm_rel_info.key_attr_ptrs (1)); /* point to list of key attributes */
      429 		     collection_index = rm_rel_info.primary_key_index_id;
      430 		     goto cont2;
      431 
      432 process_var (3):					/* short key head */
      433 
      434 		     opr_ind = 0;			/* init opr insert. index */
      435 		     j = 1;			/* only one key attribute used in a short key head */
      436 		     collection_index = rm_rel_info.primary_key_index_id;
      437 		     goto cont2;
      438 
      439 process_var (4):					/* indexed attr */
      440 
      441 		     opr_ind = 0;			/* init opr insert. index */
      442 
      443 		     j = 1;			/* only one attr secondary key indexing allowed */
      444 		     collection_index = rm_rel_info.attr_ptrs (path_var.attr_index) -> rm_attr_info.index_id;
      445 		     go to cont2;
      446 
      447 
      448 
      449 process_var (5):					/* unordered sequential */
      450 process_var (6):					/* ordered sequential (not used) */
      451 
      452 
      453 		     collection_index = rm_rel_info.rel_id;
      454 		     go to cont2;
      455 
      456 cont2:
      457 		     call build_select_op ();
      458 		     call mu_cursor_manager_$get (dbcb.dbi, rmri_ptr, (vind), collection_index,
      459 			dbcb.relmgr_entries.create_cursor, dbcb.relmgr_entries.open,
      460 			dbcb.cursor_ptrs_storage_ptr, dbcb.cursor_storage_area_ptr,
      461 			search_vars.info.relation_cursor_ptr (vind), icode);
      462 		     if icode ^= 0
      463 		     then call error (icode);
      464 
      465 
      466 		end;				/* end of processing one variable */
      467 	end;					/* loop through variables of and group */
      468 
      469 	rvi = search_ops.nops + 1;			/* fill in last search ops */
      470 	search_ops.nops,
      471 	     rni = search_ops.nops + 2;
      472 	search_ops.op.code (rvi) = RETVAL;
      473 	search_ops.op.code (rni) = RETNUL;
      474 	search_ops.op.var_ind (rvi),
      475 	     search_ops.op.var_ind (rni),
      476 	     search_ops.op.good_xfer (rni),
      477 	     search_ops.op.err_xfer (rvi),
      478 	     search_ops.op.err_xfer (rni) = 0;
      479 	search_ops.op.good_xfer (rvi) = -1;
      480 	search_ops.op.info_ptr (rvi),
      481 	     search_ops.op.info_ptr (rni) = null;
      482 
      483 	call build_vectors;
      484 
      485 	code = 0;
      486 
      487 exit:	;
      488 	return;
      489 
      490 build_select_op: proc;
      491 
      492 /* Procedure to build info for select operator */
      493 
      494 	dcl     attr_desc		 bit (36) aligned;	/* Descriptor for the attribute currently being looked at */
      495 	dcl     attr_rai_ptr	 ptr;		/* Pointer to attribute's rm_attr_info */
      496 	dcl     attr_rdi_ptr	 ptr;		/* Pointer to attribute's rm_domain_info */
      497 
      498 	dcl     1 constraint_entry	 based (constraint_entry_ptr), /* Info for a condition that can be in search spec */
      499 		2 next_entry	 ptr,		/* Next constraint in list */
      500 		2 constraint_info,
      501 		  3 field_id	 fixed bin,	/* Attribute's position in relation */
      502 		  3 operator_code	 fixed bin,	/* Comparison operator */
      503 		  3 value_ptr	 ptr,		/* Value to be compared */
      504 		  3 value_field_id	 fixed bin,	/* Field to be compared if not zero */
      505 		  3 mbz		 bit (18);	/* To fill out structure */
      506 	dcl     constraint_entry_ptr	 ptr;
      507 
      508 	dcl     1 constraint_list,			/* The list of constraint_entries */
      509 		2 number_of_constraints fixed bin,	/* How many in list */
      510 		2 head_of_list	 ptr;		/* The list */
      511 
      512           dcl     expression             bit (1);
      513 	dcl     k			 fixed bin;	/* Loop index */
      514 	dcl     last_cond_ptr	 ptr;		/* Last condition looked at that can't be in search spec */
      515 	dcl     pred_data_type	 fixed bin;	/* Constant, attribute value, or expression */
      516 	dcl     pred_desc		 bit (36) aligned;	/* Predicate data descriptor */
      517 	dcl     pred_ptr		 ptr;		/* Pointer to the node in the predicate
      518*						   tree that contains the operand */
      519 	dcl     pred_var_ind	 fixed bin;	/* Tuple variable id of predicate */
      520 	dcl     ss_possible		 bit (1);		/* True if condition can be passed to relation manager */
      521 
      522 	allocate select_info in (select_area);		/* set up select info */ /* select_area allocs never freed. It
      523*   is re-init at the start of each new S.E.. */
      524 	search_ops.op.info_ptr (si) = seli_ptr;
      525 	select_info.tuple_info_index = vind;
      526 	select_info.tid_ptr = addr (tuple_info.tuple.tuple_id (vind));
      527 	constraint_list.number_of_constraints = 0;
      528 	constraint_list.head_of_list = null ();
      529 	if elp ^= null then /* if have exprs */
      530 	     count = expr_list.nexprs;
      531 	else /* if no exprs */
      532 	     count = 0;
      533 	expression = "1"b;
      534 
      535 /*
      536**
      537**  Now we need to run through the list of condtions on attributes.  We are
      538**  going to create two structures.  A search specification to be passed
      539**  to relation manager, and a condition list for mrds to interpret at
      540**  tuple select time.  It is best to give things to relation manager so
      541**  we'll do this whenever we can.  A condition can be used by relmgr if it
      542**
      543**  1) Is not an expression to be evaluated after the tuple is retrieved
      544**  2) Does not compare attributes within the tuple to be retrieved
      545**  3) Compares the attribute to a constant with the same type descriptor
      546**
      547**  Otherwise mrds must do the comparison.  The following loop looks for
      548**  conditions which meet the above criteria.  If it finds one, it adds
      549**  an entry to the constraint list and removes it from the condition
      550**  list for the attribute.  Otherwise it merely increments the count of
      551**  the number of items in the mrds comparison list.
      552**
      553**/
      554 
      555 	do k = 1 to attr_list.nattr;
      556 	     last_cond_ptr = null ();
      557 	     do condp = attr_list.info.cond_ptr (k) repeat cond.fwd_thd
      558 		while (condp ^= null ());
      559 		attr_rai_ptr = rm_rel_info.attr_ptrs (attr_list.info.index (k));
      560 		attr_rdi_ptr = attr_rai_ptr -> rm_attr_info.domain_ptr;
      561 		attr_desc = attr_rdi_ptr -> rm_domain_info.db_desc;
      562 		pred_ptr = cond.pl_ptr;
      563 		pred_var_ind = fixed (pred_ptr -> pred_leaf.id.var_id);
      564 		pred_data_type = pred_ptr -> pred_leaf.data_type;
      565 		if pred_data_type = EXPRES		/* Compare to an expression? */
      566 		then ss_possible = "0"b;
      567 		else do;
      568 			if pred_data_type = CONST	/* Compare to constant? */
      569 			then pred_desc = pred_ptr -> pred_leaf.lit_desc_ptr -> bit36a;
      570 			else if pred_data_type = ATTR /* Compare to another attribute */
      571 			then pred_desc = pred_ptr -> pred_leaf.ai_ptr ->
      572 				rm_attr_info.domain_ptr -> rm_domain_info.db_desc;
      573 			else call sub_err_ (mrds_error_$internal_error,
      574 				MODULE_NAME, "s", null (), 0,
      575 				"A predicate was found which is neither a constant, attribute, or expression.");
      576 			ss_possible = (pred_desc = attr_desc)
      577 			     & (pred_var_ind ^= vind);
      578 		     end;
      579 		if ^ss_possible then do;
      580 			count = count + 1;
      581 			last_cond_ptr = condp;	/* The last condition looked at that can't be passed to relmgr */
      582 
      583 /*			range.tup_var (vind).needed_bits.attr (attr_rai_ptr -> rm_attr_info.defn_order) = "1"b; */
      584 		     end;
      585 		else do;
      586 
      587 /* Add the condition to the constraint list */
      588 
      589 			allocate constraint_entry in (select_area);
      590 			constraint_entry.constraint_info.field_id =
      591 			     attr_rai_ptr -> rm_attr_info.model_defn_order;
      592 			if cond.op_code = OTT_EQ
      593 			then constraint_entry.constraint_info.operator_code
      594 				= EQUAL_OPERATOR_CODE;
      595 			else if cond.op_code = OTT_NE
      596 			then constraint_entry.constraint_info.operator_code
      597 				= NOT_EQUAL_OPERATOR_CODE;
      598 			else if cond.op_code = OTT_LT
      599 			then constraint_entry.constraint_info.operator_code
      600 				= LESS_OPERATOR_CODE;
      601 			else if cond.op_code = OTT_LE
      602 			then constraint_entry.constraint_info.operator_code
      603 				= LESS_OR_EQUAL_OPERATOR_CODE;
      604 			else if cond.op_code = OTT_GT
      605 			then constraint_entry.constraint_info.operator_code
      606 				= GREATER_OPERATOR_CODE;
      607 			else if cond.op_code = OTT_GE
      608 			then constraint_entry.constraint_info.operator_code
      609 				= GREATER_OR_EQUAL_OPERATOR_CODE;
      610 			else call sub_err_ (mrds_error_$internal_error,
      611 				MODULE_NAME, "s", null (), 0,
      612 				"An unknown comparison operator was found in an attribute's condition list.");
      613 			if pred_data_type = CONST
      614 			then constraint_entry.constraint_info.value_ptr
      615 				= pred_ptr -> pred_leaf.lit_ptr;
      616 			else do;
      617 
      618 /*				range.tup_var (pred_var_ind).needed_bits.attr (fixed (pred_ptr -> pred_leaf.id.attr_id)) = "1"b; */
      619 				call extract_attr (pred_var_ind,
      620 				     pred_ptr -> pred_leaf.ai_ptr);
      621 				constraint_entry.constraint_info.value_ptr
      622 				     = move_info.t_ptr;
      623 			     end;
      624 			constraint_entry.value_field_id = 0;
      625 			constraint_entry.mbz = "0"b;
      626 			constraint_list.number_of_constraints
      627 			     = constraint_list.number_of_constraints + 1;
      628 			constraint_entry.next_entry =
      629 			     constraint_list.head_of_list;
      630 			constraint_list.head_of_list = constraint_entry_ptr;
      631 
      632 
      633 /* Now splice the condition out of the condition list for the attribute */
      634 
      635 			if last_cond_ptr = null ()	/* Delete head of list */
      636 			then attr_list.info (k).cond_ptr = cond.fwd_thd;
      637 			else last_cond_ptr -> cond.fwd_thd = cond.fwd_thd;
      638 		     end;
      639 	     end;
      640 	end;
      641 
      642 
      643 /* Now build the search specification */
      644 
      645 
      646 	rss_maximum_number_of_constraints = constraint_list.number_of_constraints;
      647 	if rss_maximum_number_of_constraints = 0
      648 	then rss_number_of_and_groups = 0;
      649 	else rss_number_of_and_groups = 1;
      650 	allocate relation_search_specification in (select_area);
      651 	relation_search_specification.head.version = SPECIFICATION_VERSION_4;
      652 	relation_search_specification.head.type = ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE;
      653 	relation_search_specification.head.pad = "0"b;
      654 	relation_search_specification.head.subset_specification_ptr = null ();
      655 	relation_search_specification.maximum_number_of_constraints =
      656 	     rss_maximum_number_of_constraints;
      657 	relation_search_specification.number_of_and_groups =
      658 	     rss_number_of_and_groups;
      659 	relation_search_specification.flags.return_unique_tuples = "0"b;
      660 	relation_search_specification.flags.mbz = "0"b;
      661 	relation_search_specification.range.type = LOW_RANGE_TYPE;
      662 	relation_search_specification.range.size = current_max_tids_per_call;
      663 	relation_search_specification.and_group (1).number_of_constraints =
      664 	     rss_maximum_number_of_constraints;
      665 	relation_search_specification.and_group (1).flags
      666 	     .collection_id_supplied = "1"b;
      667 	relation_search_specification.and_group (1).flags.mbz = "0"b;
      668 	relation_search_specification.and_group (1).search_collection_id =
      669 	     collection_index;
      670 	constraint_entry_ptr = constraint_list.head_of_list;
      671 
      672 
      673 /*
      674**
      675**   Now fill in the constraint list.  Note that if there is nothing in
      676**   the constraint list, the search spec generated will be for every
      677**   tuple in the relation.
      678**
      679**/
      680 
      681 	do k = 1 to constraint_list.number_of_constraints;
      682 	     relation_search_specification.and_group (1).constraint (k) =
      683 		constraint_entry.constraint_info, by name;
      684 	     constraint_entry_ptr = constraint_entry.next_entry;
      685 	end;
      686 	select_info.relation_search_specification_ptr = relation_search_specification_ptr;
      687 
      688 
      689 /* Now build the comparison array */
      690 
      691 	if count = 0 then
      692 	     select_info.cvla_ptr = null;		/* no conditions, select everything in range */
      693 	else do;					/* must build comp val array */
      694 
      695 		cvla_nlists_init = 1;		/* Will be greater if we allow ors */
      696 		allocate cvl_array in (select_area);	/* select_area allocs never freed. It
      697*						   is re-init at the start of each new S.E.. */
      698 		select_info.cvla_ptr = cvla_ptr;
      699 		cvl_nvals_init = count;		/* build comp val list */
      700 		call alloc_comp_val_list;
      701 		cvl_array.list_ptr (1) = cvl_ptr;
      702 		nv = 0;				/* init. val counter */
      703 		comp_val_list.rel_id = rm_rel_info.rel_id;
      704 
      705 		do k = 1 to attr_list.nattr;		/* find remaining conditions in attr list */
      706 
      707 		     if attr_list.info.cond_ptr (k) ^= null then do;
      708 			     do condp = attr_list.info.cond_ptr (k) repeat cond.fwd_thd while (condp ^= null);
      709 
      710 				rai_ptr = rm_rel_info.attr_ptrs (attr_list.info.index (k));
      711 				rdi_ptr = rm_attr_info.domain_ptr;
      712 
      713 				nv = nv + 1;	/* incr. val counter */
      714 				comp_val_list.val.attr_ind (nv) = attr_list.info.index (k);
      715 				comp_val_list.val.op (nv) = cond.op_code;
      716 				comp_val_list.val.exp_ptr (nv),
      717 				     comp_val_list.val.erslt_ptr (nv) = null;
      718 				comp_val_list.val.desc1 (nv) = rm_domain_info.db_desc;
      719 				pl_ptr = cond.pl_ptr; /* go process the operand */
      720 				comparison_var_id = fixed (pred_leaf.id.var_id);
      721 				compare_within_tuple = (comparison_var_id = vind);
      722 
      723 				call complete_comparison_item (pred_leaf.data_type, compare_within_tuple, ^expression);
      724 			     end;			/* loop through conditions */
      725 			end;			/* if attr referenced and not used */
      726 		end;				/* loop through attr list */
      727 
      728 		if elp ^= null then /* have expressions to look at */
      729 
      730 		     do k = 1 to expr_list.nexprs;
      731 
      732 			pl_ptr = expr_list.info.epl_ptr (k);
      733 			nv = nv + 1;
      734 			comp_val_list.val.op (nv) = expr_list.info.op_code (k);
      735 			comp_val_list.val.exp_ptr (nv) = pred_leaf.expr_ptr;
      736 			comp_val_list.val.erslt_ptr (nv) = pred_leaf.lit_ptr;
      737 			comp_val_list.val.desc1 (nv) = pred_leaf.rslt_desc;
      738 
      739 			pl_ptr = expr_list.info.pl_ptr (k); /* go process the comparand */
      740 			comparison_var_id = fixed (pred_leaf.id.var_id);
      741 			compare_within_tuple = (comparison_var_id = vind);
      742 			call complete_comparison_item (pred_leaf.data_type, compare_within_tuple, expression);
      743 		     end;				/* loop through exprs */
      744 	     end;					/* building comp val array */
      745 
      746      end build_select_op;
      747 
      748 complete_comparison_item: proc (data_type, compare_within_tuple, expr_caller_sw);
      749 	dcl     data_type		 fixed bin parm;	/* INPUT: 1 => constant
      750*						   2 => attribute
      751*						   3 => expression */
      752 	dcl     compare_within_tuple	 bit (1) parm;	/* INPUT: ON => both items to be compared
      753*						   depend on the same tuple. */
      754           dcl     expr_caller_sw          bit (1) parm;     /* INPUT: ON => called when evaluating exprsession */
      755 
      756 
      757 /*	if data_type = ATTR
      758*	then range.tup_var (fixed (pred_leaf.id.var_id)).needed_bits.attr (fixed (pred_leaf.id.attr_id)) = "1"b;
      759*	else if data_type = EXPR
      760*	then range.tup_var (fixed (pred_leaf.id.var_id)).whole_tuple_selected = "1"b;
      761**/
      762           comp_val_list.c_ai_ptr2(nv) = null;
      763 
      764 	if ^compare_within_tuple then do;
      765 		go to between_tuples (data_type);
      766 
      767 between_tuples (1): ;				/* constant */
      768 		comp_val_list.val.match_ptr (nv) =
      769 		     pred_leaf.lit_ptr;
      770 		comp_val_list.val.desc2 (nv) =
      771 		     pred_leaf.lit_desc_ptr -> bit36a;
      772 		go to end_between_tuples;
      773 
      774 between_tuples (2): ;				/* attr. in db. */
      775 		call extract_attr (fixed (pred_leaf.id.var_id), pred_leaf.ai_ptr);
      776 		comp_val_list.val.match_ptr (nv) =
      777 		     move_info.t_ptr;
      778 		rai_ptr = pred_leaf.ai_ptr;
      779 		rdi_ptr = rm_attr_info.domain_ptr;
      780 
      781 		comp_val_list.val.desc2 (nv) = rm_domain_info.db_desc;
      782 		comp_val_list.val.attr_ind2 (nv) = fixed (pred_leaf.id.attr_id);
      783 		go to end_between_tuples;
      784 
      785 between_tuples (3): ;				/* expressions */
      786 		call make_eval_expr_mi (pred_leaf.expr_ptr, (fixed (pred_leaf.id.var_id)),
      787 		     fixed (pred_leaf.id.var_id));
      788 		comp_val_list.val.match_ptr (nv) =
      789 		     pred_leaf.lit_ptr;
      790 		comp_val_list.val.desc2 (nv) = pred_leaf.lit_desc_ptr -> bit36a;
      791 		go to end_between_tuples;
      792 end_between_tuples: ;
      793 	     end;					/* between_tuples */
      794 	else do;					/* within_tuple */
      795 		go to within_tuple (data_type);
      796 within_tuple (1):	;				/* constant */
      797 						/* This case should not occur because a constant
      798*						   does not depend on values out of a tuple. */
      799 
      800 		go to between_tuples (1);
      801 
      802 within_tuple (2):	;				/* attr. in db. */
      803 		comp_val_list.val.attr_ind2 (nv) = fixed (pred_leaf.id.attr_id);
      804 		call prepare_attr_cvl (expr_caller_sw);
      805 		go to end_within_tuple;
      806 
      807 within_tuple (3):	;				/* expressions */
      808 		call prepare_expr_cvl;
      809 		go to end_within_tuple;
      810 end_within_tuple:	;
      811 	     end;					/* within_tuple */
      812 
      813      end complete_comparison_item;
      814 
      815 prepare_expr_cvl: proc;
      816 
      817 /* This routine sets up values in the comp_val_list
      818*   when the second item to be compared is an expression
      819*   and both values to be compared are from the same tuple. */
      820 	comp_val_list.val.desc2 (nv) = pred_leaf.lit_desc_ptr -> bit36a;
      821 	comp_val_list.val.exp_ptr2 (nv) = pred_leaf.expr_ptr;
      822 	comp_val_list.val.erslt_ptr2 (nv) = pred_leaf.lit_ptr;
      823      end prepare_expr_cvl;
      824 
      825 prepare_attr_cvl: proc (expr_sw);
      826 
      827 dcl expr_sw bit(1) parm; /* indicates that first attribute is an expression. That
      828*	             means this value must be decoded. */
      829 
      830 /* This routine sets up values in the comp_val_list
      831*   when the second item to be compared is a db attribute
      832*   and both values to be compared are from the same tuple. */
      833 	rai_ptr = pred_leaf.ai_ptr;
      834 	rdi_ptr = rm_attr_info.domain_ptr;
      835 	if expr_sw then do;  /* must decode to compare */
      836 	     comp_val_list.c_ai_ptr2 (nv) = pred_leaf.ai_ptr;
      837 	     comp_val_list.val.desc2 (nv) = rm_domain_info.user_desc;
      838 	end;
      839 	else /* can compare internally */
      840 	     comp_val_list.val.desc2 (nv) = rm_domain_info.db_desc;
      841 
      842      end prepare_attr_cvl;
      843 
      844 alloc_comp_val_list: proc;
      845 
      846 /* Allocate comp_val_list structure and peform a partial initialization. */
      847 	allocate comp_val_list in (select_area);	/* select_area allocs never freed. It
      848*						   is reinitialized for each new selection expression. */
      849 	unspec (comp_val_list.val) = "0"b;
      850 	do i = 1 to cvl_nvals_init;
      851 	     match_ptr,
      852 		comp_val_list.val (i).exp_ptr,
      853 		comp_val_list.val (i).exp_ptr2,
      854 		comp_val_list.val (i).erslt_ptr2,
      855 		comp_val_list.val (i).erslt_ptr = null ();
      856 	end;					/* loop thru comp_val_list.val */
      857 	dcl     i			 fixed bin;
      858      end alloc_comp_val_list;
      859 
      860 alloc_move_info: proc;
      861 
      862 /* Procedure to allocate and link in a move info structure */
      863 
      864 	allocate move_info in (select_area);		/* select_area allocs never freed. It
      865*						   is re-init at the start of each new S.E.. */
      866 	if cur_mi_ptr = null then /* if first */
      867 	     search_ops.op.info_ptr (mi) = mi_ptr;
      868 	else cur_mi_ptr -> move_info.fwd_thd = mi_ptr;
      869 	unspec (move_info) = "0"b;
      870 	move_info.fwd_thd = null;
      871 	move_info.s_ptr,
      872 	     move_info.t_ptr = null ();
      873 	cur_mi_ptr = mi_ptr;
      874 
      875      end alloc_move_info;
      876 
      877 extract_attr: proc (var_ind, raip);
      878 
      879 /* procedure to set up a move info to extract an attribute value from
      880*   a tuple and place it in the literal pool, stored in accordance with Multics
      881*   data type standards. */
      882 
      883 	dcl     raip		 ptr;
      884 	dcl     var_ind		 fixed bin;
      885 
      886 	rdi_ptr = raip -> rm_attr_info.domain_ptr;
      887 	call alloc_move_info;
      888 	call alloc_lit (addr (rm_domain_info.db_desc),
      889 	     move_info.t_ptr, move_info.tbit_len);
      890 	move_info.extr_attr = "1"b;
      891 	move_info.bit_move = ^(mu_data_class$varying (
      892 	     addr (raip -> rm_attr_info.domain_ptr -> rm_domain_info.db_desc)));
      893 	move_info.var_move = ^move_info.bit_move;
      894 	move_info.var_ind = var_ind;
      895 	move_info.sbit_len = raip -> rm_attr_info.bit_length;
      896 	move_info.s_desc = rm_domain_info.db_desc;
      897 	move_info.tuple_var_index = var_ind;
      898 	move_info.tuple_attr_index = raip -> rm_attr_info.defn_order;
      899      end extract_attr;
      900 
      901 make_eval_expr_mi: proc (ep, tp, vi);
      902 
      903 /* procedure to make a move_info to evaluate an expression */
      904 
      905 	dcl     ep		 ptr;
      906 	dcl     tp		 fixed bin;
      907 	dcl     vi		 fixed bin;
      908 
      909 	call alloc_move_info;
      910 	move_info.expr = "1"b;
      911 	move_info.s_ptr = ep;
      912 	move_info.tuple_var_index = tp;
      913 	move_info.var_ind = vi;
      914 
      915      end make_eval_expr_mi;
      916 
      917 alloc_lit: proc (ldp, lp, lbl);
      918 
      919 /* Procedure to allocate a literal in the literal pool */
      920 
      921 	dcl     lbl		 fixed bin (35);
      922 	dcl     (ldp, lp)		 ptr;
      923 
      924 	li.encd_proc = "0"b;
      925 	li.src_ptr,
      926 	     li.srcd_ptr,
      927 	     li.encdd_ptr = null;
      928 	li.litd_ptr = ldp;
      929 	li.encd_blen = 0;
      930 	call mrds_dsl_make_literal$alloc (dbcb_ptr, addr (li), icode);
      931 	if icode ^= 0 then call error (icode);
      932 	lbl = li.lit_blen;
      933 	lp = li.lit_ptr;
      934 
      935      end alloc_lit;
      936  build_vectors: proc;
      937 
      938 /* Here is where we build the 'shortened' simple_typed_vector for each tuple variable.
      939*   If the whole tuple has been selected, the 'whole' one in the resultant is used. */
      940 
      941 	do i = 1 to range.num_vars;
      942 	     bv_stv_ptr = tuple_info.tuple (i).tuple_ptr; /* simple_typed_veector for whole 'view' */
      943 	     bv_ri_ptr = range.tup_var (i).ri_ptr;	/* rm_rel_info ptr */
      944 	     bv_idl_ptr = bv_ri_ptr -> rm_rel_info.id_list_ptr; /* id_list for whole 'view' */
      945 	     if range.tup_var (i).whole_tuple_selected
      946 	     then do;				/* just grab what's already available */
      947 		     range.tup_var (i).stv_ptr = bv_stv_ptr;
      948 		     range.tup_var (i).idl_ptr = bv_idl_ptr;
      949 		end;
      950 	     else do;				/* Build a simple_typed_vector and an id_list */
      951 		     il_number_of_ids = bv_ri_ptr -> rm_rel_info.num_attr; /* Build it oversize */
      952 		     allocate id_list in (select_area) set (id_list_ptr);
      953 		     id_list.version = ID_LIST_VERSION_1;
      954 		     range.tup_var (i).idl_ptr = id_list_ptr;
      955 
      956 		     id_list.number_of_ids = 0;
      957 		     do k = 1 to il_number_of_ids;
      958 			if range.tup_var (i).needed_bits.attr (k)
      959 			then do;			/* get the proper id for relation */
      960 				id_list.number_of_ids = id_list.number_of_ids + 1;
      961 				id_list.id (id_list.number_of_ids) = bv_idl_ptr -> id_list.id (k);
      962 			     end;
      963 		     end;
      964 		     if id_list.number_of_ids ^= 0
      965 		     then do;
      966 			     stv_number_of_dimensions = id_list.number_of_ids;
      967 			     allocate simple_typed_vector in (select_area) set (simple_typed_vector_ptr);
      968 			     simple_typed_vector.type = SIMPLE_TYPED_VECTOR_TYPE;
      969 			     range.tup_var (i).stv_ptr = simple_typed_vector_ptr;
      970 
      971 			     stv_number_of_dimensions = 0; /* use for walking through the vector */
      972 			     do k = 1 to il_number_of_ids; /* walk the WHOLE relation */
      973 				if range.tup_var (i).needed_bits.attr (k)
      974 				then do;
      975 					stv_number_of_dimensions = stv_number_of_dimensions + 1;
      976 					simple_typed_vector.dimension (stv_number_of_dimensions).value_ptr =
      977 					     bv_stv_ptr -> simple_typed_vector.dimension (k).value_ptr;
      978 				     end;
      979 			     end;
      980 			end;			/* ids to move */
      981 		     else do;			/* no ids to move */
      982 			     range.tup_var (i).stv_ptr = null ();
      983 			end;
      984 		end;				/* build simple_typec_vector */
      985 	end;					/* walk through tuple vars */
      986 
      987 
      988 	dcl     bv_idl_ptr		 ptr;
      989 	dcl     bv_stv_ptr		 ptr;
      990 	dcl     bv_ri_ptr		 ptr;
      991 	dcl     i			 fixed bin;
      992 	dcl     k			 fixed bin;
      993 
      994      end build_vectors;
      995 
      996 error: proc (cd);
      997 
      998 /* Error Procedure */
      999 
     1000 	dcl     cd		 fixed bin (35);
     1001 
     1002 	code = cd;
     1003 	go to exit;
     1004 
     1005      end error;
     1006 
     1007 	dcl     path_var_ptr	 ptr parm;	/* Input: ptr to path through tuple variables */
     1008 	dcl     (xp,				/* work ptr */
     1009 	        pa_ptr,				/* to pvp_array */
     1010 	        cur_ii_ptr,				/* current pointers for alloc routines */
     1011 	        cur_mi_ptr,
     1012                   next_element_id_list_ptr,
     1013 	        aip_ptr)		 ptr;		/* to array of attr info ptrs */
     1014 
     1015 	dcl     (code,				/* Output:  status code */
     1016 	        icode)		 fixed bin (35);	/* internal status code */
     1017 
     1018 	dcl     (i, j,				/* internal indexes */
     1019 	        vind,				/* current var index */
     1020 	        ii, mi, si, rni, rvi,			/* indexes into search ops */
     1021 	        opr_ind,				/* index to indicate when to add inter op. */
     1022 	        count,				/* counter */
     1023 	        nv,
     1024 	        max_pv)		 fixed bin;	/* highest path var */
     1025 
     1026 
     1027 
     1028 	dcl     1 ed		 aligned,		/* encode descriptor */
     1029 		2 const		 bit (12) init ("101011000000"b) unal,
     1030 		2 len		 fixed bin (23) unal;
     1031 
     1032 	dcl     rotate_ops		 (6) fixed bin init (1, 2, 5, 6, 3, 4); /* used to rotate inequalities
     1033*						   rotate_ops(1) =>  = becomes  =
     1034*						   rotate_ops(2) => ^= becomes ^=
     1035*						   rotate_ops(3) =>  < becomes  >
     1036*						   rotate_ops(4) => <= becomes >=
     1037*						   rotate_ops(5) =>  > becomes  <
     1038*						   rotate_ops(6) => >= becomes <= */
     1039 	dcl     pvp_array		 (sv_nvars_init) ptr based (pa_ptr);
     1040 	dcl     1 li		 aligned like lit_info;
     1041 	dcl     1 current_scopes_flags aligned based (current_scope_ptr) like scope_flags;
     1042           dcl     current_scope_ptr      ptr;
     1043 
     1044 	dcl     (mrds_data_$max_attributes,
     1045 	        mrds_data_$max_id_len,
     1046 	        mrds_data_$max_safe_tids_returned_per_call,
     1047 	        mrds_data_$max_tids_returned_per_call,
     1048 	        mrds_data_$max_select_items) ext fixed bin (35);
     1049 
     1050 	dcl     (addr,
     1051                    addrel,
     1052 	        fixed,
     1053 	        null,
     1054 	        rel,
     1055 	        string,
     1056 	        unspec)		 builtin;
     1057 
     1058 	dcl     bit36a		 bit (36) aligned based;
     1059 	dcl     MODULE_NAME		 char (22) init ("mrds_dsl_gen_srch_prog");
     1060 	dcl     mrds_dsl_make_literal$alloc entry (ptr, ptr, fixed bin (35));
     1061 	dcl     mrds_error_$internal_error fixed bin (35) ext static;
     1062 	dcl     comparison_var_id	 fixed bin;	/* Index of tuple variable for second comparison value of zero. */
     1063 	dcl     compare_within_tuple	 bit (1);		/* 1 => both comparison values depend on the
     1064*						   same tuple. */
     1065 	dcl     collection_index	 bit (36) aligned;	/* index of the collection to be searched */
     1066 	dcl     mu_cursor_manager_$get entry (fixed bin (35), ptr, fixed bin (35), bit (36) aligned, entry, entry, ptr,
     1067 				 ptr, ptr, fixed bin (35));
     1068 	dcl     mu_data_class$varying	 entry (ptr) returns (bit (1) aligned);
     1069 	dcl     sub_err_		 entry () options (variable);
     1070 	dcl     sys_info$max_seg_size	 fixed bin (35) ext static;
     1071 	dcl     current_max_tids_per_call fixed bin (35);
     1072 
  1     1 /* BEGIN mdbm_scope_info.incl.pl1 -- odf 8/8/78 */
  1     2 
  1     3 /* WARNING
  1     4*          If the scope_info or scope_flags structure is changed then the
  1     5*          mrds_data_ item saved_res_version MUST be incremented to invalidate
  1     6*          all existing saved resultants
  1     7**/
  1     8 
  1     9 /* Modified by Jim Gray - - 80-11-17, to add back store/delete/modify permissions */
  1    10 
  1    11 /* 80-12-10 Jim Gray : change name of store to append_tuple, delete to delete_tuple,
  1    12*   modify to modify_attr, retrieve to read_attr, remvoe update, put level 4
  1    13*   qualifiers for permit/prevent modes and to put pads in standard format */
  1    14 
  1    15 /* 80-12-11 Jim Gray : added submodel version of file/rel name for convenience */
  1    16 
  1    17 /* 80-12-22 Jim Gray : added like referenced structure so linus_scope_data.incl
  1    18*   could make use of it for compatibility. */
  1    19 
  1    20 /* 81-1-11 Jim Gray : added touched bit to scope_flags, so that
  1    21*   the fact that null scope has been set can be displayed */
  1    22 
  1    23 /* 85-04-14 Thanh Nguyen: Made scope_flags to be aligned so we could access the
  1    24*   prevent flags from any pointer which directly pointed to scope_flags itself
  1    25*   (i.e rm_rel_info.scope_flags_ptr). */
  1    26 
  1    27 /* this structure is to be allocated in the mrds_dbcb.incl.pl1 static area,
  1    28*   and is used to maintain the scope mechanism for file access.
  1    29*   It contains the scope permit/prevent operations that this user
  1    30*   has set in his view for this opening instance. */
  1    31 
  1    32 dcl 1 scope_info aligned based (scope_ptr),		/* array of scope tuples for this user */
  1    33     2 mbz1 bit (144),				/* Reserved for future use */
  1    34     2 nfiles fixed bin,				/* Number of scope tuples in user's scope */
  1    35     2 active_scopes fixed bin,			/* number of scopes currently active for a given user */
  1    36     2 scope (max_file_init refer (scope_info.nfiles)),	/* defines user's scope of access to files */
  1    37       3 name char (30) aligned,			/* filename */
  1    38       3 sm_name char (32),				/* name of file(rel) in submodel */
  1    39       3 flags like scope_flags ;
  1    40 
  1    41 
  1    42 declare 1 scope_flags aligned based,			/* common layout of scope flag bits */
  1    43         2 permits,					/* modes to permit this user */
  1    44 	3 read_attr bit (1) unal,			/* read_attr access to this file in scope */
  1    45 	3 append_tuple bit (1) unal,			/* append_tuple concnrrency permission */
  1    46 	3 delete_tuple bit (1) unal,			/* delete_tuple concurrency permission on rel */
  1    47 	3 modify_attr bit (1) unal,			/* modify_attr concurrency permission */
  1    48 	3 mbz2 bit (10) unal,			/* for expansion of permit ops */
  1    49         2 prevents,					/* modes to be denyed to other users */
  1    50 	3 read_attr bit (1) unal,			/* on if user has prevent on read_attr for this file */
  1    51 	3 append_tuple bit (1) unal,			/* prevent of append_tuple concurrency */
  1    52 	3 delete_tuple bit (1) unal,			/* prevent of delete_tuple concurrency */
  1    53 	3 modify_attr bit (1) unal,			/* prevent of modify_attr concurrency */
  1    54 	3 mbz3 bit (10) unal,			/* for future prevent concurrency modes */
  1    55         2 touched bit (1) unal,			/* on => scope set for this relation */
  1    56         2 mbz4 bit (7) unal ;				/* for future flags */
  1    57 
  1    58 dcl  max_file_init fixed bin;				/* nbr. of files in data base */
  1    59 dcl  scope_ptr ptr init (null ());			/* points to scope_info array */
  1    60 dcl  scope_rdy bit (6) unal init ("000011"b) int static options (constant); /* scope file ready modes (5 or 6) */
  1    61 dcl  scope_rdy_array (6) bit (1) unal based;		/* array format of scope_rdy string */
  1    62 
  1    63 /* END mdbm_scope_info.incl.pl1 */
     1073 
     1074 
  2     1 /* BEGIN INCLUDE FILE  - dm_element_id_list.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*          The element_id_list structure contains an array of element 
  2     5*     identifiers.  These identifiers are used as tuple, record or 
  2     6*     element identifiers.  This structure is used across the relation_manager_,
  2     7*     record_manager_ and index_manager_ interfaces.  At some time the 
  2     8*     version should be changed to be char(8)aligned, when such a conversion
  2     9*     can be coordinated with the other structures used at these interfaces.
  2    10**/
  2    11 
  2    12 /* HISTORY:
  2    13*Written by Matthew Pierret, 06/06/82.
  2    14*Modified:
  2    15*12/16/82 by Roger Lackey:  Changed number_of_elements to fixed bin (35).
  2    16*            Did not change version.
  2    17*02/11/85 by Matthew Pierret:  Added DESCRIPTION, Written by.
  2    18**/
  2    19 
  2    20 /* format: style2,ind3 */
  2    21      dcl	   1 element_id_list      aligned based (element_id_list_ptr),
  2    22 	     2 version	      fixed bin (35),
  2    23 	     2 number_of_elements fixed bin (35),
  2    24 	     2 id		      (eil_number_of_elements refer (element_id_list.number_of_elements)) bit (36) aligned;
  2    25 
  2    26      dcl	   element_id_list_ptr    ptr;
  2    27      dcl	   eil_number_of_elements fixed bin (35);
  2    28      dcl	   ELEMENT_ID_LIST_VERSION_1
  2    29 			      init (1) fixed bin (35);
  2    30 
  2    31 
  2    32 /* END INCLUDE FILE  - dm_element_id_list.incl.pl1 */
     1075 
     1076 
  3     1 /* BEGIN INCLUDE FILE - dm_operator_constants.incl.pl1 */
  3     2 
  3     3 /* Written by Lindsey Spratt, 07/07/82
  3     4*Modified:
  3     5*10/07/82 by Lindsey Spratt:  Added the GREATER, LESS, GREATER_OR_EQUAL,
  3     6*	  LESS_OR_EQUAL and REGULAR_EXPRESSION operator codes.  Also, added
  3     7*	  bit(1) arrays for determining if a given operator code "uses" a
  3     8*	  given operator.  For example, USES_LESS_OPERATOR(x) = "1"b only if
  3     9*	  x = LESS_OPERATOR_CODE or x = LESS_OR_EQUAL_OPERATOR_CODE.
  3    10**/
  3    11 
  3    12 /* format: style2,ind3 */
  3    13      dcl	   (
  3    14 	   EQUAL_OPERATOR_CODE    init (1),
  3    15 	   GREATER_OPERATOR_CODE  init (2),
  3    16 	   LESS_OPERATOR_CODE     init (7),
  3    17 	   REGULAR_EXPRESSION_OPERATOR_CODE
  3    18 			      init (8),
  3    19 	   NOT_EQUAL_OPERATOR_CODE
  3    20 			      init (5),
  3    21 	   GREATER_OR_EQUAL_OPERATOR_CODE
  3    22 			      init (3),
  3    23 	   LESS_OR_EQUAL_OPERATOR_CODE
  3    24 			      init (6),
  3    25 	   EQUAL_IDX	      init (18),
  3    26 	   GREATER_IDX	      init (17),
  3    27 	   NOT_IDX	      init (16),
  3    28 	   REGULAR_EXPRESSION_IDX init (15)
  3    29 	   )		      fixed bin internal static options (constant);
  3    30 
  3    31      dcl	   (
  3    32 	   USES_LESS_OPERATOR     init ("0"b, (5) (1)"0"b, "1"b /* <= */, "1"b /* < */, (24) (1)"0"b),
  3    33 	   USES_GREATER_OPERATOR  init ("0"b, "0"b, "1"b /* > */, "1"b /* >= */, (28) (1)"0"b),
  3    34 	   USES_EQUAL_OPERATOR    init ("0"b, "1"b /* = */, "0"b, "1"b /* >= */, "0"b, "0"b, "1"b /* <= */,
  3    35 			      (25) (1)"0"b),
  3    36 	   USES_REGULAR_EXPRESSION_OPERATOR
  3    37 			      init ("0"b, (7) (1)"0"b, "1"b /* reg exp */, (3) (1)"0"b, "1"b /* not reg exp */,
  3    38 			      (19) (1)"0"b)
  3    39 	   )		      dimension (0:31) bit (1) unaligned internal static options (constant);
  3    40 
  3    41 /* END INCLUDE FILE - dm_operator_constants.incl.pl1 */
     1077 
     1078 
  4     1 /* BEGIN INCLUDE FILE dm_range_constants.incl.pl1. */
  4     2 
  4     3 /* HISTORY:
  4     4*Written by Matthew Pierret, 05/27/83.
  4     5*Modified:
  4     6**/
  4     7 
  4     8      dcl	   (
  4     9 	   ALL_RANGE_TYPE	      init (1),
  4    10 	   LOW_RANGE_TYPE	      init (2),
  4    11 	   HIGH_RANGE_TYPE	      init (3)
  4    12 	   )		      fixed bin internal static options (constant);
  4    13 
  4    14 
  4    15 /* END INCLUDE FILE dm_range_constants.incl.pl1. */
     1079 
     1080 
  5     1 /* BEGIN INCLUDE FILE dm_relation_spec.incl.pl1 */
  5     2 
  5     3 /* HISTORY:
  5     4*Written by Matthew Pierret, 05/10/83.
  5     5*Modified:
  5     6**/
  5     7 
  5     8 /* format: style2,ind3 */
  5     9      dcl	   1 relation_search_specification
  5    10 			      aligned based (relation_search_specification_ptr),
  5    11 	     2 head	      like specification_head,
  5    12 	     2 maximum_number_of_constraints
  5    13 			      fixed bin (17) unal,
  5    14 	     2 number_of_and_groups
  5    15 			      fixed bin (17) unal,
  5    16 	     2 flags	      unal,
  5    17 	       3 return_unique_tuples
  5    18 			      bit (1) unal,
  5    19 	       3 mbz	      bit (35) unal,
  5    20 	     2 range,
  5    21 	       3 type	      fixed bin (17),
  5    22 	       3 size	      fixed bin (17),
  5    23 	     2 and_group	      (rss_number_of_and_groups refer (relation_search_specification.number_of_and_groups)),
  5    24 	       3 search_collection_id
  5    25 			      bit (36) aligned,
  5    26 	       3 flags	      unal,
  5    27 	         4 collection_id_supplied
  5    28 			      bit (1) unal,
  5    29 	         4 mbz	      bit (17) unal,
  5    30 	       3 number_of_constraints
  5    31 			      fixed bin (17) unal,
  5    32 	       3 constraint	      (rss_maximum_number_of_constraints
  5    33 			      refer (relation_search_specification.maximum_number_of_constraints)),
  5    34 	         4 field_id	      fixed bin (17) unal,
  5    35 	         4 operator_code  fixed bin (17) unal,
  5    36 	         4 value_field_id fixed bin (17) unal,
  5    37 	         4 mbz	      bit (18) unal,
  5    38 	         4 value_ptr      ptr;
  5    39 
  5    40 
  5    41      dcl	   1 relation_numeric_specification
  5    42 			      aligned based (relation_numeric_specification_ptr),
  5    43 	     2 head	      like specification_head,
  5    44 	     2 collection_id      bit (36) aligned,
  5    45 	     2 range_size	      fixed bin (35),
  5    46 	     2 position_number    fixed bin (17) unal,
  5    47 	     2 pad	      bit (18) unal;
  5    48 
  5    49 
  5    50      dcl	   (relation_search_specification_ptr, relation_numeric_specification_ptr)
  5    51 			      ptr init (null);
  5    52      dcl	   (rss_number_of_and_groups, rss_maximum_number_of_constraints)
  5    53 			      fixed bin (17) init (0);
  5    54 
  5    55 
  5    56 
  5    57 /* END INCLUDE FILE dm_relation_spec.incl.pl1 */
     1081 
     1082 
  6     1 /* BEGIN INCLUDE FILE dm_specification_head.incl.pl1 */
  6     2 
  6     3 /* HISTORY:
  6     4*Written by Matthew Pierret, 05/11/83. (Extracted from dm_specification.incl.pl1)
  6     5*Modified:
  6     6*05/20/83 by Matthew Pierret: Changed to use version 4.
  6     7**/
  6     8 
  6     9 /* format: style2,ind3 */
  6    10      dcl	   1 specification_head   based (specification_head_ptr),
  6    11 	     2 version	      fixed bin (35),
  6    12 	     2 type	      fixed bin (17) unal,
  6    13 	     2 pad	      bit (18) unal,
  6    14 	     2 subset_specification_ptr
  6    15 			      ptr;
  6    16 
  6    17 
  6    18      dcl	   specification_head_ptr ptr;
  6    19      dcl	   SPECIFICATION_VERSION_4
  6    20 			      init (4) fixed bin (35) internal static options (constant);
  6    21 
  6    22      dcl	   (
  6    23 	   SEARCH_SPECIFICATION_TYPE
  6    24 			      init (1),
  6    25 	   ABSOLUTE_SEARCH_SPECIFICATION_TYPE
  6    26 			      init (1),
  6    27 	   NUMERIC_SPECIFICATION_TYPE
  6    28 			      init (2),
  6    29 	   ABSOLUTE_NUMERIC_SPECIFICATION_TYPE
  6    30 			      init (2),
  6    31 	   RELATIVE_SEARCH_SPECIFICATION_TYPE
  6    32 			      init (3),
  6    33 	   RELATIVE_NUMERIC_SPECIFICATION_TYPE
  6    34 			      init (4),
  6    35 	   ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
  6    36 			      init (5),
  6    37 	   RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
  6    38 			      init (6),
  6    39 	   ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
  6    40 			      init (7),
  6    41 	   RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
  6    42 			      init (8)
  6    43 	   )		      fixed bin (17) internal static options (constant);
  6    44 
  6    45 
  6    46 /* END INCLUDE FILE dm_specification_head.incl.pl1 */
     1083 
     1084 
  7     1 /* ***********************************************************
  7     2*   *                                                         *
  7     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
  7     4*   *                                                         *
  7     5*   *********************************************************** */
  7     6 /* BEGIN INCLUDE FILE - vu_typed_vector.incl.pl1 */
  7     7 
  7     8 /* Written by Lindsey Spratt, 04/02/82.
  7     9*Modified:
  7    10*09/01/82 by Lindsey Spratt:  Changed value_ptr in simple_typed_vector to be
  7    11*	  unaligned.  Changed the type number of the simple_typed_vector to
  7    12*	  "3" from "1".  The OLD_SIMPLE_TYPED_VECTOR_TYPE is now an invalid
  7    13*	  type.
  7    14**/
  7    15 
  7    16 /* format: style2,ind3 */
  7    17      dcl	   1 simple_typed_vector  based (simple_typed_vector_ptr),
  7    18 	     2 type	      fixed bin (17) unal,
  7    19 	     2 number_of_dimensions
  7    20 			      fixed bin (17) unal,
  7    21 	     2 dimension	      (stv_number_of_dimensions refer (simple_typed_vector.number_of_dimensions)),
  7    22 	       3 value_ptr	      ptr unaligned;
  7    23 
  7    24      dcl	   1 general_typed_vector based (general_typed_vector_ptr),
  7    25 	     2 type	      fixed bin (17) unal,
  7    26 	     2 number_of_dimensions
  7    27 			      fixed bin (17) unal,
  7    28 	     2 dimension	      (gtv_number_of_dimensions refer (general_typed_vector.number_of_dimensions)),
  7    29 	       3 identifier	      fixed bin (17) unal,
  7    30 	       3 pad	      bit (18) unal,
  7    31 	       3 value_ptr	      ptr unal;
  7    32 
  7    33      dcl	   simple_typed_vector_ptr
  7    34 			      ptr;
  7    35      dcl	   stv_number_of_dimensions
  7    36 			      fixed bin (17);
  7    37 
  7    38      dcl	   general_typed_vector_ptr
  7    39 			      ptr;
  7    40      dcl	   gtv_number_of_dimensions
  7    41 			      fixed bin (17);
  7    42 
  7    43      dcl	   (
  7    44 	   OLD_SIMPLE_TYPED_VECTOR_TYPE
  7    45 			      init (1),		/* value_ptr was aligned. */
  7    46 	   GENERAL_TYPED_VECTOR_TYPE
  7    47 			      init (2),
  7    48 	   SIMPLE_TYPED_VECTOR_TYPE
  7    49 			      init (3)
  7    50 	   )		      fixed bin (17) internal static options (constant);
  7    51 
  7    52 /* END INCLUDE FILE - vu_typed_vector.incl.pl1 */
     1085 
     1086 
  8     1 /* BEGIN INCLUDE FILE - dm_id_list.incl.pl1 */
  8     2 
  8     3 /* DESCRIPTION
  8     4*        The id_list structure is used to identify attributes, fields and
  8     5*   dimensions by various modules of the Data Management System.
  8     6**/
  8     7 
  8     8 /* HISTORY:
  8     9*Written by Matthew Pierret, '82.
  8    10*Modified:
  8    11*08/17/83 by Matthew Pierret: Made version constant 'internal static options
  8    12*            (constant)' and to initialize automatic variables.
  8    13**/
  8    14 
  8    15 /* format: style2,ind3 */
  8    16      dcl	   1 id_list	      aligned based (id_list_ptr),
  8    17 	     2 version	      fixed bin (35),
  8    18 	     2 number_of_ids      fixed bin (17),
  8    19 	     2 id		      (il_number_of_ids refer (id_list.number_of_ids)) fixed bin (17);
  8    20 
  8    21      dcl	   id_list_ptr	      ptr init (null);
  8    22      dcl	   il_number_of_ids	      fixed bin (17) init (-1);
  8    23      dcl	   ID_LIST_VERSION_1      fixed bin (17) init (1) internal static options (constant);
  8    24 
  8    25 /* END INCLUDE FILE - dm_id_list.incl.pl1 */
     1087 
     1088 
  9     1 /* BEGIN mrds_dbcb.incl.pl1 -- jaw, 11/7/78 */
  9     2 
  9     3 
  9     4 
  9     5 /****^  HISTORY COMMENTS:
  9     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  9     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  9     8*     This entry is being made to cover the change made on 85-07-01 by Thanh
  9     9*     Nguyen. The scopes_changed flag was added to make checking for this
  9    10*     more efficient (mrds error list #137).
  9    11*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
  9    12*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
  9    13*     Add a bit called dont_check_txn_id to indicate whether or not we should
  9    14*     care if multiple txns use the same selection_expression. (mrds #156)
  9    15*  3) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  9    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  9    17*     Added parser_work_area_ptr and mrds_se_info_ptr for new parser.
  9    18*                                                   END HISTORY COMMENTS */
  9    19 
  9    20 
  9    21 /* WARNING
  9    22*          If the dbcb structure is changed then the mrds_data_
  9    23*          item saved_res_version MUST be incremented to invalidate all
  9    24*          existing saved resultants
  9    25**/
  9    26 
  9    27 /* HISTORY :
  9    28*
  9    29*   modified by Jim Gray - - 80-10-24, to add new_select_expr bit for
  9    30*   tid_list management
  9    31*
  9    32*   81-1-9 Jim Gray : added like reference for  ease  in  making  the
  9    33*   phony resultant in mu_database_index, without having the area dcl
  9    34*   included.
  9    35*
  9    36*   81-06-17 Roger Lackey :  added  last_store_rel_name  for  use  by
  9    37*   mrds_dsl_store
  9    38*
  9    39*   81-06-26 Roger Lackey : Added no_optimize and  print_search_order
  9    40*   switches
  9    41*
  9    42*   81-07-06 Jim Gray : added identifier for  the  current  selection
  9    43*   expression,  so  that relation statistics can be updated relative
  9    44*   to number of selection expressions seem. Also  removed  init  for
  9    45*   last_store_rel_name,   as   this   iw   now   properly   done  in
  9    46*   mrds_dsl_init_res.
  9    47*
  9    48*   81-07-17  Roger Lackey : added pred_ptr and unused_ptrs.
  9    49*
  9    50*   82-08-19  Mike Kubicar : added store_vector field.  This is needed
  9    51*   for the conversion to the relation manager.
  9    52*
  9    53*   82-08-23 Davids: added the relmgr_entries and access_costs
  9    54*   substructures so that the entries and costs can change
  9    55*   depending on the type of database that is opened.
  9    56*
  9    57*   82-09-09 Mike Kubicar : added modify_vector field.  This is needed
  9    58*   since modify uses a different vector type (general) than does store.
  9    59*
  9    60*   82-09-20 Davids: changed names of (store modify)_vector to
  9    61*   (store modify)_vector_ptr. Also (delete modify)_tuple_by_id to
  9    62*   (delete modify)_tuples_by_id. added the element cursor_storage_ptr
  9    63*   which should be inited to null and will be set by mu_cursor_manager_$get
  9    64*   during the first call.
  9    65*
  9    66*   82-09-21 Davids: renamed cursor_storage_ptr to cursor_ptrs_storage_ptr
  9    67*   since it deals with the pointers to the cursors and not the cursors
  9    68*   themelves and added the element cursor_storage_area_ptr which points
  9    69*   to the area where the cursors are kept.
  9    70*
  9    71*   82-09-22 Davids: renamed the transact_ctl_seg to transactions_needed.
  9    72*   the transact_ctl_seg always had a value of 0 and really didn't mean
  9    73*   anything.
  9    74*
  9    75*   82-09-22 Mike Kubicar : added create_relation, create_index and
  9    76*   destroy_relation_by_opening to relmgr_entries.  They are needed
  9    77*   by mrds_dsl_define_temp_rel.
  9    78*
  9    79*   82-09-24 Donna Woodka : added  put_tuple to  relmgr_entries. It
  9    80*   is needed by mu_store.
  9    81*
  9    82*   82-11-12 Davids: changed the declaration of the access_costs from fixed
  9    83*   bin to float bin since the values are not integers.
  9    84*
  9    85*   83-02-02 Davids: added the dbc_uid element. This will allow mrds to make
  9    86*   sure that the dbc_ptr still points to the correct segment. Element was 
  9    87*   added to the end of the structure to allow modules that don't use
  9    88*   the element to continue to reference the dbcb structure without recompiling.
  9    89*
  9    90*   83-02-25 Davids: added the concurrency_on and rollback_on elements. These
  9    91*   are needed so that temp rels can be created with the same file attributes
  9    92*   as the permanent relations.
  9    93*
  9    94*   83-05-02 Mike Kubicar : Deleted get_next_search_specification_ptr and
  9    95*   added the resultant_in_pdir bit.
  9    96*
  9    97*   83-05-18 Davids: reduced the number of reserved bits to 14 (from 15) and
  9    98*   added the res_already_made element.
  9    99*
  9   100*   83-05-24 Mike Kubicar : Updated the relation manager calling sequences.
  9   101*
  9   102*   83-08-03 Mike Kubicar : Added the element_id_list_segment_ptr and removed
  9   103*   one of the unused pointers.
  9   104*
  9   105*   83-09-20 Ron Harvey: Added relmgr_entries.get_population.
  9   106*
  9   107*   84-08-27 John Hergert:  Created compiled_se_info_ptr from unused_ptrs(2)
  9   108*   leaving unused_ptrs(1).
  9   109*
  9   110*   85-01-15 Thanh Nguyen:  Added the work_area_ptr and removed the last
  9   111*   unused_ptrs (1).
  9   112*
  9   113*   85-04-12 Thanh Nguyen:  Added user_started_transaction and 
  9   114*   non_shared_to_shared flags.  Also added se_transaction_id and some more
  9   115*   spare ptrs, entries and reserved storages for future enhancement, since
  9   116*   we changed the saved_res_version from rslt0001 to rslt0002.
  9   117*
  9   118*   85-07-01 Thanh Nguyen:  Added scopes_changed flag.  This flag is set by
  9   119*   common routine of mrds_dsl_set_scope, reset by mrds_dsl_optimize and 
  9   120*   mrds_dsl_gen_srch_prog when building of a new search_vars.
  9   121**/
  9   122 
  9   123 
  9   124 /* this structure is based on the {unique_name}.mrds.dbcb segment
  9   125*   that constitutes the non-secure portion of the resultant model that is
  9   126*   created during the opening of a database. it contains variables that
  9   127*   are used during the runtime access of the database, and an area
  9   128*   for evaluation of requests. it points to four other
  9   129*   segments in the resultant model, {unique_name}.mrds.rdbi, the secure
  9   130*   portion of the resultant(see mdbm_rm_db_info.incl.pl1),
  9   131*   {unique_name}.mrds.select, an area for selection expression evaluation,
  9   132*   {unique_name}.mrds.curdat, and {unique_name}.mrds.stadat, two segments
  9   133*   used in the elimination of duplicate tuples during a retrieve.
  9   134*   the dbcb area holds the structure in mdbm_scope_info.incl.pl1
  9   135*   that is used when the database is using the file scope mechanism
  9   136*   for concurrency control over file readying. the segment overlayed via
  9   137*   mrds_dbc.incl.pl1 structure is pointed to and also handles concurrency control,
  9   138*   across database openings. the pointer to this dbcb structure is kept in a table
  9   139*   which associates database indexes(returned from a call to dsl_$open), with particular
  9   140*   opening instances of resultant models. (see mu_database_index routine) */
  9   141 
  9   142      dcl	   1 dbcb		      aligned based (dbcb_ptr), /* DBCB -- non-secure portion */
  9   143 	     2 data	      like dbcb_data,
  9   144 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (dbcb.static_area))));
  9   145 
  9   146      dcl	   dbcb_ptr	      ptr;
  9   147 
  9   148      declare 1 dbcb_data	      based,		/* info part of dbcb, separated out so that
  9   149*						   like references can avoid getting the area declaration */
  9   150 	     2 rdbi_ptr	      ptr,		/* pointer to write protected mdbm_util_ info. */
  9   151 	     2 range_ptr	      ptr,		/*  ptr to range structure, or null */
  9   152 	     2 select_ptr	      ptr,		/* ptr to select list, or null */
  9   153 	     2 sv_ptr	      ptr,		/* pointer to search variables */
  9   154 	     2 so_ptr	      ptr,		/* pointer to search operators */
  9   155 	     2 ti_ptr	      ptr,		/* pointer to tuple info */
  9   156 	     2 lit_ptr	      ptr,		/* pointer to the literal area, or null */
  9   157 	     2 current_ptr	      ptr,		/* ptr to select list resulting from -current clause */
  9   158 	     2 ss_ptr	      ptr,		/* ptr to select sets block if not simple s.e. */
  9   159 	     2 retr_info_ptr      ptr,		/* ptr to retrieve info area */
  9   160 	     2 trel_info_ptr      ptr,		/* ptr to retrieve info area */
  9   161 	     2 sti_ptr	      ptr,		/* pointer to store info */
  9   162 	     2 dbc_ptr	      ptr,		/*  pointer to the data base control segment */
  9   163 	     2 sfi_ptr	      ptr,		/* points to head of scalar function list */
  9   164 	     2 scope_ptr	      ptr,		/* points to array of scope tuples */
  9   165 	     2 select_area_ptr    ptr,		/* ptr to area for current selection expression allocations */
  9   166 	     2 current_data_ptr   ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  9   167*						   for eliminating duplicate tuples. */
  9   168 	     2 static_data_ptr    ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  9   169*						   for eliminating duplicate tuples. */
  9   170 	     2 store_area_ptr     ptr,		/* temp storage area for dsl_$store */
  9   171 	     2 retrieve_area_ptr  ptr,		/* temp storage for dsl_$retrieve */
  9   172 	     2 modify_area_ptr    ptr,		/* temp storage area for dsl_$modify */
  9   173 	     2 delete_area_ptr    ptr,		/* temp storage area for dsl_$delete */
  9   174 	     2 def_temp_rel_area_ptr ptr,		/* temp storage area for dsl_$define_temp_rel */
  9   175 	     2 pred_ptr	      ptr,		/* Pointer to pred_array */
  9   176 	     2 store_vector_ptr   ptr,		/* Vector structure used during store operations */
  9   177 	     2 modify_vector_ptr  ptr,		/* Used during modifies */
  9   178 	     2 element_id_list_segment_ptr ptr,		/* Points to the segment used to hold element_id_list structures */
  9   179                2 compiled_se_info_ptr ptr,                  /* points to the segment containing all info on compiled sexs */
  9   180 	     2 work_area_ptr        ptr,		/* Work area for encode/decode value allocations in mu_retrieve */
  9   181 	     2 se_info_ptr          ptr,                  /* Points to se_info struct. Primarily for error reports */
  9   182 	     2 parser_work_area_ptr ptr,		/*  work area for parser */
  9   183 	     2 reserved_ptrs      (4) ptr,		/* Reserved for future use */
  9   184 	     2 another_flag	      bit (1) unal,		/* on if predicate was -another */
  9   185 	     2 current_flag	      bit (1) unal,		/* on if predicate was -current clause */
  9   186 	     2 dbc_incr	      bit (1) unal,		/* on if dbc open mode has been incremented for this user */
  9   187 	     2 delete_flag	      bit (1) unal,		/* On if search was called from mrds_dsl_sec_delete */
  9   188 	     2 dup_retain	      bit (1) unaligned,	/* On if dup tuples allowed for retrieval */
  9   189 	     2 prev_select	      bit (1) unal,		/* on if prev. select block processed in this s.e. */
  9   190 	     2 possible_op	      bit (1) unal,		/* on of arith op. allowed */
  9   191 	     2 sel_clause	      bit (1) unal,		/* on if currently in select clause */
  9   192 	     2 dsm_sw	      bit (1) unal,		/* on if data base was opened via data submodel */
  9   193 	     2 val_rtrv	      bit (1) unal,		/* if s.e. valid for retrieve */
  9   194 	     2 val_mod	      bit (1) unal,		/* for modify */
  9   195 	     2 val_del	      bit (1) unal,		/* for delete */
  9   196 	     2 val_dtr	      bit (1) unal,		/* for define temp rel */
  9   197 	     2 transactions_needed bit (1) unal,	/* On => transaction must be started or in progress does
  9   198*                                                                     not imply that the database is of type page_file */
  9   199 	     2 open_mode	      bit (3) unal,		/* 0=>unknown, 1=>r, 2=>u, 3=>er, 4=>eu, >4=>bad */
  9   200 	     2 new_select_expr    bit (1) unal,		/* on => starting a new tid list management period */
  9   201 	     2 no_optimize	      bit (1) unal,		/* On => no optimize */
  9   202 	     2 print_search_order bit (1) unal,		/*  On => print the search order */
  9   203 	     2 resultant_in_pdir  bit (1) unal,		/* On => Temp segments are in the process dir */
  9   204 	     2 res_already_made   bit (1) unal,           /* On => resultant has been made based on a saved copy */
  9   205 	     2 user_started_transaction bit (1) unal,     /* On => user already started his own transaction. */
  9   206 	     2 non_shared_to_shared bit (1) unal,         /* On => user changed the scope from non shared to shared
  9   207*						   inside a sequence of -another selection expression. */
  9   208 	     2 scopes_changed     bit (1) unal,           /* On => scopes had been changed by set_scopes or delete_scopes */
  9   209 	     2 dont_check_txn_id  bit (1) unal,           /* On => cpmd needs same selection exp across multiple txns */
  9   210 	     2 reserved	      bit (10) unal,	/* reserved for future use */
  9   211 	     2 nseq_sch	      fixed bin (35),	/* no. tuples located via sequential search */
  9   212 	     2 nind_sch	      fixed bin (35),	/* no. tuples located via index search */
  9   213 	     2 nhash_sch	      fixed bin (35),	/* no. tuples located via hash search */
  9   214 	     2 nlk_sch	      fixed bin (35),	/* no tuples located via link search */
  9   215 	     2 cur_lit_offset     fixed bin (35),	/* current bit offset in literal string */
  9   216 	     2 dbi	      fixed bin (35),	/* database index for this opening */
  9   217 	     2 last_s_e_id_num    fixed bin (35),	/* identifying number for last selection expression seen */
  9   218 	     2 se_transaction_id  bit (36) aligned,       /* transaction id from beginning of select expression */
  9   219 	     2 last_store_rel_name char (32),		/* Name of relation last used  for store */
  9   220 	     2 cursor_ptrs_storage_ptr ptr,		/* pointer to space where cursor ptrs are stored */
  9   221 	     2 cursor_storage_area_ptr ptr,		/* pointer to area where the cursors are kept */
  9   222 	     2 reserved_words     (10) fixed bin (35),	/* Reserved for future use */
  9   223 	     2 relmgr_entries,			/* relation manager entries */
  9   224 	       3 open	      entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  9   225 	       3 close	      entry (bit (36) aligned, fixed bin (35)),
  9   226 	       3 create_cursor    entry (bit (36) aligned, ptr, ptr, fixed bin (35)),
  9   227 	       3 destroy_cursor   entry (ptr, ptr, fixed bin (35)),
  9   228 	       3 set_scope	      entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35)),
  9   229 	       3 delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  9   230 	       3 modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35)),
  9   231 	       3 get_tuple_by_id  entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  9   232 	       3 get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)),
  9   233 	       3 get_tuple_id     entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  9   234 	       3 put_tuple	      entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  9   235 	       3 get_count	      entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  9   236 	       3 get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35)),
  9   237 	       3 get_population   entry (ptr, fixed bin (35), fixed bin (35)),
  9   238 	       3 create_relation  entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)),
  9   239 	       3 create_index     entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35)),
  9   240 	       3 destroy_relation_by_path entry (char (*), char (*), fixed bin (35)),
  9   241 	       3 reserved_entries (5) entry (),
  9   242 	     2 access_costs,			/* access costs for permute */
  9   243 	       3 total_primary_key_cost float bin,
  9   244 	       3 access_cost      float bin,
  9   245 	       3 access_overhead  float bin,
  9   246 	       3 us_access_cost   float bin,
  9   247 	       3 os_access_cost   float bin,
  9   248 	     2 dbc_uid	      bit (36) aligned,	/* uid of the segment containing the dbc structure */
  9   249 	     2 concurrency_on     bit (1) unal,		/* "1"b implies dmfile concurrency is being used */
  9   250 	     2 rollback_on	      bit (1) unal;		/* "1"b iomplies before journaling is to be done */
  9   251 
  9   252 /* END mrds_dbcb.incl.pl1 */
  9   253 
  9   254 
     1089 
     1090 
 10     1 /* BEGIN mrds_predicate_tree.incl.pl1 -- jaw, 2/14/79 */
 10     2 
 10     3 /* HISTORY:
 10     4*
 10     5*   81-06-01 Jim Gray : removed assn type and len, now that
 10     6*   mu_convert is being used.
 10     7*
 10     8*
 10     9**/
 10    10 
 10    11 
 10    12 dcl 1 pred_node based (pn_ptr),			/*  structure of predicate tree node */
 10    13     2 type fixed bin,				/*  indicates if node or leaf */
 10    14     2 id unal,					/* id for node */
 10    15       3 lleaf_id like pred_leaf.id,			/* id for left leaf */
 10    16       3 op_code bit (6) unal,				/* operator code for this node */
 10    17       3 rleaf_id like pred_leaf.id,			/* id for right leaf */
 10    18     2 term_type fixed bin (5) unal,			/* if term, indicates type of term */
 10    19     2 root bit (1) unal,				/* on if root node */
 10    20     2 term bit (1) unal,				/* on if node is term */
 10    21     2 determined bit (1) unal,			/* on if term is "determined" independent of other terms */
 10    22     2 reserved bit (21) unal,				/* reserved for future use */
 10    23     2 parent ptr,					/* pointer to parent node */
 10    24     2 lbr ptr,					/* pointer to left branch */
 10    25     2 rbr ptr;					/* pointer to right branch */
 10    26 
 10    27 dcl  pn_ptr ptr;
 10    28 
 10    29 dcl 1 pred_array based (pred_ptr),			/* list representation of pred. */
 10    30     2 type fixed bin,				/*  indicates array, rather than node or leaf */
 10    31     2 num_ands fixed bin,				/* is the number of and groups */
 10    32     2 and_ptr (num_ands_init refer (pred_array.num_ands)) ptr; /* pointers to the and groups */
 10    33 
 10    34 dcl  pred_ptr ptr;
 10    35 
 10    36 dcl 1 and_group based (ag_ptr),			/* list of pointers to all terms in and group */
 10    37     2 num_terms fixed bin,				/* number of terms in list */
 10    38     2 term_ptr (num_terms_init refer (and_group.num_terms)) ptr; /* point to terms in this and group */
 10    39 
 10    40 dcl  ag_ptr ptr;
 10    41 dcl (num_ands_init,
 10    42      num_terms_init) fixed bin;
 10    43 
 10    44 dcl ((CURRENT_OP init ("000001"b)),			/* pred_node op_codes */
 10    45     (AND_OP init ("000010"b)),
 10    46     (OR_OP init ("000011"b)),
 10    47     (NOT_OP init ("000100"b)),
 10    48     (EQ_OP init ("000101"b)),
 10    49     (NE_OP init ("000110"b)),
 10    50     (LT_OP init ("000111"b)),
 10    51     (GT_OP init ("001000"b)),
 10    52     (LE_OP init ("001001"b)),
 10    53     (GE_OP init ("001010"b)),
 10    54     (ALL_OP init ("001011"b))) bit (6) int static options (constant);
 10    55 
 10    56 dcl ((CONST init (1)),				/* pred leaf data types */
 10    57     (ATTR init (2)),
 10    58     (EXPRES init (3))) fixed bin int static options (constant);
 10    59 
 10    60 dcl ((NODE init (0)),				/* type indicators */
 10    61     (LEAF init (1)),
 10    62     (ARRAY init (2))) fixed bin int static options (constant);
 10    63 
 10    64 dcl ((V_C init (1)),				/* pred_node term_types */
 10    65     (V_V init (2))) fixed bin (5) int static options (constant);
 10    66 
 10    67 dcl 1 pred_leaf based (pl_ptr),			/* structure for a predicate tree leaf */
 10    68     2 type fixed bin,				/* indicates if node or leaf */
 10    69     2 id,						/* leaf id */
 10    70       3 var_id bit (18) unal,				/* index of tuple var. */
 10    71       3 attr_id bit (18) unal,			/* defn order of attr. */
 10    72     2 dummy bit (1) unal,				/* on if dummy leaf for ALL_OP */
 10    73     2 reserved bit (35) unal,				/* reserved for future use */
 10    74     2 data_type fixed bin,				/* whether const, attr, or expr */
 10    75     2 lit_offset fixed bin (35),			/* bit offset of literal or expr. result */
 10    76     2 lit_length fixed bin (35),			/* bit length of literal or expr. result */
 10    77     2 rslt_desc bit (36),				/* descriptor of expr. result */
 10    78     2 lit_ptr ptr,					/* ptr to literal or expr. result value */
 10    79     2 lit_desc_ptr ptr,				/* ptr to literal or expr. result desc. */
 10    80     2 ai_ptr ptr,					/* to rm_attr_info for attribute */
 10    81     2 expr_ptr ptr,					/* pointer to expr. structure if expr. leaf */
 10    82     2 parent ptr;					/* pointer to parent node */
 10    83 
 10    84 dcl  pl_ptr ptr;
 10    85 
 10    86 /* END mrds_predicate_tree.incl.pl1 */
 10    87 
     1091 
     1092 
 11     1 /* BEGIN mrds_optimize_tables.incl.pl1 -- jaw, 2/23/79 */
 11     2 
 11     3 /* HISTORY:
 11     4*
 11     5*   81-07-06 Jim Gray : added number  of  tuples  selected,  and  the
 11     6*   access  methods currently available to the path_var structure, to
 11     7*   allow the cost of a search path to be properly calculated.
 11     8*
 11     9*   81-07-07 Jim Gray : added in_and_group and cost to  path_var  for
 11    10*   handling not in and_group tuple variables.
 11    11*
 11    12*   81-07-13 Jim Gray : removed calc_cost related structures that are
 11    13*   no  longer  used.  Also  commented  the access methods available.
 11    14*   Added cond_ptr and attr_index to path_var to  make  gen_srch_prog
 11    15*   use access specified by permute.
 11    16*
 11    17*   81-07-14 Jim Gray : added  condition_selected  and  attr_selected
 11    18*   bits  to  the cond and attr_list structures respectively, so that
 11    19*   the permute logic in gen_srch_prog  could  be  removed,  and  the
 11    20*   desires  of  permute could be passed to gen_srch_prog. Also added
 11    21*   description of structures in this include file.
 11    22*
 11    23*   81-07-17 Jim Gray : removed unused path_array structure once used
 11    24*   by the discarded calc_cost routine, now replaced by permute.
 11    25*
 11    26*   81-07-19 Jim Gray : added in_select_clause bit  to  path_var  for
 11    27*   use  by  optimize,  gen_srch_prog  and  the  permute  display for
 11    28*   properly  handling  no_tuple_effect  tuple  variables,  and   not
 11    29*   producing cross products not specified by the user.
 11    30*
 11    31*   81-07-21 Jim Gray : added a second condition pointer to the  path
 11    32*   var  structure,  so  that  permute could detect, make use of, and
 11    33*   pass on the info for  doing  range  searches  on  key  heads  and
 11    34*   secondary indexes.
 11    35*
 11    36*   83-04-22 Mike Kubicar : removed attr_list.info.used.  It is no
 11    37*   longer needed.
 11    38*
 11    39**/
 11    40 
 11    41 
 11    42 /* DESCRIPTION:
 11    43*
 11    44*   The  major  structure  of  this  include  file  is  the  path_var
 11    45*   structure.  It is used to hold an ordered list of tuple variables
 11    46*   from the selection expression range clause, in the order in which
 11    47*   they  will  be  used  for  doing  I/O on the database in order to
 11    48*   retrieve the data necessary to evaluate the selection expression.
 11    49*
 11    50*   The alp in this structure points to the attr_list structure which
 11    51*   contains  a  list of all attributes referenced by this particular
 11    52*   tuple variable in the selection expression.
 11    53*
 11    54*   The elp in  this  path_var  structure  for  this  tuple  variable
 11    55*   similarly  points  to  the  expr_list  structure,  which contains
 11    56*   information on all expressions in the selection expression  which
 11    57*   reference the tuple variable.
 11    58*
 11    59*   The attr_list structure in turn has  a  list  of  all  conditions
 11    60*   (comparisons  involving  it)  against  that attribute in a linked
 11    61*   list of cond structures pointed to by the cond_ptr.
 11    62*
 11    63*   The op_code encoding for thecond and expr_list structures is that
 11    64*   used  in the pred_node structures of the predicate tree, and that
 11    65*   given by the named constants starting OTT_...
 11    66*
 11    67*   The path_array structure  was  originally  intended  for  use  by
 11    68*   mrds_dsl_calc_cost,  which  is  obsolete. Now only one element is
 11    69*   used to point to the path returned by permute.
 11    70*
 11    71**/
 11    72 
 11    73 dcl 1 path_var aligned based (pvp),			/* info on one path through and group */
 11    74     2 var_index fixed bin,				/* index of this var */
 11    75     2 in_and_group bit (1) unal,			/* on => this tuple variable participates in the and group */
 11    76     2 in_select_clause bit (1),			/* on => this tuple variable selected */
 11    77     2 pad bit (34) unal,				/* for future use */
 11    78     2 cost float bin (63),				/* partial sub path cost, or total for not in and_group */
 11    79     2 number_tuples_selected fixed bin (35),		/* estimate of tuples selected by access method */
 11    80     2 access_method fixed bin,			/* encoding for the method of access to this tuple variable:
 11    81*						   1 => unique key search
 11    82*						   2 => long key head search, only "=" conditions
 11    83*						   3 => short key head, other than "=" conditions
 11    84*						   4 => indexed attr
 11    85*						   5 => unordered sequential search
 11    86*						   6 => ordered sequential search */
 11    87     2 cond_ptr ptr,					/* to condition on this T.V. to be used for accessing it */
 11    88     2 second_cond_ptr ptr,				/* to second condition when a range is specified */
 11    89     2 attr_index fixed bin,				/* attr_ptr array definition order index
 11    90*						   of attr to be used for accessing this T.V. */
 11    91     2 lk_key_ind fixed bin,				/* link index or key id */
 11    92     2 alp ptr,					/* to attribute list */
 11    93     2 elp ptr,					/* to expr list */
 11    94     2 fwd_thd ptr;					/* to next in path */
 11    95 
 11    96 dcl  pvp ptr;
 11    97 
 11    98 
 11    99 /* ACCESS METHODS AVAILABLE TO MRDS:
 11   100*
 11   101*   1) any number of key attributes making up a  total  primary  key,
 11   102*   with  at  least  one  "="  condition against each allows use of a
 11   103*   vfile seek_key, to find the 1 unique tuple referenced
 11   104*
 11   105*   2) any number of key  head  attributes  with  at  least  one  "="
 11   106*   condition  against  each  allows  use of vfile select, to find >1
 11   107*   tuples whose key has this prefix value
 11   108*
 11   109*   3)  the  first  key  head  attribute  having  other  than  a  "="
 11   110*   condition,  or  any number of conditions against it allows use of
 11   111*   vfile select, to find >1 tuples whose key has this prefix
 11   112*
 11   113*   4) a single secondarily indexed attribute with any  condition  or
 11   114*   number  of  conditions  against it allows use of vfile select, to
 11   115*   find the >= 1 tuples whose values match  that  of  the  value  or
 11   116*   range of values given
 11   117*
 11   118*   5) an unordered sequential search, where no updates  against  the
 11   119*   database  relation  will  be  done allows use of mu_scan_records,
 11   120*   which goes through the records without touching the vfile keys
 11   121*
 11   122*   6) an ordered sequential search, which must touch the vfile  keys
 11   123*   in  order  to  get  the tuple records, thus producing an in-order
 11   124*   retrieval
 11   125*
 11   126**/
 11   127 
 11   128 dcl ((TOTAL_PRIMARY_KEY init (1)),
 11   129     (LONG_KEY_HEAD init (2)),
 11   130     (SHORT_KEY_HEAD init (3)),
 11   131     (INDEXED_ATTR init (4)),
 11   132     (UNORDERED_SEQUENTIAL init (5)),
 11   133     (ORDERED_SEQUENTIAL init (6))) fixed bin int static options (constant);
 11   134 
 11   135 dcl 1 attr_list aligned based (alp),			/* info on all ref. attr. for a t.v. */
 11   136     2 nattr fixed bin,				/* number of attrs in rel */
 11   137     2 info (al_nattr_init refer (attr_list.nattr)),	/* definition order array */
 11   138       3 attr_selected bit (1) unal,			/* on => this attr used by access method chosed */
 11   139       3 pad bit (35) unal,
 11   140       3 index fixed bin,				/* definition order, same as array element number  */
 11   141       3 cond_ptr ptr ;				/* to list of conditions on attr. */
 11   142 
 11   143 dcl  alp ptr;
 11   144 dcl  al_nattr_init fixed bin;
 11   145 
 11   146 dcl 1 cond aligned based (condp),			/* info on attr condition */
 11   147     2 op_code fixed bin,				/* op code translated from pred_node */
 11   148     2 condition_selected bit (1) unal,			/* on => this condition used by access method chosen */
 11   149     2 pad bit (35) unal,
 11   150     2 pl_ptr ptr,					/* to pred leaf of other attr */
 11   151     2 fwd_thd ptr;					/* to next condition */
 11   152 
 11   153 dcl  condp ptr;
 11   154 
 11   155 dcl 1 expr_list aligned based (elp),			/* info for expr in this var */
 11   156     2 nexprs fixed bin,
 11   157     2 info (el_nexprs_init refer (expr_list.nexprs)),
 11   158       3 epl_ptr ptr,				/* to pred leaf for this expr */
 11   159       3 op_code fixed bin,
 11   160       3 reserved bit (36) unal,			/* for future use */
 11   161       3 pl_ptr ptr;					/* to pred leaf of other var */
 11   162 
 11   163 dcl  elp ptr;
 11   164 dcl  el_nexprs_init fixed bin;
 11   165 
 11   166 /* COMPARISON OPERATOR NAMED CONSTANTS:
 11   167*
 11   168*   The following named constants represent the comparison  operators
 11   169*   "=", "^=", "<", "<=", ">", ">=".
 11   170*
 11   171*   They are used in the predicate tree nodes, the cond and expr_list
 11   172*   structure, and in gen_srch_prog structures. */
 11   173 
 11   174 dcl ((OTT_EQ init (1)),
 11   175     (OTT_NE init (2)),
 11   176     (OTT_LT init (3)),
 11   177     (OTT_LE init (4)),
 11   178     (OTT_GT init (5)),
 11   179     (OTT_GE init (6))) fixed bin int static options (constant);
 11   180 
 11   181 /* END mrds_optimize_tables.incl.pl1 */
 11   182 
     1093 
     1094 
 12     1 /* BEGIN mrds_search_ops.incl.pl1 -- 2/23/79 */
 12     2 
 12     3 /* HISTORY:
 12     4*
 12     5*   81-06-01 Jim Gray : removed assn_type and len from the  move_info
 12     6*   structure, since these are not used with the advent of mu_covert.
 12     7*
 12     8*   81-06-30 Jim Gray : added range_val_ptr to  init_info  structure,
 12     9*   so  that  ranges  (10  <  x < 20) could be handled in one call to
 12    10*   vfile select, instead of two. Also added range bit to  show  when
 12    11*   usable.
 12    12*
 12    13*   81-07-06 Jim Gray : changed init_info op type encodings for those
 12    14*   access  methods  currently available in mrds, plus added bits for
 12    15*   whether mrds or vfile needs to  do  tid  list  intersection,  and
 12    16*   whether an unordered, faster sequential search can be done.
 12    17*
 12    18*   81-07-18 Jim Gray : added many comments, after changing the named
 12    19*   constants to refer to the new access methods.
 12    20*
 12    21*   82-09-01 Mike Kubicar : converted from tuple structure to vector
 12    22*   structure.  This meant changing fields which pointed directly to
 12    23*   tuple space to use indices into the tuple_info structure instead.
 12    24*
 12    25*   82-10-01 Davids: removed the encd_hash flag from move_info since it
 12    26*   is never used and removed the encd_index flag from move_info since
 12    27*   changes to mrds_dsl_gen_srch_prog have rendered it obsolute. Increased
 12    28*   size of the reserved element from 28 to 30 bits.
 12    29*
 12    30*   83-04-04 Mike Kubicar : Removed init_info.unordered.  It is no longer
 12    31*   used.
 12    32*
 12    33*   83-04-22 Mike Kubicar : Added search_specification_ptr to select_info.
 12    34*   This is the search spec to be used when retrieving tuple from a relation.
 12    35*   Also deleted the init_info strucuture and associated constants.  It is no
 12    36*   longer used.
 12    37*
 12    38*   83-05-31 Mike Kubicar : Renamed search_specification_ptr to
 12    39*   relation_search_specification_ptr.
 12    40*
 12    41**/
 12    42 
 12    43 
 12    44 /* DESCRIPTION:
 12    45*
 12    46*		      BEGIN_DESCRIPTION
 12    47*
 12    48*   The search ops structure holds the  operations  to  be  performed
 12    49*   during   a   search   of  the  database.  It  is  a  step-by-step
 12    50*   actuallization of the selection expression specified by the user.
 12    51*   For each tuple variable, there will be an move-init-select set of
 12    52*   operations. The first operations is always an initizization~  one
 12    53*   called  PICKUP_SVP,  The  last  operation  is always a case for a
 12    54*   failure condition called RETNUL, to return  tuple_not_found.  The
 12    55*   move_init_select groups each have their own RETVAl step to return
 12    56*   a tuple, if they succeed in finding an acceptable tuple. If there
 12    57*   are multiple tuple variables, each T.V. group calls the move step
 12    58*   of the next group once it has found an acceptable tuple in  order
 12    59*   to  satisfy  all conditions of the and group. Multiple and groups
 12    60*   are processed until they exhaust all  possible  tuple  variables,
 12    61*   before the mini-search for the next and group is called.
 12    62*
 12    63*		       END_DESCRIPTION
 12    64**/
 12    65 
 12    66 dcl 1 search_ops aligned based (so_ptr),		/* the search "program" */
 12    67     2 ic fixed bin,					/* index to next instruction */
 12    68     2 nops fixed bin,				/* no. of operations in list */
 12    69     2 op (so_nops_init refer (search_ops.nops)),
 12    70       3 code fixed bin,				/* op code
 12    71*						   1 => init. range
 12    72*						   2 => move values
 12    73*						   3 => select tuple
 12    74*						   4 => return value
 12    75*						   5 => return null
 12    76*						   6 => pick up new search vars ptr */
 12    77       3 var_ind fixed bin,				/* index of tuple variable */
 12    78       3 good_xfer fixed bin,				/* rel. index of instr. if this op. successful */
 12    79       3 err_xfer fixed bin,				/* rel. index of instr. if this op is unsuccess. */
 12    80       3 info_ptr ptr;				/* pointer to op. dependent info. */
 12    81 
 12    82 dcl  so_ptr ptr;
 12    83 dcl  so_nops_init fixed bin;
 12    84 
 12    85 dcl ((INIT init (1)),
 12    86     (MOVE init (2)),
 12    87     (SEL init (3)),
 12    88     (RETVAL init (4)),
 12    89     (RETNUL init (5)),
 12    90     (PICKUP_SVP init (6))) fixed bin int static options (constant);
 12    91 
 12    92 /* the move info structure is used to obtain needed information
 12    93*   for the next database access specified by the init_info.
 12    94*   This may involve moving data from tuples in other tuple variable relations
 12    95*   in the database, doing a data conversion to a needed data type,
 12    96*   encoding the data for key usage, or evaluating an expression */
 12    97 
 12    98 dcl 1 move_info aligned based (mi_ptr),			/* info for move op. */
 12    99 						/* note: items must be processed in order since
 12   100*						   items may depend on prior items in list */
 12   101     2 bit_move bit (1) unal,				/* if just straight move */
 12   102     2 var_move bit (1) unal,				/* if straignt move of var len attr. */
 12   103     2 thread bit (1) unal,				/* on if moving thread */
 12   104     2 expr bit (1) unal,				/* if evaluating an expr. */
 12   105     2 encd_attr bit (1) unal,				/* if encoding a comparison value */
 12   106     2 extr_attr bit (1) unal,				/* if the value must be extracted from a tuple */
 12   107     2 reserved bit (30) unal,
 12   108     2 var_ind fixed bin,				/* index of source var, or 0 */
 12   109     2 tuple_var_index fixed bin,			/* index of tuple variable (tuple_info.tuple) to use */
 12   110     2 tuple_attr_index fixed bin,			/* index of attribute to extract */
 12   111     2 s_ptr ptr,					/* to source (tuple.data if var., ksl_ptr if key */
 12   112     2 t_ptr ptr,					/* target, (encoded key value if encode) tuple ptr if expr */
 12   113     2 sbit_len fixed bin (35),			/* bit length (bit offset if var.) thd type if thd */
 12   114     2 tbit_len fixed bin (35),			/* target length */
 12   115     2 s_desc bit (36),				/* descriptor for source */
 12   116     2 t_desc bit (36),				/* descriptor for target */
 12   117     2 encd_desc bit (36),				/* descriptor for encd attr */
 12   118     2 fwd_thd ptr;					/* to next move info */
 12   119 
 12   120 dcl  mi_ptr ptr;
 12   121 dcl  mi_nitems_init fixed bin;
 12   122 
 12   123 
 12   124 /* the select info structure is used to hold info about
 12   125*   where to put a tuple that satisfies all conditions,
 12   126*   and to point to a list of comparisons to be made against
 12   127*   the tuple, before it is considered acceptable */
 12   128 
 12   129 dcl 1 select_info aligned based (seli_ptr),		/* info for select op. */
 12   130     2 tuple_info_index fixed bin,			/* to output tuple */
 12   131     2 tid_ptr ptr,					/* to place to store tuple id */
 12   132     2 relation_search_specification_ptr ptr,		/* Search spec for relation manager gets */
 12   133     2 cvla_ptr ptr;					/* pointer to cvl_array */
 12   134 
 12   135 dcl  seli_ptr ptr;
 12   136 
 12   137 /* END mrds_search_ops.incl.pl1 */
 12   138 
     1095 
     1096 
 13     1 /* BEGIN mrds_search_vars.incl.pl1 -- jaw, 2/26/79 */
 13     2 
 13     3 dcl 1 search_vars aligned based (sv_ptr),		/* info on all variables */
 13     4     2 nvars fixed bin,				/* number of variables */
 13     5     2 new_val (sv_nvars_init refer (search_vars.nvars),	/* indicates new values to be moved */
 13     6      sv_nvars_init refer (search_vars.nvars)) bit (1) unal,
 13     7     2 info (sv_nvars_init refer (search_vars.nvars)) like rtrv_info; /* data for each var. */
 13     8 
 13     9 dcl  sv_ptr ptr;
 13    10 dcl  sv_nvars_init fixed bin;
 13    11 
 13    12 /* END mrds_search_vars.incl.pl1 */
 13    13 
     1097 
     1098 
 14     1 /* BEGIN mrds_range.incl.pl1 -- jaw, 10/20/78 */
 14     2 
 14     3 /* Modified 83-04-22 by R. Harvey to add needed_bits */
 14     4 
 14     5 dcl 1 range aligned based (range_ptr),
 14     6     2 num_vars fixed bin,				/* number of tuple variables */
 14     7     2 tup_var (mrds_data_$max_tup_var refer (range.num_vars)), /* info for each tuple variable */
 14     8       3 name char (mrds_data_$max_id_len),		/* name of tuple variable */
 14     9       3 temp_rel bit (1) unal,			/* on if temporary relation */
 14    10       3 used bit (1) unal,				/* 1 => this tuple variable is referenced by
 14    11*						   a -select clause. */
 14    12       3 whole_tuple_selected bit (1) unal,		/* the whole tuple variable is referenced in the select clause */
 14    13       3 copy_for_current bit (1) unal,			/* -current requests attributes not previously retrieved */
 14    14       3 copied_for_current bit (1) unal,		/* tuple copied during previous -current */
 14    15       3 reserved bit (31) unal,			/* reserved for future use */
 14    16       3 rel_index fixed bin,				/* index to assoc. relation */
 14    17       3 stv_ptr ptr,				/* simple typed vector */
 14    18       3 idl_ptr ptr,				/* id_list ptr */
 14    19       3 needed_bits aligned,
 14    20         4 attr (mrds_data_$max_attributes) bit (1) unal,
 14    21       3 ri_ptr ptr;					/* pointer to rel info for assoc. relation */
 14    22 
 14    23 dcl  range_ptr ptr;
 14    24 
 14    25 /* END mrds_range.incl.pl1 */
 14    26 
     1099 
     1100 
 15     1 /* BEGIN mrds_tuple_info.incl.pl1 -- jaw 11/2/78 */
 15     2 
 15     3 /* HISTORY:
 15     4*
 15     5*   Modified in March 1977 by O Friesen to hold allocated ptr and length
 15     6*   82-10-29 Mike Kubicar : Made tuple_id aligned
 15     7*
 15     8**/
 15     9  
 15    10 dcl 1 tuple_info aligned based (ti_ptr),
 15    11     2 num_tuples fixed bin,				/* no. of tuples for which info given */
 15    12     2 tuple (ti_ntuples_init refer (tuple_info.num_tuples)),
 15    13       3 tuple_ptr ptr,				/* pointer to found tuple */
 15    14       3 tuple_id bit (36) aligned,			/* tuple id for  found tuple */
 15    15       3 var_index fixed bin;				/* index to tuple variable  */
 15    16 
 15    17 dcl  ti_ptr ptr;
 15    18 dcl  ti_ntuples_init fixed bin;
 15    19 
 15    20 /* END mrds_tuple_info.incl.pl1 */
 15    21 
     1101 
     1102 
 16     1 /* BEGIN mrds_lit_info.incl.pl1 -- jaw, 2/13/79 */
 16     2 
 16     3 /* HISTORY:
 16     4*
 16     5*   81-05-06  Rickie  E.  Brinegar: The declaration encd_ptr ptr was changed to
 16     6*   encd_entry  entry  and encd_proc bit (1) and pad bit (35) were added.  This
 16     7*   was  done  inoder to permit make use of cu_$generate call and eliminate the
 16     8*   use of cv_ptr_ to generate entry pointers.
 16     9*
 16    10*   81-06-01 Jim Gray : removed assn_len and ass_len structure elements,
 16    11*   as these are not used, with the advent of mu_convert.
 16    12*
 16    13**/
 16    14 
 16    15 dcl 1 lit_info aligned based (lip),			/* info for make literal call */
 16    16     2 src_ptr ptr,					/* to literal source data */
 16    17     2 srcd_ptr ptr,					/* to literal source descr. */
 16    18     2 encd_entry entry,				/* to encode proc. entry */
 16    19     2 encd_proc bit (1) unal,				/* does an encode proc exist? */
 16    20     2 pad bit (35) unal,
 16    21     2 encdd_ptr ptr,				/* to descr. for input to encode proc */
 16    22     2 litd_ptr ptr,					/* to descr. to final liter. val. */
 16    23     2 lit_ptr ptr,					/* to final literal value */
 16    24     2 encd_blen fixed bin (35),			/* to bit length for encode proc input */
 16    25     2 lit_blen fixed bin (35),			/* to bit length for final literal */
 16    26     2 lit_offset fixed bin (35);			/* to offset for final literal in lit. pool */
 16    27 
 16    28 dcl  lip ptr;
 16    29 
 16    30 /* END mrds_lit_info.incl.pl1 */
 16    31 
     1103 
     1104 
 17     1 /* BEGIN INCLUDE FILE mrds_expressions.incl.pl1 -- jaw 2/15/79 */
 17     2 
 17     3 /* HISTORY:
 17     4*
 17     5*   81-06-01 Jim Gray : removed assn len and type elements
 17     6*   since mu_covnert is now being used.
 17     7*
 17     8**/
 17     9 
 17    10 
 17    11 dcl 1 expr aligned based (expr_ptr),			/* internal representation of an expression,
 17    12*						   expression is stored in postfix polish form */
 17    13     2 nitems fixed bin,				/* no. items in expression */
 17    14     2 item (nexp_items_init refer (expr.nitems)),
 17    15       3 type fixed bin (3) unal,			/* 1 => data item
 17    16*						   2 => operator
 17    17*						   3 => scalar function */
 17    18       3 op_code fixed bin (3) unal,			/* 1 => add
 17    19*						   2 => subtract
 17    20*						   3 => multiply
 17    21*						   4 => divide */
 17    22       3 data_type fixed bin (2) unal,			/* 1 => literal
 17    23*						   2 => database */
 17    24       3 reserved bit (25) unal,
 17    25       3 desc bit (36),				/* data descriptor of data item or fun. result */
 17    26       3 loc_index fixed bin (18),			/* location index of data item or fun. result */
 17    27       3 bit_length fixed bin (18),			/* bit length of data item or fun. result */
 17    28       3 assn_ptr ptr,				/* pointer to item storage loc. */
 17    29       3 ai_ptr ptr,					/* to attr info if database item */
 17    30       3 fn_ptr ptr;					/* pointer to function structure if scalar function */
 17    31 
 17    32 dcl  expr_ptr ptr;
 17    33 dcl  nexp_items_init fixed bin;
 17    34 
 17    35 dcl 1 scalfn aligned based (sfn_ptr),			/* internal representation of a scalar function */
 17    36     2 entry_ptr ptr,				/* pointer to entry to be called */
 17    37     2 arg_list_ptr ptr,				/* pointer to arg list to be used for calling function */
 17    38     2 rslt_desc bit (36),				/* descriptor for result */
 17    39     2 nargs fixed bin,				/* number of input args */
 17    40     2 arg (nsf_args_init refer (scalfn.nargs)),		/* arg info */
 17    41       3 type fixed bin (3) unal,			/* 1 => literal
 17    42*						   2 => database
 17    43*						   3 => scalar function
 17    44*						   4 => expression */
 17    45       3 must_convert bit (1) unal,			/* on if arg must be converted to match requirements */
 17    46       3 reserved bit (31) unal,
 17    47       3 desc bit (36),				/* descriptor of data or result */
 17    48       3 loc_index fixed bin (18),			/* location index of data item or result */
 17    49       3 bit_length fixed bin (18),			/* bit length of data item or result */
 17    50       3 assn_ptr ptr,				/* pointer to item storage loc. */
 17    51       3 arg_desc bit (36),				/* descriptor for arg if must convert */
 17    52       3 arg_assn_ptr ptr,				/* assign_ ptr for arg in must convert */
 17    53       3 ai_ptr ptr,					/* to attr info if database item */
 17    54       3 ef_ptr ptr;					/* pointer to expression or function structure, or null */
 17    55 
 17    56 dcl  sfn_ptr ptr;
 17    57 dcl  nsf_args_init fixed bin;
 17    58 
 17    59 dcl ((DATA init (1)),
 17    60     (OPERATOR init (2)),
 17    61     (SCAL_FUN init (3)),
 17    62     (EXPR init (4)),
 17    63     (ADD init (1)),
 17    64     (SUBT init (2)),
 17    65     (MULT init (3)),
 17    66     (DIV init (4)),
 17    67     (LITERAL init (1)),
 17    68     (DATABASE init (2))) fixed bin int static options (constant);
 17    69 
 17    70 dcl  CFLTD59 bit (36) aligned int static options (constant)
 17    71      init ("100110000000000000000000000000111011"b);
 17    72 dcl  RFLTD59 bit (36) aligned int static options (constant)
 17    73      init ("100101000000000000000000000000111011"b);
 17    74 
 17    75 /* END INCLUDE FILE mrds_expressions.incl.pl1 */
 17    76 
     1105 
     1106 
 18     1 /* BEGIN mdbm_rm_db_info.incl.pl1 -- jaw, 11/7/78 */
 18     2 
 18     3 
 18     4 
 18     5 /****^  HISTORY COMMENTS:
 18     6*  1) change(86-08-13,Hergert),, approve(88-06-28,MCR7903),
 18     7*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
 18     8*     Removed change of 84-11-02. i.e. replaced even_word_pad.
 18     9*                                                   END HISTORY COMMENTS */
 18    10 
 18    11 
 18    12 /* WARNING
 18    13*          If the rm_db_info structure is changed then the mrds_data_
 18    14*          item saved_res_version MUST be incremented to invalidate all
 18    15*          existing saved resultants
 18    16**/
 18    17 
 18    18 /*  DESCRIPTION:  This  structure   is   based   on   a   segment
 18    19*   {unique_name}.mrds.rdbi that represents the secure portion of the
 18    20*   resultant model that is created partially at database open  time,
 18    21*   (the rm_file_array, and rm_rel_array) and partially at ready_file
 18    22*   time,    (the    rm_file_info,     rm_rel_info,     rm_attr_info,
 18    23*   rm_domain_info, rm_plink_info and rm_clink_info). it's purpose is
 18    24*   to  provide  an  efficient  means  of  accessing  database  model
 18    25*   information, as seen from the possibly submodel view of the user,
 18    26*   and his current state of "files readied". it is the  secure  part
 18    27*   because  it  contains  the  model  information  which needs to be
 18    28*   protected  from  general  knowledge,  and   this   segment   will
 18    29*   eventually  be  capable  of  being in a lower ring. the structure
 18    30*   itself points to four arrays that are  allocated  in  it's  area,
 18    31*   that  in  turn point to the other structures mentions above, also
 18    32*   allocated in  the  rm_db_info.static_area.  the  arrays  are  the
 18    33*   rm_file_array,  and  rm_rel_array. their are a pair for temporary
 18    34*   relations,  initially  empty,  and  a  pair  for   normal   model
 18    35*   files/relations.  the  normal  rm_file_array  is initialized to a
 18    36*   list of all known file names, the rm_rel_array only gets relation
 18    37*   names   as   files  are  readied.  the  rm_file_array  points  to
 18    38*   rm_file_infos for each file (see mdbm_rm_file_info.incl.pl1)  and
 18    39*   the   rm_rel_array   points  to  rm_rel_info  for  each  relation
 18    40*   "readied". (see mdbm_rm_rel_info.incl.pl1). (the  arrays  are  in
 18    41*   mdbm_rm_file_array.incl.pl1  and mdbm_rm_rel_array.incl.pl1). the
 18    42*   file infos point to contained rel infos, the rel infos  point  to
 18    43*   contained  attr  infos,  and  those in turn to domain infos. (see
 18    44*   mdbm_rm_attr_info.incl.pl1   and    mdbm_rm_domain_info.incl.pl1)
 18    45*   foreign     keys    are    represented    by    the    structures
 18    46*   mdbm_rm_plink_info.incl.pl1, and mdbm_rm_clink_info.incl.pl1. the
 18    47*   pathnames  of the model and submodel, if any, are also maintained
 18    48*   in rm_db_info. the pointer to this rm_db_info segment is obtained
 18    49*   from  the  dbcb  segment tructure(see mrds_dbcb.incl.pl1) see the
 18    50*   individual include files for  further  organization  information,
 18    51*   and particular data structures.
 18    52*
 18    53*   HISTORY:
 18    54*
 18    55*   80-02-01 Jim Gray : Modified to put area on even  word  boundary,
 18    56*   so that define_area_ could be used to make it an extensible area
 18    57*
 18    58*   81-1-9 Jim  Gray  :  added  like  reference  to  make  the  phony
 18    59*   resultant in mu_database_index easier to keep, since no reference
 18    60*   to the area is needed.
 18    61*
 18    62*   81-1-12 Jim Gray : added version of submodel used in  opening  to
 18    63*   resultant.
 18    64*
 18    65*   81-05-13 Rickie E. Brinegar: added the administrator bit  to  the
 18    66*   structure.
 18    67*
 18    68*   81-05-28 Jim Gray : removed pointers to file_arrays,  since  they
 18    69*   are  now  combined  into  the rel_array. Removed the control file
 18    70*   info which was unused. Added pointer  to  head  of  domain  list,
 18    71*   which is to be used to insure only one copy of each domain info.
 18    72*
 18    73*   83-05-19 Davids: Added the  saved_res_version element.
 18    74*
 18    75*   84-11-02 Thanh Nguyen:   Replaced  the  even_word_pad   by   the 
 18    76*   ref_name_proc_ptr  to point  to list  of reference  name of  the
 18    77*   check, encode, or decode proc.
 18    78*
 18    79*   CAUTION: The structure entries from db_version to sm_path  should
 18    80*   not  be moved or have their declarations changed because they are
 18    81*   used in the handling of old version database openings.
 18    82*
 18    83*
 18    84**/
 18    85 
 18    86      dcl	   1 rm_db_info	      aligned based (rdbi_ptr), /* data base info, located at base of res. dm. seg. */
 18    87 	     2 data	      like rm_db_info_data,
 18    88 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (rm_db_info.static_area))));
 18    89 
 18    90      dcl	   rdbi_ptr	      ptr;
 18    91 
 18    92      declare 1 rm_db_info_data      based,		/* separate declaration of info, so others can use
 18    93*						   like reference to it without getting the area as well */
 18    94 	     2 db_version	      fixed bin,		/* version no. of db */
 18    95 	     2 sm_version	      fixed bin unal,	/* version of submodel used unal, 0 if model opening */
 18    96 	     2 val_level	      fixed bin unal,	/* validation level for this db. */
 18    97 	     2 db_path	      char (168),		/* abs. path of db. */
 18    98 	     2 sm_path	      char (168),		/* path of submodel or model */
 18    99 	     2 mdbm_secured	      bit (1) unal,		/* ON => database is secured */
 18   100 	     2 administrator      bit (1) unal,		/* ON => user is an administrator */
 18   101 	     2 pad	      bit (34) unal,	/* for future use */
 18   102 	     2 saved_res_version  char (8),		/* version of the saved resultant in the 
 18   103*                                                               dbcb and rdbi segments in the db dir */
 18   104 	     2 domain_list_ptr    ptr,		/* pointer to head of list of domain_info's */
 18   105 	     2 ra_ptr	      ptr,		/* pointer to rel. array */
 18   106 	     2 tra_ptr	      ptr,		/* to rel array for temp rels */
 18   107 	     2 even_word_pad      fixed bin (71) aligned; /* padding to put area on even word boundary */
 18   108 
 18   109 /* END mdbm_rm_db_info.incl.pl1 */
 18   110 
 18   111 
     1107 
     1108 
 19     1 /* BEGIN mdbm_rm_rel_info.incl.pl1 -- jaw, 11/16/78 */
 19     2 
 19     3 /* WARNING
 19     4*          If the rm_rel_info structure is changed then the mrds_data_
 19     5*          item saved_res_version MUST be incremented to invalidate all
 19     6*          existing saved resultants
 19     7**/
 19     8 
 19     9 /* HISTORY:
 19    10*
 19    11*   Modified by Jim Gray - - May 1980, to  include  model  number  of
 19    12*   attributes,   and   varying  attributes,  so  that  partial  view
 19    13*   submodels will have the  info  needed  to  properly  set  up  the
 19    14*   varying length array headers in the tuple structure.
 19    15*
 19    16*   Modified  by  Jim  Gray  -  -  80-11-06,  to  rename   r_perm   =
 19    17*   status_perm,     s_perm    =    append_tuple_perm,    d_perm    =
 19    18*   delete_tuple_perm, and make m_perm = unused_perm.
 19    19*
 19    20*   81-01-23 Jim Gray : added bit to indicate whether the last  model
 19    21*   view attribute was varying character or bit, since a partial view
 19    22*   submodel will not have this information in the resultant, and  it
 19    23*   is  needed for determining the new tuple length in mus_mod_ubtup,
 19    24*   since with exact length storage  of  varying  length  attributes,
 19    25*   each  tuple  can  be  a  different  length,  which is can only be
 19    26*   determined by examining the tuple itself.
 19    27*
 19    28*   81-01-29 Jim Gray : added curent  tuple  count,  to  provide  for
 19    29*   interface  to  allow  temp  rel  population  to  be known, and to
 19    30*   provide a more efficient means of finding an approx. current perm
 19    31*   relation population.
 19    32*
 19    33*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
 19    34*   blocked  files, foreign keys, and ids procedures. Also set number
 19    35*   of files per rel to a constant of 1.
 19    36*
 19    37*   81-05-28 Jim Gray : combined data  from  rm_file_info  into  this
 19    38*   structure so that only one structure per relation is needed.
 19    39*
 19    40*   81-07-02 Jim Gray : added total_key and dup_key vfile  statistics
 19    41*   counts.   Also  added  number  of  operations  count  since  last
 19    42*   statistics update, and a time  since  the  statistics  were  last
 19    43*   updated.
 19    44*
 19    45*   81-07-06 Jim Gray :  added  a  per  selection  expression  update
 19    46*   identifier so that small relations could be updated on a per S.E.
 19    47*   basis
 19    48*
 19    49*   82-04-21 R. Lackey : Added number_selected (ri_niocbs_init refer (rm_rel_info.niocbs)) fixed bin (35)
 19    50*   to end of structure   TR 12205 (Suggestion).
 19    51*   
 19    52*   82-08-19 D. Woodka :  Removed  rm_rel_info.max_data_len  field for
 19    53*   the DMS conversion. 
 19    54*
 19    55*   82-08-30 Davids: added the opening_id element and removed the iocb
 19    56*   array and the niocb element for DMS conversion. Also removed the
 19    57*   number_selected array (and ri_niocbs_init) since subsets are not
 19    58*   going to be used.
 19    59*
 19    60*   82-09-20 Mike Kubicar : changed rm_rel_info.rel_id to bit (36) aligned
 19    61*   so that it can be used with relation manager.  Also added
 19    62*   rm_rel_info.primary_key_index_id for relation manager.
 19    63*
 19    64*   82-09-22 Mike Kubicar : Removed the, now useless, fields var_attr_ptrs,
 19    65*   nvar_atts, model_nvar_atts.
 19    66*
 19    67*   82-09-24 Davids: Removed current_key_count and current_dup_key_count
 19    68*   since the duplicate key count for each secondary index is now being
 19    69*   kept in the attr_info structure and key_count was only needed to
 19    70*   help in calculating the average selectivity of each index which
 19    71*   can now be gotten directly from each index's dup key count. Also
 19    72*   removed the file_id element since it is no longer needed for
 19    73*   anything.
 19    74*
 19    75*   82-09-27 Mike Kubicar : removed file_id_len for the same reason file_id
 19    76*   was removed.
 19    77*
 19    78*   82-11-05 Mike Kubicar : added a pointer to an id_list structure to be
 19    79*   used when retrieving tuples from this relation.
 19    80*
 19    81*   83-04-06 Davids: Added the scope_flags_ptr which points to the scope_flags structure
 19    82*   for the relation. Note that this structure is part of the resultant NOT
 19    83*   part of the db.control structure. The scopes are duplicated in the resultant
 19    84*   to reduce contention for the db.control structure. Note also that the pointer
 19    85*   will always point to a scope_flags structure even if no scopes have been
 19    86*   set on the relation, the structure is allocated when the db is opened.
 19    87**/
 19    88 
 19    89 
 19    90 /* DESCRIPTION:
 19    91*
 19    92*   This structure is allocated in the area part of the structure  in
 19    93*   mdbm_rm_db_info.incl.pl1  as  part of the resultant model created
 19    94*   at open  time  for  a  database.  There  will  be  one  of  these
 19    95*   rm_rel_info   structures  for  each  relation  appearing  in  the
 19    96*   database view (there may be less than the total in  the  database
 19    97*   for  a  submodel  openings).  There  will  also  be  one for each
 19    98*   temporary relation currently defined for that opening.
 19    99*
 19   100*   The structure in mdbm_rm_rel_array.incl.pl1 contains pointers  to
 19   101*   all  rm_rel_info  structures  allocated. It is used for searching
 19   102*   for the appropriate  structure.  This  array  is  pointed  to  by
 19   103*   rm_db_info. There are two arrays, one for perm rels, one for temp
 19   104*   rels.
 19   105*
 19   106*   The      rm_rel_info      structure      points      to       the
 19   107*   mdbm_rm_attr_info.incl.pl1  structures,  one  for  each attribute
 19   108*   appearing in this view of the relation. Each  of  these  in  turn
 19   109*   point  to a mdbm_rm_domain_info.incl.pl1 structure for the domain
 19   110*   info for each attr.
 19   111*
 19   112*   Most of the other information here deals with  specifics  of  the
 19   113*   relation's  logical  definition,  such as key and secondary index
 19   114*   attribute inidicators, security permissions, and  tuple  physical
 19   115*   construction details.
 19   116*
 19   117**/
 19   118 
 19   119      dcl	   1 rm_rel_info	      aligned based (rmri_ptr), /* relation information */
 19   120 	     2 name	      char (32),		/* from submodel */
 19   121 	     2 model_name	      char (30),		/* from model */
 19   122 	     2 rel_id	      bit (36) aligned,	/* unique id. */
 19   123 	     2 retrieve	      bit (1) unal,		/* operations allowed by this view */
 19   124 	     2 modify	      bit (1) unal,
 19   125 	     2 delete	      bit (1) unal,
 19   126 	     2 store	      bit (1) unal,
 19   127 	     2 total_key	      bit (1) unal,		/* on if view includes full primary key */
 19   128 	     2 indexed	      bit (1) unal,		/* on if exists sec. index */
 19   129 	     2 mdbm_secured	      bit (1) unal,		/* on if mdbm must check security */
 19   130 	     2 status_perm	      bit (1) unal,		/* if user has status. perm. */
 19   131 	     2 append_tuple_perm  bit (1) unal,		/* if user has store perm. */
 19   132 	     2 delete_tuple_perm  bit (1) unal,		/* if user has del. perm. */
 19   133 	     2 unused_perm	      bit (1) unal,		/* for future use. */
 19   134 	     2 last_model_attr_char_var bit (1) unal,	/* on => last model varying attr is char */
 19   135 	     2 reserved	      bit (24) unal,	/* for future use */
 19   136 	     2 num_attr	      fixed bin,		/* total no. of attr. in rel. */
 19   137 	     2 model_num_attr     fixed bin,		/* total attrs in model relation */
 19   138 	     2 nkey_attr	      fixed bin,		/* no. of key attr. */
 19   139 	     2 model_nkey_attr    fixed bin,		/* total number of keys in model */
 19   140 	     2 primary_key_index_id bit (36) aligned,     /* Index id of relation's primary key */
 19   141 	     2 nsec_inds	      fixed bin,		/* no. sec. indexes */
 19   142 	     2 max_key_len	      fixed bin (35),	/* max length (chars) of primary key */
 19   143 	     2 current_tuple_population fixed bin (35),	/* last known total  tuple count for this relation */
 19   144 	     2 last_statistics_update_count fixed bin,	/* number of operations's, since this rels stats were updated */
 19   145 	     2 last_statistics_update_time fixed bin (71),/* last time this rels stats were updated */
 19   146 	     2 last_statistics_update_s_e_ref_num fixed bin (35), /* last select expr ID that updated this rels stats */
 19   147 	     2 ready_mode	      fixed bin,		/* 1 => r, 2 => mr, 3 => u, 4 => l, 5 => sr, 6 => su */
 19   148 	     2 file_type	      fixed bin,		/* 1 => unblocked, 2 => blocked, 3 => temporary */
 19   149 	     2 tuple_id_len	      fixed bin,		/* no. bits in local tuple id */
 19   150 	     2 opening_id	      bit (36) aligned,	/* relation manager opening is */
 19   151 	     2 key_attr_ptrs      (nkey_attr_init refer (rm_rel_info.nkey_attr)) ptr, /* ptrs to key attr. */
 19   152 	     2 attr_ptrs	      (natts_init refer (rm_rel_info.num_attr)) ptr, /* ptrs to all attr. */
 19   153 	     2 id_list_ptr        ptr,		/* Id list for retrieves from the relation */
 19   154                2 scope_flags_ptr    ptr;                    /* pointer to the scope_flags structure for the rel */
 19   155 
 19   156      dcl	   rmri_ptr	      ptr;
 19   157      dcl	   (nkey_attr_init,
 19   158 	   natts_init,
 19   159 	   nvar_atts_init)	      fixed bin;
 19   160 
 19   161 /* END mdbm_rm_rel_info.incl.pl1 */
 19   162 
 19   163 
     1109 
     1110 
 20     1 /*  BEGIN  mdbm_rm_attr_info.incl.pl1  --  jaw,  11/16/78  */
 20     2 
 20     3 /* WARNING
 20     4*          If the rm_attr_info structure is changed then the mrds_data_
 20     5*          item saved_res_version MUST be incremented to invalidate all
 20     6*          existing saved resultants
 20     7**/
 20     8 
 20     9 /*
 20    10*
 20    11*   Modified  by  Jim  Gray - - 80-11-05, to add mdbm_secured bit, so
 20    12*   that rm_rel_info does not have to be checked
 20    13*
 20    14*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
 20    15*   foreign keys.
 20    16*
 20    17*   82-08-19  D. Woodka : removed rm_attr_info.bit_offset for the DMS
 20    18*   conversion.
 20    19*
 20    20*   82-09-15 Davids: added the number_of_dups field.
 20    21*
 20    22*   82-09-20 Mike Kubicar : changed the index_id field to be bit (36)
 20    23*   aligned.  This is to conform with the new definition in the database
 20    24*   model.  Also removed the now useless field varying.
 20    25*
 20    26*   82-11-05 Davids: added the field model_defn_order and clarified the
 20    27*   comment for the field defn_order.
 20    28*
 20    29*   83-05-23 Mike Kubicar : changed number_of_dups to fixed bin (35) since
 20    30*   that's what relation manager returns.
 20    31*
 20    32**/
 20    33 
 20    34 
 20    35 /*
 20    36*   this   structure   is   allocated   in   the   static   area   of
 20    37*   mdbm_rm_db_info.incl.pl1  once for each attribute per relation in
 20    38*   a     readied     file.      it     in     turn     points     to
 20    39*   mdbm_rm_domain_info.incl.pl1  for  the  attributes  domain.   the
 20    40*   rm_attr_info  is  pointed  to  by mdbm_rm_rel_info.incl.pl1.  all
 20    41*   structures  are  in  the  rm_db_info  area.   the  attribute data
 20    42*   position  within  a  tuple as stored in the data file are kept in
 20    43*   this resultant model of the attribute.
 20    44* */
 20    45 
 20    46 dcl 1 rm_attr_info aligned based (rai_ptr),		/* resultant attr. info */
 20    47     2 name char (32),				/* from submodel */
 20    48     2 model_name char (32),				/* from model */
 20    49     2 key_attr bit (1) unal,				/* if key attribute */
 20    50     2 index_attr bit (1) unal,			/* if secondary index */
 20    51     2 read_perm bit (1) unal,				/* user has retr. permission */
 20    52     2 modify_perm bit (1) unal,			/* user has modify permission */
 20    53     2 mdbm_secured bit (1) unal,			/* on => database secured */
 20    54     2 reserved bit (30) unal,				/* for future use */
 20    55     2 index_id bit (36) aligned,			/* index id if index_attr */
 20    56     2 defn_order fixed bin,				/* relative order in which attr is defined in the view */
 20    57     2 key_order fixed bin,				/* relative order defined in prim. key */
 20    58     2 bit_length fixed bin (35),			/* length if fixed, max. len. if var. */
 20    59     2 domain_ptr ptr,				/* to domain info */
 20    60     2 number_of_dups fixed bin (35),                        /* if the attribute is indexed this will
 20    61*                                                               be the number of duplicate values, exact
 20    62*                                                               for a page_file database, an estimate for a vfile type */
 20    63     2 model_defn_order fixed bin;                           /* relative order in which attr is defined in the model */
 20    64 
 20    65 dcl  rai_ptr ptr int automatic init (null ());
 20    66 
 20    67 /* END mdbm_rm_attr_info.incl.pl1 */
 20    68 
 20    69 
     1111 
     1112 
 21     1 /* BEGIN mdbm_rm_domain_info.incl.pl1 -- jaw, 9/26/78 */
 21     2 
 21     3 /* WARNING
 21     4*          If the rm_domain_info structure is changed then the mrds_data_
 21     5*          item saved_res_version MUST be incremented to invalidate all
 21     6*          existing saved resultants
 21     7**/
 21     8 
 21     9 /* DESCRIPTION:
 21    10*
 21    11*   This  structure  is  allocated  in  the  mdbm_rm_db_info.incl.pl1
 21    12*   static  area,  once per attribute used in a relation in a readied
 21    13*   file. it is pointed to by the mdbm_rm_attr_info.incl.pl1, and may
 21    14*   point  to  mdbm_rm_ck_and_group.incl.pl1  if  a  "-check"  option
 21    15*   boolean expression was declared for this domain. it contains  the
 21    16*   descriptor  for  this domain data type, and other resultant model
 21    17*   information.
 21    18*
 21    19*
 21    20*   HISTORY:
 21    21*
 21    22*   81-05-06  Rickie  E.  Brinegar:  Modified  ck_proc,  encode_proc,
 21    23*   decode_proc to be entry variables instead of entry pointers. This
 21    24*   allows these programs to be written in languages other than pl1.
 21    25*
 21    26*   81-05-28 Jim Gray : removed unused procedure points,  and  unused
 21    27*   check  stack  structure  elements.  Also made the descriptors bit
 21    28*   (36) in this structure, rather than pointers to  the  descriptors
 21    29*   elsewhere.  Also  removed un-needed redundant assign_ parameters,
 21    30*   that are actually available in the descriptors.
 21    31*
 21    32*
 21    33**/
 21    34 
 21    35 dcl 1 rm_domain_info aligned based (rdi_ptr),		/* domain information */
 21    36     2 name char (32),				/* domain name */
 21    37     2 db_desc bit (36),				/*  to desc. for db. */
 21    38     2 user_desc bit (36),				/* desc for user visible data */
 21    39     2 user_bit_len fixed bin,				/* storage length of users data */
 21    40     2 ck_proc_entry entry variable,			/* to check proc. entry */
 21    41     2 encd_proc_entry entry variable,			/* to encode proc entry */
 21    42     2 decd_proc_entry entry variable,			/* to decode proc entry */
 21    43     2 ck_proc bit (1) unal,				/* Is there a check proc */
 21    44     2 encd_proc bit (1) unal,				/* Is there an encode proc */
 21    45     2 decd_proc bit (1) unal,				/* Is there a decode proc */
 21    46     2 pad bit (33) unal,
 21    47     2 next_domain_ptr ptr ;				/* to next domain, in list of all domains */
 21    48 						/* to check stack and groups */
 21    49 
 21    50 
 21    51 dcl  rdi_ptr ptr int automatic init (null ());
 21    52 
 21    53 /* END mdbm_rm_domain_info.incl.pl1 */
 21    54 
 21    55 
     1113 
     1114 
 22     1 /* BEGIN mdbm_index.incl.pl1 -- jaw, 5/12/78 */
 22     2 
 22     3 dcl 1 index aligned based (ind_ptr),			/* layout of mdbm_index for all file types */
 22     4     2 rel_id bit (12) unal,				/* relation id */
 22     5     2 index_id bit (8) unal,				/* id of index within rel */
 22     6     2 mbz bit (7) unal,				/* pad to char. */
 22     7     2 index_val char (ind_val_len) unal;		/* index value; max 253 chars */
 22     8 
 22     9 dcl  ind_ptr ptr;
 22    10 dcl  ind_val_len fixed bin (35);
 22    11 
 22    12 /* END mdbm_index.incl.pl1 */
 22    13 
     1115 
     1116 
 23     1 /* BEGIN mdbm_rtrv_info.incl.pl1 -- jaw, 3/15/79 */
 23     2 
 23     3 /*
 23     4*   HISTORY
 23     5*
 23     6*   82-09-21 Davids: removed reference to the iocb_ind element which was the
 23     7*   index in the rm_rel_info.iocb_ptr array of the iocb to be used and added
 23     8*   the cursor_ptr element.
 23     9*   
 23    10*   82-10-1  Woodka: changed tid_array to be bit (36) aligned instead of 
 23    11*   bit (36) unaligned. 
 23    12*
 23    13*   82-10-22 Woodka : added first_seq_io bit and changed reserved to bit 32.
 23    14*
 23    15*   82-10-26 Davids: added the record_collection_cursor_ptr element. This is
 23    16*   needed because the relation manager get_tuple_by_id entry requires a 
 23    17*   record collection cursor.
 23    18*
 23    19*   83-05-03 Mike Kubicar : deleted the unused fields: thd_type, seq_io,
 23    20*   seed_id, link_io, free_array and thd_ptr.  Added the maxtids field.
 23    21*
 23    22*   83-05-31 Mike Kubicar : got rid of cursor_ptr and
 23    23*   record_collection_cursor_ptr.  Inserted the field relation_cursor_ptr.
 23    24*
 23    25**/
 23    26 
 23    27 dcl 1 rtrv_info aligned based (rti_ptr),		/* info needed to retrieve a tuple */
 23    28     2 ri_ptr ptr,					/* to rel_info */
 23    29     2 relation_cursor_ptr ptr,                              /* pointer to cursor to use */
 23    30     2 ntids fixed bin,				/* no of tuple ids in list */
 23    31     2 ctid fixed bin,				/* current position in list */
 23    32     2 maxtids fixed bin,				/* Maximum number of tids to search for */
 23    33     2 first_seq_io bit (1) unal,			/* on if first sequential i/o is to be done */
 23    34     2 reserved bit (35) unal,
 23    35     2 ta_ptr ptr;					/* to array of tuple ids */
 23    36 
 23    37 dcl  rti_ptr ptr;
 23    38 
 23    39 dcl  tid_array (ta_nids) bit (36) aligned  based (ta_ptr);	/* array of tuple ids */
 23    40 
 23    41 dcl  ta_nids fixed bin;
 23    42 dcl  ta_ptr ptr;
 23    43 
 23    44 /* END mdbm_rtrv_info.incl.pl1 */
 23    45 
     1117 
     1118 
 24     1 /* BEGIN mdbm_ind_sel_info.incl.pl1 -- jaw, 2/23/79 */
 24     2 
 24     3 /* 6-sep-79 Davids: key_bit_len added */
 24     4 
 24     5 dcl 1 ind_sel_info aligned based (isi_ptr),		/* info reqired for initind index range */
 24     6     2 op_code fixed bin,				/* comparison operator,
 24     7*						   1 => =
 24     8*						   2 => ^=
 24     9*						   3 => <
 24    10*						   4 => <=
 24    11*						   5 => >
 24    12*						   6 => >= */
 24    13     2 key char (256) var,
 24    14     2 key_bit_len fixed bin (35);			/* actual number of bits used in key */
 24    15 
 24    16 dcl  isi_ptr ptr;
 24    17 
 24    18 /* END mdbm_ind_sel_info.incl.pl1 */
 24    19 
 24    20 
     1119 
     1120 
 25     1 /* BEGIN mdbm_comp_val_list.incl.pl1 -- jaw, 2/23/79 */
 25     2 
 25     3 
 25     4 /****^  HISTORY COMMENTS:
 25     5*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
 25     6*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
 25     7*     This entry is being made to cover the change made on 85-10-13 by John
 25     8*     Hergert. (see mrds #138, phx19901)
 25     9*                                                   END HISTORY COMMENTS */
 25    10 
 25    11 /* HISTORY:
 25    12*   Modified by Al Kepner, June 22, 1979 to provide for comparing two
 25    13*   values from the same tuple.
 25    14*
 25    15*   82-10-12 Davids: changed rel_id from bit (12) to bit (36) aligned.
 25    16*
 25    17*   82-10-26 Woodka: deleted fields attr_pos_ind and attr_pos_ind2, 
 25    18*   no longer needed.
 25    19*
 25    20*   84-08-07 Thanh Nguyen: Added c_ai_ptr and c_ai_ptr2 (ptr for 
 25    21*   rm_attr_info).  These ptrs will be needed for checking of decoded proc
 25    22*   if we only have an attribute and exp_ptr is null.
 25    23*
 25    24*   85-10-13 John Hergert: removed c_ai_ptr for fixes for TRs phx19901
 25    25*   and phx11536. c_ai_ptr2 is now used as a flag to tell mu_retrieve
 25    26*   that the first comaparand is an expression and the second one should 
 25    27*   be decoded.
 25    28* */
 25    29 
 25    30 dcl 1 comp_val_list aligned based (cvl_ptr),		/* compar. list for hash search */
 25    31     2 nvals fixed bin,
 25    32     2 rel_id bit (36) aligned,			/* id of relation being searched */
 25    33     2 val (cvl_nvals_init refer (comp_val_list.nvals)),
 25    34       3 match_ptr ptr,				/* pointer to second comparison value
 25    35*						   when it is not in the current tuple
 25    36*						   or null (if both values are from the current tuple.) */
 25    37       3 exp_ptr ptr,				/* to expr to be evaluated, or null */
 25    38       3 exp_ptr2 ptr,				/* to expr to be evaluated, or null */
 25    39       3 c_ai_ptr2 ptr,                                      /* to rm_attr_info, and only be used when exp_ptr2 is not null. */
 25    40       3 erslt_ptr ptr,				/* to result of first expression */
 25    41       3 erslt_ptr2 ptr,				/* to result of second expression */
 25    42       3 op fixed bin,				/* 1 => =
 25    43*						   2 => ^=
 25    44*						   3 => <
 25    45*						   4 => <=
 25    46*						   5 => >
 25    47*						   6 => >= */
 25    48       3 desc1 bit (36),				/* descriptor for first comparison value */
 25    49       3 desc2 bit (36),				/* descriptor for second comparison value */
 25    50       3 attr_ind fixed bin,				/* attr. index for first value */
 25    51       3 attr_ind2 fixed bin,				/* attr. index for 2nd value in same tuple or 0 */
 25    52       3 pad bit (36);				/* fill to double word boundary. */
 25    53 
 25    54 dcl  cvl_ptr ptr int automatic init (null ());
 25    55 dcl  cvl_nvals_init fixed bin;
 25    56 
 25    57 dcl ((CVL_EQ init (1)),
 25    58     (CVL_NE init (2)),
 25    59     (CVL_LT init (3)),
 25    60     (CVL_LE init (4)),
 25    61     (CVL_GT init (5)),
 25    62     (CVL_GE init (6))) fixed bin int static options (constant);
 25    63 
 25    64 dcl 1 cvl_array aligned based (cvla_ptr),		/* array of lists */
 25    65     2 nlists fixed bin,
 25    66     2 list_ptr (cvla_nlists_init refer (cvl_array.nlists)) ptr;
 25    67 
 25    68 dcl  cvla_nlists_init fixed bin;
 25    69 dcl  cvla_ptr ptr int automatic init (null ());
 25    70 
 25    71 /* END mdbm_comp_val_list.incl.pl1 */
 25    72 
     1121 
     1122 
 26     1 /* BEGIN mdbm_descriptor.incl.pl1 -- jaw 5/31/78 */
 26     2 /* modified by Jim Gray - - Nov. 1979, to change type from fixed bin(5) to
 26     3*   unsigned fixed bin(6), so new packed decimal data types could be handled.
 26     4*   also the duplicate mrds_descriptor.incl.pl1 was eliminated. */
 26     5 
 26     6 dcl 1 descriptor based (desc_ptr),			/* map of Multics descriptor */
 26     7     2 version bit (1) unal,				/* DBM handles vers. 1 only */
 26     8     2 type unsigned fixed bin (6) unal,			/* data type */
 26     9     2 packed bit (1) unal,				/* on if data item is packed */
 26    10     2 number_dims bit (4) unal,			/* dimensions */
 26    11     2 size,					/* size for string data */
 26    12       3 scale bit (12) unal,				/* scale for num. data */
 26    13       3 precision bit (12) unal,			/* prec. for num. data */
 26    14     2 array_info (num_dims),
 26    15       3 lower_bound fixed bin (35),			/* lower bound of dimension */
 26    16       3 upper_bound fixed bin (35),			/* upper bound of dimension */
 26    17       3 multiplier fixed bin (35);			/*  element separation */
 26    18 
 26    19 dcl  desc_ptr ptr;
 26    20 dcl  num_dims fixed bin init (0) ;			/* more useful form of number_dims */
 26    21 
 26    22 /* END mdbm_descriptor.incl.pl1 */
 26    23 
 26    24 
     1123 
     1124 
 27     1 /* BEGIN INCLUDE FILE mdbm_seg_area.incl.pl1 - - Jim Gray 2/19/79 */
 27     2 
 27     3 /* these structures provide a standard for
 27     4*   1) using an entire segment as an area, managed by the area manager
 27     5*   2) a constant header, that has an offset to the major common structure in the area
 27     6*   the pointer to that structure is obtained via pointer(model_seg_ptr, model_seg.offset)
 27     7*   the model_area_ptr is obtained via pointer(model_seg_ptr, size(model_seg)) */
 27     8 
 27     9 declare 1 model_seg aligned based (model_seg_ptr),	/* segment header, not to be changed */
 27    10         2 struct_offset bit (18),			/* offset to major structure allocated in area */
 27    11         2 padding (3) fixed bin ;			/* to set up four word boundary */
 27    12 
 27    13 declare  model_seg_ptr ptr int automatic init (null ());
 27    14 
 27    15 
 27    16 declare  model_area area (sys_info$max_seg_size - size (model_seg)) based (model_area_ptr) ; /* segment area */
 27    17 
 27    18 declare  model_area_ptr ptr int automatic init (null ());
 27    19 
 27    20 dcl size builtin;
 27    21 
 27    22 /* END INCLUDE FILE mdbm_seg_area.incl.pl1 */
 27    23 
     1125 
     1126 
 28     1 /* BEGIN INCLUDE FILE mrds_select_area.incl.pl1   (Kepner Multics)  05/29/79 1736.1 mst Tue */
 28     2 dcl 1 select_area_struct aligned based (select_area_struct_ptr), /* major structure in segment for current selection expression allocations */
 28     3     2 version fixed bin,
 28     4     2 dbcb_ptr ptr;					/* ptr ptr to dbcb */
 28     5 
 28     6 dcl  select_area_struct_ptr ptr int automatic init (null ());
 28     7 
 28     8 dcl  select_area area (sys_info$max_seg_size - size(model_seg)) based (select_area_ptr);
 28     9 
 28    10 dcl  select_area_ptr ptr int automatic init (null ());
 28    11 						/*   END INCLUDE FILE mrds_select_area.incl.pl1 */
 28    12 
     1127 
     1128 
 29     1 /* BEGIN INCLUDE FILE mrds_debug_names.incl.pl1     Jim Gray 8/7/79 */
 29     2 
 29     3 /* this include file associates module names with debug switches
 29     4*   that are stored in the data segment mrds_debug_
 29     5*   each module has it's own bit(9) debug switch, to define for various
 29     6*   debug actions, with new module names to be added to the end
 29     7*   of this list using the next in order array index in mrds_debug_
 29     8*   the convention for naming is db_{module's full name}
 29     9*   for the defined declaration over mrds_debug_$switch.
 29    10*   module.name array is then changed to reflect the new
 29    11*   number of modules, with the full module name added to the bottom
 29    12*   of the initialize list for the name array.
 29    13*   the module name array is used by the command level interface that sets/resets
 29    14*   the current status of the debug switches for each module.
 29    15*   the modules themselves use the db_{module name} declared variable for
 29    16*   that module to interagate the bits for proper debug action to take.
 29    17*   the definition of the meaning of the 9-bits is up to each individual module's
 29    18*   designer. */
 29    19 
 29    20 
 29    21 /*
 29    22*   HISTORY
 29    23*
 29    24*   80-11-12 Davids: added db_mus_mod_ubtup
 29    25*
 29    26*   80-11-13 Davids: added db_mu_sec_get_tuple and db_mu_sec_get_tid
 29    27*
 29    28*   80-12-15 Jim Gray :  added  mrds_dsl_set_fscope  to  display  non
 29    29*   error  info  about  being queued, and request being granted after
 29    30*   being queued.
 29    31*
 29    32*   81-01-15 Jim Gray : added  mu_concurrency_control  bit  to  allow
 29    33*   running  MR8  and  MR9 mrds against the same database at the same
 29    34*   time.
 29    35*
 29    36*   81-02-02  Jim  Gray  :  added  bit  for  mrds_rst_dmdm  to  allow
 29    37*   displaying internal tuple format bit offset, rather than the user
 29    38*   view.
 29    39*
 29    40*   81-02-06 Jim Gray : added bit for  new  mu_open_name_manager,  to
 29    41*   dump  an  element  from  the  list, when display_open_names entry
 29    42*   called with switch set.
 29    43*
 29    44*   81-05-20 Jim Gray : added bit for  mrds_dsl_where_clause  display
 29    45*   of sub_err_ messages, when cross domain compare occurs.
 29    46*
 29    47*   81-06-17 Jim Gray : added bit for mu_open_iocb_manager to display
 29    48*   iocb slot and rel name.
 29    49*
 29    50*   81-07-08 Jim Gray : added comment for bit 4 in mrds_dsl_permute
 29    51*
 29    52*   81-07-17 Jim Gray : added comment for bit 5 in mrds_dsl_permute
 29    53*
 29    54*   81-07-18 Jim Gray : added bit 1 for  mrds_dsl_gen_srch_prog  that
 29    55*   allows  key  searches, other than than specified by permute to be
 29    56*   done as comparisons instead.
 29    57*
 29    58*   81-07-22  Jim   Gray   :   added   comment   about   bit   2   in
 29    59*   mrds_dsl_gen_srch_prog
 29    60**/
 29    61 
 29    62 declare (
 29    63          db_mrds_dsl_eval_expr bit (9) unal defined (mrds_debug_$switch (1)),
 29    64          db_mrds_dsl_get_token bit (9) unal defined (mrds_debug_$switch (2)),
 29    65          db_mrds_dsl_permute bit (9) unal defined (mrds_debug_$switch (3)),
 29    66          db_mrds_dsl_optimize bit (9) unal defined (mrds_debug_$switch (4)),
 29    67          db_mrds_dsl_search bit (9) unal defined (mrds_debug_$switch (5)),
 29    68          db_mrds_dsl_translate bit (9) unal defined (mrds_debug_$switch (6)),
 29    69          db_mu_retrieve bit (9) unal defined (mrds_debug_$switch (7)),
 29    70          db_mrds_dsl_open bit (9) unal defined (mrds_debug_$switch (8)),
 29    71          db_mrds_dsl_close bit (9) unal defined (mrds_debug_$switch (9)),
 29    72          db_mrds_dsl_init_res bit (9) unal defined (mrds_debug_$switch (10)),
 29    73          db_mu_sec_init_res bit (9) unal defined (mrds_debug_$switch (11)),
 29    74          db_mus_mod_ubtup bit (9) unal defined (mrds_debug_$switch (12)),
 29    75          db_mu_sec_get_tuple bit (9) unal defined (mrds_debug_$switch (13)),
 29    76          db_mu_sec_get_tid bit (9) unal defined (mrds_debug_$switch (14)),
 29    77          db_mrds_dsl_set_fscope bit (9) unal defined (mrds_debug_$switch (15)),
 29    78          db_mu_concurrency_control bit (9) unal defined (mrds_debug_$switch (16)),
 29    79          db_mrds_rst_dmdm bit (9) unal defined (mrds_debug_$switch (17)),
 29    80          db_mu_open_name_manager bit (9) unal defined (mrds_debug_$switch (18)),
 29    81          db_mrds_dsl_where_clause bit (9) unal defined (mrds_debug_$switch (19)),
 29    82          db_mu_open_iocb_manager bit (9) unal defined (mrds_debug_$switch (20)),
 29    83          db_mrds_dsl_gen_srch_prog bit (9) unal defined (mrds_debug_$switch (21))
 29    84          ) ;
 29    85 
 29    86 /* list of known module names, with index into name array
 29    87*   the same as that into mrds_debug_$switch,
 29    88*   number is the current count of defined module names,
 29    89*   name is the modules full name. */
 29    90 
 29    91 declare 1 module options (constant) internal static,
 29    92         2 number fixed bin init (21),
 29    93         2 name char (32) dimension (21) init (
 29    94          "mrds_dsl_eval_expr",			/* 1 => display value of each expression */
 29    95          "mrds_dsl_get_token",			/* 1 => display the current token */
 29    96          "mrds_dsl_permute",				/* each 1 => lost cost path found,
 29    97*						   2 => reverse partial path
 29    98*						   3 => use range order for path
 29    99*						   4 => display access method costs
 29   100*						   5 => display details of final low cost path */
 29   101          "mrds_dsl_optimize",				/* 1 => pred tree,
 29   102*						   2 => paths to consider, 3 => calc_cost on */
 29   103          "mrds_dsl_search",				/* 1 => display each tuple located */
 29   104          "mrds_dsl_translate",			/* 1 => display the search program */
 29   105          "mu_retrieve",				/* 1 => display values compared, 2 => display tuple data */
 29   106          "mrds_dsl_open",				/* 1 => allow cleanup sub_error_ */
 29   107          "mrds_dsl_close",				/* 1 => allow cleanup sub_error_ */
 29   108          "mrds_dsl_init_res",				/* 1 => allow cleanup sub_error_ */
 29   109          "mu_sec_init_res",				/* 1 => allow cleanup sub_error_ */
 29   110          "mus_mod_ubtup",				/* 1 => consistency checking between the old
 29   111*						   and new tuple during modifies will be done */
 29   112          "mu_sec_get_tuple",				/* 1 => attribute values
 29   113*						   will be zeroed in the tuple structure
 29   114*						   is don't have read permission. */
 29   115          "mu_sec_get_tid",				/* 1 => read permission to the key
 29   116*						   is checked (if db is secured) */
 29   117          "mrds_dsl_set_fscope",			/* 1 => display being queued,
 29   118*						   and request granted from queue messages */
 29   119          "mu_concurrency_control",			/* 1 => allow both dbc and db.control segs under db
 29   120*						   so can test both MR8 and MR9 mrds
 29   121*						   against the same database at the same time */
 29   122          "mrds_rst_dmdm",				/* 1 => allow internal form of bit offset value
 29   123*						   for attributes to be displayed, rather than user view */
 29   124          "mu_open_name_manager",			/* 1 => dump mrds_open_name tree node structure,
 29   125*						   when display_open_names entry called */
 29   126          "mrds_dsl_where_clause",			/* 1 => display details of cross domain compares */
 29   127          "mu_open_iocb_manager",			/* 1 => display relation and slot getting iocb for */
 29   128          "mrds_dsl_gen_srch_prog"			/* 1 => do additional conditions as sequential, not key searches
 29   129*						   when the original access was a key,
 29   130*						   and the additional conditions can be done as key also
 29   131*						   2 => force key searches, regardless of strategy
 29   132*						   used to decide between compare or key search */
 29   133          ) ;
 29   134 
 29   135 declare  mrds_debug_$switch (1:400) bit (9) unal ext ;	/* data segment debug array */
 29   136 
 29   137 /* END INCLUDE FILE mrds_debug_names.incl.pl1 */
 29   138 
     1129 
     1130 
     1131      end mrds_dsl_gen_srch_prog;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/01/88  1300.0  mrds_dsl_gen_srch_prog.pl1        >special_ldd>install>MR12.2-1073>mrds_dsl_gen_srch_prog.pl1
1073         1    04/18/85  1628.1  mdbm_scope_info.incl.pl1          >ldd>include>mdbm_scope_info.incl.pl1
1075         2    03/06/85  1031.5  dm_element_id_list.incl.pl1       >ldd>include>dm_element_id_list.incl.pl1
1077         3    10/14/83  1609.1  dm_operator_constants.incl.pl1    >ldd>include>dm_operator_constants.incl.pl1
1079         4    10/14/83  1609.1  dm_range_constants.incl.pl1       >ldd>include>dm_range_constants.incl.pl1
1081         5    10/14/83  1609.1  dm_relation_spec.incl.pl1         >ldd>include>dm_relation_spec.incl.pl1
1083         6    10/14/83  1609.1  dm_specification_head.incl.pl1    >ldd>include>dm_specification_head.incl.pl1
1085         7    10/14/83  1609.1  vu_typed_vector.incl.pl1          >ldd>include>vu_typed_vector.incl.pl1
1087         8    10/14/83  1609.1  dm_id_list.incl.pl1               >ldd>include>dm_id_list.incl.pl1
1089         9    08/01/88  1300.0  mrds_dbcb.incl.pl1                >special_ldd>install>MR12.2-1073>mrds_dbcb.incl.pl1
1091        10    10/14/83  1608.9  mrds_predicate_tree.incl.pl1      >ldd>include>mrds_predicate_tree.incl.pl1
1093        11    10/14/83  1609.1  mrds_optimize_tables.incl.pl1     >ldd>include>mrds_optimize_tables.incl.pl1
1095        12    10/14/83  1609.1  mrds_search_ops.incl.pl1          >ldd>include>mrds_search_ops.incl.pl1
1097        13    10/14/83  1608.9  mrds_search_vars.incl.pl1         >ldd>include>mrds_search_vars.incl.pl1
1099        14    10/14/83  1609.1  mrds_range.incl.pl1               >ldd>include>mrds_range.incl.pl1
1101        15    10/14/83  1609.0  mrds_tuple_info.incl.pl1          >ldd>include>mrds_tuple_info.incl.pl1
1103        16    10/14/83  1609.1  mrds_lit_info.incl.pl1            >ldd>include>mrds_lit_info.incl.pl1
1105        17    10/14/83  1608.9  mrds_expressions.incl.pl1         >ldd>include>mrds_expressions.incl.pl1
1107        18    08/01/88  1310.7  mdbm_rm_db_info.incl.pl1          >special_ldd>install>MR12.2-1073>mdbm_rm_db_info.incl.pl1
1109        19    10/14/83  1609.1  mdbm_rm_rel_info.incl.pl1         >ldd>include>mdbm_rm_rel_info.incl.pl1
1111        20    10/14/83  1609.1  mdbm_rm_attr_info.incl.pl1        >ldd>include>mdbm_rm_attr_info.incl.pl1
1113        21    10/14/83  1609.1  mdbm_rm_domain_info.incl.pl1      >ldd>include>mdbm_rm_domain_info.incl.pl1
1115        22    10/14/83  1608.3  mdbm_index.incl.pl1               >ldd>include>mdbm_index.incl.pl1
1117        23    10/14/83  1609.1  mdbm_rtrv_info.incl.pl1           >ldd>include>mdbm_rtrv_info.incl.pl1
1119        24    10/14/83  1608.6  mdbm_ind_sel_info.incl.pl1        >ldd>include>mdbm_ind_sel_info.incl.pl1
1121        25    02/05/86  1416.4  mdbm_comp_val_list.incl.pl1       >ldd>include>mdbm_comp_val_list.incl.pl1
1123        26    10/14/83  1608.6  mdbm_descriptor.incl.pl1          >ldd>include>mdbm_descriptor.incl.pl1
1125        27    10/14/83  1608.6  mdbm_seg_area.incl.pl1            >ldd>include>mdbm_seg_area.incl.pl1
1127        28    10/14/83  1608.6  mrds_select_area.incl.pl1         >ldd>include>mrds_select_area.incl.pl1
1129        29    10/14/83  1609.0  mrds_debug_names.incl.pl1         >ldd>include>mrds_debug_names.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
                                       constant        fixed bin(17,0)          initial dcl 6-22 ref 652
ATTR                                   constant        fixed bin(17,0)          initial dcl 10-56 ref 570
CONST                                  constant        fixed bin(17,0)          initial dcl 10-56 ref 568 613
ELEMENT_ID_LIST_VERSION_1       000204 automatic       fixed bin(35,0)          initial dcl 2-28 set ref 386 2-28*
EQUAL_OPERATOR_CODE                    constant        fixed bin(17,0)          initial dcl 3-13 ref 592
EXPRES                                 constant        fixed bin(17,0)          initial dcl 10-56 ref 565
GREATER_OPERATOR_CODE                  constant        fixed bin(17,0)          initial dcl 3-13 ref 604
GREATER_OR_EQUAL_OPERATOR_CODE         constant        fixed bin(17,0)          initial dcl 3-13 ref 607
ID_LIST_VERSION_1                      constant        fixed bin(17,0)          initial dcl 8-23 ref 953
INIT                                   constant        fixed bin(17,0)          initial dcl 12-85 ref 397
LESS_OPERATOR_CODE                     constant        fixed bin(17,0)          initial dcl 3-13 ref 598
LESS_OR_EQUAL_OPERATOR_CODE            constant        fixed bin(17,0)          initial dcl 3-13 ref 601
LOW_RANGE_TYPE                         constant        fixed bin(17,0)          initial dcl 4-8 ref 661
MODULE_NAME                     000166 automatic       char(22)                 initial packed unaligned dcl 1059 set ref 573* 610*
                                                                                  1059*
MOVE                                   constant        fixed bin(17,0)          initial dcl 12-85 ref 396
NOT_EQUAL_OPERATOR_CODE                constant        fixed bin(17,0)          initial dcl 3-13 ref 595
OTT_EQ                                 constant        fixed bin(17,0)          initial dcl 11-174 ref 592
OTT_GE                                 constant        fixed bin(17,0)          initial dcl 11-174 ref 607
OTT_GT                                 constant        fixed bin(17,0)          initial dcl 11-174 ref 604
OTT_LE                                 constant        fixed bin(17,0)          initial dcl 11-174 ref 601
OTT_LT                                 constant        fixed bin(17,0)          initial dcl 11-174 ref 598
OTT_NE                                 constant        fixed bin(17,0)          initial dcl 11-174 ref 595
PICKUP_SVP                             constant        fixed bin(17,0)          initial dcl 12-85 ref 341
RETNUL                                 constant        fixed bin(17,0)          initial dcl 12-85 ref 473
RETVAL                                 constant        fixed bin(17,0)          initial dcl 12-85 ref 472
SEL                                    constant        fixed bin(17,0)          initial dcl 12-85 ref 398
SIMPLE_TYPED_VECTOR_TYPE               constant        fixed bin(17,0)          initial dcl 7-43 ref 968
SPECIFICATION_VERSION_4                constant        fixed bin(35,0)          initial dcl 6-19 ref 651
access_method             7            based           fixed bin(17,0)          level 2 dcl 11-73 ref 414
addr                                                   builtin function         dcl 1050 ref 420 428 526 888 888 891 891 930 930
addrel                                                 builtin function         dcl 1050 ref 382
ai_ptr                   14            based           pointer                  level 2 dcl 10-67 set ref 570 619* 775* 778 833 836
aip_ptr                         000112 automatic       pointer                  dcl 1008 set ref 420* 428*
alp                             000230 automatic       pointer                  dcl 11-143 in procedure "mrds_dsl_gen_srch_prog" set
                                                                                  ref 361* 555 557 559 635 705 707 708 710 714
alp                      16            based           pointer                  level 2 in structure "path_var" dcl 11-73
                                                                                  in procedure "mrds_dsl_gen_srch_prog" ref 361
and_group                10            based           structure                array level 2 dcl 5-9
append_tuple              1(01)        based           bit(1)                   level 3 packed packed unaligned dcl 1041 ref 372
attr                                   based           bit(1)                   array level 4 packed packed unaligned dcl 14-5 ref
                                                                                  958 973
attr_desc                       000314 automatic       bit(36)                  dcl 494 set ref 561* 576
attr_id                   1(18)        based           bit(18)                  level 3 packed packed unaligned dcl 10-67 ref 782
                                                                                  803
attr_ind                 21            based           fixed bin(17,0)          array level 3 dcl 25-30 set ref 714*
attr_ind2                22            based           fixed bin(17,0)          array level 3 dcl 25-30 set ref 782* 803*
attr_index               14            based           fixed bin(17,0)          level 2 dcl 11-73 ref 427 444
attr_list                              based           structure                level 1 dcl 11-135
attr_ptrs                              based           pointer                  array level 2 dcl 19-119 ref 444 559 710
attr_rai_ptr                    000316 automatic       pointer                  dcl 495 set ref 559* 560 590
attr_rdi_ptr                    000320 automatic       pointer                  dcl 496 set ref 560* 561
bit36a                                 based           bit(36)                  dcl 1058 ref 568 770 790 820
bit_length               24            based           fixed bin(35,0)          level 2 dcl 20-46 ref 895
bit_move                               based           bit(1)                   level 2 packed packed unaligned dcl 12-98 set ref
                                                                                  891* 893
bv_idl_ptr                      000440 automatic       pointer                  dcl 988 set ref 944* 948 961
bv_ri_ptr                       000444 automatic       pointer                  dcl 990 set ref 943* 944 951
bv_stv_ptr                      000442 automatic       pointer                  dcl 989 set ref 942* 947 976
c_ai_ptr2                10            based           pointer                  array level 3 dcl 25-30 set ref 762* 836*
cd                                     parameter       fixed bin(35,0)          dcl 1000 ref 996 1002
code                                   parameter       fixed bin(35,0)          dcl 1015 in procedure "mrds_dsl_gen_srch_prog" set
                                                                                  ref 34 485* 1002*
code                      2            based           fixed bin(17,0)          array level 3 in structure "search_ops" dcl 12-66
                                                                                  in procedure "mrds_dsl_gen_srch_prog" set ref 341*
                                                                                  396* 397* 398* 472* 473*
collection_id_supplied
                         11            based           bit(1)                   array level 4 packed packed unaligned dcl 5-9 set
                                                                                  ref 665*
collection_index                000176 automatic       bit(36)                  dcl 1065 set ref 421* 429* 436* 444* 449* 458* 668
comp_val_list                          based           structure                level 1 dcl 25-30 set ref 847
compare_within_tuple            000175 automatic       bit(1)                   packed unaligned dcl 1063 in procedure
                                                                                  "mrds_dsl_gen_srch_prog" set ref 721* 723* 741*
                                                                                  742*
compare_within_tuple                   parameter       bit(1)                   packed unaligned dcl 752 in procedure
                                                                                  "complete_comparison_item" ref 748 764
comparison_var_id               000174 automatic       fixed bin(17,0)          dcl 1062 set ref 720* 721 740* 741
cond                                   based           structure                level 1 dcl 11-146
cond_ptr                  4            based           pointer                  array level 3 dcl 11-135 set ref 557 635* 707 708
condp                           000232 automatic       pointer                  dcl 11-153 set ref 557* 557* 562 581 592 595 598 601
                                                                                  604 607 635 637* 639 708* 708* 715 719* 724
const                           000131 automatic       bit(12)                  initial level 2 packed packed unaligned dcl 1028 set
                                                                                  ref 1028*
constraint               12            based           structure                array level 3 dcl 5-9 set ref 682*
constraint_entry                       based           structure                level 1 unaligned dcl 498 set ref 589
constraint_entry_ptr            000322 automatic       pointer                  dcl 506 set ref 589* 590 592 595 598 601 604 607 613
                                                                                  621 624 625 628 630 670* 682 684* 684
constraint_info           2            based           structure                level 2 unaligned dcl 498 set ref 682
constraint_list                 000324 automatic       structure                level 1 unaligned dcl 508
count                           000126 automatic       fixed bin(17,0)          dcl 1018 set ref 529* 531* 580* 580 691 699
create_cursor           156            based           entry variable           level 4 dcl 9-142 set ref 458*
ctid                                   based           fixed bin(17,0)          array level 3 dcl 13-3 set ref 366*
cur_ii_ptr                      000104 automatic       pointer                  dcl 1008 set ref 408*
cur_mi_ptr                      000106 automatic       pointer                  dcl 1008 set ref 408* 866 868 873*
current_max_tids_per_call       000177 automatic       fixed bin(35,0)          dcl 1071 set ref 368* 372* 380 382 662
current_scope_ptr               000164 automatic       pointer                  dcl 1042 set ref 371* 372 372 372 372 372 372
current_scopes_flags                   based           structure                level 1 dcl 1041
cursor_ptrs_storage_ptr
                        130            based           pointer                  level 3 dcl 9-142 set ref 458*
cursor_storage_area_ptr
                        132            based           pointer                  level 3 dcl 9-142 set ref 458*
cvl_array                              based           structure                level 1 dcl 25-64 set ref 696
cvl_nvals_init                  000266 automatic       fixed bin(17,0)          dcl 25-55 set ref 699* 847 847 850
cvl_ptr                         000264 automatic       pointer                  initial dcl 25-54 set ref 25-54* 701 703 714 715 716
                                                                                  716 718 734 735 736 737 762 768 770 776 781 782
                                                                                  788 790 803 820 821 822 836 837 839 847* 849 851
                                                                                  851 851 851 851
cvla_nlists_init                000267 automatic       fixed bin(17,0)          dcl 25-68 set ref 695* 696 696
cvla_ptr                        000270 automatic       pointer                  initial dcl 25-69 in procedure
                                                                                  "mrds_dsl_gen_srch_prog" set ref 25-69* 696* 698
                                                                                  701
cvla_ptr                  6            based           pointer                  level 2 in structure "select_info" dcl 12-129
                                                                                  in procedure "mrds_dsl_gen_srch_prog" set ref 691*
                                                                                  698*
data                                   based           structure                level 2 dcl 9-142
data_type                 3            based           fixed bin(17,0)          level 2 in structure "pred_leaf" dcl 10-67
                                                                                  in procedure "mrds_dsl_gen_srch_prog" set ref 564
                                                                                  723* 742*
data_type                              parameter       fixed bin(17,0)          dcl 749 in procedure "complete_comparison_item" ref
                                                                                  748 765 795
db_desc                  10            based           bit(36)                  level 2 dcl 21-35 set ref 561 570 718 781 839 888
                                                                                  888 891 891 896
dbcb                                   based           structure                level 1 dcl 9-142
dbcb_data                              based           structure                level 1 unaligned dcl 9-148
dbcb_ptr                               parameter       pointer                  dcl 9-146 set ref 34 312 317 318 323 325 326 355 458
                                                                                  458 458 458 458 930*
dbi                     114            based           fixed bin(35,0)          level 3 dcl 9-142 set ref 458*
defn_order               22            based           fixed bin(17,0)          level 2 dcl 20-46 ref 898
delete_tuple              0(02)        based           bit(1)                   level 3 in structure "current_scopes_flags" packed
                                                                                  packed unaligned dcl 1041 in procedure
                                                                                  "mrds_dsl_gen_srch_prog" ref 372
delete_tuple              1(02)        based           bit(1)                   level 3 in structure "current_scopes_flags" packed
                                                                                  packed unaligned dcl 1041 in procedure
                                                                                  "mrds_dsl_gen_srch_prog" ref 372
desc1                    17            based           bit(36)                  array level 3 dcl 25-30 set ref 718* 737*
desc2                    20            based           bit(36)                  array level 3 dcl 25-30 set ref 770* 781* 790* 820*
                                                                                  837* 839*
dimension                 1            based           structure                array level 2 packed packed unaligned dcl 7-17
domain_ptr               26            based           pointer                  level 2 dcl 20-46 ref 560 570 711 779 834 886 891
                                                                                  891
ed                              000131 automatic       structure                level 1 dcl 1028
element_id_list                        based           structure                level 1 dcl 2-21
element_id_list_ptr             000202 automatic       pointer                  dcl 2-26 set ref 385* 386 387
element_id_list_segment_ptr
                         64            based           pointer                  level 3 dcl 9-142 ref 355
elp                      20            based           pointer                  level 2 in structure "path_var" dcl 11-73
                                                                                  in procedure "mrds_dsl_gen_srch_prog" ref 362
elp                             000234 automatic       pointer                  dcl 11-163 in procedure "mrds_dsl_gen_srch_prog" set
                                                                                  ref 362* 529 529 728 728 732 734 739
encd_blen                20     000140 automatic       fixed bin(35,0)          level 2 dcl 1040 set ref 929*
encd_proc                10     000140 automatic       bit(1)                   level 2 packed packed unaligned dcl 1040 set ref
                                                                                  924*
encdd_ptr                12     000140 automatic       pointer                  level 2 dcl 1040 set ref 925*
ep                                     parameter       pointer                  dcl 905 ref 901 911
epl_ptr                   2            based           pointer                  array level 3 dcl 11-155 ref 732
err_xfer                  5            based           fixed bin(17,0)          array level 3 dcl 12-66 set ref 345* 405* 406* 407*
                                                                                  474* 474*
erslt_ptr                12            based           pointer                  array level 3 dcl 25-30 set ref 716* 736* 851*
erslt_ptr2               14            based           pointer                  array level 3 dcl 25-30 set ref 822* 851*
exp_ptr                   4            based           pointer                  array level 3 dcl 25-30 set ref 716* 735* 851*
exp_ptr2                  6            based           pointer                  array level 3 dcl 25-30 set ref 821* 851*
expr                      0(03)        based           bit(1)                   level 2 packed packed unaligned dcl 12-98 set ref
                                                                                  910*
expr_caller_sw                         parameter       bit(1)                   packed unaligned dcl 754 set ref 748 804*
expr_list                              based           structure                level 1 dcl 11-155
expr_ptr                 16            based           pointer                  level 2 dcl 10-67 set ref 735 786* 821
expr_sw                                parameter       bit(1)                   packed unaligned dcl 827 ref 825 835
expression                      000330 automatic       bit(1)                   packed unaligned dcl 512 set ref 533* 723 742*
extr_attr                 0(05)        based           bit(1)                   level 2 packed packed unaligned dcl 12-98 set ref
                                                                                  890*
field_id                  2            based           fixed bin(17,0)          level 3 dcl 498 set ref 590*
file_type                40            based           fixed bin(17,0)          level 2 dcl 19-119 ref 369
fixed                                                  builtin function         dcl 1050 ref 563 720 740 775 775 782 786 786 786 803
flags                    11            based           structure                array level 3 in structure
                                                                                  "relation_search_specification" packed packed
                                                                                  unaligned dcl 5-9 in procedure
                                                                                  "mrds_dsl_gen_srch_prog"
flags                     5            based           structure                level 2 in structure "relation_search_specification"
                                                                                  packed packed unaligned dcl 5-9 in procedure
                                                                                  "mrds_dsl_gen_srch_prog"
fwd_thd                  16            based           pointer                  level 2 in structure "move_info" dcl 12-98
                                                                                  in procedure "mrds_dsl_gen_srch_prog" set ref 868*
                                                                                  870*
fwd_thd                  22            based           pointer                  level 2 in structure "path_var" dcl 11-73
                                                                                  in procedure "mrds_dsl_gen_srch_prog" ref 353
fwd_thd                   4            based           pointer                  level 2 in structure "cond" dcl 11-146 in procedure
                                                                                  "mrds_dsl_gen_srch_prog" set ref 635 637* 637 639
                                                                                  724
good_xfer                 4            based           fixed bin(17,0)          array level 3 dcl 12-66 set ref 344* 402* 402* 402*
                                                                                  474* 479*
head                                   based           structure                level 2 dcl 5-9
head_of_list              2     000324 automatic       pointer                  level 2 dcl 508 set ref 528* 628 630* 670
i                               000115 automatic       fixed bin(17,0)          dcl 1018 in procedure "mrds_dsl_gen_srch_prog" set
                                                                                  ref 347* 351* 351 352 354 357* 359*
i                               000446 automatic       fixed bin(17,0)          dcl 991 in procedure "build_vectors" set ref 941*
                                                                                  942 943 945 947 948 954 958 969 973 982*
i                               000376 automatic       fixed bin(17,0)          dcl 857 in procedure "alloc_comp_val_list" set ref
                                                                                  850* 851 851 851 851*
ic                                     based           fixed bin(17,0)          level 2 dcl 12-66 set ref 338*
icode                           000114 automatic       fixed bin(35,0)          dcl 1015 set ref 458* 462 462* 930* 931 931*
id                        1            based           structure                level 2 in structure "pred_leaf" packed packed
                                                                                  unaligned dcl 10-67 in procedure
                                                                                  "mrds_dsl_gen_srch_prog"
id                        2            based           fixed bin(17,0)          array level 2 in structure "id_list" dcl 8-16
                                                                                  in procedure "mrds_dsl_gen_srch_prog" set ref 961*
                                                                                  961
id_list                                based           structure                level 1 dcl 8-16 set ref 952
id_list_ptr                     000220 automatic       pointer                  initial dcl 8-21 in procedure
                                                                                  "mrds_dsl_gen_srch_prog" set ref 8-21* 952* 953
                                                                                  954 956 960 960 961 961 964 966
id_list_ptr                            based           pointer                  level 2 in structure "rm_rel_info" dcl 19-119
                                                                                  in procedure "mrds_dsl_gen_srch_prog" ref 944
idl_ptr                                based           pointer                  array level 3 dcl 14-5 set ref 948* 954*
ii                              000120 automatic       fixed bin(17,0)          dcl 1018 set ref 392* 397 399 402 406 408
il_number_of_ids                000222 automatic       fixed bin(17,0)          initial dcl 8-22 set ref 8-22* 951* 952 952 957 972
in_and_group              1            based           bit(1)                   level 2 packed packed unaligned dcl 11-73 ref 389
in_select_clause          2            based           bit(1)                   level 2 dcl 11-73 ref 389
index                     3            based           fixed bin(17,0)          array level 3 dcl 11-135 ref 559 710 714
index_id                 21            based           bit(36)                  level 2 dcl 20-46 ref 444
info                      2            based           structure                array level 2 in structure "attr_list" dcl 11-135
                                                                                  in procedure "mrds_dsl_gen_srch_prog"
info                      2            based           structure                array level 2 in structure "expr_list" dcl 11-155
                                                                                  in procedure "mrds_dsl_gen_srch_prog"
info                                   based           structure                array level 2 in structure "search_vars" dcl 13-3
                                                                                  in procedure "mrds_dsl_gen_srch_prog"
info_ptr                  6            based           pointer                  array level 3 dcl 12-66 set ref 342* 408* 408* 408*
                                                                                  480* 480* 524* 866*
j                               000116 automatic       fixed bin(17,0)          dcl 1018 set ref 417* 427* 435* 443*
k                               000447 automatic       fixed bin(17,0)          dcl 992 in procedure "build_vectors" set ref 957*
                                                                                  958 961* 972* 973 976*
k                               000331 automatic       fixed bin(17,0)          dcl 513 in procedure "build_select_op" set ref 555*
                                                                                  557 559 635* 681* 682 682 682 682 682* 705* 707
                                                                                  708 710 714* 728* 732 734 739*
key_attr_ptrs            44            based           pointer                  array level 2 dcl 19-119 set ref 420 428
last_cond_ptr                   000332 automatic       pointer                  dcl 514 set ref 556* 581* 635 637
lbl                                    parameter       fixed bin(35,0)          dcl 921 set ref 917 932*
ldp                                    parameter       pointer                  dcl 922 ref 917 928
li                              000140 automatic       structure                level 1 dcl 1040 set ref 930 930
list_ptr                  2            based           pointer                  array level 2 dcl 25-64 set ref 701*
lit_blen                 21     000140 automatic       fixed bin(35,0)          level 2 dcl 1040 set ref 932
lit_desc_ptr             12            based           pointer                  level 2 dcl 10-67 ref 568 770 790 820
lit_info                               based           structure                level 1 dcl 16-15
lit_ptr                  16     000140 automatic       pointer                  level 2 in structure "li" dcl 1040 in procedure
                                                                                  "mrds_dsl_gen_srch_prog" set ref 933
lit_ptr                  10            based           pointer                  level 2 in structure "pred_leaf" dcl 10-67
                                                                                  in procedure "mrds_dsl_gen_srch_prog" ref 613 736
                                                                                  768 788 822
litd_ptr                 14     000140 automatic       pointer                  level 2 dcl 1040 set ref 928*
lp                                     parameter       pointer                  dcl 922 set ref 917 933*
match_ptr                 2            based           pointer                  array level 3 dcl 25-30 set ref 768* 776* 788* 851*
max_pv                          000130 automatic       fixed bin(17,0)          dcl 1018 set ref 354* 357
maximum_number_of_constraints
                          4            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 5-9 set ref 650*
                                                                                  655* 663 663 665 665 667 667 668 668 682 682 682
                                                                                  682 682 682 682 682 682 682
maxtids                                based           fixed bin(17,0)          array level 3 dcl 13-3 set ref 380*
mbz                       7            based           bit(18)                  level 3 in structure "constraint_entry" packed
                                                                                  packed unaligned dcl 498 in procedure
                                                                                  "build_select_op" set ref 625*
mbz                       5(01)        based           bit(35)                  level 3 in structure "relation_search_specification"
                                                                                  packed packed unaligned dcl 5-9 in procedure
                                                                                  "mrds_dsl_gen_srch_prog" set ref 660*
mbz                      11(01)        based           bit(17)                  array level 4 in structure
                                                                                  "relation_search_specification" packed packed
                                                                                  unaligned dcl 5-9 in procedure
                                                                                  "mrds_dsl_gen_srch_prog" set ref 667*
mi                              000121 automatic       fixed bin(17,0)          dcl 1018 set ref 391* 396 399 402 405 408 866
mi_ptr                          000240 automatic       pointer                  dcl 12-120 set ref 621 776 864* 866 868 869 870 871
                                                                                  871 873 888 888 890 891 893 893 894 895 896 897
                                                                                  898 910 911 912 913
model_area_ptr                  000276 automatic       pointer                  initial dcl 27-18 set ref 27-18*
model_defn_order         31            based           fixed bin(17,0)          level 2 dcl 20-46 ref 590
model_seg_ptr                   000274 automatic       pointer                  initial dcl 27-13 set ref 27-13*
modify_attr               0(03)        based           bit(1)                   level 3 in structure "current_scopes_flags" packed
                                                                                  packed unaligned dcl 1041 in procedure
                                                                                  "mrds_dsl_gen_srch_prog" ref 372
modify_attr               1(03)        based           bit(1)                   level 3 in structure "current_scopes_flags" packed
                                                                                  packed unaligned dcl 1041 in procedure
                                                                                  "mrds_dsl_gen_srch_prog" ref 372
move_info                              based           structure                level 1 dcl 12-98 set ref 864 869*
mrds_data_$max_attributes       000010 external static fixed bin(35,0)          dcl 1044 ref 363 363 363 943 943 943 945 945 947 947
                                                                                  948 948 954 954 958 958 969 969 973 973 982 982
mrds_data_$max_id_len           000012 external static fixed bin(35,0)          dcl 1044 ref 363 363 363 943 943 943 945 945 945 947
                                                                                  947 947 948 948 948 954 954 954 958 958 958 969
                                                                                  969 969 973 973 973 982 982 982
mrds_data_$max_safe_tids_returned_per_call
                                000014 external static fixed bin(35,0)          dcl 1044 ref 372
mrds_data_$max_tids_returned_per_call
                                000016 external static fixed bin(35,0)          dcl 1044 ref 368
mrds_dsl_make_literal$alloc     000020 constant        entry                    external dcl 1060 ref 930
mrds_error_$internal_error      000022 external static fixed bin(35,0)          dcl 1061 set ref 573* 610*
mu_cursor_manager_$get          000024 constant        entry                    external dcl 1066 ref 458
mu_data_class$varying           000026 constant        entry                    external dcl 1068 ref 891
nattr                                  based           fixed bin(17,0)          level 2 dcl 11-135 ref 555 705
needed_bits                            based           structure                array level 3 dcl 14-5
new_val                   1            based           bit(1)                   array level 2 packed packed unaligned dcl 13-3 set
                                                                                  ref 332*
nexprs                                 based           fixed bin(17,0)          level 2 dcl 11-155 ref 529 728
next_element_id_list_ptr        000110 automatic       pointer                  dcl 1008 set ref 355* 381 382*
next_entry                             based           pointer                  level 2 dcl 498 set ref 628* 684
nkey_attr                24            based           fixed bin(17,0)          level 2 dcl 19-119 ref 371 417 444 559 710 944
nlists                                 based           fixed bin(17,0)          level 2 dcl 25-64 set ref 696*
non_shared_to_shared    106(23)        based           bit(1)                   level 3 packed packed unaligned dcl 9-142 set ref
                                                                                  326*
nops                      1            based           fixed bin(17,0)          level 2 dcl 12-66 set ref 335* 339* 345 391 392 393
                                                                                  393* 469 470 470*
ntids                                  based           fixed bin(17,0)          array level 3 dcl 13-3 set ref 366*
null                                                   builtin function         dcl 1050 ref 322 350 408 480 1-59 5-50 5-50 8-21
                                                                                  20-65 21-51 25-54 25-69 27-13 27-18 28-6 28-10 528
                                                                                  529 556 557 573 573 610 610 635 654 691 707 708
                                                                                  716 728 762 851 866 870 871 925 982
num_attr                 22            based           fixed bin(17,0)          level 2 dcl 19-119 ref 371 944 951
num_dims                        000272 automatic       fixed bin(17,0)          initial dcl 26-20 set ref 313* 26-20*
num_tuples                             based           fixed bin(17,0)          level 2 dcl 15-10 ref 320
num_vars                               based           fixed bin(17,0)          level 2 dcl 14-5 ref 329 334 941
number_of_and_groups      4(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 5-9 set ref 650*
                                                                                  657*
number_of_constraints
                         11(18)        based           fixed bin(17,0)          array level 3 in structure
                                                                                  "relation_search_specification" packed packed
                                                                                  unaligned dcl 5-9 in procedure
                                                                                  "mrds_dsl_gen_srch_prog" set ref 663*
number_of_constraints           000324 automatic       fixed bin(17,0)          level 2 in structure "constraint_list" dcl 508
                                                                                  in procedure "build_select_op" set ref 527* 626*
                                                                                  626 646 681
number_of_dimensions      0(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 7-17 set ref
                                                                                  967*
number_of_elements        1            based           fixed bin(35,0)          level 2 dcl 2-21 set ref 387*
number_of_ids             1            based           fixed bin(17,0)          level 2 dcl 8-16 set ref 952* 956* 960* 960 961 964
                                                                                  966
nv                              000127 automatic       fixed bin(17,0)          dcl 1018 set ref 702* 713* 713 714 715 716 716 718
                                                                                  733* 733 734 735 736 737 762 768 770 776 781 782
                                                                                  788 790 803 820 821 822 836 837 839
nvals                                  based           fixed bin(17,0)          level 2 dcl 25-30 set ref 847* 849 851
nvars                                  based           fixed bin(17,0)          level 2 dcl 13-3 set ref 330* 332 332 363 363 366
                                                                                  366 366 366 380 380 381 381 382 382 385 385 458
                                                                                  458
op                       16            based           fixed bin(17,0)          array level 3 in structure "comp_val_list" dcl 25-30
                                                                                  in procedure "mrds_dsl_gen_srch_prog" set ref 715*
                                                                                  734*
op                        2            based           structure                array level 2 in structure "search_ops" dcl 12-66
                                                                                  in procedure "mrds_dsl_gen_srch_prog"
op_code                                based           fixed bin(17,0)          level 2 in structure "cond" dcl 11-146 in procedure
                                                                                  "mrds_dsl_gen_srch_prog" ref 592 595 598 601 604
                                                                                  607 715
op_code                   4            based           fixed bin(17,0)          array level 3 in structure "expr_list" dcl 11-155
                                                                                  in procedure "mrds_dsl_gen_srch_prog" ref 734
open                    146            based           entry variable           level 4 dcl 9-142 set ref 458*
operator_code             3            based           fixed bin(17,0)          level 3 dcl 498 set ref 592* 595* 598* 601* 604*
                                                                                  607*
opr_ind                         000125 automatic       fixed bin(17,0)          dcl 1018 set ref 424* 432* 439*
pa_ptr                          000102 automatic       pointer                  dcl 1008 set ref 322* 348* 352 359
pad                       1(18)        based           bit(18)                  level 3 packed packed unaligned dcl 5-9 set ref 653*
path_var                               based           structure                level 1 dcl 11-73
path_var_ptr                           parameter       pointer                  dcl 1007 ref 34 315
permits                                based           structure                level 2 dcl 1041
pl_ptr                    6            based           pointer                  array level 3 in structure "expr_list" dcl 11-155
                                                                                  in procedure "mrds_dsl_gen_srch_prog" ref 739
pl_ptr                          000224 automatic       pointer                  dcl 10-84 in procedure "mrds_dsl_gen_srch_prog" set
                                                                                  ref 719* 720 723 732* 735 736 737 739* 740 742 768
                                                                                  770 775 775 775 778 782 786 786 786 786 788 790
                                                                                  803 820 821 822 833 836
pl_ptr                    2            based           pointer                  level 2 in structure "cond" dcl 11-146 in procedure
                                                                                  "mrds_dsl_gen_srch_prog" ref 562 719
pred_data_type                  000334 automatic       fixed bin(17,0)          dcl 515 set ref 564* 565 568 570 613
pred_desc                       000335 automatic       bit(36)                  dcl 516 set ref 568* 570* 576
pred_leaf                              based           structure                level 1 unaligned dcl 10-67
pred_ptr                        000336 automatic       pointer                  dcl 517 set ref 562* 563 564 568 570 613 619
pred_var_ind                    000340 automatic       fixed bin(17,0)          dcl 519 set ref 563* 576 619*
prevents                  1            based           structure                level 2 dcl 1041
primary_key_index_id     26            based           bit(36)                  level 2 dcl 19-119 ref 421 429 436
pvp                             000226 automatic       pointer                  dcl 11-96 set ref 315* 350 359* 360 361 362 389 389
                                                                                  414 427 444
pvp_array                              based           pointer                  array dcl 1039 set ref 348 352* 359
rai_ptr                         000260 automatic       pointer                  initial dcl 20-65 set ref 20-65* 710* 711 778* 779
                                                                                  833* 834
raip                                   parameter       pointer                  dcl 883 ref 877 886 891 891 895 898
range                     6            based           structure                level 2 in structure "relation_search_specification"
                                                                                  dcl 5-9 in procedure "mrds_dsl_gen_srch_prog"
range                                  based           structure                level 1 dcl 14-5 in procedure
                                                                                  "mrds_dsl_gen_srch_prog"
range_ptr                 2            based           pointer                  level 3 in structure "dbcb" dcl 9-142 in procedure
                                                                                  "mrds_dsl_gen_srch_prog" ref 317
range_ptr                       000246 automatic       pointer                  dcl 14-23 in procedure "mrds_dsl_gen_srch_prog" set
                                                                                  ref 317* 329 334 363 941 943 945 947 948 954 958
                                                                                  969 973 982
rdbi_ptr                        000254 automatic       pointer                  dcl 18-90 in procedure "mrds_dsl_gen_srch_prog" set
                                                                                  ref 312*
rdbi_ptr                               based           pointer                  level 3 in structure "dbcb" dcl 9-142 in procedure
                                                                                  "mrds_dsl_gen_srch_prog" ref 312
rdi_ptr                         000262 automatic       pointer                  initial dcl 21-51 set ref 21-51* 711* 718 779* 781
                                                                                  834* 837 839 886* 888 888 896
read_attr                              based           bit(1)                   level 3 packed packed unaligned dcl 1041 ref 372
rel_id                    1            based           bit(36)                  level 2 in structure "comp_val_list" dcl 25-30
                                                                                  in procedure "mrds_dsl_gen_srch_prog" set ref 703*
rel_id                   20            based           bit(36)                  level 2 in structure "rm_rel_info" dcl 19-119
                                                                                  in procedure "mrds_dsl_gen_srch_prog" ref 449 703
relation_cursor_ptr                    based           pointer                  array level 3 dcl 13-3 set ref 458*
relation_numeric_specification_ptr
                                000210 automatic       pointer                  initial dcl 5-50 set ref 5-50*
relation_search_specification          based           structure                level 1 dcl 5-9 set ref 650
relation_search_specification_ptr
                          4            based           pointer                  level 2 in structure "select_info" dcl 12-129
                                                                                  in procedure "mrds_dsl_gen_srch_prog" set ref 686*
relation_search_specification_ptr
                                000206 automatic       pointer                  initial dcl 5-50 in procedure
                                                                                  "mrds_dsl_gen_srch_prog" set ref 5-50* 650* 651
                                                                                  652 653 654 655 657 659 660 661 662 663 665 667
                                                                                  668 682 686
relmgr_entries          146            based           structure                level 3 dcl 9-142
return_unique_tuples      5            based           bit(1)                   level 3 packed packed unaligned dcl 5-9 set ref 659*
ri_ptr                                 based           pointer                  array level 3 in structure "search_vars" dcl 13-3
                                                                                  in procedure "mrds_dsl_gen_srch_prog" set ref 363*
ri_ptr                                 based           pointer                  array level 3 in structure "range" dcl 14-5
                                                                                  in procedure "mrds_dsl_gen_srch_prog" ref 363 943
rm_attr_info                           based           structure                level 1 dcl 20-46
rm_db_info_data                        based           structure                level 1 unaligned dcl 18-92
rm_domain_info                         based           structure                level 1 dcl 21-35
rm_rel_info                            based           structure                level 1 dcl 19-119
rmri_ptr                        000256 automatic       pointer                  dcl 19-156 set ref 363* 369 371 417 420 421 428 429
                                                                                  436 444 449 458* 559 703 710
rni                             000123 automatic       fixed bin(17,0)          dcl 1018 set ref 470* 473 474 474 474 480
rotate_ops                      000132 automatic       fixed bin(17,0)          initial array dcl 1032 set ref 1032* 1032* 1032*
                                                                                  1032* 1032* 1032*
rslt_desc                 6            based           bit(36)                  level 2 packed packed unaligned dcl 10-67 ref 737
rss_maximum_number_of_constraints
                                000213 automatic       fixed bin(17,0)          initial dcl 5-52 set ref 5-52* 646* 647 650 650 655
                                                                                  663
rss_number_of_and_groups        000212 automatic       fixed bin(17,0)          initial dcl 5-52 set ref 5-52* 647* 649* 650 650 657
rtrv_info                              based           structure                level 1 dcl 23-27
rvi                             000124 automatic       fixed bin(17,0)          dcl 1018 set ref 469* 472 474 474 479 480
s_desc                   12            based           bit(36)                  level 2 dcl 12-98 set ref 896*
s_ptr                     4            based           pointer                  level 2 dcl 12-98 set ref 871* 911*
sbit_len                 10            based           fixed bin(35,0)          level 2 dcl 12-98 set ref 895*
scope_flags                            based           structure                level 1 dcl 1-42
scope_flags_ptr                        based           pointer                  level 2 dcl 19-119 ref 371
scope_ptr                       000200 automatic       pointer                  initial dcl 1-59 set ref 1-59*
scopes_changed          106(24)        based           bit(1)                   level 3 packed packed unaligned dcl 9-142 set ref
                                                                                  325*
search_collection_id     10            based           bit(36)                  array level 3 dcl 5-9 set ref 668*
search_ops                             based           structure                level 1 dcl 12-66 set ref 335
search_vars                            based           structure                level 1 dcl 13-3 set ref 330
select_area                            based           area                     dcl 28-8 ref 330 335 348 522 589 650 696 847 864 952
                                                                                  967
select_area_ptr          36            based           pointer                  level 3 in structure "dbcb" dcl 9-142 in procedure
                                                                                  "mrds_dsl_gen_srch_prog" ref 323
select_area_ptr                 000302 automatic       pointer                  initial dcl 28-10 in procedure
                                                                                  "mrds_dsl_gen_srch_prog" set ref 323* 330 335 348
                                                                                  28-10* 522 589 650 696 847 864 952 967
select_area_struct_ptr          000300 automatic       pointer                  initial dcl 28-6 set ref 28-6*
select_info                            based           structure                level 1 dcl 12-129 set ref 522
seli_ptr                        000242 automatic       pointer                  dcl 12-135 set ref 522* 524 525 526 686 691 698
si                              000122 automatic       fixed bin(17,0)          dcl 1018 set ref 393* 398 399 402 407 408 524
simple_typed_vector                    based           structure                level 1 packed packed unaligned dcl 7-17 set ref 967
simple_typed_vector_ptr         000214 automatic       pointer                  dcl 7-33 set ref 967* 968 969 976
size                      7            based           fixed bin(17,0)          level 3 dcl 5-9 set ref 662*
so_nops_init                    000236 automatic       fixed bin(17,0)          dcl 12-83 set ref 334* 335 335
so_ptr                                 parameter       pointer                  dcl 12-82 set ref 34 335* 338 339 341 342 343 344
                                                                                  345 391 392 393 393 396 397 398 399 399 399 402
                                                                                  402 402 405 406 407 408 408 408 469 470 470 472
                                                                                  473 474 474 474 474 474 479 480 480 524 866
specification_head                     based           structure                level 1 unaligned dcl 6-10
src_ptr                         000140 automatic       pointer                  level 2 dcl 1040 set ref 925*
srcd_ptr                  2     000140 automatic       pointer                  level 2 dcl 1040 set ref 925*
ss_possible                     000341 automatic       bit(1)                   packed unaligned dcl 520 set ref 565* 576* 579
string                                                 builtin function         dcl 1050 set ref 332*
stv_number_of_dimensions        000216 automatic       fixed bin(17,0)          dcl 7-35 set ref 966* 967 967 971* 975* 975 976
stv_ptr                                based           pointer                  array level 3 dcl 14-5 set ref 947* 969* 982*
sub_err_                        000030 constant        entry                    external dcl 1069 ref 573 610
subset_specification_ptr
                          2            based           pointer                  level 3 dcl 5-9 set ref 654*
sv_nvars_init                   000244 automatic       fixed bin(17,0)          dcl 13-10 set ref 329* 330 330 330 330 348
sv_ptr                                 parameter       pointer                  dcl 13-9 set ref 34 330* 332 342 363 366 366 380 381
                                                                                  382 385 458
t_ptr                     6            based           pointer                  level 2 dcl 12-98 set ref 621 776 871* 888*
ta_ptr                                 based           pointer                  array level 3 dcl 13-3 set ref 381* 382 385
tbit_len                 11            based           fixed bin(35,0)          level 2 dcl 12-98 set ref 888*
ti_ntuples_init                 000252 automatic       fixed bin(17,0)          dcl 15-18 set ref 320*
ti_ptr                          000250 automatic       pointer                  dcl 15-17 in procedure "mrds_dsl_gen_srch_prog" set
                                                                                  ref 318* 320 526 942
ti_ptr                   12            based           pointer                  level 3 in structure "dbcb" dcl 9-142 in procedure
                                                                                  "mrds_dsl_gen_srch_prog" ref 318
tid_ptr                   2            based           pointer                  level 2 dcl 12-129 set ref 526*
tp                                     parameter       fixed bin(17,0)          dcl 906 ref 901 912
tup_var                   2            based           structure                array level 2 dcl 14-5
tuple                     2            based           structure                array level 2 dcl 15-10
tuple_attr_index          3            based           fixed bin(17,0)          level 2 dcl 12-98 set ref 898*
tuple_id                  4            based           bit(36)                  array level 3 dcl 15-10 set ref 526
tuple_info                             based           structure                level 1 dcl 15-10
tuple_info_index                       based           fixed bin(17,0)          level 2 dcl 12-129 set ref 525*
tuple_ptr                 2            based           pointer                  array level 3 dcl 15-10 ref 942
tuple_var_index           2            based           fixed bin(17,0)          level 2 dcl 12-98 set ref 897* 912*
type                      1            based           fixed bin(17,0)          level 3 in structure "relation_search_specification"
                                                                                  packed packed unaligned dcl 5-9 in procedure
                                                                                  "mrds_dsl_gen_srch_prog" set ref 652*
type                                   based           fixed bin(17,0)          level 2 in structure "simple_typed_vector" packed
                                                                                  packed unaligned dcl 7-17 in procedure
                                                                                  "mrds_dsl_gen_srch_prog" set ref 968*
type                      6            based           fixed bin(17,0)          level 3 in structure "relation_search_specification"
                                                                                  dcl 5-9 in procedure "mrds_dsl_gen_srch_prog" set
                                                                                  ref 661*
unspec                                                 builtin function         dcl 1050 set ref 849* 869*
user_desc                11            based           bit(36)                  level 2 dcl 21-35 ref 837
val                       2            based           structure                array level 2 dcl 25-30 set ref 849*
value_field_id            6            based           fixed bin(17,0)          level 3 dcl 498 set ref 624*
value_ptr                 4            based           pointer                  level 3 in structure "constraint_entry" dcl 498
                                                                                  in procedure "build_select_op" set ref 613* 621*
value_ptr                 1            based           pointer                  array level 3 in structure "simple_typed_vector"
                                                                                  packed packed unaligned dcl 7-17 in procedure
                                                                                  "mrds_dsl_gen_srch_prog" set ref 976* 976
var_id                    1            based           bit(18)                  level 3 packed packed unaligned dcl 10-67 ref 563
                                                                                  720 740 775 775 786 786 786
var_ind                   1            based           fixed bin(17,0)          level 2 in structure "move_info" dcl 12-98
                                                                                  in procedure "mrds_dsl_gen_srch_prog" set ref 894*
                                                                                  913*
var_ind                                parameter       fixed bin(17,0)          dcl 884 in procedure "extract_attr" ref 877 894 897
var_ind                   3            based           fixed bin(17,0)          array level 3 in structure "search_ops" dcl 12-66
                                                                                  in procedure "mrds_dsl_gen_srch_prog" set ref 343*
                                                                                  399* 399* 399* 474* 474*
var_index                              based           fixed bin(17,0)          level 2 dcl 11-73 ref 360
var_move                  0(01)        based           bit(1)                   level 2 packed packed unaligned dcl 12-98 set ref
                                                                                  893*
version                                based           fixed bin(35,0)          level 2 in structure "id_list" dcl 8-16 in procedure
                                                                                  "mrds_dsl_gen_srch_prog" set ref 953*
version                                based           fixed bin(35,0)          level 2 in structure "element_id_list" dcl 2-21
                                                                                  in procedure "mrds_dsl_gen_srch_prog" set ref 386*
version                                based           fixed bin(35,0)          level 3 in structure "relation_search_specification"
                                                                                  dcl 5-9 in procedure "mrds_dsl_gen_srch_prog" set
                                                                                  ref 651*
vi                                     parameter       fixed bin(17,0)          dcl 907 ref 901 913
vind                            000117 automatic       fixed bin(17,0)          dcl 1018 set ref 360* 363 363 366 366 380 381 382
                                                                                  385 399 458 458 525 526 576 721 741
whole_tuple_selected                   based           bit(1)                   array level 3 packed packed unaligned dcl 14-5 ref
                                                                                  945
xp                              000100 automatic       pointer                  dcl 1008 set ref 350* 350* 352* 353

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABSOLUTE_NUMERIC_SPECIFICATION_TYPE    internal static fixed bin(17,0)          initial dcl 6-22
ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 6-22
ABSOLUTE_SEARCH_SPECIFICATION_TYPE     internal static fixed bin(17,0)          initial dcl 6-22
ADD                                    internal static fixed bin(17,0)          initial dcl 17-59
ALL_OP                                 internal static bit(6)                   initial packed unaligned dcl 10-44
ALL_RANGE_TYPE                         internal static fixed bin(17,0)          initial dcl 4-8
AND_OP                                 internal static bit(6)                   initial packed unaligned dcl 10-44
ARRAY                                  internal static fixed bin(17,0)          initial dcl 10-60
CFLTD59                                internal static bit(36)                  initial dcl 17-70
CURRENT_OP                             internal static bit(6)                   initial packed unaligned dcl 10-44
CVL_EQ                                 internal static fixed bin(17,0)          initial dcl 25-57
CVL_GE                                 internal static fixed bin(17,0)          initial dcl 25-57
CVL_GT                                 internal static fixed bin(17,0)          initial dcl 25-57
CVL_LE                                 internal static fixed bin(17,0)          initial dcl 25-57
CVL_LT                                 internal static fixed bin(17,0)          initial dcl 25-57
CVL_NE                                 internal static fixed bin(17,0)          initial dcl 25-57
DATA                                   internal static fixed bin(17,0)          initial dcl 17-59
DATABASE                               internal static fixed bin(17,0)          initial dcl 17-59
DIV                                    internal static fixed bin(17,0)          initial dcl 17-59
EQUAL_IDX                              internal static fixed bin(17,0)          initial dcl 3-13
EQ_OP                                  internal static bit(6)                   initial packed unaligned dcl 10-44
EXPR                                   internal static fixed bin(17,0)          initial dcl 17-59
GENERAL_TYPED_VECTOR_TYPE              internal static fixed bin(17,0)          initial dcl 7-43
GE_OP                                  internal static bit(6)                   initial packed unaligned dcl 10-44
GREATER_IDX                            internal static fixed bin(17,0)          initial dcl 3-13
GT_OP                                  internal static bit(6)                   initial packed unaligned dcl 10-44
HIGH_RANGE_TYPE                        internal static fixed bin(17,0)          initial dcl 4-8
INDEXED_ATTR                           internal static fixed bin(17,0)          initial dcl 11-128
LEAF                                   internal static fixed bin(17,0)          initial dcl 10-60
LE_OP                                  internal static bit(6)                   initial packed unaligned dcl 10-44
LITERAL                                internal static fixed bin(17,0)          initial dcl 17-59
LONG_KEY_HEAD                          internal static fixed bin(17,0)          initial dcl 11-128
LT_OP                                  internal static bit(6)                   initial packed unaligned dcl 10-44
MULT                                   internal static fixed bin(17,0)          initial dcl 17-59
NE_OP                                  internal static bit(6)                   initial packed unaligned dcl 10-44
NODE                                   internal static fixed bin(17,0)          initial dcl 10-60
NOT_IDX                                internal static fixed bin(17,0)          initial dcl 3-13
NOT_OP                                 internal static bit(6)                   initial packed unaligned dcl 10-44
NUMERIC_SPECIFICATION_TYPE             internal static fixed bin(17,0)          initial dcl 6-22
OLD_SIMPLE_TYPED_VECTOR_TYPE           internal static fixed bin(17,0)          initial dcl 7-43
OPERATOR                               internal static fixed bin(17,0)          initial dcl 17-59
ORDERED_SEQUENTIAL                     internal static fixed bin(17,0)          initial dcl 11-128
OR_OP                                  internal static bit(6)                   initial packed unaligned dcl 10-44
REGULAR_EXPRESSION_IDX                 internal static fixed bin(17,0)          initial dcl 3-13
REGULAR_EXPRESSION_OPERATOR_CODE       internal static fixed bin(17,0)          initial dcl 3-13
RELATIVE_NUMERIC_SPECIFICATION_TYPE    internal static fixed bin(17,0)          initial dcl 6-22
RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 6-22
RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 6-22
RELATIVE_SEARCH_SPECIFICATION_TYPE     internal static fixed bin(17,0)          initial dcl 6-22
RFLTD59                                internal static bit(36)                  initial dcl 17-72
SCAL_FUN                               internal static fixed bin(17,0)          initial dcl 17-59
SEARCH_SPECIFICATION_TYPE              internal static fixed bin(17,0)          initial dcl 6-22
SHORT_KEY_HEAD                         internal static fixed bin(17,0)          initial dcl 11-128
SUBT                                   internal static fixed bin(17,0)          initial dcl 17-59
TOTAL_PRIMARY_KEY                      internal static fixed bin(17,0)          initial dcl 11-128
UNORDERED_SEQUENTIAL                   internal static fixed bin(17,0)          initial dcl 11-128
USES_EQUAL_OPERATOR                    internal static bit(1)                   initial array packed unaligned dcl 3-31
USES_GREATER_OPERATOR                  internal static bit(1)                   initial array packed unaligned dcl 3-31
USES_LESS_OPERATOR                     internal static bit(1)                   initial array packed unaligned dcl 3-31
USES_REGULAR_EXPRESSION_OPERATOR       internal static bit(1)                   initial array packed unaligned dcl 3-31
V_C                                    internal static fixed bin(5,0)           initial dcl 10-64
V_V                                    internal static fixed bin(5,0)           initial dcl 10-64
ag_ptr                                 automatic       pointer                  dcl 10-40
al_nattr_init                          automatic       fixed bin(17,0)          dcl 11-144
and_group                              based           structure                level 1 unaligned dcl 10-36
db_mrds_dsl_close                      defined         bit(9)                   packed unaligned dcl 29-62
db_mrds_dsl_eval_expr                  defined         bit(9)                   packed unaligned dcl 29-62
db_mrds_dsl_gen_srch_prog              defined         bit(9)                   packed unaligned dcl 29-62
db_mrds_dsl_get_token                  defined         bit(9)                   packed unaligned dcl 29-62
db_mrds_dsl_init_res                   defined         bit(9)                   packed unaligned dcl 29-62
db_mrds_dsl_open                       defined         bit(9)                   packed unaligned dcl 29-62
db_mrds_dsl_optimize                   defined         bit(9)                   packed unaligned dcl 29-62
db_mrds_dsl_permute                    defined         bit(9)                   packed unaligned dcl 29-62
db_mrds_dsl_search                     defined         bit(9)                   packed unaligned dcl 29-62
db_mrds_dsl_set_fscope                 defined         bit(9)                   packed unaligned dcl 29-62
db_mrds_dsl_translate                  defined         bit(9)                   packed unaligned dcl 29-62
db_mrds_dsl_where_clause               defined         bit(9)                   packed unaligned dcl 29-62
db_mrds_rst_dmdm                       defined         bit(9)                   packed unaligned dcl 29-62
db_mu_concurrency_control              defined         bit(9)                   packed unaligned dcl 29-62
db_mu_open_iocb_manager                defined         bit(9)                   packed unaligned dcl 29-62
db_mu_open_name_manager                defined         bit(9)                   packed unaligned dcl 29-62
db_mu_retrieve                         defined         bit(9)                   packed unaligned dcl 29-62
db_mu_sec_get_tid                      defined         bit(9)                   packed unaligned dcl 29-62
db_mu_sec_get_tuple                    defined         bit(9)                   packed unaligned dcl 29-62
db_mu_sec_init_res                     defined         bit(9)                   packed unaligned dcl 29-62
db_mus_mod_ubtup                       defined         bit(9)                   packed unaligned dcl 29-62
desc_ptr                               automatic       pointer                  dcl 26-19
descriptor                             based           structure                level 1 unaligned dcl 26-6
eil_number_of_elements                 automatic       fixed bin(35,0)          dcl 2-27
el_nexprs_init                         automatic       fixed bin(17,0)          dcl 11-164
expr                                   based           structure                level 1 dcl 17-11
expr_ptr                               automatic       pointer                  dcl 17-32
general_typed_vector                   based           structure                level 1 packed packed unaligned dcl 7-24
general_typed_vector_ptr               automatic       pointer                  dcl 7-38
gtv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 7-40
ind_ptr                                automatic       pointer                  dcl 22-9
ind_sel_info                           based           structure                level 1 dcl 24-5
ind_val_len                            automatic       fixed bin(35,0)          dcl 22-10
index                                  based           structure                level 1 dcl 22-3
isi_ptr                                automatic       pointer                  dcl 24-16
lip                                    automatic       pointer                  dcl 16-28
max_file_init                          automatic       fixed bin(17,0)          dcl 1-58
mi_nitems_init                         automatic       fixed bin(17,0)          dcl 12-121
model_area                             based           area                     dcl 27-16
model_seg                              based           structure                level 1 dcl 27-9
module                                 internal static structure                level 1 unaligned dcl 29-91
mrds_data_$max_select_items            external static fixed bin(35,0)          dcl 1044
mrds_debug_$switch                     external static bit(9)                   array packed unaligned dcl 29-135
natts_init                             automatic       fixed bin(17,0)          dcl 19-157
nexp_items_init                        automatic       fixed bin(17,0)          dcl 17-33
nkey_attr_init                         automatic       fixed bin(17,0)          dcl 19-157
nsf_args_init                          automatic       fixed bin(17,0)          dcl 17-57
num_ands_init                          automatic       fixed bin(17,0)          dcl 10-41
num_terms_init                         automatic       fixed bin(17,0)          dcl 10-41
nvar_atts_init                         automatic       fixed bin(17,0)          dcl 19-157
pn_ptr                                 automatic       pointer                  dcl 10-27
pred_array                             based           structure                level 1 unaligned dcl 10-29
pred_node                              based           structure                level 1 unaligned dcl 10-12
pred_ptr                               automatic       pointer                  dcl 10-34
rel                                                    builtin function         dcl 1050
relation_numeric_specification         based           structure                level 1 dcl 5-41
rm_db_info                             based           structure                level 1 dcl 18-86
rti_ptr                                automatic       pointer                  dcl 23-37
scalfn                                 based           structure                level 1 dcl 17-35
scope_info                             based           structure                level 1 dcl 1-32
scope_rdy                              internal static bit(6)                   initial packed unaligned dcl 1-60
scope_rdy_array                        based           bit(1)                   array packed unaligned dcl 1-61
select_area_struct                     based           structure                level 1 dcl 28-2
sfn_ptr                                automatic       pointer                  dcl 17-56
size                                                   builtin function         dcl 27-20
specification_head_ptr                 automatic       pointer                  dcl 6-18
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 1070
ta_nids                                automatic       fixed bin(17,0)          dcl 23-41
ta_ptr                                 automatic       pointer                  dcl 23-42
tid_array                              based           bit(36)                  array dcl 23-39

NAMES DECLARED BY EXPLICIT CONTEXT.
alloc_comp_val_list             002444 constant        entry                    internal dcl 844 ref 700
alloc_lit                       002702 constant        entry                    internal dcl 917 ref 888
alloc_move_info                 002524 constant        entry                    internal dcl 860 ref 887 909
between_tuples                  000006 constant        label                    array(3) dcl 767 ref 765 800
build_select_op                 001143 constant        entry                    internal dcl 490 ref 456
build_vectors                   002746 constant        entry                    internal dcl 936 ref 483
complete_comparison_item        002221 constant        entry                    internal dcl 748 ref 723 742
cont2                           001012 constant        label                    dcl 456 ref 422 430 437 445 454
end_between_tuples              002347 constant        label                    dcl 792 ref 772 783 791
end_within_tuple                002374 constant        label                    dcl 810 ref 805 809
error                           003460 constant        entry                    internal dcl 996 ref 462 931
exit                            001141 constant        label                    dcl 487 ref 1003
extract_attr                    002560 constant        entry                    internal dcl 877 ref 619 775
make_eval_expr_mi               002663 constant        entry                    internal dcl 901 ref 786
mrds_dsl_gen_srch_prog          000111 constant        entry                    external dcl 34
prepare_attr_cvl                002412 constant        entry                    internal dcl 825 ref 804
prepare_expr_cvl                002376 constant        entry                    internal dcl 815 ref 808
process_var                     000000 constant        label                    array(6) dcl 417 set ref 414
within_tuple                    000011 constant        label                    array(3) dcl 796 ref 795

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3652        3704    3500        3662
Length      4736    3500        32        1016     151           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_dsl_gen_srch_prog              439 external procedure  is an external procedure.  
build_select_op                         internal procedure  shares stack frame of external procedure mrds_dsl_gen_srch_prog.  
complete_comparison_item                internal procedure  shares stack frame of external procedure mrds_dsl_gen_srch_prog.  
prepare_expr_cvl                        internal procedure  shares stack frame of external procedure mrds_dsl_gen_srch_prog.  
prepare_attr_cvl                        internal procedure  shares stack frame of external procedure mrds_dsl_gen_srch_prog.  
alloc_comp_val_list                     internal procedure  shares stack frame of external procedure mrds_dsl_gen_srch_prog.  
alloc_move_info                         internal procedure  shares stack frame of external procedure mrds_dsl_gen_srch_prog.  
extract_attr                            internal procedure  shares stack frame of external procedure mrds_dsl_gen_srch_prog.  
make_eval_expr_mi                       internal procedure  shares stack frame of external procedure mrds_dsl_gen_srch_prog.  
alloc_lit                               internal procedure  shares stack frame of external procedure mrds_dsl_gen_srch_prog.  
build_vectors                           internal procedure  shares stack frame of external procedure mrds_dsl_gen_srch_prog.  
error                                   internal procedure  shares stack frame of external procedure mrds_dsl_gen_srch_prog.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mrds_dsl_gen_srch_prog   000100 xp                          mrds_dsl_gen_srch_prog
                         000102 pa_ptr                      mrds_dsl_gen_srch_prog
                         000104 cur_ii_ptr                  mrds_dsl_gen_srch_prog
                         000106 cur_mi_ptr                  mrds_dsl_gen_srch_prog
                         000110 next_element_id_list_ptr    mrds_dsl_gen_srch_prog
                         000112 aip_ptr                     mrds_dsl_gen_srch_prog
                         000114 icode                       mrds_dsl_gen_srch_prog
                         000115 i                           mrds_dsl_gen_srch_prog
                         000116 j                           mrds_dsl_gen_srch_prog
                         000117 vind                        mrds_dsl_gen_srch_prog
                         000120 ii                          mrds_dsl_gen_srch_prog
                         000121 mi                          mrds_dsl_gen_srch_prog
                         000122 si                          mrds_dsl_gen_srch_prog
                         000123 rni                         mrds_dsl_gen_srch_prog
                         000124 rvi                         mrds_dsl_gen_srch_prog
                         000125 opr_ind                     mrds_dsl_gen_srch_prog
                         000126 count                       mrds_dsl_gen_srch_prog
                         000127 nv                          mrds_dsl_gen_srch_prog
                         000130 max_pv                      mrds_dsl_gen_srch_prog
                         000131 ed                          mrds_dsl_gen_srch_prog
                         000132 rotate_ops                  mrds_dsl_gen_srch_prog
                         000140 li                          mrds_dsl_gen_srch_prog
                         000164 current_scope_ptr           mrds_dsl_gen_srch_prog
                         000166 MODULE_NAME                 mrds_dsl_gen_srch_prog
                         000174 comparison_var_id           mrds_dsl_gen_srch_prog
                         000175 compare_within_tuple        mrds_dsl_gen_srch_prog
                         000176 collection_index            mrds_dsl_gen_srch_prog
                         000177 current_max_tids_per_call   mrds_dsl_gen_srch_prog
                         000200 scope_ptr                   mrds_dsl_gen_srch_prog
                         000202 element_id_list_ptr         mrds_dsl_gen_srch_prog
                         000204 ELEMENT_ID_LIST_VERSION_1   mrds_dsl_gen_srch_prog
                         000206 relation_search_specification_ptr
                                                            mrds_dsl_gen_srch_prog
                         000210 relation_numeric_specification_ptr
                                                            mrds_dsl_gen_srch_prog
                         000212 rss_number_of_and_groups    mrds_dsl_gen_srch_prog
                         000213 rss_maximum_number_of_constraints
                                                            mrds_dsl_gen_srch_prog
                         000214 simple_typed_vector_ptr     mrds_dsl_gen_srch_prog
                         000216 stv_number_of_dimensions    mrds_dsl_gen_srch_prog
                         000220 id_list_ptr                 mrds_dsl_gen_srch_prog
                         000222 il_number_of_ids            mrds_dsl_gen_srch_prog
                         000224 pl_ptr                      mrds_dsl_gen_srch_prog
                         000226 pvp                         mrds_dsl_gen_srch_prog
                         000230 alp                         mrds_dsl_gen_srch_prog
                         000232 condp                       mrds_dsl_gen_srch_prog
                         000234 elp                         mrds_dsl_gen_srch_prog
                         000236 so_nops_init                mrds_dsl_gen_srch_prog
                         000240 mi_ptr                      mrds_dsl_gen_srch_prog
                         000242 seli_ptr                    mrds_dsl_gen_srch_prog
                         000244 sv_nvars_init               mrds_dsl_gen_srch_prog
                         000246 range_ptr                   mrds_dsl_gen_srch_prog
                         000250 ti_ptr                      mrds_dsl_gen_srch_prog
                         000252 ti_ntuples_init             mrds_dsl_gen_srch_prog
                         000254 rdbi_ptr                    mrds_dsl_gen_srch_prog
                         000256 rmri_ptr                    mrds_dsl_gen_srch_prog
                         000260 rai_ptr                     mrds_dsl_gen_srch_prog
                         000262 rdi_ptr                     mrds_dsl_gen_srch_prog
                         000264 cvl_ptr                     mrds_dsl_gen_srch_prog
                         000266 cvl_nvals_init              mrds_dsl_gen_srch_prog
                         000267 cvla_nlists_init            mrds_dsl_gen_srch_prog
                         000270 cvla_ptr                    mrds_dsl_gen_srch_prog
                         000272 num_dims                    mrds_dsl_gen_srch_prog
                         000274 model_seg_ptr               mrds_dsl_gen_srch_prog
                         000276 model_area_ptr              mrds_dsl_gen_srch_prog
                         000300 select_area_struct_ptr      mrds_dsl_gen_srch_prog
                         000302 select_area_ptr             mrds_dsl_gen_srch_prog
                         000314 attr_desc                   build_select_op
                         000316 attr_rai_ptr                build_select_op
                         000320 attr_rdi_ptr                build_select_op
                         000322 constraint_entry_ptr        build_select_op
                         000324 constraint_list             build_select_op
                         000330 expression                  build_select_op
                         000331 k                           build_select_op
                         000332 last_cond_ptr               build_select_op
                         000334 pred_data_type              build_select_op
                         000335 pred_desc                   build_select_op
                         000336 pred_ptr                    build_select_op
                         000340 pred_var_ind                build_select_op
                         000341 ss_possible                 build_select_op
                         000376 i                           alloc_comp_val_list
                         000440 bv_idl_ptr                  build_vectors
                         000442 bv_stv_ptr                  build_vectors
                         000444 bv_ri_ptr                   build_vectors
                         000446 i                           build_vectors
                         000447 k                           build_vectors

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             call_ext_out_desc   call_ext_out        return_mac          ext_entry
op_alloc_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
mrds_dsl_make_literal$alloc   mu_cursor_manager_$get        mu_data_class$varying         sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
mrds_data_$max_attributes     mrds_data_$max_id_len         mrds_data_$max_safe_tids_returned_per_call
mrds_data_$max_tids_returned_per_call                       mrds_error_$internal_error




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     34 000104      1028 000116      1032 000120      1059 000151    1   59 000157    2   28 000161    5   50 000163
 5   52 000166    8   21 000170    8   22 000171   20   65 000173   21   51 000175   25   54 000176   25   69 000177
26   20 000200   27   13 000201   27   18 000202   28    6 000203   28   10 000204       312 000205       313 000212
    315 000213       317 000216       318 000221       320 000223       322 000225       323 000227       325 000231
    326 000233       329 000235       330 000237       332 000263       334 000267       335 000273       338 000305
    339 000307       341 000310       342 000312       343 000315       344 000320       345 000322       347 000340
    348 000341       350 000347       351 000356       352 000357       353 000364       354 000367       355 000371
    357 000376       359 000403       360 000407       361 000411       362 000413       363 000415       366 000477
    368 000531       369 000533       371 000537       372 000550       380 000563       381 000601       382 000616
    385 000642       386 000644       387 000646       389 000647       391 000654       392 000661       393 000664
    396 000670       397 000675       398 000702       399 000707       402 000713       405 000717       406 000720
    407 000722       408 000724       414 000734       417 000736       420 000741       421 000743       422 000745
    424 000746       427 000747       428 000751       429 000754       430 000757       432 000760       435 000761
    436 000763       437 000766       439 000767       443 000770       444 000772       445 001005       449 001006
    454 001011       456 001012       458 001013       462 001070       467 001074       469 001077       470 001105
    472 001111       473 001116       474 001123       479 001130       480 001132       483 001136       485 001137
    487 001141       488 001142       490 001143       522 001144       524 001151       525 001156       526 001160
    527 001163       528 001164       529 001166       531 001174       533 001175       555 001177       556 001207
    557 001211       559 001222       560 001237       561 001241       562 001243       563 001246       564 001251
    565 001253       568 001257       570 001264       573 001273       576 001340       579 001351       580 001353
    581 001354       584 001356       589 001357       590 001364       592 001367       595 001375       598 001402
    601 001407       604 001414       607 001421       610 001426       613 001473       619 001503       621 001514
    624 001520       625 001521       626 001523       628 001524       630 001526       635 001527       637 001541
    639 001545       640 001551       646 001553       647 001555       649 001560       650 001562       651 001604
    652 001606       653 001610       654 001612       655 001614       657 001617       659 001621       660 001623
    661 001625       662 001627       663 001631       665 001645       667 001647       668 001661       670 001663
    681 001665       682 001675       684 001747       685 001751       686 001753       691 001756       695 001763
    696 001765       698 001776       699 002000       700 002002       701 002003       702 002006       703 002007
    705 002012       707 002021       708 002027       710 002040       711 002056       713 002060       714 002061
    715 002067       716 002071       718 002074       719 002076       720 002101       721 002104       723 002107
    724 002125       726 002131       728 002133       732 002147       733 002153       734 002154       735 002164
    736 002166       737 002170       739 002172       740 002174       741 002177       742 002204       743 002216
    746 002220       748 002221       762 002223       764 002231       765 002237       767 002241       768 002242
    770 002250       772 002253       774 002254       775 002255       776 002271       778 002277       779 002302
    781 002304       782 002306       783 002314       785 002315       786 002316       788 002335       790 002343
    791 002346       792 002347       793 002350       795 002351       796 002353       800 002354       802 002355
    803 002356       804 002362       805 002370       807 002371       808 002372       809 002373       810 002374
    813 002375       815 002376       820 002377       821 002405       822 002407       823 002411       825 002412
    833 002414       834 002417       835 002422       836 002427       837 002433       838 002435       839 002436
    842 002443       844 002444       847 002445       849 002456       850 002465       851 002475       856 002521
    858 002523       860 002524       864 002525       866 002532       868 002544       869 002546       870 002551
    871 002553       873 002556       875 002557       877 002560       886 002562       887 002566       888 002567
    890 002605       891 002607       893 002634       894 002643       895 002647       896 002653       897 002656
    898 002660       899 002662       901 002663       909 002665       910 002666       911 002670       912 002675
    913 002677       915 002701       917 002702       924 002704       925 002706       928 002712       929 002715
    930 002716       931 002734       932 002740       933 002743       935 002745       936 002746       941 002747
    942 002757       943 002763       944 003026       945 003037       947 003055       948 003062       949 003066
    951 003067       952 003071       953 003101       954 003103       956 003142       957 003143       958 003153
    960 003221       961 003223       963 003230       964 003232       966 003235       967 003236       968 003252
    969 003255       971 003314       972 003315       973 003325       975 003373       976 003374       979 003411
    980 003413       982 003414       985 003455       994 003457       996 003460      1002 003462      1003 003465


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
