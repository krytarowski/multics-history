	COMPILATION LISTING OF SEGMENT listen_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/06/86  0757.1 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* format: style2 */
       12 listen_:
       13      procedure (initial_command_line);
       14 
       15 /* Multics Listener */
       16 /* initially coded in June 1969 by R. Daley */
       17 /* converted to pl1 and improved for new command loop in December 1969 by R. Daley */
       18 /* changed to reject input lines that are too long by V. Voydock in April 1970 */
       19 /* changed to truncate the stack  on every release
       20*   on August 12,1970 by V. Voydock */
       21 /* Changed to execute a start up exec_com and print the message of the
       22*   day on September 4,1970 by R. J. Feiertag */
       23 /* Extensively modified as part of redesign of user ring process initialization
       24*   by V. Voydock on October 27,1970 */
       25 /* Modified in June 1971 by V. Voydock to call cu_$ready_proc, to add "rl -all",
       26*   to use "system_free_" instead of "free_", to not blow up if
       27*   release_stack entry is somehow invoked before listen_ entry, and to make
       28*   the listen_ entry behave the same way every time it is called in a process */
       29 /* Modified in July 1971 by V. Voydock to make start command have control argument
       30*   which causes it not to restore the old io attachments */
       31 /* Modified in September 1971 by V. Voydock to not truncate free storage area after a release */
       32 /* Modified in February 1972 by V. Voydock to accept an arbitrarily long command line as input */
       33 /* Extensively modified in May 1972 by V. Voydock as part of fast command loop. Many pieces
       34*   of listen_ were moved to other procedures */
       35 /* Modified in September 1973 by M. Weaver to add level numbers, eliminate
       36*   the automatic release, and to make start and release work directly
       37*   with labels. */
       38 /* Modified in December 1974 by S. Webber to redo the buffering of the input
       39*   line. */
       40 /* Opened in November 1981 for video system support by Benson I. Margulies */
       41 /* Modified February 1984 by Jim Lippard to fix bug in call to iox_signal_ */
       42 /* Changed to use listener_info.incl.pl1 12/07/84 Steve Herbst */
       43 
       44 /* DECLARATIONS */
       45 
       46 	dcl     (
       47 	        buffer_ptr,				/* ptr to first char of workspace used by iox_$get_line */
       48 	        read_ptr		 ptr,		/* pointer to actual position in input buffer for read */
       49 	        dummy_ptr		 ptr,		/* dummy return pointer from cu_$grow_stack_frame calls */
       50 	        old_sp
       51 	        )			 pointer aligned;
       52 
       53 	dcl     (input_length, buffer_length)
       54 				 fixed bin (21);
       55 	dcl     total_input_length	 fixed bin (21);
       56 	dcl     entry,				/* 0->$listen_, 1->$release_stack */
       57 	        i			 fixed bin aligned;
       58 	dcl     code		 fixed bin (35);
       59 
       60 	dcl     initial_command_line	 char (*) var,	/* first command line to be executed */
       61 	        command_line	 char (input_length) aligned based (buffer_ptr);
       62 
       63 	dcl     spno		 bit (18) aligned,	/* used to store stack segno */
       64 	        should_restore_attachments
       65 				 bit (1) aligned;
       66 
       67 	dcl     1 x		 based (buffer_ptr) aligned,
       68 		2 ch		 (0:65536) char (1) unaligned;
       69 
       70 
       71 	dcl     1 listener_control	 aligned like based_listener_control;
       72 
       73 
       74 	dcl     iox_signal_		 entry (ptr, fixed bin (35));
       75 	dcl     com_err_		 entry options (variable);
       76 	dcl     cu_$cp		 ext entry (ptr, fixed bin (21), fixed bin (35));
       77 	dcl     cu_$ready_proc	 ext entry ();
       78 	dcl     cu_$grow_stack_frame	 entry (fixed bin (21), ptr, fixed bin (35));
       79 	dcl     get_system_free_area_	 entry returns (ptr);
       80 
       81 	dcl     (addr, baseno, codeptr, divide, environmentptr, fixed, length, min, null, ptr, rel, stackframeptr,
       82 	        stackbaseptr)	 builtin;
       83 	dcl     cleanup		 condition;
       84 	dcl     error_table_$long_record
       85 				 ext static fixed bin (35);
       86 
       87 /* Establish this frame as the "top" of the listener frame thread, so this
       88*   frame cannot be "released" around. */
       89 
       90 	entry = 0;
       91 	go to re_enter;
       92 
       93 /* Entry called after processing quit or unclaimed signal: */
       94 
       95 release_stack:
       96      entry (should_restore_attachments);
       97 
       98 	entry = 1;
       99 
      100 /* Save pointer to previous listener control information, save return point
      101*   for subsequent invocations of the listener, and initialize switches */
      102 
      103 re_enter:
      104 	if listen_static_data_.first_level_sw
      105 	then do;					/* no previous invocation to work from */
      106 		listener_control.prev_ptr = null;
      107 		listener_control.level = 1;		/* this is first invocation */
      108 		sp = stackframeptr ();
      109 		spno = baseno (sp);			/* get segno for comparing */
      110 		i = 0;
      111 		do while (baseno (sp -> stack_frame.prev_sp) = spno & sp ^= null);
      112 		     i = i + 1;
      113 		     sp = sp -> stack_frame.prev_sp;
      114 		end;
      115 		listener_control.frame = i;
      116 	     end;
      117 	else do;					/* can use info from previous invocation */
      118 		listener_control.prev_ptr = listen_static_data_.control_ptr;
      119 		listener_control.level = listen_static_data_.control_ptr -> based_listener_control.level + 1;
      120 		old_sp = environmentptr (listen_static_data_.control_ptr -> based_listener_control.start);
      121 		sp = stackframeptr ();
      122 		i = listen_static_data_.control_ptr -> based_listener_control.frame;
      123 		do while (sp ^= old_sp & sp ^= null);	/* find # of intervening frames */
      124 		     i = i + 1;
      125 		     sp = sp -> stack_frame.prev_sp;	/* back ptr is safer to use */
      126 		end;
      127 		listener_control.frame = i;
      128 	     end;
      129 
      130 /* fill in labels for release and start */
      131 	if (entry = 0) | listen_static_data_.first_level_sw
      132 	then do;
      133 		listener_control.release_all, listener_control.release, listener_control.new_release = READY_LABEL;
      134 		listen_static_data_.first_level_sw = "0"b;
      135 	     end;
      136 	else do;					/* will want to release to invocation before this one */
      137 		listener_control.release = listen_static_data_.control_ptr -> based_listener_control.new_release;
      138 		listener_control.new_release = READY_LABEL;
      139 		listener_control.release_all = listen_static_data_.control_ptr -> based_listener_control.release_all;
      140 	     end;
      141 	listener_control.start = START_LABEL;
      142 
      143 	listen_static_data_.control_ptr = addr (listener_control);	/* have finished getting info from old frame */
      144 
      145 	listener_control.flags.dont_restore_sw = "0"b;
      146 
      147 /* set ptrs to current control info and to buffer in which to read in command line */
      148 	buffer_length = 32;				/* start with 128 char input buffer */
      149 	call cu_$grow_stack_frame (buffer_length, buffer_ptr, code);
      150 						/* get storage for initial buffer */
      151 
      152 /* Establish cleanup procedure to restore control structure thread */
      153 	on condition (cleanup)
      154 	     begin;
      155 		listen_static_data_.control_ptr =
      156 		     listen_static_data_.control_ptr -> based_listener_control.prev_ptr;  /* pop level */
      157 		if listen_static_data_.control_ptr = null
      158 		then listen_static_data_.first_level_sw = "1"b;			/* used mainly in test case */
      159 	     end;
      160 
      161 /* If called at the listen_ entry, set up initial command line. */
      162 	if entry = 0
      163 	then do;
      164 		if initial_command_line ^= ""
      165 		then do;
      166 			if length (initial_command_line) > buffer_length * 4
      167 			then do;
      168 				call com_err_ (0, "listen_", "Initial command line is too long. Max=^d chars.",
      169 				     buffer_length * 4);
      170 				go to READY_LABEL;
      171 			     end;
      172 			input_length = length (initial_command_line);
      173 			command_line = initial_command_line;
      174 			total_input_length = 0;
      175 			go to CALL_CP;
      176 		     end;
      177 	     end;
      178 
      179 /* ******************************START OF BASIC LISTENER LOOP ****************************** */
      180 
      181 /* Call the "ready procedure".  The standard one prints the ready message. */
      182 /* In case of video system, restore output. */
      183 
      184 READY_LABEL:
      185 	call iox_$control (iox_$user_input, "reset_more", null (), (0));
      186 	call cu_$ready_proc ();
      187 
      188 /* Read the next command line */
      189 readnew:
      190 	read_ptr = buffer_ptr;
      191 	total_input_length = 0;			/* extra input line character count */
      192 read:
      193 	call iox_$get_line (iox_$user_input, read_ptr, buffer_length * 4 - total_input_length, input_length, code);
      194 	if code ^= 0
      195 	then do;
      196 		if code ^= error_table_$long_record
      197 		then call iox_signal_ (iox_$user_input, code);
      198 		else do;
      199 			if input_length < buffer_length * 4 - total_input_length
      200 			then goto CALL_CP;
      201 			call cu_$grow_stack_frame (buffer_length, dummy_ptr, code);
      202 						/* double size of buffer */
      203 			buffer_length = buffer_length + buffer_length;
      204 			read_ptr = addr (read_ptr -> ch (input_length));
      205 			total_input_length = total_input_length + input_length;
      206 		     end;
      207 		goto read;
      208 	     end;
      209 
      210 CALL_CP:
      211 	call cu_$cp (buffer_ptr, total_input_length + input_length, code);
      212 	if code = 100
      213 	then go to readnew;				/* ignore null command line */
      214 	go to READY_LABEL;
      215 
      216 /* ****************************** END OF BASIC LISTENER LOOP ****************************** */
      217 
      218 START_LABEL:					/* start command goes here */
      219 	if listener_control.flags.dont_restore_sw
      220 	then should_restore_attachments = "0"b;
      221 	listen_static_data_.control_ptr = listen_static_data_.control_ptr -> based_listener_control.prev_ptr;
      222 	return;
      223 
      224 get_pct:
      225      entry (P_listener_control_ptr);
      226 
      227 	dcl     P_listener_control_ptr		 ptr;
      228 
      229 /* Return pointer to control structure */
      230 	P_listener_control_ptr = listen_static_data_.control_ptr;
      231 	return;
      232 
      233 get_level:
      234      entry (level_no, frame_no);
      235 
      236 /* return command level number and stack frame number of caller's caller */
      237 
      238 	dcl     (level_no, frame_no)	 fixed bin;
      239 
      240 	if listen_static_data_.control_ptr = null
      241 	then do;					/* no previous invocation */
      242 		level_no = 0;
      243 		old_sp = stackbaseptr () -> stack_header.stack_begin_ptr;
      244 						/* in case we're not in highest ring */
      245 		frame_no = 0;
      246 	     end;
      247 	else do;					/* count only up to previous listener */
      248 		level_no = listen_static_data_.control_ptr -> based_listener_control.level;
      249 		old_sp = environmentptr (listen_static_data_.control_ptr -> based_listener_control.start);
      250 		frame_no = listen_static_data_.control_ptr -> based_listener_control.frame;
      251 	     end;
      252 
      253 	sp = stackframeptr () -> stack_frame.prev_sp -> stack_frame.prev_sp;
      254 						/* want frame no of caller's caller */
      255 	do while (sp ^= old_sp);
      256 	     frame_no = frame_no + 1;
      257 	     sp = sp -> stack_frame.prev_sp;
      258 	end;
      259 	return;
      260 
      261 get_area:
      262      entry returns (ptr);
      263 
      264 	return (get_system_free_area_ ());
      265 
  1     1 /* --------------- BEGIN include file iox_dcls.incl.pl1 --------------- */
  1     2 
  1     3 /* Written 05/04/78 by C. D. Tavares */
  1     4 /* Fixed declaration of iox_$find_iocb_n 05/07/80 by R. Holmstedt */
  1     5 /* Modified 5/83 by S. Krupp to add declarations for:  iox_$open_file,
  1     6*     iox_$close_file, iox_$detach and iox_$attach_loud entries. */
  1     7 
  1     8 dcl  iox_$attach_name entry (char (*), pointer, char (*), pointer, fixed bin (35)),
  1     9      iox_$attach_ptr entry (pointer, char (*), pointer, fixed bin (35)),
  1    10      iox_$close entry (pointer, fixed bin (35)),
  1    11      iox_$control entry (pointer, char (*), pointer, fixed bin (35)),
  1    12      iox_$delete_record entry (pointer, fixed bin (35)),
  1    13      iox_$destroy_iocb entry (pointer, fixed bin (35)),
  1    14      iox_$detach_iocb entry (pointer, fixed bin (35)),
  1    15      iox_$err_not_attached entry options (variable),
  1    16      iox_$err_not_closed entry options (variable),
  1    17      iox_$err_no_operation entry options (variable),
  1    18      iox_$err_not_open entry options (variable),
  1    19      iox_$find_iocb entry (char (*), pointer, fixed bin (35)),
  1    20      iox_$find_iocb_n entry (fixed bin, ptr, fixed bin(35)),
  1    21      iox_$get_chars entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  1    22      iox_$get_line entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  1    23      iox_$look_iocb entry (char (*), pointer, fixed bin (35)),
  1    24      iox_$modes entry (pointer, char (*), char (*), fixed bin (35)),
  1    25      iox_$move_attach entry (pointer, pointer, fixed bin (35)),
  1    26      iox_$open entry (pointer, fixed bin, bit (1) aligned, fixed bin (35)),
  1    27      iox_$position entry (pointer, fixed bin, fixed bin (21), fixed bin (35)),
  1    28      iox_$propagate entry (pointer),
  1    29      iox_$put_chars entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  1    30      iox_$read_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  1    31      iox_$read_length entry (pointer, fixed bin (21), fixed bin (35)),
  1    32      iox_$read_record entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  1    33      iox_$rewrite_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  1    34      iox_$seek_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  1    35      iox_$write_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  1    36      iox_$open_file entry(ptr, fixed bin, char(*), bit(1) aligned, fixed bin(35)),
  1    37      iox_$close_file entry(ptr, char(*), fixed bin(35)),
  1    38      iox_$detach entry(ptr, char(*), fixed bin(35)),
  1    39      iox_$attach_loud entry(ptr, char(*), ptr, fixed bin(35));
  1    40 
  1    41 dcl (iox_$user_output,
  1    42      iox_$user_input,
  1    43      iox_$user_io,
  1    44      iox_$error_output) external static pointer;
  1    45 
  1    46 /* ---------------- END include file iox_dcls.incl.pl1 ---------------- */
      266 
      267 
  2     1 /* INCLUDE FILE -- listener_info.incl.pl1  */
  2     2 
  2     3 /* Written 12/07/84 Steve Herbst */
  2     4 
  2     5 
  2     6 dcl 1 listen_static_data_ aligned external static,	/* referenced by both listen_ and absentee_listen_ */
  2     7      2 control_ptr ptr init (null),			/* points to current listener_control */
  2     8      2 first_level_sw bit (1) aligned init ("1"b);	/* ON if this is the top listener level */
  2     9 
  2    10 
  2    11 dcl 1 based_listener_control aligned			/* structure containing all control info */
  2    12 	based (listen_static_data_.control_ptr),
  2    13      2 prev_ptr ptr,				/* to previous listener_control, if any */
  2    14      2 (release_all,				/* label transferred to by "release -all" */
  2    15         release,					/* label transferred to by "release" */
  2    16         new_release,				/* next invocation's release label */
  2    17         start					/* label transferred to by the start command */
  2    18 	) label,
  2    19      2 flags aligned,
  2    20       3 dont_restore_sw bit (1) unaligned,		/* ON => don't restore I/O attachments on "start" */
  2    21       3 pad bit (35) unaligned,
  2    22      2 frame fixed bin,				/* stack frame number of current listener */
  2    23      2 level fixed bin;				/* listener level number of current listener */
  2    24 
  2    25 /* E* END INCLUDE FILE -- listener_info.incl.pl1 */
  2    26 
  2    27      
      268 
      269 
  3     1 /* 	BEGIN INCLUDE FILE ... stack_frame.incl.pl1 ... */
  3     2 
  3     3 /* format: off */
  3     4 
  3     5 /* Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr and pl1_ps_ptr */
  3     6 /* Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager bit & main_proc bit */
  3     7 /* Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr */
  3     8 /* Modified: 03/01/84, S. Herbst - Added RETURN_PTR_MASK */
  3     9 
  3    10 
  3    11 /****^  HISTORY COMMENTS:
  3    12*  1) change(86-09-15,Kissel), approve(86-09-15,MCR7473),
  3    13*     audit(86-10-01,Fawcett), install(86-11-03,MR12.0-1206):
  3    14*     Modified to add constants for the translator_id field in the stack_frame
  3    15*     structure.
  3    16*                                                   END HISTORY COMMENTS */
  3    17 
  3    18 
  3    19 dcl RETURN_PTR_MASK bit (72) int static options (constant)  /* mask to be AND'd with stack_frame.return_ptr */
  3    20 	init ("777777777777777777000000"b3);		/* when copying, to ignore bits that a call fills */
  3    21 						/* with indicators (nonzero for Fortran hexfp caller) */
  3    22 			/* say: unspec(ptr) = unspec(stack_frame.return_ptr) & RETURN_PTR_MASK; */
  3    23 
  3    24 dcl TRANSLATOR_ID_PL1V2 bit (18) internal static options (constant) init ("000000"b3);
  3    25 dcl TRANSLATOR_ID_ALM bit (18) internal static options (constant) init ("000001"b3);
  3    26 dcl TRANSLATOR_ID_PL1V1 bit (18) internal static options (constant) init ("000002"b3);
  3    27 dcl TRANSLATOR_ID_SIGNAL_CALLER bit (18) internal static options (constant) init ("000003"b3);
  3    28 dcl TRANSLATOR_ID_SIGNALLER bit (18) internal static options (constant) init ("000004"b3);
  3    29 
  3    30 
  3    31 dcl  sp pointer;					/* pointer to beginning of stack frame */
  3    32 
  3    33 dcl  stack_frame_min_length fixed bin static init(48);
  3    34 
  3    35 
  3    36 dcl 1 stack_frame based(sp) aligned,
  3    37     2 pointer_registers(0 : 7) ptr,
  3    38     2 prev_sp pointer,
  3    39     2 next_sp pointer,
  3    40     2 return_ptr pointer,
  3    41     2 entry_ptr pointer,
  3    42     2 operator_and_lp_ptr ptr,			/* serves as both */
  3    43     2 arg_ptr pointer,
  3    44     2 static_ptr ptr unaligned,
  3    45     2 support_ptr ptr unal, /* only used by fortran I/O */
  3    46     2 on_unit_relp1 bit(18) unaligned,
  3    47     2 on_unit_relp2 bit(18) unaligned,
  3    48     2 translator_id bit(18) unaligned,			/* Translator ID (see constants above)
  3    49*						   0 => PL/I version II
  3    50*						   1 => ALM
  3    51*						   2 => PL/I version I   
  3    52*						   3 => signal caller frame
  3    53*						   4 => signaller frame */
  3    54     2 operator_return_offset bit(18) unaligned,
  3    55     2 x(0: 7) bit(18) unaligned,			/* index registers */
  3    56     2 a bit(36),					/* accumulator */
  3    57     2 q bit(36),					/* q-register */
  3    58     2 e bit(36),					/* exponent */
  3    59     2 timer bit(27) unaligned,				/* timer */
  3    60     2 pad bit(6) unaligned,
  3    61     2 ring_alarm_reg bit(3) unaligned;
  3    62 
  3    63 
  3    64 dcl 1 stack_frame_flags based(sp) aligned,
  3    65     2 pad(0 : 7) bit(72),				/* skip over prs */
  3    66     2 xx0 bit(22) unal,
  3    67     2 main_proc bit(1) unal,				/* on if frame belongs to a main procedure */
  3    68     2 run_unit_manager bit(1) unal,			/* on if frame belongs to run unit manager */
  3    69     2 signal bit(1) unal,				/* on if frame belongs to logical signal_ */
  3    70     2 crawl_out bit(1) unal,				/* on if this is a signal caller frame */
  3    71     2 signaller bit(1) unal,				/* on if next frame is signaller's */
  3    72     2 link_trap bit(1) unal,				/* on if this frame was made by the linker */
  3    73     2 support bit(1) unal,				/* on if frame belongs to a support proc */
  3    74     2 condition bit(1) unal,				/* on if condition established in this frame */
  3    75     2 xx0a bit(6) unal,
  3    76     2 xx1 fixed bin,
  3    77     2 xx2 fixed bin,
  3    78     2 xx3 bit(25) unal,
  3    79     2 old_crawl_out bit (1) unal,			/* on if this is a signal caller frame */
  3    80     2 old_signaller bit(1) unal,			/* on if next frame is signaller's */
  3    81     2 xx3a bit(9) unaligned,
  3    82     2 xx4(9) bit(72) aligned,
  3    83     2 v2_pl1_op_ret_base ptr,				/* When a V2 PL/I program calls an operator the
  3    84*						*  operator puts a pointer to the base of
  3    85*						*  the calling procedure here. (text base ptr)  */
  3    86     2 xx5 bit(72) aligned,
  3    87     2 pl1_ps_ptr ptr;				/* ptr to ps for this frame; also used by fio. */
  3    88 
  3    89 /* format: on */
  3    90 
  3    91 /* 	END INCLUDE FILE ... stack_frame.incl.pl1 */
      270 
      271 
  4     1 /* 	BEGIN INCLUDE FILE ... stack_header.incl.pl1 .. 3/72 Bill Silver  */
  4     2 /*	modified 7/76 by M. Weaver for *system links and more system use of areas */
  4     3 /*	modified 3/77 by M. Weaver to add rnt_ptr */
  4     4 /*	Modified April 1983 by C. Hornig for tasking */
  4     5 
  4     6 /****^  HISTORY COMMENTS:
  4     7*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
  4     8*     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
  4     9*     added the heap_header_ptr definition.
  4    10*  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  4    11*     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
  4    12*     Modified to support control point management.  These changes were actually
  4    13*     made in February 1985 by G. Palter.
  4    14*  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
  4    15*     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
  4    16*     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
  4    17*     bit pad after cur_lot_size for the cpm_enabled. This was done to save some
  4    18*     space int the stack header and change the cpd_ptr unal to cpm_data_ptr
  4    19*     (ITS pair).
  4    20*                                                   END HISTORY COMMENTS */
  4    21 
  4    22 /* format: style2 */
  4    23 
  4    24      dcl	   sb		      ptr;		/* the  main pointer to the stack header */
  4    25 
  4    26      dcl	   1 stack_header	      based (sb) aligned,
  4    27 	     2 pad1	      (4) fixed bin,	/*  (0) also used as arg list by outward_call_handler  */
  4    28 	     2 cpm_data_ptr	      ptr,		/*  (4)  pointer to control point which owns this stack */
  4    29 	     2 combined_stat_ptr  ptr,		/*  (6)  pointer to area containing separate static */
  4    30 	     2 clr_ptr	      ptr,		/*  (8)  pointer to area containing linkage sections */
  4    31 	     2 max_lot_size	      fixed bin (17) unal,	/*  (10) DU  number of words allowed in lot */
  4    32 	     2 main_proc_invoked  fixed bin (11) unal,	/*  (10) DL  nonzero if main procedure invoked in run unit */
  4    33 	     2 have_static_vlas   bit (1) unal,		/*  (10) DL  "1"b if (very) large arrays are being used in static */
  4    34 	     2 pad4	      bit (2) unal,
  4    35 	     2 run_unit_depth     fixed bin (2) unal,	/*  (10) DL  number of active run units stacked */
  4    36 	     2 cur_lot_size	      fixed bin (17) unal,	/*  (11) DU  number of words (entries) in lot */
  4    37 	     2 cpm_enabled	      bit (18) unal,	/*  (11) DL  non-zero if control point management is enabled */
  4    38 	     2 system_free_ptr    ptr,		/*  (12)  pointer to system storage area */
  4    39 	     2 user_free_ptr      ptr,		/*  (14)  pointer to user storage area */
  4    40 	     2 null_ptr	      ptr,		/*  (16)  */
  4    41 	     2 stack_begin_ptr    ptr,		/*  (18)  pointer to first stack frame on the stack */
  4    42 	     2 stack_end_ptr      ptr,		/*  (20)  pointer to next useable stack frame */
  4    43 	     2 lot_ptr	      ptr,		/*  (22)  pointer to the lot for the current ring */
  4    44 	     2 signal_ptr	      ptr,		/*  (24)  pointer to signal procedure for current ring */
  4    45 	     2 bar_mode_sp	      ptr,		/*  (26)  value of sp before entering bar mode */
  4    46 	     2 pl1_operators_ptr  ptr,		/*  (28)  pointer to pl1_operators_$operator_table */
  4    47 	     2 call_op_ptr	      ptr,		/*  (30)  pointer to standard call operator */
  4    48 	     2 push_op_ptr	      ptr,		/*  (32)  pointer to standard push operator */
  4    49 	     2 return_op_ptr      ptr,		/*  (34)  pointer to standard return operator */
  4    50 	     2 return_no_pop_op_ptr
  4    51 			      ptr,		/*  (36)  pointer to standard return / no pop operator */
  4    52 	     2 entry_op_ptr	      ptr,		/*  (38)  pointer to standard entry operator */
  4    53 	     2 trans_op_tv_ptr    ptr,		/*  (40)  pointer to translator operator ptrs */
  4    54 	     2 isot_ptr	      ptr,		/*  (42)  pointer to ISOT */
  4    55 	     2 sct_ptr	      ptr,		/*  (44)  pointer to System Condition Table */
  4    56 	     2 unwinder_ptr	      ptr,		/*  (46)  pointer to unwinder for current ring */
  4    57 	     2 sys_link_info_ptr  ptr,		/*  (48)  pointer to *system link name table */
  4    58 	     2 rnt_ptr	      ptr,		/*  (50)  pointer to Reference Name Table */
  4    59 	     2 ect_ptr	      ptr,		/*  (52)  pointer to event channel table */
  4    60 	     2 assign_linkage_ptr ptr,		/*  (54)  pointer to storage for (obsolete) hcs_$assign_linkage */
  4    61 	     2 heap_header_ptr     ptr,		/*  (56)  pointer to the heap header for this ring */
  4    62 	     2 trace,
  4    63 	       3 frames,
  4    64 	         4 count	      fixed bin,		/*  (58)  number of trace frames */
  4    65 	         4 top_ptr	      ptr unal,		/*  (59)  pointer to last trace frame */
  4    66 	       3 in_trace	      bit (36) aligned,	/*  (60)  trace antirecursion flag */
  4    67 	     2 pad2	      bit (36),		/*  (61) */
  4    68                2 pad5	      pointer;		/*  (62)  pointer to future stuff */
  4    69 
  4    70 /*	The following offset refers to a table within the  pl1  operator table.  */
  4    71 
  4    72      dcl	   tv_offset	      fixed bin init (361) internal static;
  4    73 						/* (551) octal */
  4    74 
  4    75 
  4    76 /*	The following constants are offsets within this transfer vector table.  */
  4    77 
  4    78      dcl	   (
  4    79 	   call_offset	      fixed bin init (271),
  4    80 	   push_offset	      fixed bin init (272),
  4    81 	   return_offset	      fixed bin init (273),
  4    82 	   return_no_pop_offset   fixed bin init (274),
  4    83 	   entry_offset	      fixed bin init (275)
  4    84 	   )		      internal static;
  4    85 
  4    86 
  4    87 
  4    88 
  4    89 
  4    90 /*	The following declaration  is an overlay of the whole stack header.   Procedures which
  4    91*	move the whole stack header should use this overlay.
  4    92**/
  4    93 
  4    94      dcl	   stack_header_overlay   (size (stack_header)) fixed bin based (sb);
  4    95 
  4    96 
  4    97 
  4    98 /* 	END INCLUDE FILE ... stack_header.incl.pl1 */
      272 
      273 
      274 
      275 end listen_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/04/86  1033.9  listen_.pl1                       >special_ldd>install>MR12.0-1206>listen_.pl1
266          1    05/23/83  0916.6  iox_entries.incl.pl1              >ldd>include>iox_dcls.incl.pl1
268          2    12/20/84  0952.2  listener_info.incl.pl1            >ldd>include>listener_info.incl.pl1
270          3    11/03/86  1114.7  stack_frame.incl.pl1              >special_ldd>install>MR12.0-1206>stack_frame.incl.pl1
272          4    11/04/86  1324.3  stack_header.incl.pl1             >special_ldd>install>MR12.0-1206>stack_header.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
P_listener_control_ptr                 parameter       pointer                  dcl 227 set ref 224 230*
addr                                                   builtin function         dcl 81 ref 143 204
based_listener_control                 based           structure                level 1 dcl 2-11
baseno                                                 builtin function         dcl 81 ref 109 111
buffer_length                   000111 automatic       fixed bin(21,0)          dcl 53 set ref 148* 149* 166 168 192 199 201* 203*
                                                                                  203 203
buffer_ptr                      000100 automatic       pointer                  dcl 46 set ref 149* 173 189 210*
ch                                     based           char(1)                  array level 2 packed unaligned dcl 67 set ref 204
cleanup                         000146 stack reference condition                dcl 83 ref 153
code                            000115 automatic       fixed bin(35,0)          dcl 58 set ref 149* 192* 194 196 196* 201* 210* 212
com_err_                        000012 constant        entry                    external dcl 75 ref 168
command_line                           based           char                     dcl 60 set ref 173*
control_ptr                     000034 external static pointer                  initial level 2 dcl 2-6 set ref 118 119 120 122 137
                                                                                  139 143* 155* 155 157 221* 221 230 240 248 249 250
cu_$cp                          000014 constant        entry                    external dcl 76 ref 210
cu_$grow_stack_frame            000020 constant        entry                    external dcl 78 ref 149 201
cu_$ready_proc                  000016 constant        entry                    external dcl 77 ref 186
dont_restore_sw          22     000120 automatic       bit(1)                   level 3 packed unaligned dcl 71 set ref 145* 218
dummy_ptr                       000104 automatic       pointer                  dcl 46 set ref 201*
entry                           000113 automatic       fixed bin(17,0)          dcl 56 set ref 90* 98* 131 162
environmentptr                                         builtin function         dcl 81 ref 120 249
error_table_$long_record        000024 external static fixed bin(35,0)          dcl 84 ref 196
first_level_sw            2     000034 external static bit(1)                   initial level 2 dcl 2-6 set ref 103 131 134* 157*
flags                    22     000120 automatic       structure                level 2 dcl 71
frame                    23     000120 automatic       fixed bin(17,0)          level 2 in structure "listener_control" dcl 71
                                                                                  in procedure "listen_" set ref 115* 127*
frame                    23            based           fixed bin(17,0)          level 2 in structure "based_listener_control"
                                                                                  dcl 2-11 in procedure "listen_" ref 122 250
frame_no                               parameter       fixed bin(17,0)          dcl 238 set ref 233 245* 250* 256* 256
get_system_free_area_           000022 constant        entry                    external dcl 79 ref 264
i                               000114 automatic       fixed bin(17,0)          dcl 56 set ref 110* 112* 112 115 122* 124* 124 127
initial_command_line                   parameter       varying char             dcl 60 ref 12 164 166 172 173
input_length                    000110 automatic       fixed bin(21,0)          dcl 53 set ref 172* 173 192* 199 204 205 210
iox_$control                    000026 constant        entry                    external dcl 1-8 ref 184
iox_$get_line                   000030 constant        entry                    external dcl 1-8 ref 192
iox_$user_input                 000032 external static pointer                  dcl 1-41 set ref 184* 192* 196*
iox_signal_                     000010 constant        entry                    external dcl 74 ref 196
length                                                 builtin function         dcl 81 ref 166 172
level                    24     000120 automatic       fixed bin(17,0)          level 2 in structure "listener_control" dcl 71
                                                                                  in procedure "listen_" set ref 107* 119*
level                    24            based           fixed bin(17,0)          level 2 in structure "based_listener_control"
                                                                                  dcl 2-11 in procedure "listen_" ref 119 248
level_no                               parameter       fixed bin(17,0)          dcl 238 set ref 233 242* 248*
listen_static_data_             000034 external static structure                level 1 dcl 2-6
listener_control                000120 automatic       structure                level 1 dcl 71 set ref 143
new_release              12            based           label variable           level 2 in structure "based_listener_control"
                                                                                  dcl 2-11 in procedure "listen_" ref 137
new_release              12     000120 automatic       label variable           level 2 in structure "listener_control" dcl 71
                                                                                  in procedure "listen_" set ref 133* 138*
null                                                   builtin function         dcl 81 ref 106 111 123 157 184 184 240
old_sp                          000106 automatic       pointer                  dcl 46 set ref 120* 123 243* 249* 255
prev_ptr                               based           pointer                  level 2 in structure "based_listener_control"
                                                                                  dcl 2-11 in procedure "listen_" ref 155 221
prev_ptr                        000120 automatic       pointer                  level 2 in structure "listener_control" dcl 71
                                                                                  in procedure "listen_" set ref 106* 118*
prev_sp                  20            based           pointer                  level 2 dcl 3-36 ref 111 113 125 253 253 257
read_ptr                        000102 automatic       pointer                  dcl 46 set ref 189* 192* 204* 204
release                   6     000120 automatic       label variable           level 2 dcl 71 set ref 133* 137*
release_all               2            based           label variable           level 2 in structure "based_listener_control"
                                                                                  dcl 2-11 in procedure "listen_" ref 139
release_all               2     000120 automatic       label variable           level 2 in structure "listener_control" dcl 71
                                                                                  in procedure "listen_" set ref 133* 139*
should_restore_attachments             parameter       bit(1)                   dcl 63 set ref 95 218*
sp                              000154 automatic       pointer                  dcl 3-31 set ref 108* 109 111 111 113* 113 121* 123
                                                                                  123 125* 125 253* 255 257* 257
spno                            000116 automatic       bit(18)                  dcl 63 set ref 109* 111
stack_begin_ptr          22            based           pointer                  level 2 dcl 4-26 ref 243
stack_frame                            based           structure                level 1 dcl 3-36
stack_header                           based           structure                level 1 dcl 4-26
stackbaseptr                                           builtin function         dcl 81 ref 243
stackframeptr                                          builtin function         dcl 81 ref 108 121 253
start                    16     000120 automatic       label variable           level 2 in structure "listener_control" dcl 71
                                                                                  in procedure "listen_" set ref 141*
start                    16            based           label variable           level 2 in structure "based_listener_control"
                                                                                  dcl 2-11 in procedure "listen_" ref 120 249
total_input_length              000112 automatic       fixed bin(21,0)          dcl 55 set ref 174* 191* 192 199 205* 205 210
x                                      based           structure                level 1 dcl 67

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
RETURN_PTR_MASK                        internal static bit(72)                  initial unaligned dcl 3-19
TRANSLATOR_ID_ALM                      internal static bit(18)                  initial unaligned dcl 3-25
TRANSLATOR_ID_PL1V1                    internal static bit(18)                  initial unaligned dcl 3-26
TRANSLATOR_ID_PL1V2                    internal static bit(18)                  initial unaligned dcl 3-24
TRANSLATOR_ID_SIGNALLER                internal static bit(18)                  initial unaligned dcl 3-28
TRANSLATOR_ID_SIGNAL_CALLER            internal static bit(18)                  initial unaligned dcl 3-27
call_offset                            internal static fixed bin(17,0)          initial dcl 4-78
codeptr                                                builtin function         dcl 81
divide                                                 builtin function         dcl 81
entry_offset                           internal static fixed bin(17,0)          initial dcl 4-78
fixed                                                  builtin function         dcl 81
iox_$attach_loud                000000 constant        entry                    external dcl 1-8
iox_$attach_name                000000 constant        entry                    external dcl 1-8
iox_$attach_ptr                 000000 constant        entry                    external dcl 1-8
iox_$close                      000000 constant        entry                    external dcl 1-8
iox_$close_file                 000000 constant        entry                    external dcl 1-8
iox_$delete_record              000000 constant        entry                    external dcl 1-8
iox_$destroy_iocb               000000 constant        entry                    external dcl 1-8
iox_$detach                     000000 constant        entry                    external dcl 1-8
iox_$detach_iocb                000000 constant        entry                    external dcl 1-8
iox_$err_no_operation           000000 constant        entry                    external dcl 1-8
iox_$err_not_attached           000000 constant        entry                    external dcl 1-8
iox_$err_not_closed             000000 constant        entry                    external dcl 1-8
iox_$err_not_open               000000 constant        entry                    external dcl 1-8
iox_$error_output                      external static pointer                  dcl 1-41
iox_$find_iocb                  000000 constant        entry                    external dcl 1-8
iox_$find_iocb_n                000000 constant        entry                    external dcl 1-8
iox_$get_chars                  000000 constant        entry                    external dcl 1-8
iox_$look_iocb                  000000 constant        entry                    external dcl 1-8
iox_$modes                      000000 constant        entry                    external dcl 1-8
iox_$move_attach                000000 constant        entry                    external dcl 1-8
iox_$open                       000000 constant        entry                    external dcl 1-8
iox_$open_file                  000000 constant        entry                    external dcl 1-8
iox_$position                   000000 constant        entry                    external dcl 1-8
iox_$propagate                  000000 constant        entry                    external dcl 1-8
iox_$put_chars                  000000 constant        entry                    external dcl 1-8
iox_$read_key                   000000 constant        entry                    external dcl 1-8
iox_$read_length                000000 constant        entry                    external dcl 1-8
iox_$read_record                000000 constant        entry                    external dcl 1-8
iox_$rewrite_record             000000 constant        entry                    external dcl 1-8
iox_$seek_key                   000000 constant        entry                    external dcl 1-8
iox_$user_io                           external static pointer                  dcl 1-41
iox_$user_output                       external static pointer                  dcl 1-41
iox_$write_record               000000 constant        entry                    external dcl 1-8
min                                                    builtin function         dcl 81
ptr                                                    builtin function         dcl 81
push_offset                            internal static fixed bin(17,0)          initial dcl 4-78
rel                                                    builtin function         dcl 81
return_no_pop_offset                   internal static fixed bin(17,0)          initial dcl 4-78
return_offset                          internal static fixed bin(17,0)          initial dcl 4-78
sb                                     automatic       pointer                  dcl 4-24
stack_frame_flags                      based           structure                level 1 dcl 3-64
stack_frame_min_length                 internal static fixed bin(17,0)          initial dcl 3-33
stack_header_overlay                   based           fixed bin(17,0)          array dcl 4-94
tv_offset                              internal static fixed bin(17,0)          initial dcl 4-72

NAMES DECLARED BY EXPLICIT CONTEXT.
CALL_CP                         000537 constant        label                    dcl 210 ref 175 199
READY_LABEL                     000403 constant        label                    dcl 184 ref 133 138 170 214
START_LABEL                     000561 constant        label                    dcl 218 ref 141
get_area                        000717 constant        entry                    external dcl 261
get_level                       000634 constant        entry                    external dcl 233
get_pct                         000605 constant        entry                    external dcl 224
listen_                         000050 constant        entry                    external dcl 12
re_enter                        000103 constant        label                    dcl 103 ref 91
read                            000446 constant        label                    dcl 192 ref 207
readnew                         000443 constant        label                    dcl 189 ref 212
release_stack                   000072 constant        entry                    external dcl 95

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1152        1210     747        1162
Length      1510     747        36         263     203           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
listen_                             158 external procedure  is an external procedure.  
on unit on line 153                  64 on unit               

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
listen_                  000100 buffer_ptr                  listen_
                         000102 read_ptr                    listen_
                         000104 dummy_ptr                   listen_
                         000106 old_sp                      listen_
                         000110 input_length                listen_
                         000111 buffer_length               listen_
                         000112 total_input_length          listen_
                         000113 entry                       listen_
                         000114 i                           listen_
                         000115 code                        listen_
                         000116 spno                        listen_
                         000120 listener_control            listen_
                         000154 sp                          listen_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          signal_op           enable_op           ext_entry
ext_entry_desc      int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$cp                        cu_$grow_stack_frame          cu_$ready_proc
get_system_free_area_         iox_$control                  iox_$get_line                 iox_signal_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$long_record      iox_$user_input               listen_static_data_




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     12 000045        90 000065        91 000066        95 000067        98 000101       103 000103       106 000107
    107 000111       108 000113       109 000114       110 000117       111 000120       112 000131       113 000132
    114 000134       115 000135       116 000137       118 000140       119 000143       120 000150       121 000152
    122 000153       123 000155       124 000166       125 000167       126 000172       127 000173       131 000175
    133 000203       134 000222       135 000225       137 000226       138 000234       139 000237       141 000243
    143 000246       145 000250       148 000252       149 000254       153 000266       155 000302       157 000306
    159 000315       162 000316       164 000320       166 000327       168 000333       170 000371       172 000372
    173 000374       174 000401       175 000402       184 000403       186 000436       189 000443       191 000445
    192 000446       194 000471       196 000473       199 000507       201 000514       203 000526       204 000530
    205 000534       207 000536       210 000537       212 000555       214 000560       218 000561       221 000566
    222 000573       224 000602       230 000614       231 000621       233 000630       240 000643       242 000650
    243 000652       245 000655       246 000656       248 000657       249 000664       250 000666       253 000670
    255 000674       256 000700       257 000702       258 000705       259 000706       261 000715       264 000725


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
