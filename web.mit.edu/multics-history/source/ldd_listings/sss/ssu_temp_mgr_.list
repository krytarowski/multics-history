	COMPILATION LISTING OF SEGMENT ssu_temp_mgr_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phx. Az., Sys-M 
	Compiled on: 08/04/87  1638.5 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /* Associates temporary segments and areas with a subsystem invocation so they may all be freed at once when the
        9*   invocation is destroyed */
       10 
       11 /* Created:  8 May 1980 by W. Olin Sibert */
       12 /* Modified: 2 November 1981 by W. Olin Sibert to fix area release bug (phx10462) */
       13 
       14 /* format: style4,delnl,insnl,ifthenstmt,ifthen */
       15 
       16 
       17 ssu_temp_mgr_:
       18      procedure ();
       19 
       20 	return;					/* not an entrypoint */
       21 
       22 
       23 /* Parameters */
       24 
       25 dcl  P_sci_ptr pointer parameter;
       26 
       27 dcl  P_comment character (*) parameter;			/* get_segment, get_area: additional info about what part of
       28*						   the subsystem wants this segment/area */
       29 
       30 dcl  P_seg_ptr pointer parameter;			/* get_segment, release_segment: set -> the segment acquired
       31*						   for get; -> segment to release for release */
       32 
       33 dcl  P_area_infop pointer parameter;			/* get_area: -> optional area_info setup by caller */
       34 
       35 dcl  P_area_ptr pointer parameter;			/* get_area, release_area: set -> the area acquired for get;
       36*						   for release, -> segment to release */
       37 
       38 
       39 /* Data describing all temporary segments and areas acquired for this subsystem */
       40 
       41 dcl  1 temp_info aligned based (temp_info_ptr),		/* describes a single segment/area */
       42        2 type fixed binary,				/* unused/segment/area */
       43        2 ptr pointer,
       44        2 name character (32) unaligned;
       45 dcl  temp_info_ptr pointer;
       46 
       47 dcl  NO_TYPE fixed binary static options (constant) initial (1);
       48 dcl  SEGMENT_TYPE fixed binary static options (constant) initial (2);
       49 dcl  AREA_TYPE fixed binary static options (constant) initial (3);
       50 
       51 dcl  1 temp_info_array aligned based (sci.temp_info_ptr),
       52        2 size fixed binary,
       53        2 element (alloc_temp_info_array_size refer (temp_info_array.size)) like temp_info;
       54 
       55 dcl  alloc_temp_info_array_size fixed binary;
       56 
       57 
       58 /* Remaining declarations */
       59 
       60 dcl  1 area_info_automatic like area_info aligned automatic;
       61 
       62 dcl  code fixed binary (35);
       63 dcl  idx fixed binary;
       64 dcl  old_ptr pointer;
       65 
       66 dcl  sys_info$max_seg_size fixed binary (19) external;
       67 
       68 dcl  error_table_$area_too_small fixed binary (35) external;
       69 dcl  error_table_$badcall fixed binary (35) external;
       70 
       71 dcl  define_area_ entry (pointer, fixed binary (35));
       72 dcl  get_temp_segment_ entry (character (*), pointer, fixed binary (35));
       73 dcl  release_area_ entry (pointer);
       74 dcl  release_temp_segment_ entry (character (*), pointer, fixed binary (35));
       75 dcl  ioa_$rsnnl entry () options (variable);
       76 dcl  ssu_$abort_line entry () options (variable);
       77 
       78 dcl  (addr, currentsize, null, unspec) builtin;
       79 
       80 /**/
       81 
       82 /* Acquire a temporary segment: on failure, aborts the request line (shouldn't ever fail anyway) */
       83 
       84 get_segment:
       85      entry (P_sci_ptr, P_comment, P_seg_ptr);
       86 
       87 	call ssu_check_sci (P_sci_ptr);
       88 
       89 	sci_ptr = P_sci_ptr;
       90 
       91 	call get_temp_info_ptr ();			/* get a pointer to an empty temp_info */
       92 
       93 	temp_info.type = SEGMENT_TYPE;
       94 	call ioa_$rsnnl ("^a.^d^[ (^a)^]", temp_info.name, (0), sci.subsystem_name, sci.recursion_info.level,
       95 	     (P_comment ^= ""), P_comment);		/* construct the name it will be allocated with */
       96 
       97 	call get_temp_segment_ (temp_info.name, temp_info.ptr, code);
       98 
       99 	if code ^= 0 then				/* try to punt... */
      100 	     call ssu_$abort_line (sci_ptr, code, "Unable to get temporary segment.");
      101 
      102 	P_seg_ptr = temp_info.ptr;
      103 
      104 	return;
      105 
      106 /**/
      107 
      108 /* Acquires an area in a temporary segment */
      109 
      110 get_area:
      111      entry (P_sci_ptr, P_area_infop, P_comment, P_area_ptr);
      112 
      113 	call ssu_check_sci (P_sci_ptr);
      114 
      115 	sci_ptr = P_sci_ptr;
      116 
      117 	call get_temp_info_ptr ();			/* get one */
      118 
      119 	temp_info.type = AREA_TYPE;
      120 	call ioa_$rsnnl ("^a.^d^[ (^a)^]", temp_info.name, (0), sci.subsystem_name, sci.recursion_info.level,
      121 	     (P_comment ^= ""), P_comment);		/* construct the name it will be allocated with */
      122 
      123 	if P_area_infop = null () then do;		/* get an area with default characteristics */
      124 	     unspec (area_info_automatic) = ""b;
      125 	     area_info_automatic.control.extend = "1"b;
      126 	     if sci.debug_mode then			/* make it non-freeing */
      127 		area_info_automatic.control.dont_free = "1"b;
      128 	     else area_info_automatic.control.zero_on_free = "1"b;
      129 	end;					/* normally, zero when freeing */
      130 
      131 	else unspec (area_info_automatic) = unspec (P_area_infop -> area_info);
      132 						/* copy the caller's area_info */
      133 
      134 	area_infop = addr (area_info_automatic);
      135 
      136 	area_info.version = area_info_version_1;	/* and set a few things therein */
      137 	area_info.areap = null ();
      138 	area_info.owner = temp_info.name;
      139 	area_info.size = sys_info$max_seg_size;		/* the entire segment, please */
      140 
      141 	call define_area_ (area_infop, code);		/* get it! */
      142 
      143 	if code ^= 0 then				/* try to punt... */
      144 	     call ssu_$abort_line (sci_ptr, code, "Unable to define area.");
      145 
      146 	temp_info.ptr = area_info.areap;
      147 	P_area_ptr = area_info.areap;			/* return the area pointer */
      148 
      149 	return;
      150 
      151 /**/
      152 
      153 /* Releases a temporary segment */
      154 
      155 release_segment:
      156      entry (P_sci_ptr, P_seg_ptr);
      157 
      158 	call ssu_check_sci (P_sci_ptr);
      159 
      160 	sci_ptr = P_sci_ptr;
      161 
      162 	if sci.temp_info_ptr = null () then		/* none even allocated yet! */
      163 	     return;
      164 
      165 	do idx = 1 to temp_info_array.size;
      166 	     temp_info_ptr = addr (temp_info_array.element (idx));
      167 
      168 	     if temp_info.type = SEGMENT_TYPE then
      169 		if temp_info.ptr = P_seg_ptr then do;
      170 		     P_seg_ptr = null ();		/* so caller doesn't try again */
      171 		     call release_temp_segment_ (temp_info.name, temp_info.ptr, (0));
      172 
      173 		     temp_info.type = NO_TYPE;	/* and free up this entry */
      174 		     temp_info.ptr = null ();
      175 		     temp_info.name = "";
      176 
      177 		     return;			/* all done */
      178 		end;
      179 	end;					/* of loop looking */
      180 
      181 	return;					/* even if we didn't find it */
      182 
      183 /**/
      184 
      185 /* Release an area */
      186 
      187 release_area:
      188      entry (P_sci_ptr, P_area_ptr);
      189 
      190 	call ssu_check_sci (P_sci_ptr);
      191 
      192 	sci_ptr = P_sci_ptr;
      193 
      194 	if sci.temp_info_ptr = null () then		/* none even allocated yet! */
      195 	     return;
      196 
      197 	do idx = 1 to temp_info_array.size;
      198 	     temp_info_ptr = addr (temp_info_array.element (idx));
      199 
      200 	     if temp_info.type = AREA_TYPE then
      201 		if temp_info.ptr = P_area_ptr then do;
      202 		     P_area_ptr = null ();		/* so caller doesn't try again */
      203 		     call release_area_ (temp_info.ptr);
      204 
      205 		     temp_info.type = NO_TYPE;	/* and free up this entry */
      206 		     temp_info.ptr = null ();
      207 		     temp_info.name = "";
      208 
      209 		     return;			/* all done */
      210 		end;
      211 	end;					/* of loop looking */
      212 
      213 	return;					/* even if we didn't find it */
      214 
      215 /**/
      216 
      217 /* Release all segments and area acquired by this subsystem: called by ssu_$destroy_invocation */
      218 
      219 release_everything:
      220      entry (P_sci_ptr);
      221 
      222 	sci_ptr = P_sci_ptr;
      223 
      224 	if sci.temp_info_ptr = null () then return;	/* no temporaries allocated */
      225 
      226 	do idx = 1 to temp_info_array.size;
      227 	     temp_info_ptr = addr (temp_info_array.element (idx));
      228 
      229 	     if temp_info.type = AREA_TYPE then call release_area_ (temp_info.ptr);
      230 
      231 	     else if temp_info.type = SEGMENT_TYPE then call release_temp_segment_ (temp_info.name, temp_info.ptr, (0));
      232 
      233 	     temp_info.type = NO_TYPE;		/* and free up this entry */
      234 	     temp_info.ptr = null ();
      235 	     temp_info.name = "";
      236 	end;					/* of loop releasing */
      237 
      238 	old_ptr = sci.temp_info_ptr;			/* null pointer first to avoid trying to free it twice */
      239 	sci.temp_info_ptr = null ();
      240 
      241 	free old_ptr -> temp_info_array in (sci_parent_area);
      242 
      243 	return;
      244 
      245 /**/
      246 
      247 /* Finds a empty temp_info element: expands the array of temp_info's if necessary */
      248 
      249 get_temp_info_ptr:
      250      procedure ();
      251 
      252 dcl  idx fixed binary;
      253 dcl  new_ptr pointer;
      254 
      255 	if sci.temp_info_ptr = null () then do;
      256 	     alloc_temp_info_array_size = 10;		/* start out with ten */
      257 	     allocate temp_info_array in (sci_parent_area) set (sci.temp_info_ptr);
      258 	     temp_info_array.size = alloc_temp_info_array_size;
      259 	     do idx = 1 to temp_info_array.size;	/* initialize them */
      260 		temp_info_array (idx).type = NO_TYPE;
      261 		temp_info_array (idx).ptr = null ();
      262 		temp_info_array (idx).name = "";
      263 	     end;
      264 	end;
      265 
      266 	do idx = 1 to temp_info_array.size;		/* look for a free one */
      267 	     if temp_info_array (idx).type = NO_TYPE then do;
      268 		temp_info_ptr = addr (temp_info_array.element (idx));
      269 		return;				/* got one */
      270 	     end;
      271 	end;
      272 
      273 	old_ptr = sci.temp_info_ptr;			/* no free slots: make it bigger */
      274 	alloc_temp_info_array_size = 3 * temp_info_array.size;
      275 
      276 	allocate temp_info_array in (sci_parent_area) set (new_ptr);
      277 
      278 	new_ptr -> temp_info_array.size = alloc_temp_info_array_size;
      279 
      280 	do idx = 1 to old_ptr -> temp_info_array.size;	/* copy all the existing ones */
      281 	     new_ptr -> temp_info_array.element (idx) = old_ptr -> temp_info_array.element (idx);
      282 	end;
      283 
      284 	do idx = (old_ptr -> temp_info_array.size + 1) to new_ptr -> temp_info_array.size;
      285 	     new_ptr -> temp_info_array (idx).type = NO_TYPE;
      286 	     new_ptr -> temp_info_array (idx).ptr = null ();
      287 	     new_ptr -> temp_info_array (idx).name = "";
      288 	end;					/* and initialize all the new ones */
      289 
      290 	sci.temp_info_ptr = new_ptr;			/* new one is now ready */
      291 
      292 	temp_info_ptr = addr (new_ptr -> temp_info_array.element (old_ptr -> temp_info_array.size + 1));
      293 						/* first new */
      294 
      295 	free old_ptr -> temp_info_array in (sci_parent_area);
      296 
      297 	return;
      298 
      299      end get_temp_info_ptr;
      300 
      301 /**/
      302 
  1     1 /*  BEGIN:   _ssu_check_sci.incl.pl1			  *  *  *  *  *  */
  1     2 
  1     3 /* Created:  25 February 1982 by G. Palter */
  1     4 /* Modified: 6 November 1984 by G. Palter for version 3 and new sub_err_ 
  1     5*				  calling sequence */
  1     6 
  1     7 
  1     8 /****^  HISTORY COMMENTS:
  1     9*  1) change(87-02-07,GDixon), approve(87-05-25,MCR7680),
  1    10*     audit(87-06-02,Parisek), install(87-08-04,MR12.1-1056):
  1    11*     Modified to verify that p_sci_ptr has proper its modifier by overlaying it
  1    12*     with the structure in its.incl.pl1, rather than assuming knowledge of
  1    13*     pointer format.
  1    14*                                                   END HISTORY COMMENTS */
  1    15 
  1    16 
  1    17 /* format: style4,delnl,insnl,ifthenstmt,ifthen */
  1    18 
  1    19 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    20 /*							       */
  1    21 /* Validates that the caller's sci_ptr acutally references a valid	       */
  1    22 /* subsystem control info structure.				       */
  1    23 /*							       */
  1    24 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    25 
  1    26 ssu_check_sci:
  1    27      procedure (p_sci_ptr);
  1    28 
  1    29 dcl  p_sci_ptr pointer parameter;
  1    30 
  1    31 dcl  SSU_ character (32) static options (constant) initial ("ssu_");
  1    32 
  1    33 dcl  error_table_$bad_ptr fixed binary (35) external;
  1    34 dcl  error_table_$null_info_ptr fixed binary (35) external;
  1    35 dcl  error_table_$unimplemented_version fixed binary (35) external;
  1    36 
  1    37 dcl  sub_err_ entry () options (variable);
  1    38 
  1    39 dcl  (null, substr, unspec) builtin;
  1    40 
  1    41           if addr(p_sci_ptr) -> its.its_mod ^= ITS_MODIFIER then do;
  1    42 RESIGNAL_BAD_POINTER:
  1    43 	     call sub_err_ (error_table_$bad_ptr, SSU_, ACTION_CANT_RESTART, null (), (0), "^24.3b", unspec (p_sci_ptr));
  1    44 	     go to RESIGNAL_BAD_POINTER;
  1    45 	end;
  1    46 
  1    47 	if p_sci_ptr = null () then do;
  1    48 RESIGNAL_NULL_POINTER:
  1    49 	     call sub_err_ (error_table_$null_info_ptr, SSU_, ACTION_CANT_RESTART, null (), (0), "sci_ptr");
  1    50 	     go to RESIGNAL_NULL_POINTER;
  1    51 	end;
  1    52 
  1    53 	if p_sci_ptr -> sci.version = SCI_VERSION_3 then	/* all is well */
  1    54 	     return;
  1    55 
  1    56 RESIGNAL_BAD_VERSION:
  1    57 	call sub_err_ (error_table_$unimplemented_version, SSU_, ACTION_CANT_RESTART, null (), (0), "^24.3b",
  1    58 	     unspec (p_sci_ptr -> sci.version));
  1    59 	go to RESIGNAL_BAD_VERSION;
  1    60 
  2     1 /* BEGIN INCLUDE FILE its.incl.pl1
  2     2*   modified 27 July 79 by JRDavis to add its_unsigned
  2     3*   Internal format of ITS pointer, including ring-number field for follow-on processor */
  2     4 
  2     5 dcl 1 its based aligned,				/* declaration for ITS type pointer */
  2     6     2 pad1 bit (3) unaligned,
  2     7     2 segno bit (15) unaligned,			/* segment number within the pointer */
  2     8     2 ringno bit (3) unaligned,			/* ring number within the pointer */
  2     9     2 pad2 bit (9) unaligned,
  2    10     2 its_mod bit (6) unaligned,			/* should be 43(8) */
  2    11 
  2    12     2 offset bit (18) unaligned,			/* word offset within the addressed segment */
  2    13     2 pad3 bit (3) unaligned,
  2    14     2 bit_offset bit (6) unaligned,			/* bit offset within the word */
  2    15     2 pad4 bit (3) unaligned,
  2    16     2 mod bit (6) unaligned;				/* further modification */
  2    17 
  2    18 dcl 1 itp based aligned,				/* declaration for ITP type pointer */
  2    19     2 pr_no bit (3) unaligned,			/* number of pointer register to use */
  2    20     2 pad1 bit (27) unaligned,
  2    21     2 itp_mod bit (6) unaligned,			/* should be 41(8) */
  2    22 
  2    23     2 offset bit (18) unaligned,			/* word offset from pointer register word offset */
  2    24     2 pad2 bit (3) unaligned,
  2    25     2 bit_offset bit (6) unaligned,			/* bit offset relative to new word offset */
  2    26     2 pad3 bit (3) unaligned,
  2    27     2 mod bit (6) unaligned;				/* further modification */
  2    28 
  2    29 
  2    30 dcl 1 its_unsigned based aligned,			/* just like its, but with unsigned binary */
  2    31     2 pad1 bit (3) unaligned,
  2    32     2 segno fixed bin (15) unsigned unaligned,
  2    33     2 ringno fixed bin (3) unsigned unaligned,
  2    34     2 pad2 bit (9) unaligned,
  2    35     2 its_mod bit (6) unaligned,
  2    36 
  2    37     2 offset fixed bin (18) unsigned unaligned,
  2    38     2 pad3 bit (3) unaligned,
  2    39     2 bit_offset fixed bin (6) unsigned unaligned,
  2    40     2 pad4 bit (3) unaligned,
  2    41     2 mod bit (6) unaligned;
  2    42 
  2    43 dcl 1 itp_unsigned based aligned,			/* just like itp, but with unsigned binary where appropriate */
  2    44     2 pr_no fixed bin (3) unsigned unaligned,
  2    45     2 pad1 bit (27) unaligned,
  2    46     2 itp_mod bit (6) unaligned,
  2    47 
  2    48     2 offset fixed bin (18) unsigned unaligned,
  2    49     2 pad2 bit (3) unaligned,
  2    50     2 bit_offset fixed bin (6) unsigned unaligned,
  2    51     2 pad3 bit (3) unaligned,
  2    52     2 mod bit (6) unaligned;
  2    53 
  2    54 
  2    55 dcl  ITS_MODIFIER bit (6) unaligned internal static options (constant) init ("43"b3);
  2    56 dcl  ITP_MODIFIER bit (6) unaligned internal static options (constant) init ("41"b3);
  2    57 
  2    58 /* END INCLUDE FILE   its.incl.pl1 */
  1    61 
  1    62 
  3     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  3     2 /* format: style3 */
  3     3 
  3     4 /* These constants are to be used for the flags argument of sub_err_ */
  3     5 /* They are just "string (condition_info_header.action_flags)" */
  3     6 
  3     7 declare	(
  3     8 	ACTION_CAN_RESTART	init (""b),
  3     9 	ACTION_CANT_RESTART init ("1"b),
  3    10 	ACTION_DEFAULT_RESTART
  3    11 			init ("01"b),
  3    12 	ACTION_QUIET_RESTART
  3    13 			init ("001"b),
  3    14 	ACTION_SUPPORT_SIGNAL
  3    15 			init ("0001"b)
  3    16 	)		bit (36) aligned internal static options (constant);
  3    17 
  3    18 /* End include file */
  1    63 
  1    64 
  1    65      end ssu_check_sci;
  1    66 
  1    67 
  1    68 /*  END OF:  _ssu_check_sci.incl.pl1			  *  *  *  *  *  */
      303 
      304 
  4     1 /* BEGIN INCLUDE FILE ... _ssu_sci.incl.pl1 */
  4     2 /* Created:  31 April 1980 by W. Olin Sibert */
  4     3 /* Modified: 17 November 1981 by Jay Pattin to add info_prefix */
  4     4 /* Modified: 10 December 1981 by G. Palter to make arg_count, arg_ptr, return_arg, and arg_list_ptr replaceable */
  4     5 /* Modified: 10 February 1982 by G. Palter to reorganize and make changes required for installation */
  4     6 /* Modified: June 1982 by G. Palter for version 2 (new request processor options and replaceable procedures) */
  4     7 /* Modified: 6 November 1984 by G. Palter for version 3 (get_subsystem_and_request_name is now replaceable) */
  4     8 
  4     9 /* format: style4,^delnl */
  4    10 
  4    11 
  4    12 /* Structure used internally by subsystem utilities to contain control information about a single invocation */
  4    13 
  4    14 dcl  1 sci aligned based (sci_ptr),
  4    15        2 version character (8),
  4    16        2 parent_area_ptr pointer,			/* -> area holding this data and referenced structures */
  4    17 
  4    18        2 global_info,				/* global information about this subsystem ... */
  4    19          3 subsystem_name char (32) unaligned,		/* ... its name (eg: read_mail) */
  4    20          3 subsystem_version char (32) unaligned,		/* ... its version numer (eg: 4.3j) */
  4    21          3 info_ptr pointer,				/* ... -> data maintained by the subsystem */
  4    22          3 standalone_abort_entry entry () variable,	/* ... for standalone invocations: called by ssu_$abort_* */
  4    23          3 flags,
  4    24 	 4 standalone_invocation bit (1) unaligned,	/* ... ON => ssu_$standalone_invocation was used */
  4    25 	 4 in_listener bit (1) unaligned,		/* ... ON => in subsystem listener loop */
  4    26 	 4 executing_request bit (1) unaligned,		/* ... ON => executing a request */
  4    27 	 4 debug_mode bit (1) unaligned,		/* ... ON => debugging the subsystem */
  4    28 	 4 pad bit (32) unaligned,
  4    29 
  4    30        2 recursion_info,				/* describes relationship of this invocation to other active
  4    31*						   invocations of the same subsystem ... */
  4    32          3 invocation_data_idx fixed binary,		/* ... locates the list of active invocations */
  4    33          3 level fixed binary,			/* ... # of active invocations when this one created + 1 */
  4    34          3 previous_sci_ptr pointer,			/* ... -> description of previous invocation */
  4    35          3 next_sci_ptr pointer,			/* ... -> description of next invocation */
  4    36 
  4    37        2 request_processor_info,			/* information related to request line processing ... */
  4    38          3 request_tables_ptr pointer,			/* ... -> list of request tables in use */
  4    39          3 rp_options_ptr pointer,			/* ... -> options controlling the processor */
  4    40          3 abort_line_label label variable,
  4    41          3 request_data_ptr pointer,			/* ... -> request_data structure for current request */
  4    42 
  4    43        2 prompt_and_ready_info,			/* information related to prompts and ready messages ... */
  4    44          3 prompt character (64) varying,		/* the prompt (if any): an ioa_ control string */
  4    45          3 prompt_mode,				/* controls prompting ... */
  4    46 	 4 dont_prompt bit (1) unaligned,		/* ... ON => never prompt */
  4    47 	 4 prompt_after_null_lines bit (1) unaligned,	/* ... ON => prompt after a blank line if prompts enabled */
  4    48 	 4 dont_prompt_if_typeahead bit (1) unaligned,	/* ... ON => suppress prompts if request line available */
  4    49 	 4 pad bit (33) unaligned,
  4    50          3 ready_enabled bit (1) aligned,		/* ... ON => ready procedure should be invoked */
  4    51 
  4    52        2 listener_info,				/* information used by the listener ... */
  4    53          3 abort_subsystem_label label variable,
  4    54          3 temp_seg_ptr pointer,			/* ... -> temporary segment used for long request lines */
  4    55 
  4    56        2 temp_info_ptr pointer,			/* pointer to data used by ssu_temp_mgr_ */
  4    57 
  4    58        2 info_info,					/* information related to self-documentation ... */
  4    59          3 info_dirs_ptr pointer,			/* ... -> list of info directories */
  4    60          3 info_prefix character (32),			/* ... prefix used to form info segment names */
  4    61 
  4    62        2 ec_info,					/* data for subsystem exec_com processing ... */
  4    63          3 ec_suffix char (32) unaligned,		/* ... suffix of exec_com segments */
  4    64          3 ec_search_list char (32) unaligned,		/* ... search list used to find exec_coms */
  4    65          3 subsystem_dir_ptr pointer,			/* ... defines referencing_dir rule for above search list */
  4    66 
  4    67        2 entries,					/* all replaceable entries ... */
  4    68          (
  4    69          3 abort_line,				/* ... invoked by ssu_$abort_line */
  4    70          3 abort_subsystem,				/* ... invoked by ssu_$abort_subsystem */
  4    71          3 print_message,				/* ... invoked by ssu_$print_message */
  4    72          3 program_interrupt,				/* ... cannot be called externally */
  4    73          3 pre_request_line,				/* ... cannot be called externally */
  4    74          3 post_request_line,				/* ... cannot be called externally */
  4    75          3 ready,					/* ... invoked by ssu_$ready_proc */
  4    76          3 cpescape,				/* ... cannot be called externally */
  4    77          3 unknown_request,				/* ... invoked by ssu_$unknown_request */
  4    78          3 listen,					/* ... invoked by ssu_$listen */
  4    79          3 execute_line,				/* ... invoked by ssu_$execute_line */
  4    80          3 evaluate_active_string,			/* ... invoked by ssu_$evaluate_active_string */
  4    81          3 invoke_request,				/* ... invoked by ssu_$invoke_request */
  4    82          3 locate_request,				/* ... invoked by ssu_$locate_request */
  4    83          3 arg_count,				/* ... invoked by ssu_$arg_count */
  4    84          3 arg_ptr,					/* ... invoked by ssu_$arg_ptr */
  4    85          3 return_arg,				/* ... invoked by ssu_$return_arg */
  4    86          3 arg_list_ptr,				/* ... invoked by ssu_$arg_list_ptr */
  4    87          3 get_default_rp_options,			/* ... invoked by ssu_$get_default_rp_options */
  4    88          3 get_rp_options,				/* ... invoked by ssu_$get_request_processor_options */
  4    89          3 set_rp_options,				/* ... invoked by ssu_$set_request_processor_options */
  4    90          3 reset_rp_options,				/* ... invoked by ssu_$reset_request_processor_options */
  4    91          3 get_subsys_and_request_name			/* ... invoked by ssu_$get_subsystem_and_request_name */
  4    92          ) entry () variable options (variable);
  4    93 
  4    94 dcl  sci_ptr pointer;
  4    95 
  4    96 dcl  sci_parent_area area based (sci.parent_area_ptr);
  4    97 
  4    98 dcl  SCI_VERSION_3 character (8) static options (constant) init ("sci_0003");
  4    99 
  4   100 /* END INCLUDE FILE ... _ssu_sci.incl.pl1 */
      305 
      306 
  5     1 /* BEGIN INCLUDE FILE area_info.incl.pl1  12/75 */
  5     2 
  5     3 dcl  area_info_version_1 fixed bin static init (1) options (constant);
  5     4 
  5     5 dcl  area_infop ptr;
  5     6 
  5     7 dcl 1 area_info aligned based (area_infop),
  5     8     2 version fixed bin,				/* version number for this structure is 1 */
  5     9     2 control aligned like area_control,		/* control bits for the area */
  5    10     2 owner char (32) unal,				/* creator of the area */
  5    11     2 n_components fixed bin,				/* number of components in the area (returned only) */
  5    12     2 size fixed bin (18),				/* size of the area in words */
  5    13     2 version_of_area fixed bin,			/* version of area (returned only) */
  5    14     2 areap ptr,					/* pointer to the area (first component on multisegment area) */
  5    15     2 allocated_blocks fixed bin,			/* number of blocks allocated */
  5    16     2 free_blocks fixed bin,				/* number of free blocks not in virgin */
  5    17     2 allocated_words fixed bin (30),			/* number of words allocated in the area */
  5    18     2 free_words fixed bin (30);			/* number of words free in area not in virgin */
  5    19 
  5    20 dcl 1 area_control aligned based,
  5    21     2 extend bit (1) unal,				/* says area is extensible */
  5    22     2 zero_on_alloc bit (1) unal,			/* says block gets zerod at allocation time */
  5    23     2 zero_on_free bit (1) unal,			/* says block gets zerod at free time */
  5    24     2 dont_free bit (1) unal,			/* debugging aid, turns off free requests */
  5    25     2 no_freeing bit (1) unal,			/* for allocation method without freeing */
  5    26     2 system bit (1) unal,				/* says area is managed by system */
  5    27     2 pad bit (30) unal;
  5    28 
  5    29 /* END INCLUDE FILE area_info.incl.pl1 */
      307 
      308 
      309      end ssu_temp_mgr_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/04/87  1539.3  ssu_temp_mgr_.pl1                 >special_ldd>install>MR12.1-1054>ssu_temp_mgr_.pl1
303          1    08/04/87  1140.5  _ssu_check_sci.incl.pl1           >spec>install>1056>_ssu_check_sci.incl.pl1
1-61         2    11/26/79  1320.6  its.incl.pl1                      >ldd>include>its.incl.pl1
1-63         3    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
305          4    01/21/85  0912.2  _ssu_sci.incl.pl1                 >ldd>include>_ssu_sci.incl.pl1
307          5    06/11/76  1043.4  area_info.incl.pl1                >ldd>include>area_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000017 constant        bit(36)                  initial dcl 3-7 set ref 1-42* 1-48* 1-56*
AREA_TYPE                              constant        fixed bin(17,0)          initial dcl 49 ref 119 200 229
ITS_MODIFIER                           constant        bit(6)                   initial unaligned dcl 2-55 ref 1-41
NO_TYPE                                constant        fixed bin(17,0)          initial dcl 47 ref 173 205 233 260 267 285
P_area_infop                           parameter       pointer                  dcl 33 ref 110 123 131
P_area_ptr                             parameter       pointer                  dcl 35 set ref 110 147* 187 200 202*
P_comment                              parameter       char                     unaligned dcl 27 set ref 84 94 94* 110 120 120*
P_sci_ptr                              parameter       pointer                  dcl 25 set ref 84 87* 89 110 113* 115 155 158* 160
                                                                                  187 190* 192 219 222
P_seg_ptr                              parameter       pointer                  dcl 30 set ref 84 102* 155 168 170*
SCI_VERSION_3                   000010 constant        char(8)                  initial unaligned dcl 4-98 ref 1-53
SEGMENT_TYPE                           constant        fixed bin(17,0)          initial dcl 48 ref 93 168 231
SSU_                            000000 constant        char(32)                 initial unaligned dcl 1-31 set ref 1-42* 1-48* 1-56*
addr                                                   builtin function         dcl 78 ref 134 166 198 227 268 292 1-41
alloc_temp_info_array_size      000102 automatic       fixed bin(17,0)          dcl 55 set ref 256* 257 257 258 274* 276 276 278
area_control                           based           structure                level 1 dcl 5-20
area_info                              based           structure                level 1 dcl 5-7 set ref 131
area_info_automatic             000104 automatic       structure                level 1 dcl 60 set ref 124* 131* 134
area_info_version_1                    constant        fixed bin(17,0)          initial dcl 5-3 ref 136
area_infop                      000136 automatic       pointer                  dcl 5-5 set ref 134* 136 137 138 139 141* 146 147
areap                    16            based           pointer                  level 2 dcl 5-7 set ref 137* 146 147
code                            000130 automatic       fixed bin(35,0)          dcl 62 set ref 97* 99 99* 141* 143 143*
control                   1     000104 automatic       structure                level 2 dcl 60
debug_mode               32(03)        based           bit(1)                   level 4 packed unaligned dcl 4-14 ref 126
define_area_                    000012 constant        entry                    external dcl 71 ref 141
dont_free                 1(03) 000104 automatic       bit(1)                   level 3 packed unaligned dcl 60 set ref 126*
element                   2            based           structure                array level 2 dcl 51 set ref 166 198 227 268 281*
                                                                                  281 292
error_table_$bad_ptr            000026 external static fixed bin(35,0)          dcl 1-33 set ref 1-42*
error_table_$null_info_ptr      000030 external static fixed bin(35,0)          dcl 1-34 set ref 1-48*
error_table_$unimplemented_version
                                000032 external static fixed bin(35,0)          dcl 1-35 set ref 1-56*
extend                    1     000104 automatic       bit(1)                   level 3 packed unaligned dcl 60 set ref 125*
flags                    32            based           structure                level 3 dcl 4-14
get_temp_segment_               000014 constant        entry                    external dcl 72 ref 97
global_info               4            based           structure                level 2 dcl 4-14
idx                             000131 automatic       fixed bin(17,0)          dcl 63 in procedure "ssu_temp_mgr_" set ref 165*
                                                                                  166* 197* 198* 226* 227*
idx                             000162 automatic       fixed bin(17,0)          dcl 252 in procedure "get_temp_info_ptr" set ref
                                                                                  259* 260 261 262* 266* 267 268* 280* 281 281* 284*
                                                                                  285 286 287*
ioa_$rsnnl                      000022 constant        entry                    external dcl 75 ref 94 120
its                                    based           structure                level 1 dcl 2-5
its_mod                   0(30)        based           bit(6)                   level 2 packed unaligned dcl 2-5 ref 1-41
level                    35            based           fixed bin(17,0)          level 3 dcl 4-14 set ref 94* 120*
name                      4            based           char(32)                 level 2 in structure "temp_info" packed unaligned
                                                                                  dcl 41 in procedure "ssu_temp_mgr_" set ref 94*
                                                                                  97* 120* 138 171* 175* 207* 231* 235*
name                      6            based           char(32)                 array level 3 in structure "temp_info_array" packed
                                                                                  unaligned dcl 51 in procedure "ssu_temp_mgr_" set
                                                                                  ref 262* 287*
new_ptr                         000164 automatic       pointer                  dcl 253 set ref 276* 278 281 284 285 286 287 290 292
null                                                   builtin function         dcl 1-39 in procedure "ssu_check_sci" ref 1-42 1-42
                                                                                  1-47 1-48 1-48 1-56 1-56
null                                                   builtin function         dcl 78 in procedure "ssu_temp_mgr_" ref 123 137 162
                                                                                  170 174 194 202 206 224 234 239 255 261 286
old_ptr                         000132 automatic       pointer                  dcl 64 set ref 238* 241 273* 280 281 284 292 295
owner                     2            based           char(32)                 level 2 packed unaligned dcl 5-7 set ref 138*
p_sci_ptr                              parameter       pointer                  dcl 1-29 set ref 1-26 1-41 1-42 1-42 1-47 1-53 1-56
                                                                                  1-56
parent_area_ptr           2            based           pointer                  level 2 dcl 4-14 ref 241 257 276 295
ptr                       2            based           pointer                  level 2 in structure "temp_info" dcl 41 in procedure
                                                                                  "ssu_temp_mgr_" set ref 97* 102 146* 168 171* 174*
                                                                                  200 203* 206* 229* 231* 234*
ptr                       4            based           pointer                  array level 3 in structure "temp_info_array" dcl 51
                                                                                  in procedure "ssu_temp_mgr_" set ref 261* 286*
recursion_info           34            based           structure                level 2 dcl 4-14
release_area_                   000016 constant        entry                    external dcl 73 ref 203 229
release_temp_segment_           000020 constant        entry                    external dcl 74 ref 171 231
sci                                    based           structure                level 1 dcl 4-14
sci_parent_area                        based           area(1024)               dcl 4-96 ref 241 257 276 295
sci_ptr                         000134 automatic       pointer                  dcl 4-94 set ref 89* 94 94 99* 115* 120 120 126 143*
                                                                                  160* 162 165 166 192* 194 197 198 222* 224 226 227
                                                                                  238 239 241 255 257 257 258 259 260 261 262 266
                                                                                  267 268 273 274 276 290 295
size                     13            based           fixed bin(18,0)          level 2 in structure "area_info" dcl 5-7
                                                                                  in procedure "ssu_temp_mgr_" set ref 139*
size                                   based           fixed bin(17,0)          level 2 in structure "temp_info_array" dcl 51
                                                                                  in procedure "ssu_temp_mgr_" set ref 165 197 226
                                                                                  241 257* 258* 259 266 274 276* 278* 280 284 284
                                                                                  292 295
ssu_$abort_line                 000024 constant        entry                    external dcl 76 ref 99 143
sub_err_                        000034 constant        entry                    external dcl 1-37 ref 1-42 1-48 1-56
subsystem_name            4            based           char(32)                 level 3 packed unaligned dcl 4-14 set ref 94* 120*
sys_info$max_seg_size           000010 external static fixed bin(19,0)          dcl 66 ref 139
temp_info                              based           structure                level 1 dcl 41
temp_info_array                        based           structure                level 1 dcl 51 set ref 241 257 276 295
temp_info_ptr                   000100 automatic       pointer                  dcl 45 in procedure "ssu_temp_mgr_" set ref 93 94 97
                                                                                  97 102 119 120 138 146 166* 168 168 171 171 173
                                                                                  174 175 198* 200 200 203 205 206 207 227* 229 229
                                                                                  231 231 231 233 234 235 268* 292*
temp_info_ptr           106            based           pointer                  level 2 in structure "sci" dcl 4-14 in procedure
                                                                                  "ssu_temp_mgr_" set ref 162 165 166 194 197 198
                                                                                  224 226 227 238 239* 255 257* 258 259 260 261 262
                                                                                  266 267 268 273 274 290*
type                      2            based           fixed bin(17,0)          array level 3 in structure "temp_info_array" dcl 51
                                                                                  in procedure "ssu_temp_mgr_" set ref 260* 267 285*
type                                   based           fixed bin(17,0)          level 2 in structure "temp_info" dcl 41 in procedure
                                                                                  "ssu_temp_mgr_" set ref 93* 119* 168 173* 200 205*
                                                                                  229 231 233*
unspec                                                 builtin function         dcl 1-39 in procedure "ssu_check_sci" ref 1-42 1-42
                                                                                  1-56 1-56
unspec                                                 builtin function         dcl 78 in procedure "ssu_temp_mgr_" set ref 124*
                                                                                  131* 131
version                                based           fixed bin(17,0)          level 2 in structure "area_info" dcl 5-7
                                                                                  in procedure "ssu_temp_mgr_" set ref 136*
version                                based           char(8)                  level 2 in structure "sci" dcl 4-14 in procedure
                                                                                  "ssu_temp_mgr_" ref 1-53 1-56 1-56
zero_on_free              1(02) 000104 automatic       bit(1)                   level 3 packed unaligned dcl 60 set ref 128*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 3-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 3-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 3-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 3-7
ITP_MODIFIER                           internal static bit(6)                   initial unaligned dcl 2-56
currentsize                                            builtin function         dcl 78
error_table_$area_too_small            external static fixed bin(35,0)          dcl 68
error_table_$badcall                   external static fixed bin(35,0)          dcl 69
itp                                    based           structure                level 1 dcl 2-18
itp_unsigned                           based           structure                level 1 dcl 2-43
its_unsigned                           based           structure                level 1 dcl 2-30
substr                                                 builtin function         dcl 1-39

NAMES DECLARED BY EXPLICIT CONTEXT.
RESIGNAL_BAD_POINTER            001275 constant        label                    dcl 1-42 ref 1-44
RESIGNAL_BAD_VERSION            001427 constant        label                    dcl 1-56 set ref 1-59
RESIGNAL_NULL_POINTER           001355 constant        label                    dcl 1-48 ref 1-50
get_area                        000272 constant        entry                    external dcl 110
get_segment                     000075 constant        entry                    external dcl 84
get_temp_info_ptr               001065 constant        entry                    internal dcl 249 ref 91 117
release_area                    000645 constant        entry                    external dcl 187
release_everything              000747 constant        entry                    external dcl 219
release_segment                 000531 constant        entry                    external dcl 155
ssu_check_sci                   001267 constant        entry                    internal dcl 1-26 ref 87 113 158 190
ssu_temp_mgr_                   000063 constant        entry                    external dcl 17

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1722        1760    1504        1732
Length      2264    1504        36         267     216           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ssu_temp_mgr_                       218 external procedure  is an external procedure.  
get_temp_info_ptr                       internal procedure  shares stack frame of external procedure ssu_temp_mgr_.  
ssu_check_sci                           internal procedure  shares stack frame of external procedure ssu_temp_mgr_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
ssu_temp_mgr_            000100 temp_info_ptr               ssu_temp_mgr_
                         000102 alloc_temp_info_array_size  ssu_temp_mgr_
                         000104 area_info_automatic         ssu_temp_mgr_
                         000130 code                        ssu_temp_mgr_
                         000131 idx                         ssu_temp_mgr_
                         000132 old_ptr                     ssu_temp_mgr_
                         000134 sci_ptr                     ssu_temp_mgr_
                         000136 area_infop                  ssu_temp_mgr_
                         000162 idx                         get_temp_info_ptr
                         000164 new_ptr                     get_temp_info_ptr

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             call_ext_out_desc   call_ext_out        return_mac          ext_entry           ext_entry_desc
op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
define_area_                  get_temp_segment_             ioa_$rsnnl                    release_area_
release_temp_segment_         ssu_$abort_line               sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_ptr          error_table_$null_info_ptr    error_table_$unimplemented_version
sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     17 000062        20 000070        84 000071        87 000112        89 000121        91 000125        93 000126
     94 000130        97 000211        99 000233       102 000261       104 000264       110 000265       113 000307
    115 000316       117 000322       119 000323       120 000325       123 000406       124 000413       125 000416
    126 000420       128 000427       129 000431       131 000432       134 000437       136 000441       137 000443
    138 000445       139 000451       141 000454       143 000464       146 000515       147 000521       149 000524
    155 000525       158 000541       160 000550       162 000554       165 000560       166 000567       168 000574
    170 000603       171 000605       173 000627       174 000631       175 000634       177 000637       179 000640
    181 000642       187 000643       190 000655       192 000664       194 000670       197 000674       198 000703
    200 000710       202 000717       203 000721       205 000730       206 000732       207 000735       209 000740
    211 000741       213 000743       219 000744       222 000754       224 000760       226 000764       227 000773
    229 001000       231 001013       233 001037       234 001041       235 001044       236 001047       238 001051
    239 001054       241 001057       243 001064       249 001065       255 001066       256 001073       257 001075
    259 001110       260 001117       261 001125       262 001127       263 001135       266 001137       267 001147
    268 001156       269 001161       271 001162       273 001164       274 001167       276 001172       280 001204
    281 001213       282 001223       284 001225       285 001235       286 001242       287 001244       288 001250
    290 001252       292 001255       295 001261       297 001266    1   26 001267    1   41 001271    1   42 001275
 1   44 001350    1   47 001351    1   48 001355    1   50 001417    1   53 001420    1   56 001427    1   59 001503


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
