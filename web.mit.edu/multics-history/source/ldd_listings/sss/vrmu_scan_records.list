	COMPILATION LISTING OF SEGMENT vrmu_scan_records
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/21/84  1437.9 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 vrmu_scan_records: proc; return;
       10 
       11 /*
       12*
       13*		      BEGIN_DESCRIPTION
       14*
       15*   This routine starts with an indexed vfile_ and returns successive records
       16*   by reading the record components sequentially.  This means the order of
       17*   returned records has no correspondence to the key order in general.
       18*   For MRDS needed to have it work with the current vfile_ opening, so
       19*   needed a variable from the indx_cb.  Used transaction_code
       20*   because it is the correct dcl and is now unused.  Should use a variable
       21*   of its own and this code should be incoorperated into vfile_.
       22*
       23*		       END_DESCRIPTION
       24*
       25**/
       26 
       27 /* HISTORY:
       28*   Created by Jim Paradise on February 6, 1980.
       29*
       30*   81-07-01 Jim Gray : added an init entry, so that after
       31*   a file is read all the way to EOF, the indx_cb.transaction_code
       32*   can be reset for the next get_nest call after a positon to BOF
       33*   in mrds_dsl_search.
       34*
       35*   81-08-29 Davids: Change actually made by L. Spratt.  Changed  the
       36*   logic to determine if the current record is an indirect record or
       37*   the actual record. It used to overlay the  ind_structure  now  it
       38*   checks specific bits in the record_block_structure.
       39*
       40*   82-07-06  R.   Harvey:  Changed  $init  and $next entry points to
       41*   $scan_records_init and $scan_records_next.
       42*
       43*   82-08-11 Mike Kubicar: Added fix for phx12335.  Mu_scan_records will
       44*   honor the vfile_ wait time.  Also changed the error code returned when
       45*   the vfile_ is locked to error_table_$file_busy so that retrieve won't
       46*   return different error codes for similar condition.
       47*
       48*   82-09-29 R. Harvey:  Renamed and reformatted for vfile_relgmr_
       49*
       50*   83-03-24 Roger Lackey : Added code to return a 0 vfile_desc for stationary
       51*   records that have moved.  Also added the locking for the case where vrm is
       52*   not locking. This involved creating the vrmu_scan_rec_next structure.
       53*
       54*   83-04-07 R. Harvey : Added check to insure that record being returned is
       55*   actually data and not a vfile_relmgr_ overhead record.
       56*
       57*   83-05-12 R. Harvey : Added  the  extend_seg_ptr_array routine from  vfile_
       58*   with a slight modification so that it is extended to the proper size in
       59*   one fell swoop.
       60*
       61*   83-08-09 R. Harvey : Write-around for TR phx15467 was installed. Kudos to
       62*   Bert Moberg for identifying a solution.
       63**/
       64 
       65 /* BEGIN CHANGE 81-07-01 *********************************************** */
       66 
       67 init: scan_records_init:
       68      entry (iocb_ptr, P_code);			/* reset the end of file indicator */
       69 
       70 	indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
       71 	P_code = 0;
       72 	indx_cb.transaction_code = 262144;		/* -1 => EOF, 262144 => middle of file */
       73 
       74 	return;
       75 
       76 /* END CHANGE 81-07-01 ********************************************** */
       77 
       78 next: scan_records_next:
       79      entry (vrmu_scan_rec_next_ptr, P_code);
       80 	indx_cb_ptr = vrmu_scan_rec_next.iocb_ptr -> iocb.open_data_ptr;
       81 	vrmu_scan_rec_next.block_ptr, vrmu_scan_rec_next.record_ptr = null;
       82 	vrmu_scan_rec_next.descriptor, P_code = 0;
       83 	f_b_ptr = indx_cb.file_base_ptr;		/* establish the file_base */
       84 	if indx_cb.transaction_code = -1
       85 	then do;
       86 		P_code = error_table_$end_of_info;
       87 		return;
       88 	     end;
       89 
       90 	read_count = 0;				/* Init */
       91 
       92 start_read:
       93 	if vrmu_scan_rec_next.scan_records_should_lock then do;
       94 		read_count = read_count + 1;
       95 		if read_count > divide (indx_cb.wait_time, 1000000, 17, 0)
       96 		then do;
       97 			P_code = error_table_$file_busy;
       98 			return;
       99 		     end;
      100 
      101 		if file_base.lock_word ^= "0"b
      102 		then do;
      103 			call timer_manager_$sleep (1, "11"b); /* wait a time */
      104 			goto start_read;
      105 		     end;				/* get data from file */
      106 	     end;					/* END of scan_records must lock */
      107 	save_change_count = file_base.change_count;
      108 	if indx_cb.at_bof
      109 	then do;
      110 		indx_cb.at_bof = "0"b;
      111 		indx_cb.transaction_code = 262144;
      112 	     end;
      113 	try_descriptor = indx_cb.transaction_code;
      114 	scan_status = CONTINUE;
      115 	do while (scan_status = CONTINUE);
      116 	     if try.comp_num > hbound (seg_ptr_array, 1)
      117 	     then call extend_seg_ptr_array;
      118 	     if seg_ptr_array (try.comp_num) = null
      119 	     then do;
      120 		     call msf_manager_$get_ptr (indx_cb.fcb_ptr, (try.comp_num), DONT_CREATE,
      121 			seg_ptr_array (try.comp_num), bit_count, code);
      122 		     if code ^= 0
      123 		     then scan_status = EOF;
      124 		     else scan_status = CONTINUE;
      125 		end;
      126 	     else if try.offset >= abs (seg_limit (try.comp_num))
      127 	     then do;
      128 		     try.comp_num = try.comp_num + 1;
      129 		     try.offset = 0;
      130 		     if try.comp_num > file_base.last_comp_num
      131 		     then scan_status = EOF;
      132 		end;
      133 	     else do;
      134 		     try_block_ptr = addrel (seg_ptr_array (try.comp_num), try.offset);
      135 		     try_block_size = try_block_ptr -> record_block_structure.block_size;
      136 		     if try_block_size = 0
      137 		     then do;
      138 			     try.comp_num = try.comp_num + 1;
      139 			     try.offset = 0;
      140 			     if try.comp_num > file_base.last_comp_num
      141 			     then scan_status = EOF;
      142 			end;
      143 		     else if substr (try_block_ptr -> record_block_structure.pad, 2, 1) = "0"b
      144 						/* BEGIN CHANGE 81-08-29 ********** */
      145 		     then if (try_block_ptr -> record_block_structure.stationary
      146 			     & ^try_block_ptr -> record_block_structure.indirect)
      147 			     | ^try_block_ptr -> record_block_structure.stationary
      148 						/* END CHANGE 81-08-29 ************ */
      149 			then scan_status = RECORD_FOUND;
      150 			else try.offset = try.offset + try_block_size;
      151 		     else try.offset = try.offset + try_block_size;
      152 		end;
      153 	     if scan_status = RECORD_FOUND
      154 	     then do;
      155 		     if try_block_ptr -> record_block_structure.stationary = "0"b
      156 		     then do;
      157 			     try_record_len = length (try_block_ptr -> record_block_structure.record);
      158 			     try_record_ptr = addrel (addr (try_block_ptr -> record_block_structure.record), 1);
      159 			end;
      160 		     else do;
      161 			     try_record_len = length (try_block_ptr -> stat_structure.record);
      162 			     try_record_ptr = addrel (addr (try_block_ptr -> stat_structure.record), 1);
      163 			end;
      164 		     if try_record_len = 0 | try_record_ptr -> tuple.rel_id ^= vrmu_scan_rec_next.rel_id
      165 		     then do;			/* check next record */
      166 			     try.offset = try.offset + try_block_size;
      167 			     scan_status = CONTINUE;
      168 			end;
      169 		end;
      170 	end;
      171 	if save_change_count ^= file_base.change_count
      172 	then goto start_read;			/* set return variables */
      173 	if scan_status = RECORD_FOUND
      174 	then do;
      175 		if vrmu_scan_rec_next.stationary_rec_expected &
      176 		     try_block_ptr -> record_block_structure.stationary = "0"b then
      177 		     vrmu_scan_rec_next.descriptor = 0;
      178 		else vrmu_scan_rec_next.descriptor = try_descriptor;
      179 		try.offset = try.offset + try_block_size;
      180 		indx_cb.transaction_code = try_descriptor;
      181 		vrmu_scan_rec_next.block_ptr = try_block_ptr;
      182 		vrmu_scan_rec_next.record_ptr = try_record_ptr;
      183 		vrmu_scan_rec_next.record_len = try_record_len;
      184 	     end;
      185 	else if scan_status = EOF
      186 	then do;
      187 		indx_cb.transaction_code = -1;
      188 		P_code = error_table_$end_of_info;
      189 	     end;
      190 	else if code ^= 0
      191 	then P_code = code;
      192 	return;					/* next entry */
      193 
      194 
      195 
      196 extend_seg_ptr_array: proc;
      197 
      198 	old_array_limit = seg_ptr_array_limit;
      199 	old_array_ptr = seg_ptr_array_ptr;
      200 	seg_ptr_array_limit = file_base.last_comp_num;
      201 	allocate seg_ptr_array in (get_system_free_area_ () -> cb_area) set (seg_ptr_array_ptr);
      202 
      203 	do i = 0 to old_array_limit;
      204 	     seg_ptr_array (i) = old_array (i);
      205 	end;
      206 	do i = old_array_limit + 1 to seg_ptr_array_limit;
      207 	     seg_ptr_array (i) = null ();
      208 	end;
      209 
      210 	free old_array;				/* in systemfree */
      211 
      212 
      213 	dcl     cb_area		 area based;
      214 	dcl     get_system_free_area_	 entry () returns (ptr);
      215 	dcl     i			 fixed bin;
      216 	dcl     old_array_limit	 fixed bin;
      217 	dcl     old_array_ptr	 ptr;
      218 	dcl     old_array		 (0:old_array_limit) ptr based (old_array_ptr);
      219 
      220      end extend_seg_ptr_array;
      221 
  1     1 /* the control block */
  1     2      dcl	   indx_cb_ptr	      ptr;
  1     3      dcl	   1 indx_cb	      based (indx_cb_ptr),	/* except as noted, init by create cb */
  1     4 	     2 fcb_ptr	      ptr,
  1     5 	     2 file_base_ptr      ptr,
  1     6 	     2 node_length	      fixed,		/* number of bytes in node, init by create_seg_ptrs */
  1     7 	     2 half_node_length   fixed,		/* init by create_seg_ptrs */
  1     8 	     2 max_record_size    fixed (21),		/* init by create_seg_ptrs */
  1     9 	     2 seg_ptr_array_ptr  ptr,		/* init by create seg_ptrs */
  1    10 	     2 seg_ptr_array_limit
  1    11 			      fixed,		/* init by create seg_ptrs */
  1    12 	     2 mode	      fixed,
  1    13 	     2 is_sequential_open bit (1) aligned,
  1    14 	     2 is_read_only	      bit (1) aligned,
  1    15 	     2 is_ks_out	      bit (1) aligned,	/* position info */
  1    16 	     2 position_stack_ptr ptr,		/* init by create_position stack */
  1    17 	     2 position_stack_height
  1    18 			      fixed,		/* init by create position stack */
  1    19 	     2 root_position_ptr  ptr,		/* init by create_position_stack */
  1    20 	     2 file_position_ptr  ptr,		/* not init */
  1    21 	     2 change_position_ptr
  1    22 			      ptr,		/* not init */
  1    23 						/* auxiliary variables  */
  1    24 	     2 rover_seg_ptr      ptr,		/* init by create_seg_ptrs */
  1    25 	     2 index_state_ptr    ptr,		/* init by create_seg_ptrs */
  1    26 	     2 old_index_height   fixed,
  1    27 	     2 old_last_comp_num  fixed,
  1    28 	     2 last_change_count  fixed (35),
  1    29 	     2 wait_time	      fixed (35),
  1    30 	     2 old_rover_comp_num fixed,
  1    31 	     2 file_state_ptr     ptr,
  1    32 	     2 o_s_ptr	      ptr,
  1    33 	     2 repeating	      bit (1) aligned,
  1    34 	     2 next_substate      fixed,
  1    35 	     2 file_program_version
  1    36 			      fixed,		/* used for record_lock compatibility */
  1    37 	     2 leave_locked	      bit (1) aligned,	/* indicates use of set_file_lock order */
  1    38 	     2 dup_ok	      bit (1) aligned,	/* if set, duplicate keys may occur */
  1    39 	     2 read_exclu	      bit (1) aligned,	/* set when lock excludes readers */
  1    40 	     2 pos_incorrect      bit (1) aligned,	/* indicates index position is not current */
  1    41 	     2 saved_lock_copy    bit (36) aligned,	/* copy of process lock_id */
  1    42 	     2 min_key_len	      fixed,		/* non-zero only in old programs */
  1    43 	     2 stat	      bit (1) aligned,	/* causes write_record to create stationary records */
  1    44 	     2 current_subset     fixed (34),		/* used with select order */
  1    45 	     2 last_subset	      fixed (34),
  1    46 	     2 subset_count	      fixed (34),		/* count of descriptors in current subset */
  1    47 	     2 temp_iocbp	      ptr,		/* temporary file used to implement select order */
  1    48 	     2 trans	      bit (1) aligned,	/* set if -transaction attachment */
  1    49 	     2 transaction_code   fixed (35),		/* set for control switch only */
  1    50 	     2 tcfp	      ptr,		/* ptr to iocb for transaction control switch--if applicable */
  1    51 	     2 reflp	      ptr,		/* ptr to ref list file, set only in transaction control file */
  1    52 	     2 uid	      bit (36) aligned,	/* used under -transaction */
  1    53 	     2 collection_delay_time
  1    54 			      fixed (35),		/* microseconds to wait before garbage removal */
  1    55 	     2 min_res	      fixed (21),		/* for min_block_size order */
  1    56 	     2 min_cap	      fixed (21),		/* also for min_block_size order */
  1    57 	     2 subset_selected    bit (2) aligned,	/* first bit for select, second
  1    58*						   bit is for exclude */
  1    59 	     2 error,				/* for error_status order */
  1    60 	       3 type	      fixed,		/* only one error type supported now */
  1    61 	       3 requested	      fixed (34),		/* skip arg given to position entry */
  1    62 	       3 received	      fixed (34),		/* actual successful skips */
  1    63 	     2 state_vars,
  1    64 	       3 fixed_state_part,
  1    65 	         4 shared	      bit (1) aligned,
  1    66 	         4 next_record_position
  1    67 			      fixed,		/* 0, 1, or 2 */
  1    68 	         4 current_record_is_valid
  1    69 			      bit (1) aligned,
  1    70 	         4 ready_to_write bit (1) aligned,
  1    71 	         4 at_eof_or_bof,
  1    72 		 5 at_bof	      bit (1) unal,
  1    73 		 5 at_eof	      bit (1) unal,
  1    74 		 5 pad	      bit (36) unal,
  1    75 	         4 outside_index  bit (1) aligned,	/* set after deleting current key or after use of record_status with locate switch */
  1    76 	         4 current_descrip
  1    77 			      fixed (35),		/* needed when outside index */
  1    78 	         4 saved_descrip  fixed (35),		/* for restoring index position */
  1    79 	         4 skip_state     fixed,		/* controls scanning of deleted entries */
  1    80 	       3 new_key	      char (256) var;
  1    81 
  1    82      dcl	   current_t_code	      fixed (35) based (addr (indx_cb.tcfp -> iocb.open_data_ptr -> indx_cb.transaction_code));
  1    83 
  1    84 /* component locator structures */
  1    85      dcl	   seg_ptr_array	      (0:seg_ptr_array_limit) ptr based (seg_ptr_array_ptr);
  1    86      dcl	   seg_ptr	      ptr;
  1    87      dcl	   seg_array	      (0:262143) fixed (19) based (seg_ptr) aligned;
  1    88      dcl	   designator	      fixed (35);
  1    89      dcl	   1 ind_des_structure    based,
  1    90 	     2 comp	      fixed (17) unal,
  1    91 	     2 offset	      bit (18) unal;
  1    92      dcl	   1 stat_structure	      based,
  1    93 	     2 pad	      bit (26) unal,
  1    94 	     2 ref_count_after    fixed (16) unsigned unal,
  1    95 	     2 ind_comp	      fixed (13) unal,
  1    96 	     2 ref_count	      fixed (16) unsigned unal,
  1    97 	     2 record_lock	      bit (36) aligned,
  1    98 	     2 modifier	      fixed (35),
  1    99 	     2 time_stamp_words   fixed (71) aligned,
  1   100 	     2 prev_mod	      fixed (35),
  1   101 	     2 record	      char (1000000) var;
  1   102      dcl	   1 ind_structure	      based,
  1   103 	     2 pad	      bit (26) unal,
  1   104 	     2 ref_count_after    fixed (16) unsigned unal,
  1   105 	     2 ind_comp	      fixed (13) unal,
  1   106 	     2 ref_count	      fixed (16) unsigned unal,
  1   107 	     2 record_lock	      bit (36) aligned,
  1   108 	     2 modifier	      fixed (35),
  1   109 	     2 time_stamp_words   fixed (71) aligned,
  1   110 	     2 prev_mod	      fixed (35),
  1   111 	     2 prev_desc	      fixed (35);
  1   112      dcl	   1 time_stamp_structure based,
  1   113 	     2 ind_offset	      bit (18) unal,
  1   114 	     2 time_last_modified fixed (54) unsigned unal;
  1   115      dcl	   1 record_block_structure
  1   116 			      based,
  1   117 	     2 reserved	      aligned,		/* data used by change_record_list */
  1   118 	       3 pad	      bit (2) unal,
  1   119 	       3 block_size	      fixed (19) unal,
  1   120 	       3 lock_flag	      bit (1) unal,		/* record lock flag */
  1   121 	       3 stationary	      bit (1) unal,
  1   122 	       3 indirect	      bit (1) unal,
  1   123 	       3 after_applies    bit (1) unal,
  1   124 	       3 mbz	      bit (10) unal,
  1   125 	     2 block_tail,				/* structure varies with record type */
  1   126 	       3 record	      char (1000000) var;	/* non-stat record location */
  1   127      dcl	   1 designator_struct    aligned based (addr (designator)),
  1   128 	     2 comp_num	      fixed (17) unal,
  1   129 	     2 offset	      bit (18) unal;
  1   130 
  1   131 /* position and node templates */
  1   132      dcl	   1 position_frame	      based (pos_ptr),	/* ref8 */
  1   133 	     2 parent_position_ptr
  1   134 			      ptr,
  1   135 	     2 son_position_ptr   ptr,
  1   136 	     2 node_ptr	      ptr,
  1   137 	     2 node	      fixed (35),
  1   138 	     2 branch_num	      fixed;
  1   139      dcl	   1 node_block	      based (node_ptr),	/* ref9) */
  1   140 	     2 last_branch_num    fixed,
  1   141 	     2 low_key_pos	      fixed,
  1   142 	     2 scat_space	      fixed,
  1   143 	     2 branch_and_descrip (1 refer (node_block.last_branch_num)),
  1   144 						/* in last element only branch is used */
  1   145 	       3 branch	      fixed (35),
  1   146 	       3 descrip,
  1   147 	         4 key_descrip,
  1   148 		 5 key_pos      fixed (17) unal,
  1   149 		 5 key_length   fixed (17) unal,
  1   150 	         4 record_descrip,
  1   151 		 5 record_designator
  1   152 			      fixed (35);
  1   153      dcl	   keys		      char (4096 /* 4*node_size */) based (node_ptr);
  1   154 
  1   155 /* file base and states */
  1   156      dcl	   f_b_ptr	      ptr;
  1   157      dcl	   1 file_base	      based (f_b_ptr),	/* ref10 */
  1   158 	     2 common_header,
  1   159 	       3 file_code	      fixed (35),
  1   160 	       3 lock_word	      bit (36) aligned,
  1   161 	       3 words	      (2) fixed,
  1   162 	     2 file_version	      fixed,
  1   163 	     2 program_version    fixed,
  1   164 	     2 node_size	      fixed (19),
  1   165 	     2 minimum_key_length fixed,
  1   166 	     2 minimum_block_size fixed (19),
  1   167 	     2 max_seg_limit      fixed (19),
  1   168 	     2 root_node_block,
  1   169 	       3 last_branch_num_root
  1   170 			      fixed,		/* =1 */
  1   171 	       3 word	      fixed,
  1   172 	       3 reserved	      fixed,
  1   173 	       3 only_branch_in_root
  1   174 			      fixed (35),
  1   175 	     2 file_state	      fixed,
  1   176 	     2 change_count	      fixed (34),		/* record state info, ref12 */
  1   177 	     2 old_number_of_free_blocks
  1   178 			      fixed (34),
  1   179 	     2 prior_block_size   fixed (19),
  1   180 	     2 old_record_length  fixed (21),
  1   181 	     2 need_new_seg	      bit (1) aligned,
  1   182 	     2 old_residue	      fixed,
  1   183 	     2 new_last_comp_num  fixed,
  1   184 	     2 old_prev_free_block
  1   185 			      fixed (18),
  1   186 	     2 old_next_free_block
  1   187 			      fixed (18),
  1   188 	     2 new_record_length  fixed (21),
  1   189 	     2 old_record_designator
  1   190 			      fixed (35),
  1   191 	     2 prec_block_was_free
  1   192 			      bit (1) aligned,
  1   193 	     2 next_block_was_free
  1   194 			      bit (1) aligned,
  1   195 	     2 former_block_size  fixed (19),
  1   196 	     2 old_init_offset    fixed (18),
  1   197 	     2 old_block_size     fixed (19),
  1   198 	     2 prev_block_size    fixed (19),
  1   199 	     2 former_rover_comp_num
  1   200 			      fixed,
  1   201 	     2 former_rover_offset
  1   202 			      fixed (18),
  1   203 	     2 next_block_size    fixed (19),
  1   204 	     2 next_prev_free_block
  1   205 			      fixed (18),
  1   206 	     2 next_next_free_block
  1   207 			      fixed (18),
  1   208 	     2 saved_ks_out	      bit (1) aligned,
  1   209 	     2 new_descriptor     fixed (35),
  1   210 	     2 old_last_branch_num
  1   211 			      fixed,
  1   212 	     2 old_low_key_pos    fixed,
  1   213 	     2 old_scat_space     fixed,
  1   214 	     2 old_key_pos	      fixed,
  1   215 	     2 rover_comp_num     fixed,
  1   216 	     2 rover_offset	      fixed (18),
  1   217 	     2 old_key_length     fixed,
  1   218 	     2 b_space	      fixed,
  1   219 	     2 last_b_num	      fixed,
  1   220 	     2 count	      fixed,
  1   221 	     2 first_count	      fixed,
  1   222 	     2 second_count	      fixed,
  1   223 	     2 split_num	      fixed,
  1   224 	     2 must_compact_dest  bit (1) aligned,
  1   225 	     2 first_branch	      fixed (35),
  1   226 	     2 min_source_key_pos fixed,
  1   227 	     2 min_dest_key_pos   fixed,
  1   228 	     2 new_low_key_pos    fixed,
  1   229 	     2 new_scat_space     fixed,
  1   230 	     2 old_seg_lim	      fixed (19),
  1   231 	     2 old_number_of_free_nodes
  1   232 			      fixed,
  1   233 	     2 old_next_node_designator
  1   234 			      fixed (35),
  1   235 	     2 new_index_comp_num fixed,
  1   236 	     2 out_of_index	      bit (1) aligned,
  1   237 	     2 saved_min_res      fixed (21),
  1   238 	     2 saved_min_cap      fixed (21),
  1   239 	     2 was_stat	      bit (1) aligned,
  1   240 	     2 was_ind	      bit (1) aligned,
  1   241 	     2 old_ind_desc	      fixed (35),
  1   242 	     2 after_desc	      fixed (35),
  1   243 	     2 old_ref_count      fixed (34),
  1   244 	     2 new_ref_count      fixed (34),
  1   245 	     2 old_num_free	      fixed (34),
  1   246 	     2 old_file_ch_count  fixed (35),
  1   247 	     2 y_count,				/* for conversion of pre-MR6.9 files */
  1   248 	     2 old_modifier	      fixed (35),
  1   249 	     2 was_transaction    bit (1) aligned,	/* state blocks */
  1   250 	     2 index_state	      fixed,
  1   251 	     2 index_state_blocks (0:1),
  1   252 	       3 words	      (104),
  1   253 	     2 reserved	      (30),		/* this free space might come in handy */
  1   254 	     2 old_prev_mod	      fixed (35),
  1   255 	     2 needed_blksz	      fixed (35),
  1   256 	     2 new_desc_val	      fixed (35),
  1   257 	     2 is_partial_deletion
  1   258 			      bit (1) aligned,
  1   259 	     2 reserved2	      (42),
  1   260 	     2 file_state_blocks  (0:1),
  1   261 	       3 words	      (size (file_state_block)) fixed,
  1   262 						/* component info */
  1   263 	     2 max_comp_num	      fixed,
  1   264 	     2 last_comp_num      fixed,
  1   265 	     2 first_free_comp_num,			/* not yet supported */
  1   266 	     2 comp_table_start   (size (comp_table));	/* start of comp_array */
  1   267 
  1   268      dcl	   1 comp_table	      (0:true_max_comp_num) based (addr (file_base.comp_table_start)) aligned,
  1   269 	     2 seg_limit	      fixed (19),		/* abs value is offset of first free word in seg, max val=max
  1   270*						   seg_limit and this indicates full seg */
  1   271 	     2 comp_link	      fixed (17) unal,
  1   272 	     2 init_offset	      fixed (18) unsigned unal;
  1   273 
  1   274      dcl	   1 file_header	      based (f_b_ptr),
  1   275 	     2 first_three_pages  (3, 1024) fixed,
  1   276 	     2 spare_node	      char (4096) aligned;
  1   277 
  1   278 /* The File State */
  1   279      dcl	   fs_ptr		      ptr;
  1   280      dcl	   1 file_state_block     based (fs_ptr),
  1   281 	     2 file_action	      fixed,
  1   282 	     2 file_substate      fixed,
  1   283 	     2 number_of_keys     fixed (34),
  1   284 	     2 duplicate_keys     fixed (34),		/* 0 if no duplications */
  1   285 	     2 dup_key_bytes      fixed (34),
  1   286 	     2 total_key_length   fixed (34),
  1   287 	     2 number_of_records  fixed (34),
  1   288 	     2 total_record_length
  1   289 			      fixed (34),
  1   290 	     2 number_of_allocated_records
  1   291 			      fixed (34),
  1   292 	     2 number_of_free_blocks
  1   293 			      fixed (34),
  1   294 	     2 words	      (2) fixed;
  1   295 
  1   296 /* The Index State */
  1   297      dcl	   is_ptr		      ptr;
  1   298      dcl	   1 index_state_block    based (is_ptr),	/* if this declaration is changed,
  1   299*						   index_state_blocks must be adjusted */
  1   300 	     2 number_of_nodes    fixed (34),
  1   301 	     2 free_node_designator
  1   302 			      fixed (35),
  1   303 	     2 index_tail_comp_num
  1   304 			      fixed,
  1   305 	     2 index_height	      fixed,
  1   306 	     2 index_action	      fixed,
  1   307 	     2 index_substate     fixed,
  1   308 	     2 current_node	      fixed (35),
  1   309 	     2 change_node	      fixed (35),
  1   310 	     2 fake_node,				/* equivalent to a short node because of storage map. It holds
  1   311*						   the new key, new record descrip, and new branch in a fashion
  1   312*						   convenient for overflow-underflow in change_index. */
  1   313 	       3 fake_head_and_descrip,
  1   314 	         4 word1	      fixed,		/* last_branch_num in real node */
  1   315 	         4 word2	      fixed,		/* low_key_pos in real node */
  1   316 	         4 word3	      fixed,		/* normally scat_space */
  1   317 	         4 word4	      fixed,		/* first branch in real node */
  1   318 	         4 new_key_pos    fixed (17) unal,	/* set by initializefile to denote first char
  1   319*						   in new_key_string, never changed */
  1   320 	         4 new_key_length fixed (17) unal,
  1   321 	         4 new_record_descrip,
  1   322 		 5 new_record_designator
  1   323 			      fixed (35),
  1   324 	         4 new_branch     fixed (35),
  1   325 	       3 new_key_string   char (256),
  1   326 	     2 branch_num_adjust  fixed,
  1   327 	     2 pos_array	      (10),
  1   328 	       3 saved_node	      fixed (35),
  1   329 	       3 saved_branch_num fixed;
  1   330 
  1   331      dcl	   1 old_file_base	      based (f_b_ptr),
  1   332 	     2 words1	      (15) fixed,		/* same in both file versions */
  1   333 	     2 old_file_state_blocks
  1   334 			      (0:1),
  1   335 	       3 words	      (5) fixed,
  1   336 	     2 words2	      (7) fixed,
  1   337 	     2 record_state	      fixed,
  1   338 	     2 record_state_blocks
  1   339 			      (0:1),
  1   340 	       3 words	      (4) fixed,
  1   341 	     2 words3	      (14) fixed,		/* rover info same in both versions */
  1   342 	     2 old_version_index_height
  1   343 			      fixed,
  1   344 	     2 old_version_number_of_nodes
  1   345 			      fixed (34),
  1   346 	     2 words4	      (157) fixed,
  1   347 	     2 old_version_index_tail_comp_num
  1   348 			      fixed,
  1   349 	     2 old_version_free_node_designator
  1   350 			      fixed (35),
  1   351 	     2 words5	      (10) fixed,
  1   352 	     2 old_version_comp_info
  1   353 			      fixed,
  1   354 	     2 word,
  1   355 	     2 x_count	      fixed;		/* always zero in old version files */
  1   356 
  1   357 /* External Procedures */
  1   358      dcl	   clock_		      entry returns (fixed (71));
  1   359      dcl	   alloc_cb_file	      entry (fixed,		/* size of block in words */
  1   360 			      ptr);		/* ptr to block */
  1   361      dcl	   free_cb_file	      entry (fixed, ptr);
  1   362      dcl	   get_seg_ptr	      entry (ptr, fixed) returns (ptr);
  1   363      dcl	   make_designator	      entry (fixed, fixed (18), fixed (35));
  1   364      dcl	   create_seg_ptrs	      entry (ptr);
  1   365      dcl	   free_seg_ptrs	      entry (ptr);
  1   366      dcl	   get_new_seg	      entry (ptr, fixed, ptr, fixed, label);
  1   367      dcl	   free_seg	      entry (ptr, fixed, ptr);
  1   368      dcl	   set_bitcounts	      entry (ptr);
  1   369      dcl	   create_position_stack  entry (ptr);
  1   370      dcl	   extend_position_stack  entry (ptr);
  1   371      dcl	   free_position_stack    entry (ptr);
  1   372      dcl	   change_index	      entry (ptr, label);
  1   373      dcl	   change_record_list     entry (ptr, fixed, ptr, label);
  1   374 
  1   375 /* State Constants */
  2     1      dcl	   bumping_count	      static internal options (constant) init (-14);
  2     2      dcl	   rollback_action	      static options (constant) init (-13);
  2     3      dcl	   adjust_action	      static options (constant) init (-12);
  2     4      dcl	   unshared_opening	      static internal fixed options (constant) init (-11);
  2     5      dcl	   non_eof_delete	      static internal fixed options (constant) init (-10);
  2     6      dcl	   free_action	      static options (constant) init (-10);
  2     7      dcl	   write_trunc	      static internal fixed options (constant) init (-9);
  2     8      dcl	   allocate_action	      static options (constant) init (-9);
  2     9      dcl	   reassigning_key	      static options (constant) init (-8);
  2    10      dcl	   read_exclude	      static options (constant) init (-7);
  2    11      dcl	   adding_record	      static options (constant) init (-6);
  2    12      dcl	   deleting_key	      static options (constant) init (-5);
  2    13      dcl	   adding_key	      static options (constant) init (-4);
  2    14      dcl	   delete_action	      static options (constant) init (-3);
  2    15      dcl	   eof_delete	      static internal fixed options (constant) init (-3);
  2    16      dcl	   replace_action	      static options (constant) init (-2);
  2    17      dcl	   rewrite_action	      static internal fixed options (constant) init (-2);
  2    18      dcl	   insert_action	      static options (constant) init (-1);
  2    19      dcl	   append_action	      static internal fixed options (constant) init (-1);
  2    20      dcl	   truncate_action	      static internal fixed options (constant) init (1);
  2    21      dcl	   must_adjust	      static internal fixed options (constant) init (2);
  2    22      dcl	   must_rollback	      static internal fixed options (constant) init (3);
  1   376 
  1   377 
  1   378 /* Other constants */
  1   379      dcl	   true_max_comp_num      static options (constant) init (1250);
  1   380      dcl	   stat_header_size	      static internal fixed options (constant) init (8);
  1   381 
  1   382 /* builtins */
  1   383      dcl	   (verify, reverse)      builtin;
  1   384      dcl	   addr		      builtin;
  1   385      dcl	   divide		      builtin;
  1   386      dcl	   length		      builtin;
  1   387      dcl	   null		      builtin;
  1   388      dcl	   substr		      builtin;
  1   389      dcl	   size		      builtin;
  1   390      dcl	   abs		      builtin;
  1   391      dcl	   unspec		      builtin;
  1   392      dcl	   fixed		      builtin;
  1   393      dcl	   bit		      builtin;
  1   394      dcl	   max		      builtin;
  1   395      dcl	   min		      builtin;
  1   396      dcl	   rel		      builtin;
  1   397 
      222 
      223 
  3     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  3     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  3     3*      version number to IOX2. */
  3     4 /* format: style2 */
  3     5 
  3     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  3     7 	     2 version	      character (4) aligned,	/* IOX2 */
  3     8 	     2 name	      char (32),		/* I/O name of this block. */
  3     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  3    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  3    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  3    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  3    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  3    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
  3    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  3    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  3    17 						/* open(p,mode,not_used,s) */
  3    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  3    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  3    20 						/* get_line(p,bufptr,buflen,actlen,s) */
  3    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  3    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
  3    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  3    24 						/* put_chars(p,bufptr,buflen,s) */
  3    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  3    26 						/* modes(p,newmode,oldmode,s) */
  3    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  3    28 						/* position(p,u1,u2,s) */
  3    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  3    30 						/* control(p,order,infptr,s) */
  3    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  3    32 						/* read_record(p,bufptr,buflen,actlen,s) */
  3    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  3    34 						/* write_record(p,bufptr,buflen,s) */
  3    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  3    36 						/* rewrite_record(p,bufptr,buflen,s) */
  3    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  3    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  3    39 						/* seek_key(p,key,len,s) */
  3    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  3    41 						/* read_key(p,key,len,s) */
  3    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
  3    43 						/* read_length(p,len,s) */
  3    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  3    45 						/* open_file(p,mode,desc,not_used,s) */
  3    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  3    47 						/* close_file(p,desc,s) */
  3    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
  3    49 						/* detach(p,desc,s) */
  3    50 
  3    51      declare iox_$iocb_version_sentinel
  3    52 			      character (4) aligned external static;
  3    53 
  3    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
      224 
      225 
  4     1 /* BEGIN vrm_tuple.incl.pl1 -- jaw, 7/25/78 */
  4     2 
  4     3 /* 82-08-27 R. Harvey: taken from mdbm_tuple.incl.pl1 for vfile_relmgr_.
  4     4*   Modified dimension references to point to entries in vrm_rel_desc.    */ 
  4     5 
  4     6 
  4     7 dcl 1 tuple aligned based (tuple_ptr),			/* tuple format, all file types */
  4     8     2 rel_id bit (12) unal,				/* relation id */
  4     9     2 attr_exists (vrm_rel_desc.number_attrs) bit (1) unal,	/* existance flags */
  4    10     2 var_offsets (vrm_rel_desc.number_var_attrs) fixed bin (35) unal, /* offsets for variable attr.; stored as len|value */
  4    11     2 force_even_word (tuple_pad_length) fixed bin (71) aligned, /* pad to even word boundary */
  4    12     2 data char (vrm_rel_desc.maximum_data_length) unal;		/* space for data */
  4    13 
  4    14 
  4    15 dcl  tuple_ptr ptr;
  4    16 dcl  tuple_length fixed bin (21);			/* byte count */
  4    17 
  4    18 declare  tuple_pad_length fixed bin internal static init (0) ; /* minimum array size needed for even word padding */
  4    19 
  4    20 
  4    21 
  4    22 /* END vrm_tuple.incl.pl1 */
  4    23 
      226 
      227 
  5     1 /*   BEGIN INCLUDE  vrm_rel_desc.incl.pl1		   */
  5     2 
  5     3 /* 83-05-26 Roger Lackey : Added vrm_attr_info.key_head bit for relation_cursors */
  5     4 
  5     5 dcl 1 vrm_rel_desc based (vrm_rel_desc_ptr),
  5     6     2 record_id bit (12) unal,			/* Distinguish us from tuples and collection records */
  5     7     2 version char (8),				/* Version of this structure */
  5     8     2 file_id bit (7),				/* Value of file id from model */
  5     9     2 rel_id bit (12),				/* Relation id */
  5    10     2 switches,
  5    11       3 MRDS_compatible bit (1) unal,			/* For pre-relation_manager_ MRDS */
  5    12       3 stationary_records
  5    13      bit (1) unal,					/* On = stationary */
  5    14       3 indexed bit (1) unal,				/* This relation has attributes with secondary indices */
  5    15       3 pad bit (33) unal,
  5    16     2 var_offset fixed bin (35),			/* Position of first varying attr */
  5    17     2 maximum_data_length
  5    18      fixed bin (35),				/* Maximum size of tuple in characters */
  5    19     2 number_primary_key_attrs
  5    20      fixed bin,					/* Number of attributes which make up the primary key */
  5    21     2 number_sec_indexes fixed bin,			/* Number of attributes which have a secondary index */
  5    22     2 last_var_attr_no fixed bin,			/* Attr index of last varying attribute */
  5    23     2 number_var_attrs fixed bin,			/* Number of varying attributes */
  5    24     2 number_attrs fixed bin,				/* Number of attribute in rel */
  5    25     2 attr (vrd_no_of_attrs				/* Description of each attribute */
  5    26      refer (vrm_rel_desc.number_attrs)) aligned like vrm_attr_info;
  5    27 
  5    28 dcl 1 vrm_attr_info based (vrm_attr_info_ptr),
  5    29 						/* Attribute specific info */
  5    30     2 name char (32),				/* Name of the attribute */
  5    31     2 descriptor bit (36) aligned,			/* domain descriptor */
  5    32     2 varying bit (1) unal,				/* ON = This is a varying string */
  5    33     2 key_head bit (1) unal,				/* ON = This attr can be a keyhead */
  5    34     2 primary_key_attr bit (1) unal,			/* ON = This is a primary key attribute */
  5    35     2 pad bit (15) unal,				/* unused */
  5    36     2 index_collextion_ix fixed bin (17) unal,		/* Index into vrm_open_info.index_collection array if key_head is on */
  5    37     2 bit_length fixed bin (35),			/* Maximum bit length of tuple */
  5    38     2 bit_offset fixed bin (35);			/* Offset in tuple if fixed, index to offset in tuple if varying */
  5    39 
  5    40 
  5    41 dcl  vrm_rel_desc_ptr pointer;
  5    42 dcl  vrd_no_of_attrs fixed bin;
  5    43 dcl  VRM_REL_DESC_RECORD_ID bit (12) unal int static options (constant) init ("100000000000"b);
  5    44 dcl  VRM_REL_DESC_VERSION_1 char (8) int static options (constant) init ("       1");
  5    45 dcl  vrm_attr_info_ptr pointer;
  5    46 dcl  VRM_REL_DESC_KEY char (256) varying int static options (constant) init ("@relation_description");
  5    47 
  5    48 /*   END INCLUDE  vrm_rel_desc.incl.pl1		   */
      228 
      229 
  6     1 /*   BEGIN INCLUDE vrmu_scan_rec_next.incl.pl1   */
  6     2 
  6     3 /* Parameter list for vrmu_scan_records_next  */
  6     4 
  6     5 /* History:
  6     6*
  6     7*   83-03-24 R. Lackey: Created
  6     8*   83-04-07 R. Harvey: Added the rel_id field for tuple validation
  6     9*
  6    10**/
  6    11 
  6    12 dcl  vrmu_scan_rec_next_ptr pointer;
  6    13 
  6    14 dcl 1 vrmu_scan_rec_next aligned based (vrmu_scan_rec_next_ptr),
  6    15     2 iocb_ptr pointer,				/* (INPUT) Iocb_ptr to be used */
  6    16     2 stationary_rec_expected bit (1) unal,		/* (INPUT) ON = This relation suppose to have stationary records */
  6    17     2 scan_records_should_lock bit (1) unal,		/* (INPUT) ON = scan_records must do the locking */
  6    18     2 rel_id bit (12) unal,				/* relation id for tuple checking */
  6    19     2 pad bit (22) unal,				/* Unused */
  6    20     2 block_ptr pointer,
  6    21     2 record_ptr pointer,				/* (OUTPUT) Pointer to vfile_ record */
  6    22     2 descriptor (1) fixed bin (35),			/* (OUTPUT) Vfile rec desc */
  6    23     2 record_len fixed bin (21);			/* (OUTPUT) Length of record */
  6    24 
  6    25 
  6    26 /*   END INCLUDE vrmu_scan_rec_next.incl.pl1   */
      230 
      231 
      232 	dcl     CONTINUE		 fixed bin internal static options (constant) init (0);
      233 	dcl     DONT_CREATE		 bit (1) init ("0"b) internal static options (constant);
      234 	dcl     EOF		 fixed bin internal static options (constant) init (2);
      235 	dcl     RECORD_FOUND	 fixed bin internal static options (constant) init (1);
      236 	dcl     iocb_ptr		 ptr;
      237 	dcl     P_code		 fixed bin (35);
      238 	dcl     addrel		 builtin;
      239 	dcl     hbound		 builtin;
      240 	dcl     bit_count		 fixed bin (24);
      241 	dcl     code		 fixed bin (35);
      242 	dcl     error_table_$end_of_info
      243 				 fixed bin (35) external;
      244 	dcl     msf_manager_$get_ptr	 entry (ptr, fixed bin, bit (1), ptr, fixed bin (24), fixed bin (35));
      245 
      246 	dcl     pos_ptr		 ptr;		/* This var is not referenced, but a
      247*						   a compilor warning is issued if
      248*						   it isn't here */
      249 	dcl     read_count		 fixed bin;
      250 	dcl     error_table_$file_busy fixed bin (35) ext static;
      251 	dcl     timer_manager_$sleep	 entry (fixed bin (71), bit (2));
      252 	dcl     save_change_count	 fixed bin (35);
      253 	dcl     scan_status		 fixed bin;
      254 	dcl     try_block_ptr	 ptr;
      255 	dcl     try_block_size	 fixed bin (21);
      256 	dcl     try_descriptor	 fixed bin (35);
      257 	dcl     1 try		 based (addr (try_descriptor)),
      258 		2 comp_num	 fixed bin (17) unaligned,
      259 		2 offset		 fixed bin (18) unsigned unaligned;
      260 	dcl     try_record_len	 fixed bin (21);
      261 	dcl     try_record_ptr	 ptr;
      262 
      263 
      264 
      265      end vrmu_scan_records;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/21/84  0934.1  vrmu_scan_records.pl1             >special_ldd>online>mrds_install>vrmu_scan_records.pl1
222          1    07/19/79  1547.0  vfile_indx.incl.pl1               >ldd>include>vfile_indx.incl.pl1
1-376        2    07/19/79  1547.0  vfile_action_codes.incl.pl1       >ldd>include>vfile_action_codes.incl.pl1
224          3    05/20/83  1846.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
226          4    10/14/83  1609.1  vrm_tuple.incl.pl1                >ldd>include>vrm_tuple.incl.pl1
228          5    10/14/83  1609.1  vrm_rel_desc.incl.pl1             >ldd>include>vrm_rel_desc.incl.pl1
230          6    10/14/83  1609.1  vrmu_scan_rec_next.incl.pl1       >ldd>include>vrmu_scan_rec_next.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CONTINUE                               constant        fixed bin(17,0)          initial dcl 232 ref 114 115 124 167
DONT_CREATE                     000004 constant        bit(1)                   initial unaligned dcl 233 set ref 120*
EOF                                    constant        fixed bin(17,0)          initial dcl 234 ref 122 130 140 185
P_code                                 parameter       fixed bin(35,0)          dcl 237 set ref 67 67 71* 78 78 82* 86* 97* 188*
                                                                                  190*
RECORD_FOUND                           constant        fixed bin(17,0)          initial dcl 235 ref 143 153 173
abs                                                    builtin function         dcl 1-390 ref 126
addr                                                   builtin function         dcl 1-384 ref 116 118 120 120 126 126 126 128 128
                                                                                  129 130 134 134 138 138 139 140 150 150 151 151
                                                                                  158 162 166 166 179 179
addrel                                                 builtin function         dcl 238 ref 134 158 162
at_bof                  112            based           bit(1)                   level 5 packed unaligned dcl 1-3 set ref 108 110*
at_eof_or_bof           112            based           structure                level 4 packed unaligned dcl 1-3
bit_count                       000104 automatic       fixed bin(24,0)          dcl 240 set ref 120*
block_ptr                 4            based           pointer                  level 2 dcl 6-14 set ref 81* 181*
block_size                0(02)        based           fixed bin(19,0)          level 3 packed unaligned dcl 1-115 ref 135
block_tail                1            based           structure                level 2 unaligned dcl 1-115
cb_area                                based           area(1024)               dcl 213 ref 201
change_count             17            based           fixed bin(34,0)          level 2 dcl 1-157 ref 107 171
code                            000105 automatic       fixed bin(35,0)          dcl 241 set ref 120* 122 190 190
common_header                          based           structure                level 2 unaligned dcl 1-157
comp_num                               based           fixed bin(17,0)          level 2 packed unaligned dcl 257 set ref 116 118 120
                                                                                  120 126 128* 128 130 134 138* 138 140
comp_table                             based           structure                array level 1 dcl 1-268
comp_table_start                       based           fixed bin(17,0)          array level 2 dcl 1-157 set ref 126
descriptor               10            based           fixed bin(35,0)          array level 2 dcl 6-14 set ref 82* 175* 178*
divide                                                 builtin function         dcl 1-385 ref 95
error_table_$end_of_info        000010 external static fixed bin(35,0)          dcl 242 ref 86 188
error_table_$file_busy          000014 external static fixed bin(35,0)          dcl 250 ref 97
f_b_ptr                         000102 automatic       pointer                  dcl 1-156 set ref 83* 101 107 126 130 140 171 200
fcb_ptr                                based           pointer                  level 2 dcl 1-3 set ref 120*
file_base                              based           structure                level 1 unaligned dcl 1-157
file_base_ptr             2            based           pointer                  level 2 dcl 1-3 ref 83
file_state_block                       based           structure                level 1 unaligned dcl 1-280 ref 126 130 140 200
fixed_state_part        106            based           structure                level 3 unaligned dcl 1-3
fs_ptr                                 automatic       pointer                  dcl 1-279 ref 126 130 140 200
get_system_free_area_           000020 constant        entry                    external dcl 214 ref 201
hbound                                                 builtin function         dcl 239 ref 116
i                               000132 automatic       fixed bin(17,0)          dcl 215 set ref 203* 204 204* 206* 207*
indirect                  0(24)        based           bit(1)                   level 3 packed unaligned dcl 1-115 ref 143
indx_cb                                based           structure                level 1 unaligned dcl 1-3
indx_cb_ptr                     000100 automatic       pointer                  dcl 1-2 set ref 70* 72 80* 83 84 95 108 110 111 113
                                                                                  116 116 118 120 120 134 180 187 198 199 200 201
                                                                                  201 204 206 207
iocb                                   based           structure                level 1 dcl 3-6
iocb_ptr                               based           pointer                  level 2 in structure "vrmu_scan_rec_next" dcl 6-14
                                                                                  in procedure "vrmu_scan_records" ref 80
iocb_ptr                               parameter       pointer                  dcl 236 in procedure "vrmu_scan_records" ref 67 67
                                                                                  70
last_comp_num                          based           fixed bin(17,0)          level 2 dcl 1-157 ref 130 140 200
length                                                 builtin function         dcl 1-386 ref 157 161
lock_word                 1            based           bit(36)                  level 3 dcl 1-157 ref 101
msf_manager_$get_ptr            000012 constant        entry                    external dcl 244 ref 120
null                                                   builtin function         dcl 1-387 ref 81 118 207
offset                    0(18)        based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 257 set ref
                                                                                  126 129* 134 139* 150* 150 151* 151 166* 166 179*
                                                                                  179
old_array                              based           pointer                  array dcl 218 ref 204 210
old_array_limit                 000133 automatic       fixed bin(17,0)          dcl 216 set ref 198* 203 206 210
old_array_ptr                   000134 automatic       pointer                  dcl 217 set ref 199* 204 210
open_data_ptr            22            based           pointer                  level 2 dcl 3-6 ref 70 80
pad                                    based           bit(2)                   level 3 packed unaligned dcl 1-115 ref 143
read_count                      000106 automatic       fixed bin(17,0)          dcl 249 set ref 90* 94* 94 95
record                    7            based           varying char(1000000)    level 2 in structure "stat_structure" dcl 1-92
                                                                                  in procedure "vrmu_scan_records" set ref 161 162
record                    1            based           varying char(1000000)    level 3 in structure "record_block_structure"
                                                                                  dcl 1-115 in procedure "vrmu_scan_records" set ref
                                                                                  157 158
record_block_structure                 based           structure                level 1 unaligned dcl 1-115
record_len               11            based           fixed bin(21,0)          level 2 dcl 6-14 set ref 183*
record_ptr                6            based           pointer                  level 2 dcl 6-14 set ref 81* 182*
rel_id                                 based           bit(12)                  level 2 in structure "tuple" packed unaligned
                                                                                  dcl 4-7 in procedure "vrmu_scan_records" ref 164
rel_id                    2(02)        based           bit(12)                  level 2 in structure "vrmu_scan_rec_next" packed
                                                                                  unaligned dcl 6-14 in procedure
                                                                                  "vrmu_scan_records" ref 164
reserved                               based           structure                level 2 dcl 1-115
save_change_count               000107 automatic       fixed bin(35,0)          dcl 252 set ref 107* 171
scan_records_should_lock
                          2(01)        based           bit(1)                   level 2 packed unaligned dcl 6-14 ref 92
scan_status                     000110 automatic       fixed bin(17,0)          dcl 253 set ref 114* 115 122* 124* 130* 140* 143*
                                                                                  153 167* 173 185
seg_limit                              based           fixed bin(19,0)          array level 2 dcl 1-268 ref 126
seg_ptr_array                          based           pointer                  array dcl 1-85 set ref 116 118 120* 134 201 204*
                                                                                  207*
seg_ptr_array_limit      12            based           fixed bin(17,0)          level 2 dcl 1-3 set ref 116 198 200* 201 206
seg_ptr_array_ptr        10            based           pointer                  level 2 dcl 1-3 set ref 116 118 120 134 199 201* 204
                                                                                  207
size                                                   builtin function         dcl 1-389 ref 126 130 140 200
stat_structure                         based           structure                level 1 unaligned dcl 1-92
state_vars              106            based           structure                level 2 unaligned dcl 1-3
stationary                0(23)        based           bit(1)                   level 3 packed unaligned dcl 1-115 ref 143 143 155
                                                                                  175
stationary_rec_expected
                          2            based           bit(1)                   level 2 packed unaligned dcl 6-14 ref 175
substr                                                 builtin function         dcl 1-388 ref 143
timer_manager_$sleep            000016 constant        entry                    external dcl 251 ref 103
transaction_code         71            based           fixed bin(35,0)          level 2 dcl 1-3 set ref 72* 84 111* 113 180* 187*
try                                    based           structure                level 1 packed unaligned dcl 257
try_block_ptr                   000112 automatic       pointer                  dcl 254 set ref 134* 135 143 143 143 143 155 157 158
                                                                                  161 162 175 181
try_block_size                  000114 automatic       fixed bin(21,0)          dcl 255 set ref 135* 136 150 151 166 179
try_descriptor                  000115 automatic       fixed bin(35,0)          dcl 256 set ref 113* 116 118 120 120 126 126 128 128
                                                                                  129 130 134 134 138 138 139 140 150 150 151 151
                                                                                  166 166 178 179 179 180
try_record_len                  000116 automatic       fixed bin(21,0)          dcl 260 set ref 157* 161* 164 183
try_record_ptr                  000120 automatic       pointer                  dcl 261 set ref 158* 162* 164 182
tuple                                  based           structure                level 1 dcl 4-7
vrm_attr_info                          based           structure                level 1 unaligned dcl 5-28
vrmu_scan_rec_next                     based           structure                level 1 dcl 6-14
vrmu_scan_rec_next_ptr                 parameter       pointer                  dcl 6-12 ref 78 78 80 81 81 82 92 164 175 175 178
                                                                                  181 182 183
wait_time                41            based           fixed bin(35,0)          level 2 dcl 1-3 ref 95

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
VRM_REL_DESC_KEY                       internal static varying char(256)        initial dcl 5-46
VRM_REL_DESC_RECORD_ID                 internal static bit(12)                  initial unaligned dcl 5-43
VRM_REL_DESC_VERSION_1                 internal static char(8)                  initial unaligned dcl 5-44
adding_key                             internal static fixed bin(17,0)          initial dcl 2-13
adding_record                          internal static fixed bin(17,0)          initial dcl 2-11
adjust_action                          internal static fixed bin(17,0)          initial dcl 2-3
alloc_cb_file                   000000 constant        entry                    external dcl 1-359
allocate_action                        internal static fixed bin(17,0)          initial dcl 2-8
append_action                          internal static fixed bin(17,0)          initial dcl 2-19
bit                                                    builtin function         dcl 1-393
bumping_count                          internal static fixed bin(17,0)          initial dcl 2-1
change_index                    000000 constant        entry                    external dcl 1-372
change_record_list              000000 constant        entry                    external dcl 1-373
clock_                          000000 constant        entry                    external dcl 1-358
create_position_stack           000000 constant        entry                    external dcl 1-369
create_seg_ptrs                 000000 constant        entry                    external dcl 1-364
current_t_code                         based           fixed bin(35,0)          dcl 1-82
delete_action                          internal static fixed bin(17,0)          initial dcl 2-14
deleting_key                           internal static fixed bin(17,0)          initial dcl 2-12
designator                             automatic       fixed bin(35,0)          dcl 1-88
designator_struct                      based           structure                level 1 dcl 1-127
eof_delete                             internal static fixed bin(17,0)          initial dcl 2-15
extend_position_stack           000000 constant        entry                    external dcl 1-370
file_header                            based           structure                level 1 unaligned dcl 1-274
fixed                                                  builtin function         dcl 1-392
free_action                            internal static fixed bin(17,0)          initial dcl 2-6
free_cb_file                    000000 constant        entry                    external dcl 1-361
free_position_stack             000000 constant        entry                    external dcl 1-371
free_seg                        000000 constant        entry                    external dcl 1-367
free_seg_ptrs                   000000 constant        entry                    external dcl 1-365
get_new_seg                     000000 constant        entry                    external dcl 1-366
get_seg_ptr                     000000 constant        entry                    external dcl 1-362
ind_des_structure                      based           structure                level 1 packed unaligned dcl 1-89
ind_structure                          based           structure                level 1 unaligned dcl 1-102
index_state_block                      based           structure                level 1 unaligned dcl 1-298
insert_action                          internal static fixed bin(17,0)          initial dcl 2-18
iox_$iocb_version_sentinel             external static char(4)                  dcl 3-51
is_ptr                                 automatic       pointer                  dcl 1-297
keys                                   based           char(4096)               unaligned dcl 1-153
make_designator                 000000 constant        entry                    external dcl 1-363
max                                                    builtin function         dcl 1-394
min                                                    builtin function         dcl 1-395
must_adjust                            internal static fixed bin(17,0)          initial dcl 2-21
must_rollback                          internal static fixed bin(17,0)          initial dcl 2-22
node_block                             based           structure                level 1 unaligned dcl 1-139
non_eof_delete                         internal static fixed bin(17,0)          initial dcl 2-5
old_file_base                          based           structure                level 1 unaligned dcl 1-331
pos_ptr                                automatic       pointer                  dcl 246
position_frame                         based           structure                level 1 unaligned dcl 1-132
read_exclude                           internal static fixed bin(17,0)          initial dcl 2-10
reassigning_key                        internal static fixed bin(17,0)          initial dcl 2-9
rel                                                    builtin function         dcl 1-396
replace_action                         internal static fixed bin(17,0)          initial dcl 2-16
reverse                                                builtin function         dcl 1-383
rewrite_action                         internal static fixed bin(17,0)          initial dcl 2-17
rollback_action                        internal static fixed bin(17,0)          initial dcl 2-2
seg_array                              based           fixed bin(19,0)          array dcl 1-87
seg_ptr                                automatic       pointer                  dcl 1-86
set_bitcounts                   000000 constant        entry                    external dcl 1-368
stat_header_size                       internal static fixed bin(17,0)          initial dcl 1-380
time_stamp_structure                   based           structure                level 1 packed unaligned dcl 1-112
true_max_comp_num                      internal static fixed bin(17,0)          initial dcl 1-379
truncate_action                        internal static fixed bin(17,0)          initial dcl 2-20
tuple_length                           automatic       fixed bin(21,0)          dcl 4-16
tuple_pad_length                       internal static fixed bin(17,0)          initial dcl 4-18
tuple_ptr                              automatic       pointer                  dcl 4-15
unshared_opening                       internal static fixed bin(17,0)          initial dcl 2-4
unspec                                                 builtin function         dcl 1-391
verify                                                 builtin function         dcl 1-383
vrd_no_of_attrs                        automatic       fixed bin(17,0)          dcl 5-42
vrm_attr_info_ptr                      automatic       pointer                  dcl 5-45
vrm_rel_desc                           based           structure                level 1 unaligned dcl 5-5
vrm_rel_desc_ptr                       automatic       pointer                  dcl 5-41
write_trunc                            internal static fixed bin(17,0)          initial dcl 2-7

NAMES DECLARED BY EXPLICIT CONTEXT.
extend_seg_ptr_array            000573 constant        entry                    internal dcl 196 ref 116
init                            000035 constant        entry                    external dcl 67
next                            000065 constant        entry                    external dcl 78
scan_records_init               000025 constant        entry                    external dcl 67
scan_records_next               000055 constant        entry                    external dcl 78
start_read                      000136 constant        label                    dcl 92 ref 104 171
vrmu_scan_records               000013 constant        entry                    external dcl 9

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1026        1050     672        1036
Length      1352     672        22         266     133           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
vrmu_scan_records                   129 external procedure  is an external procedure.  
extend_seg_ptr_array                    internal procedure  shares stack frame of external procedure vrmu_scan_records.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
vrmu_scan_records        000100 indx_cb_ptr                 vrmu_scan_records
                         000102 f_b_ptr                     vrmu_scan_records
                         000104 bit_count                   vrmu_scan_records
                         000105 code                        vrmu_scan_records
                         000106 read_count                  vrmu_scan_records
                         000107 save_change_count           vrmu_scan_records
                         000110 scan_status                 vrmu_scan_records
                         000112 try_block_ptr               vrmu_scan_records
                         000114 try_block_size              vrmu_scan_records
                         000115 try_descriptor              vrmu_scan_records
                         000116 try_record_len              vrmu_scan_records
                         000120 try_record_ptr              vrmu_scan_records
                         000132 i                           extend_seg_ptr_array
                         000133 old_array_limit             extend_seg_ptr_array
                         000134 old_array_ptr               extend_seg_ptr_array

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return              ext_entry           alloc_based         free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_system_free_area_         msf_manager_$get_ptr          timer_manager_$sleep

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$end_of_info      error_table_$file_busy




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      9 000012         9 000020        67 000021        70 000042        71 000047        72 000050        74 000052
     78 000053        80 000072        81 000100        82 000106        83 000122        84 000125        86 000131
     87 000134        90 000135        92 000136        94 000144        95 000145        97 000152        98 000155
    101 000156       103 000161       104 000176       107 000177       108 000202       110 000206       111 000210
    113 000212       114 000214       115 000216       116 000220       118 000230       120 000244       122 000270
    124 000275       125 000277       126 000300       128 000313       129 000317       130 000321       132 000327
    134 000330       135 000335       136 000341       138 000342       139 000346       140 000350       142 000356
    143 000357       150 000377       151 000403       153 000405       155 000410       157 000413       158 000416
    159 000422       161 000423       162 000426       163 000432       164 000433       166 000447       167 000453
    170 000455       171 000456       173 000462       175 000465       178 000512       179 000530       180 000534
    181 000537       182 000543       183 000547       184 000553       185 000554       187 000556       188 000561
    189 000565       190 000566       192 000572       196 000573       198 000574       199 000577       200 000601
    201 000604       203 000624       204 000633       205 000640       206 000642       207 000653       208 000660
    210 000662       220 000667


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
