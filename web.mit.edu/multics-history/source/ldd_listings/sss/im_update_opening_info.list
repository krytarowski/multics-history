	COMPILATION LISTING OF SEGMENT im_update_opening_info
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phx. Az., Sys-M 
	Compiled on: 04/02/87  1308.8 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* DESCRIPTION:
        8*
        9*         This  module  update  the index_opening_info data.  Separate entries
       10*     are provided for updating  the  root_id  and  the  key_count_array.
       11*     For the key_count_array entry, this module maintains an increments array.
       12*     This is an array of increments that are to be applied to the actual key
       13*     count array in the index when the transaction commits.  When this entry is
       14*     called, the key count array that is passed (pointed to by pkca_ptr) is
       15*     compared to the opening key count array (pointed to by okca_ptr), the
       16*     differences are applied to the internal increments array (pointed to by
       17*     ikca_ptr), and the opening key count array is updated.  If increments
       18*     key_count_array has never been allocated, that is, this is the first time
       19*     this entry has been called for this index since this index has been opened
       20*     in this process, then the increments structure is allocated in the DM free
       21*     area.  If this is the first time this entry has been called for this index
       22*     since the current transaction began or since a rollback occured, a
       23*     postcommit handler is written that will cause the file key count array
       24*     to be updated with the increments key_count_array at postcommit time.
       25**/
       26 
       27 /* HISTORY:
       28*
       29*Written by Lindsey L. Spratt, 10/28/82.
       30*Modified:
       31*12/09/82 by Lindsey Spratt: Changed to use dm_key_count_array incl file.
       32*04/28/83 by Matthew Pierret:  Changed $key_count_array to use the new
       33*            collection_manager_$put_unprotected_header.  This entry does not
       34*            obtain an exclusive lock while writing the header.  This is
       35*            considered safe because only the information in the header
       36*            pertaining to key_counts is changed, and this information is not
       37*            critical.  This change was made in the hopes of relieving a major
       38*            concurrency bottleneck.
       39*10/27/84 by Lindsey L. Spratt:  Changed to use version 2 index_opening_info,
       40*            version 4 index_header, version 2 key_count_array.  Changed to put
       41*            the key_count_array (rather than modify it) when the
       42*            key_count_array was not previously in the index (this is the
       43*            second step in the conversion of the index to using version 4
       44*            index_headers from version 3).
       45*03/07/85 by R. Michael Tague:  Changed opening info version to version 3.
       46*03/11/85 by R. Michael Tague:  Changed the $key_count_array entry to manage a
       47*            increments structure instead of simply replacing the 
       48*	  key_count_array in the collection.  A postcommit handler is written
       49*	  to insure that the key_count_array is eventually updated.  Removed
       50*	  the index_header automatic version conversion.
       51*03/25/85 by R. Michael Tague:  Changed to update the key count array of 
       52*	  unprotected files by calling UPDATE_UNPROTECTED_COUNTS and to 
       53*	  maintain index_opening_info.flags.key_count_unprotected_file.
       54**/
       55 
       56 /* format: style2,ind3 */
       57 im_update_opening_info$key_count_array:
       58    proc (p_index_opening_info_ptr, p_key_count_array_ptr, p_code);
       59 
       60 /* START OF DECLARATIONS */
       61 /* Parameter */
       62 
       63       dcl	    p_index_opening_info_ptr
       64 			       ptr parameter;
       65       dcl	    p_key_count_array_ptr  ptr parameter;
       66       dcl	    p_root_id	       fixed bin (24) uns parameter;
       67       dcl	    p_code	       fixed bin (35) parameter;
       68 
       69 /* Automatic */
       70 
       71       dcl	    (update_key_counts, update_root_id)
       72 			       bit (1) aligned init ("0"b);
       73       dcl	    pkca_ptr	       ptr;		/* parameter (passed) kca ptr */
       74       dcl	    okca_ptr	       ptr;		/* opening info kca ptr */
       75       dcl	    ikca_ptr	       ptr;		/* increments kca ptr */
       76       dcl	    1 increment_info       aligned like cm_increment_info;
       77 
       78 /* Based */
       79 
       80       dcl	    work_area	       area based (work_area_ptr);
       81 
       82 /* Builtin */
       83 
       84       dcl	    (addr, bin, length, null, rel, unspec)
       85 			       builtin;
       86 
       87 /* Constant */
       88 
       89       dcl	    BITS_PER_WORD	       fixed bin init (36) internal static options (constant);
       90       dcl	    HEADER_COLLECTION_ID   bit (36) aligned init ("000000000001"b3) internal static options (constant);
       91       dcl	    myname	       init ("im_update_opening_info") char (32) varying internal static options (constant);
       92       dcl	    work_area_ptr	       ptr init (null) internal static;
       93 
       94 /* Entry */
       95 
       96       dcl	    get_dm_free_area_      entry () returns (ptr);
       97       dcl	    sub_err_	       entry () options (variable);
       98 
       99 /* External */
      100 
      101       dcl	    dm_error_$file_must_be_protected
      102 			       fixed bin (35) ext static;
      103       dcl	    dm_error_$programming_error
      104 			       fixed bin (35) ext static;
      105       dcl	    error_table_$unimplemented_version
      106 			       fixed bin (35) ext static;
      107 
      108 /* END OF DECLARATIONS */
      109 
      110 /* key_count_array:
      111*   entry (p_index_opening_info_ptr, p_key_count_array_ptr, p_code);
      112**/
      113       update_key_counts = "1"b;
      114       pkca_ptr = p_key_count_array_ptr;
      115       goto JOIN;
      116 
      117 root_id:
      118    entry (p_index_opening_info_ptr, p_root_id, p_code);
      119       update_root_id = "1"b;
      120 JOIN:
      121       p_code = 0;
      122       index_opening_info_ptr = p_index_opening_info_ptr;
      123       call CHECK_VERSION (index_opening_info.version, INDEX_OPENING_INFO_VERSION_3, "index_opening_info");
      124 
      125       index_header_ptr = index_opening_info.index_header_ptr;
      126       call CHECK_VERSION (index_header.version, INDEX_HEADER_VERSION_4, "index_header");
      127 
      128       if update_key_counts
      129       then
      130          do;
      131 	  call CHECK_VERSION (pkca_ptr -> key_count_array.version, KEY_COUNT_ARRAY_VERSION_2, "passed key_count_array");
      132 	  okca_ptr = index_opening_info.key_count_array_ptr;
      133 	  call CHECK_VERSION (okca_ptr -> key_count_array.version, KEY_COUNT_ARRAY_VERSION_2,
      134 	       "opening info key_count_array");
      135 	  if index_opening_info.key_count_unprotected_file
      136 	  then call UPDATE_UNPROTECTED_COUNTS ();
      137 	  else call UPDATE_PROBABLY_PROTECTED_COUNTS ();
      138          end;
      139       else
      140          do;
      141 	  index_header.root_id = p_root_id;
      142 	  call collection_manager_$put_header (index_opening_info.file_opening_id, index_opening_info.collection_id,
      143 	       index_header_ptr, length (unspec (index_header)), p_code);
      144 	  if p_code ^= 0
      145 	  then call ERROR_RETURN (p_code);
      146          end;
      147 MAIN_RETURN:
      148       return;
      149 
      150 ERROR_RETURN:
      151    proc (er_p_code);
      152       dcl	    er_p_code	       fixed bin (35) parameter;
      153       p_code = er_p_code;
      154       goto MAIN_RETURN;
      155    end ERROR_RETURN;
      156 
      157 CHECK_VERSION:
      158    proc (p_received_version, p_expected_version, p_structure_name);
      159       dcl	    p_received_version     char (8) aligned parameter;
      160       dcl	    p_expected_version     char (8) aligned parameter;
      161       dcl	    p_structure_name       char (*);
      162 
      163       if p_received_version ^= p_expected_version
      164       then call sub_err_ (error_table_$unimplemented_version, myname, "s", null, 0,
      165 	      "^/Expected version ^d of the ^a structure.
      166 Received version ^d instead.", p_expected_version, p_structure_name, p_received_version);
      167 
      168    end CHECK_VERSION;
      169 
      170 /* *************************************************************************
      171*   * SET_UP_KEY_INCREMENTS_ARRAY - This procedure allocates a key count    *
      172*   * array in the DM work area the same size as the opening info key count *
      173*   * array.  This allocated array is used to hold the key count increments *
      174*   * that the postcommit handler uses to update the index's key count	     *
      175*   * array.						     *
      176*   *							     *
      177*   * A pointer to the created array is returned.			     *
      178*   ************************************************************************* */
      179 
      180 SET_UP_KEY_INCREMENTS_ARRAY:
      181    proc (p_ikca_ptr);
      182       dcl	    p_ikca_ptr	       ptr;
      183 
      184       if work_area_ptr = null
      185       then work_area_ptr = get_dm_free_area_ ();
      186       kca_number_of_counts = okca_ptr -> key_count_array.number_of_counts;
      187       alloc key_count_array in (work_area);
      188       key_count_array.version = KEY_COUNT_ARRAY_VERSION_2;
      189       unspec (key_count_array.count) = ""b;
      190 
      191       p_ikca_ptr = addr (key_count_array);
      192    end SET_UP_KEY_INCREMENTS_ARRAY;
      193 
      194 /* *************************************************************************
      195*   * UPDATE_INCREMENTS_ARRAY - This procedure updates the increments key   *
      196*   * count array with the difference of parameter key count and opening    *
      197*   * key count.  Afterwards the opening key count array is set equal to    *
      198*   * the passed (parameter) key count array.			     *
      199*   ************************************************************************* */
      200 
      201 UPDATE_INCREMENTS_ARRAY:
      202    proc ();
      203 
      204       dcl	    uia_key_count_index    fixed bin;
      205 
      206       do uia_key_count_index = lbound (okca_ptr -> key_count_array.count, 1)
      207 	 to hbound (okca_ptr -> key_count_array.count, 1);
      208          ikca_ptr -> key_count_array.count (uia_key_count_index) =
      209 	    ikca_ptr -> key_count_array.count (uia_key_count_index)
      210 	    + (pkca_ptr -> key_count_array.count (uia_key_count_index)
      211 	    - okca_ptr -> key_count_array.count (uia_key_count_index));
      212          okca_ptr -> key_count_array.count (uia_key_count_index) =
      213 	    pkca_ptr -> key_count_array.count (uia_key_count_index);
      214       end;
      215    end UPDATE_INCREMENTS_ARRAY;
      216 
      217 /* *************************************************************************
      218*   * UPDATE_PROBABLY_PROTECTED_COUNTS - This procedure updates the key     *
      219*   * count array for protected files.  The first time this procedure is    *
      220*   * called for a given file, a postcommit handler is written.  If the     *
      221*   * handler cannot be written because the file is not protected then      *
      222*   * UPDATE_UNPROTECTED_COUNTS is called and index_opening_info.flags.     *
      223*   * key_count_unprotected_file is set so that future updates on this file *
      224*   * will use UPDATE_UNPROTECTED_COUNTS.			     *
      225*   ************************************************************************* */
      226 
      227 UPDATE_PROBABLY_PROTECTED_COUNTS:
      228    proc ();
      229 
      230       dcl	    uppc_code	       fixed bin (35);
      231 
      232       ikca_ptr = index_opening_info.key_count_increments_ptr;
      233       if ikca_ptr = null
      234       then
      235          do;
      236 	  call SET_UP_KEY_INCREMENTS_ARRAY (ikca_ptr);
      237 	  index_opening_info.key_count_increments_ptr = ikca_ptr;
      238          end;
      239       else call CHECK_VERSION (ikca_ptr -> key_count_array.version, KEY_COUNT_ARRAY_VERSION_2,
      240 	      "increment key_count_array");
      241 
      242       if okca_ptr -> key_count_array.number_of_counts ^= pkca_ptr -> key_count_array.number_of_counts
      243 	 | okca_ptr -> key_count_array.number_of_counts ^= ikca_ptr -> key_count_array.number_of_counts
      244       then call sub_err_ (dm_error_$programming_error, myname, ACTION_CANT_RESTART, null, 0,
      245 	      "^/The sizes of the opening key_count_array, the passed key_count_array, and^/the increments key_count_array arrays are inconsistant."
      246 	      );
      247 
      248       if ^index_opening_info.flags.key_count_postcommit_written
      249       then
      250          do;
      251 	  call WRITE_INCREMENTS_POSTCOMMIT_HANDLER (uppc_code);
      252 	  if uppc_code = dm_error_$file_must_be_protected
      253 	  then
      254 	     do;
      255 	        call UPDATE_UNPROTECTED_COUNTS ();
      256 	        index_opening_info.flags.key_count_unprotected_file = "1"b;
      257 	     end;
      258 	  else if uppc_code ^= 0
      259 	  then call ERROR_RETURN (uppc_code);
      260 	  else
      261 	     do;
      262 	        index_opening_info.flags.key_count_postcommit_written = "1"b;
      263 	        call UPDATE_INCREMENTS_ARRAY ();
      264 	     end;
      265          end;
      266       else call UPDATE_INCREMENTS_ARRAY ();
      267    end UPDATE_PROBABLY_PROTECTED_COUNTS;
      268 
      269 /* *************************************************************************
      270*   * UPDATE_UNPROTECTED_COUNTS - Updates the opening info key count array  *
      271*   * and then writes this array out to the unprotected index file.	     *
      272*   ************************************************************************* */
      273 
      274 UPDATE_UNPROTECTED_COUNTS:
      275    proc ();
      276 
      277       dcl	    upc_code	       fixed bin (35);
      278 
      279       okca_ptr -> key_count_array.count = pkca_ptr -> key_count_array.count;
      280       call collection_manager_$modify_unprotected (index_opening_info.file_opening_id, HEADER_COLLECTION_ID,
      281 	 okca_ptr, length (unspec (okca_ptr -> key_count_array)), unspec (index_header.key_count_array_element_id), (0),
      282 	 upc_code);
      283       if upc_code ^= 0
      284       then call ERROR_RETURN (upc_code);
      285    end UPDATE_UNPROTECTED_COUNTS;
      286 
      287 /* *************************************************************************
      288*   * WRITE_INCREMENTS_POSTCOMMIT_HANDLER - Builds the increment info       *
      289*   * structure and tries to write the increments postcommit handler.  The  *
      290*   * postcommit handler is given a pointer to the local increments array   *
      291*   * so that an update can be made using stacq's at postcommit time.	     *
      292*   ************************************************************************* */
      293 
      294 WRITE_INCREMENTS_POSTCOMMIT_HANDLER:
      295    proc (wiph_code);
      296       dcl	    wiph_code	       fixed bin (35);
      297 
      298       unspec (ikca_ptr -> key_count_array.count) = ""b;
      299       unspec (increment_info) = ""b;
      300       increment_info.version = CM_INCREMENT_INFO_VERSION_1;
      301       increment_info.increments_ptr = ikca_ptr;
      302       increment_info.offset_in_bits =
      303 	 BITS_PER_WORD * (bin (rel (addr (ikca_ptr -> key_count_array.count (0)))) - bin (rel (ikca_ptr)));
      304       increment_info.number_of_words =
      305 	 hbound (ikca_ptr -> key_count_array.count, 1) - lbound (ikca_ptr -> key_count_array.count, 1) + 1;
      306       call collection_manager_$postcommit_increments (index_opening_info.file_opening_id, HEADER_COLLECTION_ID,
      307 	 unspec (index_header.key_count_array_element_id), addr (increment_info), wiph_code);
      308    end WRITE_INCREMENTS_POSTCOMMIT_HANDLER;
      309 
  1     1 /* BEGIN INCLUDE FILE dm_cm_increment_info.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*This structure is used to locate an array of increment words to be used
  1     5*in one or more postcommit handlers.  The structure elements have the following
  1     6*meaning:
  1     7*increments_ptr  - pointer to the structure containing the array of word
  1     8*	        increment values in the users address space.
  1     9*offset_in_bits  - is the offset from the begining of the structure to the
  1    10*	        first word increment.  This value is also used to locate
  1    11*	        the first word increment within the collection manager
  1    12*	        element, that is, it is assumed that the structure
  1    13*	        containing the increment words is stored in begining of
  1    14*	        a collection manager element.
  1    15*number_of_words - number of word increment values.
  1    16**/
  1    17 
  1    18 /* HISTORY:
  1    19*Written by R. Michael Tague, 03/06/85.
  1    20*Modified:
  1    21**/
  1    22 
  1    23 /* format: style5,^indcomtxt */
  1    24 
  1    25 dcl     cm_increment_info_ptr	  ptr;
  1    26 dcl     1 cm_increment_info	  aligned based (cm_increment_info_ptr),
  1    27 	2 version		  char (8),
  1    28 	2 increments_ptr	  ptr,
  1    29 	2 offset_in_bits	  fixed bin (35),
  1    30 	2 number_of_words	  fixed bin (35);
  1    31 
  1    32 dcl     CM_INCREMENT_INFO_VERSION_1
  1    33 			  char (8) aligned internal static
  1    34 			  options (constant) init ("cmword01");
  1    35 
  1    36 /* END INCLUDE FILE dm_cm_increment_info.incl.pl1 */
      310 
      311 
  2     1 /* BEGIN INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*     This include file contains declarations of all collection_manager_ 
  2     5*     entrypoints.
  2     6**/
  2     7 
  2     8 /* HISTORY:
  2     9*Written by Matthew Pierret 
  2    10*Modified:
  2    11*04/14/82 by Lindsey Spratt: Changed the control_interval_id parameter of the
  2    12*	  allocate_control_interval operation to be unaligned, as well as
  2    13*	  unsigned.
  2    14*06/17/82 by Matthew Pierret: Added the put_element_portion opertion and
  2    15*            removed the beginning_location parameter from the put_element
  2    16*            operation. Added the create_page_file_operation.
  2    17*08/09/82 by Matthew Pierret: Changed "fixed bin (17)"s to "bit (36) aligned"s
  2    18*            wherever collection_id was required.
  2    19*            Also changed the control_interval_id parameter of the 
  2    20*            allocate_control_interval operation back to be aligned. So there.
  2    21*10/20/82 by Matthew Pierret: Changed $create_page_file to $create_file,
  2    22*            added the argument file_create_info_ptr to $create_file.
  2    23*12/13/82 by Lindsey Spratt:  Corrected $free_control_interval to
  2    24*	  include the zero_on_free bit.
  2    25*12/17/82 by Matthew Pierret: Added cm_$get_id.
  2    26*01/07/83 by Matthew Pierret: Added cm_$put_element_buffered, 
  2    27*            cm_$allocate_element_buffered, cm_$free_element_buffered.
  2    28*04/27/83 by Matthew Pierret: Added cm_$put_unprotected_element,
  2    29*            cm_$put_unprotected_header.
  2    30*11/07/83 by Matthew Pierret: Added $get_element_portion_buffered,
  2    31*             $simple_get_buffered_element.
  2    32*02/08/84 by Matthew Pierret:  Changed $get_id to have only one bit(1)aligned
  2    33*            parameter for specifying absolute/relative nature of search.
  2    34*03/16/84 by Matthew Pierret:  Added cm_$get_control_interval_ptr,
  2    35*            $get_element_ptr, $get_element_portion_ptr, $simple_get_element_ptr
  2    36*04/03/84 by Matthew Pierret:  Added cm_$compact_control_interval.
  2    37*06/06/84 by Matthew Pierret:  Re-named free_element* to delete and
  2    38*            delete_from_ci_buffer.
  2    39*            Re-named *_buffered_ci to =_ci_buffer.
  2    40*            get entries.
  2    41*            modify entries.
  2    42*            Changed calling sequence of modify entries to have a ptr/length
  2    43*            instead of length/ptr parameter pair.
  2    44*03/11/85 by R. Michael Tague:  Added $postcommit_increments.
  2    45**/
  2    46 
  2    47 /* This include file contains declarations of collection_manager_ entrypoints */
  2    48 
  2    49 /* format: style2,ind3 */
  2    50      dcl	   collection_manager_$allocate_control_interval
  2    51 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
  2    52      dcl	   collection_manager_$compact_control_interval
  2    53 			      entry (bit (36) aligned, fixed bin (24) uns, fixed bin (35));
  2    54      dcl	   collection_manager_$create_collection
  2    55 			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  2    56      dcl	   collection_manager_$create_file
  2    57 			      entry (char (*), char (*), ptr, bit (36) aligned, fixed bin (35));
  2    58      dcl	   collection_manager_$destroy_collection
  2    59 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  2    60      dcl	   collection_manager_$free_control_interval
  2    61 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, bit (1) aligned,
  2    62 			      fixed bin (35));
  2    63 
  2    64      dcl	   collection_manager_$delete
  2    65 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  2    66 			      fixed bin (35));
  2    67      dcl	   collection_manager_$delete_from_ci_buffer
  2    68 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  2    69 			      fixed bin (35));
  2    70 
  2    71      dcl	   collection_manager_$get
  2    72 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  2    73 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  2    74      dcl	   collection_manager_$get_control_interval_ptr
  2    75 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, ptr,
  2    76 			      fixed bin (35));
  2    77      dcl	   collection_manager_$get_from_ci_buffer
  2    78 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  2    79 			      ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  2    80      dcl	   collection_manager_$get_by_ci_ptr
  2    81 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  2    82 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), ptr, fixed bin (35));
  2    83      dcl	   collection_manager_$get_header
  2    84 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (17), ptr, bit (1) aligned,
  2    85 			      ptr, fixed bin (35), fixed bin (35));
  2    86      dcl	   collection_manager_$get_id
  2    87 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17),
  2    88 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  2    89      dcl	   collection_manager_$get_portion
  2    90 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  2    91 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  2    92 			      fixed bin (35), fixed bin (35));
  2    93      dcl	   collection_manager_$get_portion_from_ci_buffer
  2    94 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  2    95 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  2    96 			      fixed bin (35));
  2    97      dcl	   collection_manager_$get_portion_by_ci_ptr
  2    98 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  2    99 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  2   100 			      fixed bin (35));
  2   101      dcl	   collection_manager_$modify
  2   102 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  2   103 			      fixed bin (35), fixed bin (35));
  2   104      dcl	   collection_manager_$modify_unprotected
  2   105 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  2   106 			      fixed bin (35), fixed bin (35));
  2   107      dcl	   collection_manager_$modify_in_ci_buffer
  2   108 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  2   109 			      fixed bin (35), fixed bin (35));
  2   110      dcl	   collection_manager_$modify_portion
  2   111 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35), ptr,
  2   112 			      fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  2   113      dcl	   collection_manager_$postcommit_increments
  2   114 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  2   115      dcl	   collection_manager_$put
  2   116 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  2   117 			      fixed bin (35), fixed bin (35));
  2   118      dcl	   collection_manager_$put_in_ci_buffer
  2   119 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  2   120 			      fixed bin (35), fixed bin (35));
  2   121      dcl	   collection_manager_$put_header
  2   122 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  2   123      dcl	   collection_manager_$put_unprotected_header
  2   124 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  2   125 
  2   126      dcl	   collection_manager_$replace_ci_buffer
  2   127 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  2   128 			      fixed bin (35));
  2   129      dcl	   collection_manager_$setup_ci_buffer
  2   130 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  2   131 			      fixed bin (35));
  2   132      dcl	   collection_manager_$simple_get_by_ci_ptr
  2   133 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  2   134 			      fixed bin (35));
  2   135      dcl	   collection_manager_$simple_get_from_ci_buffer
  2   136 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  2   137 			      fixed bin (35));
  2   138 
  2   139 /* END INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
      312 
      313 
  3     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*
  3     5*        Contains the declaration of an element identifier.  Element
  3     6*   identifiers consist of two parts, the id (number) of the control interval
  3     7*   in which the element resides, and the index into the slot table of
  3     8*   the element in the control interval.  The declaration of the element_id 
  3     9*   structure reflects this division of the element identifier.  The structure 
  3    10*   is based on the automatic bit string element_id_string because programs
  3    11*   generally pass bit strings (element_id_string) to each other, then 
  3    12*   interpret the bit string by overlaying the element_id structure ony if
  3    13*   it is necessary to access the parts of the id.  Basing element_id on
  3    14*   addr(element_id_string) instead of on a pointer removes the necessity
  3    15*   for always setting that pointer explicitly and guarantees that changes
  3    16*   made to the string or structure do not get inconsistent.
  3    17*
  3    18*   Changes made to element_id must also be made to datum_id, declared in 
  3    19*   dm_cm_datum.incl.pl1.
  3    20**/
  3    21 
  3    22 /* HISTORY:
  3    23*Written by Matthew Pierret, 04/01/82.
  3    24*Modified:
  3    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  3    26**/
  3    27 
  3    28 /* format: style2,ind3,ll79 */
  3    29 
  3    30      dcl	   element_id_string      bit (36) aligned;
  3    31 
  3    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  3    33 	     2 control_interval_id
  3    34 			      fixed bin (24) unal unsigned,
  3    35 	     2 index	      fixed bin (12) unal unsigned;
  3    36 
  3    37 
  3    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      314 
      315 
  4     1 /* BEGIN INCLUDE FILE - dm_key_count_array.incl.pl1 */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(87-01-15,Hergert), approve(87-04-01,MCR7632),
  4     7*     audit(87-02-09,Dupuis), install(87-04-02,MR12.1-1020):
  4     8*     Added the KEY_COUNT_OFFSET_IN_CHARACTERS. This is the offset from the
  4     9*     beginning of the structure to the element key_count_array.count in
  4    10*     characters. Using this it is possible to calculate the key_count_array_ptr
  4    11*     given the "addr (key_count_array.count (0))".
  4    12*                                                   END HISTORY COMMENTS */
  4    13 
  4    14 
  4    15 /* DESCRIPTION:
  4    16*
  4    17*          The key_count_array holds counts of the number of unique key values
  4    18*     in an index.  These values are used by the search optimization done by
  4    19*     MRDS.  count(0) is the number of keys in the index.  count(N) is the
  4    20*     number of keys in the index which have at least fields 1 through N
  4    21*     having the same value as another key in the index, i.e. count(N)
  4    22*     is the number of partial duplicates with number of partial
  4    23*     duplication fields equal to N.
  4    24*
  4    25**/
  4    26 
  4    27 /* HISTORY:
  4    28*
  4    29*Written by Lindsey Spratt, 11/09/82.
  4    30*Modified:
  4    31*10/27/84 by Lindsey L. Spratt:  Changed the version to char(8) aligned.
  4    32*	  Added a description, fixed the history section.
  4    33**/
  4    34 
  4    35 /* format: style2,ind3 */
  4    36      dcl	   1 key_count_array      aligned based (key_count_array_ptr),
  4    37 	     2 version	      char (8) aligned,
  4    38 	     2 number_of_counts   fixed bin (17) unal,
  4    39 	     2 pad	      bit (18) unal,
  4    40 	     2 count	      (0:kca_number_of_counts refer (key_count_array.number_of_counts)) fixed
  4    41 			      bin (35) aligned;
  4    42 
  4    43      dcl	   KEY_COUNT_ARRAY_VERSION_2
  4    44 			      init ("KeyCnt 2") char (8) aligned internal static options (constant);
  4    45      dcl     KEY_COUNT_OFFSET_IN_CHARACTERS
  4    46 			      init (12) fixed bin internal static options (constant);
  4    47 
  4    48      dcl	   key_count_array_ptr    ptr init (null);
  4    49      dcl	   kca_number_of_counts   fixed bin (17) init (0);
  4    50 
  4    51 
  4    52 /* END INCLUDE FILE - dm_key_count_array.incl.pl1 */
      316 
      317 
  5     1 /* BEGIN INCLUDE FILE - dm_im_header.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*
  5     5*          The index_header structure is stored in the header element of an
  5     6*     index collection and describes basic information about the index.
  5     7**/
  5     8 
  5     9 /* HISTORY:
  5    10*
  5    11*Written by Lindsey Spratt, 04/02/82.
  5    12*Modified:
  5    13*10/28/82 by Lindsey Spratt:  Changed to version 3.  Added the key_count_array.
  5    14*	  count(0) is the number of keys in the index.  count(N) is the
  5    15*	  number of keys in the index which have at least fields 1 through N
  5    16*	  having the same value as another key in the index, i.e. count(N)
  5    17*	  is the number of partial duplicates with number of partial
  5    18*	  duplication fields equal to N.
  5    19*10/24/84 by Lindsey L. Spratt:  Added a description. Converted to version 4.
  5    20*	  Replaced the key_count_array with a key_count_array_element_id.
  5    21*	  Changed the version field to char(8).  Aligned the structure.
  5    22**/
  5    23 
  5    24 /* format: style2,ind3 */
  5    25      dcl	   1 index_header	      aligned based (index_header_ptr),
  5    26 	     2 version	      char (8) aligned,
  5    27 	     2 field_table_element_id
  5    28 			      like element_id,
  5    29 	     2 root_id	      fixed bin (24) unsigned unaligned,
  5    30 	     2 pad1	      bit (12) unaligned,
  5    31 	     2 number_of_duplication_fields
  5    32 			      fixed bin (17) unal,
  5    33 	     2 pad2	      bit (18) unal,
  5    34 	     2 key_count_array_element_id
  5    35 			      like element_id;
  5    36 
  5    37      dcl	   index_header_ptr	      ptr;
  5    38      dcl	   INDEX_HEADER_VERSION_4 init ("IdxHdr 4") char (8) aligned internal static options (constant);
  5    39 
  5    40 /* END INCLUDE FILE - dm_im_header.incl.pl1 */
      318 
      319 
  6     1 /* BEGIN INCLUDE FILE - dm_im_opening_info.incl.pl1 */
  6     2 
  6     3 /* DESRIPTION:
  6     4*
  6     5*          The index_opening_info is per-process information, stored in a
  6     6*     hash_table managed by the opening_manager_, which allows the
  6     7*     index_manager_ to quickly reference certain unchanging pieces of
  6     8*     information rapidly.
  6     9**/
  6    10 
  6    11 /* HISTORY:
  6    12*
  6    13*Written by Lindsey Spratt, 10/28/82.
  6    14*Modified:
  6    15*10/26/84 by Lindsey L. Spratt:  Changed version to char(8).  Added a
  6    16*            description.  Added the current_rollback_count.  Added the
  6    17*	  key_count_array_ptr.
  6    18*03/07/85 by R. Michael Tague:  Added key_count_increments_ptr and 
  6    19*	  key_counts_postcommit_written.  Changed to version 3.
  6    20*03/25/85 by R. Michael Tague:  Added key_count_unprotected_file.  This
  6    21*	  flag is used by im_update_opening_info to help it maintain the
  6    22*	  key count array info.
  6    23**/
  6    24 
  6    25 /* format: style2,ind3 */
  6    26      dcl	   1 index_opening_info   based (index_opening_info_ptr) aligned,
  6    27 	     2 version	      char (8) aligned,
  6    28 	     2 file_opening_id    bit (36) aligned,
  6    29 	     2 collection_id      bit (36) aligned,
  6    30 	     2 index_header_ptr   ptr init (null),
  6    31 	     2 field_table_ptr    ptr init (null),
  6    32 	     2 key_count_array_ptr
  6    33 			      ptr init (null),
  6    34 	     2 key_count_increments_ptr
  6    35 			      ptr init (null),
  6    36 	     2 flags,
  6    37 	       3 key_count_postcommit_written
  6    38 			      bit (1) unal init ("0"b),
  6    39 	       3 key_count_unprotected_file
  6    40 			      bit (1) unal init ("0"b),
  6    41 	       3 pad	      bit (34) unal init (""b),
  6    42 	     2 current_txn_id     fixed bin (35) init (0),
  6    43 	     2 current_rollback_count
  6    44 			      fixed bin (35) init (0);
  6    45 
  6    46      dcl	   index_opening_info_ptr ptr init (null);
  6    47      dcl	   INDEX_OPENING_INFO_VERSION_3
  6    48 			      init ("IdxOpn 3") char (8) aligned internal static options (constant);
  6    49 
  6    50 /* END INCLUDE FILE - dm_im_opening_info.incl.pl1 */
      320 
      321 
  7     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  7     2 /* format: style3 */
  7     3 
  7     4 /* These constants are to be used for the flags argument of sub_err_ */
  7     5 /* They are just "string (condition_info_header.action_flags)" */
  7     6 
  7     7 declare	(
  7     8 	ACTION_CAN_RESTART	init (""b),
  7     9 	ACTION_CANT_RESTART init ("1"b),
  7    10 	ACTION_DEFAULT_RESTART
  7    11 			init ("01"b),
  7    12 	ACTION_QUIET_RESTART
  7    13 			init ("001"b),
  7    14 	ACTION_SUPPORT_SIGNAL
  7    15 			init ("0001"b)
  7    16 	)		bit (36) aligned internal static options (constant);
  7    17 
  7    18 /* End include file */
      322 
      323 
      324    end im_update_opening_info$key_count_array;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/02/87  1304.9  im_update_opening_info.pl1        >spec>install>MR12.1-1020>im_update_opening_info.pl1
310          1    04/05/85  0924.3  dm_cm_increment_info.incl.pl1     >ldd>include>dm_cm_increment_info.incl.pl1
312          2    04/05/85  0924.4  dm_collmgr_entry_dcls.incl.pl1    >ldd>include>dm_collmgr_entry_dcls.incl.pl1
314          3    01/07/85  0858.5  dm_element_id.incl.pl1            >ldd>include>dm_element_id.incl.pl1
316          4    04/02/87  1300.6  dm_key_count_array.incl.pl1       >spec>install>MR12.1-1020>dm_key_count_array.incl.pl1
318          5    01/07/85  0858.9  dm_im_header.incl.pl1             >ldd>include>dm_im_header.incl.pl1
320          6    04/05/85  0924.4  dm_im_opening_info.incl.pl1       >ldd>include>dm_im_opening_info.incl.pl1
322          7    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000036 constant        bit(36)                  initial dcl 7-7 set ref 242*
BITS_PER_WORD                          constant        fixed bin(17,0)          initial dcl 89 ref 302
CM_INCREMENT_INFO_VERSION_1     000006 constant        char(8)                  initial dcl 1-32 ref 300
HEADER_COLLECTION_ID            000041 constant        bit(36)                  initial dcl 90 set ref 280* 306*
INDEX_HEADER_VERSION_4          000002 constant        char(8)                  initial dcl 5-38 set ref 126*
INDEX_OPENING_INFO_VERSION_3    000000 constant        char(8)                  initial dcl 6-47 set ref 123*
KEY_COUNT_ARRAY_VERSION_2       000004 constant        char(8)                  initial dcl 4-43 set ref 131* 133* 188 239*
addr                                                   builtin function         dcl 84 ref 191 302 306 306
bin                                                    builtin function         dcl 84 ref 302 302
cm_increment_info                      based           structure                level 1 dcl 1-26
collection_id             3            based           bit(36)                  level 2 dcl 6-26 set ref 142*
collection_manager_$modify_unprotected
                                000024 constant        entry                    external dcl 2-104 ref 280
collection_manager_$postcommit_increments
                                000026 constant        entry                    external dcl 2-113 ref 306
collection_manager_$put_header  000030 constant        entry                    external dcl 2-121 ref 142
count                     3            based           fixed bin(35,0)          array level 2 dcl 4-36 set ref 189* 206 206 208* 208
                                                                                  208 208 212* 212 279* 279 298* 302 304 304
dm_error_$file_must_be_protected
                                000016 external static fixed bin(35,0)          dcl 101 ref 252
dm_error_$programming_error     000020 external static fixed bin(35,0)          dcl 103 set ref 242*
element_id                             based           structure                level 1 dcl 3-32
er_p_code                              parameter       fixed bin(35,0)          dcl 152 ref 150 153
error_table_$unimplemented_version
                                000022 external static fixed bin(35,0)          dcl 105 set ref 163*
file_opening_id           2            based           bit(36)                  level 2 dcl 6-26 set ref 142* 280* 306*
flags                    14            based           structure                level 2 dcl 6-26
get_dm_free_area_               000012 constant        entry                    external dcl 96 ref 184
ikca_ptr                        000106 automatic       pointer                  dcl 75 set ref 208 208 232* 233 236* 237 239 242 298
                                                                                  301 302 302 304 304
increment_info                  000110 automatic       structure                level 1 dcl 76 set ref 299* 306 306
increments_ptr            2     000110 automatic       pointer                  level 2 dcl 76 set ref 301*
index_header                           based           structure                level 1 dcl 5-25 set ref 142 142
index_header_ptr          4            based           pointer                  initial level 2 in structure "index_opening_info"
                                                                                  dcl 6-26 in procedure
                                                                                  "im_update_opening_info$key_count_array" ref 125
index_header_ptr                000122 automatic       pointer                  dcl 5-37 in procedure
                                                                                  "im_update_opening_info$key_count_array" set ref
                                                                                  125* 126 141 142* 142 142 280 280 306 306
index_opening_info                     based           structure                level 1 dcl 6-26
index_opening_info_ptr          000124 automatic       pointer                  initial dcl 6-46 set ref 122* 123 125 132 135 142
                                                                                  142 6-46* 232 237 248 256 262 280 306
kca_number_of_counts            000120 automatic       fixed bin(17,0)          initial dcl 4-49 set ref 4-49* 186* 187 187
key_count_array                        based           structure                level 1 dcl 4-36 set ref 187 191 280 280
key_count_array_element_id
                          5            based           structure                level 2 dcl 5-25 ref 280 280 306 306
key_count_array_ptr             000116 automatic       pointer                  initial dcl 4-48 in procedure
                                                                                  "im_update_opening_info$key_count_array" set ref
                                                                                  4-48* 187* 188 189 191
key_count_array_ptr      10            based           pointer                  initial level 2 in structure "index_opening_info"
                                                                                  dcl 6-26 in procedure
                                                                                  "im_update_opening_info$key_count_array" ref 132
key_count_increments_ptr
                         12            based           pointer                  initial level 2 dcl 6-26 set ref 232 237*
key_count_postcommit_written
                         14            based           bit(1)                   initial level 3 packed unaligned dcl 6-26 set ref
                                                                                  248 262*
key_count_unprotected_file
                         14(01)        based           bit(1)                   initial level 3 packed unaligned dcl 6-26 set ref
                                                                                  135 256*
length                                                 builtin function         dcl 84 ref 142 142 280 280
myname                          000010 constant        varying char(32)         initial dcl 91 set ref 163* 242*
null                                                   builtin function         dcl 84 ref 4-48 6-46 163 163 184 233 242 242
number_of_counts          2            based           fixed bin(17,0)          level 2 packed unaligned dcl 4-36 set ref 186 187*
                                                                                  189 206 242 242 242 242 279 280 280 298 304
number_of_words           5     000110 automatic       fixed bin(35,0)          level 2 dcl 76 set ref 304*
offset_in_bits            4     000110 automatic       fixed bin(35,0)          level 2 dcl 76 set ref 302*
okca_ptr                        000104 automatic       pointer                  dcl 74 set ref 132* 133 186 206 206 208 212 242 242
                                                                                  279 280* 280 280
p_code                                 parameter       fixed bin(35,0)          dcl 67 set ref 57 117 120* 142* 144 144* 153*
p_expected_version                     parameter       char(8)                  dcl 160 set ref 157 163 163*
p_ikca_ptr                             parameter       pointer                  dcl 182 set ref 180 191*
p_index_opening_info_ptr               parameter       pointer                  dcl 63 ref 57 117 122
p_key_count_array_ptr                  parameter       pointer                  dcl 65 ref 57 114
p_received_version                     parameter       char(8)                  dcl 159 set ref 157 163 163*
p_root_id                              parameter       fixed bin(24,0)          unsigned dcl 66 ref 117 141
p_structure_name                       parameter       char                     unaligned dcl 161 set ref 157 163*
pkca_ptr                        000102 automatic       pointer                  dcl 73 set ref 114* 131 208 212 242 279
rel                                                    builtin function         dcl 84 ref 302 302
root_id                   3            based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 5-25 set ref
                                                                                  141*
sub_err_                        000014 constant        entry                    external dcl 97 ref 163 242
uia_key_count_index             000156 automatic       fixed bin(17,0)          dcl 204 set ref 206* 208 208 208 208 212 212*
unspec                                                 builtin function         dcl 84 set ref 142 142 189* 280 280 280 280 298*
                                                                                  299* 306 306
upc_code                        000176 automatic       fixed bin(35,0)          dcl 277 set ref 280* 283 283*
update_key_counts               000100 automatic       bit(1)                   initial dcl 71 set ref 71* 113* 128
update_root_id                  000101 automatic       bit(1)                   initial dcl 71 set ref 71* 119*
uppc_code                       000166 automatic       fixed bin(35,0)          dcl 230 set ref 251* 252 258 258*
version                                based           char(8)                  level 2 in structure "key_count_array" dcl 4-36
                                                                                  in procedure
                                                                                  "im_update_opening_info$key_count_array" set ref
                                                                                  131* 133* 188* 239*
version                                based           char(8)                  level 2 in structure "index_header" dcl 5-25
                                                                                  in procedure
                                                                                  "im_update_opening_info$key_count_array" set ref
                                                                                  126*
version                         000110 automatic       char(8)                  level 2 in structure "increment_info" dcl 76
                                                                                  in procedure
                                                                                  "im_update_opening_info$key_count_array" set ref
                                                                                  300*
version                                based           char(8)                  level 2 in structure "index_opening_info" dcl 6-26
                                                                                  in procedure
                                                                                  "im_update_opening_info$key_count_array" set ref
                                                                                  123*
wiph_code                              parameter       fixed bin(35,0)          dcl 296 set ref 294 306*
work_area                              based           area(1024)               dcl 80 ref 187
work_area_ptr                   000010 internal static pointer                  initial dcl 92 set ref 184 184* 187

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 7-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 7-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 7-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 7-7
KEY_COUNT_OFFSET_IN_CHARACTERS         internal static fixed bin(17,0)          initial dcl 4-45
cm_increment_info_ptr                  automatic       pointer                  dcl 1-25
collection_manager_$allocate_control_interval
                                000000 constant        entry                    external dcl 2-50
collection_manager_$compact_control_interval
                                000000 constant        entry                    external dcl 2-52
collection_manager_$create_collection
                                000000 constant        entry                    external dcl 2-54
collection_manager_$create_file 000000 constant        entry                    external dcl 2-56
collection_manager_$delete      000000 constant        entry                    external dcl 2-64
collection_manager_$delete_from_ci_buffer
                                000000 constant        entry                    external dcl 2-67
collection_manager_$destroy_collection
                                000000 constant        entry                    external dcl 2-58
collection_manager_$free_control_interval
                                000000 constant        entry                    external dcl 2-60
collection_manager_$get         000000 constant        entry                    external dcl 2-71
collection_manager_$get_by_ci_ptr
                                000000 constant        entry                    external dcl 2-80
collection_manager_$get_control_interval_ptr
                                000000 constant        entry                    external dcl 2-74
collection_manager_$get_from_ci_buffer
                                000000 constant        entry                    external dcl 2-77
collection_manager_$get_header  000000 constant        entry                    external dcl 2-83
collection_manager_$get_id      000000 constant        entry                    external dcl 2-86
collection_manager_$get_portion 000000 constant        entry                    external dcl 2-89
collection_manager_$get_portion_by_ci_ptr
                                000000 constant        entry                    external dcl 2-97
collection_manager_$get_portion_from_ci_buffer
                                000000 constant        entry                    external dcl 2-93
collection_manager_$modify      000000 constant        entry                    external dcl 2-101
collection_manager_$modify_in_ci_buffer
                                000000 constant        entry                    external dcl 2-107
collection_manager_$modify_portion
                                000000 constant        entry                    external dcl 2-110
collection_manager_$put         000000 constant        entry                    external dcl 2-115
collection_manager_$put_in_ci_buffer
                                000000 constant        entry                    external dcl 2-118
collection_manager_$put_unprotected_header
                                000000 constant        entry                    external dcl 2-123
collection_manager_$replace_ci_buffer
                                000000 constant        entry                    external dcl 2-126
collection_manager_$setup_ci_buffer
                                000000 constant        entry                    external dcl 2-129
collection_manager_$simple_get_by_ci_ptr
                                000000 constant        entry                    external dcl 2-132
collection_manager_$simple_get_from_ci_buffer
                                000000 constant        entry                    external dcl 2-135
element_id_string                      automatic       bit(36)                  dcl 3-30

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_VERSION                   000443 constant        entry                    internal dcl 157 ref 123 126 131 133 239
ERROR_RETURN                    000435 constant        entry                    internal dcl 150 ref 144 258 283
JOIN                            000233 constant        label                    dcl 120 ref 115
MAIN_RETURN                     000434 constant        label                    dcl 147 ref 154
SET_UP_KEY_INCREMENTS_ARRAY     000547 constant        entry                    internal dcl 180 ref 236
UPDATE_INCREMENTS_ARRAY         000622 constant        entry                    internal dcl 201 ref 263 266
UPDATE_PROBABLY_PROTECTED_COUNTS
                                000653 constant        entry                    internal dcl 227 ref 137
UPDATE_UNPROTECTED_COUNTS       001027 constant        entry                    internal dcl 274 ref 135 255
WRITE_INCREMENTS_POSTCOMMIT_HANDLER
                                001103 constant        entry                    internal dcl 294 ref 251
im_update_opening_info$key_count_array
                                000202 constant        entry                    external dcl 57
root_id                         000223 constant        entry                    external dcl 117

NAMES DECLARED BY CONTEXT OR IMPLICATION.
hbound                                                 builtin function         ref 206 304
lbound                                                 builtin function         ref 206 304

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1404        1436    1214        1414
Length      1774    1214        32         322     170           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
im_update_opening_info$key_count_array
                                    364 external procedure  is an external procedure.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure im_update_opening_info$key_co           
CHECK_VERSION                           internal procedure  shares stack frame of external procedure im_update_opening_info$key_co           
SET_UP_KEY_INCREMENTS_ARRAY             internal procedure  shares stack frame of external procedure im_update_opening_info$key_co           
UPDATE_INCREMENTS_ARRAY                 internal procedure  shares stack frame of external procedure im_update_opening_info$key_co           
UPDATE_PROBABLY_PROTECTED_COUNTS
                                        internal procedure  shares stack frame of external procedure im_update_opening_info$key_co           
UPDATE_UNPROTECTED_COUNTS               internal procedure  shares stack frame of external procedure im_update_opening_info$key_co           
WRITE_INCREMENTS_POSTCOMMIT_HANDLER
                                        internal procedure  shares stack frame of external procedure im_update_opening_info$key_co           

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 work_area_ptr               im_update_opening_info$key_count_array

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
im_update_opening_info$key_count_array
                         000100 update_key_counts           im_update_opening_info$key_count_array
                         000101 update_root_id              im_update_opening_info$key_count_array
                         000102 pkca_ptr                    im_update_opening_info$key_count_array
                         000104 okca_ptr                    im_update_opening_info$key_count_array
                         000106 ikca_ptr                    im_update_opening_info$key_count_array
                         000110 increment_info              im_update_opening_info$key_count_array
                         000116 key_count_array_ptr         im_update_opening_info$key_count_array
                         000120 kca_number_of_counts        im_update_opening_info$key_count_array
                         000122 index_header_ptr            im_update_opening_info$key_count_array
                         000124 index_opening_info_ptr      im_update_opening_info$key_count_array
                         000156 uia_key_count_index         UPDATE_INCREMENTS_ARRAY
                         000166 uppc_code                   UPDATE_PROBABLY_PROTECTED_COUNTS
                         000176 upc_code                    UPDATE_UNPROTECTED_COUNTS

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          mpfx2               ext_entry           op_alloc_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
collection_manager_$modify_unprotected                      collection_manager_$postcommit_increments
collection_manager_$put_header                              get_dm_free_area_             sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$file_must_be_protected                            dm_error_$programming_error
error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     71 000166    4   48 000170    4   49 000172    6   46 000173        57 000176       113 000210       114 000212
    115 000216       117 000217       119 000231       120 000233       122 000235       123 000240       125 000262
    126 000265       128 000310       131 000312       132 000337       133 000342       135 000364       137 000372
    138 000373       141 000374       142 000401       144 000423       147 000434       150 000435       153 000437
    154 000442       157 000443       163 000454       168 000546       180 000547       184 000551       186 000564
    187 000570       188 000602       189 000605       191 000616       192 000621       201 000622       206 000623
    208 000633       212 000646       214 000650       215 000652       227 000653       232 000654       233 000657
    236 000663       237 000665       238 000670       239 000671       242 000713       248 000774       251 001000
    252 001002       255 001006       256 001007       257 001012       258 001013       262 001020       263 001023
    265 001024       266 001025       267 001026       274 001027       279 001030       280 001041       283 001076
    285 001102       294 001103       298 001105       299 001117       300 001122       301 001124       302 001126
    304 001143       306 001150       308 001177


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
