	COMPILATION LISTING OF SEGMENT mrds_dsl_parser
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/01/88  1335.9 mst Mon
	    Options: optimize map

        1 /****^  ********************************************
        2*        *                                          *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988 *
        4*        *                                          *
        5*        ******************************************** */
        6 
        7 mrds_dsl_parser:
        8     proc (dbcb_ptr, area_ptr, caller, option_list_ptr, se_ptr, se_len, arg_ptr,
        9          desc_ptr,
       10          num_args, current_flag, code);
       11 
       12 /****^  HISTORY COMMENTS:
       13*  1) change(87-01-22,Hergert), approve(88-07-11,MCR7903),
       14*     audit(88-07-07,Dupuis), install(88-08-01,MR12.2-1073):
       15*     Written.
       16*  2) change(88-05-06,Hergert), approve(88-07-11,MCR7903),
       17*     audit(88-07-07,Dupuis), install(88-08-01,MR12.2-1073):
       18*     Fixed bugs and inadequacies from original design required to pass
       19*     audit and regression tests.
       20*                                                   END HISTORY COMMENTS */
       21 
       22 /* This module scans and  parses the MRDS selection expression language.
       23*   The language and the skeleton of this code was designed using LALR.
       24*   It was then customized to work with the rest of MRDS. 
       25*   That is why parts of this code may seem mechanical and confusing.
       26*   I did not spend much time to try and optimize it for either performance
       27*   or readability.
       28*
       29*   Caveats and disclaimers aside, this code scans and reads the input
       30*   selection expression. It parses it by walking through the parser tables
       31*   that were generated by LALR a token at a time and selectivly calling
       32*   mrds_dsl_semantics to actually do any work that may be required.
       33*   When this module returns to mrds_dsl_translate, the selection
       34*   expression will have been translated into tabular form and optimized,
       35*   or an error will have been detected and reported.
       36**/
       37 
       38         dbi_pic = dbcb.dbi;
       39         call mu_define_area$define_temp_dir_area (
       40 	   dbcb.parser_work_area_ptr, dbcb.dbi, (sys_info$max_seg_size),
       41 	   "MRDS" || dbi_pic, "0"b, "1"b, "0"b, "0"b, code);
       42         if code ^= 0 then call error (code);
       43 
       44         allocate parser_static_info
       45 	   in (dbcb.parser_work_area_ptr -> parser_work_area);
       46         parser_static_info.pwa_ptr = dbcb.parser_work_area_ptr;
       47         parser_static_info.ns_ptr = null;
       48 
       49         current_state = 1;
       50         lookahead_put, lookahead_get = -1;
       51         parse_stack_top = 0;
       52         lookahead_count = 0;
       53         code = 0;
       54 
       55         unspec (parser_se_info) = "0"b;
       56 
       57         parser_se_info.se_ptr = se_ptr;
       58         parser_se_info.se_length = se_len;
       59         parser_se_info.se_cursor = 1;
       60 
       61         call mrds_dsl_semantics$init (addr (parser_lex_stack),
       62 	   addr (parser_se_info),
       63 	   dbcb_ptr, psi_ptr, area_ptr, caller, option_list_ptr,
       64 	   arg_ptr, desc_ptr, num_args, current_flag);
       65 
       66 /* The parsing loop. */
       67 NEXT:
       68         if current_state = 0 then goto parse_done;
       69 
       70         current_table = current_state;
       71         if debug then do;
       72 	  db_item = "";
       73 	  db_data.state = current_state;
       74 	  db_data.top = parse_stack_top;
       75         end;
       76 
       77         goto CASE (dpda.v1 (current_table));
       78 
       79 
       80 CASE (3):						/* Multiple lookahead (k > 1) with shared look table. */
       81         current_table = dpda.v2 (current_table);
       82 
       83 
       84 CASE (1):						/* Multiple lookahead (k > 1) without default transition. */
       85         lookahead_use = lookahead_get - lookahead_need;
       86 
       87         if lookahead_use < lbound (lookahead, 1)
       88         then lookahead_use = lookahead_use - lbound (lookahead, 1);
       89 
       90         lookahead_need = lookahead_need + 1;
       91 
       92         goto read_look;
       93 
       94 
       95 CASE (10):					/* Obsolete -- Lookahead 1 (sometimes called read without
       96*						   stacking) with shared transition table. */
       97 
       98 CASE (2):						/* Read and stack and/or lookahead 1 (sometimes called
       99*						   read without stacking) with shared transition table.
      100*						   (Read transitions to state S are coded as +S while
      101*						   lookahead transitions to state S are coded -S.) */
      102         current_table = dpda.v2 (current_table);
      103 
      104 CASE (0):						/* Read and stack and/or lookahead 1 with neither a
      105*						   default transition nor a marked symbol transition. */
      106 CASE (9):						/* Obsolete -- Lookahead 1 (sometimes called
      107*						   read without stacking). */
      108         lookahead_need = 1;
      109         lookahead_use = lookahead_get;
      110 
      111 
      112 read_look:
      113         do while (lookahead_count < lookahead_need);	/* Make sure enough symbols are available. */
      114 
      115 	  call scanner (lookahead_put);
      116 
      117 	  if lookahead_put = lbound (lookahead, 1) then lookahead_put = 0;
      118 
      119 	  lookahead_put = lookahead_put - 1;
      120 	  lookahead_count = lookahead_count + 1;
      121         end;
      122 
      123         test_token = lookahead.token_id (lookahead_use);
      124 
      125 /* Look current token_id up in the read list. */
      126         m = 0;
      127         do i = current_table + 1 to current_table + dpda.v2 (current_table);
      128 	  n = dpda.v1 (i);
      129 
      130 	  if n < 0 then do;
      131 	      n = -n;
      132 	      m = i;				/* Record a marked symbol transition. */
      133 	  end;
      134 
      135 	  if n = test_token then do;
      136 	      next_state = dpda.v2 (i);
      137 	      goto got_token;
      138 	  end;
      139 
      140 	  if n > test_token then goto not_found;
      141 
      142         end;
      143 
      144 
      145 not_found:
      146         if m > 0 then do;				/* If marked symbol was in table, use it. */
      147 	  next_state = dpda.v2 (m);
      148 	  goto got_token;
      149         end;
      150 
      151         if debug then call ioa_$nnl (" ^4i^/", current_state);
      152 
      153         parser_se_info.loud = "1"b;
      154         parser_se_info.error_type = SE_TYPE;
      155         parser_se_info.error_msg =
      156 	   "The unexpected " || get_terminal (lookahead_use)
      157 	   || " was encountered.";
      158         call error (mrds_error_$sell_syntax);
      159         goto parse_done;
      160 
      161 
      162 got_token:
      163         if debug then db_data.data = get_terminal (lookahead_use);
      164 
      165         if next_state < 0 then do;			/* This is a lookahead transition. */
      166 	  if debug then do;
      167 	      db_data.type = "LK01";
      168 	      db_look = lookahead_need;
      169 	  end;
      170 	  current_state = -next_state;
      171         end;
      172         else do;					/* This is a read transition. */
      173 	  if debug then do;
      174 	      db_data.type = "READ";
      175 	      db_data.flag = "*";
      176 	  end;
      177 
      178 	  if parse_stack_top >= hbound (parse_stack, 1)
      179 	  then do;
      180 	      parser_se_info.loud = "1"b;
      181 	      parser_se_info.error_type = IL_TYPE;
      182 	      parser_se_info.error_msg =
      183 		 "The current stack top of "
      184 		 || ltrim (char (parse_stack_top))
      185 		 || ", exceeded the limit of "
      186 		 || ltrim (char (hbound (parse_stack, 1)))
      187 		 || ". Contact systems programming staff.";
      188 	      call error (mrds_error_$parser_stack_overflow);
      189 	  end;
      190 
      191 	  parse_stack_top = parse_stack_top + 1;
      192 	  parse_stack (parse_stack_top) = current_state;	/* Stack the current state. */
      193 	  unspec (parser_lex_stack (parse_stack_top)) =
      194 	       unspec (lookahead (lookahead_get));
      195 
      196 	  if lookahead_get = lbound (lookahead, 1) then lookahead_get = 0;
      197 
      198 	  lookahead_get = lookahead_get - 1;
      199 	  lookahead_count = lookahead_count - 1;
      200 	  current_state = next_state;
      201         end;
      202 
      203         if debug then call ioa_$nnl ("^a^/", db_item);
      204 
      205         goto NEXT;
      206 
      207 
      208 CASE (14):					/* Multiple lookahead (k > 1) with either (but not both)
      209*						   a default transition or a marked symbol transition. */
      210 CASE (16):					/* Multiple lookahead (k > 1) with the table
      211*						   continued at another state. */
      212 CASE (15):					/* Read and stack and/or lookahead 1 with either (but not both)
      213*						   a default transition or a marked symbol transition. */
      214 CASE (17):					/* Read and stack and/or lookahead 1
      215*						   continued at another state. */
      216 CASE (7):						/* Null state -- presence indicates LALR failure. */
      217 CASE (8):						/* Final state -- should only appear as state zero. */
      218 
      219 CASE (4):						/* Apply by rule and alternative with lookback table. */
      220 CASE (5):						/* Apply by rule and alternative without lookback. */
      221 CASE (6):						/* Apply by rule and alternative with shared lookback table. */
      222 
      223 CASE (18):					/* Apply by rule with lookback table. */
      224 CASE (19):					/* Apply by rule without lookback. */
      225 CASE (20):					/* Apply by rule with shared lookback table. */
      226 
      227         parser_se_info.loud = "0"b;
      228         call error (mrds_error_$parser_unrecognized_state);
      229 
      230 CASE (13):					/* Apply by production with shared lookback table. */
      231         current_table = dpda.v2 (current_state + 2);
      232 CASE (11):					/* Apply by production with lookback table. */
      233 CASE (12):					/* Apply by production without lookback. */
      234         production_number = dpda.v1 (current_state + 2);
      235 
      236         if debug then do;
      237 	  db_data.type = "APLY";
      238 	  if dpda.v1 (current_state + 1) < 0 then db_data.flag = "*";
      239 	  call ioa_$nnl ("^a  (^i", db_item, production_number);
      240 	  call print_production_name (production_number);
      241 	  call ioa_$nnl (")^-sd = ^i ", dpda.v1 (current_state + 1));
      242 	  if dpda.v1 (current_state + 1) > 0 then do;
      243 	      db_separator = "(";
      244 	      do t = parse_stack_top
      245 		 to parse_stack_top - dpda.v1 (current_state + 1) + 1
      246 		 by -1;
      247 		call ioa_$nnl ("^1a^d", db_separator, parse_stack (t));
      248 		db_separator = "";
      249 	      end;
      250 	      call ioa_$nnl (")");
      251 	  end;
      252 	  call ioa_$nnl ("^/");
      253         end;
      254 
      255         if dpda.v1 (current_state + 2) > 0 then do;
      256 	  call mrds_dsl_semantics (psi_ptr, lex_stack_top, production_number,
      257 	       code);
      258 	  if code ^= 0
      259 	  then if code = mrds_error_$bad_attr |
      260 		  code = mrds_error_$bad_var then do;
      261 
      262 /* At this point the semantics routine has rejected the token on the top 
      263*   of the stack (which is an identifier) as "not_found". It is possible
      264*   that there is a hyphen buried in it that is suipposed to be a minus
      265*   sign or the beginning of a keyword. If the hyphen exists in the token
      266*   we will truncate the token just before the hyphen and try again. */
      267 
      268 		 i = index (lex_token, "-") - 1;
      269 
      270 		 if i > 0 then do;
      271 		     parser_se_info.token_length,
      272 			parser_lex_stack.token_length (lex_stack_top) =
      273 			i;
      274 		     parser_se_info.se_cursor =
      275 			parser_lex_stack.token_start_pos (lex_stack_top)
      276 			+ i;
      277 		     lookahead_count = 0;		/* this should empty lookahead stack */
      278 		     lookahead_get, lookahead_put = -1;
      279 
      280 		     call mrds_dsl_semantics (psi_ptr, lex_stack_top,
      281 			production_number, code);
      282 		     if code ^= 0 then call error (code);
      283 		 end;
      284 		 else call error (code);
      285 	       end;
      286 	       else call error (code);
      287         end;
      288 
      289 /* Check for an apply of an empty production.
      290*   In this case the apply state number must be
      291*   pushed onto the parse stack.  (Reference
      292*   LaLonde, W. R.:  An efficient LALR Parser Generator.
      293*   Tech. Report CSRG-2, 1971, pp. 34-35.) */
      294 
      295         if dpda.v1 (current_state + 1) < 0 then do;
      296 	  if parse_stack_top >= hbound (parse_stack, 1) then do;
      297 	      parser_se_info.loud = "1"b;
      298 	      parser_se_info.error_type = IL_TYPE;
      299 	      parser_se_info.error_msg =
      300 		 "The current stack top of "
      301 		 || ltrim (char (parse_stack_top))
      302 		 || ", exceeded the limit of "
      303 		 || ltrim (char (hbound (parse_stack, 1)))
      304 		 || ". Contact systems programming staff.";
      305 	      call error (mrds_error_$parser_stack_overflow);
      306 	  end;
      307 	  parse_stack (parse_stack_top + 1) = current_state;
      308         end;
      309 
      310 /* Delete lexical & parse stack entries. */
      311         parse_stack_top = parse_stack_top - dpda.v1 (current_state + 1);
      312         if parse_stack_top <= 0
      313         then do;
      314 	  parser_se_info.loud = "0"b;
      315 	  call error (mrds_error_$parser_logic_error);
      316         end;
      317 
      318         test_state = parse_stack (parse_stack_top);
      319         lb = current_table + 3;
      320         ub = current_table + dpda.v2 (current_table);
      321 
      322         do while (lb <= ub);
      323 
      324 	  i = divide (ub + lb, 2, 17, 0);
      325 
      326 	  if dpda.v1 (i) = test_state then do;
      327 	      current_state = dpda.v2 (i);
      328 	      goto NEXT;
      329 	  end;
      330 	  else if dpda.v1 (i) < test_state
      331 	       then lb = i + 1;
      332 	       else ub = i - 1;
      333         end;
      334 
      335         current_state = dpda.v2 (current_table + 2);
      336         goto NEXT;
      337 
      338 parse_done:
      339 
      340         return;
      341 
      342 get_terminal:
      343     proc (lex_stack_index) returns (char (100) varying);
      344 
      345 dcl     lex_stack_index	 fixed bin parameter;
      346 dcl     temp		 char (100) varying;
      347 dcl     (length, min, substr)
      348 			 builtin;
      349 
      350         if parser_lex_stack.token_id (lex_stack_index) = 0
      351         then return ("end of the selection expression");
      352         else
      353 	  begin;
      354 
      355 
      356 
      357 dcl     token		 char (
      358 			 min (50,
      359 			 parser_lex_stack.token_length (lex_stack_index))
      360 			 )
      361 			 based (parser_lex_stack
      362 			 .token_ptr (lex_stack_index));
      363 
      364 dcl     terminal		 char (terminals_list
      365 			 .
      366 			 length (parser_lex_stack
      367 			 .token_id (lex_stack_index)))
      368 			 defined (terminal_characters)
      369 			 position (terminals_list
      370 			 .
      371 			 position (parser_lex_stack
      372 			 .token_id (lex_stack_index)))
      373 			 ;
      374 
      375 	      if length (terminal) > 2 & substr (terminal, 1, 1) = "<"
      376 		 & substr (terminal, length (terminal), 1) = ">" then do;
      377 
      378 		temp = substr (terminal, 2, length (terminal) - 2);
      379 
      380 		if length (token) > 0
      381 		then
      382 		     temp = temp || " '" || token || "'";
      383 
      384 	      end;
      385 	      else if (substr (terminal, 1, 1)) = "-" & length (terminal) > 1
      386 		 then do;
      387 		     temp = "keyword '";
      388 
      389 		     if length (token) > 0
      390 		     then temp = temp || token;
      391 		     else temp = temp || terminal;
      392 
      393 		     temp = temp || "'";
      394 		 end;
      395 		 else temp = "operator '" || terminal || "'";
      396 
      397 	      return (temp);
      398 	  end;
      399     end get_terminal;
      400 
      401 print_production_name:
      402     proc (production_name_index);
      403 dcl     production_name_index	 fixed bin parameter;
      404 dcl     variables_list_index	 fixed bin;
      405 
      406         if hbound (production_names, 1) > 0 then do;
      407 	  variables_list_index =
      408 	       -production_names (abs (production_name_index));
      409 
      410 	  begin;
      411 
      412 dcl     production_name	 char (variables_list
      413 			 .length (variables_list_index))
      414 			 defined (variable_characters)
      415 			 position (variables_list
      416 			 .position (variables_list_index));
      417 
      418 	      call ioa_$nnl (" ^a", production_name);
      419 	  end;
      420         end;
      421         return;
      422     end print_production_name;
      423 
      424 dbn:
      425     entry ();
      426         debug = "1"b;
      427         return;
      428 dbf:
      429     entry ();
      430         debug = "0"b;
      431         return;
      432 
      433 dbsn:
      434     entry ();
      435         scanner_debug = "1"b;
      436         return;
      437 dbsf:
      438     entry ();
      439         scanner_debug = "0"b;
      440         return;
      441 
      442 error:
      443     proc (cd);
      444 dcl     cd		 fixed bin (35);
      445 
      446         code, parser_se_info.error_code = cd;
      447         if parser_se_info.loud & option_list.error
      448         then call mu_print_error (addr (parser_se_info));
      449 
      450         goto parse_done;
      451 
      452     end;
      453 
      454 scanner:
      455     proc (stack_index);
      456 
      457 /*
      458*   DESCRIPTION
      459*
      460*   The purpose of this procedure is to return the next token in the
      461*   selection expression to the parser. This is done via alook up table
      462*   to conclude from the first character, what class of token we have.
      463*   After  a token type has been determined, we parse that token and then
      464*   look up its encoding in the keyword table then load the stacks.
      465*
      466*   INPUT CONDITIONS:
      467*
      468*   stack_index points to place in the lex stack where the info found
      469*   is to be placed.
      470*
      471*   OUTPUT DEFINITIONS:
      472*
      473*   Blatant syntax errors like strings with no end quote and numbers that
      474*   dont make sense (like 2.3e) are handled here. Other errors are left for
      475*   the parser to find and report.
      476*
      477*   se_cursor always points to the end of the token found plus 1
      478*
      479**/
      480 
      481         if scanner_debug then call ioa_$nnl ("Scanner: token key = ");
      482 
      483 start:
      484 
      485         parser_se_info.token_start = parser_se_info.se_cursor;
      486 
      487         if parser_se_info.se_cursor > parser_se_info.se_length then do;
      488 						/* check for EOI */
      489 	  token_end = parser_se_info.se_cursor;
      490 	  token_string = "eoi";
      491 	  call load_stack;
      492 	  goto finish;
      493         end;
      494 
      495         type = /* check first char to get an idea of type of token */
      496 	   token_type_list (
      497 	   char_class_list (rank (se_array (parser_se_info.se_cursor))));
      498 
      499         if scanner_debug then call ioa_$nnl (" ^d", type);
      500 
      501         goto token_type (type);
      502 
      503 /* number */
      504 token_type (1):
      505 
      506 
      507         state = 1;
      508 number_entry:
      509 
      510 
      511         do while ((state > 0)
      512 	   & (parser_se_info.se_length > parser_se_info.se_cursor));
      513 	  parser_se_info.se_cursor = parser_se_info.se_cursor + 1;
      514 						/* get the next char */
      515 	  class =
      516 	       char_class_list (rank (se_array (parser_se_info.se_cursor)));
      517 	  if class > 6 then class = 6;		/* maximum state allowed */
      518 	  state = num_state_table (state, class);
      519         end;
      520 
      521         if state > 0
      522         then token_end = parser_se_info.se_length;	/* last token was a number */
      523         else if state = -3
      524 	   then token_end = parser_se_info.se_cursor;
      525 	   else token_end = parser_se_info.se_cursor - 1;
      526 
      527         token_string = "<integer>";
      528 
      529 /* now check to see if we have a bit string */
      530 
      531         if state < 0 then do; /* this is cheaper than checking se length */
      532 	   if se_array (token_end+1) = B /* found a bit string */
      533 	   then do;
      534 	       if token_end+1 = parser_se_info.se_length
      535 						/* end of string reached */
      536 	       then token_end = token_end+1;
      537 	       else if search ("1234",
      538 		       se_array (token_end + 2)) = 0
      539 		  then token_end = token_end+1;
      540 		  else token_end = token_end+2;	/* take base also */
      541 
      542 	       token_string = "<bit_string>";
      543 	   end;
      544         end;
      545 
      546         call load_stack;
      547 
      548         goto finish;
      549 
      550 /* decimal --> alone or a number or .v. */
      551 token_type (2):
      552 
      553 
      554         if parser_se_info.se_length = parser_se_info.se_cursor
      555         then token_end = parser_se_info.se_cursor;
      556         else do;
      557 	  i = verify (se_array (parser_se_info.se_cursor + 1), DIGITS);
      558 						/* see if its a number or just a period */
      559 
      560 	  if i ^= 0 then do;			/* period or arg substitution */
      561 
      562 	      i = verify (se_array (parser_se_info.se_cursor + 1), "VvXx");
      563 						/* Check for .v. or .x. */
      564 
      565 	      if i ^= 0
      566 	      then token_end = parser_se_info.se_cursor;
      567 	      else if se_array (parser_se_info.se_cursor + 2) = "."
      568 		 then token_end = parser_se_info.se_cursor + 2;
      569 						/* found arg substitution */
      570 		 else token_end = parser_se_info.se_cursor;
      571 						/* just a period */
      572 	  end;
      573 	  else do;				/* found a number, go process it */
      574 	      state = 2;
      575 	      goto number_entry;
      576 	  end;
      577         end;
      578 
      579         token_string = "";
      580         call load_stack;
      581 
      582         goto finish;
      583 
      584 /* +- --> addop or keyword */
      585 token_type (3):
      586 
      587 
      588         if parser_se_info.se_length = parser_se_info.se_cursor
      589         then i = 1;
      590         else i = verify (substr (se_string, parser_se_info.se_cursor + 1),
      591 	        ALPHA_NUM);
      592 
      593         if i = 1
      594         then do;					/* just a - or + */
      595 	  token_end = parser_se_info.se_cursor;
      596 	  token_string = "";
      597 	  call load_stack;
      598         end;
      599         else do;					/* check for keyword */
      600 
      601 	  if i = 0 then do;				/* EOI encountered */
      602 	      if (parser_se_info.se_length - parser_se_info.se_cursor)
      603 		 > mrds_data_$max_id_len
      604 	      then call scanner_error (mrds_error_$long_ident,
      605 		      substr (se_string, parser_se_info.se_cursor));
      606 
      607 	      token = substr (se_string, parser_se_info.se_cursor);
      608 						/* take whole thing */
      609 	      i = parser_se_info.se_length - parser_se_info.se_cursor + 1;
      610 	  end;
      611 
      612 	  else if i - 1 > mrds_data_$max_id_len		/* check token length */
      613 	       then call scanner_error (mrds_error_$long_ident,
      614 		       substr (se_string, parser_se_info.se_cursor, i));
      615 
      616 	       else token = substr (se_string, parser_se_info.se_cursor, i);
      617 
      618 	  call lookup_token (token, id);		/* see if token is a keyword */
      619 
      620 	  if id = 0 then do;			/* just a - or a + */
      621 	      token = substr (se_string, parser_se_info.se_cursor, 1);
      622 	      call lookup_token (token, id);
      623 	      if id = 0
      624 	      then call scanner_error (mrds_error_$inv_token, token);
      625 	      token_end = parser_se_info.se_cursor;
      626 	  end;
      627 	  else /* token is a keyword */
      628 	       token_end = parser_se_info.se_cursor + i - 1;
      629 
      630 
      631 	  parser_lex_stack.token_ptr (stack_index) = /* pointer to token */
      632 	       addr (se_array (parser_se_info.token_start));
      633 
      634 	  parser_se_info.token_length,		/* length of token */
      635 	       parser_lex_stack.token_length (stack_index) =
      636 	       token_end - parser_se_info.token_start + 1;
      637 
      638 	  parser_lex_stack.token_id (stack_index) = id;
      639 	  parser_lex_stack.token_start_pos (stack_index) =
      640 	       parser_se_info.token_start;
      641 
      642 	  parser_se_info.se_cursor = token_end + 1;
      643 
      644 	  if token = "-no_ot" | token = "-no_optimize" then do;
      645 	      parser_se_info.no_ot_seen = "1"b;
      646 	      goto start;				/* get another token */
      647 	  end;
      648 	  else if token = "-pso" | token = "-print_search_order" then do;
      649 		 parser_se_info.pso_seen = "1"b;
      650 		 goto start;			/* get another token */
      651 	       end;
      652 
      653         end;
      654 
      655         goto finish;
      656 
      657 /*  symbol */
      658 token_type (4):
      659 
      660 
      661         i = verify (substr (se_string, parser_se_info.se_cursor),
      662 						/* find end */
      663 	   ALPHA_NUM || "-")
      664 	   - 1;
      665 
      666         if i = -1					/* EOI encountered, take whole thing */
      667         then if (parser_se_info.se_length - parser_se_info.se_cursor + 1)
      668 	        > mrds_data_$max_id_len
      669 	        /* check length */
      670 	   then do;
      671 	       i = index (substr (se_string, parser_se_info.se_cursor), "-");
      672 	       if i = 0
      673 	       then call scanner_error (mrds_error_$long_ident,
      674 		       substr (se_string, parser_se_info.se_cursor));
      675 	       else token_end = parser_se_info.se_cursor + i - 2;
      676 	   end;
      677 	   else token_end = parser_se_info.se_length;
      678 
      679         else if i > mrds_data_$max_id_len /* No EOI */
      680 	   then do;
      681 	       i = index (substr (se_string, parser_se_info.se_cursor, i),
      682 		  "-");
      683 	       if i = 0
      684 	       then call scanner_error (mrds_error_$long_ident,
      685 		       substr (se_string, parser_se_info.se_cursor));
      686 	       else token_end = parser_se_info.se_cursor + i - 2;
      687 	   end;
      688 	   else token_end = parser_se_info.se_cursor + i - 1;
      689 
      690         token_string = "<symbol>";
      691         call load_stack;
      692 
      693         goto finish;
      694 
      695 /* ^ ^= ^< ^> ^=< ^>< ... --> notop or relop */
      696 token_type (5):
      697 
      698 
      699         if parser_se_info.se_cursor = parser_se_info.se_length
      700         then token_end = parser_se_info.se_cursor;	/* EOI: take the "^" */
      701 
      702         else do;
      703 	  i = verify (substr (se_string, parser_se_info.se_cursor + 1, 2),
      704 	       "=><");
      705 
      706 	  if i = 0
      707 	  then token_end = parser_se_info.se_cursor + 2;	/* found three char relop */
      708 	  else token_end = parser_se_info.se_cursor + i - 1;
      709 						/* found one or two char relop */
      710         end;
      711         token_string = "";
      712         call load_stack;
      713 
      714         goto finish;
      715 
      716 /* = =< => --> relop */
      717 token_type (6):
      718 
      719 
      720         if parser_se_info.se_cursor = parser_se_info.se_length
      721         then token_end = parser_se_info.se_cursor;	/* EOI: take the "=" */
      722 
      723         else do;
      724 	  i = search (se_array (parser_se_info.se_cursor + 1), "><");
      725 	  token_end = parser_se_info.se_cursor + i;
      726         end;
      727 
      728         token_string = "";
      729         call load_stack;
      730 
      731 
      732         goto finish;
      733 
      734 /* < <= <> --> relop */
      735 token_type (7):
      736 
      737 
      738         if parser_se_info.se_cursor = parser_se_info.se_length
      739         then token_end = parser_se_info.se_cursor;	/* EOI: take the "<" */
      740 
      741         else do;
      742 	  i = search (se_array (parser_se_info.se_cursor + 1), "=>");
      743 	  token_end = parser_se_info.se_cursor + i;
      744         end;
      745 
      746         token_string = "";
      747         call load_stack;
      748 
      749 
      750         goto finish;
      751 
      752 /* > >= >< --> relop */
      753 token_type (8):
      754 
      755 
      756         if parser_se_info.se_cursor = parser_se_info.se_length
      757         then token_end = parser_se_info.se_cursor;	/* EOI: take the ">" */
      758         else do;
      759 	  i = search (se_array (parser_se_info.se_cursor + 1), "=<");
      760 	  token_end = parser_se_info.se_cursor + i;
      761         end;
      762 
      763         token_string = "";
      764         call load_stack;
      765 
      766 
      767         goto finish;
      768 
      769 /* | --> or or concat */
      770 token_type (9):
      771 
      772 
      773         if parser_se_info.se_cursor >= parser_se_info.se_length
      774         then token_end = parser_se_info.se_cursor;	/* EOI; just take | */
      775         else do;
      776 	  if se_array (parser_se_info.se_cursor + 1) = "|"
      777 	  then token_end = parser_se_info.se_cursor + 1;
      778 	  else token_end = parser_se_info.se_cursor;
      779         end;
      780 
      781         token_string = "";
      782         call load_stack;
      783 
      784         goto finish;
      785 
      786 /* CR NL SP FF VT --> whitespace */
      787 token_type (10):
      788 
      789 
      790         if parser_se_info.se_length = parser_se_info.se_cursor
      791         then i = 0;
      792         else i = verify (substr (se_string, parser_se_info.se_cursor + 1),
      793 	        WHITE_SPACE);
      794 						/* find end of white space */
      795 
      796         if i = 0
      797         then /* EOI encountered */
      798 	   parser_se_info.se_cursor = parser_se_info.se_length + 1;
      799 						/* flag for EOI trap at beginning */
      800         else parser_se_info.se_cursor = parser_se_info.se_cursor + i;
      801 						/* get rid of white space, try again */
      802 
      803         goto start;
      804 
      805 /* " --> string or bit string */
      806 token_type (11):
      807 
      808         if parser_se_info.se_length = parser_se_info.se_cursor
      809         then call scanner_error (mrds_error_$inv_string,
      810 	        substr (se_string, parser_se_info.token_start));
      811 
      812         done = "0"b;
      813         do while (^done);				/* find all double quotes */
      814 	  i = index (substr (se_string, parser_se_info.se_cursor + 1), QUOTE)
      815 	       ;
      816 	  if i = 0				/* no end quote */
      817 	  then call scanner_error (mrds_error_$inv_string,
      818 		  substr (se_string, parser_se_info.token_start));
      819 
      820 	  parser_se_info.se_cursor = parser_se_info.se_cursor + i + 1;
      821 
      822 	  if parser_se_info.se_cursor > parser_se_info.se_length
      823 	  then done = "1"b;
      824 	  else if se_array (parser_se_info.se_cursor) ^= QUOTE
      825 	       then done = "1"b;
      826         end;
      827 
      828         if parser_se_info.se_cursor <= parser_se_info.se_length
      829         then
      830 	   if se_array (parser_se_info.se_cursor)
      831 	        = B /* found a bit string */
      832 	   then do;
      833 	       if parser_se_info.se_cursor = parser_se_info.se_length
      834 						/* end of string reached */
      835 	       then token_end = parser_se_info.se_cursor;
      836 	       else if search ("1234",
      837 		       se_array (parser_se_info.se_cursor + 1)) = 0
      838 		  then token_end = parser_se_info.se_cursor;
      839 		  else token_end = parser_se_info.se_cursor + 1;
      840 						/* take base also */
      841 
      842 	       token_string = "<bit_string>";
      843 	       call load_stack;
      844 	   end;
      845 
      846 	   else do;				/* just a string */
      847 	       token_end = parser_se_info.se_cursor - 1;
      848 	       token_string = "<string>";
      849 	       call load_stack;
      850 	   end;
      851 
      852         else do;					/* just a string */
      853 	  token_end = parser_se_info.se_cursor - 1;
      854 	  token_string = "<string>";
      855 	  call load_stack;
      856         end;
      857 
      858 
      859         goto finish;
      860 
      861 /* all other characters */
      862 token_type (12):
      863 
      864 
      865         call scanner_error (mrds_error_$inv_token,
      866 	   substr (se_string, parser_se_info.se_cursor, 1));
      867 						/* cant start a token */
      868 
      869         goto finish;
      870 
      871 /* :: or : */
      872 token_type (13):
      873 
      874         if parser_se_info.se_cursor >= parser_se_info.se_length
      875         then goto token_type (12);
      876 						/* EOI. just take : */
      877 
      878         if se_array (parser_se_info.se_cursor + 1) = ":"
      879         then do;
      880 	  token_end = parser_se_info.se_cursor + 1;
      881 	  token_string = "";
      882 	  call load_stack;
      883         end;
      884         else goto token_type (12);			/* cant use a colon */
      885 
      886         goto finish;
      887 
      888 /* simple one character tokens */
      889 token_type (14):
      890 
      891 
      892         token_end = parser_se_info.se_cursor;
      893         token_string = "";
      894         call load_stack;
      895 
      896 
      897         goto finish;
      898 
      899 
      900 
      901 finish:
      902 
      903         if scanner_debug
      904         then call ioa_ (" Token type: ^a; Token: '^a'",
      905 	        token, substr (se_string, parser_se_info.token_start,
      906 	        parser_lex_stack.token_length (stack_index)));
      907         return;
      908 
      909 load_stack:
      910     proc;
      911 
      912 /* procedure to load the lex stack, update the se info structure,
      913*   and look up token ids
      914**/
      915 
      916 
      917         if token_string = "eoi" then do;		/* all done. */
      918 	  parser_lex_stack.token_ptr (stack_index) = null;
      919 
      920 	  parser_lex_stack.token_length (stack_index) = 0;
      921 
      922 	  parser_lex_stack.token_start_pos (stack_index) =
      923 	       parser_se_info.se_length;
      924 
      925 	  token_id = EOI;
      926         end;
      927         else do;
      928 	  parser_lex_stack.token_ptr (stack_index) = /* pointer to token */
      929 	       addr (se_array (parser_se_info.token_start));
      930 
      931 	  parser_lex_stack.token_length (stack_index) = /* length of token */
      932 	       token_end - parser_se_info.token_start + 1;
      933 
      934 	  parser_lex_stack.token_start_pos (stack_index) =
      935 	       parser_se_info.token_start;
      936 
      937 	  parser_se_info.se_cursor = token_end + 1;
      938 
      939 	  if token_string = ""
      940 	  then token =
      941 		  substr (se_string, parser_se_info.token_start,
      942 		  parser_lex_stack.token_length (stack_index));
      943 	  else token = token_string;
      944 
      945 	  call lookup_token (token, token_id);
      946 	  if token_id = 0
      947 	  then call scanner_error (mrds_error_$inv_token, token);
      948         end;
      949 
      950         parser_lex_stack.token_id (stack_index) = token_id;
      951 
      952         parser_se_info.token_length =
      953 	   parser_lex_stack.token_length (stack_index);
      954 
      955     end load_stack;
      956 
      957 lookup_token:
      958     proc (token, token_id);
      959 
      960 /* routine to do binary search of keyword table. This procedure tries
      961*   to do the lookup as fast possible as this is the most performance
      962*   critical part of the scanner, and consequently the whole parser.
      963*
      964*   This tries to take advantage of the of the speed of doing character
      965*   comparisons in the AQ registers instead of using EIS instructions.
      966*   Any token that is less than 9 characters can be manipulated this way.
      967*   A token of length less than 9 can be identified in about 2/3 the time
      968*   it takes to idenitify one of greater length.
      969**/
      970 
      971 dcl     token		 char (24);
      972 dcl     token_id		 fixed bin;
      973 
      974 dcl     (low, middle, high)	 fixed bin;
      975 dcl     temp_keyword	 char (24);
      976 dcl     (temp_short_keyword, short_token)
      977 			 char (8) aligned;
      978 dcl     done		 bit (1) aligned;
      979 
      980 dcl     1 short_keyword	 (hbound (keyword.name, 1)) based (sk_ptr),
      981 						/* this masks over the keyword struct using an 8 char name field */
      982 	2 name		 char (8) aligned,
      983 	2 filler		 char (16);
      984 
      985         low = lbound (keyword.name, 1);
      986         high = hbound (keyword.name, 1);
      987         middle = divide (low + high, 2, 17, 0);
      988         sk_ptr = addr (keyword);
      989         done = "0"b;
      990 
      991         if index (token, " ") < 10 then do;		/* do it the fast way */
      992 	  short_token = substr (token, 1, 8);
      993 	  do while (^done);
      994 
      995 	      if high < low
      996 	      then done = "1"b;			/* something went wrong */
      997 	      else do;
      998 
      999 		temp_short_keyword = short_keyword.name (middle);
     1000 						/* copy it, so we only look it up once */
     1001 
     1002 		if short_token ^= temp_short_keyword then do;
     1003 
     1004 		    if short_token > temp_short_keyword
     1005 		    then low = middle + 1;
     1006 		    else high = middle - 1;
     1007 
     1008 		    middle = divide (low + high, 2, 17, 0);
     1009 
     1010 		end;
     1011 		else done = "1"b;
     1012 	      end;
     1013 	  end;
     1014 
     1015 	  if short_token = temp_short_keyword
     1016 	  then token_id = keyword.value (middle);
     1017 	  else token_id = 0;
     1018 
     1019         end;
     1020 
     1021         else do;					/* do it the normal way */
     1022 
     1023 	  do while (^done);
     1024 	      if high < low
     1025 	      then done = "1"b;			/* something went wrong */
     1026 	      else do;
     1027 
     1028 		temp_keyword = keyword.name (middle);	/* copy it, so we only look it up once */
     1029 
     1030 		if token ^= temp_keyword then do;
     1031 
     1032 		    if token > temp_keyword
     1033 		    then low = middle + 1;
     1034 		    else high = middle - 1;
     1035 
     1036 		    middle = divide (low + high, 2, 17, 0);
     1037 
     1038 		end;
     1039 		else done = "1"b;
     1040 
     1041 	      end;
     1042 	  end;
     1043 
     1044 /* check to see if the search was successful, if not we're in trouble */
     1045 
     1046 	  if token = temp_keyword
     1047 	  then token_id = keyword.value (middle);
     1048 	  else token_id = 0;
     1049         end;
     1050 
     1051     end lookup_token;
     1052 
     1053 scanner_error:
     1054     proc (cd, token);
     1055 
     1056 dcl     cd		 fixed bin (35);
     1057 dcl     token		 char (*);
     1058 
     1059         parser_se_info.error_code, code = cd;
     1060         parser_se_info.loud = "1"b;
     1061         parser_se_info.error_type = SE_TYPE;
     1062         parser_se_info.error_msg = "'" || rtrim (token) || "'";
     1063         call error (code);
     1064 
     1065     end scanner_error;
     1066 
     1067 dcl     stack_index		 fixed bin parameter;
     1068 
     1069 dcl     done		 aligned bit;
     1070 dcl     token_end		 fixed bin;		/* points to where token ends in se */
     1071 dcl     token_string	 char (24) aligned;		/* the token, if known. If its not null
     1072*						   we use this to look up the token id */
     1073 dcl     mrds_data_$max_id_len	 fixed bin (35) ext static;
     1074 dcl     mrds_error_$inv_string fixed bin (35) ext static;
     1075 dcl     mrds_error_$inv_token	 fixed bin (35) ext static;
     1076 dcl     mrds_error_$long_ident fixed bin (35) ext static;
     1077 dcl     token_id		 fixed bin;
     1078 dcl     token		 char (24);		/* size is size of keyword.name */
     1079 dcl     ioa_		 entry () options (variable);
     1080 dcl     ioa_$nnl		 entry () options (variable);
     1081 dcl     sk_ptr		 ptr internal static init (null);
     1082 						/* for binary search */
     1083 dcl     (state, class, id, i, type)
     1084 			 fixed bin;
     1085 dcl     (null, addr, rank)	 builtin;
     1086 
     1087 dcl     QUOTE		 char internal static options (constant)
     1088 			 init ("""");
     1089 dcl     B			 char internal static options (constant)
     1090 			 init ("b");
     1091 dcl     DIGITS		 char (10) internal static
     1092 			 options (constant) init ("0123456789");
     1093 
     1094 dcl     EOI		 fixed bin internal static
     1095 			 options (constant) init (0);
     1096 dcl     WHITE_SPACE		 char (6) based (addr (WHITE_SPACE_data));
     1097 dcl     WHITE_SPACE_data	 internal static options (constant)
     1098 			 dim (6) bit (9) unaligned
     1099 			 init ("011"b3, "012"b3, "013"b3, "014"b3,
     1100 			 "015"b3, "040"b3);		/* HT LF VT FF CR SP */
     1101 
     1102     end scanner;
     1103 
  1     1 /* BEGIN INCLUDE FILE  mrds_se_info.incl.pl1 
  1     2*
  1     3*   These contains information relating to the selection expression.
  1     4*
  1     5**/
  1     6 
  1     7 /****^  HISTORY COMMENTS:
  1     8*  1) change(85-08-05,Hergert), approve(88-06-28,MCR7903),
  1     9*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  1    10*     Created for for new parser.
  1    11*                                                   END HISTORY COMMENTS */
  1    12 
  1    13 dcl     1 se_info		 aligned based (se_info_ptr),
  1    14 	2 se_ptr		 ptr,			/* points to the beginning of the selection expression */
  1    15 	2 se_length	 fixed bin,		/* length of the selection expression */
  1    16 	2 se_cursor	 fixed bin,		/* current place in se */
  1    17 	2 flags,
  1    18 	  3 pso_seen	 bit,			/* -pso supplied in se */
  1    19 	  3 no_ot_seen	 bit,			/* -no_ot supplied in se */
  1    20           2 error_report,
  1    21 	  3 error_info_supplied bit aligned,              /* ON -> structure already filled in */
  1    22 	  3 loud             bit aligned,                	/* ON -> call mu_print_error */
  1    23             3 token_start      fixed bin,                   /* position in se where token starts */
  1    24             3 token_length     fixed bin,                   /* length of token in se */
  1    25 	  3 error_code       fixed bin(35),               /* system error code */
  1    26             3 stack_offset     fixed bin,                   /* how far down the token is in the lex stack */
  1    27             3 error_type       char(24),                    /* type of error. ie range, select where... */
  1    28 	  3 error_msg        char(256);         	/* message to explain problem */
  1    29 
  1    30 
  1    31 /* various types of errors. actually the string that is reported in the
  1    32*   error message. */
  1    33 dcl     RC_TYPE		 char (12) internal static
  1    34 			 options (constant) init ("Range Clause");
  1    35 dcl     SE_TYPE		 char (20) internal static
  1    36 			 options (constant)
  1    37 			 init ("Selection Expression");
  1    38 dcl     SC_TYPE		 char (13) internal static
  1    39 			 options (constant)
  1    40 			 init ("Select Clause");
  1    41 dcl     WC_TYPE		 char (12) internal static
  1    42 			 options (constant)
  1    43 			 init ("Where Clause");
  1    44 dcl     WCE_TYPE		 char (23) internal static
  1    45 			 options (constant)
  1    46 			 init ("Where Clause Expression");
  1    47 dcl     WCF_TYPE		 char (21) internal static
  1    48 			 options (constant)
  1    49 			 init ("Where Clause Function");
  1    50 dcl     AV_TYPE		 char (16) internal static
  1    51 			 options (constant)
  1    52 			 init ("Access Violation");
  1    53 dcl     IL_TYPE		 char (14) internal static
  1    54 			 options (constant)
  1    55 			 init ("Internal Logic");
  1    56 
  1    57 /* parser_work_area is used to hold all static data for an invocation
  1    58*   of the parser. parser_static_info holds ptrs to all of these relevant
  1    59*   data and also a ptr back to the area it is allocated in. 
  1    60*   parser_work_area.
  1    61**/
  1    62 
  1    63 dcl parser_work_area aligned area (sys_info$max_seg_size) based (parser_static_info.pwa_ptr);
  1    64 
  1    65 dcl psi_ptr ptr;
  1    66 dcl 1 parser_static_info aligned based (psi_ptr),
  1    67       2 pwa_ptr ptr,
  1    68       2 semantics, /* for mrds_dsl_semantics */
  1    69         3 static_data_ptr ptr,
  1    70       2 expr, /* for mrds_dsl_expr_ */
  1    71         3 data_stacks_ptr ptr,
  1    72       2 func, /* for mrds_dsl_func_ */
  1    73         3 sfptrs_ptr ptr,
  1    74       2 where_clause, /* for mrds_dsl_where_clause_ */
  1    75         3 ns_ptr ptr;
  1    76 
  1    77 
  1    78 /* END INCLUDE FILE  mrds_se_info.incl.pl1 */
     1104 
     1105 
  2     1 /*  BEGIN INCLUDE FILE ..... mrds_lex_stack.incl.pl1 ..... 11/27/85 Hergert.MRDS */
  2     2 
  2     3 /****^  HISTORY COMMENTS:
  2     4*  1) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  2     5*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  2     6*     Created for for new parser.
  2     7*                                                   END HISTORY COMMENTS */
  2     8 
  2     9 dcl 1 lex_stack (-3:100) based (lex_stack_ptr) aligned,
  2    10 						/* 3:-1 is the FIFO lookahead stack
  2    11*						   1:50 is the LIFO lexical stack */
  2    12     2 invariant_part,				/* LALR predefined data */
  2    13       3 token_ptr ptr,				/* pointer to symbol (must be valid) */
  2    14       3 token_length fixed bin,	          	/* length of symbol (may be 0) */
  2    15       3 token_start_pos fixed bin,                          /* start position of symbol */
  2    16       3 token_id fixed bin;				/* encoding of the symbol */
  2    17 
  2    18 /* END INCLUDE FILE ..... mrds_lex_stack.incl.pl1 ..... */
     1106 
     1107 
  3     1 /* BEGIN INCLUDE FILE ..... mrds_dsl_tables.incl.pl1 .....
  3     2*
  3     3*
  3     4*SCANNER AND PARSER TABLES FROM SEGMENT
  3     5*	>udd>auto>Hergert>mrds_dsl.grammar
  3     6*
  3     7*   Generated by: Hergert.AUTO.a using LALR 7.3f of Tuesday, January 19, 1988
  3     8*   Generated at: Honeywell Bull, Phoenix AZ, SysM
  3     9*   Generated on: 06/27/88  1513.8 edt Mon
  3    10*   Generated from: >udd>auto>Hergert>mrds_dsl.lalr */
  3    11 
  3    12 
  3    13 /****^  HISTORY COMMENTS:
  3    14*  1) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  3    15*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  3    16*     Created for for new parser.
  3    17*                                                   END HISTORY COMMENTS */
  3    18 
  3    19 dcl 1 mrds_dsl_tables$terminals_hash_list external static,
  3    20     2 terminals_hash_list_size fixed bin,
  3    21     2 terminals_hash_list (0:1020) fixed bin (12) unsigned unaligned;
  3    22 
  3    23 dcl 1 mrds_dsl_tables$terminals_list external static,
  3    24     2 terminals_list_size fixed bin,
  3    25     2 terminals_list (74),
  3    26       3 link fixed bin (18) unsigned unaligned,
  3    27       3 position fixed bin (18) unsigned unaligned,
  3    28       3 length fixed bin (18) unsigned unaligned,
  3    29       3 code fixed bin (18) unsigned unaligned;
  3    30 
  3    31 dcl 1 mrds_dsl_tables$terminal_characters external static,
  3    32     2 terminal_characters_length fixed bin,
  3    33     2 terminal_characters char (488);
  3    34 
  3    35 dcl 1 mrds_dsl_tables$dpda external static,
  3    36     2 dpda_size fixed bin,
  3    37     2 dpda (1766),
  3    38       3 (v1, v2) fixed bin (17) unaligned;
  3    39 
  3    40 dcl 1 mrds_dsl_tables$skip external static,
  3    41     2 skip_size fixed bin,
  3    42     2 skip (2),
  3    43       3 (v1, v2) fixed bin (17) unaligned;
  3    44 
  3    45 dcl 1 mrds_dsl_tables$production_names external static,
  3    46     2 production_names_size fixed bin,
  3    47     2 production_names (169) fixed bin (17) unaligned;
  3    48 
  3    49 dcl 1 mrds_dsl_tables$variables_list external static,
  3    50     2 variables_list_size fixed bin,
  3    51     2 variables_list (75),
  3    52       3 (position, length) fixed bin (18) unsigned unaligned;
  3    53 
  3    54 dcl 1 mrds_dsl_tables$variable_characters external static,
  3    55     2 variable_characters_length fixed bin,
  3    56     2 variable_characters char (1076);
  3    57 
  3    58 dcl 1 mrds_dsl_tables$object_def aligned external static,
  3    59     2 version char (8) aligned,
  3    60     2 terminals_hash_list_offset fixed bin,
  3    61     2 terminals_list_offset fixed bin,
  3    62     2 terminal_characters_offset fixed bin,
  3    63     2 dpda_offset fixed bin,
  3    64     2 skip_offset fixed bin,
  3    65     2 standard_prelude_offset fixed bin,
  3    66     2 production_names_offset fixed bin,
  3    67     2 variables_list_offset fixed bin,
  3    68     2 variable_characters_offset fixed bin,
  3    69     2 semantics_vector_offset fixed bin;
  3    70 
  3    71 /*   END INCLUDE FILE ..... mrds_dsl_tables.incl.pl1 ..... */
     1108 
     1109 
  4     1 /* BEGIN INCLUDE mrds_se_options.incl.pl1 */
  4     2 
  4     3 /****^  HISTORY COMMENTS:
  4     4*  1) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  4     5*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  4     6*     Created for for new parser.
  4     7*                                                   END HISTORY COMMENTS */
  4     8 
  4     9 dcl     1 mode_flags	 aligned based (mode_flags_ptr),
  4    10 	2 reset_sw	 bit unal,
  4    11 	2 list_sw 	 bit unal,
  4    12           2 extras             bit (34) unal,
  4    13 	2 selected           aligned like option_list,
  4    14 	2 value              like option_list;
  4    15 
  4    16 
  4    17 dcl     1 option_list aligned based (option_list_ptr),
  4    18 	2 pso		 bit unal,
  4    19 	2 pse		 bit unal,
  4    20 	2 ot		 bit unal,
  4    21 	2 force		 bit unal,
  4    22 	2 error		 bit unal,
  4    23 	2 extras		 bit (31) unal;
  4    24 
  4    25 dcl mode_flags_ptr ptr;
  4    26 dcl option_list_ptr ptr;
  4    27 
  4    28 /* END INCLUDE mrds_se_options.incl.pl1 */
     1110 
     1111 
  5     1 /* mrds_scanner_tables.incl.pl1 
  5     2*
  5     3*   These are the tables that drive the scanner for MRDS selection expression 
  5     4*   parsing.
  5     5*
  5     6*   Originally created 08-04-85 J. Hergert
  5     7*
  5     8*
  5     9* The following declaration is used by the scanner to type the token it is 
  5    10* about to parse. The first character determines what the token could be.
  5    11*
  5    12* The codes in the following declaration are deciphered as follows:
  5    13* Any code >  0 is a token type, indicating the type of token we will try 
  5    14* to find. Codes less than 0 are negated keyword encode values. These token 
  5    15* types are simple one character tokens and no further searching need be 
  5    16* done when we find one.
  5    17**/
  5    18 
  5    19 
  5    20 /****^  HISTORY COMMENTS:
  5    21*  1) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  5    22*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  5    23*     Created for for new parser.
  5    24*                                                   END HISTORY COMMENTS */
  5    25 
  5    26 dcl token_type_list (22) fixed bin internal static options(constant) init (
  5    27 /*                                              CHARACTER CLASSES
  5    28*            1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  
  5    29*          num   .  +-  Ee   i   ^   =   <   > let  * /  |   (   )   &   , whsp  " oth   :   ]   [
  5    30**/
  5    31             1,  2,  3,  4,  4,  5,  6,  7,  8,  4, 14, 9, 14, 14, 14, 14, 10, 11, 12, 13, 14, 14);
  5    32 
  5    33 
  5    34 
  5    35 
  5    36 /* The following dcl sets up a list that is used to categorize each 
  5    37*   character into one of 22 classes. The classes are defined below.
  5    38*
  5    39*The character classes are the following:
  5    40*1 digits
  5    41*2   .
  5    42*3   +-
  5    43*4   Ee
  5    44*5   i
  5    45*6   ^
  5    46*7   =
  5    47*8   <
  5    48*9   > 
  5    49*10  letters
  5    50*11  * /
  5    51*12  |
  5    52*13  (
  5    53*14  )
  5    54*15  &
  5    55*16  ,
  5    56*17  SP TAB NL FF VT CR   (white space)
  5    57*18  "
  5    58*19  all others
  5    59*20  :
  5    60*21  ]
  5    61*22  [
  5    62**/
  5    63 
  5    64 
  5    65 /* each of 512 ascii characters classified into the above groups */
  5    66 
  5    67 dcl char_class_list (0:511) fixed bin internal static options(constant) 
  5    68     init(
  5    69 /*         whsp                !   "   #$%    &   '   (   )   *  +   ,  - */
  5    70     (9)19, (5)17, (18)19, 17, 19, 18, (3)19, 15, 19, 13, 14, 11, 3, 16, 3,
  5    71 /*  .   /   nums   :   ;  <  =  >   ?   @   ABCD  E   FGH   I   J-U       */
  5    72     2, 11, (10)1, 20, 19, 8, 7, 9, 19, 19, (4)10, 4, (3)10, 5, (12)10,
  5    73 /*   V   W   X   Y   Z   [   \   ]  ^   _   `   abcd  e   fgh   i   j-u   */
  5    74     10, 10, 10, 10, 10, 22, 19, 21, 6, 19, 19, (4)10, 4, (3)10, 5, (12)10,
  5    75 /*   v   w   x   y   z   {   |                                            */
  5    76     10, 10, 10, 10, 10, 19, 12, (387)19);
  5    77 
  5    78  
  5    79 
  5    80 
  5    81 /* the table declared below is a state table used to parse a number.
  5    82*   The rows are states, and the columns are character classes. These
  5    83*   are obtained from the char_class_list above. The columns are organized
  5    84*   so that the six correspond to classes 1-6 above.
  5    85*
  5    86*   A positive value in the table is the next state to goto, given the current
  5    87*   character class. A negative value means the scan is finished.
  5    88*   -1 means the scan is finished, a token has been found.
  5    89*   -2 means an error has been detected.
  5    90*   -3 means the scan is finished, a token has been found, the cursor must be 
  5    91*      bumped by one.
  5    92**/
  5    93 
  5    94 dcl num_state_table (6,6) fixed bin internal static options (constant) init(
  5    95 /*                class
  5    96*          1   2   3   4   5   6
  5    97*        num   .  +-  Ee   i   other
  5    98*states */
  5    99 /* 1 */   1,  2, -1,  3, -3, -1, 
  5   100 /* 2 */   4, -2, -2, -2, -2, -2, 
  5   101 /* 3 */   6, -2,  5, -2, -2, -2, 
  5   102 /* 4 */   4, -1, -1,  3, -3, -1, 
  5   103 /* 5 */   6, -2, -2, -2, -2, -2, 
  5   104 /* 6 */   6, -1, -1, -1, -3, -1);
  5   105 	
     1112 
     1113 
  6     1 /* BEGIN INCLUDE FILE ..... mrds_dsl_keywords.incl.pl1 ..... 03/17/87  1851.1 est Tue kwsl (generated) */
  6     2 	/* Keywords from >user_dir_dir>MRDS>Hergert>p>mrds_dsl.grammar
  6     3*	   Generated from >udd>MRDS>Hergert>p>mrds_dsl.lalr
  6     4*	   by Hergert.MRDS.a                  
  6     5*	   at Ford ECC Multics A              
  6     6*	   on 03/17/87  1825.8 est Tue */
  6     7 
  6     8 /* this is the list of keywords and their synonyms that are known to the scanner. */
  6     9 
  6    10 /****^  HISTORY COMMENTS:
  6    11*  1) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  6    12*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  6    13*     Created for for new parser.
  6    14*                                                   END HISTORY COMMENTS */
  6    15 
  6    16 dcl 1 keyword aligned internal static options (constant),
  6    17     2 name (74) unaligned char (24) init(
  6    18 	/*   1 */	"&",                    /*   1 &                   */
  6    19 	/*   2 */	"(",                    /*   2 (                   */
  6    20 	/*   3 */	"(+)",                  /*   3 (+)                 */
  6    21 	/*   4 */	")",                    /*   4 )                   */
  6    22 	/*   5 */	"*",                    /*   5 *                   */
  6    23 	/*   6 */	"+",                    /*   6 +                   */
  6    24 	/*   7 */	",",                    /*   7 ,                   */
  6    25 	/*   8 */	"-",                    /*   8 -                   */
  6    26 	/*   9 */	"-all_of",              /*   9 -all_of             */
  6    27 	/*  10 */	"-and",                 /*   1 &                   */
  6    28 	/*  11 */	"-any_of",              /*  10 -any_of             */
  6    29 	/*  12 */	"-ascending",           /*  11 -ascending          */
  6    30 	/*  13 */	"-current",             /*  12 -current            */
  6    31 	/*  14 */	"-descending",          /*  13 -descending         */
  6    32 	/*  15 */	"-differ",              /*  14 -differ             */
  6    33 	/*  16 */	"-distinct",            /*  15 -distinct           */
  6    34 	/*  17 */	"-dup",                 /*  16 -dup                */
  6    35 	/*  18 */	"-from",                /*  33 -range              */
  6    36 	/*  19 */	"-group_by",            /*  17 -group_by           */
  6    37 	/*  20 */	"-having",              /*  18 -having             */
  6    38 	/*  21 */	"-inter",               /*  19 -inter              */
  6    39 	/*  22 */	"-is_between",          /*  20 -is_between         */
  6    40 	/*  23 */	"-is_in",               /*  21 -is_in              */
  6    41 	/*  24 */	"-is_like",             /*  22 -is_like            */
  6    42 	/*  25 */	"-is_not_between",      /*  23 -is_not_between     */
  6    43 	/*  26 */	"-is_not_in",           /*  24 -is_not_in          */
  6    44 	/*  27 */	"-is_not_like",         /*  25 -is_not_like        */
  6    45 	/*  28 */	"-is_not_null",         /*  26 -is_not_null        */
  6    46 	/*  29 */	"-is_null",             /*  27 -is_null            */
  6    47 	/*  30 */	"-no_optimize",         /*  28 -no_optimize        */
  6    48 	/*  31 */	"-no_ot",               /*  29 -no_ot              */
  6    49 	/*  32 */	"-not",                 /*  53 ^                   */
  6    50 	/*  33 */	"-or",                  /*  55 |                   */
  6    51 	/*  34 */	"-order_by",            /*  30 -order_by           */
  6    52 	/*  35 */	"-print_search_order",  /*  31 -print_search_order */
  6    53 	/*  36 */	"-pso",                 /*  32 -pso                */
  6    54 	/*  37 */	"-range",               /*  33 -range              */
  6    55 	/*  38 */	"-select",              /*  34 -select             */
  6    56 	/*  39 */	"-union",               /*  35 -union              */
  6    57 	/*  40 */	"-where",               /*  36 -where              */
  6    58 	/*  41 */	".",                    /*  37 .                   */
  6    59 	/*  42 */	".V.",                  /*  38 .V.                 */
  6    60 	/*  43 */	".X.",                  /*  39 .X.                 */
  6    61 	/*  44 */	".v.",                  /*  38 .V.                 */
  6    62 	/*  45 */	".x.",                  /*  39 .X.                 */
  6    63 	/*  46 */	"/",                    /*  40 /                   */
  6    64 	/*  47 */	"::",                   /*  41 ::                  */
  6    65 	/*  48 */	"<",                    /*  42 <                   */
  6    66 	/*  49 */	"<=",                   /*  43 <=                  */
  6    67 	/*  50 */	"<>",                   /*  54 ^=                  */
  6    68 	/*  51 */	"<bit_string>",         /*  44 <bit_string>        */
  6    69 	/*  52 */	"<integer>",            /*  45 <integer>           */
  6    70 	/*  53 */	"<string>",             /*  46 <string>            */
  6    71 	/*  54 */	"<symbol>",             /*  47 <symbol>            */
  6    72 	/*  55 */	"=",                    /*  48 =                   */
  6    73 	/*  56 */	"=<",                   /*  43 <=                  */
  6    74 	/*  57 */	"=>",                   /*  50 >=                  */
  6    75 	/*  58 */	">",                    /*  49 >                   */
  6    76 	/*  59 */	"><",                   /*  54 ^=                  */
  6    77 	/*  60 */	">=",                   /*  50 >=                  */
  6    78 	/*  61 */	"[",                    /*  51 [                   */
  6    79 	/*  62 */	"]",                    /*  52 ]                   */
  6    80 	/*  63 */	"^",                    /*  53 ^                   */
  6    81 	/*  64 */	"^<",                   /*  50 >=                  */
  6    82 	/*  65 */	"^<=",                  /*  49 >                   */
  6    83 	/*  66 */	"^<>",                  /*  48 =                   */
  6    84 	/*  67 */	"^=",                   /*  54 ^=                  */
  6    85 	/*  68 */	"^=<",                  /*  49 >                   */
  6    86 	/*  69 */	"^=>",                  /*  42 <                   */
  6    87 	/*  70 */	"^>",                   /*  43 <=                  */
  6    88 	/*  71 */	"^><",                  /*  48 =                   */
  6    89 	/*  72 */	"^>=",                  /*  42 <                   */
  6    90 	/*  73 */	"|",                    /*  55 |                   */
  6    91 	/*  74 */	"||"),                  /*  56 ||                  */
  6    92 
  6    93 /* This table contains the codes that are known to the parser. One code
  6    94*   per token. Synonomous tokens have the same code. */
  6    95     2 value (74) fixed bin init (
  6    96 	1,	2,	3,	4,	5,	6,	7,
  6    97 	8,	9,	1,	10,	11,	12,	13,
  6    98 	14,	15,	16,	33,	17,	18,	19,
  6    99 	20,	21,	22,	23,	24,	25,	26,
  6   100 	27,	28,	29,	53,	55,	30,	31,
  6   101 	32,	33,	34,	35,	36,	37,	38,
  6   102 	39,	38,	39,	40,	41,	42,	43,
  6   103 	54,	44,	45,	46,	47,	48,	43,
  6   104 	50,	49,	54,	50,	51,	52,	53,
  6   105 	50,	49,	48,	54,	49,	42,	43,
  6   106 	48,	42,	55,	56),
  6   107 
  6   108 /* This table is used for error reporting. It decides that the keyword is
  6   109*   a "major" one. These currently are -differ, -range, -group_by, -having,
  6   110*   -inter, -order_by, -from, -select, -union, -where */
  6   111     2 major_keyword (74) bit unaligned init (
  6   112 /* 1-7   */ "0"b,     "0"b,     "0"b,     "0"b,     "0"b,     "0"b,     "0"b,
  6   113 /* 8-14  */ "0"b,     "0"b,     "0"b,     "0"b,     "0"b,     "0"b,     "0"b,
  6   114 /* 15-21 */ "1"b,     "0"b,     "0"b,     "1"b,     "1"b,     "1"b,     "1"b,
  6   115 /* 22-28 */ "0"b,     "0"b,     "0"b,     "0"b,     "0"b,     "0"b,     "0"b,
  6   116 /* 29-35 */ "0"b,     "0"b,     "0"b,     "0"b,     "0"b,     "1"b,     "0"b,
  6   117 /* 36-42 */ "0"b,     "1"b,     "1"b,     "1"b,     "1"b,     "0"b,     "0"b,
  6   118 /* 43-49 */ "0"b,     "0"b,     "0"b,     "0"b,     "0"b,     "0"b,     "0"b,
  6   119 /* 50-56 */ "0"b,     "0"b,     "0"b,     "0"b,     "0"b,     "0"b,     "0"b,
  6   120 /* 57-63 */ "0"b,     "0"b,     "0"b,     "0"b,     "0"b,     "0"b,     "0"b,
  6   121 /* 64-70 */ "0"b,     "0"b,     "0"b,     "0"b,     "0"b,     "0"b,     "0"b,
  6   122 /* 71-74 */ "0"b,     "0"b,     "0"b,     "0"b);
  6   123          
  6   124 /*   END INCLUDE FILE ..... mrds_dsl_keywords.incl.pl1 ..... */
     1114 
     1115 
  7     1 /* BEGIN mrds_dbcb.incl.pl1 -- jaw, 11/7/78 */
  7     2 
  7     3 
  7     4 
  7     5 /****^  HISTORY COMMENTS:
  7     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  7     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  7     8*     This entry is being made to cover the change made on 85-07-01 by Thanh
  7     9*     Nguyen. The scopes_changed flag was added to make checking for this
  7    10*     more efficient (mrds error list #137).
  7    11*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
  7    12*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
  7    13*     Add a bit called dont_check_txn_id to indicate whether or not we should
  7    14*     care if multiple txns use the same selection_expression. (mrds #156)
  7    15*  3) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  7    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  7    17*     Added parser_work_area_ptr and mrds_se_info_ptr for new parser.
  7    18*                                                   END HISTORY COMMENTS */
  7    19 
  7    20 
  7    21 /* WARNING
  7    22*          If the dbcb structure is changed then the mrds_data_
  7    23*          item saved_res_version MUST be incremented to invalidate all
  7    24*          existing saved resultants
  7    25**/
  7    26 
  7    27 /* HISTORY :
  7    28*
  7    29*   modified by Jim Gray - - 80-10-24, to add new_select_expr bit for
  7    30*   tid_list management
  7    31*
  7    32*   81-1-9 Jim Gray : added like reference for  ease  in  making  the
  7    33*   phony resultant in mu_database_index, without having the area dcl
  7    34*   included.
  7    35*
  7    36*   81-06-17 Roger Lackey :  added  last_store_rel_name  for  use  by
  7    37*   mrds_dsl_store
  7    38*
  7    39*   81-06-26 Roger Lackey : Added no_optimize and  print_search_order
  7    40*   switches
  7    41*
  7    42*   81-07-06 Jim Gray : added identifier for  the  current  selection
  7    43*   expression,  so  that relation statistics can be updated relative
  7    44*   to number of selection expressions seem. Also  removed  init  for
  7    45*   last_store_rel_name,   as   this   iw   now   properly   done  in
  7    46*   mrds_dsl_init_res.
  7    47*
  7    48*   81-07-17  Roger Lackey : added pred_ptr and unused_ptrs.
  7    49*
  7    50*   82-08-19  Mike Kubicar : added store_vector field.  This is needed
  7    51*   for the conversion to the relation manager.
  7    52*
  7    53*   82-08-23 Davids: added the relmgr_entries and access_costs
  7    54*   substructures so that the entries and costs can change
  7    55*   depending on the type of database that is opened.
  7    56*
  7    57*   82-09-09 Mike Kubicar : added modify_vector field.  This is needed
  7    58*   since modify uses a different vector type (general) than does store.
  7    59*
  7    60*   82-09-20 Davids: changed names of (store modify)_vector to
  7    61*   (store modify)_vector_ptr. Also (delete modify)_tuple_by_id to
  7    62*   (delete modify)_tuples_by_id. added the element cursor_storage_ptr
  7    63*   which should be inited to null and will be set by mu_cursor_manager_$get
  7    64*   during the first call.
  7    65*
  7    66*   82-09-21 Davids: renamed cursor_storage_ptr to cursor_ptrs_storage_ptr
  7    67*   since it deals with the pointers to the cursors and not the cursors
  7    68*   themelves and added the element cursor_storage_area_ptr which points
  7    69*   to the area where the cursors are kept.
  7    70*
  7    71*   82-09-22 Davids: renamed the transact_ctl_seg to transactions_needed.
  7    72*   the transact_ctl_seg always had a value of 0 and really didn't mean
  7    73*   anything.
  7    74*
  7    75*   82-09-22 Mike Kubicar : added create_relation, create_index and
  7    76*   destroy_relation_by_opening to relmgr_entries.  They are needed
  7    77*   by mrds_dsl_define_temp_rel.
  7    78*
  7    79*   82-09-24 Donna Woodka : added  put_tuple to  relmgr_entries. It
  7    80*   is needed by mu_store.
  7    81*
  7    82*   82-11-12 Davids: changed the declaration of the access_costs from fixed
  7    83*   bin to float bin since the values are not integers.
  7    84*
  7    85*   83-02-02 Davids: added the dbc_uid element. This will allow mrds to make
  7    86*   sure that the dbc_ptr still points to the correct segment. Element was 
  7    87*   added to the end of the structure to allow modules that don't use
  7    88*   the element to continue to reference the dbcb structure without recompiling.
  7    89*
  7    90*   83-02-25 Davids: added the concurrency_on and rollback_on elements. These
  7    91*   are needed so that temp rels can be created with the same file attributes
  7    92*   as the permanent relations.
  7    93*
  7    94*   83-05-02 Mike Kubicar : Deleted get_next_search_specification_ptr and
  7    95*   added the resultant_in_pdir bit.
  7    96*
  7    97*   83-05-18 Davids: reduced the number of reserved bits to 14 (from 15) and
  7    98*   added the res_already_made element.
  7    99*
  7   100*   83-05-24 Mike Kubicar : Updated the relation manager calling sequences.
  7   101*
  7   102*   83-08-03 Mike Kubicar : Added the element_id_list_segment_ptr and removed
  7   103*   one of the unused pointers.
  7   104*
  7   105*   83-09-20 Ron Harvey: Added relmgr_entries.get_population.
  7   106*
  7   107*   84-08-27 John Hergert:  Created compiled_se_info_ptr from unused_ptrs(2)
  7   108*   leaving unused_ptrs(1).
  7   109*
  7   110*   85-01-15 Thanh Nguyen:  Added the work_area_ptr and removed the last
  7   111*   unused_ptrs (1).
  7   112*
  7   113*   85-04-12 Thanh Nguyen:  Added user_started_transaction and 
  7   114*   non_shared_to_shared flags.  Also added se_transaction_id and some more
  7   115*   spare ptrs, entries and reserved storages for future enhancement, since
  7   116*   we changed the saved_res_version from rslt0001 to rslt0002.
  7   117*
  7   118*   85-07-01 Thanh Nguyen:  Added scopes_changed flag.  This flag is set by
  7   119*   common routine of mrds_dsl_set_scope, reset by mrds_dsl_optimize and 
  7   120*   mrds_dsl_gen_srch_prog when building of a new search_vars.
  7   121**/
  7   122 
  7   123 
  7   124 /* this structure is based on the {unique_name}.mrds.dbcb segment
  7   125*   that constitutes the non-secure portion of the resultant model that is
  7   126*   created during the opening of a database. it contains variables that
  7   127*   are used during the runtime access of the database, and an area
  7   128*   for evaluation of requests. it points to four other
  7   129*   segments in the resultant model, {unique_name}.mrds.rdbi, the secure
  7   130*   portion of the resultant(see mdbm_rm_db_info.incl.pl1),
  7   131*   {unique_name}.mrds.select, an area for selection expression evaluation,
  7   132*   {unique_name}.mrds.curdat, and {unique_name}.mrds.stadat, two segments
  7   133*   used in the elimination of duplicate tuples during a retrieve.
  7   134*   the dbcb area holds the structure in mdbm_scope_info.incl.pl1
  7   135*   that is used when the database is using the file scope mechanism
  7   136*   for concurrency control over file readying. the segment overlayed via
  7   137*   mrds_dbc.incl.pl1 structure is pointed to and also handles concurrency control,
  7   138*   across database openings. the pointer to this dbcb structure is kept in a table
  7   139*   which associates database indexes(returned from a call to dsl_$open), with particular
  7   140*   opening instances of resultant models. (see mu_database_index routine) */
  7   141 
  7   142      dcl	   1 dbcb		      aligned based (dbcb_ptr), /* DBCB -- non-secure portion */
  7   143 	     2 data	      like dbcb_data,
  7   144 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (dbcb.static_area))));
  7   145 
  7   146      dcl	   dbcb_ptr	      ptr;
  7   147 
  7   148      declare 1 dbcb_data	      based,		/* info part of dbcb, separated out so that
  7   149*						   like references can avoid getting the area declaration */
  7   150 	     2 rdbi_ptr	      ptr,		/* pointer to write protected mdbm_util_ info. */
  7   151 	     2 range_ptr	      ptr,		/*  ptr to range structure, or null */
  7   152 	     2 select_ptr	      ptr,		/* ptr to select list, or null */
  7   153 	     2 sv_ptr	      ptr,		/* pointer to search variables */
  7   154 	     2 so_ptr	      ptr,		/* pointer to search operators */
  7   155 	     2 ti_ptr	      ptr,		/* pointer to tuple info */
  7   156 	     2 lit_ptr	      ptr,		/* pointer to the literal area, or null */
  7   157 	     2 current_ptr	      ptr,		/* ptr to select list resulting from -current clause */
  7   158 	     2 ss_ptr	      ptr,		/* ptr to select sets block if not simple s.e. */
  7   159 	     2 retr_info_ptr      ptr,		/* ptr to retrieve info area */
  7   160 	     2 trel_info_ptr      ptr,		/* ptr to retrieve info area */
  7   161 	     2 sti_ptr	      ptr,		/* pointer to store info */
  7   162 	     2 dbc_ptr	      ptr,		/*  pointer to the data base control segment */
  7   163 	     2 sfi_ptr	      ptr,		/* points to head of scalar function list */
  7   164 	     2 scope_ptr	      ptr,		/* points to array of scope tuples */
  7   165 	     2 select_area_ptr    ptr,		/* ptr to area for current selection expression allocations */
  7   166 	     2 current_data_ptr   ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  7   167*						   for eliminating duplicate tuples. */
  7   168 	     2 static_data_ptr    ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  7   169*						   for eliminating duplicate tuples. */
  7   170 	     2 store_area_ptr     ptr,		/* temp storage area for dsl_$store */
  7   171 	     2 retrieve_area_ptr  ptr,		/* temp storage for dsl_$retrieve */
  7   172 	     2 modify_area_ptr    ptr,		/* temp storage area for dsl_$modify */
  7   173 	     2 delete_area_ptr    ptr,		/* temp storage area for dsl_$delete */
  7   174 	     2 def_temp_rel_area_ptr ptr,		/* temp storage area for dsl_$define_temp_rel */
  7   175 	     2 pred_ptr	      ptr,		/* Pointer to pred_array */
  7   176 	     2 store_vector_ptr   ptr,		/* Vector structure used during store operations */
  7   177 	     2 modify_vector_ptr  ptr,		/* Used during modifies */
  7   178 	     2 element_id_list_segment_ptr ptr,		/* Points to the segment used to hold element_id_list structures */
  7   179                2 compiled_se_info_ptr ptr,                  /* points to the segment containing all info on compiled sexs */
  7   180 	     2 work_area_ptr        ptr,		/* Work area for encode/decode value allocations in mu_retrieve */
  7   181 	     2 se_info_ptr          ptr,                  /* Points to se_info struct. Primarily for error reports */
  7   182 	     2 parser_work_area_ptr ptr,		/*  work area for parser */
  7   183 	     2 reserved_ptrs      (4) ptr,		/* Reserved for future use */
  7   184 	     2 another_flag	      bit (1) unal,		/* on if predicate was -another */
  7   185 	     2 current_flag	      bit (1) unal,		/* on if predicate was -current clause */
  7   186 	     2 dbc_incr	      bit (1) unal,		/* on if dbc open mode has been incremented for this user */
  7   187 	     2 delete_flag	      bit (1) unal,		/* On if search was called from mrds_dsl_sec_delete */
  7   188 	     2 dup_retain	      bit (1) unaligned,	/* On if dup tuples allowed for retrieval */
  7   189 	     2 prev_select	      bit (1) unal,		/* on if prev. select block processed in this s.e. */
  7   190 	     2 possible_op	      bit (1) unal,		/* on of arith op. allowed */
  7   191 	     2 sel_clause	      bit (1) unal,		/* on if currently in select clause */
  7   192 	     2 dsm_sw	      bit (1) unal,		/* on if data base was opened via data submodel */
  7   193 	     2 val_rtrv	      bit (1) unal,		/* if s.e. valid for retrieve */
  7   194 	     2 val_mod	      bit (1) unal,		/* for modify */
  7   195 	     2 val_del	      bit (1) unal,		/* for delete */
  7   196 	     2 val_dtr	      bit (1) unal,		/* for define temp rel */
  7   197 	     2 transactions_needed bit (1) unal,	/* On => transaction must be started or in progress does
  7   198*                                                                     not imply that the database is of type page_file */
  7   199 	     2 open_mode	      bit (3) unal,		/* 0=>unknown, 1=>r, 2=>u, 3=>er, 4=>eu, >4=>bad */
  7   200 	     2 new_select_expr    bit (1) unal,		/* on => starting a new tid list management period */
  7   201 	     2 no_optimize	      bit (1) unal,		/* On => no optimize */
  7   202 	     2 print_search_order bit (1) unal,		/*  On => print the search order */
  7   203 	     2 resultant_in_pdir  bit (1) unal,		/* On => Temp segments are in the process dir */
  7   204 	     2 res_already_made   bit (1) unal,           /* On => resultant has been made based on a saved copy */
  7   205 	     2 user_started_transaction bit (1) unal,     /* On => user already started his own transaction. */
  7   206 	     2 non_shared_to_shared bit (1) unal,         /* On => user changed the scope from non shared to shared
  7   207*						   inside a sequence of -another selection expression. */
  7   208 	     2 scopes_changed     bit (1) unal,           /* On => scopes had been changed by set_scopes or delete_scopes */
  7   209 	     2 dont_check_txn_id  bit (1) unal,           /* On => cpmd needs same selection exp across multiple txns */
  7   210 	     2 reserved	      bit (10) unal,	/* reserved for future use */
  7   211 	     2 nseq_sch	      fixed bin (35),	/* no. tuples located via sequential search */
  7   212 	     2 nind_sch	      fixed bin (35),	/* no. tuples located via index search */
  7   213 	     2 nhash_sch	      fixed bin (35),	/* no. tuples located via hash search */
  7   214 	     2 nlk_sch	      fixed bin (35),	/* no tuples located via link search */
  7   215 	     2 cur_lit_offset     fixed bin (35),	/* current bit offset in literal string */
  7   216 	     2 dbi	      fixed bin (35),	/* database index for this opening */
  7   217 	     2 last_s_e_id_num    fixed bin (35),	/* identifying number for last selection expression seen */
  7   218 	     2 se_transaction_id  bit (36) aligned,       /* transaction id from beginning of select expression */
  7   219 	     2 last_store_rel_name char (32),		/* Name of relation last used  for store */
  7   220 	     2 cursor_ptrs_storage_ptr ptr,		/* pointer to space where cursor ptrs are stored */
  7   221 	     2 cursor_storage_area_ptr ptr,		/* pointer to area where the cursors are kept */
  7   222 	     2 reserved_words     (10) fixed bin (35),	/* Reserved for future use */
  7   223 	     2 relmgr_entries,			/* relation manager entries */
  7   224 	       3 open	      entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  7   225 	       3 close	      entry (bit (36) aligned, fixed bin (35)),
  7   226 	       3 create_cursor    entry (bit (36) aligned, ptr, ptr, fixed bin (35)),
  7   227 	       3 destroy_cursor   entry (ptr, ptr, fixed bin (35)),
  7   228 	       3 set_scope	      entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35)),
  7   229 	       3 delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  7   230 	       3 modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35)),
  7   231 	       3 get_tuple_by_id  entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  7   232 	       3 get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)),
  7   233 	       3 get_tuple_id     entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  7   234 	       3 put_tuple	      entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  7   235 	       3 get_count	      entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  7   236 	       3 get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35)),
  7   237 	       3 get_population   entry (ptr, fixed bin (35), fixed bin (35)),
  7   238 	       3 create_relation  entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)),
  7   239 	       3 create_index     entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35)),
  7   240 	       3 destroy_relation_by_path entry (char (*), char (*), fixed bin (35)),
  7   241 	       3 reserved_entries (5) entry (),
  7   242 	     2 access_costs,			/* access costs for permute */
  7   243 	       3 total_primary_key_cost float bin,
  7   244 	       3 access_cost      float bin,
  7   245 	       3 access_overhead  float bin,
  7   246 	       3 us_access_cost   float bin,
  7   247 	       3 os_access_cost   float bin,
  7   248 	     2 dbc_uid	      bit (36) aligned,	/* uid of the segment containing the dbc structure */
  7   249 	     2 concurrency_on     bit (1) unal,		/* "1"b implies dmfile concurrency is being used */
  7   250 	     2 rollback_on	      bit (1) unal;		/* "1"b iomplies before journaling is to be done */
  7   251 
  7   252 /* END mrds_dbcb.incl.pl1 */
  7   253 
  7   254 
     1116 
     1117 
     1118 dcl     area_ptr		 pointer parameter;
     1119 dcl     caller		 fixed binary (35) parameter;
     1120 dcl     se_ptr		 pointer parameter;
     1121 dcl     se_len		 fixed binary parameter;
     1122 dcl     arg_ptr		 pointer parameter;
     1123 dcl     desc_ptr		 pointer parameter;
     1124 dcl     num_args		 fixed binary parameter;
     1125 dcl     code		 fixed bin (35) parameter;
     1126 dcl     mu_print_error	 entry (ptr);
     1127 dcl     mrds_dsl_semantics$init
     1128 			 entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35),
     1129 			 ptr, ptr, ptr, fixed bin, bit (1) aligned);
     1130 dcl     mrds_dsl_semantics	 entry (ptr, fixed bin, fixed bin,
     1131 			 fixed bin (35));
     1132 
     1133 dcl     1 parser_lex_stack	 (-3:100) aligned like lex_stack;
     1134 
     1135 dcl     1 parser_se_info	 aligned like se_info;
     1136 
     1137 dcl     lex_stack_ptr	 ptr;
     1138 
     1139 dcl     se_info_ptr		 ptr;
     1140 dcl     1 lookahead		 (-3:100)
     1141 			 defined parser_lex_stack aligned like lex_stack;
     1142 dcl     abs		 builtin;
     1143 dcl     addr		 builtin;
     1144 dcl     char		 builtin;
     1145 dcl     current_flag	 bit (1) aligned;
     1146 dcl     current_state	 fixed bin;		/* number of current state */
     1147 dcl     current_table	 fixed bin;		/* number of current table */
     1148 dcl     dbi_pic		 picture "999";
     1149 dcl     1 db_data		 unaligned,
     1150 	2 flag		 char (1),		/* * means stacked */
     1151 	2 state		 picture "zzz9",
     1152 	2 top		 picture "zzz9",
     1153 	2 filler		 char (2),
     1154 	2 type		 char (6),
     1155 	2 data		 char (100);
     1156 dcl     db_item		 char (117) defined (db_data);
     1157 dcl     db_look		 pic "99" defined (db_data.type) pos (3);
     1158 dcl     debug		 bit (1) internal static init ("0"b);
     1159 dcl     db_separator	 char (1);
     1160 dcl     divide		 builtin;
     1161 dcl     fixed		 builtin;
     1162 dcl     hbound		 builtin;
     1163 dcl     i			 fixed bin;
     1164 dcl     index		 builtin;
     1165 dcl     ioa_$nnl		 entry options (variable);
     1166 						/* Parse stack underflow or local recovery encountered
     1167*						   impossible conditions.  Both caused by bad DPDA. */
     1168 dcl     mrds_error_$sell_syntax
     1169 			 fixed bin (35) ext;
     1170 dcl     mrds_error_$parser_logic_error
     1171 			 fixed bin (35) external static;
     1172 						/* Parse, lexical, or lookahead stack overflow. */
     1173 dcl     mrds_error_$parser_stack_overflow
     1174 			 fixed bin (35) external static;
     1175 						/* Recovery failed. */
     1176 dcl     mrds_error_$parser_unrecognized_state
     1177 			 fixed bin (35) external static;
     1178 dcl     mrds_error_$bad_attr	 fixed bin (35) ext static;
     1179 dcl     mrds_error_$bad_var	 fixed bin (35) ext static;
     1180 dcl     lb		 fixed bin;
     1181 dcl     lbound		 builtin;
     1182 dcl     lex_stack_top	 fixed bin defined parse_stack_top;
     1183 						/* location of the top of the lexical stack */
     1184 dcl     lex_token		 char (parser_lex_stack
     1185 			 .token_length (lex_stack_top))
     1186 			 based (parser_lex_stack
     1187 			 .token_ptr (lex_stack_top));
     1188 dcl     lookahead_count	 fixed bin;		/* number of terminals in lookahead stack */
     1189 dcl     lookahead_get	 fixed bin;		/* location in lookahead stack to get next token */
     1190 dcl     lookahead_need	 fixed bin;		/* number of lookahead tokens needed */
     1191 dcl     lookahead_put	 fixed bin;		/* location in the lookahead stack to put next token */
     1192 dcl     lookahead_use	 fixed bin;		/* location in the lookahead stack to test with */
     1193 dcl     mu_define_area$define_temp_dir_area
     1194 			 entry (ptr, fixed bin (35), fixed bin (18),
     1195 			 char (11), bit (1) aligned,
     1196 			 bit (1) aligned, bit (1) aligned,
     1197 			 bit (1) aligned, fixed bin (35));
     1198 dcl     (m, n)		 fixed bin;
     1199 dcl     next_state		 fixed bin;		/* number of next state */
     1200 dcl     null		 builtin;
     1201 dcl     parse_stack		 (100) fixed bin aligned;	/* parse stack */
     1202 dcl     parse_stack_top	 fixed bin;		/* location of the top of the parse stack */
     1203 dcl     production_number	 fixed bin;		/* APPLY production number */
     1204 dcl     scanner_debug	 internal static bit init ("0"b);
     1205 dcl     se_string		 char (parser_se_info.se_length)
     1206 			 based (parser_se_info.se_ptr);
     1207 						/* string view of se */
     1208 dcl     se_array		 (parser_se_info.se_length) char
     1209 			 based (parser_se_info.se_ptr);
     1210 						/* array view of se */
     1211 dcl     sys_info$max_seg_size	 fixed bin (35) ext static;
     1212 dcl     t			 fixed bin;
     1213 dcl     test_state		 fixed bin;		/* top state from parse stack during look back lookups */
     1214 dcl     test_token		 fixed bin defined test_state;/* encoding of current token */
     1215 dcl     ub		 fixed bin;
     1216 dcl     unspec		 builtin;
     1217 dcl     ALPHA_NUM		 char (63) internal static options (constant)
     1218 			 init (
     1219 			 "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz"
     1220 			 );
     1221 
     1222     end mrds_dsl_parser;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/01/88  1300.0  mrds_dsl_parser.pl1               >special_ldd>install>MR12.2-1073>mrds_dsl_parser.pl1
1104         1    08/01/88  1300.0  mrds_se_info.incl.pl1             >special_ldd>install>MR12.2-1073>mrds_se_info.incl.pl1
1106         2    08/01/88  1300.0  mrds_lex_stack.incl.pl1           >special_ldd>install>MR12.2-1073>mrds_lex_stack.incl.pl1
1108         3    08/01/88  1300.0  mrds_dsl_tables.incl.pl1          >special_ldd>install>MR12.2-1073>mrds_dsl_tables.incl.pl1
1110         4    08/01/88  1300.0  mrds_se_options.incl.pl1          >special_ldd>install>MR12.2-1073>mrds_se_options.incl.pl1
1112         5    08/01/88  1300.0  mrds_scanner_tables.incl.pl1      >special_ldd>install>MR12.2-1073>mrds_scanner_tables.incl.pl1
1114         6    08/01/88  1300.0  mrds_dsl_keywords.incl.pl1        >special_ldd>install>MR12.2-1073>mrds_dsl_keywords.incl.pl1
1116         7    08/01/88  1300.0  mrds_dbcb.incl.pl1                >special_ldd>install>MR12.2-1073>mrds_dbcb.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ALPHA_NUM                       001061 constant        char(63)                 initial packed unaligned dcl 1217 ref 590 658
B                               007426 constant        char(1)                  initial packed unaligned dcl 1089 ref 532 828
DIGITS                          001056 constant        char(10)                 initial packed unaligned dcl 1091 ref 557
EOI                                    constant        fixed bin(17,0)          initial dcl 1094 ref 925
IL_TYPE                         002173 constant        char(14)                 initial packed unaligned dcl 1-53 ref 181 298
QUOTE                           007427 constant        char(1)                  initial packed unaligned dcl 1087 ref 814 824
SE_TYPE                         002177 constant        char(20)                 initial packed unaligned dcl 1-35 ref 154 1061
WHITE_SPACE                            based           char(6)                  packed unaligned dcl 1096 ref 792
WHITE_SPACE_data                001054 constant        bit(9)                   initial array packed unaligned dcl 1097 set ref 792
abs                                                    builtin function         dcl 1142 ref 407
addr                                                   builtin function         dcl 1085 in procedure "scanner" ref 631 792 928 988
addr                                                   builtin function         dcl 1143 in procedure "mrds_dsl_parser" ref 61 61 61
                                                                                  61 447 447
area_ptr                               parameter       pointer                  dcl 1118 set ref 7 61*
arg_ptr                                parameter       pointer                  dcl 1122 set ref 7 61*
caller                                 parameter       fixed bin(35,0)          dcl 1119 set ref 7 61*
cd                                     parameter       fixed bin(35,0)          dcl 1056 in procedure "scanner_error" ref 1053 1059
cd                                     parameter       fixed bin(35,0)          dcl 444 in procedure "error" ref 442 446
char                                                   builtin function         dcl 1144 ref 182 182 299 299
char_class_list                 001145 constant        fixed bin(17,0)          initial array dcl 5-67 ref 495 515
class                           001736 automatic       fixed bin(17,0)          dcl 1083 set ref 515* 517 517* 518
code                                   parameter       fixed bin(35,0)          dcl 1125 set ref 7 39* 42 42* 53* 256* 258 258 258
                                                                                  280* 282 282* 284* 286* 446* 1059* 1063*
current_flag                           parameter       bit(1)                   dcl 1145 set ref 7 61*
current_state                   001404 automatic       fixed bin(17,0)          dcl 1146 set ref 49* 67 70 73 151* 170* 192 200* 230
                                                                                  232 238 241 242 244 255 295 307 311 327* 335*
current_table                   001405 automatic       fixed bin(17,0)          dcl 1147 set ref 70* 77 80* 80 95* 95 127 127 127
                                                                                  230* 319 320 320 335
data                      4(09) 001407 automatic       char(100)                level 2 in structure "db_data" packed packed
                                                                                  unaligned dcl 1149 in procedure "mrds_dsl_parser"
                                                                                  set ref 162*
data                                   based           structure                level 2 in structure "dbcb" dcl 7-142 in procedure
                                                                                  "mrds_dsl_parser"
db_data                         001407 automatic       structure                level 1 packed packed unaligned dcl 1149 set ref 72*
                                                                                  72 203 203 239 239
db_item                                defined         char(117)                packed unaligned dcl 1156 set ref 72* 203* 239*
db_look                                defined         picture(2)               packed unaligned dcl 1157 set ref 168*
db_separator                    001445 automatic       char(1)                  packed unaligned dcl 1159 set ref 243* 247* 248*
dbcb                                   based           structure                level 1 dcl 7-142
dbcb_data                              based           structure                level 1 unaligned dcl 7-148
dbcb_ptr                               parameter       pointer                  dcl 7-146 set ref 7 38 39 39 44 46 61*
dbi                     114            based           fixed bin(35,0)          level 3 dcl 7-142 set ref 38 39*
dbi_pic                         001406 automatic       picture(3)               packed unaligned dcl 1148 set ref 38* 39
debug                           000010 internal static bit(1)                   initial packed unaligned dcl 1158 set ref 71 151 162
                                                                                  166 173 203 236 426* 430*
desc_ptr                               parameter       pointer                  dcl 1123 set ref 7 61*
divide                                                 builtin function         dcl 1160 ref 324 987 1008 1036
done                            001774 automatic       bit(1)                   dcl 978 in procedure "lookup_token" set ref 989* 993
                                                                                  995* 1011* 1023 1024* 1039*
done                            001716 automatic       bit(1)                   dcl 1069 in procedure "scanner" set ref 812* 813
                                                                                  822* 824*
dpda                      1     000020 external static structure                array level 2 packed packed unaligned dcl 3-35
error                     0(04)        based           bit(1)                   level 2 packed packed unaligned dcl 4-17 ref 447
error_code               12     001262 automatic       fixed bin(35,0)          level 3 dcl 1135 set ref 446* 1059*
error_msg                22     001262 automatic       char(256)                level 3 dcl 1135 set ref 155* 182* 299* 1062*
error_report              6     001262 automatic       structure                level 2 dcl 1135
error_type               14     001262 automatic       char(24)                 level 3 dcl 1135 set ref 154* 181* 298* 1061*
flag                            001407 automatic       char(1)                  level 2 packed packed unaligned dcl 1149 set ref
                                                                                  175* 238*
flags                     4     001262 automatic       structure                level 2 dcl 1135
hbound                                                 builtin function         dcl 1162 ref 178 182 296 299 406 986
high                            001760 automatic       fixed bin(17,0)          dcl 974 set ref 986* 987 995 1006* 1008 1024 1034*
                                                                                  1036
i                               001446 automatic       fixed bin(17,0)          dcl 1163 in procedure "mrds_dsl_parser" set ref 127*
                                                                                  128 132 136* 268* 270 271 274 324* 326 327 330 330
                                                                                  332
i                               001740 automatic       fixed bin(17,0)          dcl 1083 in procedure "scanner" set ref 557* 560
                                                                                  562* 565 585* 590* 593 601 609* 612 612 612 616
                                                                                  627 658* 666 671* 672 675 679 681* 681 683 686 688
                                                                                  703* 706 708 724* 725 742* 743 759* 760 787* 792*
                                                                                  796 800 814* 816 820
id                              001737 automatic       fixed bin(17,0)          dcl 1083 set ref 618* 620 622* 623 638
index                                                  builtin function         dcl 1164 ref 268 671 681 814 991
invariant_part                  000102 automatic       structure                array level 2 in structure "parser_lex_stack"
                                                                                  dcl 1133 in procedure "mrds_dsl_parser"
invariant_part                         defined         structure                array level 2 in structure "lookahead" dcl 1140
                                                                                  in procedure "mrds_dsl_parser"
ioa_                            000070 constant        entry                    external dcl 1079 ref 901
ioa_$nnl                        000036 constant        entry                    external dcl 1165 in procedure "mrds_dsl_parser" ref
                                                                                  151 203 239 241 247 250 252 418
ioa_$nnl                        000072 constant        entry                    external dcl 1080 in procedure "scanner" ref 481 499
keyword                         000025 constant        structure                level 1 dcl 6-16 set ref 988
lb                              001447 automatic       fixed bin(17,0)          dcl 1180 set ref 319* 322 324 330*
lbound                                                 builtin function         dcl 1181 ref 87 87 117 196 985
length                    2     000014 external static fixed bin(18,0)          array level 3 in structure
                                                                                  "mrds_dsl_tables$terminals_list" packed packed
                                                                                  unsigned unaligned dcl 3-23 in procedure
                                                                                  "mrds_dsl_parser" ref 364
length                    1(18) 000024 external static fixed bin(18,0)          array level 3 in structure
                                                                                  "mrds_dsl_tables$variables_list" packed packed
                                                                                  unsigned unaligned dcl 3-49 in procedure
                                                                                  "mrds_dsl_parser" ref 412
length                                                 builtin function         dcl 347 in procedure "get_terminal" ref 375 375 378
                                                                                  380 385 389
lex_stack                              based           structure                array level 1 dcl 2-9
lex_stack_index                        parameter       fixed bin(17,0)          dcl 345 ref 342 350 364 375 375 375 375 378 378 380
                                                                                  380 380 380 385 385 389 389 389 389 391 395
lex_stack_top                          defined         fixed bin(17,0)          dcl 1182 set ref 256* 268 268 271 274 280*
lex_token                              based           char                     packed unaligned dcl 1184 ref 268
lookahead                              defined         structure                array level 1 dcl 1140 ref 87 87 117 193 196
lookahead_count                 001450 automatic       fixed bin(17,0)          dcl 1188 set ref 52* 112 120* 120 199* 199 277*
lookahead_get                   001451 automatic       fixed bin(17,0)          dcl 1189 set ref 50* 84 109 193 196 196* 198* 198
                                                                                  278*
lookahead_need                  001452 automatic       fixed bin(17,0)          dcl 1190 set ref 84 90* 90 104* 112 168
lookahead_put                   001453 automatic       fixed bin(17,0)          dcl 1191 set ref 50* 115* 117 117* 119* 119 278*
lookahead_use                   001454 automatic       fixed bin(17,0)          dcl 1192 set ref 84* 87 87* 87 109* 123 155* 162*
loud                      7     001262 automatic       bit(1)                   level 3 dcl 1135 set ref 153* 180* 208* 297* 314*
                                                                                  447 1060*
low                             001756 automatic       fixed bin(17,0)          dcl 974 set ref 985* 987 995 1004* 1008 1024 1032*
                                                                                  1036
m                               001455 automatic       fixed bin(17,0)          dcl 1198 set ref 126* 132* 145 147
middle                          001757 automatic       fixed bin(17,0)          dcl 974 set ref 987* 999 1004 1006 1008* 1015 1028
                                                                                  1032 1034 1036* 1046
min                                                    builtin function         dcl 347 ref 380 380 389 389
mrds_data_$max_id_len           000060 external static fixed bin(35,0)          dcl 1073 ref 602 612 666 679
mrds_dsl_semantics              000034 constant        entry                    external dcl 1130 ref 256 280
mrds_dsl_semantics$init         000032 constant        entry                    external dcl 1127 ref 61
mrds_dsl_tables$dpda            000020 external static structure                level 1 unaligned dcl 3-35
mrds_dsl_tables$production_names
                                000022 external static structure                level 1 unaligned dcl 3-45
mrds_dsl_tables$terminal_characters
                                000016 external static structure                level 1 unaligned dcl 3-31
mrds_dsl_tables$terminals_list  000014 external static structure                level 1 unaligned dcl 3-23
mrds_dsl_tables$variable_characters
                                000026 external static structure                level 1 unaligned dcl 3-54
mrds_dsl_tables$variables_list  000024 external static structure                level 1 unaligned dcl 3-49
mrds_error_$bad_attr            000050 external static fixed bin(35,0)          dcl 1178 ref 258
mrds_error_$bad_var             000052 external static fixed bin(35,0)          dcl 1179 ref 258
mrds_error_$inv_string          000062 external static fixed bin(35,0)          dcl 1074 set ref 806* 816*
mrds_error_$inv_token           000064 external static fixed bin(35,0)          dcl 1075 set ref 623* 862* 946*
mrds_error_$long_ident          000066 external static fixed bin(35,0)          dcl 1076 set ref 602* 612* 672* 683*
mrds_error_$parser_logic_error  000042 external static fixed bin(35,0)          dcl 1170 set ref 315*
mrds_error_$parser_stack_overflow
                                000044 external static fixed bin(35,0)          dcl 1173 set ref 188* 305*
mrds_error_$parser_unrecognized_state
                                000046 external static fixed bin(35,0)          dcl 1176 set ref 228*
mrds_error_$sell_syntax         000040 external static fixed bin(35,0)          dcl 1168 set ref 158*
mu_define_area$define_temp_dir_area
                                000054 constant        entry                    external dcl 1193 ref 39
mu_print_error                  000030 constant        entry                    external dcl 1126 ref 447
n                               001456 automatic       fixed bin(17,0)          dcl 1198 set ref 128* 130 131* 131 135 140
name                            000025 constant        char(24)                 initial array level 2 in structure "keyword" packed
                                                                                  packed unaligned dcl 6-16 in procedure
                                                                                  "mrds_dsl_parser" set ref 985 986 1028
name                                   based           char(8)                  array level 2 in structure "short_keyword" dcl 980
                                                                                  in procedure "lookup_token" ref 999
next_state                      001457 automatic       fixed bin(17,0)          dcl 1199 set ref 136* 147* 165 170 200
no_ot_seen                5     001262 automatic       bit(1)                   level 3 dcl 1135 set ref 645*
ns_ptr                   10            based           pointer                  level 3 dcl 1-66 set ref 47*
null                                                   builtin function         dcl 1085 in procedure "scanner" ref 918
null                                                   builtin function         dcl 1200 in procedure "mrds_dsl_parser" ref 47
num_args                               parameter       fixed bin(17,0)          dcl 1124 set ref 7 61*
num_state_table                 001101 constant        fixed bin(17,0)          initial array dcl 5-94 ref 518
option_list                            based           structure                level 1 dcl 4-17
option_list_ptr                        parameter       pointer                  dcl 4-26 set ref 7 61* 447
parse_stack                     001460 automatic       fixed bin(17,0)          array dcl 1201 set ref 178 182 192* 247* 296 299
                                                                                  307* 318
parse_stack_top                 001624 automatic       fixed bin(17,0)          dcl 1202 set ref 51* 74 178 182 191* 191 192 193 244
                                                                                  244 256 256 268 268 268 268 271 271 274 274 280
                                                                                  280 296 299 307 311* 311 312 318
parser_lex_stack                000102 automatic       structure                array level 1 dcl 1133 set ref 61 61 87 87 87 87 117
                                                                                  117 123 123 193* 193 193 193 193 196 196
parser_se_info                  001262 automatic       structure                level 1 dcl 1135 set ref 55* 61 61 447 447
parser_static_info                     based           structure                level 1 dcl 1-66 set ref 44
parser_work_area                       based           area                     dcl 1-63 ref 44
parser_work_area_ptr     74            based           pointer                  level 3 dcl 7-142 set ref 39* 44 46
position                  1     000024 external static fixed bin(18,0)          array level 3 in structure
                                                                                  "mrds_dsl_tables$variables_list" packed packed
                                                                                  unsigned unaligned dcl 3-49 in procedure
                                                                                  "mrds_dsl_parser" ref 418
position                  1(18) 000014 external static fixed bin(18,0)          array level 3 in structure
                                                                                  "mrds_dsl_tables$terminals_list" packed packed
                                                                                  unsigned unaligned dcl 3-23 in procedure
                                                                                  "mrds_dsl_parser" ref 375 375 375 375 378 378 385
                                                                                  385 391 395
production_name                        defined         char                     packed unaligned dcl 412 set ref 418*
production_name_index                  parameter       fixed bin(17,0)          dcl 403 ref 401 407
production_names          1     000022 external static fixed bin(17,0)          array level 2 packed packed unaligned dcl 3-45 ref
                                                                                  406 407
production_number               001625 automatic       fixed bin(17,0)          dcl 1203 set ref 232* 239* 240* 256* 280*
psi_ptr                         000100 automatic       pointer                  dcl 1-65 set ref 44* 46 47 61* 256* 280*
pso_seen                  4     001262 automatic       bit(1)                   level 3 dcl 1135 set ref 649*
pwa_ptr                                based           pointer                  level 2 dcl 1-66 set ref 46*
rank                                                   builtin function         dcl 1085 ref 495 515
scanner_debug                   000011 internal static bit(1)                   initial packed unaligned dcl 1204 set ref 435* 439*
                                                                                  481 499 901
se_array                               based           char(1)                  array packed unaligned dcl 1208 set ref 495 515 532
                                                                                  537 557 562 567 631 724 742 759 776 824 828 836
                                                                                  878 928
se_cursor                 3     001262 automatic       fixed bin(17,0)          level 2 dcl 1135 set ref 59* 274* 483 487 489 495
                                                                                  508 513* 513 515 523 525 551 551 557 562 565 567
                                                                                  567 570 585 590 595 602 602 602 607 609 612 612
                                                                                  616 621 625 627 642* 658 666 671 672 672 675 681
                                                                                  683 683 686 688 696 696 703 706 708 717 717 724
                                                                                  725 735 735 742 743 753 753 759 760 770 770 776
                                                                                  776 778 787 792 796* 800* 800 806 814 820* 820 822
                                                                                  824 828 828 833 833 836 836 839 847 853 862 862
                                                                                  872 878 880 889 937*
se_info                                based           structure                level 1 dcl 1-13
se_len                                 parameter       fixed bin(17,0)          dcl 1121 ref 7 58
se_length                 2     001262 automatic       fixed bin(17,0)          level 2 dcl 1135 set ref 58* 487 508 521 534 551 585
                                                                                  590 602 602 602 607 609 612 612 616 621 658 666
                                                                                  671 672 672 677 681 683 683 696 703 717 735 753
                                                                                  770 787 792 796 806 806 806 814 816 816 822 828
                                                                                  833 862 862 872 901 901 922 939
se_ptr                                 parameter       pointer                  dcl 1120 in procedure "mrds_dsl_parser" ref 7 57
se_ptr                          001262 automatic       pointer                  level 2 in structure "parser_se_info" dcl 1135
                                                                                  in procedure "mrds_dsl_parser" set ref 57* 495 515
                                                                                  532 537 557 562 567 590 602 602 607 612 612 616
                                                                                  621 631 658 671 672 672 681 683 683 703 724 742
                                                                                  759 776 792 806 806 814 816 816 824 828 836 862
                                                                                  862 878 901 901 928 939
se_string                              based           char                     packed unaligned dcl 1205 ref 590 602 602 607 612
                                                                                  612 616 621 658 671 672 672 681 683 683 703 792
                                                                                  806 806 814 816 816 862 862 901 901 939
short_keyword                          based           structure                array level 1 unaligned dcl 980
short_token                     001772 automatic       char(8)                  dcl 976 set ref 992* 1002 1004 1015
sk_ptr                          000012 internal static pointer                  initial dcl 1081 set ref 988* 999
stack_index                            parameter       fixed bin(17,0)          dcl 1067 ref 454 631 634 638 639 901 901 918 920 922
                                                                                  928 931 934 939 950 952
state                           001735 automatic       fixed bin(17,0)          dcl 1083 in procedure "scanner" set ref 504* 508
                                                                                  518* 518 521 523 531 574*
state                     0(09) 001407 automatic       picture(4)               level 2 in structure "db_data" packed packed
                                                                                  unaligned dcl 1149 in procedure "mrds_dsl_parser"
                                                                                  set ref 73*
substr                                                 builtin function         dcl 347 ref 375 375 378 385
sys_info$max_seg_size           000056 external static fixed bin(35,0)          dcl 1211 ref 39
t                               001626 automatic       fixed bin(17,0)          dcl 1212 set ref 244* 247*
temp                            001642 automatic       varying char(100)        dcl 346 set ref 378* 380* 380 387* 389* 389 391* 391
                                                                                  393* 393 395* 397
temp_keyword                    001761 automatic       char(24)                 packed unaligned dcl 975 set ref 1028* 1030 1032
                                                                                  1046
temp_short_keyword              001770 automatic       char(8)                  dcl 976 set ref 999* 1002 1004 1015
terminal                               defined         char                     packed unaligned dcl 364 ref 375 375 375 375 378 378
                                                                                  385 385 391 395
terminal_characters       1     000016 external static char(488)                level 2 packed packed unaligned dcl 3-31 ref 375 375
                                                                                  375 375 375 375 375 375 378 378 378 378 385 385
                                                                                  385 385 391 391 395 395
terminals_list            1     000014 external static structure                array level 2 packed packed unaligned dcl 3-23
test_state                      001627 automatic       fixed bin(17,0)          dcl 1213 set ref 123* 123 135 135 140 140 318* 326
                                                                                  330
test_token                             defined         fixed bin(17,0)          dcl 1214 set ref 123* 135 140
token                           001727 automatic       char(24)                 packed unaligned dcl 1078 in procedure "scanner" set
                                                                                  ref 607* 616* 618* 621* 622* 623* 644 644 648 648
                                                                                  901* 939* 943* 945* 946*
token                                  parameter       char(24)                 packed unaligned dcl 971 in procedure "lookup_token"
                                                                                  ref 957 991 992 1030 1032 1046
token                                  based           char                     packed unaligned dcl 357 in begin block on line 352
                                                                                  ref 380 380 389 389
token                                  parameter       char                     packed unaligned dcl 1057 in procedure
                                                                                  "scanner_error" ref 1053 1062
token_end                       001717 automatic       fixed bin(17,0)          dcl 1070 set ref 489* 521* 523* 525* 532 534 534*
                                                                                  534 537 537* 537 540* 540 551* 565* 567* 570* 595*
                                                                                  625* 627* 634 642 675* 677* 686* 688* 696* 706*
                                                                                  708* 717* 725* 735* 743* 753* 760* 770* 776* 778*
                                                                                  833* 836* 839* 847* 853* 880* 889* 931 937
token_id                               parameter       fixed bin(17,0)          dcl 972 in procedure "lookup_token" set ref 957
                                                                                  1015* 1017* 1046* 1048*
token_id                        001726 automatic       fixed bin(17,0)          dcl 1077 in procedure "scanner" set ref 925* 945*
                                                                                  946 950
token_id                  4     000102 automatic       fixed bin(17,0)          array level 3 in structure "parser_lex_stack"
                                                                                  dcl 1133 in procedure "mrds_dsl_parser" set ref
                                                                                  350 364 375 375 375 375 378 378 385 385 391 395
                                                                                  638* 950*
token_id                  4            defined         fixed bin(17,0)          array level 3 in structure "lookahead" dcl 1140
                                                                                  in procedure "mrds_dsl_parser" ref 123
token_length              2     000102 automatic       fixed bin(17,0)          array level 3 in structure "parser_lex_stack"
                                                                                  dcl 1133 in procedure "mrds_dsl_parser" set ref
                                                                                  268 271* 380 380 389 389 634* 901 901 920* 931*
                                                                                  939 952
token_length             11     001262 automatic       fixed bin(17,0)          level 3 in structure "parser_se_info" dcl 1135
                                                                                  in procedure "mrds_dsl_parser" set ref 271* 634*
                                                                                  952*
token_ptr                       000102 automatic       pointer                  array level 3 dcl 1133 set ref 268 380 380 389 389
                                                                                  631* 918* 928*
token_start              10     001262 automatic       fixed bin(17,0)          level 3 dcl 1135 set ref 483* 631 634 639 806 806
                                                                                  816 816 901 901 928 931 934 939
token_start_pos           3     000102 automatic       fixed bin(17,0)          array level 3 dcl 1133 set ref 274 639* 922* 934*
token_string                    001720 automatic       char(24)                 dcl 1071 set ref 490* 527* 542* 579* 596* 690* 711*
                                                                                  728* 746* 763* 781* 842* 848* 854* 881* 893* 917
                                                                                  939 943
token_type_list                 002145 constant        fixed bin(17,0)          initial array dcl 5-26 ref 495
top                       1(09) 001407 automatic       picture(4)               level 2 packed packed unaligned dcl 1149 set ref 74*
type                      2(27) 001407 automatic       char(6)                  level 2 in structure "db_data" packed packed
                                                                                  unaligned dcl 1149 in procedure "mrds_dsl_parser"
                                                                                  set ref 167* 168* 168 174* 237*
type                            001741 automatic       fixed bin(17,0)          dcl 1083 in procedure "scanner" set ref 495* 499*
                                                                                  501
ub                              001630 automatic       fixed bin(17,0)          dcl 1215 set ref 320* 322 324 332*
unspec                                                 builtin function         dcl 1216 set ref 55* 193* 193
v1                        1     000020 external static fixed bin(17,0)          array level 3 packed packed unaligned dcl 3-35 set
                                                                                  ref 77 128 232 238 241* 242 244 255 295 311 326
                                                                                  330
v2                        1(18) 000020 external static fixed bin(17,0)          array level 3 packed packed unaligned dcl 3-35 ref
                                                                                  80 95 127 136 147 230 320 327 335
value                   674     000025 constant        fixed bin(17,0)          initial array level 2 dcl 6-16 set ref 1015 1046
variable_characters       1     000026 external static char(1076)               level 2 packed packed unaligned dcl 3-54 ref 418 418
variables_list            1     000024 external static structure                array level 2 packed packed unaligned dcl 3-49
variables_list_index            001704 automatic       fixed bin(17,0)          dcl 404 set ref 407* 412 418
where_clause             10            based           structure                level 2 dcl 1-66

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
AV_TYPE                                internal static char(16)                 initial packed unaligned dcl 1-50
RC_TYPE                                internal static char(12)                 initial packed unaligned dcl 1-33
SC_TYPE                                internal static char(13)                 initial packed unaligned dcl 1-38
WCE_TYPE                               internal static char(23)                 initial packed unaligned dcl 1-44
WCF_TYPE                               internal static char(21)                 initial packed unaligned dcl 1-47
WC_TYPE                                internal static char(12)                 initial packed unaligned dcl 1-41
fixed                                                  builtin function         dcl 1161
lex_stack_ptr                          automatic       pointer                  dcl 1137
mode_flags                             based           structure                level 1 dcl 4-9
mode_flags_ptr                         automatic       pointer                  dcl 4-25
mrds_dsl_tables$object_def             external static structure                level 1 dcl 3-58
mrds_dsl_tables$skip                   external static structure                level 1 unaligned dcl 3-40
mrds_dsl_tables$terminals_hash_list    external static structure                level 1 unaligned dcl 3-19
se_info_ptr                            automatic       pointer                  dcl 1139

NAMES DECLARED BY EXPLICIT CONTEXT.
CASE                            000000 constant        label                    array(0:20) dcl 80 ref 77
NEXT                            002617 constant        label                    dcl 67 ref 205 328 336
dbf                             004163 constant        entry                    external dcl 428
dbn                             004151 constant        entry                    external dcl 424
dbsf                            004206 constant        entry                    external dcl 437
dbsn                            004174 constant        entry                    external dcl 433
error                           004574 constant        entry                    internal dcl 442 ref 42 158 188 228 282 284 286 305
                                                                                  315 1063
finish                          006301 constant        label                    dcl 901 ref 492 548 582 655 693 714 732 750 767 784
                                                                                  859 869 886 897
get_terminal                    004216 constant        entry                    internal dcl 342 ref 155 162
got_token                       003065 constant        label                    dcl 162 ref 137 148
load_stack                      006346 constant        entry                    internal dcl 909 ref 491 546 580 597 691 712 729 747
                                                                                  764 782 843 849 855 882 894
lookup_token                    006475 constant        entry                    internal dcl 957 ref 618 622 945
mrds_dsl_parser                 002421 constant        entry                    external dcl 7
not_found                       002766 constant        label                    dcl 145 ref 140
number_entry                    004723 constant        label                    dcl 508 ref 575
parse_done                      004147 constant        label                    dcl 338 ref 67 159 450
print_production_name           004515 constant        entry                    internal dcl 401 ref 240
read_look                       002675 constant        label                    dcl 112 ref 92
scanner                         004630 constant        entry                    internal dcl 454 ref 115
scanner_error                   006667 constant        entry                    internal dcl 1053 ref 602 612 623 672 683 806 816
                                                                                  862 946
start                           004653 constant        label                    dcl 483 ref 646 650 803
token_type                      001036 constant        label                    array(14) dcl 504 ref 501 872 878

NAMES DECLARED BY CONTEXT OR IMPLICATION.
ltrim                                                  builtin function         ref 182 182 299 299
rtrim                                                  builtin function         ref 1062
search                                                 builtin function         ref 537 724 742 759 836
substr                                                 builtin function         ref 590 602 602 607 612 612 616 621 658 671 672 672
                                                                                  681 683 683 703 792 806 806 814 816 816 862 862
                                                                                  901 901 939 992
verify                                                 builtin function         ref 557 562 590 658 703 792

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     10010       10104    7445       10020
Length     10572    7445        74         451     343           4

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_dsl_parser                    1193 external procedure  is an external procedure.  
get_terminal                            internal procedure  shares stack frame of external procedure mrds_dsl_parser.  
begin block on line 352                 begin block         shares stack frame of external procedure mrds_dsl_parser.  
print_production_name                   internal procedure  shares stack frame of external procedure mrds_dsl_parser.  
begin block on line 410                 begin block         shares stack frame of external procedure mrds_dsl_parser.  
error                                72 internal procedure  is called by several nonquick procedures.  
scanner                                 internal procedure  shares stack frame of external procedure mrds_dsl_parser.  
load_stack                              internal procedure  shares stack frame of external procedure mrds_dsl_parser.  
lookup_token                            internal procedure  shares stack frame of external procedure mrds_dsl_parser.  
scanner_error                        74 internal procedure  is called during a stack extension.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 debug                       mrds_dsl_parser
000011 scanner_debug               mrds_dsl_parser
000012 sk_ptr                      scanner

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mrds_dsl_parser          000100 psi_ptr                     mrds_dsl_parser
                         000102 parser_lex_stack            mrds_dsl_parser
                         001262 parser_se_info              mrds_dsl_parser
                         001404 current_state               mrds_dsl_parser
                         001405 current_table               mrds_dsl_parser
                         001406 dbi_pic                     mrds_dsl_parser
                         001407 db_data                     mrds_dsl_parser
                         001445 db_separator                mrds_dsl_parser
                         001446 i                           mrds_dsl_parser
                         001447 lb                          mrds_dsl_parser
                         001450 lookahead_count             mrds_dsl_parser
                         001451 lookahead_get               mrds_dsl_parser
                         001452 lookahead_need              mrds_dsl_parser
                         001453 lookahead_put               mrds_dsl_parser
                         001454 lookahead_use               mrds_dsl_parser
                         001455 m                           mrds_dsl_parser
                         001456 n                           mrds_dsl_parser
                         001457 next_state                  mrds_dsl_parser
                         001460 parse_stack                 mrds_dsl_parser
                         001624 parse_stack_top             mrds_dsl_parser
                         001625 production_number           mrds_dsl_parser
                         001626 t                           mrds_dsl_parser
                         001627 test_state                  mrds_dsl_parser
                         001630 ub                          mrds_dsl_parser
                         001642 temp                        get_terminal
                         001704 variables_list_index        print_production_name
                         001716 done                        scanner
                         001717 token_end                   scanner
                         001720 token_string                scanner
                         001726 token_id                    scanner
                         001727 token                       scanner
                         001735 state                       scanner
                         001736 class                       scanner
                         001737 id                          scanner
                         001740 i                           scanner
                         001741 type                        scanner
                         001756 low                         lookup_token
                         001757 middle                      lookup_token
                         001760 high                        lookup_token
                         001761 temp_keyword                lookup_token
                         001770 temp_short_keyword          lookup_token
                         001772 short_token                 lookup_token
                         001774 done                        lookup_token

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this
call_int_other      return_mac          tra_ext_1           signal_op           shorten_stack       ext_entry
int_entry           int_entry_desc      verify_eis          search_eis          op_alloc_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ioa_                          ioa_$nnl                      ioa_$nnl                      mrds_dsl_semantics
mrds_dsl_semantics$init       mu_define_area$define_temp_dir_area                         mu_print_error

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
mrds_data_$max_id_len         mrds_dsl_tables$dpda          mrds_dsl_tables$production_names
mrds_dsl_tables$terminal_characters                         mrds_dsl_tables$terminals_list
mrds_dsl_tables$variable_characters                         mrds_dsl_tables$variables_list
mrds_error_$bad_attr          mrds_error_$bad_var           mrds_error_$inv_string        mrds_error_$inv_token
mrds_error_$long_ident        mrds_error_$parser_logic_error
mrds_error_$parser_stack_overflow                           mrds_error_$parser_unrecognized_state
mrds_error_$sell_syntax       sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      7 002411        38 002426        39 002441        42 002506        44 002517        46 002527        47 002534
     49 002536        50 002540        51 002543        52 002544        53 002545        55 002546        57 002551
     58 002554        59 002556        61 002560        67 002617        70 002621        71 002622        72 002625
     73 002630        74 002637        77 002646        80 002650        84 002654        87 002657        90 002663
     92 002664        95 002665       104 002671       109 002673       112 002675       115 002701       117 002707
    119 002713       120 002715       121 002716       123 002717       126 002723       127 002724       128 002741
    130 002745       131 002746       132 002750       135 002752       136 002755       137 002762       140 002763
    142 002764       145 002766       147 002770       148 002775       151 002776       153 003017       154 003021
    155 003024       158 003054       159 003064       162 003065       165 003075       166 003077       167 003102
    168 003105       170 003114       171 003116       173 003117       174 003122       175 003125       178 003127
    180 003132       181 003134       182 003137       188 003254       191 003263       192 003264       193 003267
    196 003302       198 003306       199 003310       200 003312       203 003314       205 003335       208 003336
    228 003337       230 003345       232 003354       236 003361       237 003363       238 003366       239 003373
    240 003415       241 003417       242 003443       243 003451       244 003453       247 003465       248 003511
    249 003513       250 003516       252 003531       255 003544       256 003552       258 003567       268 003577
    270 003614       271 003615       274 003624       277 003631       278 003632       280 003635       282 003651
    283 003662       284 003663       285 003671       286 003672       295 003700       296 003706       297 003711
    298 003713       299 003716       305 004033       307 004042       311 004045       312 004055       314 004057
    315 004060       318 004066       319 004071       320 004074       322 004103       324 004107       326 004112
    327 004120       328 004125       330 004126       332 004133       333 004136       335 004137       336 004146
    338 004147       424 004150       426 004156       427 004161       428 004162       430 004170       431 004172
    433 004173       435 004201       436 004204       437 004205       439 004213       440 004215       342 004216
    350 004220       364 004233       375 004246       378 004272       380 004304       384 004361       385 004363
    387 004371       389 004376       391 004422       393 004435       394 004444       395 004445       397 004501
    399 004511       401 004515       406 004517       407 004521       412 004540       418 004545       421 004572
    442 004573       446 004601       447 004607       450 004625       454 004630       481 004632       483 004653
    487 004655       489 004660       490 004661       491 004664       492 004665       495 004666       499 004676
    501 004717       504 004721       508 004723       513 004731       515 004732       517 004742       518 004746
    519 004753       521 004754       523 004761       525 004766       527 004771       531 004774       532 004776
    534 005004       537 005012       540 005025       542 005027       546 005032       548 005033       551 005034
    557 005042       560 005054       562 005055       565 005065       567 005071       570 005102       572 005104
    574 005105       575 005107       579 005110       580 005113       582 005114       585 005115       590 005123
    593 005140       595 005142       596 005144       597 005147       598 005150       601 005151       602 005153
    607 005212       609 005225       610 005231       612 005232       616 005264       618 005273       620 005275
    621 005277       622 005304       623 005306       625 005325       626 005327       627 005330       631 005334
    634 005345       638 005360       639 005365       642 005372       644 005375       645 005405       646 005407
    648 005410       649 005420       650 005422       655 005423       658 005424       666 005452       671 005462
    672 005474       675 005522       676 005526       677 005527       679 005532       681 005535       683 005547
    686 005574       687 005600       688 005601       690 005604       691 005607       693 005610       696 005611
    703 005616       706 005631       708 005636       711 005641       712 005644       714 005645       717 005646
    724 005653       725 005664       728 005666       729 005671       732 005672       735 005673       742 005700
    743 005711       746 005713       747 005716       750 005717       753 005720       759 005725       760 005736
    763 005740       764 005743       767 005744       770 005745       776 005752       778 005762       781 005763
    782 005766       784 005767       787 005770       792 005775       796 006005       800 006013       803 006014
    806 006015       812 006053       813 006055       814 006060       816 006075       820 006130       822 006135
    824 006142       826 006151       828 006152       833 006162       836 006166       839 006201       842 006204
    843 006207       844 006210       847 006211       848 006213       849 006216       850 006217       853 006220
    854 006222       855 006225       859 006226       862 006227       869 006252       872 006253       878 006256
    880 006263       881 006265       882 006270       886 006271       889 006272       893 006274       894 006277
    897 006300       901 006301       907 006344       909 006346       917 006347       918 006353       920 006361
    922 006362       925 006367       926 006371       928 006372       931 006403       934 006410       937 006415
    939 006420       943 006435       945 006440       946 006443       950 006462       952 006470       955 006474
    957 006475       985 006477       986 006501       987 006503       988 006506       989 006511       991 006512
    992 006525       993 006530       995 006532       999 006540      1002 006547      1004 006551      1006 006556
   1008 006561      1010 006565      1011 006566      1013 006570      1015 006571      1017 006601      1019 006603
   1023 006604      1024 006606      1028 006614      1030 006623      1032 006631      1034 006637      1036 006642
   1038 006646      1039 006647      1042 006651      1046 006652      1048 006664      1051 006665      1053 006666
   1059 006702      1060 006710      1061 006712      1062 006715      1063 006756      1065 006767


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
