	COMPILATION LISTING OF SEGMENT create_seg_ptrs
	Compiled by: Multics PL/I Compiler, Release 33a, of May 30, 1990
	Compiled at: ACTC Technologies Inc.          
	Compiled on: 10/16/90  1517.7 mdt Tue
	    Options: optimize map

        1 /****^  *********************************************************
        2*        *                                                       *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1990 *
        4*        *                                                       *
        5*        * Copyright (c) 1972 by Massachusetts Institute of      *
        6*        * Technology and Honeywell Information Systems, Inc.    *
        7*        *                                                       *
        8*        ********************************************************* */
        9 
       10 
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(90-10-12,Zimmerman), approve(90-10-12,MCR8216),
       16*     audit(90-10-15,Zwick), install(90-10-16,MR12.4-1043):
       17*     Data_Mgt 63 (phx21194): Raise the max number of components in an MSF to
       18*     1250.
       19*                                                   END HISTORY COMMENTS */
       20 
       21 
       22 
       23 
       24 /* Changed 6/13/77 for even-word aligned allocations to have
       25*   correct max_record_size */
       26 /*
       27*Modified:
       28*07/14/81 by Lindsey Spratt:  In get_seg_ptr, when closing the current fcb and
       29*	  re-opening, set the fcbp in the attach block as well as the
       30*	  fcb_ptr in the indx_cb, since the fcb may have moved.
       31*	       Change from using the iocbv include file to the iocb.incl.pl1
       32*	  include file.  This is necessary because the iocbv.incl.pl1
       33*	  include file has been deleted from the system as obsolete.
       34*11/16/82 by Lindsey Spratt:  Changed to extend the seg_ptr_array when an
       35*	  attempt to get a seg_ptr for a compnum >= seg_ptr_array_limit is
       36*	  made via the get_seg_ptr entry.
       37*02/05/85 by Steve Herbst: Fixed $get_seg_ptr to reinitialize file information
       38*	  when the file has been closed and reopened because
       39*	  msf_manager_$get_ptr has failed. Fixes bug allowing KST overflow
       40*	  to damage files.
       41**/
       42 
       43 /* format: style2,ind3 */
       44 create_seg_ptrs:
       45    proc (iocb_ptr);
       46       begin;
       47          indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
       48          f_b_ptr = file_base_ptr;
       49          if file_version = 10				/* previous file version */
       50          then
       51 	  do;					/* use old version file base info */
       52 	     comp_number = old_version_index_tail_comp_num;
       53 	     comp_info_ptr = addr (old_version_comp_info);
       54 	  end;
       55          else
       56 	  do;
       57 	     index_state_ptr = addr (index_state_blocks (index_state));
       58 	     is_ptr = index_state_ptr;
       59 	     comp_number = index_tail_comp_num;
       60 	     comp_info_ptr = addr (file_base.max_comp_num);
       61 	  end;
       62          seg_ptr_array_limit = comp_info.last_comp_num + 2; /* allow 2 for growth, note: this must
       63*						   be large enough for alloc_cb_file */
       64          call alloc_cb_file (size (seg_ptr_array), seg_ptr_array_ptr);
       65          seg_ptr_array = null;
       66          seg_ptr_array (0) = f_b_ptr;
       67          do while (comp_number > 0);			/* initiate additional index components */
       68 	  p = get_seg_ptr (iocb_ptr, comp_number);	/* sets value in seg_ptr_array */
       69 	  if file_version <= 30			/* old version comp_table */
       70 	  then comp_number = old_comp_info.comp_link (comp_number);
       71 	  else comp_number = comp_info.comp_link (comp_number);
       72          end;
       73          node_length = 4 * node_size;
       74          half_node_length = 2 * node_size;
       75          if file_version >= 40			/* latest version doesn't waste first two words */
       76          then max_record_size = 4 * max_seg_limit - 8;	/* compare with seq files */
       77          else max_record_size = 4 * max_seg_limit - 16;
       78          rover_seg_ptr = get_seg_ptr (iocb_ptr, rover_comp_num);
       79          old_last_comp_num = comp_info.last_comp_num;
       80          old_rover_comp_num = rover_comp_num;
       81          return;
       82 
       83          dcl     comp_info_ptr	ptr;
       84          dcl     1 comp_info		based (comp_info_ptr),
       85 	         2 max_comp_num	fixed,
       86 	         2 last_comp_num	fixed,
       87 	         2 first_free_comp_num
       88 				fixed,
       89 	         2 comp_table	(0:true_max_comp_num) aligned,
       90 		 3 seg_limit	fixed (19),
       91 		 3 comp_link	fixed (17) unal,
       92 		 3 init_offset	fixed (18) unsigned unal;
       93          dcl     1 old_comp_info	based (comp_info_ptr),
       94 	         2 max_comp_num	fixed,
       95 	         2 last_comp_num	fixed,
       96 	         2 first_free_comp_num /* not supported--used for converting versions */,
       97 	         2 comp_table	(0:true_max_comp_num),
       98 		 3 seg_limit	fixed (19),
       99 		 3 comp_link	fixed (15) unal,
      100 		 3 init_offset	fixed (18) unal;
      101       end;					/* end of create_seg_ptrs routine */
      102 
      103 free_seg_ptrs:
      104    entry (iocb_ptr);
      105       indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
      106       call free_cb_file (size (seg_ptr_array), seg_ptr_array_ptr);
      107       return;
      108 
      109 get_new_seg:
      110    entry (iocb_ptr, comp_num, seg_ptr, substate_arg, abort_exit);
      111       indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
      112       f_b_ptr = file_base_ptr;
      113       fs_ptr = file_state_ptr;			/* not yet supported
      114*						   if first_free_comp_num^=0 then do; use existing component
      115*						   comp_num=first_free_comp_num;
      116*						   first_free_comp_num=comp_link(comp_num);
      117*						   call msf_manager_$get_ptr(fcb_ptr,comp_num,"0"b,seg_ptr,foo24,foo);
      118*						   seg_ptr_array(comp_num)=seg_ptr;
      119*						   end;
      120*						   */
      121 						/* else */
      122       do;						/* create new component */
      123          if comp_num >= max_comp_num
      124          then if max_comp_num < true_max_comp_num
      125               then max_comp_num = true_max_comp_num;
      126               else go to abort_exit;
      127          if comp_num >= seg_ptr_array_limit
      128          then call extend_seg_ptr_array (1);
      129          last_comp_num = comp_num;
      130          call adjust_if_nec;
      131          call set_new_ptr;
      132          old_last_comp_num = last_comp_num;
      133       end;
      134       return;					/* end get new seg */
      135 
      136 /* not yet supported
      137*   free_seg:entry(iocb_ptr,comp_num,seg_ptr); the segment must already be zeroed
      138*   indx_cb_ptr=iocb_ptr->iocb.open_data_ptr;
      139*   f_b_ptr=file_base_ptr;
      140*   seg_ptr_array(comp_num)=null;
      141*   call hcs_$set_bc_seg(seg_ptr,0,foo);
      142*   seg_limit(comp_num)=0;
      143*   comp_link(comp_num)=first_free_comp_num;
      144*   first_free_comp_num=comp_num;
      145*   return;
      146*   */
      147 
      148 adjust_if_nec:
      149    proc;
      150       if repeating
      151       then
      152          do;
      153 	  call check_substate;
      154 	  if substate_arg = next_substate
      155 	  then call msf_manager_$adjust (fcb_ptr, comp_num - 1, foo24, "000"b, foo);
      156 	  return;
      157          end;
      158       substate_arg = substate_arg + 1;
      159    end adjust_if_nec;
      160 
      161 set_new_ptr:
      162    proc;
      163       if repeating
      164       then
      165          do;
      166 	  call check_substate;
      167 	  seg_ptr = get_seg_ptr (iocb_ptr, comp_num);
      168 	  return;
      169          end;
      170       call msf_manager_$get_ptr (fcb_ptr, comp_num, "1"b, seg_ptr, foo24, foo);
      171       if seg_ptr = null				/* unable to get new component */
      172       then
      173          do;
      174 	  if foo ^= 0
      175 	  then call sub_err_ (foo, "vfile_", "c", null, foo, "Unable to create a new msf component.");
      176 	  return;
      177          end;
      178       seg_ptr_array (comp_num) = seg_ptr;
      179       substate_arg = substate_arg + 1;
      180    end set_new_ptr;
      181 
      182 check_substate:
      183    proc;
      184       next_substate = next_substate + 1;
      185       if substate_arg = next_substate
      186       then repeating = "0"b;				/* execution resumes normally */
      187    end check_substate;
      188 
      189 set_bitcounts:
      190    entry (iocb_ptr);
      191       indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
      192       f_b_ptr = file_base_ptr;
      193       do i = 0 to last_comp_num;
      194          if seg_limit (i) > 0
      195          then
      196 	  do;
      197 	     if seg_ptr_array (i) = null
      198 	     then call msf_manager_$get_ptr (fcb_ptr, i, "0"b, seg_ptr_array (i), foo24, foo);
      199 	     call hcs_$set_bc_seg (seg_ptr_array (i), 36 * seg_limit (i), foo);
      200 	     if foo = 0
      201 	     then seg_limit (i) = -seg_limit (i);
      202 	  end;
      203       end;
      204       return;					/* end set_bitcounts code */
      205 
      206 get_seg_ptr:
      207    entry (iocb_ptr, comp_num) returns (ptr);
      208       indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
      209       if comp_num >= seg_ptr_array_limit
      210       then call extend_seg_ptr_array (comp_num - seg_ptr_array_limit + 1);
      211       if seg_ptr_array (comp_num) = null
      212       then
      213          do;
      214 	  call msf_manager_$get_ptr (fcb_ptr, comp_num, "0"b, p, foo24, foo);
      215 	  if p = null				/* unexpected failure */
      216 	  then if atb.shared			/* maybe due to an asynch change */
      217 	       then
      218 		do;				/* in case msf_manager_ bug has struck */
      219 		   call msf_manager_$close (indx_cb.fcb_ptr);
      220 						/*
      221*						   try closing and reopening msf */
      222 		   call
      223 		      msf_manager_$open (substr (attach_descrip_string, 8, dname_len),
      224 		      substr (attach_descrip_string, 9 + dname_len, ename_len), indx_cb.fcb_ptr, foo);
      225 		   iocb_ptr -> iocb.attach_data_ptr -> atb.fcbp = indx_cb.fcb_ptr;
      226 						/* The fcb may have moved */
      227 						/* between closing and opening,*/
      228 						/* so the attach_block ptr must be updated.*/
      229 		   seg_ptr_array (*) = null;		/* reinitialize file info */
      230 		   call msf_manager_$get_ptr (indx_cb.fcb_ptr, 0, "0"b, seg_ptr_array (0), foo24, foo);
      231 		   indx_cb.file_base_ptr = seg_ptr_array (0);
      232 		   iocb_ptr -> iocb.attach_data_ptr -> atb.fsp = seg_ptr_array (0);
      233 
      234 		   call msf_manager_$get_ptr (indx_cb.fcb_ptr, comp_num, "0"b, p, foo24, foo);
      235 						/* try one more time */
      236 		end;
      237 	  if (p = null) & (foo ^= 0) then do;
      238 	       if (true_max_comp_num > comp_num) & (foo = error_table_$noentry) then;   /* Do nothing: this file has hit limit before, */
      239 	       else                                                                     /* but can now be extended.  */
      240 		  call sub_err_ (foo, "vfile_", "c", null, foo, "Can't get a pointer to this msf component.");
      241 	  end;
      242 	  
      243 	  else seg_ptr_array (comp_num) = p;
      244          end;
      245       return (seg_ptr_array (comp_num));		/* end get_seg_ptr */
      246 
      247 make_designator:
      248    entry (comp_num, offset, designator);
      249       designator_struct.comp_num = comp_num;
      250       designator_struct.offset = bit (offset);
      251       return;					/* end make designator */
      252 
      253 extend_seg_ptr_array:
      254    proc (p_number_of_new_components);
      255       dcl	    p_number_of_new_components
      256 			       fixed bin;
      257       dcl	    comp_idx	       fixed bin;
      258       old_array_limit = seg_ptr_array_limit;
      259       old_array_ptr = seg_ptr_array_ptr;
      260       seg_ptr_array_limit = seg_ptr_array_limit + p_number_of_new_components;
      261       call alloc_cb_file (size (seg_ptr_array), seg_ptr_array_ptr);
      262       do comp_idx = 0 to old_array_limit;
      263          seg_ptr_array (comp_idx) = old_array (comp_idx);
      264       end;
      265       do comp_idx = old_array_limit + 1 to seg_ptr_array_limit;
      266          seg_ptr_array (comp_idx) = null;
      267       end;
      268       call free_cb_file (size (old_array), old_array_ptr);
      269       return;
      270 
      271       dcl	    old_array_limit	       fixed;
      272       dcl	    old_array_ptr	       ptr;
      273       dcl	    old_array	       (0:old_array_limit) ptr based (old_array_ptr);
      274    end;						/* end extend_seg_ptrs */
      275 
      276       dcl	    substate_arg	       fixed;
      277       dcl	    (comp_num, comp_number)
      278 			       fixed;
      279       dcl	    p		       ptr;
      280       dcl	    i		       fixed;
      281       dcl	    foo		       fixed (35);
      282       dcl	    foo24		       fixed (24);
      283       dcl	    offset	       fixed (18);
      284       dcl	    abort_exit	       label;
      285 
      286       dcl	    pos_ptr	       ptr defined (file_position_ptr);
      287 						/* not used in this module */
      288 
      289       dcl	    hcs_$set_bc_seg	       entry (ptr,		/* pointer to seg, input */
      290 			       fixed bin (24),	/* bit count to be set */
      291 			       fixed bin (35));	/* status code */
      292       dcl	    sub_err_	       entry options (variable);
      293       dcl	    msf_manager_$close     entry (ptr);
      294       dcl	    msf_manager_$open      entry (char (*), char (*), ptr, fixed (35));
      295       dcl	    msf_manager_$get_ptr   entry (ptr,		/* fcb_ptr */
      296 			       fixed bin,		/* component number of desired segment */
      297 			       bit (1),		/* create switch */
      298 			       ptr,		/* ptr to seg or null if error, output */
      299 			       fixed bin (24),	/* bitcount of segment, output */
      300 			       fixed bin (35));	/* status code */
      301       dcl	    msf_manager_$adjust    entry (ptr, fixed, fixed (24), bit (3), fixed (35));
      302       dcl     error_table_$noentry  fixed bin(35) ext static;
      303    
  1     1 /* the control block */
  1     2      dcl	   indx_cb_ptr	      ptr;
  1     3      dcl	   1 indx_cb	      based (indx_cb_ptr),	/* except as noted, init by create cb */
  1     4 	     2 fcb_ptr	      ptr,
  1     5 	     2 file_base_ptr      ptr,
  1     6 	     2 node_length	      fixed,		/* number of bytes in node, init by create_seg_ptrs */
  1     7 	     2 half_node_length   fixed,		/* init by create_seg_ptrs */
  1     8 	     2 max_record_size    fixed (21),		/* init by create_seg_ptrs */
  1     9 	     2 seg_ptr_array_ptr  ptr,		/* init by create seg_ptrs */
  1    10 	     2 seg_ptr_array_limit
  1    11 			      fixed,		/* init by create seg_ptrs */
  1    12 	     2 mode	      fixed,
  1    13 	     2 is_sequential_open bit (1) aligned,
  1    14 	     2 is_read_only	      bit (1) aligned,
  1    15 	     2 is_ks_out	      bit (1) aligned,	/* position info */
  1    16 	     2 position_stack_ptr ptr,		/* init by create_position stack */
  1    17 	     2 position_stack_height
  1    18 			      fixed,		/* init by create position stack */
  1    19 	     2 root_position_ptr  ptr,		/* init by create_position_stack */
  1    20 	     2 file_position_ptr  ptr,		/* not init */
  1    21 	     2 change_position_ptr
  1    22 			      ptr,		/* not init */
  1    23 						/* auxiliary variables  */
  1    24 	     2 rover_seg_ptr      ptr,		/* init by create_seg_ptrs */
  1    25 	     2 index_state_ptr    ptr,		/* init by create_seg_ptrs */
  1    26 	     2 old_index_height   fixed,
  1    27 	     2 old_last_comp_num  fixed,
  1    28 	     2 last_change_count  fixed (35),
  1    29 	     2 wait_time	      fixed (35),
  1    30 	     2 old_rover_comp_num fixed,
  1    31 	     2 file_state_ptr     ptr,
  1    32 	     2 o_s_ptr	      ptr,
  1    33 	     2 repeating	      bit (1) aligned,
  1    34 	     2 next_substate      fixed,
  1    35 	     2 file_program_version
  1    36 			      fixed,		/* used for record_lock compatibility */
  1    37 	     2 leave_locked	      bit (1) aligned,	/* indicates use of set_file_lock order */
  1    38 	     2 dup_ok	      bit (1) aligned,	/* if set, duplicate keys may occur */
  1    39 	     2 read_exclu	      bit (1) aligned,	/* set when lock excludes readers */
  1    40 	     2 pos_incorrect      bit (1) aligned,	/* indicates index position is not current */
  1    41 	     2 saved_lock_copy    bit (36) aligned,	/* copy of process lock_id */
  1    42 	     2 min_key_len	      fixed,		/* non-zero only in old programs */
  1    43 	     2 stat	      bit (1) aligned,	/* causes write_record to create stationary records */
  1    44 	     2 current_subset     fixed (34),		/* used with select order */
  1    45 	     2 last_subset	      fixed (34),
  1    46 	     2 subset_count	      fixed (34),		/* count of descriptors in current subset */
  1    47 	     2 temp_iocbp	      ptr,		/* temporary file used to implement select order */
  1    48 	     2 trans	      bit (1) aligned,	/* set if -transaction attachment */
  1    49 	     2 transaction_code   fixed (35),		/* set for control switch only */
  1    50 	     2 tcfp	      ptr,		/* ptr to iocb for transaction control switch--if applicable */
  1    51 	     2 reflp	      ptr,		/* ptr to ref list file, set only in transaction control file */
  1    52 	     2 uid	      bit (36) aligned,	/* used under -transaction */
  1    53 	     2 collection_delay_time
  1    54 			      fixed (35),		/* microseconds to wait before garbage removal */
  1    55 	     2 min_res	      fixed (21),		/* for min_block_size order */
  1    56 	     2 min_cap	      fixed (21),		/* also for min_block_size order */
  1    57 	     2 subset_selected    bit (2) aligned,	/* first bit for select, second
  1    58*						   bit is for exclude */
  1    59 	     2 error,				/* for error_status order */
  1    60 	       3 type	      fixed,		/* only one error type supported now */
  1    61 	       3 requested	      fixed (34),		/* skip arg given to position entry */
  1    62 	       3 received	      fixed (34),		/* actual successful skips */
  1    63 	     2 state_vars,
  1    64 	       3 fixed_state_part,
  1    65 	         4 shared	      bit (1) aligned,
  1    66 	         4 next_record_position
  1    67 			      fixed,		/* 0, 1, or 2 */
  1    68 	         4 current_record_is_valid
  1    69 			      bit (1) aligned,
  1    70 	         4 ready_to_write bit (1) aligned,
  1    71 	         4 at_eof_or_bof,
  1    72 		 5 at_bof	      bit (1) unal,
  1    73 		 5 at_eof	      bit (1) unal,
  1    74 		 5 pad	      bit (36) unal,
  1    75 	         4 outside_index  bit (1) aligned,	/* set after deleting current key or after use of record_status with locate switch */
  1    76 	         4 current_descrip
  1    77 			      fixed (35),		/* needed when outside index */
  1    78 	         4 saved_descrip  fixed (35),		/* for restoring index position */
  1    79 	         4 skip_state     fixed,		/* controls scanning of deleted entries */
  1    80 	       3 new_key	      char (256) var;
  1    81 
  1    82      dcl	   current_t_code	      fixed (35) based (addr (indx_cb.tcfp -> iocb.open_data_ptr -> indx_cb.transaction_code));
  1    83 
  1    84 /* component locator structures */
  1    85      dcl	   seg_ptr_array	      (0:seg_ptr_array_limit) ptr based (seg_ptr_array_ptr);
  1    86      dcl	   seg_ptr	      ptr;
  1    87      dcl	   seg_array	      (0:262143) fixed (19) based (seg_ptr) aligned;
  1    88      dcl	   designator	      fixed (35);
  1    89      dcl	   1 ind_des_structure    based,
  1    90 	     2 comp	      fixed (17) unal,
  1    91 	     2 offset	      bit (18) unal;
  1    92      dcl	   1 stat_structure	      based,
  1    93 	     2 pad	      bit (26) unal,
  1    94 	     2 ref_count_after    fixed (16) unsigned unal,
  1    95 	     2 ind_comp	      fixed (13) unal,
  1    96 	     2 ref_count	      fixed (16) unsigned unal,
  1    97 	     2 record_lock	      bit (36) aligned,
  1    98 	     2 modifier	      fixed (35),
  1    99 	     2 time_stamp_words   fixed (71) aligned,
  1   100 	     2 prev_mod	      fixed (35),
  1   101 	     2 record	      char (1000000) var;
  1   102      dcl	   1 ind_structure	      based,
  1   103 	     2 pad	      bit (26) unal,
  1   104 	     2 ref_count_after    fixed (16) unsigned unal,
  1   105 	     2 ind_comp	      fixed (13) unal,
  1   106 	     2 ref_count	      fixed (16) unsigned unal,
  1   107 	     2 record_lock	      bit (36) aligned,
  1   108 	     2 modifier	      fixed (35),
  1   109 	     2 time_stamp_words   fixed (71) aligned,
  1   110 	     2 prev_mod	      fixed (35),
  1   111 	     2 prev_desc	      fixed (35);
  1   112      dcl	   1 time_stamp_structure based,
  1   113 	     2 ind_offset	      bit (18) unal,
  1   114 	     2 time_last_modified fixed (54) unsigned unal;
  1   115      dcl	   1 record_block_structure
  1   116 			      based,
  1   117 	     2 reserved	      aligned,		/* data used by change_record_list */
  1   118 	       3 pad	      bit (2) unal,
  1   119 	       3 block_size	      fixed (19) unal,
  1   120 	       3 lock_flag	      bit (1) unal,		/* record lock flag */
  1   121 	       3 stationary	      bit (1) unal,
  1   122 	       3 indirect	      bit (1) unal,
  1   123 	       3 after_applies    bit (1) unal,
  1   124 	       3 mbz	      bit (10) unal,
  1   125 	     2 block_tail,				/* structure varies with record type */
  1   126 	       3 record	      char (1000000) var;	/* non-stat record location */
  1   127      dcl	   1 designator_struct    aligned based (addr (designator)),
  1   128 	     2 comp_num	      fixed (17) unal,
  1   129 	     2 offset	      bit (18) unal;
  1   130 
  1   131 /* position and node templates */
  1   132      dcl	   1 position_frame	      based (pos_ptr),	/* ref8 */
  1   133 	     2 parent_position_ptr
  1   134 			      ptr,
  1   135 	     2 son_position_ptr   ptr,
  1   136 	     2 node_ptr	      ptr,
  1   137 	     2 node	      fixed (35),
  1   138 	     2 branch_num	      fixed;
  1   139      dcl	   1 node_block	      based (node_ptr),	/* ref9) */
  1   140 	     2 last_branch_num    fixed,
  1   141 	     2 low_key_pos	      fixed,
  1   142 	     2 scat_space	      fixed,
  1   143 	     2 branch_and_descrip (1 refer (node_block.last_branch_num)),
  1   144 						/* in last element only branch is used */
  1   145 	       3 branch	      fixed (35),
  1   146 	       3 descrip,
  1   147 	         4 key_descrip,
  1   148 		 5 key_pos      fixed (17) unal,
  1   149 		 5 key_length   fixed (17) unal,
  1   150 	         4 record_descrip,
  1   151 		 5 record_designator
  1   152 			      fixed (35);
  1   153      dcl	   keys		      char (4096 /* 4*node_size */) based (node_ptr);
  1   154 
  1   155 /* file base and states */
  1   156      dcl	   f_b_ptr	      ptr;
  1   157      dcl	   1 file_base	      based (f_b_ptr),	/* ref10 */
  1   158 	     2 common_header,
  1   159 	       3 file_code	      fixed (35),
  1   160 	       3 lock_word	      bit (36) aligned,
  1   161 	       3 words	      (2) fixed,
  1   162 	     2 file_version	      fixed,
  1   163 	     2 program_version    fixed,
  1   164 	     2 node_size	      fixed (19),
  1   165 	     2 minimum_key_length fixed,
  1   166 	     2 minimum_block_size fixed (19),
  1   167 	     2 max_seg_limit      fixed (19),
  1   168 	     2 root_node_block,
  1   169 	       3 last_branch_num_root
  1   170 			      fixed,		/* =1 */
  1   171 	       3 word	      fixed,
  1   172 	       3 reserved	      fixed,
  1   173 	       3 only_branch_in_root
  1   174 			      fixed (35),
  1   175 	     2 file_state	      fixed,
  1   176 	     2 change_count	      fixed (34),		/* record state info, ref12 */
  1   177 	     2 old_number_of_free_blocks
  1   178 			      fixed (34),
  1   179 	     2 prior_block_size   fixed (19),
  1   180 	     2 old_record_length  fixed (21),
  1   181 	     2 need_new_seg	      bit (1) aligned,
  1   182 	     2 old_residue	      fixed,
  1   183 	     2 new_last_comp_num  fixed,
  1   184 	     2 old_prev_free_block
  1   185 			      fixed (18),
  1   186 	     2 old_next_free_block
  1   187 			      fixed (18),
  1   188 	     2 new_record_length  fixed (21),
  1   189 	     2 old_record_designator
  1   190 			      fixed (35),
  1   191 	     2 prec_block_was_free
  1   192 			      bit (1) aligned,
  1   193 	     2 next_block_was_free
  1   194 			      bit (1) aligned,
  1   195 	     2 former_block_size  fixed (19),
  1   196 	     2 old_init_offset    fixed (18),
  1   197 	     2 old_block_size     fixed (19),
  1   198 	     2 prev_block_size    fixed (19),
  1   199 	     2 former_rover_comp_num
  1   200 			      fixed,
  1   201 	     2 former_rover_offset
  1   202 			      fixed (18),
  1   203 	     2 next_block_size    fixed (19),
  1   204 	     2 next_prev_free_block
  1   205 			      fixed (18),
  1   206 	     2 next_next_free_block
  1   207 			      fixed (18),
  1   208 	     2 saved_ks_out	      bit (1) aligned,
  1   209 	     2 new_descriptor     fixed (35),
  1   210 	     2 old_last_branch_num
  1   211 			      fixed,
  1   212 	     2 old_low_key_pos    fixed,
  1   213 	     2 old_scat_space     fixed,
  1   214 	     2 old_key_pos	      fixed,
  1   215 	     2 rover_comp_num     fixed,
  1   216 	     2 rover_offset	      fixed (18),
  1   217 	     2 old_key_length     fixed,
  1   218 	     2 b_space	      fixed,
  1   219 	     2 last_b_num	      fixed,
  1   220 	     2 count	      fixed,
  1   221 	     2 first_count	      fixed,
  1   222 	     2 second_count	      fixed,
  1   223 	     2 split_num	      fixed,
  1   224 	     2 must_compact_dest  bit (1) aligned,
  1   225 	     2 first_branch	      fixed (35),
  1   226 	     2 min_source_key_pos fixed,
  1   227 	     2 min_dest_key_pos   fixed,
  1   228 	     2 new_low_key_pos    fixed,
  1   229 	     2 new_scat_space     fixed,
  1   230 	     2 old_seg_lim	      fixed (19),
  1   231 	     2 old_number_of_free_nodes
  1   232 			      fixed,
  1   233 	     2 old_next_node_designator
  1   234 			      fixed (35),
  1   235 	     2 new_index_comp_num fixed,
  1   236 	     2 out_of_index	      bit (1) aligned,
  1   237 	     2 saved_min_res      fixed (21),
  1   238 	     2 saved_min_cap      fixed (21),
  1   239 	     2 was_stat	      bit (1) aligned,
  1   240 	     2 was_ind	      bit (1) aligned,
  1   241 	     2 old_ind_desc	      fixed (35),
  1   242 	     2 after_desc	      fixed (35),
  1   243 	     2 old_ref_count      fixed (34),
  1   244 	     2 new_ref_count      fixed (34),
  1   245 	     2 old_num_free	      fixed (34),
  1   246 	     2 old_file_ch_count  fixed (35),
  1   247 	     2 y_count,				/* for conversion of pre-MR6.9 files */
  1   248 	     2 old_modifier	      fixed (35),
  1   249 	     2 was_transaction    bit (1) aligned,	/* state blocks */
  1   250 	     2 index_state	      fixed,
  1   251 	     2 index_state_blocks (0:1),
  1   252 	       3 words	      (104),
  1   253 	     2 reserved	      (30),		/* this free space might come in handy */
  1   254 	     2 old_prev_mod	      fixed (35),
  1   255 	     2 needed_blksz	      fixed (35),
  1   256 	     2 new_desc_val	      fixed (35),
  1   257 	     2 is_partial_deletion
  1   258 			      bit (1) aligned,
  1   259 	     2 reserved2	      (42),
  1   260 	     2 file_state_blocks  (0:1),
  1   261 	       3 words	      (size (file_state_block)) fixed,
  1   262 						/* component info */
  1   263 	     2 max_comp_num	      fixed,
  1   264 	     2 last_comp_num      fixed,
  1   265 	     2 first_free_comp_num,			/* not yet supported */
  1   266 	     2 comp_table_start   (size (comp_table));	/* start of comp_array */
  1   267 
  1   268      dcl	   1 comp_table	      (0:true_max_comp_num) based (addr (file_base.comp_table_start)) aligned,
  1   269 	     2 seg_limit	      fixed (19),		/* abs value is offset of first free word in seg, max val=max
  1   270*						   seg_limit and this indicates full seg */
  1   271 	     2 comp_link	      fixed (17) unal,
  1   272 	     2 init_offset	      fixed (18) unsigned unal;
  1   273 
  1   274      dcl	   1 file_header	      based (f_b_ptr),
  1   275 	     2 first_three_pages  (3, 1024) fixed,
  1   276 	     2 spare_node	      char (4096) aligned;
  1   277 
  1   278 /* The File State */
  1   279      dcl	   fs_ptr		      ptr;
  1   280      dcl	   1 file_state_block     based (fs_ptr),
  1   281 	     2 file_action	      fixed,
  1   282 	     2 file_substate      fixed,
  1   283 	     2 number_of_keys     fixed (34),
  1   284 	     2 duplicate_keys     fixed (34),		/* 0 if no duplications */
  1   285 	     2 dup_key_bytes      fixed (34),
  1   286 	     2 total_key_length   fixed (34),
  1   287 	     2 number_of_records  fixed (34),
  1   288 	     2 total_record_length
  1   289 			      fixed (34),
  1   290 	     2 number_of_allocated_records
  1   291 			      fixed (34),
  1   292 	     2 number_of_free_blocks
  1   293 			      fixed (34),
  1   294 	     2 words	      (2) fixed;
  1   295 
  1   296 /* The Index State */
  1   297      dcl	   is_ptr		      ptr;
  1   298      dcl	   1 index_state_block    based (is_ptr),	/* if this declaration is changed,
  1   299*						   index_state_blocks must be adjusted */
  1   300 	     2 number_of_nodes    fixed (34),
  1   301 	     2 free_node_designator
  1   302 			      fixed (35),
  1   303 	     2 index_tail_comp_num
  1   304 			      fixed,
  1   305 	     2 index_height	      fixed,
  1   306 	     2 index_action	      fixed,
  1   307 	     2 index_substate     fixed,
  1   308 	     2 current_node	      fixed (35),
  1   309 	     2 change_node	      fixed (35),
  1   310 	     2 fake_node,				/* equivalent to a short node because of storage map. It holds
  1   311*						   the new key, new record descrip, and new branch in a fashion
  1   312*						   convenient for overflow-underflow in change_index. */
  1   313 	       3 fake_head_and_descrip,
  1   314 	         4 word1	      fixed,		/* last_branch_num in real node */
  1   315 	         4 word2	      fixed,		/* low_key_pos in real node */
  1   316 	         4 word3	      fixed,		/* normally scat_space */
  1   317 	         4 word4	      fixed,		/* first branch in real node */
  1   318 	         4 new_key_pos    fixed (17) unal,	/* set by initializefile to denote first char
  1   319*						   in new_key_string, never changed */
  1   320 	         4 new_key_length fixed (17) unal,
  1   321 	         4 new_record_descrip,
  1   322 		 5 new_record_designator
  1   323 			      fixed (35),
  1   324 	         4 new_branch     fixed (35),
  1   325 	       3 new_key_string   char (256),
  1   326 	     2 branch_num_adjust  fixed,
  1   327 	     2 pos_array	      (10),
  1   328 	       3 saved_node	      fixed (35),
  1   329 	       3 saved_branch_num fixed;
  1   330 
  1   331      dcl	   1 old_file_base	      based (f_b_ptr),
  1   332 	     2 words1	      (15) fixed,		/* same in both file versions */
  1   333 	     2 old_file_state_blocks
  1   334 			      (0:1),
  1   335 	       3 words	      (5) fixed,
  1   336 	     2 words2	      (7) fixed,
  1   337 	     2 record_state	      fixed,
  1   338 	     2 record_state_blocks
  1   339 			      (0:1),
  1   340 	       3 words	      (4) fixed,
  1   341 	     2 words3	      (14) fixed,		/* rover info same in both versions */
  1   342 	     2 old_version_index_height
  1   343 			      fixed,
  1   344 	     2 old_version_number_of_nodes
  1   345 			      fixed (34),
  1   346 	     2 words4	      (157) fixed,
  1   347 	     2 old_version_index_tail_comp_num
  1   348 			      fixed,
  1   349 	     2 old_version_free_node_designator
  1   350 			      fixed (35),
  1   351 	     2 words5	      (10) fixed,
  1   352 	     2 old_version_comp_info
  1   353 			      fixed,
  1   354 	     2 word,
  1   355 	     2 x_count	      fixed;		/* always zero in old version files */
  1   356 
  1   357 /* External Procedures */
  1   358      dcl	   clock_		      entry returns (fixed (71));
  1   359      dcl	   alloc_cb_file	      entry (fixed,		/* size of block in words */
  1   360 			      ptr);		/* ptr to block */
  1   361      dcl	   free_cb_file	      entry (fixed, ptr);
  1   362      dcl	   get_seg_ptr	      entry (ptr, fixed) returns (ptr);
  1   363      dcl	   make_designator	      entry (fixed, fixed (18), fixed (35));
  1   364      dcl	   create_seg_ptrs	      entry (ptr);
  1   365      dcl	   free_seg_ptrs	      entry (ptr);
  1   366      dcl	   get_new_seg	      entry (ptr, fixed, ptr, fixed, label);
  1   367      dcl	   free_seg	      entry (ptr, fixed, ptr);
  1   368      dcl	   set_bitcounts	      entry (ptr);
  1   369      dcl	   create_position_stack  entry (ptr);
  1   370      dcl	   extend_position_stack  entry (ptr);
  1   371      dcl	   free_position_stack    entry (ptr);
  1   372      dcl	   change_index	      entry (ptr, label);
  1   373      dcl	   change_record_list     entry (ptr, fixed, ptr, label);
  1   374 
  1   375 /* State Constants */
  2     1      dcl	   bumping_count	      static internal options (constant) init (-14);
  2     2      dcl	   rollback_action	      static options (constant) init (-13);
  2     3      dcl	   adjust_action	      static options (constant) init (-12);
  2     4      dcl	   unshared_opening	      static internal fixed options (constant) init (-11);
  2     5      dcl	   non_eof_delete	      static internal fixed options (constant) init (-10);
  2     6      dcl	   free_action	      static options (constant) init (-10);
  2     7      dcl	   write_trunc	      static internal fixed options (constant) init (-9);
  2     8      dcl	   allocate_action	      static options (constant) init (-9);
  2     9      dcl	   reassigning_key	      static options (constant) init (-8);
  2    10      dcl	   read_exclude	      static options (constant) init (-7);
  2    11      dcl	   adding_record	      static options (constant) init (-6);
  2    12      dcl	   deleting_key	      static options (constant) init (-5);
  2    13      dcl	   adding_key	      static options (constant) init (-4);
  2    14      dcl	   delete_action	      static options (constant) init (-3);
  2    15      dcl	   eof_delete	      static internal fixed options (constant) init (-3);
  2    16      dcl	   replace_action	      static options (constant) init (-2);
  2    17      dcl	   rewrite_action	      static internal fixed options (constant) init (-2);
  2    18      dcl	   insert_action	      static options (constant) init (-1);
  2    19      dcl	   append_action	      static internal fixed options (constant) init (-1);
  2    20      dcl	   truncate_action	      static internal fixed options (constant) init (1);
  2    21      dcl	   must_adjust	      static internal fixed options (constant) init (2);
  2    22      dcl	   must_rollback	      static internal fixed options (constant) init (3);
  1   376 
  1   377 
  1   378 /* Other constants */
  1   379      dcl	   true_max_comp_num      static options (constant) init (1250);
  1   380      dcl	   stat_header_size	      static internal fixed options (constant) init (8);
  1   381 
  1   382 /* builtins */
  1   383      dcl	   (verify, reverse)      builtin;
  1   384      dcl	   addr		      builtin;
  1   385      dcl	   divide		      builtin;
  1   386      dcl	   length		      builtin;
  1   387      dcl	   null		      builtin;
  1   388      dcl	   substr		      builtin;
  1   389      dcl	   size		      builtin;
  1   390      dcl	   abs		      builtin;
  1   391      dcl	   unspec		      builtin;
  1   392      dcl	   fixed		      builtin;
  1   393      dcl	   bit		      builtin;
  1   394      dcl	   max		      builtin;
  1   395      dcl	   min		      builtin;
  1   396      dcl	   rel		      builtin;
  1   397 
      304 
  3     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  3     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  3     3*      version number to IOX2. */
  3     4 /* format: style2 */
  3     5 
  3     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  3     7 	     2 version	      character (4) aligned,	/* IOX2 */
  3     8 	     2 name	      char (32),		/* I/O name of this block. */
  3     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  3    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  3    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  3    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  3    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  3    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
  3    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  3    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  3    17 						/* open(p,mode,not_used,s) */
  3    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  3    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  3    20 						/* get_line(p,bufptr,buflen,actlen,s) */
  3    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  3    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
  3    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  3    24 						/* put_chars(p,bufptr,buflen,s) */
  3    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  3    26 						/* modes(p,newmode,oldmode,s) */
  3    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  3    28 						/* position(p,u1,u2,s) */
  3    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  3    30 						/* control(p,order,infptr,s) */
  3    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  3    32 						/* read_record(p,bufptr,buflen,actlen,s) */
  3    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  3    34 						/* write_record(p,bufptr,buflen,s) */
  3    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  3    36 						/* rewrite_record(p,bufptr,buflen,s) */
  3    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  3    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  3    39 						/* seek_key(p,key,len,s) */
  3    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  3    41 						/* read_key(p,key,len,s) */
  3    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
  3    43 						/* read_length(p,len,s) */
  3    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  3    45 						/* open_file(p,mode,desc,not_used,s) */
  3    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  3    47 						/* close_file(p,desc,s) */
  3    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
  3    49 						/* detach(p,desc,s) */
  3    50 
  3    51      declare iox_$iocb_version_sentinel
  3    52 			      character (4) aligned external static;
  3    53 
  3    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
      305 
  4     1 /* include file for common portions of vfile_'s attach block used in
  4     2*   several modules--created by M. Asherman 1/9/76
  4     3*   Modified 8/28/76 to add last_comp */
  4     4 
  4     5      dcl	   1 atb		      based (iocb_ptr -> iocb.actual_iocb_ptr -> iocb.attach_data_ptr),
  4     6 						/* attach block */
  4     7 	     2 flags	      aligned,
  4     8 	       3 (pad1, appending, no_trunc, pad2, ssf, header_present, blocked, shared, pad3, msf, inv_lock_reset,
  4     9 		  dup_ok_sw, trans_sw, noend_sw, exclu_sw, stat_sw, checkpoint_sw)
  4    10 			      bit (1) unal,
  4    11 	       3 pad5	      bit (19) unal,
  4    12 	     2 wait_time	      fixed (35),
  4    13 	     2 word	      fixed,
  4    14 	     2 max_rec_len	      fixed (35),
  4    15 	     2 header_id	      fixed (35),
  4    16 	     2 word2	      fixed,
  4    17 	     2 attach_descrip_string
  4    18 			      char (256),
  4    19 	     2 dname_len,
  4    20 	     2 ename_len	      fixed,
  4    21 	     2 words3	      (9) fixed,
  4    22 	     2 opening_mode	      fixed,
  4    23 	     2 word4	      fixed,
  4    24 	     2 fcbp	      ptr,
  4    25 	     2 fsp	      ptr,		/* first seg ptr */
  4    26 	     2 close_x	      entry,		/* set to close routine */
  4    27 	     2 last_comp	      fixed,		/* msf component number */
  4    28 	     2 tcf_iocbp	      ptr;		/* iocb ptr for transaction control switch */
      306 
      307       dcl	    iocb_ptr	       ptr;
      308    end /* end create_seg_ptrs */;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/16/90  1517.7  create_seg_ptrs.pl1               >spec>install>1043>create_seg_ptrs.pl1
304          1    07/19/79  1647.0  vfile_indx.incl.pl1               >ldd>include>vfile_indx.incl.pl1
1-376        2    07/19/79  1647.0  vfile_action_codes.incl.pl1       >ldd>include>vfile_action_codes.incl.pl1
305          3    05/20/83  1946.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
306          4    07/19/79  1647.0  vf_attach_block.incl.pl1          >ldd>include>vf_attach_block.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
abort_exit                             parameter       label variable           dcl 284 ref 109 123
actual_iocb_ptr          12            based           pointer                  level 2 dcl 3-6 ref 215 222 222 222 222 222 222 222
                                                                                  222 222 222
addr                                                   builtin function         dcl 1-384 ref 53 57 60 194 199 200 200 249 250
alloc_cb_file                   000026 constant        entry                    external dcl 1-359 ref 64 261
atb                                    based           structure                level 1 unaligned dcl 4-5
attach_data_ptr          16            based           pointer                  level 2 dcl 3-6 ref 215 222 222 222 222 222 222 222
                                                                                  222 222 222 225 232
attach_descrip_string
                          6            based           char(256)                level 2 packed packed unaligned dcl 4-5 ref 222 222
                                                                                  222 222
bit                                                    builtin function         dcl 1-393 ref 250
comp_idx                        000162 automatic       fixed bin(17,0)          dcl 257 set ref 262* 263 263* 265* 266*
comp_info                              based           structure                level 1 unaligned dcl 84
comp_info_ptr                   000126 automatic       pointer                  dcl 83 set ref 53* 60* 62 69 71 79
comp_link                 4            based           fixed bin(17,0)          array level 3 in structure "comp_info" packed packed
                                                                                  unaligned dcl 84 in begin block on line 46 ref 71
comp_link                 4            based           fixed bin(15,0)          array level 3 in structure "old_comp_info" packed
                                                                                  packed unaligned dcl 93 in begin block on line 46
                                                                                  ref 69
comp_num                               based           fixed bin(17,0)          level 2 in structure "designator_struct" packed
                                                                                  packed unaligned dcl 1-127 in procedure
                                                                                  "create_seg_ptrs" set ref 249*
comp_num                               parameter       fixed bin(17,0)          dcl 277 in procedure "create_seg_ptrs" set ref 109
                                                                                  123 127 129 154 167* 170* 178 206 209 209 211 214*
                                                                                  234* 238 243 245 247 249
comp_number                     000100 automatic       fixed bin(17,0)          dcl 277 set ref 52* 59* 67 68* 69* 69 71* 71
comp_table                3            based           structure                array level 2 in structure "old_comp_info" unaligned
                                                                                  dcl 93 in begin block on line 46
comp_table                             based           structure                array level 1 dcl 1-268 in procedure
                                                                                  "create_seg_ptrs"
comp_table                3            based           structure                array level 2 in structure "comp_info" dcl 84
                                                                                  in begin block on line 46
comp_table_start                       based           fixed bin(17,0)          array level 2 dcl 1-157 set ref 194 199 200 200
designator                             parameter       fixed bin(35,0)          dcl 1-88 set ref 247 249 250
designator_struct                      based           structure                level 1 dcl 1-127
dname_len               106            based           fixed bin(17,0)          level 2 dcl 4-5 ref 222 222 222 222
ename_len               107            based           fixed bin(17,0)          level 2 dcl 4-5 ref 222 222
error_table_$noentry            000024 external static fixed bin(35,0)          dcl 302 ref 238
f_b_ptr                         000112 automatic       pointer                  dcl 1-156 set ref 48* 49 52 53 57 57 60 66 69 73 74
                                                                                  75 75 77 78 80 112* 123 123 123 129 132 192* 193
                                                                                  194 199 200 200
fcb_ptr                                based           pointer                  level 2 dcl 1-3 set ref 154* 170* 197* 214* 219*
                                                                                  222* 225 230* 234*
fcbp                    124            based           pointer                  level 2 dcl 4-5 set ref 225*
file_base                              based           structure                level 1 unaligned dcl 1-157
file_base_ptr             2            based           pointer                  level 2 dcl 1-3 set ref 48 112 192 231*
file_state_block                       based           structure                level 1 unaligned dcl 1-280 ref 60 123 123 123 129
                                                                                  132 193 194 199 200 200
file_state_ptr           44            based           pointer                  level 2 dcl 1-3 ref 113
file_version              4            based           fixed bin(17,0)          level 2 dcl 1-157 ref 49 69 75
flags                                  based           structure                level 2 dcl 4-5
foo                             000105 automatic       fixed bin(35,0)          dcl 281 set ref 154* 170* 174 174* 174* 197* 199*
                                                                                  200 214* 222* 230* 234* 237 238 239* 239*
foo24                           000106 automatic       fixed bin(24,0)          dcl 282 set ref 154* 170* 197* 214* 230* 234*
free_cb_file                    000030 constant        entry                    external dcl 1-361 ref 106 268
fs_ptr                          000114 automatic       pointer                  dcl 1-279 set ref 60 113* 123 123 123 129 132 193
                                                                                  194 199 200 200
fsp                     126            based           pointer                  level 2 dcl 4-5 set ref 232*
get_seg_ptr                     000032 constant        entry                    external dcl 1-362 ref 68 78 167
half_node_length          5            based           fixed bin(17,0)          level 2 dcl 1-3 set ref 74*
hcs_$set_bc_seg                 000010 constant        entry                    external dcl 289 ref 199
i                               000104 automatic       fixed bin(17,0)          dcl 280 set ref 193* 194 197 197* 197 199 199 200
                                                                                  200*
index_state             114            based           fixed bin(17,0)          level 2 dcl 1-157 ref 57
index_state_block                      based           structure                level 1 unaligned dcl 1-298
index_state_blocks      115            based           structure                array level 2 unaligned dcl 1-157 set ref 57
index_state_ptr          34            based           pointer                  level 2 dcl 1-3 set ref 57* 58
index_tail_comp_num       2            based           fixed bin(17,0)          level 2 dcl 1-298 ref 59
indx_cb                                based           structure                level 1 unaligned dcl 1-3
indx_cb_ptr                     000110 automatic       pointer                  dcl 1-2 set ref 47* 48 57 58 62 64 64 64 64 64 65 65
                                                                                  66 73 74 75 77 78 79 80 105* 106 106 106 106 106
                                                                                  111* 112 113 127 132 150 154 154 163 170 178 184
                                                                                  184 185 185 191* 192 197 197 197 199 208* 209 209
                                                                                  211 214 219 222 225 229 229 230 230 231 231 232
                                                                                  234 243 245 258 259 260 260 261 261 261 261 261
                                                                                  263 265 266
iocb                                   based           structure                level 1 dcl 3-6
iocb_ptr                               parameter       pointer                  dcl 307 set ref 44 47 68* 78* 103 105 109 111 167*
                                                                                  189 191 206 208 215 222 222 222 222 222 222 222
                                                                                  222 222 222 225 232
is_ptr                          000116 automatic       pointer                  dcl 1-297 set ref 58* 59
last_comp_num                          based           fixed bin(17,0)          level 2 in structure "file_base" dcl 1-157
                                                                                  in procedure "create_seg_ptrs" set ref 129* 132
                                                                                  193
last_comp_num             1            based           fixed bin(17,0)          level 2 in structure "comp_info" dcl 84
                                                                                  in begin block on line 46 ref 62 79
max_comp_num                           based           fixed bin(17,0)          level 2 dcl 1-157 set ref 60 123 123 123*
max_record_size           6            based           fixed bin(21,0)          level 2 dcl 1-3 set ref 75* 77*
max_seg_limit            11            based           fixed bin(19,0)          level 2 dcl 1-157 ref 75 77
msf_manager_$adjust             000022 constant        entry                    external dcl 301 ref 154
msf_manager_$close              000014 constant        entry                    external dcl 293 ref 219
msf_manager_$get_ptr            000020 constant        entry                    external dcl 295 ref 170 197 214 230 234
msf_manager_$open               000016 constant        entry                    external dcl 294 ref 222
next_substate            51            based           fixed bin(17,0)          level 2 dcl 1-3 set ref 154 184* 184 185
node_length               4            based           fixed bin(17,0)          level 2 dcl 1-3 set ref 73*
node_size                 6            based           fixed bin(19,0)          level 2 dcl 1-157 ref 73 74
null                                                   builtin function         dcl 1-387 ref 65 171 174 174 197 211 215 229 237 239
                                                                                  239 266
offset                                 parameter       fixed bin(18,0)          dcl 283 in procedure "create_seg_ptrs" ref 247 250
offset                    0(18)        based           bit(18)                  level 2 in structure "designator_struct" packed
                                                                                  packed unaligned dcl 1-127 in procedure
                                                                                  "create_seg_ptrs" set ref 250*
old_array                              based           pointer                  array dcl 273 ref 263 268 268
old_array_limit                 000163 automatic       fixed bin(17,0)          dcl 271 set ref 258* 262 265 268 268
old_array_ptr                   000164 automatic       pointer                  dcl 272 set ref 259* 263 268 268 268*
old_comp_info                          based           structure                level 1 unaligned dcl 93
old_file_base                          based           structure                level 1 unaligned dcl 1-331
old_last_comp_num        37            based           fixed bin(17,0)          level 2 dcl 1-3 set ref 79* 132*
old_rover_comp_num       42            based           fixed bin(17,0)          level 2 dcl 1-3 set ref 80*
old_version_comp_info
                        342            based           fixed bin(17,0)          level 2 dcl 1-331 set ref 53
old_version_index_tail_comp_num
                        326            based           fixed bin(17,0)          level 2 dcl 1-331 ref 52
open_data_ptr            22            based           pointer                  level 2 dcl 3-6 ref 47 105 111 191 208
p                               000102 automatic       pointer                  dcl 279 set ref 68* 214* 215 234* 237 243
p_number_of_new_components             parameter       fixed bin(17,0)          dcl 255 ref 253 260
repeating                50            based           bit(1)                   level 2 dcl 1-3 set ref 150 163 185*
rover_comp_num           53            based           fixed bin(17,0)          level 2 dcl 1-157 set ref 78* 80
rover_seg_ptr            32            based           pointer                  level 2 dcl 1-3 set ref 78*
seg_limit                              based           fixed bin(19,0)          array level 2 dcl 1-268 set ref 194 199 200* 200
seg_ptr                                parameter       pointer                  dcl 1-86 set ref 109 167* 170* 171 178
seg_ptr_array                          based           pointer                  array dcl 1-85 set ref 64 64 65* 66* 106 106 178*
                                                                                  197 197* 199* 211 229* 230* 231 232 243* 245 261
                                                                                  261 263* 266*
seg_ptr_array_limit      12            based           fixed bin(17,0)          level 2 dcl 1-3 set ref 62* 64 64 65 106 106 127 209
                                                                                  209 229 258 260* 260 261 261 265
seg_ptr_array_ptr        10            based           pointer                  level 2 dcl 1-3 set ref 64 64 64* 65 66 106 106 106*
                                                                                  178 197 197 199 211 229 230 231 232 243 245 259
                                                                                  261 261 261* 263 266
shared                    0(07)        based           bit(1)                   level 3 packed packed unaligned dcl 4-5 ref 215
size                                                   builtin function         dcl 1-389 ref 60 64 64 106 106 123 123 123 129 132
                                                                                  193 194 199 200 200 261 261 268 268
sub_err_                        000012 constant        entry                    external dcl 292 ref 174 239
substate_arg                           parameter       fixed bin(17,0)          dcl 276 set ref 109 154 158* 158 179* 179 185
substr                                                 builtin function         dcl 1-388 ref 222 222 222 222
true_max_comp_num                      constant        fixed bin(17,0)          initial dcl 1-379 ref 123 123 238

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
abs                                                    builtin function         dcl 1-390
adding_key                             internal static fixed bin(17,0)          initial dcl 2-13
adding_record                          internal static fixed bin(17,0)          initial dcl 2-11
adjust_action                          internal static fixed bin(17,0)          initial dcl 2-3
allocate_action                        internal static fixed bin(17,0)          initial dcl 2-8
append_action                          internal static fixed bin(17,0)          initial dcl 2-19
bumping_count                          internal static fixed bin(17,0)          initial dcl 2-1
change_index                    000000 constant        entry                    external dcl 1-372
change_record_list              000000 constant        entry                    external dcl 1-373
clock_                          000000 constant        entry                    external dcl 1-358
create_position_stack           000000 constant        entry                    external dcl 1-369
create_seg_ptrs                 000000 constant        entry                    external dcl 1-364
current_t_code                         based           fixed bin(35,0)          dcl 1-82
delete_action                          internal static fixed bin(17,0)          initial dcl 2-14
deleting_key                           internal static fixed bin(17,0)          initial dcl 2-12
divide                                                 builtin function         dcl 1-385
eof_delete                             internal static fixed bin(17,0)          initial dcl 2-15
extend_position_stack           000000 constant        entry                    external dcl 1-370
file_header                            based           structure                level 1 unaligned dcl 1-274
fixed                                                  builtin function         dcl 1-392
free_action                            internal static fixed bin(17,0)          initial dcl 2-6
free_position_stack             000000 constant        entry                    external dcl 1-371
free_seg                        000000 constant        entry                    external dcl 1-367
free_seg_ptrs                   000000 constant        entry                    external dcl 1-365
get_new_seg                     000000 constant        entry                    external dcl 1-366
ind_des_structure                      based           structure                level 1 packed packed unaligned dcl 1-89
ind_structure                          based           structure                level 1 unaligned dcl 1-102
insert_action                          internal static fixed bin(17,0)          initial dcl 2-18
iox_$iocb_version_sentinel             external static char(4)                  dcl 3-51
keys                                   based           char(4096)               packed unaligned dcl 1-153
length                                                 builtin function         dcl 1-386
make_designator                 000000 constant        entry                    external dcl 1-363
max                                                    builtin function         dcl 1-394
min                                                    builtin function         dcl 1-395
must_adjust                            internal static fixed bin(17,0)          initial dcl 2-21
must_rollback                          internal static fixed bin(17,0)          initial dcl 2-22
node_block                             based           structure                level 1 unaligned dcl 1-139
non_eof_delete                         internal static fixed bin(17,0)          initial dcl 2-5
pos_ptr                                defined         pointer                  dcl 286
position_frame                         based           structure                level 1 unaligned dcl 1-132
read_exclude                           internal static fixed bin(17,0)          initial dcl 2-10
reassigning_key                        internal static fixed bin(17,0)          initial dcl 2-9
record_block_structure                 based           structure                level 1 unaligned dcl 1-115
rel                                                    builtin function         dcl 1-396
replace_action                         internal static fixed bin(17,0)          initial dcl 2-16
reverse                                                builtin function         dcl 1-383
rewrite_action                         internal static fixed bin(17,0)          initial dcl 2-17
rollback_action                        internal static fixed bin(17,0)          initial dcl 2-2
seg_array                              based           fixed bin(19,0)          array dcl 1-87
set_bitcounts                   000000 constant        entry                    external dcl 1-368
stat_header_size                       internal static fixed bin(17,0)          initial dcl 1-380
stat_structure                         based           structure                level 1 unaligned dcl 1-92
time_stamp_structure                   based           structure                level 1 packed packed unaligned dcl 1-112
truncate_action                        internal static fixed bin(17,0)          initial dcl 2-20
unshared_opening                       internal static fixed bin(17,0)          initial dcl 2-4
unspec                                                 builtin function         dcl 1-391
verify                                                 builtin function         dcl 1-383
write_trunc                            internal static fixed bin(17,0)          initial dcl 2-7

NAMES DECLARED BY EXPLICIT CONTEXT.
adjust_if_nec                   001233 constant        entry                    internal dcl 148 ref 130
check_substate                  001430 constant        entry                    internal dcl 182 ref 153 166
create_seg_ptrs                 000056 constant        entry                    external dcl 44
extend_seg_ptr_array            001441 constant        entry                    internal dcl 253 ref 127 209
free_seg_ptrs                   000305 constant        entry                    external dcl 103
get_new_seg                     000352 constant        entry                    external dcl 109
get_seg_ptr                     000572 constant        entry                    external dcl 206
make_designator                 001177 constant        entry                    external dcl 247
set_bitcounts                   000440 constant        entry                    external dcl 189
set_new_ptr                     001275 constant        entry                    internal dcl 161 ref 131

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1734        1770    1546        1744
Length      2250    1546        34         244     166           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
create_seg_ptrs                     282 external procedure  is an external procedure.  
begin block on line 46                  begin block         shares stack frame of external procedure create_seg_ptrs.  
adjust_if_nec                           internal procedure  shares stack frame of external procedure create_seg_ptrs.  
set_new_ptr                             internal procedure  shares stack frame of external procedure create_seg_ptrs.  
check_substate                          internal procedure  shares stack frame of external procedure create_seg_ptrs.  
extend_seg_ptr_array                    internal procedure  shares stack frame of external procedure create_seg_ptrs.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
create_seg_ptrs          000100 comp_number                 create_seg_ptrs
                         000102 p                           create_seg_ptrs
                         000104 i                           create_seg_ptrs
                         000105 foo                         create_seg_ptrs
                         000106 foo24                       create_seg_ptrs
                         000110 indx_cb_ptr                 create_seg_ptrs
                         000112 f_b_ptr                     create_seg_ptrs
                         000114 fs_ptr                      create_seg_ptrs
                         000116 is_ptr                      create_seg_ptrs
                         000126 comp_info_ptr               begin block on line 46
                         000162 comp_idx                    extend_seg_ptr_array
                         000163 old_array_limit             extend_seg_ptr_array
                         000164 old_array_ptr               extend_seg_ptr_array

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        begin_return_mac    return_mac          tra_ext_2
signal_op           shorten_stack       ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
alloc_cb_file                 free_cb_file                  get_seg_ptr                   hcs_$set_bc_seg
msf_manager_$adjust           msf_manager_$close            msf_manager_$get_ptr          msf_manager_$open
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$noentry




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     44 000053        47 000065        48 000072        49 000074        52 000077        53 000101        54 000103
     57 000104        58 000110        59 000111        60 000113        62 000115        64 000122        65 000136
     66 000157        67 000161        68 000164        69 000200        71 000213        72 000221        73 000222
     74 000227        75 000232        77 000242        78 000246        79 000262        80 000266        81 000271
    103 000302       105 000314       106 000321       107 000336       109 000345       111 000364       112 000371
    113 000373       123 000375       127 000407       129 000416       130 000421       131 000422       132 000423
    134 000427       189 000436       191 000447       192 000454       193 000456       194 000465       197 000472
    199 000523       200 000547       203 000555       204 000557       206 000566       208 000603       209 000610
    211 000620       214 000627       215 000652       219 000665       222 000674       225 000745       229 000755
    230 000777       231 001023       232 001030       234 001037       237 001062       238 001070       239 001100
    241 001145       243 001146       245 001153       247 001173       249 001211       250 001216       251 001224
    148 001233       150 001234       153 001237       154 001240       156 001271       158 001272       159 001274
    161 001275       163 001276       166 001301       167 001302       168 001316       170 001317       171 001343
    174 001350       176 001417       178 001420       179 001426       180 001427       182 001430       184 001431
    185 001433       187 001440       253 001441       258 001443       259 001446       260 001450       261 001452
    262 001467       263 001475       264 001502       265 001504       266 001515       267 001522       268 001524
    269 001541


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
