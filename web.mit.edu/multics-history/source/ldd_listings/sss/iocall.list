	COMPILATION LISTING OF SEGMENT iocall
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-05-05_1830.77_Fri_mdt
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 	/*	IOCALL -
       12*		This command allows the user to make calls directly to the I/O system from
       13*			command level. The following I/O calls are provided:
       14*
       15*			attach
       16*			detach
       17*			read
       18*			write
       19*			seek
       20*			tell
       21*			setsize
       22*			getsize
       23*			abort
       24*			order
       25*			changemode
       26*			resetread
       27*			resetwrite
       28*			readsync
       29*			writesync
       30*			worksync
       31*
       32*		In addition the entry checkstatus is provided so that an I/O system
       33*			caller may interpret the status returned from an I/O call.
       34*
       35*		Originally coded by R. J. Feiertag on February 21, 1970 due to unremitting
       36*			pressure.							*/
       37 	/*	Modified on April 8, 1971 by R. J. Feiertag to add some new calls.		*/
       38 
       39 iocall:	proc;
       40 
       41 dcl whoami char(8) static aligned init("iocall");
       42 
       43 	/*	AUTOMATIC VARIABLES */
       44 
       45 	dcl (l1,l2,l3,l4,l5) fixed bin(17),	/* arg lengths */
       46 	    (p1,p2,p3,p4,p5) ptr,		/* arg pointers */
       47 	    statusp ptr,			/* pointer to status string */
       48 	    call_name char(l1) based(p1),	/* the name of the I/O call */
       49 	    command_name char(32) init(whoami),		/* name of this command */
       50 	    ioname char(l2) based(p2),	/* the stream name for this call */
       51 	    arg3 char(l3) based(p3),		/* third arg */
       52 	    arg4 char(l4) based(p4),	/* fourth arg */
       53 	    arg5 char(l5) based(p5),		/* fifth arg */
       54 	    count fixed bin(17),	/* the number of arguments for this call */
       55 	    mode char(128),		/* the mode to be passed to the I/O system */
       56 	    pos fixed bin,		/* position in mode string */
       57 	    old_mode char(128),	/* the previous mode of this device */
       58 	    old_status bit(72) aligned,	/* a previous status string */
       59 	    limit fixed bin,	/* the limit of readahead or writebehind */
       60 	    status bit(72) aligned,		/* the status string returned by the I/O system */
       61 	    ioname2 char(32),	/* the detach id for a detach call */
       62 	    path char(168),		/* the path name of a segment */
       63 	    dir char(168),		/* the directory of a segment */
       64 	    entry char(32),		/* the name of a segment */
       65 	    code fixed bin(35),	/* error code */
       66 	    segptr ptr,		/* pointer to a segment */
       67 	    offset fixed bin(17),	/* an offset from the beginning of a segment */
       68 	    nelem fixed bin(17),	/* the number of elements to be read or written */
       69 	    bit_count fixed bin(24),	/* bit-count from hcs_$initiate_count */
       70 	    nelemt fixed bin(17),	/* the number of elements read or written */
       71 	    ptrname2 char(32),
       72 	    element_size fixed bin(17),	/* the size in bits of an element */
       73 	    name char(32);		/* the stream name */
       74 
       75 	dcl 1 s based(statusp) aligned,
       76 		2 code fixed bin(17),	/* error code */
       77 		2 comp bit(5) unaligned,
       78 		2 p1 bit(4) unaligned,
       79 		2 eof bit(1) unaligned,	/* end of file */
       80 		2 p2 bit(4) unaligned,
       81 		2 abs bit(1) unaligned,	/* device absent */
       82 		2 det bit(1) unaligned,	/* detached */
       83 		2 quit bit(1) unaligned,	/* quit detected */
       84 		2 abort bit(1) unaligned,	/* transaction aborted */
       85 		2 p3 bit(18) unaligned;
       86 
       87 	/*	EXTERNAL DATA */
       88 
       89 	dcl (error_table_$noarg fixed bin(35),
       90 	     sys_info$max_seg_size fixed bin) ext;	/* # of pages/segment */
       91 
       92 	/*	EXTERNAL ENTRIES */
       93 
       94 	dcl cu_$arg_ptr ext entry(fixed bin(17),ptr,fixed bin(17),fixed bin(35)),
       95 	    expand_path_ ext entry(ptr,fixed bin(17),ptr,ptr,fixed bin(35)),
       96 	hcs_$make_seg entry(char(*), char(*), char(*), fixed bin(5), ptr, fixed bin(35)),
       97 	hcs_$initiate_count entry(char(*), char(*), char(*), fixed bin(24), fixed bin, ptr, fixed bin(35)),
       98 	hcs_$set_bc entry(char(*), char(*), fixed bin(24), fixed bin(35)),
       99 	cv_dec_check_ entry(char(*), fixed bin(35), fixed bin),
      100 	    (com_err_, ioa_) entry options(variable);
      101 
      102 dcl	ios_$attach entry(char(*), char(*), char(*), char(*), bit(72) aligned), 
      103 	ios_$detach entry(char(*), char(*), char(*), bit(72) aligned), 
      104 	ios_$read entry(char(*), ptr, fixed bin, fixed bin, fixed bin, bit(72) aligned), 
      105 	ios_$write entry(char(*), ptr, fixed bin, fixed bin, fixed bin, bit(72) aligned), 
      106 	ios_$seek entry(char(*), char(*), char(*), fixed bin, bit(72) aligned), 
      107 	ios_$tell entry(char(*), char(*), char(*), fixed bin, bit(72) aligned), 
      108 	ios_$setsize entry(char(*), fixed bin, bit(72) aligned), 
      109 	ios_$getsize entry(char(*), fixed bin, bit(72) aligned), 
      110 	ios_$order entry(char(*), char(*), ptr, bit(72) aligned), 
      111 	ios_$changemode entry(char(*), char(*), char(*), bit(72) aligned), 
      112 	ios_$resetread entry(char(*), bit(72) aligned), 
      113 	ios_$resetwrite entry(char(*), bit(72) aligned), 
      114 	ios_$abort entry(char(*), bit(72) aligned, bit(72) aligned), 
      115 	ios_$readsync entry(char(*), char(*), fixed bin, bit(72) aligned), 
      116 	ios_$writesync entry(char(*), char(*), fixed bin, bit(72) aligned), 
      117 	ios_$worksync entry(char(*), char(*), char(*), bit(72) aligned);
      118 
      119 dcl (addr, bin, divide, length, null, substr) builtin;
      120 
      121 /**/
      122 
      123 	statusp = addr(status);
      124 	call cu_$arg_ptr(1,p1,l1,code); /* get call name */
      125 	if code ^= 0 then go to bad_args;
      126 	call cu_$arg_ptr(2,p2,l2,code); /* get ioname */
      127 	if code ^= 0 then go to bad_args;
      128 	call cu_$arg_ptr(3,p3,l3,code); /* get third arg */
      129 	if code ^= 0 then count = 2; /* remember which is last arg */
      130 	 else do;
      131 		call cu_$arg_ptr(4,p4,l4,code);
      132 		if code ^= 0 then count = 3; /* remember last arg */
      133 		 else do;
      134 			call cu_$arg_ptr(5,p5,l5,code);
      135 			if code ^= 0 then count = 4;
      136 			 else count = 5;
      137 			end;
      138 		end;
      139 	if call_name = "attach" then do;	/* this is an attach call */
      140 		if count < 4 then go to bad_args;
      141 		mode = ""; /* initialize mode string */
      142 		pos = 1; /* start from beginning of mode string */
      143 		do count = 6 by 1 while(code = 0); /* process remaining arguments */
      144 			substr(mode,pos,l5) = arg5; /* place next mode in mode string */
      145 			pos = pos + l5 + 1; /* update position in mode string */
      146 			call cu_$arg_ptr(count,p5,l5,code); /* pick up next argument */
      147 			if code = 0 then substr(mode,pos-1,1) = ","; /* insert delimiter in mode string */
      148 			end;
      149 		call ios_$attach(ioname,arg3,arg4,mode,status);	/* make attach call */
      150 		end;
      151 	 else if call_name = "detach" then do;	/* detach call */
      152 		if count = 2 then ioname2,mode = "";
      153 		 else if count = 3 then do;
      154 			ioname2 = arg3;
      155 			mode = "";
      156 			end;
      157 		  else if count = 4 then do;
      158 			ioname2 = arg3;
      159 			mode = arg4;
      160 			end;
      161 		   else go to bad_args;
      162 		call ios_$detach(ioname,ioname2,mode,status); /* make detach call */
      163 		end;
      164 	 else if call_name = "read" then do; /* read call */
      165 		if count < 3 | count > 5 then go to bad_args;
      166 		path = arg3;	/* align for expand_path_ */
      167 		call expand_path_(addr(path),length(arg3),addr(dir),addr(entry),code);
      168 			/* get the directory and entry */
      169 		if code ^= 0 then go to path_err;
      170 		call hcs_$make_seg(dir,entry,"",01011b,segptr,code);
      171 			/* create the segment */
      172 		if segptr = null then go to path_err;
      173 		call ios_$getsize(ioname,element_size,status); /* get element size */
      174 		if substr(status,1,36) ^= "0"b then element_size = 9; /* if can't get element size assume 9 */
      175 		if count = 3 then do; /* set up args */
      176 			offset = 0;
      177 			nelem = divide(sys_info$max_seg_size * 36, element_size, 17, 0);
      178 			end;
      179 		 else if count = 4 then do;
      180 			offset = 0;
      181 			call cv_dec_check_(arg4, code, nelem); /* convert count */
      182 			if code ^= 0
      183 			then /* ! */
      184 nelem_4:			     call num_err(arg4, "nelem");
      185 			end;
      186 		  else if count = 5 then do;
      187 			call cv_dec_check_(arg4, code, offset);
      188 			if code ^= 0
      189 			then /* ! */
      190 offset_4:			     call num_err(arg4, "offset");
      191 			call cv_dec_check_(arg5, code, nelem);
      192 			if code ^= 0
      193 			then /* ! */
      194 nelem_5:			     call num_err(arg5, "nelem");
      195 			end;
      196 		call ios_$read(ioname,segptr,offset,nelem,nelemt,status); /* make read call */
      197 		if s.code = 0 then do; /* no problems */
      198 			call hcs_$set_bc(dir,entry,nelemt*element_size,code);	/* set segment bit count */
      199 			if code ^= 0 then
      200 				call ioa_("iocall: Unable to set bit count for segment. ^a",path);
      201 			call ioa_("The number of elements read is ^d.",nelemt);
      202 			end;
      203 		end;
      204 	 else if call_name = "write" then do;	/* write call */
      205 		if count < 3 | count > 5 then go to bad_args;
      206 		path = arg3;	/* align for expand_path_ */
      207 		call expand_path_(addr(path),length(arg3),addr(dir),addr(entry),code);
      208 			/* process path name */
      209 		if code ^= 0 then go to path_err;
      210 		call hcs_$initiate_count(dir,entry,"",bit_count,1,segptr,code);
      211 			/* get pointer to segment */
      212 		if segptr = null then go to path_err;
      213 		call ios_$getsize(ioname,element_size,status); /* get element size */
      214 		if substr(status,1,36) then element_size = 9; /* if can't get element size assume 9 */
      215 		if count = 3 then do;	/* set up args */
      216 			offset = 0;
      217 			nelem = divide(bit_count,element_size,17,0); /* get element count */
      218 			nelemt = nelem * element_size;		/* Calc # bits to be sent */
      219 			bit_count = bit_count - nelemt;
      220 			if bit_count ^= 0
      221 			then call ioa_("^d bits at bit-offset ^d not transmitted to device ^a",
      222 				bit_count, nelemt, ioname);
      223 			end;
      224 		 else if count = 4 then do;
      225 			offset = 0;
      226 			call cv_dec_check_(arg4, code, nelem);
      227 			if code ^= 0
      228 			then go to nelem_4;
      229 			end;
      230 		  else if count = 5 then do;
      231 			call cv_dec_check_(arg4, code, offset);
      232 			if code ^= 0
      233 			then go to offset_4;
      234 			call cv_dec_check_(arg5, code, nelem);
      235 			if code ^= 0
      236 			then go to nelem_5;
      237 			end;
      238 		call ios_$write(ioname,segptr,offset,nelem,nelemt,status); /* make write call */
      239 		if s.code = 0 then call ioa_("The number of elements written is ^d.",nelemt);
      240 		end;
      241 	 else if call_name = "seek" then do; /* seek call */
      242 		if count = 3 then do; /* set up args */
      243 			ptrname2 = "first";
      244 			offset = 0;
      245 			end;
      246 		 else if count = 4 then do;
      247 			ptrname2 = arg4;
      248 			offset = 0;
      249 			end;
      250 		  else if count = 5 then do;
      251 			ptrname2 = arg4;
      252 			call cv_dec_check_(arg5, code, offset);
      253 			if code ^= 0
      254 			then call num_err(arg5, "offset");
      255 			end;
      256 		   else go to bad_args;
      257 		call ios_$seek(ioname,arg3,ptrname2,offset,status);	/* make seek call */
      258 		end;
      259 	 else if call_name = "tell" then do;	/* tell call */
      260 		if count = 3 then ptrname2 = "first";	/* set up args */
      261 		 else if count = 4 then ptrname2 = arg4;
      262 		  else go to bad_args;
      263 		call ios_$tell(ioname,arg3,ptrname2,offset,status);	/* make tell call */
      264 		if s.code = 0 then call ioa_("Offset is ^d.",offset);
      265 		end;
      266 	 else if call_name = "setsize" then do; /* setsize call */
      267 		if count ^= 3 then go to bad_args;
      268 		call cv_dec_check_(arg3, code, element_size); /* convert element size */
      269 		if code ^= 0
      270 		then call num_err(arg3, "element_size");
      271 		call ios_$setsize(ioname,element_size,status); /* make setsize call */
      272 		end;
      273 	 else if call_name = "getsize" then do; /* getsize call */
      274 		if count ^= 2 then go to bad_args;
      275 		call ios_$getsize(ioname,element_size,status); /* make getsize call */
      276 		if s.code = 0 then call ioa_("Element size is ^d.",element_size); /* tell user the element size */
      277 		end;
      278 	 else if call_name = "order" then do; /* order call */
      279 		if count ^= 3 then go to bad_args;
      280 		call ios_$order(ioname,arg3,null,status); /* make order call */
      281 		end;
      282 	 else if call_name = "changemode" then do; /* changemode call */
      283 		mode = ""; /* initialize mode string */
      284 		if count >= 3 then code = 0; /* we have at least three arguments */
      285 		pos = 1; /* start at beginning of mode string */
      286 		do count = 4 by 1 while(code = 0); /* process remaining arguments */
      287 			substr(mode,pos,l3) = arg3; /* add mode to mode string */
      288 			pos = pos + l3 + 1; /* update position in mode string */
      289 			call cu_$arg_ptr(count,p3,l3,code); /* get next argument */
      290 			if code = 0 then substr(mode,pos-1,1) = ","; /* insert mode delimiter */
      291 			end;
      292 		call ios_$changemode(ioname,mode,old_mode,status); /* issue changemode call */
      293 		if s.code = 0 then call ioa_("Mode changed from ^a",old_mode); /* tell user old mode */
      294 		end;
      295 	 else if call_name = "resetread" then do; /* resetread call */
      296 		if count ^= 2 then go to bad_args;
      297 		call ios_$resetread(ioname,status); /* issue resetread call */
      298 		end;
      299 	 else if call_name = "resetwrite" then do; /* resetwrite call */
      300 		if count ^= 2 then go to bad_args;
      301 		call ios_$resetwrite(ioname,status); /* issue resetwrite call */
      302 		end;
      303 	 else if call_name = "abort" then do; /* abort call */
      304 		if count ^= 2 then go to bad_args;
      305 		old_status = ""b; /* abort all transactions */
      306 		call ios_$abort(ioname,old_status,status); /* issue abort call */
      307 		end;
      308 	 else if call_name = "readsync" then do; /* readsync call */
      309 		if count = 3 then limit = bin(131071, 17); /* set high limit for default */
      310 		 else if count = 4 then do;
      311 			call cv_dec_check_(arg4, code, limit); /* else set given limit */
      312 			if code ^= 0
      313 			then /* ! */
      314 limit_4:			     call num_err(arg4, "limit");
      315 			end;
      316 		  else go to bad_args;
      317 		call ios_$readsync(ioname,arg3,limit,status); /* issue readsync call */
      318 		end;
      319 	 else if call_name = "writesync" then do; /* writesync call */
      320 		if count = 3 then limit = bin(131071, 17); /* set high default limit */
      321 		 else if count = 4 then do;
      322 			call cv_dec_check_(arg4, code, limit); /* else set given limit */
      323 			if code ^= 0
      324 			then go to limit_4;
      325 			end;
      326 		  else go to bad_args;
      327 		call ios_$writesync(ioname,arg3,limit,status); /* issue writesync call */
      328 		end;
      329 	 else if call_name = "worksync" then do; /* worksync call */
      330 		if count ^= 3 then go to bad_args;
      331 		call ios_$worksync(ioname,arg3,"",status); /* issue worksync call */
      332 		end;
      333 	 else do;
      334 		call ioa_("iocall: The ^a call to the I/O system is not permitted by iocall.",call_name);
      335 		return;
      336 		end;
      337 	name = ioname;
      338 	go to status_check; /* go interpret status */
      339 
      340 path_err:	call com_err_(code,whoami,path);	/* report error to user */
      341 	return;
      342 
      343 
      344 bad_args:	call com_err_(error_table_$noarg,whoami,""); /* incorrect number of args */
      345 	return;
      346 
      347 	/* This entry point interprets a status string */
      348 
      349 checkstatus:	entry(input_status);
      350 
      351 	dcl input_status bit(72) aligned;
      352 
      353 	name = "";
      354 	statusp = addr(status);
      355 	status = input_status;
      356 	command_name = "I/O Error";
      357 status_check:
      358 	/* print out status interpretation */
      359 	if s.code ^= 0 then call com_err_(s.code,command_name,name);
      360 	if s.eof then call ioa_("^a at end of file.",name);
      361 	if s.abs then call ioa_("^a device absent.",name);
      362 	if s.det then call ioa_("^a device detached.",name);
      363 	if s.quit then call ioa_("^a quit detected.",name);
      364 	if s.abort then call ioa_("^a transaction aborted.",name);
      365 
      366 num_err: proc(str, id);
      367 
      368 dcl (str, id) char(*);
      369 
      370 	call com_err_(0, whoami, "Non-numeric digits in ^a argument to ^a request: ^a", id, call_name, str);
      371 
      372 	go to end_iocall;
      373 
      374 end;
      375 
      376 end_iocall:
      377 end iocall;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/05/00  1830.7  iocall.pl1                        >udd>sm>ds>w>ml>iocall.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
abort                     1(17)        based           bit(1)                   level 2 packed packed unaligned dcl 75 ref 364
abs                       1(14)        based           bit(1)                   level 2 packed packed unaligned dcl 75 ref 361
addr                                                   builtin function         dcl 119 ref 123 167 167 167 167 167 167 207 207 207
                                                                                  207 207 207 354
arg3                                   based           char                     packed unaligned dcl 45 set ref 149* 154 158 166 167
                                                                                  167 206 207 207 257* 263* 268* 269* 280* 287 317*
                                                                                  327* 331*
arg4                                   based           char                     packed unaligned dcl 45 set ref 149* 159 181* 182*
                                                                                  187* 188* 226* 231* 247 251 261 311* 312* 322*
arg5                                   based           char                     packed unaligned dcl 45 set ref 144 191* 192* 234*
                                                                                  252* 253*
bin                                                    builtin function         dcl 119 ref 309 320
bit_count                       000414 automatic       fixed bin(24,0)          dcl 45 set ref 210* 217 219* 219 220 220*
call_name                              based           char                     packed unaligned dcl 45 set ref 139 151 164 204 241
                                                                                  259 266 273 278 282 295 299 303 308 319 329 334*
                                                                                  370*
code                            000406 automatic       fixed bin(35,0)          dcl 45 in procedure "iocall" set ref 124* 125 126*
                                                                                  127 128* 129 131* 132 134* 135 143 146* 147 167*
                                                                                  169 170* 181* 182 187* 188 191* 192 198* 199 207*
                                                                                  209 210* 226* 227 231* 232 234* 235 252* 253 268*
                                                                                  269 284* 286 289* 290 311* 312 322* 323 340*
code                                   based           fixed bin(17,0)          level 2 in structure "s" dcl 75 in procedure
                                                                                  "iocall" set ref 197 239 264 276 293 357 357*
com_err_                        000032 constant        entry                    external dcl 94 ref 340 344 357 370
command_name                    000122 automatic       char(32)                 initial packed unaligned dcl 45 set ref 45* 356*
                                                                                  357*
count                           000132 automatic       fixed bin(17,0)          dcl 45 set ref 129* 132* 135* 136* 140 143* 146* 152
                                                                                  153 157 165 165 175 179 186 205 205 215 224 230
                                                                                  242 246 250 260 261 267 274 279 284 286* 289* 296
                                                                                  300 304 309 310 320 321 330
cu_$arg_ptr                     000016 constant        entry                    external dcl 94 ref 124 126 128 131 134 146 289
cv_dec_check_                   000030 constant        entry                    external dcl 94 ref 181 187 191 226 231 234 252 268
                                                                                  311 322
det                       1(15)        based           bit(1)                   level 2 packed packed unaligned dcl 75 ref 362
dir                             000324 automatic       char(168)                packed unaligned dcl 45 set ref 167 167 170* 198*
                                                                                  207 207 210*
divide                                                 builtin function         dcl 119 ref 177 217
element_size                    000426 automatic       fixed bin(17,0)          dcl 45 set ref 173* 174* 177 198 213* 214* 217 218
                                                                                  268* 271* 275* 276*
entry                           000376 automatic       char(32)                 packed unaligned dcl 45 set ref 167 167 170* 198*
                                                                                  207 207 210*
eof                       1(09)        based           bit(1)                   level 2 packed packed unaligned dcl 75 ref 360
error_table_$noarg              000012 external static fixed bin(35,0)          dcl 89 set ref 344*
expand_path_                    000020 constant        entry                    external dcl 94 ref 167 207
hcs_$initiate_count             000024 constant        entry                    external dcl 94 ref 210
hcs_$make_seg                   000022 constant        entry                    external dcl 94 ref 170
hcs_$set_bc                     000026 constant        entry                    external dcl 94 ref 198
id                                     parameter       char                     packed unaligned dcl 368 set ref 366 370*
input_status                           parameter       bit(72)                  dcl 351 ref 349 355
ioa_                            000034 constant        entry                    external dcl 94 ref 199 201 220 239 264 276 293 334
                                                                                  360 361 362 363 364
ioname                                 based           char                     packed unaligned dcl 45 set ref 149* 162* 173* 196*
                                                                                  213* 220* 238* 257* 263* 271* 275* 280* 292* 297*
                                                                                  301* 306* 317* 327* 331* 337
ioname2                         000242 automatic       char(32)                 packed unaligned dcl 45 set ref 152* 154* 158* 162*
ios_$abort                      000066 constant        entry                    external dcl 102 ref 306
ios_$attach                     000036 constant        entry                    external dcl 102 ref 149
ios_$changemode                 000060 constant        entry                    external dcl 102 ref 292
ios_$detach                     000040 constant        entry                    external dcl 102 ref 162
ios_$getsize                    000054 constant        entry                    external dcl 102 ref 173 213 275
ios_$order                      000056 constant        entry                    external dcl 102 ref 280
ios_$read                       000042 constant        entry                    external dcl 102 ref 196
ios_$readsync                   000070 constant        entry                    external dcl 102 ref 317
ios_$resetread                  000062 constant        entry                    external dcl 102 ref 297
ios_$resetwrite                 000064 constant        entry                    external dcl 102 ref 301
ios_$seek                       000046 constant        entry                    external dcl 102 ref 257
ios_$setsize                    000052 constant        entry                    external dcl 102 ref 271
ios_$tell                       000050 constant        entry                    external dcl 102 ref 263
ios_$worksync                   000074 constant        entry                    external dcl 102 ref 331
ios_$write                      000044 constant        entry                    external dcl 102 ref 238
ios_$writesync                  000072 constant        entry                    external dcl 102 ref 327
l1                              000100 automatic       fixed bin(17,0)          dcl 45 set ref 124* 139 151 164 204 241 259 266 273
                                                                                  278 282 295 299 303 308 319 329 334 334 370 370
l2                              000101 automatic       fixed bin(17,0)          dcl 45 set ref 126* 149 149 162 162 173 173 196 196
                                                                                  213 213 220 220 238 238 257 257 263 263 271 271
                                                                                  275 275 280 280 292 292 297 297 301 301 306 306
                                                                                  317 317 327 327 331 331 337
l3                              000102 automatic       fixed bin(17,0)          dcl 45 set ref 128* 149 149 154 158 166 167 167 206
                                                                                  207 207 257 257 263 263 268 268 269 269 280 280
                                                                                  287 287 288 289* 317 317 327 327 331 331
l4                              000103 automatic       fixed bin(17,0)          dcl 45 set ref 131* 149 149 159 181 181 182 182 187
                                                                                  187 188 188 226 226 231 231 247 251 261 311 311
                                                                                  312 312 322 322
l5                              000104 automatic       fixed bin(17,0)          dcl 45 set ref 134* 144 144 145 146* 191 191 192 192
                                                                                  234 234 252 252 253 253
length                                                 builtin function         dcl 119 ref 167 167 207 207
limit                           000236 automatic       fixed bin(17,0)          dcl 45 set ref 309* 311* 317* 320* 322* 327*
mode                            000133 automatic       char(128)                packed unaligned dcl 45 set ref 141* 144* 147* 149*
                                                                                  152* 155* 159* 162* 283* 287* 290* 292*
name                            000427 automatic       char(32)                 packed unaligned dcl 45 set ref 337* 353* 357* 360*
                                                                                  361* 362* 363* 364*
nelem                           000413 automatic       fixed bin(17,0)          dcl 45 set ref 177* 181* 191* 196* 217* 218 226*
                                                                                  234* 238*
nelemt                          000415 automatic       fixed bin(17,0)          dcl 45 set ref 196* 198 201* 218* 219 220* 238* 239*
null                                                   builtin function         dcl 119 ref 172 212 280 280
offset                          000412 automatic       fixed bin(17,0)          dcl 45 set ref 176* 180* 187* 196* 216* 225* 231*
                                                                                  238* 244* 248* 252* 257* 263* 264*
old_mode                        000174 automatic       char(128)                packed unaligned dcl 45 set ref 292* 293*
old_status                      000234 automatic       bit(72)                  dcl 45 set ref 305* 306*
p1                              000106 automatic       pointer                  dcl 45 set ref 124* 139 151 164 204 241 259 266 273
                                                                                  278 282 295 299 303 308 319 329 334 370
p2                              000110 automatic       pointer                  dcl 45 set ref 126* 149 162 173 196 213 220 238 257
                                                                                  263 271 275 280 292 297 301 306 317 327 331 337
p3                              000112 automatic       pointer                  dcl 45 set ref 128* 149 154 158 166 167 167 206 207
                                                                                  207 257 263 268 269 280 287 289* 317 327 331
p4                              000114 automatic       pointer                  dcl 45 set ref 131* 149 159 181 182 187 188 226 231
                                                                                  247 251 261 311 312 322
p5                              000116 automatic       pointer                  dcl 45 set ref 134* 144 146* 191 192 234 252 253
path                            000252 automatic       char(168)                packed unaligned dcl 45 set ref 166* 167 167 199*
                                                                                  206* 207 207 340*
pos                             000173 automatic       fixed bin(17,0)          dcl 45 set ref 142* 144 145* 145 147 285* 287 288*
                                                                                  288 290
ptrname2                        000416 automatic       char(32)                 packed unaligned dcl 45 set ref 243* 247* 251* 257*
                                                                                  260* 261* 263*
quit                      1(16)        based           bit(1)                   level 2 packed packed unaligned dcl 75 ref 363
s                                      based           structure                level 1 dcl 75
segptr                          000410 automatic       pointer                  dcl 45 set ref 170* 172 196* 210* 212 238*
status                          000240 automatic       bit(72)                  dcl 45 set ref 123 149* 162* 173* 174 196* 213* 214
                                                                                  238* 257* 263* 271* 275* 280* 292* 297* 301* 306*
                                                                                  317* 327* 331* 354 355*
statusp                         000120 automatic       pointer                  dcl 45 set ref 123* 197 239 264 276 293 354* 357 357
                                                                                  360 361 362 363 364
str                                    parameter       char                     packed unaligned dcl 368 set ref 366 370*
substr                                                 builtin function         dcl 119 set ref 144* 147* 174 214 287* 290*
sys_info$max_seg_size           000014 external static fixed bin(17,0)          dcl 89 ref 177
whoami                          000010 internal static char(8)                  initial dcl 41 set ref 45 340* 344* 370*

NAMES DECLARED BY EXPLICIT CONTEXT.
bad_args                        003307 constant        label                    dcl 344 ref 125 127 140 157 165 205 250 261 267 274
                                                                                  279 296 300 304 310 321 330
checkstatus                     003334 constant        entry                    external dcl 349
end_iocall                      003556 constant        label                    dcl 376 ref 372
iocall                          000313 constant        entry                    external dcl 39
limit_4                         003017 constant        label                    dcl 312 ref 323
nelem_4                         001107 constant        label                    dcl 182 ref 227
nelem_5                         001230 constant        label                    dcl 192 ref 235
num_err                         003557 constant        entry                    internal dcl 366 ref 182 188 192 253 269 312
offset_4                        001161 constant        label                    dcl 188 ref 232
path_err                        003265 constant        label                    dcl 340 ref 169 172 209 212
status_check                    003357 constant        label                    dcl 357 ref 338

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4134        4232    3644        4144
Length      4464    3644        76         216     267           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
iocall                              436 external procedure  is an external procedure.  
num_err                                 internal procedure  shares stack frame of external procedure iocall.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 whoami                      iocall

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
iocall                   000100 l1                          iocall
                         000101 l2                          iocall
                         000102 l3                          iocall
                         000103 l4                          iocall
                         000104 l5                          iocall
                         000106 p1                          iocall
                         000110 p2                          iocall
                         000112 p3                          iocall
                         000114 p4                          iocall
                         000116 p5                          iocall
                         000120 statusp                     iocall
                         000122 command_name                iocall
                         000132 count                       iocall
                         000133 mode                        iocall
                         000173 pos                         iocall
                         000174 old_mode                    iocall
                         000234 old_status                  iocall
                         000236 limit                       iocall
                         000240 status                      iocall
                         000242 ioname2                     iocall
                         000252 path                        iocall
                         000324 dir                         iocall
                         000376 entry                       iocall
                         000406 code                        iocall
                         000410 segptr                      iocall
                         000412 offset                      iocall
                         000413 nelem                       iocall
                         000414 bit_count                   iocall
                         000415 nelemt                      iocall
                         000416 ptrname2                    iocall
                         000426 element_size                iocall
                         000427 name                        iocall

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_ptr                   cv_dec_check_                 expand_path_
hcs_$initiate_count           hcs_$make_seg                 hcs_$set_bc                   ioa_
ios_$abort                    ios_$attach                   ios_$changemode               ios_$detach
ios_$getsize                  ios_$order                    ios_$read                     ios_$readsync
ios_$resetread                ios_$resetwrite               ios_$seek                     ios_$setsize
ios_$tell                     ios_$worksync                 ios_$write                    ios_$writesync

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$noarg            sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     45 000304        39 000312       123 000321       124 000323       125 000342       126 000344       127 000363
    128 000365       129 000404       131 000411       132 000430       134 000435       135 000454       136 000461
    139 000463       140 000471       141 000473       142 000476       143 000500       144 000504       145 000512
    146 000516       147 000533       148 000541       149 000543       150 000605       151 000606       152 000612
    153 000623       154 000625       155 000632       156 000635       157 000636       158 000640       159 000645
    162 000652       163 000702       164 000703       165 000707       166 000713       167 000720       169 000747
    170 000751       172 001010       173 001014       174 001040       175 001044       176 001047       177 001050
    178 001055       179 001056       180 001060       181 001061       182 001105       185 001130       186 001131
    187 001133       188 001157       191 001202       192 001226       196 001251       197 001307       198 001311
    199 001341       201 001363       203 001403       204 001404       205 001410       206 001414       207 001421
    209 001450       210 001452       212 001515       213 001521       214 001545       215 001551       216 001554
    217 001555       218 001560       219 001562       220 001564       223 001621       224 001622       225 001624
    226 001625       227 001651       229 001653       230 001654       231 001656       232 001702       234 001704
    235 001730       238 001732       239 001770       240 002012       241 002013       242 002017       243 002021
    244 002024       245 002025       246 002026       247 002030       248 002035       249 002036       250 002037
    251 002041       252 002046       253 002072       257 002115       258 002154       259 002155       260 002161
    261 002167       263 002176       264 002235       265 002260       266 002261       267 002265       268 002267
    269 002313       271 002341       272 002365       273 002366       274 002372       275 002374       276 002420
    277 002442       278 002443       279 002447       280 002451       281 002506       282 002507       283 002513
    284 002516       285 002521       286 002523       287 002530       288 002536       289 002542       290 002557
    291 002565       292 002567       293 002616       294 002643       295 002644       296 002650       297 002652
    298 002672       299 002673       300 002677       301 002701       302 002721       303 002722       304 002726
    305 002730       306 002732       307 002755       308 002756       309 002762       310 002767       311 002771
    312 003015       317 003040       318 003073       319 003074       320 003100       321 003105       322 003107
    323 003133       327 003135       328 003170       329 003171       330 003175       331 003177       332 003232
    334 003233       335 003256       337 003257       338 003264       340 003265       341 003306       344 003307
    345 003330       349 003331       353 003342       354 003345       355 003347       356 003354       357 003357
    360 003401       361 003425       362 003454       363 003500       364 003527       376 003556       366 003557
    370 003575       372 003643


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
