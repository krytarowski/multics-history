	COMPILATION LISTING OF SEGMENT ms_salv_util_v3_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 05/09/85  1111.1 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* ******************************************************
        8*   *                                                    *
        9*   *                                                    *
       10*   * Copyright (c) 1972 by Massachusetts Institute of   *
       11*   * Technology and Honeywell Information Systems, Inc. *
       12*   *                                                    *
       13*   *                                                    *
       14*   ****************************************************** */
       15 
       16 ms_salv_util_v3_: proc (a_forward, a_salv_ptr, a_new_alloc_ptr, a_new_ht_ptr, a_block_size, a_seg_size, a_alloc_len, a_hdr_alloc_len,
       17 	     a_mseg_access_class, a_saved_messages, a_saved_blocks, a_last_saved_ms_ptr);
       18 
       19 /* Modified for version 3 message segments by J. Stern, 10/30/74 */
       20 /* Modified by J. Stern, 11/14/75 */
       21 /* Modified 3/77 by Charlie Davis for the installation of version 4 message segments */
       22 
       23 dcl (a_saved_blocks,				/* number of saved message blocks (argument) */
       24      a_saved_messages,				/* number of saved messages (argument) */
       25      block_bit_count,				/* bit count of message portion in block */
       26      block_hdr_size,				/* words in header */
       27      block_trailer_size,				/* words in trailer */
       28      first_full_block_bit_count,			/* bits allocated to first block message portion */
       29      full_block_bit_count,				/* bits allocated to message portion */
       30      i,						/* do loop index */
       31      htx,						/* hash table index */
       32      max_message_blocks,				/* maximum blocks in a message */
       33      message_blocks,				/* number of unchecked blocks in message */
       34      saved_blocks init (0),				/* number of saved message blocks (internal) */
       35      saved_messages init (0),				/* number of saved messages (internal) */
       36      tsaved_blocks,					/* blocks saved in message */
       37      zero_words (8) init (0, 0, 0, 0, 0, 0, 0, 0)
       38      ) fixed bin;
       39 
       40 dcl (a_alloc_len,					/* length of allocation bit string */
       41      a_hdr_alloc_len,				/* the part of alloc_len devoted to the header */
       42      a_block_size,					/* block size */
       43      a_seg_size,					/* max length of message seg */
       44      alloc_len,					/* length of allocation bit string */
       45      hdr_alloc_len,
       46      backward_offset,				/* offset to backward threaded message */
       47      bit_off,					/* offset of allocation bit for block */
       48      block_ms_words,				/* allocated size for message portion */
       49      block_offset,					/* offset to message block */
       50      block_size,					/* size of message block in words */
       51      first_block_ms_words,				/* allocated size for first block message portion */
       52      forward_offset,				/* offset to forward threaded message */
       53      max_message_size,				/* maximum words in a message */
       54      message_words,					/* word count of message */
       55      ms_offset,					/* offset to first block of message */
       56      mseg_data_v3_$block_size ext,			/* default block size */
       57      mseg_data_v3_$max_message_size ext,
       58      next_block_offset,				/* offset to next message block in message */
       59      seg_size,
       60      previous_offset init (0),			/* offset to previous message */
       61      tr_offset)					/* offset from beginning of block to trailer */
       62      fixed bin (18);
       63 
       64 dcl (a_forward,					/* ON if salvage is forward (argument) */
       65      first_block,					/* ON if block is first block in message */
       66      forward)					/* ON if salvage is forward (internal) */
       67      bit (1) aligned;
       68 
       69 dcl (a_last_saved_ms_ptr,				/* pointer to last saved message (argument) */
       70      a_new_alloc_ptr,				/* pointer to new allocation bits(argument) */
       71      a_new_ht_ptr,					/* pointer to new hash table (argument) */
       72      a_salv_ptr,					/* pointer to where to begin salvaging */
       73      last_saved_ms_ptr init (null),			/* pointer to last saved message(internal) */
       74      new_alloc_ptr,					/* pointer to new allocation bits(argument) */
       75      new_ht_ptr,					/* pointer to new hash table (internal) */
       76      next_ms_ptr,					/* pointer to next message */
       77      test_block_ptr,				/* pointer to message block being tested */
       78      test_ms_ptr)					/* pointer to message being tested */
       79      ptr;
       80 
       81 dcl  prev_ms_id bit (72) aligned;			/* previous message id */
       82 
       83 dcl (a_mseg_access_class,
       84      mseg_access_class) bit (72) aligned;		/* message segment access class */
       85 
       86 dcl 1 new_hash_table aligned based (new_ht_ptr),		/* new hash table */
       87     2 last_in_bucket (0:511) bit (18) unaligned;
       88 
       89 dcl (addr, addrel, divide, fixed, mod, null, ptr, rel, size, substr) builtin;
       90 
       91 dcl  bit_mask (alloc_len) based (new_alloc_ptr) bit (1) unaligned; /* mask for setting allocation bits */
       92 
       93 dcl  zeroes char (32) aligned based (addr (zero_words (1)));
       94 
       95 
  1     1 /* BEGIN include file mseg_hdr_v3.incl.pl1 */
  1     2 
  1     3 dcl  mptr ptr,					/* pointer to message segment */
  1     4 
  1     5      1 mseg_hdr aligned based (mptr),			/* message segment header format */
  1     6      2 lock bit (36) aligned,				/* standard file system lock */
  1     7      2 mseg_pattern bit (36) aligned,			/* to identify message segments */
  1     8      2 hdr_ms_access_class bit (72) aligned,		/* access class of header message */
  1     9      2 pad (4) fixed bin,
  1    10      2 first_ms_offset bit (18) aligned,		/* offset to first logical message */
  1    11      2 last_ms_offset bit (18) aligned,			/* offset to last logical message */
  1    12      2 alloc_len fixed bin,				/* length of allocation bit string */
  1    13      2 space_left fixed bin,				/* number of empty blocks */
  1    14      2 number_of_messages fixed bin,			/* number of messages in segment */
  1    15      2 block_size fixed bin,				/* message block size */
  1    16      2 switches,
  1    17      3 mip bit (1) unaligned,				/* ON if modification is in progress */
  1    18      3 os bit (1) unaligned,				/* ON if message segment was salvaged */
  1    19      3 ms_in_hdr bit (1) unaligned,			/* ON if there is a message in the header */
  1    20      3 sip bit (1) unaligned,				/* ON if salvage is in progress */
  1    21      3 pad2 bit (32) unaligned,
  1    22      2 version_number fixed bin,
  1    23      2 hdr_ms bit (64 * 36) aligned,			/* space for header message */
  1    24      2 hash_table aligned,				/* message ID hash table */
  1    25      3 last_in_bucket (0:511) bit (18) unaligned,		/* offset of last message in this hash table bucket */
  1    26      2 alloc_bits bit (alloc_len) aligned;		/* allocation bit string */
  1    27 
  1    28 dcl (version_number fixed bin init (3),			/* message segment version number */
  1    29      header_pattern bit (36) aligned init ((18) "01"b))	/* header identification pattern */
  1    30      internal static;
  1    31 
  1    32 /* END include file mseg_hdr_v3.incl.pl1 */
       96 
       97 
  2     1 /* BEGIN Message Block Header include file */
  2     2 
  2     3 dcl  block_ptr ptr,					/* pointer to message block */
  2     4 
  2     5      1 ms_block_hdr aligned based(block_ptr),		/* message block header structure */
  2     6       2 f_offset bit(18) unaligned,			/* offset to next block of message */
  2     7       2 first_block bit(1) unaligned,			/* ON if block is first in message */
  2     8       2 block_count bit(17) unaligned;			/* number of message bits in block */
  2     9 
  2    10 /* END Message Block Header include file */
       98 
       99 
  3     1 /* BEGIN include file ms_block_trailer_v3.incl.pl1 */
  3     2 
  3     3 dcl  tr_ptr ptr,					/* pointer to message block trailer area */
  3     4 
  3     5      1 ms_block_trailer aligned based (tr_ptr),		/* message block trailer structure */
  3     6      2 tr_pattern bit (36) aligned,			/* for identifying beginning of trailer */
  3     7      2 f_offset bit (18) unaligned,			/* offset to next logical message */
  3     8      2 b_offset bit (18) unaligned,			/* offset to previous logical message */
  3     9      2 ms_size bit (18) unaligned,			/* bit count of message */
  3    10      2 back_in_bucket bit (18) unaligned,		/* offset of preceding message in same hash bucket */
  3    11      2 ms_id bit (72) aligned,			/* message id */
  3    12      2 ring_no bit (18) unaligned,			/* validation level */
  3    13      2 pad bit (18) unaligned,
  3    14      2 sender_id char (32) aligned,			/* id of message sender */
  3    15      2 sender_authorization bit (72) aligned,		/* access authorization of message sender */
  3    16      2 access_class bit (72) aligned;			/* access class of this message */
  3    17 
  3    18 dcl  trailer_pattern bit (36) aligned init ((36) "1"b)	/* trailer identification pattern */
  3    19      internal static;
  3    20 
  3    21 /* END include file ms_block_trailer_v3.incl.pl1 */
      100 
      101 
      102 
      103 dcl  aim_check_$greater_or_equal ext entry
      104     (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
      105 
      106 /*  */
      107 
      108 	mptr = ptr (a_salv_ptr, 0);			/* make pointer to message segment */
      109 
      110 	max_message_size = mseg_data_v3_$max_message_size;
      111 	block_size = a_block_size;
      112 	max_message_blocks = divide (max_message_size, block_size, 18, 0); /* compute max blocks in message */
      113 	block_hdr_size = size (ms_block_hdr);
      114 	block_trailer_size = size (ms_block_trailer);
      115 
      116 	forward = a_forward;			/* copy argument */
      117 	next_ms_ptr = a_salv_ptr;			/* where to begin salvaging */
      118 	seg_size = a_seg_size;
      119 	alloc_len = a_alloc_len;
      120 	hdr_alloc_len = a_hdr_alloc_len;
      121 	ms_offset = fixed (rel (next_ms_ptr), 18);	/* offset of where to begin salvaging */
      122 	call check_offset (ms_offset);
      123 	new_alloc_ptr = a_new_alloc_ptr;		/* copy argument */
      124 	new_ht_ptr = a_new_ht_ptr;
      125 	mseg_access_class = a_mseg_access_class;
      126 	tr_offset = block_size - block_trailer_size;	/* initialize trailer offset */
      127 	first_block_ms_words =			/* intialize word count of full first block */
      128 	     block_size - (block_hdr_size + block_trailer_size);
      129 	first_full_block_bit_count =			/* initialize bit count of full first block */
      130 	     first_block_ms_words * 36;
      131 	full_block_bit_count =			/* initialize bit count of full block */
      132 	     (block_size - block_hdr_size) * 36;
      133 	block_ms_words =				/* initialize word count of full block */
      134 	     block_size - block_hdr_size;
      135 	if forward then prev_ms_id = (72) "0"b;
      136 	else prev_ms_id = (72) "1"b;
      137 
      138 /*  */
      139 
      140 	begin;
      141 
      142 dcl  bit_offset (max_message_blocks) fixed bin (18);	/* array of offsets into alloc bits */
      143 
      144 CHECK_MESSAGE:
      145 
      146 	     first_block = "1"b;			/* remember this is a first block of a message */
      147 	     tsaved_blocks = 0;			/* initialize blocks saved in message */
      148 
      149 	     test_ms_ptr = next_ms_ptr;		/* set pointer to message to be tested */
      150 	     ms_offset = fixed (rel (next_ms_ptr), 18);	/* set offset of message to be tested */
      151 	     tr_ptr = addrel (test_ms_ptr, tr_offset);	/* make a pointer to the trailer */
      152 	     if tr_ptr -> ms_block_trailer.tr_pattern ^= trailer_pattern /* no trailer pattern */
      153 	     then go to FIN;
      154 	     forward_offset =			/* get offset to next message */
      155 		fixed (tr_ptr -> ms_block_trailer.f_offset, 18);
      156 	     if forward_offset ^= 0
      157 	     then call check_offset (forward_offset);	/* forward offset off end of segment */
      158 	     else if mseg_hdr.last_ms_offset ^= rel (test_ms_ptr) /* header doesn't agree */
      159 	     then go to FIN;			/* give up */
      160 	     backward_offset =			/* get offset to previous message */
      161 		fixed (tr_ptr -> ms_block_trailer.b_offset, 18);
      162 	     if backward_offset ^= 0
      163 	     then call check_offset (backward_offset);	/* previous offset off end of message */
      164 	     else if mseg_hdr.first_ms_offset ^= rel (test_ms_ptr) /* header doesn't agree */
      165 	     then go to FIN;
      166 
      167 	     if ms_size = "0"b			/* check for zeroing out */
      168 	     | ms_id = "0"b
      169 	     | sender_id = zeroes
      170 	     then go to FIN;
      171 
      172 	     if ^aim_check_$greater_or_equal (mseg_access_class, access_class)
      173 	     then go to FIN;
      174 	     if ^aim_check_$greater_or_equal (access_class, sender_authorization)
      175 	     then go to FIN;
      176 
      177 	     htx = fixed (substr (ms_id, 64, 9));	/* get hash table index of message */
      178 	     block_offset = fixed (tr_ptr -> ms_block_trailer.back_in_bucket);
      179 	     if block_offset ^= 0			/* not end of thread */
      180 	     then call check_offset (block_offset);	/* check the hash bucket offset */
      181 
      182 	     if (forward)				/* forward salvage */
      183 	     then do;
      184 
      185 		if previous_offset ^= 0		/* there was a previous message */
      186 		then if backward_offset ^=
      187 		     previous_offset		/* this message doesn't point to it */
      188 		     then go to FIN;		/* give up */
      189 		next_ms_ptr = ptr (test_ms_ptr, forward_offset);
      190 
      191 		if substr (prev_ms_id, 19, 54) >= substr (ms_id, 19, 54)
      192 		then do;				/* should be monotonically increasing */
      193 		     ms_id = ""b;			/* make ms_id look bad for backward salvage too!! */
      194 		     go to FIN;
      195 		end;
      196 
      197 	     end;
      198 
      199 	     else					/* backward salvage */
      200 	     do;
      201 
      202 		if previous_offset ^= 0		/* there was a previous message */
      203 		then if forward_offset ^=
      204 		     previous_offset		/* this message doesn't point to it */
      205 		     then go to FIN;		/* give up */
      206 		next_ms_ptr = ptr (test_ms_ptr, backward_offset);
      207 
      208 		if substr (prev_ms_id, 19, 54) <= substr (ms_id, 19, 54)
      209 		then go to FIN;			/* should be monotonically decreasing */
      210 
      211 	     end;
      212 
      213 	     previous_offset = ms_offset;		/* remember for next message check */
      214 	     prev_ms_id = ms_id;
      215 
      216 	     message_words =			/* calculate number of words in message */
      217 		divide (fixed (tr_ptr -> ms_block_trailer.ms_size, 18)+35, 36, 18, 0);
      218 
      219 	     if message_words <= 0			/* bad word count */
      220 	     then go to FIN;			/* give up */
      221 	     if message_words > max_message_size
      222 	     then go to FIN;
      223 
      224 	     if message_words <= first_block_ms_words	/* calculate blocks in message */
      225 	     then message_blocks = 1;
      226 	     else
      227 	     message_blocks =
      228 		divide (message_words-first_block_ms_words+block_ms_words-1, block_ms_words, 17, 0)+1;
      229 	     block_offset = ms_offset;
      230 
      231 	     test_block_ptr = test_ms_ptr;		/* set pointer for testing rest of block */
      232 
      233 /*  */
      234 
      235 /* check the block header */
      236 
      237 CHECK_BLOCK:
      238 
      239 /* check to see if the block has been allocated */
      240 
      241 	     bit_off = divide (block_offset, block_size, 18, 0)+1; /* calculate bit offset in alloc bits */
      242 
      243 	     do i = 1 to tsaved_blocks;		/* check against other blocks in this message */
      244 		if bit_offset (i) = bit_off		/* block is used */
      245 		then go to FIN;			/* give up */
      246 	     end;
      247 
      248 	     if new_alloc_ptr -> bit_mask (bit_off) = "1"b /* block is used */
      249 	     then go to FIN;
      250 
      251 	     if test_block_ptr -> ms_block_hdr.first_block ^=
      252 	     first_block				/* bad first block flag */
      253 	     then go to FIN;
      254 
      255 	     block_bit_count =			/* get size of message portion in block */
      256 		fixed (test_block_ptr -> ms_block_hdr.block_count, 17);
      257 	     if block_bit_count <= 0			/* bad block bit count */
      258 	     then go to FIN;			/* give up */
      259 
      260 	     if (first_block)			/* first block of a message */
      261 	     then do;
      262 
      263 		if message_blocks ^= 1		/* another block follows */
      264 		then do;
      265 		     if block_bit_count ^=
      266 		     first_full_block_bit_count	/* error in block bit count */
      267 		     then go to FIN;
      268 		end;
      269 		else				/* no blocks follow */
      270 		if block_bit_count >
      271 		first_full_block_bit_count		/* error in block bit count */
      272 		then go to FIN;
      273 	     end;
      274 
      275 	     else					/* not first block in message */
      276 	     do;
      277 		if message_blocks ^= 1		/* another block follows */
      278 		then do;
      279 		     if block_bit_count ^=
      280 		     full_block_bit_count		/* error in block bit count */
      281 		     then go to FIN;		/* give up */
      282 		end;
      283 		else				/* last block in message */
      284 		if block_bit_count > full_block_bit_count /* bad block bit count */
      285 		then go to FIN;			/* give up */
      286 	     end;
      287 
      288 	     next_block_offset =			/* get the offset to the next message block */
      289 		fixed (test_block_ptr -> ms_block_hdr.f_offset, 18);
      290 
      291 	     bit_offset (tsaved_blocks + 1) = bit_off;	/* remember location of block */
      292 
      293 	     if message_blocks = 1			/* last block in message */
      294 	     then do;
      295 		if next_block_offset ^= 0		/* block pointer bad */
      296 		then go to FIN;
      297 		else				/* legitimate end of message */
      298 		do;
      299 		     saved_blocks =			/* add in saved blocks */
      300 			saved_blocks + tsaved_blocks +1;
      301 		     do i = 1 to tsaved_blocks + 1;	/* turn on the appropriate allocation bits */
      302 			new_alloc_ptr -> bit_mask (bit_offset (i)) = "1"b;
      303 		     end;
      304 		     back_in_bucket = new_hash_table.last_in_bucket (htx); /* set back ptr to previous last */
      305 		     new_hash_table.last_in_bucket (htx) = rel (test_ms_ptr); /* make this one the last in bucket */
      306 		     saved_messages =		/* add in saved message */
      307 			saved_messages + 1;
      308 		     last_saved_ms_ptr = test_ms_ptr;	/* set pointer to saved message */
      309 		     go to CHECK_MESSAGE;
      310 		end;
      311 	     end;
      312 
      313 	     else					/* not end of message */
      314 	     do;
      315 		call check_offset (next_block_offset);	/* check offset to next block */
      316 		first_block = "0"b;			/* remember next block is not a first block */
      317 		message_blocks = message_blocks - 1;	/* decrement blocks left to check */
      318 		tsaved_blocks = tsaved_blocks + 1;	/* increment temporary saved block count */
      319 		block_offset = next_block_offset;	/* reset for testing next block */
      320 		test_block_ptr =			/* make a pointer to the next block */
      321 		     ptr (test_block_ptr, next_block_offset);
      322 		go to CHECK_BLOCK;
      323 	     end;
      324 
      325 	end;					/* of BEGIN block */
      326 
      327 /*  */
      328 
      329 FIN:
      330 
      331 	a_saved_messages = saved_messages;		/* return appropriate values */
      332 	a_saved_blocks = saved_blocks;
      333 	a_last_saved_ms_ptr = last_saved_ms_ptr;
      334 	return;
      335 
      336 
      337 check_offset: proc (a_relp);				/* procedure to check validity of an offset */
      338 
      339 dcl (a_relp, relp) fixed bin (18);
      340 
      341 	     relp = a_relp;
      342 	     if relp + block_size > seg_size then go to FIN; /* offset beyond max length of segment */
      343 	     if mod (relp, block_size) ^= 0 then go to FIN; /* not offset of a block */
      344 	     relp = divide (relp, block_size, 18, 0) +1;	/* convert block offset to block number */
      345 	     if relp <= hdr_alloc_len then go to FIN;	/* offset within header blocks */
      346 	     if relp > alloc_len then go to FIN;	/* offset beyond last block */
      347 
      348 	end check_offset;
      349 
      350      end ms_salv_util_v3_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/06/85  1619.0  ms_salv_util_v3_.pl1              >spec>on>mseg>ms_salv_util_v3_.pl1
96           1    05/06/85  1121.9  mseg_hdr_v3.incl.pl1              >spec>on>mseg>mseg_hdr_v3.incl.pl1
98           2    05/06/85  1121.7  ms_block_hdr_v3.incl.pl1          >spec>on>mseg>ms_block_hdr_v3.incl.pl1
100          3    05/06/85  1121.7  ms_block_trailer_v3.incl.pl1      >spec>on>mseg>ms_block_trailer_v3.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_alloc_len                            parameter       fixed bin(18,0)          dcl 40 ref 16 119
a_block_size                           parameter       fixed bin(18,0)          dcl 40 ref 16 111
a_forward                              parameter       bit(1)                   dcl 64 ref 16 116
a_hdr_alloc_len                        parameter       fixed bin(18,0)          dcl 40 ref 16 120
a_last_saved_ms_ptr                    parameter       pointer                  dcl 69 set ref 16 333*
a_mseg_access_class                    parameter       bit(72)                  dcl 83 ref 16 125
a_new_alloc_ptr                        parameter       pointer                  dcl 69 ref 16 123
a_new_ht_ptr                           parameter       pointer                  dcl 69 ref 16 124
a_relp                                 parameter       fixed bin(18,0)          dcl 339 ref 337 341
a_salv_ptr                             parameter       pointer                  dcl 69 ref 16 108 117
a_saved_blocks                         parameter       fixed bin(17,0)          dcl 23 set ref 16 332*
a_saved_messages                       parameter       fixed bin(17,0)          dcl 23 set ref 16 329*
a_seg_size                             parameter       fixed bin(18,0)          dcl 40 ref 16 118
access_class             20            based           bit(72)                  level 2 dcl 3-3 set ref 172* 174*
addr                                                   builtin function         dcl 89 ref 167
addrel                                                 builtin function         dcl 89 ref 151
aim_check_$greater_or_equal     000012 constant        entry                    external dcl 103 ref 172 174
alloc_len                       000124 automatic       fixed bin(18,0)          dcl 40 set ref 119* 346
b_offset                  1(18)        based           bit(18)                  level 2 packed unaligned dcl 3-3 ref 160
back_in_bucket            2(18)        based           bit(18)                  level 2 packed unaligned dcl 3-3 set ref 178 304*
backward_offset                 000126 automatic       fixed bin(18,0)          dcl 40 set ref 160* 162 162* 185 206
bit_mask                               based           bit(1)                   array unaligned dcl 91 set ref 248 302*
bit_off                         000127 automatic       fixed bin(18,0)          dcl 40 set ref 237* 244 248 291
bit_offset                      000100 automatic       fixed bin(18,0)          array dcl 142 set ref 244 291* 302
block_bit_count                 000100 automatic       fixed bin(17,0)          dcl 23 set ref 255* 257 265 269 279 283
block_count               0(19)        based           bit(17)                  level 2 packed unaligned dcl 2-3 ref 255
block_hdr_size                  000101 automatic       fixed bin(17,0)          dcl 23 set ref 113* 127 131 133
block_ms_words                  000130 automatic       fixed bin(18,0)          dcl 40 set ref 133* 226 226
block_offset                    000131 automatic       fixed bin(18,0)          dcl 40 set ref 178* 179 179* 229* 237 319*
block_ptr                              automatic       pointer                  dcl 2-3 ref 113
block_size                      000132 automatic       fixed bin(18,0)          dcl 40 set ref 111* 112 126 127 131 133 237 342 343
                                                                                  344
block_trailer_size              000102 automatic       fixed bin(17,0)          dcl 23 set ref 114* 126 127
divide                                                 builtin function         dcl 89 ref 112 216 226 237 344
f_offset                               based           bit(18)                  level 2 in structure "ms_block_hdr" packed unaligned
                                                                                  dcl 2-3 in procedure "ms_salv_util_v3_" ref 288
f_offset                  1            based           bit(18)                  level 2 in structure "ms_block_trailer" packed
                                                                                  unaligned dcl 3-3 in procedure "ms_salv_util_v3_"
                                                                                  ref 154
first_block                     000144 automatic       bit(1)                   dcl 64 in procedure "ms_salv_util_v3_" set ref 144*
                                                                                  251 260 316*
first_block               0(18)        based           bit(1)                   level 2 in structure "ms_block_hdr" packed unaligned
                                                                                  dcl 2-3 in procedure "ms_salv_util_v3_" ref 251
first_block_ms_words            000133 automatic       fixed bin(18,0)          dcl 40 set ref 127* 129 224 226
first_full_block_bit_count      000103 automatic       fixed bin(17,0)          dcl 23 set ref 129* 265 269
first_ms_offset          10            based           bit(18)                  level 2 dcl 1-3 ref 164
fixed                                                  builtin function         dcl 89 ref 121 150 154 160 177 178 216 255 288
forward                         000145 automatic       bit(1)                   dcl 64 set ref 116* 135 182
forward_offset                  000134 automatic       fixed bin(18,0)          dcl 40 set ref 154* 156 156* 189 202
full_block_bit_count            000104 automatic       fixed bin(17,0)          dcl 23 set ref 131* 279 283
hdr_alloc_len                   000125 automatic       fixed bin(18,0)          dcl 40 set ref 120* 345
htx                             000106 automatic       fixed bin(17,0)          dcl 23 set ref 177* 304 305
i                               000105 automatic       fixed bin(17,0)          dcl 23 set ref 243* 244* 301* 302*
last_in_bucket                         based           bit(18)                  array level 2 packed unaligned dcl 86 set ref 304
                                                                                  305*
last_ms_offset           11            based           bit(18)                  level 2 dcl 1-3 ref 158
last_saved_ms_ptr               000146 automatic       pointer                  initial dcl 69 set ref 69* 308* 333
max_message_blocks              000107 automatic       fixed bin(17,0)          dcl 23 set ref 112* 142
max_message_size                000135 automatic       fixed bin(18,0)          dcl 40 set ref 110* 112 221
message_blocks                  000110 automatic       fixed bin(17,0)          dcl 23 set ref 224* 226* 263 277 293 317* 317
message_words                   000136 automatic       fixed bin(18,0)          dcl 40 set ref 216* 219 221 224 226
mod                                                    builtin function         dcl 89 ref 343
mptr                            000166 automatic       pointer                  dcl 1-3 set ref 108* 158 164
ms_block_hdr                           based           structure                level 1 dcl 2-3 ref 113
ms_block_trailer                       based           structure                level 1 dcl 3-3 set ref 114
ms_id                     3            based           bit(72)                  level 2 dcl 3-3 set ref 167 177 191 193* 208 214
ms_offset                       000137 automatic       fixed bin(18,0)          dcl 40 set ref 121* 122* 150* 213 229
ms_size                   2            based           bit(18)                  level 2 packed unaligned dcl 3-3 ref 167 216
mseg_access_class               000164 automatic       bit(72)                  dcl 83 set ref 125* 172*
mseg_data_v3_$max_message_size  000010 external static fixed bin(18,0)          dcl 40 ref 110
mseg_hdr                               based           structure                level 1 dcl 1-3
new_alloc_ptr                   000150 automatic       pointer                  dcl 69 set ref 123* 248 302
new_hash_table                         based           structure                level 1 dcl 86
new_ht_ptr                      000152 automatic       pointer                  dcl 69 set ref 124* 304 305
next_block_offset               000140 automatic       fixed bin(18,0)          dcl 40 set ref 288* 295 315* 319 320
next_ms_ptr                     000154 automatic       pointer                  dcl 69 set ref 117* 121 149 150 189* 206*
null                                                   builtin function         dcl 89 ref 69
prev_ms_id                      000162 automatic       bit(72)                  dcl 81 set ref 135* 136* 191 208 214*
previous_offset                 000142 automatic       fixed bin(18,0)          initial dcl 40 set ref 40* 185 185 202 202 213*
ptr                                                    builtin function         dcl 89 ref 108 189 206 320
rel                                                    builtin function         dcl 89 ref 121 150 158 164 305
relp                            000100 automatic       fixed bin(18,0)          dcl 339 set ref 341* 342 343 344* 344 345 346
saved_blocks                    000111 automatic       fixed bin(17,0)          initial dcl 23 set ref 23* 299* 299 332
saved_messages                  000112 automatic       fixed bin(17,0)          initial dcl 23 set ref 23* 306* 306 329
seg_size                        000141 automatic       fixed bin(18,0)          dcl 40 set ref 118* 342
sender_authorization     16            based           bit(72)                  level 2 dcl 3-3 set ref 174*
sender_id                 6            based           char(32)                 level 2 dcl 3-3 ref 167
size                                                   builtin function         dcl 89 ref 113 114
substr                                                 builtin function         dcl 89 ref 177 191 191 208 208
test_block_ptr                  000156 automatic       pointer                  dcl 69 set ref 231* 251 255 288 320* 320
test_ms_ptr                     000160 automatic       pointer                  dcl 69 set ref 149* 151 158 164 189 206 231 305 308
tr_offset                       000143 automatic       fixed bin(18,0)          dcl 40 set ref 126* 151
tr_pattern                             based           bit(36)                  level 2 dcl 3-3 ref 152
tr_ptr                          000170 automatic       pointer                  dcl 3-3 set ref 114 151* 152 154 160 167 167 167 172
                                                                                  174 174 177 178 191 193 208 214 216 304
trailer_pattern                 000010 constant        bit(36)                  initial dcl 3-18 ref 152
tsaved_blocks                   000113 automatic       fixed bin(17,0)          dcl 23 set ref 147* 243 291 299 301 318* 318
zero_words                      000114 automatic       fixed bin(17,0)          initial array dcl 23 set ref 23* 23* 23* 23* 23* 23*
                                                                                  23* 23* 167
zeroes                                 based           char(32)                 dcl 93 ref 167

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
header_pattern                         internal static bit(36)                  initial dcl 1-28
mseg_data_v3_$block_size               external static fixed bin(18,0)          dcl 40
version_number                         internal static fixed bin(17,0)          initial dcl 1-28

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_BLOCK                     000570 constant        label                    dcl 237 ref 322
CHECK_MESSAGE                   000210 constant        label                    dcl 144 ref 309
FIN                             001030 constant        label                    dcl 329 ref 152 158 164 167 172 174 185 194 202 208
                                                                                  219 221 244 248 251 257 265 269 279 283 295 342
                                                                                  343 345 346
check_offset                    001041 constant        entry                    internal dcl 337 ref 122 156 162 179 315
ms_salv_util_v3_                000025 constant        entry                    external dcl 16

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1200        1214    1113        1210
Length      1436    1113        14         206      64           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ms_salv_util_v3_                    130 external procedure  is an external procedure.  
begin block on line 140              88 begin block         uses auto adjustable storage.  
check_offset                         65 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
begin block on line 140  000100 bit_offset                  begin block on line 140
check_offset             000100 relp                        check_offset
ms_salv_util_v3_         000100 block_bit_count             ms_salv_util_v3_
                         000101 block_hdr_size              ms_salv_util_v3_
                         000102 block_trailer_size          ms_salv_util_v3_
                         000103 first_full_block_bit_count  ms_salv_util_v3_
                         000104 full_block_bit_count        ms_salv_util_v3_
                         000105 i                           ms_salv_util_v3_
                         000106 htx                         ms_salv_util_v3_
                         000107 max_message_blocks          ms_salv_util_v3_
                         000110 message_blocks              ms_salv_util_v3_
                         000111 saved_blocks                ms_salv_util_v3_
                         000112 saved_messages              ms_salv_util_v3_
                         000113 tsaved_blocks               ms_salv_util_v3_
                         000114 zero_words                  ms_salv_util_v3_
                         000124 alloc_len                   ms_salv_util_v3_
                         000125 hdr_alloc_len               ms_salv_util_v3_
                         000126 backward_offset             ms_salv_util_v3_
                         000127 bit_off                     ms_salv_util_v3_
                         000130 block_ms_words              ms_salv_util_v3_
                         000131 block_offset                ms_salv_util_v3_
                         000132 block_size                  ms_salv_util_v3_
                         000133 first_block_ms_words        ms_salv_util_v3_
                         000134 forward_offset              ms_salv_util_v3_
                         000135 max_message_size            ms_salv_util_v3_
                         000136 message_words               ms_salv_util_v3_
                         000137 ms_offset                   ms_salv_util_v3_
                         000140 next_block_offset           ms_salv_util_v3_
                         000141 seg_size                    ms_salv_util_v3_
                         000142 previous_offset             ms_salv_util_v3_
                         000143 tr_offset                   ms_salv_util_v3_
                         000144 first_block                 ms_salv_util_v3_
                         000145 forward                     ms_salv_util_v3_
                         000146 last_saved_ms_ptr           ms_salv_util_v3_
                         000150 new_alloc_ptr               ms_salv_util_v3_
                         000152 new_ht_ptr                  ms_salv_util_v3_
                         000154 next_ms_ptr                 ms_salv_util_v3_
                         000156 test_block_ptr              ms_salv_util_v3_
                         000160 test_ms_ptr                 ms_salv_util_v3_
                         000162 prev_ms_id                  ms_salv_util_v3_
                         000164 mseg_access_class           ms_salv_util_v3_
                         000166 mptr                        ms_salv_util_v3_
                         000170 tr_ptr                      ms_salv_util_v3_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
enter_begin         leave_begin         call_ext_out        call_int_this       call_int_other      return
tra_ext             alloc_auto_adj      mod_fx1             ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
aim_check_$greater_or_equal

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
mseg_data_v3_$max_message_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     16 000014        23 000032        40 000065        69 000066       108 000070       110 000074       111 000076
    112 000100       113 000103       114 000105       116 000107       117 000112       118 000115       119 000117
    120 000121       121 000123       122 000126       123 000134       124 000140       125 000143       126 000147
    127 000152       129 000160       131 000162       133 000166       135 000171       136 000176       140 000200
    142 000203       144 000210       147 000213       149 000214       150 000216       151 000221       152 000225
    154 000233       156 000240       158 000252       160 000261       162 000266       164 000300       167 000307
    172 000341       174 000364       177 000407       178 000414       179 000417       182 000430       185 000433
    189 000442       191 000447       193 000460       194 000463       197 000466       202 000467       206 000476
    208 000503       213 000520       214 000523       216 000527       219 000534       221 000540       224 000547
    226 000556       229 000564       231 000566       237 000570       243 000575       244 000606       246 000615
    248 000620       251 000631       255 000642       257 000646       260 000653       263 000656       265 000661
    268 000667       269 000670       273 000676       277 000677       279 000702       282 000710       283 000711
    288 000717       291 000723       293 000726       295 000731       299 000736       301 000743       302 000754
    303 000762       304 000764       305 000773       306 001000       308 001001       309 001003       315 001004
    316 001013       317 001015       318 001017       319 001020       320 001022       322 001026       325 001027
    329 001030       332 001033       333 001035       334 001037       337 001040       341 001046       342 001051
    343 001060       344 001070       345 001075       346 001102       348 001111


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
