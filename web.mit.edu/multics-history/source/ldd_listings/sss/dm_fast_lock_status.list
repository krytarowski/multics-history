	COMPILATION LISTING OF SEGMENT dm_fast_lock_status
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 07/13/88  1035.2 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1985 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 /* DESCRIPTION:
       10*
       11*Displays the status of all of the fast locks currently being held or awaited on by processes using DM.
       12**/
       13 
       14 /* HISTORY:
       15*
       16*Written by S. Cox, 03/20/85.
       17*Modified:
       18*05/17/85 by S. Cox: Changed to check for locks with no waiters.
       19**/
       20 
       21 
       22 /****^  HISTORY COMMENTS:
       23*  1) change(87-04-27,GDixon), approve(87-07-08,MCR7741),
       24*     audit(87-07-08,Hartogs), install(87-08-04,MR12.1-1055):
       25*     Upgraded for change to answer_table.incl.pl1 and user_table_entry.incl.pl1
       26*                                                   END HISTORY COMMENTS */
       27 
       28 
       29 /* format: style2,^inddcls,ifthenstmt,ifthendo,^indnoniterdo,^inditerdo,ind3,idind32 */
       30 
       31 dm_fast_lock_status:
       32 dmflst:
       33    proc ();
       34 
       35 /* START OF DECLARATIONS */
       36 /* Automatic */
       37 
       38 dcl     accept_control_argument	bit (1) aligned init ("0"b);
       39 dcl     answer_table_idx		fixed bin;
       40 dcl     at_least_one_lock		bit (1) init (NO);
       41 dcl     arg_idx			fixed bin;
       42 dcl     arg_len			fixed bin (21);
       43 dcl     arg_list_ptr		ptr init (null);
       44 dcl     arg_ptr			ptr;
       45 dcl     code			fixed bin (35);
       46 dcl     control_argument_idx		fixed bin;
       47 dcl     display_all_locks		bit (1) init (YES);
       48 dcl     display_header		bit (1) init (NO);
       49 dcl     display_waiters		bit (1) init (YES);
       50 dcl     end_of_chain		bit (1) init (NO);
       51 dcl     display_line_ptr		ptr;
       52 dcl     fast_lock_displayed		bit (1) init (NO);
       53 dcl     first_waiter		bit (1);
       54 dcl     force_interpretation_as_argument
       55 				bit (1) aligned init (NO);
       56 dcl     given_process_id		bit (1) init (NO);
       57 dcl     given_user_id		bit (1) init (NO);
       58 dcl     lock_list_index		fixed bin;
       59 dcl     number_of_args		fixed bin;
       60 dcl     person_id			char (22);
       61 dcl     project_id			char (9);
       62 dcl     process_id_fb		fixed bin (35);
       63 dcl     process_id_list_ptr		ptr;
       64 dcl     process_idx			fixed bin;
       65 dcl     save_lock_list_block_ptr	ptr init (null);
       66 dcl     sci_ptr			ptr init (null);
       67 dcl     this_is_a_standalone_invocation bit (1) aligned init (YES);
       68 dcl     user			char (34);
       69 dcl     user_match			bit (1) init (NO);
       70 dcl     work_area_ptr		ptr;
       71 
       72 /* Based */
       73 
       74 dcl     arg			char (arg_len) based (arg_ptr);
       75 dcl     display_line		char (MAX_LINE_LENGTH) varying based (display_line_ptr);
       76 dcl     1 process_id_list		based (process_id_list_ptr),
       77 	2 count			fixed bin (17),
       78 	2 id			(0 refer (process_id_list.count)) bit (36) aligned;
       79 dcl     work_area			area based (work_area_ptr);
       80 
       81 /* Builtin */
       82 
       83 dcl     (cleanup, dm_not_available_)	condition;
       84 dcl     (addr, addrel, after, before, hbound, index, ltrim, null, pointer, rel, reverse, size, substr, unspec)
       85 				builtin;
       86 
       87 
       88 /* Constant */
       89 
       90 dcl     (
       91         YES			init ("1"b) bit (1),
       92         NO			init ("0"b) bit (1),
       93         WAIT			char (4) init ("WAIT"),
       94         ANSWER_TABLE		char (32) init ("answer_table"),
       95         ABSENTEE_USER_TABLE		char (32) init ("absentee_user_table"),
       96         DAEMON_USER_TABLE		char (32) init ("daemon_user_table"),
       97         SYSDIR			char (168) init (">system_control_1")
       98         )				internal static options (constant);
       99 
      100 /****  pages/seg * words/page - area overhead - varying char overhead */
      101 dcl     MAX_LINE_LENGTH		fixed bin (21) internal static options (constant) init (255 * 1024 - 36 - 1);
      102 
      103 dcl     myname			init ("dm_fast_lock_status") char (19) internal static options (constant);
      104 
      105 dcl     ARGUMENT_TYPE		(16) internal static options (constant) char (64) varying
      106 				init ("", "", "", "", "", "", "process id holding a fast lock",
      107 				"process id holding a fast lock", "", "", "user id holding a fast lock",
      108 				"user id holding a fast lock", "", "", "", "");
      109 dcl     CONTROL_ARGUMENT		(16) internal static options (constant) char (64) varying
      110 				init ("-header", "-he", "-no_header", "-nhe", "-lock_waiters", "-lkw",
      111 				"-process_id", "-pid", "-all", "-a", "-user", "-user", "-no_lock_waiters",
      112 				"-nlkw", "-all_processes", "-ap");
      113       ;
      114 
      115 /* Entry */
      116 
      117 dcl     cu_$arg_list_ptr		entry (ptr);
      118 dcl     cv_oct_check_		entry (char (*), fixed bin (35)) returns (fixed bin (35));
      119 dcl     cv_userid_			entry (char (*)) returns (char (32));
      120 dcl     get_userid_			entry (bit (36) aligned, char (*), char (*), fixed bin, fixed bin, fixed bin (35))
      121 				;
      122 dcl     initiate_file_		entry (char (*), char (*), bit (*), ptr, fixed bin (24), fixed bin (35));
      123 dcl     match_star_name_		entry (char (*), char (*), fixed bin (35));
      124 dcl     (
      125         ioa_,
      126         ioa_$rsnnl
      127         )				entry () options (variable);
      128 dcl     lock_manager_$copy_fast_data	entry (ptr, ptr, fixed bin (35));
      129 dcl     ssu_$abort_line		entry () options (variable);
      130 dcl     ssu_$arg_count		entry (ptr, fixed bin);
      131 dcl     ssu_$arg_ptr		entry (ptr, fixed bin, ptr, fixed bin (21));
      132 dcl     ssu_$destroy_invocation	entry (ptr);
      133 dcl     ssu_$get_area		entry (ptr, ptr, char (*), ptr);
      134 dcl     ssu_$get_temp_segment		entry (ptr, char (*), ptr);
      135 dcl     ssu_$standalone_invocation	entry (ptr, char (*), char (*), ptr, entry, fixed bin (35));
      136 dcl     sub_err_			entry () options (variable);
      137 
      138 /* External */
      139 
      140 dcl     (
      141         dm_error_$system_not_initialized,
      142         error_table_$badopt,
      143         error_table_$bad_arg,
      144         error_table_$noarg,
      145         error_table_$unimplemented_version
      146         )				fixed bin (35) external;
      147 
      148 /* END OF DECLARATIONS */
      149 
      150       call cu_$arg_list_ptr (arg_list_ptr);
      151       call ssu_$standalone_invocation (sci_ptr, myname, "", arg_list_ptr, ABORT_ENTRY, code);
      152 
      153       on cleanup call CLEANUP ();
      154       on dm_not_available_ call ERROR_RETURN (dm_error_$system_not_initialized, "");
      155 
      156       call ssu_$get_area (sci_ptr, null (), myname, work_area_ptr);
      157       call ssu_$get_temp_segment (sci_ptr, myname, fast_lock_data_ptr);
      158       call ssu_$get_temp_segment (sci_ptr, myname, process_id_list_ptr);
      159 
      160       process_id_list.count = 0;
      161       allocate display_line in (work_area);
      162       call lock_manager_$copy_fast_data (fast_lock_data_ptr, null (), code);
      163       if code ^= 0 then call ERROR_RETURN (code, "Getting temporary segment to hold lock data");
      164       call CHECK_VERSION (FAST_LOCK_DATA_VERSION_1, fast_lock_data.version, "fast_lock_data");
      165 
      166       call ssu_$arg_count (sci_ptr, number_of_args);
      167 
      168       accept_control_argument = YES;
      169       control_argument_idx = -1;
      170 
      171 ARG_PROCESSING_LOOP:
      172       do arg_idx = 1 to number_of_args;
      173          call ssu_$arg_ptr (sci_ptr, arg_idx, arg_ptr, arg_len);
      174          if index (arg, "-") ^= 1 | force_interpretation_as_argument = YES
      175          then call PROCESS_ARGUMENT (arg, control_argument_idx, accept_control_argument);
      176          else if accept_control_argument = YES
      177          then call PROCESS_CONTROL_ARGUMENT (arg, control_argument_idx, accept_control_argument,
      178 	         force_interpretation_as_argument);
      179          else call REPORT_MISSING_ARGUMENT (control_argument_idx);
      180       end ARG_PROCESSING_LOOP;
      181 
      182       if control_argument_idx >= 0 & accept_control_argument = NO
      183       then call REPORT_MISSING_ARGUMENT (control_argument_idx);

      184 
      185       lock_list_head_ptr = addr (fast_lock_data.free_list_head);
      186       lock_list_block_ptr = addr (fast_lock_data.list);
      187       lock_list_block_words = size (fast_lock_wakeup_block);
      188 
      189       lock_list_index = 0;
      190 COUNT_FREE_ENTRIES:
      191       do lock_list_block_ptr = addr (fast_lock_data.list)
      192 	 repeat addrel (lock_list_block_ptr, size (lock_list_block))
      193 	 while (lock_list_block_ptr ^= pointer (fast_lock_data_ptr, lock_list_head.firstp));
      194          lock_list_index = lock_list_index + 1;
      195       end COUNT_FREE_ENTRIES;
      196 
      197       if display_header
      198       then call ioa_$rsnnl ("Lock Data Offset: ^w^/Version: ^a^/Size: ^d^/"
      199 	      || "Free List Head Offset: ^w^/Number Free Entries: ^d^/Number Allocated Entries: ^d^/", display_line,
      200 	      (0), rel (fast_lock_data_ptr), fast_lock_data.version, fast_lock_data.size, lock_list_head.firstp,
      201 	      lock_list_index + 1, (fast_lock_data.n_list_entries - lock_list_index - 1));
      202 
      203       lock_list_index = lock_list_index + 2;		/* skip to allocated block */
      204 ALLOCATED_BLOCK_LOOP:
      205       do lock_list_block_ptr = addrel (pointer (fast_lock_data_ptr, lock_list_head.firstp), size (lock_list_block))
      206 	 repeat addrel (lock_list_block_ptr, size (lock_list_block))
      207 	 while (lock_list_index <= fast_lock_data.n_list_entries);
      208          fast_lock_block_ptr, fast_lock_wakeup_block_ptr = addr (lock_list_block.block_data);
      209 
      210          if fast_lock_wakeup_block.message ^= WAIT & fast_lock_block.uid ^= ""b
      211          then
      212 PROCESS_ACTIVE_LOCK:
      213 	  do;
      214 	  call ioa_$rsnnl ("^[^a^/^;^s^]UID ^w Offset ^w", display_line, (0), display_header, display_line,
      215 	       fast_lock_block.uid, fast_lock_block.offset);
      216 	  display_header = NO;
      217 
      218 	  save_lock_list_block_ptr = lock_list_block_ptr;
      219 	  end_of_chain, user_match = NO;
      220 	  first_waiter = YES;
      221 FIND_LOCK_WAITERS:
      222 	  do lock_list_block_ptr = pointer (fast_lock_data_ptr, fast_lock_block.list_head)
      223 	       repeat pointer (fast_lock_data_ptr, lock_list_block.nextp)
      224 	       while (^end_of_chain & fast_lock_block.list_head ^= ""b);
      225 	     fast_lock_wakeup_block_ptr = addr (lock_list_block.block_data);
      226 	     if ^user_match & given_process_id then do;	/* is this block's process one the user gave us? */
      227 	        do process_idx = 1 to process_id_list.count
      228 		   while (fast_lock_wakeup_block.processid ^= process_id_list.id (process_idx));
      229 	        end;
      230 	        if process_idx <= process_id_list.count then do;
      231 		 user_match = YES;			/* found a match, need not check this fast lock again */
      232 		 at_least_one_lock = YES;
      233 	        end;
      234 	     end;
      235 	     else if display_all_locks then at_least_one_lock = YES;
      236 
      237 	     call get_userid_ (fast_lock_wakeup_block.processid, person_id, project_id, (0), (0), code);
      238 	     if display_waiters then do;
      239 	        call ioa_$rsnnl ("^a^[^/Waiters for this lock:^]^/^3xProcess ID ^w ^[(^a.^a)^;^s^s^] Event Channel ^w",
      240 		   display_line, (0), display_line, first_waiter, fast_lock_wakeup_block.processid, (code = 0),
      241 		   person_id, project_id, fast_lock_wakeup_block.event_channel);
      242 	        first_waiter = NO;
      243 	     end;
      244 	     if lock_list_block.nextp = ""b then end_of_chain = "1"b;
      245 	  end FIND_LOCK_WAITERS;
      246 	  lock_list_block_ptr = save_lock_list_block_ptr;
      247 	  if user_match | display_all_locks then call ioa_ (display_line);
      248          end PROCESS_ACTIVE_LOCK;
      249 
      250          lock_list_index = lock_list_index + 1;
      251       end ALLOCATED_BLOCK_LOOP;
      252 
      253       if display_header then call ioa_ (display_line);	/* No fast locks and user wants to see header */
      254       if display_all_locks & ^at_least_one_lock then call ioa_ ("There are no processes waiting on fast locks.");
      255       else if ^at_least_one_lock & given_process_id then do;
      256          call get_userid_ (process_id_list.id (1), person_id, project_id, (0), (0), code);
      257          call ioa_ ("^/No fast locks waited on by specified process^[. Process ID" || " ^w ^[(^a.^a)^]^;^s^s^s^ses. ^a",
      258 	    (process_id_list.count = 1), process_id_list.id (1), (code = 0), person_id, project_id, user);
      259       end;
      260 
      261       call FINISH ();
      262 
      263 MAIN_RETURN:
      264       return;
      265 
      266 ERROR_RETURN:
      267    proc (er_code, er_message);
      268 
      269 dcl     er_code			fixed bin (35) parameter;
      270 dcl     er_message			char (*) parameter;
      271 
      272       call ssu_$abort_line (sci_ptr, er_code, er_message);
      273    end;
      274 
      275 ABORT_ENTRY:
      276    procedure ();
      277       call CLEANUP ();
      278       go to MAIN_RETURN;
      279    end ABORT_ENTRY;
      280 
      281 CLEANUP:
      282    procedure ();
      283       call FINISH ();
      284    end CLEANUP;
      285 
      286 FINISH:
      287    proc ();
      288       call ssu_$destroy_invocation (sci_ptr);
      289    end FINISH;
      290 
      291 CHECK_VERSION:
      292    proc (cv_p_expected_version, cv_p_received_version, cv_p_structure_name);
      293 
      294 dcl     cv_p_expected_version		char (8) aligned parameter;
      295 dcl     cv_p_received_version		char (8) aligned parameter;
      296 dcl     cv_p_structure_name		char (32) aligned parameter;
      297 
      298       if cv_p_expected_version ^= cv_p_received_version
      299       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null (), 0,
      300 	      "^/Expected version ^a of the ^a structure." || "^/Received version ^a instead.", cv_p_expected_version,
      301 	      cv_p_structure_name, cv_p_received_version);
      302    end CHECK_VERSION;
      303 
      304 GET_PROCESS_ID_FROM_USER_ID:
      305    proc (gp_p_user_id, gp_p_process_id_list_ptr);
      306 
      307 dcl     gp_p_user_id		char (34) parameter;
      308 dcl     gp_p_process_id_list_ptr	ptr;
      309 dcl     1 gp_process_id_list		like process_id_list aligned based (gp_p_process_id_list_ptr);
      310 
      311       call GET_ANSWER_TABLES;
      312 
      313       do answer_table_idx = 1 to anstbl.current_size;
      314          utep = addr (anstbl.entry (answer_table_idx));
      315          if ute.active >= 4 then call MATCH_USER_TABLE_ENTRY (gp_p_user_id, gp_p_process_id_list_ptr);
      316       end;
      317 
      318       do answer_table_idx = 1 to autbl.current_size;
      319          utep = addr (autbl.entry (answer_table_idx));
      320          if ute.active >= 4 then call MATCH_USER_TABLE_ENTRY (gp_p_user_id, gp_p_process_id_list_ptr);
      321       end;
      322 
      323       do answer_table_idx = 1 to dutbl.current_size;
      324          utep = addr (dutbl.entry (answer_table_idx));
      325          if ute.active >= 4 then call MATCH_USER_TABLE_ENTRY (gp_p_user_id, gp_p_process_id_list_ptr);
      326       end;
      327 
      328       if gp_process_id_list.count = 0
      329       then call ERROR_RETURN (error_table_$bad_arg, "User not logged in. " || gp_p_user_id);
      330 
      331       return;
      332 
      333 GET_ANSWER_TABLES:
      334    proc ();
      335 
      336 dcl     gat_code			fixed bin (35);
      337 
      338       call initiate_file_ (SYSDIR, ANSWER_TABLE, R_ACCESS, ansp, (0), gat_code);
      339       if ansp = null () then call ERROR_RETURN (gat_code, ANSWER_TABLE);
      340       call initiate_file_ (SYSDIR, ABSENTEE_USER_TABLE, R_ACCESS, autp, (0), gat_code);
      341       if autp = null () then call ERROR_RETURN (gat_code, ABSENTEE_USER_TABLE);
      342       call initiate_file_ (SYSDIR, DAEMON_USER_TABLE, R_ACCESS, dutp, (0), gat_code);
      343       if dutp = null () then call ERROR_RETURN (gat_code, DAEMON_USER_TABLE);
      344    end;

      345 
      346 MATCH_USER_TABLE_ENTRY:
      347    proc (mu_p_user_id, mu_p_process_id_list_ptr);
      348 
      349 dcl     mu_p_process_id_list_ptr	ptr parameter;
      350 dcl     mu_p_user_id		char (34) parameter;
      351 dcl     1 mu_process_id_list		like process_id_list aligned based (mu_p_process_id_list_ptr);
      352 dcl     mu_code			fixed bin (35);
      353 
      354       call match_star_name_ ((ute.person), before (mu_p_user_id, "."), mu_code);
      355       if mu_code = 0 then call match_star_name_ ((ute.project), before (after (mu_p_user_id, "."), "."), mu_code);
      356       if mu_code = 0 then call match_star_name_ ((ute.tag), before (ltrim (reverse (mu_p_user_id)), "."), mu_code);
      357       if mu_code = 0 then do;
      358          mu_process_id_list.count = mu_process_id_list.count + 1;
      359          mu_process_id_list.id (mu_process_id_list.count) = ute.proc_id;
      360       end;
      361 
      362    end;
      363    end;
      364 
      365 PROCESS_ARGUMENT:
      366    proc (pa_p_arg, pa_p_control_argument_idx, pa_p_accept_control_argument);
      367 
      368 dcl     pa_p_arg			char (*) parm;
      369 dcl     pa_p_control_argument_idx	fixed bin parm;
      370 dcl     pa_p_accept_control_argument	bit (1) aligned parm;
      371 
      372 dcl     pa_code			fixed bin (35);
      373 
      374       pa_code = 0;
      375 
      376       goto ARGUMENT (pa_p_control_argument_idx);
      377 ARGUMENT (-1):
      378       call ssu_$abort_line (sci_ptr, error_table_$bad_arg, "^/The argument ""^a"" is out of place.", arg);
      379       return;
      380 
      381 ARGUMENT (7):					/* -process_id */
      382 ARGUMENT (8):					/* -pid */
      383       control_argument_idx = -1;
      384       accept_control_argument = YES;
      385       process_id_fb = cv_oct_check_ (arg, code);
      386       process_id_list.count = 1;
      387       unspec (process_id_list.id (1)) = unspec (process_id_fb);
      388       if code ^= 0 then call ERROR_RETURN (code, arg);
      389       given_process_id = YES;
      390       display_all_locks = NO;
      391       return;
      392 
      393 ARGUMENT (11):					/* -user */
      394 ARGUMENT (12):					/* -user */
      395       control_argument_idx = -1;
      396       accept_control_argument = YES;
      397       user = cv_userid_ (arg);
      398       call GET_PROCESS_ID_FROM_USER_ID (user, process_id_list_ptr);
      399       given_process_id = YES;
      400       display_all_locks = NO;
      401       return;
      402 
      403    end PROCESS_ARGUMENT;
      404 
      405 PROCESS_CONTROL_ARGUMENT:
      406    proc (pca_p_arg, pca_p_control_argument_idx, pca_p_accept_control_argument, pca_p_force_interpretation_as_argument);
      407 
      408 
      409 dcl     pca_p_arg			char (*) parm;
      410 dcl     pca_p_control_argument_idx	fixed bin parm;
      411 dcl     pca_p_accept_control_argument	bit (1) aligned parm;
      412 dcl     pca_p_force_interpretation_as_argument
      413 				bit (1) aligned parm;
      414 
      415       pca_p_control_argument_idx = CONTROL_ARGUMENT_INDEX (pca_p_arg);
      416       pca_p_accept_control_argument = YES;
      417       pca_p_force_interpretation_as_argument = NO;
      418 
      419       go to CONTROL_ARGUMENT (pca_p_control_argument_idx);
      420 
      421 CONTROL_ARGUMENT (-1):				/* not a control argument */
      422       call ssu_$abort_line (sci_ptr, error_table_$badopt, pca_p_arg);
      423 
      424 CONTROL_ARGUMENT (1):				/* -header */
      425 CONTROL_ARGUMENT (2):				/* -he */
      426       display_header = YES;
      427       pca_p_control_argument_idx = -1;
      428       pca_p_accept_control_argument = YES;
      429       return;
      430 
      431 CONTROL_ARGUMENT (3):				/* -no_header */
      432 CONTROL_ARGUMENT (4):				/* -nhe */
      433       display_header = NO;
      434       pca_p_control_argument_idx = -1;
      435       pca_p_accept_control_argument = YES;
      436       return;
      437 
      438 CONTROL_ARGUMENT (5):				/* -lock_waiters */
      439 CONTROL_ARGUMENT (6):				/* -lkw */
      440       display_waiters = YES;
      441       pca_p_control_argument_idx = -1;
      442       pca_p_accept_control_argument = YES;
      443       return;
      444 
      445 
      446 CONTROL_ARGUMENT (7):				/* -process_id */
      447 CONTROL_ARGUMENT (8):				/* -pid */
      448       pca_p_accept_control_argument = NO;
      449       return;
      450 
      451 
      452 CONTROL_ARGUMENT (9):				/* -all */
      453 CONTROL_ARGUMENT (10):				/* -a */
      454       display_all_locks = YES;
      455       pca_p_control_argument_idx = -1;
      456       pca_p_accept_control_argument = YES;
      457       return;
      458 
      459 
      460 CONTROL_ARGUMENT (11):				/* -user */
      461 CONTROL_ARGUMENT (12):				/* -user */
      462       pca_p_accept_control_argument = NO;
      463       return;
      464 
      465 
      466 CONTROL_ARGUMENT (13):				/* -no_lock_waiters */
      467 CONTROL_ARGUMENT (14):				/* -nlkw */
      468       display_waiters = NO;
      469       pca_p_control_argument_idx = -1;
      470       pca_p_accept_control_argument = YES;
      471       return;
      472 
      473 
      474 CONTROL_ARGUMENT (15):				/* -all_processes */
      475 CONTROL_ARGUMENT (16):				/* -ap */
      476       display_all_locks = YES;
      477       given_process_id = NO;
      478       pca_p_control_argument_idx = -1;
      479       pca_p_accept_control_argument = YES;
      480       return;
      481 
      482 
      483    end PROCESS_CONTROL_ARGUMENT;
      484 
      485 
      486 CONTROL_ARGUMENT_INDEX:
      487    proc (cai_p_arg) returns (fixed bin);
      488 
      489 dcl     cai_p_arg			char (*);
      490 dcl     cai_control_argument_idx	fixed bin;
      491 
      492       do cai_control_argument_idx = 1 to hbound (CONTROL_ARGUMENT, 1)
      493 	 while (CONTROL_ARGUMENT (cai_control_argument_idx) ^= cai_p_arg);
      494       end;
      495       if cai_control_argument_idx > hbound (CONTROL_ARGUMENT, 1)
      496       then return (-1);
      497       else return (cai_control_argument_idx);
      498 
      499    end CONTROL_ARGUMENT_INDEX;
      500 
      501 REPORT_MISSING_ARGUMENT:
      502    proc (rma_p_control_argument_idx);
      503 dcl     rma_p_control_argument_idx	fixed bin parm;
      504 
      505       call ssu_$abort_line (sci_ptr, error_table_$noarg, "^a must be followed by a^[n^] ^a.",
      506 	 CONTROL_ARGUMENT (rma_p_control_argument_idx),
      507 	 (index ("aeiouh", substr (ARGUMENT_TYPE (rma_p_control_argument_idx), 1, 1)) > 0),
      508 	 ARGUMENT_TYPE (rma_p_control_argument_idx));
      509    end REPORT_MISSING_ARGUMENT;
      510 
      511  /* BEGIN INCLUDE FILE ... absentee_user_table.incl.pl1 */
  1     2 
  1     3 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1     4 /*							       */
  1     5 /* The absentee user table is the control data base for the absentee	       */
  1     6 /* facility.  It has a header, with scheduling parameters, then one user     */
  1     7 /* table entry for each logged-in absentee job.			       */
  1     8 /*							       */
  1     9 /* Programs which use this table must also include		       */
  1    10 /* user_table_header.incl.pl1 and user_table_entry.incl.pl1.	       */
  1    11 /*							       */
  1    12 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    13 
  1    14 
  1    15 /****^  HISTORY COMMENTS:
  1    16*  1) change(81-09-10,Kittlitz), approve(), audit(), install():
  1    17*     Replace abs_user_tab.incl.pl1.
  1    18*  2) change(87-04-26,GDixon), approve(87-07-13,MCR7741),
  1    19*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  1    20*     Use ut_header common to all user control tables.
  1    21*                                                   END HISTORY COMMENTS */
  1    22 
  1    23 
  1    24 dcl  AUTBL_version_4 fixed bin int static options (constant) init (4);
  1    25 
  1    26 dcl  autp ptr automatic init (null);
  1    27 
  1    28 dcl 1 autbl based (autp) aligned,			/* a per system table to store info on absentee processes */
  1    29     2 header like ut_header,				/* Header common to all user tables. */
  1    30 
  1    31 /* Counter elements */
  1    32     2 n_abs_run fixed bin,				/* actual number of absentee processes current */
  1    33     2 max_abs_users fixed bin,			/* max number of background absentee processes permitted */
  1    34     2 n_background_abs fixed bin,			/* number of absentee processes not from foreground queue */
  1    35     2 n_sec_fg fixed bin,				/* number of secondary foreground absentee jobs */
  1    36     2 idle_units fixed bin,				/* used in adjusting abs_maxu dynamically */
  1    37     2 abs_units fixed bin,				/* part of anstbl.n_units used by background absentees */
  1    38     2 n_abs (4) fixed bin,				/* number of processes from each background queue */
  1    39     2 qres (4) fixed bin,				/* number of slots reserved for each background queue */
  1    40     2 rsc_waiting (-1:4) fixed bin,			/* number of requests waiting for resources, from each queue */
  1    41     2 qerr (-1:4) fixed bin,				/* number of consecutive errors for q (dropped if > QERR_MAX) */
  1    42     2 cpu_limit (4) fixed bin (35),			/* current per-queue cpu time limits */
  1    43 
  1    44 /* absentee user manager values. */
  1    45     2 defer_channel fixed bin (71),			/* IPC for time-defered queue entries */
  1    46     2 absentee_rq_chn fixed bin (71),			/* IPC channel for absentee requests */
  1    47     2 last_queue_searched fixed bin,			/* highest queue looked at by scheduler */
  1    48     2 debugging fixed bin,				/* take asdumps at strategic places */
  1    49     2 control,					/* see also whotab.incl.pl1 */
  1    50       3 mnbz bit (1) unal,				/* must not be zero */
  1    51       3 abs_maxu_auto bit (1) unal,			/* 1 if abs maxu has not been set by operator command */
  1    52       3 abs_maxq_auto bit (1) unal,			/* 1 if abs maxq has not been set by operator command */
  1    53       3 abs_qres_auto bit (1) unal,			/* 1 if abs qres has not been set by operator command */
  1    54       3 abs_cpu_limit_auto bit (1) unal,		/* 1 if abs cpu_limit has not been set by operator command */
  1    55       3 queue_dropped (-1:4) bit (1) unal,		/* 1 if queue has been dropped because of errors */
  1    56       3 abs_up bit (1) unal,				/* 1 if absentee facility is running */
  1    57       3 abs_stopped bit (1) unal,			/* 1 if abs stop command was issued */
  1    58 						/* both 1 if we're waiting for the last jobs to log out */
  1    59       3 aum_ctl bit (1) unal,				/* for AUM to tell AU to start a new sequence */
  1    60       3 lc_list bit (1) unal,				/* for AU to tell AUM that the lc list is non-empty */
  1    61 						/* comments in AU and AUM explain aum_ctl and lc_list */
  1    62       3 control_pad (21) bit (1) unal,			/* fill out rest of word */
  1    63     2 aum_pad fixed bin,
  1    64 
  1    65     2 entry_pad (80) fixed bin,			/*  pad table header to 128 words */
  1    66     2 entry (0 refer (autbl.current_size)) like ute;
  1    67 
  1    68 dcl AUTBL_CONTROL_NAMES (15) char(20) varying int static options(constant) init(
  1    69 	"mnbz",
  1    70 	"abs_maxu_auto",
  1    71 	"abs_maxq_auto",
  1    72 	"abs_qres_auto",
  1    73 	"abs_cpu_limit_auto",
  1    74 	"queue_dropped(-1)",
  1    75 	"queue_dropped( 0)",
  1    76 	"queue_dropped( 1)",
  1    77 	"queue_dropped( 2)",
  1    78 	"queue_dropped( 3)",
  1    79 	"queue_dropped( 4)",
  1    80 	"abs_up",
  1    81 	"abs_stopped",
  1    82 	"aum_ctl",
  1    83 	"lc_list");
  1    84 
  1    85 /* END INCLUDE FILE ... absentee_user_table.incl.pl1 */
      511 
      512  /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  2     2*
  2     3*   Values for the "access mode" argument so often used in hardcore
  2     4*   James R. Davis 26 Jan 81  MCR 4844
  2     5*   Added constants for SM access 4/28/82 Jay Pattin
  2     6*   Added text strings 03/19/85 Chris Jones
  2     7**/
  2     8 
  2     9 
  2    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  2    11 dcl	(
  2    12 	N_ACCESS		   init ("000"b),
  2    13 	R_ACCESS		   init ("100"b),
  2    14 	E_ACCESS		   init ("010"b),
  2    15 	W_ACCESS		   init ("001"b),
  2    16 	RE_ACCESS		   init ("110"b),
  2    17 	REW_ACCESS	   init ("111"b),
  2    18 	RW_ACCESS		   init ("101"b),
  2    19 	S_ACCESS		   init ("100"b),
  2    20 	M_ACCESS		   init ("010"b),
  2    21 	A_ACCESS		   init ("001"b),
  2    22 	SA_ACCESS		   init ("101"b),
  2    23 	SM_ACCESS		   init ("110"b),
  2    24 	SMA_ACCESS	   init ("111"b)
  2    25 	)		   bit (3) internal static options (constant);
  2    26 
  2    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  2    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  2    29 
  2    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  2    31 			   static options (constant);
  2    32 
  2    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  2    34 			   static options (constant);
  2    35 
  2    36 dcl	(
  2    37 	N_ACCESS_BIN	   init (00000b),
  2    38 	R_ACCESS_BIN	   init (01000b),
  2    39 	E_ACCESS_BIN	   init (00100b),
  2    40 	W_ACCESS_BIN	   init (00010b),
  2    41 	RW_ACCESS_BIN	   init (01010b),
  2    42 	RE_ACCESS_BIN	   init (01100b),
  2    43 	REW_ACCESS_BIN	   init (01110b),
  2    44 	S_ACCESS_BIN	   init (01000b),
  2    45 	M_ACCESS_BIN	   init (00010b),
  2    46 	A_ACCESS_BIN	   init (00001b),
  2    47 	SA_ACCESS_BIN	   init (01001b),
  2    48 	SM_ACCESS_BIN	   init (01010b),
  2    49 	SMA_ACCESS_BIN	   init (01011b)
  2    50 	)		   fixed bin (5) internal static options (constant);
  2    51 
  2    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      512 
      513  /* BEGIN INCLUDE FILE ... answer_table.incl.pl1 */
  3     2 
  3     3 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3     4 /*							       */
  3     5 /* The answer table has one entry per "login instance" whether completed or  */
  3     6 /* not.  It is connected to the Channel Definition Table by the pointer      */
  3     7 /* "channel".  The header is used mostly by dialup_.		       */
  3     8 /*							       */
  3     9 /* Programs which use this file must also include user_table_header.incl.pl1 */
  3    10 /*							       */
  3    11 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3    12 
  3    13 /****^  HISTORY COMMENTS:
  3    14*  1) change(81-09-10,Kittlitz), approve(), audit(), install():
  3    15*     Replace anstbl.incl.pl1.
  3    16*  2) change(85-01-15,Swenson), approve(), audit(), install():
  3    17*     Add anstbl.session_uid_counter.
  3    18*  3) change(85-08-21,Coren), approve(), audit(), install():
  3    19*     Add anstbl.message_update_time and named constants for values of
  3    20*     anstbl.session, and to make all padding explicit.
  3    21*  4) change(85-08-23,Coren), approve(), audit(), install():
  3    22*     Change "entry" to a placeholder so as not to require
  3    23*     user_table_entry.incl.pl1.
  3    24*  5) change(86-06-29,Swenson), approve(87-07-13,MCR7741),
  3    25*     audit(87-04-14,GDixon), install(87-08-04,MR12.1-1056):
  3    26*     Added the flag login_server_present which indicates whether a login
  3    27*     server request has been received.  This is used to determine whether
  3    28*     dial_ctl_ should call uc_cleanup_network_dials_ (and thus
  3    29*     hpriv_connection_list_, which only exists with the MNA RPQ software).
  3    30*  6) change(87-04-14,GDixon), approve(87-07-13,MCR7741),
  3    31*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  3    32*      A) Moved constants for ute.pw_flags.mask_ctl into
  3    33*         user_table_entry.incl.pl1.
  3    34*      B) Added common table header to all user tables.
  3    35*                                                   END HISTORY COMMENTS */
  3    36 
  3    37 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3    38 /*							       */
  3    39 /* The anstbl structure below is divided into sections.  Each section begins */
  3    40 /* with a comment describing the elements in the section.  Elements are      */
  3    41 /* placed within a section, based upon their function or the programs that   */
  3    42 /* use them.  Each section begins on a double word and is an even number of  */
  3    43 /* words long.						       */
  3    44 /*							       */
  3    45 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3    46 
  3    47 
  3    48 
  3    49 /* format: style4 */
  3    50 
  3    51 dcl  ANSTBL_version_4 static options (constant) init (4);	/* version of this declaration */
  3    52 
  3    53 dcl  ansp ptr automatic init (null);
  3    54 
  3    55 dcl  1 anstbl based (ansp) aligned,			/* Structure of answer table */
  3    56        2 header like ut_header,			/* Header common to all user tables. */
  3    57 
  3    58 /* Counter elements. */
  3    59        2 nlin fixed bin,				/* number of active lines */
  3    60        2 mxlin fixed bin,				/* maximum number of active lines */
  3    61        2 n_users fixed bin,				/* number of logged-in users */
  3    62        2 max_users fixed bin,				/* maximum number of users allowed */
  3    63        2 n_units fixed bin,				/* number of logged in units */
  3    64        2 max_units fixed bin,				/* maximum number of units */
  3    65        2 n_sessions fixed bin,			/* number of Multics sessions */
  3    66        2 n_pad fixed bin,
  3    67 
  3    68 /* Name elements. */
  3    69        2 sysdir char (64) unal,			/* name of main system control directory */
  3    70        2 as_tty char (8) unal,			/* name of main answering service device. */
  3    71 
  3    72 /* Login elements. */
  3    73        2 login_word char (8) unal,			/* login word if special_session=1  */
  3    74        2 session char (8) unal,			/* session indicator */
  3    75        2 special_message char (128) unal,		/* message to be printed for special session */
  3    76        2 message_update_time fixed bin (71),		/* time at which special_message was last updated */
  3    77        2 message_lng fixed bin,			/* length of special message */
  3    78        2 login_pad fixed bin,
  3    79 
  3    80 /* Table update elements. */
  3    81        2 lock_count fixed bin,			/* global lock for all system control tables */
  3    82        2 update_pending bit (1) aligned,		/* flag indicating that update is required */
  3    83        2 update_channel fixed binary (71),		/* event channel of update procedure */
  3    84        2 acct_update_chn fixed bin (71) aligned,		/* Timer IPC channel */
  3    85        2 acct_last_update_time fixed bin (71) aligned,	/* Time of last accounting update */
  3    86        2 acct_alarm_fail fixed bin,			/* non-zero if alarm has failed */
  3    87        2 update_pad fixed bin,
  3    88 
  3    89 /* dialup_ data values. */
  3    90        2 current_time fixed bin (71),			/* Time of last transaction */
  3    91        2 processid_index fixed bin (18),		/* unique index for process id generation */
  3    92        2 session_uid_counter fixed bin (35),		/* current session_uid */
  3    93 
  3    94 /* load_ctl_ elements. */
  3    95        2 shift fixed bin,				/* Shift, set by act_ctl_ */
  3    96        2 auto_maxu fixed bin,				/* 0 = manual, 1 = config, 2 = load-level */
  3    97        2 extra_units fixed bin,			/* Total daemon and abs units. */
  3    98 						/* load_ctl_ load leveling desired response range: */
  3    99        2 response_high fixed bin,			/* bad if user response time slower than this */
  3   100        2 response_low fixed bin,			/* bad if user response time faster than this */
  3   101        2 load_ctl_pad fixed bin,
  3   102 
  3   103 /* Login server request server data. */
  3   104        2 ls_request_server_event_channel fixed bin (71),	/* channel for login server requests */
  3   105        2 ls_request_server_process_id bit (36) aligned,	/* process serving login server requests */
  3   106        2 login_server_present bit (1) aligned,		/* On IFF a login server request has been processed */
  3   107 
  3   108        2 entry_pad (28) fixed bin,			/* pad to 128 words */
  3   109        2 entry (0 refer (anstbl.current_size)),		/* user entries */
  3   110          3 contents (UTE_SIZE) fixed bin;
  3   111 
  3   112 /* constants */
  3   113 
  3   114 /* values for anstbl.session */
  3   115 
  3   116 dcl  (AT_NORMAL init ("normal  "),
  3   117      AT_SPECIAL init ("special "),
  3   118      AT_SHUTDOWN init ("shutdown")) char (8) internal static options (constant);
  3   119 
  3   120 dcl  UTE_SIZE fixed bin internal static initial (300);
  3   121 
  3   122 /* END INCLUDE FILE ... answer_table.incl.pl1 */
      513 
      514  /* BEGIN INCLUDE FILE ... daemon_user_table.incl.pl1 */
  4     2 
  4     3 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4     4 /*							       */
  4     5 /* The daemon_user_table has one entry per daemon.  Daemons are logged in by */
  4     6 /* operator command or automatically.  If they do any I/O, it is done via    */
  4     7 /* the message coordinator.					       */
  4     8 /*							       */
  4     9 /* Programs using this include file must also use user_table_header.incl.pl1 */
  4    10 /* and user_table_entry.incl.pl1.				       */
  4    11 /*							       */
  4    12 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4    13 
  4    14 
  4    15 /****^  HISTORY COMMENTS:
  4    16*  1) change(81-09-10,Kittlitz), approve(), audit(), install():
  4    17*     Initially coded from dutbl.incl.pl1.
  4    18*  2) change(87-04-26,GDixon), approve(87-07-13,MCR7741),
  4    19*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  4    20*      A) Add use of ut_header common to all user control tables.
  4    21*      B) Corrected padding prior to first ute entry.
  4    22*                                                   END HISTORY COMMENTS */
  4    23 
  4    24 
  4    25 dcl  DUTBL_version_4 fixed bin int static init (4);	/* version of this declaration */
  4    26 
  4    27 dcl  dutp ptr automatic init (null);
  4    28 
  4    29 dcl 1 dutbl based (dutp) aligned,			/* Daemon user table */
  4    30     2 header like ut_header,				/* Header common to all user tables. */
  4    31 
  4    32     2 active_count fixed bin,				/* the count of active daemons managed by DUM_ */
  4    33 
  4    34     2 entry_pad (117) fixed bin,			/* pad to 128 words */
  4    35     2 entry (0 refer (dutbl.current_size)) like ute;	/* daemon user entries */
  4    36 
  4    37 /* END INCLUDE FILE ... daemon_user_table.incl.pl1 */
      514 
      515  /*  START OF:	dm_fast_lock_strucs.incl.pl1 ... June 1982   *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*   There is a fast_lock_block per segment to be locked.  There is a
  5     5*   fast_lock_wakeup_block per waiter on the lock.  The fast*block's are
  5     6*   taken from the fast_lock_data.list, which is a list of lock_list_block's.
  5     7**/
  5     8 
  5     9 /* HISTORY:
  5    10*Written by J. Bongiovanni, 06/15/82.
  5    11*Modified:
  5    12*10/12/84 by Stanford S. Cox:  Added version constants.
  5    13*11/14/84 by Stanford S. Cox:  Chg to make fast_lock_data.free_list_head
  5    14*   like lock_list_head.
  5    15**/
  5    16 
  5    17 /* format: style2,^inddcls,ifthenstmt,ifthendo,^indnoniterdo,^inditerdo,ind3,idind32 */
  5    18 dcl     fast_lock_ptr		ptr;
  5    19 dcl     fast_lock_block_ptr		ptr;
  5    20 dcl     fast_lock_wakeup_block_ptr	ptr;
  5    21 dcl     fast_lock_data_ptr		ptr;
  5    22 
  5    23 dcl     FAST_LOCK_DATA_VERSION_1	char (8) aligned init ("fastlk 1") int static options (constant);
  5    24 
  5    25 dcl     1 fast_lock			aligned based (fast_lock_ptr),
  5    26 						/* A fast lock */
  5    27 	2 lock_word		bit (36) aligned,	/* "0"b (unlocked) or processid (locked) */
  5    28 	2 notify_sw		bit (1) unal,	/* ON => notify on unlock */
  5    29 	2 pad			bit (17) unal,
  5    30 	2 offset			bit (18) unal;	/* Offset of block in fast_lock_data */
  5    31 
  5    32 
  5    33 dcl     1 fast_lock_block		aligned based (fast_lock_block_ptr),
  5    34 						/* Per-lock info, inner-ring */
  5    35 	2 uid			bit (36) aligned,	/* Unique ID of segment */
  5    36 	2 offset			bit (18) unal,	/* Offset of lock in segment */
  5    37 	2 pad			bit (18) unal,
  5    38 	2 list_head		bit (18) unal,	/* Thread pointer for wakeups */
  5    39 	2 mbz			bit (18) unal,
  5    40 	2 pad1			bit (36) aligned;
  5    41 
  5    42 
  5    43 dcl     1 fast_lock_wakeup_block	aligned based (fast_lock_wakeup_block_ptr),
  5    44 						/* Notify info */
  5    45 	2 event_channel		fixed bin (71),
  5    46 	2 processid		bit (36) aligned,
  5    47 	2 message			char (4);
  5    48 
  5    49 dcl     1 fast_lock_data		aligned based (fast_lock_data_ptr),
  5    50 	2 version			char (8),
  5    51 	2 size			fixed bin,
  5    52 	2 n_list_entries		fixed bin,
  5    53 	2 free_list_head		aligned like lock_list_head,
  5    54 	2 list			fixed bin (71) aligned;
  5    55 
  5    56 /*  END OF:	dm_fast_lock_strucs.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      515 
      516  /*  START OF:	dm_lock_list_strucs_.incl.pl1	June 1982  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*   fast_lock_data.free_list_head is lock_list_head. fast_lock_data.list is the
  6     5*   first two words of lock_list_block.  Other lock_list_block's are threaded
  6     6*   to make a list.  block_data is large enough to contain 
  6     7*   fast_lock_wakeup_block (largest fast lock block type).
  6     8**/
  6     9 
  6    10 /* HISTORY:
  6    11*Written by John Bongiovanni, 06/15/82.
  6    12*Modified:
  6    13*10/12/84 by Stanford S. Cox:  Added version constants.
  6    14*11/14/84 by Stanford S. Cox:  Removed lock_list_head.version as fast_lock_data
  6    15*   has a version.
  6    16**/
  6    17 
  6    18 /* format: style2,^inddcls,ifthenstmt,ifthendo,^indnoniterdo,^inditerdo,ind3,idind32 */
  6    19 dcl     lock_list_head_ptr		ptr;
  6    20 dcl     lock_list_block_ptr		ptr;
  6    21 dcl     lock_list_meters_ptr		ptr;
  6    22 
  6    23 dcl     lock_list_block_words		fixed bin;
  6    24 
  6    25 dcl     LOCK_LIST_METERS_VERSION_1	char (8) aligned init ("lklsmt 1") int static options (constant);
  6    26 
  6    27 dcl     1 lock_list_head		aligned based (lock_list_head_ptr),
  6    28 	2 firstp			bit (18) unal,
  6    29 	2 mbz			bit (18) unal;
  6    30 
  6    31 dcl     1 lock_list_block		aligned based (lock_list_block_ptr),
  6    32 	2 nextp			bit (18) unal,
  6    33 	2 mbz			bit (18) unal,
  6    34 	2 block_words		fixed bin (17) unal,
  6    35 	2 pad			bit (18) unal,
  6    36 	2 block_data		(lock_list_block_words refer (lock_list_block.block_words)) bit (36) aligned;
  6    37 
  6    38 dcl     1 lock_list_meters		aligned based (lock_list_meters_ptr),
  6    39 	2 version			char (8) aligned,
  6    40 	2 thrdout_calls		fixed bin (35),
  6    41 	2 thrdin_calls		fixed bin (35),
  6    42 	2 thrdout_steps		fixed bin (35),
  6    43 	2 thrdin_steps		fixed bin (35);
  6    44 
  6    45 
  6    46 /*  END OF:	dm_lock_list_strucs_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      516 
      517  /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  7     2 /* format: style3 */
  7     3 
  7     4 /* These constants are to be used for the flags argument of sub_err_ */
  7     5 /* They are just "string (condition_info_header.action_flags)" */
  7     6 
  7     7 declare	(
  7     8 	ACTION_CAN_RESTART	init (""b),
  7     9 	ACTION_CANT_RESTART init ("1"b),
  7    10 	ACTION_DEFAULT_RESTART
  7    11 			init ("01"b),
  7    12 	ACTION_QUIET_RESTART
  7    13 			init ("001"b),
  7    14 	ACTION_SUPPORT_SIGNAL
  7    15 			init ("0001"b)
  7    16 	)		bit (36) aligned internal static options (constant);
  7    17 
  7    18 /* End include file */
      517 
      518  /* BEGIN INCLUDE FILE ... user_attributes.incl.pl1  TAC 10/79 */
  8     2 
  8     3 
  8     4 /****^  HISTORY COMMENTS:
  8     5*  1) change(86-12-11,Brunelle), approve(87-07-13,MCR7741),
  8     6*     audit(87-04-19,GDixon), install(87-08-04,MR12.1-1056):
  8     7*     Add incl for abs_attributes.incl.pl1 to automatically include absentee
  8     8*     attribute switches.
  8     9*  2) change(87-04-19,GDixon), approve(87-07-13,MCR7741),
  8    10*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  8    11*      A) Add USER_ATTRIBUTE_NAMES arrays.  attribute_names.incl.pl1 can thereby
  8    12*         be deleted.
  8    13*      B) Add constants identifying attributes that can be changed by user at
  8    14*         login, etc.
  8    15*                                                   END HISTORY COMMENTS */
  8    16 
  8    17 
  8    18 /* Modified 82-01-03  E. N. Kittlitz.  to declare a complete level-1 structure */
  8    19 
  8    20 /* format: style4 */
  8    21 dcl  1 user_attributes aligned based,			/* the user user_attributes */
  8    22        (2 administrator bit (1),			/* 1  system administrator privileges */
  8    23        2 primary_line bit (1),			/* 2  user has primary-line privileges  */
  8    24        2 nobump bit (1),				/* 2  user cannot be bumped */
  8    25        2 guaranteed_login bit (1),			/* 4  user has guaranteed login privileges */
  8    26        2 anonymous bit (1),				/* 5  used only in SAT. project may have anon.users */
  8    27        2 nopreempt bit (1),				/* 6  used only in PDT. user not preemptable by others
  8    28*						   .  of same project (distinct from "nobump") */
  8    29        2 nolist bit (1),				/* 7  don't list user on "who" */
  8    30        2 dialok bit (1),				/* 8  user may have multiple consoles */
  8    31        2 multip bit (1),				/* 9  user may have several processes */
  8    32        2 bumping bit (1),				/* 10 in SAT. Can users in project bump each other? */
  8    33        2 brief bit (1),				/* 11 no login or logout message */
  8    34        2 vinitproc bit (1),				/* 12 user may change initial procedure */
  8    35        2 vhomedir bit (1),				/* 13 user may change homedir */
  8    36        2 nostartup bit (1),				/* 14 user does not want start_up.ec */
  8    37        2 sb_ok bit (1),				/* 15 user may be standby */
  8    38        2 pm_ok bit (1),				/* 16 user may be primary */
  8    39        2 eo_ok bit (1),				/* 17 user may be edit_only */
  8    40        2 daemon bit (1),				/* 18 user may login as daemon */
  8    41        2 vdim bit (1),				/* 19 * OBSOLETE * user may change outer mdle */
  8    42        2 no_warning bit (1),				/* 20 no warning message */
  8    43        2 igroup bit (1),				/* 21 in SAT: this project may give its users individual groups
  8    44*						   .  in PDT: this user has an individual load control group */
  8    45        2 save_pdir bit (1),				/* 22 save pdir after fatal process error */
  8    46        2 disconnect_ok bit (1),			/* 23 ok to save user's disconnected processes */
  8    47        2 save_on_disconnect bit (1),			/* 24 save them unless -nosave login arg is given */
  8    48        2 pad bit (12)) unaligned;
  8    49 
  8    50 dcl  USER_ATTRIBUTE_NAMES (0:24) char (20) int static options (constant) init
  8    51     ("none",					/* 0 */
  8    52      "administrator",				/* 1 */
  8    53      "primary_line",				/* 2 */
  8    54      "nobump",					/* 3 */
  8    55      "guaranteed_login",				/* 4 */
  8    56      "anonymous",					/* 5 */
  8    57      "nopreempt",					/* 6 */
  8    58      "nolist",					/* 7 */
  8    59      "dialok",					/* 8 */
  8    60      "multip",					/* 9 */
  8    61      "bumping",					/* 10 */
  8    62      "brief",					/* 11 */
  8    63      "vinitproc",					/* 12 */
  8    64      "vhomedir",					/* 13 */
  8    65      "nostartup",					/* 14 */
  8    66      "no_secondary",				/* 15 */
  8    67      "no_prime",					/* 16 */
  8    68      "no_eo",					/* 17 */
  8    69      "daemon",					/* 18 */
  8    70      "",						/* 19 vdim OBSOLETE */
  8    71      "no_warning",					/* 20 */
  8    72      "igroup",					/* 21 */
  8    73      "save_pdir",					/* 22 */
  8    74      "disconnect_ok",				/* 23 */
  8    75      "save_on_disconnect");				/* 24 */
  8    76 
  8    77 dcl  ALT_USER_ATTRIBUTE_NAMES (0:24) char (20) int static options (constant) init
  8    78     ("null",					/* 0 */
  8    79      "admin",					/* 1 */
  8    80      "", "",					/* 2 - 3 */
  8    81      "guar",					/* 4 */
  8    82      "anon",					/* 5 */
  8    83      "", "",					/* 6 - 7 */
  8    84      "dial",					/* 8 */
  8    85      "multi_login",					/* 9 */
  8    86      "preempting",					/* 10 */
  8    87      "",						/* 11 */
  8    88      "v_process_overseer",				/* 12 */
  8    89      "v_home_dir",					/* 13 */
  8    90      "no_start_up",					/* 14 */
  8    91      "no_sec",					/* 15 */
  8    92      "no_primary",					/* 16 */
  8    93      "no_edit_only",				/* 17 */
  8    94      "op_login",					/* 18 */
  8    95      "",						/* 19 */
  8    96      "nowarn",					/* 20 */
  8    97      "", "", "",					/* 21 - 23 */
  8    98      "save");					/* 24 */
  8    99 
  8   100 dcl  USER_ATTRIBUTES_always_allowed bit (36) aligned int static
  8   101      options(constant) init("000000000010000000010000000000000000"b);
  8   102     /* SAT/PDT attributes not needed for user to give (brief, no_warning) */
  8   103 
  8   104 dcl  USER_ATTRIBUTES_default_in_pdt bit (36) aligned int static
  8   105      options(constant) init("000000000010000000010000000000000000"b);
  8   106     /* PDT value for (brief, no_warning) is default */
  8   107 
  8   108 dcl  USER_ATTRIBUTES_settable_by_user bit (36) aligned int static
  8   109      options(constant) init("000100000110010000010000000000000000"b);	
  8   110     /* user MIGHT set (bump, ns, brief, guar, no_warning) */
  8   111 
  9     1 /* BEGIN INCLUDE FILE ... user_abs_attributes.incl.pl1 */
  9     2 
  9     3 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  9     4 /*							       */
  9     5 /* This include file describes the attributes of an absentee job.  It is     */
  9     6 /* used by user_table_entry.incl.pl1, abs_message_format.incl.pl1            */
  9     7 /* and PIT.incl.pl1.   */
  9     8 /*							       */
  9     9 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  9    10 
  9    11 /****^  HISTORY COMMENTS:
  9    12*  1) change(86-12-08,GDixon), approve(87-07-13,MCR7741),
  9    13*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  9    14*     Separated abs_attributes from the request structure
  9    15*     (abs_message_format.incl.pl1) so that the identical structure could be
  9    16*     used in the ute structure (user_table_entry.incl.pl1).
  9    17*  2) change(87-04-19,GDixon), approve(87-07-13,MCR7741),
  9    18*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  9    19*     Added ABS_ATTRIBUTE_NAMES array.
  9    20*  3) change(87-11-11,Parisek), approve(88-02-11,MCR7849),
  9    21*     audit(88-03-22,Lippard), install(88-07-13,MR12.2-1047):
  9    22*     Added the no_start_up flag. SCP6367
  9    23*                                                   END HISTORY COMMENTS */
  9    24 
  9    25 dcl 1 user_abs_attributes		aligned based,
  9    26       2 restartable			bit (1) unaligned,	/* 1 if request may be started over from the beginning */
  9    27       2 user_deferred_until_time	bit (1) unaligned,	/* 1 if request was specified as deferred */
  9    28       2 proxy			bit (1) unaligned,	/* 1 if request submitted for someone else */
  9    29       2 set_bit_cnt			bit (1) unaligned,	/* 1 if should set bit count after every write call */
  9    30       2 time_in_gmt			bit (1) unaligned,	/* 1 if deferred_time is in GMT */
  9    31       2 user_deferred_indefinitely	bit (1) unaligned,	/* 1 if operator is to say when to run it */
  9    32       2 secondary_ok		bit (1) unaligned,	/* 1 if ok to log in as secondary foreground user */
  9    33       2 truncate_absout		bit (1) unaligned,	/* 1 if .absout is to be truncated */
  9    34       2 restarted			bit (1) unaligned,	/* 1 if job is restarted */
  9    35       2 no_start_up                     bit (1) unaligned,	/* 1 if requested -ns */
  9    36       2 attributes_pad		bit (26) unaligned;
  9    37 
  9    38 dcl  ABS_ATTRIBUTE_NAMES (10) char (28) varying int static options(constant) init(
  9    39 	"restartable",
  9    40 	"user_deferred_until_time",
  9    41 	"proxy",
  9    42 	"set_bit_cnt",
  9    43 	"time_in_gmt",
  9    44 	"user_deferred_indefinitely",
  9    45 	"secondary_ok",
  9    46 	"truncate_absout",
  9    47 	"restarted",
  9    48 	"no_start_up");
  9    49 
  9    50 /* END INCLUDE FILE ... user_abs_attributes.incl.pl1 */
  9    51 
  8   112 
  8   113 
  8   114 /* END INCLUDE FILE ... user_attributes.incl.pl1 */
      518 
      519  /*  BEGIN INCLUDE FILE ... user_table_entry.incl.pl1 */
 10     2 
 10     3 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 10     4 /*							       */
 10     5 /* This include file requires that the user include		       */
 10     6 /* user_attributes.incl.pl1 as well.  It also includes		       */
 10     7 /* abs_attributes.incl.pl1 itself.				       */
 10     8 /*							       */
 10     9 /* This include file must be included to use absentee_user_table.incl.pl1,   */
 10    10 /* answer_table.incl.pl1, and daemon_user_table.incl.pl1.		       */
 10    11 /*							       */
 10    12 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 10    13 
 10    14 /****^  HISTORY COMMENTS:
 10    15*  1) change(81-12-21,Gilcrease), approve(86-03-27,MCR7370),
 10    16*     audit(86-06-23,Lippard), install(86-06-30,MR12.0-1082):
 10    17*     This comment for hcom.
 10    18*     81-12-21  E. N. Kittlitz. derived from abs_user_tab.incl.pl1,
 10    19*     anstbl.incl.pl1, and dutbl.incl.pl1.
 10    20*     82-01-02 E. N. Kittlitz. user_attributes.incl.pl1 changes
 10    21*     84-04-04 BIM added privileged_dial_server and dial_server_ring
 10    22*     84-07-12 BIM added min_process_authorization
 10    23*     84-12-31 Keith Loepere added pdir_dir_quota
 10    24*     85-01-16 by E. Swenson to add ute.session_uid
 10    25*  2) change(85-11-16,Swenson), approve(87-07-13,MCR7737),
 10    26*     audit(87-04-14,GDixon), install(87-08-04,MR12.1-1056):
 10    27*     Added fields for DSA login server support.
 10    28*  3) change(86-03-27,Gilcrease), approve(86-03-27,MCR7370),
 10    29*     audit(86-06-23,Lippard), install(86-06-30,MR12.0-1082):
 10    30*     Add truncate_absout and restarted bit for -truncate absout, SCP6297.
 10    31*  4) change(86-04-09,Herbst), approve(87-07-13,MCR7697),
 10    32*     audit(87-04-14,GDixon), install(87-08-04,MR12.1-1056):
 10    33*     Added disconnection_rel_minutes.
 10    34*  5) change(86-12-08,GDixon), approve(87-07-13,MCR7741),
 10    35*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 10    36*     Changed structure under ute.abs_attributes to use like structure in
 10    37*     abs_attributes.incl.pl1.  This allows the same attributes to be used
 10    38*     in abs_message_format.incl.pl1 and pit.incl.pl1 as well as this include
 10    39*     file.
 10    40*  6) change(87-04-14,GDixon), approve(87-07-13,MCR7741),
 10    41*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 10    42*     Move constants for ute.pw_flags.mask_ctl from answer_table.incl.pl1.
 10    43*  7) change(87-04-16,GDixon), approve(87-07-13,MCR7741),
 10    44*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 10    45*      A) Global reorganization to locate things by type of data.
 10    46*      B) Eliminate ute.uflags.logged_in.
 10    47*  8) change(87-05-10,GDixon), approve(87-07-13,MCR7741),
 10    48*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 10    49*      A) Reduced overlength person and project fields to proper length.
 10    50*      B) Adjusted dialed-console section to begin on even word boundary.
 10    51*  9) change(87-05-13,GDixon), approve(87-07-13,MCR7741),
 10    52*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 10    53*     Add ute.line_type.
 10    54* 10) change(87-11-19,Parisek), approve(88-02-11,MCR7849),
 10    55*     audit(88-02-23,Lippard), install(88-07-13,MR12.2-1047):
 10    56*     Added the lowest_ring element. Used the upper half of ute.highest_ring
 10    57*     for the storage.  SCP6367
 10    58*                                                   END HISTORY COMMENTS */
 10    59 
 10    60 /* format: style4 */
 10    61 
 10    62 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 10    63 /*							       */
 10    64 /* Each of the named sections below defines a type of data.  Typing comes    */
 10    65 /* from data associated with the ute entry itself, with the person, with     */
 10    66 /* login argument data, from the main user of the data (eg, dialup_,	       */
 10    67 /* load_ctl_, login server).  Each section begins on a double-word boundary  */
 10    68 /* and is an even number of words long.  The total structure is 300 decimal  */
 10    69 /* words long.						       */
 10    70 /*							       */
 10    71 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 10    72 
 10    73 
 10    74 dcl  UTE_version_4 fixed bin internal static options (constant) init (4);
 10    75 
 10    76 dcl  utep pointer automatic init (null);
 10    77 
 10    78 dcl  1 ute based (utep) aligned,			/* individual entry in one of the user control tables */
 10    79 
 10    80 /* Variables which give state of this entry */
 10    81        2 active fixed bin,				/* state of entry. 0=>free. see dialup_values.incl.pl1 */
 10    82        2 process_type fixed bin,			/* 1=interactive, 2=absentee, 3=daemon */
 10    83        2 ute_index fixed bin,				/* index of ute in (anstbl autbl dutbl).entry array */
 10    84        2 next_free fixed bin,				/* points to previous free entry */
 10    85 
 10    86 /* Information user gave about person_id associated with this entry. */
 10    87        2 person char (24) unal,			/* user's name */
 10    88        2 project char (12) unal,			/* project of absentee user */
 10    89        2 tag char (1) unal,				/* instance tag - someday will be generated */
 10    90        2 tag_pad bit (27) unal,
 10    91        2 anonymous fixed bin,				/* 1 if anonymous, otherwise 0 */
 10    92        2 login_flags,				/* flags for login data */
 10    93          3 cpw bit (1) unal,				/* flag for wish to change password */
 10    94          3 generate_pw bit (1) unal,			/* flag meaning -generate_pw (-gpw) was used. */
 10    95          3 special_pw unal,				/* dial or slave */
 10    96 	 4 dial_pw bit (1) unal,			/* true if dial -user */
 10    97 	 4 slave_pw bit (1) unal,			/* true if slave -user */
 10    98          3 cdp bit (1) unal,				/* flag for wish to change default project */
 10    99          3 cda bit (1) unal,				/* flag to change default authorization */
 10   100          3 auth_given bit (1) unal,			/* flag to mean -authorization was used. */
 10   101          3 noprint bit (1) unal,			/* used at logout. inhibits printing. */
 10   102          3 operator bit (1) unaligned,			/* user specified -operator on login command line */
 10   103          3 pw_pad bit (25) unal,			/* spare parts */
 10   104          3 mask_ctl bit (2) unal,			/* bits controlling pw mask. See constants, below */
 10   105 						/* Must remain last in pw_flags so it does not */
 10   106 						/* appear in PW_FLAG_VALUES array below. */
 10   107        2 generated_pw char (8) unal,			/* user must type this as new password */
 10   108        2 old_password char (8) unal,			/* must match user's previous password (value scrambled) */
 10   109        2 process_authorization bit (72),		/* access_authorization of this process */
 10   110 
 10   111 /* Information user gave about process associated with this entry. */
 10   112        2 outer_module char (32) unal,			/* Name of console dim */
 10   113        2 home_dir char (64) unal,			/* initial home directory */
 10   114        2 init_proc char (64) unal,			/* name of login responder */
 10   115        2 ip_len fixed bin (17) unal,			/* length of initproc string */
 10   116        2 ss_len fixed bin (17) unal,			/* length of subsystem string */
 10   117        2 ur_at like user_attributes aligned,		/* bits on means attributes given by user */
 10   118        2 at like user_attributes aligned,		/* bits on means attribute is on */
 10   119        2 initial_ring fixed bin,			/* ring process will be started in */
 10   120        2 arg_count fixed bin,				/* number of arguments to absentee control segment */
 10   121        2 ln_args fixed bin,				/* length of string containing arguments */
 10   122        2 arg_lengths_ptr ptr,				/* pointer to array of argument lengths */
 10   123        2 args_ptr ptr,				/* pointer to arguments to absentee control segment */
 10   124 
 10   125 /* Most of the following information is relevant only to absentee processes */
 10   126        2 input_seg char (168) unal,			/* pathname of absentee control segment */
 10   127        2 output_seg char (168) unal,			/* pathname of absentee output file */
 10   128        2 request_id fixed bin (71),			/* time request was entered - used as uid of request */
 10   129        2 reservation_id fixed bin (71),			/* nonzero if job has a resource reservation */
 10   130        2 message_id bit (72),				/* message segment id assoc with absentee request */
 10   131        2 deferred_time fixed bin (71),			/* time at which absentee process should be created */
 10   132        2 max_cpu_time fixed bin (35),			/* maximum number of seconds this process can run */
 10   133        2 queue fixed bin,				/* -1=daemon;0=interactive or foreground;>0=queue no.
 10   134*						   (but see uflags.adjust_abs_q_no). */
 10   135        2 real_queue fixed bin,			/* real queue number; ute.queue gets fudged sometimes */
 10   136        2 abs_attributes aligned like user_abs_attributes,	/* include abs_attributes.incl.pl1 */
 10   137        2 abs_flags,
 10   138          3 abs_run bit (1) unal,			/* on if job was started by abs run command */
 10   139          3 notify bit (1) unal,			/* on if user wants notification at login and logout */
 10   140          3 abs_flags_pad bit (34) unal,
 10   141        2 abs_group char (8) unal,			/* original group before load_ctl_ moves it to absentee group */
 10   142        2 sender char (32) unal,			/* name of RJE station that job is from */
 10   143        2 proxy_person char (28) unal,			/* name of user who actually entered the request, if proxy */
 10   144        2 proxy_project char (9) unal,
 10   145        2 proxy_project_pad char (3) unal,
 10   146        2 abs_pad fixed bin,
 10   147 
 10   148 /* Information about process actually created */
 10   149        2 proc_id bit (36),				/* process id of absentee process */
 10   150        2 session_uid fixed bin (35),			/* Unique authentication session id */
 10   151        2 process_authorization_range (2) bit (72) aligned,
 10   152        2 audit bit (36),				/* audit flags for user */
 10   153        2 lot_size fixed bin,				/* Size of linkage offset table */
 10   154        2 kst_size fixed bin,				/* Size of process known segment table */
 10   155        2 cls_size fixed bin,				/* Size of process combined linkage */
 10   156        2 sus_channel fixed bin (71),			/* event channel on which suspended process is blocked */
 10   157        2 lowest_ring fixed bin (17) unal,		/* lowest ring permitted */
 10   158        2 highest_ring fixed bin (17) unal,		/* highest ring permitted */
 10   159        2 pdir_lvix fixed bin (17) unal,			/* index in disk table of lv where pdir is */
 10   160        2 pdir_quota fixed bin (17) unal,		/* process directory quota */
 10   161        2 pdir_dir_quota fixed bin (17) unal,		/* process directory quota for dirs */
 10   162        2 pdir_pad fixed bin(17) unal,
 10   163        2 process_pad fixed bin,
 10   164 
 10   165 /* Information about primary terminal associated with this entry */
 10   166        2 tty_name char (32) unal,			/* absentee=>"abs1", etc.  daemon=>"bk", etc. */
 10   167        2 terminal_type char (32) unaligned,		/* terminal type */
 10   168        2 line_type fixed bin,				/* line type */
 10   169        2 tty_id_code char (4) unal,			/* "none" for absentee */
 10   170        2 network_connection_type fixed bin,		/* see net_event_message.incl.pl1 */
 10   171        2 channel ptr unal,				/* points to CDT entry for user, if any */
 10   172 
 10   173 /* Variables useful for dialed terminals */
 10   174        2 ndialed_consoles fixed bin,			/* if master, number of slaves */
 10   175        2 dial_qualifier char (22) unal,			/* first argument to dial command */
 10   176        2 dial_server_ring fixed bin (3) unsigned unaligned, /* dial server intends to attach dialing in channels at this ring. */
 10   177        2 dial_server_flags,
 10   178          3 registered_dial_server bit (1) unal,		/* process is a registered dial server */
 10   179          3 privileged_dial_server bit (1) unal,		/* "1"b -> serves range of AIM classes */
 10   180          3 dial_server_flags_pad bit (13) unal,		/* fill out the word */
 10   181        2 dial_ev_chn fixed bin (71),			/* if master, control event channel */
 10   182 
 10   183 /* Information about usage/accounting.  Device usage meters are in a
 10   184*   separate segment, "devtab" */
 10   185        2 pdtep ptr,					/* ptr to user's pdt entry, where usage meters live */
 10   186        2 cpu_this_process fixed bin (71),		/* cpu used so far this process */
 10   187        2 cpu_usage fixed bin (71),			/* total cpu time used in this session */
 10   188        2 mem_usage fixed bin (71),			/* memory usage for previous processes in session */
 10   189        2 mem_this_process fixed bin (71),		/* memory usage at last update */
 10   190        2 last_update_time fixed bin (71),		/* time of last account update */
 10   191        2 session_cost float bin,			/* dollar cost of session, for printing in logout messages */
 10   192        2 ndevices fixed bin,				/* Count of attached devices */
 10   193        2 device_head fixed bin,			/* Table index of head of device chain */
 10   194        2 device_tail fixed bin,			/* Table index of tail of device chain */
 10   195        2 rs_number fixed bin (6) unsigned unal,		/* rate structure number */
 10   196        2 rs_number_pad bit(30) unal,
 10   197        2 usage_pad fixed bin,
 10   198 
 10   199 /* Information for dialup_ (control variables). */
 10   200        2 event fixed bin (71),			/* event associated with channel or user manager */
 10   201        2 uprojp ptr,				/* ptr to user project sat entry */
 10   202        2 login_time fixed bin (71),			/* time when absentee user approved by lg_ctl_ */
 10   203        2 cant_bump_until fixed bin (71),		/* bump-protection clock */
 10   204        2 recent_fatal_error_time fixed bin (71),		/* time of first error in the suspected loop */
 10   205        2 recent_fatal_error_count fixed bin,		/* counter to detect fatal process error loops */
 10   206        2 failure_reason fixed bin,			/* why login refused 1=lg_ctl, 2=act_ctl, 3=load_ctl */
 10   207        2 count fixed bin,				/* counter for logins and dialups */
 10   208        2 n_processes fixed bin,			/* number of processes created in this session */
 10   209        2 lock_value fixed bin,			/* number of locks set for this entry */
 10   210        2 login_result fixed bin,			/* 0=logged in;1=hopeless,hang him up;2=allow another attempt */
 10   211        2 login_code char (8) unal,			/* login command from LOGIN line */
 10   212        2 preempted fixed bin,				/* if ^= 0 user preempted (never for abs) */
 10   213        2 destroy_flag fixed bin,			/* >8 when awaiting destroy */
 10   214        2 logout_type char (4) unal,			/* type of logout */
 10   215        2 logout_index fixed bin,			/* to save logout handler index while waiting for termsgnl */
 10   216        2 disconnection_rel_minutes fixed bin (17) unal,	/* disconnected this many minutes after login_time */
 10   217        2 next_disconnected_ate_index fixed bin (17) unal,	/* thread of list of user's disconnected processes */
 10   218        2 work_class fixed bin,			/* work class used by priority scheduler */
 10   219        2 group char (8) unal,				/* party group identifier */
 10   220        2 whotabx fixed bin,				/* index of user's entry in whotab */
 10   221 
 10   222        2 uflags,					/* Miscellaneous flags */
 10   223          3 dont_call_init_admin bit (1) unal,		/* Call overseer directly */
 10   224          3 ip_given bit (1) unal,			/* user gave an initproc arg on login line */
 10   225          3 ss_given bit (1) unal,			/* initial_procedure contains a subsystem name */
 10   226          3 lvs_attached bit (1) unal,			/* set and used by the lv_request_ procedure */
 10   227          3 send_initial_string bit (1) unal,		/* initial string should be sent after login line read */
 10   228          3 adjust_abs_q_no bit (1) unal,		/* this is an absentee job; user_profile.queue is NOT true Q # */
 10   229          3 foreground_secondary_ok bit (1) unal,		/* ok to login foreground absentee job as secondary */
 10   230          3 foreground_job bit (1) unal,			/* job was originally from foreground queue */
 10   231          3 sus_sent bit (1) unal,			/* sus_ ips signal has been sent to process */
 10   232          3 suspended bit (1) unal,			/* process has responded to sus_ signal */
 10   233          3 ignore_cpulimit bit (1) unal,		/* process is released, but timer can't be turned off */
 10   234          3 deferral_logged bit (1) unal,		/* abs job deferral has already been logged once */
 10   235          3 save_if_disconnected bit (1) unal,		/* user wants process preserved across hangups */
 10   236          3 disconnected bit (1) unal,			/* process is disconnected from terminal */
 10   237          3 disconnected_list bit (1) unal,		/* this ate is on a list of disconnected processes */
 10   238          3 proc_create_ok bit (1) unal,			/* lg_ctl_ has set the process creation variables */
 10   239          3 activity_can_unbump bit (1) unal,		/* only bump pending is for inactivity */
 10   240          3 fpe_causes_logout bit (1) unal,		/* "1"b means don't try to new_proc after fatal process error */
 10   241          3 user_specified_immediate bit (1) unal,		/* "1"b -> don't wait around for process destruction. */
 10   242          3 uflags_pad bit (17) unal,
 10   243 
 10   244 /* Information used by load_ctl_ for the process */
 10   245        2 user_weight fixed bin,			/* usually 10 - used in load control */
 10   246        2 standby_line fixed bin,			/* 0=user has primary line, 1=standby user */
 10   247        2 bump_grace fixed bin (71),			/* bump grace in microseconds */
 10   248 
 10   249 
 10   250 /* Information for login server */
 10   251        2 login_server_info,
 10   252          3 our_handle bit (72) aligned,			/* how LS refers to us. */
 10   253          3 his_handle bit (72) aligned,			/* how we talk to LS */
 10   254          3 termination_event_channel fixed bin (71),	/* for process termination notifications to the LS */
 10   255          3 response_event_channel fixed bin (71),		/* for other communications with the LS */
 10   256          3 process_id bit (36) aligned,			/* process_id of login server */
 10   257        2 ls_pad (5) fixed bin;			/* pad to 300 decimal words */
 10   258 
 10   259 /* values for ute.process_type */
 10   260 
 10   261 dcl  (PT_INTERACTIVE initial (1),
 10   262      PT_ABSENTEE initial (2),
 10   263      PT_DAEMON initial (3)) fixed bin internal static options (constant);
 10   264 
 10   265 dcl  PROCESS_TYPE_NAMES (0:3) char(12) varying int static options(constant) init(
 10   266 	"INVALID-TYPE",
 10   267 	"interactive",
 10   268 	"absentee",
 10   269 	"daemon");
 10   270 
 10   271 dcl  TABLE_NAMES (0:3) char(20) int static options(constant) init(
 10   272 	"UNKNOWN-TABLE",
 10   273 	"answer_table",
 10   274 	"absentee_user_table",
 10   275 	"daemon_user_table");
 10   276 
 10   277 
 10   278 /* values for ute.pw_flags.mask_ctl  */
 10   279 
 10   280 dcl  (DO_MASK init ("00"b),
 10   281      DONT_MASK init ("01"b),
 10   282      DERIVE_MASK init ("10"b)) bit (2) internal static options (constant);
 10   283 
 10   284 dcl  MASK_CTL_NAMES (0:3) char(12) varying int static options(constant) init(
 10   285 	"do_mask", "dont_mask", "derive_mask", "");
 10   286 
 10   287 
 10   288 /* names for ute.pw_flags */
 10   289 
 10   290 dcl  PW_FLAG_NAMES (9) char (12) varying int static options(constant) init(
 10   291 	"cpw",
 10   292 	"generate_pw",
 10   293 	"dial_pw",
 10   294 	"slave_pw",
 10   295 	"cdp",
 10   296 	"cda",
 10   297 	"auth_given",
 10   298 	"noprint",
 10   299 	"operator");
 10   300 
 10   301 /* names for ute.uflags */
 10   302 
 10   303 dcl  UFLAG_NAMES (19) char (24) varying int static options (constant) init (
 10   304 	"dont_call_init_admin",
 10   305 	"ip_given",
 10   306 	"ss_given",
 10   307 	"lvs_attached",
 10   308 	"send_initial_string",
 10   309 	"adjust_abs_q_no",
 10   310 	"foreground_secondary_ok",
 10   311 	"foreground_job",
 10   312 	"sus_sent",
 10   313 	"suspended",
 10   314 	"ignore_cpulimit",
 10   315 	"deferral_logged",
 10   316 	"save_if_disconnected",
 10   317 	"disconnected",
 10   318 	"disconnected_list",
 10   319 	"proc_create_ok",
 10   320 	"activity_can_unbump",
 10   321 	"fpe_causes_logout",
 10   322 	"user_specified_immediate");
 10   323 
 10   324 /* names for ute.abs_flags */
 10   325 
 10   326 dcl  ABS_FLAG_NAMES (2) char (8) varying int static options (constant) init (
 10   327 	"abs_run",
 10   328 	"notify");
 10   329 
 10   330 /* names of ute.dial_server_flags */
 10   331 
 10   332 dcl  DIAL_SERVER_FLAG_NAMES (2) char (12) varying int static options (constant) init (
 10   333 	"registered",
 10   334 	"privileged");
 10   335 
 10   336 /* values of ute.login_result */
 10   337 
 10   338 dcl  LOGIN_RESULT_VALUES (0:2) char(24) varying int static options(constant) init(
 10   339 	"logged in",
 10   340 	"login failed, hangup",
 10   341 	"login failed, try again");
 10   342 
 10   343 /*  END INCLUDE FILE ... user_table_entry.incl.pl1 */
      519 
      520  /* BEGIN INCLUDE FILE ... user_table_header.incl.pl1 */
 11     2 
 11     3 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 11     4 /*							       */
 11     5 /* This include file declares the header shared by the answer_table,	       */
 11     6 /* absentee_user_table and daemon_user_table include files.		       */
 11     7 /*							       */
 11     8 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
 11     9 
 11    10 /****^  HISTORY COMMENTS:
 11    11*  1) change(87-04-26,GDixon), approve(87-07-13,MCR7741),
 11    12*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
 11    13*     Initial coding.
 11    14*                                                   END HISTORY COMMENTS */
 11    15 
 11    16 dcl  1 ut_header			aligned based,	/* header shared by all user control tables. */
 11    17        2 header_version fixed bin,			/* version of the header (3) */
 11    18        2 entry_version fixed bin,			/* version of user table entries */
 11    19        2 user_table_type fixed bin,			/* 1 interactive, 2 absentee, 3 daemon */
 11    20        2 header_length fixed bin,			/* length of the header */
 11    21        2 max_size fixed bin,				/* max number of entries in this table */
 11    22        2 current_size fixed bin,			/* actual size of table (in entries) */
 11    23        2 number_free fixed bin,			/* number of free entries in the table. */
 11    24        2 first_free fixed bin,			/* index of first entry in the free list. */
 11    25        2 as_procid bit (36),				/* process ID of user table manager process */
 11    26        2 ut_header_pad fixed bin;
 11    27 
 11    28 /* END INCLUDE FILE ... user_table_header.incl.pl1 */
      520 
      521 
      522    end dm_fast_lock_status;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/13/88  0937.9  dm_fast_lock_status.pl1           >special_ldd>install>MR12.2-1047>dm_fast_lock_status.pl1
511          1    08/06/87  0913.4  absentee_user_table.incl.pl1      >ldd>include>absentee_user_table.incl.pl1
512          2    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
513          3    08/06/87  0913.0  answer_table.incl.pl1             >ldd>include>answer_table.incl.pl1
514          4    08/06/87  0912.9  daemon_user_table.incl.pl1        >ldd>include>daemon_user_table.incl.pl1
515          5    01/07/85  0858.7  dm_fast_lock_strucs.incl.pl1      >ldd>include>dm_fast_lock_strucs.incl.pl1
516          6    01/07/85  0859.2  dm_lock_list_strucs.incl.pl1      >ldd>include>dm_lock_list_strucs.incl.pl1
517          7    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
518          8    08/06/87  0913.6  user_attributes.incl.pl1          >ldd>include>user_attributes.incl.pl1
8-112        9    07/13/88  0900.1  user_abs_attributes.incl.pl1      >special_ldd>install>MR12.2-1047>user_abs_attributes.incl.pl1
519         10    07/13/88  0903.2  user_table_entry.incl.pl1         >special_ldd>install>MR12.2-1047>user_table_entry.incl.pl1
520         11    08/06/87  0913.6  user_table_header.incl.pl1        >ldd>include>user_table_header.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ABSENTEE_USER_TABLE             001171 constant        char(32)                 initial packed unaligned dcl 90 set ref 340* 341*
ACTION_CANT_RESTART             001232 constant        bit(36)                  initial dcl 7-7 set ref 298*
ANSWER_TABLE                    001201 constant        char(32)                 initial packed unaligned dcl 90 set ref 338* 339*
ARGUMENT_TYPE                   000462 constant        varying char(64)         initial array dcl 105 set ref 505 505*
CONTROL_ARGUMENT                000042 constant        varying char(64)         initial array dcl 109 set ref 492 492 495 505*
DAEMON_USER_TABLE               001161 constant        char(32)                 initial packed unaligned dcl 90 set ref 342* 343*
FAST_LOCK_DATA_VERSION_1        000040 constant        char(8)                  initial dcl 5-23 set ref 164*
MAX_LINE_LENGTH                        constant        fixed bin(21,0)          initial dcl 101 ref 161 197 214 214 239 239 247 253
NO                                     constant        bit(1)                   initial packed unaligned dcl 90 ref 40 48 50 52 54
                                                                                  56 57 69 182 216 219 242 390 400 417 431 446 460
                                                                                  466 477
R_ACCESS                        001232 constant        bit(3)                   initial packed unaligned dcl 2-11 set ref 338* 340*
                                                                                  342*
SYSDIR                          001107 constant        char(168)                initial packed unaligned dcl 90 set ref 338* 340*
                                                                                  342*
UTE_SIZE                               constant        fixed bin(17,0)          initial dcl 3-120 ref 314 314
WAIT                            001211 constant        char(4)                  initial packed unaligned dcl 90 ref 210
YES                                    constant        bit(1)                   initial packed unaligned dcl 90 ref 47 49 67 168 174
                                                                                  176 220 231 232 235 384 389 396 399 416 424 428
                                                                                  435 438 442 452 456 470 474 479
accept_control_argument         000100 automatic       bit(1)                   initial dcl 38 set ref 38* 168* 174* 176 176* 182
                                                                                  384* 396*
active                                 based           fixed bin(17,0)          level 2 dcl 10-78 ref 315 320 325
addr                                                   builtin function         dcl 84 ref 185 186 190 208 225 314 319 324
addrel                                                 builtin function         dcl 84 ref 195 204 251
after                                                  builtin function         dcl 84 ref 355 355
ansp                            000210 automatic       pointer                  initial dcl 3-53 set ref 3-53* 313 314 338* 339
anstbl                                 based           structure                level 1 dcl 3-55
answer_table_idx                000101 automatic       fixed bin(17,0)          dcl 39 set ref 313* 314* 318* 319* 323* 324*
arg                                    based           char                     packed unaligned dcl 74 set ref 174 174* 176* 377*
                                                                                  385* 388* 397*
arg_idx                         000103 automatic       fixed bin(17,0)          dcl 41 set ref 171* 173*
arg_len                         000104 automatic       fixed bin(21,0)          dcl 42 set ref 173* 174 174 174 176 176 377 377 385
                                                                                  385 388 388 397 397
arg_list_ptr                    000106 automatic       pointer                  initial dcl 43 set ref 43* 150* 151*
arg_ptr                         000110 automatic       pointer                  dcl 44 set ref 173* 174 174 176 377 385 388 397
at_least_one_lock               000102 automatic       bit(1)                   initial packed unaligned dcl 40 set ref 40* 232*
                                                                                  235* 254 255
autbl                                  based           structure                level 1 dcl 1-28
autp                            000206 automatic       pointer                  initial dcl 1-26 set ref 1-26* 318 319 340* 341
before                                                 builtin function         dcl 84 ref 354 354 355 355 356 356
block_data                2            based           bit(36)                  array level 2 dcl 6-31 set ref 208 225
cai_control_argument_idx        000320 automatic       fixed bin(17,0)          dcl 490 set ref 492* 492* 495 497
cai_p_arg                              parameter       char                     packed unaligned dcl 489 ref 486 492
cleanup                         000172 stack reference condition                dcl 83 ref 153
code                            000112 automatic       fixed bin(35,0)          dcl 45 set ref 151* 162* 163 163* 237* 239 256* 257
                                                                                  385* 388 388*
control_argument_idx            000113 automatic       fixed bin(17,0)          dcl 46 set ref 169* 174* 176* 179* 182 182* 381*
                                                                                  393*
count                                  based           fixed bin(17,0)          level 2 in structure "process_id_list" dcl 76
                                                                                  in procedure "dmflst" set ref 160* 227 230 257
                                                                                  386*
count                                  based           fixed bin(17,0)          level 2 in structure "gp_process_id_list" dcl 309
                                                                                  in procedure "GET_PROCESS_ID_FROM_USER_ID" ref 328
count                                  based           fixed bin(17,0)          level 2 in structure "mu_process_id_list" dcl 351
                                                                                  in procedure "MATCH_USER_TABLE_ENTRY" set ref 358*
                                                                                  358 359
cu_$arg_list_ptr                000010 constant        entry                    external dcl 117 ref 150
current_size              5            based           fixed bin(17,0)          level 3 in structure "anstbl" dcl 3-55 in procedure
                                                                                  "dmflst" ref 313
current_size              5            based           fixed bin(17,0)          level 3 in structure "dutbl" dcl 4-29 in procedure
                                                                                  "dmflst" ref 323
current_size              5            based           fixed bin(17,0)          level 3 in structure "autbl" dcl 1-28 in procedure
                                                                                  "dmflst" ref 318
cv_oct_check_                   000012 constant        entry                    external dcl 118 ref 385
cv_p_expected_version                  parameter       char(8)                  dcl 294 set ref 291 298 298*
cv_p_received_version                  parameter       char(8)                  dcl 295 set ref 291 298 298*
cv_p_structure_name                    parameter       char(32)                 dcl 296 set ref 291 298*
cv_userid_                      000014 constant        entry                    external dcl 119 ref 397
display_all_locks               000114 automatic       bit(1)                   initial packed unaligned dcl 47 set ref 47* 235 247
                                                                                  254 390* 400* 452* 474*
display_header                  000115 automatic       bit(1)                   initial packed unaligned dcl 48 set ref 48* 197 214*
                                                                                  216* 253 424* 431*
display_line                           based           varying char             dcl 75 set ref 161 197* 214* 214* 239* 239* 247*
                                                                                  253*
display_line_ptr                000120 automatic       pointer                  dcl 51 set ref 161* 197 214 214 239 239 247 253
display_waiters                 000116 automatic       bit(1)                   initial packed unaligned dcl 49 set ref 49* 238 438*
                                                                                  466*
dm_error_$system_not_initialized
                                000052 external static fixed bin(35,0)          dcl 140 set ref 154*
dm_not_available_               000200 stack reference condition                dcl 83 ref 154
dutbl                                  based           structure                level 1 dcl 4-29
dutp                            000212 automatic       pointer                  initial dcl 4-27 set ref 4-27* 323 324 342* 343
end_of_chain                    000117 automatic       bit(1)                   initial packed unaligned dcl 50 set ref 50* 219* 221
                                                                                  244*
entry                   200            based           structure                array level 2 in structure "autbl" dcl 1-28
                                                                                  in procedure "dmflst" set ref 319
entry                   200            based           structure                array level 2 in structure "dutbl" dcl 4-29
                                                                                  in procedure "dmflst" set ref 324
entry                   200            based           structure                array level 2 in structure "anstbl" dcl 3-55
                                                                                  in procedure "dmflst" set ref 314
er_code                                parameter       fixed bin(35,0)          dcl 269 set ref 266 272*
er_message                             parameter       char                     packed unaligned dcl 270 set ref 266 272*
error_table_$bad_arg            000056 external static fixed bin(35,0)          dcl 140 set ref 328* 377*
error_table_$badopt             000054 external static fixed bin(35,0)          dcl 140 set ref 421*
error_table_$noarg              000060 external static fixed bin(35,0)          dcl 140 set ref 505*
error_table_$unimplemented_version
                                000062 external static fixed bin(35,0)          dcl 140 set ref 298*
event_channel                          based           fixed bin(71,0)          level 2 dcl 5-43 set ref 239*
fast_lock_block                        based           structure                level 1 dcl 5-33
fast_lock_block_ptr             000214 automatic       pointer                  dcl 5-19 set ref 208* 210 214 214 221 221
fast_lock_data                         based           structure                level 1 dcl 5-49
fast_lock_data_ptr              000220 automatic       pointer                  dcl 5-21 set ref 157* 162* 164 185 186 190 190 197
                                                                                  197 197 197 197 204 204 221 245
fast_lock_displayed             000122 automatic       bit(1)                   initial packed unaligned dcl 52 set ref 52*
fast_lock_wakeup_block                 based           structure                level 1 dcl 5-43 set ref 187
fast_lock_wakeup_block_ptr      000216 automatic       pointer                  dcl 5-20 set ref 187 208* 210 225* 227 237 239 239
first_waiter                    000123 automatic       bit(1)                   packed unaligned dcl 53 set ref 220* 239* 242*
firstp                                 based           bit(18)                  level 2 packed packed unaligned dcl 6-27 set ref 190
                                                                                  197* 204
force_interpretation_as_argument
                                000124 automatic       bit(1)                   initial dcl 54 set ref 54* 174 176*
free_list_head            4            based           structure                level 2 dcl 5-49 set ref 185
gat_code                        000262 automatic       fixed bin(35,0)          dcl 336 set ref 338* 339* 340* 341* 342* 343*
get_userid_                     000016 constant        entry                    external dcl 120 ref 237 256
given_process_id                000125 automatic       bit(1)                   initial packed unaligned dcl 56 set ref 56* 226 255
                                                                                  389* 399* 477*
given_user_id                   000126 automatic       bit(1)                   initial packed unaligned dcl 57 set ref 57*
gp_p_process_id_list_ptr               parameter       pointer                  dcl 308 set ref 304 315* 320* 325* 328
gp_p_user_id                           parameter       char(34)                 packed unaligned dcl 307 set ref 304 315* 320* 325*
                                                                                  328
gp_process_id_list                     based           structure                level 1 dcl 309
hbound                                                 builtin function         dcl 84 ref 492 495
header                                 based           structure                level 2 in structure "anstbl" dcl 3-55 in procedure
                                                                                  "dmflst"
header                                 based           structure                level 2 in structure "dutbl" dcl 4-29 in procedure
                                                                                  "dmflst"
header                                 based           structure                level 2 in structure "autbl" dcl 1-28 in procedure
                                                                                  "dmflst"
id                        1            based           bit(36)                  array level 2 in structure "process_id_list" dcl 76
                                                                                  in procedure "dmflst" set ref 227 256* 257* 387*
id                        1            based           bit(36)                  array level 2 in structure "mu_process_id_list"
                                                                                  dcl 351 in procedure "MATCH_USER_TABLE_ENTRY" set
                                                                                  ref 359*
index                                                  builtin function         dcl 84 ref 174 505
initiate_file_                  000020 constant        entry                    external dcl 122 ref 338 340 342
ioa_                            000024 constant        entry                    external dcl 124 ref 247 253 254 257
ioa_$rsnnl                      000026 constant        entry                    external dcl 124 ref 197 214 239
list                      6            based           fixed bin(71,0)          level 2 dcl 5-49 set ref 186 190
list_head                 2            based           bit(18)                  level 2 packed packed unaligned dcl 5-33 ref 221 221
lock_list_block                        based           structure                level 1 dcl 6-31 set ref 195 204 251
lock_list_block_ptr             000224 automatic       pointer                  dcl 6-20 set ref 186* 190* 190* 195 195 204* 204 208
                                                                                  218 221* 225 244* 245* 246* 251 251*
lock_list_block_words           000226 automatic       fixed bin(17,0)          dcl 6-23 set ref 187* 195 204 251
lock_list_head                         based           structure                level 1 dcl 6-27
lock_list_head_ptr              000222 automatic       pointer                  dcl 6-19 set ref 185* 190 197 204
lock_list_index                 000127 automatic       fixed bin(17,0)          dcl 58 set ref 189* 194* 194 197 197 203* 203 204
                                                                                  250* 250
lock_manager_$copy_fast_data    000030 constant        entry                    external dcl 128 ref 162
ltrim                                                  builtin function         dcl 84 ref 356 356
match_star_name_                000022 constant        entry                    external dcl 123 ref 354 355 356
message                   3            based           char(4)                  level 2 dcl 5-43 ref 210
mu_code                         000272 automatic       fixed bin(35,0)          dcl 352 set ref 354* 355 355* 356 356* 357
mu_p_process_id_list_ptr               parameter       pointer                  dcl 349 ref 346 358 358 359 359
mu_p_user_id                           parameter       char(34)                 packed unaligned dcl 350 ref 346 354 354 355 355 356
                                                                                  356
mu_process_id_list                     based           structure                level 1 dcl 351
myname                          001102 constant        char(19)                 initial packed unaligned dcl 103 set ref 151* 156*
                                                                                  157* 158* 298*
n_list_entries            3            based           fixed bin(17,0)          level 2 dcl 5-49 ref 197 204
nextp                                  based           bit(18)                  level 2 packed packed unaligned dcl 6-31 ref 244 245
null                                                   builtin function         dcl 84 ref 43 65 66 156 156 162 162 1-26 3-53 4-27
                                                                                  10-76 298 298 339 341 343
number_of_args                  000130 automatic       fixed bin(17,0)          dcl 59 set ref 166* 171
offset                    1            based           bit(18)                  level 2 packed packed unaligned dcl 5-33 set ref
                                                                                  214*
pa_code                         000302 automatic       fixed bin(35,0)          dcl 372 set ref 374*
pa_p_accept_control_argument           parameter       bit(1)                   dcl 370 ref 365
pa_p_arg                               parameter       char                     packed unaligned dcl 368 ref 365
pa_p_control_argument_idx              parameter       fixed bin(17,0)          dcl 369 ref 365 376
pca_p_accept_control_argument          parameter       bit(1)                   dcl 411 set ref 405 416* 428* 435* 442* 446* 456*
                                                                                  460* 470* 479*
pca_p_arg                              parameter       char                     packed unaligned dcl 409 set ref 405 415* 421*
pca_p_control_argument_idx             parameter       fixed bin(17,0)          dcl 410 set ref 405 415* 419 427* 434* 441* 455*
                                                                                  469* 478*
pca_p_force_interpretation_as_argument parameter       bit(1)                   dcl 412 set ref 405 417*
person                    4            based           char(24)                 level 2 packed packed unaligned dcl 10-78 ref 354
person_id                       000131 automatic       char(22)                 packed unaligned dcl 60 set ref 237* 239* 256* 257*
pointer                                                builtin function         dcl 84 ref 190 204 221 245
proc_id                 276            based           bit(36)                  level 2 dcl 10-78 ref 359
process_id_fb                   000142 automatic       fixed bin(35,0)          dcl 62 set ref 385* 387
process_id_list                        based           structure                level 1 unaligned dcl 76
process_id_list_ptr             000144 automatic       pointer                  dcl 63 set ref 158* 160 227 227 230 256 257 257 386
                                                                                  387 398*
process_idx                     000146 automatic       fixed bin(17,0)          dcl 64 set ref 227* 227* 230
processid                 2            based           bit(36)                  level 2 dcl 5-43 set ref 227 237* 239*
project                  12            based           char(12)                 level 2 packed packed unaligned dcl 10-78 ref 355
project_id                      000137 automatic       char(9)                  packed unaligned dcl 61 set ref 237* 239* 256* 257*
rel                                                    builtin function         dcl 84 ref 197 197
reverse                                                builtin function         dcl 84 ref 356 356
rma_p_control_argument_idx             parameter       fixed bin(17,0)          dcl 503 ref 501 505 505 505
save_lock_list_block_ptr        000150 automatic       pointer                  initial dcl 65 set ref 65* 218* 246
sci_ptr                         000152 automatic       pointer                  initial dcl 66 set ref 66* 151* 156* 157* 158* 166*
                                                                                  173* 272* 288* 377* 421* 505*
size                                                   builtin function         dcl 84 in procedure "dmflst" ref 187 195 204 251
size                      2            based           fixed bin(17,0)          level 2 in structure "fast_lock_data" dcl 5-49
                                                                                  in procedure "dmflst" set ref 197*
ssu_$abort_line                 000032 constant        entry                    external dcl 129 ref 272 377 421 505
ssu_$arg_count                  000034 constant        entry                    external dcl 130 ref 166
ssu_$arg_ptr                    000036 constant        entry                    external dcl 131 ref 173
ssu_$destroy_invocation         000040 constant        entry                    external dcl 132 ref 288
ssu_$get_area                   000042 constant        entry                    external dcl 133 ref 156
ssu_$get_temp_segment           000044 constant        entry                    external dcl 134 ref 157 158
ssu_$standalone_invocation      000046 constant        entry                    external dcl 135 ref 151
sub_err_                        000050 constant        entry                    external dcl 136 ref 298
substr                                                 builtin function         dcl 84 ref 505
tag                      15            based           char(1)                  level 2 packed packed unaligned dcl 10-78 ref 356
this_is_a_standalone_invocation 000154 automatic       bit(1)                   initial dcl 67 set ref 67*
uid                                    based           bit(36)                  level 2 dcl 5-33 set ref 210 214*
unspec                                                 builtin function         dcl 84 set ref 387* 387
user                            000155 automatic       char(34)                 packed unaligned dcl 68 set ref 257* 397* 398*
user_abs_attributes                    based           structure                level 1 dcl 9-25
user_attributes                        based           structure                level 1 dcl 8-21
user_match                      000166 automatic       bit(1)                   initial packed unaligned dcl 69 set ref 69* 219* 226
                                                                                  231* 247
ut_header                              based           structure                level 1 dcl 11-16
ute                                    based           structure                level 1 dcl 10-78
utep                            000230 automatic       pointer                  initial dcl 10-76 set ref 10-76* 314* 315 319* 320
                                                                                  324* 325 354 355 356 359
version                                based           char(8)                  level 2 dcl 5-49 set ref 164* 197*
work_area                              based           area(1024)               dcl 79 ref 161
work_area_ptr                   000170 automatic       pointer                  dcl 70 set ref 156* 161

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABS_ATTRIBUTE_NAMES                    internal static varying char(28)         initial array dcl 9-38
ABS_FLAG_NAMES                         internal static varying char(8)          initial array dcl 10-326
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 7-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 7-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 7-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 7-7
ALT_USER_ATTRIBUTE_NAMES               internal static char(20)                 initial array packed unaligned dcl 8-77
ANSTBL_version_4                       internal static fixed bin(17,0)          initial dcl 3-51
AT_NORMAL                              internal static char(8)                  initial packed unaligned dcl 3-116
AT_SHUTDOWN                            internal static char(8)                  initial packed unaligned dcl 3-116
AT_SPECIAL                             internal static char(8)                  initial packed unaligned dcl 3-116
AUTBL_CONTROL_NAMES                    internal static varying char(20)         initial array dcl 1-68
AUTBL_version_4                        internal static fixed bin(17,0)          initial dcl 1-24
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
DERIVE_MASK                            internal static bit(2)                   initial packed unaligned dcl 10-280
DIAL_SERVER_FLAG_NAMES                 internal static varying char(12)         initial array dcl 10-332
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 2-33
DONT_MASK                              internal static bit(2)                   initial packed unaligned dcl 10-280
DO_MASK                                internal static bit(2)                   initial packed unaligned dcl 10-280
DUTBL_version_4                        internal static fixed bin(17,0)          initial dcl 4-25
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
LOCK_LIST_METERS_VERSION_1             internal static char(8)                  initial dcl 6-25
LOGIN_RESULT_VALUES                    internal static varying char(24)         initial array dcl 10-338
MASK_CTL_NAMES                         internal static varying char(12)         initial array dcl 10-284
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
PROCESS_TYPE_NAMES                     internal static varying char(12)         initial array dcl 10-265
PT_ABSENTEE                            internal static fixed bin(17,0)          initial dcl 10-261
PT_DAEMON                              internal static fixed bin(17,0)          initial dcl 10-261
PT_INTERACTIVE                         internal static fixed bin(17,0)          initial dcl 10-261
PW_FLAG_NAMES                          internal static varying char(12)         initial array dcl 10-290
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 2-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 2-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 2-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
RW_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 2-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 2-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 2-30
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 2-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 2-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 2-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
TABLE_NAMES                            internal static char(20)                 initial array packed unaligned dcl 10-271
UFLAG_NAMES                            internal static varying char(24)         initial array dcl 10-303
USER_ATTRIBUTES_always_allowed         internal static bit(36)                  initial dcl 8-100
USER_ATTRIBUTES_default_in_pdt         internal static bit(36)                  initial dcl 8-104
USER_ATTRIBUTES_settable_by_user       internal static bit(36)                  initial dcl 8-108
USER_ATTRIBUTE_NAMES                   internal static char(20)                 initial array packed unaligned dcl 8-50
UTE_version_4                          internal static fixed bin(17,0)          initial dcl 10-74
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
fast_lock                              based           structure                level 1 dcl 5-25
fast_lock_ptr                          automatic       pointer                  dcl 5-18
lock_list_meters                       based           structure                level 1 dcl 6-38
lock_list_meters_ptr                   automatic       pointer                  dcl 6-21

NAMES DECLARED BY EXPLICIT CONTEXT.
ABORT_ENTRY                     003231 constant        entry                    internal dcl 275 ref 151 151
ALLOCATED_BLOCK_LOOP            002400 constant        label                    dcl 204
ARGUMENT                        000000 constant        label                    array(-1:12) dcl 377 ref 376
ARG_PROCESSING_LOOP             002110 constant        label                    dcl 171
CHECK_VERSION                   003300 constant        entry                    internal dcl 291 ref 164
CLEANUP                         003247 constant        entry                    internal dcl 281 ref 153 277
CONTROL_ARGUMENT                000016 constant        label                    array(-1:16) dcl 421 ref 419
CONTROL_ARGUMENT_INDEX          004535 constant        entry                    internal dcl 486 ref 415
COUNT_FREE_ENTRIES              002257 constant        label                    dcl 190
ERROR_RETURN                    003172 constant        entry                    internal dcl 266 ref 154 163 328 339 341 343 388
FIND_LOCK_WAITERS               002517 constant        label                    dcl 221
FINISH                          003263 constant        entry                    internal dcl 286 ref 261 283
GET_ANSWER_TABLES               003546 constant        entry                    internal dcl 333 ref 311
GET_PROCESS_ID_FROM_USER_ID     003372 constant        entry                    internal dcl 304 ref 398
MAIN_RETURN                     003170 constant        label                    dcl 263 ref 278
MATCH_USER_TABLE_ENTRY          003762 constant        entry                    internal dcl 346 ref 315 320 325
PROCESS_ACTIVE_LOCK             002431 constant        label                    dcl 210
PROCESS_ARGUMENT                004217 constant        entry                    internal dcl 365 ref 174
PROCESS_CONTROL_ARGUMENT        004406 constant        entry                    internal dcl 405 ref 176
REPORT_MISSING_ARGUMENT         004601 constant        entry                    internal dcl 501 ref 179 182
dm_fast_lock_status             001572 constant        entry                    external dcl 31
dmflst                          001562 constant        entry                    external dcl 31

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5236        5322    4676        5246
Length      6030    4676        64         471     337           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
dmflst                              626 external procedure  is an external procedure.  
on unit on line 153                  64 on unit               
on unit on line 154                  78 on unit               
ERROR_RETURN                         80 internal procedure  is called by several nonquick procedures.  
ABORT_ENTRY                          64 internal procedure  is assigned to an entry variable.  
CLEANUP                              64 internal procedure  is called by several nonquick procedures.  
FINISH                               68 internal procedure  is called by several nonquick procedures.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure dmflst.  
GET_PROCESS_ID_FROM_USER_ID             internal procedure  shares stack frame of external procedure dmflst.  
GET_ANSWER_TABLES                       internal procedure  shares stack frame of external procedure dmflst.  
MATCH_USER_TABLE_ENTRY                  internal procedure  shares stack frame of external procedure dmflst.  
PROCESS_ARGUMENT                        internal procedure  shares stack frame of external procedure dmflst.  
PROCESS_CONTROL_ARGUMENT                internal procedure  shares stack frame of external procedure dmflst.  
CONTROL_ARGUMENT_INDEX                  internal procedure  shares stack frame of external procedure dmflst.  
REPORT_MISSING_ARGUMENT                 internal procedure  shares stack frame of external procedure dmflst.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
dmflst                   000100 accept_control_argument     dmflst
                         000101 answer_table_idx            dmflst
                         000102 at_least_one_lock           dmflst
                         000103 arg_idx                     dmflst
                         000104 arg_len                     dmflst
                         000106 arg_list_ptr                dmflst
                         000110 arg_ptr                     dmflst
                         000112 code                        dmflst
                         000113 control_argument_idx        dmflst
                         000114 display_all_locks           dmflst
                         000115 display_header              dmflst
                         000116 display_waiters             dmflst
                         000117 end_of_chain                dmflst
                         000120 display_line_ptr            dmflst
                         000122 fast_lock_displayed         dmflst
                         000123 first_waiter                dmflst
                         000124 force_interpretation_as_argument
                                                            dmflst
                         000125 given_process_id            dmflst
                         000126 given_user_id               dmflst
                         000127 lock_list_index             dmflst
                         000130 number_of_args              dmflst
                         000131 person_id                   dmflst
                         000137 project_id                  dmflst
                         000142 process_id_fb               dmflst
                         000144 process_id_list_ptr         dmflst
                         000146 process_idx                 dmflst
                         000150 save_lock_list_block_ptr    dmflst
                         000152 sci_ptr                     dmflst
                         000154 this_is_a_standalone_invocation
                                                            dmflst
                         000155 user                        dmflst
                         000166 user_match                  dmflst
                         000170 work_area_ptr               dmflst
                         000206 autp                        dmflst
                         000210 ansp                        dmflst
                         000212 dutp                        dmflst
                         000214 fast_lock_block_ptr         dmflst
                         000216 fast_lock_wakeup_block_ptr  dmflst
                         000220 fast_lock_data_ptr          dmflst
                         000222 lock_list_head_ptr          dmflst
                         000224 lock_list_block_ptr         dmflst
                         000226 lock_list_block_words       dmflst
                         000230 utep                        dmflst
                         000262 gat_code                    GET_ANSWER_TABLES
                         000272 mu_code                     MATCH_USER_TABLE_ENTRY
                         000302 pa_code                     PROCESS_ARGUMENT
                         000320 cai_control_argument_idx    CONTROL_ARGUMENT_INDEX

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_this_desc
call_int_this       call_int_other_desc call_int_other      return_mac          tra_ext_1           enable_op
shorten_stack       ext_entry           int_entry           int_entry_desc      reverse_cs          set_chars_eis
op_alloc_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cu_$arg_list_ptr              cv_oct_check_                 cv_userid_                    get_userid_
initiate_file_                ioa_                          ioa_$rsnnl                    lock_manager_$copy_fast_data
match_star_name_              ssu_$abort_line               ssu_$arg_count                ssu_$arg_ptr
ssu_$destroy_invocation       ssu_$get_area                 ssu_$get_temp_segment         ssu_$standalone_invocation
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$system_not_initialized                            error_table_$bad_arg          error_table_$badopt
error_table_$noarg            error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     38 001527        40 001530        43 001531        47 001533        48 001535        49 001536        50 001537
     52 001540        54 001541        56 001542        57 001543        65 001544        66 001546        67 001547
     69 001551    1   26 001552    3   53 001554    4   27 001555   10   76 001556        31 001561       150 001600
    151 001607       153 001646       154 001670       156 001722       157 001747       158 001767       160 002007
    161 002010       162 002020       163 002035       164 002056       166 002073       168 002104       169 002106
    171 002110       173 002117       174 002134       176 002200       179 002233       180 002235       182 002237
    185 002246       186 002251       187 002254       189 002256       190 002257       194 002271       195 002272
    197 002300       203 002376       204 002400       208 002417       210 002424       214 002431       216 002506
    218 002510       219 002512       220 002515       221 002517       225 002534       226 002537       227 002543
    229 002557       230 002561       231 002563       232 002565       234 002566       235 002567       237 002573
    238 002632       239 002634       242 002730       244 002732       245 002740       246 002745       247 002747
    250 002770       251 002771       253 002777       254 003017       255 003042       256 003046       257 003107
    261 003164       263 003170       266 003171       272 003205       273 003227       275 003230       277 003236
    278 003243       281 003246       283 003254       284 003261       286 003262       288 003270       289 003277
    291 003300       298 003302       302 003371       304 003372       311 003374       313 003375       314 003405
    315 003412       316 003426       318 003430       319 003441       320 003445       321 003461       323 003463
    324 003473       325 003477       326 003513       328 003515       331 003545       333 003546       338 003547
    339 003605       340 003625       341 003663       342 003703       343 003741       344 003761       346 003762
    354 003764       355 004026       356 004112       357 004204       358 004207       359 004212       362 004216
    365 004217       374 004230       376 004231       377 004234       379 004267       381 004270       384 004272
    385 004274       386 004317       387 004321       388 004324       389 004345       390 004347       391 004350
    393 004351       396 004353       397 004355       398 004400       399 004402       400 004404       401 004405
    405 004406       415 004417       416 004435       417 004440       419 004441       421 004443       424 004465
    427 004467       428 004472       429 004474       431 004475       434 004477       435 004501       436 004503
    438 004504       441 004505       442 004507       443 004510       446 004511       449 004512       452 004513
    455 004514       456 004516       457 004517       460 004520       463 004521       466 004522       469 004523
    470 004525       471 004526       474 004527       477 004530       478 004531       479 004533       480 004534
    486 004535       492 004546       494 004565       495 004567       497 004576       501 004601       505 004603
    509 004660


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
