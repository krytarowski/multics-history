	COMPILATION LISTING OF SEGMENT expmac
	Compiled by: Multics PL/I Compiler, Release 28d, of September 14, 1983
	Compiled at: Honeywell LCPD Phoenix, System M
	Compiled on: 10/03/83  1637.0 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* macro expander for pl/1.
       12*
       13*  expmac$many expands a macro with many arguments.
       14*
       15*   expmac$one expands a macro with a single argument.  m_a is called
       16*   if the argument is not addressable already.  the parameter 'double'
       17*   being non-zero means that the macro argument represents a double
       18*   length operand.  expmac$one will expand macro+1 if the operand is
       19*   not on an even boundary and macro+2 if it is on an even boundary.
       20*
       21*   expmac$abs is used to append a block of words to the output buffer.
       22*
       23*   expmac$eis is used to expand a macro consisting of an EIS instruction where
       24*   the result operand is in cg_stat$eis_temp and the other operand is passed as an
       25*   argument to expmac$eis.
       26*
       27*   expmac$two_eis is used to expand a macro consisting of an EIS instruction that has
       28*   two operands, both of which are supplied in the argument list.
       29*
       30*   expmac$many_eis expands a macro consisting of an EIS instruction and takes all its
       31*   operands from its argument list.
       32*
       33*   Initial Version: 10 October, 1968 by BLW
       34*	Modified:  6 April, 1971 by BLW for Version II
       35*	Modified: 26 October 1972 by BLW	
       36*	Modified: 14 February 1973 by RAB
       37*	Modified:	29 May 1973 by RAB for EIS
       38*	Modified:	23 Feb 1976 by RAB to fix 1469
       39*	Modified:	1 Dec 1976 by RAB for -long_profile
       40*	Modified:	6 Mar 1977 by RAB to opt multiply of constants
       41*	Modified:	25 Mar 1977 by RAB to fix 1599
       42*	Modified: 5 May 1977 by SHW for new pl1_operator_names_
       43*	Modified:	15 July 1977 by RAB to fix 1646
       44*	Modified:	6 December 1977 by RAB to fix 1693
       45*	Modified:	15 January 1978 by RAB to fix 1698
       46*	Modified:	8 March 1978 by RAB to fix 1713
       47*	Modified:	11 August 1978 by RAB to change handling of aggregate temp ref counts by expmac$eis and friends
       48*	Modified:	21 August 1978 by RAB to increase obj seg limit from 32K to 128K
       49*	Modified:	25 August 1978 by RAB to help fix 1780
       50*	Modified: 25 April 1979 by PCK to implement 4-bit decimal
       51*	Modified:	18 July 1979 by RAB to fix 1842 (ERR 313 when comparing
       52*		entry vars).  Method of counting down ref counts in put_word
       53*		changed to fix the bug.
       54*	Modified 791029 by PG to make changes so that fix for 1744 does not degrade
       55*		code for abs(floating_expr). Fixes long-outstanding problem with way
       56*		machine_state.indicators is set for instructions that modify both the A and Q.
       57*	Modified 800109 by PG to fix bug 1861 in above change involving pl1_operators_ & handling of indicators.
       58*          Modified 8/19/81 by EBush to keep peepholer from removing what it thinks
       59*                    are no-ops (eppn pn|0) but are really sites for binder relocation. (Bug 2084)
       60**/
       61 
       62 /* format: style3 */
       63 expmac:
       64      proc (macro, arg_pt);
       65 
       66 /* parameters */
       67 
       68 dcl	PR		fixed bin (3);
       69 dcl	macro		fixed bin,		/* id of macro to be expanded */
       70 	arg_pt		ptr;			/* ptr to single arg of macro */
       71 
       72 /* builtins */
       73 
       74 dcl	(abs, addr, addrel, binary, bit, divide, fixed, hbound, lbound, mod, null, ptr, string, substr)
       75 			builtin;
       76 
       77 /* automatic */
       78 
       79 dcl	(arg_blk, p, q, q2, mac_pt, ref_pt, output_pt, sym_use_pt, reloc_pt, text_pt)
       80 			ptr,
       81 	b72		bit (72) aligned,
       82 	(addressable, found, hold_perm_address)
       83 			bit (1) aligned,
       84 	made_perm_addressable
       85 			bit (1) aligned init ("0"b),
       86 	mop		fixed bin (10),
       87 	(s1, s2, n)	fixed bin,
       88 	inst		bit (10) aligned,
       89 	rhs		bit (18) aligned,
       90 	erase		bit (19) aligned,
       91 	not_constant	bit (1),
       92 	eis		bit (1) aligned init ("0"b),
       93 	count_arg		bit (7) aligned,
       94 	constant_value	fixed bin (18),
       95 	(fw, const_string)	bit (36) aligned,
       96 	(i, j, k, num_args, text_pos, first_pos, size, shift_amount, inc, offset)
       97 			fixed bin (18),
       98 	k71		fixed bin (71),
       99 	mac		fixed bin;
      100 
      101 dcl	1 info		aligned like instruction_info_$instruction_info;
      102 
      103 /* entries */
      104 
      105 dcl	cg_error		entry (fixed bin, fixed bin),
      106 	constant_zero	entry (ptr) returns (bit (1)),
      107 	expmac		entry (fixed bin (15), ptr),
      108 	c_a		entry (fixed bin (18), fixed bin (18)) returns (ptr),
      109 	error		entry (fixed bin, ptr, ptr),
      110 	expmac_test	entry (fixed bin, ptr, (4) ptr, (4) bit (1) aligned) returns (bit (1)),
      111 	m_a		entry (ptr, bit (2) aligned),
      112 	expmac$zero	entry (fixed bin (15)),
      113 	(load, adjust_ref_count)
      114 			entry (ptr, fixed bin),
      115 	need_temp		entry (ptr, bit (2) aligned),
      116 	compile_exp	entry (ptr),
      117 	compile_exp$save	entry (ptr) returns (ptr),
      118 	state_man$erase_reg entry (bit (19) aligned),
      119 	base_man$load_var	entry (fixed bin, ptr, fixed bin),
      120 	aq_man$save_aq	entry (ptr, fixed bin),
      121 	power_of_two	entry (fixed bin (18)) returns (fixed bin (18)) reducible;
      122 
      123 /* internal static */
      124 
      125 dcl	max_obj_seg_size	fixed bin (17) int static init (131071) options (constant);
      126 
      127 dcl	(
      128 	ldfx1		init (7),
      129 	stfx1		init (15),
      130 	sta		init (4),
      131 	load_pt		init (60),
      132 	load_ab		init (618),
      133 	load_sb		init (621),
      134 	fx1_to_fx2	init (88),
      135 	quick_desc_mac	init (279),
      136 	get_desc_size	init (284),
      137 	zero_mac		init (308),
      138 	sxl0		init (345),
      139 	sxl7		init (352),
      140 	stx0		init (714),
      141 	stx7		init (721),
      142 	xr18_to_q		init (735),
      143 	xr_to_q		init (583)
      144 	)		fixed bin (15) int static options (constant);
      145 
      146 dcl	add_op		(2) bit (10) int static init ("0001111100"b,
      147 						/* adq */
      148 			"0001111110"b /* adaq */);
      149 
      150 dcl	(
      151 	eapbp		init ("0111010100"b),
      152 	lcq		init ("0110111100"b),
      153 	fld		init ("1000110010"b),
      154 	fst		init ("1001011010"b),
      155 	lda		init ("0100111010"b),
      156 	ldq		init ("0100111100"b),
      157 	adq		init ("0001111100"b),
      158 	sbq		init ("0011111100"b),
      159 	mpy		init ("1000000100"b),
      160 	qls		init ("1110111100"b),
      161 	lrs		init ("1110110110"b),
      162 	lrl		init ("1111110110"b),
      163 	arl		init ("1111110010"b),
      164 	tsp4		init ("1101110000"b),
      165 	tsp2		init ("0101110100"b),
      166 	tsp3		init ("0101110110"b),
      167 	tra		init ("1110010000"b),
      168 	eax0		init ("1100100000"b),
      169 	tsx0		init ("1110000000"b)
      170 	)		bit (10) int static options (constant);
      171 
      172 dcl	(
      173 	lda_dl		init ("010011101000000111"b),
      174 	lda_du		init ("010011101000000011"b),
      175 	mpy_dl		init ("100000010000000111"b)
      176 	)		bit (18) int static options (constant);
      177 
      178 dcl	dl_inst		(0:3) bit (18) aligned int static options (constant) init ("001111110000000111"b,
      179 						/* sbq ,dl */
      180 			"000111110000000111"b,	/* adq ,dl */
      181 			"011011110000000111"b,	/* lcq ,dl */
      182 			"010011110000000111"b);	/* ldq ,dl */
      183 
      184 dcl	(
      185 	sbq_dl		defined (dl_inst (0)),
      186 	adq_dl		defined (dl_inst (1)),
      187 	lcq_dl		defined (dl_inst (2)),
      188 	ldq_dl		defined (dl_inst (3))
      189 	)		bit (18) aligned;
      190 
      191 dcl	(
      192 	eppbp_bp_up_zero	init ("010000000000000000011101010001000000"b),
      193 	epplp_lp_up_zero	init ("100000000000000000011111000001000000"b),
      194 	eppab_ab_up_zero	init ("001000000000000000011101001101000000"b),
      195 	eppbb_bb_up_zero	init ("011000000000000000011101011101000000"b),
      196 	epplb_lb_up_zero	init ("101000000000000000011111001101000000"b),
      197 	eppsb_sb_up_zero	init ("111000000000000000011111011101000000"b),
      198 	eax0_0_al		init ("000000000000000000110010000000000101"b),
      199 	fld_0_dl		init ("000000000000000000100011001000000111"b),
      200 	llr_36		init ("000000000000100100111111111000000000"b),
      201 	ldq_0_dl		init ("000000000000000000010011110000000111"b),
      202 	tpl_3_ic		init ("000000000000000011110000101000000100"b),
      203 	ora_0_dl		init ("000000000000000000010111101000000111"b),
      204 	adq_0_dl		init ("000000000000000000000111110000000111"b),
      205 	sbq_0_dl		init ("000000000000000000001111110000000111"b),
      206 	mpy_1_dl		init ("000000000000000001100000010000000111"b),
      207 	div_1_dl		init ("000000000000000001101000110000000111"b)
      208 	)		bit (36) int static options (constant);
      209 
      210 dcl	(
      211 	als_ins		init ("000000000000000000111011101000000000"b),
      212 	lls_ins		init ("000000000000000000111011111000000000"b),
      213 	anaq_ap		init ("000000000000000000011111111001000000"b)
      214 	)		bit (36) int static;	/* these get set */
      215 
      216 /* external static */
      217 
      218 dcl	(
      219 	cg_stat$text_base,
      220 	cg_stat$text_reloc_base,
      221 	cg_stat$cur_node,
      222 	cg_stat$complex_ac,
      223 	cg_stat$sym_use_base,
      224 	cg_stat$cur_statement
      225 	)		ptr ext,
      226 	(
      227 	pl1_operator_names_$last,
      228 	cg_stat$max_program_size
      229 	)		fixed bin ext,
      230 	cg_stat$used_operator
      231 			bit (900) ext,
      232 	cg_stat$last_macro	fixed bin (15) ext,
      233 	cg_stat$text_pos	fixed bin (18) ext;
      234 
      235 dcl	1 instruction_info_$instruction_info
      236 			(0:1023) aligned ext static,
      237 	  2 changes	unaligned,
      238 	    3 a		unal bit (1),
      239 	    3 q		unal bit (1),
      240 	    3 indicators	unal bit (1),
      241 	    3 b		(1:6) unal bit (1),
      242 	    3 x		(0:7) unal bit (1),
      243 	    3 dr		unal bit (1),
      244 	  2 directable	unal bit (1),
      245 	  2 fixed_pt	unal bit (1),
      246 	  2 float_pt	unal bit (1),
      247 	  2 some_base	unal bit (1),
      248 	  2 pad		unal bit (5),
      249 	  2 num_words	unal fixed bin (7),
      250 	  2 double_ins	unal bit (1);
      251 
      252 dcl	instruction_info_$operators
      253 			aligned ext static;
      254 
      255 dcl	macro_table_$macro_count
      256 			fixed bin ext,
      257 	macro_table_$macro_table
      258 			(1000) bit (72) ext static;
      259 
      260 /* based */
      261 
      262 dcl	1 operator_info	aligned based (addr (instruction_info_$operators)),
      263 	  2 n_entries	fixed bin,
      264 	  2 entry		(1 refer (operator_info.n_entries)),
      265 	    3 first	fixed bin (18) uns unal,
      266 	    3 last	fixed bin (18) uns unal,
      267 	    3 info	aligned like instruction_info_$instruction_info;
      268 
      269 dcl	arg		(num_args) ptr based (p);
      270 
      271 dcl	1 macro_def	aligned based (p),
      272 	  2 rel_ptr	unaligned bit (18),		/* rel ptr to body if size > 0 */
      273 	  2 op_code	unaligned bit (10),		/* op_code if size = 0 */
      274 	  2 size		unaligned bit (8),		/* size of body if multi instructions */
      275 	  2 erase		unaligned bit (15),		/* which registers unaltered */
      276 	  2 no_al		unaligned bit (1),		/* "1"b if no AL modification allowed */
      277 	  2 no_ql		unaligned bit (1),		/* "1"b if no QL modification allowed */
      278 	  2 perm		unaligned bit (1),		/* "1"b if arg1 should be made perm addressable */
      279 	  2 cat		unaligned bit (1),		/* "1"b if target length should be taken from source length */
      280 	  2 length_in_q	unaligned bit (1),		/* "1"b if length for move is in q register */
      281 	  2 compare	unaligned bit (1),		/* "1"b if macro is an EIS comparison */
      282 	  2 xec_eis	unaligned bit (1);		/* "1"b if macro xec's EIS instruction */
      283 
      284 dcl	1 arg_word	aligned based (p),
      285 	  2 dummy		unaligned bit (3),
      286 	  2 number	unaligned bit (3),		/* arg number */
      287 	  2 increment	unaligned bit (12),		/* add this to arg offset */
      288 	  2 ignored	unaligned bit (12),
      289 	  2 modifier	unaligned bit (6);
      290 
      291 dcl	1 instruction	aligned based (p),
      292 	  2 base		unaligned bit (3),
      293 	  2 offset	unaligned bit (15),
      294 	  2 op_code	unaligned bit (10),
      295 	  2 flag		unaligned bit (1),
      296 	  2 ext_base	unaligned bit (1),
      297 	  2 tag		unaligned bit (6);
      298 
      299 dcl	1 ic_instruction	based aligned,
      300 	  2 offset	unaligned bit (18),
      301 	  2 op_code	unaligned bit (10),
      302 	  2 flag		unaligned bit (1),
      303 	  2 ext_base	unaligned bit (1),
      304 	  2 tag		unaligned bit (6);
      305 
      306 dcl	1 forward_ref	based aligned,
      307 	  2 eis_flag	unaligned bit (1),
      308 	  2 offset	unaligned bit (17),
      309 	  2 pad		unaligned bit (18);
      310 
      311 dcl	full_word		bit (36) aligned based;
      312 
      313 dcl	1 reloc		aligned based,
      314 	  2 skip1		unal bit (12),
      315 	  2 left_rel	unal bit (6),
      316 	  2 skip2		unal bit (12),
      317 	  2 right_rel	unal bit (6);
      318 
      319 dcl	1 half_word	aligned based,
      320 	  2 left		unaligned bit (18),
      321 	  2 right		unaligned bit (18);
      322 
      323 dcl	fix_bin		fixed bin based;
      324 
      325 dcl	1 packed_ptr_st	based aligned,
      326 	  2 packedptr	ptr unal;
      327 
      328 /* include files */
      329 
  1     1 /* BEGIN INCLUDE FILE operator_names.incl.pl1 77-5-2 SHW */
  1     2 
  1     3 dcl  op_names_pt ptr;
  1     4 
  1     5 dcl 1 operator_names aligned based (op_names_pt),
  1     6     2 first fixed bin (18),				/* offset of first operator in operator segment */
  1     7     2 last fixed bin (18),				/* offset of last operator in operator segment */
  1     8     2 first_special fixed bin (18),			/* offset of first special operator */
  1     9     2 last_special fixed bin (18),			/* offset of last special operator */
  1    10     2 number_special fixed bin,			/* number of special operators */
  1    11 
  1    12     2 names (1 refer (first) : 1 refer (last)),		/* array of pointers to and lengths of names */
  1    13       3 namep bit (18) unal,				/* rel pointer to ACI string for name */
  1    14       3 len fixed bin (17) unal,			/* length of this operator name */
  1    15 
  1    16     2 special (0 refer (number_special)),		/* array of info about special operators */
  1    17       3 offset fixed bin (18),			/* offset of start of code for this operator */
  1    18       3 namep bit (18) unal,				/* rel pointer to ACI string for name */
  1    19       3 len fixed bin (17) unal;			/* length of this operator name */
  1    20 
  1    21 /* END INCLUDE FILE operator_names.incl.pl1 */
      330 
  2     1 /* BEGIN INCLUDE FILE ... machine_state.incl.pl1 */
  2     2 
  2     3 dcl	cg_static_$m_s_p ptr ext static,
  2     4 	m_s_p ptr init(cg_static_$m_s_p);
  2     5 
  2     6 dcl	1 machine_state	aligned based(m_s_p),
  2     7 	2 node_type	bit(9),
  2     8 	2 indicators	fixed bin,
  2     9 	2 next		ptr unal,
  2    10 	2 a_reg,
  2    11 	  3 variable(10)	ptr unal,
  2    12 	  3 number	fixed bin(17),
  2    13 	  3 size		fixed bin(8),
  2    14 	  3 length	fixed bin(8),
  2    15 	  3 offset	fixed bin(8),
  2    16 	  3 constant	fixed bin(24),
  2    17 	  3 changed	fixed bin(18),
  2    18 	  3 instruction	bit(36),
  2    19 	  3 locked	bit(1) aligned,
  2    20 	  3 number_h_o	fixed bin,
  2    21 	  3 has_offset(3)	ptr unal,
  2    22 	2 q_reg,
  2    23 	  3 variable(10)	ptr unal,
  2    24 	  3 number	fixed bin(17),
  2    25 	  3 size		fixed bin(8),
  2    26 	  3 length	fixed bin(8),
  2    27 	  3 offset	fixed bin(8),
  2    28 	  3 constant	fixed bin(24),
  2    29 	  3 changed	fixed bin(18),
  2    30 	  3 instruction	bit(36),
  2    31 	  3 locked	bit(1) aligned,
  2    32 	  3 number_h_o	fixed bin,
  2    33 	  3 has_offset(3)	ptr unal,
  2    34 	2 string_reg,
  2    35 	  3 variable	ptr unal,
  2    36 	  3 size		fixed bin(8),
  2    37 	  3 offset	fixed bin(8),
  2    38 	2 complex_reg,
  2    39 	  3 variable	ptr unal,
  2    40 	  3 size		fixed bin(8),
  2    41 	  3 scale		fixed bin(8),
  2    42 	2 decimal_reg,
  2    43 	  3 variable	ptr unal,
  2    44 	  3 size		fixed bin(8),
  2    45 	  3 scale		fixed bin(8),
  2    46 	2 index_regs(0:7),
  2    47 	  3 variable	ptr unal,
  2    48 	  3 constant	fixed bin,
  2    49 	  3 type		fixed bin(8),
  2    50 	  3 used		fixed bin(18),
  2    51 	  3 changed	fixed bin(18),
  2    52 	  3 instruction	bit(36),
  2    53 	  3 filler	fixed bin,
  2    54 	2 base_regs(0:7),
  2    55 	  3 variable	ptr unal,
  2    56 	  3 constant	fixed bin,
  2    57 	  3 type		fixed bin(8),
  2    58 	  3 pad (12)	fixed bin,	/* future...room to make 5 element array for variable, constant, type */
  2    59 	  3 number	fixed bin (17),	/* future...number of valid elements in array */
  2    60 	  3 used		fixed bin(18),
  2    61 	  3 changed	fixed bin(18),
  2    62 	  3 instruction	bit(36),
  2    63 	  3 locked	fixed bin(2),
  2    64 	2 indicators_ref(2:3) ptr unal;
  2    65 
  2    66 /* Permissible values for machine_state.indicators. */
  2    67 
  2    68 dcl (	ind_known_refs	init (-2),		/* set by comparison of known, nonzero, references */
  2    69 	ind_invalid	init (-1),
  2    70 	ind_string_aq	init (0),			/* logical value in storage */
  2    71 	ind_logical	init (1),			/* logical value in A or AQ */
  2    72 	ind_arithmetic	init (2),			/* arith value in Q, AQ, or EAQ */
  2    73 	ind_x (0:7)	init (6, 7, 8, 9, 10, 11, 12, 13),
  2    74 	ind_decimal_reg	init (14)
  2    75 	) fixed bin internal static options (constant);
  2    76 
  2    77 /* END INCLUDE FILE ... machine_state.incl.pl1 */
      331 
  3     1 /* BEGIN INCLUDE FILE ... nodes.incl.pl1 */
  3     2 
  3     3 /* Modified: 26 Dec 1979 by PCK to implement by name assignment */
  3     4 
  3     5 dcl (	block_node		initial("000000001"b),
  3     6 	statement_node		initial("000000010"b),
  3     7 	operator_node		initial("000000011"b),
  3     8 	reference_node		initial("000000100"b),
  3     9 	token_node		initial("000000101"b),
  3    10 	symbol_node		initial("000000110"b),
  3    11 	context_node		initial("000000111"b),
  3    12 	array_node		initial("000001000"b),
  3    13 	bound_node		initial("000001001"b),
  3    14 	format_value_node		initial("000001010"b),
  3    15 	list_node			initial("000001011"b),
  3    16 	default_node		initial("000001100"b),
  3    17 	machine_state_node		initial("000001101"b),
  3    18 	source_node		initial("000001110"b),
  3    19 	label_node		initial("000001111"b),
  3    20 	cross_reference_node	initial("000010000"b),
  3    21 	sf_par_node		initial("000010001"b),
  3    22 	temporary_node		initial("000010010"b),
  3    23 	label_array_element_node	initial("000010011"b),
  3    24 	by_name_agg_node		initial("000010100"b))
  3    25 				bit(9) internal static aligned options(constant);
  3    26 
  3    27 dcl	1 node			based aligned,
  3    28 	2 type			unal bit(9),
  3    29 	2 source_id		unal structure,
  3    30 	  3 file_number		bit(8),
  3    31 	  3 line_number		bit(14),
  3    32 	  3 statement_number	bit(5);
  3    33 
  3    34 /* END INCLUDE FILE ... nodes.incl.pl1 */
      332 
  4     1 /* BEGIN INCLUDE FILE ... cg_reference.incl.pl1 */
  4     2 
  4     3 dcl	1 reference		based aligned,
  4     4 	2 node_type		bit(9) unaligned,
  4     5 	2 array_ref		bit(1) unaligned,
  4     6 	2 varying_ref		bit(1) unaligned,
  4     7 	2 shared			bit(1) unaligned,
  4     8 	2 put_data_sw		bit(1) unaligned,
  4     9 	2 processed		bit(1) unaligned,
  4    10 	2 units			fixed(3) unaligned,
  4    11 	2 ref_count		fixed(17) unaligned,
  4    12 	2 c_offset		fixed(24),
  4    13 	2 c_length		fixed(24),
  4    14 	2 symbol			ptr unaligned,
  4    15 	2 qualifier		ptr unaligned,
  4    16 	2 offset			ptr unaligned,
  4    17 	2 length			ptr unaligned,
  4    18 						/* these fields are used by the 645 code generator */
  4    19 	2 c_f_offset		fixed bin(6),
  4    20 	2 address			structure unaligned,
  4    21 	  3 base			bit(3),
  4    22 	  3 offset		bit(15),
  4    23 	  3 op			bit(9),
  4    24 	  3 no_address		bit(1),
  4    25 	  3 inhibit		bit(1),
  4    26 	  3 ext_base		bit(1),
  4    27 	  3 tag			bit(6),
  4    28 	2 info			structure unaligned,
  4    29 	  3 address_in		structure,
  4    30 	    4 b			dimension(0:7) bit(1),
  4    31 	    4 storage		bit(1),
  4    32 	  3 value_in		structure,
  4    33 	    4 a			bit(1),
  4    34 	    4 q			bit(1),
  4    35 	    4 aq			bit(1),
  4    36 	    4 string_aq		bit(1),
  4    37 	    4 complex_aq		bit(1),
  4    38 	    4 decimal_aq		bit(1),
  4    39 	    4 b			dimension(0:7) bit(1),
  4    40 	    4 storage		bit(1),
  4    41 	    4 indicators		bit(1),
  4    42 	    4 x			dimension(0:7) bit(1),
  4    43 	  3 other			structure,
  4    44 	    4 big_offset		bit(1),
  4    45 	    4 big_length		bit(1),
  4    46 	    4 modword_in_offset	bit(1),
  4    47 	2 data_type		fixed(5) unaligned,
  4    48 	2 bits			structure unaligned,
  4    49 	  3 padded_ref		bit(1),
  4    50 	  3 aligned_ref		bit(1),
  4    51 	  3 long_ref		bit(1),
  4    52 	  3 forward_ref		bit(1),
  4    53 	  3 ic_ref		bit(1),
  4    54 	  3 temp_ref		bit(1),
  4    55 	  3 defined_ref		bit(1),
  4    56 	  3 evaluated		bit(1),
  4    57 	  3 allocate		bit(1),
  4    58 	  3 allocated		bit(1),
  4    59 	  3 aliasable		bit(1),
  4    60 	  3 even			bit(1),
  4    61 	  3 perm_address		bit(1),
  4    62 	  3 aggregate		bit(1),
  4    63 	  3 hit_zero		bit(1),
  4    64 	  3 dont_save		bit(1),
  4    65 	  3 fo_in_qual		bit(1),
  4    66 	  3 hard_to_load		bit(1),
  4    67 	2 relocation		bit(12) unaligned,
  4    68 	2 more_bits		structure unaligned,
  4    69 	  3 substr		bit(1),
  4    70 	  3 padded_for_store_ref	bit(1),
  4    71 	  3 aligned_for_store_ref	bit(1),
  4    72 	  3 mbz			bit(15),
  4    73 	2 store_ins		bit(18) unaligned;
  4    74 
  4    75 /* END INCLUDE FILE ... cg_reference.incl.pl1 */
      333 
  5     1 /* BEGIN INCLUDE FILE ... symbol.incl.pl1 */
  5     2 
  5     3 dcl	1 symbol			based aligned,
  5     4 	2 node_type		bit(9) unal,
  5     5 	2 source_id		structure unal,
  5     6 	  3 file_number		bit(8),
  5     7 	  3 line_number		bit(14),
  5     8 	  3 statement_number	bit(5),
  5     9 	2 location		fixed(18) unal unsigned,
  5    10 	2 allocated		bit(1) unal,
  5    11 	2 dcl_type		bit(3) unal,
  5    12 	2 reserved		bit(6) unal,
  5    13 	2 pix			unal,
  5    14 	  3 pic_fixed		bit(1) unal,
  5    15 	  3 pic_float		bit(1) unal,
  5    16 	  3 pic_char		bit(1) unal,
  5    17 	  3 pic_scale		fixed(7) unal,
  5    18 	  3 pic_size		fixed(7) unal,
  5    19 	2 level			fixed(8) unal,
  5    20 	2 boundary		fixed(3) unal,
  5    21 	2 size_units		fixed(3) unal,
  5    22 	2 scale			fixed(7) unal,
  5    23 	2 runtime			bit(18) unal,
  5    24 	2 runtime_offset		bit(18) unal,
  5    25 	2 block_node		ptr unal,
  5    26 	2 token			ptr unal,
  5    27 	2 next			ptr unal,
  5    28 	2 multi_use		ptr unal,
  5    29 	2 cross_references		ptr unal,
  5    30 	2 initial			ptr unal,
  5    31 	2 array			ptr unal,
  5    32 	2 descriptor		ptr unal,
  5    33 	2 equivalence		ptr unal,
  5    34 	2 reference		ptr unal,
  5    35 	2 general			ptr unal,
  5    36 	2 father			ptr unal,
  5    37 	2 brother			ptr unal,
  5    38 	2 son			ptr unal,
  5    39 	2 word_size		ptr unal,
  5    40 	2 bit_size		ptr unal,
  5    41 	2 dcl_size		ptr unal,
  5    42 	2 symtab_size		ptr unal,
  5    43 	2 c_word_size		fixed(24),
  5    44 	2 c_bit_size		fixed(24),
  5    45 	2 c_dcl_size		fixed(24),
  5    46 
  5    47 	2 attributes		structure aligned,
  5    48 	  3 data_type		structure unal,
  5    49 	    4 structure		bit(1) ,
  5    50 	    4 fixed		bit(1),
  5    51 	    4 float		bit(1),
  5    52 	    4 bit			bit(1),
  5    53 	    4 char		bit(1),
  5    54 	    4 ptr			bit(1),
  5    55 	    4 offset		bit(1),
  5    56 	    4 area		bit(1),
  5    57 	    4 label		bit(1),
  5    58 	    4 entry		bit(1),
  5    59 	    4 file		bit(1),
  5    60 	    4 arg_descriptor	bit(1),
  5    61 	    4 storage_block		bit(1),
  5    62 	    4 explicit_packed	bit(1), /* options(packed) */
  5    63 	    4 condition		bit(1),
  5    64 	    4 format		bit(1),
  5    65 	    4 builtin		bit(1),
  5    66 	    4 generic		bit(1),
  5    67 	    4 picture		bit(1),
  5    68 
  5    69 	  3 misc_attributes		structure unal,
  5    70 	    4 dimensioned		bit(1),
  5    71 	    4 initialed		bit(1),
  5    72 	    4 aligned		bit(1),
  5    73 	    4 unaligned		bit(1),
  5    74 	    4 signed		bit(1),
  5    75 	    4 unsigned		bit(1),
  5    76 	    4 precision		bit(1),
  5    77 	    4 varying		bit(1),
  5    78 	    4 local		bit(1),
  5    79 	    4 decimal		bit(1),
  5    80 	    4 binary		bit(1),
  5    81 	    4 real		bit(1),
  5    82 	    4 complex		bit(1),
  5    83 	    4 variable		bit(1),
  5    84 	    4 reducible		bit(1),
  5    85 	    4 irreducible		bit(1),
  5    86 	    4 returns		bit(1),
  5    87 	    4 position		bit(1),
  5    88 	    4 internal		bit(1),
  5    89 	    4 external		bit(1),
  5    90 	    4 like		bit(1),
  5    91 	    4 member		bit(1),
  5    92 	    4 non_varying		bit(1),
  5    93 	    4 options		bit(1),
  5    94 	    4 variable_arg_list 	bit(1),		/* options(variable) */
  5    95 	    4 alloc_in_text		bit(1),		/* options(constant) */
  5    96 
  5    97 	  3 storage_class		structure unal,
  5    98 	    4 auto		bit(1),
  5    99 	    4 based		bit(1),
  5   100 	    4 static		bit(1),
  5   101 	    4 controlled		bit(1),
  5   102 	    4 defined		bit(1),
  5   103 	    4 parameter		bit(1),
  5   104 	    4 param_desc		bit(1),
  5   105 	    4 constant		bit(1),
  5   106 	    4 temporary		bit(1),
  5   107 	    4 return_value		bit(1),
  5   108 
  5   109 	  3 file_attributes		structure unal,
  5   110 	    4 print		bit(1),
  5   111 	    4 input		bit(1),
  5   112 	    4 output		bit(1),
  5   113 	    4 update		bit(1),
  5   114 	    4 stream		bit(1),
  5   115 	    4 reserved_1		bit(1),
  5   116 	    4 record		bit(1),
  5   117 	    4 sequential		bit(1),
  5   118 	    4 direct		bit(1),
  5   119 	    4 interactive		bit(1),		/* env(interactive) */
  5   120 	    4 reserved_2		bit(1),
  5   121 	    4 reserved_3		bit(1),
  5   122 	    4 stringvalue		bit(1),		/* env(stringvalue) */
  5   123 	    4 keyed		bit(1),
  5   124 	    4 reserved_4		bit(1),
  5   125 	    4 environment		bit(1),
  5   126 
  5   127 	  3 compiler_developed	structure unal,
  5   128 	    4 aliasable		bit(1),
  5   129 	    4 packed		bit(1),
  5   130 	    4 passed_as_arg		bit(1),
  5   131 	    4 allocate		bit(1),
  5   132 	    4 set			bit(1),
  5   133 	    4 exp_extents		bit(1),
  5   134 	    4 refer_extents		bit(1),
  5   135 	    4 star_extents		bit(1),
  5   136 	    4 isub		bit(1),
  5   137 	    4 put_in_symtab		bit(1),
  5   138 	    4 contiguous		bit(1),
  5   139 	    4 put_data		bit(1),
  5   140 	    4 overlayed		bit(1),
  5   141 	    4 error		bit(1),
  5   142 	    4 symtab_processed	bit(1),
  5   143 	    4 overlayed_by_builtin	bit(1),
  5   144 	    4 defaulted		bit(1),
  5   145 	    4 connected		bit(1);
  5   146 
  5   147 /* END INCLUDE FILE ... symbol.incl.pl1 */
      334 
  6     1 /* BEGIN INCLUDE FILE ... operator.incl.pl1 */
  6     2 
  6     3 /*	Modified: 2 Apr 1980 by PCK to add max_number_of_operands */
  6     4 
  6     5 /* format: style3 */
  6     6 dcl	1 operator	based aligned,
  6     7 	  2 node_type	bit (9) unaligned,
  6     8 	  2 op_code	bit (9) unaligned,
  6     9 	  2 shared	bit (1) unaligned,
  6    10 	  2 processed	bit (1) unaligned,
  6    11 	  2 optimized	bit (1) unaligned,
  6    12 	  2 number	fixed (14) unaligned,
  6    13 	  2 operand	dimension (n refer (operator.number)) ptr unaligned;
  6    14 
  6    15 dcl	max_number_of_operands
  6    16 			fixed bin (15) int static options (constant) initial (32767);
  6    17 
  6    18 /* END INCLUDE FILE ... operator.incl.pl1 */
      335 
  7     1 dcl (	real_fix_bin_1		init(1),
  7     2 	real_fix_bin_2		init(2),
  7     3 	real_flt_bin_1		init(3),
  7     4 	real_flt_bin_2		init(4),
  7     5 	complex_fix_bin_1		init(5),
  7     6 	complex_fix_bin_2		init(6),
  7     7 	complex_flt_bin_1		init(7),
  7     8 	complex_flt_bin_2		init(8),
  7     9 	real_fix_dec		init(9),
  7    10 	real_flt_dec		init(10),
  7    11 	complex_fix_dec		init(11),
  7    12 	complex_flt_dec		init(12),
  7    13 	char_string		init(13),
  7    14 	bit_string		init(14),
  7    15 	label_constant		init(15),
  7    16 	local_label_variable	init(16),
  7    17 	label_variable		init(17),
  7    18 	entry_variable		init(18),
  7    19 	ext_entry_in		init(19),
  7    20 	ext_entry_out		init(20),
  7    21 	int_entry			init(21),
  7    22 	int_entry_other		init(22),
  7    23 	unpacked_ptr		init(23),
  7    24 	packed_ptr		init(24)) fixed bin(15) int static options(constant);
      336 
  8     1 /* BEGIN INCLUDE FILE ... boundary.incl.pl1 */
  8     2 
  8     3 /* Modified: 26 Apr 1979 by PCK to implement 4-bit decimal */
  8     4 
  8     5 dcl (	bit_		init(1),
  8     6 	digit_		init(2),
  8     7 	character_	init(3),
  8     8 	half_		init(4),
  8     9 	word_		init(5),
  8    10 	mod2_		init(6),
  8    11 	mod4_		init(7)) fixed bin(3) int static options(constant);
  8    12 
  8    13 /* END INCLUDE FILE ... boundary.incl.pl1 */
      337 
  9     1 /* BEGIN INCLUDE FILE ... cgsystem.incl.pl1 */
  9     2 
  9     3 /* Modified: 25 Apr 1979 by PCK to implement 4-bit decimal */
  9     4 
  9     5 dcl (	bits_per_char		init(9),
  9     6 	bits_per_half		init(18),
  9     7 	bits_per_word		init(36),
  9     8 	bits_per_two_words		init(72),
  9     9 	bits_per_four_words		init(144),
  9    10 	bits_per_words(2)		init(36,72),
  9    11 	packed_digits_per_char	init(2),
  9    12 	chars_per_word		init(4),
  9    13 	packed_digits_per_word	init(8),
  9    14 
  9    15 	break_even_bits		init(216),
  9    16 	break_even_words		init(6),
  9    17 
  9    18 	label_size		init(4),
  9    19 
  9    20 	convert_size(13:14)		init(9,1),
  9    21 	max_offset(13:14)		init(27,35),
  9    22 	max_short_size(13:14)	init(8,72),
  9    23 
  9    24 	units_per_word(0:5)		init(1,36,8,4,2,1),
  9    25 
  9    26 	max_dec_scale		init(32),
  9    27 	min_dec_scale		init(-31),
  9    28 	max_p_xreg		init(18),
  9    29 	max_p_fix_bin_1		init(35),
  9    30 	max_p_flt_bin_1		init(27),
  9    31 	max_p_fix_dec		init(59),
  9    32 	max_length_p		init(24),
  9    33 	default_fix_bin_p		init(17)) fixed bin(8) int static options(constant);
  9    34 
  9    35 dcl      (convert_offset(0:5)		init(36,1,4.5,9,18,36),
  9    36 	bits_per_packed_digit	init(4.5)) fixed bin(8,1) int static options(constant);
  9    37 
  9    38 dcl	max_index_register_value	init(262143) fixed bin(31) int static options(constant);
  9    39 
  9    40 /* END INCLUDE FILE ... cgsystem.incl.pl1 */
  9    41 
      338 
 10     1 /* BEGIN INCLUDE FILE relocation_bits.incl.pl1 */
 10     2 
 10     3 /* This include file defines the relocation bits as bit (6) entities.  See
 10     4*   also relbts.incl.pl1 and reloc_lower.incl.pl1. */
 10     5 
 10     6 dcl (	rc_a	initial("000000"b),		/* absolute */
 10     7 	rc_t	initial("010000"b),		/* text */
 10     8 	rc_nt	initial("010001"b),		/* negative text */
 10     9 	rc_lp18	initial("010010"b),		/* linkage, 18 bit */
 10    10 	rc_nlp18	initial("010011"b),		/* negative link, 18 bit */
 10    11 	rc_lp15	initial("010100"b),		/* linkage, 15 bit */
 10    12 	rc_dp	initial("010101"b),		/* def section */
 10    13 	rc_s	initial("010110"b),		/* symbol segment */
 10    14 	rc_ns	initial("010111"b),		/* negative symbol */
 10    15 	rc_is18	initial("011000"b),		/* internal static 18 */
 10    16 	rc_is15	initial("011001"b),		/* internal static 15 */
 10    17 	rc_lb	initial("011000"b),		/* link block */
 10    18 	rc_nlb	initial("011001"b),		/* negative link block */
 10    19 	rc_sr	initial("011010"b),		/* self relative */
 10    20 	rc_e	initial("011111"b))		/* escape */
 10    21 	bit(6) int static options(constant);
 10    22 
 10    23 /* END INCLUDE FILE relocation_bits.incl.pl1 */
      339 
 11     1 dcl	bases(0:7) bit(3) aligned int static init("000"b, "010"b, "100"b,  "001"b, "011"b, "101"b, "111"b,"110"b)
 11     2 	options(constant);
 11     3 
 11     4 dcl (	ap	defined(bases(0)),
 11     5 	bp	defined(bases(1)),
 11     6 	lp	defined(bases(2)),
 11     7 	sp	defined(bases(7))) bit(3) aligned;
 11     8 
 11     9 dcl (	ab	defined(bases(3)),
 11    10 	bb	defined(bases(4)),
 11    11 	lb	defined(bases(5)),
 11    12 	sb	defined(bases(6))) bit(3) aligned;
 11    13 
 11    14 dcl	which_base(0:7) fixed bin int static init(0,3,1,4,2,5,7,6) options(constant);
      340 
      341 
      342 /* program */
      343 
      344 	k = 0;
      345 
      346 	p = arg_pt;
      347 	if p -> reference.temp_ref
      348 	then do;
      349 		if p -> reference.data_type ^= real_fix_bin_1
      350 		then goto set_one;
      351 
      352 		if p -> reference.value_in.storage
      353 		then goto set_one;
      354 		if p -> reference.array_ref
      355 		then goto set_one;
      356 		if p -> reference.aggregate
      357 		then goto set_one;
      358 
      359 		if macro = stfx1
      360 		then goto set_one;
      361 		if macro = zero_mac
      362 		then goto set_one;
      363 		if macro = load_pt
      364 		then goto set_one;
      365 		if macro >= load_ab & macro <= load_sb
      366 		then go to set_one;
      367 		if macro >= sxl0 & macro <= sxl7
      368 		then goto set_one;
      369 		if macro >= stx0 & macro <= stx7
      370 		then goto set_one;
      371 		if macro = quick_desc_mac
      372 		then goto set_one;
      373 		if macro = get_desc_size
      374 		then goto set_one;
      375 
      376 /* have reference to single precision fixed binary temp without
      377*	        value in storage.  if value is in an index register, we'll
      378*	        transfer it to storage or the q register */
      379 
      380 		call save_temp;
      381 		if macro = ldfx1
      382 		then return;
      383 	     end;
      384 
      385 	goto set_one;
      386 
      387 expmac$many:
      388      entry (macro, arg_pt, arg_cnt);
      389 
      390 dcl	arg_cnt		fixed bin;		/* number of arguments */
      391 
      392 	if arg_cnt <= 0
      393 	then return;
      394 	arg_blk = arg_pt;
      395 	num_args = arg_cnt;
      396 
      397 	do i = 1 to num_args;
      398 	     p = arg_blk -> arg (i);
      399 	     if ^p -> reference.perm_address
      400 	     then call m_a (p, "0"b);
      401 	end;
      402 
      403 normal:
      404 	mac = macro;
      405 	goto join;
      406 
      407 expmac$one:
      408      entry (macro, arg_pt, double);
      409 
      410 dcl	double		fixed bin;		/* non-zero if double length operand */
      411 
      412 	k = double;
      413 
      414 set_one:
      415 	num_args = 1;
      416 
      417 	ref_pt = arg_pt;
      418 	if ^ref_pt -> reference.perm_address
      419 	then call m_a (ref_pt, k ^= 0);
      420 
      421 	arg_blk = addr (ref_pt);
      422 
      423 	if k = 0
      424 	then goto normal;
      425 	if ref_pt -> reference.even
      426 	then mac = macro + 2;
      427 	else mac = macro + 1;
      428 
      429 join:
      430 	if mac < 1
      431 	then goto unknown;
      432 
      433 	if mac > macro_table_$macro_count
      434 	then do;
      435 unknown:
      436 		call cg_error (302, mac);
      437 		return;
      438 	     end;
      439 
      440 	cg_stat$last_macro = mac;
      441 
      442 	mac_pt = addr (macro_table_$macro_table (mac));
      443 	if mac_pt -> full_word = "0"b
      444 	then return;
      445 
      446 	do i = 1 to num_args;
      447 	     p = arg_blk -> arg (i);
      448 	     if ^p -> reference.shared
      449 	     then if p -> reference.ref_count = 1
      450 		then call need_temp (p, "11"b);
      451 	end;
      452 
      453 	erase = mac_pt -> macro_def.erase;
      454 
      455 	if erase
      456 	then call state_man$erase_reg (erase);
      457 
      458 	not_constant = "1"b;
      459 	count_arg = (7)"0"b;
      460 
      461 	first_pos, text_pos = cg_stat$text_pos;
      462 
      463 /* check for no AL modification allowed */
      464 
      465 	if mac_pt -> macro_def.no_al
      466 	then do;
      467 		p = arg_blk -> arg (1);
      468 		if substr (p -> address.tag, 3, 4) = "0101"b
      469 						/* al */
      470 		then do;
      471 			substr (p -> address.tag, 3, 4) = "1000"b;
      472 						/* x0 */
      473 			addrel (cg_stat$text_base, text_pos) -> full_word = eax0_0_al;
      474 			text_pos = text_pos + 1;
      475 		     end;
      476 	     end;
      477 
      478 	if mac_pt -> macro_def.perm
      479 	then do;
      480 		made_perm_addressable = "1"b;
      481 		hold_perm_address = arg_blk -> arg (1) -> reference.perm_address;
      482 		arg_blk -> arg (1) -> reference.perm_address = "1"b;
      483 	     end;
      484 
      485 	text_pt, output_pt = addrel (cg_stat$text_base, text_pos);
      486 	reloc_pt = addrel (cg_stat$text_reloc_base, text_pos);
      487 	sym_use_pt = addrel (cg_stat$sym_use_base, text_pos);
      488 
      489 	size = fixed (mac_pt -> macro_def.size, 8);
      490 	if size = 0
      491 	then do;
      492 
      493 /* macro is just an op_code, use of arg_1 is implied */
      494 
      495 		p = arg_blk -> arg (1);
      496 		output_pt -> full_word = string (p -> reference.address);
      497 		output_pt -> instruction.op_code = mac_pt -> macro_def.op_code;
      498 
      499 		q2 = p -> reference.symbol;
      500 		if q2 ^= null
      501 		then sym_use_pt -> packedptr = q2;
      502 
      503 		inst = output_pt -> instruction.op_code;
      504 		mop = fixed (substr (inst, 1, 9), 9) + 512 * fixed (substr (inst, 10, 1), 1);
      505 
      506 		if p -> reference.ic_ref
      507 		then do;
      508 			inc = 0;
      509 			call text_ref;
      510 		     end;
      511 
      512 		reloc_pt -> left_rel = substr (p -> reference.relocation, 1, 6);
      513 		reloc_pt -> right_rel = substr (p -> reference.relocation, 7, 6);
      514 
      515 		if ^p -> reference.shared & ^substr (count_arg, 1, 1)
      516 		then substr (count_arg, 1, 1) = "1"b;
      517 
      518 /* eliminate instructions which are effectively nop's -- if they really are ! */
      519 
      520 		fw = output_pt -> full_word;
      521 
      522 		if reloc_pt -> left_rel = rc_a
      523 		then do;
      524 			if fw = eppbp_bp_up_zero
      525 			then goto done;
      526 			if fw = epplp_lp_up_zero
      527 			then goto done;
      528 			if fw = eppab_ab_up_zero
      529 			then go to done;
      530 			if fw = eppbb_bb_up_zero
      531 			then go to done;
      532 			if fw = epplb_lb_up_zero
      533 			then go to done;
      534 			if fw = eppsb_sb_up_zero
      535 			then go to done;
      536 		     end;
      537 		if fw = ora_0_dl
      538 		then goto done;
      539 		if fw = adq_0_dl
      540 		then goto done;
      541 		if fw = sbq_0_dl
      542 		then goto done;
      543 		if fw = mpy_1_dl
      544 		then if cg_stat$cur_node -> operand (1) -> reference.data_type = real_fix_bin_1
      545 		     then go to done;
      546 		if fw = div_1_dl
      547 		then goto done;
      548 
      549 		rhs = output_pt -> right;
      550 		q = addrel (output_pt, -1);
      551 
      552 /* the following section attempts to remove code from the
      553*	        sequences generated for string assignments and conversion
      554*	        from bit to fixed.  Let N be the shift amount of the LRL,
      555*	        if the preceding instruction is an lda which referecnes
      556*	        a direct constant, the code attempts to shift the constant
      557*	        reference and delete the lrl instruction.
      558*	        if the preceding instruction is
      559*			anaq	ap|2*(72-N)	(72-n)"1"b
      560*	        the anaq instruction is removed.  if the preceding word is
      561*			als	N
      562*	        the two shift instructions are replaced by the instruction
      563*			anaq	ap|144+2*N	(N)"0"b || (72-N)"1"b
      564*	        if the preceding word is
      565*			als	N-36
      566*	        and the instruction before that is an lda, the
      567*	        lda is changed to an ldq, the als and the lrl are
      568*	        replaced by the instruction
      569*			anaq	ap|144+2*N	(N)"0"b || (72-N)"1"b
      570*	        Finally, if the preceding instruction is
      571*			lls	N
      572*	        it and the lrl are replaced by the same anaq as above */
      573 
      574 		if rhs = lrl | rhs = arl
      575 		then do;
      576 			shift_amount = fixed (output_pt -> left, 18);
      577 
      578 			if q -> right = lda_du
      579 			then do;
      580 				const_string = q -> left;
      581 				goto l7;
      582 			     end;
      583 
      584 			if q -> right = lda_dl
      585 			then do;
      586 				const_string = (18)"0"b || q -> left;
      587 
      588 l7:
      589 				b72 = "0"b;
      590 				substr (b72, shift_amount + 1) = const_string;
      591 				if substr (b72, 37, 36)
      592 				then goto l1;
      593 
      594 				if b72 = "0"b & rhs = lrl
      595 				then do;
      596 					q -> full_word = fld_0_dl;
      597 					goto done;
      598 				     end;
      599 
      600 				if substr (b72, 19, 18) = "0"b
      601 				then do;
      602 					q -> left = b72;
      603 					q -> right = lda_du;
      604 					goto done;
      605 				     end;
      606 
      607 				if substr (b72, 1, 18) = "0"b
      608 				then do;
      609 					q -> left = substr (b72, 19, 18);
      610 					q -> right = lda_dl;
      611 					goto done;
      612 				     end;
      613 
      614 				goto l1;
      615 			     end;
      616 
      617 			substr (anaq_ap, 1, 18) = bit (fixed (2 * (72 - shift_amount), 18), 18);
      618 			if q -> full_word = anaq_ap
      619 			then do;
      620 				q -> full_word = fw;
      621 				goto done;
      622 			     end;
      623 
      624 			substr (als_ins, 1, 18) = bit (shift_amount, 18);
      625 			if q -> full_word = als_ins
      626 			then goto ga;
      627 
      628 			if shift_amount < 37
      629 			then goto tls;
      630 			substr (als_ins, 1, 18) = bit (fixed (shift_amount - 36, 18), 18);
      631 			if q -> full_word = als_ins
      632 			then do;
      633 				q2 = addrel (q, -1);
      634 				if q2 -> instruction.op_code ^= lda
      635 				then goto l1;
      636 				q2 -> instruction.op_code = ldq;
      637 				goto ga;
      638 			     end;
      639 
      640 tls:
      641 			substr (lls_ins, 1, 18) = bit (shift_amount, 18);
      642 			if q -> full_word ^= lls_ins
      643 			then goto l1;
      644 ga:
      645 			substr (anaq_ap, 1, 18) = bit (fixed (144 + 2 * shift_amount, 18), 18);
      646 			q -> full_word = anaq_ap;
      647 			goto done;
      648 		     end;
      649 
      650 		if rhs = lrs
      651 		then do;
      652 
      653 /* check for anaq	ap|2*(72-N) */
      654 
      655 			shift_amount = fixed (output_pt -> left, 18);
      656 			substr (anaq_ap, 1, 18) = bit (fixed (2 * (72 - shift_amount), 18), 18);
      657 			if q -> full_word = anaq_ap
      658 			then do;
      659 				q -> full_word = fw;
      660 				go to done;
      661 			     end;
      662 		     end;
      663 
      664 		if rhs = qls
      665 		then do;
      666 			if q -> right ^= qls
      667 			then goto l1;
      668 
      669 /* have two consecutive qls instructions, combine them */
      670 
      671 			q -> left = bit (fixed (fixed (q -> left, 18) + fixed (output_pt -> left, 18), 18), 18);
      672 			goto done;
      673 		     end;
      674 
      675 /* the following section recognizes consecutive adq or sbq
      676*	        instructions and attempts to combine constant terms */
      677 
      678 		if rhs = adq_dl
      679 		then s1 = 1;
      680 		else if rhs = sbq_dl
      681 		then s1 = -1;
      682 		else goto m1;
      683 
      684 		j = 0;
      685 		if q -> right = adq_dl
      686 		then s2 = 1;
      687 		else if q -> right = sbq_dl
      688 		then s2 = -1;
      689 		else do;
      690 
      691 /* if word before ldq has 2 in offset field, it may be
      692*		        part of min | max macro so we'll skip the optimization */
      693 
      694 			if addrel (q, -1) -> left = "000000000000000010"b
      695 			then goto l1;
      696 
      697 			j = 2;
      698 			if q -> right = ldq_dl
      699 			then s2 = 1;
      700 			else if q -> right = lcq_dl
      701 			then s2 = -1;
      702 			else goto l1;
      703 		     end;
      704 
      705 /* if we are in abs sequence, skip the optimization */
      706 
      707 		if addrel (q, -2) -> full_word = tpl_3_ic
      708 		then go to m1;
      709 
      710 		k = s1 * fixed (output_pt -> left, 18) + s2 * fixed (q -> left, 18);
      711 
      712 		if k = 0
      713 		then do;
      714 			if j ^= 0
      715 			then q -> full_word = ldq_0_dl;
      716 			else do;
      717 				output_pt = q;
      718 				reloc_pt = addrel (reloc_pt, -1);
      719 				sym_use_pt = addrel (sym_use_pt, -1);
      720 				text_pos = text_pos - 1;
      721 			     end;
      722 			goto done;
      723 		     end;
      724 
      725 		if abs (k) > 111111111111111111b
      726 		then goto l1;
      727 
      728 		q -> right = dl_inst (j + fixed (k > 0, 1));
      729 
      730 		q -> left = bit (k, 18);
      731 		goto done;
      732 
      733 m1:
      734 		if not_constant
      735 		then goto l1;
      736 
      737 /* the follwing section first tries to optimize multiplications
      738*	        with 2 constant operands, and then tries to replace
      739*	        multipications by a constant power of two by a left shift
      740*	        instruction */
      741 
      742 		if inst = mpy
      743 		then do;
      744 			if cg_stat$cur_node -> operand (1) -> reference.data_type ^= real_fix_bin_1
      745 			then goto l1;
      746 
      747 			if rhs = mpy_dl & (q -> right = ldq_dl | q -> right = lcq_dl)
      748 			     & addrel (q, -1) -> left ^= "000002"b3 & addrel (q, -2) -> full_word ^= tpl_3_ic
      749 			then do;
      750 				k71 = fixed (output_pt -> left, 18) * fixed (q -> left, 18);
      751 
      752 				if k71 <= 111111111111111111b
      753 				then do;
      754 					q -> left = bit (fixed (k71, 18), 18);
      755 					go to done;
      756 				     end;
      757 			     end;
      758 
      759 			constant_value = fixed (const_string, 36);
      760 			k = power_of_two (constant_value);
      761 			if k = 0
      762 			then goto l1;
      763 
      764 			if q -> right = qls
      765 			then do;
      766 				q -> left = bit (fixed (fixed (q -> left, 18) + k, 18), 18);
      767 				goto done;
      768 			     end;
      769 
      770 			output_pt -> full_word = bit (k, 18) || qls;
      771 			goto l1;
      772 		     end;
      773 
      774 l1:
      775 		text_pos = text_pos + 1;
      776 		goto done;
      777 	     end;
      778 
      779 /* have macro of size words, may have arguments used */
      780 
      781 	mac_pt = ptr (mac_pt, mac_pt -> macro_def.rel_ptr);
      782 	addressable = "1"b;
      783 
      784 	do i = 0 to size - 1;
      785 
      786 	     call put_word;
      787 	end;
      788 
      789 done:
      790 	if count_arg
      791 	then do i = 1 to num_args;
      792 		if substr (count_arg, i, 1)
      793 		then call adjust_ref_count (arg_blk -> arg (i), -1);
      794 	     end;
      795 
      796 	if text_pos >= cg_stat$max_program_size
      797 	then call cg_error (311, cg_stat$max_program_size);
      798 
      799 	do i = first_pos to text_pos - 1;
      800 
      801 	     inst = text_pt -> instruction.op_code;
      802 	     mop = binary (substr (inst, 1, 9), 9) + 512 * binary (substr (inst, 10, 1), 1);
      803 	     info = instruction_info_$instruction_info (mop);
      804 	     PR = binary (text_pt -> instruction.base, 3);
      805 
      806 /* See if we have a reference to a pl1_operator_. Note that the following tests are
      807*   carefully arranged in such a way as to make the code execute as quickly as possible.
      808*   Needless to say, the following tests rely on knowledge of how the generated code
      809*   addresses operators. Note that not all references use pr0, so we don't test that. */
      810 
      811 	     if text_pt -> instruction.ext_base & (text_pt -> instruction.tag = ""b)
      812 		& ((inst = tsx0) | (inst = tsp2) | (inst = tra) | (inst = tsp4) | (inst = tsp3))
      813 	     then do;
      814 		     offset = binary (text_pt -> instruction.offset, 15);
      815 
      816 		     if offset <= pl1_operator_names_$last
      817 		     then substr (cg_stat$used_operator, offset, 1) = "1"b;
      818 
      819 		     if (inst = tsx0) | (inst = tsp3)
      820 		     then do;
      821 
      822 /* We have a normal or math operator. See how it affects the registers & indicators.
      823*   A major assumption here is that an operator that modifies the Q or AQ
      824*   also sets the ARITHMETIC indicators for that register. Most of the operators
      825*   do just that. All operators that behave otherwise (i.e. set the LOGICAL
      826*   indicators) must be in the operator_info table in instruction_info. */
      827 
      828 			     do j = lbound (operator_info.entry, 1) to hbound (operator_info.entry, 1)
      829 				while (operator_info.entry (j).last < offset);
      830 			     end;
      831 
      832 			     if j <= hbound (operator_info.entry, 1)
      833 			     then if operator_info.entry (j).first <= offset
      834 				then found = "1"b;
      835 				else found = "0"b;
      836 			     else found = "0"b;
      837 
      838 			     if found
      839 			     then info = operator_info.entry (j).info;
      840 			     else do;
      841 				     string (info.changes) = substr (erase, 1, 2);
      842 						/* A, Q */
      843 				     info.changes.indicators = "1"b;
      844 				     info.fixed_pt = "1"b;
      845 						/* one of these must be true... */
      846 				     info.float_pt = "1"b;
      847 						/* ...all exceptions are in table */
      848 
      849 				     if substr (erase, 14, 1)
      850 				     then info.changes.b (1) = "1"b;
      851 				end;
      852 			end;
      853 		     else if inst = tsp4
      854 		     then string (info.changes) = "111111111"b;
      855 
      856 		end;
      857 
      858 	     if eis & xec_eis
      859 	     then string (info.changes) = "001"b;
      860 
      861 /* The following statement should set the indicators to -1 (invalid), but we can't
      862*   do so until all of the places that depend on the incorrect value have been
      863*   fixed to set it to 0 themselves. Anybody that issues sztl-type instructions
      864*   (for example) is affected. */
      865 
      866 	     if info.changes.indicators
      867 	     then machine_state.indicators = 0;
      868 
      869 	     if info.changes.q
      870 	     then do;
      871 		     q_reg.changed = i;
      872 		     q_reg.instruction = text_pt -> full_word;
      873 		end;
      874 
      875 	     if info.changes.a
      876 	     then do;
      877 		     a_reg.changed = i;
      878 		     a_reg.instruction = text_pt -> full_word;
      879 		end;
      880 
      881 	     if (info.fixed_pt | info.float_pt) & info.changes.q
      882 	     then machine_state.indicators = ind_arithmetic;
      883 	     else if info.changes.indicators & info.changes.a
      884 	     then machine_state.indicators = ind_logical;
      885 
      886 	     if info.some_base
      887 	     then call change_base_ (i, which_base (PR));
      888 
      889 	     else do PR = lbound (info.changes.b, 1) to hbound (info.changes.b, 1);
      890 		     if info.changes.b (PR)
      891 		     then call change_base_ (i, (PR));
      892 		end;
      893 
      894 
      895 	     do j = 0 to 7;
      896 		if info.changes.x (j)
      897 		then do;
      898 			index_regs (j).changed = i;
      899 			index_regs (j).instruction = text_pt -> full_word;
      900 			machine_state.indicators = ind_x (j);
      901 		     end;
      902 	     end;
      903 
      904 	     if info.changes.dr
      905 	     then machine_state.indicators = ind_decimal_reg;
      906 
      907 	     text_pt = addrel (text_pt, 1);
      908 
      909 /* Next sequence skips over EIS descriptors if they exist */
      910 
      911 	     nwords = info.num_words - 1;
      912 	     if eis
      913 	     then if xec_eis
      914 		then nwords = 2;
      915 
      916 	     if nwords > 0
      917 	     then do;
      918 
      919 /* eis instruction */
      920 
      921 		     if ^compare
      922 		     then if machine_state.indicators = ind_known_refs
      923 			then do;
      924 
      925 /* we have set a value without setting the indicators,
      926*		        remove it from the indicators */
      927 
      928 				p = arg_blk -> arg (1);
      929 				if p = indicators_ref (2)
      930 				then machine_state.indicators = ind_invalid;
      931 				else if p = indicators_ref (3)
      932 				then machine_state.indicators = ind_invalid;
      933 			     end;
      934 
      935 		     i = i + nwords;
      936 		     text_pt = addrel (text_pt, nwords);
      937 		end;
      938 
      939 	end;
      940 
      941 	cg_stat$text_pos = text_pos;
      942 
      943 	if made_perm_addressable
      944 	then arg_blk -> arg (1) -> reference.perm_address = hold_perm_address;
      945 
      946 	return;
      947 
      948 expmac$zero:
      949      entry (macro);
      950 
      951 	cg_stat$last_macro, mac = macro;
      952 
      953 	if mac < 1
      954 	then goto unknown;
      955 	if mac > macro_table_$macro_count
      956 	then goto unknown;
      957 
      958 	num_args = 0;
      959 	count_arg = (7)"0"b;
      960 
      961 	mac_pt = addr (macro_table_$macro_table (mac));
      962 
      963 	if mac_pt -> full_word = "0"b
      964 	then return;
      965 
      966 	erase = mac_pt -> macro_def.erase;
      967 
      968 	if erase
      969 	then call state_man$erase_reg (erase);
      970 
      971 	size = fixed (mac_pt -> macro_def.size, 8);
      972 
      973 	first_pos, text_pos = cg_stat$text_pos;
      974 	text_pt, output_pt = addrel (cg_stat$text_base, text_pos);
      975 	reloc_pt = addrel (cg_stat$text_reloc_base, text_pos);
      976 
      977 /* there must be a macro body if there are no args */
      978 
      979 	if size = 0
      980 	then do;
      981 		call cg_error (304, mac);
      982 		return;
      983 	     end;
      984 
      985 	mac_pt = ptr (mac_pt, mac_pt -> macro_def.rel_ptr);
      986 	do i = 0 to size - 1;
      987 	     output_pt -> full_word = mac_pt -> full_word;
      988 	     reloc_pt -> full_word = "0"b;
      989 
      990 /* convert the sequence
      991*			ldq	x
      992*			llr	36
      993*	        into the instruction
      994*			lda	x	*/
      995 
      996 /* We cannot do the optimization if the
      997*	        q register could have been loaded via
      998*	        more than 1 path (min or max bifs)*/
      999 
     1000 	     if output_pt -> full_word = llr_36
     1001 	     then if machine_state.indicators = ind_arithmetic
     1002 		then do;
     1003 			q = addrel (output_pt, -1);
     1004 			if q -> instruction.op_code = ldq
     1005 			then do;
     1006 				q -> instruction.op_code = lda;
     1007 				goto l4;
     1008 			     end;
     1009 		     end;
     1010 
     1011 
     1012 	     output_pt = addrel (output_pt, 1);
     1013 	     reloc_pt = addrel (reloc_pt, 1);
     1014 	     text_pos = text_pos + 1;
     1015 
     1016 l4:
     1017 	     mac_pt = addrel (mac_pt, 1);
     1018 	end;
     1019 
     1020 	goto done;
     1021 
     1022 expmac$abs:
     1023      entry (blk_pt, blk_cnt);
     1024 
     1025 dcl	blk_pt		ptr,			/* points at block to be appended */
     1026 	blk_cnt		fixed bin;		/* number of words in block */
     1027 
     1028 dcl	blk		(blk_cnt) fixed bin based;
     1029 
     1030 	if blk_cnt <= 0
     1031 	then return;
     1032 
     1033 	cg_stat$last_macro = 0;
     1034 
     1035 /* we use the fact that the relocation segment will be
     1036*	   filled with zeros as its length grows */
     1037 
     1038 	addrel (cg_stat$text_base, cg_stat$text_pos) -> blk = blk_pt -> blk;
     1039 
     1040 	cg_stat$text_pos = cg_stat$text_pos + blk_cnt;
     1041 	if cg_stat$text_pos >= cg_stat$max_program_size
     1042 	then call cg_error (311, cg_stat$max_program_size);
     1043 
     1044 	return;
     1045 
     1046 expmac$interpret:
     1047      entry (macro_start, node_pt, refs, atom);
     1048 
     1049 /* This entry is called to interpret the macro sequence
     1050*	   starting at "macro_start" */
     1051 
     1052 dcl	macro_start	fixed bin,		/* start of sequence */
     1053 	node_pt		ptr,			/* points at operator node */
     1054 	refs		(4) ptr,			/* ref nodes for operands */
     1055 	atom		(4) bit (1) aligned;	/* ON if operand is atomic */
     1056 
     1057 dcl	(b1, b2, b3)	bit (1),
     1058 	(depth, code)	fixed bin,
     1059 	ref		(4) ptr defined (refs),
     1060 	(
     1061 	stack		(10),
     1062 	rand		(4)
     1063 	)		ptr;
     1064 
     1065 dcl	1 special_word	aligned based,
     1066 	  2 part1		unal bit (18),
     1067 	  2 op		unal bit (9),
     1068 	  2 skip		unal bit (3),
     1069 	  2 part2		unal bit (6);
     1070 
     1071 dcl	special_erase	bit (15) aligned based;
     1072 
     1073 dcl	sp_erase		bit (19) aligned;
     1074 
     1075 	mac_pt = addr (macro_start);
     1076 	goto init;
     1077 
     1078 expmac$conditional:
     1079      entry (macro, node_pt, refs, atom);
     1080 
     1081 	mac_pt = addr (macro_table_$macro_table (macro));
     1082 
     1083 	erase = mac_pt -> macro_def.erase;
     1084 
     1085 	if erase
     1086 	then call state_man$erase_reg (erase);
     1087 
     1088 	mac_pt = ptr (mac_pt, mac_pt -> macro_def.rel_ptr);
     1089 
     1090 /* initialize */
     1091 
     1092 init:
     1093 	first_pos, text_pos = cg_stat$text_pos;
     1094 	text_pt, output_pt = addrel (cg_stat$text_base, text_pos);
     1095 	reloc_pt = addrel (cg_stat$text_reloc_base, text_pos);
     1096 	sym_use_pt = addrel (cg_stat$sym_use_base, text_pos);
     1097 
     1098 	num_args = node_pt -> operator.number;
     1099 
     1100 	rand (2) = node_pt -> operand (2);
     1101 	rand (3) = node_pt -> operand (3);
     1102 	if num_args >= 4
     1103 	then rand (4) = node_pt -> operand (4);
     1104 
     1105 	code = fixed (atom (2) || atom (3), 2);
     1106 
     1107 	arg_blk = addr (refs);
     1108 	addressable = "0"b;
     1109 	count_arg = (7)"0"b;
     1110 
     1111 	depth = 0;
     1112 
     1113 /* if bit 28 of word from macro table is off, this is ordinary instruction */
     1114 
     1115 loop:
     1116 	if ^mac_pt -> instruction.flag
     1117 	then do;
     1118 		call put_word;
     1119 		goto loop;
     1120 	     end;
     1121 
     1122 /* have special control word */
     1123 
     1124 	mop = fixed (mac_pt -> special_word.op, 9);
     1125 	s2 = fixed (mac_pt -> special_word.part2, 9);
     1126 	s1 = fixed (mac_pt -> special_word.part1, 18);
     1127 	k = fixed (mac_pt -> arg_word.number, 3);
     1128 	if k > 0
     1129 	then if k <= num_args
     1130 	     then p = ref (k);
     1131 	goto sw (mop);
     1132 
     1133 /* end of macro sequence */
     1134 
     1135 sw (0):
     1136 	if depth = 0
     1137 	then goto done;
     1138 
     1139 	mac_pt = stack (depth);
     1140 	depth = depth - 1;
     1141 	goto next;
     1142 
     1143 /* IF operator */
     1144 
     1145 sw (1):
     1146 	b2 = "1"b;
     1147 	goto test;
     1148 
     1149 /* IFNOT operator */
     1150 
     1151 sw (2):
     1152 	b2 = "0"b;
     1153 
     1154 test:
     1155 	if s2 = 1
     1156 	then b1 = ref (2) -> reference.value_in.q;
     1157 	else if s2 = 2
     1158 	then b1 = ref (3) -> reference.value_in.q;
     1159 	else if s2 = 3
     1160 	then b1 = ref (2) -> reference.value_in.a;
     1161 	else if s2 = 4
     1162 	then b1 = ref (3) -> reference.value_in.a;
     1163 	else if s2 = 5
     1164 	then b1 = ref (2) -> reference.value_in.complex_aq;
     1165 	else if s2 = 6
     1166 	then b1 = ref (3) -> reference.value_in.complex_aq;
     1167 	else if s2 = 7
     1168 	then b1 = constant_zero (ref (2));
     1169 	else if s2 = 8
     1170 	then b1 = constant_zero (ref (3));
     1171 	else if s2 = 9
     1172 	then b1 = atom (2);
     1173 	else if s2 = 10
     1174 	then b1 = atom (3);
     1175 	else if s2 = 11
     1176 	then b1 = atom (4);
     1177 	else b1 = expmac_test (s2, node_pt, refs, atom);
     1178 
     1179 	if b1 = b2
     1180 	then do;
     1181 
     1182 /* test succeeded */
     1183 
     1184 next:
     1185 		mac_pt = addrel (mac_pt, 1);
     1186 		goto loop;
     1187 	     end;
     1188 
     1189 /* test failed */
     1190 
     1191 	goto sw (4);
     1192 
     1193 /* FLIPTO operator */
     1194 
     1195 sw (3):
     1196 	q = ref (2);
     1197 	ref (2) = ref (3);
     1198 	ref (3) = q;
     1199 
     1200 	q = rand (2);
     1201 	rand (2) = rand (3);
     1202 	rand (3) = q;
     1203 
     1204 	b1 = atom (2);
     1205 	atom (2) = atom (3);
     1206 	atom (3) = b1;
     1207 
     1208 	code = fixed (atom (2) || atom (3), 2);
     1209 
     1210 /* JUMP operator */
     1211 
     1212 sw (4):
     1213 	if s1 = 0
     1214 	then goto done;
     1215 	mac_pt = ptr (mac_pt, s1);
     1216 	goto loop;
     1217 
     1218 /* PUT operator */
     1219 
     1220 sw (5):
     1221 	depth = depth + 1;
     1222 	stack (depth) = mac_pt;
     1223 	goto sw (4);
     1224 
     1225 /* FETCH operator */
     1226 
     1227 sw (6):
     1228 	b2 = "0"b;
     1229 
     1230 f1:
     1231 	b1 = atom (k);
     1232 	b3 = "0"b;
     1233 
     1234 f2:
     1235 	cg_stat$text_pos = text_pos;
     1236 
     1237 	if b1
     1238 	then call load (ref (k), 0);
     1239 	else call compile_exp (rand (k));
     1240 
     1241 	if b2 & ref (k) -> reference.data_type ^= real_fix_bin_2
     1242 	then call expmac$zero ((fx1_to_fx2));
     1243 
     1244 	if b3
     1245 	then if ref (k) -> reference.value_in.complex_aq
     1246 	     then do;
     1247 		     q = ref (k);
     1248 		     string (q -> reference.address) = string (cg_stat$complex_ac -> reference.address);
     1249 		     q -> reference.relocation = cg_stat$complex_ac -> reference.relocation;
     1250 		     q -> reference.perm_address = "1"b;
     1251 		end;
     1252 	     else ref (k) = rand (k) -> operand (1);
     1253 
     1254 f3:
     1255 	text_pos = cg_stat$text_pos;
     1256 	output_pt = addrel (cg_stat$text_base, text_pos);
     1257 	reloc_pt = addrel (cg_stat$text_reloc_base, text_pos);
     1258 	sym_use_pt = addrel (cg_stat$sym_use_base, text_pos);
     1259 	goto next;
     1260 
     1261 /* GET_FX2 operator */
     1262 
     1263 sw (7):
     1264 	b2 = "1"b;
     1265 	goto f1;
     1266 
     1267 /* COMPILE operator */
     1268 
     1269 sw (8):
     1270 	b1, b2, b3 = "0"b;
     1271 	goto f2;
     1272 
     1273 /* CPLALT operator */
     1274 
     1275 sw (9):
     1276 	b3 = "1"b;
     1277 	b1, b2 = "0"b;
     1278 	goto f2;
     1279 
     1280 /* CPLSAVE operator */
     1281 
     1282 sw (10):
     1283 	cg_stat$text_pos = text_pos;
     1284 
     1285 	ref (k) = compile_exp$save (rand (k));
     1286 
     1287 	goto f3;
     1288 
     1289 /* LOAD operator */
     1290 
     1291 sw (11):
     1292 	b1 = "1"b;
     1293 	b2, b3 = "0"b;
     1294 	goto f2;
     1295 
     1296 /* ADD operator */
     1297 
     1298 sw (12):
     1299 	if p -> reference.no_address
     1300 	then call call_ma;
     1301 
     1302 	output_pt -> full_word = string (p -> reference.address);
     1303 	output_pt -> instruction.op_code = add_op (p -> reference.data_type);
     1304 
     1305 	q2 = p -> reference.symbol;
     1306 	if q2 ^= null
     1307 	then sym_use_pt -> packedptr = q2;
     1308 
     1309 	reloc_pt -> left_rel = substr (p -> reference.relocation, 1, 6);
     1310 	reloc_pt -> right_rel = substr (p -> reference.relocation, 7, 6);
     1311 
     1312 	output_pt = addrel (output_pt, 1);
     1313 	reloc_pt = addrel (reloc_pt, 1);
     1314 	sym_use_pt = addrel (sym_use_pt, 1);
     1315 	text_pos = text_pos + 1;
     1316 	goto next;
     1317 
     1318 /* SWITCH operator */
     1319 
     1320 sw (13):
     1321 	if s2 = 1
     1322 	then n = code;
     1323 	else if s2 = 2
     1324 	then n = fixed (node_pt -> operator.op_code, 9);
     1325 	else if s2 = 3
     1326 	then n = ref (1) -> reference.data_type;
     1327 	else if s2 = 4
     1328 	then n = ref (2) -> reference.data_type;
     1329 	else if s2 = 5
     1330 	then n = ref (3) -> reference.data_type;
     1331 
     1332 	mac_pt = addrel (mac_pt, n - s1 + 1);
     1333 	goto loop;
     1334 
     1335 /* ERASE operator */
     1336 
     1337 sw (14):
     1338 	cg_stat$text_pos = text_pos;
     1339 
     1340 	sp_erase = mac_pt -> special_erase;
     1341 	call state_man$erase_reg (sp_erase);
     1342 	goto f3;
     1343 
     1344 /* BUMP operator */
     1345 
     1346 sw (15):
     1347 	if ^p -> reference.shared
     1348 	then p -> reference.ref_count = p -> reference.ref_count + 1;
     1349 
     1350 	goto next;
     1351 
     1352 /* DROP operator */
     1353 
     1354 sw (16):
     1355 	if ^p -> reference.shared
     1356 	then call adjust_ref_count (p, -1);
     1357 
     1358 	goto next;
     1359 
     1360 expmac$fill_usage:
     1361      entry (val, last_use);
     1362 
     1363 dcl	(val, last_use, use, prev_use)
     1364 			fixed bin (17);
     1365 
     1366 	use = last_use;
     1367 	do while (use ^= 0);
     1368 	     output_pt = addrel (cg_stat$text_base, use);
     1369 	     prev_use = fixed (output_pt -> forward_ref.offset, 17);
     1370 
     1371 	     if output_pt -> forward_ref.eis_flag
     1372 	     then do;
     1373 		     output_pt -> forward_ref.eis_flag = "0"b;
     1374 		     use = use - output_pt -> descriptor.char;
     1375 		     output_pt -> descriptor.char = 0;
     1376 		end;
     1377 
     1378 	     call set_offset (val - use);
     1379 	     use = prev_use;
     1380 	end;
     1381 
     1382 	return;
     1383 
     1384 
     1385 
     1386 
     1387 /* Macro expander for EIS instructions */
     1388 
     1389 expmac$eis:
     1390      entry (macro, arg_pt);
     1391 
     1392 dcl	lreg		(3) bit (1) aligned;	/* "1"b if length is in a register */
     1393 dcl	len		(3) bit (4) aligned;	/* register containing length */
     1394 dcl	count		(3) bit (1) aligned;	/* "1"b if reference count is to be decremented */
     1395 
     1396 dcl	cat		bit (1) aligned;		/* "1"b if target length should be taken from source length */
     1397 dcl	length_in_q	bit (1) aligned;		/* "1"b if length for move is in q register */
     1398 dcl	compare		bit (1) aligned;		/* "1"b if macro is an EIS comparison */
     1399 dcl	xec_eis		bit (1) aligned;		/* "1"b if macro xec's an EIS instruction */
     1400 dcl	(nwords, type)	fixed bin;
     1401 dcl	ichar		fixed bin (3);
     1402 dcl	ibit		fixed bin (4);
     1403 dcl	scale		fixed bin (6);
     1404 dcl	ptarray		(2) ptr;
     1405 
     1406 dcl	mf		(3) fixed bin (6) int static init (30, 12, 3);
     1407 						/* location of modification factor */
     1408 
     1409 dcl	cg_stat$eis_temp	ptr ext;
     1410 
     1411 dcl	1 descriptor	based aligned,		/* layout of operand descr */
     1412 	  2 word_address	bit (18) unal,
     1413 	  2 char		fixed bin (2) uns unal,
     1414 	  2 bit		fixed bin (4) uns unal,
     1415 	  2 length	bit (12) unal;
     1416 
     1417 dcl	1 four_bit_descriptor
     1418 			based aligned,		/* EIS 4-bit operand descriptor */
     1419 	  2 word_address	bit (18) unal,
     1420 	  2 char		fixed bin (3) uns unal,
     1421 	  2 bit		fixed bin (3) uns unal,
     1422 	  2 length	bit (12) unal;
     1423 
     1424 
     1425 dcl	1 mod_factor	aligned,			/* layout of modification_factor field */
     1426 	  2 ext_base	bit (1) unal,
     1427 	  2 tag		unal,
     1428 	    3 length_in_reg bit (1),
     1429 	    3 indirect_descriptor
     1430 			bit (1),
     1431 	    3 offset_reg	bit (4);
     1432 
     1433 dcl	copy_temp		entry (ptr) returns (ptr);
     1434 dcl	make_n_addressable	entry (ptr, fixed bin);
     1435 dcl	load_size$xr_or_aq	entry (ptr, bit (4) aligned);
     1436 dcl	state_man$unlock	entry ();
     1437 dcl	aq_man$lock	entry (ptr, fixed bin);
     1438 
     1439 	num_args = 2;
     1440 	ptarray (1) = cg_stat$eis_temp;
     1441 	ptarray (2) = arg_pt;
     1442 	arg_blk = addr (ptarray);
     1443 	go to join_eis;
     1444 
     1445 expmac$one_eis:
     1446      entry (macro, arg_pt);
     1447 
     1448 	num_args = 1;
     1449 	arg_blk = addr (arg_pt);
     1450 	go to join_eis;
     1451 
     1452 expmac$two_eis:
     1453      entry (macro, arg_pt, arg_pt2);
     1454 
     1455 dcl	arg_pt2		ptr;
     1456 
     1457 	num_args = 2;
     1458 	ptarray (1) = arg_pt;
     1459 	ptarray (2) = arg_pt2;
     1460 	arg_blk = addr (ptarray);
     1461 	go to join_eis;
     1462 
     1463 expmac$many_eis:
     1464      entry (macro, arg_pt, arg_cnt);
     1465 
     1466 	if arg_cnt <= 0
     1467 	then return;
     1468 	arg_blk = arg_pt;
     1469 	num_args = arg_cnt;
     1470 
     1471 join_eis:
     1472 	eis = "1"b;
     1473 	count_arg = (7)"0"b;
     1474 
     1475 /* Check for short string temporaries not in storage.  If found, then store
     1476*   from aq */
     1477 
     1478 	do i = 1 to num_args;
     1479 	     p = arg_blk -> arg (i);
     1480 	     if p -> reference.temp_ref
     1481 	     then if ^p -> reference.value_in.storage & ^p -> reference.array_ref & ^p -> reference.aggregate
     1482 		then if p -> reference.data_type >= char_string
     1483 		     then if ^p -> reference.long_ref & ^p -> reference.varying_ref
     1484 			then if p -> reference.value_in.a
     1485 			     then do;
     1486 				     if p -> reference.shared
     1487 				     then p, arg_blk -> arg (i) = copy_temp (p);
     1488 				     p -> reference.ref_count = p -> reference.ref_count + 1;
     1489 				     p -> reference.value_in.storage = "1"b;
     1490 				     p -> reference.store_ins = bit (cg_stat$text_pos, 18);
     1491 				     size = p -> reference.c_length * convert_size (p -> reference.data_type);
     1492 
     1493 				     call expmac$one ((sta), p, fixed (size > bits_per_word, 1));
     1494 				end;
     1495 			     else call error315;
     1496 			else ;
     1497 		     else if p -> reference.data_type > 0
     1498 		     then if p -> reference.data_type <= real_fix_bin_2
     1499 			then if p -> reference.value_in.q
     1500 			     then call aq_man$save_aq (p, 0);
     1501 			     else call save_temp;
     1502 	end;
     1503 
     1504 /* Initialize */
     1505 
     1506 	mac = macro;
     1507 
     1508 	if macro <= 0
     1509 	then go to unknown;
     1510 	if macro > macro_table_$macro_count
     1511 	then go to unknown;
     1512 
     1513 	mac_pt = addr (macro_table_$macro_table (mac));
     1514 	if mac_pt -> full_word = "0"b
     1515 	then return;
     1516 
     1517 	cat = mac_pt -> macro_def.cat;
     1518 	length_in_q = mac_pt -> macro_def.length_in_q;
     1519 	compare = mac_pt -> macro_def.compare;
     1520 	xec_eis = mac_pt -> macro_def.xec_eis;
     1521 	if xec_eis
     1522 	then n = -num_args;
     1523 	else n = num_args;
     1524 	if length_in_q
     1525 	then call aq_man$lock (null, 2);
     1526 
     1527 /* Make all rands addressable */
     1528 
     1529 	call make_n_addressable (arg_blk, n);
     1530 
     1531 /* Get lengths for all the rands and determine whose reference counts are
     1532*  to be decremented */
     1533 
     1534 	do i = 1 to num_args;
     1535 	     p = arg_blk -> arg (i);
     1536 
     1537 	     if length_in_q
     1538 	     then do;
     1539 		     lreg (i) = "1"b;
     1540 		     len (i) = "0110"b;		/* q */
     1541 		end;
     1542 	     else if cat & i = 1
     1543 	     then ;
     1544 	     else do;
     1545 		     lreg (i) =
     1546 			p -> reference.length ^= null | p -> reference.c_length > 4095
     1547 			| (p -> reference.varying_ref & p -> reference.c_length = 0) | xec_eis;
     1548 		     if lreg (i)
     1549 		     then call load_size$xr_or_aq (p, len (i));
     1550 		end;
     1551 	     count (i) =
     1552 		^(p -> reference.shared | (i = 1 & p -> reference.temp_ref & ^p -> reference.aggregate & ^compare));
     1553 	     if count (i)
     1554 	     then if p -> reference.ref_count = 1
     1555 		then call need_temp (p, "01"b);
     1556 	end;
     1557 
     1558 	if cat
     1559 	then do;
     1560 		lreg (1) = lreg (2);
     1561 		len (1) = len (2);
     1562 	     end;
     1563 
     1564 	erase = mac_pt -> macro_def.erase;
     1565 	if erase
     1566 	then call state_man$erase_reg (erase);
     1567 
     1568 	cg_stat$last_macro = mac;
     1569 
     1570 	text_pos, first_pos = cg_stat$text_pos;
     1571 	text_pt, output_pt = addrel (cg_stat$text_base, text_pos);
     1572 	reloc_pt = addrel (cg_stat$text_reloc_base, text_pos);
     1573 	sym_use_pt = addrel (cg_stat$sym_use_base, text_pos);
     1574 
     1575 	size = fixed (mac_pt -> macro_def.size, 8);
     1576 
     1577 	mac_pt = ptr (mac_pt, mac_pt -> macro_def.rel_ptr);
     1578 
     1579 /* Start filling in the text */
     1580 
     1581 	output_pt -> full_word = mac_pt -> full_word;
     1582 	reloc_pt -> full_word = "0"b;
     1583 
     1584 	inc = 0;
     1585 	inst = output_pt -> instruction.op_code;
     1586 
     1587 	if ^xec_eis
     1588 	then do;
     1589 		mop = fixed (substr (inst, 1, 9), 9) + 512 * fixed (substr (inst, 10, 1), 1);
     1590 		nwords = instruction_info_$instruction_info (mop).num_words;
     1591 	     end;
     1592 	else nwords = 3;
     1593 
     1594 /* Loop to fill in the operand descriptors */
     1595 
     1596 	do i = 1 to nwords - 1;
     1597 
     1598 	     output_pt = addrel (output_pt, 1);
     1599 	     reloc_pt = addrel (reloc_pt, 1);
     1600 	     sym_use_pt = addrel (sym_use_pt, 1);
     1601 
     1602 	     mac_pt = addrel (mac_pt, 1);
     1603 
     1604 	     k = fixed (mac_pt -> arg_word.number, 3);
     1605 	     if mac_pt -> instruction.base
     1606 	     then k = 0;
     1607 
     1608 /* Check for use of argument */
     1609 
     1610 	     if k ^= 0
     1611 	     then do;
     1612 
     1613 		     if k <= num_args
     1614 		     then p = arg_blk -> arg (k);
     1615 		     else do;
     1616 			     call cg_error (303, macro);
     1617 			     go to step;
     1618 			end;
     1619 
     1620 		     q2 = p -> reference.symbol;
     1621 		     if q2 ^= null
     1622 		     then sym_use_pt -> packedptr = q2;
     1623 
     1624 		     output_pt -> full_word = string (p -> reference.address);
     1625 		     type = mac_pt -> descriptor.bit;
     1626 
     1627 /* See if we must build a descriptor */
     1628 
     1629 /* Meanings of values of type (operand types of macros in macro_table.table) */
     1630 /* 0 = address	   */
     1631 /* 1 = decimal	   */
     1632 /* 2 = 8-bit character */
     1633 /* 3 = bit	   */
     1634 /* 4 = 4-bit character */
     1635 
     1636 		     if type > 0
     1637 		     then do;
     1638 			     string (mod_factor) = substr (string (p -> reference.address), 30, 7);
     1639 			     mod_factor.length_in_reg = lreg (k);
     1640 
     1641 			     if lreg (k)
     1642 			     then output_pt -> descriptor.length = "00000000"b || len (k);
     1643 			     else do;
     1644 				     q = p;
     1645 				     if cat
     1646 				     then if k = 1
     1647 					then q = arg_blk -> arg (2);
     1648 				     if mac_pt -> descriptor.length = (12)"0"b
     1649 				     then output_pt -> descriptor.length =
     1650 					     bit (fixed (q -> reference.c_length, 12), 12);
     1651 				     else output_pt -> descriptor.length = mac_pt -> descriptor.length;
     1652 				end;
     1653 
     1654 			     if ^xec_eis
     1655 			     then substr (text_pt -> full_word, mf (i), 7) = string (mod_factor);
     1656 
     1657 			     if type <= 2 | type = 4
     1658 			     then do;
     1659 				     ichar = p -> reference.c_f_offset;
     1660 				     ibit = 0;
     1661 				end;
     1662 			     else do;
     1663 				     ichar = divide (p -> reference.c_f_offset, bits_per_char, 2, 0);
     1664 				     ibit = mod (p -> reference.c_f_offset, bits_per_char);
     1665 				end;
     1666 
     1667 			     if ichar > 0
     1668 			     then if q2 ^= null & type = 1
     1669 				then if q2 -> symbol.unaligned & q2 -> symbol.decimal
     1670 				     then output_pt -> four_bit_descriptor.char = ichar;
     1671 				     else output_pt -> descriptor.char = ichar;
     1672 				else output_pt -> descriptor.char = ichar;
     1673 			     if ibit > 0
     1674 			     then output_pt -> descriptor.bit = ibit;
     1675 
     1676 			     if type = 1
     1677 			     then do;
     1678 				     if p -> reference.data_type = complex_fix_dec
     1679 					| p -> reference.data_type = complex_flt_dec
     1680 				     then output_pt -> descriptor.length =
     1681 					     bit (divide (p -> reference.c_length, 2, 12, 0), 12);
     1682 				     if p -> reference.data_type = real_fix_dec
     1683 					| p -> reference.data_type = complex_fix_dec
     1684 				     then do;
     1685 					     if q2 ^= null
     1686 					     then if q2 -> symbol.unaligned & q2 -> symbol.decimal
     1687 						then output_pt -> four_bit_descriptor.bit = 5;
     1688 						else output_pt -> descriptor.bit = 1;
     1689 					     else output_pt -> descriptor.bit = 1;
     1690 					     if q2 ^= null
     1691 					     then do;
     1692 						     scale = q2 -> symbol.scale;
     1693 						     if scale > max_dec_scale | scale < min_dec_scale
     1694 						     then scale = 0;
     1695 						     else scale = -scale;
     1696 						     if scale < 0
     1697 						     then scale = scale + 64;
     1698 						     if scale ^= 0
     1699 						     then substr (output_pt -> descriptor.length, 1, 6) =
     1700 							     bit (scale, 6);
     1701 						end;
     1702 					end;
     1703 				     else if q2 ^= null
     1704 				     then if q2 -> symbol.unaligned & q2 -> symbol.decimal
     1705 					then output_pt -> four_bit_descriptor.bit = 4;
     1706 						/* 4-bit float decimal */
     1707 
     1708 				     if k = 1
     1709 				     then if instruction_info_$instruction_info (mop).changes.dr
     1710 					then do;
     1711 						p -> reference.value_in.decimal_aq = "1"b;
     1712 						decimal_reg.variable = p;
     1713 					     end;
     1714 				end;
     1715 			     else if type = 4
     1716 			     then do;
     1717 				     output_pt -> four_bit_descriptor.bit = 4;
     1718 				     output_pt -> four_bit_descriptor.char = ichar;
     1719 				end;
     1720 			end;
     1721 
     1722 		     if p -> reference.ic_ref
     1723 		     then call text_ref;
     1724 
     1725 		     reloc_pt -> left_rel = substr (p -> reference.relocation, 1, 6);
     1726 		     reloc_pt -> right_rel = substr (p -> reference.relocation, 7, 6);
     1727 
     1728 		     if count (k)
     1729 		     then call adjust_ref_count (p, -1);
     1730 		end;
     1731 
     1732 	     else do;
     1733 		     output_pt -> full_word = mac_pt -> full_word;
     1734 		     reloc_pt -> full_word = "0"b;
     1735 		end;
     1736 step:
     1737 	end;
     1738 
     1739 /* Unlock all registers locked for this instruction */
     1740 
     1741 	call state_man$unlock;
     1742 
     1743 	text_pos = text_pos + nwords;
     1744 
     1745 /* See if we have non-EIS sequence following EIS instruction.  If so, put_word will handle it */
     1746 
     1747 	if size > nwords
     1748 	then do;
     1749 		output_pt = addrel (output_pt, 1);
     1750 		reloc_pt = addrel (reloc_pt, 1);
     1751 		sym_use_pt = addrel (sym_use_pt, 1);
     1752 		mac_pt = addrel (mac_pt, 1);
     1753 		eis = "0"b;
     1754 		do i = nwords to size - 1;
     1755 		     call put_word;
     1756 		end;
     1757 	     end;
     1758 
     1759 	go to done;
     1760 
     1761 
     1762 
     1763 put_word:
     1764      proc;
     1765 
     1766 dcl	inc_orig		fixed bin;
     1767 
     1768 /* check for use of argument */
     1769 
     1770 	k = fixed (mac_pt -> arg_word.number, 3);
     1771 	if mac_pt -> instruction.tag
     1772 	then k = 0;
     1773 	if mac_pt -> instruction.base
     1774 	then k = 0;
     1775 
     1776 	inst = mac_pt -> instruction.op_code;
     1777 	mop = fixed (substr (inst, 1, 9), 9) + 512 * fixed (substr (inst, 10, 1), 1);
     1778 
     1779 /* check for use of argument */
     1780 
     1781 	if k ^= 0
     1782 	then do;
     1783 
     1784 		if k <= num_args
     1785 		then p = arg_blk -> arg (k);
     1786 		else do;
     1787 			call cg_error (303, macro);
     1788 			return;
     1789 		     end;
     1790 
     1791 /* check for base register being loaded */
     1792 
     1793 		if inst = eapbp
     1794 		then do;
     1795 			call call_base_man;
     1796 			goto l3;
     1797 		     end;
     1798 
     1799 /* make sure arg is addressable */
     1800 
     1801 		if ^addressable
     1802 		then call call_ma;
     1803 
     1804 		fw = string (p -> reference.address);
     1805 
     1806 		inc, inc_orig = fixed (mac_pt -> arg_word.increment, 12);
     1807 
     1808 /* if macro word is of form
     1809*			op argk+inc
     1810*		   and the corresponding argument has indirection,
     1811*		   we must either load value of inc into an index,
     1812*		   or we must load base register with address */
     1813 
     1814 		if inc = 0
     1815 		then goto copy;
     1816 
     1817 		if substr (p -> address.tag, 1, 2) = "00"b
     1818 		then goto copy;
     1819 
     1820 		if p -> address.tag = "010000"b	/* * */
     1821 		then do;
     1822 
     1823 /* have simple case, just load value of inc into x0 */
     1824 
     1825 			output_pt -> left = bit (fixed (inc, 18), 18);
     1826 			output_pt -> right = eax0;
     1827 
     1828 			substr (fw, 31, 6) = "111000"b;
     1829 						/* *0 */
     1830 
     1831 			output_pt = addrel (output_pt, 1);
     1832 			reloc_pt = addrel (reloc_pt, 1);
     1833 			sym_use_pt = addrel (sym_use_pt, 1);
     1834 			text_pos = text_pos + 1;
     1835 			inc = 0;
     1836 		     end;
     1837 		else do;
     1838 			call adjust_ref_count (p, 1);
     1839 			call call_base_man;
     1840 			fw = string (p -> reference.address);
     1841 		     end;
     1842 
     1843 /* copy word from macro table into output */
     1844 
     1845 copy:
     1846 		output_pt -> full_word = mac_pt -> full_word;
     1847 
     1848 /* combine kth arg with macro word */
     1849 
     1850 		output_pt -> left = "0"b;
     1851 		output_pt -> full_word = output_pt -> full_word | fw;
     1852 
     1853 		q2 = p -> reference.symbol;
     1854 		if q2 ^= null
     1855 		then sym_use_pt -> packedptr = q2;
     1856 
     1857 		if p -> reference.ic_ref
     1858 		then call text_ref;
     1859 		else if inc > 0
     1860 		then if output_pt -> instruction.ext_base
     1861 		     then output_pt -> instruction.offset =
     1862 			     bit (fixed (fixed (output_pt -> instruction.offset, 15) + inc, 15), 15);
     1863 		     else output_pt -> left = bit (fixed (fixed (output_pt -> left, 18) + inc, 18), 18);
     1864 
     1865 		reloc_pt -> left_rel = substr (p -> reference.relocation, 1, 6);
     1866 		reloc_pt -> right_rel = substr (p -> reference.relocation, 7, 6);
     1867 
     1868 		if ^p -> reference.shared & inc_orig = 0 & ^substr (count_arg, k, 1)
     1869 		then substr (count_arg, k, 1) = "1"b;
     1870 
     1871 	     end;
     1872 
     1873 	else do;
     1874 		output_pt -> full_word = mac_pt -> full_word;
     1875 		p = null;
     1876 		reloc_pt -> full_word = "0"b;
     1877 	     end;
     1878 
     1879 	if reloc_pt -> left_rel = rc_a
     1880 	then do;
     1881 		if output_pt -> full_word = eppbp_bp_up_zero
     1882 		then goto l3;
     1883 		if output_pt -> full_word = epplp_lp_up_zero
     1884 		then goto l3;
     1885 		if output_pt -> full_word = eppab_ab_up_zero
     1886 		then go to l3;
     1887 		if output_pt -> full_word = eppbb_bb_up_zero
     1888 		then go to l3;
     1889 		if output_pt -> full_word = epplb_lb_up_zero
     1890 		then go to l3;
     1891 		if output_pt -> full_word = eppsb_sb_up_zero
     1892 		then go to l3;
     1893 	     end;
     1894 
     1895 	q = addrel (output_pt, -1);
     1896 
     1897 /* following section flushes sequence
     1898*			fld	x
     1899*			fst	x
     1900*	        which may arise in some complex arithmetic sequences */
     1901 
     1902 	if inst = fst
     1903 	then do;
     1904 		fw = output_pt -> full_word;
     1905 		substr (fw, 19, 10) = fld;
     1906 		if q -> full_word = fw
     1907 		then goto prev;
     1908 	     end;
     1909 
     1910 	if i > 0
     1911 	then goto l2;
     1912 
     1913 	if output_pt -> right = adq_dl
     1914 	then s1 = 1;
     1915 	else if output_pt -> right = sbq_dl
     1916 	then s1 = -1;
     1917 	else goto l2;
     1918 
     1919 	j = 0;
     1920 	if q -> right = adq_dl
     1921 	then s2 = 1;
     1922 	else if q -> right = sbq_dl
     1923 	then s2 = -1;
     1924 	else do;
     1925 
     1926 /* if word before ldq has 2 in offset field, it may be
     1927*		        part of min | max macro so we'll skip the optimization */
     1928 
     1929 		if addrel (q, -1) -> left = "000000000000000010"b
     1930 		then goto l2;
     1931 
     1932 		j = 2;
     1933 		if q -> right = ldq_dl
     1934 		then s2 = 1;
     1935 		else if q -> right = lcq_dl
     1936 		then s2 = -1;
     1937 		else goto l2;
     1938 	     end;
     1939 
     1940 /* if we are in abs  sequence, skip optimization */
     1941 
     1942 	if addrel (q, -2) -> full_word = tpl_3_ic
     1943 	then go to l2;
     1944 
     1945 	k = s1 * fixed (output_pt -> left, 18) + s2 * fixed (q -> left, 18);
     1946 
     1947 	if k = 0
     1948 	then do;
     1949 		if j ^= 0
     1950 		then q -> full_word = ldq_0_dl;
     1951 		else do;
     1952 prev:
     1953 			output_pt = q;
     1954 			reloc_pt = addrel (reloc_pt, -1);
     1955 			sym_use_pt = addrel (sym_use_pt, -1);
     1956 			text_pos = text_pos - 1;
     1957 		     end;
     1958 		goto l3;
     1959 	     end;
     1960 
     1961 	if abs (k) > 111111111111111111b
     1962 	then goto l2;
     1963 
     1964 	q -> right = dl_inst (j + fixed (k > 0, 1));
     1965 
     1966 	q -> left = bit (k, 18);
     1967 	goto l3;
     1968 
     1969 l2:
     1970 	output_pt = addrel (output_pt, 1);
     1971 	reloc_pt = addrel (reloc_pt, 1);
     1972 	sym_use_pt = addrel (sym_use_pt, 1);
     1973 	text_pos = text_pos + 1;
     1974 
     1975 l3:
     1976 	mac_pt = addrel (mac_pt, 1);
     1977      end;
     1978 
     1979 call_base_man:
     1980      proc;
     1981 
     1982 dcl	hold_perm_address	bit (1) aligned;
     1983 
     1984 	cg_stat$text_pos = text_pos;
     1985 
     1986 	if addressable
     1987 	then do;
     1988 		hold_perm_address = p -> reference.perm_address;
     1989 		p -> reference.perm_address = "1"b;
     1990 	     end;
     1991 
     1992 	call base_man$load_var (2, p, 1);
     1993 
     1994 	if addressable
     1995 	then p -> reference.perm_address = hold_perm_address;
     1996 
     1997 	text_pos = cg_stat$text_pos;
     1998 	output_pt = addrel (cg_stat$text_base, text_pos);
     1999 	reloc_pt = addrel (cg_stat$text_reloc_base, text_pos);
     2000 	sym_use_pt = addrel (cg_stat$sym_use_base, text_pos);
     2001 
     2002      end;
     2003 
     2004 call_ma:
     2005      proc;
     2006 
     2007 	cg_stat$text_pos = text_pos;
     2008 
     2009 	call m_a (p, "0"b);
     2010 
     2011 	text_pos = cg_stat$text_pos;
     2012 	output_pt = addrel (cg_stat$text_base, text_pos);
     2013 	reloc_pt = addrel (cg_stat$text_reloc_base, text_pos);
     2014 	sym_use_pt = addrel (cg_stat$sym_use_base, text_pos);
     2015 
     2016      end;
     2017 
     2018 set_offset:
     2019      proc (off_val);
     2020 
     2021 dcl	pt		ptr,
     2022 	off_val		fixed bin (18);
     2023 
     2024 	pt = output_pt;
     2025 
     2026 	if off_val >= 0
     2027 	then pt -> ic_instruction.offset = bit (off_val, 18);
     2028 	else pt -> ic_instruction.offset = bit (fixed (262144 + off_val, 18), 18);
     2029 
     2030      end;
     2031 
     2032 text_ref:
     2033      proc;
     2034 
     2035 dcl	(q, s)		ptr,
     2036 	offset		fixed bin (18),
     2037 	temp		fixed bin (35);
     2038 
     2039 	offset = text_pos;
     2040 
     2041 	if p -> reference.defined_ref
     2042 	then s = p -> reference.qualifier;
     2043 	else s = p;
     2044 	s = s -> reference.symbol;
     2045 	if s = null
     2046 	then goto so2;
     2047 	if s -> node.type = label_node
     2048 	then goto so1;
     2049 
     2050 	if s -> symbol.label
     2051 	then goto so1;
     2052 	if s -> symbol.entry
     2053 	then goto so1;
     2054 	if ^s -> symbol.constant
     2055 	then goto so;
     2056 
     2057 	not_constant = "0"b;
     2058 
     2059 	q = s -> symbol.initial;
     2060 	if q = null
     2061 	then goto so1;
     2062 
     2063 	if p -> reference.c_offset ^= 0
     2064 	then if p -> reference.units ^= word_
     2065 	     then goto so;
     2066 
     2067 	if p -> reference.forward_ref
     2068 	then q = addrel (q, inc + p -> reference.c_offset);
     2069 	else q = addrel (cg_stat$text_base, inc + fixed (substr (string (p -> reference.address), 1, 18), 18));
     2070 
     2071 	const_string = q -> full_word;
     2072 
     2073 	if instruction_info_$instruction_info (mop).directable
     2074 	then do;
     2075 
     2076 		if eis
     2077 		then do;
     2078 			if i = 2
     2079 			then if q -> right = "0"b
     2080 			     then do;
     2081 				     output_pt -> left = q -> left;
     2082 				     substr (text_pt -> full_word, 15, 4) = "0011"b;
     2083 						/* du */
     2084 				     return;
     2085 				end;
     2086 			go to so;
     2087 		     end;
     2088 
     2089 		if q -> left = "0"b
     2090 		then do;
     2091 is_dl:
     2092 			output_pt -> left = q -> right;
     2093 			output_pt -> instruction.tag = "000111"b;
     2094 						/* dl */
     2095 			return;
     2096 		     end;
     2097 
     2098 		if q -> right = "0"b
     2099 		then do;
     2100 			output_pt -> left = q -> left;
     2101 			output_pt -> instruction.tag = "000011"b;
     2102 						/* du */
     2103 			return;
     2104 		     end;
     2105 
     2106 		if q -> fix_bin > 0
     2107 		then goto so;
     2108 
     2109 		temp = -q -> fix_bin;
     2110 		q = addr (temp);
     2111 
     2112 		if (18)"0"b || q -> right ^= q -> full_word
     2113 		then goto so;
     2114 
     2115 		if inst = ldq
     2116 		then inst = lcq;
     2117 		else if inst = adq
     2118 		then inst = sbq;
     2119 		else if inst = sbq
     2120 		then inst = adq;
     2121 		else if inst = lcq
     2122 		then inst = ldq;
     2123 		else goto so;
     2124 
     2125 		output_pt -> instruction.op_code = inst;
     2126 		mop = fixed (substr (inst, 1, 9), 9) + 512 * fixed (substr (inst, 10, 1), 1);
     2127 		goto is_dl;
     2128 
     2129 	     end;
     2130 
     2131 so:
     2132 	s -> symbol.allocate = "1"b;
     2133 
     2134 so1:
     2135 	if p -> reference.forward_ref
     2136 	then do;
     2137 		if s -> symbol.location > max_obj_seg_size
     2138 		then do;
     2139 			call cg_error (333, max_obj_seg_size);
     2140 			return;
     2141 		     end;
     2142 		output_pt -> forward_ref.offset = bit (fixed (s -> symbol.location, 17), 17);
     2143 		if eis
     2144 		then do;
     2145 			output_pt -> forward_ref.eis_flag = "1"b;
     2146 			s -> symbol.location = offset + i;
     2147 			output_pt -> descriptor.char = i;
     2148 		     end;
     2149 		else s -> symbol.location = offset;
     2150 	     end;
     2151 	else do;
     2152 so2:
     2153 		call set_offset (fixed (output_pt -> ic_instruction.offset, 18) + inc - offset);
     2154 	     end;
     2155      end;
     2156 
     2157 
     2158 save_temp:
     2159      proc;
     2160 
     2161 dcl	i		fixed bin (18);
     2162 dcl	mac		fixed bin (15);
     2163 
     2164 /* have reference to fixed binary temp without value in storage.
     2165*	        if value is in an index register, we'll transfer it to storage
     2166*	        or the q register.  If value is in q, we'll store it unless
     2167*	        the original macro was ldfx1, in which case we have an error. */
     2168 
     2169 	if p -> reference.value_in.q
     2170 	then do;
     2171 		if macro = ldfx1
     2172 		then call error315;
     2173 		else do;
     2174 			p -> reference.value_in.storage = "1"b;
     2175 			p -> reference.ref_count = p -> reference.ref_count + 1;
     2176 			call expmac (stfx1, p);
     2177 		     end;
     2178 		return;
     2179 	     end;
     2180 
     2181 	if string (p -> reference.value_in.x) = "0"b
     2182 	then do;
     2183 		call error315;
     2184 		return;
     2185 	     end;
     2186 
     2187 	do i = 0 to 7 while (^p -> reference.value_in.x (i));
     2188 	end;
     2189 
     2190 	if macro = ldfx1
     2191 	then do;
     2192 		if p -> reference.symbol -> symbol.c_dcl_size > default_fix_bin_p
     2193 		then mac = xr18_to_q;
     2194 		else mac = xr_to_q;
     2195 		q = c_a (i, 8);			/* 0,i */
     2196 		call expmac (mac, q);
     2197 		call adjust_ref_count (p, -1);
     2198 		return;
     2199 	     end;
     2200 
     2201 	p -> reference.value_in.storage = "1"b;
     2202 	p -> reference.ref_count = p -> reference.ref_count + 2;
     2203 	call expmac ((zero_mac), p);
     2204 	call expmac (sxl0 + i, p);
     2205 
     2206      end;
     2207 
     2208 
     2209 error315:
     2210      proc;
     2211 
     2212 	call error (315, cg_stat$cur_statement, p);
     2213 
     2214      end;
     2215 
     2216 change_base_:
     2217      procedure (insx, base);
     2218 declare	insx		fixed bin (18);
     2219 declare	base		fixed bin;
     2220 declare	k		fixed bin;
     2221 declare	q		ptr;
     2222 
     2223 	if insx <= base_regs (base).changed
     2224 	then return;
     2225 
     2226 	base_regs (base).changed = insx;
     2227 	base_regs (base).instruction = text_pt -> full_word;
     2228 
     2229 	q = base_regs (base).variable;
     2230 	k = base_regs (base).type;
     2231 	if q = null
     2232 	then k = 0;
     2233 
     2234 	if k = 1
     2235 	then q -> reference.value_in.b (base) = "0"b;
     2236 	else if k = 2
     2237 	then q -> reference.address_in.b (base) = "0"b;
     2238 
     2239 	base_regs (base).type = 0;
     2240 
     2241      end change_base_;
     2242 
     2243      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/03/83  1008.3  expmac.pl1                        >spec>on>pl128d>expmac.pl1
330          1    09/14/77  1705.7  operator_names.incl.pl1           >ldd>include>operator_names.incl.pl1
331          2    11/13/79  1015.8  machine_state.incl.pl1            >ldd>include>machine_state.incl.pl1
332          3    07/21/80  1546.3  nodes.incl.pl1                    >ldd>include>nodes.incl.pl1
333          4    07/21/80  1546.3  cg_reference.incl.pl1             >ldd>include>cg_reference.incl.pl1
334          5    10/02/83  0828.4  symbol.incl.pl1                   >spec>on>pl128d>symbol.incl.pl1
335          6    07/21/80  1546.3  operator.incl.pl1                 >ldd>include>operator.incl.pl1
336          7    05/03/76  1320.4  data_types.incl.pl1               >ldd>include>data_types.incl.pl1
337          8    10/25/79  1645.8  boundary.incl.pl1                 >ldd>include>boundary.incl.pl1
338          9    10/25/79  1645.8  cgsystem.incl.pl1                 >ldd>include>cgsystem.incl.pl1
339         10    10/30/80  1648.7  relocation_bits.incl.pl1          >ldd>include>relocation_bits.incl.pl1
340         11    05/03/76  1320.8  bases.incl.pl1                    >ldd>include>bases.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
PR                              000100 automatic       fixed bin(3,0)           dcl 68 set ref 804* 886 889* 890 890*
a                               000167 automatic       bit(1)                   level 3 in structure "info" packed unaligned dcl 101
                                                                                  in procedure "expmac" set ref 875 883
a                        11(09)        based           bit(1)                   level 4 in structure "reference" packed unaligned
                                                                                  dcl 4-3 in procedure "expmac" ref 1159 1161 1480
a_reg                     3            based           structure                level 2 dcl 2-6
abs                                                    builtin function         dcl 74 ref 725 1961
add_op                          000064 constant        bit(10)                  initial array unaligned dcl 146 ref 1303
addr                                                   builtin function         dcl 74 ref 421 442 828 828 828 832 832 838 961 1075
                                                                                  1081 1107 1442 1449 1460 1513 2110
addrel                                                 builtin function         dcl 74 ref 473 485 486 487 550 633 694 707 718 719
                                                                                  747 747 907 936 974 975 1003 1012 1013 1016 1038
                                                                                  1094 1095 1096 1184 1256 1257 1258 1312 1313 1314
                                                                                  1332 1368 1571 1572 1573 1598 1599 1600 1602 1749
                                                                                  1750 1751 1752 1831 1832 1833 1895 1929 1942 1954
                                                                                  1955 1969 1971 1972 1975 1998 1999 2000 2012 2013
                                                                                  2014 2067 2069
address                  10            based           structure                level 2 packed unaligned dcl 4-3 set ref 496 1248*
                                                                                  1248 1302 1624 1638 1804 1840 2069
address_in               11            based           structure                level 3 packed unaligned dcl 4-3
addressable                     000130 automatic       bit(1)                   dcl 79 set ref 782* 1108* 1801 1986 1994
adjust_ref_count                000036 constant        entry                    external dcl 105 ref 792 1354 1728 1838 2197
adq                                    constant        bit(10)                  initial unaligned dcl 150 ref 2117 2119
adq_0_dl                               constant        bit(36)                  initial unaligned dcl 191 ref 539
adq_dl                                 defined         bit(18)                  dcl 184 ref 678 685 1913 1920
aggregate                12(19)        based           bit(1)                   level 3 packed unaligned dcl 4-3 ref 356 1480 1551
allocate                 33(02)        based           bit(1)                   level 4 packed unaligned dcl 5-3 set ref 2131*
als_ins                         000010 internal static bit(36)                  initial unaligned dcl 210 set ref 624* 625 630* 631
anaq_ap                         000012 internal static bit(36)                  initial unaligned dcl 210 set ref 617* 618 644* 646
                                                                                  656* 657
aq_man$lock                     000130 constant        entry                    external dcl 1437 ref 1524
aq_man$save_aq                  000052 constant        entry                    external dcl 105 ref 1497
arg                                    based           pointer                  array dcl 269 set ref 398 447 467 481 482 495 792*
                                                                                  928 943 1479 1486* 1535 1613 1645 1784
arg_blk                         000102 automatic       pointer                  dcl 79 set ref 394* 398 421* 447 467 481 482 495 792
                                                                                  928 943 1107* 1442* 1449* 1460* 1468* 1479 1486
                                                                                  1529* 1535 1613 1645 1784
arg_cnt                                parameter       fixed bin(17,0)          dcl 390 ref 387 392 395 1463 1466 1469
arg_pt                                 parameter       pointer                  dcl 69 set ref 63 346 387 394 407 417 1389 1441 1445
                                                                                  1449 1452 1458 1463 1468
arg_pt2                                parameter       pointer                  dcl 1455 ref 1452 1459
arg_word                               based           structure                level 1 dcl 284
arl                                    constant        bit(10)                  initial unaligned dcl 150 ref 574
array_ref                 0(09)        based           bit(1)                   level 2 packed unaligned dcl 4-3 ref 354 1480
atom                                   parameter       bit(1)                   array dcl 1052 set ref 1046 1078 1105 1105 1171 1173
                                                                                  1175 1177* 1204 1205* 1205 1206* 1208 1208 1230
attributes               31            based           structure                level 2 dcl 5-3
b                        11            based           bit(1)                   array level 4 in structure "reference" packed
                                                                                  unaligned dcl 4-3 in procedure "expmac" set ref
                                                                                  2236*
b                        11(15)        based           bit(1)                   array level 4 in structure "reference" packed
                                                                                  unaligned dcl 4-3 in procedure "expmac" set ref
                                                                                  2234*
b                         0(03) 000167 automatic       bit(1)                   array level 3 in structure "info" packed unaligned
                                                                                  dcl 101 in procedure "expmac" set ref 849* 889 889
                                                                                  890
b1                              000172 automatic       bit(1)                   unaligned dcl 1057 set ref 1154* 1157* 1159* 1161*
                                                                                  1163* 1165* 1167* 1169* 1171* 1173* 1175* 1177*
                                                                                  1179 1204* 1206 1230* 1237 1269* 1277* 1291*
b2                              000173 automatic       bit(1)                   unaligned dcl 1057 set ref 1145* 1151* 1179 1227*
                                                                                  1241 1263* 1269* 1277* 1293*
b3                              000174 automatic       bit(1)                   unaligned dcl 1057 set ref 1232* 1244 1269* 1275*
                                                                                  1293*
b72                             000126 automatic       bit(72)                  dcl 79 set ref 588* 590* 591 594 600 602 607 609
base                                   parameter       fixed bin(17,0)          dcl 2219 in procedure "change_base_" ref 2216 2223
                                                                                  2226 2227 2229 2230 2234 2236 2239
base                                   based           bit(3)                   level 2 in structure "instruction" packed unaligned
                                                                                  dcl 291 in procedure "expmac" ref 804 1605 1773
base_man$load_var               000050 constant        entry                    external dcl 105 ref 1992
base_regs               160            based           structure                array level 2 dcl 2-6
binary                                                 builtin function         dcl 74 ref 802 802 804 814
bit                       0(21)        based           fixed bin(3,0)           level 2 in structure "four_bit_descriptor" packed
                                                                                  unsigned unaligned dcl 1417 in procedure "expmac"
                                                                                  set ref 1685* 1703* 1717*
bit                       0(20)        based           fixed bin(4,0)           level 2 in structure "descriptor" packed unsigned
                                                                                  unaligned dcl 1411 in procedure "expmac" set ref
                                                                                  1625 1673* 1688* 1689*
bit                                                    builtin function         dcl 74 in procedure "expmac" ref 617 624 630 640 644
                                                                                  656 671 730 754 766 770 1490 1648 1678 1698 1825
                                                                                  1859 1863 1966 2026 2028 2142
bits                     12(06)        based           structure                level 2 packed unaligned dcl 4-3
bits_per_char                   006735 constant        fixed bin(8,0)           initial dcl 9-5 ref 1663 1664
bits_per_word                          constant        fixed bin(8,0)           initial dcl 9-5 ref 1493 1493
blk                                    based           fixed bin(17,0)          array dcl 1028 set ref 1038* 1038
blk_cnt                                parameter       fixed bin(17,0)          dcl 1025 ref 1022 1030 1038 1040
blk_pt                                 parameter       pointer                  dcl 1025 ref 1022 1038
c_a                             000022 constant        entry                    external dcl 105 ref 2195
c_dcl_size               30            based           fixed bin(24,0)          level 2 dcl 5-3 ref 2192
c_f_offset                7            based           fixed bin(6,0)           level 2 dcl 4-3 ref 1659 1663 1664
c_length                  2            based           fixed bin(24,0)          level 2 dcl 4-3 ref 1491 1545 1545 1648 1678
c_offset                  1            based           fixed bin(24,0)          level 2 dcl 4-3 ref 2063 2067
cat                             000250 automatic       bit(1)                   dcl 1396 in procedure "expmac" set ref 1517* 1542
                                                                                  1558 1645
cat                       1(18)        based           bit(1)                   level 2 in structure "macro_def" packed unaligned
                                                                                  dcl 271 in procedure "expmac" ref 1517
cg_error                        000014 constant        entry                    external dcl 105 ref 435 796 981 1041 1616 1787 2139
cg_stat$complex_ac              000064 external static pointer                  dcl 218 ref 1248 1249
cg_stat$cur_node                000062 external static pointer                  dcl 218 ref 543 744
cg_stat$cur_statement           000070 external static pointer                  dcl 218 set ref 2212*
cg_stat$eis_temp                000116 external static pointer                  dcl 1409 ref 1440
cg_stat$last_macro              000100 external static fixed bin(15,0)          dcl 218 set ref 440* 951* 1033* 1568*
cg_stat$max_program_size        000074 external static fixed bin(17,0)          dcl 218 set ref 796 796* 1041 1041*
cg_stat$sym_use_base            000066 external static pointer                  dcl 218 ref 487 1096 1258 1573 2000 2014
cg_stat$text_base               000056 external static pointer                  dcl 218 ref 473 485 974 1038 1094 1256 1368 1571
                                                                                  1998 2012 2069
cg_stat$text_pos                000102 external static fixed bin(18,0)          dcl 218 set ref 461 941* 973 1038 1040* 1040 1041
                                                                                  1092 1234* 1254 1282* 1337* 1490 1570 1984* 1997
                                                                                  2007* 2011
cg_stat$text_reloc_base         000060 external static pointer                  dcl 218 ref 486 975 1095 1257 1572 1999 2013
cg_stat$used_operator           000076 external static bit(900)                 unaligned dcl 218 set ref 816*
cg_static_$m_s_p                000114 external static pointer                  dcl 2-3 ref 2-3
changed                  50            based           fixed bin(18,0)          level 3 in structure "machine_state" dcl 2-6
                                                                                  in procedure "expmac" set ref 871*
changed                 201            based           fixed bin(18,0)          array level 3 in structure "machine_state" dcl 2-6
                                                                                  in procedure "expmac" set ref 2223 2226*
changed                  22            based           fixed bin(18,0)          level 3 in structure "machine_state" dcl 2-6
                                                                                  in procedure "expmac" set ref 877*
changed                  74            based           fixed bin(18,0)          array level 3 in structure "machine_state" dcl 2-6
                                                                                  in procedure "expmac" set ref 898*
changes                         000104 external static structure                array level 2 in structure
                                                                                  "instruction_info_$instruction_info" packed
                                                                                  unaligned dcl 235 in procedure "expmac"
changes                         000167 automatic       structure                level 2 in structure "info" packed unaligned dcl 101
                                                                                  in procedure "expmac" set ref 841* 853* 858*
char                      0(18)        based           fixed bin(3,0)           level 2 in structure "four_bit_descriptor" packed
                                                                                  unsigned unaligned dcl 1417 in procedure "expmac"
                                                                                  set ref 1667* 1718*
char                      0(18)        based           fixed bin(2,0)           level 2 in structure "descriptor" packed unsigned
                                                                                  unaligned dcl 1411 in procedure "expmac" set ref
                                                                                  1374 1375* 1671* 1672* 2147*
char_string                            constant        fixed bin(15,0)          initial dcl 7-1 ref 1480
code                            000176 automatic       fixed bin(17,0)          dcl 1057 set ref 1105* 1208* 1320
compare                         000252 automatic       bit(1)                   dcl 1398 in procedure "expmac" set ref 921 1519*
                                                                                  1551
compare                   1(20)        based           bit(1)                   level 2 in structure "macro_def" packed unaligned
                                                                                  dcl 271 in procedure "expmac" ref 1519
compile_exp                     000042 constant        entry                    external dcl 105 ref 1239
compile_exp$save                000044 constant        entry                    external dcl 105 ref 1285
compiler_developed       32(35)        based           structure                level 3 packed unaligned dcl 5-3
complex_aq               11(13)        based           bit(1)                   level 4 packed unaligned dcl 4-3 ref 1163 1165 1244
complex_fix_dec                        constant        fixed bin(15,0)          initial dcl 7-1 ref 1678 1682
complex_flt_dec                        constant        fixed bin(15,0)          initial dcl 7-1 ref 1678
const_string                    000150 automatic       bit(36)                  dcl 79 set ref 580* 586* 590 759 2071*
constant                 32(16)        based           bit(1)                   level 4 packed unaligned dcl 5-3 ref 2054
constant_value                  000146 automatic       fixed bin(18,0)          dcl 79 set ref 759* 760*
constant_zero                   000016 constant        entry                    external dcl 105 ref 1167 1169
convert_size                    000034 constant        fixed bin(8,0)           initial array dcl 9-5 ref 1491
copy_temp                       000120 constant        entry                    external dcl 1433 ref 1486
count                           000245 automatic       bit(1)                   array dcl 1394 set ref 1551* 1553 1728
count_arg                       000145 automatic       bit(7)                   dcl 79 set ref 459* 515 515* 789 792 959* 1109*
                                                                                  1473* 1868 1868*
data_type                12            based           fixed bin(5,0)           level 2 in structure "reference" packed unaligned
                                                                                  dcl 4-3 in procedure "expmac" ref 349 543 744 1241
                                                                                  1303 1325 1327 1329 1480 1491 1497 1497 1678 1678
                                                                                  1682 1682
data_type                31            based           structure                level 3 in structure "symbol" packed unaligned
                                                                                  dcl 5-3 in procedure "expmac"
decimal                  31(28)        based           bit(1)                   level 4 packed unaligned dcl 5-3 ref 1667 1685 1703
decimal_aq               11(14)        based           bit(1)                   level 4 packed unaligned dcl 4-3 set ref 1711*
decimal_reg              65            based           structure                level 2 dcl 2-6
default_fix_bin_p                      constant        fixed bin(8,0)           initial dcl 9-5 ref 2192
defined_ref              12(12)        based           bit(1)                   level 3 packed unaligned dcl 4-3 ref 2041
depth                           000175 automatic       fixed bin(17,0)          dcl 1057 set ref 1111* 1135 1139 1140* 1140 1220*
                                                                                  1220 1222
descriptor                             based           structure                level 1 dcl 1411
directable                0(18) 000104 external static bit(1)                   array level 2 packed unaligned dcl 235 ref 2073
div_1_dl                        000046 constant        bit(36)                  initial unaligned dcl 191 ref 546
divide                                                 builtin function         dcl 74 ref 1663 1678
dl_inst                         000060 constant        bit(18)                  initial array dcl 178 ref 678 678 680 680 685 685
                                                                                  687 687 698 698 700 700 728 747 747 747 747 1913
                                                                                  1913 1915 1915 1920 1920 1922 1922 1933 1933 1935
                                                                                  1935 1964
double                                 parameter       fixed bin(17,0)          dcl 410 ref 407 412
dr                        0(17) 000104 external static bit(1)                   array level 3 in structure
                                                                                  "instruction_info_$instruction_info" packed
                                                                                  unaligned dcl 235 in procedure "expmac" ref 1708
dr                        0(17) 000167 automatic       bit(1)                   level 3 in structure "info" packed unaligned dcl 101
                                                                                  in procedure "expmac" set ref 904
eapbp                                  constant        bit(10)                  initial unaligned dcl 150 ref 1793
eax0                                   constant        bit(10)                  initial unaligned dcl 150 ref 1826
eax0_0_al                              constant        bit(36)                  initial unaligned dcl 191 ref 473
eis                             000144 automatic       bit(1)                   initial dcl 79 set ref 79* 858 912 1471* 1753* 2076
                                                                                  2143
eis_flag                               based           bit(1)                   level 2 packed unaligned dcl 306 set ref 1371 1373*
                                                                                  2145*
entry                    31(09)        based           bit(1)                   level 4 in structure "symbol" packed unaligned
                                                                                  dcl 5-3 in procedure "expmac" ref 2052
entry                     1            based           structure                array level 2 in structure "operator_info" dcl 262
                                                                                  in procedure "expmac" ref 828 828 832
eppab_ab_up_zero                000055 constant        bit(36)                  initial unaligned dcl 191 ref 528 1885
eppbb_bb_up_zero                000054 constant        bit(36)                  initial unaligned dcl 191 ref 530 1887
eppbp_bp_up_zero                000057 constant        bit(36)                  initial unaligned dcl 191 ref 524 1881
epplb_lb_up_zero                000053 constant        bit(36)                  initial unaligned dcl 191 ref 532 1889
epplp_lp_up_zero                000056 constant        bit(36)                  initial unaligned dcl 191 ref 526 1883
eppsb_sb_up_zero                000052 constant        bit(36)                  initial unaligned dcl 191 ref 534 1891
erase                           000142 automatic       bit(19)                  dcl 79 in procedure "expmac" set ref 453* 455 455*
                                                                                  841 849 966* 968 968* 1083* 1085 1085* 1564* 1565
                                                                                  1565*
erase                     1            based           bit(15)                  level 2 in structure "macro_def" packed unaligned
                                                                                  dcl 271 in procedure "expmac" ref 453 966 1083
                                                                                  1564
error                           000024 constant        entry                    external dcl 105 ref 2212
even                     12(17)        based           bit(1)                   level 3 packed unaligned dcl 4-3 ref 425
expmac                          000020 constant        entry                    external dcl 105 ref 2176 2196 2203 2204
expmac$zero                     000032 constant        entry                    external dcl 105 ref 1241
expmac_test                     000026 constant        entry                    external dcl 105 ref 1177
ext_base                  0(29)        based           bit(1)                   level 2 packed unaligned dcl 291 ref 811 1859
first                     1            based           fixed bin(18,0)          array level 3 packed unsigned unaligned dcl 262 ref
                                                                                  832
first_pos                       000156 automatic       fixed bin(18,0)          dcl 79 set ref 461* 799 973* 1092* 1570*
fix_bin                                based           fixed bin(17,0)          dcl 323 ref 2106 2109
fixed                                                  builtin function         dcl 74 ref 489 504 504 576 617 630 644 655 656 671
                                                                                  671 671 710 710 728 750 750 754 759 766 766 971
                                                                                  1105 1124 1125 1126 1127 1208 1323 1369 1493 1493
                                                                                  1575 1589 1589 1604 1648 1770 1777 1777 1806 1825
                                                                                  1859 1859 1863 1863 1945 1945 1964 2028 2069 2126
                                                                                  2126 2142 2152
fixed_pt                  0(19) 000167 automatic       bit(1)                   level 2 packed unaligned dcl 101 set ref 844* 881
flag                      0(28)        based           bit(1)                   level 2 packed unaligned dcl 291 ref 1115
fld                                    constant        bit(10)                  initial unaligned dcl 150 ref 1905
fld_0_dl                               constant        bit(36)                  initial unaligned dcl 191 ref 596
float_pt                  0(20) 000167 automatic       bit(1)                   level 2 packed unaligned dcl 101 set ref 846* 881
forward_ref                            based           structure                level 1 dcl 306 in procedure "expmac"
forward_ref              12(09)        based           bit(1)                   level 3 in structure "reference" packed unaligned
                                                                                  dcl 4-3 in procedure "expmac" ref 2067 2134
found                           000131 automatic       bit(1)                   dcl 79 set ref 832* 835* 836* 838
four_bit_descriptor                    based           structure                level 1 dcl 1417
fst                                    constant        bit(10)                  initial unaligned dcl 150 ref 1902
full_word                              based           bit(36)                  dcl 311 set ref 443 473* 496* 520 596* 618 620* 625
                                                                                  631 642 646* 657 659* 707 714* 747 770* 872 878
                                                                                  899 963 987* 987 988* 1000 1302* 1514 1581* 1581
                                                                                  1582* 1624* 1654* 1733* 1733 1734* 1845* 1845
                                                                                  1851* 1851 1874* 1874 1876* 1881 1883 1885 1887
                                                                                  1889 1891 1904 1906 1942 1949* 2071 2082* 2112
                                                                                  2227
fw                              000147 automatic       bit(36)                  dcl 79 set ref 520* 524 526 528 530 532 534 537 539
                                                                                  541 543 546 620 659 1804* 1828* 1840* 1851 1904*
                                                                                  1905* 1906
fx1_to_fx2                             constant        fixed bin(15,0)          initial dcl 127 ref 1241
get_desc_size                          constant        fixed bin(15,0)          initial dcl 127 ref 373
half_word                              based           structure                level 1 dcl 319
hbound                                                 builtin function         dcl 74 ref 828 832 889
hold_perm_address               000320 automatic       bit(1)                   dcl 1982 in procedure "call_base_man" set ref 1988*
                                                                                  1994
hold_perm_address               000132 automatic       bit(1)                   dcl 79 in procedure "expmac" set ref 481* 943
i                               000362 automatic       fixed bin(18,0)          dcl 2161 in procedure "save_temp" set ref 2187*
                                                                                  2187* 2195* 2204
i                               000151 automatic       fixed bin(18,0)          dcl 79 in procedure "expmac" set ref 397* 398* 446*
                                                                                  447* 784* 789* 792 792* 799* 871 877 886* 890* 898
                                                                                  935* 935* 986* 1478* 1479 1486* 1534* 1535 1539
                                                                                  1540 1542 1545 1548 1548 1551 1551 1553* 1596*
                                                                                  1654* 1754* 1910 2078 2146 2147
ibit                            000257 automatic       fixed bin(4,0)           dcl 1402 set ref 1660* 1664* 1673 1673
ic_instruction                         based           structure                level 1 dcl 299
ic_ref                   12(10)        based           bit(1)                   level 3 packed unaligned dcl 4-3 ref 506 1722 1857
ichar                           000256 automatic       fixed bin(3,0)           dcl 1401 set ref 1659* 1663* 1667 1667 1671 1672
                                                                                  1718
inc                             000161 automatic       fixed bin(18,0)          dcl 79 set ref 508* 1584* 1806* 1814 1825 1835* 1859
                                                                                  1859 1863 2067 2069 2152
inc_orig                        000310 automatic       fixed bin(17,0)          dcl 1766 set ref 1806* 1868
increment                 0(06)        based           bit(12)                  level 2 packed unaligned dcl 284 ref 1806
ind_arithmetic                         constant        fixed bin(17,0)          initial dcl 2-68 ref 881 1000
ind_decimal_reg                        constant        fixed bin(17,0)          initial dcl 2-68 ref 904
ind_invalid                            constant        fixed bin(17,0)          initial dcl 2-68 ref 929 931
ind_known_refs                  006736 constant        fixed bin(17,0)          initial dcl 2-68 ref 921
ind_logical                            constant        fixed bin(17,0)          initial dcl 2-68 ref 883
ind_x                           000036 constant        fixed bin(17,0)          initial array dcl 2-68 ref 900
index_regs               70            based           structure                array level 2 dcl 2-6
indicators                1            based           fixed bin(17,0)          level 2 in structure "machine_state" dcl 2-6
                                                                                  in procedure "expmac" set ref 866* 881* 883* 900*
                                                                                  904* 921 929* 931* 1000
indicators                0(02) 000167 automatic       bit(1)                   level 3 in structure "info" packed unaligned dcl 101
                                                                                  in procedure "expmac" set ref 843* 866 883
indicators_ref          420            based           pointer                  array level 2 packed unaligned dcl 2-6 ref 929 931
info                      2            based           structure                array level 3 in structure "operator_info" dcl 262
                                                                                  in procedure "expmac" ref 838
info                            000167 automatic       structure                level 1 dcl 101 in procedure "expmac" set ref 803*
                                                                                  838*
info                     11            based           structure                level 2 in structure "reference" packed unaligned
                                                                                  dcl 4-3 in procedure "expmac"
initial                  11            based           pointer                  level 2 packed unaligned dcl 5-3 ref 2059
inst                            000140 automatic       bit(10)                  dcl 79 set ref 503* 504 504 742 801* 802 802 811 811
                                                                                  811 811 811 819 819 853 1585* 1589 1589 1776* 1777
                                                                                  1777 1793 1902 2115 2115* 2117 2117* 2119 2119*
                                                                                  2121 2121* 2125 2126 2126
instruction              23            based           bit(36)                  level 3 in structure "machine_state" dcl 2-6
                                                                                  in procedure "expmac" set ref 878*
instruction              51            based           bit(36)                  level 3 in structure "machine_state" dcl 2-6
                                                                                  in procedure "expmac" set ref 872*
instruction              75            based           bit(36)                  array level 3 in structure "machine_state" dcl 2-6
                                                                                  in procedure "expmac" set ref 899*
instruction                            based           structure                level 1 dcl 291 in procedure "expmac"
instruction             202            based           bit(36)                  array level 3 in structure "machine_state" dcl 2-6
                                                                                  in procedure "expmac" set ref 2227*
instruction_info_$instruction_info
                                000104 external static structure                array level 1 dcl 235 ref 803
instruction_info_$operators     000106 external static fixed bin(17,0)          dcl 252 set ref 828 828 828 832 832 838
insx                                   parameter       fixed bin(18,0)          dcl 2218 ref 2216 2223 2226
j                               000152 automatic       fixed bin(18,0)          dcl 79 set ref 684* 697* 714 728 828* 828* 832 832
                                                                                  838 895* 896 898 899 900* 1919* 1932* 1949 1964
k                               000400 automatic       fixed bin(17,0)          dcl 2220 in procedure "change_base_" set ref 2230*
                                                                                  2231* 2234 2236
k                               000153 automatic       fixed bin(18,0)          dcl 79 in procedure "expmac" set ref 344* 412* 418
                                                                                  423 710* 712 725 728 730 760* 761 766 770 1127*
                                                                                  1128 1128 1128 1230 1237 1239 1241 1244 1247 1252
                                                                                  1252 1285 1285 1604* 1605* 1610 1613 1613 1639
                                                                                  1641 1641 1645 1708 1728 1770* 1771* 1773* 1781
                                                                                  1784 1784 1868 1868 1945* 1947 1961 1964 1966
k71                             000164 automatic       fixed bin(71,0)          dcl 79 set ref 750* 752 754
label                    31(08)        based           bit(1)                   level 4 packed unaligned dcl 5-3 ref 2050
label_node                             constant        bit(9)                   initial dcl 3-5 ref 2047
last                      1(18)        based           fixed bin(18,0)          array level 3 packed unsigned unaligned dcl 262 ref
                                                                                  828
last_use                               parameter       fixed bin(17,0)          dcl 1363 ref 1360 1366
lbound                                                 builtin function         dcl 74 ref 828 889
lcq                                    constant        bit(10)                  initial unaligned dcl 150 ref 2115 2121
lcq_dl                                 defined         bit(18)                  dcl 184 ref 700 747 1935
lda                                    constant        bit(10)                  initial unaligned dcl 150 ref 634 1006
lda_dl                                 constant        bit(18)                  initial unaligned dcl 172 ref 584 610
lda_du                                 constant        bit(18)                  initial unaligned dcl 172 ref 578 603
ldfx1                                  constant        fixed bin(15,0)          initial dcl 127 ref 381 2171 2190
ldq                                    constant        bit(10)                  initial unaligned dcl 150 ref 636 1004 2115 2121
ldq_0_dl                               constant        bit(36)                  initial unaligned dcl 191 ref 714 1949
ldq_dl                                 defined         bit(18)                  dcl 184 ref 698 747 1933
left                                   based           bit(18)                  level 2 packed unaligned dcl 319 set ref 576 580 586
                                                                                  602* 609* 655 671* 671 671 694 710 710 730* 747
                                                                                  750 750 754* 766* 766 1825* 1850* 1863* 1863 1929
                                                                                  1945 1945 1966* 2081* 2081 2089 2091* 2100* 2100
left_rel                  0(12)        based           bit(6)                   level 2 packed unaligned dcl 313 set ref 512* 522
                                                                                  1309* 1725* 1865* 1879
len                             000242 automatic       bit(4)                   array dcl 1393 set ref 1540* 1548* 1561* 1561 1641
length                    0(24)        based           bit(12)                  level 2 in structure "descriptor" packed unaligned
                                                                                  dcl 1411 in procedure "expmac" set ref 1641* 1648
                                                                                  1648* 1651* 1651 1678* 1698*
length                    6            based           pointer                  level 2 in structure "reference" packed unaligned
                                                                                  dcl 4-3 in procedure "expmac" ref 1545
length_in_q                     000251 automatic       bit(1)                   dcl 1397 in procedure "expmac" set ref 1518* 1524
                                                                                  1537
length_in_q               1(19)        based           bit(1)                   level 2 in structure "macro_def" packed unaligned
                                                                                  dcl 271 in procedure "expmac" ref 1518
length_in_reg             0(01) 000266 automatic       bit(1)                   level 3 packed unaligned dcl 1425 set ref 1639*
llr_36                          000051 constant        bit(36)                  initial unaligned dcl 191 ref 1000
lls_ins                         000011 internal static bit(36)                  initial unaligned dcl 210 set ref 640* 642
load                            000034 constant        entry                    external dcl 105 ref 1237
load_ab                                constant        fixed bin(15,0)          initial dcl 127 ref 365
load_pt                                constant        fixed bin(15,0)          initial dcl 127 ref 363
load_sb                                constant        fixed bin(15,0)          initial dcl 127 ref 365
load_size$xr_or_aq              000124 constant        entry                    external dcl 1435 ref 1548
location                  1            based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 5-3 set ref
                                                                                  2137 2142 2146* 2149*
long_ref                 12(08)        based           bit(1)                   level 3 packed unaligned dcl 4-3 ref 1480
lreg                            000237 automatic       bit(1)                   array dcl 1392 set ref 1539* 1545* 1548 1560* 1560
                                                                                  1639 1641
lrl                                    constant        bit(10)                  initial unaligned dcl 150 ref 574 594
lrs                                    constant        bit(10)                  initial unaligned dcl 150 ref 650
m_a                             000030 constant        entry                    external dcl 105 ref 399 418 2009
m_s_p                           000170 automatic       pointer                  initial dcl 2-3 set ref 866 871 872 877 878 881 883
                                                                                  898 899 900 904 921 929 929 931 931 1000 1712 2-3*
                                                                                  2223 2226 2227 2229 2230 2239
mac                             000166 automatic       fixed bin(17,0)          dcl 79 in procedure "expmac" set ref 403* 425* 427*
                                                                                  429 433 435* 440 442 951* 953 955 961 981* 1506*
                                                                                  1513 1568
mac                             000363 automatic       fixed bin(15,0)          dcl 2162 in procedure "save_temp" set ref 2192*
                                                                                  2194* 2196*
mac_pt                          000112 automatic       pointer                  dcl 79 set ref 442* 443 453 465 478 489 497 781* 781
                                                                                  781 961* 963 966 971 985* 985 985 987 1016* 1016
                                                                                  1075* 1081* 1083 1088* 1088 1088 1115 1124 1125
                                                                                  1126 1127 1139* 1184* 1184 1215* 1215 1222 1332*
                                                                                  1332 1340 1513* 1514 1517 1518 1519 1520 1564 1575
                                                                                  1577* 1577 1577 1581 1602* 1602 1604 1605 1625
                                                                                  1648 1651 1733 1752* 1752 1770 1771 1773 1776 1806
                                                                                  1845 1874 1975* 1975
machine_state                          based           structure                level 1 dcl 2-6
macro                                  parameter       fixed bin(17,0)          dcl 69 set ref 63 359 361 363 365 365 367 367 369
                                                                                  369 371 373 381 387 403 407 425 427 948 951 1078
                                                                                  1081 1389 1445 1452 1463 1506 1508 1510 1616*
                                                                                  1787* 2171 2190
macro_def                              based           structure                level 1 dcl 271
macro_start                            parameter       fixed bin(17,0)          dcl 1052 set ref 1046 1075
macro_table_$macro_count        000110 external static fixed bin(17,0)          dcl 255 ref 433 955 1510
macro_table_$macro_table        000112 external static bit(72)                  array unaligned dcl 255 set ref 442 961 1081 1513
made_perm_addressable           000133 automatic       bit(1)                   initial dcl 79 set ref 79* 480* 943
make_n_addressable              000122 constant        entry                    external dcl 1434 ref 1529
max_dec_scale                          constant        fixed bin(8,0)           initial dcl 9-5 ref 1693
max_obj_seg_size                000065 constant        fixed bin(17,0)          initial dcl 125 set ref 2137 2139*
mf                              000021 constant        fixed bin(6,0)           initial array dcl 1406 ref 1654
min_dec_scale                   006734 constant        fixed bin(8,0)           initial dcl 9-5 ref 1693
misc_attributes          31(19)        based           structure                level 3 packed unaligned dcl 5-3
mod                                                    builtin function         dcl 74 ref 1664
mod_factor                      000266 automatic       structure                level 1 dcl 1425 set ref 1638* 1654
mop                             000134 automatic       fixed bin(10,0)          dcl 79 set ref 504* 802* 803 1124* 1131 1589* 1590
                                                                                  1708 1777* 2073 2126*
mpy                                    constant        bit(10)                  initial unaligned dcl 150 ref 742
mpy_1_dl                        000047 constant        bit(36)                  initial unaligned dcl 191 ref 543
mpy_dl                                 constant        bit(18)                  initial unaligned dcl 172 ref 747
n                               000137 automatic       fixed bin(17,0)          dcl 79 set ref 1320* 1323* 1325* 1327* 1329* 1332
                                                                                  1521* 1523* 1529*
n_entries                              based           fixed bin(17,0)          level 2 dcl 262 ref 828 832
need_temp                       000040 constant        entry                    external dcl 105 ref 448 1553
no_address               10(27)        based           bit(1)                   level 3 packed unaligned dcl 4-3 set ref 1298
no_al                     1(15)        based           bit(1)                   level 2 packed unaligned dcl 271 ref 465
node                                   based           structure                level 1 dcl 3-27
node_pt                                parameter       pointer                  dcl 1052 set ref 1046 1078 1098 1100 1101 1102 1177*
                                                                                  1323
not_constant                    000143 automatic       bit(1)                   unaligned dcl 79 set ref 458* 733 2057*
null                                                   builtin function         dcl 74 ref 500 1306 1524 1524 1545 1621 1667 1685
                                                                                  1690 1703 1854 1875 2045 2060 2231
num_args                        000154 automatic       fixed bin(18,0)          dcl 79 set ref 395* 397 414* 446 789 958* 1098* 1102
                                                                                  1128 1439* 1448* 1457* 1469* 1478 1521 1523 1534
                                                                                  1613 1784
num_words                 0(27) 000167 automatic       fixed bin(7,0)           level 2 in structure "info" packed unaligned dcl 101
                                                                                  in procedure "expmac" set ref 911
num_words                 0(27) 000104 external static fixed bin(7,0)           array level 2 in structure
                                                                                  "instruction_info_$instruction_info" packed
                                                                                  unaligned dcl 235 in procedure "expmac" ref 1590
number                    0(03)        based           bit(3)                   level 2 in structure "arg_word" packed unaligned
                                                                                  dcl 284 in procedure "expmac" ref 1127 1604 1770
number                    0(21)        based           fixed bin(14,0)          level 2 in structure "operator" packed unaligned
                                                                                  dcl 6-6 in procedure "expmac" ref 1098
nwords                          000254 automatic       fixed bin(17,0)          dcl 1400 set ref 911* 912* 916 935 936 1590* 1592*
                                                                                  1596 1743 1747 1754
off_val                                parameter       fixed bin(18,0)          dcl 2021 ref 2018 2026 2026 2028
offset                    0(01)        based           bit(17)                  level 2 in structure "forward_ref" packed unaligned
                                                                                  dcl 306 in procedure "expmac" set ref 1369 2142*
offset                          000162 automatic       fixed bin(18,0)          dcl 79 in procedure "expmac" set ref 814* 816 816
                                                                                  828 832
offset                                 based           bit(18)                  level 2 in structure "ic_instruction" packed
                                                                                  unaligned dcl 299 in procedure "expmac" set ref
                                                                                  2026* 2028* 2152
offset                          000352 automatic       fixed bin(18,0)          dcl 2035 in procedure "text_ref" set ref 2039* 2146
                                                                                  2149 2152
offset                    0(03)        based           bit(15)                  level 2 in structure "instruction" packed unaligned
                                                                                  dcl 291 in procedure "expmac" set ref 814 1859*
                                                                                  1859
op                        0(18)        based           bit(9)                   level 2 packed unaligned dcl 1065 ref 1124
op_code                   0(18)        based           bit(10)                  level 2 in structure "macro_def" packed unaligned
                                                                                  dcl 271 in procedure "expmac" ref 497
op_code                   0(09)        based           bit(9)                   level 2 in structure "operator" packed unaligned
                                                                                  dcl 6-6 in procedure "expmac" ref 1323
op_code                   0(18)        based           bit(10)                  level 2 in structure "instruction" packed unaligned
                                                                                  dcl 291 in procedure "expmac" set ref 497* 503 634
                                                                                  636* 801 1004 1006* 1303* 1585 1776 2125*
operand                   1            based           pointer                  array level 2 packed unaligned dcl 6-6 ref 543 744
                                                                                  1100 1101 1102 1252
operator                               based           structure                level 1 dcl 6-6
operator_info                          based           structure                level 1 dcl 262
ora_0_dl                               constant        bit(36)                  initial unaligned dcl 191 ref 537
output_pt                       000116 automatic       pointer                  dcl 79 set ref 485* 496 497 503 520 549 550 576 655
                                                                                  671 710 717* 750 770 974* 987 1000 1003 1012* 1012
                                                                                  1094* 1256* 1302 1303 1312* 1312 1368* 1369 1371
                                                                                  1373 1374 1375 1571* 1581 1585 1598* 1598 1624
                                                                                  1641 1648 1651 1667 1671 1672 1673 1678 1685 1688
                                                                                  1689 1698 1703 1717 1718 1733 1749* 1749 1825 1826
                                                                                  1831* 1831 1845 1850 1851 1851 1859 1859 1859 1863
                                                                                  1863 1874 1881 1883 1885 1887 1889 1891 1895 1904
                                                                                  1913 1915 1945 1952* 1969* 1969 1998* 2012* 2024
                                                                                  2081 2091 2093 2100 2101 2125 2142 2145 2147 2152
p                               000104 automatic       pointer                  dcl 79 set ref 346* 347 349 352 354 356 398* 399
                                                                                  399* 447* 448 448 448* 467* 468 471 495* 496 499
                                                                                  506 512 513 515 928* 929 931 1128* 1298 1302 1303
                                                                                  1305 1309 1310 1346 1346 1346 1354 1354* 1479*
                                                                                  1480 1480 1480 1480 1480 1480 1480 1480 1486 1486*
                                                                                  1486* 1488 1488 1489 1490 1491 1491 1493* 1497
                                                                                  1497 1497 1497* 1535* 1545 1545 1545 1545 1548*
                                                                                  1551 1551 1551 1553 1553* 1613* 1620 1624 1638
                                                                                  1644 1659 1663 1664 1678 1678 1678 1682 1682 1711
                                                                                  1712 1722 1725 1726 1728* 1784* 1804 1817 1820
                                                                                  1838* 1840 1853 1857 1865 1866 1868 1875* 1988
                                                                                  1989 1992* 1994 2009* 2041 2041 2043 2063 2063
                                                                                  2067 2067 2069 2134 2169 2174 2175 2175 2176* 2181
                                                                                  2187 2192 2197* 2201 2202 2202 2203* 2204* 2212*
packed_ptr_st                          based           structure                level 1 dcl 325
packedptr                              based           pointer                  level 2 packed unaligned dcl 325 set ref 500* 1306*
                                                                                  1621* 1854*
part1                                  based           bit(18)                  level 2 packed unaligned dcl 1065 ref 1126
part2                     0(30)        based           bit(6)                   level 2 packed unaligned dcl 1065 ref 1125
perm                      1(17)        based           bit(1)                   level 2 packed unaligned dcl 271 ref 478
perm_address             12(18)        based           bit(1)                   level 3 packed unaligned dcl 4-3 set ref 399 418 481
                                                                                  482* 943* 1250* 1988 1989* 1994*
pl1_operator_names_$last        000072 external static fixed bin(17,0)          dcl 218 ref 816
power_of_two                    000054 constant        entry                    external dcl 105 ref 760
prev_use                        000236 automatic       fixed bin(17,0)          dcl 1363 set ref 1369* 1379
pt                              000336 automatic       pointer                  dcl 2021 set ref 2024* 2026 2028
ptarray                         000262 automatic       pointer                  array dcl 1404 set ref 1440* 1441* 1442 1458* 1459*
                                                                                  1460
ptr                                                    builtin function         dcl 74 ref 781 985 1088 1215 1577
q                        11(10)        based           bit(1)                   level 4 in structure "reference" packed unaligned
                                                                                  dcl 4-3 in procedure "expmac" ref 1154 1157 1497
                                                                                  2169
q                               000106 automatic       pointer                  dcl 79 in procedure "expmac" set ref 550* 578 580
                                                                                  584 586 596 602 603 609 610 618 620 625 631 633
                                                                                  642 646 657 659 666 671 671 685 687 694 698 700
                                                                                  707 710 714 717 728 730 747 747 747 747 750 754
                                                                                  764 766 766 1003* 1004 1006 1195* 1198 1200* 1202
                                                                                  1247* 1248 1249 1250 1644* 1645* 1648 1895* 1906
                                                                                  1920 1922 1929 1933 1935 1942 1945 1949 1952 1964
                                                                                  1966 2195* 2196*
q                               000346 automatic       pointer                  dcl 2035 in procedure "text_ref" set ref 2059* 2060
                                                                                  2067* 2067 2069* 2071 2078 2081 2089 2091 2098
                                                                                  2100 2106 2109 2110* 2112 2112
q                         0(01) 000167 automatic       bit(1)                   level 3 in structure "info" packed unaligned dcl 101
                                                                                  in procedure "expmac" set ref 869 881
q                               000402 automatic       pointer                  dcl 2221 in procedure "change_base_" set ref 2229*
                                                                                  2231 2234 2236
q2                              000110 automatic       pointer                  dcl 79 set ref 499* 500 500 633* 634 636 1305* 1306
                                                                                  1306 1620* 1621 1621 1667 1667 1667 1685 1685 1685
                                                                                  1690 1692 1703 1703 1703 1853* 1854 1854
q_reg                    31            based           structure                level 2 dcl 2-6
qls                                    constant        bit(10)                  initial unaligned dcl 150 ref 664 666 764 770
qualifier                 4            based           pointer                  level 2 packed unaligned dcl 4-3 ref 2041
quick_desc_mac                         constant        fixed bin(15,0)          initial dcl 127 ref 371
rand                            000224 automatic       pointer                  array dcl 1057 set ref 1100* 1101* 1102* 1200 1201*
                                                                                  1201 1202* 1239* 1252 1285*
rc_a                                   constant        bit(6)                   initial unaligned dcl 10-6 ref 522 1879
real_fix_bin_1                         constant        fixed bin(15,0)          initial dcl 7-1 ref 349 543 744
real_fix_bin_2                         constant        fixed bin(15,0)          initial dcl 7-1 ref 1241 1497
real_fix_dec                           constant        fixed bin(15,0)          initial dcl 7-1 ref 1682
ref                                    defined         pointer                  array dcl 1057 set ref 1128 1154 1157 1159 1161 1163
                                                                                  1165 1167* 1169* 1195 1197* 1197 1198* 1237* 1241
                                                                                  1244 1247 1252* 1285* 1325 1327 1329
ref_count                 0(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 4-3 set ref 448 1346*
                                                                                  1346 1488* 1488 1553 2175* 2175 2202* 2202
ref_pt                          000114 automatic       pointer                  dcl 79 set ref 417* 418 418* 421 425
reference                              based           structure                level 1 dcl 4-3
refs                                   parameter       pointer                  array dcl 1052 set ref 1046 1078 1107 1128 1128 1154
                                                                                  1154 1157 1157 1159 1159 1161 1161 1163 1163 1165
                                                                                  1165 1167 1167 1169 1169 1177* 1195 1195 1197*
                                                                                  1197 1197 1197 1198* 1198 1237 1237 1241 1241 1244
                                                                                  1244 1247 1247 1252* 1252 1285* 1285 1325 1325
                                                                                  1327 1327 1329 1329
rel_ptr                                based           bit(18)                  level 2 packed unaligned dcl 271 ref 781 985 1088
                                                                                  1577
reloc                                  based           structure                level 1 dcl 313
reloc_pt                        000122 automatic       pointer                  dcl 79 set ref 486* 512 513 522 718* 718 975* 988
                                                                                  1013* 1013 1095* 1257* 1309 1310 1313* 1313 1572*
                                                                                  1582 1599* 1599 1725 1726 1734 1750* 1750 1832*
                                                                                  1832 1865 1866 1876 1879 1954* 1954 1971* 1971
                                                                                  1999* 2013*
relocation               12(24)        based           bit(12)                  level 2 packed unaligned dcl 4-3 set ref 512 513
                                                                                  1249* 1249 1309 1310 1725 1726 1865 1866
rhs                             000141 automatic       bit(18)                  dcl 79 set ref 549* 574 574 594 650 664 678 680 747
right                     0(18)        based           bit(18)                  level 2 packed unaligned dcl 319 set ref 549 578 584
                                                                                  603* 610* 666 685 687 698 700 728* 747 747 764
                                                                                  1826* 1913 1915 1920 1922 1933 1935 1964* 2078
                                                                                  2091 2098 2112
right_rel                 0(30)        based           bit(6)                   level 2 packed unaligned dcl 313 set ref 513* 1310*
                                                                                  1726* 1866*
s                               000350 automatic       pointer                  dcl 2035 set ref 2041* 2043* 2044* 2044 2045 2047
                                                                                  2050 2052 2054 2059 2131 2137 2142 2146 2149
s1                              000135 automatic       fixed bin(17,0)          dcl 79 set ref 678* 680* 710 1126* 1212 1215 1332
                                                                                  1913* 1915* 1945
s2                              000136 automatic       fixed bin(17,0)          dcl 79 set ref 685* 687* 698* 700* 710 1125* 1154
                                                                                  1157 1159 1161 1163 1165 1167 1169 1171 1173 1175
                                                                                  1177* 1320 1323 1325 1327 1329 1920* 1922* 1933*
                                                                                  1935* 1945
sbq                                    constant        bit(10)                  initial unaligned dcl 150 ref 2117 2119
sbq_0_dl                               constant        bit(36)                  initial unaligned dcl 191 ref 541
sbq_dl                                 defined         bit(18)                  dcl 184 ref 680 687 1915 1922
scale                     2(28)        based           fixed bin(7,0)           level 2 in structure "symbol" packed unaligned
                                                                                  dcl 5-3 in procedure "expmac" ref 1692
scale                           000260 automatic       fixed bin(6,0)           dcl 1403 in procedure "expmac" set ref 1692* 1693
                                                                                  1693 1693* 1695* 1695 1696 1696* 1696 1698 1698
shared                    0(11)        based           bit(1)                   level 2 packed unaligned dcl 4-3 ref 448 515 1346
                                                                                  1354 1486 1551 1868
shift_amount                    000160 automatic       fixed bin(18,0)          dcl 79 set ref 576* 590 617 624 628 630 640 644 655*
                                                                                  656
size                            000157 automatic       fixed bin(18,0)          dcl 79 in procedure "expmac" set ref 489* 490 784
                                                                                  971* 979 986 1491* 1493 1493 1575* 1747 1754
size                      0(28)        based           bit(8)                   level 2 in structure "macro_def" packed unaligned
                                                                                  dcl 271 in procedure "expmac" ref 489 971 1575
some_base                 0(21) 000167 automatic       bit(1)                   level 2 packed unaligned dcl 101 set ref 886
sp_erase                        000234 automatic       bit(19)                  dcl 1073 set ref 1340* 1341*
special_erase                          based           bit(15)                  dcl 1071 ref 1340
special_word                           based           structure                level 1 dcl 1065
sta                                    constant        fixed bin(15,0)          initial dcl 127 ref 1493
stack                           000200 automatic       pointer                  array dcl 1057 set ref 1139 1222*
state_man$erase_reg             000046 constant        entry                    external dcl 105 ref 455 968 1085 1341 1565
state_man$unlock                000126 constant        entry                    external dcl 1436 ref 1741
stfx1                           000066 constant        fixed bin(15,0)          initial dcl 127 set ref 359 2176*
storage                  11(23)        based           bit(1)                   level 4 packed unaligned dcl 4-3 set ref 352 1480
                                                                                  1489* 2174* 2201*
storage_class            32(09)        based           structure                level 3 packed unaligned dcl 5-3
store_ins                13(18)        based           bit(18)                  level 2 packed unaligned dcl 4-3 set ref 1490*
string                                                 builtin function         dcl 74 set ref 496 841* 853* 858* 1248* 1248 1302
                                                                                  1624 1638* 1638 1654 1804 1840 2069 2181
stx0                                   constant        fixed bin(15,0)          initial dcl 127 ref 369
stx7                                   constant        fixed bin(15,0)          initial dcl 127 ref 369
substr                                                 builtin function         dcl 74 set ref 468 471* 504 504 512 513 515 515*
                                                                                  590* 591 600 607 609 617* 624* 630* 640* 644* 656*
                                                                                  792 802 802 816* 841 849 1309 1310 1589 1589 1638
                                                                                  1654* 1698* 1725 1726 1777 1777 1817 1828* 1865
                                                                                  1866 1868 1868* 1905* 2069 2082* 2126 2126
sxl0                                   constant        fixed bin(15,0)          initial dcl 127 ref 367 2204
sxl7                                   constant        fixed bin(15,0)          initial dcl 127 ref 367
sym_use_pt                      000120 automatic       pointer                  dcl 79 set ref 487* 500 719* 719 1096* 1258* 1306
                                                                                  1314* 1314 1573* 1600* 1600 1621 1751* 1751 1833*
                                                                                  1833 1854 1955* 1955 1972* 1972 2000* 2014*
symbol                    3            based           pointer                  level 2 in structure "reference" packed unaligned
                                                                                  dcl 4-3 in procedure "expmac" ref 499 1305 1620
                                                                                  1853 2044 2192
symbol                                 based           structure                level 1 dcl 5-3 in procedure "expmac"
tag                       0(01) 000266 automatic       structure                level 2 in structure "mod_factor" packed unaligned
                                                                                  dcl 1425 in procedure "expmac"
tag                      10(30)        based           bit(6)                   level 3 in structure "reference" packed unaligned
                                                                                  dcl 4-3 in procedure "expmac" set ref 468 471*
                                                                                  1817 1820
tag                       0(30)        based           bit(6)                   level 2 in structure "instruction" packed unaligned
                                                                                  dcl 291 in procedure "expmac" set ref 811 1771
                                                                                  2093* 2101*
temp                            000353 automatic       fixed bin(35,0)          dcl 2035 set ref 2109* 2110
temp_ref                 12(11)        based           bit(1)                   level 3 packed unaligned dcl 4-3 ref 347 1480 1551
text_pos                        000155 automatic       fixed bin(18,0)          dcl 79 set ref 461* 473 474* 474 485 486 487 720*
                                                                                  720 774* 774 796 799 941 973* 974 975 1014* 1014
                                                                                  1092* 1094 1095 1096 1234 1254* 1256 1257 1258
                                                                                  1282 1315* 1315 1337 1570* 1571 1572 1573 1743*
                                                                                  1743 1834* 1834 1956* 1956 1973* 1973 1984 1997*
                                                                                  1998 1999 2000 2007 2011* 2012 2013 2014 2039
text_pt                         000124 automatic       pointer                  dcl 79 set ref 485* 801 804 811 811 814 872 878 899
                                                                                  907* 907 936* 936 974* 1094* 1571* 1654 2082 2227
tpl_3_ic                        000050 constant        bit(36)                  initial unaligned dcl 191 ref 707 747 1942
tra                                    constant        bit(10)                  initial unaligned dcl 150 ref 811
tsp2                                   constant        bit(10)                  initial unaligned dcl 150 ref 811
tsp3                                   constant        bit(10)                  initial unaligned dcl 150 ref 811 819
tsp4                                   constant        bit(10)                  initial unaligned dcl 150 ref 811 853
tsx0                                   constant        bit(10)                  initial unaligned dcl 150 ref 811 819
type                                   based           bit(9)                   level 2 in structure "node" packed unaligned
                                                                                  dcl 3-27 in procedure "expmac" ref 2047
type                            000255 automatic       fixed bin(17,0)          dcl 1400 in procedure "expmac" set ref 1625* 1636
                                                                                  1657 1657 1667 1676 1715
type                    162            based           fixed bin(8,0)           array level 3 in structure "machine_state" dcl 2-6
                                                                                  in procedure "expmac" set ref 2230 2239*
unaligned                31(22)        based           bit(1)                   level 4 packed unaligned dcl 5-3 ref 1667 1685 1703
units                     0(14)        based           fixed bin(3,0)           level 2 packed unaligned dcl 4-3 ref 2063
use                             000235 automatic       fixed bin(17,0)          dcl 1363 set ref 1366* 1367 1368 1374* 1374 1378
                                                                                  1379*
val                                    parameter       fixed bin(17,0)          dcl 1363 ref 1360 1378
value_in                 11(09)        based           structure                level 3 packed unaligned dcl 4-3
variable                 65            based           pointer                  level 3 in structure "machine_state" packed
                                                                                  unaligned dcl 2-6 in procedure "expmac" set ref
                                                                                  1712*
variable                160            based           pointer                  array level 3 in structure "machine_state" packed
                                                                                  unaligned dcl 2-6 in procedure "expmac" ref 2229
varying_ref               0(10)        based           bit(1)                   level 2 packed unaligned dcl 4-3 ref 1480 1545
which_base                      000024 constant        fixed bin(17,0)          initial array dcl 11-14 set ref 886*
word_                                  constant        fixed bin(3,0)           initial dcl 8-5 ref 2063
x                        11(25)        based           bit(1)                   array level 4 in structure "reference" packed
                                                                                  unaligned dcl 4-3 in procedure "expmac" ref 2181
                                                                                  2187
x                         0(09) 000167 automatic       bit(1)                   array level 3 in structure "info" packed unaligned
                                                                                  dcl 101 in procedure "expmac" set ref 896
xec_eis                   1(21)        based           bit(1)                   level 2 in structure "macro_def" packed unaligned
                                                                                  dcl 271 in procedure "expmac" ref 1520
xec_eis                         000253 automatic       bit(1)                   dcl 1399 in procedure "expmac" set ref 858 912 1520*
                                                                                  1521 1545 1587 1654
xr18_to_q                              constant        fixed bin(15,0)          initial dcl 127 ref 2192
xr_to_q                                constant        fixed bin(15,0)          initial dcl 127 ref 2194
zero_mac                               constant        fixed bin(15,0)          initial dcl 127 ref 361 2203

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ab                                     defined         bit(3)                   dcl 11-9
ap                                     defined         bit(3)                   dcl 11-4
array_node                             internal static bit(9)                   initial dcl 3-5
bases                                  internal static bit(3)                   initial array dcl 11-1
bb                                     defined         bit(3)                   dcl 11-9
bit_                                   internal static fixed bin(3,0)           initial dcl 8-5
bit_string                             internal static fixed bin(15,0)          initial dcl 7-1
bits_per_four_words                    internal static fixed bin(8,0)           initial dcl 9-5
bits_per_half                          internal static fixed bin(8,0)           initial dcl 9-5
bits_per_packed_digit                  internal static fixed bin(8,1)           initial dcl 9-35
bits_per_two_words                     internal static fixed bin(8,0)           initial dcl 9-5
bits_per_words                         internal static fixed bin(8,0)           initial array dcl 9-5
block_node                             internal static bit(9)                   initial dcl 3-5
bound_node                             internal static bit(9)                   initial dcl 3-5
bp                                     defined         bit(3)                   dcl 11-4
break_even_bits                        internal static fixed bin(8,0)           initial dcl 9-5
break_even_words                       internal static fixed bin(8,0)           initial dcl 9-5
by_name_agg_node                       internal static bit(9)                   initial dcl 3-5
character_                             internal static fixed bin(3,0)           initial dcl 8-5
chars_per_word                         internal static fixed bin(8,0)           initial dcl 9-5
complex_fix_bin_1                      internal static fixed bin(15,0)          initial dcl 7-1
complex_fix_bin_2                      internal static fixed bin(15,0)          initial dcl 7-1
complex_flt_bin_1                      internal static fixed bin(15,0)          initial dcl 7-1
complex_flt_bin_2                      internal static fixed bin(15,0)          initial dcl 7-1
context_node                           internal static bit(9)                   initial dcl 3-5
convert_offset                         internal static fixed bin(8,1)           initial array dcl 9-35
cross_reference_node                   internal static bit(9)                   initial dcl 3-5
default_node                           internal static bit(9)                   initial dcl 3-5
digit_                                 internal static fixed bin(3,0)           initial dcl 8-5
entry_variable                         internal static fixed bin(15,0)          initial dcl 7-1
ext_entry_in                           internal static fixed bin(15,0)          initial dcl 7-1
ext_entry_out                          internal static fixed bin(15,0)          initial dcl 7-1
format_value_node                      internal static bit(9)                   initial dcl 3-5
half_                                  internal static fixed bin(3,0)           initial dcl 8-5
ind_string_aq                          internal static fixed bin(17,0)          initial dcl 2-68
int_entry                              internal static fixed bin(15,0)          initial dcl 7-1
int_entry_other                        internal static fixed bin(15,0)          initial dcl 7-1
label_array_element_node               internal static bit(9)                   initial dcl 3-5
label_constant                         internal static fixed bin(15,0)          initial dcl 7-1
label_size                             internal static fixed bin(8,0)           initial dcl 9-5
label_variable                         internal static fixed bin(15,0)          initial dcl 7-1
lb                                     defined         bit(3)                   dcl 11-9
list_node                              internal static bit(9)                   initial dcl 3-5
local_label_variable                   internal static fixed bin(15,0)          initial dcl 7-1
lp                                     defined         bit(3)                   dcl 11-4
machine_state_node                     internal static bit(9)                   initial dcl 3-5
max_index_register_value               internal static fixed bin(31,0)          initial dcl 9-38
max_length_p                           internal static fixed bin(8,0)           initial dcl 9-5
max_number_of_operands                 internal static fixed bin(15,0)          initial dcl 6-15
max_offset                             internal static fixed bin(8,0)           initial array dcl 9-5
max_p_fix_bin_1                        internal static fixed bin(8,0)           initial dcl 9-5
max_p_fix_dec                          internal static fixed bin(8,0)           initial dcl 9-5
max_p_flt_bin_1                        internal static fixed bin(8,0)           initial dcl 9-5
max_p_xreg                             internal static fixed bin(8,0)           initial dcl 9-5
max_short_size                         internal static fixed bin(8,0)           initial array dcl 9-5
mod2_                                  internal static fixed bin(3,0)           initial dcl 8-5
mod4_                                  internal static fixed bin(3,0)           initial dcl 8-5
op_names_pt                            automatic       pointer                  dcl 1-3
operator_names                         based           structure                level 1 dcl 1-5
operator_node                          internal static bit(9)                   initial dcl 3-5
packed_digits_per_char                 internal static fixed bin(8,0)           initial dcl 9-5
packed_digits_per_word                 internal static fixed bin(8,0)           initial dcl 9-5
packed_ptr                             internal static fixed bin(15,0)          initial dcl 7-1
rc_dp                                  internal static bit(6)                   initial unaligned dcl 10-6
rc_e                                   internal static bit(6)                   initial unaligned dcl 10-6
rc_is15                                internal static bit(6)                   initial unaligned dcl 10-6
rc_is18                                internal static bit(6)                   initial unaligned dcl 10-6
rc_lb                                  internal static bit(6)                   initial unaligned dcl 10-6
rc_lp15                                internal static bit(6)                   initial unaligned dcl 10-6
rc_lp18                                internal static bit(6)                   initial unaligned dcl 10-6
rc_nlb                                 internal static bit(6)                   initial unaligned dcl 10-6
rc_nlp18                               internal static bit(6)                   initial unaligned dcl 10-6
rc_ns                                  internal static bit(6)                   initial unaligned dcl 10-6
rc_nt                                  internal static bit(6)                   initial unaligned dcl 10-6
rc_s                                   internal static bit(6)                   initial unaligned dcl 10-6
rc_sr                                  internal static bit(6)                   initial unaligned dcl 10-6
rc_t                                   internal static bit(6)                   initial unaligned dcl 10-6
real_flt_bin_1                         internal static fixed bin(15,0)          initial dcl 7-1
real_flt_bin_2                         internal static fixed bin(15,0)          initial dcl 7-1
real_flt_dec                           internal static fixed bin(15,0)          initial dcl 7-1
reference_node                         internal static bit(9)                   initial dcl 3-5
sb                                     defined         bit(3)                   dcl 11-9
sf_par_node                            internal static bit(9)                   initial dcl 3-5
source_node                            internal static bit(9)                   initial dcl 3-5
sp                                     defined         bit(3)                   dcl 11-4
statement_node                         internal static bit(9)                   initial dcl 3-5
symbol_node                            internal static bit(9)                   initial dcl 3-5
temporary_node                         internal static bit(9)                   initial dcl 3-5
token_node                             internal static bit(9)                   initial dcl 3-5
units_per_word                         internal static fixed bin(8,0)           initial array dcl 9-5
unpacked_ptr                           internal static fixed bin(15,0)          initial dcl 7-1

NAMES DECLARED BY EXPLICIT CONTEXT.
call_base_man                   005737 constant        entry                    internal dcl 1979 ref 1795 1839
call_ma                         006022 constant        entry                    internal dcl 2004 ref 1298 1801
change_base_                    006643 constant        entry                    internal dcl 2216 ref 886 890
copy                            005414 constant        label                    dcl 1845 ref 1814 1817
done                            001470 constant        label                    dcl 789 ref 524 526 528 530 532 534 537 539 541 543
                                                                                  546 597 604 611 621 647 660 672 722 731 755 767
                                                                                  776 1020 1135 1212 1759
error315                        006624 constant        entry                    internal dcl 2209 ref 1495 2171 2183
expmac                          000125 constant        entry                    external dcl 63
expmac$abs                      002373 constant        entry                    external dcl 1022
expmac$conditional              002462 constant        entry                    external dcl 1078
expmac$eis                      003632 constant        entry                    external dcl 1389
expmac$fill_usage               003552 constant        entry                    external dcl 1360
expmac$interpret                002446 constant        entry                    external dcl 1046
expmac$many                     000221 constant        entry                    external dcl 387
expmac$many_eis                 003723 constant        entry                    external dcl 1463
expmac$one                      000277 constant        entry                    external dcl 407 ref 1493
expmac$one_eis                  003657 constant        entry                    external dcl 1445
expmac$two_eis                  003677 constant        entry                    external dcl 1452
expmac$zero                     002207 constant        entry                    external dcl 948
f1                              003147 constant        label                    dcl 1230 ref 1265
f2                              003157 constant        label                    dcl 1234 ref 1271 1278 1294
f3                              003267 constant        label                    dcl 1254 ref 1287 1342
ga                              001102 constant        label                    dcl 644 ref 625 637
init                            002516 constant        label                    dcl 1092 ref 1076
is_dl                           006236 constant        label                    dcl 2091 ref 2127
join                            000355 constant        label                    dcl 429 ref 405
join_eis                        003740 constant        label                    dcl 1471 ref 1443 1450 1461
l1                              001446 constant        label                    dcl 774 ref 591 614 634 642 666 694 700 725 733 744
                                                                                  761 771
l2                              005721 constant        label                    dcl 1969 ref 1910 1915 1929 1935 1942 1961
l3                              005733 constant        label                    dcl 1975 ref 1796 1881 1883 1885 1887 1889 1891 1958
                                                                                  1967
l4                              002361 constant        label                    dcl 1016 ref 1007
l7                              000746 constant        label                    dcl 588 set ref 581
loop                            002576 constant        label                    dcl 1115 ref 1119 1186 1216 1333
m1                              001316 constant        label                    dcl 733 ref 680 707
next                            003065 constant        label                    dcl 1184 ref 1141 1259 1316 1350 1358
normal                          000271 constant        label                    dcl 403 ref 423
prev                            005665 constant        label                    dcl 1952 ref 1906
put_word                        005235 constant        entry                    internal dcl 1763 ref 786 1118 1755
save_temp                       006427 constant        entry                    internal dcl 2158 ref 380 1501
set_offset                      006060 constant        entry                    internal dcl 2018 ref 1378 2152
set_one                         000310 constant        label                    dcl 414 ref 349 352 354 356 359 361 363 365 367 369
                                                                                  371 373 385
so                              006334 constant        label                    dcl 2131 ref 2054 2063 2086 2106 2112 2121
so1                             006337 constant        label                    dcl 2134 ref 2047 2050 2052 2060
so2                             006417 constant        label                    dcl 2152 ref 2045
step                            005170 constant        label                    dcl 1736 ref 1617
sw                              000000 constant        label                    array(0:16) dcl 1135 ref 1131 1191 1223
test                            002650 constant        label                    dcl 1154 ref 1147
text_ref                        006105 constant        entry                    internal dcl 2032 ref 509 1722 1857
tls                             001072 constant        label                    dcl 640 ref 628
unknown                         000362 constant        label                    dcl 435 ref 429 953 955 1508 1510

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      7572        7724    6737        7602
Length     10476    6737       132         535     632           4

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
expmac                              357 external procedure  is an external procedure.  
put_word                                internal procedure  shares stack frame of external procedure expmac.  
call_base_man                           internal procedure  shares stack frame of external procedure expmac.  
call_ma                                 internal procedure  shares stack frame of external procedure expmac.  
set_offset                              internal procedure  shares stack frame of external procedure expmac.  
text_ref                                internal procedure  shares stack frame of external procedure expmac.  
save_temp                               internal procedure  shares stack frame of external procedure expmac.  
error315                                internal procedure  shares stack frame of external procedure expmac.  
change_base_                            internal procedure  shares stack frame of external procedure expmac.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 als_ins                     expmac
000011 lls_ins                     expmac
000012 anaq_ap                     expmac

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
expmac                   000100 PR                          expmac
                         000102 arg_blk                     expmac
                         000104 p                           expmac
                         000106 q                           expmac
                         000110 q2                          expmac
                         000112 mac_pt                      expmac
                         000114 ref_pt                      expmac
                         000116 output_pt                   expmac
                         000120 sym_use_pt                  expmac
                         000122 reloc_pt                    expmac
                         000124 text_pt                     expmac
                         000126 b72                         expmac
                         000130 addressable                 expmac
                         000131 found                       expmac
                         000132 hold_perm_address           expmac
                         000133 made_perm_addressable       expmac
                         000134 mop                         expmac
                         000135 s1                          expmac
                         000136 s2                          expmac
                         000137 n                           expmac
                         000140 inst                        expmac
                         000141 rhs                         expmac
                         000142 erase                       expmac
                         000143 not_constant                expmac
                         000144 eis                         expmac
                         000145 count_arg                   expmac
                         000146 constant_value              expmac
                         000147 fw                          expmac
                         000150 const_string                expmac
                         000151 i                           expmac
                         000152 j                           expmac
                         000153 k                           expmac
                         000154 num_args                    expmac
                         000155 text_pos                    expmac
                         000156 first_pos                   expmac
                         000157 size                        expmac
                         000160 shift_amount                expmac
                         000161 inc                         expmac
                         000162 offset                      expmac
                         000164 k71                         expmac
                         000166 mac                         expmac
                         000167 info                        expmac
                         000170 m_s_p                       expmac
                         000172 b1                          expmac
                         000173 b2                          expmac
                         000174 b3                          expmac
                         000175 depth                       expmac
                         000176 code                        expmac
                         000200 stack                       expmac
                         000224 rand                        expmac
                         000234 sp_erase                    expmac
                         000235 use                         expmac
                         000236 prev_use                    expmac
                         000237 lreg                        expmac
                         000242 len                         expmac
                         000245 count                       expmac
                         000250 cat                         expmac
                         000251 length_in_q                 expmac
                         000252 compare                     expmac
                         000253 xec_eis                     expmac
                         000254 nwords                      expmac
                         000255 type                        expmac
                         000256 ichar                       expmac
                         000257 ibit                        expmac
                         000260 scale                       expmac
                         000262 ptarray                     expmac
                         000266 mod_factor                  expmac
                         000310 inc_orig                    put_word
                         000320 hold_perm_address           call_base_man
                         000336 pt                          set_offset
                         000346 q                           text_ref
                         000350 s                           text_ref
                         000352 offset                      text_ref
                         000353 temp                        text_ref
                         000362 i                           save_temp
                         000363 mac                         save_temp
                         000400 k                           change_base_
                         000402 q                           change_base_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              r_ne_as             unpk_to_pk          call_ext_in         call_ext_out
return              mod_fx1             ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
adjust_ref_count              aq_man$lock                   aq_man$save_aq                base_man$load_var
c_a                           cg_error                      compile_exp                   compile_exp$save
constant_zero                 copy_temp                     error                         expmac
expmac$zero                   expmac_test                   load                          load_size$xr_or_aq
m_a                           make_n_addressable            need_temp                     power_of_two
state_man$erase_reg           state_man$unlock

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
cg_stat$complex_ac            cg_stat$cur_node              cg_stat$cur_statement         cg_stat$eis_temp
cg_stat$last_macro            cg_stat$max_program_size      cg_stat$sym_use_base          cg_stat$text_base
cg_stat$text_pos              cg_stat$text_reloc_base       cg_stat$used_operator         cg_static_$m_s_p
instruction_info_$instruction_info                          instruction_info_$operators   macro_table_$macro_count
macro_table_$macro_table      pl1_operator_names_$last




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     79 000111    2    3 000113        63 000121       344 000133       346 000134       347 000140       349 000143
    352 000147       354 000152       356 000155       359 000160       361 000163       363 000165       365 000167
    367 000173       369 000177       371 000203       373 000205       380 000207       381 000210       385 000214
    387 000215       392 000227       394 000232       395 000235       397 000236       398 000245       399 000251
    401 000267       403 000271       405 000274       407 000275       412 000305       414 000310       417 000312
    418 000315       421 000334       423 000336       425 000340       427 000351       429 000355       433 000357
    435 000362       437 000375       440 000376       442 000377       443 000403       446 000405       447 000415
    448 000421       451 000444       453 000446       455 000452       458 000462       459 000464       461 000465
    465 000471       467 000475       468 000500       471 000504       473 000510       474 000515       478 000516
    480 000521       481 000523       482 000531       485 000533       486 000542       487 000546       489 000552
    490 000555       495 000557       496 000562       497 000564       499 000570       500 000572       503 000577
    504 000603       506 000614       508 000617       509 000620       512 000621       513 000626       515 000631
    520 000641       522 000643       524 000646       526 000651       528 000653       530 000655       532 000657
    534 000661       537 000663       539 000666       541 000670       543 000672       546 000704       549 000707
    550 000712       574 000715       576 000724       578 000727       580 000734       581 000737       584 000740
    586 000742       588 000746       590 000750       591 000756       594 000760       596 000764       597 000766
    600 000767       602 000773       603 000775       604 000777       607 001000       609 001003       610 001005
    611 001007       614 001010       617 001011       618 001023       620 001026       621 001030       624 001031
    625 001036       628 001041       630 001044       631 001052       633 001055       634 001060       636 001065
    637 001071       640 001072       642 001077       644 001102       646 001112       647 001114       650 001115
    655 001117       656 001122       657 001134       659 001137       660 001141       664 001142       666 001145
    671 001151       672 001164       678 001165       680 001172       684 001176       685 001177       687 001207
    694 001214       697 001222       698 001224       700 001232       707 001236       710 001243       712 001254
    714 001255       717 001262       718 001263       719 001266       720 001271       722 001273       725 001274
    728 001301       730 001310       731 001315       733 001316       742 001320       744 001323       747 001333
    750 001361       752 001370       754 001374       755 001402       759 001403       760 001406       761 001416
    764 001420       766 001423       767 001434       770 001435       771 001445       774 001446       776 001447
    781 001450       782 001454       784 001456       786 001465       787 001466       789 001470       792 001503
    794 001525       796 001527       799 001545       801 001555       802 001561       803 001572       804 001575
    811 001600       814 001631       816 001635       819 001643       828 001647       830 001666       832 001670
    835 001707       836 001711       838 001712       841 001721       843 001724       844 001726       846 001730
    849 001732       852 001737       853 001740       858 001745       866 001753       869 001762       871 001767
    872 001772       875 001774       877 002000       878 002003       881 002005       883 002016       886 002025
    889 002042       890 002047       892 002056       895 002060       896 002065       898 002071       899 002076
    900 002100       902 002103       904 002105       907 002113       911 002116       912 002123       916 002131
    921 002133       928 002141       929 002144       931 002153       935 002161       936 002163       939 002165
    941 002167       943 002172       946 002203       948 002204       951 002215       953 002222       955 002224
    958 002226       959 002227       961 002230       963 002234       966 002236       968 002241       971 002250
    973 002253       974 002257       975 002265       979 002271       981 002273       982 002305       985 002306
    986 002313       987 002323       988 002325      1000 002326      1003 002335      1004 002340      1006 002345
   1007 002351      1012 002352      1013 002355      1014 002360      1016 002361      1018 002364      1020 002366
   1022 002367      1030 002401      1033 002404      1038 002406      1040 002421      1041 002423      1044 002440
   1046 002441      1075 002454      1076 002457      1078 002460      1081 002470      1083 002477      1085 002502
   1088 002511      1092 002516      1094 002522      1095 002530      1096 002534      1098 002540      1100 002546
   1101 002551      1102 002553      1105 002557      1107 002571      1108 002573      1109 002574      1111 002575
   1115 002576      1118 002601      1119 002602      1124 002603      1125 002607      1126 002612      1127 002615
   1128 002621      1131 002632      1135 002634      1139 002636      1140 002641      1141 002643      1145 002644
   1147 002646      1151 002647      1154 002650      1157 002663      1159 002676      1161 002711      1163 002724
   1165 002737      1167 002752      1169 002770      1171 003006      1173 003017      1175 003030      1177 003041
   1179 003061      1184 003065      1186 003070      1191 003071      1195 003072      1197 003076      1198 003100
   1200 003101      1201 003103      1202 003105      1204 003106      1205 003113      1206 003116      1208 003121
   1212 003132      1215 003134      1216 003137      1220 003140      1222 003141      1223 003145      1227 003146
   1230 003147      1232 003156      1234 003157      1237 003162      1239 003203      1241 003213      1244 003240
   1247 003251      1248 003252      1249 003257      1250 003261      1251 003263      1252 003264      1254 003267
   1256 003272      1257 003276      1258 003302      1259 003306      1263 003307      1265 003311      1269 003312
   1271 003316      1275 003317      1277 003321      1278 003324      1282 003325      1285 003330      1287 003344
   1291 003345      1293 003347      1294 003351      1298 003352      1302 003357      1303 003362      1305 003371
   1306 003373      1309 003400      1310 003404      1312 003407      1313 003411      1314 003414      1315 003417
   1316 003420      1320 003421      1323 003427      1325 003440      1327 003451      1329 003462      1332 003472
   1333 003500      1337 003501      1340 003504      1341 003506      1342 003514      1346 003515      1350 003526
   1354 003527      1358 003545      1360 003546      1366 003560      1367 003563      1368 003566      1369 003573
   1371 003577      1373 003602      1374 003604      1375 003612      1378 003616      1379 003624      1380 003626
   1382 003627      1389 003630      1439 003640      1440 003642      1441 003646      1442 003652      1443 003654
   1445 003655      1448 003665      1449 003667      1450 003672      1452 003673      1457 003705      1458 003707
   1459 003713      1460 003716      1461 003720      1463 003721      1466 003731      1468 003734      1469 003737
   1471 003740      1473 003742      1478 003743      1479 003751      1480 003755      1486 004010      1488 004031
   1489 004037      1490 004042      1491 004050      1493 004056      1494 004077      1495 004100      1496 004101
   1497 004102      1501 004124      1502 004125      1506 004127      1508 004132      1510 004133      1513 004136
   1514 004142      1517 004144      1518 004150      1519 004154      1520 004160      1521 004164      1523 004170
   1524 004172      1529 004210      1534 004221      1535 004231      1537 004235      1539 004237      1540 004242
   1541 004244      1542 004245      1545 004253      1548 004277      1551 004312      1553 004345      1556 004367
   1558 004371      1560 004373      1561 004375      1564 004400      1565 004404      1568 004414      1570 004417
   1571 004422      1572 004430      1573 004434      1575 004440      1577 004443      1581 004450      1582 004452
   1584 004453      1585 004454      1587 004460      1589 004462      1590 004473      1591 004477      1592 004500
   1596 004502      1598 004511      1599 004514      1600 004517      1602 004522      1604 004525      1605 004531
   1610 004535      1613 004537      1616 004546      1617 004562      1620 004563      1621 004565      1624 004572
   1625 004574      1636 004600      1638 004601      1639 004604      1641 004612      1644 004622      1645 004623
   1648 004633      1651 004646      1654 004650      1657 004660      1659 004665      1660 004667      1661 004670
   1663 004671      1664 004674      1667 004700      1671 004724      1672 004732      1673 004737      1676 004745
   1678 004750      1682 004772      1685 004777      1688 005015      1689 005022      1690 005026      1692 005032
   1693 005037      1695 005045      1696 005047      1698 005053      1702 005064      1703 005065      1708 005102
   1711 005112      1712 005114      1714 005116      1715 005117      1717 005121      1718 005125      1722 005132
   1725 005136      1726 005143      1728 005146      1730 005164      1733 005165      1734 005167      1736 005170
   1741 005172      1743 005177      1747 005201      1749 005203      1750 005206      1751 005211      1752 005214
   1753 005217      1754 005220      1755 005231      1756 005232      1759 005234      1763 005235      1770 005236
   1771 005242      1773 005246      1776 005252      1777 005256      1781 005267      1784 005271      1787 005300
   1788 005314      1793 005315      1795 005320      1796 005321      1801 005322      1804 005325      1806 005330
   1814 005335      1817 005337      1820 005342      1825 005346      1826 005354      1828 005357      1831 005361
   1832 005364      1833 005367      1834 005372      1835 005373      1836 005374      1838 005375      1839 005410
   1840 005411      1845 005414      1850 005416      1851 005420      1853 005422      1854 005424      1857 005431
   1859 005436      1863 005460      1865 005471      1866 005476      1868 005501      1871 005516      1874 005517
   1875 005521      1876 005523      1879 005524      1881 005527      1883 005532      1885 005534      1887 005536
   1889 005540      1891 005542      1895 005544      1902 005547      1904 005552      1905 005554      1906 005560
   1910 005563      1913 005565      1915 005575      1919 005601      1920 005602      1922 005612      1929 005617
   1932 005625      1933 005627      1935 005635      1942 005641      1945 005646      1947 005657      1949 005660
   1952 005665      1954 005666      1955 005671      1956 005674      1958 005676      1961 005677      1964 005704
   1966 005713      1967 005720      1969 005721      1971 005724      1972 005727      1973 005732      1975 005733
   1977 005736      1979 005737      1984 005740      1986 005743      1988 005745      1989 005752      1992 005754
   1994 005772      1997 006002      1998 006005      1999 006011      2000 006015      2002 006021      2004 006022
   2007 006023      2009 006026      2011 006040      2012 006043      2013 006047      2014 006053      2016 006057
   2018 006060      2024 006062      2026 006064      2028 006075      2030 006104      2032 006105      2039 006106
   2041 006110      2043 006117      2044 006120      2045 006123      2047 006127      2050 006133      2052 006136
   2054 006141      2057 006144      2059 006145      2060 006147      2063 006153      2067 006162      2069 006172
   2071 006202      2073 006204      2076 006211      2078 006213      2081 006221      2082 006224      2084 006230
   2086 006231      2089 006232      2091 006236      2093 006242      2095 006245      2098 006246      2100 006251
   2101 006254      2103 006257      2106 006260      2109 006262      2110 006264      2112 006266      2115 006272
   2117 006300      2119 006305      2121 006312      2125 006316      2126 006322      2127 006333      2131 006334
   2134 006337      2137 006343      2139 006351      2140 006364      2142 006365      2143 006375      2145 006377
   2146 006401      2147 006405      2148 006412      2149 006413      2150 006416      2152 006417      2155 006426
   2158 006427      2169 006430      2171 006434      2174 006442      2175 006444      2176 006451      2178 006462
   2181 006463      2183 006466      2184 006467      2187 006470      2188 006502      2190 006504      2192 006510
   2194 006520      2195 006522      2196 006537      2197 006550      2198 006563      2201 006564      2202 006567
   2203 006574      2204 006607      2206 006623      2209 006624      2212 006625      2214 006642      2216 006643
   2223 006645      2226 006656      2227 006657      2229 006661      2230 006663      2231 006665      2234 006672
   2236 006702      2239 006710      2241 006711


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
