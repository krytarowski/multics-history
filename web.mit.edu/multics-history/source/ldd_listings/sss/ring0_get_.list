	COMPILATION LISTING OF SEGMENT ring0_get_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/20/86  1203.3 mst Thu
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 ring0_get_: proc;
       12 
       13 /* "Adjusted" by Bernard Greenberg, for hc def seg 07/22/76 */
       14 
       15 dcl (sltp1, names_ptr1, defs_ptr1) ptr static init (null),
       16     (names_ptr2, defs_ptr2) ptr,
       17     (a_defsp, a_sltp, a_namep, defp, defsp) ptr,
       18     (i, j) fixed bin,
       19      hcs_$initiate ext entry (char (*), char (*), char (*), fixed bin, fixed bin, ptr, fixed bin),
       20      get_definition_ entry (ptr, char (*), char (*), ptr, fixed bin);
       21 
       22 dcl  based_bit18 bit (18) aligned based dim (0:511);
       23 dcl  a_defname char (*),
       24      a_offset fixed bin (18),
       25      a_type fixed bin;
       26 
       27 
       28 
       29 dcl (error_table_$no_defs, error_table_$noentry) fixed bin (35) ext;
       30 dcl  error_table_$invalidsegno fixed bin (35) ext;
       31 
       32 dcl  segptr ptr,
       33      code fixed bin,
       34      entryptr ptr,
       35      dir char (*),
       36      entry char (*);
       37 
       38 dcl  SLDIR char (55) init (">system_library_1") static options (constant);
       39 
       40 
       41 dcl (addr, addrel, baseno, baseptr, fixed, length, null, reverse, verify) builtin;
       42 
       43 
       44 /*  */
       45 
       46 segptr:	entry (dir, entry, segptr, code);		/* entry to return segment pointer */
       47 
       48 	call get_static_ptrs ("0"b);
       49 	segptr = get_segptr ();
       50 	return;
       51 
       52 
       53 name:	entry (dir, entry, segptr, code);		/* entry to return segment name */
       54 
       55 	call get_static_ptrs ("0"b);
       56 	call get_name (segptr, "0"b);			/* 0 => one */
       57 	return;
       58 
       59 names:	entry (dir, entryptr, segptr, code);		/* entry to return pointer to names */
       60 
       61 	call get_static_ptrs ("0"b);
       62 	call get_name (segptr, "1"b);			/* 1 => many */
       63 	return;
       64 
       65 definition: entry (segptr, entry, a_defname, a_offset, a_type, code);
       66 
       67 	call get_static_ptrs ("1"b);			/* 1 => get defs ptr */
       68 	if segptr = null then segptr = get_segptr ();
       69 	call get_definition (segptr);
       70 	return;
       71 
       72 
       73 
       74 /* The following entries are the same as the above except that the caller
       75*   supplies a pointer to the SLT and NAME TABLE to use */
       76 
       77 segptr_given_slt: entry (dir, entry, segptr, code, a_sltp, a_namep);
       78 
       79 	call get_param_ptrs ("0"b);
       80 	segptr = get_segptr ();
       81 	return;
       82 
       83 name_given_slt: entry (dir, entry, segptr, code, a_sltp, a_namep);
       84 
       85 	call get_param_ptrs ("0"b);
       86 	call get_name (segptr, "0"b);
       87 	return;
       88 
       89 
       90 definition_given_slt: entry (segptr, entry, a_defname, a_offset, a_type, code, a_sltp, a_namep, a_defsp);
       91 
       92 	call get_param_ptrs ("1"b);
       93 	if segptr = null then segptr = get_segptr ();	/* Look up entry if needed */
       94 	call get_definition (segptr);
       95 	return;
       96 
       97 /*  */
       98 get_static_ptrs: proc (we_want_defs);
       99 
      100 dcl  we_want_defs bit (1) aligned;			/* T => call for defs */
      101 
      102 	     code = 0;
      103 	     if we_want_defs & defs_ptr1 = null then call init_static_ptrs;
      104 	     else if names_ptr1 = null then call init_static_ptrs;
      105 	     if code ^= 0 then go to error;
      106 	     sltp = sltp1;
      107 	     names_ptr2 = names_ptr1;
      108 	     defs_ptr2 = defs_ptr1;
      109 	     return;
      110 
      111 init_static_ptrs: proc;
      112 		call hcs_$initiate (SLDIR, "slt", "", 0, 1, sltp1, code);
      113 		if sltp1 = null then return;
      114 		call hcs_$initiate (SLDIR, "name_table", "", 0, 1, names_ptr1, code);
      115 		if names_ptr1 = null then return;
      116 		if we_want_defs then do;
      117 		     call hcs_$initiate (SLDIR, "definitions_", "", 0, 1, defs_ptr1, code);
      118 		     if defs_ptr1 = null then return;
      119 		end;
      120 		code = 0;				/* Let's hear it for hcs_$initiate! */
      121 	     end init_static_ptrs;
      122 	end get_static_ptrs;
      123 
      124 get_param_ptrs: proc (we_want_defs);
      125 
      126 dcl  we_want_defs bit (1) aligned;			/* We want definitions */
      127 	     sltp = a_sltp;
      128 	     names_ptr2 = a_namep;
      129 	     if we_want_defs then defs_ptr2 = a_defsp;
      130 	end get_param_ptrs;
      131 
      132 get_segptr: procedure returns (ptr);
      133 
      134 
      135 	     do i = slt.first_sup_seg to slt.last_sup_seg; /* loop through sup segs searching */
      136 		sltep = addr (slt.seg (i));		/* get pointer to SLT entry */
      137 		namep = addrel (names_ptr2, slte.names_ptr); /* get pointer to names for this segment */
      138 		do j = 1 to namep -> segnam.count;	/* search all names */
      139 		     if entry = namep -> segnam.names (j).name then do; /* found it */
      140 			code = 0;
      141 			return (baseptr (i));
      142 		     end;
      143 		end;
      144 	     end;
      145 
      146 	     code = error_table_$noentry;
      147 	     go to error_segptr;
      148 	end get_segptr;
      149 
      150 get_name:	procedure (sp, many);
      151 
      152 dcl  many bit (1) aligned, sp ptr;
      153 
      154 	     i = bin (baseno (sp));			/* get input segment number */
      155 	     if i > slt.last_sup_seg | i < slt.first_sup_seg then do; /* bad input segment number */
      156 		code = error_table_$invalidsegno;
      157 		return;
      158 	     end;
      159 
      160 	     sltep = addr (slt.seg (i));		/* get pointer to SLT entry */
      161 	     pathp = addrel (names_ptr2, slte.path_ptr);
      162 	     namep = addrel (names_ptr2, slte.names_ptr);
      163 	     if pathp ^= names_ptr2 then dir = pathp -> path.name; else dir = ""; /* return path name */
      164 	     if many then entryptr = namep;
      165 	     else entry = namep -> segnam.names (1).name; /* return only one name */
      166 	     code = 0;
      167 	end get_name;
      168 
      169 get_definition: procedure (textp);
      170 dcl  textp ptr;
      171 
      172 	     code = 0;
      173 	     i = bin (baseno (textp));
      174 	     if i < 4 | i > 511 then code = error_table_$no_defs;
      175 	     else do;
      176 		defsp = addrel (defs_ptr2, defs_ptr2 -> based_bit18 (i));
      177 		if defsp = defs_ptr2 then code = error_table_$no_defs;
      178 		else do;
      179 		     call get_definition_ (defsp, entry, a_defname, defp, code);
      180 		     if code = 0 then do;
      181 			a_type = fixed (defp -> definition.class, 3);
      182 			a_offset = fixed (defp -> definition.value, 18);
      183 		     end;
      184 		end;
      185 	     end;
      186 
      187 	end get_definition;
      188 
      189 error_segptr: segptr = null;
      190 error:	return;
      191 						/*  */
  1     1 /* BEGIN INCLUDE FILE slt.incl.pl1 --- Last modified 2/76 SHW */
  1     2 
  1     3 /* Declarations for Segment Loading Table header and array.
  1     4*
  1     5*   Used by Initialization and MST Checker subroutines */
  1     6 
  1     7 dcl sltp ptr,					/* pointer to base of SLT segment */
  1     8     names_ptr ptr,					/* pointer to base of SLT names segment */
  1     9     namep ptr,					/* pointer to segment name list block */
  1    10     pathp ptr,					/* pointer to segment's directory path name */
  1    11     aclp ptr;					/* pointer to acl structure */
  1    12 
  1    13 declare 1 slt based (sltp) aligned,			/* declaration of Segment Loading Table (SLT) */
  1    14 	2 name_seg_ptr ptr,				/* words 0-1, pointer (ITS pair) to name segment */
  1    15 	2 free_core_start fixed bin (24),		/* word 2, start of free core after perm-wired */
  1    16 	2 first_sup_seg fixed bin (18),		/* word 3, first supervisor segment number */
  1    17 	2 last_sup_seg fixed bin (18), 		/* word 4, last supervisor segment number */
  1    18 	2 first_init_seg fixed bin (18),		/* word 5, first initializer segment number */
  1    19 	2 last_init_seg fixed bin (18),		/* word 6, last initializer segment number */
  1    20 	2 free_core_size fixed bin (24),		/* size (in words) of free core after perm-wired */
  1    21 	2 seg (0:8191) aligned,			/* segment entries (4 words each) */
  1    22 	  3 slte (4) fixed bin (35);			/* Space for SLT entries */
  1    23 
  1    24 /* auxiliary segment of SLT for storing of segment names and directory path names */
  1    25 
  1    26 declare 1 name_seg based (names_ptr) aligned,		/* name segment header */
  1    27 	2 pad bit (18) unal,
  1    28 	2 next_loc bit (18) unal,			/* Next available free location in name seg */
  1    29 	2 ht (0:127) bit (18) aligned;		/* Names hash table */
  1    30 
  1    31 declare 1 segnam based (namep) aligned,			/* declaration for segment name block */
  1    32 	2 count fixed bin (17),			/* number of segment names in this block */
  1    33 	2 names (50 refer (segnam.count)),		/* segment name array */
  1    34 	  3 hp bit (18) unal,			/* hash thread pointer */
  1    35 	  3 ref bit (1) unal,			/* "1"b if name referenced */
  1    36 	  3 pad bit (5) unal,
  1    37 	  3 segno bit (12) unal,			/* segment number associated with this name */
  1    38 	  3 name char (32) unal;			/* space for name (max 32 characters) */
  1    39 
  1    40 declare 1 path based (pathp) aligned,			/* declaration for directory path name */
  1    41 	2 size fixed bin (17),			/* length of pathname */
  1    42 	2 name char (168 refer (path.size)) unal,	/* directory path name */
  1    43 	2 acls fixed bin;				/* ACL list starts here */
  1    44 
  1    45 declare 1 acls based (aclp) aligned,			/* declaration for acl list */
  1    46 	2 count fixed bin,				/* number of entries in acl list */
  1    47 	2 acl (50 refer (acls.count)),		/* array of acl entries */
  1    48 	  3 userid char (32),			/* user specification */
  1    49 	  3 mode bit (36) aligned,			/* mode for the specified user */
  1    50 	  3 pad bit (36) aligned,
  1    51 	  3 code fixed bin;
  1    52 
  1    53 
  1    54 /* END INCLUDE FILE slt.incl.pl1 */
      192 
  2     1 /* BEGIN INCLUDE FILE slte.incl.pl1 */
  2     2 /* Declaration for Segment Loading Table Entry structure.
  2     3*   Used by Initialization, MST Generation, and MST Checker subroutines */
  2     4 /* modified 5/4/76 by Noel I. Morris	*/
  2     5 /* last modified 12/12/83 by Keith Loepere for breakpointable */
  2     6 /* format: style3 */
  2     7 
  2     8 dcl	sltep		ptr;
  2     9 
  2    10 dcl	1 slte_uns	based (sltep) aligned,
  2    11 	( 2 names_ptr	bit (18),			/* rel pointer to thread of names */
  2    12 	  2 path_ptr	bit (18),			/* rel pointer to pathname (if present) */
  2    13 /**** End of word 1 */
  2    14 	  2 access	bit (4),			/* SDW access bit (REWP) */
  2    15 	  2 cache		bit (1),			/* Segment to be allowed in cache */
  2    16 	  2 abs_seg	bit (1),			/* segment is an abs seg if ON */
  2    17 	  2 firmware_seg	bit (1),			/* load in low 256 */
  2    18 	  2 layout_seg	bit (1),			/* mailbox & such */
  2    19 	  2 breakpointable  bit (1),			/* includes breakpoint_page */
  2    20 	  2 pad1		bit (3),			/* unused */
  2    21 	  2 wired		bit (1),			/* segment is wired if ON */
  2    22 	  2 paged		bit (1),			/* segment is paged if ON */
  2    23 	  2 per_process	bit (1),			/* segment is per-process if ON */
  2    24 	  2 pad3		bit (2),
  2    25 	  2 acl_provided	bit (1),			/* ON if acl structure follows path_name on MST */
  2    26 /**** End of 1st half of word 2 */
  2    27 	  2 pad4		bit (3),
  2    28 	  2 branch_required bit (1),			/* path name supplied if ON */
  2    29 	  2 init_seg	bit (1),			/* segment is init_seg if ON */
  2    30 	  2 temp_seg	bit (1),			/* segment is temp_seg if ON */
  2    31 	  2 link_provided	bit (1),			/* linkage segment provided if ON */
  2    32 	  2 link_sect	bit (1),			/* segment is linkage segment if ON */
  2    33 	  2 link_sect_wired bit (1),			/* linkage segment is wired if ON */
  2    34 	  2 combine_link	bit (1),			/* linkage is combined if ON */
  2    35 	  2 pre_linked	bit (1),			/* lot entry has been made if ON */
  2    36 	  2 defs		bit (1),			/* segment is definitions segment if ON */
  2    37 /***** End of word 2 */
  2    38 	  2 pad5		bit (6),
  2    39 	  2 cur_length	fixed bin (9) uns,		/* current length of segment (in 1024 word blocks) */
  2    40 	  2 ringbrack	(3) fixed bin (3) uns,	/* ringbrackets */
  2    41 	  2 segno		fixed bin (18) uns,		/* text/link segment number */
  2    42 /***** End of word 3 */
  2    43 	  2 pad7		bit (3),
  2    44 	  2 max_length	fixed bin (9) uns,		/* maximum length for segment */
  2    45 	  2 bit_count	fixed bin (24) uns
  2    46 	  )		unaligned;		/* bitcount of segment */
  2    47 
  2    48 dcl	1 slte		based (sltep) aligned,
  2    49 	( 2 names_ptr	bit (18),			/* rel pointer to thread of names */
  2    50 	  2 path_ptr	bit (18),			/* rel pointer to pathname (if present) */
  2    51 	  2 access	bit (4),			/* SDW access bit (REWP) */
  2    52 	  2 cache		bit (1),			/* Segment to be allowed in cache */
  2    53 	  2 abs_seg	bit (1),			/* segment is an abs seg if ON */
  2    54 	  2 firmware_seg    bit (1),
  2    55 	  2 layout_seg      bit (1),
  2    56 	  2 breakpointable  bit (1),
  2    57 	  2 pad2		bit (3),
  2    58 	  2 wired		bit (1),			/* segment is wired if ON */
  2    59 	  2 paged		bit (1),			/* segment is paged if ON */
  2    60 	  2 per_process	bit (1),			/* segment is per-process if ON */
  2    61 	  2 pad3		bit (2),
  2    62 	  2 acl_provided	bit (1),			/* ON if acl structure follows path_name on MST */
  2    63 	  2 pad4		bit (3),
  2    64 	  2 branch_required bit (1),			/* path name supplied if ON */
  2    65 	  2 init_seg	bit (1),			/* segment is init_seg if ON */
  2    66 	  2 temp_seg	bit (1),			/* segment is temp_seg if ON */
  2    67 	  2 link_provided	bit (1),			/* linkage segment provided if ON */
  2    68 	  2 link_sect	bit (1),			/* segment is linkage segment if ON */
  2    69 	  2 link_sect_wired bit (1),			/* linkage segment is wired if ON */
  2    70 	  2 combine_link	bit (1),			/* linkage is combined if ON */
  2    71 	  2 pre_linked	bit (1),			/* lot entry has been made if ON */
  2    72 	  2 defs		bit (1),			/* segment is definitions segment if ON */
  2    73 	  2 pad5		bit (6),
  2    74 	  2 cur_length	bit (9),			/* current length of segment (in 1024 word blocks) */
  2    75 	  2 ringbrack	(3) bit (3),		/* ringbrackets */
  2    76 	  2 segno		bit (18),			/* text/link segment number */
  2    77 	  2 pad6		bit (3),
  2    78 	  2 max_length	bit (9),			/* maximum length for segment */
  2    79 	  2 bit_count	bit (24)
  2    80 	  )		unaligned;		/* bitcount of segment */
  2    81 
  2    82 /* END INCLUDE FILE slte.incl.pl1 */
      193 
  3     1 /* BEGIN INCLUDE FILE definition.incl.pl1 */
  3     2 
  3     3 
  3     4 
  3     5 /****^  HISTORY COMMENTS:
  3     6*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  3     7*     audit(86-07-18,DGHowe), install(86-11-20,MR12.0-1222):
  3     8*     Modified to add indirect bit to definition flags.
  3     9*                                                   END HISTORY COMMENTS */
  3    10 
  3    11 
  3    12 dcl	1 definition	aligned based,
  3    13 	2 forward		unal bit(18),	/* offset of next def */
  3    14 	2 backward	unal bit(18),	/* offset of previous def */
  3    15 	2 value		unal bit(18),
  3    16 	2 flags		unal,
  3    17 	  3 new		bit(1),
  3    18 	  3 ignore	bit(1),
  3    19 	  3 entry		bit(1),
  3    20 	  3 retain	bit(1),
  3    21 	  3 argcount	bit(1),
  3    22 	  3 descriptors	bit(1),
  3    23 	  3 indirect	bit(1),
  3    24 	  3 unused	bit(8),
  3    25 	2 class		unal bit(3),
  3    26 	2 symbol		unal bit(18),	/* offset of ACC for symbol */
  3    27 	2 segname		unal bit(18);	/* offset of segname def */
  3    28 
  3    29 /* END INCLUDE FILE definition.incl.pl1 */
      194 
      195      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/20/86  1145.0  ring0_get_.pl1                    >special_ldd>install>MR12.0-1222>ring0_get_.pl1
192          1    05/24/82  1005.0  slt.incl.pl1                      >ldd>include>slt.incl.pl1
193          2    07/11/84  0937.3  slte.incl.pl1                     >ldd>include>slte.incl.pl1
194          3    11/20/86  1035.2  definition.incl.pl1               >special_ldd>install>MR12.0-1222>definition.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
SLDIR                           000000 constant        char(55)                 initial unaligned dcl 38 set ref 112* 114* 117*
a_defname                              parameter       char                     unaligned dcl 23 set ref 65 90 179*
a_defsp                                parameter       pointer                  dcl 15 ref 90 129
a_namep                                parameter       pointer                  dcl 15 ref 77 83 90 128
a_offset                               parameter       fixed bin(18,0)          dcl 23 set ref 65 90 182*
a_sltp                                 parameter       pointer                  dcl 15 ref 77 83 90 127
a_type                                 parameter       fixed bin(17,0)          dcl 23 set ref 65 90 181*
addr                                                   builtin function         dcl 41 ref 136 160
addrel                                                 builtin function         dcl 41 ref 137 161 162 176
based_bit18                            based           bit(18)                  array dcl 22 ref 176
baseno                                                 builtin function         dcl 41 ref 154 173
baseptr                                                builtin function         dcl 41 ref 141
class                     1(33)        based           bit(3)                   level 2 packed unaligned dcl 3-12 ref 181
code                                   parameter       fixed bin(17,0)          dcl 32 set ref 46 53 59 65 77 83 90 102* 105 112*
                                                                                  114* 117* 120* 140* 146* 156* 166* 172* 174* 177*
                                                                                  179* 180
count                                  based           fixed bin(17,0)          level 2 dcl 1-31 ref 138
definition                             based           structure                level 1 dcl 3-12
defp                            000104 automatic       pointer                  dcl 15 set ref 179* 181 182
defs_ptr1                       000014 internal static pointer                  initial dcl 15 set ref 103 108 117* 118
defs_ptr2                       000102 automatic       pointer                  dcl 15 set ref 108* 129* 176 176 177
defsp                           000106 automatic       pointer                  dcl 15 set ref 176* 177 179*
dir                                    parameter       char                     unaligned dcl 32 set ref 46 53 59 77 83 163* 163*
entry                                  parameter       char                     unaligned dcl 32 set ref 46 53 65 77 83 90 139 165*
                                                                                  179*
entryptr                               parameter       pointer                  dcl 32 set ref 59 164*
error_table_$invalidsegno       000026 external static fixed bin(35,0)          dcl 30 ref 156
error_table_$no_defs            000022 external static fixed bin(35,0)          dcl 29 ref 174 177
error_table_$noentry            000024 external static fixed bin(35,0)          dcl 29 ref 146
first_sup_seg             3            based           fixed bin(18,0)          level 2 dcl 1-13 ref 135 155
fixed                                                  builtin function         dcl 41 ref 181 182
get_definition_                 000020 constant        entry                    external dcl 15 ref 179
hcs_$initiate                   000016 constant        entry                    external dcl 15 ref 112 114 117
i                               000110 automatic       fixed bin(17,0)          dcl 15 set ref 135* 136 141* 154* 155 155 160 173*
                                                                                  174 174 176
j                               000111 automatic       fixed bin(17,0)          dcl 15 set ref 138* 139*
last_sup_seg              4            based           fixed bin(18,0)          level 2 dcl 1-13 ref 135 155
many                                   parameter       bit(1)                   dcl 152 ref 150 164
name                      2            based           char(32)                 array level 3 in structure "segnam" packed unaligned
                                                                                  dcl 1-31 in procedure "ring0_get_" ref 139 165
name                      1            based           char                     level 2 in structure "path" packed unaligned
                                                                                  dcl 1-40 in procedure "ring0_get_" ref 163
namep                           000114 automatic       pointer                  dcl 1-7 set ref 137* 138 139 162* 164 165
names                     1            based           structure                array level 2 dcl 1-31
names_ptr                              based           bit(18)                  level 2 packed unaligned dcl 2-48 ref 137 162
names_ptr1                      000012 internal static pointer                  initial dcl 15 set ref 104 107 114* 115
names_ptr2                      000100 automatic       pointer                  dcl 15 set ref 107* 128* 137 161 162 163
null                                                   builtin function         dcl 41 ref 68 93 103 104 113 115 118 189
path                                   based           structure                level 1 dcl 1-40
path_ptr                  0(18)        based           bit(18)                  level 2 packed unaligned dcl 2-48 ref 161
pathp                           000116 automatic       pointer                  dcl 1-7 set ref 161* 163 163
seg                      10            based           structure                array level 2 dcl 1-13 set ref 136 160
segnam                                 based           structure                level 1 dcl 1-31
segptr                                 parameter       pointer                  dcl 32 set ref 46 49* 53 56* 59 62* 65 68 68* 69* 77
                                                                                  80* 83 86* 90 93 93* 94* 189*
size                                   based           fixed bin(17,0)          level 2 dcl 1-40 ref 163
slt                                    based           structure                level 1 dcl 1-13
slte                                   based           structure                level 1 dcl 2-48
sltep                           000120 automatic       pointer                  dcl 2-8 set ref 136* 137 160* 161 162
sltp                            000112 automatic       pointer                  dcl 1-7 set ref 106* 127* 135 135 136 155 155 160
sltp1                           000010 internal static pointer                  initial dcl 15 set ref 106 112* 113
sp                                     parameter       pointer                  dcl 152 ref 150 154
textp                                  parameter       pointer                  dcl 170 ref 169 173
value                     1            based           bit(18)                  level 2 packed unaligned dcl 3-12 ref 182
we_want_defs                           parameter       bit(1)                   dcl 100 in procedure "get_static_ptrs" ref 98 103
                                                                                  116
we_want_defs                           parameter       bit(1)                   dcl 126 in procedure "get_param_ptrs" ref 124 129

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
aclp                                   automatic       pointer                  dcl 1-7
acls                                   based           structure                level 1 dcl 1-45
length                                                 builtin function         dcl 41
name_seg                               based           structure                level 1 dcl 1-26
names_ptr                              automatic       pointer                  dcl 1-7
reverse                                                builtin function         dcl 41
slte_uns                               based           structure                level 1 dcl 2-10
verify                                                 builtin function         dcl 41

NAMES DECLARED BY EXPLICIT CONTEXT.
definition                      000236 constant        entry                    external dcl 65
definition_given_slt            000443 constant        entry                    external dcl 90
error                           000523 constant        label                    dcl 190 ref 105
error_segptr                    000521 constant        label                    dcl 189 ref 147
get_definition                  001170 constant        entry                    internal dcl 169 ref 69 94
get_name                        001074 constant        entry                    internal dcl 150 ref 56 62 86
get_param_ptrs                  000771 constant        entry                    internal dcl 124 ref 79 85 92
get_segptr                      001011 constant        entry                    internal dcl 132 ref 49 68 80 93
get_static_ptrs                 000524 constant        entry                    internal dcl 98 ref 48 55 61 67
init_static_ptrs                000561 constant        entry                    internal dcl 111 ref 103 104
name                            000120 constant        entry                    external dcl 53
name_given_slt                  000364 constant        entry                    external dcl 83
names                           000171 constant        entry                    external dcl 59
ring0_get_                      000043 constant        entry                    external dcl 11
segptr                          000056 constant        entry                    external dcl 46
segptr_given_slt                000316 constant        entry                    external dcl 77

NAME DECLARED BY CONTEXT OR IMPLICATION.
bin                                                    builtin function         ref 154 173

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1450        1500    1302        1460
Length      1750    1302        30         233     145           6

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ring0_get_                          234 external procedure  is an external procedure.  
get_static_ptrs                         internal procedure  shares stack frame of external procedure ring0_get_.  
init_static_ptrs                        internal procedure  shares stack frame of external procedure ring0_get_.  
get_param_ptrs                          internal procedure  shares stack frame of external procedure ring0_get_.  
get_segptr                              internal procedure  shares stack frame of external procedure ring0_get_.  
get_name                                internal procedure  shares stack frame of external procedure ring0_get_.  
get_definition                          internal procedure  shares stack frame of external procedure ring0_get_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 sltp1                       ring0_get_
000012 names_ptr1                  ring0_get_
000014 defs_ptr1                   ring0_get_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
ring0_get_               000100 names_ptr2                  ring0_get_
                         000102 defs_ptr2                   ring0_get_
                         000104 defp                        ring0_get_
                         000106 defsp                       ring0_get_
                         000110 i                           ring0_get_
                         000111 j                           ring0_get_
                         000112 sltp                        ring0_get_
                         000114 namep                       ring0_get_
                         000116 pathp                       ring0_get_
                         000120 sltep                       ring0_get_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   return_mac          ext_entry           ext_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_definition_               hcs_$initiate

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$invalidsegno     error_table_$no_defs          error_table_$noentry


CONSTANTS
001272  aa     000002000000
001273  aa     000000000000
001274  aa     600000000041
001275  aa     000203000000

001276  aa     000002000000
001277  aa     000000000000
001300  aa     600000000041
001301  aa     000202000000

000000  aa  076 163 171 163	>sys
000001  aa  164 145 155 137	tem_
000002  aa  154 151 142 162	libr
000003  aa  141 162 171 137	ary_
000004  aa  061 040 040 040	1   
000005  aa  040 040 040 040	    
000006  aa  040 040 040 040	    
000007  aa  040 040 040 040	    
000010  aa  040 040 040 040	    
000011  aa  040 040 040 040	    
000012  aa  040 040 040 040	    
000013  aa  040 040 040 040	    
000014  aa  040 040 040 040	    
000015  aa  040 040 040 000	   

000016  aa     524000000014

000017  aa     524000000012

000020  aa     524000000000

000021  aa     524000000003

000022  aa  163 154 164 000	slt

000023  aa     526000000067

000024  aa     514000000001

000025  aa     404000000021

000026  aa     404000000022

000027  aa     526077777777

000030  aa     464000000000

000032  aa     077777000043
000033  aa     000001000000

000034  aa  144 145 146 151	defi
000035  aa  156 151 164 151	niti
000036  aa  157 156 163 137	ons_

000037  aa  156 141 155 145	name
000040  aa  137 164 141 142	_tab
000041  aa  154 145 000 000	le

BEGIN PROCEDURE ring0_get_
ENTRY TO ring0_get_                                         STATEMENT 1 ON LINE 11
ring0_get_: proc;

000042  da     000064200000
000043  aa   000360 6270 00	eax7 	240
000044  aa  7 00034 3521 20	epp2 	pr7|28,*
000045  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000046  aa     000000000000
000047  aa     000000000000
						STATEMENT 1 ON LINE 46
segptr:	entry (dir, entry, segptr, code);

000050  aa   000033 7100 04	tra  	27,ic		000103
ENTRY TO segptr                                             STATEMENT 1 ON LINE 46
segptr:	entry (dir, entry, segptr, code);

000051  at     000004000027
000052  tt     000027000030
000053  ta     000025000000
000054  ta     000051000000
000055  da     000071300000
000056  aa   000360 6270 00	eax7 	240
000057  aa  7 00034 3521 20	epp2 	pr7|28,*
000060  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
000061  aa     000010000000
000062  aa     000000000000
000063  aa  6 00042 3735 20	epp7 	pr6|34,*
000064  aa  7 00000 2361 20	ldq  	pr7|0,*
000065  aa   000002 6040 04	tmi  	2,ic		000067
000066  aa   777777 3760 07	anq  	262143,dl
000067  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000070  aa  6 00200 7561 00	stq  	pr6|128
000071  aa  7 00002 2361 20	ldq  	pr7|2,*
000072  aa   000002 6040 04	tmi  	2,ic		000074
000073  aa   777777 3760 07	anq  	262143,dl
000074  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000075  aa  6 00201 7561 00	stq  	pr6|129
000076  aa  6 00032 3715 20	epp5 	pr6|26,*
000077  aa  5 00006 3535 20	epp3 	pr5|6,*
000100  aa  6 00126 2535 00	spri3	pr6|86
000101  aa  5 00010 3515 20	epp1 	pr5|8,*
000102  aa  6 00130 2515 00	spri1	pr6|88
						STATEMENT 1 ON LINE 48
	call get_static_ptrs ("0"b);

000103  aa   000000 2350 07	lda  	0,dl
000104  aa  6 00202 7551 00	sta  	pr6|130
000105  aa   001171 3520 04	epp2 	633,ic		001276 = 000002000000
000106  aa   000416 6700 04	tsp4 	270,ic		000524
						STATEMENT 1 ON LINE 49
	segptr = get_segptr ();

000107  aa  6 00126 3521 20	epp2 	pr6|86,*		segptr
000110  aa  6 00206 2521 00	spri2	pr6|134
000111  aa  6 00204 3521 00	epp2 	pr6|132
000112  aa   004000 4310 07	fld  	2048,dl
000113  aa  2 00000 7571 00	staq 	pr2|0
000114  aa   000675 6700 04	tsp4 	445,ic		001011
						STATEMENT 1 ON LINE 50
	return;

000115  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO name                                               STATEMENT 1 ON LINE 53
name:	entry (dir, entry, segptr, code);

000116  ta     000051000000
000117  da     000076300000
000120  aa   000360 6270 00	eax7 	240
000121  aa  7 00034 3521 20	epp2 	pr7|28,*
000122  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
000123  aa     000010000000
000124  aa     000000000000
000125  aa  6 00042 3735 20	epp7 	pr6|34,*
000126  aa  7 00000 2361 20	ldq  	pr7|0,*
000127  aa   000002 6040 04	tmi  	2,ic		000131
000130  aa   777777 3760 07	anq  	262143,dl
000131  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000132  aa  6 00200 7561 00	stq  	pr6|128
000133  aa  7 00002 2361 20	ldq  	pr7|2,*
000134  aa   000002 6040 04	tmi  	2,ic		000136
000135  aa   777777 3760 07	anq  	262143,dl
000136  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000137  aa  6 00201 7561 00	stq  	pr6|129
000140  aa  6 00032 3715 20	epp5 	pr6|26,*
000141  aa  5 00006 3535 20	epp3 	pr5|6,*
000142  aa  6 00126 2535 00	spri3	pr6|86
000143  aa  5 00010 3515 20	epp1 	pr5|8,*
000144  aa  6 00130 2515 00	spri1	pr6|88
						STATEMENT 1 ON LINE 55
	call get_static_ptrs ("0"b);

000145  aa   000000 2350 07	lda  	0,dl
000146  aa  6 00203 7551 00	sta  	pr6|131
000147  aa   001123 3520 04	epp2 	595,ic		001272 = 000002000000
000150  aa   000354 6700 04	tsp4 	236,ic		000524
						STATEMENT 1 ON LINE 56
	call get_name (segptr, "0"b);

000151  aa   000000 2350 07	lda  	0,dl
000152  aa  6 00203 7551 00	sta  	pr6|131
000153  aa  6 00126 3521 20	epp2 	pr6|86,*		segptr
000154  aa  6 00214 2521 00	spri2	pr6|140
000155  aa  6 00203 3521 00	epp2 	pr6|131
000156  aa  6 00216 2521 00	spri2	pr6|142
000157  aa  6 00212 3521 00	epp2 	pr6|138
000160  aa   010000 4310 07	fld  	4096,dl
000161  aa  2 00000 7571 00	staq 	pr2|0
000162  aa   000712 6700 04	tsp4 	458,ic		001074
						STATEMENT 1 ON LINE 57
	return;

000163  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO names                                              STATEMENT 1 ON LINE 59
names:	entry (dir, entryptr, segptr, code);

000164  at     000004000027
000165  tt     000030000030
000166  ta     000025000000
000167  ta     000164000000
000170  da     000103300000
000171  aa   000360 6270 00	eax7 	240
000172  aa  7 00034 3521 20	epp2 	pr7|28,*
000173  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
000174  aa     000010000000
000175  aa     000000000000
000176  aa  6 00042 3735 20	epp7 	pr6|34,*
000177  aa  7 00000 2361 20	ldq  	pr7|0,*
000200  aa   000002 6040 04	tmi  	2,ic		000202
000201  aa   777777 3760 07	anq  	262143,dl
000202  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000203  aa  6 00200 7561 00	stq  	pr6|128
000204  aa  6 00032 3715 20	epp5 	pr6|26,*
000205  aa  5 00006 3535 20	epp3 	pr5|6,*
000206  aa  6 00126 2535 00	spri3	pr6|86
000207  aa  5 00010 3515 20	epp1 	pr5|8,*
000210  aa  6 00130 2515 00	spri1	pr6|88
						STATEMENT 1 ON LINE 61
	call get_static_ptrs ("0"b);

000211  aa   000000 2350 07	lda  	0,dl
000212  aa  6 00203 7551 00	sta  	pr6|131
000213  aa   001057 3520 04	epp2 	559,ic		001272 = 000002000000
000214  aa   000310 6700 04	tsp4 	200,ic		000524
						STATEMENT 1 ON LINE 62
	call get_name (segptr, "1"b);

000215  aa   400000 2350 03	lda  	131072,du
000216  aa  6 00203 7551 00	sta  	pr6|131
000217  aa  6 00126 3521 20	epp2 	pr6|86,*		segptr
000220  aa  6 00214 2521 00	spri2	pr6|140
000221  aa  6 00203 3521 00	epp2 	pr6|131
000222  aa  6 00216 2521 00	spri2	pr6|142
000223  aa  6 00212 3521 00	epp2 	pr6|138
000224  aa   010000 4310 07	fld  	4096,dl
000225  aa  2 00000 7571 00	staq 	pr2|0
000226  aa   000646 6700 04	tsp4 	422,ic		001074
						STATEMENT 1 ON LINE 63
	return;

000227  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO definition                                         STATEMENT 1 ON LINE 65
definition: entry (segptr, entry, a_defname, a_offset, a_type, code);

000230  at     000006000030
000231  tt     000027000027
000232  tt     000026000025
000233  ta     000025000000
000234  ta     000230000000
000235  da     000111300000
000236  aa   000360 6270 00	eax7 	240
000237  aa  7 00034 3521 20	epp2 	pr7|28,*
000240  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
000241  aa     000014000000
000242  aa     000000000000
000243  aa  6 00042 3735 20	epp7 	pr6|34,*
000244  aa  7 00002 2361 20	ldq  	pr7|2,*
000245  aa   000002 6040 04	tmi  	2,ic		000247
000246  aa   777777 3760 07	anq  	262143,dl
000247  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000250  aa  6 00201 7561 00	stq  	pr6|129
000251  aa  7 00004 2361 20	ldq  	pr7|4,*
000252  aa   000002 6040 04	tmi  	2,ic		000254
000253  aa   777777 3760 07	anq  	262143,dl
000254  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000255  aa  6 00222 7561 00	stq  	pr6|146
000256  aa  6 00032 3715 20	epp5 	pr6|26,*
000257  aa  5 00002 3535 20	epp3 	pr5|2,*
000260  aa  6 00126 2535 00	spri3	pr6|86
000261  aa  5 00014 3515 20	epp1 	pr5|12,*
000262  aa  6 00130 2515 00	spri1	pr6|88
						STATEMENT 1 ON LINE 67
	call get_static_ptrs ("1"b);

000263  aa   400000 2350 03	lda  	131072,du
000264  aa  6 00203 7551 00	sta  	pr6|131
000265  aa   001005 3520 04	epp2 	517,ic		001272 = 000002000000
000266  aa   000236 6700 04	tsp4 	158,ic		000524
						STATEMENT 1 ON LINE 68
	if segptr = null then segptr = get_segptr ();

000267  aa  6 00126 2371 20	ldaq 	pr6|86,*		segptr
000270  aa   777542 6770 04	eraq 	-158,ic		000032 = 077777000043 000001000000
000271  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000272  aa   000007 6010 04	tnz  	7,ic		000301
000273  aa  6 00126 3521 20	epp2 	pr6|86,*		segptr
000274  aa  6 00206 2521 00	spri2	pr6|134
000275  aa  6 00204 3521 00	epp2 	pr6|132
000276  aa   004000 4310 07	fld  	2048,dl
000277  aa  2 00000 7571 00	staq 	pr2|0
000300  aa   000511 6700 04	tsp4 	329,ic		001011
						STATEMENT 1 ON LINE 69
	call get_definition (segptr);

000301  aa  6 00126 3521 20	epp2 	pr6|86,*		segptr
000302  aa  6 00206 2521 00	spri2	pr6|134
000303  aa  6 00204 3521 00	epp2 	pr6|132
000304  aa   004000 4310 07	fld  	2048,dl
000305  aa  2 00000 7571 00	staq 	pr2|0
000306  aa   000662 6700 04	tsp4 	434,ic		001170
						STATEMENT 1 ON LINE 70
	return;

000307  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO segptr_given_slt                                   STATEMENT 1 ON LINE 77
segptr_given_slt: entry (dir, entry, segptr, code, a_sltp, a_namep);

000310  at     000006000027
000311  tt     000027000030
000312  tt     000025000030
000313  ta     000030000000
000314  ta     000310000000
000315  da     000121300000
000316  aa   000360 6270 00	eax7 	240
000317  aa  7 00034 3521 20	epp2 	pr7|28,*
000320  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
000321  aa     000014000000
000322  aa     000000000000
000323  aa  6 00042 3735 20	epp7 	pr6|34,*
000324  aa  7 00000 2361 20	ldq  	pr7|0,*
000325  aa   000002 6040 04	tmi  	2,ic		000327
000326  aa   777777 3760 07	anq  	262143,dl
000327  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000330  aa  6 00200 7561 00	stq  	pr6|128
000331  aa  7 00002 2361 20	ldq  	pr7|2,*
000332  aa   000002 6040 04	tmi  	2,ic		000334
000333  aa   777777 3760 07	anq  	262143,dl
000334  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000335  aa  6 00201 7561 00	stq  	pr6|129
000336  aa  6 00032 3715 20	epp5 	pr6|26,*
000337  aa  5 00006 3535 20	epp3 	pr5|6,*
000340  aa  6 00126 2535 00	spri3	pr6|86
000341  aa  5 00010 3515 20	epp1 	pr5|8,*
000342  aa  6 00130 2515 00	spri1	pr6|88
000343  aa  5 00012 3735 20	epp7 	pr5|10,*
000344  aa  6 00122 6535 00	spri7	pr6|82
000345  aa  5 00014 3535 20	epp3 	pr5|12,*
000346  aa  6 00124 2535 00	spri3	pr6|84
						STATEMENT 1 ON LINE 79
	call get_param_ptrs ("0"b);

000347  aa   000000 2350 07	lda  	0,dl
000350  aa  6 00203 7551 00	sta  	pr6|131
000351  aa   000721 3520 04	epp2 	465,ic		001272 = 000002000000
000352  aa   000417 6700 04	tsp4 	271,ic		000771
						STATEMENT 1 ON LINE 80
	segptr = get_segptr ();

000353  aa  6 00126 3521 20	epp2 	pr6|86,*		segptr
000354  aa  6 00206 2521 00	spri2	pr6|134
000355  aa  6 00204 3521 00	epp2 	pr6|132
000356  aa   004000 4310 07	fld  	2048,dl
000357  aa  2 00000 7571 00	staq 	pr2|0
000360  aa   000431 6700 04	tsp4 	281,ic		001011
						STATEMENT 1 ON LINE 81
	return;

000361  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO name_given_slt                                     STATEMENT 1 ON LINE 83
name_given_slt: entry (dir, entry, segptr, code, a_sltp, a_namep);

000362  ta     000310000000
000363  da     000130300000
000364  aa   000360 6270 00	eax7 	240
000365  aa  7 00034 3521 20	epp2 	pr7|28,*
000366  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
000367  aa     000014000000
000370  aa     000000000000
000371  aa  6 00042 3735 20	epp7 	pr6|34,*
000372  aa  7 00000 2361 20	ldq  	pr7|0,*
000373  aa   000002 6040 04	tmi  	2,ic		000375
000374  aa   777777 3760 07	anq  	262143,dl
000375  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000376  aa  6 00200 7561 00	stq  	pr6|128
000377  aa  7 00002 2361 20	ldq  	pr7|2,*
000400  aa   000002 6040 04	tmi  	2,ic		000402
000401  aa   777777 3760 07	anq  	262143,dl
000402  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000403  aa  6 00201 7561 00	stq  	pr6|129
000404  aa  6 00032 3715 20	epp5 	pr6|26,*
000405  aa  5 00006 3535 20	epp3 	pr5|6,*
000406  aa  6 00126 2535 00	spri3	pr6|86
000407  aa  5 00010 3515 20	epp1 	pr5|8,*
000410  aa  6 00130 2515 00	spri1	pr6|88
000411  aa  5 00012 3735 20	epp7 	pr5|10,*
000412  aa  6 00122 6535 00	spri7	pr6|82
000413  aa  5 00014 3535 20	epp3 	pr5|12,*
000414  aa  6 00124 2535 00	spri3	pr6|84
						STATEMENT 1 ON LINE 85
	call get_param_ptrs ("0"b);

000415  aa   000000 2350 07	lda  	0,dl
000416  aa  6 00203 7551 00	sta  	pr6|131
000417  aa   000653 3520 04	epp2 	427,ic		001272 = 000002000000
000420  aa   000351 6700 04	tsp4 	233,ic		000771
						STATEMENT 1 ON LINE 86
	call get_name (segptr, "0"b);

000421  aa   000000 2350 07	lda  	0,dl
000422  aa  6 00203 7551 00	sta  	pr6|131
000423  aa  6 00126 3521 20	epp2 	pr6|86,*		segptr
000424  aa  6 00214 2521 00	spri2	pr6|140
000425  aa  6 00203 3521 00	epp2 	pr6|131
000426  aa  6 00216 2521 00	spri2	pr6|142
000427  aa  6 00212 3521 00	epp2 	pr6|138
000430  aa   010000 4310 07	fld  	4096,dl
000431  aa  2 00000 7571 00	staq 	pr2|0
000432  aa   000442 6700 04	tsp4 	290,ic		001074
						STATEMENT 1 ON LINE 87
	return;

000433  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO definition_given_slt                               STATEMENT 1 ON LINE 90
definition_given_slt: entry (segptr, entry, a_defname, a_offset, a_type, code, a_sltp, a_namep, a_defsp);

000434  at     000011000030
000435  tt     000027000027
000436  tt     000026000025
000437  tt     000025000030
000440  tt     000030000030
000441  ta     000434000000
000442  da     000141300000
000443  aa   000360 6270 00	eax7 	240
000444  aa  7 00034 3521 20	epp2 	pr7|28,*
000445  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
000446  aa     000022000000
000447  aa     000000000000
000450  aa  6 00042 3735 20	epp7 	pr6|34,*
000451  aa  7 00002 2361 20	ldq  	pr7|2,*
000452  aa   000002 6040 04	tmi  	2,ic		000454
000453  aa   777777 3760 07	anq  	262143,dl
000454  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000455  aa  6 00201 7561 00	stq  	pr6|129
000456  aa  7 00004 2361 20	ldq  	pr7|4,*
000457  aa   000002 6040 04	tmi  	2,ic		000461
000460  aa   777777 3760 07	anq  	262143,dl
000461  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000462  aa  6 00222 7561 00	stq  	pr6|146
000463  aa  6 00032 3715 20	epp5 	pr6|26,*
000464  aa  5 00002 3535 20	epp3 	pr5|2,*
000465  aa  6 00126 2535 00	spri3	pr6|86
000466  aa  5 00014 3515 20	epp1 	pr5|12,*
000467  aa  6 00130 2515 00	spri1	pr6|88
000470  aa  5 00016 3735 20	epp7 	pr5|14,*
000471  aa  6 00122 6535 00	spri7	pr6|82
000472  aa  5 00020 3535 20	epp3 	pr5|16,*
000473  aa  6 00124 2535 00	spri3	pr6|84
						STATEMENT 1 ON LINE 92
	call get_param_ptrs ("1"b);

000474  aa   400000 2350 03	lda  	131072,du
000475  aa  6 00203 7551 00	sta  	pr6|131
000476  aa   000574 3520 04	epp2 	380,ic		001272 = 000002000000
000477  aa   000272 6700 04	tsp4 	186,ic		000771
						STATEMENT 1 ON LINE 93
	if segptr = null then segptr = get_segptr ();

000500  aa  6 00126 2371 20	ldaq 	pr6|86,*		segptr
000501  aa   777331 6770 04	eraq 	-295,ic		000032 = 077777000043 000001000000
000502  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000503  aa   000007 6010 04	tnz  	7,ic		000512
000504  aa  6 00126 3521 20	epp2 	pr6|86,*		segptr
000505  aa  6 00206 2521 00	spri2	pr6|134
000506  aa  6 00204 3521 00	epp2 	pr6|132
000507  aa   004000 4310 07	fld  	2048,dl
000510  aa  2 00000 7571 00	staq 	pr2|0
000511  aa   000300 6700 04	tsp4 	192,ic		001011
						STATEMENT 1 ON LINE 94
	call get_definition (segptr);

000512  aa  6 00126 3521 20	epp2 	pr6|86,*		segptr
000513  aa  6 00206 2521 00	spri2	pr6|134
000514  aa  6 00204 3521 00	epp2 	pr6|132
000515  aa   004000 4310 07	fld  	2048,dl
000516  aa  2 00000 7571 00	staq 	pr2|0
000517  aa   000451 6700 04	tsp4 	297,ic		001170
						STATEMENT 1 ON LINE 95
	return;

000520  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 189
error_segptr: segptr = null;

000521  aa   777311 2370 04	ldaq 	-311,ic		000032 = 077777000043 000001000000
000522  aa  6 00126 7571 20	staq 	pr6|86,*		segptr
						STATEMENT 1 ON LINE 190
error:	return;

000523  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 195
     end;

BEGIN PROCEDURE get_static_ptrs
ENTRY TO get_static_ptrs                                    STATEMENT 1 ON LINE 98
get_static_ptrs: proc (we_want_defs);

000524  aa  6 00132 6501 00	spri4	pr6|90
000525  aa  6 00134 2521 00	spri2	pr6|92
						STATEMENT 1 ON LINE 102
	     code = 0;

000526  aa  6 00130 4501 20	stz  	pr6|88,*		code
						STATEMENT 1 ON LINE 103
	     if we_want_defs & defs_ptr1 = null then call init_static_ptrs;

000527  aa  2 00002 2351 20	lda  	pr2|2,*		we_want_defs
000530  aa   400000 3150 03	cana 	131072,du
000531  aa   000010 6000 04	tze  	8,ic		000541
000532  aa  6 00044 3701 20	epp4 	pr6|36,*
000533  ia  4 00014 2371 00	ldaq 	pr4|12		defs_ptr1
000534  aa   777276 6770 04	eraq 	-322,ic		000032 = 077777000043 000001000000
000535  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000536  aa   000003 6010 04	tnz  	3,ic		000541
000537  aa   000022 6700 04	tsp4 	18,ic		000561
000540  aa   000007 7100 04	tra  	7,ic		000547
						STATEMENT 1 ON LINE 104
	     else if names_ptr1 = null then call init_static_ptrs;

000541  aa  6 00044 3701 20	epp4 	pr6|36,*
000542  ia  4 00012 2371 00	ldaq 	pr4|10		names_ptr1
000543  aa   777267 6770 04	eraq 	-329,ic		000032 = 077777000043 000001000000
000544  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000545  aa   000002 6010 04	tnz  	2,ic		000547
000546  aa   000013 6700 04	tsp4 	11,ic		000561
						STATEMENT 1 ON LINE 105
	     if code ^= 0 then go to error;

000547  aa  6 00130 2361 20	ldq  	pr6|88,*		code
000550  aa   777753 6010 04	tnz  	-21,ic		000523
						STATEMENT 1 ON LINE 106
	     sltp = sltp1;

000551  aa  6 00044 3701 20	epp4 	pr6|36,*
000552  ia  4 00010 3735 20	epp7 	pr4|8,*		sltp1
000553  aa  6 00112 6535 00	spri7	pr6|74		sltp
						STATEMENT 1 ON LINE 107
	     names_ptr2 = names_ptr1;

000554  ia  4 00012 3715 20	epp5 	pr4|10,*		names_ptr1
000555  aa  6 00100 6515 00	spri5	pr6|64		names_ptr2
						STATEMENT 1 ON LINE 108
	     defs_ptr2 = defs_ptr1;

000556  ia  4 00014 3535 20	epp3 	pr4|12,*		defs_ptr1
000557  aa  6 00102 2535 00	spri3	pr6|66		defs_ptr2
						STATEMENT 1 ON LINE 109
	     return;

000560  aa  6 00132 6101 00	rtcd 	pr6|90
						STATEMENT 1 ON LINE 122
	end get_static_ptrs;

BEGIN PROCEDURE init_static_ptrs
ENTRY TO init_static_ptrs                                   STATEMENT 1 ON LINE 111
init_static_ptrs: proc;

000561  aa  6 00140 6501 00	spri4	pr6|96
						STATEMENT 1 ON LINE 112
		call hcs_$initiate (SLDIR, "slt", "", 0, 1, sltp1, code);

000562  aa   777240 2350 04	lda  	-352,ic		000022 = 163154164000
000563  aa  6 00223 7551 00	sta  	pr6|147
000564  aa  6 00225 4501 00	stz  	pr6|149
000565  aa   000001 2360 07	ldq  	1,dl
000566  aa  6 00226 7561 00	stq  	pr6|150
000567  aa   777211 3520 04	epp2 	-375,ic		000000 = 076163171163
000570  aa  6 00232 2521 00	spri2	pr6|154
000571  aa  6 00223 3521 00	epp2 	pr6|147
000572  aa  6 00234 2521 00	spri2	pr6|156
000573  aa  6 00224 3521 00	epp2 	pr6|148
000574  aa  6 00236 2521 00	spri2	pr6|158
000575  aa  6 00225 3521 00	epp2 	pr6|149
000576  aa  6 00240 2521 00	spri2	pr6|160
000577  aa  6 00226 3521 00	epp2 	pr6|150
000600  aa  6 00242 2521 00	spri2	pr6|162
000601  aa  6 00044 3701 20	epp4 	pr6|36,*
000602  ia  4 00010 3521 00	epp2 	pr4|8		sltp1
000603  aa  6 00244 2521 00	spri2	pr6|164
000604  aa  6 00130 3521 20	epp2 	pr6|88,*		code
000605  aa  6 00246 2521 00	spri2	pr6|166
000606  aa   777215 3520 04	epp2 	-371,ic		000023 = 526000000067
000607  aa  6 00250 2521 00	spri2	pr6|168
000610  aa   777211 3520 04	epp2 	-375,ic		000021 = 524000000003
000611  aa  6 00252 2521 00	spri2	pr6|170
000612  aa   777206 3520 04	epp2 	-378,ic		000020 = 524000000000
000613  aa  6 00254 2521 00	spri2	pr6|172
000614  aa   777211 3520 04	epp2 	-375,ic		000025 = 404000000021
000615  aa  6 00256 2521 00	spri2	pr6|174
000616  aa  6 00260 2521 00	spri2	pr6|176
000617  aa  6 00264 2521 00	spri2	pr6|180
000620  aa   777210 3520 04	epp2 	-376,ic		000030 = 464000000000
000621  aa  6 00262 2521 00	spri2	pr6|178
000622  aa  6 00230 6211 00	eax1 	pr6|152
000623  aa   034000 4310 07	fld  	14336,dl
000624  la  4 00016 3521 20	epp2 	pr4|14,*		hcs_$initiate
000625  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 113
		if sltp1 = null then return;

000626  aa  6 00044 3701 20	epp4 	pr6|36,*
000627  ia  4 00010 2371 00	ldaq 	pr4|8		sltp1
000630  aa   777202 6770 04	eraq 	-382,ic		000032 = 077777000043 000001000000
000631  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000632  aa   000002 6010 04	tnz  	2,ic		000634
000633  aa  6 00140 6101 00	rtcd 	pr6|96
						STATEMENT 1 ON LINE 114
		call hcs_$initiate (SLDIR, "name_table", "", 0, 1, names_ptr1, code);

000634  aa   777203 2350 04	lda  	-381,ic		000037 = 156141155145
000635  aa   777203 2360 04	ldq  	-381,ic		000040 = 137164141142
000636  aa  6 00230 7571 00	staq 	pr6|152
000637  aa   154145 2350 03	lda  	55397,du
000640  aa  6 00232 7551 00	sta  	pr6|154
000641  aa  6 00225 4501 00	stz  	pr6|149
000642  aa   000001 2360 07	ldq  	1,dl
000643  aa  6 00224 7561 00	stq  	pr6|148
000644  aa   777134 3520 04	epp2 	-420,ic		000000 = 076163171163
000645  aa  6 00270 2521 00	spri2	pr6|184
000646  aa  6 00230 3521 00	epp2 	pr6|152
000647  aa  6 00272 2521 00	spri2	pr6|186
000650  aa  6 00226 3521 00	epp2 	pr6|150
000651  aa  6 00274 2521 00	spri2	pr6|188
000652  aa  6 00225 3521 00	epp2 	pr6|149
000653  aa  6 00276 2521 00	spri2	pr6|190
000654  aa  6 00224 3521 00	epp2 	pr6|148
000655  aa  6 00300 2521 00	spri2	pr6|192
000656  ia  4 00012 3521 00	epp2 	pr4|10		names_ptr1
000657  aa  6 00302 2521 00	spri2	pr6|194
000660  aa  6 00130 3521 20	epp2 	pr6|88,*		code
000661  aa  6 00304 2521 00	spri2	pr6|196
000662  aa   777141 3520 04	epp2 	-415,ic		000023 = 526000000067
000663  aa  6 00306 2521 00	spri2	pr6|198
000664  aa   777133 3520 04	epp2 	-421,ic		000017 = 524000000012
000665  aa  6 00310 2521 00	spri2	pr6|200
000666  aa   777132 3520 04	epp2 	-422,ic		000020 = 524000000000
000667  aa  6 00312 2521 00	spri2	pr6|202
000670  aa   777135 3520 04	epp2 	-419,ic		000025 = 404000000021
000671  aa  6 00314 2521 00	spri2	pr6|204
000672  aa  6 00316 2521 00	spri2	pr6|206
000673  aa  6 00322 2521 00	spri2	pr6|210
000674  aa   777134 3520 04	epp2 	-420,ic		000030 = 464000000000
000675  aa  6 00320 2521 00	spri2	pr6|208
000676  aa  6 00266 6211 00	eax1 	pr6|182
000677  aa   034000 4310 07	fld  	14336,dl
000700  la  4 00016 3521 20	epp2 	pr4|14,*		hcs_$initiate
000701  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 115
		if names_ptr1 = null then return;

000702  aa  6 00044 3701 20	epp4 	pr6|36,*
000703  ia  4 00012 2371 00	ldaq 	pr4|10		names_ptr1
000704  aa   777126 6770 04	eraq 	-426,ic		000032 = 077777000043 000001000000
000705  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000706  aa   000002 6010 04	tnz  	2,ic		000710
000707  aa  6 00140 6101 00	rtcd 	pr6|96
						STATEMENT 1 ON LINE 116
		if we_want_defs then do;

000710  aa  6 00134 3735 20	epp7 	pr6|92,*
000711  aa  7 00002 2351 20	lda  	pr7|2,*		we_want_defs
000712  aa   400000 3150 03	cana 	131072,du
000713  aa   000054 6000 04	tze  	44,ic		000767
						STATEMENT 1 ON LINE 117
		     call hcs_$initiate (SLDIR, "definitions_", "", 0, 1, defs_ptr1, code);

000714  aa   777120 2370 04	ldaq 	-432,ic		000034 = 144145146151 156151164151
000715  aa  6 00266 7571 00	staq 	pr6|182
000716  aa   777120 2350 04	lda  	-432,ic		000036 = 157156163137
000717  aa  6 00270 7551 00	sta  	pr6|184
000720  aa  6 00225 4501 00	stz  	pr6|149
000721  aa   000001 2360 07	ldq  	1,dl
000722  aa  6 00226 7561 00	stq  	pr6|150
000723  aa   777055 3520 04	epp2 	-467,ic		000000 = 076163171163
000724  aa  6 00232 2521 00	spri2	pr6|154
000725  aa  6 00266 3521 00	epp2 	pr6|182
000726  aa  6 00234 2521 00	spri2	pr6|156
000727  aa  6 00224 3521 00	epp2 	pr6|148
000730  aa  6 00236 2521 00	spri2	pr6|158
000731  aa  6 00225 3521 00	epp2 	pr6|149
000732  aa  6 00240 2521 00	spri2	pr6|160
000733  aa  6 00226 3521 00	epp2 	pr6|150
000734  aa  6 00242 2521 00	spri2	pr6|162
000735  ia  4 00014 3521 00	epp2 	pr4|12		defs_ptr1
000736  aa  6 00244 2521 00	spri2	pr6|164
000737  aa  6 00130 3521 20	epp2 	pr6|88,*		code
000740  aa  6 00246 2521 00	spri2	pr6|166
000741  aa   777062 3520 04	epp2 	-462,ic		000023 = 526000000067
000742  aa  6 00250 2521 00	spri2	pr6|168
000743  aa   777053 3520 04	epp2 	-469,ic		000016 = 524000000014
000744  aa  6 00252 2521 00	spri2	pr6|170
000745  aa   777053 3520 04	epp2 	-469,ic		000020 = 524000000000
000746  aa  6 00254 2521 00	spri2	pr6|172
000747  aa   777056 3520 04	epp2 	-466,ic		000025 = 404000000021
000750  aa  6 00256 2521 00	spri2	pr6|174
000751  aa  6 00260 2521 00	spri2	pr6|176
000752  aa  6 00264 2521 00	spri2	pr6|180
000753  aa   777055 3520 04	epp2 	-467,ic		000030 = 464000000000
000754  aa  6 00262 2521 00	spri2	pr6|178
000755  aa  6 00230 6211 00	eax1 	pr6|152
000756  aa   034000 4310 07	fld  	14336,dl
000757  la  4 00016 3521 20	epp2 	pr4|14,*		hcs_$initiate
000760  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 118
		     if defs_ptr1 = null then return;

000761  aa  6 00044 3701 20	epp4 	pr6|36,*
000762  ia  4 00014 2371 00	ldaq 	pr4|12		defs_ptr1
000763  aa   777047 6770 04	eraq 	-473,ic		000032 = 077777000043 000001000000
000764  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000765  aa   000002 6010 04	tnz  	2,ic		000767
000766  aa  6 00140 6101 00	rtcd 	pr6|96
						STATEMENT 1 ON LINE 119
		end;

						STATEMENT 1 ON LINE 120
		code = 0;

000767  aa  6 00130 4501 20	stz  	pr6|88,*		code
						STATEMENT 1 ON LINE 121
	     end init_static_ptrs;

000770  aa  6 00140 6101 00	rtcd 	pr6|96
  END PROCEDURE init_static_ptrs
  END PROCEDURE get_static_ptrs
BEGIN PROCEDURE get_param_ptrs
ENTRY TO get_param_ptrs                                     STATEMENT 1 ON LINE 124
get_param_ptrs: proc (we_want_defs);

000771  aa  6 00146 6501 00	spri4	pr6|102
000772  aa  6 00150 2521 00	spri2	pr6|104
						STATEMENT 1 ON LINE 127
	     sltp = a_sltp;

000773  aa  6 00122 3735 20	epp7 	pr6|82,*		a_sltp
000774  aa  7 00000 3735 20	epp7 	pr7|0,*		a_sltp
000775  aa  6 00112 6535 00	spri7	pr6|74		sltp
						STATEMENT 1 ON LINE 128
	     names_ptr2 = a_namep;

000776  aa  6 00124 3715 20	epp5 	pr6|84,*		a_namep
000777  aa  5 00000 3715 20	epp5 	pr5|0,*		a_namep
001000  aa  6 00100 6515 00	spri5	pr6|64		names_ptr2
						STATEMENT 1 ON LINE 129
	     if we_want_defs then defs_ptr2 = a_defsp;

001001  aa  2 00002 2351 20	lda  	pr2|2,*		we_want_defs
001002  aa   400000 3150 03	cana 	131072,du
001003  aa   000005 6000 04	tze  	5,ic		001010
001004  aa  6 00032 3535 20	epp3 	pr6|26,*
001005  aa  3 00022 3515 20	epp1 	pr3|18,*		a_defsp
001006  aa  1 00000 3515 20	epp1 	pr1|0,*		a_defsp
001007  aa  6 00102 2515 00	spri1	pr6|66		defs_ptr2
						STATEMENT 1 ON LINE 130
	end get_param_ptrs;

001010  aa  6 00146 6101 00	rtcd 	pr6|102
  END PROCEDURE get_param_ptrs
BEGIN PROCEDURE get_segptr
ENTRY TO get_segptr                                         STATEMENT 1 ON LINE 132
get_segptr: procedure returns (ptr);

001011  aa  6 00154 6501 00	spri4	pr6|108
001012  aa  6 00156 2521 00	spri2	pr6|110
						STATEMENT 1 ON LINE 135
	     do i = slt.first_sup_seg to slt.last_sup_seg;

001013  aa  6 00112 3735 20	epp7 	pr6|74,*		sltp
001014  aa  7 00004 2361 00	ldq  	pr7|4		slt.last_sup_seg
001015  aa  6 00162 7561 00	stq  	pr6|114
001016  aa  7 00003 2361 00	ldq  	pr7|3		slt.first_sup_seg
001017  aa  6 00110 7561 00	stq  	pr6|72		i
001020  aa  6 00110 2361 00	ldq  	pr6|72		i
001021  aa  6 00162 1161 00	cmpq 	pr6|114
001022  aa   000046 6054 04	tpnz 	38,ic		001070
						STATEMENT 1 ON LINE 136
		sltep = addr (slt.seg (i));

001023  aa   000002 7360 00	qls  	2
001024  aa  6 00112 3735 20	epp7 	pr6|74,*		sltp
001025  aa  7 00010 3735 06	epp7 	pr7|8,ql		slt.seg
001026  aa  6 00120 6535 00	spri7	pr6|80		sltep
						STATEMENT 1 ON LINE 137
		namep = addrel (names_ptr2, slte.names_ptr);

001027  aa  7 00000 2351 00	lda  	pr7|0		slte.names_ptr
001030  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
001031  aa  6 00100 3521 61	epp2 	pr6|64,*au	names_ptr2
001032  aa   000000 0520 03	adwp2	0,du
001033  aa  6 00114 2521 00	spri2	pr6|76		namep
						STATEMENT 1 ON LINE 138
		do j = 1 to namep -> segnam.count;

001034  aa  2 00000 2361 00	ldq  	pr2|0		segnam.count
001035  aa  6 00163 7561 00	stq  	pr6|115
001036  aa   000001 2360 07	ldq  	1,dl
001037  aa  6 00111 7561 00	stq  	pr6|73		j
001040  aa  6 00111 2361 00	ldq  	pr6|73		j
001041  aa  6 00163 1161 00	cmpq 	pr6|115
001042  aa   000024 6054 04	tpnz 	20,ic		001066
						STATEMENT 1 ON LINE 139
		     if entry = namep -> segnam.names (j).name then do;

001043  aa   000011 4020 07	mpy  	9,dl
001044  aa  6 00032 3735 20	epp7 	pr6|26,*
001045  aa  7 00004 3715 20	epp5 	pr7|4,*
001046  aa  6 00114 3535 20	epp3 	pr6|76,*		namep
001047  aa  3 77771 3535 06	epp3 	pr3|-7,ql		segnam.name
001050  aa  6 00201 2351 00	lda  	pr6|129
001051  aa  040 100 106 540	cmpc 	(pr,rl),(pr),fill(040)
001052  aa  5 00000 00 0005	desc9a	pr5|0,al		entry
001053  aa  3 00000 00 0040	desc9a	pr3|0,32		segnam.name
001054  aa   000010 6010 04	tnz  	8,ic		001064
						STATEMENT 1 ON LINE 140
			code = 0;

001055  aa  6 00130 4501 20	stz  	pr6|88,*		code
						STATEMENT 1 ON LINE 141
			return (baseptr (i));

001056  aa  6 00110 2361 00	ldq  	pr6|72		i
001057  aa  6 00000 3525 00	epbp2	pr6|0
001060  aa   000000 3130 06	easp2	0,ql
001061  aa  6 00156 3515 20	epp1 	pr6|110,*
001062  aa  1 00002 2521 20	spri2	pr1|2,*
001063  aa  6 00154 6101 00	rtcd 	pr6|108
						STATEMENT 1 ON LINE 142
		     end;

						STATEMENT 1 ON LINE 143
		end;

001064  aa  6 00111 0541 00	aos  	pr6|73		j
001065  aa   777753 7100 04	tra  	-21,ic		001040
						STATEMENT 1 ON LINE 144
	     end;

001066  aa  6 00110 0541 00	aos  	pr6|72		i
001067  aa   777731 7100 04	tra  	-39,ic		001020
						STATEMENT 1 ON LINE 146
	     code = error_table_$noentry;

001070  aa  6 00044 3701 20	epp4 	pr6|36,*
001071  la  4 00024 2361 20	ldq  	pr4|20,*		error_table_$noentry
001072  aa  6 00130 7561 20	stq  	pr6|88,*		code
						STATEMENT 1 ON LINE 147
	     go to error_segptr;

001073  aa   777426 7100 04	tra  	-234,ic		000521
						STATEMENT 1 ON LINE 148
	end get_segptr;

  END PROCEDURE get_segptr
BEGIN PROCEDURE get_name
ENTRY TO get_name                                           STATEMENT 1 ON LINE 150
get_name:	procedure (sp, many);

001074  aa  6 00164 6501 00	spri4	pr6|116
001075  aa  6 00166 2521 00	spri2	pr6|118
						STATEMENT 1 ON LINE 154
	     i = bin (baseno (sp));

001076  aa  2 00002 3735 20	epp7 	pr2|2,*		sp
001077  aa  7 00000 3735 20	epp7 	pr7|0,*		sp
001100  aa  7 00000 2131 00	epaq 	pr7|0		sp
001101  aa   077777 3750 03	ana  	32767,du
001102  aa   000066 7730 00	lrl  	54
001103  aa  6 00110 7561 00	stq  	pr6|72		i
						STATEMENT 1 ON LINE 155
	     if i > slt.last_sup_seg | i < slt.first_sup_seg then do;

001104  aa  6 00112 3715 20	epp5 	pr6|74,*		sltp
001105  aa  5 00004 1161 00	cmpq 	pr5|4		slt.last_sup_seg
001106  aa   000003 6054 04	tpnz 	3,ic		001111
001107  aa  5 00003 1161 00	cmpq 	pr5|3		slt.first_sup_seg
001110  aa   000005 6050 04	tpl  	5,ic		001115
						STATEMENT 1 ON LINE 156
		code = error_table_$invalidsegno;

001111  aa  6 00044 3701 20	epp4 	pr6|36,*
001112  la  4 00026 2361 20	ldq  	pr4|22,*		error_table_$invalidsegno
001113  aa  6 00130 7561 20	stq  	pr6|88,*		code
						STATEMENT 1 ON LINE 157
		return;

001114  aa  6 00164 6101 00	rtcd 	pr6|116
						STATEMENT 1 ON LINE 158
	     end;

						STATEMENT 1 ON LINE 160
	     sltep = addr (slt.seg (i));

001115  aa   000002 7360 00	qls  	2
001116  aa  5 00010 3535 06	epp3 	pr5|8,ql		slt.seg
001117  aa  6 00120 2535 00	spri3	pr6|80		sltep
						STATEMENT 1 ON LINE 161
	     pathp = addrel (names_ptr2, slte.path_ptr);

001120  aa  3 00000 2351 00	lda  	pr3|0		slte.path_ptr
001121  aa   000022 7350 00	als  	18
001122  aa  6 00100 3515 61	epp1 	pr6|64,*au	names_ptr2
001123  aa   000000 0510 03	adwp1	0,du
001124  aa  6 00116 2515 00	spri1	pr6|78		pathp
						STATEMENT 1 ON LINE 162
	     namep = addrel (names_ptr2, slte.names_ptr);

001125  aa  3 00000 2351 00	lda  	pr3|0		slte.names_ptr
001126  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
001127  aa  6 00100 3735 61	epp7 	pr6|64,*au	names_ptr2
001130  aa   000000 1530 03	adwp7	0,du
001131  aa  6 00114 6535 00	spri7	pr6|76		namep
						STATEMENT 1 ON LINE 163
	     if pathp ^= names_ptr2 then dir = pathp -> path.name;

001132  aa  6 00116 2371 00	ldaq 	pr6|78		pathp
001133  aa  6 00100 6771 00	eraq 	pr6|64		names_ptr2
001134  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001135  aa   000011 6000 04	tze  	9,ic		001146
001136  aa  6 00032 3715 20	epp5 	pr6|26,*
001137  aa  5 00002 3535 20	epp3 	pr5|2,*
001140  aa  6 00200 2351 00	lda  	pr6|128
001141  aa  1 00000 7271 00	lxl7 	pr1|0		path.size
001142  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
001143  aa  1 00001 00 0017	desc9a	pr1|1,x7		path.name
001144  aa  3 00000 00 0005	desc9a	pr3|0,al		dir
001145  aa   000007 7100 04	tra  	7,ic		001154
						STATEMENT 2 ON LINE 163
 else dir = "";

001146  aa  6 00032 3715 20	epp5 	pr6|26,*
001147  aa  5 00002 3515 20	epp1 	pr5|2,*
001150  aa  6 00200 2351 00	lda  	pr6|128
001151  aa  040 140 100 400	mlr  	(),(pr,rl),fill(040)
001152  aa   000000 00 0000	desc9a	0,0
001153  aa  1 00000 00 0005	desc9a	pr1|0,al		dir
						STATEMENT 1 ON LINE 164
	     if many then entryptr = namep;

001154  aa  2 00004 2351 20	lda  	pr2|4,*		many
001155  aa   400000 3150 03	cana 	131072,du
001156  aa   000003 6000 04	tze  	3,ic		001161
001157  aa  5 00004 6535 20	spri7	pr5|4,*		entryptr
001160  aa   000006 7100 04	tra  	6,ic		001166
						STATEMENT 1 ON LINE 165
	     else entry = namep -> segnam.names (1).name;

001161  aa  5 00004 3535 20	epp3 	pr5|4,*
001162  aa  6 00201 2361 00	ldq  	pr6|129
001163  aa  040 140 100 500	mlr  	(pr),(pr,rl),fill(040)
001164  aa  7 00002 00 0040	desc9a	pr7|2,32		segnam.name
001165  aa  3 00000 00 0006	desc9a	pr3|0,ql		entry
						STATEMENT 1 ON LINE 166
	     code = 0;

001166  aa  6 00130 4501 20	stz  	pr6|88,*		code
						STATEMENT 1 ON LINE 167
	end get_name;

001167  aa  6 00164 6101 00	rtcd 	pr6|116
  END PROCEDURE get_name
BEGIN PROCEDURE get_definition
ENTRY TO get_definition                                     STATEMENT 1 ON LINE 169
get_definition: procedure (textp);

001170  aa  6 00172 6501 00	spri4	pr6|122
001171  aa  6 00174 2521 00	spri2	pr6|124
						STATEMENT 1 ON LINE 172
	     code = 0;

001172  aa  6 00130 4501 20	stz  	pr6|88,*		code
						STATEMENT 1 ON LINE 173
	     i = bin (baseno (textp));

001173  aa  2 00002 3735 20	epp7 	pr2|2,*		textp
001174  aa  7 00000 3735 20	epp7 	pr7|0,*		textp
001175  aa  7 00000 2131 00	epaq 	pr7|0		textp
001176  aa   077777 3750 03	ana  	32767,du
001177  aa   000066 7730 00	lrl  	54
001200  aa  6 00110 7561 00	stq  	pr6|72		i
						STATEMENT 1 ON LINE 174
	     if i < 4 | i > 511 then code = error_table_$no_defs;

001201  aa   000004 1160 07	cmpq 	4,dl
001202  aa   000003 6040 04	tmi  	3,ic		001205
001203  aa   000777 1160 07	cmpq 	511,dl
001204  aa   000005 6044 04	tmoz 	5,ic		001211
001205  aa  6 00044 3701 20	epp4 	pr6|36,*
001206  la  4 00022 2361 20	ldq  	pr4|18,*		error_table_$no_defs
001207  aa  6 00130 7561 20	stq  	pr6|88,*		code
001210  aa   000061 7100 04	tra  	49,ic		001271
						STATEMENT 1 ON LINE 175
	     else do;

						STATEMENT 1 ON LINE 176
		defsp = addrel (defs_ptr2, defs_ptr2 -> based_bit18 (i));

001211  aa  6 00102 2351 66	lda  	pr6|66,*ql	based_bit18
001212  aa  6 00102 3515 61	epp1 	pr6|66,*au	defs_ptr2
001213  aa   000000 0510 03	adwp1	0,du
001214  aa  6 00106 2515 00	spri1	pr6|70		defsp
						STATEMENT 1 ON LINE 177
		if defsp = defs_ptr2 then code = error_table_$no_defs;

001215  aa  6 00106 2371 00	ldaq 	pr6|70		defsp
001216  aa  6 00102 6771 00	eraq 	pr6|66		defs_ptr2
001217  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
001220  aa   000005 6010 04	tnz  	5,ic		001225
001221  aa  6 00044 3701 20	epp4 	pr6|36,*
001222  la  4 00022 2361 20	ldq  	pr4|18,*		error_table_$no_defs
001223  aa  6 00130 7561 20	stq  	pr6|88,*		code
001224  aa   000045 7100 04	tra  	37,ic		001271
						STATEMENT 1 ON LINE 178
		else do;

						STATEMENT 1 ON LINE 179
		     call get_definition_ (defsp, entry, a_defname, defp, code);

001225  aa  6 00106 3521 00	epp2 	pr6|70		defsp
001226  aa  6 00326 2521 00	spri2	pr6|214
001227  aa  6 00032 3715 20	epp5 	pr6|26,*
001230  aa  5 00004 3521 20	epp2 	pr5|4,*		entry
001231  aa  6 00330 2521 00	spri2	pr6|216
001232  aa  5 00006 3521 20	epp2 	pr5|6,*		a_defname
001233  aa  6 00332 2521 00	spri2	pr6|218
001234  aa  6 00104 3521 00	epp2 	pr6|68		defp
001235  aa  6 00334 2521 00	spri2	pr6|220
001236  aa  6 00130 3521 20	epp2 	pr6|88,*		code
001237  aa  6 00336 2521 00	spri2	pr6|222
001240  aa   776570 3520 04	epp2 	-648,ic		000030 = 464000000000
001241  aa  6 00340 2521 00	spri2	pr6|224
001242  aa  6 00346 2521 00	spri2	pr6|230
001243  aa  6 00042 3535 20	epp3 	pr6|34,*
001244  aa  3 00002 3521 20	epp2 	pr3|2,*
001245  aa  6 00342 2521 00	spri2	pr6|226
001246  aa  3 00004 3521 20	epp2 	pr3|4,*
001247  aa  6 00344 2521 00	spri2	pr6|228
001250  aa   776555 3520 04	epp2 	-659,ic		000025 = 404000000021
001251  aa  6 00350 2521 00	spri2	pr6|232
001252  aa  6 00324 6211 00	eax1 	pr6|212
001253  aa   024000 4310 07	fld  	10240,dl
001254  aa  6 00044 3701 20	epp4 	pr6|36,*
001255  la  4 00020 3521 20	epp2 	pr4|16,*		get_definition_
001256  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 180
		     if code = 0 then do;

001257  aa  6 00130 2361 20	ldq  	pr6|88,*		code
001260  aa   000011 6010 04	tnz  	9,ic		001271
						STATEMENT 1 ON LINE 181
			a_type = fixed (defp -> definition.class, 3);

001261  aa  6 00104 3735 20	epp7 	pr6|68,*		defp
001262  aa  7 00001 2361 00	ldq  	pr7|1		definition.class
001263  aa  0 00432 3771 00	anaq 	pr0|282		= 000000000000 000000000007
001264  aa  6 00032 3715 20	epp5 	pr6|26,*
001265  aa  5 00012 7561 20	stq  	pr5|10,*		a_type
						STATEMENT 1 ON LINE 182
			a_offset = fixed (defp -> definition.value, 18);

001266  aa  7 00001 2351 00	lda  	pr7|1		definition.value
001267  aa   000066 7730 00	lrl  	54
001270  aa  5 00010 7561 20	stq  	pr5|8,*		a_offset
						STATEMENT 1 ON LINE 183
		     end;

						STATEMENT 1 ON LINE 184
		end;

						STATEMENT 1 ON LINE 185
	     end;

						STATEMENT 1 ON LINE 187
	end get_definition;

001271  aa  6 00172 6101 00	rtcd 	pr6|122
  END PROCEDURE get_definition
  END PROCEDURE ring0_get_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
