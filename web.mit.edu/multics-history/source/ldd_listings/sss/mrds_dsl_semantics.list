	COMPILATION LISTING OF SEGMENT mrds_dsl_semantics
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/01/88  1334.6 mst Mon
	    Options: optimize map

        1 /****^  ********************************************
        2*        *                                          *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988 *
        4*        *                                          *
        5*        ******************************************** */
        6 
        7 
        8 
        9 /****^  HISTORY COMMENTS:
       10*  1) change(87-01-22,Hergert), approve(88-07-11,MCR7903),
       11*     audit(88-07-11,Dupuis), install(88-08-01,MR12.2-1073):
       12*     Written.
       13*  2) change(88-06-27,Hergert), approve(88-07-11,MCR7903),
       14*     audit(88-07-11,Dupuis), install(88-08-01,MR12.2-1073):
       15*     Fixed bugs and inadequacies from original design required to pass audit
       16*     and regression tests.
       17*                                                   END HISTORY COMMENTS */
       18 
       19 
       20 mrds_dsl_semantics:
       21     proc (psi_ptr, ls_top, prod_no, code);
       22 
       23 /*	SEMANTICS SEGMENT mrds_dsl_semantics.pl1
       24*   Generated by: Hergert.SysMaint.a using LALR 7.3a of Thursday, January 24, 1985
       25*   Generated at: Ford ECC Multics C
       26*   Generated on: 11/26/85  1644.7 est Tue
       27*   Generated from: >udd>MRDS>Hergert>p>d>mrds_dsl.lalr
       28**/
       29 
       30 
       31 /* -controls
       32*   -count
       33*   -long_source
       34*   -source
       35*   -symbols
       36*   -terminals
       37*   -production_names
       38*   -table mrds_dsl_tables
       39*   -terminals_list
       40*   -variables_list
       41*   -production
       42*   -semantics mrds_dsl_semantics
       43*   -synonyms '<=  ='<      ^>
       44*   =    ^'<>     ^>'<
       45*   ^=   '<>      >'<
       46*   >    ^'<=     ^='<
       47*   >=   =>       ^'<
       48*   '<    ^>=      ^=>
       49*   .V. .v.
       50*   .X. .x.
       51*   -range -from
       52*   &   -and
       53*   '|  -or
       54*   ^   -not
       55*   -order
       56*   &
       57*   (
       58*   )
       59*   *
       60*   +
       61*   ,
       62*   -
       63*   -all_of
       64*   -any_of
       65*   -ascending
       66*   -current
       67*   -descending
       68*   -differ
       69*   -dup
       70*   -group_by
       71*   -having
       72*   -inter
       73*   -is_between
       74*   -is_in
       75*   -is_like
       76*   -is_not_between
       77*   -is_not_in
       78*   -is_not_like
       79*   -is_not_null
       80*   -is_null
       81*   -no_optimize
       82*   -no_ot
       83*   -order_by
       84*   -print_search_order
       85*   -pso
       86*   -range
       87*   -select
       88*   -union
       89*   -where
       90*   .
       91*   .V.
       92*   .X.
       93*   /
       94*   ::
       95*   '<
       96*   '<=
       97*   <bit_string>
       98*   <integer>
       99*   <string>
      100*   <symbol>
      101*   =
      102*   >
      103*   >=
      104*   [
      105*   ]
      106*   ^
      107*   ^=
      108*   '|
      109*   '|'|
      110*   (* COMMENTS
      111*
      112*   To add a new production to the language, just insert the production in
      113*   the appropriate place in this description of the grammar. Also create
      114*   a new "prod (%%%%N): return;" sequence in the correct place, where N
      115*   is the relative production number in the rule. Then use the command
      116*   "lalr mrds_dsl". New tables will be created, a new mrds_dsl_semantics.pl1
      117*   and a few other things. To test the new grammar use the command
      118*   "lalrp mrds_dsl -trace". This invokes an interpretor that will wait
      119*   for terminal input. Enter a sample grammar and end it with the string "EOI".
      120*   After the grammar is proven correct the old mrds_dsl_semantics.pl1 will
      121*   have to be modified to reflect the new grammar. Usually some of the
      122*   productions have to be renumbered and code must be installed to handle the
      123*   new ones.
      124*
      125*   If a new kewyword was added then a new keyword table must also be created.
      126*   This is done with the kwsl command: "kwsl mrds_dsl". It will create a
      127*   new mrds_dsl.incl.pl1. This must renamed to mrds_dsl_keywords.incl.pl1
      128*   and modified by changing the size of keyword.name and adding the new level
      129*   major_keyword according to the old mrds_dsl_keywords.incl.pl1
      130*   Also the declaration and initialization of op_array in 
      131*   mrds_dsl_where_clause_ needs to be changed to reflect the new token ids
      132*   of the relational operators. I know this stinks, but...
      133*
      134*   Due to a bug in the LALR compiler the production
      135*   <attrubute_spec> ::= <relation>.<attribute> has to be represented as
      136*   <attribute_spec> ::= <symbol>.<symbol> which is syntactically
      137*   equivalent.
      138*
      139*   -pso and -no_ot have been removed. Since they currently can
      140*   exist anyplace in a selection expression, to maintain
      141*   upward compatibility, their parsing was moved to the scanner.
      142*
      143*   -another and -compiled have been removed from <control_order>.
      144*   They will be handled outside of the parser.
      145*
      146*   <control_order> was renamed <current_clause>
      147*   *)
      148*   %page;
      149*
      150*   (* SELECTION EXPRESSION *)
      151*   -parse */
      152 
      153         dbcb_ptr = static_data.dbcb_ptr;
      154         select_area_ptr = static_data.select_area_ptr;
      155         lex_stack_ptr = static_data.lex_stack_ptr;
      156         code = 0;
      157 
      158         if debug
      159         then call ioa_ (
      160 	        "Semantics: production ^d, Lex stack token '^a', stack top ^d",
      161 	        prod_no, lex_token, ls_top);
      162 
      163         goto prod (prod_no);
      164 
      165 
      166 
      167 
      168 /* <selection_expression> ::=
      169*   <current_clause>   |
      170*   <query> -order_by <order_spec_list> |
      171*   <query> ! */
      172 
      173 prod (1):
      174         call mrds_dsl_select_clause_$finish (dbcb_ptr, static_data.range_ptr,
      175 	   static_data.select_list_ptr, dbcb.ti_ptr, caller,
      176 	   area_ptr, argp_ptr, descp_ptr, num_args, cur_sw, code);
      177         if code ^= 0 then call error (code, ^LOUD, 0, "", "");
      178         goto exit;
      179 
      180 prod (2):
      181         call error (mrds_error_$unimplemented_syntax, LOUD, 1, SE_TYPE, "");
      182         goto exit;
      183 
      184 prod (3):
      185 
      186 /* If we are compiling, pred_leaf_list_ptr will point to a structure containg
      187*   pointers to the predicate leaves generated in where_clause that were
      188*   specified as .x. These have to be filled in at run time. trl_ptr will
      189*   point to a structure containing info on the temp rels used in a cse.
      190*   Since we dont know the se_index at this point we pass the pointer
      191*   back to compile in the cse struc and let him worry about it.
      192**/
      193 
      194         if caller = mrds_data_$caller_compile then do;
      195 	  dbcb.compiled_se_info_ptr -> compiled_se_info.temp_x_leaf_ptr =
      196 	       static_data.x_pred_leaf_ptr;
      197 	  dbcb.compiled_se_info_ptr
      198 	       -> compiled_se_info.temp_temp_rel_list_ptr = static_data.trl_ptr;
      199         end;
      200 
      201         goto exit;
      202 
      203 
      204 
      205 /* <current_clause> ::=
      206*   <current_header> |
      207*   <current_header> <select_list> ! */
      208 
      209 prod (4):
      210         goto exit;
      211 
      212 prod (5):
      213         goto exit;
      214 
      215 
      216 
      217 
      218 /* <current_header> ::= -current ! */
      219 
      220 prod (6):
      221         if dbcb.current_ptr ^= null then do;
      222 	  select_list_ptr, static_data.select_list_ptr = dbcb.current_ptr;
      223 	  string (select_list.var_exists) = "0"b;
      224 	  select_list.num_vars, select_list.num_items = 0;
      225         end;
      226         else call init_select_list;
      227 
      228         if caller = mrds_data_$caller_compile
      229         then call error (mrds_error_$inval_comp_expr, LOUD, 0, SE_TYPE,
      230 	        "A selection expression consisting of -current cannot be compiled."
      231 	        );
      232         if dbcb.range_ptr = null
      233         then /* no existing s.e. */
      234 	   call error (mrds_error_$no_prior_se, LOUD, 0, SE_TYPE, "");
      235 
      236         if dbcb.ss_ptr ^= null ()
      237         then call error (mrds_error_$curr_not_alld, LOUD, 0, SE_TYPE, "");
      238 
      239         dbcb.current_flag = "1"b;
      240 
      241         goto exit;
      242 
      243 
      244 
      245 
      246 /* <query> ::=
      247*   <query_expression> |
      248*   <query> <set_op> <query_expression>   ! */
      249 
      250 prod (7):
      251         goto exit;
      252 
      253 prod (8):
      254 
      255         ss_ptr = dbcb.ss_ptr;
      256         nitems_init = 2 * mrds_data_$max_sets;
      257 
      258         if se_pending then do;
      259 	  if select_sets.nitems + 1 >= nitems_init	/* make sure there is roomm for the se and its required oper */
      260 	  then
      261 	       call error (mrds_error_$set_ovfl, LOUD, 0, SE_TYPE, "");
      262 
      263 	  select_sets.nitems = select_sets.nitems + 1;
      264 	  select_sets.items.oper_flag (select_sets.nitems) = "0"b;
      265 						/* not an operator */
      266 	  select_sets.items.range_ptr (select_sets.nitems) = dbcb.range_ptr;
      267 	  select_sets.items.select_ptr (select_sets.nitems) =
      268 	       dbcb.select_ptr;
      269 	  select_sets.items.ti_ptr (select_sets.nitems) = dbcb.ti_ptr;
      270 	  select_sets.items.so_ptr (select_sets.nitems) = dbcb.so_ptr;
      271 
      272 	  se_pending = "0"b;
      273         end;
      274 
      275         select_sets.nitems = select_sets.nitems + 1;	/* incr. item count */
      276 
      277         select_sets.items.oper_flag (select_sets.nitems) = "1"b;
      278 						/* build oper. item in structure */
      279         select_sets.items.op_code (select_sets.nitems) = op_stack (op_top);
      280         op_top = op_top - 1;
      281 
      282         goto exit;
      283 
      284 
      285 
      286 
      287 /* <set_op> ::=
      288*   -union |
      289*   -inter |
      290*   -differ   ! */
      291 
      292 prod (9):
      293 
      294         call process_set_op (UNION);
      295 
      296         goto exit;
      297 
      298 prod (10):
      299 
      300         call process_set_op (INTERSECTION);
      301 
      302         goto exit;
      303 
      304 prod (11):
      305 
      306         call process_set_op (DIFFERENCE);
      307 
      308         goto exit;
      309 
      310 
      311 
      312 
      313 /* <query_expression> ::=
      314*   <query_clause> |
      315*   ( <query> ) ! */
      316 
      317 prod (12):
      318         dbcb.range_ptr, range_ptr = static_data.range_ptr;
      319         dbcb.select_ptr = static_data.select_list_ptr;
      320         dbcb.print_search_order = dbcb.se_info_ptr -> se_info.pso_seen;
      321         dbcb.no_optimize = dbcb.se_info_ptr -> se_info.no_ot_seen;
      322         option_list_ptr = static_data.option_list_ptr;
      323 
      324         if option_list.force then do;			/* setup the option specified in the smo command */
      325 	  dbcb.print_search_order = option_list.pso;
      326 	  dbcb.no_optimize = ^option_list.ot;
      327         end;
      328         else do;
      329 	  if option_list.pso then dbcb.print_search_order = "1"b;
      330 	  if ^option_list.ot then dbcb.no_optimize = "1"b;
      331         end;
      332 
      333         call get_relation_statistics (code);
      334         if code ^= 0 then call error (code, ^LOUD, 0, "", "");
      335 
      336         call mrds_dsl_optimize (dbcb_ptr, pred_tree_ptr, dbcb.so_ptr, code);
      337         if code ^= 0 then call error (code, ^LOUD, 0, "", "");
      338 
      339         se_pending = "1"b;
      340 
      341         goto exit;
      342 
      343 prod (13):
      344         goto exit;
      345 
      346 
      347 
      348 /* <query_clause> ::=
      349*   <required_clause> |
      350*   <required_clause> <optional_clauses> ! */
      351 
      352 prod (14):
      353         goto exit;
      354 
      355 prod (15):
      356         goto exit;
      357 
      358 
      359 
      360 
      361 /* <required_clause> ::=
      362*   <range_clause> <select_clause> |
      363*   <select_clause> <range_clause> ! */
      364 
      365 prod (16):
      366         goto exit;
      367 
      368 prod (17):
      369         goto exit;
      370 
      371 
      372 
      373 
      374 /* <optional_clauses> ::=
      375*   <where_clause> |
      376*   <group_clause> |
      377*   <where_clause> <group_clause> ! */
      378 
      379 prod (18):
      380         goto exit;
      381 
      382 prod (19):
      383         call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");
      384         goto exit;
      385 
      386 prod (20):
      387         call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");
      388         goto exit;
      389 
      390 
      391 
      392 
      393 /* <group_clause> ::=
      394*   -group_by <simple_expr> |
      395*   -group_by <simple_expr> -having <qualifier> ! */
      396 
      397 prod (21):
      398         goto exit;
      399 
      400 prod (22):
      401         goto exit;
      402 
      403 
      404 
      405 
      406 /* <order_spec_list> ::=
      407*   <simple_expr> |
      408*   <simple_expr> <direction> |
      409*   <order_spec_list> , <simple_expr> |
      410*   <order_spec_list> , <simple_expr> <direction> ! */
      411 
      412 prod (23):
      413         goto exit;
      414 
      415 prod (24):
      416         goto exit;
      417 
      418 prod (25):
      419         goto exit;
      420 
      421 prod (26):
      422         goto exit;
      423 
      424 
      425 
      426 
      427 /* <direction> ::=
      428*   -ascending |
      429*   -descending ! */
      430 
      431 prod (27):
      432         goto exit;
      433 
      434 prod (28):
      435         goto exit;
      436 
      437 
      438 /*
      439*   (* RANGE CLAUSE *)
      440*
      441*
      442*
      443*
      444*   <range_clause> ::= -range <range_def_list>   ! */
      445 
      446 prod (29):
      447         goto exit;
      448 
      449 
      450 /* <range_def_list> ::=
      451*		<sql_range_def_list> |
      452*		<dsl_range_def_list> ! */
      453 
      454 prod (30):
      455         return;
      456 
      457 prod (31):
      458         return;
      459 
      460 
      461 /* <sql_range_def_list> ::=
      462*		<sql_range> |
      463*		<sql_range_def_list> , <sql_range> ! */
      464 
      465 prod (32):
      466         return;
      467 
      468 prod (33):
      469         return;
      470 
      471 
      472 /* <sql_range> ::=
      473*		<sql_range_item> |
      474*		<sql_range_item> (+) ! */
      475 
      476 prod (34):
      477         return;
      478 
      479 prod (35):
      480         return;
      481 
      482 
      483 /* <sql_range_item> ::=
      484*		<relation_id> |
      485*		<relation_id> <relation_label> ! */
      486 
      487 prod (36):
      488         return;
      489 
      490 prod (37):
      491         return;
      492 
      493 
      494 /* <dsl_range_def_list> ::=
      495*		<dsl_range_item> |
      496*		<dsl_range_def_list> <dsl_range_item> ! */
      497 
      498 prod (38):
      499         return;
      500 
      501 prod (39):
      502         return;
      503 
      504 
      505 /* <dsl_range_item> ::= ( <relation_label> <relation_id> ) ! */
      506 
      507 prod (40):
      508         range_ptr = static_data.range_ptr;
      509         string (range.tup_var (range.num_vars).needed_bits) = "0"b;
      510         range.tup_var (range.num_vars).copy_for_current,
      511 	   range.tup_var (range.num_vars).copied_for_current = "0"b;
      512 
      513         range.tup_var.name (range.num_vars) = get_stacked_token (ls_top - 2);
      514 						/* Grab the label */
      515 
      516         do i = 1 to range.num_vars - 1;
      517 	  if range.name (range.num_vars) = range.name (i)
      518 	  then call error (mrds_error_$mult_def_var, LOUD, 2, RC_TYPE,
      519 		  "The relation label '"
      520 		  || get_stacked_token (ls_top - 2)
      521 		  || "' has already been used to identify a relation.");
      522         end;
      523 
      524         goto exit;
      525 
      526 
      527 
      528 
      529 /* <relation_id> ::=
      530*   <relation> |
      531*   <v_arg_substitution> |
      532*   <db_label>.<relation> ! */
      533 
      534 prod (41):
      535         range_ptr = static_data.range_ptr;
      536         if range.num_vars >= mrds_data_$max_tup_var
      537         then call error (mrds_error_$max_tup_var, LOUD, 0, RC_TYPE,
      538 	        "The maximum number is "
      539 	        || ltrim (char (mrds_data_$max_tup_var)));
      540         range.num_vars = range.num_vars + 1;		/* increment count */
      541         rmra_ptr = static_data.rdbi_ptr -> rm_db_info.ra_ptr;	/* point to perm rel array */
      542 
      543         if length (lex_token) < mrds_data_$max_id_len
      544         then
      545 	   i = index (string (rm_rel_array.name), "!" || lex_token || " ");
      546         else i = index (string (rm_rel_array.name), "!" || lex_token);
      547         if i = 0
      548         then call error (mrds_error_$undef_rel, LOUD, 0, RC_TYPE,
      549 	        "The relation '" || lex_token
      550 	        || "' is unknown in this opening.");
      551 						/* if not found */
      552 
      553         i = divide ((i - 1), 33, 17, 0) + 1;		/* convert from char to array index */
      554 
      555         range.tup_var.used (range.num_vars) = "0"b;	/* initially assume variable not used  */
      556         range.tup_var.whole_tuple_selected (range.num_vars) = "0"b;
      557 						/* initially assume variable not selected  */
      558         range.tup_var.temp_rel (range.num_vars) = "0"b;	/* was found, init. tup var info */
      559         range.tup_var.rel_index (range.num_vars) = i;
      560         range.tup_var.ri_ptr (range.num_vars) =
      561 	   rm_rel_array.rel_data.ri_ptr (i);
      562 
      563         goto exit;
      564 
      565 
      566 prod (42):
      567         range_ptr = static_data.range_ptr;
      568         if range.num_vars >= mrds_data_$max_tup_var
      569         then call error (mrds_error_$max_tup_var, LOUD, 0, RC_TYPE,
      570 	        "The maximum number is "
      571 	        || ltrim (char (mrds_data_$max_tup_var)));
      572         range.num_vars = range.num_vars + 1;		/* increment count */
      573         if descriptor_ptr -> bit36 = FB35
      574         then /* if value is fixed bin, no need to convert */
      575 	   temp_rel_index = arg_ptr -> fixed_bin_35;
      576 
      577         else do;					/* no such luck, must convert */
      578 
      579 	  if ^mu_valid_data_type$valid_scalar_data_type (descriptor_ptr
      580 	       -> bit36)
      581 	  then
      582 	       call error (mrds_error_$bad_temp_rel_val, ^LOUD, 0, "",
      583 		  "");
      584 
      585 	  call mu_convert$convert_data (arg_ptr, descriptor_ptr,
      586 	       addr (temp_rel_index), addr (FB35), code);
      587 	  if code ^= 0 then goto exit;
      588 
      589         end;					/* converting temp. rel. value */
      590 
      591         rmra_ptr = static_data.rdbi_ptr -> rm_db_info.tra_ptr;
      592         if temp_rel_index < 1 | rm_rel_array.num_rels < temp_rel_index
      593         then /*  if correspond. temp. rel. not yet defined */
      594 	   call error (mrds_error_$undef_temp_rel, ^LOUD, 0, "",
      595 	        "");
      596 
      597         if rm_rel_array.rel_data.ri_ptr (temp_rel_index) = null
      598         then
      599 	   call error (mrds_error_$undef_temp_rel, ^LOUD, 0, "",
      600 	        "");
      601 
      602         range.tup_var.used (range.num_vars) = "0"b;	/* initially assume variable not used  */
      603         range.tup_var.whole_tuple_selected (range.num_vars) = "0"b;
      604 						/* initially assume variable not selected  */
      605         range.tup_var.temp_rel (range.num_vars) = "1"b;	/* init tup_var info */
      606         range.tup_var.rel_index (range.num_vars) = temp_rel_index;
      607         range.tup_var.ri_ptr (range.num_vars) =
      608 	   rm_rel_array.rel_data.ri_ptr (temp_rel_index);
      609 
      610         if caller = mrds_data_$caller_compile then do;
      611 	  if static_data.trl_ptr = null then do;
      612 	      allocate temp_rel_list in (select_area) set (static_data.trl_ptr);
      613 	      static_data.trl_ptr -> temp_rel_list.number_of_temp_rels = 0;
      614 	  end;
      615 
      616 	  trl_ptr = static_data.trl_ptr;
      617 	  temp_rel_list.number_of_temp_rels =
      618 	       temp_rel_list.number_of_temp_rels + 1;	/* save the name of the temp rel for CSE */
      619 	  temp_rel_list.name (number_of_temp_rels) =
      620 	       rm_rel_array.name.submodel (temp_rel_index);
      621 	  temp_rel_list.index (number_of_temp_rels) = temp_rel_index;
      622         end;
      623 
      624         goto exit;
      625 
      626 prod (43):
      627         call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");
      628 
      629         goto exit;
      630 
      631 
      632 
      633 /*
      634*   (* SELECT CLAUSE *)
      635*
      636*
      637*
      638*
      639*   <select_clause> ::=
      640*   <select_header> * |
      641*   <select_header> <select_list> ! */
      642 
      643 prod (44):
      644         call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");
      645         goto exit;
      646 
      647 prod (45):
      648         call mrds_dsl_select_clause_$finish (dbcb_ptr, static_data.range_ptr,
      649 	   static_data.select_list_ptr, dbcb.ti_ptr, caller,
      650 	   area_ptr, argp_ptr, descp_ptr, num_args, cur_sw, code);
      651         if code ^= 0 then call error (code, ^LOUD, 0, "", "");
      652         goto exit;
      653 
      654 
      655 
      656 
      657 /* <select_header> ::=
      658*   -select  |
      659*   -select -distinct
      660*   -select -dup  ! */
      661 
      662 prod (46):
      663         call init_select_list;
      664         goto exit;
      665 
      666 prod (47):
      667         call init_select_list;
      668         goto exit;
      669 
      670 prod (48):
      671 
      672         dbcb.val_mod, dbcb.val_del, dbcb.val_dtr = "0"b;
      673 
      674         if dbcb.ss_ptr = null
      675         then dbcb.dup_retain = "1"b;			/* set correct dup flag */
      676         else dbcb.ss_ptr -> select_sets.dup_retain = "1"b;
      677 
      678         call init_select_list;
      679 
      680         goto exit;
      681 
      682 
      683 
      684 
      685 /* <select_list> ::=
      686*   <select_item> |
      687*   <select_list> <select_item> ! */
      688 
      689 prod (49):
      690         goto exit;
      691 
      692 prod (50):
      693         goto exit;
      694 
      695 
      696 
      697 
      698 /* <select_item> ::=
      699*   <select_id> |
      700*   <select_id> :: <alias> ! */
      701 
      702 prod (51):
      703         goto exit;
      704 
      705 prod (52):
      706         call error (mrds_error_$unimplemented_syntax, LOUD, 1, SE_TYPE, "");
      707         goto exit;
      708 
      709 
      710 
      711 /* <select_id> ::=
      712*   <attribute> |
      713*   ( <simple_expr> ) |
      714*   ( <simple_expr> ) * |
      715*   <relation> . <attribute> |
      716*   <relation> . <attribute> * ! */
      717 
      718 prod (53):
      719 						/* this means that a whole relation is to be returned */
      720         call get_attribute_info (^ATTRIBUTE, ^KEY, static_data.rel_index, attr_index);
      721 
      722         call mrds_dsl_select_clause_$all_attributes (dbcb_ptr, static_data.range_ptr,
      723 	   static_data.select_list_ptr, rmri_ptr, static_data.rel_index, cur_sw,
      724 	   caller,
      725 	   code);
      726         if code ^= 0 then call error (code, ^LOUD, 0, "", "");
      727 
      728         goto exit;
      729 
      730 prod (54):
      731         call error (mrds_error_$unimplemented_syntax, LOUD, 2, SE_TYPE, "");
      732         goto exit;
      733 
      734 prod (55):
      735         call error (mrds_error_$unimplemented_syntax, LOUD, 3, SE_TYPE, "");
      736         goto exit;
      737 
      738 prod (56):
      739         call get_attribute_info (ATTRIBUTE, ^KEY, static_data.rel_index, attr_index);
      740 
      741         call mrds_dsl_select_clause_$one_attribute (dbcb_ptr, static_data.range_ptr,
      742 	   static_data.select_list_ptr, rmri_ptr, attr_index, static_data.rel_index, ^KEY, cur_sw,
      743 	   caller, code);
      744         if code ^= 0 then call error (code, ^LOUD, 0, "", "");
      745 
      746         goto exit;
      747 
      748 
      749 prod (57):
      750         call get_attribute_info (ATTRIBUTE, KEY, static_data.rel_index, attr_index);
      751 
      752         call mrds_dsl_select_clause_$one_attribute (dbcb_ptr, static_data.range_ptr,
      753 	   static_data.select_list_ptr, rmri_ptr, attr_index, static_data.rel_index, KEY, cur_sw,
      754 	   caller, code);
      755         if code ^= 0 then call error (code, ^LOUD, 0, "", "");
      756 
      757         goto exit;
      758 
      759 
      760 
      761 /*
      762*   (*  WHERE CLAUSE *)
      763*
      764*
      765*
      766*
      767*   <where_clause> ::=
      768*   -where <qualifier> ! */
      769 
      770 prod (58):
      771         call mrds_dsl_where_clause_$finish (psi_ptr,pred_tree_ptr);
      772 
      773         goto exit;
      774 
      775 
      776 
      777 
      778 /* <qualifier> ::=
      779*   <qualifier_term> |
      780*   <qualifier> <or_op> <qualifier_term>  ! */
      781 
      782 prod (59):
      783         goto exit;
      784 
      785 prod (60):
      786         call mrds_dsl_where_clause_$build_node (psi_ptr,dbcb_ptr, select_area_ptr,
      787 	   lex_stack.token_id (ls_top - 1),
      788 	   LOGICAL_NODE, ^NOT_NODE, code);
      789         if code ^= 0 then call error (code, ^LOUD, 0, "", "");
      790 
      791         goto exit;
      792 
      793 
      794 
      795 
      796 /* <qualifier_term> ::=
      797*   <qualifier_factor> |
      798*   <qualifier_term> <and_op> <qualifier_factor> ! */
      799 
      800 prod (61):
      801         goto exit;
      802 
      803 prod (62):
      804         call mrds_dsl_where_clause_$build_node (psi_ptr,dbcb_ptr, select_area_ptr,
      805 	   lex_stack.token_id (ls_top - 1), LOGICAL_NODE, ^NOT_NODE, code);
      806         if code ^= 0 then call error (code, ^LOUD, 0, "", "");
      807 
      808         goto exit;
      809 
      810 
      811 
      812 
      813 /* <qualifier_factor> ::=
      814*   <predicate> |
      815*   <not_op> <predicate> ! */
      816 
      817 prod (63):
      818         goto exit;
      819 
      820 prod (64):
      821         call mrds_dsl_where_clause_$build_node (psi_ptr,dbcb_ptr, select_area_ptr,
      822 	   lex_stack.token_id (ls_top - 1),
      823 	   LOGICAL_NODE, NOT_NODE, code);
      824         if code ^= 0 then call error (code, ^LOUD, 0, "", "");
      825 
      826         goto exit;
      827 
      828 
      829 
      830 
      831 /* <predicate> ::=
      832*   <term> |
      833*   (<qualifier>) ! */
      834 
      835 prod (65):
      836         goto exit;
      837 
      838 prod (66):
      839         goto exit;
      840 
      841 
      842 
      843 
      844 /* <term> ::=
      845*   <expr_or_query> <comp_op> <expr_or_query> |
      846*   <expr_or_query> <is_in> ( <query_literal> ) |
      847*   <like_item> <like> <regular_expr> |
      848*   <attribute_spec> <is_null> |
      849*   <expr> <between> <expr> <and_op> <expr> ! */
      850 
      851 prod (67):
      852         call mrds_dsl_where_clause_$build_node (psi_ptr,dbcb_ptr, select_area_ptr,
      853 	   lex_stack.token_id (ls_top - 1),
      854 	   ^LOGICAL_NODE, ^NOT_NODE, code);
      855         if code ^= 0 then call error (code, ^LOUD, 0, "", "");
      856 
      857         goto exit;
      858 
      859 prod (68):
      860         goto exit;
      861 
      862 prod (69):
      863         goto exit;
      864 
      865 prod (70):
      866         goto exit;
      867 
      868 prod (71):
      869         goto exit;
      870 
      871 
      872 
      873 
      874 /* <expr_or_query> ::=
      875*   ( <query_literal> ) |
      876*   [ <old_func_or_expr> ] |
      877*   <expr> |
      878*   <x_arg_substitution> ! */
      879 
      880 prod (72):
      881         goto exit;
      882 
      883 prod (73):
      884         efd_ptr = expr_efd_ptrs (current_expr_level);
      885         call mrds_dsl_expr_$finish (psi_ptr,efd_ptr, select_area_ptr,
      886 	   current_expr_level);
      887 
      888         if exp_fun_data.var_index <= 0 then do;		/* if constant expression */
      889 	  if exp_fun_data.ef_ptr ^= null ()
      890 	  then do;
      891 	      call mrds_dsl_eval_expr (area_ptr, exp_fun_data.ef_ptr,
      892 		 null, null, code);			/* evaluate const. expr */
      893 	      if code ^= 0
      894 	      then call error (code, LOUD, 0, WCE_TYPE,
      895 		      "Error occured while evaluating expression.");
      896 	  end;
      897 	  call mrds_dsl_where_clause_$build_literal (psi_ptr,dbcb_ptr,
      898 	       select_area_ptr, exp_fun_data.assn_ptr,
      899 	       addr (exp_fun_data.descriptor), static_data.x_pred_leaf_ptr, ^X_SW,
      900 	       code);
      901 	  if code ^= 0 then call error (code, ^LOUD, 0, "", "");
      902         end;
      903 
      904         else do;
      905 	  call mrds_dsl_where_clause_$build_expr (psi_ptr,efd_ptr, select_area_ptr,
      906 	       code);
      907 	  if code ^= 0 then call error (code, ^LOUD, 0, "", "");
      908         end;
      909 
      910         current_expr_level = current_expr_level - 1;
      911 
      912         goto exit;
      913 
      914 prod (74):
      915         goto exit;
      916 
      917 prod (75):
      918         call mrds_dsl_where_clause_$build_literal (psi_ptr,dbcb_ptr, select_area_ptr,
      919 	   null, null, static_data.x_pred_leaf_ptr, X_SW, code);
      920         if code ^= 0 then call error (code, ^LOUD, 0, "", "");
      921         goto exit;
      922 
      923 
      924 
      925 
      926 /* <query_literal> ::=
      927*   <query> |
      928*   <constant_list> ! */
      929 
      930 prod (76):
      931         goto exit;
      932 
      933 prod (77):
      934         goto exit;
      935 
      936 
      937 
      938 
      939 /* <old_func_or_expr> ::=
      940*   <old_function> |
      941*   <old_expr> |
      942*   ( <old_expr> ) ! */
      943 
      944 prod (78):
      945         efd_ptr = func_efd_ptrs (current_func_level);
      946 
      947         if exp_fun_data.var_index <= 0 then do;		/* function is a constant */
      948 	  call mrds_dsl_eval_func (area_ptr, exp_fun_data.ef_ptr, null, null,
      949 	       code);
      950 	  if code ^= 0
      951 	  then
      952 	       call error (code, LOUD, 0, WCF_TYPE,
      953 		  "Error occured while evaluating function.");
      954 	  if addr (exp_fun_data.descriptor) -> descriptor.type > 18
      955 	       & addr (exp_fun_data.descriptor) -> descriptor.type < 23
      956 	  then char_sw = CHAR_SW;
      957 	  else char_sw = ^CHAR_SW;
      958 	  call mrds_dsl_expr_$build_literal (psi_ptr,dbcb_ptr, exp_fun_data.assn_ptr,
      959 	       addr (exp_fun_data.descriptor), char_sw, current_expr_level,
      960 	       code);
      961 	  if code ^= 0 then call error (code, ^LOUD, 0, "", "");
      962         end;
      963 
      964         else do;
      965 	  if expr_efd_ptrs (current_expr_level) -> exp_fun_data.var_index = 0
      966 	  then
      967 	       expr_efd_ptrs (current_expr_level) -> exp_fun_data.var_index =
      968 		  exp_fun_data.var_index;
      969 	  else if expr_efd_ptrs (current_expr_level)
      970 		  -> exp_fun_data.var_index ^= exp_fun_data.var_index
      971 	       then call error (mrds_error_$mult_expr_vars, LOUD, 0,
      972 		       WCE_TYPE, "");		/* else must match established var. */
      973 
      974 	  call mrds_dsl_expr_$build_function (psi_ptr,dbcb_ptr, efd_ptr,
      975 	       current_expr_level, code);
      976 	  if code ^= 0 then call error (code, ^LOUD, 0, "", "");
      977         end;
      978 
      979         current_func_level = current_func_level - 1;
      980 
      981         goto exit;
      982 
      983 
      984 prod (79):
      985         goto exit;
      986 
      987 prod (80):
      988         goto exit;
      989 
      990 
      991 
      992 
      993 /* <like_item> ::=
      994*   <attribute_spec> |
      995*   <function> ! */
      996 
      997 prod (81):
      998         goto exit;
      999 
     1000 prod (82):
     1001         goto exit;
     1002 
     1003 
     1004 
     1005 
     1006 /* <is_in> ::=
     1007*   -is_in |
     1008*   -is_not_in ! */
     1009 
     1010 prod (83):
     1011         call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");
     1012         goto exit;
     1013 
     1014 prod (84):
     1015         call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");
     1016         goto exit;
     1017 
     1018 
     1019 
     1020 
     1021 /* <like> ::=
     1022*   -is_like |
     1023*   -is_not_like ! */
     1024 
     1025 prod (85):
     1026         call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");
     1027         goto exit;
     1028 
     1029 prod (86):
     1030         call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");
     1031         goto exit;
     1032 
     1033 
     1034 
     1035 
     1036 /* <is_null> ::=
     1037*   -is_null |
     1038*   -is_not_null ! */
     1039 
     1040 prod (87):
     1041         call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");
     1042         goto exit;
     1043 
     1044 prod (88):
     1045         call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");
     1046         goto exit;
     1047 
     1048 
     1049 
     1050 
     1051 /* <between> ::=
     1052*   -is_between |
     1053*   -is_not_between ! */
     1054 
     1055 prod (89):
     1056         call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");
     1057         goto exit;
     1058 
     1059 prod (90):
     1060         call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");
     1061         goto exit;
     1062 
     1063 
     1064 
     1065 
     1066 /* <comp_op> ::=
     1067*   <rel_op> |
     1068*   <rel_op> -any_of | (* ^= -any_of is always true *)
     1069*   <rel_op> -all_of ! (* = -all_of is always false *) */
     1070 
     1071 prod (91):
     1072         goto exit;
     1073 
     1074 prod (92):
     1075         call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");
     1076         goto exit;
     1077 
     1078 prod (93):
     1079         call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");
     1080         goto exit;
     1081 
     1082 
     1083 
     1084 
     1085 /* <rel_op> ::=
     1086*   =  |  ^=  |  >   |  >=  |  '<  |  '<= ! */
     1087 
     1088 prod (94):
     1089         goto exit;
     1090 
     1091 prod (95):
     1092         goto exit;
     1093 
     1094 prod (96):
     1095         goto exit;
     1096 
     1097 prod (97):
     1098         goto exit;
     1099 
     1100 prod (98):
     1101         goto exit;
     1102 
     1103 prod (99):
     1104         goto exit;
     1105 
     1106 
     1107 /* <regular_expr> ::=
     1108*		<expr> |
     1109*		<x_arg_substitution> ! */
     1110 
     1111 prod (100):
     1112         return;
     1113 
     1114 prod (101):
     1115         return;
     1116 
     1117 /*
     1118*   (*   EXPRESSIONS   *)
     1119*
     1120*
     1121*   (* SIMPLE EXPR  I.E. no arg substitution *)
     1122*
     1123*
     1124*
     1125*
     1126*   <simple_expr> ::=
     1127*   <simple_arith_term> |
     1128*   <simple_expr> <add_op> <simple_arith_term> ! */
     1129 
     1130 prod (102):
     1131         goto exit;
     1132 
     1133 prod (103):
     1134         goto exit;
     1135 
     1136 
     1137 
     1138 
     1139 /* <simple_arith_term> ::=
     1140*   <simple_arith_factor> |
     1141*   <simple_arith_term> <mult_op> <simple_arith_factor> ! */
     1142 
     1143 prod (104):
     1144         goto exit;
     1145 
     1146 prod (105):
     1147         goto exit;
     1148 
     1149 
     1150 
     1151 
     1152 /* <simple_arith_factor> ::=
     1153*   <simple_primary> |
     1154*   <simple_arith_factor> '|'| <simple_primary> |
     1155*   <add_op> <simple_primary> ! */
     1156 
     1157 prod (106):
     1158         goto exit;
     1159 
     1160 prod (107):
     1161         call error (mrds_error_$unimplemented_syntax, LOUD, 1, SE_TYPE, "");
     1162         goto exit;
     1163 
     1164 prod (108):
     1165         goto exit;
     1166 
     1167 
     1168 
     1169 
     1170 /* <simple_primary> ::=
     1171*   <attribute_spec> |
     1172*   <function> |
     1173*   (<simple_expr>) |
     1174*   <constant> ! */
     1175 
     1176 prod (109):
     1177         goto exit;
     1178 
     1179 prod (110):
     1180         goto exit;
     1181 
     1182 prod (111):
     1183         goto exit;
     1184 
     1185 prod (112):
     1186         goto exit;
     1187 
     1188 
     1189 /*
     1190*   (* STANDARD EXPR  I.E. arg substitution *)
     1191*
     1192*
     1193*
     1194*
     1195*   <expr> ::=
     1196*   <arith_term> |
     1197*   <expr> <add_op> <arith_term> ! */
     1198 
     1199 prod (113):
     1200         goto exit;
     1201 
     1202 prod (114):
     1203         goto exit;
     1204 
     1205 
     1206 
     1207 
     1208 /* <arith_term> ::=
     1209*   <arith_factor> |
     1210*   <arith_term> <mult_op> <arith_factor> ! */
     1211 
     1212 prod (115):
     1213         goto exit;
     1214 
     1215 prod (116):
     1216         goto exit;
     1217 
     1218 
     1219 
     1220 
     1221 /* <arith_factor> ::=
     1222*   <primary> |
     1223*   <arith_factor> '|'| <primary> |
     1224*   <add_op> <primary> ! */
     1225 
     1226 prod (117):
     1227         if primary_type = "ATTR" then do;
     1228 	  call mrds_dsl_where_clause_$build_attribute (psi_ptr,dbcb_ptr,
     1229 	       select_area_ptr,
     1230 	       static_data.rel_index,
     1231 	       static_data.rmri_ptr -> rm_rel_info.attr_ptrs (attr_index), code);
     1232 	  if code ^= 0 then call error (code, ^LOUD, 0, "", "");
     1233         end;
     1234 
     1235         else if primary_type = "CONS" then do;
     1236 	       call mrds_dsl_where_clause_$build_literal (psi_ptr,dbcb_ptr,
     1237 		  select_area_ptr,
     1238 		  constant_ptr, descriptor_copy_ptr, static_data.x_pred_leaf_ptr,
     1239 		  ^X_SW, code)
     1240 		  ;
     1241 	       if code ^= 0 then call error (code, ^LOUD, 0, "", "");
     1242 	   end;
     1243 	   else if primary_type = "VARG" then do;
     1244 		  call mrds_dsl_where_clause_$build_literal (psi_ptr,dbcb_ptr,
     1245 		       select_area_ptr,
     1246 		       arg_ptr, descriptor_ptr, static_data.x_pred_leaf_ptr,
     1247 		       ^X_SW, code);
     1248 		  if code ^= 0 then call error (code, ^LOUD, 0, "", "");
     1249 	        end;
     1250 
     1251         goto exit;
     1252 
     1253 prod (118):
     1254         call error (mrds_error_$unimplemented_syntax, LOUD, 1, SE_TYPE, "");
     1255         goto exit;
     1256 
     1257 prod (119):
     1258         if primary_type = "CONS" then do;
     1259 	  char_descriptor.length =
     1260 	       lex_stack.token_length (ls_top)
     1261 	       + lex_stack.token_start_pos (ls_top)
     1262 	       - lex_stack.token_start_pos (ls_top - 1);
     1263 	  constant_ptr = lex_stack.token_ptr (ls_top - 1);
     1264 	  allocate descriptor_copy in (literal_area);
     1265 	  descriptor_copy = addr (char_descriptor) -> descriptor_copy;
     1266 	  call mrds_dsl_where_clause_$build_literal (psi_ptr,dbcb_ptr,
     1267 	       select_area_ptr,
     1268 	       constant_ptr, descriptor_copy_ptr, static_data.x_pred_leaf_ptr, ^X_SW,
     1269 	       code)
     1270 	       ;
     1271 	  if code ^= 0 then call error (code, ^LOUD, 0, "", "");
     1272         end;
     1273         else call error (mrds_error_$unimplemented_syntax, LOUD, 1, SE_TYPE,
     1274 	        "");
     1275         goto exit;
     1276 
     1277 
     1278 
     1279 
     1280 /* <primary> ::=
     1281*   <attribute_spec> |
     1282*   <function> |
     1283*   (<expr>) |
     1284*   <constant> |
     1285*   <v_arg_substitution>   ! */
     1286 
     1287 prod (120):
     1288 						/* Say this attribute is needed, although it may not be */
     1289         static_data.range_ptr -> range.tup_var (static_data.rel_index).needed_bits
     1290 	   .
     1291 	   attr (static_data.rmri_ptr -> rm_rel_info.attr_ptrs (attr_index)
     1292 	   -> rm_attr_info.defn_order) = "1"b;
     1293 
     1294         primary_type = "ATTR";
     1295 
     1296         goto exit;
     1297 
     1298 prod (121):
     1299         primary_type = "FUNC";
     1300         goto exit;
     1301 
     1302 prod (122):
     1303         primary_type = "EXPR";
     1304         goto exit;
     1305 
     1306 prod (123):					/* constant */
     1307         primary_type = "CONS";
     1308 
     1309         goto exit;
     1310 
     1311 prod (124):					/* .v. */
     1312         primary_type = "VARG";
     1313 
     1314         goto exit;
     1315 
     1316 
     1317 
     1318 /*
     1319*   (* OLD EXPR  I.E. BRACKETS AROUND EXPRESSIONS  *)
     1320*
     1321*
     1322*
     1323*
     1324*   <old_expr> ::=
     1325*   <old_primary> <arith_op> <old_primary> ! */
     1326 
     1327 prod (125):
     1328 
     1329         call mrds_dsl_expr_$condense_stack (psi_ptr,dbcb_ptr, select_area_ptr,
     1330 	   get_stacked_token (ls_top - 1), current_expr_level, code);
     1331         if code ^= 0 then call error (code, ^LOUD, 0, "", "");
     1332         goto exit;
     1333 
     1334 
     1335 
     1336 
     1337 /* <old_primary> ::=
     1338*   <relation>.<attribute> |
     1339*   <old_function> |
     1340*   <constant> |
     1341*   ( <old_expr> ) |
     1342*   <v_arg_substitution>   ! */
     1343 
     1344 prod (126):
     1345         call init_expression;
     1346         call get_attribute_info (ATTRIBUTE, ^KEY, static_data.rel_index, attr_index);
     1347         efd_ptr = expr_efd_ptrs (current_expr_level);
     1348 
     1349         if exp_fun_data.var_index = 0
     1350         then exp_fun_data.var_index = static_data.rel_index;
     1351         else if static_data.rel_index ^= exp_fun_data.var_index
     1352 	   then
     1353 	        call error (mrds_error_$mult_expr_vars, LOUD, 0, WCE_TYPE,
     1354 		   "");				/* else must match that already set */
     1355 
     1356         call mrds_dsl_expr_$build_attribute (psi_ptr,dbcb_ptr, static_data.range_ptr, static_data.rel_index,
     1357 	   rm_rel_info.attr_ptrs (attr_index), current_expr_level, code);
     1358         if code ^= 0 then call error (code, ^LOUD, 0, "", "");
     1359 
     1360         goto exit;
     1361 
     1362 
     1363 prod (127):
     1364         efd_ptr = func_efd_ptrs (current_func_level);
     1365 
     1366         if exp_fun_data.var_index <= 0 then do;		/* function is a constant */
     1367 	  call mrds_dsl_eval_func (area_ptr, exp_fun_data.ef_ptr, null, null,
     1368 	       code);
     1369 	  if code ^= 0
     1370 	  then
     1371 	       call error (code, LOUD, 0, WCF_TYPE,
     1372 		  "Error occured while evaluating function.");
     1373 	  if addr (exp_fun_data.descriptor) -> descriptor.type > 18
     1374 	       & addr (exp_fun_data.descriptor) -> descriptor.type < 23
     1375 	  then char_sw = CHAR_SW;
     1376 	  else char_sw = ^CHAR_SW;
     1377 	  call mrds_dsl_expr_$build_literal (psi_ptr,dbcb_ptr, exp_fun_data.assn_ptr,
     1378 	       addr (exp_fun_data.descriptor), char_sw, current_expr_level,
     1379 	       code);
     1380 	  if code ^= 0 then call error (code, ^LOUD, 0, "", "");
     1381         end;
     1382 
     1383         else do;
     1384 	  if expr_efd_ptrs (current_expr_level) -> exp_fun_data.var_index = 0
     1385 	  then
     1386 	       expr_efd_ptrs (current_expr_level) -> exp_fun_data.var_index =
     1387 		  exp_fun_data.var_index;
     1388 	  else if expr_efd_ptrs (current_expr_level)
     1389 		  -> exp_fun_data.var_index ^= exp_fun_data.var_index
     1390 	       then call error (mrds_error_$mult_expr_vars, LOUD, 0,
     1391 		       WCE_TYPE, "");		/* else must match established var. */
     1392 
     1393 	  call mrds_dsl_expr_$build_function (psi_ptr,dbcb_ptr, efd_ptr,
     1394 	       current_expr_level, code);
     1395 	  if code ^= 0 then call error (code, ^LOUD, 0, "", "");
     1396         end;
     1397 
     1398         current_func_level = current_func_level - 1;
     1399 
     1400         goto exit;
     1401 
     1402 
     1403 prod (128):
     1404         call init_expression;
     1405         call mrds_dsl_expr_$build_literal (psi_ptr,dbcb_ptr, constant_ptr,
     1406 	   descriptor_copy_ptr,
     1407 	   ^CHAR_SW, current_expr_level, code);
     1408         if code ^= 0 then call error (code, ^LOUD, 0, "", "");
     1409         goto exit;
     1410 
     1411 prod (129):
     1412         goto exit;
     1413 
     1414 prod (130):
     1415         call init_expression;
     1416         call mrds_dsl_expr_$build_literal (psi_ptr,dbcb_ptr, arg_ptr, descriptor_ptr,
     1417 	   ^CHAR_SW, current_expr_level,
     1418 	   code);
     1419         if code ^= 0 then call error (code, ^LOUD, 0, "", "");
     1420         goto exit;
     1421 
     1422 
     1423 
     1424 
     1425 /* <old_function> ::= <fn_name> (<old_arg_list>)   ! */
     1426 
     1427 prod (131):
     1428 
     1429         call mrds_dsl_func_$finish (psi_ptr,dbcb_ptr, select_area_ptr, area_ptr,
     1430 	   func_efd_ptrs (current_func_level),
     1431 	   current_func_level, code);
     1432         if code ^= 0 then call error (code, ^LOUD, 0, "", "");
     1433 
     1434         goto exit;
     1435 
     1436 
     1437 
     1438 
     1439 
     1440 /* <old_arg_list> ::=
     1441*   <old_arg> |
     1442*   <old_arg_list> <old_arg>   ! */
     1443 
     1444 prod (132):
     1445         goto exit;
     1446 
     1447 prod (133):
     1448         goto exit;
     1449 
     1450 
     1451 
     1452 
     1453 /* <old_arg> ::=
     1454*   [ <old_func_or_expr> ] |
     1455*   <old_function> |
     1456*   <relation>.<attribute> |
     1457*   <constant> |
     1458*   <v_arg_substitution> ! */
     1459 
     1460 prod (134):
     1461         efd_ptr = expr_efd_ptrs (current_expr_level);
     1462         call mrds_dsl_expr_$finish (psi_ptr,efd_ptr, select_area_ptr,
     1463 	   current_expr_level);
     1464 
     1465         if exp_fun_data.var_index <= 0 then do;		/* if really a constant */
     1466 
     1467 	  call mrds_dsl_eval_expr (area_ptr, exp_fun_data.ef_ptr, null, null,
     1468 	       code);
     1469 	  if code ^= 0
     1470 	  then call error (code, LOUD, 0, WCE_TYPE,
     1471 		  "Error occured while evaluating the expression.");
     1472 	  call mrds_dsl_func_$build_literal (psi_ptr,dbcb_ptr, exp_fun_data.assn_ptr,
     1473 	       addr (exp_fun_data.descriptor), current_func_level, code);
     1474 	  if code ^= 0 then call error (code, ^LOUD, 0, "", "");
     1475         end;					/* if constant */
     1476 
     1477         else do;					/* if not constant */
     1478 	  if func_efd_ptrs (current_func_level) -> exp_fun_data.var_index = 0
     1479 	  then
     1480 	       func_efd_ptrs (current_func_level) -> exp_fun_data.var_index =
     1481 		  exp_fun_data.var_index;
     1482 	  else if func_efd_ptrs (current_func_level)
     1483 		  -> exp_fun_data.var_index ^= exp_fun_data.var_index
     1484 	       then call error (mrds_error_$mult_expr_vars, LOUD, 0,
     1485 		       WCE_TYPE, "");		/* else must match established var. */
     1486 
     1487 	  call mrds_dsl_func_$build_expr_func (psi_ptr,dbcb_ptr, efd_ptr,
     1488 	       EXPRESSION, current_func_level, code);
     1489 	  if code ^= 0 then call error (code, ^LOUD, 0, "", "");
     1490         end;
     1491 
     1492         current_expr_level = current_expr_level - 1;
     1493 
     1494         goto exit;
     1495 
     1496 prod (135):
     1497         efd_ptr = func_efd_ptrs (current_func_level);
     1498         if exp_fun_data.var_index <= 0 then do;		/* if really a constant */
     1499 	  call mrds_dsl_eval_func (area_ptr, exp_fun_data.ef_ptr, null, null,
     1500 	       code);
     1501 	  if code ^= 0
     1502 	  then call error (code, LOUD, 0, WCF_TYPE,
     1503 		  "Error occured while evaluating function.");
     1504 	  call mrds_dsl_func_$build_literal (psi_ptr,dbcb_ptr, exp_fun_data.assn_ptr,
     1505 	       addr (exp_fun_data.descriptor), current_func_level - 1, code);
     1506 	  if code ^= 0 then call error (code, ^LOUD, 0, "", "");
     1507         end;					/* if constant */
     1508 
     1509         else do;					/* if not constant */
     1510 	  if func_efd_ptrs (current_func_level - 1) -> exp_fun_data.var_index
     1511 	       = 0
     1512 	  then
     1513 	       func_efd_ptrs (current_func_level - 1)
     1514 		  -> exp_fun_data.var_index =
     1515 		  exp_fun_data.var_index;
     1516 	  else if func_efd_ptrs (current_func_level - 1)
     1517 		  -> exp_fun_data.var_index ^= exp_fun_data.var_index
     1518 	       then call error (mrds_error_$mult_expr_vars, LOUD, 0,
     1519 		       WCE_TYPE, "");		/* else must match established var. */
     1520 
     1521 	  call mrds_dsl_func_$build_expr_func (psi_ptr,dbcb_ptr, efd_ptr,
     1522 	       ^EXPRESSION,
     1523 	       current_func_level - 1, code);
     1524 	  if code ^= 0 then call error (code, ^LOUD, 0, "", "");
     1525         end;
     1526 
     1527         current_expr_level = current_expr_level - 1;
     1528         current_func_level = current_func_level - 1;
     1529 
     1530 
     1531         goto exit;
     1532 
     1533 prod (136):
     1534         call get_attribute_info (ATTRIBUTE, ^KEY, static_data.rel_index, attr_index);
     1535         efd_ptr = func_efd_ptrs (current_func_level);
     1536 
     1537         if exp_fun_data.var_index = 0
     1538         then exp_fun_data.var_index = static_data.rel_index;
     1539         else if static_data.rel_index ^= exp_fun_data.var_index
     1540 	   then
     1541 	        call error (mrds_error_$mult_expr_vars, LOUD, 0, WCF_TYPE,
     1542 		   "");				/* else must match that already set */
     1543 
     1544         call mrds_dsl_func_$build_attribute (psi_ptr,dbcb_ptr, static_data.range_ptr, static_data.rel_index,
     1545 	   rm_rel_info.attr_ptrs (attr_index), current_func_level, code);
     1546         if code ^= 0 then call error (code, ^LOUD, 0, "", "");
     1547 
     1548         goto exit;
     1549 
     1550 prod (137):
     1551         call mrds_dsl_func_$build_literal (psi_ptr,dbcb_ptr, constant_ptr,
     1552 	   descriptor_copy_ptr, current_func_level, code);
     1553         if code ^= 0 then call error (code, ^LOUD, 0, "", "");
     1554         goto exit;
     1555 
     1556 prod (138):
     1557         call mrds_dsl_func_$build_literal (psi_ptr,dbcb_ptr, arg_ptr, descriptor_ptr,
     1558 	   current_func_level, code);
     1559         if code ^= 0 then call error (code, ^LOUD, 0, "", "");
     1560         goto exit;
     1561 
     1562 
     1563 /*
     1564*   (* COMMON PRODUCTIONS *)
     1565*
     1566*
     1567*
     1568*
     1569*   <function> ::= <fn_name> (<arg_list>)   ! */
     1570 
     1571 prod (139):
     1572         call error (mrds_error_$unimplemented_syntax, LOUD, 3, SE_TYPE, "");
     1573         goto exit;
     1574 
     1575 
     1576 
     1577 
     1578 /* <arg_list> ::=
     1579*   <expr> |
     1580*   <arg_list> , <expr>   ! */
     1581 
     1582 prod (140):
     1583         goto exit;
     1584 
     1585 prod (141):
     1586         goto exit;
     1587 
     1588 
     1589 
     1590 /* <attribute_spec> ::=
     1591*   <attribute> |
     1592*   <symbol> . <symbol>   |
     1593*   <db_label> . <relation> . <attribute>  ! */
     1594 
     1595 prod (142):
     1596         call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");
     1597         goto exit;
     1598 
     1599 prod (143):
     1600         call get_attribute_info (ATTRIBUTE, ^KEY, static_data.rel_index, attr_index);
     1601 
     1602         goto exit;
     1603 
     1604 prod (144):
     1605         goto exit;
     1606 
     1607 
     1608 
     1609 
     1610 /* <constant_list> ::=
     1611*   <constant_item> , <constant_item> |
     1612*   <constant_list> , <constant_item> ! */
     1613 
     1614 prod (145):
     1615         goto exit;
     1616 
     1617 prod (146):
     1618         goto exit;
     1619 
     1620 
     1621 
     1622 
     1623 /* <constant_item> ::=
     1624*   <constant> |
     1625*   <v_arg_substitution> |
     1626*   <x_arg_substitution> ! */
     1627 
     1628 prod (147):
     1629         goto exit;
     1630 
     1631 prod (148):
     1632         goto exit;
     1633 
     1634 prod (149):
     1635         goto exit;
     1636 
     1637 
     1638 
     1639 
     1640 /* <constant> ::=
     1641*   <string> |
     1642*   <integer> |
     1643*   <bit_string> ! */
     1644 
     1645 prod (150):
     1646         j = index (substr (lex_token, 2), DQ);
     1647 
     1648         if j = 0 then do;				/* no double quotes */
     1649 	  char_descriptor.length = lex_stack.token_length (ls_top) - 2;
     1650 						/* dont want first and last quotes */
     1651 	  if char_descriptor.length = 0 then do;	/* null string */
     1652 	      string_len = 0;
     1653 	      allocate string_token in (select_area) set (constant_ptr);
     1654 	  end;
     1655 	  else constant_ptr = addcharno (lex_stack.token_ptr (ls_top), 1);
     1656 						/* skip 1st quote */
     1657         end;
     1658 
     1659         else do;					/* yech, we have double quotes */
     1660 	  string_len = lex_stack.token_length (ls_top);
     1661 	  allocate string_token in (select_area);
     1662 
     1663 	  i = 1;					/* next free spot in string_token */
     1664 	  k = 2;					/* start after first quote */
     1665 	  done = "0"b;
     1666 	  do while (^done);				/* process each DQ  taking only one of the two quotes */
     1667 
     1668 	      substr (string_token, i, j) = substr (lex_token, k, j);
     1669 
     1670 	      i = i + j;
     1671 	      k = k + j + 1;
     1672 
     1673 	      j = index (substr (lex_token, k), DQ);
     1674 
     1675 	      if j = 0 then do;			/* all done, but need rest of string */
     1676 		substr (string_token, i, string_len - k) =
     1677 		     substr (lex_token, k, string_len - k);
     1678 		i = i + string_len - k;
     1679 		done = "1"b;
     1680 	      end;
     1681 	  end;
     1682 
     1683 	  constant_ptr = addr (string_token);
     1684 	  char_descriptor.length = i - 1;
     1685         end;					/* else if have DQ */
     1686 
     1687 
     1688         allocate descriptor_copy in (literal_area);
     1689         descriptor_copy = addr (char_descriptor) -> descriptor_copy;
     1690 
     1691         if debug
     1692         then
     1693 	   call ioa_ (
     1694 	        "Quoted strings: input -> '^a' output -> '^a' descriptor -> ^o"
     1695 	        ,
     1696 	        lex_token, cons, descriptor_copy);
     1697 
     1698         goto exit;
     1699 
     1700 prod (151):
     1701         char_descriptor.length = lex_stack.token_length (ls_top);
     1702         constant_ptr = lex_stack.token_ptr (ls_top);
     1703         allocate descriptor_copy in (literal_area);
     1704         descriptor_copy = addr (char_descriptor) -> descriptor_copy;
     1705 
     1706         goto exit;
     1707 
     1708 prod (152):
     1709         b_pos =
     1710 	   lex_stack.token_length (ls_top) - index (reverse (lex_token), B)
     1711 	   + 1;
     1712 
     1713 /* convert the base to something meaningful */
     1714         if b_pos = lex_stack.token_length (ls_top)
     1715         then base = 1;
     1716         else base =
     1717 	        binary (substr (lex_token, lex_stack.token_length (ls_top)),
     1718 	        17);
     1719 
     1720         if search (lex_token,QUOTE)=0 then do; /* bit integer i.e. 101b */
     1721 	   bit_start_pos=1;                  /* first bit pos in token */
     1722 	   i=1;                              /* token len - i = pos of last data char in token */
     1723 	   k=1;                              /* token len - k = num of data chars in token */
     1724         end;
     1725         else do;                             /* bit string i.e. "101"b */
     1726 	   bit_start_pos=2;
     1727 	   i=2;
     1728 	   k=3;
     1729         end;
     1730 
     1731         j = verify (substr (lex_token, bit_start_pos, b_pos - k),
     1732 	   LEGAL_CHARACTERS (base));			/* do the characters in the string make sense given the base */
     1733 
     1734         if j = 0 then do;				/* all characters are good */
     1735 	  char_descriptor.length, string_len = (b_pos - k) * base;
     1736 	  allocate string_token in (select_area);
     1737 
     1738 	  do j = bit_start_pos to b_pos - i;			/* replace characters with their corresponding bit string */
     1739 	      substr (string_token, (j - i) * base + 1, base) =
     1740 		 substr (
     1741 		 HEX_BITS (
     1742 		 index ("0123456789abcdef", substr (lex_token, j, 1))),
     1743 		 5 - base);
     1744 	  end;
     1745 
     1746 	  constant_ptr = string_ptr;
     1747 	  allocate descriptor_copy in (literal_area);
     1748 	  descriptor_copy = addr (char_descriptor) -> descriptor_copy;
     1749 
     1750 	  if debug
     1751 	  then call ioa_ (
     1752 		  "Bit string: input -> '^a' output -> '^a' descriptor -> ^o"
     1753 		  ,
     1754 		  lex_token, string_token, descriptor_copy);
     1755         end;
     1756         else call error (mrds_error_$inv_string, LOUD, 0, WC_TYPE,
     1757 	        "The bit string contains characters that conflict with given base."
     1758 	        );
     1759 
     1760         goto exit;
     1761 
     1762 
     1763 
     1764 
     1765 /* <arith_op> ::= <mult_op> | <add_op> ! */
     1766 
     1767 prod (153):
     1768         goto exit;
     1769 
     1770 prod (154):
     1771         goto exit;
     1772 
     1773 
     1774 
     1775 
     1776 /* <add_op> ::= + | - ! */
     1777 
     1778 prod (155):
     1779         goto exit;
     1780 
     1781 prod (156):
     1782         goto exit;
     1783 
     1784 
     1785 
     1786 
     1787 /* <mult_op> ::= * | / ! */
     1788 
     1789 prod (157):
     1790         goto exit;
     1791 
     1792 prod (158):
     1793         goto exit;
     1794 
     1795 
     1796 
     1797 
     1798 /* <and_op> ::= & ! */
     1799 
     1800 prod (159):
     1801         goto exit;
     1802 
     1803 
     1804 
     1805 
     1806 /* <or_op>  ::= '| ! */
     1807 
     1808 prod (160):
     1809         goto exit;
     1810 
     1811 
     1812 
     1813 
     1814 /* <not_op> ::= ^ ! */
     1815 
     1816 prod (161):
     1817         goto exit;
     1818 
     1819 
     1820 
     1821 
     1822 /* <v_arg_substitution> ::=  .V. ! */
     1823 
     1824 prod (162):
     1825         call get_next_arg (arg_ptr, descriptor_ptr);
     1826 
     1827         goto exit;
     1828 
     1829 
     1830 
     1831 
     1832 /* <x_arg_substitution> ::=  .X. ! */
     1833 
     1834 prod (163):
     1835         goto exit;
     1836 
     1837 
     1838 
     1839 
     1840 /* <db_label> ::= <symbol> ! */
     1841 
     1842 prod (164):
     1843         call error (mrds_error_$unimplemented_syntax, LOUD, 0, SE_TYPE, "");
     1844         goto exit;
     1845 
     1846 
     1847 
     1848 
     1849 /* <relation> ::= <symbol>   ! */
     1850 
     1851 prod (165):
     1852         goto exit;
     1853 
     1854 
     1855 
     1856 
     1857 /* <relation_label> ::= <symbol> ! */
     1858 
     1859 prod (166):
     1860         goto exit;
     1861 
     1862 
     1863 
     1864 
     1865 /* <attribute> ::=  <symbol>   ! */
     1866 
     1867 prod (167):
     1868         goto exit;
     1869 
     1870 
     1871 
     1872 
     1873 /* <fn_name> ::= <symbol> ! */
     1874 
     1875 prod (168):
     1876         if dbcb.sfi_ptr = null () then do;
     1877 	  call mrds_dsl_get_builtins (dbcb_ptr, code);
     1878 	  if code ^= 0 then call error (code, LOUD, 0, WCF_TYPE, "");
     1879         end;
     1880 
     1881         current_func_level = current_func_level + 1;	/* now make a new function level */
     1882         allocate exp_fun_data in (select_area);
     1883         unspec (exp_fun_data) = "0"b;
     1884         func_efd_ptrs (current_func_level) = efd_ptr;
     1885 
     1886         current_expr_level = current_expr_level + 1;	/* and since a function is a expression, a new one of these */
     1887         allocate exp_fun_data in (select_area);
     1888         unspec (exp_fun_data) = "0"b;
     1889         expr_efd_ptrs (current_expr_level) = efd_ptr;
     1890 
     1891         call mrds_dsl_expr_$init (psi_ptr,current_expr_level);
     1892         call mrds_dsl_func_$init (psi_ptr,dbcb_ptr, lex_token, dbcb.sfi_ptr,
     1893 	   select_area_ptr,
     1894 	   current_func_level, code)
     1895 	   ;
     1896         if code ^= 0 then call error (code, ^LOUD, 0, "", "");
     1897 
     1898         goto exit;
     1899 
     1900 
     1901 
     1902 
     1903 /* <alias> ::=  <symbol>   ! */
     1904 
     1905 prod (169):
     1906         goto exit;
     1907 
     1908 
     1909 exit:
     1910         return;
     1911 
     1912 get_relation_statistics:
     1913     procedure (code);
     1914 
     1915 /* DESCRIPTION:
     1916*
     1917*   This routine updates the current relation  population  statistics
     1918*   for  each  relation  in the range clause for this block. Temp rel
     1919*   stats never need to be updated, they are set at definition  time.
     1920*   Perm  rels  are  updated  at  first  reference  time,  and  every
     1921*   mrds_data_$ statistic_update_count_interval reference  times,  or
     1922*   mrds_data_$statistics_update_time_interval   elapsed  real  time,
     1923*   whichever comes first. Small size relations have their statistics
     1924*   updated  every  selection  expression,  to avoid large perenctage
     1925*   changes over few update I/O operations,  "small"  is  defined  in
     1926*   mrds_data_$statistics_update_small_rel_size.      The     current
     1927*   statistics  are  expected  to  be  reasonable  accurate  for  the
     1928*   optimization  of  search  costs  done  in  mrds_dsl_permute.  The
     1929*   statistics kept are the number of  tuples  in  the  relation  and
     1930*   number of dupliacte index values for each index.
     1931*
     1932**/
     1933 
     1934 dcl     i			 fixed bin;		/* loop index */
     1935 dcl     mrds_data_$statistics_update_count_interval
     1936 			 fixed bin (35) ext;	/* number of rel refs before update needed */
     1937 dcl     mrds_data_$statistics_update_small_rel_size
     1938 			 fixed bin (35) ext;	/* num tuples below which
     1939*						   must update stats every S.E. */
     1940 dcl     mrds_data_$statistics_update_time_interval
     1941 			 fixed bin (71) ext;	/* number of real microsecs before update needed */
     1942 dcl     code		 fixed bin (35);		/* local error code */
     1943 dcl     mu_rel_statistics$record_statistics
     1944 			 entry (fixed bin (35), entry, entry, entry,
     1945 			 entry, entry, ptr, ptr, ptr,
     1946 			 fixed bin (35), fixed bin (35));
     1947 
     1948 dcl     current_time	 fixed bin (71);		/* variable for current time */
     1949 
     1950 
     1951         current_time = clock ();
     1952 
     1953 /* go through all relations referenced in the range clause */
     1954 
     1955         do i = 1 to range.num_vars while (code = 0);
     1956 
     1957 	  if ^range.tup_var (i).temp_rel then do;	/* only need to update perm rels */
     1958 
     1959 	      rmri_ptr = range.tup_var (i).ri_ptr;
     1960 
     1961 /* don't update relations already seen in this selection expresion */
     1962 
     1963 	      if rm_rel_info.last_statistics_update_s_e_ref_num
     1964 		 ^= dbcb.last_s_e_id_num then do;
     1965 
     1966 		if rm_rel_info.last_statistics_update_count ^= 0
     1967 		then /* 0 => never got stats */
     1968 		     rm_rel_info.last_statistics_update_count =
     1969 			rm_rel_info.last_statistics_update_count + 1;
     1970 						/* add to ref cnt */
     1971 
     1972 		if rm_rel_info.last_statistics_update_count = 0
     1973 		     | rm_rel_info.current_tuple_population
     1974 		     <= mrds_data_$statistics_update_small_rel_size
     1975 		     | rm_rel_info.last_statistics_update_count
     1976 		     > mrds_data_$statistics_update_count_interval
     1977 		     | current_time
     1978 		     - rm_rel_info.last_statistics_update_time
     1979 		     > mrds_data_$statistics_update_time_interval then do;
     1980 						/* time to do update */
     1981 
     1982 		    call mu_rel_statistics$record_statistics (dbcb.dbi,
     1983 		         dbcb.relmgr_entries.create_cursor,
     1984 		         dbcb.relmgr_entries.open,
     1985 		         dbcb.relmgr_entries.get_duplicate_key_count,
     1986 		         dbcb.relmgr_entries.get_population,
     1987 		         dbcb.relmgr_entries.get_count,
     1988 		         dbcb.cursor_ptrs_storage_ptr,
     1989 		         dbcb.cursor_storage_area_ptr, rmri_ptr,
     1990 		         dbcb.last_s_e_id_num, code);
     1991 
     1992 		    if caller = mrds_data_$caller_compile
     1993 		         & rm_rel_info.current_tuple_population = 0
     1994 		    then rm_rel_info.current_tuple_population = 5;
     1995 		end;
     1996 	      end;
     1997 	  end;
     1998         end;
     1999     end get_relation_statistics;
     2000 
     2001 get_attribute_info:
     2002     proc (attribute, key, rel_index, attr_index);
     2003 						/* procedure to check an attribute and get the info for it */
     2004 dcl     (rel_index, attr_index)
     2005 			 fixed bin parameter;
     2006 dcl     (attribute, key)	 bit (1) aligned parameter;
     2007 dcl     (rel_pos, attr_pos)	 fixed bin;
     2008 
     2009         range_ptr = static_data.range_ptr;
     2010         if attribute then do;				/* find relation and attribute positions in lex stack */
     2011 	  if key then do;				/* found a * after attribute for temp rel */
     2012 	      rel_pos = 3;
     2013 	      attr_pos = 1;
     2014 	  end;
     2015 	  else do;
     2016 	      rel_pos = 2;
     2017 	      attr_pos = 0;
     2018 	  end;
     2019         end;
     2020         else rel_pos, attr_pos = 0;
     2021 
     2022         rel_name = get_stacked_token (ls_top - rel_pos);
     2023         attr_name = get_stacked_token (ls_top - attr_pos);
     2024 
     2025 /* make sure the relation name is good */
     2026         do rel_index = 1 to range.num_vars
     2027 	   while (rel_name ^= range.tup_var.name (rel_index));
     2028         end;
     2029 
     2030         if rel_index > range.num_vars
     2031         then call error (mrds_error_$bad_var, LOUD, rel_pos, SE_TYPE,
     2032 	        "The relation identifier '" || rtrim (rel_name)
     2033 	        || "' is unknown in this opening.");
     2034 
     2035         if range.tup_var.temp_rel (rel_index)
     2036         then rmra_ptr = static_data.rdbi_ptr -> rm_db_info.tra_ptr;
     2037         else rmra_ptr = static_data.rdbi_ptr -> rm_db_info.ra_ptr;
     2038 
     2039         static_data.rmri_ptr, rmri_ptr =
     2040 	   rm_rel_array.rel_data
     2041 	   .ri_ptr (range.tup_var.rel_index (rel_index));
     2042 
     2043         if attribute then do;
     2044 	  do attr_index = 1 to rm_rel_info.num_attr
     2045 	       while (attr_name
     2046 	       ^= rm_rel_info.attr_ptrs (attr_index) -> rm_attr_info.name);
     2047 	  end;
     2048 
     2049 	  if attr_index > rm_rel_info.num_attr
     2050 	  then call error (mrds_error_$bad_attr, LOUD, attr_pos, SE_TYPE,
     2051 		  "The attribute '" || rtrim (attr_name)
     2052 		  || "' does not exist in the relation '"
     2053 		  || rtrim (rm_rel_info.name) || "'.");
     2054         end;
     2055 
     2056     end get_attribute_info;
     2057 
     2058 dbf:
     2059     entry ();
     2060         debug = "0"b;
     2061         return;
     2062 
     2063 dbn:
     2064     entry ();
     2065         debug = "1"b;
     2066         return;
     2067 
     2068 
     2069 error:
     2070     proc (cd, loud, stack_offset, error_type, message);
     2071 
     2072 dcl     cd		 fixed bin (35);		/* standard error code */
     2073 dcl     loud		 bit (1) aligned;		/* OFF => dont print or signal error */
     2074 dcl     stack_offset	 fixed bin;		/* offset from ls_top of where token is in lex stack */
     2075 dcl     error_type		 char (*);
     2076 dcl     message		 char (*);
     2077 
     2078         se_info_ptr = dbcb.se_info_ptr;
     2079         code = cd;
     2080 
     2081         if se_info.error_info_supplied then do;		/* sombody else did the dirty work */
     2082 						/* now just get the token */
     2083 	  se_info.token_length =
     2084 	       lex_stack.token_length (ls_top - se_info.stack_offset);
     2085 	  se_info.token_start =
     2086 	       lex_stack.token_start_pos (ls_top - se_info.stack_offset);
     2087         end;
     2088 
     2089         else do;
     2090 	  se_info.loud = loud;
     2091 	  se_info.error_type = error_type;
     2092 	  se_info.token_start =
     2093 	       lex_stack.token_start_pos (ls_top - stack_offset);
     2094 	  se_info.token_length =
     2095 	       lex_stack.token_length (ls_top - stack_offset);
     2096 
     2097 	  if code = mrds_error_$unimplemented_syntax
     2098 	  then se_info.error_msg =
     2099 		  "Unimplemented token is '"
     2100 		  || get_stacked_token (ls_top - stack_offset) || "'.";
     2101 	  else se_info.error_msg = message;
     2102         end;
     2103 
     2104         goto exit;
     2105 
     2106     end error;
     2107 
     2108 get_next_arg:
     2109     proc (a_ptr, d_ptr);
     2110 dcl     (d_ptr, a_ptr)	 ptr;
     2111 
     2112         if num_args < 1
     2113         then call error (mrds_error_$insuff_args, ^LOUD, 0, "", "");
     2114 
     2115         a_ptr = argp_ptr -> based_ptr;			/* get ptr to arg */
     2116         d_ptr, desc_ptr = descp_ptr -> based_ptr;		/* and ptr to desc. */
     2117 
     2118         if descriptor.type = VAR_CHAR | descriptor.type = VAR_BIT
     2119         then
     2120 	   /* if varying */
     2121 	   a_ptr = addrel (a_ptr, -1);		/* include length */
     2122 
     2123         argp_ptr = addrel (argp_ptr, 2);		/* adjust argp_ptr to bypass this arg */
     2124         descp_ptr = addrel (descp_ptr, 2);		/* and the descp_ptr */
     2125         num_args = num_args - 1;			/* and the remaining arg count */
     2126 
     2127     end get_next_arg;
     2128 
     2129 get_stacked_token:
     2130     proc (position) returns (char (*));
     2131 dcl     position		 fixed bin;
     2132 dcl     len		 fixed bin;
     2133 dcl     token		 char (len) based;
     2134         len = lex_stack (position).token_length;
     2135         return (lex_stack (position).token_ptr -> token);
     2136     end get_stacked_token;
     2137 
     2138 init_expression:
     2139     proc;
     2140 
     2141 /* This proc is called for every argument in an expression to make
     2142*   sure that we will have a exp_fun_data structure to put the expression
     2143*   into. It checks to see if our func level is the same as our expr level
     2144*   and makes a new struct if it is. The only time the func and expr level
     2145*   are the same is if the current expr is a func. The parser does not know
     2146*   when it encounters a new expression so we have to help it a little.
     2147**/
     2148 
     2149         if current_expr_level = current_func_level then do;
     2150 	  current_expr_level = current_expr_level + 1;	/* make a new expr level */
     2151 	  allocate exp_fun_data in (select_area);
     2152 	  unspec (exp_fun_data) = "0"b;
     2153 	  expr_efd_ptrs (current_expr_level) = efd_ptr;
     2154 	  call mrds_dsl_expr_$init (psi_ptr,current_expr_level);
     2155         end;
     2156 
     2157     end;
     2158 
     2159 init_select_list:
     2160     proc;
     2161 
     2162 /* routine to initialize a select_list structure. This holds the select clause */
     2163         allocate select_list in (select_area) set (static_data.select_list_ptr);
     2164         select_list_ptr = static_data.select_list_ptr;
     2165         select_list.mla_ptr = null ();
     2166         allocate free_relations in (select_area);
     2167         free_relations.num_free_rels = 0;
     2168         string (select_list.var_exists) = "0"b;
     2169         select_list.num_vars, select_list.num_items = 0;	/* init. to empty */
     2170     end;
     2171 
     2172 process_set_op:
     2173     proc (type);
     2174 
     2175 dcl     type		 fixed bin;
     2176 
     2177         if dbcb.ss_ptr = null then do;			/* first time */
     2178 	  dbcb.val_rtrv,				/* init valid. flags */
     2179 	       dbcb.val_dtr = "1"b;
     2180 	  dbcb.val_mod,
     2181 	       dbcb.val_del = "0"b;
     2182 
     2183 	  nitems_init = 2 * mrds_data_$max_sets;	/* set up select sets structure */
     2184 	  allocate select_sets in (select_area);
     2185 	  select_sets.dup_retain = "0"b;
     2186 	  select_sets.nitems = 0;
     2187 	  dbcb.ss_ptr = ss_ptr;
     2188 
     2189 	  do k = 1 to static_data.select_list_ptr -> select_list.num_items;
     2190 	      select_sets.domains (k) =
     2191 		 static_data.select_list_ptr -> select_list.ai_ptr (k)
     2192 		 -> rm_attr_info.domain_ptr -> rm_domain_info.name;
     2193 	  end;
     2194 
     2195 	  op_top = 0;
     2196 
     2197         end;
     2198         else do;
     2199 	  ss_ptr = dbcb.ss_ptr;
     2200 	  nitems_init = 2 * mrds_data_$max_sets;
     2201         end;
     2202 
     2203         if se_pending then do;
     2204 	  if select_sets.nitems + 1 >= nitems_init	/* check for the se and its required oper */
     2205 	  then call error (mrds_error_$set_ovfl, LOUD, 0, SE_TYPE, "");
     2206 
     2207 	  select_sets.nitems = select_sets.nitems + 1;
     2208 	  select_sets.items.oper_flag (select_sets.nitems) = "0"b;
     2209 						/* not an operator */
     2210 	  select_sets.items.range_ptr (select_sets.nitems) = dbcb.range_ptr;
     2211 	  select_sets.items.select_ptr (select_sets.nitems) =
     2212 	       dbcb.select_ptr;
     2213 	  select_sets.items.ti_ptr (select_sets.nitems) = dbcb.ti_ptr;
     2214 	  select_sets.items.so_ptr (select_sets.nitems) = dbcb.so_ptr;
     2215 
     2216 	  se_pending = "0"b;
     2217         end;
     2218 
     2219         allocate range in (select_area) set (static_data.range_ptr);
     2220         static_data.range_ptr -> range.num_vars = 0;
     2221 
     2222         pred_tree_ptr = null;
     2223 
     2224         if op_top >= mrds_data_$max_sets
     2225         then /* if overflowing operator stack */
     2226 	   call error (mrds_error_$set_ovfl, LOUD, 0, SE_TYPE, "");
     2227 
     2228         op_top = op_top + 1;
     2229         op_stack (op_top) = type;
     2230 
     2231     end process_set_op;
     2232 
     2233 init:
     2234     entry (a_lex_stack_ptr, a_se_info_ptr, a_dbcb_ptr, psi_ptr, a_area_ptr, a_caller,
     2235          a_option_list_ptr, a_argp_ptr, a_descp_ptr, a_num_args, a_cur_sw);
     2236 
     2237         allocate static_data in (parser_work_area);
     2238 
     2239 /* copy the outside world into static locals */
     2240         static_data.lex_stack_ptr = a_lex_stack_ptr;
     2241         dbcb_ptr, static_data.dbcb_ptr = a_dbcb_ptr;
     2242         static_data.area_ptr = a_area_ptr;
     2243         static_data.caller = a_caller;
     2244         static_data.option_list_ptr = a_option_list_ptr;
     2245         static_data.argp_ptr = a_argp_ptr;
     2246         static_data.descp_ptr = a_descp_ptr;
     2247         static_data.num_args = a_num_args;
     2248         static_data.cur_sw = a_cur_sw;
     2249         dbcb.se_info_ptr = a_se_info_ptr;
     2250 
     2251         select_area_ptr, static_data.select_area_ptr = dbcb.select_area_ptr;
     2252         static_data.trl_ptr, static_data.x_pred_leaf_ptr, pred_tree_ptr = null;
     2253         static_data.char_descriptor.type="5260"b3;
     2254         current_expr_level, current_func_level = 0;
     2255 
     2256 
     2257 /* Range clause initializations */
     2258         if cur_sw
     2259         then static_data.range_ptr = dbcb.range_ptr;
     2260         else do;
     2261 	  allocate range in (select_area) set (static_data.range_ptr);
     2262 	  static_data.range_ptr -> range.num_vars = 0;
     2263         end;
     2264 
     2265         static_data.rdbi_ptr = dbcb.rdbi_ptr;
     2266 
     2267         return;
     2268 
  1     1 /*  BEGIN INCLUDE FILE ..... mrds_lex_stack.incl.pl1 ..... 11/27/85 Hergert.MRDS */
  1     2 
  1     3 /****^  HISTORY COMMENTS:
  1     4*  1) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  1     5*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  1     6*     Created for for new parser.
  1     7*                                                   END HISTORY COMMENTS */
  1     8 
  1     9 dcl 1 lex_stack (-3:100) based (lex_stack_ptr) aligned,
  1    10 						/* 3:-1 is the FIFO lookahead stack
  1    11*						   1:50 is the LIFO lexical stack */
  1    12     2 invariant_part,				/* LALR predefined data */
  1    13       3 token_ptr ptr,				/* pointer to symbol (must be valid) */
  1    14       3 token_length fixed bin,	          	/* length of symbol (may be 0) */
  1    15       3 token_start_pos fixed bin,                          /* start position of symbol */
  1    16       3 token_id fixed bin;				/* encoding of the symbol */
  1    17 
  1    18 /* END INCLUDE FILE ..... mrds_lex_stack.incl.pl1 ..... */
     2269 
     2270 
  2     1 /* BEGIN INCLUDE FILE  mrds_se_info.incl.pl1 
  2     2*
  2     3*   These contains information relating to the selection expression.
  2     4*
  2     5**/
  2     6 
  2     7 /****^  HISTORY COMMENTS:
  2     8*  1) change(85-08-05,Hergert), approve(88-06-28,MCR7903),
  2     9*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  2    10*     Created for for new parser.
  2    11*                                                   END HISTORY COMMENTS */
  2    12 
  2    13 dcl     1 se_info		 aligned based (se_info_ptr),
  2    14 	2 se_ptr		 ptr,			/* points to the beginning of the selection expression */
  2    15 	2 se_length	 fixed bin,		/* length of the selection expression */
  2    16 	2 se_cursor	 fixed bin,		/* current place in se */
  2    17 	2 flags,
  2    18 	  3 pso_seen	 bit,			/* -pso supplied in se */
  2    19 	  3 no_ot_seen	 bit,			/* -no_ot supplied in se */
  2    20           2 error_report,
  2    21 	  3 error_info_supplied bit aligned,              /* ON -> structure already filled in */
  2    22 	  3 loud             bit aligned,                	/* ON -> call mu_print_error */
  2    23             3 token_start      fixed bin,                   /* position in se where token starts */
  2    24             3 token_length     fixed bin,                   /* length of token in se */
  2    25 	  3 error_code       fixed bin(35),               /* system error code */
  2    26             3 stack_offset     fixed bin,                   /* how far down the token is in the lex stack */
  2    27             3 error_type       char(24),                    /* type of error. ie range, select where... */
  2    28 	  3 error_msg        char(256);         	/* message to explain problem */
  2    29 
  2    30 
  2    31 /* various types of errors. actually the string that is reported in the
  2    32*   error message. */
  2    33 dcl     RC_TYPE		 char (12) internal static
  2    34 			 options (constant) init ("Range Clause");
  2    35 dcl     SE_TYPE		 char (20) internal static
  2    36 			 options (constant)
  2    37 			 init ("Selection Expression");
  2    38 dcl     SC_TYPE		 char (13) internal static
  2    39 			 options (constant)
  2    40 			 init ("Select Clause");
  2    41 dcl     WC_TYPE		 char (12) internal static
  2    42 			 options (constant)
  2    43 			 init ("Where Clause");
  2    44 dcl     WCE_TYPE		 char (23) internal static
  2    45 			 options (constant)
  2    46 			 init ("Where Clause Expression");
  2    47 dcl     WCF_TYPE		 char (21) internal static
  2    48 			 options (constant)
  2    49 			 init ("Where Clause Function");
  2    50 dcl     AV_TYPE		 char (16) internal static
  2    51 			 options (constant)
  2    52 			 init ("Access Violation");
  2    53 dcl     IL_TYPE		 char (14) internal static
  2    54 			 options (constant)
  2    55 			 init ("Internal Logic");
  2    56 
  2    57 /* parser_work_area is used to hold all static data for an invocation
  2    58*   of the parser. parser_static_info holds ptrs to all of these relevant
  2    59*   data and also a ptr back to the area it is allocated in. 
  2    60*   parser_work_area.
  2    61**/
  2    62 
  2    63 dcl parser_work_area aligned area (sys_info$max_seg_size) based (parser_static_info.pwa_ptr);
  2    64 
  2    65 dcl psi_ptr ptr;
  2    66 dcl 1 parser_static_info aligned based (psi_ptr),
  2    67       2 pwa_ptr ptr,
  2    68       2 semantics, /* for mrds_dsl_semantics */
  2    69         3 static_data_ptr ptr,
  2    70       2 expr, /* for mrds_dsl_expr_ */
  2    71         3 data_stacks_ptr ptr,
  2    72       2 func, /* for mrds_dsl_func_ */
  2    73         3 sfptrs_ptr ptr,
  2    74       2 where_clause, /* for mrds_dsl_where_clause_ */
  2    75         3 ns_ptr ptr;
  2    76 
  2    77 
  2    78 /* END INCLUDE FILE  mrds_se_info.incl.pl1 */
     2271 
     2272 
  3     1 /* BEGIN INCLUDE mrds_se_options.incl.pl1 */
  3     2 
  3     3 /****^  HISTORY COMMENTS:
  3     4*  1) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  3     5*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  3     6*     Created for for new parser.
  3     7*                                                   END HISTORY COMMENTS */
  3     8 
  3     9 dcl     1 mode_flags	 aligned based (mode_flags_ptr),
  3    10 	2 reset_sw	 bit unal,
  3    11 	2 list_sw 	 bit unal,
  3    12           2 extras             bit (34) unal,
  3    13 	2 selected           aligned like option_list,
  3    14 	2 value              like option_list;
  3    15 
  3    16 
  3    17 dcl     1 option_list aligned based (option_list_ptr),
  3    18 	2 pso		 bit unal,
  3    19 	2 pse		 bit unal,
  3    20 	2 ot		 bit unal,
  3    21 	2 force		 bit unal,
  3    22 	2 error		 bit unal,
  3    23 	2 extras		 bit (31) unal;
  3    24 
  3    25 dcl mode_flags_ptr ptr;
  3    26 dcl option_list_ptr ptr;
  3    27 
  3    28 /* END INCLUDE mrds_se_options.incl.pl1 */
     2273 
     2274 
  4     1 /* BEGIN mrds_dbcb.incl.pl1 -- jaw, 11/7/78 */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  4     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  4     8*     This entry is being made to cover the change made on 85-07-01 by Thanh
  4     9*     Nguyen. The scopes_changed flag was added to make checking for this
  4    10*     more efficient (mrds error list #137).
  4    11*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
  4    12*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
  4    13*     Add a bit called dont_check_txn_id to indicate whether or not we should
  4    14*     care if multiple txns use the same selection_expression. (mrds #156)
  4    15*  3) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  4    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  4    17*     Added parser_work_area_ptr and mrds_se_info_ptr for new parser.
  4    18*                                                   END HISTORY COMMENTS */
  4    19 
  4    20 
  4    21 /* WARNING
  4    22*          If the dbcb structure is changed then the mrds_data_
  4    23*          item saved_res_version MUST be incremented to invalidate all
  4    24*          existing saved resultants
  4    25**/
  4    26 
  4    27 /* HISTORY :
  4    28*
  4    29*   modified by Jim Gray - - 80-10-24, to add new_select_expr bit for
  4    30*   tid_list management
  4    31*
  4    32*   81-1-9 Jim Gray : added like reference for  ease  in  making  the
  4    33*   phony resultant in mu_database_index, without having the area dcl
  4    34*   included.
  4    35*
  4    36*   81-06-17 Roger Lackey :  added  last_store_rel_name  for  use  by
  4    37*   mrds_dsl_store
  4    38*
  4    39*   81-06-26 Roger Lackey : Added no_optimize and  print_search_order
  4    40*   switches
  4    41*
  4    42*   81-07-06 Jim Gray : added identifier for  the  current  selection
  4    43*   expression,  so  that relation statistics can be updated relative
  4    44*   to number of selection expressions seem. Also  removed  init  for
  4    45*   last_store_rel_name,   as   this   iw   now   properly   done  in
  4    46*   mrds_dsl_init_res.
  4    47*
  4    48*   81-07-17  Roger Lackey : added pred_ptr and unused_ptrs.
  4    49*
  4    50*   82-08-19  Mike Kubicar : added store_vector field.  This is needed
  4    51*   for the conversion to the relation manager.
  4    52*
  4    53*   82-08-23 Davids: added the relmgr_entries and access_costs
  4    54*   substructures so that the entries and costs can change
  4    55*   depending on the type of database that is opened.
  4    56*
  4    57*   82-09-09 Mike Kubicar : added modify_vector field.  This is needed
  4    58*   since modify uses a different vector type (general) than does store.
  4    59*
  4    60*   82-09-20 Davids: changed names of (store modify)_vector to
  4    61*   (store modify)_vector_ptr. Also (delete modify)_tuple_by_id to
  4    62*   (delete modify)_tuples_by_id. added the element cursor_storage_ptr
  4    63*   which should be inited to null and will be set by mu_cursor_manager_$get
  4    64*   during the first call.
  4    65*
  4    66*   82-09-21 Davids: renamed cursor_storage_ptr to cursor_ptrs_storage_ptr
  4    67*   since it deals with the pointers to the cursors and not the cursors
  4    68*   themelves and added the element cursor_storage_area_ptr which points
  4    69*   to the area where the cursors are kept.
  4    70*
  4    71*   82-09-22 Davids: renamed the transact_ctl_seg to transactions_needed.
  4    72*   the transact_ctl_seg always had a value of 0 and really didn't mean
  4    73*   anything.
  4    74*
  4    75*   82-09-22 Mike Kubicar : added create_relation, create_index and
  4    76*   destroy_relation_by_opening to relmgr_entries.  They are needed
  4    77*   by mrds_dsl_define_temp_rel.
  4    78*
  4    79*   82-09-24 Donna Woodka : added  put_tuple to  relmgr_entries. It
  4    80*   is needed by mu_store.
  4    81*
  4    82*   82-11-12 Davids: changed the declaration of the access_costs from fixed
  4    83*   bin to float bin since the values are not integers.
  4    84*
  4    85*   83-02-02 Davids: added the dbc_uid element. This will allow mrds to make
  4    86*   sure that the dbc_ptr still points to the correct segment. Element was 
  4    87*   added to the end of the structure to allow modules that don't use
  4    88*   the element to continue to reference the dbcb structure without recompiling.
  4    89*
  4    90*   83-02-25 Davids: added the concurrency_on and rollback_on elements. These
  4    91*   are needed so that temp rels can be created with the same file attributes
  4    92*   as the permanent relations.
  4    93*
  4    94*   83-05-02 Mike Kubicar : Deleted get_next_search_specification_ptr and
  4    95*   added the resultant_in_pdir bit.
  4    96*
  4    97*   83-05-18 Davids: reduced the number of reserved bits to 14 (from 15) and
  4    98*   added the res_already_made element.
  4    99*
  4   100*   83-05-24 Mike Kubicar : Updated the relation manager calling sequences.
  4   101*
  4   102*   83-08-03 Mike Kubicar : Added the element_id_list_segment_ptr and removed
  4   103*   one of the unused pointers.
  4   104*
  4   105*   83-09-20 Ron Harvey: Added relmgr_entries.get_population.
  4   106*
  4   107*   84-08-27 John Hergert:  Created compiled_se_info_ptr from unused_ptrs(2)
  4   108*   leaving unused_ptrs(1).
  4   109*
  4   110*   85-01-15 Thanh Nguyen:  Added the work_area_ptr and removed the last
  4   111*   unused_ptrs (1).
  4   112*
  4   113*   85-04-12 Thanh Nguyen:  Added user_started_transaction and 
  4   114*   non_shared_to_shared flags.  Also added se_transaction_id and some more
  4   115*   spare ptrs, entries and reserved storages for future enhancement, since
  4   116*   we changed the saved_res_version from rslt0001 to rslt0002.
  4   117*
  4   118*   85-07-01 Thanh Nguyen:  Added scopes_changed flag.  This flag is set by
  4   119*   common routine of mrds_dsl_set_scope, reset by mrds_dsl_optimize and 
  4   120*   mrds_dsl_gen_srch_prog when building of a new search_vars.
  4   121**/
  4   122 
  4   123 
  4   124 /* this structure is based on the {unique_name}.mrds.dbcb segment
  4   125*   that constitutes the non-secure portion of the resultant model that is
  4   126*   created during the opening of a database. it contains variables that
  4   127*   are used during the runtime access of the database, and an area
  4   128*   for evaluation of requests. it points to four other
  4   129*   segments in the resultant model, {unique_name}.mrds.rdbi, the secure
  4   130*   portion of the resultant(see mdbm_rm_db_info.incl.pl1),
  4   131*   {unique_name}.mrds.select, an area for selection expression evaluation,
  4   132*   {unique_name}.mrds.curdat, and {unique_name}.mrds.stadat, two segments
  4   133*   used in the elimination of duplicate tuples during a retrieve.
  4   134*   the dbcb area holds the structure in mdbm_scope_info.incl.pl1
  4   135*   that is used when the database is using the file scope mechanism
  4   136*   for concurrency control over file readying. the segment overlayed via
  4   137*   mrds_dbc.incl.pl1 structure is pointed to and also handles concurrency control,
  4   138*   across database openings. the pointer to this dbcb structure is kept in a table
  4   139*   which associates database indexes(returned from a call to dsl_$open), with particular
  4   140*   opening instances of resultant models. (see mu_database_index routine) */
  4   141 
  4   142      dcl	   1 dbcb		      aligned based (dbcb_ptr), /* DBCB -- non-secure portion */
  4   143 	     2 data	      like dbcb_data,
  4   144 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (dbcb.static_area))));
  4   145 
  4   146      dcl	   dbcb_ptr	      ptr;
  4   147 
  4   148      declare 1 dbcb_data	      based,		/* info part of dbcb, separated out so that
  4   149*						   like references can avoid getting the area declaration */
  4   150 	     2 rdbi_ptr	      ptr,		/* pointer to write protected mdbm_util_ info. */
  4   151 	     2 range_ptr	      ptr,		/*  ptr to range structure, or null */
  4   152 	     2 select_ptr	      ptr,		/* ptr to select list, or null */
  4   153 	     2 sv_ptr	      ptr,		/* pointer to search variables */
  4   154 	     2 so_ptr	      ptr,		/* pointer to search operators */
  4   155 	     2 ti_ptr	      ptr,		/* pointer to tuple info */
  4   156 	     2 lit_ptr	      ptr,		/* pointer to the literal area, or null */
  4   157 	     2 current_ptr	      ptr,		/* ptr to select list resulting from -current clause */
  4   158 	     2 ss_ptr	      ptr,		/* ptr to select sets block if not simple s.e. */
  4   159 	     2 retr_info_ptr      ptr,		/* ptr to retrieve info area */
  4   160 	     2 trel_info_ptr      ptr,		/* ptr to retrieve info area */
  4   161 	     2 sti_ptr	      ptr,		/* pointer to store info */
  4   162 	     2 dbc_ptr	      ptr,		/*  pointer to the data base control segment */
  4   163 	     2 sfi_ptr	      ptr,		/* points to head of scalar function list */
  4   164 	     2 scope_ptr	      ptr,		/* points to array of scope tuples */
  4   165 	     2 select_area_ptr    ptr,		/* ptr to area for current selection expression allocations */
  4   166 	     2 current_data_ptr   ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  4   167*						   for eliminating duplicate tuples. */
  4   168 	     2 static_data_ptr    ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  4   169*						   for eliminating duplicate tuples. */
  4   170 	     2 store_area_ptr     ptr,		/* temp storage area for dsl_$store */
  4   171 	     2 retrieve_area_ptr  ptr,		/* temp storage for dsl_$retrieve */
  4   172 	     2 modify_area_ptr    ptr,		/* temp storage area for dsl_$modify */
  4   173 	     2 delete_area_ptr    ptr,		/* temp storage area for dsl_$delete */
  4   174 	     2 def_temp_rel_area_ptr ptr,		/* temp storage area for dsl_$define_temp_rel */
  4   175 	     2 pred_ptr	      ptr,		/* Pointer to pred_array */
  4   176 	     2 store_vector_ptr   ptr,		/* Vector structure used during store operations */
  4   177 	     2 modify_vector_ptr  ptr,		/* Used during modifies */
  4   178 	     2 element_id_list_segment_ptr ptr,		/* Points to the segment used to hold element_id_list structures */
  4   179                2 compiled_se_info_ptr ptr,                  /* points to the segment containing all info on compiled sexs */
  4   180 	     2 work_area_ptr        ptr,		/* Work area for encode/decode value allocations in mu_retrieve */
  4   181 	     2 se_info_ptr          ptr,                  /* Points to se_info struct. Primarily for error reports */
  4   182 	     2 parser_work_area_ptr ptr,		/*  work area for parser */
  4   183 	     2 reserved_ptrs      (4) ptr,		/* Reserved for future use */
  4   184 	     2 another_flag	      bit (1) unal,		/* on if predicate was -another */
  4   185 	     2 current_flag	      bit (1) unal,		/* on if predicate was -current clause */
  4   186 	     2 dbc_incr	      bit (1) unal,		/* on if dbc open mode has been incremented for this user */
  4   187 	     2 delete_flag	      bit (1) unal,		/* On if search was called from mrds_dsl_sec_delete */
  4   188 	     2 dup_retain	      bit (1) unaligned,	/* On if dup tuples allowed for retrieval */
  4   189 	     2 prev_select	      bit (1) unal,		/* on if prev. select block processed in this s.e. */
  4   190 	     2 possible_op	      bit (1) unal,		/* on of arith op. allowed */
  4   191 	     2 sel_clause	      bit (1) unal,		/* on if currently in select clause */
  4   192 	     2 dsm_sw	      bit (1) unal,		/* on if data base was opened via data submodel */
  4   193 	     2 val_rtrv	      bit (1) unal,		/* if s.e. valid for retrieve */
  4   194 	     2 val_mod	      bit (1) unal,		/* for modify */
  4   195 	     2 val_del	      bit (1) unal,		/* for delete */
  4   196 	     2 val_dtr	      bit (1) unal,		/* for define temp rel */
  4   197 	     2 transactions_needed bit (1) unal,	/* On => transaction must be started or in progress does
  4   198*                                                                     not imply that the database is of type page_file */
  4   199 	     2 open_mode	      bit (3) unal,		/* 0=>unknown, 1=>r, 2=>u, 3=>er, 4=>eu, >4=>bad */
  4   200 	     2 new_select_expr    bit (1) unal,		/* on => starting a new tid list management period */
  4   201 	     2 no_optimize	      bit (1) unal,		/* On => no optimize */
  4   202 	     2 print_search_order bit (1) unal,		/*  On => print the search order */
  4   203 	     2 resultant_in_pdir  bit (1) unal,		/* On => Temp segments are in the process dir */
  4   204 	     2 res_already_made   bit (1) unal,           /* On => resultant has been made based on a saved copy */
  4   205 	     2 user_started_transaction bit (1) unal,     /* On => user already started his own transaction. */
  4   206 	     2 non_shared_to_shared bit (1) unal,         /* On => user changed the scope from non shared to shared
  4   207*						   inside a sequence of -another selection expression. */
  4   208 	     2 scopes_changed     bit (1) unal,           /* On => scopes had been changed by set_scopes or delete_scopes */
  4   209 	     2 dont_check_txn_id  bit (1) unal,           /* On => cpmd needs same selection exp across multiple txns */
  4   210 	     2 reserved	      bit (10) unal,	/* reserved for future use */
  4   211 	     2 nseq_sch	      fixed bin (35),	/* no. tuples located via sequential search */
  4   212 	     2 nind_sch	      fixed bin (35),	/* no. tuples located via index search */
  4   213 	     2 nhash_sch	      fixed bin (35),	/* no. tuples located via hash search */
  4   214 	     2 nlk_sch	      fixed bin (35),	/* no tuples located via link search */
  4   215 	     2 cur_lit_offset     fixed bin (35),	/* current bit offset in literal string */
  4   216 	     2 dbi	      fixed bin (35),	/* database index for this opening */
  4   217 	     2 last_s_e_id_num    fixed bin (35),	/* identifying number for last selection expression seen */
  4   218 	     2 se_transaction_id  bit (36) aligned,       /* transaction id from beginning of select expression */
  4   219 	     2 last_store_rel_name char (32),		/* Name of relation last used  for store */
  4   220 	     2 cursor_ptrs_storage_ptr ptr,		/* pointer to space where cursor ptrs are stored */
  4   221 	     2 cursor_storage_area_ptr ptr,		/* pointer to area where the cursors are kept */
  4   222 	     2 reserved_words     (10) fixed bin (35),	/* Reserved for future use */
  4   223 	     2 relmgr_entries,			/* relation manager entries */
  4   224 	       3 open	      entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  4   225 	       3 close	      entry (bit (36) aligned, fixed bin (35)),
  4   226 	       3 create_cursor    entry (bit (36) aligned, ptr, ptr, fixed bin (35)),
  4   227 	       3 destroy_cursor   entry (ptr, ptr, fixed bin (35)),
  4   228 	       3 set_scope	      entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35)),
  4   229 	       3 delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  4   230 	       3 modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35)),
  4   231 	       3 get_tuple_by_id  entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  4   232 	       3 get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)),
  4   233 	       3 get_tuple_id     entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  4   234 	       3 put_tuple	      entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  4   235 	       3 get_count	      entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  4   236 	       3 get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35)),
  4   237 	       3 get_population   entry (ptr, fixed bin (35), fixed bin (35)),
  4   238 	       3 create_relation  entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)),
  4   239 	       3 create_index     entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35)),
  4   240 	       3 destroy_relation_by_path entry (char (*), char (*), fixed bin (35)),
  4   241 	       3 reserved_entries (5) entry (),
  4   242 	     2 access_costs,			/* access costs for permute */
  4   243 	       3 total_primary_key_cost float bin,
  4   244 	       3 access_cost      float bin,
  4   245 	       3 access_overhead  float bin,
  4   246 	       3 us_access_cost   float bin,
  4   247 	       3 os_access_cost   float bin,
  4   248 	     2 dbc_uid	      bit (36) aligned,	/* uid of the segment containing the dbc structure */
  4   249 	     2 concurrency_on     bit (1) unal,		/* "1"b implies dmfile concurrency is being used */
  4   250 	     2 rollback_on	      bit (1) unal;		/* "1"b iomplies before journaling is to be done */
  4   251 
  4   252 /* END mrds_dbcb.incl.pl1 */
  4   253 
  4   254 
     2275 
     2276 
  5     1 /* BEGIN mrds_range.incl.pl1 -- jaw, 10/20/78 */
  5     2 
  5     3 /* Modified 83-04-22 by R. Harvey to add needed_bits */
  5     4 
  5     5 dcl 1 range aligned based (range_ptr),
  5     6     2 num_vars fixed bin,				/* number of tuple variables */
  5     7     2 tup_var (mrds_data_$max_tup_var refer (range.num_vars)), /* info for each tuple variable */
  5     8       3 name char (mrds_data_$max_id_len),		/* name of tuple variable */
  5     9       3 temp_rel bit (1) unal,			/* on if temporary relation */
  5    10       3 used bit (1) unal,				/* 1 => this tuple variable is referenced by
  5    11*						   a -select clause. */
  5    12       3 whole_tuple_selected bit (1) unal,		/* the whole tuple variable is referenced in the select clause */
  5    13       3 copy_for_current bit (1) unal,			/* -current requests attributes not previously retrieved */
  5    14       3 copied_for_current bit (1) unal,		/* tuple copied during previous -current */
  5    15       3 reserved bit (31) unal,			/* reserved for future use */
  5    16       3 rel_index fixed bin,				/* index to assoc. relation */
  5    17       3 stv_ptr ptr,				/* simple typed vector */
  5    18       3 idl_ptr ptr,				/* id_list ptr */
  5    19       3 needed_bits aligned,
  5    20         4 attr (mrds_data_$max_attributes) bit (1) unal,
  5    21       3 ri_ptr ptr;					/* pointer to rel info for assoc. relation */
  5    22 
  5    23 dcl  range_ptr ptr;
  5    24 
  5    25 /* END mrds_range.incl.pl1 */
  5    26 
     2277 
     2278 
  6     1 /* Begin mrds_compiled_se_info.incl.pl1 -- John Hergert 09/01/84
  6     2*   Data structure to hold all pertinent information regarding compiled
  6     3*   selection expressions. Most of this information is put into the dbcb
  6     4*   variables having the same names when the compiled selection is referenced.
  6     5**/
  6     6 
  6     7 
  6     8 /****^  HISTORY COMMENTS:
  6     9*  1) change(87-01-22,Hergert), approve(88-05-19,MCR7903),
  6    10*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  6    11*     Removed all references to var_exists_ptr.
  6    12*                                                   END HISTORY COMMENTS */
  6    13 
  6    14 
  6    15 dcl     1 compiled_se_info	 aligned based (compiled_se_info_ptr),
  6    16           2 real_select_area_ptr ptr,                       /* the real one assigned at open time */
  6    17 	2 compile_area_ptr	 ptr,			/* run time work area */
  6    18           2 temp_x_leaf_ptr    ptr,                         /* temp place to hold ptr to pred_leaf_list of .x.'s */
  6    19           2 temp_temp_rel_list_ptr ptr,                     /* temporary holding spot for list of temp rels */
  6    20 	2 number_of_compiled_se                           /* count of number of cse's weve had in this opening */
  6    21 			 fixed bin (35),
  6    22 
  6    23 
  6    24 	2 se_info		 (1                           /* various peices of information needed to describe the se */
  6    25 			 refer (compiled_se_info.number_of_compiled_se)),
  6    26             3 free             bit(1) unal,                 /* indicates whether this se is being used or not */
  6    27             3 dup_retain       bit(1) unal,                 /* se had a -dup in it */
  6    28             3 reserved         bit(34) unal,                /* a few spares */
  6    29             3 se_id_num        fixed bin(35),               /* the unique id num for the se */
  6    30 	  3 seg_ptr	 ptr,			/* points to seg that has compiled se */
  6    31 	  3 saved_ptrs,				/* these point to the various tables in the seg */
  6    32 	    5 select_area_ptr
  6    33 			 ptr,
  6    34 	    5 range_ptr	 ptr,
  6    35 	    5 select_ptr	 ptr,
  6    36 	    5 ti_ptr	 ptr,
  6    37 	    5 ss_ptr	 ptr,
  6    38               5 so_ptr         ptr,
  6    39               5 temp_rel_list_ptr ptr,
  6    40               5 x_leaf_ptr     ptr,                         /* ptr to list of ptrs to pred leaves for .x.'s */
  6    41               5 lit_ptr        ptr,
  6    42               5 reserved       (5) ptr;
  6    43 
  6    44 dcl     compiled_se_info_ptr	 ptr;
  6    45 
  6    46 
  6    47 
  6    48 /* info relating to the attributes and the literal for filling .X.'s */
  6    49 
  6    50 dcl  1 x_pred_leaf  based (x_pred_leaf_ptr) aligned,
  6    51        2 number_of_x fixed bin (35),                       /* number of .x. specified in this selection expr */
  6    52        2 lit_arg_ptr ptr,                                  /* temp pointer to literal arg */
  6    53        2 lit_desc_ptr ptr,                                  /* temp pointer to literal desc */
  6    54        2 info (mrds_data_$max_pred_nodes refer (x_pred_leaf.number_of_x)), /* this should be big enough */
  6    55          3 encode_proc bit unal,                            /* does this .x. have to be encoded */
  6    56          3 pad bit(35) unal,
  6    57          3 encode_entry entry,                              /* encode proc */
  6    58          3 encode_in_desc_ptr ptr,                          /* ptr to input to encode descrptior */
  6    59          3 encode_out_desc_ptr ptr,                         /* ptr to encoded descrptior */
  6    60          3 encode_bit_len fixed bin(35),                    /* length in bits of encoded value */
  6    61          3 lit_val_len fixed bin(35),                       /* length of value in bits to go in lit pool */
  6    62          3 lit_val_ptr ptr;                                 /* ptr to value in lit pool */
  6    63  
  6    64 
  6    65 dcl     x_pred_leaf_ptr     ptr;
  6    66 
  6    67 
  6    68 /* array of names for the temp rels used in a cse */
  6    69 /* these are used to make sure the temp isnt redefined on us after the se is compiled */
  6    70 dcl  1 temp_rel_list based (trl_ptr) aligned,   
  6    71        2 number_of_temp_rels fixed bin(35),  /* total number of temp rels in se including sets */
  6    72        2 temp_rel_info (mrds_data_$max_temp_rels) ,
  6    73          3 name char(32),                    /* model name */
  6    74          3 index fixed bin(35);              /* temp rel index */
  6    75 
  6    76 
  6    77 dcl trl_ptr ptr;
     2279 
     2280 
  7     1 /* BEGIN mdbm_rm_db_info.incl.pl1 -- jaw, 11/7/78 */
  7     2 
  7     3 
  7     4 
  7     5 /****^  HISTORY COMMENTS:
  7     6*  1) change(86-08-13,Hergert),, approve(88-06-28,MCR7903),
  7     7*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  7     8*     Removed change of 84-11-02. i.e. replaced even_word_pad.
  7     9*                                                   END HISTORY COMMENTS */
  7    10 
  7    11 
  7    12 /* WARNING
  7    13*          If the rm_db_info structure is changed then the mrds_data_
  7    14*          item saved_res_version MUST be incremented to invalidate all
  7    15*          existing saved resultants
  7    16**/
  7    17 
  7    18 /*  DESCRIPTION:  This  structure   is   based   on   a   segment
  7    19*   {unique_name}.mrds.rdbi that represents the secure portion of the
  7    20*   resultant model that is created partially at database open  time,
  7    21*   (the rm_file_array, and rm_rel_array) and partially at ready_file
  7    22*   time,    (the    rm_file_info,     rm_rel_info,     rm_attr_info,
  7    23*   rm_domain_info, rm_plink_info and rm_clink_info). it's purpose is
  7    24*   to  provide  an  efficient  means  of  accessing  database  model
  7    25*   information, as seen from the possibly submodel view of the user,
  7    26*   and his current state of "files readied". it is the  secure  part
  7    27*   because  it  contains  the  model  information  which needs to be
  7    28*   protected  from  general  knowledge,  and   this   segment   will
  7    29*   eventually  be  capable  of  being in a lower ring. the structure
  7    30*   itself points to four arrays that are  allocated  in  it's  area,
  7    31*   that  in  turn point to the other structures mentions above, also
  7    32*   allocated in  the  rm_db_info.static_area.  the  arrays  are  the
  7    33*   rm_file_array,  and  rm_rel_array. their are a pair for temporary
  7    34*   relations,  initially  empty,  and  a  pair  for   normal   model
  7    35*   files/relations.  the  normal  rm_file_array  is initialized to a
  7    36*   list of all known file names, the rm_rel_array only gets relation
  7    37*   names   as   files  are  readied.  the  rm_file_array  points  to
  7    38*   rm_file_infos for each file (see mdbm_rm_file_info.incl.pl1)  and
  7    39*   the   rm_rel_array   points  to  rm_rel_info  for  each  relation
  7    40*   "readied". (see mdbm_rm_rel_info.incl.pl1). (the  arrays  are  in
  7    41*   mdbm_rm_file_array.incl.pl1  and mdbm_rm_rel_array.incl.pl1). the
  7    42*   file infos point to contained rel infos, the rel infos  point  to
  7    43*   contained  attr  infos,  and  those in turn to domain infos. (see
  7    44*   mdbm_rm_attr_info.incl.pl1   and    mdbm_rm_domain_info.incl.pl1)
  7    45*   foreign     keys    are    represented    by    the    structures
  7    46*   mdbm_rm_plink_info.incl.pl1, and mdbm_rm_clink_info.incl.pl1. the
  7    47*   pathnames  of the model and submodel, if any, are also maintained
  7    48*   in rm_db_info. the pointer to this rm_db_info segment is obtained
  7    49*   from  the  dbcb  segment tructure(see mrds_dbcb.incl.pl1) see the
  7    50*   individual include files for  further  organization  information,
  7    51*   and particular data structures.
  7    52*
  7    53*   HISTORY:
  7    54*
  7    55*   80-02-01 Jim Gray : Modified to put area on even  word  boundary,
  7    56*   so that define_area_ could be used to make it an extensible area
  7    57*
  7    58*   81-1-9 Jim  Gray  :  added  like  reference  to  make  the  phony
  7    59*   resultant in mu_database_index easier to keep, since no reference
  7    60*   to the area is needed.
  7    61*
  7    62*   81-1-12 Jim Gray : added version of submodel used in  opening  to
  7    63*   resultant.
  7    64*
  7    65*   81-05-13 Rickie E. Brinegar: added the administrator bit  to  the
  7    66*   structure.
  7    67*
  7    68*   81-05-28 Jim Gray : removed pointers to file_arrays,  since  they
  7    69*   are  now  combined  into  the rel_array. Removed the control file
  7    70*   info which was unused. Added pointer  to  head  of  domain  list,
  7    71*   which is to be used to insure only one copy of each domain info.
  7    72*
  7    73*   83-05-19 Davids: Added the  saved_res_version element.
  7    74*
  7    75*   84-11-02 Thanh Nguyen:   Replaced  the  even_word_pad   by   the 
  7    76*   ref_name_proc_ptr  to point  to list  of reference  name of  the
  7    77*   check, encode, or decode proc.
  7    78*
  7    79*   CAUTION: The structure entries from db_version to sm_path  should
  7    80*   not  be moved or have their declarations changed because they are
  7    81*   used in the handling of old version database openings.
  7    82*
  7    83*
  7    84**/
  7    85 
  7    86      dcl	   1 rm_db_info	      aligned based (rdbi_ptr), /* data base info, located at base of res. dm. seg. */
  7    87 	     2 data	      like rm_db_info_data,
  7    88 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (rm_db_info.static_area))));
  7    89 
  7    90      dcl	   rdbi_ptr	      ptr;
  7    91 
  7    92      declare 1 rm_db_info_data      based,		/* separate declaration of info, so others can use
  7    93*						   like reference to it without getting the area as well */
  7    94 	     2 db_version	      fixed bin,		/* version no. of db */
  7    95 	     2 sm_version	      fixed bin unal,	/* version of submodel used unal, 0 if model opening */
  7    96 	     2 val_level	      fixed bin unal,	/* validation level for this db. */
  7    97 	     2 db_path	      char (168),		/* abs. path of db. */
  7    98 	     2 sm_path	      char (168),		/* path of submodel or model */
  7    99 	     2 mdbm_secured	      bit (1) unal,		/* ON => database is secured */
  7   100 	     2 administrator      bit (1) unal,		/* ON => user is an administrator */
  7   101 	     2 pad	      bit (34) unal,	/* for future use */
  7   102 	     2 saved_res_version  char (8),		/* version of the saved resultant in the 
  7   103*                                                               dbcb and rdbi segments in the db dir */
  7   104 	     2 domain_list_ptr    ptr,		/* pointer to head of list of domain_info's */
  7   105 	     2 ra_ptr	      ptr,		/* pointer to rel. array */
  7   106 	     2 tra_ptr	      ptr,		/* to rel array for temp rels */
  7   107 	     2 even_word_pad      fixed bin (71) aligned; /* padding to put area on even word boundary */
  7   108 
  7   109 /* END mdbm_rm_db_info.incl.pl1 */
  7   110 
  7   111 
     2281 
     2282 
  8     1 /* BEGIN mdbm_rm_domain_info.incl.pl1 -- jaw, 9/26/78 */
  8     2 
  8     3 /* WARNING
  8     4*          If the rm_domain_info structure is changed then the mrds_data_
  8     5*          item saved_res_version MUST be incremented to invalidate all
  8     6*          existing saved resultants
  8     7**/
  8     8 
  8     9 /* DESCRIPTION:
  8    10*
  8    11*   This  structure  is  allocated  in  the  mdbm_rm_db_info.incl.pl1
  8    12*   static  area,  once per attribute used in a relation in a readied
  8    13*   file. it is pointed to by the mdbm_rm_attr_info.incl.pl1, and may
  8    14*   point  to  mdbm_rm_ck_and_group.incl.pl1  if  a  "-check"  option
  8    15*   boolean expression was declared for this domain. it contains  the
  8    16*   descriptor  for  this domain data type, and other resultant model
  8    17*   information.
  8    18*
  8    19*
  8    20*   HISTORY:
  8    21*
  8    22*   81-05-06  Rickie  E.  Brinegar:  Modified  ck_proc,  encode_proc,
  8    23*   decode_proc to be entry variables instead of entry pointers. This
  8    24*   allows these programs to be written in languages other than pl1.
  8    25*
  8    26*   81-05-28 Jim Gray : removed unused procedure points,  and  unused
  8    27*   check  stack  structure  elements.  Also made the descriptors bit
  8    28*   (36) in this structure, rather than pointers to  the  descriptors
  8    29*   elsewhere.  Also  removed un-needed redundant assign_ parameters,
  8    30*   that are actually available in the descriptors.
  8    31*
  8    32*
  8    33**/
  8    34 
  8    35 dcl 1 rm_domain_info aligned based (rdi_ptr),		/* domain information */
  8    36     2 name char (32),				/* domain name */
  8    37     2 db_desc bit (36),				/*  to desc. for db. */
  8    38     2 user_desc bit (36),				/* desc for user visible data */
  8    39     2 user_bit_len fixed bin,				/* storage length of users data */
  8    40     2 ck_proc_entry entry variable,			/* to check proc. entry */
  8    41     2 encd_proc_entry entry variable,			/* to encode proc entry */
  8    42     2 decd_proc_entry entry variable,			/* to decode proc entry */
  8    43     2 ck_proc bit (1) unal,				/* Is there a check proc */
  8    44     2 encd_proc bit (1) unal,				/* Is there an encode proc */
  8    45     2 decd_proc bit (1) unal,				/* Is there a decode proc */
  8    46     2 pad bit (33) unal,
  8    47     2 next_domain_ptr ptr ;				/* to next domain, in list of all domains */
  8    48 						/* to check stack and groups */
  8    49 
  8    50 
  8    51 dcl  rdi_ptr ptr int automatic init (null ());
  8    52 
  8    53 /* END mdbm_rm_domain_info.incl.pl1 */
  8    54 
  8    55 
     2283 
     2284 
  9     1 /* BEGIN mdbm_rm_rel_array.incl.pl1 -- jaw, 8/9/78 */
  9     2 
  9     3 /* WARNING
  9     4*          If the rm_rel_array structure is changed then the mrds_data_
  9     5*          item saved_res_version MUST be incremented to invalidate all
  9     6*          existing saved resultants
  9     7**/
  9     8 
  9     9 /* HISTORY:
  9    10*
  9    11*   81-05-28 Jim Gray : added  model_name  and  file_id  as  part  of
  9    12*   combining   funtions   of   file_array  and  rel_array  into  one
  9    13*   structure. This will only allow 1 relation per file model now.
  9    14*   Also changed structure to allow more efficient searching
  9    15*   via and index builtin, rather than a programmed loop.
  9    16*   Search is now I = index(string(rm_rel_array.name), "!" || in_name)
  9    17*   with I = ((I - 1) / 33) + 1 to convert from a char to array index.
  9    18*
  9    19**/
  9    20 
  9    21 
  9    22 /* this structure is allocated in the static are of the structure
  9    23*   in  mdbm_rm_db_info.incl.pl1,  the secure portion of the database
  9    24*   resultant  model  upon  opening  the  database.  two  copies  are
  9    25*   allocated,  one for temporary relations, initially empty, and one
  9    26*   for relations known to the opener, which has a length  sufficient
  9    27*   for  all  relations known to the user, but whose names, etc. will
  9    28*   not be filled  in  until  the  file  containing  that  particular
  9    29*   relation  is readied. the rm_db_info structure contains a pointer
  9    30*   to the rel_arrays, and the array entries, when  "readied",  point
  9    31*   to  the  mdbm_rm_rel_info.incl.pl1  structures  containing  model
  9    32*   information about the relation, it's attributes, etc. */
  9    33 
  9    34 dcl 1 rm_rel_array aligned based (rmra_ptr),		/* array of open relations */
  9    35     2 num_rels fixed bin,				/* no. rels in db. */
  9    36     2 name (1:rm_num_rels_init refer (rm_rel_array.num_rels)) unal,
  9    37       3 mark char (1) unal,				/* separator character = "!" */
  9    38       3 submodel char (32) unal,			/* name of relation is submodel view, model opening => model name */
  9    39     2 rel_data (rm_num_rels_init refer (rm_rel_array.num_rels)),
  9    40       3 model_name char (30),				/* name of relation in model */
  9    41       3 ri_ptr ptr unal ;				/* pointer to rm_rel_info */
  9    42 
  9    43 dcl  rmra_ptr ptr;
  9    44 dcl  rm_num_rels_init fixed bin;
  9    45 
  9    46 /* END mdbm_rm_rel_array.incl.pl1 */
  9    47 
  9    48 
     2285 
     2286 
 10     1 /* BEGIN mdbm_rm_rel_info.incl.pl1 -- jaw, 11/16/78 */
 10     2 
 10     3 /* WARNING
 10     4*          If the rm_rel_info structure is changed then the mrds_data_
 10     5*          item saved_res_version MUST be incremented to invalidate all
 10     6*          existing saved resultants
 10     7**/
 10     8 
 10     9 /* HISTORY:
 10    10*
 10    11*   Modified by Jim Gray - - May 1980, to  include  model  number  of
 10    12*   attributes,   and   varying  attributes,  so  that  partial  view
 10    13*   submodels will have the  info  needed  to  properly  set  up  the
 10    14*   varying length array headers in the tuple structure.
 10    15*
 10    16*   Modified  by  Jim  Gray  -  -  80-11-06,  to  rename   r_perm   =
 10    17*   status_perm,     s_perm    =    append_tuple_perm,    d_perm    =
 10    18*   delete_tuple_perm, and make m_perm = unused_perm.
 10    19*
 10    20*   81-01-23 Jim Gray : added bit to indicate whether the last  model
 10    21*   view attribute was varying character or bit, since a partial view
 10    22*   submodel will not have this information in the resultant, and  it
 10    23*   is  needed for determining the new tuple length in mus_mod_ubtup,
 10    24*   since with exact length storage  of  varying  length  attributes,
 10    25*   each  tuple  can  be  a  different  length,  which is can only be
 10    26*   determined by examining the tuple itself.
 10    27*
 10    28*   81-01-29 Jim Gray : added curent  tuple  count,  to  provide  for
 10    29*   interface  to  allow  temp  rel  population  to  be known, and to
 10    30*   provide a more efficient means of finding an approx. current perm
 10    31*   relation population.
 10    32*
 10    33*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
 10    34*   blocked  files, foreign keys, and ids procedures. Also set number
 10    35*   of files per rel to a constant of 1.
 10    36*
 10    37*   81-05-28 Jim Gray : combined data  from  rm_file_info  into  this
 10    38*   structure so that only one structure per relation is needed.
 10    39*
 10    40*   81-07-02 Jim Gray : added total_key and dup_key vfile  statistics
 10    41*   counts.   Also  added  number  of  operations  count  since  last
 10    42*   statistics update, and a time  since  the  statistics  were  last
 10    43*   updated.
 10    44*
 10    45*   81-07-06 Jim Gray :  added  a  per  selection  expression  update
 10    46*   identifier so that small relations could be updated on a per S.E.
 10    47*   basis
 10    48*
 10    49*   82-04-21 R. Lackey : Added number_selected (ri_niocbs_init refer (rm_rel_info.niocbs)) fixed bin (35)
 10    50*   to end of structure   TR 12205 (Suggestion).
 10    51*   
 10    52*   82-08-19 D. Woodka :  Removed  rm_rel_info.max_data_len  field for
 10    53*   the DMS conversion. 
 10    54*
 10    55*   82-08-30 Davids: added the opening_id element and removed the iocb
 10    56*   array and the niocb element for DMS conversion. Also removed the
 10    57*   number_selected array (and ri_niocbs_init) since subsets are not
 10    58*   going to be used.
 10    59*
 10    60*   82-09-20 Mike Kubicar : changed rm_rel_info.rel_id to bit (36) aligned
 10    61*   so that it can be used with relation manager.  Also added
 10    62*   rm_rel_info.primary_key_index_id for relation manager.
 10    63*
 10    64*   82-09-22 Mike Kubicar : Removed the, now useless, fields var_attr_ptrs,
 10    65*   nvar_atts, model_nvar_atts.
 10    66*
 10    67*   82-09-24 Davids: Removed current_key_count and current_dup_key_count
 10    68*   since the duplicate key count for each secondary index is now being
 10    69*   kept in the attr_info structure and key_count was only needed to
 10    70*   help in calculating the average selectivity of each index which
 10    71*   can now be gotten directly from each index's dup key count. Also
 10    72*   removed the file_id element since it is no longer needed for
 10    73*   anything.
 10    74*
 10    75*   82-09-27 Mike Kubicar : removed file_id_len for the same reason file_id
 10    76*   was removed.
 10    77*
 10    78*   82-11-05 Mike Kubicar : added a pointer to an id_list structure to be
 10    79*   used when retrieving tuples from this relation.
 10    80*
 10    81*   83-04-06 Davids: Added the scope_flags_ptr which points to the scope_flags structure
 10    82*   for the relation. Note that this structure is part of the resultant NOT
 10    83*   part of the db.control structure. The scopes are duplicated in the resultant
 10    84*   to reduce contention for the db.control structure. Note also that the pointer
 10    85*   will always point to a scope_flags structure even if no scopes have been
 10    86*   set on the relation, the structure is allocated when the db is opened.
 10    87**/
 10    88 
 10    89 
 10    90 /* DESCRIPTION:
 10    91*
 10    92*   This structure is allocated in the area part of the structure  in
 10    93*   mdbm_rm_db_info.incl.pl1  as  part of the resultant model created
 10    94*   at open  time  for  a  database.  There  will  be  one  of  these
 10    95*   rm_rel_info   structures  for  each  relation  appearing  in  the
 10    96*   database view (there may be less than the total in  the  database
 10    97*   for  a  submodel  openings).  There  will  also  be  one for each
 10    98*   temporary relation currently defined for that opening.
 10    99*
 10   100*   The structure in mdbm_rm_rel_array.incl.pl1 contains pointers  to
 10   101*   all  rm_rel_info  structures  allocated. It is used for searching
 10   102*   for the appropriate  structure.  This  array  is  pointed  to  by
 10   103*   rm_db_info. There are two arrays, one for perm rels, one for temp
 10   104*   rels.
 10   105*
 10   106*   The      rm_rel_info      structure      points      to       the
 10   107*   mdbm_rm_attr_info.incl.pl1  structures,  one  for  each attribute
 10   108*   appearing in this view of the relation. Each  of  these  in  turn
 10   109*   point  to a mdbm_rm_domain_info.incl.pl1 structure for the domain
 10   110*   info for each attr.
 10   111*
 10   112*   Most of the other information here deals with  specifics  of  the
 10   113*   relation's  logical  definition,  such as key and secondary index
 10   114*   attribute inidicators, security permissions, and  tuple  physical
 10   115*   construction details.
 10   116*
 10   117**/
 10   118 
 10   119      dcl	   1 rm_rel_info	      aligned based (rmri_ptr), /* relation information */
 10   120 	     2 name	      char (32),		/* from submodel */
 10   121 	     2 model_name	      char (30),		/* from model */
 10   122 	     2 rel_id	      bit (36) aligned,	/* unique id. */
 10   123 	     2 retrieve	      bit (1) unal,		/* operations allowed by this view */
 10   124 	     2 modify	      bit (1) unal,
 10   125 	     2 delete	      bit (1) unal,
 10   126 	     2 store	      bit (1) unal,
 10   127 	     2 total_key	      bit (1) unal,		/* on if view includes full primary key */
 10   128 	     2 indexed	      bit (1) unal,		/* on if exists sec. index */
 10   129 	     2 mdbm_secured	      bit (1) unal,		/* on if mdbm must check security */
 10   130 	     2 status_perm	      bit (1) unal,		/* if user has status. perm. */
 10   131 	     2 append_tuple_perm  bit (1) unal,		/* if user has store perm. */
 10   132 	     2 delete_tuple_perm  bit (1) unal,		/* if user has del. perm. */
 10   133 	     2 unused_perm	      bit (1) unal,		/* for future use. */
 10   134 	     2 last_model_attr_char_var bit (1) unal,	/* on => last model varying attr is char */
 10   135 	     2 reserved	      bit (24) unal,	/* for future use */
 10   136 	     2 num_attr	      fixed bin,		/* total no. of attr. in rel. */
 10   137 	     2 model_num_attr     fixed bin,		/* total attrs in model relation */
 10   138 	     2 nkey_attr	      fixed bin,		/* no. of key attr. */
 10   139 	     2 model_nkey_attr    fixed bin,		/* total number of keys in model */
 10   140 	     2 primary_key_index_id bit (36) aligned,     /* Index id of relation's primary key */
 10   141 	     2 nsec_inds	      fixed bin,		/* no. sec. indexes */
 10   142 	     2 max_key_len	      fixed bin (35),	/* max length (chars) of primary key */
 10   143 	     2 current_tuple_population fixed bin (35),	/* last known total  tuple count for this relation */
 10   144 	     2 last_statistics_update_count fixed bin,	/* number of operations's, since this rels stats were updated */
 10   145 	     2 last_statistics_update_time fixed bin (71),/* last time this rels stats were updated */
 10   146 	     2 last_statistics_update_s_e_ref_num fixed bin (35), /* last select expr ID that updated this rels stats */
 10   147 	     2 ready_mode	      fixed bin,		/* 1 => r, 2 => mr, 3 => u, 4 => l, 5 => sr, 6 => su */
 10   148 	     2 file_type	      fixed bin,		/* 1 => unblocked, 2 => blocked, 3 => temporary */
 10   149 	     2 tuple_id_len	      fixed bin,		/* no. bits in local tuple id */
 10   150 	     2 opening_id	      bit (36) aligned,	/* relation manager opening is */
 10   151 	     2 key_attr_ptrs      (nkey_attr_init refer (rm_rel_info.nkey_attr)) ptr, /* ptrs to key attr. */
 10   152 	     2 attr_ptrs	      (natts_init refer (rm_rel_info.num_attr)) ptr, /* ptrs to all attr. */
 10   153 	     2 id_list_ptr        ptr,		/* Id list for retrieves from the relation */
 10   154                2 scope_flags_ptr    ptr;                    /* pointer to the scope_flags structure for the rel */
 10   155 
 10   156      dcl	   rmri_ptr	      ptr;
 10   157      dcl	   (nkey_attr_init,
 10   158 	   natts_init,
 10   159 	   nvar_atts_init)	      fixed bin;
 10   160 
 10   161 /* END mdbm_rm_rel_info.incl.pl1 */
 10   162 
 10   163 
     2287 
     2288 
 11     1 /*  BEGIN  mdbm_rm_attr_info.incl.pl1  --  jaw,  11/16/78  */
 11     2 
 11     3 /* WARNING
 11     4*          If the rm_attr_info structure is changed then the mrds_data_
 11     5*          item saved_res_version MUST be incremented to invalidate all
 11     6*          existing saved resultants
 11     7**/
 11     8 
 11     9 /*
 11    10*
 11    11*   Modified  by  Jim  Gray - - 80-11-05, to add mdbm_secured bit, so
 11    12*   that rm_rel_info does not have to be checked
 11    13*
 11    14*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
 11    15*   foreign keys.
 11    16*
 11    17*   82-08-19  D. Woodka : removed rm_attr_info.bit_offset for the DMS
 11    18*   conversion.
 11    19*
 11    20*   82-09-15 Davids: added the number_of_dups field.
 11    21*
 11    22*   82-09-20 Mike Kubicar : changed the index_id field to be bit (36)
 11    23*   aligned.  This is to conform with the new definition in the database
 11    24*   model.  Also removed the now useless field varying.
 11    25*
 11    26*   82-11-05 Davids: added the field model_defn_order and clarified the
 11    27*   comment for the field defn_order.
 11    28*
 11    29*   83-05-23 Mike Kubicar : changed number_of_dups to fixed bin (35) since
 11    30*   that's what relation manager returns.
 11    31*
 11    32**/
 11    33 
 11    34 
 11    35 /*
 11    36*   this   structure   is   allocated   in   the   static   area   of
 11    37*   mdbm_rm_db_info.incl.pl1  once for each attribute per relation in
 11    38*   a     readied     file.      it     in     turn     points     to
 11    39*   mdbm_rm_domain_info.incl.pl1  for  the  attributes  domain.   the
 11    40*   rm_attr_info  is  pointed  to  by mdbm_rm_rel_info.incl.pl1.  all
 11    41*   structures  are  in  the  rm_db_info  area.   the  attribute data
 11    42*   position  within  a  tuple as stored in the data file are kept in
 11    43*   this resultant model of the attribute.
 11    44* */
 11    45 
 11    46 dcl 1 rm_attr_info aligned based (rai_ptr),		/* resultant attr. info */
 11    47     2 name char (32),				/* from submodel */
 11    48     2 model_name char (32),				/* from model */
 11    49     2 key_attr bit (1) unal,				/* if key attribute */
 11    50     2 index_attr bit (1) unal,			/* if secondary index */
 11    51     2 read_perm bit (1) unal,				/* user has retr. permission */
 11    52     2 modify_perm bit (1) unal,			/* user has modify permission */
 11    53     2 mdbm_secured bit (1) unal,			/* on => database secured */
 11    54     2 reserved bit (30) unal,				/* for future use */
 11    55     2 index_id bit (36) aligned,			/* index id if index_attr */
 11    56     2 defn_order fixed bin,				/* relative order in which attr is defined in the view */
 11    57     2 key_order fixed bin,				/* relative order defined in prim. key */
 11    58     2 bit_length fixed bin (35),			/* length if fixed, max. len. if var. */
 11    59     2 domain_ptr ptr,				/* to domain info */
 11    60     2 number_of_dups fixed bin (35),                        /* if the attribute is indexed this will
 11    61*                                                               be the number of duplicate values, exact
 11    62*                                                               for a page_file database, an estimate for a vfile type */
 11    63     2 model_defn_order fixed bin;                           /* relative order in which attr is defined in the model */
 11    64 
 11    65 dcl  rai_ptr ptr int automatic init (null ());
 11    66 
 11    67 /* END mdbm_rm_attr_info.incl.pl1 */
 11    68 
 11    69 
     2289 
     2290 
 12     1 /* BEGIN INCLUDE FILE mdbm_seg_area.incl.pl1 - - Jim Gray 2/19/79 */
 12     2 
 12     3 /* these structures provide a standard for
 12     4*   1) using an entire segment as an area, managed by the area manager
 12     5*   2) a constant header, that has an offset to the major common structure in the area
 12     6*   the pointer to that structure is obtained via pointer(model_seg_ptr, model_seg.offset)
 12     7*   the model_area_ptr is obtained via pointer(model_seg_ptr, size(model_seg)) */
 12     8 
 12     9 declare 1 model_seg aligned based (model_seg_ptr),	/* segment header, not to be changed */
 12    10         2 struct_offset bit (18),			/* offset to major structure allocated in area */
 12    11         2 padding (3) fixed bin ;			/* to set up four word boundary */
 12    12 
 12    13 declare  model_seg_ptr ptr int automatic init (null ());
 12    14 
 12    15 
 12    16 declare  model_area area (sys_info$max_seg_size - size (model_seg)) based (model_area_ptr) ; /* segment area */
 12    17 
 12    18 declare  model_area_ptr ptr int automatic init (null ());
 12    19 
 12    20 dcl size builtin;
 12    21 
 12    22 /* END INCLUDE FILE mdbm_seg_area.incl.pl1 */
 12    23 
     2291 
     2292 
 13     1 /* BEGIN INCLUDE FILE mrds_select_area.incl.pl1   (Kepner Multics)  05/29/79 1736.1 mst Tue */
 13     2 dcl 1 select_area_struct aligned based (select_area_struct_ptr), /* major structure in segment for current selection expression allocations */
 13     3     2 version fixed bin,
 13     4     2 dbcb_ptr ptr;					/* ptr ptr to dbcb */
 13     5 
 13     6 dcl  select_area_struct_ptr ptr int automatic init (null ());
 13     7 
 13     8 dcl  select_area area (sys_info$max_seg_size - size(model_seg)) based (select_area_ptr);
 13     9 
 13    10 dcl  select_area_ptr ptr int automatic init (null ());
 13    11 						/*   END INCLUDE FILE mrds_select_area.incl.pl1 */
 13    12 
     2293 
     2294 
 14     1 /* BEGIN mdbm_descriptor.incl.pl1 -- jaw 5/31/78 */
 14     2 /* modified by Jim Gray - - Nov. 1979, to change type from fixed bin(5) to
 14     3*   unsigned fixed bin(6), so new packed decimal data types could be handled.
 14     4*   also the duplicate mrds_descriptor.incl.pl1 was eliminated. */
 14     5 
 14     6 dcl 1 descriptor based (desc_ptr),			/* map of Multics descriptor */
 14     7     2 version bit (1) unal,				/* DBM handles vers. 1 only */
 14     8     2 type unsigned fixed bin (6) unal,			/* data type */
 14     9     2 packed bit (1) unal,				/* on if data item is packed */
 14    10     2 number_dims bit (4) unal,			/* dimensions */
 14    11     2 size,					/* size for string data */
 14    12       3 scale bit (12) unal,				/* scale for num. data */
 14    13       3 precision bit (12) unal,			/* prec. for num. data */
 14    14     2 array_info (num_dims),
 14    15       3 lower_bound fixed bin (35),			/* lower bound of dimension */
 14    16       3 upper_bound fixed bin (35),			/* upper bound of dimension */
 14    17       3 multiplier fixed bin (35);			/*  element separation */
 14    18 
 14    19 dcl  desc_ptr ptr;
 14    20 dcl  num_dims fixed bin init (0) ;			/* more useful form of number_dims */
 14    21 
 14    22 /* END mdbm_descriptor.incl.pl1 */
 14    23 
 14    24 
     2295 
     2296 
 15     1 /* BEGIN mrds_select_list.incl.pl1 -- jaw 10/20/78 */
 15     2 
 15     3 /* HISTORY:
 15     4*
 15     5*   81-06-01 Jim Gray : removed user len and type elements,
 15     6*   since mu_convert rather than assign_ is now used.
 15     7*
 15     8*   84-11-22 John Hergert: added fr_ptr
 15     9*
 15    10*/****^  HISTORY COMMENTS:
 15    11*  1) change(86-07-17,Dupuis), approve(86-08-05,MCR7491), audit(86-08-08,Blair),
 15    12*     install(86-08-15,MR12.0-1127):
 15    13*     85-11-22 Hergert: Added variable var_exists so that it may be kept
 15    14*     around per select expression (in sets) and when compiling. (mrds #158)
 15    15*  2) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
 15    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
 15    17*     For new parser, (and general readability) renamed sel_ptr to
 15    18*     select_list_ptr.
 15    19*                                                   END HISTORY COMMENTS */
 15    20 
 15    21 
 15    22 dcl 1 select_list based (select_list_ptr),			/* tabular representation of -select clause */
 15    23     2 num_vars fixed bin,				/* number of free variables */
 15    24     2 mla_ptr ptr,					/* pointer to array of move list pointers */
 15    25     2 fr_ptr ptr,                                           /* pointer to free_raltions struct in mrds_dsl_select_clause */
 15    26     2 num_items fixed bin,				/* number of attributes specified in select list */
 15    27     2 var_exists (36) bit(1),
 15    28     2 item (mrds_data_$max_select_items refer (select_list.num_items)),
 15    29       3 must_convert bit (1) unal,			/* on if conversion required */
 15    30       3 key bit (1) unal,				/* on if to be key attr. in temp. rel. */
 15    31       3 index bit (1) unal,				/* on if index attribute in temp rel */
 15    32       3 reserved bit (33) unal,			/* reserved for future use */
 15    33       3 var_index fixed bin,				/*  index of assoc. tuple variable */
 15    34       3 ai_ptr ptr,					/* ptr to attr_info */
 15    35       3 user_desc_ptr ptr,				/* to descriptor for user value */
 15    36       3 user_ptr ptr ;				/* pointer to user's area */
 15    37 
 15    38 dcl  select_list_ptr ptr int automatic init (null ());
 15    39 
 15    40 dcl 1 move_list_array (select_list.num_vars) based (select_list.mla_ptr),
 15    41     2 var_index fixed bin,
 15    42     2 ml_ptr ptr;
 15    43 
 15    44 /* END mrds_select_list.incl.pl1 */
 15    45 
     2297 
     2298 
 16     1 /* BEGIN mrds_select_sets.incl.pl1		rdl,	2/27/79			*/
 16     2 
 16     3 dcl 1 select_sets aligned based (ss_ptr),
 16     4     2 dup_retain bit (1) unal,			/* ON => duplicate selected tuples must be preserved */
 16     5     2 pad bit (35) unal,				/* Resevered for furture use */
 16     6     2 domains (mrds_data_$max_select_items) char (32),	/* domain name of each select item */
 16     7     2 nitems fixed bin,				/* Number of items in this structure */
 16     8     2 items (nitems_init refer (select_sets.nitems)),
 16     9       3 oper_flag bit (1) unal,			/* On => this item is an operator */
 16    10       3 pad bit (35) unal,				/* Reserved for future use */
 16    11       3 op_code fixed bin,				/* Valid only if oper_flag id on
 16    12*						   1 -> union
 16    13*						   2 => intersection
 16    14*						   3 => Difference 			*/
 16    15       3 range_ptr ptr,				/* Valid only if oper_flag  is OFF, these pointers are */
 16    16       3 select_ptr ptr,				/* used by  mrds_dsl_search */
 16    17       3 so_ptr ptr,
 16    18       3 ti_ptr ptr;					/* to tuple info structure for this block */
 16    19 
 16    20 
 16    21 dcl  ss_ptr ptr;					/* Pointer to the selected sets */
 16    22 dcl  nitems_init fixed bin;
 16    23 
 16    24 dcl  UNION fixed bin internal static options (constant) init (1);
 16    25 dcl  INTERSECTION fixed bin internal static options (constant) init (2);
 16    26 dcl  DIFFERENCE fixed bin internal static options (constant) init (3);
 16    27 
 16    28 /* END mrds_dsl_select_sets.incl.pl1					*/
 16    29 
     2299 
     2300 
 17     1 /* BEGIN mdbm_scope_info.incl.pl1 -- odf 8/8/78 */
 17     2 
 17     3 /* WARNING
 17     4*          If the scope_info or scope_flags structure is changed then the
 17     5*          mrds_data_ item saved_res_version MUST be incremented to invalidate
 17     6*          all existing saved resultants
 17     7**/
 17     8 
 17     9 /* Modified by Jim Gray - - 80-11-17, to add back store/delete/modify permissions */
 17    10 
 17    11 /* 80-12-10 Jim Gray : change name of store to append_tuple, delete to delete_tuple,
 17    12*   modify to modify_attr, retrieve to read_attr, remvoe update, put level 4
 17    13*   qualifiers for permit/prevent modes and to put pads in standard format */
 17    14 
 17    15 /* 80-12-11 Jim Gray : added submodel version of file/rel name for convenience */
 17    16 
 17    17 /* 80-12-22 Jim Gray : added like referenced structure so linus_scope_data.incl
 17    18*   could make use of it for compatibility. */
 17    19 
 17    20 /* 81-1-11 Jim Gray : added touched bit to scope_flags, so that
 17    21*   the fact that null scope has been set can be displayed */
 17    22 
 17    23 /* 85-04-14 Thanh Nguyen: Made scope_flags to be aligned so we could access the
 17    24*   prevent flags from any pointer which directly pointed to scope_flags itself
 17    25*   (i.e rm_rel_info.scope_flags_ptr). */
 17    26 
 17    27 /* this structure is to be allocated in the mrds_dbcb.incl.pl1 static area,
 17    28*   and is used to maintain the scope mechanism for file access.
 17    29*   It contains the scope permit/prevent operations that this user
 17    30*   has set in his view for this opening instance. */
 17    31 
 17    32 dcl 1 scope_info aligned based (scope_ptr),		/* array of scope tuples for this user */
 17    33     2 mbz1 bit (144),				/* Reserved for future use */
 17    34     2 nfiles fixed bin,				/* Number of scope tuples in user's scope */
 17    35     2 active_scopes fixed bin,			/* number of scopes currently active for a given user */
 17    36     2 scope (max_file_init refer (scope_info.nfiles)),	/* defines user's scope of access to files */
 17    37       3 name char (30) aligned,			/* filename */
 17    38       3 sm_name char (32),				/* name of file(rel) in submodel */
 17    39       3 flags like scope_flags ;
 17    40 
 17    41 
 17    42 declare 1 scope_flags aligned based,			/* common layout of scope flag bits */
 17    43         2 permits,					/* modes to permit this user */
 17    44 	3 read_attr bit (1) unal,			/* read_attr access to this file in scope */
 17    45 	3 append_tuple bit (1) unal,			/* append_tuple concnrrency permission */
 17    46 	3 delete_tuple bit (1) unal,			/* delete_tuple concurrency permission on rel */
 17    47 	3 modify_attr bit (1) unal,			/* modify_attr concurrency permission */
 17    48 	3 mbz2 bit (10) unal,			/* for expansion of permit ops */
 17    49         2 prevents,					/* modes to be denyed to other users */
 17    50 	3 read_attr bit (1) unal,			/* on if user has prevent on read_attr for this file */
 17    51 	3 append_tuple bit (1) unal,			/* prevent of append_tuple concurrency */
 17    52 	3 delete_tuple bit (1) unal,			/* prevent of delete_tuple concurrency */
 17    53 	3 modify_attr bit (1) unal,			/* prevent of modify_attr concurrency */
 17    54 	3 mbz3 bit (10) unal,			/* for future prevent concurrency modes */
 17    55         2 touched bit (1) unal,			/* on => scope set for this relation */
 17    56         2 mbz4 bit (7) unal ;				/* for future flags */
 17    57 
 17    58 dcl  max_file_init fixed bin;				/* nbr. of files in data base */
 17    59 dcl  scope_ptr ptr init (null ());			/* points to scope_info array */
 17    60 dcl  scope_rdy bit (6) unal init ("000011"b) int static options (constant); /* scope file ready modes (5 or 6) */
 17    61 dcl  scope_rdy_array (6) bit (1) unal based;		/* array format of scope_rdy string */
 17    62 
 17    63 /* END mdbm_scope_info.incl.pl1 */
     2301 
     2302 
 18     1 /* BEGIN mrds_predicate_tree.incl.pl1 -- jaw, 2/14/79 */
 18     2 
 18     3 /* HISTORY:
 18     4*
 18     5*   81-06-01 Jim Gray : removed assn type and len, now that
 18     6*   mu_convert is being used.
 18     7*
 18     8*
 18     9**/
 18    10 
 18    11 
 18    12 dcl 1 pred_node based (pn_ptr),			/*  structure of predicate tree node */
 18    13     2 type fixed bin,				/*  indicates if node or leaf */
 18    14     2 id unal,					/* id for node */
 18    15       3 lleaf_id like pred_leaf.id,			/* id for left leaf */
 18    16       3 op_code bit (6) unal,				/* operator code for this node */
 18    17       3 rleaf_id like pred_leaf.id,			/* id for right leaf */
 18    18     2 term_type fixed bin (5) unal,			/* if term, indicates type of term */
 18    19     2 root bit (1) unal,				/* on if root node */
 18    20     2 term bit (1) unal,				/* on if node is term */
 18    21     2 determined bit (1) unal,			/* on if term is "determined" independent of other terms */
 18    22     2 reserved bit (21) unal,				/* reserved for future use */
 18    23     2 parent ptr,					/* pointer to parent node */
 18    24     2 lbr ptr,					/* pointer to left branch */
 18    25     2 rbr ptr;					/* pointer to right branch */
 18    26 
 18    27 dcl  pn_ptr ptr;
 18    28 
 18    29 dcl 1 pred_array based (pred_ptr),			/* list representation of pred. */
 18    30     2 type fixed bin,				/*  indicates array, rather than node or leaf */
 18    31     2 num_ands fixed bin,				/* is the number of and groups */
 18    32     2 and_ptr (num_ands_init refer (pred_array.num_ands)) ptr; /* pointers to the and groups */
 18    33 
 18    34 dcl  pred_ptr ptr;
 18    35 
 18    36 dcl 1 and_group based (ag_ptr),			/* list of pointers to all terms in and group */
 18    37     2 num_terms fixed bin,				/* number of terms in list */
 18    38     2 term_ptr (num_terms_init refer (and_group.num_terms)) ptr; /* point to terms in this and group */
 18    39 
 18    40 dcl  ag_ptr ptr;
 18    41 dcl (num_ands_init,
 18    42      num_terms_init) fixed bin;
 18    43 
 18    44 dcl ((CURRENT_OP init ("000001"b)),			/* pred_node op_codes */
 18    45     (AND_OP init ("000010"b)),
 18    46     (OR_OP init ("000011"b)),
 18    47     (NOT_OP init ("000100"b)),
 18    48     (EQ_OP init ("000101"b)),
 18    49     (NE_OP init ("000110"b)),
 18    50     (LT_OP init ("000111"b)),
 18    51     (GT_OP init ("001000"b)),
 18    52     (LE_OP init ("001001"b)),
 18    53     (GE_OP init ("001010"b)),
 18    54     (ALL_OP init ("001011"b))) bit (6) int static options (constant);
 18    55 
 18    56 dcl ((CONST init (1)),				/* pred leaf data types */
 18    57     (ATTR init (2)),
 18    58     (EXPRES init (3))) fixed bin int static options (constant);
 18    59 
 18    60 dcl ((NODE init (0)),				/* type indicators */
 18    61     (LEAF init (1)),
 18    62     (ARRAY init (2))) fixed bin int static options (constant);
 18    63 
 18    64 dcl ((V_C init (1)),				/* pred_node term_types */
 18    65     (V_V init (2))) fixed bin (5) int static options (constant);
 18    66 
 18    67 dcl 1 pred_leaf based (pl_ptr),			/* structure for a predicate tree leaf */
 18    68     2 type fixed bin,				/* indicates if node or leaf */
 18    69     2 id,						/* leaf id */
 18    70       3 var_id bit (18) unal,				/* index of tuple var. */
 18    71       3 attr_id bit (18) unal,			/* defn order of attr. */
 18    72     2 dummy bit (1) unal,				/* on if dummy leaf for ALL_OP */
 18    73     2 reserved bit (35) unal,				/* reserved for future use */
 18    74     2 data_type fixed bin,				/* whether const, attr, or expr */
 18    75     2 lit_offset fixed bin (35),			/* bit offset of literal or expr. result */
 18    76     2 lit_length fixed bin (35),			/* bit length of literal or expr. result */
 18    77     2 rslt_desc bit (36),				/* descriptor of expr. result */
 18    78     2 lit_ptr ptr,					/* ptr to literal or expr. result value */
 18    79     2 lit_desc_ptr ptr,				/* ptr to literal or expr. result desc. */
 18    80     2 ai_ptr ptr,					/* to rm_attr_info for attribute */
 18    81     2 expr_ptr ptr,					/* pointer to expr. structure if expr. leaf */
 18    82     2 parent ptr;					/* pointer to parent node */
 18    83 
 18    84 dcl  pl_ptr ptr;
 18    85 
 18    86 /* END mrds_predicate_tree.incl.pl1 */
 18    87 
     2303 
     2304 
 19     1 /* BEGIN mrds_lit_info.incl.pl1 -- jaw, 2/13/79 */
 19     2 
 19     3 /* HISTORY:
 19     4*
 19     5*   81-05-06  Rickie  E.  Brinegar: The declaration encd_ptr ptr was changed to
 19     6*   encd_entry  entry  and encd_proc bit (1) and pad bit (35) were added.  This
 19     7*   was  done  inoder to permit make use of cu_$generate call and eliminate the
 19     8*   use of cv_ptr_ to generate entry pointers.
 19     9*
 19    10*   81-06-01 Jim Gray : removed assn_len and ass_len structure elements,
 19    11*   as these are not used, with the advent of mu_convert.
 19    12*
 19    13**/
 19    14 
 19    15 dcl 1 lit_info aligned based (lip),			/* info for make literal call */
 19    16     2 src_ptr ptr,					/* to literal source data */
 19    17     2 srcd_ptr ptr,					/* to literal source descr. */
 19    18     2 encd_entry entry,				/* to encode proc. entry */
 19    19     2 encd_proc bit (1) unal,				/* does an encode proc exist? */
 19    20     2 pad bit (35) unal,
 19    21     2 encdd_ptr ptr,				/* to descr. for input to encode proc */
 19    22     2 litd_ptr ptr,					/* to descr. to final liter. val. */
 19    23     2 lit_ptr ptr,					/* to final literal value */
 19    24     2 encd_blen fixed bin (35),			/* to bit length for encode proc input */
 19    25     2 lit_blen fixed bin (35),			/* to bit length for final literal */
 19    26     2 lit_offset fixed bin (35);			/* to offset for final literal in lit. pool */
 19    27 
 19    28 dcl  lip ptr;
 19    29 
 19    30 /* END mrds_lit_info.incl.pl1 */
 19    31 
     2305 
     2306 
 20     1 /* BEGIN INCLUDE FILE mrds_exp_fun_data.incl.pl1 -- jaw 5/20/77 */
 20     2 
 20     3 /* HISTORY:
 20     4*
 20     5*   81-06-01 Jim Gray : removed assn len and type entries,
 20     6*   now that mu_convert is being used.
 20     7*
 20     8**/
 20     9 
 20    10 
 20    11 dcl 1 exp_fun_data based (efd_ptr),			/* data for expression or function */
 20    12     2 var_index fixed bin,				/* index of assoc. tuple variable */
 20    13     2 loc_index fixed bin (18),			/* bit offset within literal pool for result */
 20    14     2 bit_length fixed bin (18),			/* bit length of expr. result */
 20    15     2 descriptor bit (36),				/* descriptor of expr. result */
 20    16     2 assn_ptr ptr,					/* pointer to storage location */
 20    17     2 ef_ptr ptr;					/* pointer to expression structure */
 20    18 
 20    19 dcl  efd_ptr ptr;
 20    20 
 20    21 /* END INCLUDE FILE mrds_exp_fun_data.incl.pl1 */
 20    22 
     2307 
     2308 
     2309 /* declarations are sorted by variable name. Please keep it this way. */
     2310 
     2311 dcl     ATTRIBUTE		 bit (1) aligned init ("1"b) internal
     2312 			 static options (constant);
     2313 dcl     B			 char (1) aligned init ("b") internal
     2314 			 static options (constant);
     2315 dcl     CHAR_SW		 bit (1) aligned init ("1"b) internal
     2316 			 static options (constant);
     2317 dcl     DQ		 char (2) init ("""""") aligned internal
     2318 			 static options (constant);	/* 2 quotes, i hope */
     2319 dcl     EXPRESSION		 bit (1) aligned init ("1"b) internal
     2320 			 static options (constant);
     2321 dcl     FB35		 bit (36) init ("404000000043"b3) internal
     2322 			 static options (constant);
     2323 dcl     HEX_BITS		 (16) char (4)
     2324 			 init ("0000", "0001", "0010", "0011", "0100",
     2325 			 "0101", "0110", "0111", "1000", "1001", "1010",
     2326 			 "1011", "1100", "1101", "1110", "1111")
     2327 			 internal static options (constant);
     2328 dcl     KEY		 bit (1) aligned init ("1"b) internal
     2329 			 static options (constant);
     2330 dcl     LEGAL_CHARACTERS	 (4) char (16)
     2331 			 init ("01", "0123", "01234567",
     2332 			 "0123456789abcdef") internal static
     2333 			 options (constant);
     2334 dcl     LOGICAL_NODE	 bit (1) aligned init ("1"b) internal
     2335 			 static options (constant);
     2336 dcl     LOUD		 bit (1) aligned init ("1"b) internal
     2337 			 static options (constant);
     2338 dcl     NOT_NODE		 bit (1) aligned init ("1"b) internal
     2339 			 static options (constant);
     2340 dcl     QUOTE		 init ("""") char(1) internal static
     2341 			 options (constant);
     2342 dcl     VAR_BIT		 init (20) fixed bin (5) internal static
     2343 			 options (constant);
     2344 dcl     VAR_CHAR		 init (22) fixed bin (5) internal static
     2345 			 options (constant);
     2346 dcl     X_SW		 bit (1) aligned init ("1"b) internal
     2347 			 static options (constant);
     2348 dcl     a_area_ptr		 ptr parameter;
     2349 dcl     a_argp_ptr		 ptr parameter;
     2350 dcl     a_caller		 fixed bin (35) parameter;
     2351 dcl     a_cur_sw		 bit aligned parameter;
     2352 dcl     a_dbcb_ptr		 ptr parameter;
     2353 dcl     a_descp_ptr		 ptr parameter;
     2354 dcl     a_lex_stack_ptr	 ptr parameter;
     2355 dcl     a_num_args		 fixed bin parameter;
     2356 dcl     a_option_list_ptr	 ptr parameter;
     2357 dcl     a_se_info_ptr	 ptr parameter;
     2358 dcl     addcharno		 builtin;
     2359 dcl     addr		 builtin;
     2360 dcl     addrel		 builtin;
     2361 dcl     attr_name		 char (32);
     2362 dcl     b_pos		 fixed bin;
     2363 dcl     base		 fixed bin;
     2364 dcl     based_ptr		 ptr based;
     2365 dcl     binary		 builtin;
     2366 dcl     bit36		 bit (36) based;
     2367 dcl     bit_start_pos          fixed bin;
     2368 dcl     char		 builtin;
     2369 dcl     char_sw		 bit (1) aligned;
     2370 dcl     clock		 builtin;
     2371 dcl     code		 fixed bin (35) parameter;
     2372 dcl     cons		 char (char_descriptor.length)
     2373 			 based (constant_ptr);
     2374 dcl     debug		 bit internal static init ("0"b);
     2375 dcl     descriptor_copy	 bit (36) aligned based (descriptor_copy_ptr);
     2376 dcl     descriptor_copy_ptr	 ptr;
     2377 dcl     divide		 builtin;
     2378 dcl     done		 bit (1) aligned;
     2379 dcl     fixed		 builtin;
     2380 dcl     fixed_bin_35	 fixed bin (35) based;
     2381 dcl     1 free_relations	 based (select_list.fr_ptr) aligned,
     2382 						/* list of relation used in the select clause */
     2383 	2 num_free_rels	 fixed bin,
     2384 	2 free_rels	 (mrds_data_$max_relations) fixed bin;
     2385 						/* array to hold all indicies of free vars */
     2386 dcl     i			 fixed bin;
     2387 dcl     index		 builtin;
     2388 dcl     ioa_		 entry () options (variable);
     2389 dcl     j			 fixed bin;
     2390 dcl     k			 fixed bin;
     2391 dcl     length		 builtin;
     2392 dcl     lex_stack_ptr	 ptr;
     2393 dcl     lex_token		 char (lex_stack (ls_top).token_length)
     2394 			 based (lex_stack (ls_top).token_ptr);
     2395 dcl     literal_area	 area based (dbcb.select_area_ptr);
     2396 dcl     ls_top		 fixed bin parameter;
     2397 dcl     ltrim		 builtin;
     2398 dcl     mrds_data_$caller_compile
     2399 			 fixed bin (35) external static;
     2400 dcl     mrds_data_$max_attributes
     2401 			 fixed bin (35) external static;
     2402 dcl     mrds_data_$max_expr_stack_size	 fixed bin (35) external static;
     2403 dcl     mrds_data_$max_id_len	 fixed bin (35) external static;
     2404 dcl     mrds_data_$max_relations
     2405 			 fixed bin (35) external static;
     2406 dcl     mrds_data_$max_select_items
     2407 			 fixed bin (35) external static;
     2408 dcl     mrds_data_$max_sets	 fixed bin (35) external static;
     2409 dcl     mrds_data_$max_temp_rels
     2410 			 fixed bin (35) external static;
     2411 dcl     mrds_data_$max_tup_var fixed bin (35) external static;
     2412 dcl     mrds_dsl_eval_expr	 entry (ptr, ptr, ptr, ptr, fixed bin (35));
     2413 dcl     mrds_dsl_eval_func	 entry (ptr, ptr, ptr, ptr, fixed bin (35));
     2414 dcl     mrds_dsl_expr_$build_attribute
     2415 			 entry (ptr,ptr, ptr, fixed bin, ptr, fixed bin,
     2416 			 fixed bin (35));
     2417 dcl     mrds_dsl_expr_$build_function
     2418 			 entry (ptr,ptr, ptr, fixed bin, fixed bin (35));
     2419 dcl     mrds_dsl_expr_$build_literal
     2420 			 entry (ptr, ptr,ptr, ptr, bit (1) aligned,
     2421 			 fixed bin, fixed bin (35));
     2422 dcl     mrds_dsl_expr_$condense_stack
     2423 			 entry (ptr, ptr,ptr, char (1) aligned, fixed bin,
     2424 			 fixed bin (35));
     2425 dcl     mrds_dsl_expr_$finish	 entry (ptr,ptr, ptr, fixed bin);
     2426 dcl     mrds_dsl_expr_$init	 entry (ptr,fixed bin);
     2427 dcl     mrds_dsl_func_$build_attribute
     2428 			 entry (ptr,ptr, ptr, fixed bin, ptr, fixed bin,
     2429 			 fixed bin (35));
     2430 dcl     mrds_dsl_func_$build_expr_func
     2431 			 entry (ptr,ptr, ptr, bit (1) aligned, fixed bin,
     2432 			 fixed bin (35));
     2433 dcl     mrds_dsl_func_$build_literal
     2434 			 entry (ptr,ptr, ptr, ptr, fixed bin, fixed bin (35))
     2435 			 ;
     2436 dcl     mrds_dsl_func_$finish	 entry (ptr,ptr, ptr, ptr, ptr, fixed bin,
     2437 			 fixed bin (35));
     2438 dcl     mrds_dsl_func_$init	 entry (ptr,ptr, char (*), ptr, ptr, fixed bin,
     2439 			 fixed bin (35));
     2440 dcl     mrds_dsl_get_builtins	 entry (ptr, fixed bin (35));
     2441 dcl     mrds_dsl_optimize	 entry (ptr, ptr, ptr, fixed bin (35));
     2442 dcl     mrds_dsl_select_clause_$all_attributes
     2443 			 entry (ptr, ptr, ptr, ptr, fixed bin,
     2444 			 bit (1) aligned, fixed bin (35), fixed bin (35))
     2445 			 ;
     2446 dcl     mrds_dsl_select_clause_$finish
     2447 			 entry (ptr, ptr, ptr, ptr, fixed bin (35), ptr,
     2448 			 ptr, ptr, fixed bin, bit (1) aligned,
     2449 			 fixed bin (35));
     2450 dcl     mrds_dsl_select_clause_$one_attribute
     2451 			 entry (ptr, ptr, ptr, ptr, fixed bin, fixed bin,
     2452 			 bit (1) aligned, bit (1) aligned,
     2453 			 fixed bin (35), fixed bin (35))
     2454 			 ;
     2455 dcl     mrds_dsl_where_clause_$build_attribute
     2456 			 entry (ptr,ptr, ptr, fixed bin, ptr, fixed bin (35))
     2457 			 ;
     2458 dcl     mrds_dsl_where_clause_$build_expr
     2459 			 entry (ptr,ptr, ptr, fixed bin (35));
     2460 dcl     mrds_dsl_where_clause_$build_literal
     2461 			 entry (ptr,ptr, ptr, ptr, ptr, ptr, bit (1) aligned,
     2462 			 fixed bin (35));
     2463 dcl     mrds_dsl_where_clause_$build_node
     2464 			 entry (ptr,ptr, ptr, fixed bin, bit (1) aligned,
     2465 			 bit (1) aligned, fixed bin (35));
     2466 dcl     mrds_dsl_where_clause_$finish
     2467 			 entry (ptr,ptr);
     2468 dcl     mrds_error_$bad_attr	 fixed bin (35) external static;
     2469 dcl     mrds_error_$bad_temp_rel_val
     2470 			 fixed bin (35) external static;
     2471 dcl     mrds_error_$bad_var	 fixed bin (35) external static;
     2472 dcl     mrds_error_$curr_not_alld
     2473 			 fixed bin (35) external static;
     2474 dcl     mrds_error_$insuff_args
     2475 			 fixed bin (35) external static;
     2476 dcl     mrds_error_$inv_string fixed bin (35) external static;
     2477 dcl     mrds_error_$inval_comp_expr
     2478 			 fixed bin (35) external static;
     2479 dcl     mrds_error_$max_tup_var
     2480 			 fixed bin (35) external static;
     2481 dcl     mrds_error_$mult_def_var
     2482 			 fixed bin (35) external static;
     2483 dcl     mrds_error_$mult_expr_vars
     2484 			 fixed bin (35) external static;
     2485 dcl     mrds_error_$no_prior_se
     2486 			 fixed bin (35) external static;
     2487 dcl     mrds_error_$set_ovfl	 fixed bin (35) external static;
     2488 dcl     mrds_error_$undef_rel	 fixed bin (35) external static;
     2489 dcl     mrds_error_$undef_temp_rel
     2490 			 fixed bin (35) external static;
     2491 dcl     mrds_error_$unimplemented_syntax
     2492 			 fixed bin (35) external static;
     2493 dcl     mu_convert$convert_data
     2494 			 entry (ptr, ptr, ptr, ptr, fixed bin (35));
     2495 dcl     mu_valid_data_type$valid_scalar_data_type
     2496 			 entry (bit (36)) returns (bit (1) aligned);
     2497 dcl     null		 builtin;
     2498 dcl     prod_no		 fixed bin parameter;
     2499 dcl     rel		 builtin;
     2500 dcl     rel_name		 char (32);
     2501 dcl     reverse		 builtin;
     2502 dcl     rtrim		 builtin;
     2503 dcl     se_info_ptr		 ptr;
     2504 dcl     search		 builtin;
     2505 dcl 1 static_data aligned based (parser_static_info.static_data_ptr),
     2506       2 area_ptr ptr,
     2507       2 arg_ptr ptr,
     2508       2 argp_ptr ptr,
     2509       2 constant_ptr ptr,
     2510       2 dbcb_ptr ptr,
     2511       2 descp_ptr ptr,
     2512       2 descriptor_ptr ptr,
     2513       2 lex_stack_ptr ptr,
     2514       2 pred_tree_ptr ptr,
     2515       2 option_list_ptr ptr,
     2516       2 range_ptr ptr,
     2517       2 rdbi_ptr ptr,
     2518       2 rmri_ptr ptr,
     2519       2 select_area_ptr ptr,
     2520       2 select_list_ptr ptr,
     2521       2 trl_ptr ptr,
     2522       2 x_pred_leaf_ptr ptr,
     2523       2 attr_index fixed bin,
     2524       2 caller fixed bin (35),
     2525       2 char_descriptor aligned,
     2526 	3 type bit (12) unal,
     2527 	3 length fixed bin (23) unal,
     2528       2 cur_sw bit(1) aligned,
     2529       2 se_pending bit (1) aligned,
     2530       2 current_expr_level fixed bin,
     2531       2 current_func_level fixed bin,
     2532       2 num_args fixed bin,
     2533       2 op_top fixed bin,
     2534       2 primary_type char (4) aligned,
     2535       2 rel_index fixed bin,
     2536       2 efd_ptrs (mrds_data_$max_expr_stack_size),
     2537           3 expr_efd_ptrs ptr,
     2538           3 func_efd_ptrs ptr,
     2539       2 op_stack (mrds_data_$max_sets) fixed bin;
     2540 dcl     string		 builtin;
     2541 dcl     string_len		 fixed bin;
     2542 dcl     string_ptr		 ptr;
     2543 dcl     string_token	 char (string_len) based (string_ptr);
     2544 dcl     substr		 builtin;
     2545 dcl     sys_info$max_seg_size	 fixed bin (35) external static;
     2546 dcl     temp_rel_index	 fixed bin (35);
     2547 dcl     unspec		 builtin;
     2548 dcl     verify		 builtin;
     2549 
     2550     end mrds_dsl_semantics;
     2551 
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/01/88  1300.0  mrds_dsl_semantics.pl1            >special_ldd>install>MR12.2-1073>mrds_dsl_semantics.pl1
2269         1    08/01/88  1300.0  mrds_lex_stack.incl.pl1           >special_ldd>install>MR12.2-1073>mrds_lex_stack.incl.pl1
2271         2    08/01/88  1300.0  mrds_se_info.incl.pl1             >special_ldd>install>MR12.2-1073>mrds_se_info.incl.pl1
2273         3    08/01/88  1300.0  mrds_se_options.incl.pl1          >special_ldd>install>MR12.2-1073>mrds_se_options.incl.pl1
2275         4    08/01/88  1300.0  mrds_dbcb.incl.pl1                >special_ldd>install>MR12.2-1073>mrds_dbcb.incl.pl1
2277         5    10/14/83  1609.1  mrds_range.incl.pl1               >ldd>include>mrds_range.incl.pl1
2279         6    08/01/88  1300.0  mrds_compiled_se_info.incl.pl1    >special_ldd>install>MR12.2-1073>mrds_compiled_se_info.incl.pl1
2281         7    08/01/88  1310.7  mdbm_rm_db_info.incl.pl1          >special_ldd>install>MR12.2-1073>mdbm_rm_db_info.incl.pl1
2283         8    10/14/83  1609.1  mdbm_rm_domain_info.incl.pl1      >ldd>include>mdbm_rm_domain_info.incl.pl1
2285         9    10/14/83  1609.1  mdbm_rm_rel_array.incl.pl1        >ldd>include>mdbm_rm_rel_array.incl.pl1
2287        10    10/14/83  1609.1  mdbm_rm_rel_info.incl.pl1         >ldd>include>mdbm_rm_rel_info.incl.pl1
2289        11    10/14/83  1609.1  mdbm_rm_attr_info.incl.pl1        >ldd>include>mdbm_rm_attr_info.incl.pl1
2291        12    10/14/83  1608.6  mdbm_seg_area.incl.pl1            >ldd>include>mdbm_seg_area.incl.pl1
2293        13    10/14/83  1608.6  mrds_select_area.incl.pl1         >ldd>include>mrds_select_area.incl.pl1
2295        14    10/14/83  1608.6  mdbm_descriptor.incl.pl1          >ldd>include>mdbm_descriptor.incl.pl1
2297        15    08/01/88  1300.0  mrds_select_list.incl.pl1         >special_ldd>install>MR12.2-1073>mrds_select_list.incl.pl1
2299        16    10/14/83  1608.4  mrds_select_sets.incl.pl1         >ldd>include>mrds_select_sets.incl.pl1
2301        17    04/18/85  1628.1  mdbm_scope_info.incl.pl1          >ldd>include>mdbm_scope_info.incl.pl1
2303        18    10/14/83  1608.9  mrds_predicate_tree.incl.pl1      >ldd>include>mrds_predicate_tree.incl.pl1
2305        19    10/14/83  1609.1  mrds_lit_info.incl.pl1            >ldd>include>mrds_lit_info.incl.pl1
2307        20    10/14/83  1608.9  mrds_exp_fun_data.incl.pl1        >ldd>include>mrds_exp_fun_data.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ATTRIBUTE                       000357 constant        bit(1)                   initial dcl 2311 set ref 718 738* 749* 1346* 1533*
                                                                                  1599*
B                                      constant        char(1)                  initial dcl 2313 ref 1708
CHAR_SW                                constant        bit(1)                   initial dcl 2315 ref 954 957 1373 1376 1405 1416
DIFFERENCE                             constant        fixed bin(17,0)          initial dcl 16-26 set ref 304*
DQ                                     constant        char(2)                  initial dcl 2317 ref 1645 1673
EXPRESSION                      000357 constant        bit(1)                   initial dcl 2319 set ref 1487* 1521
FB35                            000367 constant        bit(36)                  initial packed unaligned dcl 2321 set ref 573 585
                                                                                  585
HEX_BITS                        000271 constant        char(4)                  initial array packed unaligned dcl 2323 ref 1739
INTERSECTION                           constant        fixed bin(17,0)          initial dcl 16-25 set ref 298*
KEY                             000357 constant        bit(1)                   initial dcl 2328 set ref 718 738 741 749* 752* 1346
                                                                                  1533 1599
LEGAL_CHARACTERS                000251 constant        char(16)                 initial array packed unaligned dcl 2330 ref 1731
LOGICAL_NODE                    000357 constant        bit(1)                   initial dcl 2334 set ref 785* 803* 820* 851
LOUD                            000357 constant        bit(1)                   initial dcl 2336 set ref 177 180* 228* 232* 236*
                                                                                  259* 334 337 382* 386* 517* 536* 547* 568* 579 592
                                                                                  597 626* 643* 651 705* 726 730* 734* 744 755 789
                                                                                  806 824 855 893* 901 907 920 950* 961 969* 976
                                                                                  1010* 1014* 1025* 1029* 1040* 1044* 1055* 1059*
                                                                                  1074* 1078* 1160* 1232 1241 1248 1253* 1271 1273*
                                                                                  1331 1351* 1358 1369* 1380 1388* 1395 1408 1419
                                                                                  1432 1469* 1474 1482* 1489 1501* 1506 1516* 1524
                                                                                  1539* 1546 1553 1559 1571* 1595* 1756* 1842* 1878*
                                                                                  1896 2030* 2049* 2112 2204* 2224*
NOT_NODE                        000357 constant        bit(1)                   initial dcl 2338 set ref 785 803 820* 851
QUOTE                                  constant        char(1)                  initial packed unaligned dcl 2340 ref 1720
RC_TYPE                         000335 constant        char(12)                 initial packed unaligned dcl 2-33 set ref 517* 536*
                                                                                  547* 568*
SE_TYPE                         000330 constant        char(20)                 initial packed unaligned dcl 2-35 set ref 180* 228*
                                                                                  232* 236* 259* 382* 386* 626* 643* 705* 730* 734*
                                                                                  1010* 1014* 1025* 1029* 1040* 1044* 1055* 1059*
                                                                                  1074* 1078* 1160* 1253* 1273* 1571* 1595* 1842*
                                                                                  2030* 2049* 2204* 2224*
UNION                                  constant        fixed bin(17,0)          initial dcl 16-24 set ref 292*
VAR_BIT                                constant        fixed bin(5,0)           initial dcl 2342 ref 2118
VAR_CHAR                               constant        fixed bin(5,0)           initial dcl 2344 ref 2118
WCE_TYPE                        000317 constant        char(23)                 initial packed unaligned dcl 2-44 set ref 893* 969*
                                                                                  1351* 1388* 1469* 1482* 1516*
WCF_TYPE                        000311 constant        char(21)                 initial packed unaligned dcl 2-47 set ref 950* 1369*
                                                                                  1501* 1539* 1878*
WC_TYPE                         000325 constant        char(12)                 initial packed unaligned dcl 2-41 set ref 1756*
X_SW                            000357 constant        bit(1)                   initial dcl 2346 set ref 897 917* 1236 1244 1266
a_area_ptr                             parameter       pointer                  dcl 2348 ref 2233 2242
a_argp_ptr                             parameter       pointer                  dcl 2349 ref 2233 2245
a_caller                               parameter       fixed bin(35,0)          dcl 2350 ref 2233 2243
a_cur_sw                               parameter       bit(1)                   dcl 2351 ref 2233 2248
a_dbcb_ptr                             parameter       pointer                  dcl 2352 ref 2233 2241
a_descp_ptr                            parameter       pointer                  dcl 2353 ref 2233 2246
a_lex_stack_ptr                        parameter       pointer                  dcl 2354 ref 2233 2240
a_num_args                             parameter       fixed bin(17,0)          dcl 2355 ref 2233 2247
a_option_list_ptr                      parameter       pointer                  dcl 2356 ref 2233 2244
a_ptr                                  parameter       pointer                  dcl 2110 set ref 2108 2115* 2118* 2118
a_se_info_ptr                          parameter       pointer                  dcl 2357 ref 2233 2249
addcharno                                              builtin function         dcl 2358 ref 1655
addr                                                   builtin function         dcl 2359 ref 585 585 585 585 897 897 954 954 958 958
                                                                                  1265 1373 1373 1377 1377 1472 1472 1504 1504 1683
                                                                                  1689 1704 1748
addrel                                                 builtin function         dcl 2360 ref 2118 2123 2124
ai_ptr                   12            based           pointer                  array level 3 dcl 15-22 ref 2190
area_ptr                               based           pointer                  level 2 dcl 2505 set ref 173* 647* 891* 948* 1367*
                                                                                  1427* 1467* 1499* 2242*
arg_ptr                   2            based           pointer                  level 2 dcl 2505 set ref 573 585* 1244* 1416* 1556*
                                                                                  1824*
argp_ptr                  4            based           pointer                  level 2 dcl 2505 set ref 173* 647* 2115 2123* 2123
                                                                                  2245*
assn_ptr                  4            based           pointer                  level 2 dcl 20-11 set ref 897* 958* 1377* 1472*
                                                                                  1504*
attr                                   based           bit(1)                   array level 4 packed packed unaligned dcl 5-5 set
                                                                                  ref 1287*
attr_index                             parameter       fixed bin(17,0)          dcl 2004 in procedure "get_attribute_info" set ref
                                                                                  2001 2044* 2044* 2049
attr_index               42            based           fixed bin(17,0)          level 2 in structure "static_data" dcl 2505
                                                                                  in procedure "mrds_dsl_semantics" set ref 718*
                                                                                  738* 741* 749* 752* 1228 1287 1346* 1356 1533*
                                                                                  1544 1599*
attr_name                       000146 automatic       char(32)                 packed unaligned dcl 2361 set ref 2023* 2044 2049
attr_pos                        000241 automatic       fixed bin(17,0)          dcl 2007 set ref 2013* 2017* 2020* 2023 2049*
attr_ptrs                              based           pointer                  array level 2 dcl 10-119 set ref 1228* 1287 1356*
                                                                                  1544* 2044
attribute                              parameter       bit(1)                   dcl 2006 ref 2001 2010 2043
b_pos                           000156 automatic       fixed bin(17,0)          dcl 2362 set ref 1708* 1714 1731 1735 1738
base                            000157 automatic       fixed bin(17,0)          dcl 2363 set ref 1714* 1716* 1731 1735 1739 1739
                                                                                  1739
based_ptr                              based           pointer                  dcl 2364 ref 2115 2116
binary                                                 builtin function         dcl 2365 ref 1716
bit36                                  based           bit(36)                  packed unaligned dcl 2366 set ref 573 579*
bit_start_pos                   000160 automatic       fixed bin(17,0)          dcl 2367 set ref 1721* 1726* 1731 1738
caller                   43            based           fixed bin(35,0)          level 2 dcl 2505 set ref 173* 184 228 610 647* 722*
                                                                                  741* 752* 1992 2243*
cd                                     parameter       fixed bin(35,0)          dcl 2072 ref 2069 2079
char                                                   builtin function         dcl 2368 ref 536 568
char_descriptor          44            based           structure                level 2 dcl 2505 set ref 1265 1689 1704 1748
char_sw                         000161 automatic       bit(1)                   dcl 2369 set ref 954* 957* 958* 1373* 1376* 1377*
clock                                                  builtin function         dcl 2370 ref 1951
code                                   parameter       fixed bin(35,0)          dcl 2371 in procedure "mrds_dsl_semantics" set ref
                                                                                  20 156* 173* 177 177* 333* 334 334* 336* 337 337*
                                                                                  585* 587 647* 651 651* 722* 726 726* 741* 744 744*
                                                                                  752* 755 755* 785* 789 789* 803* 806 806* 820* 824
                                                                                  824* 851* 855 855* 891* 893 893* 897* 901 901*
                                                                                  905* 907 907* 917* 920 920* 948* 950 950* 958* 961
                                                                                  961* 974* 976 976* 1228* 1232 1232* 1236* 1241
                                                                                  1241* 1244* 1248 1248* 1266* 1271 1271* 1327* 1331
                                                                                  1331* 1356* 1358 1358* 1367* 1369 1369* 1377* 1380
                                                                                  1380* 1393* 1395 1395* 1405* 1408 1408* 1416* 1419
                                                                                  1419* 1427* 1432 1432* 1467* 1469 1469* 1472* 1474
                                                                                  1474* 1487* 1489 1489* 1499* 1501 1501* 1504* 1506
                                                                                  1506* 1521* 1524 1524* 1544* 1546 1546* 1550* 1553
                                                                                  1553* 1556* 1559 1559* 1877* 1878 1878* 1892* 1896
                                                                                  1896* 2079* 2097
code                                   parameter       fixed bin(35,0)          dcl 1942 in procedure "get_relation_statistics" set
                                                                                  ref 1912 1955 1982*
compiled_se_info                       based           structure                level 1 dcl 6-15
compiled_se_info_ptr     66            based           pointer                  level 3 dcl 4-142 ref 195 197
cons                                   based           char                     packed unaligned dcl 2372 set ref 1691*
constant_ptr              6            based           pointer                  level 2 dcl 2505 set ref 1236* 1263* 1266* 1405*
                                                                                  1550* 1653* 1655* 1683* 1691 1702* 1746*
copied_for_current                     based           bit(1)                   array level 3 packed packed unaligned dcl 5-5 set
                                                                                  ref 510*
copy_for_current                       based           bit(1)                   array level 3 packed packed unaligned dcl 5-5 set
                                                                                  ref 510*
create_cursor           156            based           entry variable           level 4 dcl 4-142 set ref 1982*
cur_sw                   45            based           bit(1)                   level 2 dcl 2505 set ref 173* 647* 722* 741* 752*
                                                                                  2248* 2258
current_expr_level       47            based           fixed bin(17,0)          level 2 dcl 2505 set ref 883 885* 910* 910 958* 965
                                                                                  965 969 974* 1327* 1347 1356* 1377* 1384 1384 1388
                                                                                  1393* 1405* 1416* 1460 1462* 1492* 1492 1527* 1527
                                                                                  1886* 1886 1889 1891* 2149 2150* 2150 2153 2154*
                                                                                  2254*
current_flag            106(01)        based           bit(1)                   level 3 packed packed unaligned dcl 4-142 set ref
                                                                                  239*
current_func_level       50            based           fixed bin(17,0)          level 2 dcl 2505 set ref 944 979* 979 1363 1398*
                                                                                  1398 1427 1427* 1472* 1478 1478 1482 1487* 1496
                                                                                  1504 1510 1510 1516 1521 1528* 1528 1535 1544*
                                                                                  1550* 1556* 1881* 1881 1884 1892* 2149 2254*
current_ptr              16            based           pointer                  level 3 dcl 4-142 ref 220 222
current_time                    000226 automatic       fixed bin(71,0)          dcl 1948 set ref 1951* 1972
current_tuple_population
                         31            based           fixed bin(35,0)          level 2 dcl 10-119 set ref 1972 1992 1992*
cursor_ptrs_storage_ptr
                        130            based           pointer                  level 3 dcl 4-142 set ref 1982*
cursor_storage_area_ptr
                        132            based           pointer                  level 3 dcl 4-142 set ref 1982*
d_ptr                                  parameter       pointer                  dcl 2110 set ref 2108 2116*
data                                   based           structure                level 2 in structure "dbcb" dcl 4-142 in procedure
                                                                                  "mrds_dsl_semantics"
data                                   based           structure                level 2 in structure "rm_db_info" dcl 7-86
                                                                                  in procedure "mrds_dsl_semantics"
dbcb                                   based           structure                level 1 dcl 4-142
dbcb_data                              based           structure                level 1 unaligned dcl 4-148
dbcb_ptr                 10            based           pointer                  level 2 in structure "static_data" dcl 2505
                                                                                  in procedure "mrds_dsl_semantics" set ref 153
                                                                                  2241*
dbcb_ptr                        000102 automatic       pointer                  dcl 4-146 in procedure "mrds_dsl_semantics" set ref
                                                                                  153* 173* 173 195 197 220 222 232 236 239 253 266
                                                                                  267 269 270 317 319 320 320 321 321 325 326 329
                                                                                  330 336* 336 647* 647 670 670 670 674 674 676 722*
                                                                                  741* 752* 785* 803* 820* 851* 897* 917* 958* 974*
                                                                                  1228* 1236* 1244* 1264 1266* 1327* 1356* 1377*
                                                                                  1393* 1405* 1416* 1427* 1472* 1487* 1504* 1521*
                                                                                  1544* 1550* 1556* 1688 1703 1747 1875 1877* 1892*
                                                                                  1892 1963 1982 1982 1982 1982 1982 1982 1982 1982
                                                                                  1982 2078 2177 2178 2178 2180 2180 2187 2199 2210
                                                                                  2211 2213 2214 2241* 2249 2251 2258 2265
dbi                     114            based           fixed bin(35,0)          level 3 dcl 4-142 set ref 1982*
debug                           000010 internal static bit(1)                   initial packed unaligned dcl 2374 set ref 158 1691
                                                                                  1750 2060* 2065*
defn_order               22            based           fixed bin(17,0)          level 2 dcl 11-46 ref 1287
desc_ptr                        000130 automatic       pointer                  dcl 14-19 set ref 2116* 2118 2118
descp_ptr                12            based           pointer                  level 2 dcl 2505 set ref 173* 647* 2116 2124* 2124
                                                                                  2246*
descriptor                             based           structure                level 1 unaligned dcl 14-6 in procedure
                                                                                  "mrds_dsl_semantics"
descriptor                3            based           bit(36)                  level 2 in structure "exp_fun_data" packed packed
                                                                                  unaligned dcl 20-11 in procedure
                                                                                  "mrds_dsl_semantics" set ref 897 897 954 954 958
                                                                                  958 1373 1373 1377 1377 1472 1472 1504 1504
descriptor_copy                        based           bit(36)                  dcl 2375 set ref 1264 1265* 1265 1688 1689* 1689
                                                                                  1691* 1703 1704* 1704 1747 1748* 1748 1750*
descriptor_copy_ptr             000162 automatic       pointer                  dcl 2376 set ref 1236* 1264* 1265 1266* 1405* 1550*
                                                                                  1688* 1689 1691 1703* 1704 1747* 1748 1750
descriptor_ptr           14            based           pointer                  level 2 dcl 2505 set ref 573 579 585* 1244* 1416*
                                                                                  1556* 1824*
divide                                                 builtin function         dcl 2377 ref 553
domain_ptr               26            based           pointer                  level 2 dcl 11-46 ref 2190
domains                   1            based           char(32)                 array level 2 dcl 16-3 set ref 2190*
done                            000164 automatic       bit(1)                   dcl 2378 set ref 1665* 1666 1679*
dup_retain                             based           bit(1)                   level 2 in structure "select_sets" packed packed
                                                                                  unaligned dcl 16-3 in procedure
                                                                                  "mrds_dsl_semantics" set ref 676* 2185*
dup_retain              106(04)        based           bit(1)                   level 3 in structure "dbcb" packed packed unaligned
                                                                                  dcl 4-142 in procedure "mrds_dsl_semantics" set
                                                                                  ref 674*
ef_ptr                    6            based           pointer                  level 2 dcl 20-11 set ref 889 891* 948* 1367* 1467*
                                                                                  1499*
efd_ptr                         000144 automatic       pointer                  dcl 20-19 set ref 883* 885* 888 889 891 897 897 897
                                                                                  905* 944* 947 948 954 954 958 958 958 965 969 974*
                                                                                  1347* 1349 1349 1351 1363* 1366 1367 1373 1373
                                                                                  1377 1377 1377 1384 1388 1393* 1460* 1462* 1465
                                                                                  1467 1472 1472 1472 1478 1482 1487* 1496* 1498
                                                                                  1499 1504 1504 1504 1510 1516 1521* 1535* 1537
                                                                                  1537 1539 1882* 1883 1884 1887* 1888 1889 2151*
                                                                                  2152 2153
efd_ptrs                 56            based           structure                array level 2 dcl 2505
error_info_supplied       6            based           bit(1)                   level 3 dcl 2-13 ref 2081
error_msg                22            based           char(256)                level 3 dcl 2-13 set ref 2097* 2101*
error_report              6            based           structure                level 2 dcl 2-13
error_type                             parameter       char                     packed unaligned dcl 2075 in procedure "error" ref
                                                                                  2069 2091
error_type               14            based           char(24)                 level 3 in structure "se_info" dcl 2-13 in procedure
                                                                                  "mrds_dsl_semantics" set ref 2091*
exp_fun_data                           based           structure                level 1 unaligned dcl 20-11 set ref 1882 1883* 1887
                                                                                  1888* 2151 2152*
expr_efd_ptrs            56            based           pointer                  array level 3 dcl 2505 set ref 883 965 965 969 1347
                                                                                  1384 1384 1388 1460 1889* 2153*
fixed_bin_35                           based           fixed bin(35,0)          dcl 2380 ref 573
flags                     4            based           structure                level 2 dcl 2-13
force                     0(03)        based           bit(1)                   level 2 packed packed unaligned dcl 3-17 ref 324
fr_ptr                    4            based           pointer                  level 2 dcl 15-22 set ref 2166* 2167
free_relations                         based           structure                level 1 dcl 2381 set ref 2166
func_efd_ptrs            60            based           pointer                  array level 3 dcl 2505 set ref 944 1363 1427* 1478
                                                                                  1478 1482 1496 1510 1510 1516 1535 1884*
get_count               222            based           entry variable           level 4 dcl 4-142 set ref 1982*
get_duplicate_key_count
                        226            based           entry variable           level 4 dcl 4-142 set ref 1982*
get_population          232            based           entry variable           level 4 dcl 4-142 set ref 1982*
i                               000165 automatic       fixed bin(17,0)          dcl 2386 in procedure "mrds_dsl_semantics" set ref
                                                                                  516* 517* 543* 546* 547 553* 553 559 560 1663*
                                                                                  1668 1670* 1670 1676 1678* 1678 1684 1722* 1727*
                                                                                  1738 1739
i                               000224 automatic       fixed bin(17,0)          dcl 1934 in procedure "get_relation_statistics" set
                                                                                  ref 1955* 1957 1959*
id                        1            based           structure                level 2 packed packed unaligned dcl 18-67
index                    11            based           fixed bin(35,0)          array level 3 in structure "temp_rel_list" dcl 6-70
                                                                                  in procedure "mrds_dsl_semantics" set ref 621*
index                                                  builtin function         dcl 2387 in procedure "mrds_dsl_semantics" ref 543
                                                                                  546 1645 1673 1708 1739
invariant_part                         based           structure                array level 2 dcl 1-9
ioa_                            000012 constant        entry                    external dcl 2388 ref 158 1691 1750
item                     10            based           structure                array level 2 unaligned dcl 15-22
items                                  based           structure                array level 2 dcl 16-3
j                               000166 automatic       fixed bin(17,0)          dcl 2389 set ref 1645* 1648 1668 1668 1670 1671
                                                                                  1673* 1675 1731* 1734 1738* 1739 1739*
k                               000167 automatic       fixed bin(17,0)          dcl 2390 set ref 1664* 1668 1671* 1671 1673 1676
                                                                                  1676 1676 1678 1723* 1728* 1731 1735 2189* 2190
                                                                                  2190*
key                                    parameter       bit(1)                   dcl 2006 ref 2001 2011
last_s_e_id_num         115            based           fixed bin(35,0)          level 3 dcl 4-142 set ref 1963 1982*
last_statistics_update_count
                         32            based           fixed bin(17,0)          level 2 dcl 10-119 set ref 1966 1966* 1966 1972 1972
last_statistics_update_s_e_ref_num
                         36            based           fixed bin(35,0)          level 2 dcl 10-119 ref 1963
last_statistics_update_time
                         34            based           fixed bin(71,0)          level 2 dcl 10-119 ref 1972
len                             000100 automatic       fixed bin(17,0)          dcl 2132 set ref 2134* 2135
length                   44(12)        based           fixed bin(23,0)          level 3 in structure "static_data" packed packed
                                                                                  unaligned dcl 2505 in procedure
                                                                                  "mrds_dsl_semantics" set ref 1259* 1649* 1651
                                                                                  1684* 1691 1691 1700* 1735*
length                                                 builtin function         dcl 2391 in procedure "mrds_dsl_semantics" ref 543
lex_stack                              based           structure                array level 1 dcl 1-9
lex_stack_ptr                   000170 automatic       pointer                  dcl 2392 in procedure "mrds_dsl_semantics" set ref
                                                                                  155* 158 158 158 543 543 543 543 546 546 547 547
                                                                                  785 803 820 851 1259 1259 1259 1263 1645 1645 1649
                                                                                  1655 1660 1668 1668 1673 1673 1676 1676 1691 1691
                                                                                  1691 1700 1702 1708 1708 1708 1714 1716 1716 1716
                                                                                  1720 1720 1731 1731 1739 1739 1750 1750 1750 1892
                                                                                  1892 1892 2083 2085 2092 2094 2134 2135
lex_stack_ptr            16            based           pointer                  level 2 in structure "static_data" dcl 2505
                                                                                  in procedure "mrds_dsl_semantics" set ref 155
                                                                                  2240*
lex_token                              based           char                     packed unaligned dcl 2393 set ref 158* 543 543 546
                                                                                  547 1645 1668 1673 1676 1691* 1708 1716 1720 1731
                                                                                  1739 1750* 1892*
literal_area                           based           area(1024)               dcl 2395 ref 1264 1688 1703 1747
loud                                   parameter       bit(1)                   dcl 2073 in procedure "error" ref 2069 2090
loud                      7            based           bit(1)                   level 3 in structure "se_info" dcl 2-13 in procedure
                                                                                  "mrds_dsl_semantics" set ref 2090*
ls_top                                 parameter       fixed bin(17,0)          dcl 2396 set ref 20 158 158 158 158* 513 517 543 543
                                                                                  543 543 546 546 547 547 785 803 820 851 1259 1259
                                                                                  1259 1263 1327 1645 1645 1649 1655 1660 1668 1668
                                                                                  1673 1673 1676 1676 1691 1691 1691 1700 1702 1708
                                                                                  1708 1708 1714 1716 1716 1716 1720 1720 1731 1731
                                                                                  1739 1739 1750 1750 1750 1892 1892 1892 2022 2023
                                                                                  2083 2085 2092 2094 2097
ltrim                                                  builtin function         dcl 2397 ref 536 568
message                                parameter       char                     packed unaligned dcl 2076 ref 2069 2101
mla_ptr                   2            based           pointer                  level 2 dcl 15-22 set ref 2165*
model_area_ptr                  000122 automatic       pointer                  initial dcl 12-18 set ref 12-18*
model_seg_ptr                   000120 automatic       pointer                  initial dcl 12-13 set ref 12-13*
mrds_data_$caller_compile       000014 external static fixed bin(35,0)          dcl 2398 ref 184 228 610 1992
mrds_data_$max_attributes       000016 external static fixed bin(35,0)          dcl 2400 ref 509 509 509 510 510 510 510 513 513 517
                                                                                  517 517 517 555 555 556 556 558 558 559 559 560
                                                                                  560 560 602 602 603 603 605 605 606 606 607 607
                                                                                  607 1287 1287 1957 1957 1959 1959 1959 2026 2026
                                                                                  2035 2035 2039 2039 2219 2261
mrds_data_$max_expr_stack_size  000020 external static fixed bin(35,0)          dcl 2402 ref 279 2229 2237
mrds_data_$max_id_len           000022 external static fixed bin(35,0)          dcl 2403 ref 509 509 509 510 510 510 510 510 510 513
                                                                                  513 513 517 517 517 517 517 517 543 555 555 555
                                                                                  556 556 556 558 558 558 559 559 559 560 560 560
                                                                                  602 602 602 603 603 603 605 605 605 606 606 606
                                                                                  607 607 607 1287 1287 1287 1957 1957 1957 1959
                                                                                  1959 1959 2026 2026 2026 2035 2035 2035 2039 2039
                                                                                  2039 2219 2261
mrds_data_$max_relations        000024 external static fixed bin(35,0)          dcl 2404 ref 2166
mrds_data_$max_select_items     000026 external static fixed bin(35,0)          dcl 2406 ref 259 263 263 264 264 266 266 267 267 269
                                                                                  269 270 270 275 275 277 277 279 279 2163 2163 2184
                                                                                  2184 2186 2204 2207 2207 2208 2208 2210 2210 2211
                                                                                  2211 2213 2213 2214 2214
mrds_data_$max_sets             000030 external static fixed bin(35,0)          dcl 2408 ref 256 2183 2200 2224 2237
mrds_data_$max_temp_rels        000032 external static fixed bin(35,0)          dcl 2409 ref 612
mrds_data_$max_tup_var          000034 external static fixed bin(35,0)          dcl 2411 ref 536 536 568 568 2219 2219 2261 2261
mrds_data_$statistics_update_count_interval
                                000156 external static fixed bin(35,0)          dcl 1935 ref 1972
mrds_data_$statistics_update_small_rel_size
                                000160 external static fixed bin(35,0)          dcl 1937 ref 1972
mrds_data_$statistics_update_time_interval
                                000162 external static fixed bin(71,0)          dcl 1940 ref 1972
mrds_dsl_eval_expr              000036 constant        entry                    external dcl 2412 ref 891 1467
mrds_dsl_eval_func              000040 constant        entry                    external dcl 2413 ref 948 1367 1499
mrds_dsl_expr_$build_attribute  000042 constant        entry                    external dcl 2414 ref 1356
mrds_dsl_expr_$build_function   000044 constant        entry                    external dcl 2417 ref 974 1393
mrds_dsl_expr_$build_literal    000046 constant        entry                    external dcl 2419 ref 958 1377 1405 1416
mrds_dsl_expr_$condense_stack   000050 constant        entry                    external dcl 2422 ref 1327
mrds_dsl_expr_$finish           000052 constant        entry                    external dcl 2425 ref 885 1462
mrds_dsl_expr_$init             000054 constant        entry                    external dcl 2426 ref 1891 2154
mrds_dsl_func_$build_attribute  000056 constant        entry                    external dcl 2427 ref 1544
mrds_dsl_func_$build_expr_func  000060 constant        entry                    external dcl 2430 ref 1487 1521
mrds_dsl_func_$build_literal    000062 constant        entry                    external dcl 2433 ref 1472 1504 1550 1556
mrds_dsl_func_$finish           000064 constant        entry                    external dcl 2436 ref 1427
mrds_dsl_func_$init             000066 constant        entry                    external dcl 2438 ref 1892
mrds_dsl_get_builtins           000070 constant        entry                    external dcl 2440 ref 1877
mrds_dsl_optimize               000072 constant        entry                    external dcl 2441 ref 336
mrds_dsl_select_clause_$all_attributes
                                000074 constant        entry                    external dcl 2442 ref 722
mrds_dsl_select_clause_$finish  000076 constant        entry                    external dcl 2446 ref 173 647
mrds_dsl_select_clause_$one_attribute
                                000100 constant        entry                    external dcl 2450 ref 741 752
mrds_dsl_where_clause_$build_attribute
                                000102 constant        entry                    external dcl 2455 ref 1228
mrds_dsl_where_clause_$build_expr
                                000104 constant        entry                    external dcl 2458 ref 905
mrds_dsl_where_clause_$build_literal
                                000106 constant        entry                    external dcl 2460 ref 897 917 1236 1244 1266
mrds_dsl_where_clause_$build_node
                                000110 constant        entry                    external dcl 2463 ref 785 803 820 851
mrds_dsl_where_clause_$finish   000112 constant        entry                    external dcl 2466 ref 770
mrds_error_$bad_attr            000114 external static fixed bin(35,0)          dcl 2468 set ref 2049*
mrds_error_$bad_temp_rel_val    000116 external static fixed bin(35,0)          dcl 2469 set ref 579*
mrds_error_$bad_var             000120 external static fixed bin(35,0)          dcl 2471 set ref 2030*
mrds_error_$curr_not_alld       000122 external static fixed bin(35,0)          dcl 2472 set ref 236*
mrds_error_$insuff_args         000124 external static fixed bin(35,0)          dcl 2474 set ref 2112*
mrds_error_$inv_string          000126 external static fixed bin(35,0)          dcl 2476 set ref 1756*
mrds_error_$inval_comp_expr     000130 external static fixed bin(35,0)          dcl 2477 set ref 228*
mrds_error_$max_tup_var         000132 external static fixed bin(35,0)          dcl 2479 set ref 536* 568*
mrds_error_$mult_def_var        000134 external static fixed bin(35,0)          dcl 2481 set ref 517*
mrds_error_$mult_expr_vars      000136 external static fixed bin(35,0)          dcl 2483 set ref 969* 1351* 1388* 1482* 1516* 1539*
mrds_error_$no_prior_se         000140 external static fixed bin(35,0)          dcl 2485 set ref 232*
mrds_error_$set_ovfl            000142 external static fixed bin(35,0)          dcl 2487 set ref 259* 2204* 2224*
mrds_error_$undef_rel           000144 external static fixed bin(35,0)          dcl 2488 set ref 547*
mrds_error_$undef_temp_rel      000146 external static fixed bin(35,0)          dcl 2489 set ref 592* 597*
mrds_error_$unimplemented_syntax
                                000150 external static fixed bin(35,0)          dcl 2491 set ref 180* 382* 386* 626* 643* 705* 730*
                                                                                  734* 1010* 1014* 1025* 1029* 1040* 1044* 1055*
                                                                                  1059* 1074* 1078* 1160* 1253* 1273* 1571* 1595*
                                                                                  1842* 2097
mu_convert$convert_data         000152 constant        entry                    external dcl 2493 ref 585
mu_rel_statistics$record_statistics
                                000164 constant        entry                    external dcl 1943 ref 1982
mu_valid_data_type$valid_scalar_data_type
                                000154 constant        entry                    external dcl 2495 ref 579
name                                   based           char(32)                 level 2 in structure "rm_rel_info" dcl 10-119
                                                                                  in procedure "mrds_dsl_semantics" ref 2049
name                      1            based           structure                array level 2 in structure "rm_rel_array" packed
                                                                                  packed unaligned dcl 9-34 in procedure
                                                                                  "mrds_dsl_semantics" ref 543 546
name                      1            based           char(32)                 array level 3 in structure "temp_rel_list" dcl 6-70
                                                                                  in procedure "mrds_dsl_semantics" set ref 619*
name                                   based           char(32)                 level 2 in structure "rm_attr_info" dcl 11-46
                                                                                  in procedure "mrds_dsl_semantics" ref 2044
name                                   based           char(32)                 level 2 in structure "rm_domain_info" dcl 8-35
                                                                                  in procedure "mrds_dsl_semantics" ref 2190
name                      2            based           char                     array level 3 in structure "range" dcl 5-5
                                                                                  in procedure "mrds_dsl_semantics" set ref 513* 517
                                                                                  517 2026
needed_bits                            based           structure                array level 3 dcl 5-5 set ref 509*
nitems                                 based           fixed bin(17,0)          level 2 dcl 16-3 set ref 259 263* 263 264 266 267
                                                                                  269 270 275* 275 277 279 2184* 2186* 2204 2207*
                                                                                  2207 2208 2210 2211 2213 2214
nitems_init                     000140 automatic       fixed bin(17,0)          dcl 16-22 set ref 256* 259 2183* 2184 2184 2200*
                                                                                  2204
nkey_attr                24            based           fixed bin(17,0)          level 2 dcl 10-119 ref 1228 1287 1356 1544 2044
no_optimize             106(18)        based           bit(1)                   level 3 packed packed unaligned dcl 4-142 set ref
                                                                                  321* 326* 330*
no_ot_seen                5            based           bit(1)                   level 3 dcl 2-13 ref 321
null                                                   builtin function         dcl 2497 ref 220 232 236 597 611 674 889 891 891 891
                                                                                  891 917 917 917 917 948 948 948 948 1367 1367 1367
                                                                                  1367 1467 1467 1467 1467 1499 1499 1499 1499 1875
                                                                                  2252 8-51 11-65 12-13 12-18 13-6 13-10 15-38 17-59
                                                                                  2165 2177 2222
num_args                 51            based           fixed bin(17,0)          level 2 dcl 2505 set ref 173* 647* 2112 2125* 2125
                                                                                  2247*
num_attr                 22            based           fixed bin(17,0)          level 2 dcl 10-119 ref 2044 2049
num_dims                        000132 automatic       fixed bin(17,0)          initial dcl 14-20 set ref 14-20*
num_free_rels                          based           fixed bin(17,0)          level 2 dcl 2381 set ref 2167*
num_items                 6            based           fixed bin(17,0)          level 2 dcl 15-22 set ref 224* 2163* 2169* 2189
num_rels                               based           fixed bin(17,0)          level 2 dcl 9-34 ref 543 546 560 592 597 607 2039
num_vars                               based           fixed bin(17,0)          level 2 in structure "select_list" dcl 15-22
                                                                                  in procedure "mrds_dsl_semantics" set ref 224*
                                                                                  2169*
num_vars                               based           fixed bin(17,0)          level 2 in structure "range" dcl 5-5 in procedure
                                                                                  "mrds_dsl_semantics" set ref 509 510 510 513 516
                                                                                  517 536 540* 540 555 556 558 559 560 568 572* 572
                                                                                  602 603 605 606 607 1955 2026 2030 2219* 2220*
                                                                                  2261* 2262*
number_of_temp_rels                    based           fixed bin(35,0)          level 2 dcl 6-70 set ref 613* 617* 617 619 621
op_code                                based           fixed bin(17,0)          array level 3 dcl 16-3 set ref 279*
op_stack                               based           fixed bin(17,0)          array level 2 dcl 2505 set ref 279 2229*
op_top                   52            based           fixed bin(17,0)          level 2 dcl 2505 set ref 279 280* 280 2195* 2224
                                                                                  2228* 2228 2229
open                    146            based           entry variable           level 4 dcl 4-142 set ref 1982*
oper_flag                              based           bit(1)                   array level 3 packed packed unaligned dcl 16-3 set
                                                                                  ref 264* 277* 2208*
option_list                            based           structure                level 1 dcl 3-17
option_list_ptr          22            based           pointer                  level 2 in structure "static_data" dcl 2505
                                                                                  in procedure "mrds_dsl_semantics" set ref 322
                                                                                  2244*
option_list_ptr                 000100 automatic       pointer                  dcl 3-26 in procedure "mrds_dsl_semantics" set ref
                                                                                  322* 324 325 326 329 330
ot                        0(02)        based           bit(1)                   level 2 packed packed unaligned dcl 3-17 ref 326 330
parser_static_info                     based           structure                level 1 dcl 2-66
parser_work_area                       based           area                     dcl 2-63 ref 2237
position                               parameter       fixed bin(17,0)          dcl 2131 ref 2129 2134 2135
pred_leaf                              based           structure                level 1 unaligned dcl 18-67
pred_tree_ptr            20            based           pointer                  level 2 dcl 2505 set ref 336* 770* 2222* 2252*
primary_type             53            based           char(4)                  level 2 dcl 2505 set ref 1226 1235 1243 1257 1294*
                                                                                  1298* 1302* 1306* 1311*
print_search_order      106(19)        based           bit(1)                   level 3 packed packed unaligned dcl 4-142 set ref
                                                                                  320* 325* 329*
prod_no                                parameter       fixed bin(17,0)          dcl 2498 set ref 20 158* 163
psi_ptr                                parameter       pointer                  dcl 2-65 set ref 20 153 154 155 173 173 173 173 173
                                                                                  173 173 173 184 195 197 222 228 258 272 279 279
                                                                                  280 280 317 319 322 336 339 507 534 541 566 573
                                                                                  573 579 585 585 591 610 611 612 613 616 647 647
                                                                                  647 647 647 647 647 647 718 718 722 722 722 722
                                                                                  722 738 738 741 741 741 741 741 741 749 749 752
                                                                                  752 752 752 752 752 770* 770 785* 803* 820* 851*
                                                                                  883 883 885* 885 891 897* 897 905* 910 910 917*
                                                                                  917 944 944 948 958* 958 965 965 965 965 969 969
                                                                                  974* 974 979 979 1226 1228* 1228 1228 1228 1235
                                                                                  1236* 1236 1236 1243 1244* 1244 1244 1244 1257
                                                                                  1259 1263 1265 1266* 1266 1266 1287 1287 1287 1287
                                                                                  1294 1298 1302 1306 1311 1327* 1327 1346 1346 1347
                                                                                  1347 1349 1351 1356* 1356 1356 1356 1356 1363 1363
                                                                                  1367 1377* 1377 1384 1384 1384 1384 1388 1388
                                                                                  1393* 1393 1398 1398 1405* 1405 1405 1416* 1416
                                                                                  1416 1416 1427* 1427 1427 1427 1427 1460 1460
                                                                                  1462* 1462 1467 1472* 1472 1478 1478 1478 1478
                                                                                  1482 1482 1487* 1487 1492 1492 1496 1496 1499
                                                                                  1504* 1504 1510 1510 1510 1510 1516 1516 1521*
                                                                                  1521 1527 1527 1528 1528 1533 1533 1535 1535 1537
                                                                                  1539 1544* 1544 1544 1544 1544 1550* 1550 1550
                                                                                  1556* 1556 1556 1556 1599 1599 1649 1651 1653 1655
                                                                                  1683 1684 1689 1691 1691 1691 1700 1702 1704 1735
                                                                                  1746 1748 1824 1824 1881 1881 1884 1884 1886 1886
                                                                                  1889 1889 1891* 1891 1892* 1892 1992 2009 2035
                                                                                  2037 2039 2112 2115 2116 2123 2123 2124 2124 2125
                                                                                  2125 2149 2149 2150 2150 2153 2153 2154* 2154 2163
                                                                                  2164 2189 2190 2195 2203 2216 2219 2220 2222 2224
                                                                                  2228 2228 2229 2229 2233 2237 2237 2240 2241 2242
                                                                                  2243 2244 2245 2246 2247 2248 2251 2252 2252 2252
                                                                                  2253 2254 2254 2258 2258 2261 2262 2265
pso                                    based           bit(1)                   level 2 packed packed unaligned dcl 3-17 ref 325 329
pso_seen                  4            based           bit(1)                   level 3 dcl 2-13 ref 320
pwa_ptr                                based           pointer                  level 2 dcl 2-66 ref 2237
ra_ptr                  134            based           pointer                  level 3 dcl 7-86 ref 541 2037
rai_ptr                         000116 automatic       pointer                  initial dcl 11-65 set ref 11-65*
range                                  based           structure                level 1 dcl 5-5 set ref 2219 2261
range_ptr                 2            based           pointer                  level 3 in structure "dbcb" dcl 4-142 in procedure
                                                                                  "mrds_dsl_semantics" set ref 232 266 317* 2210
                                                                                  2258
range_ptr                              based           pointer                  array level 3 in structure "select_sets" dcl 16-3
                                                                                  in procedure "mrds_dsl_semantics" set ref 266*
                                                                                  2210*
range_ptr                24            based           pointer                  level 2 in structure "static_data" dcl 2505
                                                                                  in procedure "mrds_dsl_semantics" set ref 173* 317
                                                                                  507 534 566 647* 722* 741* 752* 1287 1356* 1544*
                                                                                  2009 2219* 2220 2258* 2261* 2262
range_ptr                       000104 automatic       pointer                  dcl 5-23 in procedure "mrds_dsl_semantics" set ref
                                                                                  317* 507* 509 509 510 510 510 510 513 513 516 517
                                                                                  517 517 534* 536 540 540 555 555 556 556 558 558
                                                                                  559 559 560 560 566* 568 572 572 602 602 603 603
                                                                                  605 605 606 606 607 607 1955 1957 1959 2009* 2026
                                                                                  2026 2030 2035 2039
rdbi_ptr                 26            based           pointer                  level 2 in structure "static_data" dcl 2505
                                                                                  in procedure "mrds_dsl_semantics" set ref 541 591
                                                                                  2035 2037 2265*
rdbi_ptr                               based           pointer                  level 3 in structure "dbcb" dcl 4-142 in procedure
                                                                                  "mrds_dsl_semantics" ref 2265
rdi_ptr                         000110 automatic       pointer                  initial dcl 8-51 set ref 8-51*
rel_data                               based           structure                array level 2 dcl 9-34
rel_index                              based           fixed bin(17,0)          array level 3 in structure "range" dcl 5-5
                                                                                  in procedure "mrds_dsl_semantics" set ref 559*
                                                                                  606* 2039
rel_index                              parameter       fixed bin(17,0)          dcl 2004 in procedure "get_attribute_info" set ref
                                                                                  2001 2026* 2026* 2030 2035 2039
rel_index                54            based           fixed bin(17,0)          level 2 in structure "static_data" dcl 2505
                                                                                  in procedure "mrds_dsl_semantics" set ref 718*
                                                                                  722* 738* 741* 749* 752* 1228* 1287 1346* 1349
                                                                                  1351 1356* 1533* 1537 1539 1544* 1599*
rel_name                        000172 automatic       char(32)                 packed unaligned dcl 2500 set ref 2022* 2026 2030
rel_pos                         000240 automatic       fixed bin(17,0)          dcl 2007 set ref 2012* 2016* 2020* 2022 2030*
relmgr_entries          146            based           structure                level 3 dcl 4-142
reverse                                                builtin function         dcl 2501 ref 1708
ri_ptr                                 based           pointer                  array level 3 in structure "rm_rel_array" packed
                                                                                  packed unaligned dcl 9-34 in procedure
                                                                                  "mrds_dsl_semantics" ref 560 597 607 2039
ri_ptr                                 based           pointer                  array level 3 in structure "range" dcl 5-5
                                                                                  in procedure "mrds_dsl_semantics" set ref 560*
                                                                                  607* 1959
rm_attr_info                           based           structure                level 1 dcl 11-46
rm_db_info                             based           structure                level 1 dcl 7-86
rm_db_info_data                        based           structure                level 1 unaligned dcl 7-92
rm_domain_info                         based           structure                level 1 dcl 8-35
rm_rel_array                           based           structure                level 1 dcl 9-34
rm_rel_info                            based           structure                level 1 dcl 10-119
rmra_ptr                        000112 automatic       pointer                  dcl 9-43 set ref 541* 543 546 560 591* 592 597 607
                                                                                  619 2035* 2037* 2039
rmri_ptr                        000114 automatic       pointer                  dcl 10-156 in procedure "mrds_dsl_semantics" set ref
                                                                                  722* 741* 752* 1356 1544 1959* 1963 1966 1966 1966
                                                                                  1972 1972 1972 1972 1982* 1992 1992 2039* 2044
                                                                                  2044 2049 2049
rmri_ptr                 30            based           pointer                  level 2 in structure "static_data" dcl 2505
                                                                                  in procedure "mrds_dsl_semantics" set ref 1228
                                                                                  1287 2039*
rtrim                                                  builtin function         dcl 2502 ref 2030 2049 2049
scope_flags                            based           structure                level 1 dcl 17-42
scope_ptr                       000142 automatic       pointer                  initial dcl 17-59 set ref 17-59*
se_info                                based           structure                level 1 dcl 2-13
se_info_ptr                     000202 automatic       pointer                  dcl 2503 in procedure "mrds_dsl_semantics" set ref
                                                                                  2078* 2081 2083 2083 2085 2085 2090 2091 2092 2094
                                                                                  2097 2101
se_info_ptr              72            based           pointer                  level 3 in structure "dbcb" dcl 4-142 in procedure
                                                                                  "mrds_dsl_semantics" set ref 320 321 2078 2249*
se_pending               46            based           bit(1)                   level 2 dcl 2505 set ref 258 272* 339* 2203 2216*
search                                                 builtin function         dcl 2504 ref 1720
select_area                            based           area                     dcl 13-8 ref 612 1653 1661 1736 1882 1887 2151 2163
                                                                                  2166 2184 2219 2261
select_area_ptr                 000126 automatic       pointer                  initial dcl 13-10 in procedure "mrds_dsl_semantics"
                                                                                  set ref 154* 612 785* 803* 820* 851* 885* 897*
                                                                                  905* 917* 1228* 1236* 1244* 1266* 1327* 1427*
                                                                                  1462* 1653 1661 1736 1882 1887 1892* 2251* 2261
                                                                                  13-10* 2151 2163 2166 2184 2219
select_area_ptr          36            based           pointer                  level 3 in structure "dbcb" dcl 4-142 in procedure
                                                                                  "mrds_dsl_semantics" ref 1264 1688 1703 1747 2251
select_area_ptr          32            based           pointer                  level 2 in structure "static_data" dcl 2505
                                                                                  in procedure "mrds_dsl_semantics" set ref 154
                                                                                  2251*
select_area_struct_ptr          000124 automatic       pointer                  initial dcl 13-6 set ref 13-6*
select_list                            based           structure                level 1 unaligned dcl 15-22 set ref 2163
select_list_ptr          34            based           pointer                  level 2 in structure "static_data" dcl 2505
                                                                                  in procedure "mrds_dsl_semantics" set ref 173*
                                                                                  222* 319 647* 722* 741* 752* 2163* 2164 2189 2190
select_list_ptr                 000134 automatic       pointer                  initial dcl 15-38 in procedure "mrds_dsl_semantics"
                                                                                  set ref 222* 223 224 224 15-38* 2164* 2165 2166
                                                                                  2167 2168 2169 2169
select_ptr                4            based           pointer                  level 3 in structure "dbcb" dcl 4-142 in procedure
                                                                                  "mrds_dsl_semantics" set ref 267 319* 2211
select_ptr                             based           pointer                  array level 3 in structure "select_sets" dcl 16-3
                                                                                  in procedure "mrds_dsl_semantics" set ref 267*
                                                                                  2211*
select_sets                            based           structure                level 1 dcl 16-3 set ref 2184
semantics                 2            based           structure                level 2 dcl 2-66
sfi_ptr                  32            based           pointer                  level 3 dcl 4-142 set ref 1875 1892*
so_ptr                                 based           pointer                  array level 3 in structure "select_sets" dcl 16-3
                                                                                  in procedure "mrds_dsl_semantics" set ref 270*
                                                                                  2214*
so_ptr                   10            based           pointer                  level 3 in structure "dbcb" dcl 4-142 in procedure
                                                                                  "mrds_dsl_semantics" set ref 270 336* 2214
ss_ptr                   20            based           pointer                  level 3 in structure "dbcb" dcl 4-142 in procedure
                                                                                  "mrds_dsl_semantics" set ref 236 253 674 676 2177
                                                                                  2187* 2199
ss_ptr                          000136 automatic       pointer                  dcl 16-21 in procedure "mrds_dsl_semantics" set ref
                                                                                  253* 259 263 263 264 264 266 266 267 267 269 269
                                                                                  270 270 275 275 277 277 279 279 2184* 2185 2186
                                                                                  2187 2190 2199* 2204 2207 2207 2208 2208 2210 2210
                                                                                  2211 2211 2213 2213 2214 2214
stack_offset             13            based           fixed bin(17,0)          level 3 in structure "se_info" dcl 2-13 in procedure
                                                                                  "mrds_dsl_semantics" ref 2083 2085
stack_offset                           parameter       fixed bin(17,0)          dcl 2074 in procedure "error" ref 2069 2092 2094
                                                                                  2097
static_data                            based           structure                level 1 dcl 2505 set ref 2237
static_data_ptr           2            based           pointer                  level 3 dcl 2-66 set ref 153 154 155 173 173 173 173
                                                                                  173 173 173 173 184 195 197 222 228 258 272 279
                                                                                  279 280 280 317 319 322 336 339 507 534 541 566
                                                                                  573 573 579 585 585 591 610 611 612 613 616 647
                                                                                  647 647 647 647 647 647 647 718 718 722 722 722
                                                                                  722 722 738 738 741 741 741 741 741 741 749 749
                                                                                  752 752 752 752 752 752 770 883 883 885 891 897
                                                                                  910 910 917 944 944 948 958 965 965 965 965 969
                                                                                  969 974 979 979 1226 1228 1228 1228 1235 1236 1236
                                                                                  1243 1244 1244 1244 1257 1259 1263 1265 1266 1266
                                                                                  1287 1287 1287 1287 1294 1298 1302 1306 1311 1327
                                                                                  1346 1346 1347 1347 1349 1351 1356 1356 1356 1356
                                                                                  1363 1363 1367 1377 1384 1384 1384 1384 1388 1388
                                                                                  1393 1398 1398 1405 1405 1416 1416 1416 1427 1427
                                                                                  1427 1427 1460 1460 1462 1467 1472 1478 1478 1478
                                                                                  1478 1482 1482 1487 1492 1492 1496 1496 1499 1504
                                                                                  1510 1510 1510 1510 1516 1516 1521 1527 1527 1528
                                                                                  1528 1533 1533 1535 1535 1537 1539 1544 1544 1544
                                                                                  1544 1550 1550 1556 1556 1556 1599 1599 1649 1651
                                                                                  1653 1655 1683 1684 1689 1691 1691 1691 1700 1702
                                                                                  1704 1735 1746 1748 1824 1824 1881 1881 1884 1884
                                                                                  1886 1886 1889 1889 1891 1892 1992 2009 2035 2037
                                                                                  2039 2112 2115 2116 2123 2123 2124 2124 2125 2125
                                                                                  2149 2149 2150 2150 2153 2153 2154 2163 2164 2189
                                                                                  2190 2195 2203 2216 2219 2220 2222 2224 2228 2228
                                                                                  2229 2229 2237* 2240 2241 2242 2243 2244 2245 2246
                                                                                  2247 2248 2251 2252 2252 2252 2253 2254 2254 2258
                                                                                  2258 2261 2262 2265
string                                                 builtin function         dcl 2540 set ref 223* 509* 543 546 2168*
string_len                      000204 automatic       fixed bin(17,0)          dcl 2541 set ref 1652* 1653 1653 1660* 1661 1661
                                                                                  1668 1676 1676 1676 1678 1683 1735* 1736 1736 1739
                                                                                  1750 1750
string_ptr                      000206 automatic       pointer                  dcl 2542 set ref 1661* 1668 1676 1683 1736* 1739
                                                                                  1746 1750
string_token                           based           char                     packed unaligned dcl 2543 set ref 1653 1661 1668*
                                                                                  1676* 1683 1736 1739* 1750*
submodel                  1(09)        based           char(32)                 array level 3 packed packed unaligned dcl 9-34 ref
                                                                                  619
substr                                                 builtin function         dcl 2544 set ref 1645 1668* 1668 1673 1676* 1676
                                                                                  1716 1731 1739* 1739 1739
temp_rel                               based           bit(1)                   array level 3 packed packed unaligned dcl 5-5 set
                                                                                  ref 558* 605* 1957 2035
temp_rel_index                  000210 automatic       fixed bin(35,0)          dcl 2546 set ref 573* 585 585 592 592 597 606 607
                                                                                  619 621
temp_rel_info             1            based           structure                array level 2 dcl 6-70
temp_rel_list                          based           structure                level 1 dcl 6-70 set ref 612
temp_temp_rel_list_ptr
                          6            based           pointer                  level 2 dcl 6-15 set ref 197*
temp_x_leaf_ptr           4            based           pointer                  level 2 dcl 6-15 set ref 195*
ti_ptr                   12            based           pointer                  level 3 in structure "dbcb" dcl 4-142 in procedure
                                                                                  "mrds_dsl_semantics" set ref 173* 269 647* 2213
ti_ptr                                 based           pointer                  array level 3 in structure "select_sets" dcl 16-3
                                                                                  in procedure "mrds_dsl_semantics" set ref 269*
                                                                                  2213*
token                                  based           char                     packed unaligned dcl 2133 ref 2135
token_id                  4            based           fixed bin(17,0)          array level 3 dcl 1-9 set ref 785* 803* 820* 851*
token_length             11            based           fixed bin(17,0)          level 3 in structure "se_info" dcl 2-13 in procedure
                                                                                  "mrds_dsl_semantics" set ref 2083* 2094*
token_length              2            based           fixed bin(17,0)          array level 3 in structure "lex_stack" dcl 1-9
                                                                                  in procedure "mrds_dsl_semantics" ref 158 158 543
                                                                                  543 546 547 1259 1645 1649 1660 1668 1673 1676
                                                                                  1691 1691 1700 1708 1708 1714 1716 1716 1720 1731
                                                                                  1739 1750 1750 1892 1892 2083 2094 2134
token_ptr                              based           pointer                  array level 3 dcl 1-9 ref 158 543 543 546 547 1263
                                                                                  1645 1655 1668 1673 1676 1691 1702 1708 1716 1720
                                                                                  1731 1739 1750 1892 2135
token_start              10            based           fixed bin(17,0)          level 3 dcl 2-13 set ref 2085* 2092*
token_start_pos           3            based           fixed bin(17,0)          array level 3 dcl 1-9 ref 1259 1259 2085 2092
tra_ptr                 136            based           pointer                  level 3 dcl 7-86 ref 591 2035
trl_ptr                         000106 automatic       pointer                  dcl 6-77 in procedure "mrds_dsl_semantics" set ref
                                                                                  616* 617 617 619 619 621 621
trl_ptr                  36            based           pointer                  level 2 in structure "static_data" dcl 2505
                                                                                  in procedure "mrds_dsl_semantics" set ref 197 611
                                                                                  612* 613 616 2252*
tup_var                   2            based           structure                array level 2 dcl 5-5
type                     44            based           bit(12)                  level 3 in structure "static_data" packed packed
                                                                                  unaligned dcl 2505 in procedure
                                                                                  "mrds_dsl_semantics" set ref 2253*
type                      0(01)        based           fixed bin(6,0)           level 2 in structure "descriptor" packed packed
                                                                                  unsigned unaligned dcl 14-6 in procedure
                                                                                  "mrds_dsl_semantics" ref 954 954 1373 1373 2118
                                                                                  2118
type                                   parameter       fixed bin(17,0)          dcl 2175 in procedure "process_set_op" ref 2172 2229
unspec                                                 builtin function         dcl 2547 set ref 1883* 1888* 2152*
used                                   based           bit(1)                   array level 3 packed packed unaligned dcl 5-5 set
                                                                                  ref 555* 602*
val_del                 106(11)        based           bit(1)                   level 3 packed packed unaligned dcl 4-142 set ref
                                                                                  670* 2180*
val_dtr                 106(12)        based           bit(1)                   level 3 packed packed unaligned dcl 4-142 set ref
                                                                                  670* 2178*
val_mod                 106(10)        based           bit(1)                   level 3 packed packed unaligned dcl 4-142 set ref
                                                                                  670* 2180*
val_rtrv                106(09)        based           bit(1)                   level 3 packed packed unaligned dcl 4-142 set ref
                                                                                  2178*
var_exists                7            based           bit(1)                   array level 2 packed packed unaligned dcl 15-22 set
                                                                                  ref 223* 2168*
var_index                              based           fixed bin(17,0)          level 2 dcl 20-11 set ref 888 947 965 965* 965 969
                                                                                  969 1349 1349* 1351 1366 1384 1384* 1384 1388 1388
                                                                                  1465 1478 1478* 1478 1482 1482 1498 1510 1510*
                                                                                  1510 1516 1516 1537 1537* 1539
verify                                                 builtin function         dcl 2548 ref 1731
whole_tuple_selected                   based           bit(1)                   array level 3 packed packed unaligned dcl 5-5 set
                                                                                  ref 556* 603*
x_pred_leaf_ptr          40            based           pointer                  level 2 dcl 2505 set ref 195 897* 917* 1236* 1244*
                                                                                  1266* 2252*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALL_OP                                 internal static bit(6)                   initial packed unaligned dcl 18-44
AND_OP                                 internal static bit(6)                   initial packed unaligned dcl 18-44
ARRAY                                  internal static fixed bin(17,0)          initial dcl 18-60
ATTR                                   internal static fixed bin(17,0)          initial dcl 18-56
AV_TYPE                                internal static char(16)                 initial packed unaligned dcl 2-50
CONST                                  internal static fixed bin(17,0)          initial dcl 18-56
CURRENT_OP                             internal static bit(6)                   initial packed unaligned dcl 18-44
EQ_OP                                  internal static bit(6)                   initial packed unaligned dcl 18-44
EXPRES                                 internal static fixed bin(17,0)          initial dcl 18-56
GE_OP                                  internal static bit(6)                   initial packed unaligned dcl 18-44
GT_OP                                  internal static bit(6)                   initial packed unaligned dcl 18-44
IL_TYPE                                internal static char(14)                 initial packed unaligned dcl 2-53
LEAF                                   internal static fixed bin(17,0)          initial dcl 18-60
LE_OP                                  internal static bit(6)                   initial packed unaligned dcl 18-44
LT_OP                                  internal static bit(6)                   initial packed unaligned dcl 18-44
NE_OP                                  internal static bit(6)                   initial packed unaligned dcl 18-44
NODE                                   internal static fixed bin(17,0)          initial dcl 18-60
NOT_OP                                 internal static bit(6)                   initial packed unaligned dcl 18-44
OR_OP                                  internal static bit(6)                   initial packed unaligned dcl 18-44
SC_TYPE                                internal static char(13)                 initial packed unaligned dcl 2-38
V_C                                    internal static fixed bin(5,0)           initial dcl 18-64
V_V                                    internal static fixed bin(5,0)           initial dcl 18-64
ag_ptr                                 automatic       pointer                  dcl 18-40
and_group                              based           structure                level 1 unaligned dcl 18-36
compiled_se_info_ptr                   automatic       pointer                  dcl 6-44
fixed                                                  builtin function         dcl 2379
lip                                    automatic       pointer                  dcl 19-28
lit_info                               based           structure                level 1 dcl 19-15
max_file_init                          automatic       fixed bin(17,0)          dcl 17-58
mode_flags                             based           structure                level 1 dcl 3-9
mode_flags_ptr                         automatic       pointer                  dcl 3-25
model_area                             based           area                     dcl 12-16
model_seg                              based           structure                level 1 dcl 12-9
move_list_array                        based           structure                array level 1 unaligned dcl 15-40
natts_init                             automatic       fixed bin(17,0)          dcl 10-157
nkey_attr_init                         automatic       fixed bin(17,0)          dcl 10-157
num_ands_init                          automatic       fixed bin(17,0)          dcl 18-41
num_terms_init                         automatic       fixed bin(17,0)          dcl 18-41
nvar_atts_init                         automatic       fixed bin(17,0)          dcl 10-157
pl_ptr                                 automatic       pointer                  dcl 18-84
pn_ptr                                 automatic       pointer                  dcl 18-27
pred_array                             based           structure                level 1 unaligned dcl 18-29
pred_node                              based           structure                level 1 unaligned dcl 18-12
pred_ptr                               automatic       pointer                  dcl 18-34
rdbi_ptr                               automatic       pointer                  dcl 7-90
rel                                                    builtin function         dcl 2499
rm_num_rels_init                       automatic       fixed bin(17,0)          dcl 9-44
scope_info                             based           structure                level 1 dcl 17-32
scope_rdy                              internal static bit(6)                   initial packed unaligned dcl 17-60
scope_rdy_array                        based           bit(1)                   array packed unaligned dcl 17-61
select_area_struct                     based           structure                level 1 dcl 13-2
size                                                   builtin function         dcl 12-20
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 2545
x_pred_leaf                            based           structure                level 1 dcl 6-50
x_pred_leaf_ptr                        automatic       pointer                  dcl 6-65

NAMES DECLARED BY EXPLICIT CONTEXT.
dbf                             013307 constant        entry                    external dcl 2058
dbn                             013321 constant        entry                    external dcl 2063
error                           014521 constant        entry                    internal dcl 2069 ref 177 180 228 232 236 259 334
                                                                                  337 382 386 517 536 547 568 579 592 597 626 643
                                                                                  651 705 726 730 734 744 755 789 806 824 855 893
                                                                                  901 907 920 950 961 969 976 1010 1014 1025 1029
                                                                                  1040 1044 1055 1059 1074 1078 1160 1232 1241 1248
                                                                                  1253 1271 1273 1331 1351 1358 1369 1380 1388 1395
                                                                                  1408 1419 1432 1469 1474 1482 1489 1501 1506 1516
                                                                                  1524 1539 1546 1553 1559 1571 1595 1756 1842 1878
                                                                                  1896 2030 2049 2112 2204 2224
exit                            013305 constant        label                    dcl 1909 ref 178 182 201 209 212 241 250 282 296 302
                                                                                  308 341 343 352 355 365 368 379 384 388 397 400
                                                                                  412 415 418 421 431 434 446 524 563 587 624 629
                                                                                  645 652 664 668 680 689 692 702 707 728 732 736
                                                                                  746 757 773 782 791 800 808 817 826 835 838 857
                                                                                  859 862 865 868 880 912 914 921 930 933 981 984
                                                                                  987 997 1000 1012 1016 1027 1031 1042 1046 1057
                                                                                  1061 1071 1076 1080 1088 1091 1094 1097 1100 1103
                                                                                  1130 1133 1143 1146 1157 1162 1164 1176 1179 1182
                                                                                  1185 1199 1202 1212 1215 1251 1255 1275 1296 1300
                                                                                  1304 1309 1314 1332 1360 1400 1409 1411 1420 1434
                                                                                  1444 1447 1494 1531 1548 1554 1560 1573 1582 1585
                                                                                  1597 1602 1604 1614 1617 1628 1631 1634 1698 1706
                                                                                  1760 1767 1770 1778 1781 1789 1792 1800 1808 1816
                                                                                  1827 1834 1844 1851 1859 1867 1898 1905 2104
get_attribute_info              013752 constant        entry                    internal dcl 2001 ref 718 738 749 1346 1533 1599
get_next_arg                    014715 constant        entry                    internal dcl 2108 ref 1824
get_relation_statistics         013567 constant        entry                    internal dcl 1912 ref 333
get_stacked_token               015036 constant        entry                    internal dcl 2129 ref 513 517 1327 2022 2023 2097
init                            013343 constant        entry                    external dcl 2233
init_expression                 015062 constant        entry                    internal dcl 2138 ref 1344 1403 1414
init_select_list                015126 constant        entry                    internal dcl 2159 ref 226 662 666 678
mrds_dsl_semantics              000702 constant        entry                    external dcl 20
process_set_op                  015166 constant        entry                    internal dcl 2172 ref 292 298 304
prod                            000000 constant        label                    array(169) dcl 173 ref 163

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     16670       17056   16004       16700
Length     20146   16004       166        1054     663           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_dsl_semantics                  558 external procedure  is an external procedure.  
get_relation_statistics                 internal procedure  shares stack frame of external procedure mrds_dsl_semantics.  
get_attribute_info                      internal procedure  shares stack frame of external procedure mrds_dsl_semantics.  
error                                83 internal procedure  is called during a stack extension.  
get_next_arg                            internal procedure  shares stack frame of external procedure mrds_dsl_semantics.  
get_stacked_token                    66 internal procedure  uses returns(char(*)) or returns(bit(*)).  
init_expression                         internal procedure  shares stack frame of external procedure mrds_dsl_semantics.  
init_select_list                        internal procedure  shares stack frame of external procedure mrds_dsl_semantics.  
process_set_op                          internal procedure  shares stack frame of external procedure mrds_dsl_semantics.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 debug                       mrds_dsl_semantics

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
get_stacked_token        000100 len                         get_stacked_token
mrds_dsl_semantics       000100 option_list_ptr             mrds_dsl_semantics
                         000102 dbcb_ptr                    mrds_dsl_semantics
                         000104 range_ptr                   mrds_dsl_semantics
                         000106 trl_ptr                     mrds_dsl_semantics
                         000110 rdi_ptr                     mrds_dsl_semantics
                         000112 rmra_ptr                    mrds_dsl_semantics
                         000114 rmri_ptr                    mrds_dsl_semantics
                         000116 rai_ptr                     mrds_dsl_semantics
                         000120 model_seg_ptr               mrds_dsl_semantics
                         000122 model_area_ptr              mrds_dsl_semantics
                         000124 select_area_struct_ptr      mrds_dsl_semantics
                         000126 select_area_ptr             mrds_dsl_semantics
                         000130 desc_ptr                    mrds_dsl_semantics
                         000132 num_dims                    mrds_dsl_semantics
                         000134 select_list_ptr             mrds_dsl_semantics
                         000136 ss_ptr                      mrds_dsl_semantics
                         000140 nitems_init                 mrds_dsl_semantics
                         000142 scope_ptr                   mrds_dsl_semantics
                         000144 efd_ptr                     mrds_dsl_semantics
                         000146 attr_name                   mrds_dsl_semantics
                         000156 b_pos                       mrds_dsl_semantics
                         000157 base                        mrds_dsl_semantics
                         000160 bit_start_pos               mrds_dsl_semantics
                         000161 char_sw                     mrds_dsl_semantics
                         000162 descriptor_copy_ptr         mrds_dsl_semantics
                         000164 done                        mrds_dsl_semantics
                         000165 i                           mrds_dsl_semantics
                         000166 j                           mrds_dsl_semantics
                         000167 k                           mrds_dsl_semantics
                         000170 lex_stack_ptr               mrds_dsl_semantics
                         000172 rel_name                    mrds_dsl_semantics
                         000202 se_info_ptr                 mrds_dsl_semantics
                         000204 string_len                  mrds_dsl_semantics
                         000206 string_ptr                  mrds_dsl_semantics
                         000210 temp_rel_index              mrds_dsl_semantics
                         000224 i                           get_relation_statistics
                         000226 current_time                get_relation_statistics
                         000240 rel_pos                     get_attribute_info
                         000241 attr_pos                    get_attribute_info

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_other_desc
return_mac          tra_ext_1           shorten_stack       ext_entry           int_entry_desc      set_chars_eis
index_chars_eis     return_chars_eis    verify_eis          any_to_any_truncate_op_alloc_           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ioa_                          mrds_dsl_eval_expr            mrds_dsl_eval_func
mrds_dsl_expr_$build_attribute                              mrds_dsl_expr_$build_function mrds_dsl_expr_$build_literal
mrds_dsl_expr_$condense_stack mrds_dsl_expr_$finish         mrds_dsl_expr_$init
mrds_dsl_func_$build_attribute                              mrds_dsl_func_$build_expr_func
mrds_dsl_func_$build_literal  mrds_dsl_func_$finish         mrds_dsl_func_$init           mrds_dsl_get_builtins
mrds_dsl_optimize             mrds_dsl_select_clause_$all_attributes
mrds_dsl_select_clause_$finish                              mrds_dsl_select_clause_$one_attribute
mrds_dsl_where_clause_$build_attribute                      mrds_dsl_where_clause_$build_expr
mrds_dsl_where_clause_$build_literal                        mrds_dsl_where_clause_$build_node
mrds_dsl_where_clause_$finish mu_convert$convert_data       mu_rel_statistics$record_statistics
mu_valid_data_type$valid_scalar_data_type

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
mrds_data_$caller_compile     mrds_data_$max_attributes     mrds_data_$max_expr_stack_size
mrds_data_$max_id_len         mrds_data_$max_relations      mrds_data_$max_select_items   mrds_data_$max_sets
mrds_data_$max_temp_rels      mrds_data_$max_tup_var        mrds_data_$statistics_update_count_interval
mrds_data_$statistics_update_small_rel_size                 mrds_data_$statistics_update_time_interval
mrds_error_$bad_attr          mrds_error_$bad_temp_rel_val  mrds_error_$bad_var           mrds_error_$curr_not_alld
mrds_error_$insuff_args       mrds_error_$inv_string        mrds_error_$inval_comp_expr   mrds_error_$max_tup_var
mrds_error_$mult_def_var      mrds_error_$mult_expr_vars    mrds_error_$no_prior_se       mrds_error_$set_ovfl
mrds_error_$undef_rel         mrds_error_$undef_temp_rel    mrds_error_$unimplemented_syntax




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 8   51 000661   11   65 000663   12   13 000664   12   18 000665   13    6 000666   13   10 000667   14   20 000670
15   38 000671   17   59 000672        20 000675       153 000713       154 000720       155 000722       156 000724
    158 000726       163 000765       173 000770       177 001027       178 001065       180 001066       182 001121
    184 001122       195 001131       197 001135       201 001143       209 001144       212 001145       220 001146
    222 001153       223 001161       224 001163       225 001165       226 001166       228 001167       232 001232
    236 001271       239 001330       241 001333       250 001334       253 001335       256 001340       258 001344
    259 001351       263 001410       264 001415       266 001432       267 001440       269 001446       270 001454
    272 001462       275 001466       277 001472       279 001507       280 001524       282 001526       292 001527
    296 001531       298 001532       302 001534       304 001535       308 001537       317 001540       319 001547
    320 001555       321 001563       322 001570       324 001575       325 001600       326 001605       327 001615
    329 001616       330 001623       333 001630       334 001636       336 001674       337 001716       339 001754
    341 001761       343 001762       352 001763       355 001764       365 001765       368 001766       379 001767
    382 001770       384 002022       386 002023       388 002055       397 002056       400 002057       412 002060
    415 002061       418 002062       421 002063       431 002064       434 002065       446 002066       454 002067
    457 002070       465 002071       468 002072       476 002073       479 002074       487 002075       490 002076
    498 002077       501 002100       507 002101       509 002106       510 002155       513 002201       516 002266
    517 002277       522 002453       524 002456       534 002457       536 002464       540 002560       541 002562
    543 002570       546 002644       547 002700       553 002761       555 002767       556 003037       558 003045
    559 003056       560 003064       563 003111       566 003112       568 003117       572 003213       573 003215
    579 003230       585 003300       587 003327       591 003332       592 003340       597 003401       602 003453
    603 003523       605 003531       606 003542       607 003550       610 003575       611 003603       612 003607
    613 003622       616 003626       617 003633       619 003637       621 003650       624 003652       626 003653
    629 003705       643 003706       645 003740       647 003741       651 004000       652 004036       662 004037
    664 004040       666 004041       668 004042       670 004043       674 004052       676 004061       678 004063
    680 004064       689 004065       692 004066       702 004067       705 004070       707 004123       718 004124
    722 004151       726 004202       728 004240       730 004241       732 004274       734 004275       736 004330
    738 004331       741 004353       744 004413       746 004451       749 004452       752 004471       755 004526
    757 004564       770 004565       773 004601       782 004602       785 004603       789 004634       791 004672
    800 004673       803 004674       806 004725       808 004763       817 004764       820 004765       824 005013
    826 005051       835 005052       838 005053       851 005054       855 005110       857 005146       859 005147
    862 005150       865 005151       868 005152       880 005153       883 005154       885 005163       888 005200
    889 005202       891 005207       893 005234       897 005273       901 005333       902 005371       905 005372
    907 005410       910 005446       912 005453       914 005454       917 005455       920 005510       921 005546
    930 005547       933 005550       944 005551       947 005560       948 005562       950 005605       954 005644
    957 005660       958 005663       961 005714       962 005752       965 005753       969 005764       974 006020
    976 006043       979 006101       981 006106       984 006107       987 006110       997 006111      1000 006112
   1010 006113      1012 006145      1014 006146      1016 006200      1025 006201      1027 006233      1029 006234
   1031 006266      1040 006267      1042 006321      1044 006322      1046 006354      1055 006355      1057 006407
   1059 006410      1061 006442      1071 006443      1074 006444      1076 006476      1078 006477      1080 006531
   1088 006532      1091 006533      1094 006534      1097 006535      1100 006536      1103 006537      1111 006540
   1114 006541      1130 006542      1133 006543      1143 006544      1146 006545      1157 006546      1160 006547
   1162 006602      1164 006603      1176 006604      1179 006605      1182 006606      1185 006607      1199 006610
   1202 006611      1212 006612      1215 006613      1226 006614      1228 006622      1232 006653      1233 006711
   1235 006712      1236 006714      1241 006744      1242 007002      1243 007003      1244 007005      1248 007035
   1251 007073      1253 007074      1255 007127      1257 007130      1259 007136      1263 007146      1264 007150
   1265 007156      1266 007163      1271 007214      1272 007252      1273 007253      1275 007306      1287 007307
   1294 007372      1296 007374      1298 007375      1300 007402      1302 007403      1304 007410      1306 007411
   1309 007416      1311 007417      1314 007424      1327 007425      1331 007502      1332 007541      1344 007542
   1346 007543      1347 007565      1349 007574      1351 007601      1356 007635      1358 007674      1360 007732
   1363 007733      1366 007742      1367 007744      1369 007767      1373 010026      1376 010042      1377 010045
   1380 010076      1381 010134      1384 010135      1388 010146      1393 010202      1395 010225      1398 010263
   1400 010270      1403 010271      1405 010272      1408 010324      1409 010362      1411 010363      1414 010364
   1416 010365      1419 010417      1420 010455      1427 010456      1432 010506      1434 010544      1444 010545
   1447 010546      1460 010547      1462 010556      1465 010573      1467 010575      1469 010623      1472 010662
   1474 010713      1475 010751      1478 010752      1482 010766      1487 011022      1489 011047      1492 011105
   1494 011112      1496 011113      1498 011122      1499 011125      1501 011150      1504 011207      1506 011243
   1507 011301      1510 011302      1516 011310      1521 011344      1524 011377      1527 011435      1528 011442
   1531 011444      1533 011445      1535 011467      1537 011476      1539 011503      1544 011537      1546 011576
   1548 011634      1550 011635      1553 011661      1554 011717      1556 011720      1559 011744      1560 012002
   1571 012003      1573 012036      1582 012037      1585 012040      1595 012041      1597 012073      1599 012074
   1602 012116      1604 012117      1614 012120      1617 012121      1628 012122      1631 012123      1634 012124
   1645 012125      1648 012145      1649 012147      1651 012155      1652 012156      1653 012157      1654 012171
   1655 012172      1657 012175      1660 012176      1661 012200      1663 012207      1664 012211      1665 012213
   1666 012214      1668 012216      1670 012232      1671 012235      1673 012240      1675 012256      1676 012257
   1678 012265      1679 012271      1681 012273      1683 012274      1684 012301      1688 012307      1689 012315
   1691 012322      1698 012372      1700 012373      1702 012404      1703 012406      1704 012414      1706 012421
   1708 012422      1714 012445      1716 012453      1720 012471      1721 012507      1722 012511      1723 012512
   1724 012513      1726 012514      1727 012516      1728 012517      1731 012521      1734 012537      1735 012540
   1736 012547      1738 012556      1739 012567      1744 012627      1746 012631      1747 012636      1748 012644
   1750 012651      1755 012716      1756 012717      1760 012754      1767 012755      1770 012756      1778 012757
   1781 012760      1789 012761      1792 012762      1800 012763      1808 012764      1816 012765      1824 012766
   1827 013001      1834 013002      1842 013003      1844 013035      1851 013036      1859 013037      1867 013040
   1875 013041      1877 013046      1878 013057      1881 013113      1882 013117      1883 013124      1884 013127
   1886 013135      1887 013141      1888 013146      1889 013151      1891 013157      1892 013173      1896 013245
   1898 013303      1905 013304      1909 013305      2058 013306      2060 013315      2061 013317      2063 013320
   2065 013327      2066 013332      2233 013333      2237 013354      2240 013371      2241 013400      2242 013407
   2243 013414      2244 013421      2245 013424      2246 013432      2247 013440      2248 013445      2249 013450
   2251 013454      2252 013462      2253 013477      2254 013504      2258 013506      2261 013515      2262 013557
   2265 013560      2267 013566      1912 013567      1951 013571      1955 013573      1957 013606      1959 013650
   1963 013656      1966 013662      1972 013665      1982 013701      1992 013733      1998 013747      1999 013751
   2001 013752      2009 013754      2010 013761      2011 013764      2012 013767      2013 013771      2014 013773
   2016 013774      2017 013776      2019 013777      2020 014000      2022 014002      2023 014032      2026 014063
   2028 014137      2030 014141      2035 014233      2037 014306      2039 014314      2043 014337      2044 014342
   2047 014366      2049 014370      2054 014516      2056 014517      2069 014520      2078 014541      2079 014546
   2081 014552      2083 014554      2085 014563      2087 014572      2090 014573      2091 014576      2092 014603
   2094 014613      2097 014622      2101 014703      2104 014712      2108 014715      2112 014717      2115 014761
   2116 014770      2118 014777      2123 015013      2124 015021      2125 015027      2127 015034      2129 015035
   2134 015043      2135 015053      2138 015062      2149 015063      2150 015071      2151 015072      2152 015077
   2153 015102      2154 015111      2157 015125      2159 015126      2163 015127      2164 015145      2165 015146
   2166 015150      2167 015161      2168 015162      2169 015163      2170 015165      2172 015166      2177 015170
   2178 015175      2180 015201      2183 015205      2184 015211      2185 015236      2186 015240      2187 015241
   2189 015243      2190 015257      2193 015273      2195 015275      2197 015301      2199 015302      2200 015304
   2203 015310      2204 015315      2207 015356      2208 015363      2210 015400      2211 015406      2213 015414
   2214 015422      2216 015430      2219 015434      2220 015476      2222 015477      2224 015501      2228 015540
   2229 015544      2231 015555


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
