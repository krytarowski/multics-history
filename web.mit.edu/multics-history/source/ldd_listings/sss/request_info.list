	COMPILATION LISTING OF SEGMENT request_info
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/28/88  1322.8 mst Fri
	    Options: optimize map

        1 /****^  ********************************************
        2*        *                                          *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988 *
        4*        *                                          *
        5*        ******************************************** */
        6 
        7 
        8 /****^  HISTORY COMMENTS:
        9*  1) change(88-04-20,Parisek), approve(88-06-13,MCR7913),
       10*     audit(88-08-16,Farley), install(88-08-22,MR12.2-1089):
       11*     Initial coding.  Extracted code from list_abs_requests.pl1 and modified
       12*     to meet the specific requirements of this command/AF.  This command calls
       13*     lar_util_$request_info (new entrypoint developed to service this
       14*     command) with three parameters, the pointer to the info structure, a
       15*     switch designating whether or not rqi was invoked as active function,
       16*     and finally the return error code.  SCP-6391.
       17*                                                   END HISTORY COMMENTS */
       18 
       19 /* format: off */
       20 
       21 request_info:
       22 rqi:	procedure;
       23 
       24 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       25 	/*									*/
       26 	/* Command/Active function to provide information on absentee, IO Daemon, retrieval	*/
       27           /* and imft requests                                                                      */
       28 	/*									*/
       29 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       30 
       31     dcl	
       32           abs_key                       bit(1),
       33 	afsw                          bit(1) aligned,
       34 	allsw                         bit(1) aligned,
       35 	arg_msg			char(64),
       36 	argptr			ptr,
       37 	arglen			fixed bin(21),
       38 	code			fixed bin(35),
       39 	com_key                       bit(1),
       40 	ctl_arg_given		bit(1),
       41 	default_queue		fixed bin,
       42 	dfi_arg                       char(32),
       43 	dir			char(168),
       44 	ds_arg                        char(32),
       45 	ent			char(32),
       46 	err_msg			char(256),
       47 	fg_arg                        char(32),
       48 	fg_sw                         bit(1),
       49 	finish			fixed bin,
       50 	foreground_sw		bit(1),
       51 	gen_type			char(32),
       52 	i			fixed bin,
       53 	ignore_code		fixed bin(35),
       54 	ii			fixed bin,
       55 	iix			fixed bin,
       56 	imft_dest                     char(32),
       57 	imft_key                      bit(1),
       58 	imft_source                   char(32),
       59 	io_key                        bit(1),
       60 	io_queue_name                 char(32),
       61 	key_arg                       char(32),
       62 	max_queue			fixed bin,
       63 	min_queue			fixed bin,
       64 	nargs			fixed bin,
       65 	pch_arg                       char(32),
       66 	plt_arg                       char(32),
       67 	prt_arg                       char(32),
       68 	priority			fixed bin,
       69 	priority_q                    char(2),
       70           retlen                        fixed bin(21),
       71 	retptr                        ptr,
       72 	retv_key                      bit(1),
       73 	rsc_arg                       char(32),
       74 	rqt_arg                       char(32),
       75 	rqt_key                       bit(1),
       76 	rqi_key                       bit(1),
       77 	rqt_type                      fixed bin,
       78 	rs_len                        fixed bin,
       79 	sc_arg                        char(32),
       80 	sdr_arg                       char(32),
       81 	start			fixed bin,
       82 	tp			ptr,
       83 	user_arg			bit(1) aligned;
       84 
       85     dcl	arg			char(arglen) unal based (argptr);
       86     dcl   ret_arg                       char(retlen) varying based (retptr);
       87     dcl   ret_data                      char(info.output_count) based (info.temptr);
       88 		
       89     dcl  (addr, after, before, hbound, index, length, min, null, rtrim,
       90 	substr, unspec) 		builtin;
       91 
       92     dcl	cleanup			condition;
       93 
       94     dcl   complain                      entry variable options (variable),
       95 						/* com_err_ or active_fnc_err_ */
       96 	get_argument                  variable entry (fixed bin, ptr, fixed bin(21), fixed bin (35)),
       97 	active_fnc_err_               entry options (variable),
       98 	com_err_			options (variable),
       99           cu_$af_return_arg             entry (fixed bin, ptr, fixed bin(21), fixed bin(35)),
      100 	cu_$af_arg_ptr		entry (fixed bin, ptr, fixed bin(21), fixed bin(35)),
      101 	cu_$arg_ptr		entry (fixed bin, ptr, fixed bin(21), fixed bin(35)),
      102 	cv_dec_check_		entry (char(*), fixed bin(35)) returns(fixed bin(35)),
      103 	enter_output_request$default_request_type
      104 				entry (char(*), char(*), fixed bin, fixed bin, fixed bin(35)),
      105 	enter_output_request$request_type
      106 				entry (char(*), char(*), char(*), fixed bin, fixed bin, fixed bin(35)),
      107 	expand_pathname_		entry (char(*), char(*), char(*), fixed bin(35)),
      108 	get_temp_segment_		entry (char(*), ptr, fixed bin(35)),
      109 	hcs_$star_		entry (char(*), char(*), fixed bin(2), ptr, fixed bin, ptr, ptr,
      110 				     fixed bin(35)),
      111 	message_segment_$close	entry (fixed bin, fixed bin(35)),
      112 	message_segment_$open	entry (char(*), char(*), fixed bin, fixed bin(35)),
      113 	ioa_$rsnnl		entry() options(variable),
      114 	iod_info_$generic_type	entry (char(*), char(32), fixed bin(35)),
      115 	iod_info_$queue_data	entry (char(*), fixed bin, fixed bin, fixed bin(35)),
      116 	iox_$put_chars		entry (ptr, ptr, fixed bin(21), fixed bin(35)),
      117 	lar_util_$request_info	entry (ptr, bit (1) aligned, fixed bin(35)),    
      118 	release_temp_segment_	entry (char(*), ptr, fixed bin(35)),
      119 	system_info_$default_absentee_queue
      120 				entry (fixed bin);
      121 
      122     dcl	ALL                           fixed bin int static options (constant) init (1),
      123 						/* bit position in com_keywords */
      124     	BRANCHES                      fixed bin(2) int static options (constant) init (2),
      125     	CURRENTLY_UNDEFINED           fixed bin int static options (constant) init (-1),
      126           IMFT                          fixed bin int static options (constant) init (5),
      127 	POSITION                      fixed bin int static options (constant) init (4),
      128 						/* bit position in com_keywords */
      129 	QUEUE_NEG                     fixed bin int static options (constant) init (-1),
      130 	QUEUE_1                       fixed bin int static options (constant) init (1),
      131 	QUEUE_2                       fixed bin int static options (constant) init (2),
      132 	QUEUE_3                       fixed bin int static options (constant) init (3),
      133 	QUEUE_4                       fixed bin int static options (constant) init (4),
      134 	abs_dir			char(168) int static init(">system_control_1"),
      135 	id                            char(32) int static options (constant) init ("request_info"),
      136 	iod_dir			char(168) int static init(">daemon_dir_dir>io_daemon_dir"),
      137 	retriever_dir		char(168) int static init(">daemon_dir_dir>volume_retriever");
      138 
      139     dcl	error_table_$badopt		fixed bin(35) ext static,
      140 	error_table_$id_not_found	fixed bin(35) ext static,
      141 	error_table_$noarg		fixed bin(35) ext static,
      142 	error_table_$not_act_fnc	fixed bin(35) ext static,
      143 	iox_$user_output		ptr ext static;
      144 
      145 
      146 
      147 
      148 	/*  Begin include file lar_info.incl.pl1			  */
  1     2 
  1     3 /* Original version Aug 1977 */
  1     4 /* Modified May 1978 by T. Casey to add many new parameters */
  1     5 /* Modified November 1978 by T. Casey to add several variables for MR7.0 */
  1     6 /* Modified to add queue_name 11/05/79 S. Herbst */
  1     7 /* Modified Jan 1982 by G. Dixon to dcl constants for request_type values */
  1     8 
  1     9 /****^  HISTORY COMMENTS:
  1    10*  1) change(88-04-20,Parisek), approve(88-06-13,MCR7913),
  1    11*     audit(88-08-16,Farley), install(88-08-22,MR12.2-1089):
  1    12*     A) Added the abs_rqi, com_rqi, output_rqi, retv_rqi, and imft_rqi
  1    13*        elements to store bit values which determine what specific data is
  1    14*        requested by request_info command/AF.  Modified the pad field
  1    15*        to fill in the remaining unused word.
  1    16*     B) Included the arrays defining the information keywords used with
  1    17*        request_info (rqi).  Each element in these arrays pertains to a
  1    18*        bit value within one of the bit strings listed in A above.  Also,
  1    19*        the order of each element represents the identical order of the
  1    20*        respective bit within the above mentioned bit strings.
  1    21*     C) Added forms_sw and forms_name elements for storing info about
  1    22*        requested output special forms.
  1    23*  2) change(88-08-25,Farley), approve(88-09-16,MCR7911),
  1    24*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  1    25*     Increased forms_name to 64 characters.
  1    26*                                                   END HISTORY COMMENTS */
  1    27 
  1    28 
  1    29 dcl  info_ptr ptr;
  1    30 dcl 1 info aligned based (info_ptr),
  1    31     2 temptr ptr aligned,				/* pointer to temporary segment */
  1    32     2 mseg_idx fixed bin aligned,			/* offset of message segment */
  1    33     2 request_type fixed bin,				/* ABS, IO, OUTPUT, RETV */
  1    34     2 queue_name char (32) unal,			/* request type for io_daemon: printer, punch, etc. */
  1    35     2 queue fixed bin aligned,			/* priority level of message segment */
  1    36     2 input_count fixed bin (21) aligned,		/* length of temporary in chars when called */
  1    37     2 output_count fixed bin (21) aligned,		/* length of temporary in chars on return */
  1    38     2 select_count fixed bin aligned,			/* returned count of selected entries (from all queues) */
  1    39     2 user_select_count fixed bin aligned,		/* returned count of requests for specified user (from all Qs) */
  1    40     2 message_count fixed bin,			/* returned count of total entries (from all queues) */
  1    41     2 switches,
  1    42       3 long_sw bit (1) unaligned,			/* on - long format */
  1    43       3 admin_sw bit (1) unaligned,			/* on - admin option */
  1    44       3 total_sw bit (1) unaligned,			/* on - totals only */
  1    45       3 user_sw bit (1) unaligned,			/* on - look for supplied person.project */
  1    46       3 immediate bit (1) unaligned,			/* on - return only non-deferred matches */
  1    47       3 long_id_sw bit (1) unaligned,			/* on - print long ID even when not in long format */
  1    48       3 all_opt_sw bit (1) unaligned,			/* on - all queue data wanted */
  1    49       3 q_opt_sw bit (1) unaligned,			/* on - user specified a queue */
  1    50       3 path_sw bit (1) unaligned,			/* on - print full pathname even when not in long format */
  1    51       3 brief_sw bit (1) unaligned,			/* on - brief format */
  1    52       3 position_sw bit (1) unaligned,			/* on - print position in queue */
  1    53       3 resource_sw bit (1) unaligned,			/* on - print just rq's w/resource arg and print resource */
  1    54       3 dirname_sw bit (1) unaligned,			/* on - dirname given */
  1    55       3 ename_sw bit (1) unaligned,			/* on - ename given */
  1    56       3 id_sw bit (1) unaligned,			/* on - request ID given */
  1    57       3 deferred_indefinitely bit (1) unaligned,		/* on - print only requests that are deferred indefinitely */
  1    58       3 sender_sw bit (1) unaligned,			/* on - sender (RJE station) given */
  1    59       3 no_total_sw bit (1) unaligned,			/* RETURNED: on if unable to get totals for a queue */
  1    60       3 abs_q_1 bit (1) unaligned,			/* on - listing abs Qs 0 & 1, pretending all from 1 */
  1    61       3 resource_name_sw bit (1) unaligned,		/* on - resource name given */
  1    62       3 search_all bit (1) unaligned,			/* on - search all Qs, list ones that we select requests from */
  1    63       3 forms_sw bit (1) unaligned,			/* on - special forms name given */
  1    64       3 abs_rqi bit (13) unaligned,			/* each bit represents 1 request element */
  1    65       3 com_rqi bit (11) unaligned,			/* each bit represents 1 request element */
  1    66       3 output_rqi bit (11) unaligned,			/* each bit represents 1 request element */
  1    67       3 retv_rqi bit (4) unaligned,			/* each bit represents 1 request element */
  1    68       3 imft_rqi bit (3) unaligned,			/* each bit represents 1 request element */
  1    69       3 pad bit (8) unaligned,			/* rest of word */
  1    70     2 person char (28) aligned,			/* supplied person name - may be "*" */
  1    71     2 project char (28) aligned,			/* supplied project name - may be "*" */
  1    72     2 request_id char (19) aligned,			/* select request(s) matching this ID */
  1    73     2 dirname char (168) unal,			/* select requests from this directory */
  1    74     2 ename char (32) unal,				/* select requests matching this ename (can be starname) */
  1    75     2 sender char (32) aligned,			/* select requests entered by this RJE station */
  1    76     2 resource_name char (100) varying aligned,		/* select requests requiring the named resource(s) */
  1    77     2 forms_name char (64) unal;			/* select requests requiring the named form(s) */
  1    78 
  1    79 						/* possible values for info.request_type.	*/
  1    80 dcl ABS    fixed bin int static options(constant) init(1),	/*   list_abs_requests			*/
  1    81     IO     fixed bin int static options(constant) init(2),	/*   list_daemon_requests (almost obsolete)	*/
  1    82     OUTPUT fixed bin int static options(constant) init(3),	/*   list_output_requests			*/
  1    83     RETV   fixed bin int static options(constant) init(4);	/*   list_retrieval_requests			*/
  1    84 
  1    85 						/* below is defined the request_info */
  1    86 						/* information keyword arrays */
  1    87 /* The order of the following keywords within their respective arrays is
  1    88*   important as each element MUST be kept in sync with the respective
  1    89*   bit defined in com_rqi, abs_rqi, retv_rqi, output_rqi, or imft_rqi.
  1    90*   If any additional keywords are added in the future be sure a corresponding
  1    91*   bit is added to the proper bit string above.  Also add the format data
  1    92*   for the new element within its proper place in the buffer_element routine
  1    93*   of lar_util_.
  1    94**/
  1    95 
  1    96 dcl	abs_keywords                  (28) char(32) int static options (constant) init
  1    97 	     ("max_cpu_time", "limit", "li",		/* 1 */
  1    98 	     "output_file", "of",			/* 2 */
  1    99 	     "proxy_name", "pxn",			/* 3 */
  1   100 	     "resource", "rsc",			/* 4 */
  1   101 	     "sender",				/* 5 */
  1   102 	     "comment",				/* 6 */
  1   103 	     "args",				/* 7 */
  1   104 	     "home_dir", "hd",			/* 8 */
  1   105 	     "init_proc", "ip",			/* 9 */
  1   106 	     "initial_ring", "ring", "rg",		/* 10 */
  1   107 	     "authorization", "auth",			/* 11 */
  1   108 	     "deferred_time", "dftime", "time", 
  1   109 	          "dftm", "tm",			/* 12 */
  1   110 	     "deferred_by", "dfb"),			/* 13 */
  1   111 
  1   112 	abs_keyword_index             (28) fixed bin int static options (constant) init
  1   113 						/* index in info.abs_rqi */
  1   114 	     (1, 1, 1, 2, 2, 3, 3, 4, 4, 5, 6, 7, 8, 8, 9, 9, 10, 10, 10,
  1   115 	     11, 11, 12, 12, 12, 12, 12, 13, 13),
  1   116 
  1   117 	com_keywords                  (23) char(32) int static options (constant) init
  1   118 	     ("all", "a",				/* 1 */
  1   119 	     "request_id", "id",			/* 2 */
  1   120 	     "submitter",				/* 3 */
  1   121 	     "position", "pos",			/* 4 */
  1   122 	     "directory", "dr",			/* 5 */
  1   123 	     "entry", "et",				/* 6 */
  1   124 	     "enter_time", "etime", "etm",		/* 7 */
  1   125 	     "message_type", "type", "tp",		/* 8 */
  1   126 	     "queue", "q",				/* 9 */
  1   127 	     "state", "st",				/* 10 */
  1   128 	     "request_flags", "flags"),		/* 11 */
  1   129 
  1   130 	com_keyword_index             (23) fixed bin int static options (constant) init
  1   131 						/* index in info.com_rqi */
  1   132 	     (1, 1, 2, 2, 3, 4, 4, 5, 5, 6, 6, 7, 7, 7, 8, 8, 8,
  1   133 	     9, 9, 10, 10, 11, 11),
  1   134 
  1   135 	output_keywords               (23) char(32) int static options (constant) init
  1   136 	     ("bit_count", "bc",			/* 1 */
  1   137 	     "copies", "cp",			/* 2 */
  1   138 	     "destination", "dest", "ds",		/* 3 */
  1   139 	     "heading", "he",			/* 4 */
  1   140 	     "indent", "ind", "in",			/* 5 */
  1   141 	     "line_length", "ll",			/* 6 */
  1   142 	     "page_length", "pl",			/* 7 */
  1   143 	     "top_label", "tlbl",			/* 8 */
  1   144 	     "bottom_label", "blbl",			/* 9 */
  1   145 	     "output_conversion", "ocv",		/* 10 */
  1   146 	     "forms"),				/* 11 */
  1   147 
  1   148 	output_keyword_index          (23) fixed bin int static options (constant) init
  1   149 						/* index in info.output_rqi */
  1   150 	     (1, 1, 2, 2, 3, 3, 3, 4, 4, 5, 5, 5, 6, 6, 7, 7, 7, 8, 
  1   151 	     9, 9, 10, 10, 11),
  1   152 
  1   153 	retv_keywords                 (10) char(32) int static options (constant) init
  1   154 	     ("from_time", "fmtime", "fmtm",		/* 1 */
  1   155 	     "new_dir", "ndr",			/* 2 */
  1   156 	     "new_entry", "net",			/* 3 */
  1   157 	     "to_time", "ttime", "ttm"),		/* 4 */
  1   158 
  1   159 	retv_keyword_index            (10) fixed bin int static options (constant) init
  1   160 						/* index in info.retv_rqi */
  1   161 	     (1, 1, 1, 2, 2, 3, 3, 4, 4, 4),
  1   162 
  1   163 	imft_keywords                 (6) char(32) int static options (constant) init
  1   164 	     ("foreign_dir", "fdr",			/* 1 */
  1   165 	     "foreign_entry", "fet",			/* 2 */
  1   166 	     "foreign_user", "fu"),			/* 3 */
  1   167 
  1   168 	imft_keyword_index            (6) fixed bin int static options (constant) init
  1   169 						/* index in info.imft_rqi */
  1   170 	     (1, 1, 2, 2, 3, 3);
  1   171 
  1   172 /*  End include file lar_info.incl.pl1			  */
      148 
      149 
      150     dcl	1 local_info		like info aligned;
      151 
      152 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      153 
      154  	call cu_$af_return_arg (nargs, retptr, retlen, code);
      155 	if code = 0 then do;
      156  	     afsw = "1"b;
      157  	     complain = active_fnc_err_;
      158  	     get_argument = cu_$af_arg_ptr;
      159  	     ret_arg = "";
      160  	end;
      161  	else if code = error_table_$not_act_fnc then do;
      162  	     afsw = "0"b;
      163  	     complain = com_err_;
      164  	     get_argument = cu_$arg_ptr;
      165  	end;
      166 	else if code ^= 0 then do;
      167 	     call com_err_ (code, id);
      168 	     return;
      169 	end;		
      170 
      171 	call init;				/* defaults */
      172 	
      173 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      174 
      175 	allsw,     
      176 	ctl_arg_given,
      177 	foreground_sw = "0"b;
      178 
      179 	do i = 1 to nargs;
      180 	     call get_arg (i);
      181 	     if code ^= 0 then go to CHECK;		/* if no more arguments do consistency check */
      182 	     if index(arg, "-") = 1 then do;		/* if argument is an option match it with acceptable options */
      183 		ctl_arg_given = "1"b;
      184 		if arg = "-user" |
      185 		arg = "-am" | arg = "-admin" then do;
      186 		     if arg = "-user" then user_arg = "1"b; /* remember if it was -user */
      187 		     else user_arg = ""b;		/* or -admin */
      188 		     info.admin_sw = "1"b;
      189 		     call get_arg (i+1);		/* check for optional user name */
      190 		     if code = 0			/* if there is an argument there */
      191 		     & index(arg, "-") ^= 1 then do;	/* and it is not a control arg */
      192 			if info.user_sw then do;	/* user given ... but user already given */
      193 			     arg_msg = "User name given twice";
      194 PRINT_ARG_ERR:		     call ioa_$rsnnl ("^a. ^a", err_msg, rs_len, arg_msg, arg);
      195 			     call print_err_msg (0);
      196 			     return;
      197 			end;
      198 			i = i + 1;		/* remember that we used this arg */
      199 			info.user_sw = "1"b;
      200 			info.person = before (arg, ".");
      201 			info.project = before (after (arg, "."), ".");
      202 			if info.person = "" then info.person = "*";
      203 			if info.project = "" then info.project = "*";
      204 		     end;
      205 		     else if user_arg then do;	/* user name not optional after -user */
      206 			code = error_table_$noarg;
      207 			arg_msg = "After -user";
      208 			goto PRINT_MISS_ARG;
      209 		     end;
      210 		end;
      211 
      212 		else if arg = "-p" | arg = "-pn" | arg = "-pathname" then do;
      213 		     if info.dirname_sw then do;
      214 			if info.ename_sw then	/* -et already given */
      215 			     arg_msg = "Pathname and entryname cannot both be given.";
      216 			else arg_msg = "Pathname given twice";
      217 			goto PRINT_ARG_ERR;
      218 		     end;
      219 		     i = i + 1;
      220 		     call get_arg (i);		/* get PATH */
      221 		     if code ^= 0 then do;
      222 			arg_msg = "After -pn";
      223 			goto PRINT_MISS_ARG;
      224 		     end;
      225 		     call expand_pathname_ (arg, info.dirname, info.ename, code);
      226 		     if code ^= 0 then do;
      227 			call ioa_$rsnnl ("Expanding pathname: ^a", err_msg, rs_len, arg);
      228 			call print_err_msg (code);
      229 			return;
      230 		     end;
      231 		     info.dirname_sw, info.path_sw = "1"b;
      232 		end;
      233 		else if arg = "-a" | arg = "-all" then info.all_opt_sw = "1"b; /* we'll check later */
      234 		else if (arg = "-im" | arg = "-immediate") then do;
      235 		     if info.request_type = RETV then do;
      236 			err_msg = "Cannot specify -immediate with the retrieval request type.";
      237 			call print_err_msg (0);
      238 			return;
      239 		     end;
      240 		     info.immediate = "1"b;
      241 		end;
      242 		else if arg = "-q" | arg = "-queue" then do;
      243 		     if info.q_opt_sw then do;
      244 			arg_msg = "Queue option given twice";
      245 			goto PRINT_ARG_ERR;
      246 		     end;
      247 		     i = i + 1;			/* get next argument - number indicating which queue */
      248 		     call get_arg (i);
      249 		     if code ^= 0 then do;
      250 			arg_msg = "After -queue";
      251 			goto PRINT_MISS_ARG;
      252 		     end;
      253 		     info.q_opt_sw = "1"b;		/* remember that it has been given */
      254 		     priority_q = arg;		/* remember for CHECK */
      255 		     if (arg = "fg" | arg = "foreground") then fg_sw = "1"b;
      256 		end;
      257 		else if arg = "-id" then do;
      258 		     if info.id_sw then do;
      259 			arg_msg = "Id option given twice";
      260 			goto PRINT_ARG_ERR;
      261 		     end;
      262 		     i = i + 1;			/* next arg is the ID */
      263 		     call get_arg (i);
      264 		     if code ^= 0 then do;
      265 			arg_msg = "After -id";
      266 PRINT_MISS_ARG:		err_msg = arg_msg;
      267 			call print_err_msg (code);
      268 			return;
      269 		     end;
      270 		     info.id_sw = "1"b;
      271 		     info.request_id = arg;
      272 		end;
      273 		else if arg = "-et" | arg = "-entry" then do;
      274 		     if info.ename_sw then do;	/* entryname already given */
      275 			if info.dirname_sw then
      276 			     arg_msg = "Pathname and entry name cannot both be given";
      277 			else arg_msg = "Entry name given twice";
      278 			goto PRINT_ARG_ERR;
      279 		     end;
      280 		     i = i + 1;
      281 		     call get_arg (i);
      282 		     if code ^= 0 then do;
      283 			arg_msg = "After -entry";
      284 			goto PRINT_MISS_ARG;
      285 		     end;
      286 		     info.ename_sw = "1"b;
      287 		     info.ename = arg;
      288 		end;
      289 		else if arg = "-forms" then do;
      290 		     if info.forms_sw then do;
      291 			arg_msg = "Forms given twice.";
      292 			goto PRINT_ARG_ERR;
      293 		     end;
      294 		     call get_arg (i+1);		/* check for optional forms name */
      295 		     if code = 0 & index (arg, "-") ^= 1 then do;
      296 			i = i + 1;		/* increment arg index */
      297 			info.forms_name = arg;	/* and save form name */
      298 		     end;
      299 		     else info.forms_name = "";	/* else show no form name given */
      300 		     info.forms_sw = "1"b;
      301 		end;
      302 		else if arg = "-rsc" | arg = "-resource" then do;
      303 		     info.resource_sw = "1"b;
      304 		     rsc_arg = arg;
      305 		     call get_arg (i+1);		/* look at next arg */
      306 		     if code = 0			/* if there is an arg there */
      307 			then if index(arg, "-") ^= 1 then do;
      308 						/* and it's not a control arg */
      309 						/* assume it's a resource name */
      310 			     i = i + 1;		/* bump arg index */
      311 			     if info.resource_name_sw then do;
      312 				arg_msg = "Resource name given twice";
      313 				goto PRINT_ARG_ERR;
      314 			     end;
      315 			     info.resource_name_sw = "1"b;
      316 			     info.resource_name = arg;
      317 			     if length (arg) > length (info.resource_name) then do;
      318 				call ioa_$rsnnl ("Resource name too long; limit is ^d characters.",
      319 				     err_msg, rs_len, length (info.resource_name));
      320 				call print_err_msg (0);
      321 				return;
      322 			     end;
      323 			end;
      324 		end;
      325 		else if arg = "-dfi" | arg = "-deferred_indefinitely" then do;
      326 		     dfi_arg = arg;	
      327 		     info.deferred_indefinitely = "1"b;
      328 		end;
      329 		else if arg= "-destination" | arg = "-ds" then do;
      330 						/* IMFT ctl_arg */
      331 		     if ds_arg ^= "" then do;
      332 			arg_msg = "Destination given twice";
      333 			goto PRINT_ARG_ERR;
      334 		     end;
      335 		     ds_arg = arg;
      336 		     i = i + 1;
      337 		     call get_arg (i);
      338 		     if code ^= 0 then do;
      339 			arg_msg = "After -destination";
      340 			goto PRINT_MISS_ARG;
      341 		     end;
      342 		     imft_dest = arg;
      343 		end;
      344 		else if arg= "-source" | arg = "-sc" then do;
      345 						/* IMFT ctl_arg */
      346 		     if sc_arg ^= "" then do;
      347 			arg_msg = "Source given twice";
      348 			goto PRINT_ARG_ERR;
      349 		     end;
      350 		     sc_arg = arg;
      351 		     i = i + 1;
      352 		     call get_arg (i);
      353 		     if code ^= 0 then do;
      354 			arg_msg = "After -source";
      355 			goto PRINT_MISS_ARG;
      356 		     end;
      357 		     imft_source = arg;
      358 		end;
      359 		else if arg = "-sender" then do;
      360 		     if info.sender_sw then do;
      361 			arg_msg = "Sender given twice";
      362 			goto PRINT_ARG_ERR;
      363 		     end;
      364 		     sdr_arg = arg;	
      365 		     i = i + 1;
      366 		     call get_arg (i);
      367 		     if code ^= 0 then do;
      368 			arg_msg = "After -sender";
      369 			goto PRINT_MISS_ARG;
      370 		     end;
      371 		     info.sender_sw = "1"b;
      372 		     info.sender = arg;
      373 		end;
      374 		else if arg = "-fg" | arg = "-foreground" then do;
      375 		     fg_arg = arg;	
      376 		     foreground_sw = "1"b;
      377 		end;
      378 		else do;
      379 		     err_msg = arg;
      380 		     call print_err_msg (error_table_$badopt);
      381 		     return;
      382 		end;
      383                end;
      384 
      385 	     else do;				/* not a control arg, might be a keyword or request type */
      386 		do ii = 1 to hbound (com_keywords, 1) while
      387 		     (com_keywords (ii) ^= arg);	/* check for common keys */
      388 		end;
      389 		if ii <= hbound (com_keywords, 1) then do;
      390 		     iix = com_keyword_index (ii);
      391 		     if iix = ALL | iix = POSITION then do;
      392 			if iix = ALL then allsw = "1"b;
      393 			info.position_sw = "1"b;	/* position or all */
      394 		     end;
      395 		     substr(info.com_rqi, iix, 1) = "1"b;
      396 		     com_key = "1"b;		/* remember what key is being used */
      397 		     rqi_key = "1"b;		/* remember that a key is specified */
      398 		end;
      399 		else do;
      400 		     do ii = 1 to hbound (abs_keywords, 1) while
      401 			(abs_keywords (ii) ^= arg);	/* check for abs keys */
      402 		     end;
      403 		     if ii <= hbound (abs_keywords, 1) then do;
      404 			iix = abs_keyword_index (ii);
      405 			substr(info.abs_rqi, iix, 1) = "1"b;
      406 			abs_key = "1"b;
      407 			rqi_key = "1"b;
      408 		     end;
      409 		     else do;
      410 			do ii = 1 to hbound (output_keywords, 1) while
      411 			     (output_keywords (ii) ^= arg);
      412 						/* check for output/io keys */
      413 			end;
      414 			if ii <= hbound (output_keywords, 1) then do;
      415 			     iix = output_keyword_index (ii);
      416 			     substr(info.output_rqi, iix, 1) = "1"b;
      417 			     io_key = "1"b;
      418 			     rqi_key = "1"b;
      419 			end;
      420 			else do;
      421 			     do ii = 1 to hbound (retv_keywords, 1) while
      422 				(retv_keywords (ii) ^= arg);
      423 						/* check for retrieval keys */
      424 			     end;
      425 			     if ii <= hbound (retv_keywords, 1) then do;
      426 				iix = retv_keyword_index (ii);
      427 				substr(info.retv_rqi, iix, 1) = "1"b;
      428 				retv_key = "1"b;
      429 				rqi_key = "1"b;
      430 			     end;
      431 			     else do;
      432 				do ii = 1 to hbound (imft_keywords, 1) while
      433 				     (imft_keywords (ii) ^= arg);
      434 						/* check for imft keys */
      435 				end;
      436 				if ii <= hbound (imft_keywords, 1) then do;
      437 				     iix = imft_keyword_index (ii);
      438 				     substr(info.imft_rqi, iix, 1) = "1"b;
      439 				     imft_key = "1"b;
      440 				     rqi_key = "1"b;
      441 				end;
      442 				else if ^rqt_key then do;	/* check for request type key */
      443 				     call look_rqt_key (substr(arg, 1, arglen));
      444 						/* define the rqt */
      445 				     key_arg = arg;
      446 				     rqt_key = "1"b;
      447 				     call init_rqt;
      448 						/* initialize rqt dependent data */
      449 				end;
      450 				else do;		/* must be invalid keyword */
      451 				     call ioa_$rsnnl ("Invalid keyword, ^a.",
      452 					err_msg, rs_len, arg);
      453 				     call print_err_msg (0);
      454 				     return;
      455 				end;
      456 			     end;
      457 			end;
      458 		     end;
      459 		end;
      460 	     end;
      461 	end;					/* end argument loop */
      462 
      463 /* Now check the arguments for consistency */
      464 
      465 CHECK:
      466 
      467 	if ^rqt_key then do;			/* missing rqt key */
      468 	     err_msg = "Missing request type keyword.";
      469 	     call print_err_msg (0);
      470 	     return;
      471 	end;
      472 
      473 	if ^rqi_key then do;			/* missing info key */
      474 	     err_msg = "Missing request info keyword.";
      475 	     call print_err_msg (0);
      476 	     return;
      477 	end;
      478 
      479 	if allsw & afsw then do;
      480 	     err_msg = "Keyword ""all"" not permitted with the active function.";
      481 	     call print_err_msg (0);
      482 	     return;
      483 	end;
      484 
      485 	if rqt_type = ABS & (^abs_key & ^com_key) then do;
      486 incons_key:    err_msg = "request type key inconsistent with info key.";
      487 	     call print_err_msg (0);
      488 	     return;
      489 	end;
      490 	
      491 	if (rqt_type = OUTPUT | rqt_type = IO) & (^io_key & ^com_key) then
      492 	     goto incons_key;
      493 
      494 	if rqt_type = RETV & (^retv_key & ^com_key) then goto incons_key;
      495 
      496 	if rqt_type = IMFT & (^imft_key & ^com_key) then goto incons_key;
      497 
      498 	if rqt_type ^= ABS then do;
      499 	     if rsc_arg ^= "" then do;		/* -rsc given, but rqt not abs */
      500 		err_msg = rtrim(rsc_arg) || " for " || key_arg;
      501 		goto CHECK_BADOPT;
      502 	     end;
      503 	     else if dfi_arg ^= "" then do;		/* -dfi given, but rqt not abs */
      504 		err_msg = rtrim(dfi_arg) || " for " || key_arg;
      505 		goto CHECK_BADOPT;
      506 	     end;
      507 	     else if sdr_arg ^= "" then do;		/* -sender given, but rqt not abs */
      508 		err_msg = rtrim(sdr_arg) || " for " || key_arg;
      509 		goto CHECK_BADOPT;
      510 	     end;
      511 	     else if fg_arg ^= "" then do;		/* -foreground given, but rqt not abs */
      512 		err_msg = rtrim(fg_arg) || " for " || key_arg;
      513 		goto CHECK_BADOPT;
      514 	     end;
      515 	end;
      516 
      517 	if rqt_type ^= IMFT & (ds_arg ^= "" | sc_arg ^= "") then do;
      518 	     if ds_arg ^= "" then err_msg = rtrim(ds_arg) || " for " || key_arg;
      519 						/* -dest given, but rqt not imft */
      520 	     else err_msg = rtrim(sc_arg) || " for " || key_arg;
      521 						/* -source given, but rqt not imft */
      522 CHECK_BADOPT:  call print_err_msg (error_table_$badopt);
      523 	     return;
      524 	end;
      525 
      526 	if info.all_opt_sw & info.q_opt_sw then do;
      527 	     err_msg = "The -all and -queue control arguments are incompatible.";
      528 	     call print_err_msg (0);
      529 	     return;
      530 	end;
      531 
      532 	if info.q_opt_sw then do;
      533 	     if fg_sw & rqt_type = ABS then priority = -1;/* foreground queue */
      534 	     else do;
      535 		priority = cv_dec_check_ (rtrim(priority_q), code);
      536 		if code ^= 0 then do;
      537 		     call ioa_$rsnnl ("Illegal queue number ^a", err_msg, rs_len, rtrim(priority_q));
      538 		     call print_err_msg (0);
      539 		     return;
      540 		end;
      541 	     end;
      542 	     start, finish = priority;		/* specified queue */
      543 	     if priority < min_queue | priority > max_queue then do;
      544 		call ioa_$rsnnl ("-queue ^d is invalid.  Use a number from ^d to ^d.", err_msg, rs_len,
      545 		     priority, min_queue, max_queue);
      546 		call print_err_msg (0);
      547 		return;
      548 	     end;
      549 	end;
      550 
      551 	if (foreground_sw & (info.all_opt_sw | info.q_opt_sw)) |
      552 	     (info.all_opt_sw & (info.q_opt_sw | foreground_sw)) |
      553 	     (info.q_opt_sw & (info.all_opt_sw | foreground_sw)) then do;
      554 	     call ioa_$rsnnl ("The following control arguments are incompatible: -foreground, -all, and -queue",
      555 		err_msg, rs_len);
      556 	     call print_err_msg (0);
      557 	     return;
      558 	end;
      559 
      560 	if rqt_type = IMFT then do;
      561 	     if imft_dest ^= "" then do;		/* -dest */
      562 		info.queue_name = "To_" || rtrim(imft_dest);
      563 		call iod_info_$generic_type (info.queue_name, gen_type, code);
      564 		if code ^= 0 then do;
      565 		     if code = error_table_$id_not_found then do;
      566 id_not_found:		call ioa_$rsnnl ("Unknown request type.  ^a",
      567 			     err_msg, rs_len, info.queue_name);
      568 			call print_err_msg (code);
      569 			return;
      570 		     end;
      571 		     else do;
      572 rqt_warning:		call ioa_$rsnnl ("Warning -- Unable to check request type ^a.",
      573 			     err_msg, rs_len, io_queue_name);
      574 			call print_err_msg (code);
      575 		     end;
      576 		end;
      577 		else call iod_info_$queue_data (info.queue_name, default_queue, max_queue, ignore_code);
      578 	     end;
      579 	     else if imft_source ^= "" then do;		/* -sc */
      580 		info.queue_name = "From_" || rtrim(imft_source);
      581 		call iod_info_$generic_type (info.queue_name, gen_type, code);
      582 		if code ^= 0 then do;
      583 		     if code = error_table_$id_not_found then
      584 			goto id_not_found;
      585 		     else goto rqt_warning;
      586 		end;
      587 		else call iod_info_$queue_data (info.queue_name, default_queue, max_queue, ignore_code);
      588 	     end;
      589 	end;
      590 
      591 
      592 /* Now set first and last queue according to arguments or defaults (but -q argument processing sets them in-line) */
      593 
      594 	if info.all_opt_sw then do;			/* all queues */
      595 	     start = min_queue;
      596 	     finish = max_queue;
      597 	end;
      598 	else if foreground_sw then			/* only foreground queue */
      599 	     start, finish = -1;
      600 	else if ^info.q_opt_sw then do;		/* no queue specified - set defaults */
      601 	     start = min_queue;			/* that is, search all queues */
      602 	     finish = max_queue;
      603 	     info.search_all = "1"b;			/* but only print for queues that we select requests from */
      604 
      605 	end;
      606 	if info.request_type = ABS then do;		/* for absentee queues */
      607 	     if start = 1 then			/* if user said -q 1 */
      608 		start = 0;			/* we pretend queue 0 is the first part of queue 1 */
      609 	     if start <= 0				/* if listing queue 0 */
      610 	     & finish >= 1				/* and also queue 1 */
      611 	     then info.abs_q_1 = "1"b;		/* turn on the "pretend they are one queue" switch */
      612 	end;
      613 
      614 /* Arguments are ok. Get ready to call lar_util_$request_info. First, get a temp segment for lar_util_ to build the listing in. */
      615 
      616 	info.mseg_idx = 0;				/* no open mseg */
      617 
      618 /* CONDITION HANDLER FOR cleanup */
      619 
      620 	on condition (cleanup) begin;			/* but first be sure we will give it back no matter what */
      621 	     if info.mseg_idx ^= 0 then		/* if we have an open mseg */
      622 		call message_segment_$close (info.mseg_idx, ignore_code);
      623 	     if tp ^= null then			/* if we have a temp seg */
      624 		call release_temp_segment_ (id, tp, code); /* give it back */
      625 	end;					/* end begin block */
      626 
      627 /* END CONDITION HANDLER */
      628 
      629 	call get_temp_segment_ (id, tp, code);
      630 	if code ^= 0 then do;
      631 	     err_msg = "temporary segment";
      632 	     call print_err_msg (code);
      633 	     return;
      634 	end;
      635 
      636 /* Initialize, before entering loop over queues */
      637 
      638 	info.temptr = tp;
      639 
      640 /* Beginning of loop over one or more queues */
      641 
      642 	do info.queue = start to finish;
      643 	     if info.queue = -1 then ent = "absentee_foreground.ms"; /* construct entry name of message segment */
      644 	     else call ioa_$rsnnl ("^a_^d.ms", ent, rs_len, info.queue_name, info.queue);
      645 	     call message_segment_$open (dir, ent, info.mseg_idx, code); /* initiate message segment containing requests */
      646 	     if code = 0 then do;			/* if we opened it successfully, go list it */
      647 
      648 /* call lar_util_$request_info, which will build up a listing of this queue's requests, in a printable segment */
      649 
      650 		call lar_util_$request_info (info_ptr, afsw, code);
      651 						/* get information on requests in this queue */
      652 		call message_segment_$close (info.mseg_idx, ignore_code);
      653 						/* close message segment */
      654 	     end;
      655 	     if code ^= 0 then do;
      656 		call ioa_$rsnnl ("^[Attempting to open^x^;^]^a>^a", err_msg, rs_len, (info.mseg_idx = 0), dir, ent);
      657 		call print_err_msg (code);
      658 	     end;
      659 	     info.mseg_idx = 0;			/* so cleanup handler doesn't try to close it again */
      660 	     info.input_count = info.output_count;	/* copy new length of temorary */
      661 	end;
      662 
      663 /* End of loop over queues. Now print the info produced by lar_util_$request_info. */
      664 
      665 	if info.output_count > 1 then do;
      666 	     if afsw then do;
      667 		info.output_count = info.output_count - 1;   /* remove the xtra char placed at end of string */
      668 		ret_arg = ret_data;
      669 	     end;
      670 	     else do;
      671 		if allsw then info.output_count = info.output_count - 1;
      672 						/* if all, then remove trailing NL */
      673 		call iox_$put_chars (iox_$user_output, info.temptr, info.output_count, code);
      674 		if code ^= 0 then do;
      675 		     err_msg = "user_output";
      676 		     call print_err_msg (code);
      677 		end;
      678 	     end;
      679 	end;
      680 
      681 /* This is the main exit from this procedure */
      682 
      683 ERROR_EXIT:
      684 	if tp ^= null() then call release_temp_segment_ (id, tp, code);
      685 	return;
      686 
      687 
      688 
      689 
      690 test_rqi:	entry (rqt_test, sys_dir_test);		/* entry point for testing rqi command		*/
      691 
      692     dcl	sys_dir_test		char(*);
      693     dcl   rqt_test                      char(*);
      694 
      695 	if rqt_test = "absentee" | rqt_test = "abs" then
      696 	     abs_dir = sys_dir_test;
      697 	else if rqt_test = "output" | rqt_test = "out" | rqt_test = "io" |
      698 	     rqt_test = "imft" then
      699 	     iod_dir = sys_dir_test;
      700 	else if rqt_test = "retrieval" | rqt_test = "retv" then
      701 	     retriever_dir = sys_dir_test;
      702 	return;
      703 
      704 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      705 	/*									*/
      706 	/*	INTERNAL	 PROCEDURES						*/
      707 	/*									*/
      708 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      709 
      710 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      711 
      712 
      713 get_arg:	proc (argno);
      714 
      715     dcl	argno			fixed bin;
      716 
      717 	     call get_argument (argno, argptr, arglen, code);
      718 	     return;
      719 
      720 	end get_arg;
      721 
      722 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      723 
      724 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      725 
      726 
      727 init:	proc;
      728 
      729 	tp = null();
      730 	rqi_key, rqt_key, abs_key, com_key, io_key, imft_key, retv_key
      731 	     = "0"b;
      732 	dfi_arg, ds_arg, fg_arg, imft_dest, imft_source, pch_arg,
      733 	     plt_arg, prt_arg, rsc_arg, rqt_arg, sdr_arg, sc_arg = "";
      734 
      735 	info_ptr = addr (local_info);
      736 	unspec (info) = ""b;			/* zero everyting in info structure */
      737 
      738 	return;
      739 
      740 	end init;
      741 
      742 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      743 
      744 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      745 
      746 
      747 print_err_msg: proc (ec);
      748 
      749 dcl	ec			fixed bin(35);	/* error code */
      750 
      751 /* The global variable, err_msg, is an implicit argument */
      752 
      753 	     call complain (ec, id, err_msg);
      754 	     return;
      755 
      756 	end print_err_msg;
      757 
      758 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      759 
      760 look_rqt_key:
      761 	proc (key);
      762      dcl key char (*) parm;
      763 	
      764 	if key = "absentee" | key = "abs" then rqt_type = ABS;
      765 	else if key = "retrieval" | key = "retv" then rqt_type = RETV;
      766 	else if key = "io" then rqt_type = IO;
      767 	else if key = "imft" then rqt_type = IMFT;
      768 	else if key = "output" | key = "out" then rqt_type = OUTPUT;
      769 	else rqt_type = CURRENTLY_UNDEFINED;		/* could be a user-defined rqt */
      770 
      771 	return;
      772 
      773      end look_rqt_key;
      774 
      775 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      776 
      777 init_rqt:
      778           proc ();
      779 
      780 	if rqt_type = OUTPUT | rqt_type = IO then do;	/* OUTPUT/IO */
      781 	     min_queue = 1;
      782 	     dir = iod_dir;
      783 	     call enter_output_request$default_request_type ("printer",
      784 		info.queue_name, default_queue, max_queue, code);
      785 	     if code ^= 0 then goto undef_rqt;
      786 	     info.request_type = OUTPUT;
      787 	end;
      788 	else if rqt_type = CURRENTLY_UNDEFINED then do;	/* Possibly user-defined */
      789 	     call enter_output_request$request_type (key_arg, gen_type,
      790 		info.queue_name, default_queue, max_queue, code);
      791 	     if code ^= 0 then do;
      792 undef_rqt:	call ioa_$rsnnl ("Getting request type defaults for ^a.", err_msg, rs_len, key_arg);
      793 		call print_err_msg (code);
      794 		goto ERROR_EXIT;
      795 	     end;
      796 	     min_queue = QUEUE_1;
      797 	     dir = iod_dir;
      798 	     if gen_type = "imft" then info.request_type = IMFT;
      799 	     else info.request_type = OUTPUT;
      800 	end;
      801 	else if rqt_type = ABS then do;		/* ABS */
      802 	     call system_info_$default_absentee_queue (default_queue);
      803 	     if default_queue = 0 then default_queue = QUEUE_3;
      804 	     max_queue = QUEUE_4;
      805 	     min_queue = QUEUE_NEG;
      806 	     dir = abs_dir;
      807 	     info.queue_name = "absentee";
      808 	     info.request_type = ABS;
      809 	end;
      810 	else if rqt_type = RETV then do;		/* RETV */
      811 	     call hcs_$star_ (retriever_dir, "volume_retriever*.ms", BRANCHES,
      812 		null, max_queue, (null), (null), code);
      813 	     if code ^= 0 then
      814 		max_queue = QUEUE_3;
      815 	     default_queue = min (max_queue, QUEUE_3);
      816 	     min_queue = QUEUE_1;
      817 	     dir = retriever_dir;
      818 	     info.queue_name = "volume_retriever";
      819 	     info.request_type = RETV;
      820 	end;
      821 	else if rqt_type = IMFT then do;		/* IMFT */
      822 	     call iod_info_$queue_data ("imft", default_queue, max_queue, code);
      823 	     if code ^= 0 then do;
      824 		max_queue = QUEUE_4;
      825 		default_queue = QUEUE_2;
      826 	     end;
      827 	     min_queue = QUEUE_1;
      828 	     dir = iod_dir;
      829 	     gen_type = "imft";
      830 	     info.queue_name = "imft";
      831 	     info.request_type = IMFT;
      832 	end;
      833 
      834      end init_rqt;
      835 
      836      end request_info;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/28/88  1258.0  request_info.pl1                  >special_ldd>install>MR12.2-1199>request_info.pl1
148          1    10/28/88  1226.7  lar_info.incl.pl1                 >special_ldd>install>MR12.2-1199>lar_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ABS                                    constant        fixed bin(17,0)          initial dcl 1-80 ref 485 498 533 606 764 801 808
ALL                                    constant        fixed bin(17,0)          initial dcl 122 ref 391 392
BRANCHES                        001534 constant        fixed bin(2,0)           initial dcl 122 set ref 811*
CURRENTLY_UNDEFINED             007214 constant        fixed bin(17,0)          initial dcl 122 ref 769 788
IMFT                                   constant        fixed bin(17,0)          initial dcl 122 ref 496 517 560 767 798 821 831
IO                                     constant        fixed bin(17,0)          initial dcl 1-80 ref 491 766 780
OUTPUT                                 constant        fixed bin(17,0)          initial dcl 1-80 ref 491 768 780 786 799
POSITION                               constant        fixed bin(17,0)          initial dcl 122 ref 391
QUEUE_1                                constant        fixed bin(17,0)          initial dcl 122 ref 796 816 827
QUEUE_2                                constant        fixed bin(17,0)          initial dcl 122 ref 825
QUEUE_3                                constant        fixed bin(17,0)          initial dcl 122 ref 803 813 815
QUEUE_4                                constant        fixed bin(17,0)          initial dcl 122 ref 804 824
QUEUE_NEG                              constant        fixed bin(17,0)          initial dcl 122 ref 805
RETV                                   constant        fixed bin(17,0)          initial dcl 1-80 ref 235 494 765 810 819
abs_dir                         000010 internal static char(168)                initial packed unaligned dcl 122 set ref 695* 806
abs_key                         000100 automatic       bit(1)                   packed unaligned dcl 31 set ref 406* 485 730*
abs_keyword_index               001056 constant        fixed bin(17,0)          initial array dcl 1-96 ref 404
abs_keywords                    001112 constant        char(32)                 initial array packed unaligned dcl 1-96 ref 400 400
                                                                                  403
abs_q_1                  22(18)        based           bit(1)                   level 3 packed packed unaligned dcl 1-30 set ref
                                                                                  609*
abs_rqi                  22(22)        based           bit(13)                  level 3 packed packed unaligned dcl 1-30 set ref
                                                                                  405*
active_fnc_err_                 000206 constant        entry                    external dcl 94 ref 157
addr                                                   builtin function         dcl 89 ref 735
admin_sw                 22(01)        based           bit(1)                   level 3 packed packed unaligned dcl 1-30 set ref
                                                                                  188*
afsw                            000101 automatic       bit(1)                   dcl 31 set ref 156* 162* 479 650* 666
after                                                  builtin function         dcl 89 ref 201
all_opt_sw               22(06)        based           bit(1)                   level 3 packed packed unaligned dcl 1-30 set ref
                                                                                  233* 526 551 551 551 594
allsw                           000102 automatic       bit(1)                   dcl 31 set ref 175* 392* 479 671
arg                                    based           char                     packed unaligned dcl 85 set ref 182 184 184 184 186
                                                                                  190 194* 200 201 212 212 212 225* 227* 233 233 234
                                                                                  234 242 242 254 255 255 257 271 273 273 287 289
                                                                                  295 297 302 302 304 306 316 317 325 325 326 329
                                                                                  329 335 342 344 344 350 357 359 364 372 374 374
                                                                                  375 379 386 400 410 421 432 443 443 445 451*
arg_msg                         000103 automatic       char(64)                 packed unaligned dcl 31 set ref 193* 194* 207* 214*
                                                                                  216* 222* 244* 250* 259* 265* 266 275* 277* 283*
                                                                                  291* 312* 332* 339* 347* 354* 361* 368*
arglen                          000126 automatic       fixed bin(21,0)          dcl 31 set ref 182 184 184 184 186 190 194 194 200
                                                                                  201 212 212 212 225 225 227 227 233 233 234 234
                                                                                  242 242 254 255 255 257 271 273 273 287 289 295
                                                                                  297 302 302 304 306 316 317 325 325 326 329 329
                                                                                  335 342 344 344 350 357 359 364 372 374 374 375
                                                                                  379 386 400 410 421 432 443 443 443 443 445 451
                                                                                  451 717*
argno                                  parameter       fixed bin(17,0)          dcl 715 set ref 713 717*
argptr                          000124 automatic       pointer                  dcl 31 set ref 182 184 184 184 186 190 194 200 201
                                                                                  212 212 212 225 227 233 233 234 234 242 242 254
                                                                                  255 255 257 271 273 273 287 289 295 297 302 302
                                                                                  304 306 316 317 325 325 326 329 329 335 342 344
                                                                                  344 350 357 359 364 372 374 374 375 379 386 400
                                                                                  410 421 432 443 443 445 451 717*
before                                                 builtin function         dcl 89 ref 200 201
cleanup                         000540 stack reference condition                dcl 92 ref 620
code                            000127 automatic       fixed bin(35,0)          dcl 31 set ref 154* 155 161 166 167* 181 190 206*
                                                                                  221 225* 226 228* 249 264 267* 282 295 306 338 353
                                                                                  367 535* 536 563* 564 565 568* 574* 581* 582 583
                                                                                  623* 629* 630 632* 645* 646 650* 655 657* 673* 674
                                                                                  676* 683* 717* 783* 785 789* 791 793* 811* 813
                                                                                  822* 823
com_err_                        000210 constant        entry                    external dcl 94 ref 163 167
com_key                         000130 automatic       bit(1)                   packed unaligned dcl 31 set ref 396* 485 491 494 496
                                                                                  730*
com_keyword_index               000537 constant        fixed bin(17,0)          initial array dcl 1-96 ref 390
com_keywords                    000566 constant        char(32)                 initial array packed unaligned dcl 1-96 ref 386 386
                                                                                  389
com_rqi                  22(35)        based           bit(11)                  level 3 packed packed unaligned dcl 1-30 set ref
                                                                                  395*
complain                        000546 automatic       entry variable           dcl 94 set ref 157* 163* 753
ctl_arg_given                   000131 automatic       bit(1)                   packed unaligned dcl 31 set ref 175* 183*
cu_$af_arg_ptr                  000214 constant        entry                    external dcl 94 ref 158
cu_$af_return_arg               000212 constant        entry                    external dcl 94 ref 154
cu_$arg_ptr                     000216 constant        entry                    external dcl 94 ref 164
cv_dec_check_                   000220 constant        entry                    external dcl 94 ref 535
default_queue                   000132 automatic       fixed bin(17,0)          dcl 31 set ref 577* 587* 783* 789* 802* 803 803*
                                                                                  815* 822* 825*
deferred_indefinitely
                         22(15)        based           bit(1)                   level 3 packed packed unaligned dcl 1-30 set ref
                                                                                  327*
dfi_arg                         000133 automatic       char(32)                 packed unaligned dcl 31 set ref 326* 503 504 732*
dir                             000143 automatic       char(168)                packed unaligned dcl 31 set ref 645* 656* 782* 797*
                                                                                  806* 817* 828*
dirname                  47            based           char(168)                level 2 packed packed unaligned dcl 1-30 set ref
                                                                                  225*
dirname_sw               22(12)        based           bit(1)                   level 3 packed packed unaligned dcl 1-30 set ref 213
                                                                                  231* 275
ds_arg                          000215 automatic       char(32)                 packed unaligned dcl 31 set ref 331 335* 517 518 518
                                                                                  732*
ec                                     parameter       fixed bin(35,0)          dcl 749 set ref 747 753*
ename                   121            based           char(32)                 level 2 packed packed unaligned dcl 1-30 set ref
                                                                                  225* 287*
ename_sw                 22(13)        based           bit(1)                   level 3 packed packed unaligned dcl 1-30 set ref 214
                                                                                  274 286*
ent                             000225 automatic       char(32)                 packed unaligned dcl 31 set ref 643* 644* 645* 656*
enter_output_request$default_request_type
                                000222 constant        entry                    external dcl 94 ref 783
enter_output_request$request_type
                                000224 constant        entry                    external dcl 94 ref 789
err_msg                         000235 automatic       char(256)                packed unaligned dcl 31 set ref 194* 227* 236* 266*
                                                                                  318* 379* 451* 468* 474* 480* 486* 500* 504* 508*
                                                                                  512* 518* 520* 527* 537* 544* 554* 566* 572* 631*
                                                                                  656* 675* 753* 792*
error_table_$badopt             000256 external static fixed bin(35,0)          dcl 139 set ref 380* 522*
error_table_$id_not_found       000260 external static fixed bin(35,0)          dcl 139 ref 565 583
error_table_$noarg              000262 external static fixed bin(35,0)          dcl 139 ref 206
error_table_$not_act_fnc        000264 external static fixed bin(35,0)          dcl 139 ref 161
expand_pathname_                000226 constant        entry                    external dcl 94 ref 225
fg_arg                          000335 automatic       char(32)                 packed unaligned dcl 31 set ref 375* 511 512 732*
fg_sw                           000345 automatic       bit(1)                   packed unaligned dcl 31 set ref 255* 533
finish                          000346 automatic       fixed bin(17,0)          dcl 31 set ref 542* 596* 598* 602* 609 642
foreground_sw                   000347 automatic       bit(1)                   packed unaligned dcl 31 set ref 175* 376* 551 551
                                                                                  551 598
forms_name              173            based           char(64)                 level 2 packed packed unaligned dcl 1-30 set ref
                                                                                  297* 299*
forms_sw                 22(21)        based           bit(1)                   level 3 packed packed unaligned dcl 1-30 set ref 290
                                                                                  300*
gen_type                        000350 automatic       char(32)                 packed unaligned dcl 31 set ref 563* 581* 789* 798
                                                                                  829*
get_argument                    000552 automatic       entry variable           dcl 94 set ref 158* 164* 717
get_temp_segment_               000230 constant        entry                    external dcl 94 ref 629
hbound                                                 builtin function         dcl 89 ref 386 389 400 403 410 414 421 425 432 436
hcs_$star_                      000232 constant        entry                    external dcl 94 ref 811
i                               000360 automatic       fixed bin(17,0)          dcl 31 set ref 179* 180* 189 198* 198 219* 219 220*
                                                                                  247* 247 248* 262* 262 263* 280* 280 281* 294 296*
                                                                                  296 305 310* 310 336* 336 337* 351* 351 352* 365*
                                                                                  365 366*
id                              001452 constant        char(32)                 initial packed unaligned dcl 122 set ref 167* 623*
                                                                                  629* 683* 753*
id_sw                    22(14)        based           bit(1)                   level 3 packed packed unaligned dcl 1-30 set ref 258
                                                                                  270*
ignore_code                     000361 automatic       fixed bin(35,0)          dcl 31 set ref 577* 587* 621* 652*
ii                              000362 automatic       fixed bin(17,0)          dcl 31 set ref 386* 386* 389 390 400* 400* 403 404
                                                                                  410* 410* 414 415 421* 421* 425 426 432* 432* 436
                                                                                  437
iix                             000363 automatic       fixed bin(17,0)          dcl 31 set ref 390* 391 391 392 395 404* 405 415*
                                                                                  416 426* 427 437* 438
imft_dest                       000364 automatic       char(32)                 packed unaligned dcl 31 set ref 342* 561 562 732*
imft_key                        000374 automatic       bit(1)                   packed unaligned dcl 31 set ref 439* 496 730*
imft_keyword_index              000000 constant        fixed bin(17,0)          initial array dcl 1-96 ref 437
imft_keywords                   000006 constant        char(32)                 initial array packed unaligned dcl 1-96 ref 432 432
                                                                                  436
imft_rqi                 23(25)        based           bit(3)                   level 3 packed packed unaligned dcl 1-30 set ref
                                                                                  438*
imft_source                     000375 automatic       char(32)                 packed unaligned dcl 31 set ref 357* 579 580 732*
immediate                22(04)        based           bit(1)                   level 3 packed packed unaligned dcl 1-30 set ref
                                                                                  240*
index                                                  builtin function         dcl 89 ref 182 190 295 306
info                                   based           structure                level 1 dcl 1-30 set ref 736*
info_ptr                        000556 automatic       pointer                  dcl 1-29 set ref 188 192 199 200 201 202 202 203 203
                                                                                  213 214 225 225 231 231 233 235 240 243 253 258
                                                                                  270 271 274 275 286 287 290 297 299 300 303 311
                                                                                  315 316 317 318 318 327 360 371 372 393 395 405
                                                                                  416 427 438 526 526 532 551 551 551 551 551 551
                                                                                  562 563 566 577 580 581 587 594 600 603 606 609
                                                                                  616 621 621 638 642 643 644 644 645 650* 652 656
                                                                                  659 660 660 665 667 667 668 668 671 671 673 673
                                                                                  735* 736 783 786 789 798 799 807 808 818 819 830
                                                                                  831
input_count              15            based           fixed bin(21,0)          level 2 dcl 1-30 set ref 660*
io_key                          000405 automatic       bit(1)                   packed unaligned dcl 31 set ref 417* 491 730*
io_queue_name                   000406 automatic       char(32)                 packed unaligned dcl 31 set ref 572*
ioa_$rsnnl                      000240 constant        entry                    external dcl 94 ref 194 227 318 451 537 544 554 566
                                                                                  572 644 656 792
iod_dir                         000062 internal static char(168)                initial packed unaligned dcl 122 set ref 697* 782
                                                                                  797 828
iod_info_$generic_type          000242 constant        entry                    external dcl 94 ref 563 581
iod_info_$queue_data            000244 constant        entry                    external dcl 94 ref 577 587 822
iox_$put_chars                  000246 constant        entry                    external dcl 94 ref 673
iox_$user_output                000266 external static pointer                  dcl 139 set ref 673*
key                                    parameter       char                     packed unaligned dcl 762 ref 760 764 764 765 765 766
                                                                                  767 768 768
key_arg                         000416 automatic       char(32)                 packed unaligned dcl 31 set ref 445* 500 504 508 512
                                                                                  518 520 789* 792*
lar_util_$request_info          000250 constant        entry                    external dcl 94 ref 650
length                                                 builtin function         dcl 89 ref 317 317 318 318
local_info                      000560 automatic       structure                level 1 dcl 150 set ref 735
max_queue                       000426 automatic       fixed bin(17,0)          dcl 31 set ref 543 544* 577* 587* 596 602 783* 789*
                                                                                  804* 811* 813* 815 822* 824*
message_segment_$close          000234 constant        entry                    external dcl 94 ref 621 652
message_segment_$open           000236 constant        entry                    external dcl 94 ref 645
min                                                    builtin function         dcl 89 ref 815
min_queue                       000427 automatic       fixed bin(17,0)          dcl 31 set ref 543 544* 595 601 781* 796* 805* 816*
                                                                                  827*
mseg_idx                  2            based           fixed bin(17,0)          level 2 dcl 1-30 set ref 616* 621 621* 645* 652* 656
                                                                                  659*
nargs                           000430 automatic       fixed bin(17,0)          dcl 31 set ref 154* 179
null                                                   builtin function         dcl 89 ref 623 683 729 811 811 811 811
output_count             16            based           fixed bin(21,0)          level 2 dcl 1-30 set ref 660 665 667* 667 668 671*
                                                                                  671 673*
output_keyword_index            000220 constant        fixed bin(17,0)          initial array dcl 1-96 ref 415
output_keywords                 000247 constant        char(32)                 initial array packed unaligned dcl 1-96 ref 410 410
                                                                                  414
output_rqi               23(10)        based           bit(11)                  level 3 packed packed unaligned dcl 1-30 set ref
                                                                                  416*
path_sw                  22(08)        based           bit(1)                   level 3 packed packed unaligned dcl 1-30 set ref
                                                                                  231*
pch_arg                         000431 automatic       char(32)                 packed unaligned dcl 31 set ref 732*
person                   24            based           char(28)                 level 2 dcl 1-30 set ref 200* 202 202*
plt_arg                         000441 automatic       char(32)                 packed unaligned dcl 31 set ref 732*
position_sw              22(10)        based           bit(1)                   level 3 packed packed unaligned dcl 1-30 set ref
                                                                                  393*
priority                        000461 automatic       fixed bin(17,0)          dcl 31 set ref 533* 535* 542 543 543 544*
priority_q                      000462 automatic       char(2)                  packed unaligned dcl 31 set ref 254* 535 535 537 537
project                  33            based           char(28)                 level 2 dcl 1-30 set ref 201* 203 203*
prt_arg                         000451 automatic       char(32)                 packed unaligned dcl 31 set ref 732*
q_opt_sw                 22(07)        based           bit(1)                   level 3 packed packed unaligned dcl 1-30 set ref 243
                                                                                  253* 526 532 551 551 551 600
queue                    14            based           fixed bin(17,0)          level 2 dcl 1-30 set ref 642* 643 644*
queue_name                4            based           char(32)                 level 2 packed packed unaligned dcl 1-30 set ref
                                                                                  562* 563* 566* 577* 580* 581* 587* 644* 783* 789*
                                                                                  807* 818* 830*
release_temp_segment_           000252 constant        entry                    external dcl 94 ref 623 683
request_id               42            based           char(19)                 level 2 dcl 1-30 set ref 271*
request_type              3            based           fixed bin(17,0)          level 2 dcl 1-30 set ref 235 606 786* 798* 799* 808*
                                                                                  819* 831*
resource_name           141            based           varying char(100)        level 2 dcl 1-30 set ref 316* 317 318 318
resource_name_sw         22(19)        based           bit(1)                   level 3 packed packed unaligned dcl 1-30 set ref 311
                                                                                  315*
resource_sw              22(11)        based           bit(1)                   level 3 packed packed unaligned dcl 1-30 set ref
                                                                                  303*
ret_arg                                based           varying char             dcl 86 set ref 159* 668*
ret_data                               based           char                     packed unaligned dcl 87 ref 668
retlen                          000463 automatic       fixed bin(21,0)          dcl 31 set ref 154* 159 668
retptr                          000464 automatic       pointer                  dcl 31 set ref 154* 159 668
retriever_dir                   000134 internal static char(168)                initial packed unaligned dcl 122 set ref 700* 811*
                                                                                  817
retv_key                        000466 automatic       bit(1)                   packed unaligned dcl 31 set ref 428* 494 730*
retv_keyword_index              000066 constant        fixed bin(17,0)          initial array dcl 1-96 ref 426
retv_keywords                   000100 constant        char(32)                 initial array packed unaligned dcl 1-96 ref 421 421
                                                                                  425
retv_rqi                 23(21)        based           bit(4)                   level 3 packed packed unaligned dcl 1-30 set ref
                                                                                  427*
rqi_key                         000510 automatic       bit(1)                   packed unaligned dcl 31 set ref 397* 407* 418* 429*
                                                                                  440* 473 730*
rqt_arg                         000477 automatic       char(32)                 packed unaligned dcl 31 set ref 732*
rqt_key                         000507 automatic       bit(1)                   packed unaligned dcl 31 set ref 442 446* 465 730*
rqt_test                               parameter       char                     packed unaligned dcl 693 ref 690 695 695 697 697 697
                                                                                  697 700 700
rqt_type                        000511 automatic       fixed bin(17,0)          dcl 31 set ref 485 491 491 494 496 498 517 533 560
                                                                                  764* 765* 766* 767* 768* 769* 780 780 788 801 810
                                                                                  821
rs_len                          000512 automatic       fixed bin(17,0)          dcl 31 set ref 194* 227* 318* 451* 537* 544* 554*
                                                                                  566* 572* 644* 656* 792*
rsc_arg                         000467 automatic       char(32)                 packed unaligned dcl 31 set ref 304* 499 500 732*
rtrim                                                  builtin function         dcl 89 ref 500 504 508 512 518 520 535 535 537 537
                                                                                  562 580
sc_arg                          000513 automatic       char(32)                 packed unaligned dcl 31 set ref 346 350* 517 520
                                                                                  732*
sdr_arg                         000523 automatic       char(32)                 packed unaligned dcl 31 set ref 364* 507 508 732*
search_all               22(20)        based           bit(1)                   level 3 packed packed unaligned dcl 1-30 set ref
                                                                                  603*
sender                  131            based           char(32)                 level 2 dcl 1-30 set ref 372*
sender_sw                22(16)        based           bit(1)                   level 3 packed packed unaligned dcl 1-30 set ref 360
                                                                                  371*
start                           000533 automatic       fixed bin(17,0)          dcl 31 set ref 542* 595* 598* 601* 607 607* 609 642
substr                                                 builtin function         dcl 89 set ref 395* 405* 416* 427* 438* 443 443
switches                 22            based           structure                level 2 dcl 1-30
sys_dir_test                           parameter       char                     packed unaligned dcl 692 ref 690 695 697 700
system_info_$default_absentee_queue
                                000254 constant        entry                    external dcl 94 ref 802
temptr                                 based           pointer                  level 2 dcl 1-30 set ref 638* 668 673*
tp                              000534 automatic       pointer                  dcl 31 set ref 623 623* 629* 638 683 683* 729*
unspec                                                 builtin function         dcl 89 set ref 736*
user_arg                        000536 automatic       bit(1)                   dcl 31 set ref 186* 187* 205
user_sw                  22(03)        based           bit(1)                   level 3 packed packed unaligned dcl 1-30 set ref 192
                                                                                  199*

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK                           004213 constant        label                    dcl 465 ref 181
CHECK_BADOPT                    004664 constant        label                    dcl 522 ref 501 505 509 513
ERROR_EXIT                      006157 constant        label                    dcl 683 ref 794
PRINT_ARG_ERR                   002516 constant        label                    dcl 194 ref 217 245 260 278 292 313 333 348 362
PRINT_MISS_ARG                  003157 constant        label                    dcl 266 ref 208 223 251 284 340 355 369
get_arg                         006321 constant        entry                    internal dcl 713 ref 180 189 220 248 263 281 294 305
                                                                                  337 352 366
id_not_found                    005266 constant        label                    dcl 566 ref 583
incons_key                      004265 constant        label                    dcl 486 ref 491 494 496
init                            006340 constant        entry                    internal dcl 727 ref 171
init_rqt                        006555 constant        entry                    internal dcl 777 ref 447
look_rqt_key                    006450 constant        entry                    internal dcl 760 ref 443
print_err_msg                   006424 constant        entry                    internal dcl 747 ref 195 228 237 267 320 380 453 469
                                                                                  475 481 487 522 528 538 546 556 568 574 632 657
                                                                                  676 793
request_info                    002305 constant        entry                    external dcl 21
rqi                             002276 constant        entry                    external dcl 21
rqt_warning                     005322 constant        label                    dcl 572 ref 585
test_rqi                        006211 constant        entry                    external dcl 690
undef_rqt                       006670 constant        label                    dcl 792 ref 785

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      7576       10066    7223        7606
Length     10354    7223       270         252     353         176

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rqi                                 737 external procedure  is an external procedure.  
on unit on line 620                  84 on unit               
get_arg                                 internal procedure  shares stack frame of external procedure rqi.  
init                                    internal procedure  shares stack frame of external procedure rqi.  
print_err_msg                           internal procedure  shares stack frame of external procedure rqi.  
look_rqt_key                         65 internal procedure  is called during a stack extension.  
init_rqt                                internal procedure  shares stack frame of external procedure rqi.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 abs_dir                     rqi
000062 iod_dir                     rqi
000134 retriever_dir               rqi

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rqi                      000100 abs_key                     rqi
                         000101 afsw                        rqi
                         000102 allsw                       rqi
                         000103 arg_msg                     rqi
                         000124 argptr                      rqi
                         000126 arglen                      rqi
                         000127 code                        rqi
                         000130 com_key                     rqi
                         000131 ctl_arg_given               rqi
                         000132 default_queue               rqi
                         000133 dfi_arg                     rqi
                         000143 dir                         rqi
                         000215 ds_arg                      rqi
                         000225 ent                         rqi
                         000235 err_msg                     rqi
                         000335 fg_arg                      rqi
                         000345 fg_sw                       rqi
                         000346 finish                      rqi
                         000347 foreground_sw               rqi
                         000350 gen_type                    rqi
                         000360 i                           rqi
                         000361 ignore_code                 rqi
                         000362 ii                          rqi
                         000363 iix                         rqi
                         000364 imft_dest                   rqi
                         000374 imft_key                    rqi
                         000375 imft_source                 rqi
                         000405 io_key                      rqi
                         000406 io_queue_name               rqi
                         000416 key_arg                     rqi
                         000426 max_queue                   rqi
                         000427 min_queue                   rqi
                         000430 nargs                       rqi
                         000431 pch_arg                     rqi
                         000441 plt_arg                     rqi
                         000451 prt_arg                     rqi
                         000461 priority                    rqi
                         000462 priority_q                  rqi
                         000463 retlen                      rqi
                         000464 retptr                      rqi
                         000466 retv_key                    rqi
                         000467 rsc_arg                     rqi
                         000477 rqt_arg                     rqi
                         000507 rqt_key                     rqi
                         000510 rqi_key                     rqi
                         000511 rqt_type                    rqi
                         000512 rs_len                      rqi
                         000513 sc_arg                      rqi
                         000523 sdr_arg                     rqi
                         000533 start                       rqi
                         000534 tp                          rqi
                         000536 user_arg                    rqi
                         000546 complain                    rqi
                         000552 get_argument                rqi
                         000556 info_ptr                    rqi
                         000560 local_info                  rqi

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_char_temp     cat_realloc_chars   call_ent_var_desc   call_ent_var        call_ext_out_desc
call_ext_out        call_int_this_desc  return_mac          enable_op           shorten_stack       ext_entry
ext_entry_desc      int_entry           int_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
active_fnc_err_               com_err_                      cu_$af_arg_ptr                cu_$af_return_arg
cu_$arg_ptr                   cv_dec_check_                 enter_output_request$default_request_type
enter_output_request$request_type                           expand_pathname_              get_temp_segment_
hcs_$star_                    ioa_$rsnnl                    iod_info_$generic_type        iod_info_$queue_data
iox_$put_chars                lar_util_$request_info        message_segment_$close        message_segment_$open
release_temp_segment_         system_info_$default_absentee_queue

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$id_not_found     error_table_$noarg            error_table_$not_act_fnc
iox_$user_output




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     21 002275       154 002312       155 002326       156 002330       157 002332       158 002337       159 002342
    160 002343       161 002344       162 002347       163 002350       164 002354       165 002357       166 002360
    167 002362       168 002376       171 002377       175 002400       179 002403       180 002413       181 002415
    182 002417       183 002433       184 002435       186 002452       187 002460       188 002461       189 002464
    190 002471       192 002507       193 002513       194 002516       195 002554       196 002557       198 002560
    199 002561       200 002563       201 002574       202 002620       203 002627       204 002636       205 002637
    206 002641       207 002644       208 002647       210 002650       212 002651       213 002665       214 002671
    216 002700       217 002703       219 002704       220 002705       221 002707       222 002711       223 002714
    225 002715       226 002746       227 002750       228 003003       229 003005       231 003006       232 003013
    233 003014       234 003030       235 003040       236 003044       237 003047       238 003052       240 003053
    241 003055       242 003056       243 003066       244 003072       245 003075       247 003076       248 003077
    249 003101       250 003103       251 003106       253 003107       254 003112       255 003120       256 003132
    257 003133       258 003137       259 003143       260 003146       262 003147       263 003150       264 003152
    265 003154       266 003157       267 003162       268 003164       270 003165       271 003170       272 003175
    273 003176       274 003206       275 003212       277 003221       278 003224       280 003225       281 003226
    282 003230       283 003232       284 003235       286 003236       287 003241       288 003246       289 003247
    290 003253       291 003257       292 003262       294 003263       295 003270       296 003306       297 003307
    298 003313       299 003314       300 003320       301 003323       302 003324       303 003334       304 003337
    305 003342       306 003347       310 003365       311 003366       312 003372       313 003375       315 003376
    316 003400       317 003410       318 003413       320 003443       321 003446       324 003447       325 003450
    326 003460       327 003463       328 003466       329 003467       331 003477       332 003503       333 003506
    335 003507       336 003512       337 003513       338 003515       339 003517       340 003522       342 003523
    343 003530       344 003531       346 003541       347 003545       348 003550       350 003551       351 003554
    352 003555       353 003557       354 003561       355 003564       357 003565       358 003572       359 003573
    360 003577       361 003603       362 003606       364 003607       365 003612       366 003613       367 003615
    368 003617       369 003622       371 003623       372 003626       373 003633       374 003634       375 003644
    376 003647       377 003650       379 003651       380 003654       381 003663       383 003664       386 003665
    388 003703       389 003705       390 003710       391 003712       392 003716       393 003722       395 003725
    396 003731       397 003733       398 003734       400 003735       402 003753       403 003755       404 003760
    405 003762       406 003766       407 003770       408 003771       410 003772       413 004007       414 004011
    415 004014       416 004016       417 004022       418 004024       419 004025       421 004026       424 004043
    425 004045       426 004050       427 004052       428 004056       429 004060       430 004061       432 004062
    435 004077       436 004101       437 004104       438 004106       439 004112       440 004114       441 004115
    442 004116       443 004120       445 004140       446 004146       447 004150       449 004151       451 004152
    453 004205       454 004210       461 004211       465 004213       468 004215       469 004220       470 004223
    473 004224       474 004226       475 004231       476 004234       479 004235       480 004242       481 004245
    482 004250       485 004251       486 004265       487 004270       488 004273       491 004274       494 004304
    496 004312       498 004320       499 004322       500 004326       501 004365       503 004367       504 004373
    505 004432       507 004434       508 004440       509 004477       511 004501       512 004505       513 004544
    517 004546       518 004560       520 004624       522 004664       523 004674       526 004675       527 004706
    528 004711       529 004714       532 004715       533 004717       535 004726       536 004770       537 004773
    538 005043       539 005047       542 005050       543 005053       544 005057       546 005114       547 005117
    551 005120       554 005153       556 005177       557 005202       560 005203       561 005206       562 005212
    563 005240       564 005261       565 005263       566 005266       568 005317       569 005321       572 005322
    574 005352       576 005354       577 005355       578 005402       579 005403       580 005407       581 005435
    582 005456       583 005460       585 005463       587 005464       594 005511       595 005515       596 005517
    597 005521       598 005522       600 005530       601 005533       602 005535       603 005537       606 005541
    607 005544       609 005550       616 005557       620 005560       621 005574       623 005610       625 005636
    629 005637       630 005660       631 005662       632 005665       633 005667       638 005670       642 005672
    643 005706       644 005716       645 005747       646 005775       650 005777       652 006012       655 006024
    656 006026       657 006072       659 006074       660 006076       661 006100       665 006103       666 006107
    667 006112       668 006114       669 006126       671 006127       673 006133       674 006150       675 006152
    676 006155       683 006157       685 006204       690 006205       695 006231       697 006253       700 006302
    702 006320       713 006321       717 006323       718 006337       727 006340       729 006341       730 006343
    732 006352       735 006416       736 006420       738 006423       747 006424       753 006426       754 006446
    760 006447       764 006463       765 006501       766 006515       767 006525       768 006535       769 006551
    771 006554       777 006555       780 006556       781 006563       782 006565       783 006571       785 006623
    786 006625       787 006630       788 006631       789 006633       791 006666       792 006670       793 006720
    794 006722       796 006723       797 006725       798 006731       799 006741       800 006744       801 006745
    802 006747       803 006756       804 006762       805 006764       806 006766       807 006772       808 006776
    809 007000       810 007001       811 007003       813 007055       815 007061       816 007066       817 007070
    818 007074       819 007100       820 007102       821 007103       822 007105       823 007133       824 007135
    825 007137       827 007141       828 007143       829 007147       830 007152       831 007156       834 007160


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
