	COMPILATION LISTING OF SEGMENT probe_print_stack_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/27/88  1236.8 mst Thu
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(88-09-07,WAAnderson), approve(88-09-30,MCR7952),
       16*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
       17*     Added format control comment to make the source more readable.
       18*                                                   END HISTORY COMMENTS */
       19 
       20 
       21 /* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       22 
       23 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       24 
       25 probe_print_stack_:
       26   proc ();
       27 
       28   call probe_error_$malfunction ();	/* can't call here */
       29 
       30   /* *	This procedure implements the stack printing feature of probe, as well
       31*   *	as the request used to print the stack.
       32*
       33*   Modified 3 Sept 79 JRD -  to make stack req. respect the "execute" bit. */
       34   /* Format shortened, "long" added 09/30/81 S. Herbst */
       35   /* Changed to print support frames with decimal increments 12/10/81 S. Herbst */
       36   /* Trailing space removed 07/26/82 S. Herbst */
       37   /* Fixed "stack long all" not to print garbage pathname for return_to_ring_0_ 05/27/83 S. Herbst */
       38   /* Changed to call probe_block_name_ with "0"b (brief form) 08/26/83 S. Herbst */
       39 
       40   dcl (
       41       P_probe_info_ptr	pointer,
       42       P_first_level		fixed bin,/* (input) start history at this level */
       43       P_number_levels	fixed bin,/* number of levels to trace */
       44       P_all_flag		bit (1) aligned,
       45 				/* indicates to include system routines */
       46       P_long_flag		bit (1) aligned,
       47 				/* indicates long format (paths, offsets) */
       48       P_code		fixed bin (35)
       49       )			parameter;
       50 
       51   dcl frame_reached		bit (1);	/* have we reached the current frame */
       52   dcl (i, j)		fixed bin;
       53   dcl block_name		char (256) varying;
       54   dcl continue_tracing	bit (1) aligned;
       55   dcl code		fixed bin (35);
       56 
       57   dcl 1 cond_info		aligned like condition_info automatic;
       58 
       59   dcl probe_et_$syntax_error	fixed bin (35) external static;
       60 
       61   dcl find_condition_info_	entry (pointer, pointer, fixed bin (35));
       62   dcl get_shortest_path_	entry (char (*)) returns (char (168));
       63   dcl hcs_$fs_get_path_name	entry (ptr, char (*), fixed bin, char (*),
       64 			fixed bin (35));
       65   dcl ioa_$ioa_switch	entry options (variable);
       66   dcl ioa_$rsnnl		entry options (variable);
       67 
       68   dcl probe_error_$malfunction
       69 			entry options (variable);
       70   dcl probe_error_		entry options (variable);
       71   dcl probe_block_name_	entry (ptr, ptr, bit (1) aligned)
       72 			returns (char (256) varying);
       73   dcl probe_get_$integer	entry (ptr, fixed bin, fixed bin (35));
       74   dcl probe_trace_a_stack_	entry (ptr, ptr, bit (1) aligned);
       75 
       76   dcl (addr, bin, fixed, max, min, null, rel)
       77 			builtin;
       78 				/*  */
       79 
       80 probe_print_stack_$print_stack_history:
       81   entry (P_probe_info_ptr, P_first_level, P_number_levels, P_all_flag,
       82        P_long_flag, P_code);
       83 
       84   probe_info_ptr = P_probe_info_ptr;
       85   P_code = 0;
       86 
       87   call probe_trace_a_stack_ (probe_info_ptr,
       88        probe_info.current_stack_frame -> stack_frame.prev_sp,
       89        P_all_flag);			/* get something to work with */
       90 
       91   j = max (stack_info.max_level - P_first_level + 1, 1);
       92 				/* user sees numbers top down not bottom up */
       93 
       94   lfp = stack_info.level_chain;	/* start out with top frame */
       95   do while (level_frame.number ^= j);	/* search for starting level */
       96     lfp = level_frame.next;		/* consider the next frame */
       97   end;
       98 
       99   continue_tracing = "1"b;		/* curse pl1, which lacks do ... until */
      100   i = min (stack_info.max_level, j + P_number_levels - 1);
      101   do while (continue_tracing);
      102 
      103     /* if a condition exists, find out its name */
      104 
      105     if level_frame.condition_frame_ptr = null
      106       then
      107 	 cond_info.condition_name = "";
      108       else call find_condition_info_ ((level_frame.condition_frame_ptr),
      109 	      addr (cond_info), code);
      110 
      111     block_name =
      112          probe_block_name_ (probe_info_ptr, addr (level_frame.source_info),
      113          "0"b);
      114 
      115 
      116     call ioa_$ioa_switch (probe_info.output_switch,
      117          "^3d^[.^d^;^s^]^14t^a^a^[ (^a)^;^s^]^[^60t^]^a^[ (run unit wall)^]",
      118          level_frame.printed_number,
      119          level_frame.printed_decimal ^= 0,
      120          level_frame.printed_decimal,
      121          block_name,
      122          pretty_line (),
      123          (level_frame.source_info.seg_info_ptr -> seg_info.language_type
      124          ^= probe_info.language_type),
      125          palatable_language_names (level_frame.source_info.seg_info_ptr
      126          -> seg_info.language_type),
      127          cond_info.condition_name ^= "",
      128          cond_info.condition_name,
      129          level_frame.flags.run_unit_manager);
      130 
      131     if level_frame.number >= i
      132       then continue_tracing = "0"b;	/* stop as soon as the final interesting frame */
      133       else lfp = level_frame.next;	/* gets reached; otherwise go on to next frame */
      134   end;
      135   return;				/* end of code for $print_stack_history entry point */
      136 
      137   /*  */
      138 
      139 pretty_line:
      140   proc () returns (char (300));
      141 
      142   /* *	This procedure returns a pleasantly formatted string describing the
      143*   *	current frame. It is used by print_stack_history.
      144*   *	GLOBAL imports: level_frame */
      145 
      146   dcl map_index		fixed bin;
      147   dcl 1 map_array		(no_stmnts) based (map_ptr) like statement_map;
      148   dcl no_stmnts		fixed bin;
      149   dcl map_ptr		ptr;
      150   dcl file		fixed bin (8) unsigned;
      151   dcl line		fixed bin (14) unsigned;
      152   dcl stmt		fixed bin (5) unsigned;
      153   dcl dn			char (168);
      154   dcl en			char (32);
      155   dcl (retu, long_retu)	char (300);
      156 
      157   no_stmnts = level_frame.source_info.seg_info_ptr -> seg_info.map_size;
      158   map_ptr =
      159        level_frame.source_info.seg_info_ptr -> seg_info.statement_map_ptr;
      160   map_index = level_frame.source_info.stmnt_map_entry_index;
      161 
      162   if map_ptr ^= null () & map_index > 1 & map_index <= no_stmnts
      163     then do;
      164       file = fixed (map_array (map_index).file, 8);
      165       line = fixed (map_array (map_index).line, 14);
      166       stmt = fixed (map_array (map_index).statement, 5);
      167 
      168       call ioa_$rsnnl ("^x(line^x^[^d-^;^s^]^d^[,^d^;^s^])", retu, (0),
      169 	 (file > 0), file, line, (stmt > 1), stmt);
      170     end;
      171 
      172   else if ^P_long_flag
      173     then retu = "";
      174 
      175   else if level_frame.component_text_ptr = null
      176     then
      177          call ioa_$rsnnl ("|^o", retu, (0),
      178 	    bin (rel (level_frame.source_info.instruction_ptr), 18));
      179 
      180   else call ioa_$rsnnl ("|^o", retu, (0),
      181 	  bin (rel (level_frame.instruction_ptr), 18)
      182 	  - bin (rel (level_frame.component_text_ptr), 18));
      183 
      184   if P_long_flag then do;
      185       call hcs_$fs_get_path_name (level_frame.source_info.instruction_ptr, dn,
      186 	 (0), en, code);
      187       if code ^= 0
      188         then
      189 	   return (retu);		/* no pathname - might be special hardcore module */
      190 
      191       dn = get_shortest_path_ (dn);
      192 
      193       call ioa_$rsnnl ("^a^x(^a^[>^]^a|^o)", long_retu, (0),
      194 	 retu, dn, dn ^= ">", en,
      195 	 bin (rel (level_frame.source_info.instruction_ptr), 18));
      196       return (long_retu);
      197     end;
      198 
      199     else
      200          return (retu);
      201   end pretty_line;
      202 
      203   /*  */
      204 
      205   /* *	The rest of this program implements the various requests used to display the stack */
      206 
      207 probe_print_stack_$stack_request:
      208   entry (P_probe_info_ptr);
      209 
      210   /* *	This procedure implements the "stack" request in probe -- it process arguments
      211*   *	and calls probe_print_stack_$print_stack_history. It parses the following syntaxes:
      212*   *
      213*   *	   stack [N[,M] [all]
      214*   *
      215*   *	If both N and M are specified then N is number of first frame and M is number to print
      216*   *	else N is number to print and first frame printed is top one
      217*   *	else all frames are printed.
      218*   *
      219*   *	JRD 2 july 79 */
      220 
      221   probe_info_ptr = P_probe_info_ptr;
      222 
      223   begin;				/* avoid name conflicts */
      224 
      225     dcl start		  fixed bin;
      226 				/* first frame to trace */
      227     dcl num_frames;			/* number of frames to print */
      228     dcl (all, long)		  bit (1) aligned;
      229 				/* print system support too? */
      230     dcl N			  fixed bin;
      231     dcl M			  fixed bin;
      232     dcl 1 have,
      233         (
      234          2 N,
      235          2 M,
      236          2 all,
      237          2 long,
      238          2 fault
      239          )		  bit (1) aligned;
      240 
      241     all, long = "0"b;
      242     have = "0"b;
      243 
      244     do while (probe_info.ct -> token.type < probe_info.end_token);
      245 				/* look through token chain */
      246       if probe_info.ct -> token.type = CONSTANT_TYPE then do;
      247 	if have.N
      248 	  then goto SYNTAX_ERROR;
      249 	have.N = "1"b;
      250 	call probe_get_$integer (probe_info_ptr, N, code);
      251 
      252 	if code ^= 0
      253 	  then goto SOME_ERROR;
      254         end;			/* CONSTANT */
      255 
      256       else if probe_info.ct -> token.type = NAME_TYPE then do;
      257 	if current_identifier_name = "all" then do;
      258 	    if have.all
      259 	      then goto SYNTAX_ERROR;
      260 	      else do;
      261 	        have.all = "1"b;
      262 	        all = "1"b;
      263 	        call bump_ct ();
      264 	      end;
      265 	  end;			/* all spec */
      266 
      267 	else if current_identifier_name = "long"
      268 	     | current_identifier_name = "lg" then do;
      269 	    if have.long
      270 	      then go to SYNTAX_ERROR;
      271 	      else do;
      272 	        have.long = "1"b;
      273 	        long = "1"b;
      274 	        call bump_ct ();
      275 	      end;
      276 	  end;
      277 
      278 	else if current_identifier_name = "fault" then do;
      279 	    goto SYNTAX_ERROR;	/* not presently implemented */
      280 	  end;
      281 
      282 	else call probe_error_ (probe_info_ptr, 0,
      283 		"Unrecognized option ""^a"".", current_identifier_name);
      284         end;			/* of option processing */
      285 
      286       else if probe_info.ct -> token.type = COMMA then do;
      287 	if have.M
      288 	  then goto SYNTAX_ERROR;
      289 	  else do;
      290 	    have.M = "1"b;
      291 	    call bump_ct ();
      292 	    if probe_info.ct -> token.type ^= CONSTANT_TYPE
      293 	      then
      294 		 goto SYNTAX_ERROR;
      295 
      296 	    call probe_get_$integer (probe_info_ptr, M, code);
      297 	    if code ^= 0
      298 	      then goto SOME_ERROR;
      299 	  end;			/* getting M */
      300         end;
      301 
      302       else goto SYNTAX_ERROR;		/* other operator */
      303     end;				/* token loop */
      304 
      305     num_frames, start = 77313;	/* default, should be fewer frames then this */
      306 
      307     if have.M then do;
      308         start = N;
      309         num_frames = M;
      310       end;
      311 
      312     else if have.N
      313       then num_frames = N;
      314 
      315     if probe_info.execute
      316       then
      317 	 call probe_print_stack_$print_stack_history (probe_info_ptr, start,
      318 	      num_frames, all, long, (0));
      319 
      320   end;				/* begin block */
      321 
      322   return;				/* end of code for stack request */
      323 
      324 
      325 SYNTAX_ERROR:			/* general exit for request syntax error */
      326   code = probe_et_$syntax_error;
      327   goto SOME_ERROR;
      328 
      329 
      330 SOME_ERROR:
      331   call probe_error_ (probe_info_ptr, code);
      332 				/* never returns */
      333 
      334   /*  */
      335 
      336   /* *	Assorted request support routines, extracted from probe_requests_ */
      337 
      338 bump_ct:
      339   proc ();
      340 
      341   probe_info.ct = probe_info.ct -> token.next;
      342   if probe_info.ct = null ()
      343     then goto SYNTAX_ERROR;
      344 
      345   return;
      346   end;				/* internal procedure bump_ct */
      347 
      348   /*  */
      349 
      350   /*	INCLUDE FILES	*/
      351 
  1     1 /*	BEGIN INCLUDE FILE probe_info.incl.pl1		*/
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(88-10-24,WAAnderson), approve(88-10-24,MCR7952),
  1     7*     audit(88-10-24,RWaters), install(88-10-27,MR12.2-1194):
  1     8*     Added field 'retry_using_main' to add new C feature.
  1     9*                                                   END HISTORY COMMENTS */
  1    10 
  1    11 
  1    12 /* Created: 04/22/79 W. Olin Sibert, from subsystem_info	
  1    13*   Modified: 22 Sept 79 JRd to remove: 	default (ptr & (auto|based)) init (null ());
  1    14*   Added flags.setting_break 08/22/83 Steve Herbst
  1    15*   Added flags.executing_quit_request 01/15/85 Steve Herbst
  1    16**/
  1    17 
  1    18 dcl 1 probe_info aligned based (probe_info_ptr),		/* standard data for a probe invocation */
  1    19     2 probe_info_version fixed bin,			/* version of this structure */
  1    20 
  1    21     2 static_info_ptr pointer unaligned,		/* pointer to static information structure */
  1    22     2 modes_ptr pointer unaligned,			/* pointer to probe_modes structure */
  1    23 
  1    24     2 ptr_to_current_source ptr,			/* current_source is based on this */
  1    25     2 ptr_to_initial_source ptr,			/* initial_source is based on this */
  1    26     2 machine_cond_ptr pointer,			/* pointer to machine conditions, if we faulted to get here */
  1    27 
  1    28     2 token_info aligned,				/* information about token chain currently being processed */
  1    29       3 first_token pointer unaligned,			/* first token in chain */
  1    30       3 ct pointer unaligned, 			/* pointer to current token; updated in MANY places */
  1    31       3 end_token bit (18) aligned,			/* token type at which to stop scanning token chain */
  1    32       3 buffer_ptr pointer unaligned,			/* pointer to input buffer */
  1    33       3 buffer_lth fixed bin (21),			/* and length */
  1    34 
  1    35     2 random_info aligned,
  1    36       3 current_stack_frame pointer unaligned,		/* stack frame pointer for frame in which probe was invoked */
  1    37       3 input_type fixed bin, 			/* current input type */
  1    38       3 language_type fixed bin,			/* current language being processed */
  1    39       3 return_method fixed bin,			/* how we should return after exiting probe */
  1    40       3 entry_method fixed bin,			/* how we got here in the first place */
  1    41       3 pad1 (19) bit (36) aligned,
  1    42 
  1    43     2 break_info,					/* break info -- only interesting if we got here via a break */
  1    44       3 break_slot_ptr pointer,			/* pointer to break slot -- non-null IFF at a break */
  1    45       3 last_break_slot_ptr pointer unaligned,		/* pointer to previous break slot, not presently used */
  1    46       3 break_reset bit (1) aligned,			/* this break has been reset by somebody further on */
  1    47       3 real_break_return_loc pointer,			/* where to REALLY return to, modulo previous bit */
  1    48 
  1    49     2 probe_area_info,				/* information about various probe areas */
  1    50       3 break_segment_ptr pointer unaligned,		/* pointer to Personid.probe */
  1    51       3 break_area_ptr pointer unaligned,		/* pointer to area in break segment */
  1    52       3 scratch_area_ptr pointer unaligned,		/* pointer to probe scratch seg in process dir */
  1    53       3 probe_area_ptr pointer unaligned,		/* This area lasts as long as an invocation of probe. */
  1    54       3 work_area_ptr pointer unaligned,		/* This area lasts as long as the current request line */
  1    55       3 expression_area_ptr pointer unaligned,		/* This area lasts as long as the current command */
  1    56 
  1    57     2 flags aligned,				/* this, in particular, should be saved and restored correctly */
  1    58      (3 execute,					/* "1"b => execute requests, "0"b => just check syntax */
  1    59       3 in_listener,				/* ON => in probe listener loop */
  1    60       3 executing_request,				/* ON => executing a request */
  1    61       3 in_interpret_line,				/* executing in probe_listen_$interpret_line */
  1    62       3 setting_break,				/* executing "after" or "before": check syntax of "if" */
  1    63       3 executing_quit_request,			/* to prevent error looping during "quit" request */
  1    64       3 pad (30)) bit (1) unaligned,
  1    65 
  1    66     2 io_switches,					/* switches probe will do normal I/O on */
  1    67       3 input_switch pointer,
  1    68       3 output_switch pointer,
  1    69 
  1    70     2 error_info,					/* information about the last error saved for later printing */
  1    71       3 error_code fixed bin (35),
  1    72       3 error_message char (300) varying,
  1    73 
  1    74     2 listener_info,				/* internal use by probe listener */
  1    75       3 request_name character (32) varying,		/* primary name of the request being processed */
  1    76       3 abort_probe_label label variable,
  1    77       3 abort_line_label label variable,
  1    78       3 depth fixed binary,				/* count of active invocations of probe */
  1    79       3 previous pointer unaligned,			/* -> previous invocation's info */
  1    80       3 next pointer unaligned,
  1    81 
  1    82     2 end_of_probe_info pointer aligned,
  1    83     2 retry_using_main fixed bin aligned;
  1    84    
  1    85 
  1    86 dcl  probe_info_ptr pointer;
  1    87 
  1    88 dcl  probe_info_version fixed bin static options (constant) initial (1);
  1    89 
  1    90 dcl  probe_info_version_1 fixed bin static options (constant) initial (1);
  1    91 
  1    92 dcl  scratch_area area based (probe_info.scratch_area_ptr);
  1    93 dcl  probe_area area based (probe_info.probe_area_ptr);
  1    94 dcl  work_area area based (probe_info.work_area_ptr);
  1    95 dcl  expression_area area based (probe_info.expression_area_ptr);
  1    96 
  1    97 /*	END INCLUDE FILE probe_info.incl.pl1		*/
      352 
      353 
      354   /* ;;;;;;; */
      355 
  2     1 /*	BEGIN INCLUDE FILE probe_static_info.incl.pl1	*/
  2     2 
  2     3 /* *	This include file describes per-process information about probe, such
  2     4*   *	as various options available and the info directories and modes.
  2     5*   *
  2     6*   *	Created: 06/06/79 W. Olin Sibert */
  2     7 
  2     8 dcl 1 probe_static_info aligned based (probe_info.static_info_ptr), /* per-process data about probe */
  2     9     2 probe_info_version fixed bin,			/* same as probe_info.probe_info_version */
  2    10 
  2    11     2 version aligned,
  2    12       3 major_version fixed bin,
  2    13       3 minor_version fixed bin,
  2    14       3 version_string char (32) unaligned,		/* like "4.3f, patch 1" */
  2    15 
  2    16     2 name char (32) unaligned,			/* "probe" */
  2    17     2 prompt character (40) varying,			/* prompt for reading requests */
  2    18     2 switches,
  2    19       3 brief_sw bit (1) unaligned,			/* briefer break messages, no header (default OFF) */
  2    20       3 no_handle_faults_sw bit (1) unaligned,		/* don't handle bad ptr faults (default OFF) */
  2    21       3 recursive_breaks_sw bit (1) unaligned,		/* don't ignore recursive breaks in probe */
  2    22       3 prompt_on_sw bit (1) unaligned,			/* prompt for request lines */
  2    23       3 switch_pad bit (32) unaligned,
  2    24 
  2    25     2 scratch_segment_ptr pointer,			/* pointer to probe_scratch_ -- always valid */
  2    26     2 break_segment_ptr pointer,			/* pointer to Person.breaks -- valid only if needed */
  2    27 
  2    28     2 seg_info_offset_ptr pointer,			/* pointer to seg_info_offset array */
  2    29 
  2    30     2 probe_segno bit (18),				/* segment number of probe itself */
  2    31    2 last_break_segno bit (18),			/* segment number of last interrupted program */
  2    32 
  2    33     2 stack_info aligned,				/* information about the stack trace in probe_scratch_ */
  2    34       3 level_chain pointer unaligned,			/* first level frame entry pointer */
  2    35       3 max_level fixed bin,				/* number of stack levels */
  2    36       3 flags aligned,
  2    37        (4 good_stack,
  2    38         4 traced_with_all,				/* whether the stack trace includes support frames */
  2    39         4 pad1 (34)) bit (1) unaligned,
  2    40 
  2    41     2 modes_ptr pointer unaligned,			/* pointer to modes -- same as probe_info.modes_ptr */
  2    42 
  2    43     2 request_table_info aligned,			/* info for request definitions */
  2    44       3 array_ptr pointer,				/* pointer to array of request table pointers */
  2    45       3 array_size fixed bin, 			/* number of elements in use */
  2    46       3 array_max_size fixed bin,			/* max number of elements in array */
  2    47       3 using_internal_array bit (1) aligned,		/* whether or not we are using the array in probe_static_info */
  2    48 
  2    49     2 io_switches,					/* switches probe does its I/O on */
  2    50       3 input_switch pointer,
  2    51       3 output_switch pointer,
  2    52       3 (private_input_sw, private_output_sw) bit (1) aligned,
  2    53 						/* created by ids, ods and should be destroyed */
  2    54 
  2    55     2 info_directory_info aligned,			/* info about info directories */
  2    56       3 array_ptr pointer,
  2    57       3 array_size fixed bin,
  2    58       3 array_max_size fixed bin,
  2    59       3 using_internal_array bit (1) aligned,
  2    60 
  2    61     2 exclude_name_info aligned,			/* info for exclude array used in printing values */
  2    62       3 array_ptr pointer,
  2    63       3 array_size fixed bin,
  2    64       3 array_max_size fixed bin,
  2    65       3 using_internal_array bit (1) aligned,
  2    66 
  2    67     2 null_seg_info_ptr pointer unaligned,		/* pointer to the "null" seg_info block */
  2    68 
  2    69     2 initial_arrays,				/* initial versions of various arrays */
  2    70       3 request_table_ptr_array (10) pointer aligned,
  2    71       3 info_directory_name_array (3) char (168) unaligned,
  2    72       3 exclude_name_array (6) char (32) unaligned,
  2    73 
  2    74     2 metering_info,					/* last values for "mode meter" */
  2    75       3 last_clock fixed bin (71),
  2    76       3 last_vclock fixed bin (71),
  2    77       3 last_page_faults fixed bin,
  2    78 
  2    79     2 end_of_probe_static_info fixed bin;
  2    80 
  2    81 
  2    82 dcl 1 probe_seg_info_array aligned based (probe_static_info.seg_info_offset_ptr),
  2    83     2 count fixed bin,				/* number of entries in seg_info_offset array */
  2    84     2 seg_info_offset (0 : seg_info_offset_count refer (probe_seg_info_array.count)) bit (18) aligned;
  2    85 
  2    86 dcl  seg_info_offset_count fixed bin;			/* one less than the number of info_offsets */
  2    87 
  2    88 dcl  probe_request_tables (probe_static_info.request_table_info.array_max_size) /* array of request table pointers */
  2    89      pointer aligned based (probe_static_info.request_table_info.array_ptr);
  2    90 
  2    91 dcl  probe_info_directories (probe_static_info.info_directory_info.array_max_size) /* array of info directories */
  2    92      char (168) unaligned based (probe_static_info.info_directory_info.array_ptr);
  2    93 
  2    94 dcl  probe_exclude_names (probe_static_info.exclude_name_info.array_max_size) /* array of exclude names */
  2    95      char (168) unaligned based (probe_static_info.exclude_name_info.array_ptr);
  2    96 
  2    97 /*	END INCLUDE FILE probe_static_info.incl.pl1	*/
      356 
      357 
      358   /* ;;;;;;; */
      359 
  3     1 /* BEGIN INCLUDE FILE ... probe_source_info.incl.pl1
  3     2*
  3     3*  James R. Davis 2 July 79 */
  3     4 
  3     5 dcl 1 source_info based aligned,
  3     6       2 stmnt_map_entry_index fixed bin,		/* index in stmnt map for this stmnt */
  3     7       2 instruction_ptr ptr,				/* to last instruction executed  */
  3     8       2 block_ptr ptr,				/* to runtime_block node */
  3     9       2 stack_ptr ptr,				/* to a stack frame */
  3    10       2 entry_ptr ptr,				/* to entry seq. for this proc */
  3    11       2 seg_info_ptr ptr;				/* to seg_info */
  3    12 
  3    13 dcl 1 current_source aligned like source_info based (probe_info.ptr_to_current_source);
  3    14 dcl 1 initial_source aligned like source_info based (probe_info.ptr_to_initial_source);
  3    15 
  3    16 /* END INCLUDE FILE ... probe_source_info.incl.pl1 */
      360 
      361 
      362   /* ;;;;;;; */
      363 
  4     1 /* BEGIN INCLUDE FILE ... probe_seg_info.incl.pl1
  4     2*
  4     3*   25 June 79 JRDavis
  4     4*
  4     5*   Modified  7 April 1983, TO - Add fields for character offset/line
  4     6*	correction per file.
  4     7**/
  4     8 
  4     9 dcl 1 seg_info based aligned,				/* place to remember information about object seg */
  4    10     2 language_type fixed bin,			/* language of source program */
  4    11     2 bits aligned,
  4    12       3 ignore_case bit (1) unal,
  4    13       3 bound_segment bit (1) unaligned,
  4    14       3 component bit (1) unaligned,
  4    15       3 pad bit (33) unal,
  4    16     2 names,					/* where to find it */
  4    17       3 directory_name character (168) unal,		/* what directory */
  4    18       3 entry_name character (32) unal,			/* what segment */
  4    19       3 segname character (32) unal,			/* procedure segname definition */
  4    20     2 identifier fixed bin (71),			/* time of object creation */
  4    21     2 pointers,					/* location of various parts of segment */
  4    22       3 symbol_header_ptr ptr unal,			/* to symbol section */
  4    23       3 original_source_ptr ptr unal,			/* to segment source map */
  4    24       3 statement_map_ptr ptr unal,			/* to segment statement map */
  4    25       3 break_info ptr unal,				/* for unbound segments, and start of chain for
  4    26*						   bound ones, -> break_map !obsolete, I think! */
  4    27       3 chain ptr unal,				/* to entry for next component if bound */
  4    28       3 linkage_ptr ptr unal,				/* to linkage section */
  4    29     2 bounds aligned,				/* structure of bounds information */
  4    30       3 text_bounds,
  4    31         4 start fixed bin (35),
  4    32         4 end fixed bin (35),
  4    33       3 symbol_bounds,
  4    34         4 start fixed bin (35),
  4    35         4 end fixed bin (35),
  4    36     2 map_size fixed bin,				/* size of statement map */
  4    37     2 error_code fixed bin (35),			/* errors encoutered while getting info, are recorded here */
  4    38     2 bound_create_time fixed bin (71),			/* time seg containing was bound or compiled. */
  4    39     2 bound_sym_header ptr unal,			/* to sym. section header for bound seg */
  4    40     2 pad (1) fixed bin (35),
  4    41 
  4    42     2 nfiles fixed bin,
  4    43     2 per_file (seg_info_nfiles refer (seg_info.nfiles)),
  4    44       3 file_pointers ptr unal,
  4    45       3 break_line (0:3) fixed bin (18) unsigned unaligned;
  4    46 
  4    47 dcl  seg_info_nfiles fixed bin;			/* for allocation purposes */
  4    48 
  4    49 
  4    50 /* END INCLUDE FILE ... probe_seg_info.incl.pl1 */
      364 
      365 
      366   /* ;;;;;;; */
      367 
  5     1 /* BEGIN INCLUDE FILE ... probe_level_frame.incl.pl1  */
  5     2 
  5     3 /* Modified 25 Aug 79 JRDavis */
  5     4 /* Added printed_(number decimal) for numbering support frames 12/10/81 S. Herbst */
  5     5 
  5     6 dcl 1 level_frame based (lfp) aligned,
  5     7       2 next ptr unal,
  5     8       2 prev ptr unal,
  5     9       2 number fixed bin,
  5    10       2 printed_number fixed bin,
  5    11       2 printed_decimal fixed bin,
  5    12       2 condition_frame_ptr ptr,
  5    13       2 flags unal,
  5    14         3 quick bit (1) unal,
  5    15         3 error_signalled bit (1) unal,
  5    16         3 support bit (1) unal,
  5    17         3 run_unit_manager bit (1) unal,
  5    18         3 pad bit (32) unal,
  5    19       2 source_info aligned like source_info,
  5    20       2 component_info aligned,
  5    21        3 component_name char (32),
  5    22        3 component_text_ptr ptr;
  5    23 
  5    24 dcl lfp ptr;
  5    25 
  5    26 /* END INCLUDE FILE ... probe_level_frame.incl.pl1 */
      368 
      369 
      370   /* ;;;;;;; */
      371 
  6     1 /*	BEGIN INCLUDE FILE probe_tokens.incl.pl1	*/
  6     2 /*	Split up into probe_tokens and probe_references, 04/22/79 WOS */
  6     3 
  6     4 dcl 1 token_header aligned based,			/* header information common to all tokens */
  6     5     2 next pointer unaligned,				/* pointer to next token in chain */
  6     6     2 prev pointer unaligned,				/* same for previous token */
  6     7     2 type bit (18) aligned,
  6     8     2 buffer_ptr pointer unaligned,			/* pointer to beginning of input buffer */
  6     9     2 location fixed bin (17) unal,			/* offset in input buffer */
  6    10     2 length fixed bin (17) unal,
  6    11     2 flags aligned,
  6    12      (3 leading_whitespace,				/* there is whitespace before thios token */
  6    13       3 trailing_whitespace) bit (1) unaligned,		/* and same for after */
  6    14       3 pad1 bit (34) unaligned;
  6    15 
  6    16 dcl 1 token aligned based,				/* produced by scan_probe_input_ */
  6    17     2 header aligned like token_header;			/* that's all there is */
  6    18 
  6    19 dcl 1 identifier aligned based,			/* keyword or identifier token */
  6    20     2 header aligned like token_header,
  6    21     2 length fixed bin,				/* length of name */
  6    22     2 name pointer unaligned;				/* to string in buffer containing name */
  6    23 
  6    24 dcl 1 operator aligned based,				/* for punctuation */
  6    25     2 header aligned like token_header;			/* nothing but a header here */
  6    26 
  6    27 dcl 1 constant aligned based,				/* for strings pointers numbers etc */
  6    28     2 header aligned like token_header,
  6    29     2 encoded_precision aligned,			/* encoded precision kludge for assign_ */
  6    30       3 scale fixed bin (17) unaligned,			/* arithmetic scale */
  6    31       3 precision fixed bin (17) unaligned,		/* arithmetic precision or other size */
  6    32     2 scale_and_precision fixed bin (35),		/* An identical copy of the two values above */
  6    33     2 data_type fixed bin,				/* standard data type code + packed bit */
  6    34     2 data_ptr pointer unaligned;
  6    35 
  6    36 
  6    37 dcl (OPERATOR_TYPE init ("100"b),			/* types for above */
  6    38      NAME_TYPE init ("010"b),
  6    39      CONSTANT_TYPE init ("001"b)) bit (18) internal static options (constant);
  6    40 
  6    41 
  6    42 dcl  current_identifier_name				/* Overlays for looking at the current tokens */
  6    43      char (probe_info.ct -> identifier.length) based (probe_info.ct -> identifier.name);
  6    44 dcl 1 current_constant aligned like constant based (probe_info.ct);
  6    45 dcl 1 current_token aligned like token based (probe_info.ct);
  6    46 
  6    47 /*	END INCLUDE FILE probe_tokens.incl.pl1		*/
      372 
      373 
      374   /* ;;;;;;; */
      375 
  7     1 /* BEGIN INCLUDE FILE ... probe_operators.incl.pl1 */
  7     2 
  7     3 
  7     4 
  7     5 /****^  HISTORY COMMENTS:
  7     6*  1) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  7     7*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  7     8*     Added new C operators.
  7     9*                                                   END HISTORY COMMENTS */
  7    10 
  7    11 
  7    12 /* These are the operator.types for each defined operator */
  7    13 /* Modified June 83 JMAthane for PASCAL_ARROW new operator */
  7    14 /* Added PASCAL_RANGE and PASCAL_ASSIGN 07/26/83 S. Herbst */
  7    15 /* Modified April 88 Hinatsu Addition of C types */
  7    16 
  7    17      dcl	   (PLUS		      init ("400001"b3), MINUS init ("400002"b3),
  7    18 	   TIMES		      init ("400003"b3), SLASH init ("400004"b3),
  7    19 	   OR_BAR		      init ("400005"b3), NOT_SIGN init ("400006"b3),
  7    20 	   LESS_THAN	      init ("400007"b3), GREATER_THAN init ("400010"b3),
  7    21 	   EQUALS		      init ("400011"b3), NOT_EQUALS init ("400012"b3),
  7    22 	   NOT_GREATER_THAN	      init ("400013"b3), NOT_LESS_THAN init ("400014"b3),
  7    23 	   PERIOD		      init ("400015"b3), COLON init ("400016"b3),
  7    24 	   AMPERSAND	      init ("400017"b3), PERCENT init ("400020"b3),
  7    25 	   DOLLAR_SIGN	      init ("400021"b3), LEFT_BRACKET init ("400022"b3),
  7    26 	   RIGHT_BRACKET	      init ("400023"b3), ARROW init ("400024"b3),
  7    27 	   COMMA		      init ("400025"b3), QUESTION_MARK init ("400026"b3),
  7    28 	   PASCAL_ARROW	      init ("400027"b3), PASCAL_RANGE init ("400030"b3),
  7    29 	   PASCAL_ASSIGN	      init ("400031"b3),
  7    30 
  7    31 /* Additons to support C types */
  7    32 	   C_LEFT_SHIFT           init ("400032"b3), C_RIGHT_SHIFT init ("400033"b3),
  7    33 
  7    34 /* operator 28 are left for future expansion */
  7    35 
  7    36 	   LEFT_PAREN	      init ("400035"b3), RIGHT_PAREN init ("400036"b3),
  7    37              C_EQUAL                init ("400037"b3), C_NOT_EQUAL init ("400040"b3),
  7    38 	   SEMI_COLON	      init ("400041"b3), NEW_LINE init ("400042"b3),
  7    39 	   C_INDIRECTION          init ("400034"b3)
  7    40 
  7    41 	   )		      bit (18) aligned internal static options (constant);
  7    42 
  7    43      dcl	   OPERATOR_VALUES	      (0:34) char (4) varying internal static options (constant) init
  7    44 			      ("????", "+", "-", "*", "/", "|", "^", "<",
  7    45 			      ">", "=", "^=", "<=", ">=", ".", ":", "&",
  7    46 			      "%", "$", "[", "]", "->", ",", "?", "^",
  7    47 			      "..", ":=", "<<", ">>", "*", "(", ")",
  7    48 			      "==", "!=", ";","
  7    49 ");
  7    50 
  7    51 /* END INCLUDE FILE ... probe_operators.incl.pl1 */
      376 
      377 
      378   /* ;;;;;;; */
      379 
  8     1 /* 	BEGIN INCLUDE FILE ... stack_frame.incl.pl1 ... */
  8     2 
  8     3 /* format: off */
  8     4 
  8     5 /* Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr and pl1_ps_ptr */
  8     6 /* Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager bit & main_proc bit */
  8     7 /* Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr */
  8     8 /* Modified: 03/01/84, S. Herbst - Added RETURN_PTR_MASK */
  8     9 
  8    10 
  8    11 /****^  HISTORY COMMENTS:
  8    12*  1) change(86-09-15,Kissel), approve(86-09-15,MCR7473),
  8    13*     audit(86-10-01,Fawcett), install(86-11-03,MR12.0-1206):
  8    14*     Modified to add constants for the translator_id field in the stack_frame
  8    15*     structure.
  8    16*                                                   END HISTORY COMMENTS */
  8    17 
  8    18 
  8    19 dcl RETURN_PTR_MASK bit (72) int static options (constant)  /* mask to be AND'd with stack_frame.return_ptr */
  8    20 	init ("777777777777777777000000"b3);		/* when copying, to ignore bits that a call fills */
  8    21 						/* with indicators (nonzero for Fortran hexfp caller) */
  8    22 			/* say: unspec(ptr) = unspec(stack_frame.return_ptr) & RETURN_PTR_MASK; */
  8    23 
  8    24 dcl TRANSLATOR_ID_PL1V2 bit (18) internal static options (constant) init ("000000"b3);
  8    25 dcl TRANSLATOR_ID_ALM bit (18) internal static options (constant) init ("000001"b3);
  8    26 dcl TRANSLATOR_ID_PL1V1 bit (18) internal static options (constant) init ("000002"b3);
  8    27 dcl TRANSLATOR_ID_SIGNAL_CALLER bit (18) internal static options (constant) init ("000003"b3);
  8    28 dcl TRANSLATOR_ID_SIGNALLER bit (18) internal static options (constant) init ("000004"b3);
  8    29 
  8    30 
  8    31 dcl  sp pointer;					/* pointer to beginning of stack frame */
  8    32 
  8    33 dcl  stack_frame_min_length fixed bin static init(48);
  8    34 
  8    35 
  8    36 dcl 1 stack_frame based(sp) aligned,
  8    37     2 pointer_registers(0 : 7) ptr,
  8    38     2 prev_sp pointer,
  8    39     2 next_sp pointer,
  8    40     2 return_ptr pointer,
  8    41     2 entry_ptr pointer,
  8    42     2 operator_and_lp_ptr ptr,			/* serves as both */
  8    43     2 arg_ptr pointer,
  8    44     2 static_ptr ptr unaligned,
  8    45     2 support_ptr ptr unal, /* only used by fortran I/O */
  8    46     2 on_unit_relp1 bit(18) unaligned,
  8    47     2 on_unit_relp2 bit(18) unaligned,
  8    48     2 translator_id bit(18) unaligned,			/* Translator ID (see constants above)
  8    49*						   0 => PL/I version II
  8    50*						   1 => ALM
  8    51*						   2 => PL/I version I   
  8    52*						   3 => signal caller frame
  8    53*						   4 => signaller frame */
  8    54     2 operator_return_offset bit(18) unaligned,
  8    55     2 x(0: 7) bit(18) unaligned,			/* index registers */
  8    56     2 a bit(36),					/* accumulator */
  8    57     2 q bit(36),					/* q-register */
  8    58     2 e bit(36),					/* exponent */
  8    59     2 timer bit(27) unaligned,				/* timer */
  8    60     2 pad bit(6) unaligned,
  8    61     2 ring_alarm_reg bit(3) unaligned;
  8    62 
  8    63 
  8    64 dcl 1 stack_frame_flags based(sp) aligned,
  8    65     2 pad(0 : 7) bit(72),				/* skip over prs */
  8    66     2 xx0 bit(22) unal,
  8    67     2 main_proc bit(1) unal,				/* on if frame belongs to a main procedure */
  8    68     2 run_unit_manager bit(1) unal,			/* on if frame belongs to run unit manager */
  8    69     2 signal bit(1) unal,				/* on if frame belongs to logical signal_ */
  8    70     2 crawl_out bit(1) unal,				/* on if this is a signal caller frame */
  8    71     2 signaller bit(1) unal,				/* on if next frame is signaller's */
  8    72     2 link_trap bit(1) unal,				/* on if this frame was made by the linker */
  8    73     2 support bit(1) unal,				/* on if frame belongs to a support proc */
  8    74     2 condition bit(1) unal,				/* on if condition established in this frame */
  8    75     2 xx0a bit(6) unal,
  8    76     2 xx1 fixed bin,
  8    77     2 xx2 fixed bin,
  8    78     2 xx3 bit(25) unal,
  8    79     2 old_crawl_out bit (1) unal,			/* on if this is a signal caller frame */
  8    80     2 old_signaller bit(1) unal,			/* on if next frame is signaller's */
  8    81     2 xx3a bit(9) unaligned,
  8    82     2 xx4(9) bit(72) aligned,
  8    83     2 v2_pl1_op_ret_base ptr,				/* When a V2 PL/I program calls an operator the
  8    84*						*  operator puts a pointer to the base of
  8    85*						*  the calling procedure here. (text base ptr)  */
  8    86     2 xx5 bit(72) aligned,
  8    87     2 pl1_ps_ptr ptr;				/* ptr to ps for this frame; also used by fio. */
  8    88 
  8    89 /* format: on */
  8    90 
  8    91 /* 	END INCLUDE FILE ... stack_frame.incl.pl1 */
      380 
      381 
      382   /*  */
      383 
  9     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  9     2 
  9     3 /* Structure for find_condition_info_.
  9     4*
  9     5*   Written 1-Mar-79 by M. N. Davidoff.
  9     6**/
  9     7 
  9     8 /* automatic */
  9     9 
  9    10      declare condition_info_ptr     pointer;
  9    11 
  9    12 /* based */
  9    13 
  9    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  9    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  9    16 	     2 version	      fixed binary,		/* Must be 1 */
  9    17 	     2 condition_name     char (32) varying,	/* name of condition */
  9    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  9    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  9    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  9    21 	     2 flags	      unaligned,
  9    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  9    23 	       3 pad1	      bit (35),
  9    24 	     2 pad2	      bit (36),
  9    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  9    26 	     2 pad3	      (4) bit (36);
  9    27 
  9    28 /* internal static */
  9    29 
  9    30      declare condition_info_version_1
  9    31 			      fixed binary internal static options (constant) initial (1);
  9    32 
  9    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
      384 
      385 
      386   /* ;;;;;;; */
      387 
 10     1 /* BEGIN INCLUDE FILE  ... probe_lang_types.incl.pl1
 10     2*
 10     3*   JRD 26 June 79
 10     4*   MBW 31 July 1981 to add algol68 */
 10     5 
 10     6 
 10     7 /****^  HISTORY COMMENTS:
 10     8*  1) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
 10     9*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
 10    10*     Added C Language type.
 10    11*                                                   END HISTORY COMMENTS */
 10    12 
 10    13 
 10    14 /*   Modified June 83 JMAthane to add PASCAL language type */
 10    15 /*   Modified April 88 Hinatsu to add C language type */
 10    16 
 10    17      dcl	   (UNKNOWN_lang_type     init (1),
 10    18 	   OTHER_lang_type	      init (2),
 10    19 	   PL1_lang_type	      init (3),
 10    20 	   FORTRAN_lang_type      init (4),
 10    21 	   COBOL_lang_type	      init (5),
 10    22 	   ALM_lang_type	      init (6),
 10    23 	   ALGOL68_lang_type      init (7),
 10    24 	   PASCAL_lang_type	      init (8),
 10    25 	   C_lang_type	      init (9)) fixed bin internal static options (constant);
 10    26 
 10    27      dcl	   official_language_names (9) char (32) internal static options (constant) init
 10    28 			      ("Unknown", "other", "PL/I", "FORTRAN", "COBOL", "ALM", "Algol 68", "Pascal", "C");
 10    29 
 10    30      dcl	   palatable_language_names (9) char (32) internal static options (constant) init
 10    31 			      ("Unknown", "Other", "pl1", "fortran", "cobol", "alm", "algol68", "pascal", "c");
 10    32 
 10    33 /* END INCLUDE FILE ... probe_lang_types.incl.pl1 */
      388 
      389 
      390   /* ;;;;;;; */
      391 
 11     1 dcl	1 statement_map	aligned based,
 11     2 	2 location	bit(18) unaligned,
 11     3 	2 source_id	unaligned,
 11     4 	  3 file		bit(8),
 11     5 	  3 line		bit(14),
 11     6 	  3 statement	bit(5),
 11     7 	2 source_info	unaligned,
 11     8 	  3 start		bit(18),
 11     9 	  3 length	bit(9);
      392 
      393 
      394   end;				/* probe_stack_trace_ external procedure */
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/27/88  1224.6  probe_print_stack_.pl1            >spec>install>MR12.2-1194>probe_print_stack_.pl1
352          1    10/27/88  1223.7  probe_info.incl.pl1               >spec>install>MR12.2-1194>probe_info.incl.pl1
356          2    11/12/82  1624.3  probe_static_info.incl.pl1        >ldd>include>probe_static_info.incl.pl1
360          3    11/26/79  1320.6  probe_source_info.incl.pl1        >ldd>include>probe_source_info.incl.pl1
364          4    11/02/83  1845.0  probe_seg_info.incl.pl1           >ldd>include>probe_seg_info.incl.pl1
368          5    05/17/82  1411.1  probe_level_frame.incl.pl1        >ldd>include>probe_level_frame.incl.pl1
372          6    11/26/79  1320.6  probe_tokens.incl.pl1             >ldd>include>probe_tokens.incl.pl1
376          7    10/26/88  1255.5  probe_operators.incl.pl1          >ldd>include>probe_operators.incl.pl1
380          8    11/07/86  1550.3  stack_frame.incl.pl1              >ldd>include>stack_frame.incl.pl1
384          9    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
388         10    10/26/88  1255.5  probe_lang_types.incl.pl1         >ldd>include>probe_lang_types.incl.pl1
392         11    05/06/74  1751.6  statement_map.incl.pl1            >ldd>include>statement_map.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
COMMA                                  constant        bit(18)                  initial dcl 7-17 ref 286
CONSTANT_TYPE                          constant        bit(18)                  initial packed unaligned dcl 6-37 ref 246 292
M                         1     000577 automatic       bit(1)                   level 2 in structure "have" dcl 232
                                                                                  in begin block on line 223 set ref 287 290* 307
M                               000576 automatic       fixed bin(17,0)          dcl 231 in begin block on line 223 set ref 296* 309
N                               000575 automatic       fixed bin(17,0)          dcl 230 in begin block on line 223 set ref 250* 308
                                                                                  312
N                               000577 automatic       bit(1)                   level 2 in structure "have" dcl 232
                                                                                  in begin block on line 223 set ref 247 249* 312
NAME_TYPE                              constant        bit(18)                  initial packed unaligned dcl 6-37 ref 256
P_all_flag                             parameter       bit(1)                   dcl 40 set ref 80 87*
P_code                                 parameter       fixed bin(35,0)          dcl 40 set ref 80 85*
P_first_level                          parameter       fixed bin(17,0)          dcl 40 ref 80 91
P_long_flag                            parameter       bit(1)                   dcl 40 ref 80 172 184
P_number_levels                        parameter       fixed bin(17,0)          dcl 40 ref 80 100
P_probe_info_ptr                       parameter       pointer                  dcl 40 ref 80 84 207 221
addr                                                   builtin function         dcl 76 ref 108 108 111 111
all                       2     000577 automatic       bit(1)                   level 2 in structure "have" dcl 232
                                                                                  in begin block on line 223 set ref 258 261*
all                             000573 automatic       bit(1)                   dcl 228 in begin block on line 223 set ref 241* 262*
                                                                                  315*
bin                                                    builtin function         dcl 76 ref 175 175 180 180 193 193
block_name                      000102 automatic       varying char(256)        dcl 53 set ref 111* 116*
code                            000204 automatic       fixed bin(35,0)          dcl 55 set ref 108* 185* 187 250* 252 296* 297 325*
                                                                                  330*
component_info           26            based           structure                level 2 dcl 5-6
component_text_ptr       36            based           pointer                  level 3 dcl 5-6 ref 175 180
cond_info                       000206 automatic       structure                level 1 dcl 57 set ref 108 108
condition_frame_ptr       6            based           pointer                  level 2 dcl 5-6 ref 105 108
condition_info                         based           structure                level 1 dcl 9-14
condition_name            3     000206 automatic       varying char(32)         level 2 dcl 57 set ref 105* 116 116*
constant                               based           structure                level 1 dcl 6-27
continue_tracing                000203 automatic       bit(1)                   dcl 54 set ref 99* 101 131*
ct                       13            based           pointer                  level 3 packed packed unaligned dcl 1-18 set ref 244
                                                                                  246 256 257 257 267 267 267 267 278 278 282 282
                                                                                  282 286 292 341* 341 342
current_identifier_name                based           char                     packed unaligned dcl 6-42 set ref 257 267 267 278
                                                                                  282*
current_stack_frame      17            based           pointer                  level 3 packed packed unaligned dcl 1-18 ref 87
dn                              000261 automatic       char(168)                packed unaligned dcl 153 set ref 185* 191* 191* 193*
                                                                                  193
en                              000333 automatic       char(32)                 packed unaligned dcl 154 set ref 185* 193*
end_token                14            based           bit(18)                  level 3 dcl 1-18 ref 244
execute                  64            based           bit(1)                   level 3 packed packed unaligned dcl 1-18 ref 315
file                            000256 automatic       fixed bin(8,0)           unsigned dcl 150 in procedure "pretty_line" set ref
                                                                                  164* 168 168*
file                      0(18)        based           bit(8)                   array level 3 in structure "map_array" packed packed
                                                                                  unaligned dcl 147 in procedure "pretty_line" ref
                                                                                  164
find_condition_info_            000012 constant        entry                    external dcl 61 ref 108
fixed                                                  builtin function         dcl 76 ref 164 165 166
flags                    10            based           structure                level 2 in structure "level_frame" packed packed
                                                                                  unaligned dcl 5-6 in procedure
                                                                                  "probe_print_stack_"
flags                    64            based           structure                level 2 in structure "probe_info" dcl 1-18
                                                                                  in procedure "probe_print_stack_"
get_shortest_path_              000014 constant        entry                    external dcl 62 ref 191
have                            000577 automatic       structure                level 1 unaligned dcl 232 set ref 242*
hcs_$fs_get_path_name           000016 constant        entry                    external dcl 63 ref 185
header                                 based           structure                level 2 dcl 6-16
i                               000100 automatic       fixed bin(17,0)          dcl 52 set ref 100* 131
identifier                             based           structure                level 1 dcl 6-19
instruction_ptr          14            based           pointer                  level 3 dcl 5-6 set ref 175 175 180 185* 193 193
io_switches              66            based           structure                level 2 dcl 1-18
ioa_$ioa_switch                 000020 constant        entry                    external dcl 65 ref 116
ioa_$rsnnl                      000022 constant        entry                    external dcl 66 ref 168 175 180 193
j                               000101 automatic       fixed bin(17,0)          dcl 52 set ref 91* 95 100
language_type                          based           fixed bin(17,0)          level 2 in structure "seg_info" dcl 4-9 in procedure
                                                                                  "probe_print_stack_" ref 116 116
language_type            21            based           fixed bin(17,0)          level 3 in structure "probe_info" dcl 1-18
                                                                                  in procedure "probe_print_stack_" ref 116
length                    6            based           fixed bin(17,0)          level 2 dcl 6-19 ref 257 267 267 278 282 282
level_chain              50            based           pointer                  level 3 packed packed unaligned dcl 2-8 ref 94
level_frame                            based           structure                level 1 dcl 5-6
lfp                             000242 automatic       pointer                  dcl 5-24 set ref 94* 95 96* 96 105 108 111 111 116
                                                                                  116 116 116 116 116 131 133* 133 157 158 160 175
                                                                                  175 175 180 180 185 193 193
line                            000257 automatic       fixed bin(14,0)          unsigned dcl 151 in procedure "pretty_line" set ref
                                                                                  165* 168*
line                      0(26)        based           bit(14)                  array level 3 in structure "map_array" packed packed
                                                                                  unaligned dcl 147 in procedure "pretty_line" ref
                                                                                  165
long                            000574 automatic       bit(1)                   dcl 228 in begin block on line 223 set ref 241* 273*
                                                                                  315*
long                      3     000577 automatic       bit(1)                   level 2 in structure "have" dcl 232
                                                                                  in begin block on line 223 set ref 269 272*
long_retu                       000456 automatic       char(300)                packed unaligned dcl 155 set ref 193* 196
map_array                              based           structure                array level 1 packed packed unaligned dcl 147
map_index                       000252 automatic       fixed bin(17,0)          dcl 146 set ref 160* 162 162 164 165 166
map_ptr                         000254 automatic       pointer                  dcl 149 set ref 158* 162 164 165 166
map_size                110            based           fixed bin(17,0)          level 2 dcl 4-9 ref 157
max                                                    builtin function         dcl 76 ref 91
max_level                51            based           fixed bin(17,0)          level 3 dcl 2-8 ref 91 100
min                                                    builtin function         dcl 76 ref 100
name                      7            based           pointer                  level 2 packed packed unaligned dcl 6-19 ref 257 267
                                                                                  267 278 282
next                                   based           pointer                  level 3 in structure "token" packed packed unaligned
                                                                                  dcl 6-16 in procedure "probe_print_stack_" ref 341
next                                   based           pointer                  level 2 in structure "level_frame" packed packed
                                                                                  unaligned dcl 5-6 in procedure
                                                                                  "probe_print_stack_" ref 96 133
no_stmnts                       000253 automatic       fixed bin(17,0)          dcl 148 set ref 157* 162
null                                                   builtin function         dcl 76 ref 105 162 175 342
num_frames                      000572 automatic       fixed bin(17,0)          dcl 227 set ref 305* 309* 312* 315*
number                    2            based           fixed bin(17,0)          level 2 dcl 5-6 ref 95 131
output_switch            70            based           pointer                  level 3 dcl 1-18 set ref 116*
palatable_language_names        000000 constant        char(32)                 initial array packed unaligned dcl 10-30 set ref
                                                                                  116*
pointers                 76            based           structure                level 2 dcl 4-9
prev_sp                  20            based           pointer                  level 2 dcl 8-36 set ref 87*
printed_decimal           4            based           fixed bin(17,0)          level 2 dcl 5-6 set ref 116 116*
printed_number            3            based           fixed bin(17,0)          level 2 dcl 5-6 set ref 116*
probe_block_name_               000030 constant        entry                    external dcl 71 ref 111
probe_error_                    000026 constant        entry                    external dcl 70 ref 282 330
probe_error_$malfunction        000024 constant        entry                    external dcl 68 ref 28
probe_et_$syntax_error          000010 external static fixed bin(35,0)          dcl 59 ref 325
probe_get_$integer              000032 constant        entry                    external dcl 73 ref 250 296
probe_info                             based           structure                level 1 dcl 1-18
probe_info_ptr                  000240 automatic       pointer                  dcl 1-86 set ref 84* 87* 87 91 94 100 111* 116 116
                                                                                  221* 244 244 246 250* 256 257 257 267 267 267 267
                                                                                  278 278 282* 282 282 282 286 292 296* 315 315*
                                                                                  330* 341 341 342
probe_static_info                      based           structure                level 1 dcl 2-8
probe_trace_a_stack_            000034 constant        entry                    external dcl 74 ref 87
random_info              17            based           structure                level 2 dcl 1-18
rel                                                    builtin function         dcl 76 ref 175 175 180 180 193 193
retu                            000343 automatic       char(300)                packed unaligned dcl 155 set ref 168* 172* 175* 180*
                                                                                  187 193* 199
run_unit_manager         10(03)        based           bit(1)                   level 3 packed packed unaligned dcl 5-6 set ref 116*
seg_info                               based           structure                level 1 dcl 4-9
seg_info_ptr             24            based           pointer                  level 3 dcl 5-6 set ref 116 116 157 158
source_id                 0(18)        based           structure                array level 2 packed packed unaligned dcl 147
source_info              12            based           structure                level 2 in structure "level_frame" dcl 5-6
                                                                                  in procedure "probe_print_stack_" set ref 111 111
source_info                            based           structure                level 1 dcl 3-5 in procedure "probe_print_stack_"
stack_frame                            based           structure                level 1 dcl 8-36
stack_info               50            based           structure                level 2 dcl 2-8
start                           000571 automatic       fixed bin(17,0)          dcl 225 set ref 305* 308* 315*
statement                 1(04)        based           bit(5)                   array level 3 packed packed unaligned dcl 147 ref
                                                                                  166
statement_map                          based           structure                level 1 dcl 11-1
statement_map_ptr       100            based           pointer                  level 3 packed packed unaligned dcl 4-9 ref 158
static_info_ptr           1            based           pointer                  level 2 packed packed unaligned dcl 1-18 ref 91 94
                                                                                  100
stmnt_map_entry_index
                         12            based           fixed bin(17,0)          level 3 dcl 5-6 set ref 160
stmt                            000260 automatic       fixed bin(5,0)           unsigned dcl 152 set ref 166* 168 168*
token                                  based           structure                level 1 dcl 6-16
token_header                           based           structure                level 1 dcl 6-4
token_info               12            based           structure                level 2 dcl 1-18
type                      2            based           bit(18)                  level 3 dcl 6-16 ref 244 246 256 286 292

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALGOL68_lang_type                      internal static fixed bin(17,0)          initial dcl 10-17
ALM_lang_type                          internal static fixed bin(17,0)          initial dcl 10-17
AMPERSAND                              internal static bit(18)                  initial dcl 7-17
ARROW                                  internal static bit(18)                  initial dcl 7-17
COBOL_lang_type                        internal static fixed bin(17,0)          initial dcl 10-17
COLON                                  internal static bit(18)                  initial dcl 7-17
C_EQUAL                                internal static bit(18)                  initial dcl 7-17
C_INDIRECTION                          internal static bit(18)                  initial dcl 7-17
C_LEFT_SHIFT                           internal static bit(18)                  initial dcl 7-17
C_NOT_EQUAL                            internal static bit(18)                  initial dcl 7-17
C_RIGHT_SHIFT                          internal static bit(18)                  initial dcl 7-17
C_lang_type                            internal static fixed bin(17,0)          initial dcl 10-17
DOLLAR_SIGN                            internal static bit(18)                  initial dcl 7-17
EQUALS                                 internal static bit(18)                  initial dcl 7-17
FORTRAN_lang_type                      internal static fixed bin(17,0)          initial dcl 10-17
GREATER_THAN                           internal static bit(18)                  initial dcl 7-17
LEFT_BRACKET                           internal static bit(18)                  initial dcl 7-17
LEFT_PAREN                             internal static bit(18)                  initial dcl 7-17
LESS_THAN                              internal static bit(18)                  initial dcl 7-17
MINUS                                  internal static bit(18)                  initial dcl 7-17
NEW_LINE                               internal static bit(18)                  initial dcl 7-17
NOT_EQUALS                             internal static bit(18)                  initial dcl 7-17
NOT_GREATER_THAN                       internal static bit(18)                  initial dcl 7-17
NOT_LESS_THAN                          internal static bit(18)                  initial dcl 7-17
NOT_SIGN                               internal static bit(18)                  initial dcl 7-17
OPERATOR_TYPE                          internal static bit(18)                  initial packed unaligned dcl 6-37
OPERATOR_VALUES                        internal static varying char(4)          initial array dcl 7-43
OR_BAR                                 internal static bit(18)                  initial dcl 7-17
OTHER_lang_type                        internal static fixed bin(17,0)          initial dcl 10-17
PASCAL_ARROW                           internal static bit(18)                  initial dcl 7-17
PASCAL_ASSIGN                          internal static bit(18)                  initial dcl 7-17
PASCAL_RANGE                           internal static bit(18)                  initial dcl 7-17
PASCAL_lang_type                       internal static fixed bin(17,0)          initial dcl 10-17
PERCENT                                internal static bit(18)                  initial dcl 7-17
PERIOD                                 internal static bit(18)                  initial dcl 7-17
PL1_lang_type                          internal static fixed bin(17,0)          initial dcl 10-17
PLUS                                   internal static bit(18)                  initial dcl 7-17
QUESTION_MARK                          internal static bit(18)                  initial dcl 7-17
RETURN_PTR_MASK                        internal static bit(72)                  initial packed unaligned dcl 8-19
RIGHT_BRACKET                          internal static bit(18)                  initial dcl 7-17
RIGHT_PAREN                            internal static bit(18)                  initial dcl 7-17
SEMI_COLON                             internal static bit(18)                  initial dcl 7-17
SLASH                                  internal static bit(18)                  initial dcl 7-17
TIMES                                  internal static bit(18)                  initial dcl 7-17
TRANSLATOR_ID_ALM                      internal static bit(18)                  initial packed unaligned dcl 8-25
TRANSLATOR_ID_PL1V1                    internal static bit(18)                  initial packed unaligned dcl 8-26
TRANSLATOR_ID_PL1V2                    internal static bit(18)                  initial packed unaligned dcl 8-24
TRANSLATOR_ID_SIGNALLER                internal static bit(18)                  initial packed unaligned dcl 8-28
TRANSLATOR_ID_SIGNAL_CALLER            internal static bit(18)                  initial packed unaligned dcl 8-27
UNKNOWN_lang_type                      internal static fixed bin(17,0)          initial dcl 10-17
condition_info_ptr                     automatic       pointer                  dcl 9-10
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 9-30
current_constant                       based           structure                level 1 dcl 6-44
current_source                         based           structure                level 1 dcl 3-13
current_token                          based           structure                level 1 dcl 6-45
expression_area                        based           area(1024)               dcl 1-95
frame_reached                          automatic       bit(1)                   packed unaligned dcl 51
initial_source                         based           structure                level 1 dcl 3-14
official_language_names                internal static char(32)                 initial array packed unaligned dcl 10-27
operator                               based           structure                level 1 dcl 6-24
probe_area                             based           area(1024)               dcl 1-93
probe_exclude_names                    based           char(168)                array packed unaligned dcl 2-94
probe_info_directories                 based           char(168)                array packed unaligned dcl 2-91
probe_info_version                     internal static fixed bin(17,0)          initial dcl 1-88
probe_info_version_1                   internal static fixed bin(17,0)          initial dcl 1-90
probe_request_tables                   based           pointer                  array dcl 2-88
probe_seg_info_array                   based           structure                level 1 dcl 2-82
scratch_area                           based           area(1024)               dcl 1-92
seg_info_nfiles                        automatic       fixed bin(17,0)          dcl 4-47
seg_info_offset_count                  automatic       fixed bin(17,0)          dcl 2-86
sp                                     automatic       pointer                  dcl 8-31
stack_frame_flags                      based           structure                level 1 dcl 8-64
stack_frame_min_length                 internal static fixed bin(17,0)          initial dcl 8-33
work_area                              based           area(1024)               dcl 1-94

NAMES DECLARED BY EXPLICIT CONTEXT.
SOME_ERROR                      001003 constant        label                    dcl 330 ref 252 297 327
SYNTAX_ERROR                    000777 constant        label                    dcl 325 ref 247 258 269 279 286 287 292 342
bump_ct                         001444 constant        entry                    internal dcl 338 ref 263 274 291
pretty_line                     001021 constant        entry                    internal dcl 139 ref 116 116
probe_print_stack_              000215 constant        entry                    external dcl 25
probe_print_stack_$print_stack_history
                                000235 constant        entry                    external dcl 80 ref 315
probe_print_stack_$stack_request
                                000525 constant        entry                    external dcl 207

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1712        1750    1464        1722
Length      2400    1464        36         413     226           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
probe_print_stack_                  640 external procedure  is an external procedure.  
pretty_line                             internal procedure  shares stack frame of external procedure probe_print_stack_.  
begin block on line 223                 begin block         shares stack frame of external procedure probe_print_stack_.  
bump_ct                                 internal procedure  shares stack frame of external procedure probe_print_stack_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
probe_print_stack_       000100 i                           probe_print_stack_
                         000101 j                           probe_print_stack_
                         000102 block_name                  probe_print_stack_
                         000203 continue_tracing            probe_print_stack_
                         000204 code                        probe_print_stack_
                         000206 cond_info                   probe_print_stack_
                         000240 probe_info_ptr              probe_print_stack_
                         000242 lfp                         probe_print_stack_
                         000252 map_index                   pretty_line
                         000253 no_stmnts                   pretty_line
                         000254 map_ptr                     pretty_line
                         000256 file                        pretty_line
                         000257 line                        pretty_line
                         000260 stmt                        pretty_line
                         000261 dn                          pretty_line
                         000333 en                          pretty_line
                         000343 retu                        pretty_line
                         000456 long_retu                   pretty_line
                         000571 start                       begin block on line 223
                         000572 num_frames                  begin block on line 223
                         000573 all                         begin block on line 223
                         000574 long                        begin block on line 223
                         000575 N                           begin block on line 223
                         000576 M                           begin block on line 223
                         000577 have                        begin block on line 223

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_ne_as             call_ext_in         call_ext_out_desc   call_ext_out        return_mac
ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
find_condition_info_          get_shortest_path_            hcs_$fs_get_path_name         ioa_$ioa_switch
ioa_$rsnnl                    probe_block_name_             probe_error_                  probe_error_$malfunction
probe_get_$integer            probe_trace_a_stack_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
probe_et_$syntax_error




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     25 000214        28 000222        80 000226        84 000242        85 000246        87 000247        91 000263
     94 000275        95 000277        96 000304        97 000306        99 000307       100 000311       101 000323
    105 000326       108 000335       111 000354       116 000376       131 000510       133 000516       134 000520
    135 000521       207 000522       221 000532       241 000536       242 000540       244 000545       246 000555
    247 000557       249 000561       250 000563       252 000576       254 000600       256 000601       257 000603
    258 000612       261 000614       262 000616       263 000617       265 000620       267 000621       269 000631
    272 000633       273 000635       274 000636       276 000637       278 000640       279 000644       282 000645
    284 000701       286 000702       287 000704       290 000706       291 000710       292 000711       296 000716
    297 000731       303 000733       305 000734       307 000737       308 000741       309 000743       310 000745
    312 000746       315 000752       322 000776       325 000777       327 001002       330 001003       394 001020
    139 001021       157 001023       158 001027       160 001031       162 001033       164 001044       165 001055
    166 001064       168 001073       170 001152       172 001153       175 001163       180 001223       184 001262
    185 001266       187 001321       191 001331       193 001344       196 001430       199 001436       338 001444
    341 001445       342 001452       345 001454


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
