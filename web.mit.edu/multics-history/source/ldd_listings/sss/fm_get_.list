	COMPILATION LISTING OF SEGMENT fm_get_
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-17_1934.06_Mon_mdt
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* DESCRIPTION
        8*
        9*   This routine implements the file manager's read primitives.
       10**/
       11 
       12 /* HISTORY:
       13*
       14*Written by Bensoussan-Ives, 06/22/82.
       15*   01/28/82 Andre Bensoussan, Specification and design.
       16*   06/22/82 Jeffrey D. Ives, Design and coding.
       17*Modified:
       18*01/31/84 by Matthew Pierret:  Added the get_ci_ptr and terminate_ci_ptr
       19*            entries.  The latter is currently a no-op.  get_ci_ptr returns
       20*            a pointer to the addressable portion of a control interval, 
       21*            allowing for faster retrievals overall many common retrieval
       22*            patterns.  Also changed the format comment to simply style2.
       23*03/16/84 by Matthew Pierret:  Changed $get_ci_ptr to return
       24*            dm_error_$ci_not_allocated if the control interval has not been
       25*            allocated instead of returning a pointer to a page of zeroes.
       26*            If the control interval is part of a non-existent segment, there
       27*            is no page to which to point.
       28*05/21/84 by R. Michael Tague:  Created $simple_get, which is an entry for
       29*	  getting from just one control interval without having to set
       30*	  up a ci_parts structure.
       31*06/07/84 by Lee Baldwin:  Renamed a bunch of dm_error_ codes.
       32*07/27/84 by Matthew Pierret:  Changed to check read ring bracket.  Also added
       33*            RETURN and ERROR_RETURN procedures, replacing the statements
       34*            "go to GOOD_RETURN", "go to BAD_RETURN" and "go to <error>".
       35*            Changed to use my_file_access_info instead of proc_ad.
       36*11/12/84 by Matthew Pierret:  Made the proc statement be fm_get_$get so
       37*            there are no useless entrypoints. Added get_ci_ptr_exclusive.
       38*            Made several changes to the dm_ci* include files.
       39*12/17/84 by Matthew Pierret:  Changed to use the new state variables in
       40*            my_file_access_info, and to return dm_error_$bad_file_oid if
       41*            entry_state is not IN_USE and dm_error_$file_doesnt_exist if
       42*            file_state is not FIEL_EXISTS. Also, changed LOCK_WAIT_TIME to
       43*            1e9 from 1e8. Changed to use dm_error_$no_current_transaction
       44*            instead of dm_error_$fm_no_current_txn.
       45*04/22/85 by R. Michael Tague:  Added $internal_get_ci_ptr that will return a
       46*	  pointer even if the file is not open.
       47**/
       48 
       49 /* format: style2 */
       50 
       51 fm_get_$get:
       52      procedure (p_file_oid, p_ci_num, p_ci_parts_ptr, p_code);
       53 
       54 /* START OF DECLARATIONS */
       55 
       56 /* Parameters */
       57 
       58 	dcl     p_ci_num		 fixed bin (27) parm;
       59 	dcl     p_ci_parts_ptr	 ptr parm;
       60 	dcl     p_ci_ptr		 ptr parameter;
       61 	dcl     p_single_part_length	 fixed bin (17) parm;
       62 	dcl     p_single_part_offset	 fixed bin (17) parm;
       63 	dcl     p_single_part_ptr	 ptr parm;
       64 	dcl     p_code		 fixed bin (35) parm;
       65 	dcl     p_file_oid		 bit (36) aligned parm;
       66 
       67 	dcl     1 p_ci_header	 aligned parm,
       68 		2 stamp		 bit (72),
       69 		2 id		 bit (72);
       70 
       71 
       72 /* Automatic */
       73 
       74 	dcl     caller_validation_level
       75 				 fixed bin init (0);/* for cleanup */
       76 	dcl     ci_num		 fixed bin (27);
       77 	dcl     code		 fixed bin (35) init (0);
       78 	dcl     component_num	 fixed bin;
       79 	dcl     just_get_ci_ptr	 bit (1) aligned;
       80 	dcl     just_get_header	 bit aligned;
       81 	dcl     lock_mode		 fixed bin;
       82 	dcl     min_opens		 fixed bin;
       83 	dcl     number_of_addressable_bytes
       84 				 fixed bin;
       85 	dcl     page_num		 fixed bin;
       86 	dcl     part_idx		 fixed bin;
       87 	dcl     part_length		 fixed bin;
       88 	dcl     part_offset		 fixed bin;
       89 
       90 	dcl     part_ptr		 ptr init (null ());
       91 	dcl     my_ci_id		 fixed bin (71);
       92 	dcl     my_ci_stamp		 fixed bin (71);
       93 	dcl     1 my_file_oid	 aligned like file_oid;
       94 
       95 	dcl     1 single_ci_part	 aligned,
       96 		2 number_of_parts	 fixed bin (17) init (1),
       97 		2 part		 (1) like ci_parts.part;
       98 
       99 	dcl     1 effective_integrity_switches
      100 				 aligned like file_access_info.integrity_switches;
      101 	dcl     1 my_file_access_info	 aligned like file_access_info;
      102 
      103 /* Constant */
      104 
      105 	dcl     LOCK_WAIT_TIME	 init (1000000000) fixed bin (71) internal static options (constant);
      106 	dcl     NULL_INTEGRITY_SWITCHES
      107 				 init ((5)"0"b) bit (5) aligned static options (constant);
      108 	dcl     GET_INTEGRITY_SWITCHES init ((5)"1"b) bit (5) aligned static options (constant);
      109 
      110 
      111 /* Conditions */
      112 
      113 	dcl     cleanup		 condition;
      114 
      115 /* Based */
      116 
      117 	dcl     part_buffer		 char (part_length) based (part_ptr);
      118 
      119 	dcl     1 seg		 aligned based,
      120 		2 pages		 (0:254),
      121 		  3 double_words	 (512) fixed bin (71);
      122 
      123 /* Builtin */
      124 
      125 	dcl     (addr, baseno, baseptr, bin, divide, hbound, lbound, multiply, null, string, substr, unspec)
      126 				 builtin;
      127 
      128 /* External Variables */
      129 
      130 	dcl     dm_data_$current_txn_id
      131 				 bit (36) aligned ext;
      132 	dcl     dm_error_$bad_file_oid fixed bin (35) ext;
      133 	dcl     dm_error_$ci_bad_hdr_arg_ver
      134 				 fixed bin (35) ext;
      135 	dcl     dm_error_$ci_bad_hdr_id_num
      136 				 fixed bin (35) ext;
      137 	dcl     dm_error_$ci_bad_hdr_size_code
      138 				 fixed bin (35) ext;
      139 	dcl     dm_error_$ci_bad_hdr_uid
      140 				 fixed bin (35) ext;
      141 	dcl     dm_error_$ci_bad_stamp_ver
      142 				 fixed bin (35) ext;
      143 	dcl     dm_error_$ci_not_allocated
      144 				 fixed bin (35) ext;
      145 	dcl     dm_error_$ci_num_oob	 fixed bin (35) ext;
      146 	dcl     dm_error_$ci_num_parts_neg
      147 				 fixed bin (35) ext;
      148 	dcl     dm_error_$ci_parts_oob fixed bin (35) ext;
      149 	dcl     dm_error_$file_doesnt_exist
      150 				 fixed bin (35) ext;
      151 	dcl     dm_error_$no_current_transaction
      152 				 fixed bin (35) ext;
      153 	dcl     error_table_$noentry	 fixed bin (35) ext;
      154 	dcl     error_table_$no_r_permission
      155 				 fixed bin (35) ext;
      156 
      157 
      158 /* External Entries */
      159 
      160 	dcl     cu_$level_get	 entry (fixed bin);
      161 	dcl     cu_$level_set	 entry (fixed bin);
      162 	dcl     get_ring_		 entry () returns (fixed bin (3));
      163 	dcl     lock_manager_$lock	 entry (bit (36) aligned, fixed bin (27), fixed bin, fixed bin (71), fixed bin,
      164 				 fixed bin (35));
      165 	dcl     msf_manager_$msf_get_ptr
      166 				 entry (ptr, fixed bin, bit (1), ptr, fixed bin (24), fixed bin (35));
      167 
      168 /* END OF DECLARATIONS */
      169 
      170 /* This entry is actually the main procedure statement and is repeated
      171*   here for the reader's convenience
      172*
      173*get: entry  (p_file_oid, p_ci_num, p_ci_parts_ptr, p_code); */
      174 
      175 	call INIT;
      176 
      177 	just_get_header, just_get_ci_ptr = "0"b;
      178 	min_opens = 1;
      179 	string (effective_integrity_switches) = GET_INTEGRITY_SWITCHES;
      180 	lock_mode = LOCK_MODE_S;
      181 
      182 	ci_parts_ptr = p_ci_parts_ptr;
      183 	ci_num = p_ci_num;
      184 
      185 	if ci_num = 0
      186 	then number_of_addressable_bytes = CI_0_ADDRESSABLE_LENGTH;
      187 	else number_of_addressable_bytes = CI_ADDRESSABLE_LENGTH;
      188 
      189 	go to JOIN;
      190 
      191 
      192 get_ci_header:
      193      entry (p_file_oid, p_ci_num, p_ci_header, p_code);
      194 
      195 	call INIT;
      196 
      197 	just_get_header = "1"b;
      198 	just_get_ci_ptr = "0"b;
      199 	min_opens = 1;
      200 	string (effective_integrity_switches) = GET_INTEGRITY_SWITCHES;
      201 	lock_mode = LOCK_MODE_S;
      202 
      203 	ci_num = p_ci_num;
      204 
      205 	if addr (p_ci_header) -> ci_stamp.version ^= CI_STAMP_VERSION_1
      206 	then call ERROR_RETURN (dm_error_$ci_bad_hdr_arg_ver);
      207 
      208 	go to JOIN;
      209 
      210 internal_get:
      211      entry (p_file_oid, p_ci_num, p_ci_parts_ptr, p_code);
      212 
      213 	call INIT;
      214 
      215 	just_get_header, just_get_ci_ptr = "0"b;
      216 	min_opens = 0;
      217 	string (effective_integrity_switches) = GET_INTEGRITY_SWITCHES;
      218 	lock_mode = LOCK_MODE_S;
      219 
      220 	ci_parts_ptr = p_ci_parts_ptr;
      221 	ci_num = p_ci_num;
      222 
      223 	number_of_addressable_bytes = CI_ADDRESSABLE_LENGTH;
      224 
      225 	go to JOIN;
      226 
      227 
      228 
      229 
      230 get_exclusive:
      231      entry (p_file_oid, p_ci_num, p_ci_parts_ptr, p_code);
      232 
      233 	call INIT;
      234 
      235 	just_get_header, just_get_ci_ptr = "0"b;
      236 	min_opens = 1;
      237 	string (effective_integrity_switches) = GET_INTEGRITY_SWITCHES;
      238 	lock_mode = LOCK_MODE_X;
      239 
      240 	ci_parts_ptr = p_ci_parts_ptr;
      241 	ci_num = p_ci_num;
      242 
      243 	if ci_num = 0
      244 	then number_of_addressable_bytes = CI_0_ADDRESSABLE_LENGTH;
      245 	else number_of_addressable_bytes = CI_ADDRESSABLE_LENGTH;
      246 
      247 	go to JOIN;
      248 
      249 raw_get:
      250      entry (p_file_oid, p_ci_num, p_ci_parts_ptr, p_code);
      251 
      252 	call INIT;
      253 
      254 	just_get_header, just_get_ci_ptr = "0"b;
      255 	min_opens = 1;
      256 	string (effective_integrity_switches) = NULL_INTEGRITY_SWITCHES;
      257 	lock_mode = LOCK_MODE_S;
      258 
      259 	ci_parts_ptr = p_ci_parts_ptr;
      260 	ci_num = p_ci_num;
      261 
      262 	if ci_num = 0
      263 	then number_of_addressable_bytes = CI_0_ADDRESSABLE_LENGTH;
      264 	else number_of_addressable_bytes = CI_ADDRESSABLE_LENGTH;
      265 
      266 	go to JOIN;
      267 
      268 
      269 simple_get:
      270      entry (p_file_oid, p_ci_num, p_single_part_offset, p_single_part_ptr, p_single_part_length, p_code);
      271 
      272 	call INIT;
      273 
      274 	just_get_header = "0"b;
      275 	just_get_ci_ptr = "0"b;
      276 	min_opens = 1;
      277 	string (effective_integrity_switches) = GET_INTEGRITY_SWITCHES;
      278 	lock_mode = LOCK_MODE_S;
      279 	ci_parts_ptr = addr (single_ci_part);
      280 	ci_parts.part (1).offset_in_bytes = p_single_part_offset;
      281 	ci_parts.part (1).length_in_bytes = p_single_part_length;
      282 	ci_parts.part (1).local_ptr = p_single_part_ptr;
      283 	ci_num = p_ci_num;
      284 	if ci_num = 0
      285 	then number_of_addressable_bytes = CI_0_ADDRESSABLE_LENGTH;
      286 	else number_of_addressable_bytes = CI_ADDRESSABLE_LENGTH;
      287 	go to JOIN;
      288 
      289 get_ci_ptr:
      290      entry (p_file_oid, p_ci_num, p_ci_ptr, p_code);
      291 
      292 /* This entry gets a pointer to the addressable portion of a ci.  The pointer
      293*   is directly into the file ci, not a copy, so this pointer must not be 
      294*   used to update the ci. */
      295 
      296 	call INIT;
      297 	p_ci_ptr = null;
      298 	just_get_header = "0"b;
      299 	just_get_ci_ptr = "1"b;
      300 	min_opens = 1;
      301 	string (effective_integrity_switches) = GET_INTEGRITY_SWITCHES;
      302 	lock_mode = LOCK_MODE_S;
      303 	ci_num = p_ci_num;
      304 
      305 	go to JOIN;
      306 
      307 
      308 internal_get_ci_ptr:
      309      entry (p_file_oid, p_ci_num, p_ci_ptr, p_code);
      310 
      311 /* This entry gets a pointer to the addressable portion of a ci.  The pointer
      312*   is directly into the file ci, not a copy, so this pointer must not be 
      313*   used to update the ci.  This entry differs from get_ci_ptr in that the file
      314*   need not be open.
      315* */
      316 
      317 	call INIT;
      318 	p_ci_ptr = null;
      319 	just_get_header = "0"b;
      320 	just_get_ci_ptr = "1"b;
      321 	min_opens = 0;
      322 	string (effective_integrity_switches) = GET_INTEGRITY_SWITCHES;
      323 	lock_mode = LOCK_MODE_S;
      324 	ci_num = p_ci_num;
      325 
      326 	go to JOIN;
      327 
      328 get_ci_ptr_exclusive:
      329      entry (p_file_oid, p_ci_num, p_ci_ptr, p_code);
      330 
      331 /* This entry is the same as get_ci_ptr except that it acquires an
      332*   exclusive lock on the control interval. */
      333 
      334 	call INIT;
      335 	p_ci_ptr = null;
      336 	just_get_header = "0"b;
      337 	just_get_ci_ptr = "1"b;
      338 	min_opens = 1;
      339 	string (effective_integrity_switches) = GET_INTEGRITY_SWITCHES;
      340 	lock_mode = LOCK_MODE_X;
      341 	ci_num = p_ci_num;
      342 	go to JOIN;
      343 
      344 
      345 terminate_ci_ptr:
      346      entry (p_file_oid, p_ci_num, p_ci_ptr, p_code);
      347 
      348 /* This entry is currently not supported.  $get_ci_ptr should be changed
      349*in the future to remember the ci pointers gotten, holding them until
      350*terminate_ci_ptr releases the ci_ptr. */
      351 
      352 	call RETURN ();
      353 
      354 JOIN:
      355 	if ci_num < 0 | ci_num > MAX_CI_NUM
      356 	then call ERROR_RETURN (dm_error_$ci_num_oob);
      357 
      358 	unspec (my_file_oid) = p_file_oid;
      359 
      360 	if my_file_oid.file_access_table_idx < lbound (file_access_table.e, 1)
      361 	     | my_file_oid.file_access_table_idx > file_access_table.h.last_entry
      362 	then call ERROR_RETURN (dm_error_$bad_file_oid);
      363 
      364 	my_file_access_info = file_access_table.e (my_file_oid.file_access_table_idx);
      365 
      366 	if my_file_access_info.state.entry_state = FILE_ACCESS_INFO_NOT_IN_USE
      367 	then call ERROR_RETURN (dm_error_$bad_file_oid);
      368 
      369 	if my_file_access_info.state.file_state ^= FILE_EXISTS
      370 	then call ERROR_RETURN (dm_error_$file_doesnt_exist);
      371 
      372 	if my_file_access_info.opens < min_opens
      373 	then call ERROR_RETURN (dm_error_$bad_file_oid);
      374 
      375 	if my_file_oid.uid_tail ^= substr (my_file_access_info.uid, 19, 18)
      376 	then call ERROR_RETURN (dm_error_$bad_file_oid);
      377 
      378 	if my_file_access_info.seg_0_num = ""b
      379 	then call ERROR_RETURN (dm_error_$file_doesnt_exist);
      380 
      381 	call cu_$level_get (caller_validation_level);
      382 	if caller_validation_level > my_file_access_info.ring_brackets.read
      383 	then call ERROR_RETURN (error_table_$no_r_permission);
      384 
      385 	effective_integrity_switches = effective_integrity_switches & my_file_access_info.integrity_switches;
      386 
      387 	if effective_integrity_switches.transaction
      388 	then do;
      389 		if dm_data_$current_txn_id = ""b
      390 		then call ERROR_RETURN (dm_error_$no_current_transaction);
      391 	     end;
      392 
      393 	if effective_integrity_switches.lock
      394 	then do;
      395 		if my_file_access_info.lock_advice = 0
      396 		then do;
      397 			call lock_manager_$lock (my_file_access_info.uid, ci_num, lock_mode, LOCK_WAIT_TIME, (0),
      398 			     code);
      399 			if code ^= 0
      400 			then call ERROR_RETURN (code);
      401 		     end;
      402 		else do;
      403 			if my_file_access_info.last_transaction_id ^= dm_data_$current_txn_id
      404 			then do;
      405 				my_file_access_info.last_transaction_id = dm_data_$current_txn_id;
      406 				file_access_table.e (my_file_oid.file_access_table_idx) = my_file_access_info;
      407 
      408 				call lock_manager_$lock (my_file_access_info.uid, LOCK_ENTIRE_FILE,
      409 				     (my_file_access_info.lock_advice), LOCK_WAIT_TIME, (0), code);
      410 				if code ^= 0
      411 				then call ERROR_RETURN (code);
      412 			     end;
      413 
      414 			if my_file_access_info.lock_advice = LOCK_MODE_X
      415 			then ;
      416 			else if lock_mode = LOCK_MODE_S
      417 			     & (my_file_access_info.lock_advice = LOCK_MODE_S
      418 			     | my_file_access_info.lock_advice = LOCK_MODE_SIX)
      419 			then ;
      420 			else do;
      421 				call lock_manager_$lock (my_file_access_info.uid, ci_num, lock_mode,
      422 				     LOCK_WAIT_TIME, (0), code);
      423 				if code ^= 0
      424 				then call ERROR_RETURN (code);
      425 			     end;
      426 		     end;
      427 	     end;
      428 
      429 	component_num = divide (ci_num, my_file_access_info.blocking_factor, 27);
      430 
      431 	if component_num = 0
      432 	then do;
      433 		ci_ptr = baseptr (my_file_access_info.seg_0_num);
      434 		go to REAL_GET;
      435 	     end;
      436 	else if component_num <= hbound (my_file_access_info.seg_nums, 1)
      437 	then do;
      438 		if my_file_access_info.seg_nums (component_num) ^= 0
      439 		then do;
      440 			ci_ptr = baseptr (my_file_access_info.seg_nums (component_num));
      441 			go to REAL_GET;
      442 		     end;
      443 	     end;
      444 
      445 	on cleanup call cu_$level_set (caller_validation_level);
      446 	call cu_$level_set (get_ring_ ());
      447 
      448 	call msf_manager_$msf_get_ptr ((my_file_access_info.msf_ptr), component_num, "0"b, ci_ptr, (0), code);
      449 
      450 	call cu_$level_set (caller_validation_level);
      451 
      452 	if ci_ptr = null ()
      453 	then do;
      454 		if code = error_table_$noentry
      455 		then go to FAKE_GET;
      456 
      457 		call ERROR_RETURN (code);
      458 	     end;
      459 
      460 	if component_num <= hbound (my_file_access_info.seg_nums, 1)
      461 	then do;
      462 		my_file_access_info.seg_nums (component_num) = bin (baseno (ci_ptr), 18);
      463 		file_access_table.e (my_file_oid.file_access_table_idx) = my_file_access_info;
      464 	     end;
      465 
      466 
      467 REAL_GET:
      468 	page_num = ci_num - multiply (component_num, my_file_access_info.blocking_factor, 27);
      469 	ci_ptr = addr (ci_ptr -> seg.pages (page_num));
      470 
      471 	my_ci_stamp = ci.trailer.stamp;
      472 	my_ci_id = ci.header.id;
      473 
      474 	if my_ci_stamp = 0
      475 	then go to FAKE_GET;
      476 
      477 	if addr (my_ci_stamp) -> ci_stamp.version ^= CI_STAMP_VERSION_1
      478 	then call ERROR_RETURN (dm_error_$ci_bad_stamp_ver);
      479 
      480 	if addr (my_ci_id) -> ci_id.size_code ^= SIZE_CODE_1024_WORDS
      481 	then call ERROR_RETURN (dm_error_$ci_bad_hdr_size_code);
      482 
      483 	if addr (my_ci_id) -> ci_id.uid ^= my_file_access_info.uid
      484 	then call ERROR_RETURN (dm_error_$ci_bad_hdr_uid);
      485 
      486 	if addr (my_ci_id) -> ci_id.num ^= ci_num
      487 	then call ERROR_RETURN (dm_error_$ci_bad_hdr_id_num);
      488 
      489 	if just_get_ci_ptr
      490 	then go to GET_CI_PTR;
      491 
      492 	if just_get_header
      493 	then go to REAL_GET_HEADER;
      494 
      495 	cip_number_of_parts = ci_parts.number_of_parts;
      496 	if cip_number_of_parts < 0
      497 	then call ERROR_RETURN (dm_error_$ci_num_parts_neg);
      498 
      499 	do part_idx = lbound (ci_parts.part, 1) to cip_number_of_parts;
      500 	     part_length = ci_parts.part (part_idx).length_in_bytes;
      501 
      502 	     if part_length ^= 0
      503 	     then do;
      504 		     part_offset = ci_parts.part (part_idx).offset_in_bytes;
      505 		     part_ptr = ci_parts.part (part_idx).local_ptr;
      506 
      507 		     if part_offset < 0 | part_length < 0 | part_offset + part_length > number_of_addressable_bytes
      508 		     then call ERROR_RETURN (dm_error_$ci_parts_oob);
      509 
      510 		     part_buffer = substr (ci.addressable_bytes, part_offset + 1, part_length);
      511 		end;
      512 	end;
      513 
      514 	p_code = 0;
      515 MAIN_RETURN:
      516 	return;
      517 
      518 RETURN:
      519      proc ();
      520 	p_code = 0;
      521 	go to MAIN_RETURN;
      522      end RETURN;
      523 	;
      524 
      525 
      526 ERROR_RETURN:
      527      proc (er_p_code);
      528 
      529 	dcl     er_p_code		 fixed bin (35);
      530 
      531 	p_code = er_p_code;
      532 	go to MAIN_RETURN;
      533 
      534      end ERROR_RETURN;
      535 
      536 FAKE_GET:
      537 	if just_get_ci_ptr
      538 	then call ERROR_RETURN (dm_error_$ci_not_allocated);
      539 
      540 	if just_get_header
      541 	then go to FAKE_GET_HEADER;
      542 
      543 	cip_number_of_parts = ci_parts.number_of_parts;
      544 	if cip_number_of_parts < 0
      545 	then call ERROR_RETURN (dm_error_$ci_num_parts_neg);
      546 
      547 	do part_idx = lbound (ci_parts.part, 1) to cip_number_of_parts;
      548 	     part_length = ci_parts.part (part_idx).length_in_bytes;
      549 
      550 	     if part_length ^= 0
      551 	     then do;
      552 		     part_offset = ci_parts.part (part_idx).offset_in_bytes;
      553 		     part_ptr = ci_parts.part (part_idx).local_ptr;
      554 
      555 		     if part_offset < 0 | part_length < 0 | part_offset + part_length > number_of_addressable_bytes
      556 		     then call ERROR_RETURN (dm_error_$ci_parts_oob);
      557 
      558 		     unspec (part_buffer) = ""b;
      559 		end;
      560 	end;
      561 
      562 	call RETURN ();
      563 
      564 
      565 
      566 
      567 
      568 FAKE_GET_HEADER:
      569 	my_ci_stamp = TEMPLATE_CI_STAMP_1;
      570 	addr (my_ci_id) -> ci_id.uid = my_file_access_info.uid;
      571 	addr (my_ci_id) -> ci_id.size_code = SIZE_CODE_1024_WORDS;
      572 	addr (my_ci_id) -> ci_id.num = ci_num;
      573 
      574 REAL_GET_HEADER:
      575 	unspec (p_ci_header.stamp) = unspec (my_ci_stamp);
      576 	unspec (p_ci_header.id) = unspec (my_ci_id);
      577 
      578 	call RETURN ();
      579 
      580 
      581 GET_CI_PTR:
      582 	p_ci_ptr = addr (ci.addressable_bytes);
      583 	call RETURN ();
      584 
      585 
      586 /* THIS IS THE END OF THE MAIN LINE CODE */
      587 
      588 INIT:
      589      proc;
      590 
      591 /* THE LOGIC DOES NOT DEPEND ON THE INITIALIZATIONS BELOW */
      592 
      593 	ci_ptr = null ();
      594 	ci_parts_ptr = null ();
      595 	part_ptr = null ();
      596 
      597 	cip_number_of_parts = -1;
      598 	code = -1;
      599 	component_num = -1;
      600 	lock_mode = -1;
      601 	my_ci_id = -1;
      602 	my_ci_stamp = -1;
      603 	number_of_addressable_bytes = -1;
      604 	page_num = -1;
      605 	part_idx = -1;
      606 	part_length = -1;
      607 	part_offset = -1;
      608 
      609 	unspec (my_file_oid) = ""b;
      610 
      611 /* THE LOGIC DOES NOT DEPEND ON THE INITIALIZATIONS ABOVE */
      612 
      613      end INIT;
      614 
      615 /* START OF INCLUDE FILES */
      616 
  1     1 /*  BEGIN INCLUDE FILE:  dm_ci.incl.pl1  */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*
  1     5*        This include file contains the structure which defines the 
  1     6*   format of a control interval.  
  1     7*   
  1     8*   ****  NOTE:  This include file depends on the dm_ci_header.incl.pl1 ****
  1     9*   ****  Any program which includes dm_ci.incl.pl1 must also include   ****
  1    10*   ****  dm_ci_header.incl.pl1.                                        ****
  1    11**/
  1    12 
  1    13 /* HISTORY:
  1    14*Written by Jeffrey D. Ives, 09/07/82.
  1    15*     (design by Andre Bensoussan and Jeffrey Ives.)
  1    16*Modified:
  1    17*11/07/84 by Matthew Pierret:  To remove declarations which are also in
  1    18*            dm_ci_header.incl.pl1.
  1    19**/
  1    20 
  1    21 /* format: style2,ind3 */
  1    22 
  1    23      dcl	   ci_ptr		      ptr;
  1    24      dcl	   1 ci		      aligned based (ci_ptr),
  1    25 	     2 header	      like ci_header_chunks,
  1    26 	     2 addressable_bytes  char (4072),
  1    27 	     2 trailer	      like ci_trailer_chunk;
  1    28 
  1    29 
  1    30 /*  END INCLUDE FILE:  dm_ci.incl.pl1  */
      617 
      618 
  2     1 /* BEGIN INCLUDE FILE:  dm_ci_header.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*        This include file contains various structures which make up the
  2     6*   header and trailer of a control interval.
  2     7*   
  2     8*   ****  NOTE:  The include file dm_ci.incl.pl1 is heavily dependent ****
  2     9*   ****  on this include file.  When changing this include file,     ****
  2    10*   ****  check dm_ci.incl.pl1 to see if it is affected.              ****
  2    11**/
  2    12 
  2    13 /* HISTORY:
  2    14*Written by Jeffrey D. Ives, 03/02/82.
  2    15*  (Design by Andre Bensoussan and Jeffrey D. Ives)
  2    16*Modified:
  2    17*11/02/84 by Matthew Pierret:  Re-organized so that dm_ci.incl.pl1 and
  2    18*            dm_ci_header.incl.pl1 do not duplicate structures or constants.
  2    19**/
  2    20 
  2    21 /* format: style2,ind3 */
  2    22 
  2    23 /* ci_header is the first four words of a control interval. Its contents
  2    24*   are used to verify that a control interval is in an expected format,
  2    25*   to identify the control interval and the file to which the control
  2    26*   interval belongs, and to maintain information for the synchronization
  2    27*   of disk I/O between DM file control intervals and associated before
  2    28*   journal control intervals.  The first two words are the time stamp for
  2    29*   synchronization; the latter two identify the control interval. */
  2    30 
  2    31      dcl	   ci_header_ptr	      ptr;
  2    32      dcl	   1 ci_header	      aligned based (ci_header_ptr),
  2    33 	     2 stamp	      like ci_stamp,
  2    34 	     2 id		      like ci_id;
  2    35 
  2    36 /* ci_trailer is the last two words of a control interval and must match
  2    37*   the first two words (ci_header.stamp). */
  2    38 
  2    39      dcl	   ci_trailer_ptr	      ptr;
  2    40      dcl	   1 ci_trailer	      like ci_header.stamp aligned based (ci_trailer_ptr);
  2    41 
  2    42 
  2    43 /* ci_stamp is a two-word date/time modified stamp, consisting of:
  2    44*     version: a 9-bit version string for the structure
  2    45*     bj_idx:  before journal index for I/O synchronization
  2    46*     time_modified:  Multics clock time of last modification */
  2    47 
  2    48      dcl	   1 ci_stamp	      aligned based,
  2    49 	     3 version	      bit (9) unal,
  2    50 	     3 bj_idx	      fixed bin (9) uns unal,
  2    51 	     3 time_modified      fixed bin (53) unal;
  2    52 
  2    53      dcl	   CI_HEADER_STAMP_VERSION_1
  2    54 			      bit (9) aligned static options (constant) init ("641"b3);
  2    55 
  2    56 /* ci_id is a two-word identification of the control interval, which
  2    57*   rarely changes and consists of:
  2    58*     uid:   DM file unique identifier
  2    59*     size_code:  the control interval size in bytes, in an encoded
  2    60*                 form (see ci_size_code below).
  2    61*     num:   the control interval number.  0 is the number of the first
  2    62*            control interval of a file. */
  2    63 
  2    64      dcl	   1 ci_id	      aligned based,
  2    65 	     3 uid	      bit (36),
  2    66 	     3 size_code	      bit (9) unal,
  2    67 	     3 num	      fixed bin (27) uns unal;
  2    68 
  2    69 /* ci_size_code is the structure which defines the content of ci_id.size_code.
  2    70*   The size in bytes of a control interval is equal to 
  2    71*   (2 ** ci_size_code.exponent * (64 + 8 * ci_size_code.addon)).  */
  2    72 
  2    73      dcl	   1 ci_size_code	      aligned based,
  2    74 	     2 exponent	      fixed bin (6) uns unal,
  2    75 	     2 addon	      fixed bin (3) uns unal;
  2    76 
  2    77 /* ci_header_chunks is a structure which can be used to update the
  2    78*   ci_stamp or ci_id in one memory cycle. */
  2    79 
  2    80      dcl	   1 ci_header_chunks     aligned based (ci_header_ptr),
  2    81 	     2 stamp	      fixed bin (71),
  2    82 	     2 id		      fixed bin (71);
  2    83 
  2    84 /* ci_trailer_chunk is a structure which can e used to update the
  2    85*   ci_trailer in one memory cycle. */
  2    86 
  2    87      dcl	   1 ci_trailer_chunk     aligned based,
  2    88 	     2 stamp	      fixed bin (71);
  2    89 
  2    90 
  2    91 /*  END INCLUDE FILE:  dm_ci_header.incl.pl1  */
      619 
      620 
  3     1 /* BEGIN INCLUDE FILE dm_ci_constants.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*
  3     5*        This include file contains constants used with the ci and
  3     6*   ci_header structures.
  3     7**/
  3     8 
  3     9 /* HISTORY:
  3    10*Written by Matthew Pierret, 11/07/84.
  3    11*Modified:
  3    12**/
  3    13 
  3    14 /* format: style2,ind3 */
  3    15 
  3    16 
  3    17      dcl	   MAX_CI_NUM	      fixed bin (27) static options (constant) init (134217727);
  3    18      dcl	   CI_STAMP_VERSION_1     bit (9) aligned static options (constant) init ("641"b3);
  3    19      dcl	   TEMPLATE_CI_STAMP_1    fixed bin (71) static options (constant) init (-876220343501203701760);
  3    20      dcl	   (SIZE_CODE_1024_WORDS, CI_SIZE_CODE_1024_WORDS)
  3    21 			      bit (9) aligned static options (constant) init ("060"b3);
  3    22 
  3    23 /* END INCLUDE FILE dm_ci_constants.incl.pl1 */
      621 
      622 
  4     1 /* BEGIN INCLUDE FILE dm_ci_lengths.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*       This include file contains constants which are the length in bytes
  4     5*   of the addressable portion of a control interval.  The addressable portion
  4     6*   is that part of the control interval which callers of file_manager_
  4     7*   may access, specifically, everything between the end of the control
  4     8*   interval header (ci_header) and the control interval trailer (ci_trailer).
  4     9*   Control interval 0 is slightly different, as it also contains an 
  4    10*   unaddressable portion in which it maintains the file attributes.  For
  4    11*   control interval 0 the addressable portion is everything between the end
  4    12*   of the control interval header and the beginning of the file attributes.
  4    13**/
  4    14 
  4    15 /* HISTORY:
  4    16*Written by Matthew Pierret, 11/02/84.
  4    17*Modified:
  4    18**/
  4    19 
  4    20 /* format: style2,ind3 */
  4    21 
  4    22      dcl	   CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES
  4    23 			      fixed bin (17) init (4072) int static options (constant);
  4    24 
  4    25      dcl	   CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES
  4    26 			      fixed bin (17) init (3176) int static options (constant);
  4    27 
  4    28 
  4    29      dcl	   CI_ADDRESSABLE_LENGTH  fixed bin (17) init (4072) int static options (constant);
  4    30 
  4    31      dcl	   CI_0_ADDRESSABLE_LENGTH
  4    32 			      fixed bin (17) init (3176) int static options (constant);
  4    33 
  4    34 /* END INCLUDE FILE dm_ci_lengths.incl.pl1 */
      623 
      624 
  5     1 /*  BEGIN INCLUDE FILE:  dm_ci_parts.incl.pl1  */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*
  5     5*        This include file contains the ci_parts structure.  This structure
  5     6*   is used across the file_manager_ interface to specify the parts of a
  5     7*   control interval to get or put.  If the number_of parts is equal to 0,
  5     8*   modules which take ci_parts interpret this case to mean to do everything
  5     9*   except the actual requested operation, i.e., lock the control interval
  5    10*   but don't get anything.  offset_in_bytes is the 0-originned offset in
  5    11*   bytes from the beginning of the addressable portion of the control interval.
  5    12*   An offset_in_bytes which is in the addressable portion is in error.
  5    13*   Likewise, if offset_in_bytes + length_in_bytes is outside of the addressable
  5    14*   portion, it is in error.
  5    15**/
  5    16 
  5    17 /* HISTORY:
  5    18*Written by Matthew Pierret, 01/28/82.
  5    19*  (01/28/82 Andre Bensoussan, Design.)
  5    20*Modified:
  5    21*11/07/84 by Matthew Pierret:  To add must_be_zero, initial attributes on
  5    22*            automatic storge.
  5    23**/
  5    24 
  5    25 /* format: style2,ind3 */
  5    26 
  5    27      dcl	   1 ci_parts	      aligned based (ci_parts_ptr),
  5    28 	     2 number_of_parts    fixed bin (17),
  5    29 	     2 must_be_zero	      fixed bin,
  5    30 	     2 part	      (cip_number_of_parts refer (ci_parts.number_of_parts)),
  5    31 	       3 offset_in_bytes  fixed bin (17),
  5    32 	       3 length_in_bytes  fixed bin (17),
  5    33 	       3 local_ptr	      ptr;
  5    34 
  5    35      dcl	   ci_parts_ptr	      ptr init (null ());
  5    36      dcl	   cip_number_of_parts    fixed bin (17) init (0);
  5    37 
  5    38 
  5    39 /*  BEGIN INCLUDE FILE:   dm_ci_parts.incl.pl1   */
      625 
      626 
  6     1 /*  START OF:	dm_lock_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*
  6     5*     Hierarchical lock modes for Data Management control interval locking.  In
  6     6*addition to conventional read and write locks, intention locks are provided
  6     7*for finer locking granularity.
  6     8**/
  6     9 
  6    10 /* HISTORY:
  6    11*Written by Jeffrey D. Ives, 04/30/82.
  6    12*Modified:
  6    13*12/05/84 by Stanford S. Cox: Added Description.
  6    14**/
  6    15 /* format: style3,idind25 */
  6    16 
  6    17      dcl	   LOCK_MODE_S	      fixed bin static options (constant) init (2);
  6    18      dcl	   LOCK_MODE_X	      fixed bin static options (constant) init (3);
  6    19      dcl	   LOCK_MODE_IS	      fixed bin static options (constant) init (4);
  6    20      dcl	   LOCK_MODE_IX	      fixed bin static options (constant) init (5);
  6    21      dcl	   LOCK_MODE_SIX	      fixed bin static options (constant) init (6);
  6    22 
  6    23      dcl	   LOCK_ENTIRE_FILE	      fixed bin (27) static options (constant) init (-1);
  6    24 
  6    25      dcl	   LOCK_MODE_NAMES (2:6)  char (3) int static options (constant)
  6    26 			      init ("  S", "  X", " IS", " IX", "SIX");
  6    27 
  6    28 /*
  6    29*     S       Share                           Let others read it but not modify it.
  6    30*     X	   Exclusive		     Let nobody else read or modify it.
  6    31*     IS	   Intention Share		     I am only using S locks, because I am only reading CIs.
  6    32*     IX	   Intention Exclusive	     I am using S and X locks, because I am reading and modifying CIs.
  6    33*     SIX	   Share with Intention Exclusive  I am reading control intervals, but only locking the ones I modify.
  6    34**/
  6    35 
  6    36 /*  END OF:	dm_lock_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      627 
      628 
  7     1 /*  BEGIN INCLUDE FILE: dm_fm_file_oid.incl.pl1 */
  7     2 
  7     3 /* DESCRIPTION:
  7     4*        This include file contains the file_oid (file opening identifier)
  7     5*   structure.  File opening ids are passed across the file_manager_
  7     6*   interface as bit(36)aligned strings.  The file_oid structure defines
  7     7*   the contents of the string.  Two components make up a file opening id:
  7     8*   the index of the file opening in the file_access_table structure, which
  7     9*   contains per-process information on each file which is open, and the
  7    10*   last 18 bits of the file's unique id, used for verification of the entry
  7    11*   in the file_access_table.
  7    12**/
  7    13 
  7    14 /*
  7    15*HISTORY:
  7    16*Written by Matthew Pierret, 07/16/84.
  7    17*Modified:
  7    18*11/02/84 by Matthew Pierret:  Made file_oid based.
  7    19**/
  7    20 
  7    21 /* format: style2,ind3 */
  7    22 
  7    23      dcl	   1 file_oid	      aligned based,
  7    24 	     2 file_access_table_idx
  7    25 			      fixed bin (17) unal,	/* index into file_access_table */
  7    26 	     2 uid_tail	      bit (18) unal;	/* Last 18 bits of file unique id */
  7    27 
  7    28 
  7    29 /* END INCLUDE FILE:  dm_fm_file_oid.incl.pl1 */
      629 
      630 
  8     1 /* BEGIN INCLUDE FILE:	dm_fm_file_access_info.incl.pl1 */
  8     2 
  8     3 /* DESCRIPTION:
  8     4*        The file_access_info structure contains per-process information
  8     5*   about a DM file.  Each file_access_info structure is one entry in
  8     6*   the file_access_table.e array.  The entry can be in one of three states:
  8     7*   not-in-use (file_access_info.entry_state is 0), in-use (entry_state is
  8     8*   -1) or still in-use, but to be discarded at the end of the transaction
  8     9*   (any number > 0).  An entry needs to be discarded when the file is 
  8    10*   completely closed by the user.  This last state is useful because it is 
  8    11*   better not to discard the entry when it is completely closed until the
  8    12*   end of the current transaction, so that if the transaction is aborted, the 
  8    13*   file need not be re-opened to apply the before images.  A list of entries
  8    14*   to be discarded is maintained using the entry_state variable.
  8    15*        The file can be in one of three states: exists (file_state = 1), 
  8    16*   does not exist (file_state = 0), and logically_deleted (file_state = 3).
  8    17**/
  8    18 
  8    19 /* HISTORY:
  8    20*Written by Jeffrey D. Ives, 10/11/82.
  8    21*  (Original design by Andre Bensoussan, 01/28/82.)
  8    22*Modified:
  8    23*10/05/83 Jeffrey D. Ives: Added fields for lock advice and expanded seg_nums.
  8    24*07/12/84 by Matthew Pierret: Re-named proc_ad to file_access_info.
  8    25*12/17/84 by Matthew Pierret: Changed post_transaction_actions sub-structure
  8    26*            to state, with entry_state (replacing thread) and the new
  8    27*            file_state.  Added a DESCRIPTION section. Added constants for
  8    28*            possible file_state values.
  8    29**/
  8    30 
  8    31 /* format: style2,^inddcls,dclind5 */
  8    32 
  8    33 dcl  1 file_access_info     aligned based (file_access_info_ptr),
  8    34        2 state	        aligned,
  8    35          3 entry_state      fixed bin (17) unal,
  8    36          3 file_state       fixed bin (17) unal,
  8    37        2 uid	        bit (36),
  8    38        2 blocking_factor    fixed bin (17) unal,
  8    39        2 ring_brackets      unal,
  8    40          3 write	        fixed bin (3) unsigned unal,
  8    41          3 read	        fixed bin (3) unsigned unal,
  8    42          3 mbz_rb	        fixed bin (3) unsigned unal,
  8    43        2 integrity_switches unal,
  8    44          3 record_time_modified
  8    45 		        bit (1) unal,		/* record time modified in ci_header and trailer	*/
  8    46          3 transaction      bit (1) unal,		/* permit access only during a transaction	*/
  8    47          3 lock	        bit (1) unal,		/* lock control intervals before accessing them	*/
  8    48          3 bj	        bit (1) unal,		/* put undo records in the before journal	*/
  8    49          3 aj	        bit (1) unal,		/* put redo records in the after journal	*/
  8    50          3 mbz_is	        bit (4) unal,
  8    51        2 last_transaction_id
  8    52 		        bit (36),
  8    53        2 msf_ptr	        ptr unal,
  8    54        2 pn_tbl_idx	        fixed bin (17) unal,
  8    55        2 lock_advice        fixed bin (17) unal,
  8    56        2 opens	        fixed bin (17) unal,
  8    57        2 seg_0_num	        bit (18) unal,
  8    58        2 seg_nums	        (27) fixed bin (12) uns unal;
  8    59 
  8    60 
  8    61 dcl  file_access_info_ptr   ptr init (null ());
  8    62 
  8    63 dcl  (
  8    64      FILE_ACCESS_INFO_IN_USE
  8    65 		        init (-1),
  8    66      FILE_ACCESS_INFO_NOT_IN_USE
  8    67 		        init (0),
  8    68      FILE_DOES_NOT_EXIST init (0),
  8    69      FILE_EXISTS	        init (1),
  8    70      FILE_LOGICALLY_DELETED init (3)
  8    71      )		        fixed bin internal static options (constant);
  8    72 
  8    73 
  8    74 /* END INCLUDE FILE:	dm_fm_file_access_info.incl.pl1  */
      631 
      632 
  9     1 /* BEGIN INCLUDE FILE:	dm_fm_file_access_tbl.incl.pl1  */
  9     2 
  9     3 /* DESCRIPTION:
  9     4*
  9     5*        This include file contains the file_access_table structure.  This
  9     6*   is a per-process table which contains one entry for each file which the
  9     7*   process has open.  The table is set up during per-process initialization 
  9     8*   and is pointed to by fm_data_$file_access_table_ptr.  The bounds limit
  9     9*   on the array of entries is abritrary and can be changed.
  9    10**/
  9    11 
  9    12 /* HISTORY:
  9    13*Written by Jeffrey D. Ives, 10/11/82. 
  9    14*  (01/28/82 Andre Bensoussan, Design.)
  9    15*Modified:
  9    16*07/11/84 by Matthew Pierret:  Changed name of structure from proc_ad_tbl to
  9    17*            file_access_table.
  9    18*11/07/84 by Matthew Pierret:  Removed the un-used post_commit_actions element.
  9    19*            Removed the now-obsolete oid structure.  It has been replaced by
  9    20*            file_oid in dm_fm_file_oid.incl.pl1.
  9    21**/
  9    22 
  9    23 /* format: style2,ind3 */
  9    24 
  9    25 
  9    26      dcl	   fm_data_$file_access_table_ptr
  9    27 			      ptr ext;
  9    28 
  9    29      dcl	   1 file_access_table    aligned based (fm_data_$file_access_table_ptr),
  9    30 	     2 h,
  9    31 	       3 version	      char (8) aligned,
  9    32 	       3 last_entry	      fixed bin,
  9    33 	       3 post_transaction_actions
  9    34 			      fixed bin,
  9    35 	       3 mbz_1	      (6) fixed bin (71),
  9    36 	     2 e		      (1024) like file_access_info;
  9    37 
  9    38 
  9    39      dcl	   FILE_ACCESS_TABLE_VERSION_1
  9    40 			      init ("FileAT 1") char (8) aligned static options (constant);
  9    41 
  9    42 /*  END INCLUDE FILE:    dm_fm_file_access_tbl.incl.pl1  */
      633 
      634 
      635      end fm_get_$get;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/17/00  1934.0  fm_get_.pl1                       >udd>sm>ds>w>ml>fm_get_.pl1
617          1    01/07/85  1000.4  dm_ci.incl.pl1                    >ldd>incl>dm_ci.incl.pl1
619          2    01/07/85  1000.5  dm_ci_header.incl.pl1             >ldd>incl>dm_ci_header.incl.pl1
621          3    01/07/85  1000.3  dm_ci_constants.incl.pl1          >ldd>incl>dm_ci_constants.incl.pl1
623          4    01/07/85  1000.7  dm_ci_lengths.incl.pl1            >ldd>incl>dm_ci_lengths.incl.pl1
625          5    01/07/85  1000.8  dm_ci_parts.incl.pl1              >ldd>incl>dm_ci_parts.incl.pl1
627          6    01/07/85  1001.4  dm_lock_modes.incl.pl1            >ldd>incl>dm_lock_modes.incl.pl1
629          7    01/07/85  1000.9  dm_fm_file_oid.incl.pl1           >ldd>incl>dm_fm_file_oid.incl.pl1
631          8    03/06/85  1131.2  dm_fm_file_access_info.incl.pl1   >ldd>incl>dm_fm_file_access_info.incl.pl1
633          9    01/07/85  1001.1  dm_fm_file_access_tbl.incl.pl1    >ldd>incl>dm_fm_file_access_tbl.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CI_0_ADDRESSABLE_LENGTH                constant        fixed bin(17,0)          initial dcl 4-31 ref 185 243 262 284
CI_ADDRESSABLE_LENGTH                  constant        fixed bin(17,0)          initial dcl 4-29 ref 187 223 245 264 286
CI_STAMP_VERSION_1                     constant        bit(9)                   initial dcl 3-18 ref 205 477
FILE_ACCESS_INFO_NOT_IN_USE            constant        fixed bin(17,0)          initial dcl 8-63 ref 366
FILE_EXISTS                            constant        fixed bin(17,0)          initial dcl 8-63 ref 369
GET_INTEGRITY_SWITCHES                 constant        bit(5)                   initial dcl 108 ref 179 200 217 237 277 301 322 339
LOCK_ENTIRE_FILE                000006 constant        fixed bin(27,0)          initial dcl 6-23 set ref 408*
LOCK_MODE_S                            constant        fixed bin(17,0)          initial dcl 6-17 ref 180 201 218 257 278 302 323 416
                                                                                  416
LOCK_MODE_SIX                          constant        fixed bin(17,0)          initial dcl 6-21 ref 416
LOCK_MODE_X                            constant        fixed bin(17,0)          initial dcl 6-18 ref 238 340 414
LOCK_WAIT_TIME                  000004 constant        fixed bin(71,0)          initial dcl 105 set ref 397* 408* 421*
MAX_CI_NUM                      000002 constant        fixed bin(27,0)          initial dcl 3-17 ref 354
NULL_INTEGRITY_SWITCHES                constant        bit(5)                   initial dcl 106 ref 256
SIZE_CODE_1024_WORDS                   constant        bit(9)                   initial dcl 3-20 ref 480 571
TEMPLATE_CI_STAMP_1             000000 constant        fixed bin(71,0)          initial dcl 3-19 ref 568
addr                                                   builtin function         dcl 125 ref 205 279 469 477 480 483 486 570 571 572
                                                                                  581
addressable_bytes         4            based           char(4072)               level 2 dcl 1-24 set ref 510 581
baseno                                                 builtin function         dcl 125 ref 462
baseptr                                                builtin function         dcl 125 ref 433 440
bin                                                    builtin function         dcl 125 ref 462
blocking_factor           2     000135 automatic       fixed bin(17,0)          level 2 packed packed unaligned dcl 101 set ref 429
                                                                                  467
caller_validation_level         000100 automatic       fixed bin(17,0)          initial dcl 74 set ref 74* 381* 382 445* 450*
ci                                     based           structure                level 1 dcl 1-24
ci_header                              based           structure                level 1 dcl 2-32
ci_header_chunks                       based           structure                level 1 dcl 2-80
ci_id                                  based           structure                level 1 dcl 2-64
ci_num                          000101 automatic       fixed bin(27,0)          dcl 76 set ref 183* 185 203* 221* 241* 243 260* 262
                                                                                  283* 284 303* 324* 341* 354 354 397* 421* 429 467
                                                                                  486 572
ci_parts                               based           structure                level 1 dcl 5-27
ci_parts_ptr                    000166 automatic       pointer                  initial dcl 5-35 set ref 182* 220* 240* 259* 279*
                                                                                  280 281 282 495 499 500 504 505 543 547 548 552
                                                                                  553 5-35* 594*
ci_ptr                          000164 automatic       pointer                  dcl 1-23 set ref 433* 440* 448* 452 462 469* 469 471
                                                                                  472 510 581 593*
ci_stamp                               based           structure                level 1 dcl 2-48
ci_trailer_chunk                       based           structure                level 1 dcl 2-87
cip_number_of_parts             000170 automatic       fixed bin(17,0)          initial dcl 5-36 set ref 495* 496 499 543* 544 547
                                                                                  5-36* 597*
cleanup                         000156 stack reference condition                dcl 113 ref 445
code                            000102 automatic       fixed bin(35,0)          initial dcl 77 set ref 77* 397* 399 399* 408* 410
                                                                                  410* 421* 423 423* 448* 454 457* 598*
component_num                   000103 automatic       fixed bin(17,0)          dcl 78 set ref 429* 431 436 438 440 448* 460 462 467
                                                                                  599*
cu_$level_get                   000046 constant        entry                    external dcl 160 ref 381
cu_$level_set                   000050 constant        entry                    external dcl 161 ref 445 446 450
divide                                                 builtin function         dcl 125 ref 429
dm_data_$current_txn_id         000010 external static bit(36)                  dcl 130 ref 389 403 405
dm_error_$bad_file_oid          000012 external static fixed bin(35,0)          dcl 132 set ref 360* 366* 372* 375*
dm_error_$ci_bad_hdr_arg_ver    000014 external static fixed bin(35,0)          dcl 133 set ref 205*
dm_error_$ci_bad_hdr_id_num     000016 external static fixed bin(35,0)          dcl 135 set ref 486*
dm_error_$ci_bad_hdr_size_code  000020 external static fixed bin(35,0)          dcl 137 set ref 480*
dm_error_$ci_bad_hdr_uid        000022 external static fixed bin(35,0)          dcl 139 set ref 483*
dm_error_$ci_bad_stamp_ver      000024 external static fixed bin(35,0)          dcl 141 set ref 477*
dm_error_$ci_not_allocated      000026 external static fixed bin(35,0)          dcl 143 set ref 536*
dm_error_$ci_num_oob            000030 external static fixed bin(35,0)          dcl 145 set ref 354*
dm_error_$ci_num_parts_neg      000032 external static fixed bin(35,0)          dcl 146 set ref 496* 544*
dm_error_$ci_parts_oob          000034 external static fixed bin(35,0)          dcl 148 set ref 507* 555*
dm_error_$file_doesnt_exist     000036 external static fixed bin(35,0)          dcl 149 set ref 369* 378*
dm_error_$no_current_transaction
                                000040 external static fixed bin(35,0)          dcl 151 set ref 389*
e                        20            based           structure                array level 2 dcl 9-29 set ref 360 364 406* 463*
effective_integrity_switches    000134 automatic       structure                level 1 dcl 99 set ref 179* 200* 217* 237* 256* 277*
                                                                                  301* 322* 339* 385* 385
entry_state                     000135 automatic       fixed bin(17,0)          level 3 packed packed unaligned dcl 101 set ref 366
er_p_code                              parameter       fixed bin(35,0)          dcl 529 ref 526 531
error_table_$no_r_permission    000044 external static fixed bin(35,0)          dcl 154 set ref 382*
error_table_$noentry            000042 external static fixed bin(35,0)          dcl 153 ref 454
file_access_info                       based           structure                level 1 dcl 8-33
file_access_info_ptr            000172 automatic       pointer                  initial dcl 8-61 set ref 8-61*
file_access_table                      based           structure                level 1 dcl 9-29
file_access_table_idx           000124 automatic       fixed bin(17,0)          level 2 packed packed unaligned dcl 93 set ref 360
                                                                                  360 364 406 463
file_oid                               based           structure                level 1 dcl 7-23
file_state                0(18) 000135 automatic       fixed bin(17,0)          level 3 packed packed unaligned dcl 101 set ref 369
fm_data_$file_access_table_ptr  000060 external static pointer                  dcl 9-26 ref 360 360 364 406 463
get_ring_                       000052 constant        entry                    external dcl 162 ref 446 446
h                                      based           structure                level 2 dcl 9-29
hbound                                                 builtin function         dcl 125 ref 436 460
header                                 based           structure                level 2 dcl 1-24
id                        2            parameter       bit(72)                  level 2 in structure "p_ci_header" dcl 67
                                                                                  in procedure "fm_get_$get" set ref 576*
id                        2            based           fixed bin(71,0)          level 3 in structure "ci" dcl 1-24 in procedure
                                                                                  "fm_get_$get" ref 472
integrity_switches       22(27)        based           structure                array level 3 in structure "file_access_table"
                                                                                  packed packed unaligned dcl 9-29 in procedure
                                                                                  "fm_get_$get"
integrity_switches        2(27)        based           structure                level 2 in structure "file_access_info" packed
                                                                                  packed unaligned dcl 8-33 in procedure
                                                                                  "fm_get_$get"
integrity_switches        2(27) 000135 automatic       structure                level 2 in structure "my_file_access_info" packed
                                                                                  packed unaligned dcl 101 in procedure
                                                                                  "fm_get_$get" set ref 385
just_get_ci_ptr                 000104 automatic       bit(1)                   dcl 79 set ref 177* 198* 215* 235* 254* 275* 299*
                                                                                  320* 337* 489 536
just_get_header                 000105 automatic       bit(1)                   dcl 80 set ref 177* 197* 215* 235* 254* 274* 298*
                                                                                  319* 336* 492 540
last_entry                2            based           fixed bin(17,0)          level 3 dcl 9-29 ref 360
last_transaction_id       3     000135 automatic       bit(36)                  level 2 dcl 101 set ref 403 405*
lbound                                                 builtin function         dcl 125 ref 360 499 547
length_in_bytes           3            based           fixed bin(17,0)          array level 3 dcl 5-27 set ref 281* 500 548
local_ptr                 4            based           pointer                  array level 3 dcl 5-27 set ref 282* 505 553
lock                      0(02) 000134 automatic       bit(1)                   level 2 packed packed unaligned dcl 99 set ref 393
lock_advice               5(18) 000135 automatic       fixed bin(17,0)          level 2 packed packed unaligned dcl 101 set ref 395
                                                                                  408 414 416 416
lock_manager_$lock              000054 constant        entry                    external dcl 163 ref 397 408 421
lock_mode                       000106 automatic       fixed bin(17,0)          dcl 81 set ref 180* 201* 218* 238* 257* 278* 302*
                                                                                  323* 340* 397* 416 421* 600*
min_opens                       000107 automatic       fixed bin(17,0)          dcl 82 set ref 178* 199* 216* 236* 255* 276* 300*
                                                                                  321* 338* 372
msf_manager_$msf_get_ptr        000056 constant        entry                    external dcl 165 ref 448
msf_ptr                   4     000135 automatic       pointer                  level 2 packed packed unaligned dcl 101 set ref 448
multiply                                               builtin function         dcl 125 ref 467
my_ci_id                        000120 automatic       fixed bin(71,0)          dcl 91 set ref 472* 480 483 486 570 571 572 576 601*
my_ci_stamp                     000122 automatic       fixed bin(71,0)          dcl 92 set ref 471* 474 477 568* 574 602*
my_file_access_info             000135 automatic       structure                level 1 dcl 101 set ref 364* 406 463
my_file_oid                     000124 automatic       structure                level 1 dcl 93 set ref 358* 609*
null                                                   builtin function         dcl 125 ref 90 297 318 335 452 5-35 8-61 593 594 595
num                       1(09)        based           fixed bin(27,0)          level 2 packed packed unsigned unaligned dcl 2-64
                                                                                  set ref 486 572*
number_of_addressable_bytes     000110 automatic       fixed bin(17,0)          dcl 83 set ref 185* 187* 223* 243* 245* 262* 264*
                                                                                  284* 286* 507 555 603*
number_of_parts                 000126 automatic       fixed bin(17,0)          initial level 2 in structure "single_ci_part" dcl 95
                                                                                  in procedure "fm_get_$get" set ref 95*
number_of_parts                        based           fixed bin(17,0)          level 2 in structure "ci_parts" dcl 5-27
                                                                                  in procedure "fm_get_$get" ref 495 543
offset_in_bytes           2            based           fixed bin(17,0)          array level 3 dcl 5-27 set ref 280* 504 552
opens                     6     000135 automatic       fixed bin(17,0)          level 2 packed packed unaligned dcl 101 set ref 372
p_ci_header                            parameter       structure                level 1 dcl 67 set ref 192 205
p_ci_num                               parameter       fixed bin(27,0)          dcl 58 ref 51 183 192 203 210 221 230 241 249 260
                                                                                  269 283 289 303 308 324 328 341 345
p_ci_parts_ptr                         parameter       pointer                  dcl 59 ref 51 182 210 220 230 240 249 259
p_ci_ptr                               parameter       pointer                  dcl 60 set ref 289 297* 308 318* 328 335* 345 581*
p_code                                 parameter       fixed bin(35,0)          dcl 64 set ref 51 192 210 230 249 269 289 308 328
                                                                                  345 514* 520* 531*
p_file_oid                             parameter       bit(36)                  dcl 65 ref 51 192 210 230 249 269 289 308 328 345
                                                                                  358
p_single_part_length                   parameter       fixed bin(17,0)          dcl 61 ref 269 281
p_single_part_offset                   parameter       fixed bin(17,0)          dcl 62 ref 269 280
p_single_part_ptr                      parameter       pointer                  dcl 63 ref 269 282
page_num                        000111 automatic       fixed bin(17,0)          dcl 85 set ref 467* 469 604*
pages                                  based           structure                array level 2 dcl 119 set ref 469
part                      2            based           structure                array level 2 dcl 5-27 set ref 499 547
part_buffer                            based           char                     packed unaligned dcl 117 set ref 510* 558*
part_idx                        000112 automatic       fixed bin(17,0)          dcl 86 set ref 499* 500 504 505* 547* 548 552 553*
                                                                                  605*
part_length                     000113 automatic       fixed bin(17,0)          dcl 87 set ref 500* 502 507 507 510 510 548* 550 555
                                                                                  555 558 606*
part_offset                     000114 automatic       fixed bin(17,0)          dcl 88 set ref 504* 507 507 510 552* 555 555 607*
part_ptr                        000116 automatic       pointer                  initial dcl 90 set ref 90* 505* 510 553* 558 595*
read                      2(21) 000135 automatic       fixed bin(3,0)           level 3 packed packed unsigned unaligned dcl 101 set
                                                                                  ref 382
ring_brackets             2(18) 000135 automatic       structure                level 2 packed packed unaligned dcl 101
seg                                    based           structure                level 1 dcl 119
seg_0_num                 6(18) 000135 automatic       bit(18)                  level 2 packed packed unaligned dcl 101 set ref 378
                                                                                  433
seg_nums                  7     000135 automatic       fixed bin(12,0)          array level 2 packed packed unsigned unaligned
                                                                                  dcl 101 set ref 436 438 440 460 462*
single_ci_part                  000126 automatic       structure                level 1 dcl 95 set ref 279
size_code                 1            based           bit(9)                   level 2 packed packed unaligned dcl 2-64 set ref 480
                                                                                  571*
stamp                                  based           structure                level 2 in structure "ci_header" dcl 2-32
                                                                                  in procedure "fm_get_$get"
stamp                  1776            based           fixed bin(71,0)          level 3 in structure "ci" dcl 1-24 in procedure
                                                                                  "fm_get_$get" ref 471
stamp                                  parameter       bit(72)                  level 2 in structure "p_ci_header" dcl 67
                                                                                  in procedure "fm_get_$get" set ref 574*
state                           000135 automatic       structure                level 2 dcl 101
string                                                 builtin function         dcl 125 set ref 179* 200* 217* 237* 256* 277* 301*
                                                                                  322* 339*
substr                                                 builtin function         dcl 125 ref 375 510
trailer                1776            based           structure                level 2 dcl 1-24
transaction               0(01) 000134 automatic       bit(1)                   level 2 packed packed unaligned dcl 99 set ref 387
uid                       1     000135 automatic       bit(36)                  level 2 in structure "my_file_access_info" dcl 101
                                                                                  in procedure "fm_get_$get" set ref 375 397* 408*
                                                                                  421* 483 570
uid                                    based           bit(36)                  level 2 in structure "ci_id" dcl 2-64 in procedure
                                                                                  "fm_get_$get" set ref 483 570*
uid_tail                  0(18) 000124 automatic       bit(18)                  level 2 packed packed unaligned dcl 93 set ref 375
unspec                                                 builtin function         dcl 125 set ref 358* 558* 574* 574 576* 576 609*
version                                based           bit(9)                   level 2 packed packed unaligned dcl 2-48 ref 205 477

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
CI_HEADER_STAMP_VERSION_1              internal static bit(9)                   initial dcl 2-53
CI_SIZE_CODE_1024_WORDS                internal static bit(9)                   initial dcl 3-20
CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES
                                       internal static fixed bin(17,0)          initial dcl 4-22
CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES
                                       internal static fixed bin(17,0)          initial dcl 4-25
FILE_ACCESS_INFO_IN_USE                internal static fixed bin(17,0)          initial dcl 8-63
FILE_ACCESS_TABLE_VERSION_1            internal static char(8)                  initial dcl 9-39
FILE_DOES_NOT_EXIST                    internal static fixed bin(17,0)          initial dcl 8-63
FILE_LOGICALLY_DELETED                 internal static fixed bin(17,0)          initial dcl 8-63
LOCK_MODE_IS                           internal static fixed bin(17,0)          initial dcl 6-19
LOCK_MODE_IX                           internal static fixed bin(17,0)          initial dcl 6-20
LOCK_MODE_NAMES                        internal static char(3)                  initial array packed unaligned dcl 6-25
ci_header_ptr                          automatic       pointer                  dcl 2-31
ci_size_code                           based           structure                level 1 dcl 2-73
ci_trailer                             based           structure                level 1 dcl 2-40
ci_trailer_ptr                         automatic       pointer                  dcl 2-39

NAMES DECLARED BY EXPLICIT CONTEXT.
ERROR_RETURN                    001712 constant        entry                    internal dcl 526 ref 205 354 360 366 369 372 375 378
                                                                                  382 389 399 410 423 457 477 480 483 486 496 507
                                                                                  536 544 555
FAKE_GET                        001562 constant        label                    dcl 536 ref 454 474
FAKE_GET_HEADER                 001660 constant        label                    dcl 568 ref 540
GET_CI_PTR                      001701 constant        label                    dcl 581 ref 489
INIT                            001717 constant        entry                    internal dcl 588 ref 175 195 213 233 252 272 296 317
                                                                                  334
JOIN                            000523 constant        label                    dcl 354 ref 189 208 225 247 266 287 305 326 342
MAIN_RETURN                     001561 constant        label                    dcl 515 ref 521 532
REAL_GET                        001376 constant        label                    dcl 467 ref 434 441
REAL_GET_HEADER                 001670 constant        label                    dcl 574 ref 492
RETURN                          001707 constant        entry                    internal dcl 518 ref 352 562 578 583
fm_get_$get                     000051 constant        entry                    external dcl 51
get_ci_header                   000115 constant        entry                    external dcl 192
get_ci_ptr                      000371 constant        entry                    external dcl 289
get_ci_ptr_exclusive            000456 constant        entry                    external dcl 328
get_exclusive                   000215 constant        entry                    external dcl 230
internal_get                    000161 constant        entry                    external dcl 210
internal_get_ci_ptr             000424 constant        entry                    external dcl 308
raw_get                         000256 constant        entry                    external dcl 249
simple_get                      000322 constant        entry                    external dcl 269
terminate_ci_ptr                000511 constant        entry                    external dcl 345

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2366        2450    1752        2376
Length      3064    1752        62         377     413           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
fm_get_$get                         172 external procedure  is an external procedure.  
on unit on line 445                  68 on unit               
RETURN                                  internal procedure  shares stack frame of external procedure fm_get_$get.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure fm_get_$get.  
INIT                                    internal procedure  shares stack frame of external procedure fm_get_$get.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
fm_get_$get              000100 caller_validation_level     fm_get_$get
                         000101 ci_num                      fm_get_$get
                         000102 code                        fm_get_$get
                         000103 component_num               fm_get_$get
                         000104 just_get_ci_ptr             fm_get_$get
                         000105 just_get_header             fm_get_$get
                         000106 lock_mode                   fm_get_$get
                         000107 min_opens                   fm_get_$get
                         000110 number_of_addressable_bytes fm_get_$get
                         000111 page_num                    fm_get_$get
                         000112 part_idx                    fm_get_$get
                         000113 part_length                 fm_get_$get
                         000114 part_offset                 fm_get_$get
                         000116 part_ptr                    fm_get_$get
                         000120 my_ci_id                    fm_get_$get
                         000122 my_ci_stamp                 fm_get_$get
                         000124 my_file_oid                 fm_get_$get
                         000126 single_ci_part              fm_get_$get
                         000134 effective_integrity_switches
                                                            fm_get_$get
                         000135 my_file_access_info         fm_get_$get
                         000164 ci_ptr                      fm_get_$get
                         000166 ci_parts_ptr                fm_get_$get
                         000170 cip_number_of_parts         fm_get_$get
                         000172 file_access_info_ptr        fm_get_$get

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return_mac          enable_op           ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cu_$level_get                 cu_$level_set                 get_ring_                     lock_manager_$lock
msf_manager_$msf_get_ptr

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_data_$current_txn_id       dm_error_$bad_file_oid        dm_error_$ci_bad_hdr_arg_ver  dm_error_$ci_bad_hdr_id_num
dm_error_$ci_bad_hdr_size_code                              dm_error_$ci_bad_hdr_uid      dm_error_$ci_bad_stamp_ver
dm_error_$ci_not_allocated    dm_error_$ci_num_oob          dm_error_$ci_num_parts_neg    dm_error_$ci_parts_oob
dm_error_$file_doesnt_exist   dm_error_$no_current_transaction                            error_table_$no_r_permission
error_table_$noentry          fm_data_$file_access_table_ptr




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     74 000030        77 000031        90 000032        95 000034    5   35 000036    5   36 000040    8   61 000041
     51 000044       175 000062       177 000063       178 000065       179 000067       180 000071       182 000073
    183 000077       185 000101       187 000105       189 000107       192 000110       195 000126       197 000127
    198 000131       199 000132       200 000134       201 000136       203 000140       205 000143       208 000156
    210 000157       213 000172       215 000173       216 000175       217 000176       218 000200       220 000202
    221 000206       223 000210       225 000212       230 000213       233 000226       235 000227       236 000231
    237 000233       238 000235       240 000237       241 000243       243 000245       245 000251       247 000253
    249 000254       252 000267       254 000270       255 000272       256 000274       257 000275       259 000277
    260 000303       262 000305       264 000311       266 000313       269 000314       272 000333       274 000334
    275 000335       276 000336       277 000340       278 000342       279 000344       280 000346       281 000351
    282 000353       283 000356       284 000360       286 000364       287 000366       289 000367       296 000402
    297 000403       298 000406       299 000407       300 000411       301 000413       302 000415       303 000417
    305 000421       308 000422       317 000435       318 000436       319 000441       320 000442       321 000444
    322 000445       323 000447       324 000451       326 000453       328 000454       334 000467       335 000470
    336 000473       337 000474       338 000476       339 000500       340 000502       341 000504       342 000506
    345 000507       352 000522       354 000523       358 000536       360 000541       364 000562       366 000573
    369 000604       372 000620       375 000633       378 000651       381 000663       382 000672       385 000706
    387 001013       389 001016       393 001027       395 001032       397 001037       399 001061       401 001065
    403 001066       405 001072       406 001074       408 001104       410 001127       414 001133       416 001142
    421 001153       423 001175       429 001201       431 001207       433 001210       434 001215       436 001216
    438 001220       440 001231       441 001234       445 001235       446 001261       448 001301       450 001327
    452 001336       454 001342       457 001346       460 001350       462 001353       463 001365       467 001376
    469 001405       471 001410       472 001412       474 001414       477 001416       480 001431       483 001444
    486 001456       489 001471       492 001473       495 001475       496 001477       499 001507       500 001517
    502 001524       504 001525       505 001530       507 001532       510 001547       512 001556       514 001560
    515 001561       536 001562       540 001573       543 001575       544 001577       547 001607       548 001617
    550 001624       552 001625       553 001630       555 001632       558 001647       560 001655       562 001657
    568 001660       570 001662       571 001664       572 001666       574 001670       576 001675       578 001700
    581 001701       583 001705       635 001706       518 001707       520 001710       521 001711       526 001712
    531 001714       532 001716       588 001717       593 001720       594 001722       595 001723       597 001724
    598 001726       599 001730       600 001732       601 001733       602 001735       603 001736       604 001740
    605 001741       606 001742       607 001743       609 001744       613 001745


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
