	COMPILATION LISTING OF SEGMENT im_basic_search
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/24/88  1535.8 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 /* DESCRIPTION:
       11*
       12*          This module searches the index for a specified key.  It returns the
       13*     element_id of the found key (or the element_id for the correct location
       14*     for the missing key) and the leaf_ci_header of the control interval
       15*     containing the returned element_id.
       16*
       17*     All internal subroutines have uppercase names.  If an error is
       18*     encountered in an internal subroutine, ERROR_RETURN is called directly
       19*     with the appropriate error code.  Control is not returned to the caller
       20*     of the subroutine.  Instead, a non-local transfer is performed to the
       21*     MAIN_RETURN label, following which the main procedure returns to its
       22*     caller.  For this reason, there are no error code checks after subroutine
       23*     calls.
       24*
       25*     This subroutine accesses data in a collection exclusively via direct
       26*     access, i.e., first gets a pointer to a control interval (node) by
       27*     calling collection_manager_$get_control_interval_ptr then gets elements
       28*     (keys and ci_headers) by copying the contents of the elements into local
       29*     buffers. It is imperative that a new
       30*     pointer to the current node (current_node_ptr) is gotten whenever the
       31*     current node (current_node_id) changes.  For this reason, the value of
       32*     current_node_id should never be manually changed; the subroutine
       33*     GET_NEW_NODE is called to change the value of current_node_id and get a
       34*     new current_node_ptr.  Calls to get a new node should always look like
       35*     the following:
       36*     
       37*      call GET_NEW_NODE (<new node id>, current_node_id, current_node_ptr);
       38*     
       39*     Because im_basic_search is such a heavily used routine and must be as
       40*     performant as possible, it gets elements out of control intervals
       41*     directly without calling collection_manager_.  This trade-off of
       42*     modularity in favor of performance is absolutely necessary.  Actual
       43*     knowledge of the format of a control interval is limited to the two
       44*     internal subroutines GET_CI_HEADER and GET_NEW_KEY.  These two routines
       45*     copy data out of the control interval into local buffers to avoid
       46*     problems with proper alignment.
       47*
       48*     GET_CI_HEADER and GET_NEW_KEY maintain the values of certain variables
       49*     that must be kept in synch.  The caller must co-operate by always calling
       50*     these routines in one of the following ways:
       51*     
       52*      call GET_CI_HEADER (current_node_ptr,
       53*                          current_node_id,
       54*                          common_ci_header_ptr,
       55*                          leaf_ci_header_ptr,
       56*                          branch_ci_header_ptr,
       57*                          element_id_string);
       58*     
       59*      call GET_NEW_KEY (current_node_ptr,
       60*                        current_node_id,
       61*                        <index>,
       62*                        leaf_key_ptr     | branch_key_ptr,
       63*                        lk_string_length | (0),
       64*                        (0)              | bk_string_length,
       65*                        element_id_string);
       66*
       67*     Also for performance reasons, the subroutine COMPARE_VECTOR_TO_STRING is
       68*     included in dm_comp_vec_str_proc.incl.pl1.  This routine, which is shared
       69*     by several modules, is written as an internal subroutine to eliminate the
       70*     call overhead that would be necessary were it an external routine.  This
       71*     routine takes no arguments and relies on global variables declared and
       72*     set in the main procedure to simulate parameters, again to avoid the cost
       73*     of argument list preparation.  All such pseudo-parameters are automatic
       74*     variables prefixed with the string "cvs_p_".
       75**/
       76 
       77 /* HISTORY:
       78*
       79*Written by Lindsey Spratt, 03/28/82.
       80*Modified:
       81*04/22/82 by Lindsey Spratt: Added capability to deal with branch keys which
       82*	  have fewer than the full set of fields.
       83*05/26/82 by Lindsey Spratt: Changed calculation of new current_idx when vector
       84*	  is greater than the key to add the mod(current_idx + high_idx, 2)
       85*	  instead of just adding "1".  The old technique gave a result one
       86*	  too great when (current_idx + high_idx) was a multiple of two.
       87*06/21/82 by Lindsey Spratt: Changed name from im_search_$location to
       88*	  im_basic_search.  Added p_want_* flags to calling sequence, to
       89*	  support the im_structural_search routine.  Added case statement to
       90*	  determine what value to return for the p_key_id, based on the
       91*	  vector_*key flags and the p_want_* flags.
       92*07/26/82 by Lindsey Spratt:  Added the duplicate-field-filtering feature and
       93*	  extended the search algorithm to allow for "degenerate" branch
       94*	  nodes, those with no keys.
       95*08/09/82 by Matthew Pierret:  Changed calling sequence of 
       96*            collection_manager_$get_element to not use offset and length.
       97*08/27/82 by Lindsey Spratt:  Added p_is_relative_search and
       98*	  p_position_stack_ptr to calling sequence.  Changed to use local
       99*	  variable "first_idx" instead of referencing key_range.first
      100*	  directly as part of implementing "relative" searches.  The
      101*	  position_stack is only modified/used by im_basic_search, it is
      102*	  held by im_basic_search's caller, though, to make it so that this
      103*	  module only needs to calculate the position_stack once in a series
      104*	  of searches.
      105*09/13/82 by Lindsey Spratt:  Added check of the parent thread.  Rebuilt the
      106*	  search algorithm for branch nodes.
      107*10/20/82 by Lindsey Spratt:  Changed the leaf_node key search to be the same
      108*	  algorithm as that used for branch nodes.  Corrected the algorithm
      109*	  for the case where the search vector is equal to more than one key
      110*	  (in either a branch or leaf node).  If a key is desired which is
      111*	  <= the vector, or > the vector, then the rightmost (highest) key =
      112*	  the vector must be located.  If a key is desired which is >=
      113*	  the vector, or < the vector, then the leftmost (lowest) key = the
      114*	  vector must be located.
      115*10/27/82 by Lindsey Spratt:  Moved get_new_key to top of LEAF_KEY_LOOP.
      116*11/03/82 by Lindsey Spratt:  Added code to catch the case where an exact match
      117*	  is being sought and when exiting from the leaf loop it
      118*	  is the key identified by the high_idx, not the current_idx (which
      119*	  equals low_idx). 
      120*11/04/82 by Lindsey Spratt:  Added the insertion entry point, to be called by
      121*	  im_put_key.
      122*11/15/82 by Matthew Pierret: Added code to catch the case where an exact match
      123*	  is being sought and when exiting from the leaf loop it is equal
      124*            to the vector and is the first key.
      125*11/19/82 by Matthew Pierret: Changed to use buffered control interval
      126*            technology. To reduce on calls to file_manager_ (by 
      127*            collection_manager_) and on copying of data, when a node is to be
      128*            searched the whole node is retrieved into a local buffer by calling
      129*            cm_$setup_buffered_ci. Elements are then retrieved from that buffer
      130*            using cm_$get_element_buffered.
      131*            Also made current_node_id, parent_node_id, less_branch_id unsigned.
      132*01/19/83 by Lindsey Spratt:  Fixed to correctly set the p_key_id when working
      133*	  with the first key of a CI.  It was testing current_idx, which may
      134*	  be one greater or less  than the last key tested, whose slot index
      135*	  is accurately recorded in element_id.index.  Added some logic to
      136*	  check for the "low" limit when doing relative searching and trying
      137*	  to set the p_key_id one less than the element_id.index value.
      138*01/25/83 by Lindsey Spratt:  Fixed to set the parent_idx correctly when the
      139*	  "found" key is the first key in the CI, it is equal to the vector
      140*	  (hence, first_inequal_field_id >
      141*	  simple_typed_vector.number_of_dimensions), and the caller wants
      142*	  keys  ">=" to the vector.  The correct value is =
      143*	  key_range.first, it was being set to key_range.first - 1.
      144*02/23/83 by Lindsey Spratt: Added a new entry, $reposition, to support
      145*	  automatic re-positioning of cursors when they are found to have
      146*	  become invalid.  Added support for the version 3 cursor, which
      147*	  includes the ability for the cursor to have any combination of the
      148*	  the three possible operations (current, next, previous) be defined
      149*	  and the remaining operations be invalid for a given cursor.
      150*	       Changed the calling sequences to use the index_opening_info
      151*	  structure.
      152*03/02/83 by Lindsey Spratt:  Fixed execution path for $reposition entry to not
      153*	  reference the simple_typed_vector.
      154*03/07/83 by Lindsey Spratt:  Fixed the position_stack initialization to get
      155*	  the stack in the right order when doing a top_down init.  Also,
      156*	  fixed position_stack init to consistently set the id_string.index
      157*	  value to be the first (or leftmost) valid key slot; it was being
      158*	  set to be one to the left of the the first valid key slot on some
      159*	  occasions.
      160*03/24/83 by Lindsey Spratt:  Changed im_compare* to data_mgmt_util_$compare*.
      161*	  Was changed to use field_table version 2.
      162*04/09/83 by Lindsey L. Spratt:  Changed the post-BRANCH_KEY_LOOP
      163*	  interpretation of the comparison of the "vector" and the key.  If
      164*	  they compared equal, but the vector is shorter than the key, then
      165*	  the comparison is reinterpreted to be "less-than".
      166*05/02/83 by Lindsey L. Spratt:  Fixed a bug in the setting of the first_idx
      167*            for a branch node when doing a relative search.
      168*07/12/83 by Matthew Pierret:  Changed to set up the current node when the 
      169*            position_stack does not need to be set up for a relative search.
      170*07/13/83 by Matthew Pierret:  Changed all internal subroutine names to be 
      171*            uppercase. Adopted the convention of prefixing variable names 
      172*            declared in subroutines with the initials of the subroutine.
      173*            Added an ERROR_RETURN subroutine which takes an error code, sets
      174*            p_code to the value of the error code, and non-locally goes to
      175*            the return statement in the main procedure. Changed all subroutines
      176*            to call ERROR_RETURN when encountering an error and removed passing
      177*            of error codes, allowing callers of subroutines to assume that if
      178*            control is returned, no errors were encountered.
      179*03/14/84 by Lindsey L. Spratt:  Fixed GET_*CI_HEADER programs to allow for
      180*            branch CI's with key_range.first = key_range.last = 0.
      181*03/23/84 by Matthew Pierret:  Changed to get a pointer to a control interval
      182*            (node) in a file instead of setting up a CI buffer. Converted all
      183*            file access to this direct access method, including those that
      184*            were previously buffered and those that were previously standard.
      185*            Changed all modifications of the value of current_node_id to be 
      186*            done by the subroutine GET_NEW_NODE, which sets current_node_id and
      187*            current_node_ptr synchronously. Removed SETUP_NODE_BUFFER,
      188*            GET_NEW_BUFFERED_KEY and GET_BUFFERED_CI_HEADER.
      189*04/09/84 by Matthew Pierret:  Changed to access control intervals directly
      190*            instead of calling collection_manager_$simple_get_buffered_element.
      191*            This means that the subroutines GET_CI_HEADER and GET_NEW_KEY now
      192*            have sufficient knowledge about the format of control intervals to
      193*            find where keys and headers are stored.  This drastic step is taken
      194*            because this module is in a critical path and its performance is
      195*            very important to performance of the index_manager_. Also changed
      196*            these two subroutines to be completely parameterized.
      197*04/20/84 by Matthew Pierret:  Changed calls to
      198*            data_format_util_$compare_vector_to_string to be calls to the
      199*            internal subroutine COMPARE_VECTOR_TO_STRING, which is contained
      200*            in the include file dm_comp_vec_str_proc.incl.pl1.  Changed the
      201*            names of variables which were passed to dfu_$cvts to the names
      202*            expected by COMPARE_VECTOR_TO_STRING as global variables
      203*            simulating parameters.
      204*05/04/84 by Matthew Pierret:  Changed to FIELD_TABLE_VERSION_3.
      205*05/10/84 by Matthew Pierret:  Changed to align local_key_buffer on an even
      206*            word boundary.  Changed references to data_mgmt_util_ to be to
      207*            data_format_util_.
      208*05/23/84 by Lindsey L. Spratt:  Fixed a reference to field_table.version in a
      209*            sub_err_ call to use the cvs_p_field_table_ptr as it was supposed
      210*            to.
      211*10/12/84 by Matthew Pieret:  Changed to use the new dm_cm_basic_ci and
      212*            dm_cm_basic_ci_const include files.
      213*10/28/84 by Lindsey L. Spratt:  Changed to use version 2 index_opening_info,
      214*            and version 4 index_header.  Added some internal procedures to
      215*            help clarify the top level algorithm.
      216*10/30/84 by Lindsey L. Spratt:  Introduced the only_want_key_equal_to_vector
      217*            and want_highest_equal_key flags, derived from the other want_*
      218*            flags.  Remodularized the ANALYZE_RESULTS internal proc.
      219*11/08/84 by Lindsey L. Spratt:  Added documentation to the internal
      220*            procedures.  Moved the local variable initialization into an
      221*            internal program.
      222*11/14/84 by Lindsey L. Spratt:  Change REPOSITION_CURSOR to use its rp_code
      223*            instead of the global code variable.  Added the failed_exact_match
      224*            flag.  Changed REPORT_PREVIOUS_KEY to set the p_key_id.index to 0
      225*            when there is no previous key.  Fixed INIT_POSITION_STACK to do a
      226*            RETURN when the "least key" is after the end of the index and
      227*            therefore no searching is possible.  Changed INIT_POSITION_STACK
      228*            to use its own ips_code instead of the global code variable.
      229*            Fixed the setting of only_want_key_equal_to_vector.
      230*01/10/85 by Lindsey L. Spratt:  Changed the position_stack inversion in the
      231*            INIT_TOP_DOWN block of INIT_POSITION_STACK to only loop through
      232*            half of the position_stack.  As it was, the stack was being
      233*            inverted twice.  Changed SKIP_DEGENERATE_NODE to use
      234*            current_depth=max(current_depth -1,1) rather than just
      235*            "=current_depth".
      236*	  Fixed parent_idx setting in FIND_NEXT_BRANCH.
      237*02/15/85 by Lindsey L. Spratt:  Changed test after BRANCH_KEY_LOOP in
      238*	  FIND_NEXT_BRANCH to be "cvs_p_vector_less_than_key |
      239*	  ^want_highest_equal_key" instead of "cvs_p_vector_less_than_key |
      240*	  cvs_p_first_inequal_field_id <= number_of_fields_in_vector |
      241*	  want_highest_equal_key".
      242*03/07/85 by R. Michael Tague:  Changed opening info version to version 3.
      243*04/19/85 by Lindsey L. Spratt:  Fixed two problems with relative searches.
      244*            INIT_POSITION was setting element_id.control_interval_id at one
      245*            point in INIT_TOP_DOWN where it should have been setting
      246*            element_id.index.  FIND_LEAF_NODE, at the end of the
      247*            BRANCH_NODE_LOOP, was incorrectly setting the first_idx when the
      248*            current_node_id = position_stack.id_string.control_interval_id.
      249*            The proc SET_RELATIVE_FIRST_IDX has been created for setting the
      250*            first_idx in this case, and SETUP_FIRST_NODE and FIND_LEAF_NODE
      251*            changed to use it.
      252*           Fixed REPORT_PREVIOUS_KEY to always check for the previous key
      253*            being before the logical beginning of the index, as defined by the
      254*            position_stack, when doing a relative search.
      255**/
      256 
      257 /****^  HISTORY COMMENTS:
      258*  1) change(87-05-06,Dupuis), approve(87-05-29,MCR7695), audit(87-06-02,Blair),
      259*     install(87-07-17,MR12.1-1042):
      260*     Changed the buffer alignment so that branch_key.string would be on a
      261*     double-word boundary. The key string was being aligned on an odd-word
      262*     boundary and this was causing bad comparisons when dealing with fields
      263*     that needed to be aligned on double-word boundaries.
      264*  2) change(87-11-19,Dupuis), approve(87-12-11,MCR7812), audit(87-12-11,Blair),
      265*     install(88-01-12,MR12.2-1012):
      266*     Changed the CURRENT_KEY_SATISFIES_CONSTRAINTS internal proc to correct
      267*     phx20998. When the vector was less than the key, but the number of fields
      268*     matching was equal to the index_header.number_of_duplication_fields, the
      269*     subroutine was determining that they weren't equal. This wasn't true,
      270*     because the tuple ids were the only fields that were inequal.
      271*  3) change(88-06-24,Dupuis), approve(88-08-31,MCR7974), audit(88-09-01,Blair),
      272*     install(88-09-06,MR12.2-1099):
      273*     Changed the FIND_NEXT_BRANCH to correctly get the correct branch in all
      274*     cases. See phx21803 for complete details.
      275*                                                   END HISTORY COMMENTS */
      276 
      277 
      278 /* format: style2,ind3 */
      279 
      280 im_basic_search:
      281    proc (p_index_opening_info_ptr, p_index_cursor_ptr, p_is_relative_search, p_position_stack_ptr,
      282         p_want_key_equal_to_vector, p_want_keys_greater_than_vector, p_want_keys_less_than_vector, p_typed_vector_ptr,
      283         p_key_id_string, p_leaf_ci_header_ptr, p_code);
      284 
      285 /* START OF DECLARATIONS */
      286 /* Parameter */
      287 
      288       dcl	    p_index_opening_info_ptr
      289 			       ptr parameter;
      290       dcl	    p_index_cursor_ptr     ptr parameter;
      291       dcl	    p_is_relative_search   bit (1) aligned parameter;
      292       dcl	    p_position_stack_ptr   ptr parameter;
      293       dcl	    (p_want_key_equal_to_vector, p_want_keys_less_than_vector, p_want_keys_greater_than_vector)
      294 			       bit (1) aligned parameter;
      295       dcl	    p_typed_vector_ptr     ptr parameter;
      296       dcl	    p_key_id_string	       bit (36) aligned parameter;
      297       dcl	    p_leaf_ci_header_ptr   ptr parameter;
      298       dcl	    p_maximum_duplication_field
      299 			       fixed bin parameter;
      300       dcl	    p_key_string_ptr       ptr parameter;
      301       dcl	    p_key_string_length    fixed bin (24) parameter;
      302       dcl	    p_code	       fixed bin (35) parameter;
      303 
      304 /* Automatic */
      305 
      306       dcl	    cvs_p_field_table_ptr  ptr;
      307       dcl	    cvs_p_simple_typed_vector_ptr
      308 			       ptr;
      309       dcl	    cvs_p_key_string_ptr   ptr;
      310       dcl	    cvs_p_key_string_length
      311 			       fixed bin (35);
      312       dcl	    cvs_p_last_field_idx   fixed bin (17);
      313       dcl	    cvs_p_first_inequal_field_id
      314 			       fixed bin (17);
      315       dcl	    cvs_p_vector_equal_to_key
      316 			       bit (1) aligned;
      317       dcl	    cvs_p_vector_less_than_key
      318 			       bit (1) aligned;
      319       dcl	    cvs_p_code	       fixed bin (35);
      320 
      321       dcl	    (want_key_equal_to_vector, want_keys_greater_than_vector, want_keys_less_than_vector,
      322 	    only_want_key_equal_to_vector, want_highest_equal_key, is_relative_search, is_reposition, is_insertion,
      323 	    failed_exact_match)    bit (1) aligned init ("0"b);
      324       dcl	    position_stack_ptr     ptr init (null);
      325       dcl	    (high_duplication_field, low_duplication_field)
      326 			       fixed bin init (0);
      327 
      328       dcl	    is_first_pass_through_loop
      329 			       bit (1) aligned;
      330 
      331       dcl	    current_depth	       fixed bin init (0);
      332       dcl	    first_idx	       fixed bin;
      333       dcl	    equal_idx	       fixed bin init (0);
      334       dcl	    low_idx	       fixed bin;
      335       dcl	    high_idx	       fixed bin;
      336       dcl	    current_idx	       fixed bin;
      337       dcl	    parent_idx	       fixed bin init (-1);
      338       dcl	    depth_idx	       fixed bin (17) init (0);
      339 
      340       dcl	    number_of_fields_in_vector
      341 			       fixed bin (35) init (0);
      342 
      343       dcl	    parent_node_id	       fixed bin (24) unsigned init (0);
      344       dcl	    current_node_id	       fixed bin (24) unsigned;
      345       dcl	    less_branch_id	       fixed bin (24) unsigned;
      346 
      347       dcl	    key_id_ptr	       ptr;
      348       dcl	    current_node_ptr       ptr;
      349 
      350       dcl	    local_header_buffer    bit (max (LEAF_CI_HEADER_LENGTH_IN_BITS, BRANCH_CI_HEADER_LENGTH_IN_BITS)) aligned;
      351       dcl	    local_key_buffer       (DOUBLE_WORDS_PER_PAGE) fixed bin (71);
      352       dcl	    local_key_id_string    bit (36) aligned init ("0"b);
      353       dcl	    temp_id_string	       bit (36) aligned init ("0"b);
      354 
      355 /* Based */
      356 
      357       dcl	    1 position_stack       aligned based (position_stack_ptr),
      358 	      2 depth	       fixed bin (17),
      359 	      2 id_string	       (10) bit (36) aligned;
      360 
      361       dcl	    1 p_key_id	       like element_id based (key_id_ptr);
      362 
      363 /* Builtin */
      364 
      365       dcl	    (addcharno, addr, addrel, ceil, divide, length, max, null, string, unspec)
      366 			       builtin;
      367 
      368 /* Controlled */
      369 /* Constant */
      370 
      371       dcl	    (
      372 	    ALL_FIELDS_ARE_PRESENT init (-1),
      373 	    BYTES_PER_WORD	       init (4),
      374 	    BITS_PER_BYTE	       init (9),
      375 	    DOUBLE_WORDS_PER_PAGE  init (512)
      376 	    )		       fixed bin (17) unal internal static options (constant);
      377       dcl	    myname	       init ("im_basic_search") char (16) internal static options (constant);
      378 
      379 /* Entry */
      380 
      381       dcl	    im_validate_cursor     entry (ptr, ptr, fixed bin (35));
      382       dcl	    data_format_util_$compare_string_to_string
      383 			       entry (ptr, ptr, fixed bin (24), ptr, fixed bin (24), fixed bin unal, fixed bin,
      384 			       bit (1) aligned, bit (1) aligned, fixed bin (35));
      385 
      386       dcl	    im_set_cursor$at_current
      387 			       entry (ptr, bit (36) aligned, ptr, fixed bin (24), fixed bin (35));
      388       dcl	    im_set_cursor$no_current
      389 			       entry (ptr, bit (36) aligned, ptr, fixed bin (24), fixed bin (35));
      390       dcl	    im_set_cursor$at_beginning
      391 			       entry (ptr, bit (36) aligned, ptr, fixed bin (24), fixed bin (35));
      392       dcl	    im_set_cursor$at_end   entry (ptr, bit (36) aligned, ptr, fixed bin (24), fixed bin (35));
      393 
      394       dcl	    sub_err_	       entry options (variable);
      395 
      396 /* External */
      397 
      398       dcl	    (
      399 	    error_table_$unimplemented_version,
      400 	    vd_error_$wrong_type,
      401 	    dm_error_$key_not_found,
      402 	    dm_error_$bad_first_key_idx,
      403 	    dm_error_$bad_last_key_idx,
      404 	    dm_error_$bad_parent_thread,
      405 	    dm_error_$long_return_element,
      406 	    dm_error_$no_element,
      407    	    dm_error_$programming_error
      408 	    )		       fixed bin (35) ext;
      409 
      410 /* END OF DECLARATIONS */
      411 
      412       want_key_equal_to_vector = p_want_key_equal_to_vector;
      413       want_keys_less_than_vector = p_want_keys_less_than_vector;
      414       want_keys_greater_than_vector = p_want_keys_greater_than_vector;
      415       is_relative_search = p_is_relative_search;
      416       position_stack_ptr = p_position_stack_ptr;
      417       cvs_p_simple_typed_vector_ptr = p_typed_vector_ptr;
      418       if cvs_p_simple_typed_vector_ptr -> simple_typed_vector.type ^= SIMPLE_TYPED_VECTOR_TYPE
      419       then call sub_err_ (vd_error_$wrong_type, myname, ACTION_CANT_RESTART, null, 0,
      420 	      "^/Expected a simple_typed_vector, type ^d, structure. Received type ^d.", SIMPLE_TYPED_VECTOR_TYPE,
      421 	      cvs_p_simple_typed_vector_ptr -> simple_typed_vector.type);
      422 
      423       key_id_ptr = addr (p_key_id_string);
      424       goto JOIN;
      425 
      426 insert:
      427    entry (p_index_opening_info_ptr, p_index_cursor_ptr, p_typed_vector_ptr, p_key_id_string, p_maximum_duplication_field,
      428         p_leaf_ci_header_ptr, p_code);
      429       is_insertion = "1"b;
      430       want_key_equal_to_vector = "1"b;
      431       want_keys_less_than_vector = "0"b;
      432       want_keys_greater_than_vector = "0"b;
      433       is_relative_search = "0"b;
      434       position_stack_ptr = null;
      435       cvs_p_simple_typed_vector_ptr = p_typed_vector_ptr;
      436       if cvs_p_simple_typed_vector_ptr -> simple_typed_vector.type ^= SIMPLE_TYPED_VECTOR_TYPE
      437       then call sub_err_ (vd_error_$wrong_type, myname, "s", null, 0,
      438 	      "^/Expected a simple_typed_vector, type ^d, structure. Received type ^d.", SIMPLE_TYPED_VECTOR_TYPE,
      439 	      cvs_p_simple_typed_vector_ptr -> simple_typed_vector.type);
      440 
      441       key_id_ptr = addr (p_key_id_string);
      442       goto JOIN;
      443 
      444 reposition:
      445    entry (p_index_opening_info_ptr, p_index_cursor_ptr, p_key_string_ptr, p_key_string_length, p_code);
      446       index_opening_info_ptr = p_index_opening_info_ptr;
      447 
      448       key_id_ptr = addr (local_key_id_string);
      449       local_key_id_string = p_index_cursor_ptr -> index_cursor.key_id_string;
      450 
      451       is_reposition = "1"b;
      452       want_key_equal_to_vector = "1"b;
      453       want_keys_less_than_vector = "0"b;
      454       want_keys_greater_than_vector = "0"b;
      455       is_relative_search = "0"b;
      456       position_stack_ptr = null;
      457       cvs_p_simple_typed_vector_ptr = null;
      458       goto JOIN;
      459 
      460 JOIN:
      461       call INITIALIZE_LOCAL_VARIABLES ();
      462 
      463       call SETUP_FIRST_NODE ();
      464 
      465       if ^common_ci_header.is_leaf
      466       then call FIND_LEAF_NODE ();
      467 
      468       call FIND_LEAF_KEY ();
      469 
      470       call ANALYZE_RESULTS ();
      471 
      472       if is_reposition
      473       then call REPOSITION_CURSOR ();
      474       else if p_leaf_ci_header_ptr ^= null
      475       then p_leaf_ci_header_ptr -> leaf_ci_header = leaf_ci_header;
      476 
      477 
      478       if failed_exact_match | p_key_id.index = 0
      479       then call ERROR_RETURN (dm_error_$key_not_found);
      480       else call RETURN ();
      481 
      482 MAIN_RETURN:
      483       return;
      484 
      485 RETURN:
      486    proc ();
      487       p_code = 0;
      488       goto MAIN_RETURN;
      489    end RETURN;
      490 
      491 
      492 ERROR_RETURN:
      493    proc (er_code);
      494 
      495       dcl	    er_code	       fixed bin (35);
      496 
      497       p_code = er_code;
      498       goto MAIN_RETURN;
      499 
      500    end ERROR_RETURN;
      501 
      502 /* Internal procedure description:
      503*
      504*          This program decides how to report the results of the search
      505*     through the index.  The global variables which are its "output" are:
      506*     code, p_key_id, and p_maximum_duplication_field.
      507**/
      508 
      509 ANALYZE_RESULTS:
      510    proc ();
      511 
      512       if CURRENT_KEY_SATISFIES_CONSTRAINTS ()
      513       then p_key_id = element_id;
      514       else if only_want_key_equal_to_vector
      515       then call REPORT_FAILED_EXACT_MATCH ();
      516       else if want_keys_greater_than_vector
      517       then call REPORT_NEXT_KEY ();
      518       else call REPORT_PREVIOUS_KEY ();
      519    end ANALYZE_RESULTS;
      520 
      521 
      522 
      523 /* Internal procedure description:
      524*
      525*          This program verifies that the current node's recorded parent key is
      526*     the same key as the one from which the search just came.  If not, there
      527*     is a problem in the structure of the index.
      528**/
      529 
      530 CHECK_PARENT_THREAD:
      531    proc (cpt_parent_node_id, cpt_parent_idx, cpt_header_parent_id_string);
      532 
      533       dcl	    cpt_parent_node_id     fixed bin (24) unsigned;
      534       dcl	    cpt_parent_idx	       fixed bin;
      535       dcl	    cpt_header_parent_id_string
      536 			       bit (36) aligned;
      537 
      538 
      539       if addr (cpt_header_parent_id_string) -> element_id.control_interval_id ^= cpt_parent_node_id
      540 	 | addr (cpt_header_parent_id_string) -> element_id.index ^= cpt_parent_idx
      541       then call sub_err_ (dm_error_$bad_parent_thread, myname, "h", null, 0,
      542 	      "^/The child node's recorded parent is node ^d, slot index ^d.
      543 The actual parent is node ^d, slot index ^d.", addr (cpt_header_parent_id_string) -> element_id.control_interval_id,
      544 	      addr (cpt_header_parent_id_string) -> element_id.index, cpt_parent_node_id, cpt_parent_idx);
      545 
      546    end CHECK_PARENT_THREAD;
      547 
      548 
      549 
      550 CHECK_VERSION:
      551    proc (p_received_version, p_expected_version, p_structure_name);
      552       dcl	    p_received_version     char (8) aligned parameter;
      553       dcl	    p_expected_version     char (8) aligned parameter;
      554       dcl	    p_structure_name       char (*);
      555 
      556       if p_received_version ^= p_expected_version
      557       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      558 	      "^/Expected version ^a of the ^a structure.
      559 Received version ^a instead.", p_expected_version, p_structure_name, p_received_version);
      560 
      561    end CHECK_VERSION;
      562 
      563 
      564 
      565 /* Internal procedure description:
      566*
      567*          This program determines if the key pointed at at the end of the
      568*     search is a key which satisfies the caller's search constraints.
      569**/
      570 
      571 CURRENT_KEY_SATISFIES_CONSTRAINTS:
      572    proc () returns (bit (1) aligned);
      573 
      574       if is_insertion
      575       then if cvs_p_first_inequal_field_id > index_header.number_of_duplication_fields
      576 	 | cvs_p_vector_equal_to_key
      577 	 then return (want_key_equal_to_vector);
      578 
      579       if cvs_p_vector_less_than_key
      580       then return (want_keys_greater_than_vector);
      581       else if cvs_p_vector_equal_to_key | cvs_p_first_inequal_field_id > index_header.number_of_duplication_fields
      582       then return (want_key_equal_to_vector);
      583       else return (want_keys_less_than_vector);
      584 
      585    end CURRENT_KEY_SATISFIES_CONSTRAINTS;
      586 
      587 /* Internal procedure description:
      588*
      589*          This program determines if the desired leaf key
      590*     is present in the current leaf node (located by FIND_LEAF_NODE).
      591**/
      592 
      593 FIND_LEAF_KEY:
      594    proc ();
      595       cvs_p_vector_equal_to_key = "0"b;
      596 
      597       low_idx = first_idx - 1;
      598       high_idx = leaf_ci_header.common.key_range.last + 1;
      599       current_idx = divide (low_idx + high_idx, 2, 17, 0);
      600 
      601       cvs_p_last_field_idx = ALL_FIELDS_ARE_PRESENT;
      602       cvs_p_first_inequal_field_id = index_header.number_of_duplication_fields;
      603 
      604 LEAF_KEY_LOOP:
      605       do while (cvs_p_first_inequal_field_id <= index_header.number_of_duplication_fields & current_idx ^= low_idx);
      606 
      607          call GET_NEW_KEY (current_node_ptr, current_node_id, current_idx, cvs_p_key_string_ptr, cvs_p_key_string_length,
      608 	    (0), element_id_string);
      609 
      610          if is_reposition
      611          then call data_format_util_$compare_string_to_string (cvs_p_field_table_ptr, p_key_string_ptr,
      612 	         p_key_string_length, cvs_p_key_string_ptr, (cvs_p_key_string_length), (cvs_p_last_field_idx),
      613 	         cvs_p_first_inequal_field_id, cvs_p_vector_equal_to_key, cvs_p_vector_less_than_key, cvs_p_code);
      614          else call COMPARE_VECTOR_TO_STRING ();
      615 
      616          if cvs_p_code ^= 0
      617          then call ERROR_RETURN (cvs_p_code);
      618 
      619          if cvs_p_first_inequal_field_id <= index_header.number_of_duplication_fields
      620          then
      621 	  do;
      622 	     if cvs_p_vector_less_than_key
      623 	     then
      624 	        do;
      625 		 high_duplication_field = cvs_p_first_inequal_field_id - 1;
      626 		 high_idx = current_idx;
      627 		 current_idx = divide (low_idx + current_idx, 2, 17, 0);
      628 	        end;
      629 	     else if cvs_p_first_inequal_field_id <= number_of_fields_in_vector
      630 						/* Vector is greater than key, in some field which was tested. */
      631 	     then
      632 	        do;
      633 		 low_duplication_field = cvs_p_first_inequal_field_id - 1;
      634 		 low_idx = current_idx;
      635 		 current_idx = divide (high_idx + current_idx, 2, 17, 0);
      636 	        end;
      637 	     else if want_highest_equal_key		/* For all tested fields, vector = key. */
      638 	     then
      639 	        do;				/* Find the highest key such that  the key <= vector. */
      640 		 low_idx = current_idx;
      641 		 current_idx = divide (high_idx + current_idx, 2, 17, 0);
      642 	        end;
      643 	     else
      644 	        do;				/* Find the lowest key such that the key >= vector. */
      645 		 equal_idx = current_idx;		/* Record that the current key exactly matches the vector. */
      646 		 high_idx = current_idx;
      647 		 current_idx = divide (low_idx + current_idx, 2, 17, 0);
      648 	        end;
      649 	  end;
      650       end LEAF_KEY_LOOP;
      651 
      652       if current_idx < first_idx			/* Vector is less than all of the keys in the leaf ci. */
      653       then if current_idx + 1 = equal_idx & only_want_key_equal_to_vector
      654 	 then
      655 	    do;
      656 	       current_idx = equal_idx;
      657 	       cvs_p_vector_less_than_key = "0"b;
      658 	       cvs_p_vector_equal_to_key = "1"b;
      659 	       element_id.index = current_idx;
      660 	    end;
      661 	 else
      662 	    do;
      663 	       cvs_p_vector_less_than_key = "1"b;
      664 	       cvs_p_vector_equal_to_key = "0"b;
      665 	       current_idx = first_idx;
      666 	       element_id.index = current_idx;
      667 	    end;
      668       else if ^(cvs_p_vector_less_than_key | cvs_p_vector_equal_to_key) & current_idx + 1 = equal_idx
      669 	 & only_want_key_equal_to_vector
      670       then
      671          do;
      672 	  current_idx = equal_idx;
      673 	  cvs_p_vector_less_than_key = "0"b;
      674 	  cvs_p_vector_equal_to_key = "1"b;
      675 	  element_id.index = current_idx;
      676          end;
      677    end FIND_LEAF_KEY;
      678 
      679 /* Internal procedure description:
      680*
      681*          This program, given a branch node, finds the leaf node which should
      682*     contain the desired leaf key.
      683**/
      684 
      685 FIND_LEAF_NODE:
      686    proc ();
      687 BRANCH_NODE_LOOP:
      688       do while (^common_ci_header.is_leaf);
      689 
      690          if is_relative_search
      691          then if addr (position_stack.id_string (current_depth)) -> element_id.control_interval_id = current_node_id
      692 	    then
      693 	       do;
      694 		current_idx = addr (position_stack.id_string (current_depth)) -> element_id.index;
      695 		if current_idx > 0
      696 		then
      697 		   do;
      698 		      call GET_NEW_KEY (current_node_ptr, current_node_id, current_idx, branch_key_ptr, (0),
      699 			 bk_string_length, element_id_string);
      700 		      less_branch_id = branch_key.branch_id;
      701 		   end;
      702 		else less_branch_id = branch_ci_header.low_branch_id;
      703 	       end;
      704 	    else less_branch_id = branch_ci_header.low_branch_id;
      705          else less_branch_id = branch_ci_header.low_branch_id;
      706 						/* The low_idx identifies the highest "key" which is */
      707 						/* less than or equal to the vector.  To begin with, */
      708 						/* this is the non-existant key before the first key */
      709 						/* of the node. */
      710          low_idx = first_idx - 1;			/* The high_idx identifies the lowest key which is */
      711 						/* greater than vector.  To begin with, this is the */
      712 						/* non-existant key after the last key of the node. */
      713          high_idx = branch_ci_header.common.key_range.last + 1;
      714 
      715          current_idx = divide (low_idx + high_idx, 2, 17, 0);
      716 
      717          call FIND_NEXT_BRANCH ();
      718 
      719          if is_relative_search
      720          then current_depth = max (current_depth - 1, 1);
      721 
      722 
      723          call GET_CI_HEADER (current_node_ptr, current_node_id, common_ci_header_ptr, leaf_ci_header_ptr,
      724 	    branch_ci_header_ptr, element_id_string);
      725 
      726          call CHECK_PARENT_THREAD (parent_node_id, parent_idx, common_ci_header.parent_id_string);
      727 
      728          call SKIP_DEGENERATE_NODES ();
      729 
      730          if is_relative_search
      731          then if current_node_id = addr (position_stack.id_string (current_depth)) -> element_id.control_interval_id
      732 	    then call SET_RELATIVE_FIRST_IDX (position_stack_ptr, common_ci_header_ptr, first_idx);
      733 	    else first_idx = common_ci_header.key_range.first;
      734          else first_idx = common_ci_header.key_range.first;
      735 
      736       end BRANCH_NODE_LOOP;
      737 
      738    end FIND_LEAF_NODE;
      739 
      740 /* Internal procedure description:
      741*
      742*          This program, given a branch node, finds the next branch node
      743*     indicated by the keys in the given branch node.  Its search algorithm is
      744*     similar to that used for finding a leaf key in a leaf node
      745*     (FIND_LEAF_KEY).
      746**/
      747 
      748 FIND_NEXT_BRANCH:
      749    proc ();
      750 
      751       is_first_pass_through_loop = "1"b;
      752 
      753 /* if the first_idx is after the end of the key_range, then skip to the next CI. */
      754 
      755       if first_idx < high_idx
      756       then
      757 BRANCH_KEY_LOOP:
      758          do while (current_idx ^= low_idx | is_first_pass_through_loop);
      759 	  is_first_pass_through_loop = "0"b;
      760 
      761 	  call GET_NEW_KEY (current_node_ptr, current_node_id, current_idx, branch_key_ptr, (0), bk_string_length,
      762 	       element_id_string);
      763 
      764 	  if is_reposition
      765 	  then call data_format_util_$compare_string_to_string (cvs_p_field_table_ptr, p_key_string_ptr,
      766 		  p_key_string_length, addr (branch_key.string), length (branch_key.string),
      767 		  (branch_key.last_field_idx), cvs_p_first_inequal_field_id, cvs_p_vector_equal_to_key,
      768 		  cvs_p_vector_less_than_key, cvs_p_code);
      769 	  else
      770 	     do;
      771 	        cvs_p_key_string_ptr = addr (branch_key.string);
      772 	        cvs_p_key_string_length = length (branch_key.string);
      773 	        cvs_p_last_field_idx = branch_key.last_field_idx;
      774 
      775 	        call COMPARE_VECTOR_TO_STRING ();
      776 	     end;
      777 	  if cvs_p_code ^= 0
      778 	  then call ERROR_RETURN (cvs_p_code);
      779 
      780 	  if cvs_p_vector_less_than_key
      781 	  then
      782 	     do;
      783 	        high_idx = current_idx;
      784 	        current_idx = divide (low_idx + current_idx, 2, 17, 0);
      785 	     end;
      786 	  else if cvs_p_first_inequal_field_id <= number_of_fields_in_vector
      787 	  then
      788 	     do;
      789 	        low_idx = current_idx;
      790 	        less_branch_id = branch_key.branch_id;
      791 	        current_idx = divide (high_idx + current_idx, 2, 17, 0);
      792 	     end;
      793 	  else if want_highest_equal_key
      794 	  then
      795 	     do;
      796 	        low_idx = current_idx;
      797 	        less_branch_id = branch_key.branch_id;
      798 	        current_idx = divide (high_idx + current_idx, 2, 17, 0);
      799 	     end;
      800 	  else
      801 	     do;
      802 	        if ^(cvs_p_vector_equal_to_key & want_key_equal_to_vector)
      803 	        then call sub_err_ (dm_error_$programming_error, myname, ACTION_CANT_RESTART, null, 0,
      804 		   "The vector and the key should have been equal.");
      805 	        if want_key_equal_to_vector & want_keys_greater_than_vector
      806 	        then do;
      807 		   high_idx = current_idx;
      808 		   current_idx = divide (low_idx + current_idx, 2, 17, 0);
      809 	        end;
      810 	        else do;
      811 		   low_idx = current_idx;
      812 		   less_branch_id = branch_key.branch_id;
      813 	        end;
      814 	     end;
      815 
      816          end BRANCH_KEY_LOOP;
      817 
      818       if cvs_p_vector_less_than_key | ^want_highest_equal_key
      819       then
      820          do;
      821 	  parent_idx = current_idx;
      822 	  if parent_idx < common_ci_header.key_range.first
      823 	  then parent_idx = 0;
      824 	  parent_node_id = current_node_id;
      825 	  call GET_NEW_NODE (less_branch_id, current_node_id, current_node_ptr);
      826          end;
      827       else
      828          do;
      829 
      830 /* current_idx is not used here to set parent_idx because it can be 1
      831*slot lower than the actual parent slot (if the case which caused the
      832*exit from the above loop was the ^want_highest_equal_key case).
      833*element_id.index is always the index of the last key actually inspected.
      834**/
      835 	  parent_idx = element_id.index;
      836 	  if parent_idx < common_ci_header.key_range.first
      837 	  then parent_idx = common_ci_header.key_range.first;
      838 	  parent_node_id = current_node_id;
      839 	  call GET_NEW_NODE ((branch_key.branch_id), current_node_id, current_node_ptr);
      840          end;
      841    end FIND_NEXT_BRANCH;
      842 
      843 /* Internal procedure description:
      844*
      845*          This routine gets a pointer to the control interval which is used as
      846*     node gnn_p_node_id.  It also sets gnn_p_current_node_id to this value and
      847*     returns the value of the pointer in gnn_p_current_node_ptr.  In this way
      848*     this routine is used as a double-assignment statement, setting the global
      849*     variables current_node_id and current_node_ptr in tandem. This is to help
      850*     keep the two in synch. 
      851**/
      852 
      853 GET_NEW_NODE:
      854    proc (gnn_p_node_id, gnn_p_current_node_id, gnn_p_current_node_ptr);
      855 
      856       dcl	    gnn_p_node_id	       fixed bin (24) unsigned;
      857       dcl	    gnn_p_current_node_id  fixed bin (24) unsigned;
      858       dcl	    gnn_p_current_node_ptr ptr;
      859 
      860       dcl	    gnn_code	       fixed bin (35);
      861 
      862       gnn_p_current_node_id = gnn_p_node_id;
      863 
      864       call collection_manager_$get_control_interval_ptr (index_cursor.file_opening_id, index_cursor.collection_id,
      865 	 gnn_p_current_node_id, gnn_p_current_node_ptr, gnn_code);
      866       if gnn_code ^= 0
      867       then call ERROR_RETURN (gnn_code);
      868 
      869       return;
      870 
      871    end GET_NEW_NODE;
      872 
      873 /* Internal procedure description:
      874*
      875*          This routine copies the element at slot 1 in the control interval
      876*     pointed to by gch_p_node_ptr to the buffer pointed to by
      877*     gch_p_common_ci_header_ptr. Slot 1 is reserved for the index control
      878*     interval header. Of the two output parameters, gch_p_leaf_ci_header_ptr
      879*     and gch_p_branch_ci_header_ptr, one will be set to null and the other to
      880*     gch_p_common_ci_header_ptr depending on whether the node is a branch or
      881*     leaf node.
      882**/
      883 
      884 GET_CI_HEADER:
      885    proc (gch_p_node_ptr, gch_p_node_id, gch_p_common_ci_header_ptr, gch_p_leaf_ci_header_ptr, gch_p_branch_ci_header_ptr,
      886         gch_p_header_id_string);
      887 
      888       dcl	    (gch_p_node_ptr, gch_p_common_ci_header_ptr, gch_p_leaf_ci_header_ptr, gch_p_branch_ci_header_ptr)
      889 			       ptr;
      890       dcl	    gch_p_node_id	       fixed bin (24) unsigned;
      891       dcl	    gch_p_header_id_string bit (36) aligned;
      892 
      893       dcl	    1 gch_p_header_id      aligned like element_id based (addr (gch_p_header_id_string));
      894 
      895       dcl	    gch_header_length_in_bytes
      896 			       fixed bin (35);
      897       dcl	    gch_header_string      char (gch_header_length_in_bytes) based;
      898       dcl	    1 gch_slot	       aligned like datum_slot based (gch_slot_ptr);
      899       dcl	    gch_slot_ptr	       ptr;
      900 
      901       gch_p_header_id.control_interval_id = gch_p_node_id;
      902       gch_p_header_id.index = 1;
      903 
      904       gch_slot_ptr = addcharno (gch_p_node_ptr, DATUM_POSITION_TABLE_OFFSET_IN_BYTES);
      905 						/* First slot */
      906 
      907       if gch_slot.offset_in_bytes = FREE_SLOT
      908       then call sub_err_ (dm_error_$no_element, myname, ACTION_CANT_RESTART, null, 0,
      909 	      "^/Expected an index control interval header at the first slot of^/control interval ^d.", gch_p_node_id);
      910       if gch_slot.length_in_bits > max (LEAF_CI_HEADER_LENGTH_IN_BITS, BRANCH_CI_HEADER_LENGTH_IN_BITS)
      911       then call sub_err_ (dm_error_$long_return_element, myname, ACTION_CANT_RESTART, null, 0,
      912 	      "^/An index control interval header should be no longer than ^d bits;^/the one in control interval ^d is ^d bits.",
      913 	      max (LEAF_CI_HEADER_LENGTH_IN_BITS, BRANCH_CI_HEADER_LENGTH_IN_BITS), gch_p_node_id,
      914 	      gch_slot.length_in_bits);
      915 
      916       gch_header_length_in_bytes = ceil (divide (gch_slot.length_in_bits, BITS_PER_BYTE, 35, 18));
      917 
      918       gch_p_common_ci_header_ptr -> gch_header_string =
      919 	 addcharno (gch_p_node_ptr, gch_slot.offset_in_bytes) -> gch_header_string;
      920 
      921 
      922       if gch_p_common_ci_header_ptr -> common_ci_header.is_leaf
      923       then
      924          do;
      925 	  gch_p_leaf_ci_header_ptr = gch_p_common_ci_header_ptr;
      926 	  gch_p_branch_ci_header_ptr = null;
      927 
      928 	  if gch_p_leaf_ci_header_ptr -> leaf_ci_header.common.key_range.first < 0
      929 	  then call ERROR_RETURN (dm_error_$bad_first_key_idx);
      930 	  else if gch_p_leaf_ci_header_ptr -> leaf_ci_header.common.key_range.last
      931 	       < gch_p_leaf_ci_header_ptr -> leaf_ci_header.common.key_range.first
      932 	  then call ERROR_RETURN (dm_error_$bad_last_key_idx);
      933          end;
      934       else
      935          do;
      936 	  gch_p_leaf_ci_header_ptr = null;
      937 	  gch_p_branch_ci_header_ptr = gch_p_common_ci_header_ptr;
      938 
      939 	  if gch_p_branch_ci_header_ptr -> branch_ci_header.common.key_range.last
      940 	       < gch_p_branch_ci_header_ptr -> branch_ci_header.common.key_range.first
      941 	  then call ERROR_RETURN (dm_error_$bad_last_key_idx);
      942          end;
      943 
      944       return;
      945 
      946    end GET_CI_HEADER;
      947 
      948 /* Internal procedure description:
      949*     
      950*          This routine gets a key out of a control interval.  The pointer to
      951*     the control interval (gnk_p_node_ptr) and the index of the key in the
      952*     slot table (gnk_p_index) are input. The gnk_p_key_ptr points to a local
      953*     buffer in which the key will be copied. The two output values are the
      954*     length of the leaf_key.string (gnk_p_lk_string_length) should the key be
      955*     a leaf key, and the length of branch_key.string (gnk_p_bk_string_length)
      956*     should the key be a branch key.  
      957**/
      958 
      959 GET_NEW_KEY:
      960    proc (gnk_p_node_ptr, gnk_p_node_id, gnk_p_index, gnk_p_key_ptr, gnk_p_lk_string_length, gnk_p_bk_string_length,
      961         gnk_p_key_id_string);
      962 
      963       dcl	    gnk_p_node_ptr	       ptr;
      964       dcl	    gnk_p_node_id	       fixed bin (24) unsigned;
      965       dcl	    gnk_p_index	       fixed bin;
      966       dcl	    gnk_p_key_ptr	       ptr;
      967       dcl	    gnk_p_lk_string_length fixed bin (35);
      968       dcl	    gnk_p_bk_string_length fixed bin (35);
      969       dcl	    gnk_p_key_id_string    bit (36) aligned;
      970 
      971       dcl	    1 gnk_p_key_id	       aligned like element_id based (addr (gnk_p_key_id_string));
      972 
      973       dcl	    gnk_key_length_in_bytes
      974 			       fixed bin (35);
      975       dcl	    gnk_key_string	       char (gnk_key_length_in_bytes) based;
      976       dcl	    1 gnk_slot	       aligned like datum_slot based (gnk_slot_ptr);
      977       dcl	    gnk_slot_ptr	       ptr;
      978 
      979       gnk_p_key_id.control_interval_id = gnk_p_node_id;
      980       gnk_p_key_id.index = gnk_p_index;
      981 
      982       gnk_slot_ptr =
      983 	 addcharno (gnk_p_node_ptr, DATUM_POSITION_TABLE_OFFSET_IN_BYTES + BYTES_PER_WORD * (gnk_p_index - 1));
      984 
      985       if gnk_slot.offset_in_bytes = FREE_SLOT
      986       then call ERROR_RETURN (dm_error_$no_element);
      987       if gnk_slot.length_in_bits > CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES * BITS_PER_BYTE
      988       then call ERROR_RETURN (dm_error_$long_return_element);
      989 
      990       gnk_key_length_in_bytes = ceil (divide (gnk_slot.length_in_bits, BITS_PER_BYTE, 35, 18));
      991 
      992       gnk_p_key_ptr -> gnk_key_string = addcharno (gnk_p_node_ptr, gnk_slot.offset_in_bytes) -> gnk_key_string;
      993 
      994       gnk_p_lk_string_length = gnk_slot.length_in_bits;
      995       gnk_p_bk_string_length = gnk_slot.length_in_bits - BRANCH_KEY_HEADER_LENGTH_IN_BITS;
      996 
      997       return;
      998    end GET_NEW_KEY;
      999 
     1000 /* Internal procedure description:
     1001*
     1002*          This program sets up the local variables, mostly by copying data
     1003*     from the parameters.  Input structures are checked to ensure that they
     1004*     are of the same version as the structures used by im_basic_search.
     1005**/
     1006 
     1007 INITIALIZE_LOCAL_VARIABLES:
     1008    proc ();
     1009 
     1010       want_highest_equal_key =
     1011 	 (want_keys_less_than_vector & want_key_equal_to_vector)
     1012 	 | (want_keys_greater_than_vector & ^want_key_equal_to_vector);
     1013       only_want_key_equal_to_vector =
     1014 	 want_key_equal_to_vector & ^(want_keys_less_than_vector | want_keys_greater_than_vector);
     1015 
     1016       index_opening_info_ptr = p_index_opening_info_ptr;
     1017       call CHECK_VERSION (index_opening_info.version, INDEX_OPENING_INFO_VERSION_3, "index_opening_info");
     1018 
     1019       index_header_ptr = index_opening_info.index_header_ptr;
     1020       call CHECK_VERSION (index_header.version, INDEX_HEADER_VERSION_4, "index_header");
     1021 
     1022       index_cursor_ptr = p_index_cursor_ptr;
     1023       if index_cursor.type ^= INDEX_CURSOR_TYPE
     1024       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
     1025 	      "^/Expected an index type cursor, cursor type ^d.  Received type ^d instead.", INDEX_CURSOR_TYPE,
     1026 	      index_cursor.type);
     1027 
     1028       if index_cursor.version ^= INDEX_CURSOR_VERSION_3
     1029       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
     1030 	      "^/Expected version ^d of the index_cursor structure. Received version ^d.", INDEX_CURSOR_VERSION_3,
     1031 	      index_cursor.version);
     1032 
     1033       cvs_p_field_table_ptr = index_opening_info.field_table_ptr;
     1034 
     1035       if cvs_p_simple_typed_vector_ptr = null
     1036       then
     1037          do;
     1038 	  if cvs_p_field_table_ptr -> field_table.version ^= FIELD_TABLE_VERSION_3
     1039 	  then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
     1040 		  "^/Expected version ^a of the field_table structure.  Received version ^a.", FIELD_TABLE_VERSION_3,
     1041 		  cvs_p_field_table_ptr -> field_table.version);
     1042 	  number_of_fields_in_vector = cvs_p_field_table_ptr -> field_table.number_of_fields;
     1043          end;
     1044       else number_of_fields_in_vector = cvs_p_simple_typed_vector_ptr -> simple_typed_vector.number_of_dimensions;
     1045 
     1046       cvs_p_key_string_ptr = addr (local_key_buffer);
     1047       branch_key_ptr = addrel (cvs_p_key_string_ptr, 1);
     1048       common_ci_header_ptr = addr (local_header_buffer);
     1049    end INITIALIZE_LOCAL_VARIABLES;
     1050 
     1051 /* Internal procedure description:
     1052*     
     1053*          This program fills in the values in the position_stack structure.
     1054*     Ths position_stack defines the effective low (left) end of the index,
     1055*     below which (i.e. to the left of which) searches cannot go.  The position
     1056*     stack is only used for relative searches.  It is initialized to point at
     1057*     the key in the index_cursor and each of that key's ancestors (that key's
     1058*     parent key, the parent key's parent key, up to the root parent key).
     1059*
     1060*
     1061*          In the INIT_TOP_DOWN case, there is no known key position in a leaf
     1062*     node stored in the index_cursor, so it is necessary to initialize the
     1063*     position_stack by starting with the first (or last) branch in the root
     1064*     node and working down the tree.  This finds the levels of the position
     1065*     stack in reverse order from the way INIT_BOTTOM_UP finds them, so it's
     1066*     necessary to reverse the elements of the position_stack.
     1067*     
     1068*          In the INIT_BOTTOM_UP case, there is a known key position in a leaf
     1069*     which is the least key value, so the position_stack initialization is
     1070*     done from the leaf node up to the root node.
     1071*     
     1072**/
     1073 
     1074 
     1075 INIT_POSITION_STACK:
     1076    proc ();
     1077       dcl	    ips_code	       fixed bin (35) init (0);
     1078 
     1079       call im_validate_cursor (index_opening_info_ptr, index_cursor_ptr, ips_code);
     1080       if ips_code ^= 0
     1081       then call ERROR_RETURN (ips_code);
     1082 
     1083       if index_cursor.flags.is_at_end_of_index | index_cursor.flags.is_at_beginning_of_index
     1084       then
     1085 INIT_TOP_DOWN:
     1086          do;
     1087 
     1088 
     1089 	  call GET_NEW_NODE ((index_header.root_id), current_node_id, current_node_ptr);
     1090 	  call GET_CI_HEADER (current_node_ptr, current_node_id, common_ci_header_ptr, leaf_ci_header_ptr,
     1091 	       branch_ci_header_ptr, element_id_string);
     1092 
     1093 	  do while (^common_ci_header.is_leaf);
     1094 
     1095 	     position_stack.depth = position_stack.depth + 1;
     1096 	     addr (position_stack.id_string (position_stack.depth)) -> element_id.control_interval_id = current_node_id;
     1097 
     1098 	     if index_cursor.flags.is_at_beginning_of_index
     1099 	     then
     1100 	        do;
     1101 		 call GET_NEW_NODE ((branch_ci_header.low_branch_id), current_node_id, current_node_ptr);
     1102 						/* Set current_node_id, current_node_ptr */
     1103 		 addr (position_stack.id_string (position_stack.depth)) -> element_id.index = 0;
     1104 	        end;
     1105 	     else
     1106 	        do;
     1107 		 current_idx = branch_ci_header.common.key_range.last;
     1108 		 addr (position_stack.id_string (position_stack.depth)) -> element_id.index = current_idx;
     1109 		 if current_idx = 0
     1110 		 then call GET_NEW_NODE ((branch_ci_header.low_branch_id), current_node_id, current_node_ptr);
     1111 		 else
     1112 		    do;
     1113 		       call GET_NEW_KEY (current_node_ptr, current_node_id, current_idx, branch_key_ptr, (0),
     1114 			  bk_string_length, element_id_string);
     1115 		       call GET_NEW_NODE ((branch_key.branch_id), current_node_id, current_node_ptr);
     1116 		    end;
     1117 	        end;
     1118 	  end;
     1119 	  position_stack.depth = position_stack.depth + 1;
     1120 	  addr (position_stack.id_string (position_stack.depth)) -> element_id.control_interval_id = current_node_id;
     1121 	  if index_cursor.flags.is_at_beginning_of_index
     1122 	  then addr (position_stack.id_string (position_stack.depth)) -> element_id.index =
     1123 		  common_ci_header.key_range.first;
     1124 	  else addr (position_stack.id_string (position_stack.depth)) -> element_id.index =
     1125 		  common_ci_header.key_range.last;
     1126 
     1127 /*  The position_stack is "upside down" at this point and needs to be inverted,
     1128*to get position_stack(1) to correspond to a position in a leaf node and 
     1129*position_stack(position_stack.depth) to correspond to a position in the root. 
     1130**/
     1131 
     1132 	  do depth_idx = 1 to divide (position_stack.depth, 2, 35, 0);
     1133 	     temp_id_string = position_stack.id_string (depth_idx);
     1134 	     position_stack.id_string (depth_idx) = position_stack.id_string (position_stack.depth - depth_idx + 1);
     1135 	     position_stack.id_string (position_stack.depth - depth_idx + 1) = temp_id_string;
     1136 	  end;
     1137 
     1138          end INIT_TOP_DOWN;
     1139       else
     1140 INIT_BOTTOM_UP:
     1141          do;
     1142 	  call GET_NEW_NODE ((addr (index_cursor.key_id_string) -> element_id.control_interval_id), current_node_id,
     1143 	       current_node_ptr);
     1144 	  call GET_CI_HEADER (current_node_ptr, current_node_id, common_ci_header_ptr, leaf_ci_header_ptr,
     1145 	       branch_ci_header_ptr, element_id_string);
     1146 
     1147 	  position_stack.depth = 1;
     1148 
     1149 	  current_idx = addr (index_cursor.key_id_string) -> element_id.index;
     1150 	  if index_cursor.flags.current_key_exists
     1151 	  then current_idx = current_idx + 1;
     1152 
     1153 	  if current_idx > common_ci_header.key_range.last
     1154 	  then if common_ci_header.next_id > 0
     1155 	       then
     1156 		do;
     1157 		   call GET_NEW_NODE ((common_ci_header.next_id), current_node_id, current_node_ptr);
     1158 		   call GET_CI_HEADER (current_node_ptr, current_node_id, common_ci_header_ptr, leaf_ci_header_ptr,
     1159 		        branch_ci_header_ptr, element_id_string);
     1160 		   current_idx = common_ci_header.key_range.first;
     1161 		end;
     1162 	       else
     1163 		do;
     1164 		   p_key_id_string = "0"b;
     1165 		   call RETURN ();
     1166 		end;
     1167 
     1168 	  addr (position_stack.id_string (1)) -> element_id.control_interval_id = current_node_id;
     1169 	  addr (position_stack.id_string (1)) -> element_id.index = current_idx;
     1170 
     1171 	  do while (common_ci_header.parent_id_string ^= "0"b);
     1172 	     position_stack.depth = position_stack.depth + 1;
     1173 	     position_stack.id_string (position_stack.depth) = common_ci_header.parent_id_string;
     1174 
     1175 	     call GET_NEW_NODE ((addr (common_ci_header.parent_id_string) -> element_id.control_interval_id),
     1176 		current_node_id, current_node_ptr);
     1177 	     call GET_CI_HEADER (current_node_ptr, current_node_id, common_ci_header_ptr, leaf_ci_header_ptr,
     1178 		branch_ci_header_ptr, element_id_string);
     1179 
     1180 	  end;
     1181          end INIT_BOTTOM_UP;
     1182 
     1183       current_depth = position_stack.depth;
     1184 
     1185    end INIT_POSITION_STACK;
     1186 
     1187 /* Internal procedure description:
     1188*     
     1189*          This program sets up the output parameters of im_basic_search to
     1190*     report the failure of a search for an exact match of the input
     1191*     typed_vector.  This is the expected result for the im_basic_search$insert
     1192*     entry, and the p_key_id and p_maximum_duplication_field output parameters
     1193*     provide important information to the caller.
     1194**/
     1195 
     1196 REPORT_FAILED_EXACT_MATCH:
     1197    proc ();
     1198       failed_exact_match = "1"b;
     1199 
     1200       if is_insertion
     1201       then p_maximum_duplication_field = max (high_duplication_field, low_duplication_field);
     1202 
     1203       if cvs_p_vector_less_than_key
     1204       then p_key_id = element_id;
     1205       else
     1206          do;
     1207 	  p_key_id.control_interval_id = element_id.control_interval_id;
     1208 	  p_key_id.index = current_idx + 1;
     1209          end;
     1210    end REPORT_FAILED_EXACT_MATCH;
     1211 
     1212 /* Internal procedure description:
     1213*     
     1214*          This procedure makes p_key_id point at the next key after the one
     1215*     pointed at by element_id (the current key).  This is the result of the
     1216*     search, to be returned to the caller of im_basic_search.
     1217**/
     1218 
     1219 REPORT_NEXT_KEY:
     1220    proc ();
     1221       if element_id.index >= leaf_ci_header.common.key_range.last
     1222       then
     1223          do;
     1224 	  p_key_id.control_interval_id = leaf_ci_header.common.next_id;
     1225 	  if leaf_ci_header.common.next_id > 0
     1226 	  then
     1227 	     do;
     1228 	        call GET_NEW_NODE ((leaf_ci_header.common.next_id), current_node_id, current_node_ptr);
     1229 	        call GET_CI_HEADER (current_node_ptr, current_node_id, common_ci_header_ptr, leaf_ci_header_ptr,
     1230 		   branch_ci_header_ptr, element_id_string);
     1231 	        p_key_id.index = leaf_ci_header.common.key_range.first;
     1232 	     end;
     1233 	  else p_key_id.index = 0;
     1234          end;
     1235       else
     1236          do;
     1237 	  p_key_id.control_interval_id = element_id.control_interval_id;
     1238 	  p_key_id.index = element_id.index + 1;
     1239          end;
     1240 
     1241    end REPORT_NEXT_KEY;
     1242 
     1243 /* Internal procedure description:
     1244*     
     1245*          This procedure makes p_key_id point at the key previous to the one
     1246*     pointed at by element_id (the current key).  This is the result of the
     1247*     search, to be returned to the caller of im_basic_search.
     1248**/
     1249 
     1250 REPORT_PREVIOUS_KEY:
     1251    proc ();
     1252       if is_relative_search
     1253       then
     1254          do;
     1255 
     1256 /* It's necessary to check that the "previous" key is not before the logical
     1257*beginning of the index, as defined in position_stack.
     1258**/
     1259 	  if element_id.control_interval_id
     1260 	       = addr (position_stack.id_string (current_depth)) -> element_id.control_interval_id
     1261 	       & element_id.index <= addr (position_stack.id_string (current_depth)) -> element_id.index
     1262 	  then
     1263 	     do;
     1264 	        p_key_id.control_interval_id = 0;
     1265 	        p_key_id.index = 0;
     1266 	        return;
     1267 	     end;
     1268          end;
     1269 
     1270       if element_id.index <= leaf_ci_header.common.key_range.first
     1271       then
     1272          do;
     1273 	  p_key_id.control_interval_id = leaf_ci_header.common.previous_id;
     1274 
     1275 	  if leaf_ci_header.common.previous_id > 0
     1276 	  then
     1277 	     do;
     1278 	        call GET_NEW_NODE ((leaf_ci_header.common.previous_id), current_node_id, current_node_ptr);
     1279 	        call GET_CI_HEADER (current_node_ptr, current_node_id, common_ci_header_ptr, leaf_ci_header_ptr,
     1280 		   branch_ci_header_ptr, element_id_string);
     1281 	        p_key_id.index = leaf_ci_header.common.key_range.last;
     1282 	     end;
     1283 	  else p_key_id.index = 0;
     1284          end;
     1285       else
     1286          do;
     1287 	  p_key_id.control_interval_id = element_id.control_interval_id;
     1288 	  p_key_id.index = element_id.index - 1;
     1289          end;
     1290 
     1291    end REPORT_PREVIOUS_KEY;
     1292 
     1293 /* Internal procedure description:
     1294*     
     1295*          This program changes the index_cursor to point to the new position
     1296*     which is the result of the entire search.
     1297**/
     1298 
     1299 REPOSITION_CURSOR:
     1300    proc ();
     1301       dcl	    rp_code	       fixed bin (35);
     1302 
     1303       string (index_cursor.flags) = "0"b;
     1304 
     1305       if ^failed_exact_match
     1306       then call im_set_cursor$at_current (index_cursor_ptr, unspec (p_key_id), index_cursor.current_key_string_ptr,
     1307 	      (index_cursor.current_key_string_length), rp_code);
     1308       else if p_key_id.index > leaf_ci_header.common.key_range.last
     1309       then if leaf_ci_header.common.next_id ^= 0
     1310 	 then
     1311 	    do;
     1312 	       call GET_NEW_NODE ((leaf_ci_header.common.next_id), current_node_id, current_node_ptr);
     1313 	       call GET_CI_HEADER (current_node_ptr, current_node_id, common_ci_header_ptr, leaf_ci_header_ptr,
     1314 		  branch_ci_header_ptr, element_id_string);
     1315 
     1316 	       p_key_id.control_interval_id = current_node_id;
     1317 	       p_key_id.index = leaf_ci_header.common.key_range.first;
     1318 	       call im_set_cursor$no_current (index_cursor_ptr, unspec (p_key_id), index_cursor.current_key_string_ptr,
     1319 		  (index_cursor.current_key_string_length), rp_code);
     1320 	    end;
     1321 	 else
     1322 	    do;
     1323 	       p_key_id.index = leaf_ci_header.common.key_range.last;
     1324 	       call im_set_cursor$at_end (index_cursor_ptr, unspec (p_key_id), index_cursor.current_key_string_ptr,
     1325 		  (index_cursor.current_key_string_length), rp_code);
     1326 	    end;
     1327       else if p_key_id.index = leaf_ci_header.common.key_range.first & leaf_ci_header.previous_id = 0
     1328       then call im_set_cursor$at_beginning (index_cursor_ptr, unspec (p_key_id), index_cursor.current_key_string_ptr,
     1329 	      (index_cursor.current_key_string_length), rp_code);
     1330       else call im_set_cursor$no_current (index_cursor_ptr, unspec (p_key_id), index_cursor.current_key_string_ptr,
     1331 	      (index_cursor.current_key_string_length), rp_code);
     1332       if rp_code ^= 0
     1333       then call ERROR_RETURN (rp_code);
     1334    end REPOSITION_CURSOR;
     1335 
     1336 SET_RELATIVE_FIRST_IDX:
     1337    proc (srfi_p_position_stack_ptr, srfi_p_common_ci_header_ptr, srfi_p_first_idx);
     1338       dcl	    srfi_p_position_stack_ptr
     1339 			       ptr parm;
     1340       dcl	    srfi_p_common_ci_header_ptr
     1341 			       ptr parm;
     1342       dcl	    srfi_p_first_idx       fixed bin parm;
     1343 
     1344 
     1345       srfi_p_first_idx = addr (srfi_p_position_stack_ptr -> position_stack.id_string (current_depth)) -> element_id.index;
     1346 
     1347 /* For branch nodes, the position_stack index indicates the least branch to be
     1348*searched, and the first_idx should be set to one greater than this index.
     1349*The first_idx is used to indicate the least branch key to be compared against.
     1350*Depending on the result of this comparison, the branch greater or less than
     1351*(the less_branch_id) this "first" branch key may be used.  The branch less
     1352*than the "first" branch key then should be the least branch, that identified
     1353*by the position_stack index.
     1354*
     1355*For leaf nodes, the position_stack index indicates the least key which is a
     1356*valid result.  Keys less than this key logically don't exist in relative
     1357*searches.
     1358**/
     1359 
     1360       if ^common_ci_header.is_leaf
     1361       then srfi_p_first_idx = max (srfi_p_first_idx + 1, srfi_p_common_ci_header_ptr -> common_ci_header.key_range.first);
     1362 
     1363    end SET_RELATIVE_FIRST_IDX;
     1364 
     1365 /* Internal procedure description:
     1366*
     1367*          This procedure finds the first node to be searched and makes it the
     1368*     current one.  The first node to search in the absolute search case is
     1369*     simply the root node, the first_idx is the key_range.first key in the
     1370*     root node.  In the relative search case, it is necessary to
     1371*     use the position stack to determine where the effective lower limit of
     1372*     the root node is (the value specified in first_idx).
     1373*     
     1374**/
     1375 
     1376 SETUP_FIRST_NODE:
     1377    proc ();
     1378       if is_relative_search
     1379       then
     1380          do;
     1381 	  if position_stack.depth = 0
     1382 	  then call INIT_POSITION_STACK ();
     1383 	  else
     1384 	     do;
     1385 	        current_depth = position_stack.depth;
     1386 
     1387 	        call GET_NEW_NODE ((addr (position_stack.id_string (current_depth)) -> element_id.control_interval_id),
     1388 		   current_node_id, current_node_ptr);
     1389 	        call GET_CI_HEADER (current_node_ptr, current_node_id, common_ci_header_ptr, leaf_ci_header_ptr,
     1390 		   branch_ci_header_ptr, element_id_string);
     1391 
     1392 	     end;
     1393 
     1394 	  call SET_RELATIVE_FIRST_IDX (position_stack_ptr, common_ci_header_ptr, first_idx);
     1395          end;
     1396       else
     1397          do;
     1398 	  call GET_NEW_NODE ((index_header.root_id), current_node_id, current_node_ptr);
     1399 	  call GET_CI_HEADER (current_node_ptr, current_node_id, common_ci_header_ptr, leaf_ci_header_ptr,
     1400 	       branch_ci_header_ptr, element_id_string);
     1401 
     1402 	  first_idx = common_ci_header.key_range.first;
     1403          end;
     1404       parent_node_id = current_node_id;
     1405 
     1406    end SETUP_FIRST_NODE;
     1407 
     1408 /* Internal procedure description:
     1409*
     1410*          This procedure ensures that the current node is either a
     1411*     non-degenerate branch node, or a leaf node.  A degenerte branch node is
     1412*     one which contains no keys and has only a "low_branch", identified by the
     1413*     low_branch_id.  Degenerate branches are skipped by just following the
     1414*     low_branch_id "pointer".  Degenerate branches can be identified by the
     1415*     fact that the key_range.first value in their headers is equal to 0.
     1416**/
     1417 
     1418 SKIP_DEGENERATE_NODES:
     1419    proc ();
     1420 
     1421       do while (^common_ci_header.is_leaf & common_ci_header.key_range.first = 0);
     1422          parent_node_id = current_node_id;
     1423          parent_idx = 0;
     1424 
     1425          call GET_NEW_NODE ((branch_ci_header.low_branch_id), current_node_id, current_node_ptr);
     1426 
     1427          if is_relative_search
     1428          then current_depth = max (current_depth - 1, 1);
     1429 
     1430          call GET_CI_HEADER (current_node_ptr, current_node_id, common_ci_header_ptr, leaf_ci_header_ptr,
     1431 	    branch_ci_header_ptr, element_id_string);
     1432 
     1433          call CHECK_PARENT_THREAD (parent_node_id, parent_idx, common_ci_header.parent_id_string);
     1434       end;
     1435    end SKIP_DEGENERATE_NODES;
     1436 
  1     1 /* BEGIN INCLUDE FILE - dm_comp_vec_str_proc.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:  
  1     4*
  1     5*          This program compares the value of a simple_typed_vector and a key.
  1     6*     It is responsible for "parsing" the key bit string into its constituent
  1     7*     fields, using the information provided by the field_table.  Dimension I
  1     8*     of the simple_typed_vector is assumed to be the same field as field I of
  1     9*     the key.
  1    10*          The comparison is done a-field-at-a-time, starting with field 1 and
  1    11*     continuing with field 2, field 3, etc. until either an inequality is
  1    12*     found or all of the fields have been compared.  
  1    13*
  1    14*	Global variables are assumed to be in the main procedure so as to
  1    15*     simulate the calling sequence:
  1    16*
  1    17*     call COMPARE_VECTOR_TO_STRING
  1    18*        (cvs_p_field_table_ptr, cvs_p_simple_typed_vector_ptr, 
  1    19*         cvs_p_key_string_ptr, cvs_p_key_string_length, 
  1    20*         cvs_p_last_field_idx, cvs_p_first_inequal_field_id, 
  1    21*         cvs_p_vector_equal_to_key, cvs_p_vector_less_than_key, cvs_p_code);
  1    22*
  1    23*     They must be declared as follows described under Parameters.
  1    24**/
  1    25 
  1    26 /* HISTORY:
  1    27*
  1    28*Written by Matthew Pierret, 04/19/84.
  1    29*  (Extracted from dmu_compare_vector_to_str.pl1.)
  1    30*Modified:
  1    31*05/03/84 by Matthew Pierret:  Changed to FIELD_TABLE_VERSION_3.
  1    32*12/07/84 by M. Sharpe:  to correct format and dcls.
  1    33**/
  1    34 
  1    35 
  1    36 /****^  HISTORY COMMENTS:
  1    37*  1) change(86-12-17,Dupuis), approve(87-04-01,MCR7632), audit(87-01-13,Blair),
  1    38*     install(87-04-02,MR12.1-1020):
  1    39*     Corrected a bug (phx20420) where the cvs_                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                scriptor.size = cvs_last_field_length_ptr -> cvs_based_real_fix_bin_1u;
  1   210 
  1   211 		    cvs_last_field_length_in_bits = cvs_truncated_field_descriptor.size + BITS_PER_WORD;
  1   212 		    cvs_last_field_is_truncated = "1"b;
  1   213 		 end;
  1   214 	     end;
  1   215 	  else if arg_descriptor.type = char_dtype
  1   216 	  then
  1   217 	     do;
  1   218 	        if arg_descriptor.size > BYTES_PER_WORD + 1
  1   219 	        then
  1   220 		 do;
  1   221 		    cvs_last_field_length_ptr =
  1   222 		       addbitno (cvs_key_string_ptr, field_table.field (cvs_last_field_idx).location - 1);
  1   223 		    cvs_last_field_value_ptr = addbitno (cvs_last_field_length_ptr, BITS_PER_WORD);
  1   224 
  1   225 		    cvs_truncated_field_descriptor.packed = "1"b;
  1   226 		    cvs_truncated_field_descriptor.flag = "1"b;
  1   227 		    cvs_truncated_field_descriptor.type = char_dtype;
  1   228 		    cvs_truncated_field_descriptor.size = cvs_last_field_length_ptr -> cvs_based_real_fix_bin_1u;
  1   229 
  1   230 		    cvs_last_field_length_in_bits =
  1   231 		       cvs_truncated_field_descriptor.size * BITS_PER_BYTE + BITS_PER_WORD;
  1   232 		    cvs_last_field_is_truncated = "1"b;
  1   233 		 end;
  1   234 	     end;
  1   235 	  else cvs_last_field_is_truncated = "0"b;
  1   236 
  1   237 	  if cvs_last_field_is_truncated
  1   238 	  then cvs_location_of_first_varying_field =
  1   239 		field_table.field (cvs_last_field_idx).location + cvs_last_field_length_in_bits;
  1   240 	  else cvs_location_of_first_varying_field = field_table.location_of_first_varying_field;
  1   241          end;
  1   242 
  1   243       cvs_varying_field_value_offset = cvs_location_of_first_varying_field - 1;
  1   244 						/* 1 is subtracted because locations are */
  1   245 						/* 1-based, offsets are 0-based.         */
  1   246 
  1   247 FIELD_LOOP:
  1   248       do cvs_field_idx = 1 to cvs_maximum_field_idx while (cv_p_code = 0 & cv_p_vector_equal_to_key);
  1   249          if cvs_last_field_is_truncated & cvs_field_idx = cvs_last_field_idx
  1   250          then
  1   251 	  do;
  1   252 	     cv_p_field_value_ptr = cvs_last_field_value_ptr;
  1   253 	     cv_p_field_value_length = -1;
  1   254 	     cv_p_descriptor_ptr = addr (cvs_truncated_field_descriptor);
  1   255 	  end;
  1   256          else
  1   257 	  do;
  1   258 	     cv_p_descriptor_ptr = addr (field_table.field (cvs_field_idx).descriptor);
  1   259 						/* Is field varying or non-varying? */
  1   260 	     if ^(cv_p_descriptor_ptr -> arg_descriptor.type = varying_char_dtype
  1   261 	        | cv_p_descriptor_ptr -> arg_descriptor.type = varying_bit_dtype)
  1   262 	     then
  1   263 PREPARE_NONVARYING_FIELD:
  1   264 	        do;
  1   265 		 cv_p_field_value_length = -1;
  1   266 		 cv_p_field_value_ptr = addbitno (cvs_key_string_ptr, field_table.field (cvs_field_idx).location - 1);
  1   267 	        end PREPARE_NONVARYING_FIELD;
  1   268 	     else
  1   269 PREPARE_VARYING_FIELD:
  1   270 	        do;
  1   271 		 cvs_length_field_length = field_table.field (cvs_field_idx).length_in_bits;
  1   272 		 cvs_length_field_ptr = addbitno (cvs_key_string_ptr, field_table.field (cvs_field_idx).location - 1);
  1   273 		 cv_p_field_value_length = bin (cvs_length_field_string, 35, 0);
  1   274 
  1   275 		 cvs_field_value_offset = cvs_varying_field_value_offset;
  1   276 
  1   277 		 if field_table.field (cvs_field_idx).flags.length_is_in_characters
  1   278 		 then cvs_varying_field_value_offset =
  1   279 		         cvs_varying_field_value_offset + cv_p_field_value_length * BITS_PER_BYTE;
  1   280 		 else cvs_varying_field_value_offset = cvs_varying_field_value_offset + cv_p_field_value_length;
  1   281 
  1   282 		 cv_p_field_value_ptr = addbitno (cvs_key_string_ptr, cvs_field_value_offset);
  1   283 
  1   284 	        end PREPARE_VARYING_FIELD;
  1   285 	  end;
  1   286 
  1   287          cv_p_vector_value_ptr = simple_typed_vector.dimension (cvs_field_idx).value_ptr;
  1   288          cv_p_vector_value_length = -1;			/* length is only needed if vector is in field format */
  1   289 
  1   290          call COMPARE_VALUES (VECTOR_VALUE_IS_IN_VECTOR_FORMAT);
  1   291 
  1   292 /* Actually uses global variables to simulate:
  1   293*
  1   294*         call COMPARE_VALUES 
  1   295*               (VECTOR_VALUE_IS_IN_VECTOR_FORMAT,
  1   296*	      cv_p_descriptor_ptr, 
  1   297*                cv_p_vector_value_ptr,
  1   298*	      cv_p_field_value_ptr, cv_p_field_value_length, 
  1   299*                cv_p_vector_equal_to_key, cv_p_vector_less_than_key, cv_p_code);
  1   300**/
  1   301 
  1   302          if cv_p_vector_equal_to_key
  1   303          then if cvs_last_field_is_truncated & cvs_field_idx = cvs_last_field_idx
  1   304 	    then if cvs_truncated_field_descriptor.size < arg_descriptor.size
  1   305 	         then cv_p_vector_equal_to_key = "0"b;
  1   306 
  1   307       end FIELD_LOOP;
  1   308 
  1   309       cvs_p_first_inequal_field_id = cvs_field_idx - bin (^cv_p_vector_equal_to_key);
  1   310 
  1   311       if cvs_maximum_field_idx < hbound (simple_typed_vector.dimension, 1)
  1   312       then cvs_p_vector_equal_to_key = "0"b;		/* The vector is longer than the key, so the */
  1   313 						/* comparison cannot be equal. */
  1   314       else cvs_p_vector_equal_to_key = cv_p_vector_equal_to_key;
  1   315 
  1   316       cvs_p_vector_less_than_key = cv_p_vector_less_than_key;
  1   317       cvs_p_code = cv_p_code;
  1   318 
  1   319       return;
  1   320 
  2     1 /* BEGIN INCLUDE FILE - dm_comp_vec_str_proc.incl.pl1 */
  2     2 
  2     3 
  2     4 
  2     5 /****^  HISTORY COMMENTS:
  2     6*  1) change(87-05-06,Dupuis), approve(87-05-29,MCR7695), audit(87-06-02,Blair),
  2     7*     install(87-07-17,MR12.1-1042):
  2     8*     Added a check to determine if the values were aligned correctly before
  2     9*     doing the comparisons. Although the calling program was supposed to take
  2    10*     care of alignment, this wasn't always the case (phx20843). This check can
  2    11*     be taken out in the future (for performance reasons) once we know we are
  2    12*     bug free.
  2    13*                                                   END HISTORY COMMENTS */
  2    14 
  2    15 
  2    16 /* DESCRIPTION:
  2    17*   
  2    18*   This internal routine is contained in an include file so that critical
  2    19*   execution paths may save the time that would have been spent on the
  2    20*   overhead of making an external call.  The time to execute this routine is
  2    21*   very small, much less than the time required in making an external call and
  2    22*   setting up an argument list.
  2    23*   
  2    24*   Modules which include this routine must follow strict guidelines in the
  2    25*   naming of certain variables, as this internal routine assumes the caller
  2    26*   has global variables set up so as to simulate the calling sequence:
  2    27*   
  2    28*   call COMPARE_VALUES_INTERNAL_PROC
  2    29*        (cv_p_descriptor_ptr, cv_p_vector_value_ptr,
  2    30*         cv_p_field_value_ptr, cv_p_field_value_length, 
  2    31*         cv_p_vector_equal_to_key, cv_p_vector_less_than_key, cv_p_code);
  2    32*   
  2    33*   These variables must be declared in the calling routine as described
  2    34*   under Parameters.
  2    35*
  2    36*   This routine compares two values and returns information about whether the
  2    37*   first is less than, equal to, or greater than, the second.  Both values
  2    38*   must be of the same data-type, however the storage conventions for varying
  2    39*   string data for the second value are slightly different from the Multics
  2    40*   standard format.  This difference consists solely in that the length of the
  2    41*   varying string is not stored as the initial piece of information in the
  2    42*   string.  The length of varying string values in fields is passed in as a
  2    43*   parameter.
  2    44*
  2    45*   The first value is referred to as the "vector" value, since it usually is
  2    46*   the value of a dimension of a typed_vector.  The second value is referred
  2    47*   to as the "field" value, since it is usually the value of a field of a key.
  2    48*   If cv_p_vector_value_is_in_field_format is OFF, the vector value is in the
  2    49*   Multics standard format; if ON, the vector value is in same format as the
  2    50*   field value.  The field value format is the format described above.
  2    51**/
  2    52 
  2    53 /* HISTORY:
  2    54*Written by Matthew Pierret, 04/18/84.
  2    55*  (Extracted from dmu_compare_values.pl1)
  2    56*Modified:
  2    57*05/14/84 by Matthew Pierret:  Changed to assume that values in field format
  2    58*            are properly aligned.
  2    59*12/07/84 by M. Sharpe:  to correct format and dcls.
  2    60**/
  2    61 
  2    62 /* format: style2,ind3 */
  2    63 
  2    64 
  2    65 COMPARE_VALUES:
  2    66    proc (cv_p_vector_value_is_in_field_format);
  2    67 
  2    68 /* START OF DECLARATIONS */
  2    69 
  2    70 /* Parameter */
  2    71 
  2    72       dcl	    cv_p_vector_value_is_in_field_format
  2    73 			       bit (1) aligned;
  2    74 
  2    75 /*  The following must be declared in the calling routine: 
  2    76*
  2    77*      dcl	    cv_p_descriptor_ptr             /* points to the descriptor for
  2    78*                                        ptr;  /* the vector/field value
  2    79*      dcl	    cv_p_vector_value_ptr     ptr;  /* points to the vector value
  2    80*      dcl	    cv_p_vector_value_length  fixed bin (35);
  2    81*                                              /* length of vector value in bits
  2    82*      dcl	    cv_p_field_value_ptr      ptr;  /* points to the field value
  2    83*      dcl	    cv_p_field_value_length   fixed bin (35);
  2    84*                                              /* length of field value in bits
  2    85*      dcl	    cv_p_vector_equal_to_key  bit (1) aligned;
  2    86*                                              /* is set by this routine to ON
  2    87*                                              /* if the values are equal
  2    88*      dcl	    cv_p_vector_less_than_key bit (1) aligned;
  2    89*                                              /* is set by this routine to ON
  2    90*                                              /* if the vector value is less
  2    91*                                              /* than the field value.
  2    92*      dcl	    cv_p_code	          fixed bin (35);
  2    93*
  2    94**/
  2    95 
  2    96 /* Automatic */
  2    97       dcl	    cv_local_vector_real_fix_bin_1
  2    98 			       fixed bin (35) aligned;
  2    99       dcl	    cv_local_field_real_fix_bin_1
  2   100 			       fixed bin (35) aligned;
  2   101       dcl	    cv_local_vector_real_fix_bin_2
  2   102 			       fixed bin (71) aligned;
  2   103       dcl	    cv_local_field_real_fix_bin_2
  2   104 			       fixed bin (71) aligned;
  2   105 
  2   106       dcl	    cv_local_vector_real_flt_bin_1
  2   107 			       float bin (27) aligned;
  2   108       dcl	    cv_local_field_real_flt_bin_1
  2   109 			       float bin (27) aligned;
  2   110       dcl	    cv_local_vector_real_flt_bin_2
  2   111 			       float bin (63) aligned;
  2   112       dcl	    cv_local_field_real_flt_bin_2
  2   113 			       float bin (63) aligned;
  2   114 
  2   115       dcl	    cv_local_vector_real_fix_bin_1_uns
  2   116 			       fixed bin (35) aligned unsigned;
  2   117       dcl	    cv_local_field_real_fix_bin_1_uns
  2   118 			       fixed bin (35) aligned unsigned;
  2   119       dcl	    cv_local_vector_real_fix_bin_2_uns
  2   120 			       fixed bin (71) aligned unsigned;
  2   121       dcl	    cv_local_field_real_fix_bin_2_uns
  2   122 			       fixed bin (71) aligned unsigned;
  2   123 
  2   124       dcl	    (cv_vector_real_part_value_ptr, cv_vector_imaginary_part_value_ptr, cv_field_real_part_value_ptr,
  2   125 	    cv_field_imaginary_part_value_ptr)
  2   126 			       ptr init (null);
  2   127 
  2   128       dcl	    1 cv_local_arg_descriptor
  2   129 			       like arg_descriptor;
  2   130       dcl	    1 cv_local_fixed_arg_descriptor
  2   131 			       like fixed_arg_descriptor;
  2   132 
  2   133 /* Based */
  2   134 
  2   135       dcl	    cv_bit_string	       bit (sys_info$max_seg_size * 36) based;
  2   136       dcl	    cv_char_string	       char (sys_info$max_seg_size * 4) based;
  2   137 
  2   138       dcl	    cv_based_real_fix_bin_1a
  2   139 			       fixed bin (35) based aligned;
  2   140       dcl	    cv_based_real_fix_bin_2a
  2   141 			       fixed bin (71) based aligned;
  2   142       dcl	    cv_based_real_fix_bin_1u
  2   143 			       fixed bin (35) based unaligned;
  2   144       dcl	    cv_based_real_fix_bin_2u
  2   145 			       fixed bin (71) based unaligned;
  2   146 
  2   147       dcl	    cv_based_real_flt_bin_1a
  2   148 			       float bin (27) based aligned;
  2   149       dcl	    cv_based_real_flt_bin_2a
  2   150 			       float bin (63) based aligned;
  2   151       dcl	    cv_based_real_flt_bin_1u
  2   152 			       float bin (27) based unaligned;
  2   153       dcl	    cv_based_real_flt_bin_2u
  2   154 			       float bin (63) based unaligned;
  2   155 
  2   156       dcl	    cv_based_real_fix_bin_1_unsa
  2   157 			       fixed bin (35) based aligned unsigned;
  2   158       dcl	    cv_based_real_fix_bin_2_unsa
  2   159 			       fixed bin (71) based aligned unsigned;
  2   160       dcl	    cv_based_real_fix_bin_1_unsu
  2   161 			       fixed bin (35) based unaligned unsigned;
  2   162       dcl	    cv_based_real_fix_bin_2_unsu
  2   163 			       fixed bin (71) based unaligned unsigned;
  2   164 
  2   165 /* Builtin */
  2   166 
  2   167       dcl	    (addbitno, addcharno, ceil, copy, substr, null, unspec)
  2   168 			       builtin;
  2   169 
  2   170 /* Constant */
  2   171 
  2   172       dcl	    myname	       init ("dmu_compare_values") char (32) varying internal static options (constant);
  2   173 
  2   174       dcl	    (
  2   175 	    BITS_PER_WORD	       init (36),
  2   176 	    BYTES_PER_WORD	       init (4),
  2   177 	    BITS_PER_EXPONENT      init (8),
  2   178 	    BIT4_DECIMAL_EXPONENT  init (2),
  2   179 	    BIT9_DECIMAL_EXPONENT  init (1),
  2   180 	    SIGN		       init (1),
  2   181 	    DEFAULT_LENGTH	       init (-1),
  2   182 	    HIGHEST_SUPPORTED_DATA_TYPE
  2   183 			       init (44)
  2   184 	    )		       fixed bin (17) internal static options (constant);
  2   185       dcl	    NEED_TO_CHECK_FOR_ALIGNMENT (46) bit (1) internal static options (constant) init (
  2   186               "1"b, "1"b, "1"b, "1"b, "1"b, "1"b, "1"b, "1"b, "1"b, "1"b, "1"b, "1"b, /* 1 to 12 */
  2   187               "0"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b, /* 13 to 19 */
  2   188               "0"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b, /* 20 to 32 */
  2   189               "1"b, "1"b, /* 33 to 34 */ "0"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b, "0"b, /* 35 to 42 */
  2   190               "1"b, "1"b, "1"b, "1"b /* 43 to 46 */);
  2   191 
  2   192       dcl	    REQUIRED_ALIGNMENT (46) fixed bin internal static options (constant) init (
  2   193       	    36, 72, 36, 72, 72, 72, 72, 72, 36, 36, 36, 36, /* 1 to 12 */
  2   194 	    0, 0, 0, 0, 0, 0, 0, /* 13 to 19 */
  2   195 	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* 20 to 32 */
  2   196 	    36, 72, /* 33 to 34 */ 0, 0, 0, 0, 0, 0, 0, 0, /* 35 to 42 */
  2   197 	    36, 36, 36, 36 ); /* 43 to 46 */
  2   198 
  2   199 /* Entry */
  2   200 
  2   201       dcl	    dmu_compare_values     entry (ptr, ptr, ptr, fixed bin (35), bit (1) aligned, bit (1) aligned,
  2   202 			       fixed bin (35));
  2   203       dcl	    dmu_compare_decimal_values$dmu_compare_dec9ls
  2   204 			       entry (fixed bin (17), ptr, ptr, bit (1) aligned, bit (1) aligned);
  2   205       dcl	    dmu_compare_decimal_values$dmu_compare_dec9fl
  2   206 			       entry (fixed bin (17), ptr, ptr, bit (1) aligned, bit (1) aligned);
  2   207       dcl	    dmu_compare_decimal_values$dmu_compare_dec4fl
  2   208 			       entry (fixed bin (17), ptr, ptr, bit (1) aligned, bit (1) aligned);
  2   209       dcl	    dmu_compare_decimal_values$dmu_compare_dec4ls
  2   210 			       entry (fixed bin (17), ptr, ptr, bit (1) aligned, bit (1) aligned);
  2   211       dcl	    sub_err_	       entry () options (variable);
  2   212 
  2   213 /* External */
  2   214 
  2   215       dcl	    sys_info$max_seg_size  fixed bin (35) ext static;
  2   216       dcl	    error_table_$bad_arg   fixed bin (35) ext;
  2   217       dcl	    dm_error_$unimplemented_data_type
  2   218 			       fixed bin (35) ext;
  2   219 
  2   220 /* END OF DECLARATIONS */
  2   221 
  2   222       cv_p_code = 0;
  2   223 
  2   224       arg_descriptor_ptr = cv_p_descriptor_ptr;
  2   225 
  2   226       if arg_descriptor.type < 1 | arg_descriptor.type > HIGHEST_SUPPORTED_DATA_TYPE
  2   227       then call
  2   228 	    sub_err_ (error_table_$bad_arg, myname, ACTION_CANT_RESTART, null, 0,
  2   229 	    "^/The caller-provided descriptor has an invalid type, ^d. Valid types
  2   230 are between 1 and ^d.", arg_descriptor.type, HIGHEST_SUPPORTED_DATA_TYPE);
  2   231 
  2   232       if ^arg_descriptor.packed & NEED_TO_CHECK_FOR_ALIGNMENT (arg_descriptor.type)
  2   233       then if mod (bitno (cv_p_vector_value_ptr), REQUIRED_ALIGNMENT (arg_descriptor.type)) ^= 0
  2   234       then call sub_err_ (error_table_$bad_arg, myname, ACTION_CANT_RESTART, null, 0,
  2   235 	 "^/The vector_value pointer (^p) has an invalid alignment.^/It's address should have been divisible by ^d.",
  2   236 	 cv_p_vector_value_ptr, REQUIRED_ALIGNMENT (arg_descriptor.type));
  2   237       else if mod (bitno (cv_p_field_value_ptr), REQUIRED_ALIGNMENT (arg_descriptor.type)) ^= 0
  2   238       then call sub_err_ (error_table_$bad_arg, myname, ACTION_CANT_RESTART, null, 0,
  2   239 	 "^/The field_value pointer (^p) has an invalid alignment.^/It's address should have been divisible by ^d.",
  2   240 	 cv_p_field_value_ptr, REQUIRED_ALIGNMENT (arg_descriptor.type));
  2   241 
  2   242       goto CV_TYPE (arg_descriptor.type);
  2   243 CV_TYPE (1):					/* real_fix_bin_1 (short) */
  2   244       if arg_descriptor.packed
  2   245       then
  2   246          do;
  2   247 	  if substr (cv_p_vector_value_ptr -> cv_bit_string, 1, 1)
  2   248 	  then unspec (cv_local_vector_real_fix_bin_1) =
  2   249 		copy ("1"b, BITS_PER_WORD - fixed_arg_descriptor.precision)
  2   250 		|| substr (cv_p_vector_value_ptr -> cv_bit_string, 2, fixed_arg_descriptor.precision);
  2   251 	  else unspec (cv_local_vector_real_fix_bin_1) =
  2   252 		copy ("0"b, BITS_PER_WORD - fixed_arg_descriptor.precision)
  2   253 		|| substr (cv_p_vector_value_ptr -> cv_bit_string, 2, fixed_arg_descriptor.precision);
  2   254 	  if substr (cv_p_field_value_ptr -> cv_bit_string, 1, 1)
  2   255 	  then unspec (cv_local_field_real_fix_bin_1) =
  2   256 		copy ("1"b, BITS_PER_WORD - fixed_arg_descriptor.precision)
  2   257 		|| substr (cv_p_field_value_ptr -> cv_bit_string, 2, fixed_arg_descriptor.precision);
  2   258 	  else unspec (cv_local_field_real_fix_bin_1) =
  2   259 		copy ("0"b, BITS_PER_WORD - fixed_arg_descriptor.precision)
  2   260 		|| substr (cv_p_field_value_ptr -> cv_bit_string, 2, fixed_arg_descriptor.precision);
  2   261 	  if cv_local_vector_real_fix_bin_1 = cv_local_field_real_fix_bin_1
  2   262 	  then goto CV_RETURN_EQUAL;
  2   263 	  else if cv_local_vector_real_fix_bin_1 < cv_local_field_real_fix_bin_1
  2   264 	  then goto CV_RETURN_LESS;
  2   265 	  else goto CV_RETURN_GREATER;
  2   266          end;
  2   267       else if cv_p_vector_value_ptr -> cv_based_real_fix_bin_1a = cv_p_field_value_ptr -> cv_based_real_fix_bin_1a
  2   268       then goto CV_RETURN_EQUAL;
  2   269       else if cv_p_vector_value_ptr -> cv_based_real_fix_bin_1a < cv_p_field_value_ptr -> cv_based_real_fix_bin_1a
  2   270       then goto CV_RETURN_LESS;
  2   271       else goto CV_RETURN_GREATER;
  2   272 
  2   273 
  2   274 CV_TYPE (2):					/* real_fix_bin_2 (long) */
  2   275       if arg_descriptor.packed
  2   276       then
  2   277          do;
  2   278 	  if substr (cv_p_vector_value_ptr -> cv_bit_string, 1, 1)
  2   279 	  then unspec (cv_local_vector_real_fix_bin_2) =
  2   280 		copy ("1"b, 2 * BITS_PER_WORD - fixed_arg_descriptor.precision)
  2   281 		|| substr (cv_p_vector_value_ptr -> cv_bit_string, 2, fixed_arg_descriptor.precision);
  2   282 	  else unspec (cv_local_vector_real_fix_bin_2) =
  2   283 		copy ("0"b, 2 * BITS_PER_WORD - fixed_arg_descriptor.precision)
  2   284 		|| substr (cv_p_vector_value_ptr -> cv_bit_string, 2, fixed_arg_descriptor.precision);
  2   285 	  if substr (cv_p_field_value_ptr -> cv_bit_string, 1, 1)
  2   286 	  then unspec (cv_local_field_real_fix_bin_2) =
  2   287 		copy ("1"b, 2 * BITS_PER_WORD - fixed_arg_descriptor.precision)
  2   288 		|| substr (cv_p_field_value_ptr -> cv_bit_string, 2, fixed_arg_descriptor.precision);
  2   289 	  else unspec (cv_local_field_real_fix_bin_2) =
  2   290 		copy ("0"b, 2 * BITS_PER_WORD - fixed_arg_descriptor.precision)
  2   291 		|| substr (cv_p_field_value_ptr -> cv_bit_string, 2, fixed_arg_descriptor.precision);
  2   292 	  if cv_local_vector_real_fix_bin_2 = cv_local_field_real_fix_bin_2
  2   293 	  then goto CV_RETURN_EQUAL;
  2   294 	  else if cv_local_vector_real_fix_bin_2 < cv_local_field_real_fix_bin_2
  2   295 	  then goto CV_RETURN_LESS;
  2   296 	  else goto CV_RETURN_GREATER;
  2   297          end;
  2   298       else if cv_p_vector_value_ptr -> cv_based_real_fix_bin_2a = cv_p_field_value_ptr -> cv_based_real_fix_bin_2a
  2   299       then goto CV_RETURN_EQUAL;
  2   300       else if cv_p_vector_value_ptr -> cv_based_real_fix_bin_2a < cv_p_field_value_ptr -> cv_based_real_fix_bin_2a
  2   301       then goto CV_RETURN_LESS;
  2   302       else goto CV_RETURN_GREATER;
  2   303 
  2   304 
  2   305 CV_TYPE (3):					/* real_flt_bin_1 (short) */
  2   306       if arg_descriptor.packed
  2   307       then
  2   308          do;
  2   309 	  unspec (cv_local_vector_real_flt_bin_1) =
  2   310 	     substr (cv_p_vector_value_ptr -> cv_bit_string, 1, BITS_PER_EXPONENT + SIGN + arg_descriptor.size)
  2   311 	     || copy ("0"b, (BITS_PER_WORD - (BITS_PER_EXPONENT + arg_descriptor.size + SIGN)));
  2   312 	  unspec (cv_local_field_real_flt_bin_1) =
  2   313 	     substr (cv_p_field_value_ptr -> cv_bit_string, 1, BITS_PER_EXPONENT + SIGN + arg_descriptor.size)
  2   314 	     || copy ("0"b, (BITS_PER_WORD - (BITS_PER_EXPONENT + arg_descriptor.size + SIGN)));
  2   315 
  2   316 
  2   317 	  if cv_local_vector_real_flt_bin_1 = cv_local_field_real_flt_bin_1
  2   318 	  then goto CV_RETURN_EQUAL;
  2   319 	  else if cv_local_vector_real_flt_bin_1 < cv_local_field_real_flt_bin_1
  2   320 	  then goto CV_RETURN_LESS;
  2   321 	  else goto CV_RETURN_GREATER;
  2   322          end;
  2   323       else if cv_p_vector_value_ptr -> cv_based_real_flt_bin_1a = cv_p_field_value_ptr -> cv_based_real_flt_bin_1a
  2   324       then goto CV_RETURN_EQUAL;
  2   325       else if cv_p_vector_value_ptr -> cv_based_real_flt_bin_1a < cv_p_field_value_ptr -> cv_based_real_flt_bin_1a
  2   326       then goto CV_RETURN_LESS;
  2   327       else goto CV_RETURN_GREATER;
  2   328 
  2   329 CV_TYPE (4):					/* real_flt_bin_2 (long) */
  2   330       if arg_descriptor.packed
  2   331       then
  2   332          do;
  2   333 	  unspec (cv_local_vector_real_flt_bin_2) =
  2   334 	     substr (cv_p_vector_value_ptr -> cv_bit_string, 1, BITS_PER_EXPONENT + SIGN + arg_descriptor.size)
  2   335 	     || copy ("0"b, (BITS_PER_WORD - (BITS_PER_EXPONENT + arg_descriptor.size + SIGN)));
  2   336 	  unspec (cv_local_field_real_flt_bin_2) =
  2   337 	     substr (cv_p_field_value_ptr -> cv_bit_string, 1, BITS_PER_EXPONENT + SIGN + arg_descriptor.size)
  2   338 	     || copy ("0"b, (BITS_PER_WORD - (BITS_PER_EXPONENT + arg_descriptor.size + SIGN)));
  2   339 
  2   340 	  if cv_local_vector_real_flt_bin_2 = cv_local_field_real_flt_bin_2
  2   341 	  then goto CV_RETURN_EQUAL;
  2   342 	  else if cv_local_vector_real_flt_bin_2 < cv_local_field_real_flt_bin_2
  2   343 	  then goto CV_RETURN_LESS;
  2   344 	  else goto CV_RETURN_GREATER;
  2   345          end;
  2   346       else if cv_p_vector_value_ptr -> cv_based_real_flt_bin_2a = cv_p_field_value_ptr -> cv_based_real_flt_bin_2a
  2   347       then goto CV_RETURN_EQUAL;
  2   348       else if cv_p_vector_value_ptr -> cv_based_real_flt_bin_2a < cv_p_field_value_ptr -> cv_based_real_flt_bin_2a
  2   349       then goto CV_RETURN_LESS;
  2   350       else goto CV_RETURN_GREATER;
  2   351 
  2   352 CV_TYPE (5):					/*cplx_fix_bin_1*/
  2   353       cv_field_real_part_value_ptr = cv_p_field_value_ptr;
  2   354       cv_vector_real_part_value_ptr = cv_p_vector_value_ptr;
  2   355       if arg_descriptor.packed
  2   356       then
  2   357          do;
  2   358 	  cv_vector_imaginary_part_value_ptr = addbitno (cv_p_vector_value_ptr, fixed_arg_descriptor.precision + SIGN);
  2   359 	  cv_field_imaginary_part_value_ptr = addbitno (cv_p_field_value_ptr, fixed_arg_descriptor.precision + SIGN);
  2   360          end;
  2   361       else
  2   362          do;
  2   363 	  cv_vector_imaginary_part_value_ptr = addbitno (cv_p_vector_value_ptr, BITS_PER_WORD);
  2   364 	  cv_field_imaginary_part_value_ptr = addbitno (cv_p_field_value_ptr, BITS_PER_WORD);
  2   365          end;
  2   366       cv_local_fixed_arg_descriptor = fixed_arg_descriptor;
  2   367       cv_local_fixed_arg_descriptor.type = real_fix_bin_1_dtype;
  2   368       call
  2   369          dmu_compare_values (addr (cv_local_fixed_arg_descriptor), cv_vector_real_part_value_ptr,
  2   370          cv_field_real_part_value_ptr, (DEFAULT_LENGTH), cv_p_vector_equal_to_key, cv_p_vector_less_than_key, cv_p_code);
  2   371       if cv_p_code ^= 0
  2   372       then return;
  2   373       if cv_p_vector_equal_to_key
  2   374       then call
  2   375 	    dmu_compare_values (addr (cv_local_fixed_arg_descriptor), cv_vector_imaginary_part_value_ptr,
  2   376 	    cv_field_imaginary_part_value_ptr, (DEFAULT_LENGTH), cv_p_vector_equal_to_key, cv_p_vector_less_than_key,
  2   377 	    cv_p_code);
  2   378       return;
  2   379 
  2   380 CV_TYPE (6):					/*cplx_fix_bin_2*/
  2   381       cv_field_real_part_value_ptr = cv_p_field_value_ptr;
  2   382       cv_vector_real_part_value_ptr = cv_p_vector_value_ptr;
  2   383       if arg_descriptor.packed
  2   384       then
  2   385          do;
  2   386 	  cv_vector_imaginary_part_value_ptr = addbitno (cv_p_vector_value_ptr, fixed_arg_descriptor.precision + SIGN);
  2   387 	  cv_field_imaginary_part_value_ptr = addbitno (cv_p_field_value_ptr, fixed_arg_descriptor.precision + SIGN);
  2   388          end;
  2   389       else
  2   390          do;
  2   391 	  cv_vector_imaginary_part_value_ptr = addbitno (cv_p_vector_value_ptr, 2 * BITS_PER_WORD);
  2   392 	  cv_field_imaginary_part_value_ptr = addbitno (cv_p_field_value_ptr, 2 * BITS_PER_WORD);
  2   393          end;
  2   394       cv_local_fixed_arg_descriptor = fixed_arg_descriptor;
  2   395       cv_local_fixed_arg_descriptor.type = real_fix_bin_2_dtype;
  2   396       call
  2   397          dmu_compare_values (addr (cv_local_fixed_arg_descriptor), cv_vector_real_part_value_ptr,
  2   398          cv_field_real_part_value_ptr, (DEFAULT_LENGTH), cv_p_vector_equal_to_key, cv_p_vector_less_than_key, cv_p_code);
  2   399       if cv_p_code ^= 0
  2   400       then return;
  2   401       if cv_p_vector_equal_to_key
  2   402       then call
  2   403 	    dmu_compare_values (addr (cv_local_fixed_arg_descriptor), cv_vector_imaginary_part_value_ptr,
  2   404 	    cv_field_imaginary_part_value_ptr, (DEFAULT_LENGTH), cv_p_vector_equal_to_key, cv_p_vector_less_than_key,
  2   405 	    cv_p_code);
  2   406       return;
  2   407 
  2   408 CV_TYPE (7):					/*cplx_flt_bin_1*/
  2   409       cv_field_real_part_value_ptr = cv_p_field_value_ptr;
  2   410       cv_vector_real_part_value_ptr = cv_p_vector_value_ptr;
  2   411       if arg_descriptor.packed
  2   412       then
  2   413          do;
  2   414 	  cv_vector_imaginary_part_value_ptr =
  2   415 	     addbitno (cv_p_vector_value_ptr, BITS_PER_EXPONENT + SIGN + arg_descriptor.size);
  2   416 	  cv_field_imaginary_part_value_ptr =
  2   417 	     addbitno (cv_p_field_value_ptr, BITS_PER_EXPONENT + SIGN + arg_descriptor.size);
  2   418          end;
  2   419       else
  2   420          do;
  2   421 	  cv_vector_imaginary_part_value_ptr = addbitno (cv_p_vector_value_ptr, BITS_PER_WORD);
  2   422 	  cv_field_imaginary_part_value_ptr = addbitno (cv_p_field_value_ptr, BITS_PER_WORD);
  2   423          end;
  2   424       cv_local_arg_descriptor = arg_descriptor;
  2   425       cv_local_arg_descriptor.type = real_flt_bin_1_dtype;
  2   426       call
  2   427          dmu_compare_values (addr (cv_local_arg_descriptor), cv_vector_real_part_value_ptr, cv_field_real_part_value_ptr,
  2   428          (DEFAULT_LENGTH), cv_p_vector_equal_to_key, cv_p_vector_less_than_key, cv_p_code);
  2   429       if cv_p_code ^= 0
  2   430       then return;
  2   431       if cv_p_vector_equal_to_key
  2   432       then call
  2   433 	    dmu_compare_values (addr (cv_local_arg_descriptor), cv_vector_imaginary_part_value_ptr,
  2   434 	    cv_field_imaginary_part_value_ptr, (DEFAULT_LENGTH), cv_p_vector_equal_to_key, cv_p_vector_less_than_key,
  2   435 	    cv_p_code);
  2   436       return;
  2   437 
  2   438 CV_TYPE (8):					/*cplx_flt_bin_2*/
  2   439       cv_field_real_part_value_ptr = cv_p_field_value_ptr;
  2   440       cv_vector_real_part_value_ptr = cv_p_vector_value_ptr;
  2   441       if arg_descriptor.packed
  2   442       then
  2   443          do;
  2   444 	  cv_vector_imaginary_part_value_ptr =
  2   445 	     addbitno (cv_p_vector_value_ptr, BITS_PER_EXPONENT + SIGN + arg_descriptor.size);
  2   446 	  cv_field_imaginary_part_value_ptr =
  2   447 	     addbitno (cv_p_field_value_ptr, BITS_PER_EXPONENT + SIGN + arg_descriptor.size);
  2   448          end;
  2   449       else
  2   450          do;
  2   451 	  cv_vector_imaginary_part_value_ptr = addbitno (cv_p_vector_value_ptr, 2 * BITS_PER_WORD);
  2   452 	  cv_field_imaginary_part_value_ptr = addbitno (cv_p_field_value_ptr, 2 * BITS_PER_WORD);
  2   453          end;
  2   454       cv_local_arg_descriptor = arg_descriptor;
  2   455       cv_local_arg_descriptor.type = real_flt_bin_2_dtype;
  2   456       call
  2   457          dmu_compare_values (addr (cv_local_arg_descriptor), cv_vector_real_part_value_ptr, cv_field_real_part_value_ptr,
  2   458          (DEFAULT_LENGTH), cv_p_vector_equal_to_key, cv_p_vector_less_than_key, cv_p_code);
  2   459       if cv_p_code ^= 0
  2   460       then return;
  2   461       if cv_p_vector_equal_to_key
  2   462       then call
  2   463 	    dmu_compare_values (addr (cv_local_arg_descriptor), cv_vector_imaginary_part_value_ptr,
  2   464 	    cv_field_imaginary_part_value_ptr, (DEFAULT_LENGTH), cv_p_vector_equal_to_key, cv_p_vector_less_than_key,
  2   465 	    cv_p_code);
  2   466       return;
  2   467 
  2   468 CV_TYPE (9):					/* real_fix_dec_9bit_ls */
  2   469       call
  2   470          dmu_compare_decimal_values$dmu_compare_dec9ls ((fixed_arg_descriptor.precision + SIGN), cv_p_vector_value_ptr,
  2   471          cv_p_field_value_ptr, cv_p_vector_equal_to_key, cv_p_vector_less_than_key);
  2   472       return;
  2   473 
  2   474 CV_TYPE (10):					/* real_flt_dec_9bit */
  2   475       call
  2   476          dmu_compare_decimal_values$dmu_compare_dec9fl ((arg_descriptor.size + SIGN + BIT9_DECIMAL_EXPONENT),
  2   477          cv_p_vector_value_ptr, cv_p_field_value_ptr, cv_p_vector_equal_to_key, cv_p_vector_less_than_key);
  2   478       return;
  2   479 
  2   480 CV_TYPE (11):					/* cplx_fix_dec_9bit_ls */
  2   481       cv_vector_real_part_value_ptr = cv_p_vector_value_ptr;
  2   482       cv_field_real_part_value_ptr = cv_p_field_value_ptr;
  2   483       cv_vector_imaginary_part_value_ptr = addcharno (cv_p_vector_value_ptr, fixed_arg_descriptor.precision + SIGN);
  2   484       cv_field_imaginary_part_value_ptr = addcharno (cv_p_field_value_ptr, fixed_arg_descriptor.precision + SIGN);
  2   485       call
  2   486          dmu_compare_decimal_values$dmu_compare_dec9ls ((fixed_arg_descriptor.precision + SIGN),
  2   487          cv_vector_real_part_value_ptr, cv_field_real_part_value_ptr, cv_p_vector_equal_to_key, cv_p_vector_less_than_key)
  2   488          ;
  2   489       if cv_p_vector_equal_to_key
  2   490       then call
  2   491 	    dmu_compare_decimal_values$dmu_compare_dec9ls ((fixed_arg_descriptor.precision + SIGN),
  2   492 	    cv_vector_imaginary_part_value_ptr, cv_field_imaginary_part_value_ptr, cv_p_vector_equal_to_key,
  2   493 	    cv_p_vector_less_than_key);
  2   494       return;
  2   495 
  2   496 CV_TYPE (12):					/* cplx_flt_dec_9bit */
  2   497       cv_vector_real_part_value_ptr = cv_p_vector_value_ptr;
  2   498       cv_field_real_part_value_ptr = cv_p_field_value_ptr;
  2   499       cv_vector_imaginary_part_value_ptr =
  2   500          addcharno (cv_p_vector_value_ptr, arg_descriptor.size + SIGN + BIT9_DECIMAL_EXPONENT);
  2   501       cv_field_imaginary_part_value_ptr =
  2   502          addcharno (cv_p_field_value_ptr, arg_descriptor.size + SIGN + BIT9_DECIMAL_EXPONENT);
  2   503 
  2   504       call
  2   505          dmu_compare_decimal_values$dmu_compare_dec9fl ((arg_descriptor.size + SIGN + BIT9_DECIMAL_EXPONENT),
  2   506          cv_vector_real_part_value_ptr, cv_field_real_part_value_ptr, cv_p_vector_equal_to_key, cv_p_vector_less_than_key)
  2   507          ;
  2   508       if cv_p_vector_equal_to_key
  2   509       then call
  2   510 	    dmu_compare_decimal_values$dmu_compare_dec9fl ((arg_descriptor.size + SIGN + BIT9_DECIMAL_EXPONENT),
  2   511 	    cv_vector_imaginary_part_value_ptr, cv_field_imaginary_part_value_ptr, cv_p_vector_equal_to_key,
  2   512 	    cv_p_vector_less_than_key);
  2   513       return;
  2   514 
  2   515 CV_TYPE (19):					/* bit (nonvarying) */
  2   516       if substr (cv_p_vector_value_ptr -> cv_bit_string, 1, arg_descriptor.size)
  2   517          = substr (cv_p_field_value_ptr -> cv_bit_string, 1, arg_descriptor.size)
  2   518       then goto CV_RETURN_EQUAL;
  2   519       else if substr (cv_p_vector_value_ptr -> cv_bit_string, 1, arg_descriptor.size)
  2   520 	    < substr (cv_p_field_value_ptr -> cv_bit_string, 1, arg_descriptor.size)
  2   521       then goto CV_RETURN_LESS;
  2   522       else goto CV_RETURN_GREATER;
  2   523 
  2   524 
  2   525 CV_TYPE (20):					/* varying_bit */
  2   526       if cv_p_vector_value_is_in_field_format
  2   527       then if substr (cv_p_vector_value_ptr -> cv_bit_string, 1, cv_p_vector_value_length)
  2   528 	    = substr (cv_p_field_value_ptr -> cv_bit_string, 1, cv_p_field_value_length)
  2   529 	 then goto CV_RETURN_EQUAL;
  2   530 	 else if substr (cv_p_vector_value_ptr -> cv_bit_string, 1, cv_p_vector_value_length)
  2   531 	         < substr (cv_p_field_value_ptr -> cv_bit_string, 1, cv_p_field_value_length)
  2   532 	 then goto CV_RETURN_LESS;
  2   533 	 else goto CV_RETURN_GREATER;
  2   534       else if substr (cv_p_vector_value_ptr -> cv_bit_string, BITS_PER_WORD + 1,
  2   535 	    cv_p_vector_value_ptr -> cv_based_real_fix_bin_1u)
  2   536 	    = substr (cv_p_field_value_ptr -> cv_bit_string, 1, cv_p_field_value_length)
  2   537       then goto CV_RETURN_EQUAL;
  2   538       else if substr (cv_p_vector_value_ptr -> cv_bit_string, BITS_PER_WORD + 1,
  2   539 	    cv_p_vector_value_ptr -> cv_based_real_fix_bin_1u)
  2   540 	    < substr (cv_p_field_value_ptr -> cv_bit_string, 1, cv_p_field_value_length)
  2   541       then goto CV_RETURN_LESS;
  2   542       else goto CV_RETURN_GREATER;
  2   543 
  2   544 CV_TYPE (21):					/* char (nonvarying) */
  2   545       if substr (cv_p_vector_value_ptr -> cv_char_string, 1, arg_descriptor.size)
  2   546          = substr (cv_p_field_value_ptr -> cv_char_string, 1, arg_descriptor.size)
  2   547       then goto CV_RETURN_EQUAL;
  2   548       else if substr (cv_p_vector_value_ptr -> cv_char_string, 1, arg_descriptor.size)
  2   549 	    < substr (cv_p_field_value_ptr -> cv_char_string, 1, arg_descriptor.size)
  2   550       then goto CV_RETURN_LESS;
  2   551       else goto CV_RETURN_GREATER;
  2   552 
  2   553 CV_TYPE (22):					/* varying_char */
  2   554       if cv_p_vector_value_is_in_field_format
  2   555       then if substr (cv_p_vector_value_ptr -> cv_char_string, 1, cv_p_vector_value_length)
  2   556 	    = substr (cv_p_field_value_ptr -> cv_char_string, 1, cv_p_field_value_length)
  2   557 	 then goto CV_RETURN_EQUAL;
  2   558 	 else if substr (cv_p_vector_value_ptr -> cv_char_string, 1, cv_p_vector_value_length)
  2   559 	         < substr (cv_p_field_value_ptr -> cv_char_string, 1, cv_p_field_value_length)
  2   560 	 then goto CV_RETURN_LESS;
  2   561 	 else goto CV_RETURN_GREATER;
  2   562       else if substr (cv_p_vector_value_ptr -> cv_char_string, BYTES_PER_WORD + 1,
  2   563 	    cv_p_vector_value_ptr -> cv_based_real_fix_bin_1u)
  2   564 	    = substr (cv_p_field_value_ptr -> cv_char_string, 1, cv_p_field_value_length)
  2   565       then goto CV_RETURN_EQUAL;
  2   566       else if substr (cv_p_vector_value_ptr -> cv_char_string, BYTES_PER_WORD + 1,
  2   567 	    cv_p_vector_value_ptr -> cv_based_real_fix_bin_1u)
  2   568 	    < substr (cv_p_field_value_ptr -> cv_char_string, 1, cv_p_field_value_length)
  2   569       then goto CV_RETURN_LESS;
  2   570       else goto CV_RETURN_GREATER;
  2   571 
  2   572 CV_TYPE (33):					/* real_fix_bin_1_uns */
  2   573       if arg_descriptor.packed
  2   574       then
  2   575          do;
  2   576 	  unspec (cv_local_vector_real_fix_bin_1_uns) =
  2   577 	     copy ("0"b, BITS_PER_WORD - fixed_arg_descriptor.precision)
  2   578 	     || substr (cv_p_vector_value_ptr -> cv_bit_string, 1, fixed_arg_descriptor.precision);
  2   579 	  unspec (cv_local_field_real_fix_bin_1_uns) =
  2   580 	     copy ("0"b, BITS_PER_WORD - fixed_arg_descriptor.precision)
  2   581 	     || substr (cv_p_field_value_ptr -> cv_bit_string, 1, fixed_arg_descriptor.precision);
  2   582 	  if cv_local_vector_real_fix_bin_1_uns = cv_local_field_real_fix_bin_1_uns
  2   583 	  then goto CV_RETURN_EQUAL;
  2   584 	  else if cv_local_vector_real_fix_bin_1_uns < cv_local_field_real_fix_bin_1_uns
  2   585 	  then goto CV_RETURN_LESS;
  2   586 	  else goto CV_RETURN_GREATER;
  2   587          end;
  2   588       else if cv_p_vector_value_ptr -> cv_based_real_fix_bin_1_unsa = cv_p_field_value_ptr -> cv_based_real_fix_bin_1_unsa
  2   589       then goto CV_RETURN_EQUAL;
  2   590       else if cv_p_vector_value_ptr -> cv_based_real_fix_bin_1_unsa < cv_p_field_value_ptr -> cv_based_real_fix_bin_1_unsa
  2   591       then goto CV_RETURN_LESS;
  2   592       else goto CV_RETURN_GREATER;
  2   593 
  2   594 CV_TYPE (34):					/* real_fix_bin_2_uns */
  2   595       if arg_descriptor.packed
  2   596       then
  2   597          do;
  2   598 	  unspec (cv_local_vector_real_fix_bin_2_uns) =
  2   599 	     copy ("0"b, 2 * BITS_PER_WORD - fixed_arg_descriptor.precision)
  2   600 	     || substr (cv_p_vector_value_ptr -> cv_bit_string, 1, fixed_arg_descriptor.precision);
  2   601 	  unspec (cv_local_field_real_fix_bin_2_uns) =
  2   602 	     copy ("0"b, 2 * BITS_PER_WORD - fixed_arg_descriptor.precision)
  2   603 	     || substr (cv_p_field_value_ptr -> cv_bit_string, 1, fixed_arg_descriptor.precision);
  2   604 	  if cv_local_vector_real_fix_bin_2_uns = cv_local_field_real_fix_bin_2_uns
  2   605 	  then goto CV_RETURN_EQUAL;
  2   606 	  else if cv_local_vector_real_fix_bin_2_uns < cv_local_field_real_fix_bin_2_uns
  2   607 	  then goto CV_RETURN_LESS;
  2   608 	  else goto CV_RETURN_GREATER;
  2   609          end;
  2   610       else if cv_p_vector_value_ptr -> cv_based_real_fix_bin_2_unsa = cv_p_field_value_ptr -> cv_based_real_fix_bin_2_unsa
  2   611       then goto CV_RETURN_EQUAL;
  2   612       else if cv_p_vector_value_ptr -> cv_based_real_fix_bin_2_unsa < cv_p_field_value_ptr -> cv_based_real_fix_bin_2_unsa
  2   613       then goto CV_RETURN_LESS;
  2   614       else goto CV_RETURN_GREATER;
  2   615 
  2   616 CV_TYPE (43):					/* real_fix_dec_4bit_bytealigned_ls */
  2   617       call
  2   618          dmu_compare_decimal_values$dmu_compare_dec4ls (fixed_arg_descriptor.precision + SIGN, cv_p_vector_value_ptr,
  2   619          cv_p_field_value_ptr, cv_p_vector_equal_to_key, cv_p_vector_less_than_key);
  2   620       return;
  2   621 
  2   622 CV_TYPE (44):					/* real_flt_dec_4bit_byte_alig ned_dtype */
  2   623       call
  2   624          dmu_compare_decimal_values$dmu_compare_dec4fl (arg_descriptor.size + SIGN + BIT4_DECIMAL_EXPONENT,
  2   625          cv_p_vector_value_ptr, cv_p_field_value_ptr, cv_p_vector_equal_to_key, cv_p_vector_less_than_key);
  2   626       return;
  2   627 
  2   628 CV_TYPE (45):					/* cplx_fix_dec_4bit_bytealigned_ls */
  2   629       cv_vector_real_part_value_ptr = cv_p_vector_value_ptr;
  2   630       cv_field_real_part_value_ptr = cv_p_field_value_ptr;
  2   631 
  2   632       cv_vector_imaginary_part_value_ptr =
  2   633          addcharno (cv_p_vector_value_ptr, ceil (divide (fixed_arg_descriptor.precision + 2, 2, 35, 18)));
  2   634       cv_field_imaginary_part_value_ptr =
  2   635          addcharno (cv_p_field_value_ptr, ceil (divide (fixed_arg_descriptor.precision + 2, 2, 35, 18)));
  2   636 
  2   637       call
  2   638          dmu_compare_decimal_values$dmu_compare_dec4ls (fixed_arg_descriptor.precision + SIGN,
  2   639          cv_vector_real_part_value_ptr, cv_field_real_part_value_ptr, cv_p_vector_equal_to_key, cv_p_vector_less_than_key)
  2   640          ;
  2   641       if cv_p_vector_equal_to_key
  2   642       then call
  2   643 	    dmu_compare_decimal_values$dmu_compare_dec4ls (fixed_arg_descriptor.precision + SIGN,
  2   644 	    cv_vector_imaginary_part_value_ptr, cv_field_imaginary_part_value_ptr, cv_p_vector_equal_to_key,
  2   645 	    cv_p_vector_less_than_key);
  2   646 
  2   647       return;
  2   648 
  2   649 CV_TYPE (46):					/* cplx_flt_dec_4bit_bytealigned */
  2   650       cv_vector_real_part_value_ptr = cv_p_vector_value_ptr;
  2   651       cv_field_real_part_value_ptr = cv_p_field_value_ptr;
  2   652 
  2   653       cv_vector_imaginary_part_value_ptr =
  2   654          addcharno (cv_p_vector_value_ptr, ceil (divide (fixed_arg_descriptor.precision + 4, 2, 35, 18)));
  2   655       cv_field_imaginary_part_value_ptr =
  2   656          addcharno (cv_p_field_value_ptr, ceil (divide (fixed_arg_descriptor.precision + 4, 2, 35, 18)));
  2   657 
  2   658       call
  2   659          dmu_compare_decimal_values$dmu_compare_dec4fl (arg_descriptor.size + SIGN + BIT4_DECIMAL_EXPONENT,
  2   660          cv_vector_real_part_value_ptr, cv_field_real_part_value_ptr, cv_p_vector_equal_to_key, cv_p_vector_less_than_key)
  2   661          ;
  2   662       if cv_p_vector_equal_to_key
  2   663       then call
  2   664 	    dmu_compare_decimal_values$dmu_compare_dec4fl (arg_descriptor.size + SIGN + BIT4_DECIMAL_EXPONENT,
  2   665 	    cv_vector_imaginary_part_value_ptr, cv_field_imaginary_part_value_ptr, cv_p_vector_equal_to_key,
  2   666 	    cv_p_vector_less_than_key);
  2   667 
  2   668       return;
  2   669 
  2   670 
  2   671 CV_TYPE (13):
  2   672 CV_TYPE (14):
  2   673 CV_TYPE (15):
  2   674 CV_TYPE (16):
  2   675 CV_TYPE (17):
  2   676 CV_TYPE (18):
  2   677 CV_TYPE (23):
  2   678 CV_TYPE (24):
  2   679 CV_TYPE (25):
  2   680 CV_TYPE (26):
  2   681 CV_TYPE (27):
  2   682 CV_TYPE (28):
  2   683 CV_TYPE (29):
  2   684 CV_TYPE (30):
  2   685 CV_TYPE (31):
  2   686 CV_TYPE (32):
  2   687 CV_TYPE (35):
  2   688 CV_TYPE (36):
  2   689 CV_TYPE (37):
  2   690 CV_TYPE (38):
  2   691 CV_TYPE (39):
  2   692 CV_TYPE (40):
  2   693 CV_TYPE (41):
  2   694 CV_TYPE (42):
  2   695       cv_p_code = dm_error_$unimplemented_data_type;
  2   696       return;
  2   697 
  2   698 CV_RETURN_EQUAL:
  2   699       cv_p_vector_equal_to_key = "1"b;
  2   700       cv_p_vector_less_than_key = "0"b;
  2   701       return;
  2   702 
  2   703 CV_RETURN_LESS:
  2   704       cv_p_vector_equal_to_key = "0"b;
  2   705       cv_p_vector_less_than_key = "1"b;
  2   706       return;
  2   707 
  2   708 CV_RETURN_GREATER:
  2   709       cv_p_vector_equal_to_key = "0"b;
  2   710       cv_p_vector_less_than_key = "0"b;
  2   711       return;
  2   712 
  3     1 /* BEGIN INCLUDE FILE ... arg_descriptor.incl.pl1
  3     2*
  3     3*   James R. Davis 1 Mar 79 */
  3     4 /* Modified June 83 JMAthane for extended arg descriptor format */
  3     5 
  3     6      dcl	   1 arg_descriptor	      based (arg_descriptor_ptr) aligned,
  3     7 	     2 flag	      bit (1) unal,
  3     8 	     2 type	      fixed bin (6) unsigned unal,
  3     9 	     2 packed	      bit (1) unal,
  3    10 	     2 number_dims	      fixed bin (4) unsigned unal,
  3    11 	     2 size	      fixed bin (24) unsigned unal;
  3    12 
  3    13      dcl	   1 fixed_arg_descriptor based (arg_descriptor_ptr) aligned,
  3    14 	     2 flag	      bit (1) unal,
  3    15 	     2 type	      fixed bin (6) unsigned unal,
  3    16 	     2 packed	      bit (1) unal,
  3    17 	     2 number_dims	      fixed bin (4) unsigned unal,
  3    18 	     2 scale	      fixed bin (11) unal,
  3    19 	     2 precision	      fixed bin (12) unsigned unal;
  3    20 
  3    21      dcl	   1 extended_arg_descriptor based (arg_descriptor_ptr) aligned,
  3    22 	     2 flag	      bit (1) unal,		/* = "1"b */
  3    23 	     2 type	      fixed bin (6) unsigned unal, /* = 58 */
  3    24 	     2 packed	      bit (1) unal,		/* significant if number_dims ^= 0 */
  3    25 	     2 number_dims	      fixed (4) unsigned unal,/* number of variable dimensions */
  3    26 	     2 size	      bit (24) unal,
  3    27 	     2 dims	      (0 refer (extended_arg_descriptor.number_dims)), /* part referenced by called generated code */
  3    28 	       3 low	      fixed bin (35),
  3    29 	       3 high	      fixed bin (35),
  3    30 	       3 multiplier	      fixed bin (35),	/* in bits if packed, in words if not */
  3    31 	     2 real_type	      fixed bin (18) unsigned unal,
  3    32 	     2 type_offset	      fixed bin (18) unsigned unal; /* offset rel to symbol tree to symbol node for type, if any */
  3    33 
  3    34      dcl	   arg_descriptor_ptr     ptr;
  3    35 
  3    36      dcl	   extended_arg_type      fixed bin init (58);
  3    37 
  3    38 /* END INCLUDE file .... arg_descriptor.incl.pl1  */
  2   713 
  2   714 
  4     1 /* BEGIN INCLUDE FILE ... std_descriptor_types.incl.pl1 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(86-09-05,JMAthane), approve(86-09-05,MCR7525),
  4     6*     audit(86-09-11,Martinson), install(86-11-12,MR12.0-1208):
  4     7*     Added pascal_string_type_dtype descriptor type.  Its number is 87.
  4     8*     Objects of this type are PASCAL string types.
  4     9*  2) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  4    10*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  4    11*     Added the new C types.
  4    12*                                                   END HISTORY COMMENTS */
  4    13 
  4    14 /* This include file defines mnemonic names for the Multics
  4    15*   standard descriptor types, using both pl1 and cobol terminology.
  4    16*   PG 780613
  4    17*   JRD 790530
  4    18*   JRD 791016
  4    19*   MBW 810731
  4    20*   TGO 830614 Add hex types.
  4    21*   Modified June 83 JMAthane to add PASCAL data types
  4    22*   TGO 840120 Add float dec extended and generic, float binary generic
  4    23**/
  4    24 
  4    25      dcl	   (real_fix_bin_1_dtype  init (1),
  4    26 	   real_fix_bin_2_dtype   init (2),
  4    27 	   real_flt_bin_1_dtype   init (3),
  4    28 	   real_flt_bin_2_dtype   init (4),
  4    29 	   cplx_fix_bin_1_dtype   init (5),
  4    30 	   cplx_fix_bin_2_dtype   init (6),
  4    31 	   cplx_flt_bin_1_dtype   init (7),
  4    32 	   cplx_flt_bin_2_dtype   init (8),
  4    33 	   real_fix_dec_9bit_ls_dtype init (9),
  4    34 	   real_flt_dec_9bit_dtype init (10),
  4    35 	   cplx_fix_dec_9bit_ls_dtype init (11),
  4    36 	   cplx_flt_dec_9bit_dtype init (12),
  4    37 	   pointer_dtype	      init (13),
  4    38 	   offset_dtype	      init (14),
  4    39 	   label_dtype	      init (15),
  4    40 	   entry_dtype	      init (16),
  4    41 	   structure_dtype	      init (17),
  4    42 	   area_dtype	      init (18),
  4    43 	   bit_dtype	      init (19),
  4    44 	   varying_bit_dtype      init (20),
  4    45 	   char_dtype	      init (21),
  4    46 	   varying_char_dtype     init (22),
  4    47 	   file_dtype	      init (23),
  4    48 	   real_fix_dec_9bit_ls_overp_dtype init (29),
  4    49 	   real_fix_dec_9bit_ts_overp_dtype init (30),
  4    50 	   real_fix_bin_1_uns_dtype init (33),
  4    51 	   real_fix_bin_2_uns_dtype init (34),
  4    52 	   real_fix_dec_9bit_uns_dtype init (35),
  4    53 	   real_fix_dec_9bit_ts_dtype init (36),
  4    54 	   real_fix_dec_4bit_uns_dtype init (38),	/* digit-aligned */
  4    55 	   real_fix_dec_4bit_ts_dtype init (39),	/* byte-aligned */
  4    56 	   real_fix_dec_4bit_bytealigned_uns_dtype init (40), /* COBOL */
  4    57 	   real_fix_dec_4bit_ls_dtype init (41),	/* digit-aligned */
  4    58 	   real_flt_dec_4bit_dtype init (42),		/* digit-aligned */
  4    59 	   real_fix_dec_4bit_bytealigned_ls_dtype init (43),
  4    60 	   real_flt_dec_4bit_bytealigned_dtype init (44),
  4    61 	   cplx_fix_dec_4bit_bytealigned_ls_dtype init (45),
  4    62 	   cplx_flt_dec_4bit_bytealigned_dtype init (46),
  4    63 	   real_flt_hex_1_dtype   init (47),
  4    64 	   real_flt_hex_2_dtype   init (48),
  4    65 	   cplx_flt_hex_1_dtype   init (49),
  4    66 	   cplx_flt_hex_2_dtype   init (50),
  4    67 	   c_typeref_dtype        init (54),
  4    68 	   c_enum_dtype           init (55),
  4    69              c_enum_const_dtype     init (56),
  4    70 	   c_union_dtype          init (57),
  4    71 	   algol68_straight_dtype init (59),
  4    72 	   algol68_format_dtype   init (60),
  4    73 	   algol68_array_descriptor_dtype init (61),
  4    74 	   algol68_union_dtype    init (62),
  4    75 
  4    76 	   cobol_comp_6_dtype     init (1),
  4    77 	   cobol_comp_7_dtype     init (1),
  4    78 	   cobol_display_ls_dtype init (9),
  4    79 	   cobol_structure_dtype  init (17),
  4    80 	   cobol_char_string_dtype init (21),
  4    81 	   cobol_display_ls_overp_dtype init (29),
  4    82 	   cobol_display_ts_overp_dtype init (30),
  4    83 	   cobol_display_uns_dtype init (35),
  4    84 	   cobol_display_ts_dtype init (36),
  4    85 	   cobol_comp_8_uns_dtype init (38),		/* digit aligned */
  4    86 	   cobol_comp_5_ts_dtype  init (39),		/* byte aligned */
  4    87 	   cobol_comp_5_uns_dtype init (40),
  4    88 	   cobol_comp_8_ls_dtype  init (41),		/* digit aligned */
  4    89 	   real_flt_dec_extended_dtype init (81),	/* 9-bit exponent */
  4    90 	   cplx_flt_dec_extended_dtype init (82),	/* 9-bit exponent */
  4    91 	   real_flt_dec_generic_dtype init (83),	/* generic float decimal */
  4    92 	   cplx_flt_dec_generic_dtype init (84),
  4    93 	   real_flt_bin_generic_dtype init (85),	/* generic float binary */
  4    94 	   cplx_flt_bin_generic_dtype init (86)) fixed bin internal static options (constant);
  4    95 
  4    96      dcl	   (ft_integer_dtype      init (1),
  4    97 	   ft_real_dtype	      init (3),
  4    98 	   ft_double_dtype	      init (4),
  4    99 	   ft_complex_dtype	      init (7),
  4   100 	   ft_complex_double_dtype init (8),
  4   101 	   ft_external_dtype      init (16),
  4   102 	   ft_logical_dtype	      init (19),
  4   103 	   ft_char_dtype	      init (21),
  4   104 	   ft_hex_real_dtype      init (47),
  4   105 	   ft_hex_double_dtype    init (48),
  4   106 	   ft_hex_complex_dtype   init (49),
  4   107 	   ft_hex_complex_double_dtype init (50)
  4   108 	   )		      fixed bin internal static options (constant);
  4   109 
  4   110      dcl	   (algol68_short_int_dtype init (1),
  4   111 	   algol68_int_dtype      init (1),
  4   112 	   algol68_long_int_dtype init (2),
  4   113 	   algol68_real_dtype     init (3),
  4   114 	   algol68_long_real_dtype init (4),
  4   115 	   algol68_compl_dtype    init (7),
  4   116 	   algol68_long_compl_dtype init (8),
  4   117 	   algol68_bits_dtype     init (19),
  4   118 	   algol68_bool_dtype     init (19),
  4   119 	   algol68_char_dtype     init (21),
  4   120 	   algol68_byte_dtype     init (21),
  4   121 	   algol68_struct_struct_char_dtype init (22),
  4   122 	   algol68_struct_struct_bool_dtype init (20)
  4   123 	   )		      fixed bin internal static options (constant);
  4   124 
  4   125      dcl	   (label_constant_runtime_dtype init (24),
  4   126 	   int_entry_runtime_dtype init (25),
  4   127 	   ext_entry_runtime_dtype init (26),
  4   128 	   ext_procedure_runtime_dtype init (27),
  4   129 	   picture_runtime_dtype  init (63)
  4   130 	   )		      fixed bin internal static options (constant);
  4   131 
  4   132      dcl	   (pascal_integer_dtype  init (1),
  4   133 	   pascal_real_dtype      init (4),
  4   134 	   pascal_label_dtype     init (24),
  4   135 	   pascal_internal_procedure_dtype init (25),
  4   136 	   pascal_exportable_procedure_dtype init (26),
  4   137 	   pascal_imported_procedure_dtype init (27),
  4   138 	   pascal_typed_pointer_type_dtype init (64),
  4   139 	   pascal_char_dtype      init (65),
  4   140 	   pascal_boolean_dtype   init (66),
  4   141 	   pascal_record_file_type_dtype init (67),
  4   142 	   pascal_record_type_dtype init (68),
  4   143 	   pascal_set_dtype	      init (69),
  4   144 	   pascal_enumerated_type_dtype init (70),
  4   145 	   pascal_enumerated_type_element_dtype init (71),
  4   146 	   pascal_enumerated_type_instance_dtype init (72),
  4   147 	   pascal_user_defined_type_dtype init (73),
  4   148 	   pascal_user_defined_type_instance_dtype init (74),
  4   149 	   pascal_text_file_dtype init (75),
  4   150 	   pascal_procedure_type_dtype init (76),
  4   151 	   pascal_variable_formal_parameter_dtype init (77),
  4   152 	   pascal_value_formal_parameter_dtype init (78),
  4   153 	   pascal_entry_formal_parameter_dtype init (79),
  4   154 	   pascal_parameter_procedure_dtype init (80),
  4   155 	   pascal_string_type_dtype init (87)) fixed bin int static options (constant);
  4   156 
  4   157 
  4   158 /* END INCLUDE FILE ... std_descriptor_types.incl.pl1 */
  2   715 
  2   716 
  5     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  5     2 /* format: style3 */
  5     3 
  5     4 /* These constants are to be used for the flags argument of sub_err_ */
  5     5 /* They are just "string (condition_info_header.action_flags)" */
  5     6 
  5     7 declare	(
  5     8 	ACTION_CAN_RESTART	init (""b),
  5     9 	ACTION_CANT_RESTART init ("1"b),
  5    10 	ACTION_DEFAULT_RESTART
  5    11 			init ("01"b),
  5    12 	ACTION_QUIET_RESTART
  5    13 			init ("001"b),
  5    14 	ACTION_SUPPORT_SIGNAL
  5    15 			init ("0001"b)
  5    16 	)		bit (36) aligned internal static options (constant);
  5    17 
  5    18 /* End include file */
  2   717 
  2   718    end COMPARE_VALUES;
  2   719 
  2   720 /* END INCLUDE FILE - dm_comp_vec_str_proc.incl.pl1 */
  1   321 
  1   322 
  6     1 /* ********** BEGIN INCLUDE FILE dm_field_table.incl.pl1 ********** */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*
  6     5*          The field_table describes the layout of a set of fields in a
  6     6*     formatted data string.  Such a string is the stored representation of a
  6     7*     record or a key.  Fields are placed side-by-side in the string in the
  6     8*     order they appear in the field_table.field array.  The string is divided
  6     9*     into the fixed portion and the varying portion.  In the fixed portion
  6    10*     appear fixed-length fields and fixed-size length-fields for
  6    11*     varying-length fields.  In the varying portion appear varying length
  6    12*     fields.  The length-field for a varying-length field contains the length
  6    13*     of the field values either in bits or in characte                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                *** */
  7     6 /* BEGIN INCLUDE FILE - vu_typed_vector.incl.pl1 */
  7     7 
  7     8 /* Written by Lindsey Spratt, 04/02/82.
  7     9*Modified:
  7    10*09/01/82 by Lindsey Spratt:  Changed value_ptr in simple_typed_vector to be
  7    11*	  unaligned.  Changed the type number of the simple_typed_vector to
  7    12*	  "3" from "1".  The OLD_SIMPLE_TYPED_VECTOR_TYPE is now an invalid
  7    13*	  type.
  7    14**/
  7    15 
  7    16 /* format: style2,ind3 */
  7    17      dcl	   1 simple_typed_vector  based (simple_typed_vector_ptr),
  7    18 	     2 type	      fixed bin (17) unal,
  7    19 	     2 number_of_dimensions
  7    20 			      fixed bin (17) unal,
  7    21 	     2 dimension	      (stv_number_of_dimensions refer (simple_typed_vector.number_of_dimensions)),
  7    22 	       3 value_ptr	      ptr unaligned;
  7    23 
  7    24      dcl	   1 general_typed_vector based (general_typed_vector_ptr),
  7    25 	     2 type	      fixed bin (17) unal,
  7    26 	     2 number_of_dimensions
  7    27 			      fixed bin (17) unal,
  7    28 	     2 dimension	      (gtv_number_of_dimensions refer (general_typed_vector.number_of_dimensions)),
  7    29 	       3 identifier	      fixed bin (17) unal,
  7    30 	       3 pad	      bit (18) unal,
  7    31 	       3 value_ptr	      ptr unal;
  7    32 
  7    33      dcl	   simple_typed_vector_ptr
  7    34 			      ptr;
  7    35      dcl	   stv_number_of_dimensions
  7    36 			      fixed bin (17);
  7    37 
  7    38      dcl	   general_typed_vector_ptr
  7    39 			      ptr;
  7    40      dcl	   gtv_number_of_dimensions
  7    41 			      fixed bin (17);
  7    42 
  7    43      dcl	   (
  7    44 	   OLD_SIMPLE_TYPED_VECTOR_TYPE
  7    45 			      init (1),		/* value_ptr was aligned. */
  7    46 	   GENERAL_TYPED_VECTOR_TYPE
  7    47 			      init (2),
  7    48 	   SIMPLE_TYPED_VECTOR_TYPE
  7    49 			      init (3)
  7    50 	   )		      fixed bin (17) internal static options (constant);
  7    51 
  7    52 /* END INCLUDE FILE - vu_typed_vector.incl.pl1 */
  1   325 
  1   326 
  8     1 /* BEGIN INCLUDE FILE ... arg_descriptor.incl.pl1
  8     2*
  8     3*   James R. Davis 1 Mar 79 */
  8     4 /* Modified June 83 JMAthane for extended arg descriptor format */
  8     5 
  8     6      dcl	   1 arg_descriptor	      based (arg_descriptor_ptr) aligned,
  8     7 	     2 flag	      bit (1) unal,
  8     8 	     2 type	      fixed bin (6) unsigned unal,
  8     9 	     2 packed	      bit (1) unal,
  8    10 	     2 number_dims	      fixed bin (4) unsigned unal,
  8    11 	     2 size	      fixed bin (24) unsigned unal;
  8    12 
  8    13      dcl	   1 fixed_arg_descriptor based (arg_descriptor_ptr) aligned,
  8    14 	     2 flag	      bit (1) unal,
  8    15 	     2 type	      fixed bin (6) unsigned unal,
  8    16 	     2 packed	      bit (1) unal,
  8    17 	     2 number_dims	      fixed bin (4) unsigned unal,
  8    18 	     2 scale	      fixed bin (11) unal,
  8    19 	     2 precision	      fixed bin (12) unsigned unal;
  8    20 
  8    21      dcl	   1 extended_arg_descriptor based (arg_descriptor_ptr) aligned,
  8    22 	     2 flag	      bit (1) unal,		/* = "1"b */
  8    23 	     2 type	      fixed bin (6) unsigned unal, /* = 58 */
  8    24 	     2 packed	      bit (1) unal,		/* significant if number_dims ^= 0 */
  8    25 	     2 number_dims	      fixed (4) unsigned unal,/* number of variable dimensions */
  8    26 	     2 size	      bit (24) unal,
  8    27 	     2 dims	      (0 refer (extended_arg_descriptor.number_dims)), /* part referenced by called generated code */
  8    28 	       3 low	      fixed bin (35),
  8    29 	       3 high	      fixed bin (35),
  8    30 	       3 multiplier	      fixed bin (35),	/* in bits if packed, in words if not */
  8    31 	     2 real_type	      fixed bin (18) unsigned unal,
  8    32 	     2 type_offset	      fixed bin (18) unsigned unal; /* offset rel to symbol tree to symbol node for type, if any */
  8    33 
  8    34      dcl	   arg_descriptor_ptr     ptr;
  8    35 
  8    36      dcl	   extended_arg_type      fixed bin init (58);
  8    37 
  8    38 /* END INCLUDE file .... arg_descriptor.incl.pl1  */
  1   327 
  1   328 
  9     1 /* BEGIN INCLUDE FILE ... std_descriptor_types.incl.pl1 */
  9     2 
  9     3 
  9     4 /****^  HISTORY COMMENTS:
  9     5*  1) change(86-09-05,JMAthane), approve(86-09-05,MCR7525),
  9     6*     audit(86-09-11,Martinson), install(86-11-12,MR12.0-1208):
  9     7*     Added pascal_string_type_dtype descriptor type.  Its number is 87.
  9     8*     Objects of this type are PASCAL string types.
  9     9*  2) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  9    10*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  9    11*     Added the new C types.
  9    12*                                                   END HISTORY COMMENTS */
  9    13 
  9    14 /* This include file defines mnemonic names for the Multics
  9    15*   standard descriptor types, using both pl1 and cobol terminology.
  9    16*   PG 780613
  9    17*   JRD 790530
  9    18*   JRD 791016
  9    19*   MBW 810731
  9    20*   TGO 830614 Add hex types.
  9    21*   Modified June 83 JMAthane to add PASCAL data types
  9    22*   TGO 840120 Add float dec extended and generic, float binary generic
  9    23**/
  9    24 
  9    25      dcl	   (real_fix_bin_1_dtype  init (1),
  9    26 	   real_fix_bin_2_dtype   init (2),
  9    27 	   real_flt_bin_1_dtype   init (3),
  9    28 	   real_flt_bin_2_dtype   init (4),
  9    29 	   cplx_fix_bin_1_dtype   init (5),
  9    30 	   cplx_fix_bin_2_dtype   init (6),
  9    31 	   cplx_flt_bin_1_dtype   init (7),
  9    32 	   cplx_flt_bin_2_dtype   init (8),
  9    33 	   real_fix_dec_9bit_ls_dtype init (9),
  9    34 	   real_flt_dec_9bit_dtype init (10),
  9    35 	   cplx_fix_dec_9bit_ls_dtype init (11),
  9    36 	   cplx_flt_dec_9bit_dtype init (12),
  9    37 	   pointer_dtype	      init (13),
  9    38 	   offset_dtype	      init (14),
  9    39 	   label_dtype	      init (15),
  9    40 	   entry_dtype	      init (16),
  9    41 	   structure_dtype	      init (17),
  9    42 	   area_dtype	      init (18),
  9    43 	   bit_dtype	      init (19),
  9    44 	   varying_bit_dtype      init (20),
  9    45 	   char_dtype	      init (21),
  9    46 	   varying_char_dtype     init (22),
  9    47 	   file_dtype	      init (23),
  9    48 	   real_fix_dec_9bit_ls_overp_dtype init (29),
  9    49 	   real_fix_dec_9bit_ts_overp_dtype init (30),
  9    50 	   real_fix_bin_1_uns_dtype init (33),
  9    51 	   real_fix_bin_2_uns_dtype init (34),
  9    52 	   real_fix_dec_9bit_uns_dtype init (35),
  9    53 	   real_fix_dec_9bit_ts_dtype init (36),
  9    54 	   real_fix_dec_4bit_uns_dtype init (38),	/* digit-aligned */
  9    55 	   real_fix_dec_4bit_ts_dtype init (39),	/* byte-aligned */
  9    56 	   real_fix_dec_4bit_bytealigned_uns_dtype init (40), /* COBOL */
  9    57 	   real_fix_dec_4bit_ls_dtype init (41),	/* digit-aligned */
  9    58 	   real_flt_dec_4bit_dtype init (42),		/* digit-aligned */
  9    59 	   real_fix_dec_4bit_bytealigned_ls_dtype init (43),
  9    60 	   real_flt_dec_4bit_bytealigned_dtype init (44),
  9    61 	   cplx_fix_dec_4bit_bytealigned_ls_dtype init (45),
  9    62 	   cplx_flt_dec_4bit_bytealigned_dtype init (46),
  9    63 	   real_flt_hex_1_dtype   init (47),
  9    64 	   real_flt_hex_2_dtype   init (48),
  9    65 	   cplx_flt_hex_1_dtype   init (49),
  9    66 	   cplx_flt_hex_2_dtype   init (50),
  9    67 	   c_typeref_dtype        init (54),
  9    68 	   c_enum_dtype           init (55),
  9    69              c_enum_const_dtype     init (56),
  9    70 	   c_union_dtype          init (57),
  9    71 	   algol68_straight_dtype init (59),
  9    72 	   algol68_format_dtype   init (60),
  9    73 	   algol68_array_descriptor_dtype init (61),
  9    74 	   algol68_union_dtype    init (62),
  9    75 
  9    76 	   cobol_comp_6_dtype     init (1),
  9    77 	   cobol_comp_7_dtype     init (1),
  9    78 	   cobol_display_ls_dtype init (9),
  9    79 	   cobol_structure_dtype  init (17),
  9    80 	   cobol_char_string_dtype init (21),
  9    81 	   cobol_display_ls_overp_dtype init (29),
  9    82 	   cobol_display_ts_overp_dtype init (30),
  9    83 	   cobol_display_uns_dtype init (35),
  9    84 	   cobol_display_ts_dtype init (36),
  9    85 	   cobol_comp_8_uns_dtype init (38),		/* digit aligned */
  9    86 	   cobol_comp_5_ts_dtype  init (39),		/* byte aligned */
  9    87 	   cobol_comp_5_uns_dtype init (40),
  9    88 	   cobol_comp_8_ls_dtype  init (41),		/* digit aligned */
  9    89 	   real_flt_dec_extended_dtype init (81),	/* 9-bit exponent */
  9    90 	   cplx_flt_dec_extended_dtype init (82),	/* 9-bit exponent */
  9    91 	   real_flt_dec_generic_dtype init (83),	/* generic float decimal */
  9    92 	   cplx_flt_dec_generic_dtype init (84),
  9    93 	   real_flt_bin_generic_dtype init (85),	/* generic float binary */
  9    94 	   cplx_flt_bin_generic_dtype init (86)) fixed bin internal static options (constant);
  9    95 
  9    96      dcl	   (ft_integer_dtype      init (1),
  9    97 	   ft_real_dtype	      init (3),
  9    98 	   ft_double_dtype	      init (4),
  9    99 	   ft_complex_dtype	      init (7),
  9   100 	   ft_complex_double_dtype init (8),
  9   101 	   ft_external_dtype      init (16),
  9   102 	   ft_logical_dtype	      init (19),
  9   103 	   ft_char_dtype	      init (21),
  9   104 	   ft_hex_real_dtype      init (47),
  9   105 	   ft_hex_double_dtype    init (48),
  9   106 	   ft_hex_complex_dtype   init (49),
  9   107 	   ft_hex_complex_double_dtype init (50)
  9   108 	   )		      fixed bin internal static options (constant);
  9   109 
  9   110      dcl	   (algol68_short_int_dtype init (1),
  9   111 	   algol68_int_dtype      init (1),
  9   112 	   algol68_long_int_dtype init (2),
  9   113 	   algol68_real_dtype     init (3),
  9   114 	   algol68_long_real_dtype init (4),
  9   115 	   algol68_compl_dtype    init (7),
  9   116 	   algol68_long_compl_dtype init (8),
  9   117 	   algol68_bits_dtype     init (19),
  9   118 	   algol68_bool_dtype     init (19),
  9   119 	   algol68_char_dtype     init (21),
  9   120 	   algol68_byte_dtype     init (21),
  9   121 	   algol68_struct_struct_char_dtype init (22),
  9   122 	   algol68_struct_struct_bool_dtype init (20)
  9   123 	   )		      fixed bin internal static options (constant);
  9   124 
  9   125      dcl	   (label_constant_runtime_dtype init (24),
  9   126 	   int_entry_runtime_dtype init (25),
  9   127 	   ext_entry_runtime_dtype init (26),
  9   128 	   ext_procedure_runtime_dtype init (27),
  9   129 	   picture_runtime_dtype  init (63)
  9   130 	   )		      fixed bin internal static options (constant);
  9   131 
  9   132      dcl	   (pascal_integer_dtype  init (1),
  9   133 	   pascal_real_dtype      init (4),
  9   134 	   pascal_label_dtype     init (24),
  9   135 	   pascal_internal_procedure_dtype init (25),
  9   136 	   pascal_exportable_procedure_dtype init (26),
  9   137 	   pascal_imported_procedure_dtype init (27),
  9   138 	   pascal_typed_pointer_type_dtype init (64),
  9   139 	   pascal_char_dtype      init (65),
  9   140 	   pascal_boolean_dtype   init (66),
  9   141 	   pascal_record_file_type_dtype init (67),
  9   142 	   pascal_record_type_dtype init (68),
  9   143 	   pascal_set_dtype	      init (69),
  9   144 	   pascal_enumerated_type_dtype init (70),
  9   145 	   pascal_enumerated_type_element_dtype init (71),
  9   146 	   pascal_enumerated_type_instance_dtype init (72),
  9   147 	   pascal_user_defined_type_dtype init (73),
  9   148 	   pascal_user_defined_type_instance_dtype init (74),
  9   149 	   pascal_text_file_dtype init (75),
  9   150 	   pascal_procedure_type_dtype init (76),
  9   151 	   pascal_variable_formal_parameter_dtype init (77),
  9   152 	   pascal_value_formal_parameter_dtype init (78),
  9   153 	   pascal_entry_formal_parameter_dtype init (79),
  9   154 	   pascal_parameter_procedure_dtype init (80),
  9   155 	   pascal_string_type_dtype init (87)) fixed bin int static options (constant);
  9   156 
  9   157 
  9   158 /* END INCLUDE FILE ... std_descriptor_types.incl.pl1 */
  1   329 
  1   330 
 10     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
 10     2 /* format: style3 */
 10     3 
 10     4 /* These constants are to be used for the flags argument of sub_err_ */
 10     5 /* They are just "string (condition_info_header.action_flags)" */
 10     6 
 10     7 declare	(
 10     8 	ACTION_CAN_RESTART	init (""b),
 10     9 	ACTION_CANT_RESTART init ("1"b),
 10    10 	ACTION_DEFAULT_RESTART
 10    11 			init ("01"b),
 10    12 	ACTION_QUIET_RESTART
 10    13 			init ("001"b),
 10    14 	ACTION_SUPPORT_SIGNAL
 10    15 			init ("0001"b)
 10    16 	)		bit (36) aligned internal static options (constant);
 10    17 
 10    18 /* End include file */
  1   331 
  1   332    end COMPARE_VECTOR_TO_STRING;
  1   333 
  1   334 /* END INCLUDE FILE - dm_comp_vec_str_proc.incl.pl1 */
     1437 
     1438 
 11     1 /* BEGIN INCLUDE FILE - dm_im_cursor.incl.pl1 */
 11     2 
 11     3 /* DESCRIPTION:
 11     4*
 11     5*          This structure specifies a DM file, an index collection in that DM
 11     6*file, and a position (key) in that index collection.
 11     7*
 11     8**/
 11     9 
 11    10 /* HISTORY:
 11    11*
 11    12*Written by Lindsey Spratt, 03/29/82
 11    13*Modified:
 11    14*08/09/82 by Matthew Pierret: Changed collection_id from "fixed bin (17)" to
 11    15*            "bit (35) aligned".
 11    16*08/26/82 by Lindsey Spratt:  Changed to version 2.  Added the is_valid and
 11    17*	  is_at_end_of_index flags.  Changed the key_check_value to fixed
 11    18*	  bin (35).  Added the IM_HASH_BIAS, which is used to increment the
 11    19*	  value developed by hash_index_, and IM_HASH_NUMBER_OF_BUCKETS,
 11    20*	  which is a unique number used by hash_index_ to develop the
 11    21*	  key_check_value.
 11    22*02/23/83 by Lindsey Spratt: Changed to keep the current key value in the
 11    23*	  cursor.  Also, implemented the ability to have the cursor
 11    24*	  positioned before or after the index.  
 11    25*10/23/84 by Lindsey L. Spratt:  Added a description section.
 11    26**/
 11    27 
 11    28 /* format: style2,ind3 */
 11    29      dcl	   1 index_cursor	      based (index_cursor_ptr),
 11    30 	     2 type	      fixed bin (17) unaligned,
 11    31 	     2 version	      fixed bin (17) unaligned,
 11    32 	     2 file_opening_id    bit (36) aligned,
 11    33 	     2 collection_id      bit (36) aligned,
 11    34 	     2 key_id_string      bit (36) aligned,	/* Is the location of the current key, */
 11    35 						/* if flags.current_key_exists is on. Is the location */
 11    36 						/* of the end of the index if flags.is_at_end_of_index */
 11    37 						/* is on, which is only available via an operation */
 11    38 						/* requiring the "previous" key.  Is the location of */
 11    39 						/* the "next" key, otherwise. */
 11    40 	     2 area_ptr	      ptr,		/* Area in which the cursor and key_string area allocated. */
 11    41 						/* Must be a freeing area. */
 11    42 	     2 current_key_string_ptr
 11    43 			      ptr,		/* Points to the value of the current key. */
 11    44 	     2 current_key_string_length
 11    45 			      fixed bin (24) unal,	/* Is the length of the current key in bits. */
 11    46 	     2 pad	      bit (12) unal,
 11    47 	     2 flags	      aligned,
 11    48 	       3 is_at_beginning_of_index
 11    49 			      bit (1) unaligned,	/* Only the "next" key is defined. */
 11    50 	       3 is_at_end_of_index
 11    51 			      bit (1) unaligned,	/* Only the "previous" key is defined. */
 11    52 	       3 current_key_exists
 11    53 			      bit (1) unaligned,	/* If on, indicates that the "current" key is identified */
 11    54 						/* by the key_id_string.  If off, the "current" position */
 11    55 						/* is undefined, and the key_id_string identifies the */
 11    56 						/* previous or next key, depending on whether */
 11    57 						/* flags.is_at_end_of_index is off or on, respectively. */
 11    58 	       3 is_valid	      bit (1) unaligned,	/* If off, the index_manager_ was interrupted while */
 11    59 						/* setting the cursor position and the cursor is not */
 11    60 						/* to be trusted for relative position operations. */
 11    61 	       3 pad	      bit (32) unal;
 11    62 
 11    63 
 11    64      dcl	   index_cursor_ptr	      ptr;
 11    65 
 11    66      dcl	   INDEX_CURSOR_VERSION_3 fixed bin (17) init (3) internal static options (constant);
 11    67      dcl	   INDEX_CURSOR_TYPE      init (2) fixed bin (17) internal static options (constant);
 11    68 
 11    69 /* END INCLUDE FILE - dm_im_cursor.incl.pl1 */
     1439 
     1440 
 12     1 /* BEGIN INCLUDE FILE - dm_im_ci_header.incl.pl1 */
 12     2 
 12     3 /* DESCRIPTION:
 12     4*
 12     5*          Each node (control interval) in the index has a header which
 12     6*     describes the contents of that node.  Although there are two different
 12     7*     kinds of headers, leaf and branch, they have a great deal in common, the
 12     8*     common_ci_header.  The common_ci_header states which slots are used by
 12     9*     the keys (leaf or branch) in the key_range substructure.  There is an
 12    10*     "upward pointer" to the node's parent branch key (parent_id_string).
 12    11*     There are pointers to the previous and next nodes (previous_id and
 12    12*     next_id) on the same level to facilitate rotation of keys, and sequential
 12    13*     searching.  There is also a count of how much space is in use by the keys.
 12    14*
 12    15**/
 12    16 
 12    17 /* HISTORY:
 12    18*
 12    19*Written by Lindsey Spratt, 03/29/82.
 12    20*Modified:
 12    21*10/25/84 by Lindsey L. Spratt:  Added a description and fixed the history
 12    22*            section format.
 12    23**/
 12    24 
 12    25 /* format: style2,ind3 */
 12    26      dcl	   1 common_ci_header     based (common_ci_header_ptr),
 12    27 	     2 flags	      unaligned,
 12    28 	       3 is_leaf	      bit (1) unaligned,	/* ON for leaf_ci, OFF for branch_ci. */
 12    29 	       3 pad	      bit (17) unaligned,	/* Must be zero. */
 12    30 	     2 key_tail_space_used_since_last_prefix_compaction
 12    31 			      fixed bin (18) unsigned unal,
 12    32 	     2 key_range	      unaligned,
 12    33 	       3 first	      fixed bin (18) unsigned,
 12    34 	       3 last	      fixed bin (18) unsigned,
 12    35 	     2 parent_id_string   bit (36) aligned,
 12    36 	     2 previous_id	      fixed bin (24) unsigned unaligned,
 12    37 	     2 next_id	      fixed bin (24) unsigned unaligned,
 12    38 	     2 pad	      bit (24) unaligned;
 12    39 
 12    40 
 12    41      dcl	   common_ci_header_ptr   ptr;
 12    42 
 12    43      dcl	   1 leaf_ci_header	      based (leaf_ci_header_ptr),
 12    44 	     2 common	      like common_ci_header;
 12    45 
 12    46      dcl	   leaf_ci_header_ptr     ptr;
 12    47 
 12    48      dcl	   1 branch_ci_header     based (branch_ci_header_ptr),
 12    49 	     2 common	      like common_ci_header,
 12    50 	     2 low_branch_id      fixed bin (24) unsigned unaligned,
 12    51 	     2 pad	      bit (12) unaligned;
 12    52 
 12    53      dcl	   branch_ci_header_ptr   ptr;
 12    54 
 12    55 
 12    56      dcl	   (
 12    57 	   DEFAULT_INITIAL_KEY_SLOT
 12    58 			      init (2),
 12    59 	   DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT
 12    60 			      init (1),
 12    61 	   LEAF_CI_HEADER_LENGTH_IN_BITS
 12    62 			      init (180),
 12    63 	   BRANCH_CI_HEADER_LENGTH_IN_BITS
 12    64 			      init (216)
 12    65 	   )		      internal static options (constant) fixed bin;
 12    66 
 12    67 /* END INCLUDE FILE - dm_im_ci_header.incl.pl1 */
     1441 
     1442 
 13     1 /* BEGIN INCLUDE FILE - dm_im_key.incl.pl1 */
 13     2 
 13     3 /* DESCRIPTION:
 13     4*
 13     5*          There are two formats for keys, the leaf_key structure and the
 13     6*     branch_key structure. The branch_key has two more pieces of information
 13     7*     than the leaf_key. One is the control interval id of the
 13     8*     node for all keys greater than the value of the branch key.  The other is
 13     9*     the number of fields for which there are values in the "string" portion
 13    10*     of the key.  This allows for the storing of only as much data as is needed
 13    11*     to discriminate between the children being split by the branch key.
 13    12**/
 13    13 
 13    14 /* HISTORY:
 13    15*
 13    16*Written by Lindsey Spratt, 03/29/82.
 13    17*Modified:
 13    18*10/25/84 by Lindsey L. Spratt:  Added history and description sections.
 13    19**/
 13    20 
 13    21 /* format: style2,ind3 */
 13    22      dcl	   key_string	      bit (key_string_length) based (key_string_ptr);
 13    23      dcl	   key_string_length      fixed bin (35);
 13    24      dcl	   key_string_ptr	      ptr;
 13    25 
 13    26      dcl	   1 leaf_key	      based (leaf_key_ptr) unaligned,
 13    27 	     2 string	      bit (lk_string_length) unal;
 13    28 
 13    29      dcl	   lk_string_length	      fixed bin (35);
 13    30      dcl	   leaf_key_ptr	      ptr;
 13    31 
 13    32      dcl	   1 branch_key	      based (branch_key_ptr) unaligned,
 13    33 	     2 branch_id	      fixed bin (24) unsigned unaligned,
 13    34 	     2 last_field_idx     fixed bin (12) unaligned unsigned,
 13    35 	     2 string	      bit (bk_string_length) unal;
 13    36 
 13    37      dcl	   BRANCH_KEY_HEADER_LENGTH_IN_BITS
 13    38 			      init (36) fixed bin (35) internal static options (constant);
 13    39      dcl	   bk_string_length	      fixed bin (35);
 13    40      dcl	   branch_key_ptr	      ptr;
 13    41 
 13    42 /* END INCLUDE FILE - dm_im_key.incl.pl1 */
     1443 
     1444 
 14     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
 14     2 
 14     3 /* DESCRIPTION:
 14     4*
 14     5*        Contains the declaration of an element identifier.  Element
 14     6*   identifiers consist of two parts, the id (number) of the control interval
 14     7*   in which the element resides, and the index into the slot table of
 14     8*   the element in the control interval.  The declaration of the element_id 
 14     9*   structure reflects this division of the element identifier.  The structure 
 14    10*   is based on the automatic bit string element_id_string because programs
 14    11*   generally pass bit strings (element_id_string) to each other, then 
 14    12*   interpret the bit string by overlaying the element_id structure ony if
 14    13*   it is necessary to access the parts of the id.  Basing element_id on
 14    14*   addr(element_id_string) instead of on a pointer removes the necessity
 14    15*   for always setting that pointer explicitly and guarantees that changes
 14    16*   made to the string or structure do not get inconsistent.
 14    17*
 14    18*   Changes made to element_id must also be made to datum_id, declared in 
 14    19*   dm_cm_datum.incl.pl1.
 14    20**/
 14    21 
 14    22 /* HISTORY:
 14    23*Written by Matthew Pierret, 04/01/82.
 14    24*Modified:
 14    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
 14    26**/
 14    27 
 14    28 /* format: style2,ind3,ll79 */
 14    29 
 14    30      dcl	   element_id_string      bit (36) aligned;
 14    31 
 14    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
 14    33 	     2 control_interval_id
 14    34 			      fixed bin (24) unal unsigned,
 14    35 	     2 index	      fixed bin (12) unal unsigned;
 14    36 
 14    37 
 14    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
     1445 
     1446 
 15     1 /* BEGIN INCLUDE FILE dm_ci_lengths.incl.pl1 */
 15     2 
 15     3 /* DESCRIPTION:
 15     4*       This include file contains constants which are the length in bytes
 15     5*   of the addressable portion of a control interval.  The addressable portion
 15     6*   is that part of the control interval which callers of file_manager_
 15     7*   may access, specifically, everything between the end of the control
 15     8*   interval header (ci_header) and the control interval trailer (ci_trailer).
 15     9*   Control interval 0 is slightly different, as it also contains an 
 15    10*   unaddressable portion in which it maintains the file attributes.  For
 15    11*   control interval 0 the addressable portion is everything between the end
 15    12*   of the control interval header and the beginning of the file attributes.
 15    13**/
 15    14 
 15    15 /* HISTORY:
 15    16*Written by Matthew Pierret, 11/02/84.
 15    17*Modified:
 15    18**/
 15    19 
 15    20 /* format: style2,ind3 */
 15    21 
 15    22      dcl	   CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES
 15    23 			      fixed bin (17) init (4072) int static options (constant);
 15    24 
 15    25      dcl	   CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES
 15    26 			      fixed bin (17) init (3176) int static options (constant);
 15    27 
 15    28 
 15    29      dcl	   CI_ADDRESSABLE_LENGTH  fixed bin (17) init (4072) int static options (constant);
 15    30 
 15    31      dcl	   CI_0_ADDRESSABLE_LENGTH
 15    32 			      fixed bin (17) init (3176) int static options (constant);
 15    33 
 15    34 /* END INCLUDE FILE dm_ci_lengths.incl.pl1 */
     1447 
     1448 
 16     1 /* BEGIN INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
 16     2 
 16     3 /* DESCRIPTION:
 16     4*     This include file contains declarations of all collection_manager_ 
 16     5*     entrypoints.
 16     6**/
 16     7 
 16     8 /* HISTORY:
 16     9*Written by Matthew Pierret 
 16    10*Modified:
 16    11*04/14/82 by Lindsey Spratt: Changed the control_interval_id parameter of the
 16    12*	  allocate_control_interval operation to be unaligned, as well as
 16    13*	  unsigned.
 16    14*06/17/82 by Matthew Pierret: Added the put_element_portion opertion and
 16    15*            removed the beginning_location parameter from the put_element
 16    16*            operation. Added the create_page_file_operation.
 16    17*08/09/82 by Matthew Pierret: Changed "fixed bin (17)"s to "bit (36) aligned"s
 16    18*            wherever collection_id was required.
 16    19*            Also changed the control_interval_id parameter of the 
 16    20*            allocate_control_interval operation back to be aligned. So there.
 16    21*10/20/82 by Matthew Pierret: Changed $create_page_file to $create_file,
 16    22*            added the argument file_create_info_ptr to $create_file.
 16    23*12/13/82 by Lindsey Spratt:  Corrected $free_control_interval to
 16    24*	  include the zero_on_free bit.
 16    25*12/17/82 by Matthew Pierret: Added cm_$get_id.
 16    26*01/07/83 by Matthew Pierret: Added cm_$put_element_buffered, 
 16    27*            cm_$allocate_element_buffered, cm_$free_element_buffered.
 16    28*04/27/83 by Matthew Pierret: Added cm_$put_unprotected_element,
 16    29*            cm_$put_unprotected_header.
 16    30*11/07/83 by Matthew Pierret: Added $get_element_portion_buffered,
 16    31*             $simple_get_buffered_element.
 16    32*02/08/84 by Matthew Pierret:  Changed $get_id to have only one bit(1)aligned
 16    33*            parameter for specifying absolute/relative nature of search.
 16    34*03/16/84 by Matthew Pierret:  Added cm_$get_control_interval_ptr,
 16    35*            $get_element_ptr, $get_element_portion_ptr, $simple_get_element_ptr
 16    36*04/03/84 by Matthew Pierret:  Added cm_$compact_control_interval.
 16    37*06/06/84 by Matthew Pierret:  Re-named free_element* to delete and
 16    38*            delete_from_ci_buffer.
 16    39*            Re-named *_buffered_ci to =_ci_buffer.
 16    40*            get entries.
 16    41*            modify entries.
 16    42*            Changed calling sequence of modify entries to have a ptr/length
 16    43*            instead of length/ptr parameter pair.
 16    44*03/11/85 by R. Michael Tague:  Added $postcommit_increments.
 16    45**/
 16    46 
 16    47 /* This include file contains declarations of collection_manager_ entrypoints */
 16    48 
 16    49 /* format: style2,ind3 */
 16    50      dcl	   collection_manager_$allocate_control_interval
 16    51 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
 16    52      dcl	   collection_manager_$compact_control_interval
 16    53 			      entry (bit (36) aligned, fixed bin (24) uns, fixed bin (35));
 16    54      dcl	   collection_manager_$create_collection
 16    55 			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
 16    56      dcl	   collection_manager_$create_file
 16    57 			      entry (char (*), char (*), ptr, bit (36) aligned, fixed bin (35));
 16    58      dcl	   collection_manager_$destroy_collection
 16    59 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
 16    60      dcl	   collection_manager_$free_control_interval
 16    61 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, bit (1) aligned,
 16    62 			      fixed bin (35));
 16    63 
 16    64      dcl	   collection_manager_$delete
 16    65 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
 16    66 			      fixed bin (35));
 16    67      dcl	   collection_manager_$delete_from_ci_buffer
 16    68 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
 16    69 			      fixed bin (35));
 16    70 
 16    71      dcl	   collection_manager_$get
 16    72 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
 16    73 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
 16    74      dcl	   collection_manager_$get_control_interval_ptr
 16    75 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, ptr,
 16    76 			      fixed bin (35));
 16    77      dcl	   collection_manager_$get_from_ci_buffer
 16    78 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
 16    79 			      ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
 16    80      dcl	   collection_manager_$get_by_ci_ptr
 16    81 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
 16    82 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), ptr, fixed bin (35));
 16    83      dcl	   collection_manager_$get_header
 16    84 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (17), ptr, bit (1) aligned,
 16    85 			      ptr, fixed bin (35), fixed bin (35));
 16    86      dcl	   collection_manager_$get_id
 16    87 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17),
 16    88 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
 16    89      dcl	   collection_manager_$get_portion
 16    90 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
 16    91 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
 16    92 			      fixed bin (35), fixed bin (35));
 16    93      dcl	   collection_manager_$get_portion_from_ci_buffer
 16    94 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
 16    95 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
 16    96 			      fixed bin (35));
 16    97      dcl	   collection_manager_$get_portion_by_ci_ptr
 16    98 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
 16    99 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
 16   100 			      fixed bin (35));
 16   101      dcl	   collection_manager_$modify
 16   102 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
 16   103 			      fixed bin (35), fixed bin (35));
 16   104      dcl	   collection_manager_$modify_unprotected
 16   105 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
 16   106 			      fixed bin (35), fixed bin (35));
 16   107      dcl	   collection_manager_$modify_in_ci_buffer
 16   108 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
 16   109 			      fixed bin (35), fixed bin (35));
 16   110      dcl	   collection_manager_$modify_portion
 16   111 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35), ptr,
 16   112 			      fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
 16   113      dcl	   collection_manager_$postcommit_increments
 16   114 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
 16   115      dcl	   collection_manager_$put
 16   116 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
 16   117 			      fixed bin (35), fixed bin (35));
 16   118      dcl	   collection_manager_$put_in_ci_buffer
 16   119 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
 16   120 			      fixed bin (35), fixed bin (35));
 16   121      dcl	   collection_manager_$put_header
 16   122 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
 16   123      dcl	   collection_manager_$put_unprotected_header
 16   124 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
 16   125 
 16   126      dcl	   collection_manager_$replace_ci_buffer
 16   127 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
 16   128 			      fixed bin (35));
 16   129      dcl	   collection_manager_$setup_ci_buffer
 16   130 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
 16   131 			      fixed bin (35));
 16   132      dcl	   collection_manager_$simple_get_by_ci_ptr
 16   133 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
 16   134 			      fixed bin (35));
 16   135      dcl	   collection_manager_$simple_get_from_ci_buffer
 16   136 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
 16   137 			      fixed bin (35));
 16   138 
 16   139 /* END INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
     1449 
     1450 
 17     1 /* ***********************************************************
 17     2*   *                                                         *
 17     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
 17     4*   *                                                         *
 17     5*   *********************************************************** */
 17     6 /* BEGIN INCLUDE FILE - vu_typed_vector.incl.pl1 */
 17     7 
 17     8 /* Written by Lindsey Spratt, 04/02/82.
 17     9*Modified:
 17    10*09/01/82 by Lindsey Spratt:  Changed value_ptr in simple_typed_vector to be
 17    11*	  unaligned.  Changed the type number of the simple_typed_vector to
 17    12*	  "3" from "1".  The OLD_SIMPLE_TYPED_VECTOR_TYPE is now an invalid
 17    13*	  type.
 17    14**/
 17    15 
 17    16 /* format: style2,ind3 */
 17    17      dcl	   1 simple_typed_vector  based (simple_typed_vector_ptr),
 17    18 	     2 type	      fixed bin (17) unal,
 17    19 	     2 number_of_dimensions
 17    20 			      fixed bin (17) unal,
 17    21 	     2 dimension	      (stv_number_of_dimensions refer (simple_typed_vector.number_of_dimensions)),
 17    22 	       3 value_ptr	      ptr unaligned;
 17    23 
 17    24      dcl	   1 general_typed_vector based (general_typed_vector_ptr),
 17    25 	     2 type	      fixed bin (17) unal,
 17    26 	     2 number_of_dimensions
 17    27 			      fixed bin (17) unal,
 17    28 	     2 dimension	      (gtv_number_of_dimensions refer (general_typed_vector.number_of_dimensions)),
 17    29 	       3 identifier	      fixed bin (17) unal,
 17    30 	       3 pad	      bit (18) unal,
 17    31 	       3 value_ptr	      ptr unal;
 17    32 
 17    33      dcl	   simple_typed_vector_ptr
 17    34 			      ptr;
 17    35      dcl	   stv_number_of_dimensions
 17    36 			      fixed bin (17);
 17    37 
 17    38      dcl	   general_typed_vector_ptr
 17    39 			      ptr;
 17    40      dcl	   gtv_number_of_dimensions
 17    41 			      fixed bin (17);
 17    42 
 17    43      dcl	   (
 17    44 	   OLD_SIMPLE_TYPED_VECTOR_TYPE
 17    45 			      init (1),		/* value_ptr was aligned. */
 17    46 	   GENERAL_TYPED_VECTOR_TYPE
 17    47 			      init (2),
 17    48 	   SIMPLE_TYPED_VECTOR_TYPE
 17    49 			      init (3)
 17    50 	   )		      fixed bin (17) internal static options (constant);
 17    51 
 17    52 /* END INCLUDE FILE - vu_typed_vector.incl.pl1 */
     1451 
     1452 
 18     1 /* BEGIN INCLUDE FILE - dm_im_opening_info.incl.pl1 */
 18     2 
 18     3 /* DESRIPTION:
 18     4*
 18     5*          The index_opening_info is per-process information, stored in a
 18     6*     hash_table managed by the opening_manager_, which allows the
 18     7*     index_manager_ to quickly reference certain unchanging pieces of
 18     8*     information rapidly.
 18     9**/
 18    10 
 18    11 /* HISTORY:
 18    12*
 18    13*Written by Lindsey Spratt, 10/28/82.
 18    14*Modified:
 18    15*10/26/84 by Lindsey L. Spratt:  Changed version to char(8).  Added a
 18    16*            description.  Added the current_rollback_count.  Added the
 18    17*	  key_count_array_ptr.
 18    18*03/07/85 by R. Michael Tague:  Added key_count_increments_ptr and 
 18    19*	  key_counts_postcommit_written.  Changed to version 3.
 18    20*03/25/85 by R. Michael Tague:  Added key_count_unprotected_file.  This
 18    21*	  flag is used by im_update_opening_info to help it maintain the
 18    22*	  key count array info.
 18    23**/
 18    24 
 18    25 /* format: style2,ind3 */
 18    26      dcl	   1 index_opening_info   based (index_opening_info_ptr) aligned,
 18    27 	     2 version	      char (8) aligned,
 18    28 	     2 file_opening_id    bit (36) aligned,
 18    29 	     2 collection_id      bit (36) aligned,
 18    30 	     2 index_header_ptr   ptr init (null),
 18    31 	     2 field_table_ptr    ptr init (null),
 18    32 	     2 key_count_array_ptr
 18    33 			      ptr init (null),
 18    34 	     2 key_count_increments_ptr
 18    35 			      ptr init (null),
 18    36 	     2 flags,
 18    37 	       3 key_count_postcommit_written
 18    38 			      bit (1) unal init ("0"b),
 18    39 	       3 key_count_unprotected_file
 18    40 			      bit (1) unal init ("0"b),
 18    41 	       3 pad	      bit (34) unal init (""b),
 18    42 	     2 current_txn_id     fixed bin (35) init (0),
 18    43 	     2 current_rollback_count
 18    44 			      fixed bin (35) init (0);
 18    45 
 18    46      dcl	   index_opening_info_ptr ptr init (null);
 18    47      dcl	   INDEX_OPENING_INFO_VERSION_3
 18    48 			      init ("IdxOpn 3") char (8) aligned internal static options (constant);
 18    49 
 18    50 /* END INCLUDE FILE - dm_im_opening_info.incl.pl1 */
     1453 
     1454 
 19     1 /* BEGIN INCLUDE FILE - dm_im_header.incl.pl1 */
 19     2 
 19     3 /* DESCRIPTION:
 19     4*
 19     5*          The index_header structure is stored in the header element of an
 19     6*     index collection and describes basic information about the index.
 19     7**/
 19     8 
 19     9 /* HISTORY:
 19    10*
 19    11*Written by Lindsey Spratt, 04/02/82.
 19    12*Modified:
 19    13*10/28/82 by Lindsey Spratt:  Changed to version 3.  Added the key_count_array.
 19    14*	  count(0) is the number of keys in the index.  count(N) is the
 19    15*	  number of keys in the index which have at least fields 1 through N
 19    16*	  having the same value as another key in the index, i.e. count(N)
 19    17*	  is the number of partial duplicates with number of partial
 19    18*	  duplication fields equal to N.
 19    19*10/24/84 by Lindsey L. Spratt:  Added a description. Converted to version 4.
 19    20*	  Replaced the key_count_array with a key_count_array_element_id.
 19    21*	  Changed the version field to char(8).  Aligned the structure.
 19    22**/
 19    23 
 19    24 /* format: style2,ind3 */
 19    25      dcl	   1 index_header	      aligned based (index_header_ptr),
 19    26 	     2 version	      char (8) aligned,
 19    27 	     2 field_table_element_id
 19    28 			      like element_id,
 19    29 	     2 root_id	      fixed bin (24) unsigned unaligned,
 19    30 	     2 pad1	      bit (12) unaligned,
 19    31 	     2 number_of_duplication_fields
 19    32 			      fixed bin (17) unal,
 19    33 	     2 pad2	      bit (18) unal,
 19    34 	     2 key_count_array_element_id
 19    35 			      like element_id;
 19    36 
 19    37      dcl	   index_header_ptr	      ptr;
 19    38      dcl	   INDEX_HEADER_VERSION_4 init ("IdxHdr 4") char (8) aligned internal static options (constant);
 19    39 
 19    40 /* END INCLUDE FILE - dm_im_header.incl.pl1 */
     1455 
     1456 
 20     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
 20     2 /* format: style3 */
 20     3 
 20     4 /* These constants are to be used for the flags argument of sub_err_ */
 20     5 /* They are just "string (condition_info_header.action_flags)" */
 20     6 
 20     7 declare	(
 20     8 	ACTION_CAN_RESTART	init (""b),
 20     9 	ACTION_CANT_RESTART init ("1"b),
 20    10 	ACTION_DEFAULT_RESTART
 20    11 			init ("01"b),
 20    12 	ACTION_QUIET_RESTART
 20    13 			init ("001"b),
 20    14 	ACTION_SUPPORT_SIGNAL
 20    15 			init ("0001"b)
 20    16 	)		bit (36) aligned internal static options (constant);
 20    17 
 20    18 /* End include file */
     1457 
     1458 
 21     1 /* ********** BEGIN INCLUDE FILE dm_field_table.incl.pl1 ********** */
 21     2 
 21     3 /* DESCRIPTION:
 21     4*
 21     5*          The field_table describes the layout of a set of fields in a
 21     6*     formatted data string.  Such a string is the stored representation of a
 21     7*     record or a key.  Fields are placed side-by-side in the string in the
 21     8*     order they appear in the field_table.field array.  The string is divided
 21     9*     into the fixed portion and the varying portion.  In the fixed portion
 21    10*     appear fixed-length fields and fixed-size length-fields for
 21    11*     varying-length fields.  In the varying portion appear varying length
 21    12*     fields.  The length-field for a varying-length field contains the length
 21    13*     of the field values either in bits or in characters, depending on the
 21    14*     data type of the field.
 21    15**/
 21    16 
 21    17 /* HISTORY:
 21    18*Written by Matthew Pierret, 04/01/82.
 21    19*Modified:
 21    20*04/20/82 by Matthew Pierret: Added length_is_in_characters, meaning, if on,
 21    21*	  that if the field is varying, its length is expressed in
 21    22*	  bytes/characters.
 21    23*03/22/83 by Lindsey Spratt:  Changed lofvf to have a precision of 35 instead
 21    24*	  of 17, changed version to 2, changed version field to char(8) from
 21    25*	  fixed bin (17).
 21    26*05/01/84 by Matthew Pierret:  Changed version to 3. Removed field.name and
 21    27*            put field names in one string (field_names) at the end of the 
 21    28*            structure. Added field.location_of_name and field.length_of_name
 21    29*            for locating the field name in field_names. Aligned all "fixed bin"
 21    30*            structure elements.  Changed maximum_field_name_length to 
 21    31*            length_of_field_names.
 21    32**/
 21    33 
 21    34 /* format: style2 */
 21    35 
 21    36      dcl	   1 field_table	      aligned based (field_table_ptr),
 21    37 	     2 version	      char (8) aligned init (FIELD_TABLE_VERSION_3),
 21    38 	     2 number_of_fields   fixed bin (17),
 21    39 	     2 length_of_field_names
 21    40 			      fixed bin (17),	/* length of field_names in characters */
 21    41 	     2 location_of_first_varying_field
 21    42 			      fixed bin (35),	/* location of first bit in the varying portion of the formatted string */
 21    43 	     2 field	      (ft_number_of_fields refer (field_table.number_of_fields)),
 21    44 	       3 flags	      aligned,
 21    45 	         4 descriptor_is_varying
 21    46 			      bit (1) unal,		/* if on, the descriptor is not limited to the standard 36 bits */
 21    47 						/* and is stored in a stand-alone fashion, with field.descriptor */
 21    48 						/* containing the id of the element in which the descriptor is stored. */
 21    49 	         4 length_is_in_characters
 21    50 			      bit (1) unal,		/* if field is varying, the length field describes its length */
 21    51 						/* in characters instead of in bits */
 21    52 	         4 must_be_zero   bit (34) unal,
 21    53 	       3 descriptor	      bit (36) aligned,
 21    54 	       3 location	      fixed bin (35),	/* location of first bit of field in formatted string */
 21    55 	       3 length_in_bits   fixed bin (35),	/* length of field in bits */
 21    56 	     3 location_of_name   fixed bin (17),	/* location of first character of field name in field_names */
 21    57 	     3 length_of_name     fixed bin (17),	/* length of name in characters */
 21    58 	     2 varying_field_map  (ft_number_of_fields refer (field_table.number_of_fields)),
 21    59 	       3 field_id	      fixed bin (17),	/* field_id of Nth varying field */
 21    60 	       3 varying_field_index
 21    61 			      fixed bin (17),	/* ordinality among varying fields of field N */
 21    62 	     2 field_names	      char (ft_length_of_field_names refer (field_table.length_of_field_names));
 21    63 
 21    64 
 21    65      dcl	   field_table_ptr	      ptr;
 21    66      dcl	   ft_length_of_field_names
 21    67 			      fixed bin;
 21    68      dcl	   ft_number_of_fields    fixed bin;
 21    69      dcl	   FIELD_TABLE_VERSION_3  char (8) aligned init ("FldTbl 3") internal static options (constant);
 21    70 
 21    71 dcl field_name char (field_name_length) based (field_name_ptr);
 21    72 
 21    73 dcl field_name_length fixed bin;
 21    74 dcl field_name_ptr ptr;
 21    75 
 21    76 /* END INCLUDE FILE dm_field_table.incl.pl1 */
     1459 
     1460 
 22     1 /* BEGIN INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
 22     2 
 22     3 /* DESCRIPTION:
 22     4*
 22     5*        The collection_manager_ manages the structure of the addressable
 22     6*   portion of a control interval.  The addressable portion is that portion of
 22     7*   a control interval which the file_manager_ will allow the
 22     8*   collection_manager_ to address.  In this description control interval will
 22     9*   be used to mean the addressable portion of a control interval.
 22    10*   
 22    11*        A control interval is divided into four parts: the header, the datum
 22    12*   position table (also known as the slot table or slots), un-used space and
 22    13*   used space.  The beginning of the header is at offset 0, and the end of the
 22    14*   used space is at the end of the control interval (curently offset 4072).
 22    15*   Pictoriarly, a control interval is structured as follows:
 22    16*   
 22    17*   ----------------------------------------------------------------------
 22    18*   |        || | | | | | ||               ||   | / / |       |/|   |    |
 22    19*   | Header || | slot  | || un-used space ||   |/ / /|       |/|   |    |
 22    20*   |        || | table | ||               ||   | / / |       |/|   |    |
 22    21*   |        || | | | | | ||               ||   |/ / /|       |/|   |    |
 22    22*   ----------------------------------------------------------------------
 22    23*                                           ^ ^    ^      ^    ^  ^   ^
 22    24*                                           | |    |      |    |  |   |
 22    25*                                           | |...........|.......|...|
 22    26*                        start of used space|      |           |      |
 22    27*                                                  |           |  each|
 22    28*                                          scattered free space|  is a used
 22    29*                                                                 datum
 22    30*   
 22    31*      The basic_control_interval structure describes the header
 22    32*   (basic_control_interval.header, bci_header) and the slots
 22    33*   (basic_control_interval.datum_position_table, datum_slot for one only).
 22    34*   Each datum_slot contains the offset (in bytes) and the length (in bits) of
 22    35*   a datum in the used space.  If the offset is equal to FREE_SLOT (declared
 22    36*   in dm_cm_basic_ci_const.incl.pl1), the slot is un-used.  The slot also
 22    37*   contains flags describing the type of datum (see dm_cm_datum.incl.pl1).
 22    38**/
 22    39 
 22    40 /* HISTORY:
 22    41*Written by Matthew Pierret, 02/07/82.
 22    42*Modified:
 22    43*03/25/82 by Matthew Pierret: Fixed alignment differences basic_control_interval
 22    44*            and its sub-structures.
 22    45*06/14/82 by Matthew Pierret: Removed common header and buffers. Changed
 22    46*            basic_ci_header to bci_header. Added previous_control_interval.
 22    47*07/12/82 by Matthew Pierret: Changed collection_id to be bit (36) aligned.
 22    48*10/29/82 by Matthew Pierret: Added flags to datum slots. 
 22    49*11/10/82 by Matthew Pierret: Removed continued_datum_is_present flag, as it
 22    50*            is not used.
 22    51*03/28/84 by Matthew Pierret: Added the constants BCI_HEADER_LENGTH_IN_BYTES
 22    52*            and DATUM_POSITION_TABLE_OFFSET_IN_BYTES.
 22    53**/
 22    54 
 22    55 /* format: style2 */
 22    56      dcl	   1 basic_control_interval
 22    57 			      aligned based (basic_control_interval_ptr),
 22    58 	     2 header	      like bci_header,
 22    59 	     2 datum_position_table
 22    60 			      (0 refer (basic_control_interval.number_of_datums)) like datum_slot;
 22    61 
 22    62 
 22    63      dcl	   1 bci_header	      aligned based (bci_header_ptr),
 22    64 	     2 layout_type	      char (4) aligned,
 22    65 	     2 collection_id      bit (36) aligned,
 22    66 	     2 next_control_interval
 22    67 			      fixed bin (24) uns unal,
 22    68 	     2 previous_control_interval
 22    69 			      fixed bin (24) uns unal,
 22    70 	     2 flags	      unal,
 22    71 	       3 continuation_datum_is_present
 22    72 			      bit (1) unal,
 22    73 	       3 free_slot_is_present
 22    74 			      bit (1) unal,
 22    75 	       3 must_be_zero     bit (4) unal,		/* reserved */
 22    76 	     2 scattered_free_space
 22    77 			      fixed bin (17) unal,
 22    78 	     2 start_of_used_space
 22    79 			      fixed bin (17) unal,
 22    80 	     2 number_of_datums   fixed bin (17) unal;
 22    81 
 22    82      dcl	   1 datum_slot	      aligned based (datum_slot_ptr),
 22    83 	     2 flags	      unal,
 22    84 	       3 special_format_datum
 22    85 			      bit (1) unal,		/* reserved */
 22    86 	       3 is_continued     bit (1) unal,
 22    87 	       3 is_continuation  bit (1) unal,
 22    88 	       3 mbz	      bit (1) unal,		/* reserved */
 22    89 	     2 offset_in_bytes    fixed bin (15) uns unal,
 22    90 	     2 length_in_bits     fixed bin (17) uns unal;
 22    91 
 22    92      dcl	   basic_control_interval_ptr
 22    93 			      ptr;
 22    94      dcl	   bci_header_ptr	      ptr;
 22    95      dcl	   datum_slot_ptr	      ptr;
 22    96 
 22    97      dcl	   BASIC_CI_LAYOUT_1      char (4) aligned init ("bci1") internal static options (constant);
 22    98 
 22    99 /* END INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
     1461 
     1462 
 23     1 /* BEGIN INCLUDE FILE dm_cm_basic_ci_const.incl.pl1 */
 23     2 
 23     3 /* DESCRIPTION:
 23     4*
 23     5*   Contains constants useful in describing parts of a basic control interval.
 23     6**/
 23     7 
 23     8 /* HISTORY:
 23     9*Written by Matthew Pierret, 09/20/84.
 23    10*Modified:
 23    11**/
 23    12 
 23    13      dcl	   FREE_SLOT	      init (0) fixed bin (15) uns internal static options (constant);
 23    14      dcl	   BCI_HEADER_LENGTH_IN_BYTES
 23    15 			      init (20) fixed bin internal static options (constant);
 23    16      dcl	   DATUM_POSITION_TABLE_OFFSET_IN_BYTES
 23    17 			      init (20) fixed bin internal static options (constant);
 23    18 
 23    19 
 23    20 /* END INCLUDE FILE dm_cm_basic_ci_const.incl.pl1 */
     1463 
     1464 
     1465    end im_basic_search;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/24/88  1358.8  im_basic_search.pl1               >special_ldd>install>MR12.2-1184>im_basic_search.pl1
1437         1    04/09/87  0850.7  dm_comp_vec_str_proc.incl.pl1     >ldd>include>dm_comp_vec_str_proc.incl.pl1
1-321        2    07/20/87  1749.7  dm_comp_values_proc.incl.pl1      >ldd>include>dm_comp_values_proc.incl.pl1
2-713        3    11/02/83  1845.0  arg_descriptor.incl.pl1           >ldd>include>arg_descriptor.incl.pl1
2-715        4    10/24/88  1336.9  std_descriptor_types.incl.pl1     >special_ldd>install>MR12.2-1184>std_descriptor_types.incl.pl1
2-717        5    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
1-323        6    01/07/85  0858.8  dm_field_table.incl.pl1           >ldd>include>dm_field_table.incl.pl1
1-325        7    10/14/83  1609.1  vu_typed_vector.incl.pl1          >ldd>include>vu_typed_vector.incl.pl1
1-327        8    11/02/83  1845.0  arg_descriptor.incl.pl1           >ldd>include>arg_descriptor.incl.pl1
1-329        9    10/24/88  1336.9  std_descriptor_types.incl.pl1     >special_ldd>install>MR12.2-1184>std_descriptor_types.incl.pl1
1-331       10    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
1439        11    01/07/85  0858.9  dm_im_cursor.incl.pl1             >ldd>include>dm_im_cursor.incl.pl1
1441        12    01/07/85  0858.8  dm_im_ci_header.incl.pl1          >ldd>include>dm_im_ci_header.incl.pl1
1443        13    01/07/85  0858.9  dm_im_key.incl.pl1                >ldd>include>dm_im_key.incl.pl1
1445        14    01/07/85  0858.5  dm_element_id.incl.pl1            >ldd>include>dm_element_id.incl.pl1
1447        15    01/07/85  0900.7  dm_ci_lengths.incl.pl1            >ldd>include>dm_ci_lengths.incl.pl1
1449        16    04/05/85  0924.4  dm_collmgr_entry_dcls.incl.pl1    >ldd>include>dm_collmgr_entry_dcls.incl.pl1
1451        17    10/14/83  1609.1  vu_typed_vector.incl.pl1          >ldd>include>vu_typed_vector.incl.pl1
1453        18    04/05/85  0924.4  dm_im_opening_info.incl.pl1       >ldd>include>dm_im_opening_info.incl.pl1
1455        19    01/07/85  0858.9  dm_im_header.incl.pl1             >ldd>include>dm_im_header.incl.pl1
1457        20    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
1459        21    01/07/85  0858.8  dm_field_table.incl.pl1           >ldd>include>dm_field_table.incl.pl1
1461        22    01/07/85  0858.0  dm_cm_basic_ci.incl.pl1           >ldd>include>dm_cm_basic_ci.incl.pl1
1463        23    01/07/85  0858.1  dm_cm_basic_ci_const.incl.pl1     >ldd>include>dm_cm_basic_ci_const.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000211 constant        bit(36)                  initial dcl 5-7 in procedure "COMPARE_VALUES" set
                                                                                  ref 2-226* 2-232* 2-237*
ACTION_CANT_RESTART             000211 constant        bit(36)                  initial dcl 10-7 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING" set ref 1-165* 1-171*
ACTION_CANT_RESTART             000211 constant        bit(36)                  initial dcl 20-7 in procedure "im_basic_search" set
                                                                                  ref 418* 556* 802* 907* 910* 1023* 1028* 1038*
ALL_FIELDS_ARE_PRESENT                 constant        fixed bin(17,0)          initial packed unaligned dcl 371 ref 601
BIT4_DECIMAL_EXPONENT                  constant        fixed bin(17,0)          initial dcl 2-174 ref 2-622 2-658 2-662
BIT9_DECIMAL_EXPONENT                  constant        fixed bin(17,0)          initial dcl 2-174 ref 2-474 2-499 2-501 2-504 2-508
BITS_PER_BYTE                          constant        fixed bin(17,0)          initial dcl 1-141 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING" ref 1-199 1-230 1-277
BITS_PER_BYTE                          constant        fixed bin(17,0)          initial packed unaligned dcl 371 in procedure
                                                                                  "im_basic_search" ref 916 987 990
BITS_PER_EXPONENT                      constant        fixed bin(17,0)          initial dcl 2-174 ref 2-309 2-309 2-312 2-312 2-333
                                                                                  2-333 2-336 2-336 2-414 2-416 2-444 2-446
BITS_PER_WORD                          constant        fixed bin(17,0)          initial dcl 2-174 in procedure "COMPARE_VALUES" ref
                                                                                  2-247 2-251 2-254 2-258 2-278 2-282 2-285 2-289
                                                                                  2-309 2-312 2-333 2-336 2-363 2-364 2-391 2-392
                                                                                  2-421 2-422 2-451 2-452 2-534 2-538 2-576 2-579
                                                                                  2-598 2-601
BITS_PER_WORD                          constant        fixed bin(17,0)          initial dcl 1-141 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING" ref 1-199 1-204 1-211
                                                                                  1-223 1-230
BRANCH_CI_HEADER_LENGTH_IN_BITS        constant        fixed bin(17,0)          initial dcl 12-56 ref 350 910 910 910
BRANCH_KEY_HEADER_LENGTH_IN_BITS       constant        fixed bin(35,0)          initial dcl 13-37 ref 995
BYTES_PER_WORD                         constant        fixed bin(17,0)          initial packed unaligned dcl 371 in procedure
                                                                                  "im_basic_search" ref 982
BYTES_PER_WORD                         constant        fixed bin(17,0)          initial dcl 1-141 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING" ref 1-218
BYTES_PER_WORD                         constant        fixed bin(17,0)          initial dcl 2-174 in procedure "COMPARE_VALUES" ref
                                                                                  2-562 2-566
CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES
                                       constant        fixed bin(17,0)          initial dcl 15-22 ref 987
DATUM_POSITION_TABLE_OFFSET_IN_BYTES   constant        fixed bin(17,0)          initial dcl 23-16 ref 904 982
DEFAULT_LENGTH                         constant        fixed bin(17,0)          initial dcl 2-174 ref 2-368 2-373 2-396 2-401 2-426
                                                                                  2-431 2-456 2-461
DOUBLE_WORDS_PER_PAGE                  constant        fixed bin(17,0)          initial packed unaligned dcl 371 ref 351
FIELD_TABLE_VERSION_3           000152 constant        char(8)                  initial dcl 21-69 in procedure "im_basic_search" set
                                                                                  ref 1038 1038*
FIELD_TABLE_VERSION_3           000150 constant        char(8)                  initial dcl 6-69 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING" set ref 21-36 1-171
                                                                                  1-171*
FREE_SLOT                              constant        fixed bin(15,0)          initial unsigned dcl 23-13 ref 907 985
HIGHEST_SUPPORTED_DATA_TYPE     000136 constant        fixed bin(17,0)          initial dcl 2-174 set ref 2-226 2-226*
INDEX_CURSOR_TYPE               000225 constant        fixed bin(17,0)          initial dcl 11-67 set ref 1023 1023*
INDEX_CURSOR_VERSION_3          000223 constant        fixed bin(17,0)          initial dcl 11-66 set ref 1028 1028*
INDEX_HEADER_VERSION_4          000154 constant        char(8)                  initial dcl 19-38 set ref 1020*
INDEX_OPENING_INFO_VERSION_3    000156 constant        char(8)                  initial dcl 18-47 set ref 1017*
LEAF_CI_HEADER_LENGTH_IN_BITS          constant        fixed bin(17,0)          initial dcl 12-56 ref 350 910 910 910
NEED_TO_CHECK_FOR_ALIGNMENT     000134 constant        bit(1)                   initial array packed unaligned dcl 2-185 ref 2-232
REQUIRED_ALIGNMENT              000056 constant        fixed bin(17,0)          initial array dcl 2-192 set ref 2-232 2-232* 2-237
                                                                                  2-237*
SIGN                                   constant        fixed bin(17,0)          initial dcl 2-174 ref 2-309 2-309 2-312 2-312 2-333
                                                                                  2-333 2-336 2-336 2-358 2-359 2-386 2-387 2-414
                                                                                  2-416 2-444 2-446 2-468 2-474 2-483 2-484 2-485
                                                                                  2-489 2-499 2-501 2-504 2-508 2-616 2-622 2-637
                                                                                  2-641 2-658 2-662
SIMPLE_TYPED_VECTOR_TYPE        000223 constant        fixed bin(17,0)          initial dcl 17-43 in procedure "im_basic_search" set
                                                                                  ref 418 418* 436 436*
SIMPLE_TYPED_VECTOR_TYPE        000223 constant        fixed bin(17,0)          initial dcl 7-43 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING" set ref 1-165 1-165*
VECTOR_VALUE_IS_IN_VECTOR_FORMAT       constant        bit(1)                   initial dcl 1-146 set ref 1-290*
addbitno                                               builtin function         dcl 2-167 in procedure "COMPARE_VALUES" ref 2-358
                                                                                  2-359 2-363 2-364 2-386 2-387 2-391 2-392 2-414
                                                                                  2-416 2-421 2-422 2-444 2-446 2-451 2-452
addbitno                                               builtin function         dcl 1-135 in procedure "COMPARE_VECTOR_TO_STRING"
                                                                                  ref 1-202 1-204 1-221 1-223 1-266 1-272 1-282
addcharno                                              builtin function         dcl 2-167 in procedure "COMPARE_VALUES" ref 2-483
                                                                                  2-484 2-499 2-501 2-632 2-634 2-653 2-655
addcharno                                              builtin function         dcl 365 in procedure "im_basic_search" ref 904 918
                                                                                  982 992
addr                                                   builtin function         dcl 365 in procedure "im_basic_search" ref 423 441
                                                                                  448 512 539 539 539 539 659 666 675 690 694 730
                                                                                  764 764 771 835 901 902 979 980 1046 1048 1096
                                                                                  1103 1108 1120 1121 1124 1142 1149 1168 1169 1175
                                                                                  1203 1207 1221 1237 1238 1259 1259 1259 1259 1270
                                                                                  1287 1288 1345 1387
addr                                                   builtin function         dcl 1-135 in procedure "COMPARE_VECTOR_TO_STRING"
                                                                                  ref 1-192 1-254 1-258 2-368 2-368 2-373 2-373
                                                                                  2-396 2-396 2-401 2-401 2-426 2-426 2-431 2-431
                                                                                  2-456 2-456 2-461 2-461
addrel                                                 builtin function         dcl 365 ref 1047
arg_descriptor                         based           structure                level 1 dcl 8-6 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
arg_descriptor                         based           structure                level 1 dcl 3-6 in procedure "COMPARE_VALUES" set
                                                                                  ref 2-424 2-454
arg_descriptor_ptr              000560 automatic       pointer                  dcl 3-34 in procedure "COMPARE_VALUES" set ref
                                                                                  2-224* 2-226 2-226 2-226 2-232 2-232 2-232 2-232
                                                                                  2-237 2-237 2-242 2-243 2-247 2-247 2-251 2-251
                                                                                  2-254 2-254 2-258 2-258 2-274 2-278 2-278 2-282
                                                                                  2-282 2-285 2-285 2-289 2-289 2-305 2-309 2-309
                                                                                  2-312 2-312 2-329 2-333 2-333 2-336 2-336 2-355
                                                                                  2-358 2-359 2-366 2-383 2-386 2-387 2-394 2-411
                                                                                  2-414 2-416 2-424 2-441 2-444 2-446 2-454 2-468
                                                                                  2-474 2-483 2-484 2-485 2-489 2-499 2-501 2-504
                                                                                  2-508 2-515 2-515 2-519 2-519 2-544 2-544 2-548
                                                                                  2-548 2-572 2-576 2-576 2-579 2-579 2-594 2-598
                                                                                  2-598 2-601 2-601 2-616 2-622 2-632 2-634 2-637
                                                                                  2-641 2-653 2-655 2-658 2-662
arg_descriptor_ptr              000512 automatic       pointer                  dcl 8-34 in procedure "COMPARE_VECTOR_TO_STRING" set
                                                                                  ref 1-192* 1-194 1-194 1-196 1-199 1-215 1-218
                                                                                  1-302
bci_header                             based           structure                level 1 dcl 22-63
bin                                                    builtin function         dcl 1-135 ref 1-273 1-309
bit_dtype                              constant        fixed bin(17,0)          initial dcl 9-25 ref 1-196 1-208
bk_string_length                000166 automatic       fixed bin(35,0)          dcl 13-39 set ref 698* 761* 764 764 764 764 771 772
                                                                                  1113*
branch_ci_header                       based           structure                level 1 unaligned dcl 12-48
branch_ci_header_ptr            000164 automatic       pointer                  dcl 12-53 set ref 702 704 705 713 723* 1090* 1101
                                                                                  1107 1109 1144* 1158* 1177* 1229* 1279* 1313*
                                                                                  1389* 1399* 1425 1430*
branch_id                              based           fixed bin(24,0)          level 2 packed packed unsigned unaligned dcl 13-32
                                                                                  ref 700 790 797 812 839 1115
branch_key                             based           structure                level 1 packed packed unaligned dcl 13-32
branch_key_ptr                  000170 automatic       pointer                  dcl 13-40 set ref 698* 700 761* 764 764 764 764 764
                                                                                  771 772 773 790 797 812 839 1047* 1113* 1115
ceil                                                   builtin function         dcl 2-167 in procedure "COMPARE_VALUES" ref 2-632
                                                                                  2-634 2-653 2-655
ceil                                                   builtin function         dcl 365 in procedure "im_basic_search" ref 916 990
char_dtype                             constant        fixed bin(17,0)          initial dcl 9-25 ref 1-215 1-227
collection_id             2            based           bit(36)                  level 2 dcl 11-29 set ref 864*
collection_manager_$get_control_interval_ptr
                                000050 constant        entry                    external dcl 16-74 ref 864
common                                 based           structure                level 2 in structure "leaf_ci_header" unaligned
                                                                                  dcl 12-43 in procedure "im_basic_search"
common                                 based           structure                level 2 in structure "branch_ci_header" unaligned
                                                                                  dcl 12-48 in procedure "im_basic_search"
common_ci_header                       based           structure                level 1 unaligned dcl 12-26
common_ci_header_ptr            000160 automatic       pointer                  dcl 12-41 set ref 465 687 723* 726 730* 733 734 822
                                                                                  836 836 1048* 1090* 1093 1121 1124 1144* 1153 1153
                                                                                  1157 1158* 1160 1171 1173 1175 1177* 1229* 1279*
                                                                                  1313* 1360 1389* 1394* 1399* 1402 1421 1421 1430*
                                                                                  1433
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "p_key_id" packed packed
                                                                                  unsigned unaligned dcl 361 in procedure
                                                                                  "im_basic_search" set ref 1207* 1224* 1237* 1264*
                                                                                  1273* 1287* 1316*
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "element_id" packed packed
                                                                                  unsigned unaligned dcl 14-32 in procedure
                                                                                  "im_basic_search" set ref 539 539* 690 730 1096*
                                                                                  1120* 1142 1168* 1175 1207 1237 1259 1259 1287
                                                                                  1387
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "gch_p_header_id" packed packed
                                                                                  unsigned unaligned dcl 893 in procedure
                                                                                  "GET_CI_HEADER" set ref 901*
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "gnk_p_key_id" packed packed
                                                                                  unsigned unaligned dcl 971 in procedure
                                                                                  "GET_NEW_KEY" set ref 979*
copy                                                   builtin function         dcl 2-167 ref 2-247 2-251 2-254 2-258 2-278 2-282
                                                                                  2-285 2-289 2-309 2-312 2-333 2-336 2-576 2-579
                                                                                  2-598 2-601
cpt_header_parent_id_string            parameter       bit(36)                  dcl 535 set ref 530 539 539 539 539
cpt_parent_idx                         parameter       fixed bin(17,0)          dcl 534 set ref 530 539 539*
cpt_parent_node_id                     parameter       fixed bin(24,0)          unsigned dcl 533 set ref 530 539 539*
current_depth                   000133 automatic       fixed bin(17,0)          initial dcl 331 set ref 331* 690 694 719* 719 730
                                                                                  1183* 1259 1259 1345 1385* 1387 1427* 1427
current_idx                     000140 automatic       fixed bin(17,0)          dcl 336 set ref 599* 604 607* 626 627* 627 634 635*
                                                                                  635 640 641* 641 645 646 647* 647 652 652 656* 659
                                                                                  665* 666 668 672* 675 694* 695 698* 715* 755 761*
                                                                                  783 784* 784 789 791* 791 796 798* 798 807 808*
                                                                                  808 811 821 1107* 1108 1109 1113* 1149* 1150* 1150
                                                                                  1153 1160* 1169 1208
current_key_exists       12(02)        based           bit(1)                   level 3 packed packed unaligned dcl 11-29 set ref
                                                                                  1150
current_key_string_length
                         10            based           fixed bin(24,0)          level 2 packed packed unaligned dcl 11-29 ref 1305
                                                                                  1318 1324 1327 1330
current_key_string_ptr
                          6            based           pointer                  level 2 dcl 11-29 set ref 1305* 1318* 1324* 1327*
                                                                                  1330*
current_node_id                 000145 automatic       fixed bin(24,0)          unsigned dcl 344 set ref 607* 690 698* 723* 730 761*
                                                                                  824 825* 838 839* 1089* 1090* 1096 1101* 1109*
                                                                                  1113* 1115* 1120 1142* 1144* 1157* 1158* 1168
                                                                                  1175* 1177* 1228* 1229* 1278* 1279* 1312* 1313*
                                                                                  1316 1387* 1389* 1398* 1399* 1404 1422 1425* 1430*
current_node_ptr                000152 automatic       pointer                  dcl 348 set ref 607* 698* 723* 761* 825* 839* 1089*
                                                                                  1090* 1101* 1109* 1113* 1115* 1142* 1144* 1157*
                                                                                  1158* 1175* 1177* 1228* 1229* 1278* 1279* 1312*
                                                                                  1313* 1387* 1389* 1398* 1399* 1425* 1430*
cv_based_real_fix_bin_1_unsa           based           fixed bin(35,0)          unsigned dcl 2-156 ref 2-588 2-588 2-590 2-590
cv_based_real_fix_bin_1a               based           fixed bin(35,0)          dcl 2-138 ref 2-267 2-267 2-269 2-269
cv_based_real_fix_bin_1u               based           fixed bin(35,0)          packed unaligned dcl 2-142 ref 2-534 2-538 2-562
                                                                                  2-566
cv_based_real_fix_bin_2_unsa           based           fixed bin(71,0)          unsigned dcl 2-158 ref 2-610 2-610 2-612 2-612
cv_based_real_fix_bin_2a               based           fixed bin(71,0)          dcl 2-140 ref 2-298 2-298 2-300 2-300
cv_based_real_flt_bin_1a               based           float bin(27)            dcl 2-147 ref 2-323 2-323 2-325 2-325
cv_based_real_flt_bin_2a               based           float bin(63)            dcl 2-149 ref 2-346 2-346 2-348 2-348
cv_bit_string                          based           bit                      packed unaligned dcl 2-135 ref 2-247 2-247 2-251
                                                                                  2-254 2-254 2-258 2-278 2-278 2-282 2-285 2-285
                                                                                  2-289 2-309 2-312 2-333 2-336 2-515 2-515 2-519
                                                                                  2-519 2-525 2-525 2-530 2-530 2-534 2-534 2-538
                                                                                  2-538 2-576 2-579 2-598 2-601
cv_char_string                         based           char                     packed unaligned dcl 2-136 ref 2-544 2-544 2-548
                                                                                  2-548 2-553 2-553 2-558 2-558 2-562 2-562 2-566
                                                                                  2-566
cv_field_imaginary_part_value_ptr
                                000554 automatic       pointer                  initial dcl 2-124 set ref 2-124* 2-359* 2-364*
                                                                                  2-373* 2-387* 2-392* 2-401* 2-416* 2-422* 2-431*
                                                                                  2-446* 2-452* 2-461* 2-484* 2-489* 2-501* 2-508*
                                                                                  2-634* 2-641* 2-655* 2-662*
cv_field_real_part_value_ptr    000552 automatic       pointer                  initial dcl 2-124 set ref 2-124* 2-352* 2-368*
                                                                                  2-380* 2-396* 2-408* 2-426* 2-438* 2-456* 2-482*
                                                                                  2-485* 2-498* 2-504* 2-630* 2-637* 2-651* 2-658*
cv_local_arg_descriptor         000556 automatic       structure                level 1 packed packed unaligned dcl 2-128 set ref
                                                                                  2-424* 2-426 2-426 2-431 2-431 2-454* 2-456 2-456
                                                                                  2-461 2-461
cv_local_field_real_fix_bin_1   000525 automatic       fixed bin(35,0)          dcl 2-99 set ref 2-254* 2-258* 2-261 2-263
cv_local_field_real_fix_bin_1_uns
                                000541 automatic       fixed bin(35,0)          unsigned dcl 2-117 set ref 2-579* 2-582 2-584
cv_local_field_real_fix_bin_2   000530 automatic       fixed bin(71,0)          dcl 2-103 set ref 2-285* 2-289* 2-292 2-294
cv_local_field_real_fix_bin_2_uns
                                000544 automatic       fixed bin(71,0)          unsigned dcl 2-121 set ref 2-601* 2-604 2-606
cv_local_field_real_flt_bin_1   000533 automatic       float bin(27)            dcl 2-108 set ref 2-312* 2-317 2-319
cv_local_field_real_flt_bin_2   000536 automatic       float bin(63)            dcl 2-112 set ref 2-336* 2-340 2-342
cv_local_fixed_arg_descriptor   000557 automatic       structure                level 1 packed packed unaligned dcl 2-130 set ref
                                                                                  2-366* 2-368 2-368 2-373 2-373 2-394* 2-396 2-396
                                                                                  2-401 2-401
cv_local_vector_real_fix_bin_1  000524 automatic       fixed bin(35,0)          dcl 2-97 set ref 2-247* 2-251* 2-261 2-263
cv_local_vector_real_fix_bin_1_uns
                                000540 automatic       fixed bin(35,0)          unsigned dcl 2-115 set ref 2-576* 2-582 2-584
cv_local_vector_real_fix_bin_2  000526 automatic       fixed bin(71,0)          dcl 2-101 set ref 2-278* 2-282* 2-292 2-294
cv_local_vector_real_fix_bin_2_uns
                                000542 automatic       fixed bin(71,0)          unsigned dcl 2-119 set ref 2-598* 2-604 2-606
cv_local_vector_real_flt_bin_1  000532 automatic       float bin(27)            dcl 2-106 set ref 2-309* 2-317 2-319
cv_local_vector_real_flt_bin_2  000534 automatic       float bin(63)            dcl 2-110 set ref 2-333* 2-340 2-342
cv_p_code                       000442 automatic       fixed bin(35,0)          dcl 1-85 set ref 1-177* 1-247 1-317 2-222* 2-368*
                                                                                  2-371 2-373* 2-396* 2-399 2-401* 2-426* 2-429
                                                                                  2-431* 2-456* 2-459 2-461* 2-671*
cv_p_descriptor_ptr             000444 automatic       pointer                  dcl 1-86 set ref 1-254* 1-258* 1-260 1-260 2-224
cv_p_field_value_length         000446 automatic       fixed bin(35,0)          dcl 1-87 set ref 1-253* 1-265* 1-273* 1-277 1-280
                                                                                  2-525 2-530 2-534 2-538 2-553 2-558 2-562 2-566
cv_p_field_value_ptr            000450 automatic       pointer                  dcl 1-89 set ref 1-252* 1-266* 1-282* 2-237 2-237*
                                                                                  2-254 2-254 2-258 2-267 2-269 2-285 2-285 2-289
                                                                                  2-298 2-300 2-312 2-323 2-325 2-336 2-346 2-348
                                                                                  2-352 2-359 2-364 2-380 2-387 2-392 2-408 2-416
                                                                                  2-422 2-438 2-446 2-452 2-468* 2-474* 2-482 2-484
                                                                                  2-498 2-501 2-515 2-519 2-525 2-530 2-534 2-538
                                                                                  2-544 2-548 2-553 2-558 2-562 2-566 2-579 2-588
                                                                                  2-590 2-601 2-610 2-612 2-616* 2-622* 2-630 2-634
                                                                                  2-651 2-655
cv_p_vector_equal_to_key        000452 automatic       bit(1)                   dcl 1-90 set ref 1-178* 1-247 1-302 1-302* 1-309
                                                                                  1-314 2-368* 2-373 2-373* 2-396* 2-401 2-401*
                                                                                  2-426* 2-431 2-431* 2-456* 2-461 2-461* 2-468*
                                                                                  2-474* 2-485* 2-489 2-489* 2-504* 2-508 2-508*
                                                                                  2-616* 2-622* 2-637* 2-641 2-641* 2-658* 2-662
                                                                                  2-662* 2-698* 2-703* 2-708*
cv_p_vector_less_than_key       000453 automatic       bit(1)                   dcl 1-92 set ref 1-179* 1-316 2-368* 2-373* 2-396*
                                                                                  2-401* 2-426* 2-431* 2-456* 2-461* 2-468* 2-474*
                                                                                  2-485* 2-489* 2-504* 2-508* 2-616* 2-622* 2-637*
                                                                                  2-641* 2-658* 2-662* 2-700* 2-705* 2-710*
cv_p_vector_value_is_in_field_format   parameter       bit(1)                   dcl 2-72 ref 2-65 2-525 2-553
cv_p_vector_value_length        000454 automatic       fixed bin(35,0)          dcl 1-94 set ref 1-288* 2-525 2-530 2-553 2-558
cv_p_vector_value_ptr           000456 automatic       pointer                  dcl 1-96 set ref 1-287* 2-232 2-232* 2-247 2-247
                                                                                  2-251 2-267 2-269 2-278 2-278 2-282 2-298 2-300
                                                                                  2-309 2-323 2-325 2-333 2-346 2-348 2-354 2-358
                                                                                  2-363 2-382 2-386 2-391 2-410 2-414 2-421 2-440
                                                                                  2-444 2-451 2-468* 2-474* 2-480 2-483 2-496 2-499
                                                                                  2-515 2-519 2-525 2-530 2-534 2-534 2-538 2-538
                                                                                  2-544 2-548 2-553 2-558 2-562 2-562 2-566 2-566
                                                                                  2-576 2-588 2-590 2-598 2-610 2-612 2-616* 2-622*
                                                                                  2-628 2-632 2-649 2-653
cv_vector_imaginary_part_value_ptr
                                000550 automatic       pointer                  initial dcl 2-124 set ref 2-124* 2-358* 2-363*
                                                                                  2-373* 2-386* 2-391* 2-401* 2-414* 2-421* 2-431*
                                                                                  2-444* 2-451* 2-461* 2-483* 2-489* 2-499* 2-508*
                                                                                  2-632* 2-641* 2-653* 2-662*
cv_vector_real_part_value_ptr   000546 automatic       pointer                  initial dcl 2-124 set ref 2-124* 2-354* 2-368*
                                                                                  2-382* 2-396* 2-410* 2-426* 2-440* 2-456* 2-480*
                                                                                  2-485* 2-496* 2-504* 2-628* 2-637* 2-649* 2-658*
cvs_based_real_fix_bin_1u              based           fixed bin(35,0)          packed unaligned dcl 1-126 ref 1-209 1-228
cvs_field_idx                   000460 automatic       fixed bin(17,0)          dcl 1-99 set ref 1-247* 1-249 1-258 1-266 1-271
                                                                                  1-272 1-277 1-287 1-302* 1-309
cvs_field_value_offset          000461 automatic       fixed bin(24,0)          dcl 1-100 set ref 1-275* 1-282
cvs_key_string_length           000462 automatic       fixed bin(35,0)          dcl 1-101 set ref 1-161*
cvs_key_string_ptr              000464 automatic       pointer                  dcl 1-102 set ref 1-160* 1-202 1-221 1-266 1-272
                                                                                  1-282
cvs_last_field_idx              000466 automatic       fixed bin(17,0)          dcl 1-103 set ref 1-162* 1-181 1-188 1-191 1-192
                                                                                  1-202 1-221 1-237 1-249 1-302
cvs_last_field_is_truncated     000467 automatic       bit(1)                   initial dcl 1-104 set ref 1-104* 1-186* 1-194*
                                                                                  1-212* 1-232* 1-235* 1-237 1-249 1-302
cvs_last_field_length_in_bits   000470 automatic       fixed bin(35,0)          dcl 1-106 set ref 1-211* 1-230* 1-237
cvs_last_field_length_ptr       000472 automatic       pointer                  dcl 1-108 set ref 1-202* 1-204 1-209 1-221* 1-223
                                                                                  1-228
cvs_last_field_value_ptr        000474 automatic       pointer                  dcl 1-110 set ref 1-204* 1-223* 1-252
cvs_length_field_length         000476 automatic       fixed bin(35,0)          dcl 1-112 set ref 1-271* 1-273
cvs_length_field_ptr            000500 automatic       pointer                  dcl 1-114 set ref 1-272* 1-273
cvs_length_field_string                based           bit                      packed unaligned dcl 1-130 ref 1-273
cvs_location_of_first_varying_field
                                000502 automatic       fixed bin(35,0)          dcl 1-115 set ref 1-185* 1-237* 1-240* 1-243
cvs_maximum_field_idx           000503 automatic       fixed bin(17,0)          dcl 1-117 set ref 1-184* 1-191* 1-247 1-311
cvs_p_code                      000113 automatic       fixed bin(35,0)          dcl 319 set ref 610* 616 616* 764* 777 777* 1-317*
cvs_p_field_table_ptr           000100 automatic       pointer                  dcl 306 set ref 610* 764* 1033* 1038 1038 1042 1-170
cvs_p_first_inequal_field_id    000110 automatic       fixed bin(17,0)          dcl 313 set ref 574 581 602* 604 610* 619 625 629
                                                                                  633 764* 786 1-309*
cvs_p_key_string_length         000106 automatic       fixed bin(35,0)          dcl 310 set ref 607* 610 772* 1-161
cvs_p_key_string_ptr            000104 automatic       pointer                  dcl 309 set ref 607* 610* 771* 1046* 1047 1-160
cvs_p_last_field_idx            000107 automatic       fixed bin(17,0)          dcl 312 set ref 601* 610 773* 1-162
cvs_p_simple_typed_vector_ptr   000102 automatic       pointer                  dcl 307 set ref 417* 418 418 435* 436 436 457* 1035
                                                                                  1044 1-164
cvs_p_vector_equal_to_key       000111 automatic       bit(1)                   dcl 315 set ref 574 581 595* 610* 658* 664* 668 674*
                                                                                  764* 802 1-311* 1-314*
cvs_p_vector_less_than_key      000112 automatic       bit(1)                   dcl 317 set ref 579 610* 622 657* 663* 668 673* 764*
                                                                                  780 818 1203 1-316*
cvs_truncated_field_descriptor  000504 automatic       structure                level 1 packed packed unaligned dcl 1-118 set ref
                                                                                  1-254
cvs_varying_field_value_offset  000505 automatic       fixed bin(24,0)          dcl 1-121 set ref 1-243* 1-275 1-277* 1-277 1-280*
                                                                                  1-280
data_format_util_$compare_string_to_string
                                000012 constant        entry                    external dcl 382 ref 610 764
datum_slot                             based           structure                level 1 dcl 22-82
depth                                  based           fixed bin(17,0)          level 2 dcl 357 set ref 1095* 1095 1096 1103 1108
                                                                                  1119* 1119 1120 1121 1124 1132 1134 1135 1147*
                                                                                  1172* 1172 1173 1183 1381 1385
depth_idx                       000142 automatic       fixed bin(17,0)          initial dcl 338 set ref 338* 1132* 1133 1134 1134
                                                                                  1135*
descriptor                6            based           bit(36)                  array level 3 dcl 6-36 set ref 1-192 1-258
dimension                 1            based           structure                array level 2 packed packed unaligned dcl 7-17 ref
                                                                                  1-184 1-191 1-311
divide                                                 builtin function         dcl 365 ref 599 627 635 641 647 715 784 791 798 808
                                                                                  916 990 1132 2-632 2-634 2-653 2-655
dm_error_$bad_first_key_idx     000034 external static fixed bin(35,0)          dcl 398 set ref 928*
dm_error_$bad_last_key_idx      000036 external static fixed bin(35,0)          dcl 398 set ref 930* 939*
dm_error_$bad_parent_thread     000040 external static fixed bin(35,0)          dcl 398 set ref 539*
dm_error_$key_not_found         000032 external static fixed bin(35,0)          dcl 398 set ref 478*
dm_error_$long_return_element   000042 external static fixed bin(35,0)          dcl 398 set ref 910* 987*
dm_error_$no_element            000044 external static fixed bin(35,0)          dcl 398 set ref 907* 985*
dm_error_$programming_error     000046 external static fixed bin(35,0)          dcl 398 set ref 802*
dm_error_$unimplemented_data_type
                                000076 external static fixed bin(35,0)          dcl 2-217 ref 2-671
dmu_compare_decimal_values$dmu_compare_dec4fl
                                000064 constant        entry                    external dcl 2-207 ref 2-622 2-658 2-662
dmu_compare_decimal_values$dmu_compare_dec4ls
                                000066 constant        entry                    external dcl 2-209 ref 2-616 2-637 2-641
dmu_compare_decimal_values$dmu_compare_dec9fl
                                000062 constant        entry                    external dcl 2-205 ref 2-474 2-504 2-508
dmu_compare_decimal_values$dmu_compare_dec9ls
                                000060 constant        entry                    external dcl 2-203 ref 2-468 2-485 2-489
dmu_compare_values              000056 constant        entry                    external dcl 2-201 ref 2-368 2-373 2-396 2-401 2-426
                                                                                  2-431 2-456 2-461
element_id                             based           structure                level 1 dcl 14-32 set ref 512 1203
element_id_string               000172 automatic       bit(36)                  dcl 14-30 set ref 512 607* 659 666 675 698* 723*
                                                                                  761* 835 1090* 1113* 1144* 1158* 1177* 1203 1207
                                                                                  1221 1229* 1237 1238 1259 1259 1270 1279* 1287
                                                                                  1288 1313* 1389* 1399* 1430*
equal_idx                       000135 automatic       fixed bin(17,0)          initial dcl 333 set ref 333* 645* 652 656 668 672
er_code                                parameter       fixed bin(35,0)          dcl 495 ref 492 497
error_table_$bad_arg            000074 external static fixed bin(35,0)          dcl 2-216 set ref 2-226* 2-232* 2-237*
error_table_$unimplemented_version
                                000026 external static fixed bin(35,0)          dcl 398 in procedure "im_basic_search" set ref 556*
                                                                                  1023* 1028* 1038*
error_table_$unimplemented_version
                                000054 external static fixed bin(35,0)          dcl 1-155 in procedure "COMPARE_VECTOR_TO_STRING"
                                                                                  set ref 1-165* 1-171*
extended_arg_type               000514 automatic       fixed bin(17,0)          initial dcl 8-36 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING" set ref 8-36*
extended_arg_type               000562 automatic       fixed bin(17,0)          initial dcl 3-36 in procedure "COMPARE_VALUES" set
                                                                                  ref 3-36*
failed_exact_match              000124 automatic       bit(1)                   initial dcl 321 set ref 321* 478 1198* 1305
field                     5            based           structure                array level 2 dcl 6-36 set ref 1-184
field_table                            based           structure                level 1 dcl 6-36 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
field_table                            based           structure                level 1 dcl 21-36 in procedure "im_basic_search"
field_table_ptr           6            based           pointer                  initial level 2 in structure "index_opening_info"
                                                                                  dcl 18-26 in procedure "im_basic_search" ref 1033
field_table_ptr                 000506 automatic       pointer                  dcl 6-65 in procedure "COMPARE_VECTOR_TO_STRING" set
                                                                                  ref 1-170* 1-171 1-171 1-184 1-185 1-192 1-202
                                                                                  1-221 1-237 1-240 1-258 1-266 1-271 1-272 1-277
file_opening_id           1            based           bit(36)                  level 2 dcl 11-29 set ref 864*
first                     1            based           fixed bin(18,0)          level 4 in structure "leaf_ci_header" packed packed
                                                                                  unsigned unaligned dcl 12-43 in procedure
                                                                                  "im_basic_search" set ref 928 930 1231 1270 1317
                                                                                  1327
first                     1            based           fixed bin(18,0)          level 3 in structure "common_ci_header" packed
                                                                                  packed unsigned unaligned dcl 12-26 in procedure
                                                                                  "im_basic_search" ref 733 734 822 836 836 1121
                                                                                  1160 1360 1402 1421
first                     1            based           fixed bin(18,0)          level 4 in structure "branch_ci_header" packed
                                                                                  packed unsigned unaligned dcl 12-48 in procedure
                                                                                  "im_basic_search" ref 939
first_idx                       000134 automatic       fixed bin(17,0)          dcl 332 set ref 597 652 665 710 730* 733* 734* 755
                                                                                  1394* 1402*
fixed_arg_descriptor                   based           structure                level 1 dcl 3-13 ref 2-366 2-394
flag                            000504 automatic       bit(1)                   level 2 packed packed unaligned dcl 1-118 set ref
                                                                                  1-207* 1-226*
flags                     5            based           structure                array level 3 in structure "field_table" dcl 6-36
                                                                                  in procedure "COMPARE_VECTOR_TO_STRING"
flags                                  based           structure                level 2 in structure "common_ci_header" packed
                                                                                  packed unaligned dcl 12-26 in procedure
                                                                                  "im_basic_search"
flags                    12            based           structure                level 2 in structure "index_cursor" dcl 11-29
                                                                                  in procedure "im_basic_search" set ref 1303*
gch_header_length_in_bytes      000324 automatic       fixed bin(35,0)          dcl 895 set ref 916* 918 918
gch_header_string                      based           char                     packed unaligned dcl 897 set ref 918* 918
gch_p_branch_ci_header_ptr             parameter       pointer                  dcl 888 set ref 884 926* 937* 939 939
gch_p_common_ci_header_ptr             parameter       pointer                  dcl 888 ref 884 918 922 925 937
gch_p_header_id                        based           structure                level 1 dcl 893
gch_p_header_id_string                 parameter       bit(36)                  dcl 891 set ref 884 901 902
gch_p_leaf_ci_header_ptr               parameter       pointer                  dcl 888 set ref 884 925* 928 930 930 936*
gch_p_node_id                          parameter       fixed bin(24,0)          unsigned dcl 890 set ref 884 901 907* 910*
gch_p_node_ptr                         parameter       pointer                  dcl 888 ref 884 904 918
gch_slot                               based           structure                level 1 dcl 898
gch_slot_ptr                    000326 automatic       pointer                  dcl 899 set ref 904* 907 910 910 916 918
gnk_key_length_in_bytes         000336 automatic       fixed bin(35,0)          dcl 973 set ref 990* 992 992
gnk_key_string                         based           char                     packed unaligned dcl 975 set ref 992* 992
gnk_p_bk_string_length                 parameter       fixed bin(35,0)          dcl 968 set ref 959 995*
gnk_p_index                            parameter       fixed bin(17,0)          dcl 965 ref 959 980 982
gnk_p_key_id                           based           structure                level 1 dcl 971
gnk_p_key_id_string                    parameter       bit(36)                  dcl 969 set ref 959 979 980
gnk_p_key_ptr                          parameter       pointer                  dcl 966 ref 959 992
gnk_p_lk_string_length                 parameter       fixed bin(35,0)          dcl 967 set ref 959 994*
gnk_p_node_id                          parameter       fixed bin(24,0)          unsigned dcl 964 ref 959 979
gnk_p_node_ptr                         parameter       pointer                  dcl 963 ref 959 982 992
gnk_slot                               based           structure                level 1 dcl 976
gnk_slot_ptr                    000340 automatic       pointer                  dcl 977 set ref 982* 985 987 990 992 994 995
gnn_code                        000314 automatic       fixed bin(35,0)          dcl 860 set ref 864* 866 866*
gnn_p_current_node_id                  parameter       fixed bin(24,0)          unsigned dcl 857 set ref 853 862* 864*
gnn_p_current_node_ptr                 parameter       pointer                  dcl 858 set ref 853 864*
gnn_p_node_id                          parameter       fixed bin(24,0)          unsigned dcl 856 ref 853 862
hbound                                                 builtin function         dcl 1-135 ref 1-184 1-184 1-191 1-311
high_duplication_field          000130 automatic       fixed bin(17,0)          initial dcl 325 set ref 325* 625* 1200
high_idx                        000137 automatic       fixed bin(17,0)          dcl 335 set ref 598* 599 626* 635 641 646* 713* 715
                                                                                  755 783* 791 798 807*
id_string                 1            based           bit(36)                  array level 2 dcl 357 set ref 690 694 730 1096 1103
                                                                                  1108 1120 1121 1124 1133 1134* 1134 1135* 1168
                                                                                  1169 1173* 1259 1259 1345 1387
im_set_cursor$at_beginning      000020 constant        entry                    external dcl 390 ref 1327
im_set_cursor$at_current        000014 constant        entry                    external dcl 386 ref 1305
im_set_cursor$at_end            000022 constant        entry                    external dcl 392 ref 1324
im_set_cursor$no_current        000016 constant        entry                    external dcl 388 ref 1318 1330
im_validate_cursor              000010 constant        entry                    external dcl 381 ref 1079
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "element_id" packed packed
                                                                                  unsigned unaligned dcl 14-32 in procedure
                                                                                  "im_basic_search" set ref 539 539* 659* 666* 675*
                                                                                  694 835 1103* 1108* 1121* 1124* 1149 1169* 1221
                                                                                  1238 1259 1259 1270 1288 1345
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "gnk_p_key_id" packed packed
                                                                                  unsigned unaligned dcl 971 in procedure
                                                                                  "GET_NEW_KEY" set ref 980*
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "gch_p_header_id" packed packed
                                                                                  unsigned unaligned dcl 893 in procedure
                                                                                  "GET_CI_HEADER" set ref 902*
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "p_key_id" packed packed
                                                                                  unsigned unaligned dcl 361 in procedure
                                                                                  "im_basic_search" set ref 478 1208* 1231* 1233*
                                                                                  1238* 1265* 1281* 1283* 1288* 1308 1317* 1323*
                                                                                  1327
index_cursor                           based           structure                level 1 unaligned dcl 11-29
index_cursor_ptr                000156 automatic       pointer                  dcl 11-64 set ref 864 864 1022* 1023 1023 1028 1028
                                                                                  1079* 1083 1083 1098 1121 1142 1149 1150 1303
                                                                                  1305* 1305 1305 1318* 1318 1318 1324* 1324 1324
                                                                                  1327* 1327 1327 1330* 1330 1330
index_header                           based           structure                level 1 dcl 19-25
index_header_ptr                000176 automatic       pointer                  dcl 19-37 in procedure "im_basic_search" set ref 574
                                                                                  581 602 604 619 1019* 1020 1089 1398
index_header_ptr          4            based           pointer                  initial level 2 in structure "index_opening_info"
                                                                                  dcl 18-26 in procedure "im_basic_search" ref 1019
index_opening_info                     based           structure                level 1 dcl 18-26
index_opening_info_ptr          000174 automatic       pointer                  initial dcl 18-46 set ref 446* 18-46* 1016* 1017
                                                                                  1019 1033 1079*
ips_code                        000356 automatic       fixed bin(35,0)          initial dcl 1077 set ref 1077* 1079* 1080 1080*
is_at_beginning_of_index
                         12            based           bit(1)                   level 3 packed packed unaligned dcl 11-29 set ref
                                                                                  1083 1098 1121
is_at_end_of_index       12(01)        based           bit(1)                   level 3 packed packed unaligned dcl 11-29 set ref
                                                                                  1083
is_first_pass_through_loop      000132 automatic       bit(1)                   dcl 328 set ref 751* 755 759*
is_insertion                    000123 automatic       bit(1)                   initial dcl 321 set ref 321* 429* 574 1200
is_leaf                                based           bit(1)                   level 3 packed packed unaligned dcl 12-26 ref 465
                                                                                  687 922 1093 1360 1421
is_relative_search              000121 automatic       bit(1)                   initial dcl 321 set ref 321* 415* 433* 455* 690 719
                                                                                  730 1252 1378 1427
is_reposition                   000122 automatic       bit(1)                   initial dcl 321 set ref 321* 451* 472 610 764
key_id_ptr                      000150 automatic       pointer                  dcl 347 set ref 423* 441* 448* 478 512 1203 1207
                                                                                  1208 1224 1231 1233 1237 1238 1264 1265 1273 1281
                                                                                  1283 1287 1288 1305 1305 1308 1316 1317 1318 1318
                                                                                  1323 1324 1324 1327 1327 1327 1330 1330
key_id_string             3            based           bit(36)                  level 2 dcl 11-29 set ref 449 1142 1149
key_range                 1            based           structure                level 3 in structure "branch_ci_header" packed
                                                                                  packed unaligned dcl 12-48 in procedure
                                                                                  "im_basic_search"
key_range                 1            based           structure                level 2 in structure "common_ci_header" packed
                                                                                  packed unaligned dcl 12-26 in procedure
                                                                                  "im_basic_search"
key_range                 1            based           structure                level 3 in structure "leaf_ci_header" packed packed
                                                                                  unaligned dcl 12-43 in procedure "im_basic_search"
last                      1(18)        based           fixed bin(18,0)          level 4 in structure "leaf_ci_header" packed packed
                                                                                  unsigned unaligned dcl 12-43 in procedure
                                                                                  "im_basic_search" set ref 598 930 1221 1281 1308
                                                                                  1323
last                      1(18)        based           fixed bin(18,0)          level 4 in structure "branch_ci_header" packed
                                                                                  packed unsigned unaligned dcl 12-48 in procedure
                                                                                  "im_basic_search" ref 713 939 1107
last                      1(18)        based           fixed bin(18,0)          level 3 in structure "common_ci_header" packed
                                                                                  packed unsigned unaligned dcl 12-26 in procedure
                                                                                  "im_basic_search" ref 1124 1153
last_field_idx            0(24)        based           fixed bin(12,0)          level 2 packed packed unsigned unaligned dcl 13-32
                                                                                  ref 764 773
leaf_ci_header                         based           structure                level 1 unaligned dcl 12-43 set ref 474* 474
leaf_ci_header_ptr              000162 automatic       pointer                  dcl 12-46 set ref 474 598 723* 1090* 1144* 1158*
                                                                                  1177* 1221 1224 1225 1228 1229* 1231 1270 1273
                                                                                  1275 1278 1279* 1281 1308 1308 1312 1313* 1317
                                                                                  1323 1327 1327 1389* 1399* 1430*
length                                                 builtin function         dcl 365 ref 764 764 772
length_in_bits            0(19)        based           fixed bin(17,0)          level 2 in structure "gnk_slot" packed packed
                                                                                  unsigned unaligned dcl 976 in procedure
                                                                                  "GET_NEW_KEY" ref 987 990 994 995
length_in_bits            0(19)        based           fixed bin(17,0)          level 2 in structure "gch_slot" packed packed
                                                                                  unsigned unaligned dcl 898 in procedure
                                                                                  "GET_CI_HEADER" set ref 910 910* 916
length_in_bits           10            based           fixed bin(35,0)          array level 3 in structure "field_table" dcl 6-36
                                                                                  in procedure "COMPARE_VECTOR_TO_STRING" ref 1-271
length_is_in_characters
                          5(01)        based           bit(1)                   array level 4 packed packed unaligned dcl 6-36 ref
                                                                                  1-277
less_branch_id                  000146 automatic       fixed bin(24,0)          unsigned dcl 345 set ref 700* 702* 704* 705* 790*
                                                                                  797* 812* 825*
local_header_buffer             000154 automatic       bit                      dcl 350 set ref 1048
local_key_buffer                000154 automatic       fixed bin(71,0)          array dcl 351 set ref 1046
local_key_id_string             000154 automatic       bit(36)                  initial dcl 352 set ref 352* 448 449*
location                  7            based           fixed bin(35,0)          array level 3 dcl 6-36 ref 1-202 1-221 1-237 1-266
                                                                                  1-272
location_of_first_varying_field
                          4            based           fixed bin(35,0)          level 2 dcl 6-36 ref 1-185 1-240
low_branch_id             5            based           fixed bin(24,0)          level 2 packed packed unsigned unaligned dcl 12-48
                                                                                  ref 702 704 705 1101 1109 1425
low_duplication_field           000131 automatic       fixed bin(17,0)          initial dcl 325 set ref 325* 633* 1200
low_idx                         000136 automatic       fixed bin(17,0)          dcl 334 set ref 597* 599 604 627 634* 640* 647 710*
                                                                                  715 755 784 789* 796* 808 811*
max                                                    builtin function         dcl 365 ref 350 719 910 910 910 1200 1360 1427
min                                                    builtin function         dcl 1-135 ref 1-184 1-191
myname                          000137 constant        varying char(32)         initial dcl 2-172 in procedure "COMPARE_VALUES" set
                                                                                  ref 2-226* 2-232* 2-237*
myname                          000160 constant        char(16)                 initial packed unaligned dcl 377 in procedure
                                                                                  "im_basic_search" set ref 418* 436* 539* 556* 802*
                                                                                  907* 910* 1023* 1028* 1038* 1-165* 1-171*
next_id                   3(24)        based           fixed bin(24,0)          level 3 in structure "leaf_ci_header" packed packed
                                                                                  unsigned unaligned dcl 12-43 in procedure
                                                                                  "im_basic_search" set ref 1224 1225 1228 1308 1312
next_id                   3(24)        based           fixed bin(24,0)          level 2 in structure "common_ci_header" packed
                                                                                  packed unsigned unaligned dcl 12-26 in procedure
                                                                                  "im_basic_search" ref 1153 1157
null                                                   builtin function         dcl 2-167 in procedure "COMPARE_VALUES" ref 2-124
                                                                                  2-124 2-124 2-124 2-226 2-226 2-232 2-232 2-237
                                                                                  2-237
null                                                   builtin function         dcl 365 in procedure "im_basic_search" ref 324 418
                                                                                  418 434 436 436 456 457 474 18-46 539 539 556 556
                                                                                  802 802 907 907 910 910 926 936 1023 1023 1028
                                                                                  1028 1035 1038 1038
null                                                   builtin function         dcl 1-135 in procedure "COMPARE_VECTOR_TO_STRING"
                                                                                  ref 1-165 1-165 1-171 1-171
number_of_dimensions      0(18)        based           fixed bin(17,0)          level 2 in structure "simple_typed_vector" packed
                                                                                  packed unaligned dcl 7-17 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING" ref 1-184 1-191 1-311
number_of_dimensions      0(18)        based           fixed bin(17,0)          level 2 in structure "simple_typed_vector" packed
                                                                                  packed unaligned dcl 17-17 in procedure
                                                                                  "im_basic_search" ref 1044
number_of_duplication_fields
                          4            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 19-25 ref 574
                                                                                  581 602 604 619
number_of_fields          2            based           fixed bin(17,0)          level 2 in structure "field_table" dcl 6-36
                                                                                  in procedure "COMPARE_VECTOR_TO_STRING" ref 1-184
number_of_fields          2            based           fixed bin(17,0)          level 2 in structure "field_table" dcl 21-36
                                                                                  in procedure "im_basic_search" ref 1042
number_of_fields_in_vector      000143 automatic       fixed bin(35,0)          initial dcl 340 set ref 340* 629 786 1042* 1044*
offset_in_bytes           0(04)        based           fixed bin(15,0)          level 2 in structure "gch_slot" packed packed
                                                                                  unsigned unaligned dcl 898 in procedure
                                                                                  "GET_CI_HEADER" ref 907 918
offset_in_bytes           0(04)        based           fixed bin(15,0)          level 2 in structure "gnk_slot" packed packed
                                                                                  unsigned unaligned dcl 976 in procedure
                                                                                  "GET_NEW_KEY" ref 985 992
only_want_key_equal_to_vector   000117 automatic       bit(1)                   initial dcl 321 set ref 321* 514 652 668 1013*
p_code                                 parameter       fixed bin(35,0)          dcl 302 set ref 280 426 444 487* 497*
p_expected_version                     parameter       char(8)                  dcl 553 set ref 550 556 556*
p_index_cursor_ptr                     parameter       pointer                  dcl 290 ref 280 426 444 449 1022
p_index_opening_info_ptr               parameter       pointer                  dcl 288 ref 280 426 444 446 1016
p_is_relative_search                   parameter       bit(1)                   dcl 291 ref 280 415
p_key_id                               based           structure                level 1 packed packed unaligned dcl 361 set ref 512*
                                                                                  1203* 1305 1305 1318 1318 1324 1324 1327 1327 1330
                                                                                  1330
p_key_id_string                        parameter       bit(36)                  dcl 296 set ref 280 423 426 441 1164*
p_key_string_length                    parameter       fixed bin(24,0)          dcl 301 set ref 444 610* 764*
p_key_string_ptr                       parameter       pointer                  dcl 300 set ref 444 610* 764*
p_leaf_ci_header_ptr                   parameter       pointer                  dcl 297 ref 280 426 474 474
p_maximum_duplication_field            parameter       fixed bin(17,0)          dcl 298 set ref 426 1200*
p_position_stack_ptr                   parameter       pointer                  dcl 292 ref 280 416
p_received_version                     parameter       char(8)                  dcl 552 set ref 550 556 556*
p_structure_name                       parameter       char                     packed unaligned dcl 554 set ref 550 556*
p_typed_vector_ptr                     parameter       pointer                  dcl 295 ref 280 417 426 435
p_want_key_equal_to_vector             parameter       bit(1)                   dcl 293 ref 280 412
p_want_keys_greater_than_vector        parameter       bit(1)                   dcl 293 ref 280 414
p_want_keys_less_than_vector           parameter       bit(1)                   dcl 293 ref 280 413
packed                    0(07)        based           bit(1)                   level 2 in structure "arg_descriptor" packed packed
                                                                                  unaligned dcl 3-6 in procedure "COMPARE_VALUES"
                                                                                  ref 2-232 2-243 2-274 2-305 2-329 2-355 2-383
                                                                                  2-411 2-441 2-572 2-594
packed                    0(07) 000504 automatic       bit(1)                   level 2 in structure
                                                                                  "cvs_truncated_field_descriptor" packed packed
                                                                                  unaligned dcl 1-118 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING" set ref 1-206* 1-225*
parent_id_string          2            based           bit(36)                  level 2 dcl 12-26 set ref 726* 1171 1173 1175 1433*
parent_idx                      000141 automatic       fixed bin(17,0)          initial dcl 337 set ref 337* 726* 821* 822 822* 835*
                                                                                  836 836* 1423* 1433*
parent_node_id                  000144 automatic       fixed bin(24,0)          initial unsigned dcl 343 set ref 343* 726* 824* 838*
                                                                                  1404* 1422* 1433*
position_stack                         based           structure                level 1 dcl 357
position_stack_ptr              000126 automatic       pointer                  initial dcl 324 set ref 324* 416* 434* 456* 690 694
                                                                                  730 730* 1095 1095 1096 1096 1103 1103 1108 1108
                                                                                  1119 1119 1120 1120 1121 1121 1124 1124 1132 1133
                                                                                  1134 1134 1134 1135 1135 1147 1168 1169 1172 1172
                                                                                  1173 1173 1183 1259 1259 1381 1385 1387 1394*
precision                 0(24)        based           fixed bin(12,0)          level 2 packed packed unsigned unaligned dcl 3-13
                                                                                  ref 2-247 2-247 2-251 2-251 2-254 2-254 2-258
                                                                                  2-258 2-278 2-278 2-282 2-282 2-285 2-285 2-289
                                                                                  2-289 2-358 2-359 2-386 2-387 2-468 2-483 2-484
                                                                                  2-485 2-489 2-576 2-576 2-579 2-579 2-598 2-598
                                                                                  2-601 2-601 2-616 2-632 2-634 2-637 2-641 2-653
                                                                                  2-655
previous_id               3            based           fixed bin(24,0)          level 3 packed packed unsigned unaligned dcl 12-43
                                                                                  set ref 1273 1275 1278 1327
real_fix_bin_1_dtype                   constant        fixed bin(17,0)          initial dcl 4-25 ref 2-367
real_fix_bin_2_dtype                   constant        fixed bin(17,0)          initial dcl 4-25 ref 2-395
real_flt_bin_1_dtype                   constant        fixed bin(17,0)          initial dcl 4-25 ref 2-425
real_flt_bin_2_dtype                   constant        fixed bin(17,0)          initial dcl 4-25 ref 2-455
root_id                   3            based           fixed bin(24,0)          level 2 packed packed unsigned unaligned dcl 19-25
                                                                                  ref 1089 1398
rp_code                         000410 automatic       fixed bin(35,0)          dcl 1301 set ref 1305* 1318* 1324* 1327* 1330* 1332
                                                                                  1332*
simple_typed_vector                    based           structure                level 1 packed packed unaligned dcl 7-17
                                                                                  in procedure "COMPARE_VECTOR_TO_STRING"
simple_typed_vector                    based           structure                level 1 packed packed unaligned dcl 17-17
                                                                                  in procedure "im_basic_search"
simple_typed_vector_ptr         000510 automatic       pointer                  dcl 7-33 set ref 1-164* 1-165 1-165 1-184 1-191
                                                                                  1-287 1-311
size                      0(12)        based           fixed bin(24,0)          level 2 in structure "arg_descriptor" packed packed
                                                                                  unsigned unaligned dcl 3-6 in procedure
                                                                                  "COMPARE_VALUES" ref 2-309 2-309 2-312 2-312 2-333
                                                                                  2-333 2-336 2-336 2-414 2-416 2-444 2-446 2-474
                                                                                  2-499 2-501 2-504 2-508 2-515 2-515 2-519 2-519
                                                                                  2-544 2-544 2-548 2-548 2-622 2-658 2-662
size                      0(12)        based           fixed bin(24,0)          level 2 in structure "arg_descriptor" packed packed
                                                                                  unsigned unaligned dcl 8-6 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING" ref 1-199 1-218 1-302
size                      0(12) 000504 automatic       fixed bin(24,0)          level 2 in structure
                                                                                  "cvs_truncated_field_descriptor" packed packed
                                                                                  unsigned unaligned dcl 1-118 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING" set ref 1-209* 1-211
                                                                                  1-228* 1-230 1-302
srfi_p_common_ci_header_ptr            parameter       pointer                  dcl 1340 ref 1336 1360
srfi_p_first_idx                       parameter       fixed bin(17,0)          dcl 1342 set ref 1336 1345* 1360* 1360
srfi_p_position_stack_ptr              parameter       pointer                  dcl 1338 ref 1336 1345
string                    1            based           bit                      level 2 in structure "branch_key" packed packed
                                                                                  unaligned dcl 13-32 in procedure "im_basic_search"
                                                                                  set ref 764 764 764 764 771 772
string                                                 builtin function         dcl 365 in procedure "im_basic_search" set ref 1303*
sub_err_                        000070 constant        entry                    external dcl 2-211 in procedure "COMPARE_VALUES" ref
                                                                                  2-226 2-232 2-237
sub_err_                        000024 constant        entry                    external dcl 394 in procedure "im_basic_search" ref
                                                                                  418 436 539 556 802 907 910 1023 1028 1038
sub_err_                        000052 constant        entry                    external dcl 1-151 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING" ref 1-165 1-171
substr                                                 builtin function         dcl 2-167 ref 2-247 2-247 2-251 2-254 2-254 2-258
                                                                                  2-278 2-278 2-282 2-285 2-285 2-289 2-309 2-312
                                                                                  2-333 2-336 2-515 2-515 2-519 2-519 2-525 2-525
                                                                                  2-530 2-530 2-534 2-534 2-538 2-538 2-544 2-544
                                                                                  2-548 2-548 2-553 2-553 2-558 2-558 2-562 2-562
                                                                                  2-566 2-566 2-576 2-579 2-598 2-601
sys_info$max_seg_size           000072 external static fixed bin(35,0)          dcl 2-215 ref 2-247 2-247 2-251 2-254 2-254 2-258
                                                                                  2-278 2-278 2-282 2-285 2-285 2-289 2-309 2-312
                                                                                  2-333 2-336 2-515 2-515 2-519 2-519 2-525 2-525
                                                                                  2-530 2-530 2-534 2-534 2-538 2-538 2-544 2-544
                                                                                  2-548 2-548 2-553 2-553 2-558 2-558 2-562 2-562
                                                                                  2-566 2-566 2-576 2-579 2-598 2-601
temp_id_string                  000155 automatic       bit(36)                  initial dcl 353 set ref 353* 1133* 1135
type                                   based           fixed bin(17,0)          level 2 in structure "simple_typed_vector" packed
                                                                                  packed unaligned dcl 17-17 in procedure
                                                                                  "im_basic_search" set ref 418 418* 436 436*
type                      0(01) 000557 automatic       fixed bin(6,0)           level 2 in structure "cv_local_fixed_arg_descriptor"
                                                                                  packed packed unsigned unaligned dcl 2-130
                                                                                  in procedure "COMPARE_VALUES" set ref 2-367*
                                                                                  2-395*
type                      0(01)        based           fixed bin(6,0)           level 2 in structure "arg_descriptor" packed packed
                                                                                  unsigned unaligned dcl 8-6 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING" ref 1-194 1-194 1-196
                                                                                  1-215 1-260 1-260
type                      0(01)        based           fixed bin(6,0)           level 2 in structure "arg_descriptor" packed packed
                                                                                  unsigned unaligned dcl 3-6 in procedure
                                                                                  "COMPARE_VALUES" set ref 2-226 2-226 2-226* 2-232
                                                                                  2-232 2-232 2-237 2-237 2-242
type                                   based           fixed bin(17,0)          level 2 in structure "index_cursor" packed packed
                                                                                  unaligned dcl 11-29 in procedure "im_basic_search"
                                                                                  set ref 1023 1023*
type                                   based           fixed bin(17,0)          level 2 in structure "simple_typed_vector" packed
                                                                                  packed unaligned dcl 7-17 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING" set ref 1-165 1-165*
type                      0(01) 000556 automatic       fixed bin(6,0)           level 2 in structure "cv_local_arg_descriptor"
                                                                                  packed packed unsigned unaligned dcl 2-128
                                                                                  in procedure "COMPARE_VALUES" set ref 2-425*
                                                                                  2-455*
type                      0(01) 000504 automatic       fixed bin(6,0)           level 2 in structure
                                                                                  "cvs_truncated_field_descriptor" packed packed
                                                                                  unsigned unaligned dcl 1-118 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING" set ref 1-208* 1-227*
unspec                                                 builtin function         dcl 2-167 in procedure "COMPARE_VALUES" set ref
                                                                                  2-247* 2-251* 2-254* 2-258* 2-278* 2-282* 2-285*
                                                                                  2-289* 2-309* 2-312* 2-333* 2-336* 2-576* 2-579*
                                                                                  2-598* 2-601*
unspec                                                 builtin function         dcl 365 in procedure "im_basic_search" ref 1305 1305
                                                                                  1318 1318 1324 1324 1327 1327 1330 1330
value_ptr                 1            based           pointer                  array level 3 packed packed unaligned dcl 7-17 ref
                                                                                  1-287
varying_bit_dtype                      constant        fixed bin(17,0)          initial dcl 9-25 ref 1-194 1-260
varying_char_dtype                     constant        fixed bin(17,0)          initial dcl 9-25 ref 1-194 1-260
vd_error_$wrong_type            000030 external static fixed bin(35,0)          dcl 398 set ref 418* 436*
version                                based           char(8)                  initial level 2 in structure "field_table" dcl 6-36
                                                                                  in procedure "COMPARE_VECTOR_TO_STRING" set ref
                                                                                  1-171 1-171*
version                   0(18)        based           fixed bin(17,0)          level 2 in structure "index_cursor" packed packed
                                                                                  unaligned dcl 11-29 in procedure "im_basic_search"
                                                                                  set ref 1028 1028*
version                                based           char(8)                  level 2 in structure "index_header" dcl 19-25
                                                                                  in procedure "im_basic_search" set ref 1020*
version                                based           char(8)                  initial level 2 in structure "field_table" dcl 21-36
                                                                                  in procedure "im_basic_search" set ref 1038 1038*
version                                based           char(8)                  level 2 in structure "index_opening_info" dcl 18-26
                                                                                  in procedure "im_basic_search" set ref 1017*
want_highest_equal_key          000120 automatic       bit(1)                   initial dcl 321 set ref 321* 637 793 818 1010*
want_key_equal_to_vector        000114 automatic       bit(1)                   initial dcl 321 set ref 321* 412* 430* 452* 574 581
                                                                                  802 805 1010 1010 1013
want_keys_greater_than_vector   000115 automatic       bit(1)                   initial dcl 321 set ref 321* 414* 432* 454* 516 579
                                                                                  805 1010 1013
want_keys_less_than_vector      000116 automatic       bit(1)                   initial dcl 321 set ref 321* 413* 431* 453* 583 1010
                                                                                  1013

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 10-7 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 20-7 in procedure "im_basic_search"
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 5-7 in procedure "COMPARE_VALUES"
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 10-7 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 20-7 in procedure "im_basic_search"
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 5-7 in procedure "COMPARE_VALUES"
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 5-7 in procedure "COMPARE_VALUES"
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 10-7 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 20-7 in procedure "im_basic_search"
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 20-7 in procedure "im_basic_search"
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 10-7 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 5-7 in procedure "COMPARE_VALUES"
BASIC_CI_LAYOUT_1                      internal static char(4)                  initial dcl 22-97
BCI_HEADER_LENGTH_IN_BYTES             internal static fixed bin(17,0)          initial dcl 23-14
CI_0_ADDRESSABLE_LENGTH                internal static fixed bin(17,0)          initial dcl 15-31
CI_ADDRESSABLE_LENGTH                  internal static fixed bin(17,0)          initial dcl 15-29
CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES
                                       internal static fixed bin(17,0)          initial dcl 15-25
DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT
                                       internal static fixed bin(17,0)          initial dcl 12-56
DEFAULT_INITIAL_KEY_SLOT               internal static fixed bin(17,0)          initial dcl 12-56
GENERAL_TYPED_VECTOR_TYPE              internal static fixed bin(17,0)          initial dcl 17-43 in procedure "im_basic_search"
GENERAL_TYPED_VECTOR_TYPE              internal static fixed bin(17,0)          initial dcl 7-43 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
OLD_SIMPLE_TYPED_VECTOR_TYPE           internal static fixed bin(17,0)          initial dcl 17-43 in procedure "im_basic_search"
OLD_SIMPLE_TYPED_VECTOR_TYPE           internal static fixed bin(17,0)          initial dcl 7-43 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
algol68_array_descriptor_dtype         internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
algol68_array_descriptor_dtype         internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
algol68_bits_dtype                     internal static fixed bin(17,0)          initial dcl 9-110 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
algol68_bits_dtype                     internal static fixed bin(17,0)          initial dcl 4-110 in procedure "COMPARE_VALUES"
algol68_bool_dtype                     internal static fixed bin(17,0)          initial dcl 9-110 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
algol68_bool_dtype                     internal static fixed bin(17,0)          initial dcl 4-110 in procedure "COMPARE_VALUES"
algol68_byte_dtype                     internal static fixed bin(17,0)          initial dcl 9-110 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
algol68_byte_dtype                     internal static fixed bin(17,0)          initial dcl 4-110 in procedure "COMPARE_VALUES"
algol68_char_dtype                     internal static fixed bin(17,0)          initial dcl 9-110 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
algol68_char_dtype                     internal static fixed bin(17,0)          initial dcl 4-110 in procedure "COMPARE_VALUES"
algol68_compl_dtype                    internal static fixed bin(17,0)          initial dcl 4-110 in procedure "COMPARE_VALUES"
algol68_compl_dtype                    internal static fixed bin(17,0)          initial dcl 9-110 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
algol68_format_dtype                   internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
algol68_format_dtype                   internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
algol68_int_dtype                      internal static fixed bin(17,0)          initial dcl 4-110 in procedure "COMPARE_VALUES"
algol68_int_dtype                      internal static fixed bin(17,0)          initial dcl 9-110 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
algol68_long_compl_dtype               internal static fixed bin(17,0)          initial dcl 4-110 in procedure "COMPARE_VALUES"
algol68_long_compl_dtype               internal static fixed bin(17,0)          initial dcl 9-110 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
algol68_long_int_dtype                 internal static fixed bin(17,0)          initial dcl 9-110 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
algol68_long_int_dtype                 internal static fixed bin(17,0)          initial dcl 4-110 in procedure "COMPARE_VALUES"
algol68_long_real_dtype                internal static fixed bin(17,0)          initial dcl 9-110 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
algol68_long_real_dtype                internal static fixed bin(17,0)          initial dcl 4-110 in procedure "COMPARE_VALUES"
algol68_real_dtype                     internal static fixed bin(17,0)          initial dcl 9-110 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
algol68_real_dtype                     internal static fixed bin(17,0)          initial dcl 4-110 in procedure "COMPARE_VALUES"
algol68_short_int_dtype                internal static fixed bin(17,0)          initial dcl 4-110 in procedure "COMPARE_VALUES"
algol68_short_int_dtype                internal static fixed bin(17,0)          initial dcl 9-110 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
algol68_straight_dtype                 internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
algol68_straight_dtype                 internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
algol68_struct_struct_bool_dtype       internal static fixed bin(17,0)          initial dcl 4-110 in procedure "COMPARE_VALUES"
algol68_struct_struct_bool_dtype       internal static fixed bin(17,0)          initial dcl 9-110 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
algol68_struct_struct_char_dtype       internal static fixed bin(17,0)          initial dcl 9-110 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
algol68_struct_struct_char_dtype       internal static fixed bin(17,0)          initial dcl 4-110 in procedure "COMPARE_VALUES"
algol68_union_dtype                    internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
algol68_union_dtype                    internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
area_dtype                             internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
area_dtype                             internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
basic_control_interval                 based           structure                level 1 dcl 22-56
basic_control_interval_ptr             automatic       pointer                  dcl 22-92
bci_header_ptr                         automatic       pointer                  dcl 22-94
bit_dtype                              internal static fixed bin(17,0)          initial dcl 4-25
c_enum_const_dtype                     internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
c_enum_const_dtype                     internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
c_enum_dtype                           internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
c_enum_dtype                           internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
c_typeref_dtype                        internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
c_typeref_dtype                        internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
c_union_dtype                          internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
c_union_dtype                          internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
char_dtype                             internal static fixed bin(17,0)          initial dcl 4-25
cobol_char_string_dtype                internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
cobol_char_string_dtype                internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
cobol_comp_5_ts_dtype                  internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
cobol_comp_5_ts_dtype                  internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
cobol_comp_5_uns_dtype                 internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
cobol_comp_5_uns_dtype                 internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
cobol_comp_6_dtype                     internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
cobol_comp_6_dtype                     internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
cobol_comp_7_dtype                     internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
cobol_comp_7_dtype                     internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
cobol_comp_8_ls_dtype                  internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
cobol_comp_8_ls_dtype                  internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
cobol_comp_8_uns_dtype                 internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
cobol_comp_8_uns_dtype                 internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
cobol_display_ls_dtype                 internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
cobol_display_ls_dtype                 internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
cobol_display_ls_overp_dtype           internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
cobol_display_ls_overp_dtype           internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
cobol_display_ts_dtype                 internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
cobol_display_ts_dtype                 internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
cobol_display_ts_overp_dtype           internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
cobol_display_ts_overp_dtype           internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
cobol_display_uns_dtype                internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
cobol_display_uns_dtype                internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
cobol_structure_dtype                  internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
cobol_structure_dtype                  internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
collection_manager_$allocate_control_interval
                                000000 constant        entry                    external dcl 16-50
collection_manager_$compact_control_interval
                                000000 constant        entry                    external dcl 16-52
collection_manager_$create_collection
                                000000 constant        entry                    external dcl 16-54
collection_manager_$create_file 000000 constant        entry                    external dcl 16-56
collection_manager_$delete      000000 constant        entry                    external dcl 16-64
collection_manager_$delete_from_ci_buffer
                                000000 constant        entry                    external dcl 16-67
collection_manager_$destroy_collection
                                000000 constant        entry                    external dcl 16-58
collection_manager_$free_control_interval
                                000000 constant        entry                    external dcl 16-60
collection_manager_$get         000000 constant        entry                    external dcl 16-71
collection_manager_$get_by_ci_ptr
                                000000 constant        entry                    external dcl 16-80
collection_manager_$get_from_ci_buffer
                                000000 constant        entry                    external dcl 16-77
collection_manager_$get_header  000000 constant        entry                    external dcl 16-83
collection_manager_$get_id      000000 constant        entry                    external dcl 16-86
collection_manager_$get_portion 000000 constant        entry                    external dcl 16-89
collection_manager_$get_portion_by_ci_ptr
                                000000 constant        entry                    external dcl 16-97
collection_manager_$get_portion_from_ci_buffer
                                000000 constant        entry                    external dcl 16-93
collection_manager_$modify      000000 constant        entry                    external dcl 16-101
collection_manager_$modify_in_ci_buffer
                                000000 constant        entry                    external dcl 16-107
collection_manager_$modify_portion
                                000000 constant        entry                    external dcl 16-110
collection_manager_$modify_unprotected
                                000000 constant        entry                    external dcl 16-104
collection_manager_$postcommit_increments
                                000000 constant        entry                    external dcl 16-113
collection_manager_$put         000000 constant        entry                    external dcl 16-115
collection_manager_$put_header  000000 constant        entry                    external dcl 16-121
collection_manager_$put_in_ci_buffer
                                000000 constant        entry                    external dcl 16-118
collection_manager_$put_unprotected_header
                                000000 constant        entry                    external dcl 16-123
collection_manager_$replace_ci_buffer
                                000000 constant        entry                    external dcl 16-126
collection_manager_$setup_ci_buffer
                                000000 constant        entry                    external dcl 16-129
collection_manager_$simple_get_by_ci_ptr
                                000000 constant        entry                    external dcl 16-132
collection_manager_$simple_get_from_ci_buffer
                                000000 constant        entry                    external dcl 16-135
cplx_fix_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
cplx_fix_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
cplx_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
cplx_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
cplx_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
cplx_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
cplx_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
cplx_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
cplx_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
cplx_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
cplx_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
cplx_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
cplx_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
cplx_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
cplx_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
cplx_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
cplx_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
cplx_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
cplx_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
cplx_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
cplx_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
cplx_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
cplx_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
cplx_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
cplx_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
cplx_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
cv_based_real_fix_bin_1_unsu           based           fixed bin(35,0)          packed unsigned unaligned dcl 2-160
cv_based_real_fix_bin_2_unsu           based           fixed bin(71,0)          packed unsigned unaligned dcl 2-162
cv_based_real_fix_bin_2u               based           fixed bin(71,0)          packed unaligned dcl 2-144
cv_based_real_flt_bin_1u               based           float bin(27)            packed unaligned dcl 2-151
cv_based_real_flt_bin_2u               based           float bin(63)            packed unaligned dcl 2-153
cvs_current_field_id                   automatic       fixed bin(35,0)          dcl 1-98
cvs_key_string                         based           bit                      packed unaligned dcl 1-129
cvs_varying_field_idx                  automatic       fixed bin(17,0)          dcl 1-120
datum_slot_ptr                         automatic       pointer                  dcl 22-95
entry_dtype                            internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
entry_dtype                            internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
ext_entry_runtime_dtype                internal static fixed bin(17,0)          initial dcl 9-125 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
ext_entry_runtime_dtype                internal static fixed bin(17,0)          initial dcl 4-125 in procedure "COMPARE_VALUES"
ext_procedure_runtime_dtype            internal static fixed bin(17,0)          initial dcl 4-125 in procedure "COMPARE_VALUES"
ext_procedure_runtime_dtype            internal static fixed bin(17,0)          initial dcl 9-125 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
extended_arg_descriptor                based           structure                level 1 dcl 8-21 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
extended_arg_descriptor                based           structure                level 1 dcl 3-21 in procedure "COMPARE_VALUES"
field_name                             based           char                     packed unaligned dcl 21-71 in procedure
                                                                                  "im_basic_search"
field_name                             based           char                     packed unaligned dcl 6-71 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
field_name_length                      automatic       fixed bin(17,0)          dcl 21-73 in procedure "im_basic_search"
field_name_length                      automatic       fixed bin(17,0)          dcl 6-73 in procedure "COMPARE_VECTOR_TO_STRING"
field_name_ptr                         automatic       pointer                  dcl 21-74 in procedure "im_basic_search"
field_name_ptr                         automatic       pointer                  dcl 6-74 in procedure "COMPARE_VECTOR_TO_STRING"
field_table_ptr                        automatic       pointer                  dcl 21-65
file_dtype                             internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
file_dtype                             internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
fixed_arg_descriptor                   based           structure                level 1 dcl 8-13
ft_char_dtype                          internal static fixed bin(17,0)          initial dcl 9-96 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
ft_char_dtype                          internal static fixed bin(17,0)          initial dcl 4-96 in procedure "COMPARE_VALUES"
ft_complex_double_dtype                internal static fixed bin(17,0)          initial dcl 4-96 in procedure "COMPARE_VALUES"
ft_complex_double_dtype                internal static fixed bin(17,0)          initial dcl 9-96 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
ft_complex_dtype                       internal static fixed bin(17,0)          initial dcl 9-96 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
ft_complex_dtype                       internal static fixed bin(17,0)          initial dcl 4-96 in procedure "COMPARE_VALUES"
ft_double_dtype                        internal static fixed bin(17,0)          initial dcl 4-96 in procedure "COMPARE_VALUES"
ft_double_dtype                        internal static fixed bin(17,0)          initial dcl 9-96 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
ft_external_dtype                      internal static fixed bin(17,0)          initial dcl 4-96 in procedure "COMPARE_VALUES"
ft_external_dtype                      internal static fixed bin(17,0)          initial dcl 9-96 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
ft_hex_complex_double_dtype            internal static fixed bin(17,0)          initial dcl 4-96 in procedure "COMPARE_VALUES"
ft_hex_complex_double_dtype            internal static fixed bin(17,0)          initial dcl 9-96 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
ft_hex_complex_dtype                   internal static fixed bin(17,0)          initial dcl 9-96 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
ft_hex_complex_dtype                   internal static fixed bin(17,0)          initial dcl 4-96 in procedure "COMPARE_VALUES"
ft_hex_double_dtype                    internal static fixed bin(17,0)          initial dcl 4-96 in procedure "COMPARE_VALUES"
ft_hex_double_dtype                    internal static fixed bin(17,0)          initial dcl 9-96 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
ft_hex_real_dtype                      internal static fixed bin(17,0)          initial dcl 4-96 in procedure "COMPARE_VALUES"
ft_hex_real_dtype                      internal static fixed bin(17,0)          initial dcl 9-96 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
ft_integer_dtype                       internal static fixed bin(17,0)          initial dcl 4-96 in procedure "COMPARE_VALUES"
ft_integer_dtype                       internal static fixed bin(17,0)          initial dcl 9-96 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
ft_length_of_field_names               automatic       fixed bin(17,0)          dcl 21-66 in procedure "im_basic_search"
ft_length_of_field_names               automatic       fixed bin(17,0)          dcl 6-66 in procedure "COMPARE_VECTOR_TO_STRING"
ft_logical_dtype                       internal static fixed bin(17,0)          initial dcl 9-96 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
ft_logical_dtype                       internal static fixed bin(17,0)          initial dcl 4-96 in procedure "COMPARE_VALUES"
ft_number_of_fields                    automatic       fixed bin(17,0)          dcl 6-68 in procedure "COMPARE_VECTOR_TO_STRING"
ft_number_of_fields                    automatic       fixed bin(17,0)          dcl 21-68 in procedure "im_basic_search"
ft_real_dtype                          internal static fixed bin(17,0)          initial dcl 4-96 in procedure "COMPARE_VALUES"
ft_real_dtype                          internal static fixed bin(17,0)          initial dcl 9-96 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
general_typed_vector                   based           structure                level 1 packed packed unaligned dcl 17-24
                                                                                  in procedure "im_basic_search"
general_typed_vector                   based           structure                level 1 packed packed unaligned dcl 7-24
                                                                                  in procedure "COMPARE_VECTOR_TO_STRING"
general_typed_vector_ptr               automatic       pointer                  dcl 17-38 in procedure "im_basic_search"
general_typed_vector_ptr               automatic       pointer                  dcl 7-38 in procedure "COMPARE_VECTOR_TO_STRING"
gtv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 7-40 in procedure "COMPARE_VECTOR_TO_STRING"
gtv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 17-40 in procedure "im_basic_search"
int_entry_runtime_dtype                internal static fixed bin(17,0)          initial dcl 4-125 in procedure "COMPARE_VALUES"
int_entry_runtime_dtype                internal static fixed bin(17,0)          initial dcl 9-125 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
key_string                             based           bit                      packed unaligned dcl 13-22
key_string_length                      automatic       fixed bin(35,0)          dcl 13-23
key_string_ptr                         automatic       pointer                  dcl 13-24
label_constant_runtime_dtype           internal static fixed bin(17,0)          initial dcl 9-125 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
label_constant_runtime_dtype           internal static fixed bin(17,0)          initial dcl 4-125 in procedure "COMPARE_VALUES"
label_dtype                            internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
label_dtype                            internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
leaf_key                               based           structure                level 1 packed packed unaligned dcl 13-26
leaf_key_ptr                           automatic       pointer                  dcl 13-30
lk_string_length                       automatic       fixed bin(35,0)          dcl 13-29
offset_dtype                           internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
offset_dtype                           internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
pascal_boolean_dtype                   internal static fixed bin(17,0)          initial dcl 4-132 in procedure "COMPARE_VALUES"
pascal_boolean_dtype                   internal static fixed bin(17,0)          initial dcl 9-132 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
pascal_char_dtype                      internal static fixed bin(17,0)          initial dcl 4-132 in procedure "COMPARE_VALUES"
pascal_char_dtype                      internal static fixed bin(17,0)          initial dcl 9-132 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
pascal_entry_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 4-132 in procedure "COMPARE_VALUES"
pascal_entry_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 9-132 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
pascal_enumerated_type_dtype           internal static fixed bin(17,0)          initial dcl 9-132 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
pascal_enumerated_type_dtype           internal static fixed bin(17,0)          initial dcl 4-132 in procedure "COMPARE_VALUES"
pascal_enumerated_type_element_dtype   internal static fixed bin(17,0)          initial dcl 4-132 in procedure "COMPARE_VALUES"
pascal_enumerated_type_element_dtype   internal static fixed bin(17,0)          initial dcl 9-132 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
pascal_enumerated_type_instance_dtype  internal static fixed bin(17,0)          initial dcl 9-132 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
pascal_enumerated_type_instance_dtype  internal static fixed bin(17,0)          initial dcl 4-132 in procedure "COMPARE_VALUES"
pascal_exportable_procedure_dtype      internal static fixed bin(17,0)          initial dcl 9-132 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
pascal_exportable_procedure_dtype      internal static fixed bin(17,0)          initial dcl 4-132 in procedure "COMPARE_VALUES"
pascal_imported_procedure_dtype        internal static fixed bin(17,0)          initial dcl 9-132 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
pascal_imported_procedure_dtype        internal static fixed bin(17,0)          initial dcl 4-132 in procedure "COMPARE_VALUES"
pascal_integer_dtype                   internal static fixed bin(17,0)          initial dcl 4-132 in procedure "COMPARE_VALUES"
pascal_integer_dtype                   internal static fixed bin(17,0)          initial dcl 9-132 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
pascal_internal_procedure_dtype        internal static fixed bin(17,0)          initial dcl 9-132 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
pascal_internal_procedure_dtype        internal static fixed bin(17,0)          initial dcl 4-132 in procedure "COMPARE_VALUES"
pascal_label_dtype                     internal static fixed bin(17,0)          initial dcl 4-132 in procedure "COMPARE_VALUES"
pascal_label_dtype                     internal static fixed bin(17,0)          initial dcl 9-132 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
pascal_parameter_procedure_dtype       internal static fixed bin(17,0)          initial dcl 9-132 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
pascal_parameter_procedure_dtype       internal static fixed bin(17,0)          initial dcl 4-132 in procedure "COMPARE_VALUES"
pascal_procedure_type_dtype            internal static fixed bin(17,0)          initial dcl 4-132 in procedure "COMPARE_VALUES"
pascal_procedure_type_dtype            internal static fixed bin(17,0)          initial dcl 9-132 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
pascal_real_dtype                      internal static fixed bin(17,0)          initial dcl 9-132 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
pascal_real_dtype                      internal static fixed bin(17,0)          initial dcl 4-132 in procedure "COMPARE_VALUES"
pascal_record_file_type_dtype          internal static fixed bin(17,0)          initial dcl 9-132 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
pascal_record_file_type_dtype          internal static fixed bin(17,0)          initial dcl 4-132 in procedure "COMPARE_VALUES"
pascal_record_type_dtype               internal static fixed bin(17,0)          initial dcl 9-132 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
pascal_record_type_dtype               internal static fixed bin(17,0)          initial dcl 4-132 in procedure "COMPARE_VALUES"
pascal_set_dtype                       internal static fixed bin(17,0)          initial dcl 4-132 in procedure "COMPARE_VALUES"
pascal_set_dtype                       internal static fixed bin(17,0)          initial dcl 9-132 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
pascal_string_type_dtype               internal static fixed bin(17,0)          initial dcl 4-132 in procedure "COMPARE_VALUES"
pascal_string_type_dtype               internal static fixed bin(17,0)          initial dcl 9-132 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
pascal_text_file_dtype                 internal static fixed bin(17,0)          initial dcl 4-132 in procedure "COMPARE_VALUES"
pascal_text_file_dtype                 internal static fixed bin(17,0)          initial dcl 9-132 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
pascal_typed_pointer_type_dtype        internal static fixed bin(17,0)          initial dcl 9-132 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
pascal_typed_pointer_type_dtype        internal static fixed bin(17,0)          initial dcl 4-132 in procedure "COMPARE_VALUES"
pascal_user_defined_type_dtype         internal static fixed bin(17,0)          initial dcl 4-132 in procedure "COMPARE_VALUES"
pascal_user_defined_type_dtype         internal static fixed bin(17,0)          initial dcl 9-132 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
pascal_user_defined_type_instance_dtype
                                       internal static fixed bin(17,0)          initial dcl 9-132 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
pascal_user_defined_type_instance_dtype
                                       internal static fixed bin(17,0)          initial dcl 4-132 in procedure "COMPARE_VALUES"
pascal_value_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 4-132 in procedure "COMPARE_VALUES"
pascal_value_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 9-132 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
pascal_variable_formal_parameter_dtype internal static fixed bin(17,0)          initial dcl 9-132 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
pascal_variable_formal_parameter_dtype internal static fixed bin(17,0)          initial dcl 4-132 in procedure "COMPARE_VALUES"
picture_runtime_dtype                  internal static fixed bin(17,0)          initial dcl 4-125 in procedure "COMPARE_VALUES"
picture_runtime_dtype                  internal static fixed bin(17,0)          initial dcl 9-125 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
pointer_dtype                          internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
pointer_dtype                          internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
real_fix_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
real_fix_bin_1_uns_dtype               internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
real_fix_bin_1_uns_dtype               internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
real_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
real_fix_bin_2_uns_dtype               internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
real_fix_bin_2_uns_dtype               internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
real_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
real_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
real_fix_dec_4bit_bytealigned_uns_dtype
                                       internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
real_fix_dec_4bit_bytealigned_uns_dtype
                                       internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
real_fix_dec_4bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
real_fix_dec_4bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
real_fix_dec_4bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
real_fix_dec_4bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
real_fix_dec_4bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
real_fix_dec_4bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
real_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
real_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
real_fix_dec_9bit_ls_overp_dtype       internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
real_fix_dec_9bit_ls_overp_dtype       internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
real_fix_dec_9bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
real_fix_dec_9bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
real_fix_dec_9bit_ts_overp_dtype       internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
real_fix_dec_9bit_ts_overp_dtype       internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
real_fix_dec_9bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
real_fix_dec_9bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
real_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
real_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
real_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
real_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
real_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
real_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
real_flt_dec_4bit_dtype                internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
real_flt_dec_4bit_dtype                internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
real_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
real_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
real_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
real_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
real_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
real_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
real_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
real_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
real_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
real_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
simple_typed_vector_ptr                automatic       pointer                  dcl 17-33
structure_dtype                        internal static fixed bin(17,0)          initial dcl 9-25 in procedure
                                                                                  "COMPARE_VECTOR_TO_STRING"
structure_dtype                        internal static fixed bin(17,0)          initial dcl 4-25 in procedure "COMPARE_VALUES"
stv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 17-35 in procedure "im_basic_search"
stv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 7-35 in procedure "COMPARE_VECTOR_TO_STRING"
varying_bit_dtype                      internal static fixed bin(17,0)          initial dcl 4-25
varying_char_dtype                     internal static fixed bin(17,0)          initial dcl 4-25

NAMES DECLARED BY EXPLICIT CONTEXT.
ANALYZE_RESULTS                 001401 constant        entry                    internal dcl 509 ref 470
BRANCH_KEY_LOOP                 002304 constant        label                    dcl 755
BRANCH_NODE_LOOP                002136 constant        label                    dcl 687
CHECK_PARENT_THREAD             001431 constant        entry                    internal dcl 530 ref 726 1433
CHECK_VERSION                   001536 constant        entry                    internal dcl 550 ref 1017 1020
COMPARE_VALUES                  005651 constant        entry                    internal dcl 2-65 ref 1-290
COMPARE_VECTOR_TO_STRING        005023 constant        entry                    internal dcl 1-49 ref 614 775
CURRENT_KEY_SATISFIES_CONSTRAINTS
                                001640 constant        entry                    internal dcl 571 ref 512
CV_RETURN_EQUAL                 010557 constant        label                    dcl 2-698 ref 2-261 2-267 2-292 2-298 2-317 2-323
                                                                                  2-340 2-346 2-515 2-525 2-534 2-544 2-553 2-562
                                                                                  2-582 2-588 2-604 2-610
CV_RETURN_GREATER               010567 constant        label                    dcl 2-708 ref 2-265 2-271 2-296 2-302 2-321 2-327
                                                                                  2-344 2-350 2-522 2-533 2-542 2-551 2-561 2-570
                                                                                  2-586 2-592 2-608 2-614
CV_RETURN_LESS                  010563 constant        label                    dcl 2-703 set ref 2-263 2-269 2-294 2-300 2-319
                                                                                  2-325 2-342 2-348 2-519 2-530 2-538 2-548 2-558
                                                                                  2-566 2-584 2-590 2-606 2-612
CV_TYPE                         000000 constant        label                    array(46) dcl 2-243 ref 2-242
ERROR_RETURN                    001374 constant        entry                    internal dcl 492 ref 478 616 777 866 928 930 939 985
                                                                                  987 1080 1332
FIELD_LOOP                      005436 constant        label                    dcl 1-247
FIND_LEAF_KEY                   001703 constant        entry                    internal dcl 593 ref 468
FIND_LEAF_NODE                  002135 constant        entry                    internal dcl 685 ref 465
FIND_NEXT_BRANCH                002276 constant        entry                    internal dcl 748 ref 717
GET_CI_HEADER                   002656 constant        entry                    internal dcl 884 ref 723 1090 1144 1158 1177 1229
                                                                                  1279 1313 1389 1399 1430
GET_NEW_KEY                     003164 constant        entry                    internal dcl 959 ref 607 698 761 1113
GET_NEW_NODE                    002624 constant        entry                    internal dcl 853 ref 825 839 1089 1101 1109 1115
                                                                                  1142 1157 1175 1228 1278 1312 1387 1398 1425
INITIALIZE_LOCAL_VARIABLES      003303 constant        entry                    internal dcl 1007 ref 460
INIT_BOTTOM_UP                  004044 constant        label                    dcl 1139
INIT_POSITION_STACK             003651 constant        entry                    internal dcl 1075 ref 1381
INIT_TOP_DOWN                   003676 constant        label                    dcl 1083
JOIN                            001320 constant        label                    dcl 460 ref 424 442 458
LEAF_KEY_LOOP                   001727 constant        label                    dcl 604
MAIN_RETURN                     001370 constant        label                    dcl 482 ref 488 498
PREPARE_NONVARYING_FIELD        005503 constant        label                    dcl 1-260
PREPARE_VARYING_FIELD           005520 constant        label                    dcl 1-268
REPORT_FAILED_EXACT_MATCH       004143 constant        entry                    internal dcl 1196 ref 514
REPORT_NEXT_KEY                 004205 constant        entry                    internal dcl 1219 ref 516
REPORT_PREVIOUS_KEY             004270 constant        entry                    internal dcl 1250 ref 518
REPOSITION_CURSOR               004406 constant        entry                    internal dcl 1299 ref 472
RETURN                          001371 constant        entry                    internal dcl 485 ref 480 1165
SETUP_FIRST_NODE                004711 constant        entry                    internal dcl 1376 ref 463
SET_RELATIVE_FIRST_IDX          004662 constant        entry                    internal dcl 1336 ref 730 1394
SKIP_DEGENERATE_NODES           004752 constant        entry                    internal dcl 1418 ref 728
im_basic_search                 001000 constant        entry                    external dcl 280
insert                          001135 constant        entry                    external dcl 426
reposition                      001263 constant        entry                    external dcl 444

NAMES DECLARED BY CONTEXT OR IMPLICATION.
bitno                                                  builtin function         ref 2-232 2-237
mod                                                    builtin function         ref 2-232 2-237

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     11470       11570   11061       11500
Length     12554   11061       100         750     406           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
im_basic_search                    1070 external procedure  is an external procedure.  
RETURN                                  internal procedure  shares stack frame of external procedure im_basic_search.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure im_basic_search.  
ANALYZE_RESULTS                         internal procedure  shares stack frame of external procedure im_basic_search.  
CHECK_PARENT_THREAD                     internal procedure  shares stack frame of external procedure im_basic_search.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure im_basic_search.  
CURRENT_KEY_SATISFIES_CONSTRAINTS
                                        internal procedure  shares stack frame of external procedure im_basic_search.  
FIND_LEAF_KEY                           internal procedure  shares stack frame of external procedure im_basic_search.  
FIND_LEAF_NODE                          internal procedure  shares stack frame of external procedure im_basic_search.  
FIND_NEXT_BRANCH                        internal procedure  shares stack frame of external procedure im_basic_search.  
GET_NEW_NODE                            internal procedure  shares stack frame of external procedure im_basic_search.  
GET_CI_HEADER                           internal procedure  shares stack frame of external procedure im_basic_search.  
GET_NEW_KEY                             internal procedure  shares stack frame of external procedure im_basic_search.  
INITIALIZE_LOCAL_VARIABLES              internal procedure  shares stack frame of external procedure im_basic_search.  
INIT_POSITION_STACK                     internal procedure  shares stack frame of external procedure im_basic_search.  
REPORT_FAILED_EXACT_MATCH               internal procedure  shares stack frame of external procedure im_basic_search.  
REPORT_NEXT_KEY                         internal procedure  shares stack frame of external procedure im_basic_search.  
REPORT_PREVIOUS_KEY                     internal procedure  shares stack frame of external procedure im_basic_search.  
REPOSITION_CURSOR                       internal procedure  shares stack frame of external procedure im_basic_search.  
SET_RELATIVE_FIRST_IDX                  internal procedure  shares stack frame of external procedure im_basic_search.  
SETUP_FIRST_NODE                        internal procedure  shares stack frame of external procedure im_basic_search.  
SKIP_DEGENERATE_NODES                   internal procedure  shares stack frame of external procedure im_basic_search.  
COMPARE_VECTOR_TO_STRING                internal procedure  shares stack frame of external procedure im_basic_search.  
COMPARE_VALUES                          internal procedure  shares stack frame of external procedure im_basic_search.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
im_basic_search          000100 cvs_p_field_table_ptr       im_basic_search
                         000102 cvs_p_simple_typed_vector_ptr
                                                            im_basic_search
                         000104 cvs_p_key_string_ptr        im_basic_search
                         000106 cvs_p_key_string_length     im_basic_search
                         000107 cvs_p_last_field_idx        im_basic_search
                         000110 cvs_p_first_inequal_field_id
                                                            im_basic_search
                         000111 cvs_p_vector_equal_to_key   im_basic_search
                         000112 cvs_p_vector_less_than_key  im_basic_search
                         000113 cvs_p_code                  im_basic_search
                         000114 want_key_equal_to_vector    im_basic_search
                         000115 want_keys_greater_than_vector
                                                            im_basic_search
                         000116 want_keys_less_than_vector  im_basic_search
                         000117 only_want_key_equal_to_vector
                                                            im_basic_search
                         000120 want_highest_equal_key      im_basic_search
                         000121 is_relative_search          im_basic_search
                         000122 is_reposition               im_basic_search
                         000123 is_insertion                im_basic_search
                         000124 failed_exact_match          im_basic_search
                         000126 position_stack_ptr          im_basic_search
                         000130 high_duplication_field      im_basic_search
                         000131 low_duplication_field       im_basic_search
                         000132 is_first_pass_through_loop  im_basic_search
                         000133 current_depth               im_basic_search
                         000134 first_idx                   im_basic_search
                         000135 equal_idx                   im_basic_search
                         000136 low_idx                     im_basic_search
                         000137 high_idx                    im_basic_search
                         000140 current_idx                 im_basic_search
                         000141 parent_idx                  im_basic_search
                         000142 depth_idx                   im_basic_search
                         000143 number_of_fields_in_vector  im_basic_search
                         000144 parent_node_id              im_basic_search
                         000145 current_node_id             im_basic_search
                         000146 less_branch_id              im_basic_search
                         000150 key_id_ptr                  im_basic_search
                         000152 current_node_ptr            im_basic_search
                         000154 local_header_buffer         im_basic_search
                         000154 local_key_buffer            im_basic_search
                         000154 local_key_id_string         im_basic_search
                         000155 temp_id_string              im_basic_search
                         000156 index_cursor_ptr            im_basic_search
                         000160 common_ci_header_ptr        im_basic_search
                         000162 leaf_ci_header_ptr          im_basic_search
                         000164 branch_ci_header_ptr        im_basic_search
                         000166 bk_string_length            im_basic_search
                         000170 branch_key_ptr              im_basic_search
                         000172 element_id_string           im_basic_search
                         000174 index_opening_info_ptr      im_basic_search
                         000176 index_header_ptr            im_basic_search
                         000314 gnn_code                    GET_NEW_NODE
                         000324 gch_header_length_in_bytes  GET_CI_HEADER
                         000326 gch_slot_ptr                GET_CI_HEADER
                         000336 gnk_key_length_in_bytes     GET_NEW_KEY
                         000340 gnk_slot_ptr                GET_NEW_KEY
                         000356 ips_code                    INIT_POSITION_STACK
                         000410 rp_code                     REPOSITION_CURSOR
                         000442 cv_p_code                   COMPARE_VECTOR_TO_STRING
                         000444 cv_p_descriptor_ptr         COMPARE_VECTOR_TO_STRING
                         000446 cv_p_field_value_length     COMPARE_VECTOR_TO_STRING
                         000450 cv_p_field_value_ptr        COMPARE_VECTOR_TO_STRING
                         000452 cv_p_vector_equal_to_key    COMPARE_VECTOR_TO_STRING
                         000453 cv_p_vector_less_than_key   COMPARE_VECTOR_TO_STRING
                         000454 cv_p_vector_value_length    COMPARE_VECTOR_TO_STRING
                         000456 cv_p_vector_value_ptr       COMPARE_VECTOR_TO_STRING
                         000460 cvs_field_idx               COMPARE_VECTOR_TO_STRING
                         000461 cvs_field_value_offset      COMPARE_VECTOR_TO_STRING
                         000462 cvs_key_string_length       COMPARE_VECTOR_TO_STRING
                         000464 cvs_key_string_ptr          COMPARE_VECTOR_TO_STRING
                         000466 cvs_last_field_idx          COMPARE_VECTOR_TO_STRING
                         000467 cvs_last_field_is_truncated COMPARE_VECTOR_TO_STRING
                         000470 cvs_last_field_length_in_bits
                                                            COMPARE_VECTOR_TO_STRING
                         000472 cvs_last_field_length_ptr   COMPARE_VECTOR_TO_STRING
                         000474 cvs_last_field_value_ptr    COMPARE_VECTOR_TO_STRING
                         000476 cvs_length_field_length     COMPARE_VECTOR_TO_STRING
                         000500 cvs_length_field_ptr        COMPARE_VECTOR_TO_STRING
                         000502 cvs_location_of_first_varying_field
                                                            COMPARE_VECTOR_TO_STRING
                         000503 cvs_maximum_field_idx       COMPARE_VECTOR_TO_STRING
                         000504 cvs_truncated_field_descriptor
                                                            COMPARE_VECTOR_TO_STRING
                         000505 cvs_varying_field_value_offset
                                                            COMPARE_VECTOR_TO_STRING
                         000506 field_table_ptr             COMPARE_VECTOR_TO_STRING
                         000510 simple_typed_vector_ptr     COMPARE_VECTOR_TO_STRING
                         000512 arg_descriptor_ptr          COMPARE_VECTOR_TO_STRING
                         000514 extended_arg_type           COMPARE_VECTOR_TO_STRING
                         000524 cv_local_vector_real_fix_bin_1
                                                            COMPARE_VALUES
                         000525 cv_local_field_real_fix_bin_1
                                                            COMPARE_VALUES
                         000526 cv_local_vector_real_fix_bin_2
                                                            COMPARE_VALUES
                         000530 cv_local_field_real_fix_bin_2
                                                            COMPARE_VALUES
                         000532 cv_local_vector_real_flt_bin_1
                                                            COMPARE_VALUES
                         000533 cv_local_field_real_flt_bin_1
                                                            COMPARE_VALUES
                         000534 cv_local_vector_real_flt_bin_2
                                                            COMPARE_VALUES
                         000536 cv_local_field_real_flt_bin_2
                                                            COMPARE_VALUES
                         000540 cv_local_vector_real_fix_bin_1_uns
                                                            COMPARE_VALUES
                         000541 cv_local_field_real_fix_bin_1_uns
                                                            COMPARE_VALUES
                         000542 cv_local_vector_real_fix_bin_2_uns
                                                            COMPARE_VALUES
                         000544 cv_local_field_real_fix_bin_2_uns
                                                            COMPARE_VALUES
                         000546 cv_vector_real_part_value_ptr
                                                            COMPARE_VALUES
                         000550 cv_vector_imaginary_part_value_ptr
                                                            COMPARE_VALUES
                         000552 cv_field_real_part_value_ptr
                                                            COMPARE_VALUES
                         000554 cv_field_imaginary_part_value_ptr
                                                            COMPARE_VALUES
                         000556 cv_local_arg_descriptor     COMPARE_VALUES
                         000557 cv_local_fixed_arg_descriptor
                                                            COMPARE_VALUES
                         000560 arg_descriptor_ptr          COMPARE_VALUES
                         000562 extended_arg_type           COMPARE_VALUES

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_bit_temp      cat_realloc_bits    call_ext_out_desc   call_ext_out        return_mac          longbs_to_fx2
alloc_auto_adj      mdfx1               shorten_stack       ext_entry           ceil_fx1            set_bits_eis
divide_fx1

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
collection_manager_$get_control_interval_ptr                data_format_util_$compare_string_to_string
dmu_compare_decimal_values$dmu_compare_dec4fl               dmu_compare_decimal_values$dmu_compare_dec4ls
dmu_compare_decimal_values$dmu_compare_dec9fl               dmu_compare_decimal_values$dmu_compare_dec9ls
dmu_compare_values            im_set_cursor$at_beginning    im_set_cursor$at_current      im_set_cursor$at_end
im_set_cursor$no_current      im_validate_cursor            sub_err_                      sub_err_
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bad_first_key_idx   dm_error_$bad_last_key_idx    dm_error_$bad_parent_thread   dm_error_$key_not_found
dm_error_$long_return_element dm_error_$no_element          dm_error_$programming_error
dm_error_$unimplemented_data_type                           error_table_$bad_arg
error_table_$unimplemented_version                          error_table_$unimplemented_version
sys_info$max_seg_size         vd_error_$wrong_type




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    321 000715       324 000726       325 000730       331 000732       333 000733       337 000734       338 000736
    340 000737       343 000740       350 000741       351 000753       352 000762       353 000763   18   46 000764
    280 000770       412 001017       413 001023       414 001026       415 001031       416 001034       417 001037
    418 001042       423 001124       424 001126       426 001127       429 001154       430 001156       431 001157
    432 001160       433 001161       434 001162       435 001164       436 001167       441 001253       442 001255
    444 001256       446 001274       448 001300       449 001302       451 001306       452 001310       453 001311
    454 001312       455 001313       456 001314       457 001316       458 001317       460 001320       463 001321
    465 001322       468 001326       470 001327       472 001330       474 001334       478 001346       480 001367
    482 001370       485 001371       487 001372       488 001373       492 001374       497 001376       498 001400
    509 001401       512 001402       514 001417       516 001423       518 001427       519 001430       530 001431
    539 001433       546 001535       550 001536       556 001547       561 001637       571 001640       574 001642
    579 001657       581 001665       583 001700       593 001703       595 001704       597 001705       598 001710
    599 001715       601 001720       602 001723       604 001727       607 001740       610 001743       614 002005
    616 002006       619 002012       622 002017       625 002022       626 002025       627 002027       628 002032
    629 002033       633 002036       634 002040       635 002042       636 002045       637 002046       640 002050
    641 002052       642 002055       645 002056       646 002060       647 002061       650 002064       652 002065
    656 002075       657 002077       658 002100       659 002102       660 002103       663 002104       664 002106
    665 002107       666 002111       667 002112       668 002113       672 002126       673 002130       674 002131
    675 002133       677 002134       685 002135       687 002136       690 002141       694 002152       695 002155
    698 002156       700 002161       701 002170       702 002171       703 002175       704 002176       705 002203
    710 002207       713 002212       715 002217       717 002222       719 002223       723 002233       726 002235
    728 002250       730 002251       733 002263       734 002270       736 002274       738 002275       748 002276
    751 002277       755 002301       759 002311       761 002312       764 002315       771 002365       772 002370
    773 002372       775 002401       777 002402       780 002406       783 002411       784 002413       785 002416
    786 002417       789 002422       790 002424       791 002433       792 002437       793 002440       796 002442
    797 002444       798 002453       799 002457       802 002460       805 002530       807 002534       808 002536
    809 002541       811 002542       812 002544       816 002553       818 002554       821 002561       822 002563
    824 002571       825 002573       826 002575       835 002576       836 002601       838 002610       839 002612
    841 002623       853 002624       862 002626       864 002630       866 002651       869 002655       884 002656
    901 002660       902 002664       904 002667       907 002674       910 002750       916 003050       918 003063
    922 003100       925 003103       926 003104       928 003106       930 003124       933 003137       936 003140
    937 003142       939 003145       944 003163       959 003164       979 003166       980 003172       982 003175
    985 003207       987 003222       990 003241       992 003255       994 003272       995 003274       997 003302
   1007 003303      1010 003304      1013 003314      1016 003321      1017 003325      1019 003347      1020 003352
   1022 003375      1023 003401      1028 003460      1033 003542      1035 003545      1038 003551      1042 003627
   1043 003632      1044 003633      1046 003642      1047 003644      1048 003646      1049 003650      1075 003651
   1077 003652      1079 003653      1080 003666      1083 003672      1089 003676      1090 003704      1093 003706
   1095 003711      1096 003712      1098 003717      1101 003723      1103 003731      1104 003735      1107 003736
   1108 003742      1109 003745      1113 003755      1115 003760      1118 003771      1119 003772      1120 003773
   1121 004000      1124 004013      1132 004016      1133 004027      1134 004031      1135 004037      1136 004041
   1138 004043      1142 004044      1144 004051      1147 004053      1149 004055      1150 004061      1153 004065
   1157 004100      1158 004103      1160 004105      1161 004111      1164 004112      1165 004113      1168 004114
   1169 004120      1171 004122      1172 004125      1173 004126      1175 004130      1177 004135      1180 004137
   1183 004140      1185 004142      1196 004143      1198 004144      1200 004146      1203 004156      1207 004171
   1208 004175      1210 004204      1219 004205      1221 004206      1224 004220      1225 004224      1228 004232
   1229 004235      1231 004237      1232 004247      1233 004250      1234 004253      1237 004254      1238 004260
   1241 004267      1250 004270      1252 004271      1259 004273      1264 004316      1265 004322      1266 004325
   1270 004326      1273 004340      1275 004344      1278 004350      1279 004353      1281 004355      1282 004365
   1283 004366      1284 004371      1287 004372      1288 004376      1291 004405      1299 004406      1303 004407
   1305 004411      1308 004442      1312 004465      1313 004470      1316 004472      1317 004501      1318 004510
   1320 004536      1323 004537      1324 004545      1326 004572      1327 004573      1330 004630      1332 004655
   1334 004661      1336 004662      1345 004664      1360 004672      1363 004710      1376 004711      1378 004712
   1381 004714      1385 004720      1387 004721      1389 004726      1394 004730      1395 004732      1398 004733
   1399 004741      1402 004743      1404 004747      1406 004751      1418 004752      1421 004753      1422 004763
   1423 004765      1425 004766      1427 004774      1430 005004      1433 005006      1434 005021      1435 005022
 1   49 005023    1  104 005024    8   36 005025    1  160 005027    1  161 005031    1  162 005033    1  164 005035
 1  165 005037    1  170 005122    1  171 005124    1  177 005203    1  178 005204    1  179 005206    1  181 005207
 1  184 005212    1  185 005227    1  186 005231    1  187 005232    1  188 005233    1  191 005235    1  192 005247
 1  194 005253    1  196 005266    1  199 005270    1  202 005276    1  204 005310    1  206 005314    1  207 005316
 1  208 005320    1  209 005324    1  211 005331    1  212 005335    1  214 005337    1  215 005340    1  218 005342
 1  221 005350    1  223 005362    1  225 005366    1  226 005370    1  227 005372    1  228 005376    1  230 005403
 1  232 005410    1  234 005412    1  235 005413    1  237 005414    1  240 005425    1  243 005430    1  247 005436
 1  249 005452    1  252 005457    1  253 005461    1  254 005463    1  255 005465    1  258 005466    1  260 005472
 1  265 005503    1  266 005505    1  267 005517    1  271 005520    1  272 005524    1  273 005534    1  275 005540
 1  277 005542    1  280 005552    1  282 005556    1  287 005562    1  288 005571    1  290 005573    1  302 005575
 1  307 005615    1  309 005617    1  311 005626    1  314 005640    1  316 005643    1  317 005646    1  319 005650
 2   65 005651    2  124 005653    3   36 005660    2  222 005662    2  224 005663    2  226 005665    2  232 005752
 2  237 006053    2  242 006136    2  243 006143    2  247 006146    2  251 006203    2  254 006233    2  258 006271
 2  261 006321    2  263 006325    2  265 006326    2  267 006327    2  269 006332    2  271 006333    2  274 006334
 2  278 006337    2  282 006374    2  285 006424    2  289 006462    2  292 006512    2  294 006516    2  296 006517
 2  298 006520    2  300 006523    2  302 006524    2  305 006525    2  309 006530    2  312 006573    2  317 006621
 2  319 006625    2  321 006626    2  323 006627    2  325 006632    2  327 006633    2  329 006634    2  333 006637
 2  336 006702    2  340 006730    2  342 006734    2  344 006735    2  346 006736    2  348 006741    2  350 006742
 2  352 006743    2  354 006745    2  355 006747    2  358 006752    2  359 006760    2  360 006763    2  363 006764
 2  364 006770    2  366 006773    2  367 007017    2  368 007023    2  371 007052    2  373 007055    2  378 007107
 2  380 007110    2  382 007112    2  383 007114    2  386 007117    2  387 007125    2  388 007130    2  391 007131
 2  392 007135    2  394 007140    2  395 007164    2  396 007170    2  399 007217    2  401 007222    2  406 007254
 2  408 007255    2  410 007257    2  411 007261    2  414 007264    2  416 007274    2  418 007277    2  421 007300
 2  422 007304    2  424 007307    2  425 007332    2  426 007336    2  429 007365    2  431 007370    2  436 007422
 2  438 007423    2  440 007425    2  441 007427    2  444 007432    2  446 007442    2  448 007445    2  451 007446
 2  452 007452    2  454 007455    2  455 007500    2  456 007504    2  459 007533    2  461 007536    2  466 007570
 2  468 007571    2  472 007614    2  474 007615    2  478 007640    2  480 007641    2  482 007643    2  483 007645
 2  484 007654    2  485 007657    2  489 007701    2  494 007727    2  496 007730    2  498 007732    2  499 007734
 2  501 007744    2  504 007747    2  508 007771    2  513 010017    2  515 010020    2  519 010030    2  522 010031
 2  525 010032    2  530 010046    2  533 010047    2  534 010050    2  538 010065    2  542 010066    2  544 010067
 2  548 010077    2  551 010100    2  553 010101    2  558 010115    2  561 010116    2  562 010117    2  566 010134
 2  570 010135    2  572 010136    2  576 010141    2  579 010171    2  582 010211    2  584 010215    2  586 010216
 2  588 010217    2  590 010222    2  592 010223    2  594 010224    2  598 010227    2  601 010257    2  604 010300
 2  606 010304    2  608 010305    2  610 010306    2  612 010311    2  614 010312    2  616 010313    2  620 010336
 2  622 010337    2  626 010362    2  628 010363    2  630 010365    2  632 010367    2  634 010403    2  637 010406
 2  641 010430    2  647 010456    2  649 010457    2  651 010461    2  653 010463    2  655 010476    2  658 010501
 2  662 010524    2  668 010552    2  671 010553    2  696 010556    2  698 010557    2  700 010561    2  701 010562
 2  703 010563    2  705 010564    2  706 010566    2  708 010567    2  710 010570    2  711 010571


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
