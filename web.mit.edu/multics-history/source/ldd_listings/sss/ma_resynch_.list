	COMPILATION LISTING OF SEGMENT ma_resynch_
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/04/82  1817.8 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 ma_resynch_: proc (a_info_ptr); default (fixed&^precision&^constant) precision (21); /* DEFAULT */
       12 default (constant&real&^decimal) binary;
       13 
       14 /* This program is part of the merge_ascii/compare_ascii subsystem. */
       15 /* It is called with a pointer to a control structure which */
       16 /* describes a number of texts, and the place in each */
       17 /* at which synchronization was lost. RESYNCH_ fills in information */
       18 /* indicating where it found it possible to get back in synch. */
       19 
       20 /* Coded by RE Mullen */
       21 
       22 dcl  a_info_ptr ptr;
       23 
       24 dcl  i fixed bin;
       25 dcl  EOF bit (1) aligned init (""b);
       26 dcl  blocklen (8) fixed bin;
       27 dcl  blocklines (8) fixed bin;
       28 dcl  depth (8) fixed bin;				/* chars past cp(i) where block(i) created */
       29 dcl  xiny (8, 8) fixed bin;				/* xiny(i,j) is chars past cp(j) where block(i) found */
       30 dcl  votes (8) fixed bin;				/* est value of synch on block (i) */
       31 
       32 
       33 dcl  cp_i ptr;					/* for loops */
       34 dcl  len_i fixed bin;
       35 dcl  depth_i fixed bin;
       36 dcl  blocklen_i fixed bin;
       37 dcl  blocklines_i fixed bin;
       38 dcl  votes_i fixed bin;
       39 dcl  i_in (8) fixed bin;
       40 
       41 dcl (best, best_votes) fixed bin;
       42 dcl  n_blocks fixed bin;
       43 
       44 dcl  NL char (1) aligned int static options (constant) init ("
       45 ");
       46 dcl  ch char (999) based;
       47 dcl  skipchars (0:1) char (1) unal based;
       48 dcl  ioa_ entry options (variable);
       49 
       50 dcl  synch bit (1) aligned;
       51 
       52 /*  */
  1     1 /* BEGIN INCLUDE FILE ... merge_ascii_info.incl.pl1 ... REM Winter '77 */
  1     2 /* Modified for archive component convention THVV 1980 */
  1     3 /* Added output_iocb_ptr for cpa -output_file */
  1     4 
  1     5 dcl  ma_info_ptr ptr;
  1     6 
  1     7 /* programs modifiying variables are supplied im most comments */
  1     8 /* ma_info.control.*** modified by ma unless otherwise noted */
  1     9 /* ma_info.per_text(output).*** usually set by ma_edit_ instead */
  1    10 /* ma=merge_ascii ma_=merge_ascii_ mar_=ma_resynch_ maa_=ma_analyze_ mae_=ma_edit_ */
  1    11 
  1    12 dcl 1 ma_info aligned based (ma_info_ptr),
  1    13     2 control aligned,				/* stuff controling program action */
  1    14       3 minlines fixed bin,				/* ma: resynch block must have >= minlines */
  1    15       3 minchars fixed bin,				/* ma: resynch block must have >= minchars */
  1    16       3 lo fixed bin,				/* ma: lowest seg_index to resynch */
  1    17       3 hi fixed bin,				/* ma: highest seg_index to resynch */
  1    18       3 eof bit (1),				/* set by mar_ and ma_.skip_same for ma_ */
  1    19       3 synchlen fixed bin,				/* mar_: chars between resynch start and next diff */
  1    20       3 synchlines fixed bin,				/* mar_: lines between resynch start and next diff */
  1    21       3 have_orig bit (1),				/* "1"b if original provided */
  1    22       3 have_output bit (1),				/* ma_: "1"b if merge and have got path */
  1    23       3 have_edit bit (1),				/* if any "-edit" segs */
  1    24       3 convergence_ok bit (1) aligned,			/* "1"b => ok to pick up identical changes */
  1    25       3 brief_mode bit (1) aligned,			/* UNUSED */
  1    26       3 total_differences fixed bin,			/* ma_: number of time synch lost */
  1    27       3 total_lines_differing fixed bin,		/* ma_: summed over all diff in all texts */
  1    28       3 totals_only bit (1),				/* ma: dont print differences */
  1    29       3 print_heading bit (1),			/* ma: print heading before start */
  1    30       3 no_line_numbers bit (1),			/* ma: dont print linnos with diffs */
  1    31       3 print_new_lines bit (1),			/* ma: dont print context or old with diff */
  1    32       3 no_totals bit (1),				/* ma: dont print totals line when done */
  1    33       3 abort_label label,				/* goto abort label to bust out */
  1    34       3 op_dirname char (168),			/* info about desired output seg */
  1    35       3 op_ename char (32),
  1    36       3 op_ptr ptr,
  1    37       3 output_iocb_ptr ptr,
  1    38     2 per_text_info (8) aligned,			/* 1=output_temp, 2=orig, 3+=updates */
  1    39       3 tptr ptr,					/* ma: base of each text */
  1    40       3 tchars fixed bin,				/* ma: chars in each text */
  1    41       3 tlines fixed bin,				/* UNUSED */
  1    42       3 cp ptr,					/* ma_: ->current position, next char to process */
  1    43       3 len fixed bin,				/* ma_: chars remaining to process */
  1    44       3 line fixed bin,				/* ma_: line number cp points at */
  1    45       3 difflen fixed bin,				/* mar_: chars between synchs */
  1    46       3 difflines fixed bin,				/* mar_: lines between synchs */
  1    47       3 same_as fixed bin,				/* mar_: seg_index of lowest seg with identical diff */
  1    48       3 textid char (1) aligned,			/* ma: char to identify text in display */
  1    49       3 edit bit (1) aligned,				/* ma: not take automatically */
  1    50       3 pad_t (3) fixed bin,				/* make 16 wds for indexing speed */
  1    51     2 text_id (8) aligned,				/* names of the stff */
  1    52       3 dirname char (168),
  1    53       3 ename char (32),
  1    54       3 component char (32);
  1    55 
  1    56 dcl  ma_text_ids char (8) init ("mabcdefg")int static options (constant);
  1    57 dcl  MA_TEXT_IDS char (8) init ("MABCDEFG")int static options (constant);
  1    58 dcl  ma_max_texts fixed bin int static options (constant) init (8);
  1    59 
  1    60 /* END INCLUDE FILE ... merge_ascii_info.incl.pl1 */
       53 
       54 /*  */
       55 
       56 /* this program finds the next point at which the text are back in synch.
       57*   If no resynch point is found, we say that we are "in synch at the ends",
       58*   and set the global switch ma_info.eof.
       59*
       60*   It is the contract of this program to also set the following global variables:
       61*   ma_info.difflen(i) is set to the number of chars which differ in each text.
       62*   ma_info.difflines(i) is set to the number of lines which differ in each text.
       63*   ma_info.synchlen is set to the number of characters which are in the resynched block.
       64*   ma_info.synchlines is set to the number of lines which are in the resynched block.
       65*   ma_info.same_as(i) is set to the seg_index of the lowest numbered segment
       66*   with a difference matching that present in text(i).
       67*   If no lower numbered text has a matching difference then same_as(i) is set to zero.
       68*
       69*   Note that no variables in ma_info are set by any internal procedures.
       70*   Note that this program does not modify any variables it uses to regain synch,
       71*   it advances no pointers, it does not reduce the remaining lengths.
       72**/
       73 	ma_info_ptr = a_info_ptr;			/* copy pointer at least, to automatic */
       74 
       75 	do i = lo to hi;
       76 	     depth (i) = 0;
       77 	end;
       78 
       79 /* We start out not in synch.  Each call to try_deeper_resynch
       80*   defines a block of lines in each segment which begins one
       81*   line deeper in the remaining text.  The variable depth(i) is the number
       82*   of characters between where synch was lost and the first character of
       83*   the line starting the defined block. */
       84 	synch = ""b;
       85 	do while (^synch);
       86 	     call try_deeper_resynch;
       87 	end;
       88 
       89 /* Finally in SYNCH again.
       90*   Got in synch at blocks: substr(cp(*)->ch, xiny(best,*)+1, synchlen)
       91*   If EOF then we must setup a zero_length resynched block at the end of each text.
       92*   We then strip matching lines off the tail of the alleged differences.
       93*   Finally we determine difflines(*) and which differences match.
       94**/
       95 	ma_info.eof = EOF;
       96 
       97 /* Set synchlen, synchlines, difflen (*) */
       98 	do i = lo to hi;
       99 	     if EOF then do;			/* at synch at ends */
      100 		difflen (i) = len (i);		/* difference is entire rest */
      101 		synchlen, synchlines = 0;		/* resynch block is empty */
      102 	     end;
      103 	     else do;				/* set lenght of differences */
      104 						/* synchlen, synchlines already set correctly by check_synch */
      105 		difflen (i) = xiny (best, i);
      106 	     end;
      107 	end;
      108 
      109 	call shrink_diff;				/* strip matching chars */
      110 
      111 	do i = lo to hi;
      112 	     difflines (i) = DIFFLINES (i);
      113 	     same_as (i) = SAME_AS (i);		/* seg index of lowest matching text, or zero */
      114 	end;
      115 
      116 
      117 /*  */
      118 try_deeper_resynch: proc;
      119 
      120 dcl (i, j, k) fixed bin;
      121 
      122 
      123 	     n_blocks = 0;
      124 
      125 	     do i = lo to hi;			/* setup blocks in each text, scan others  */
      126 
      127 /* init useful vars */
      128 		cp_i = cp (i);
      129 		depth_i = depth (i);
      130 		len_i = len (i);
      131 		votes_i = 1;
      132 						/* go deeper */
      133 		k = index (substr (cp_i -> ch, depth_i+1, len_i-depth_i), NL);
      134 		if k = 0 then depth_i = len_i;
      135 		else depth_i = depth_i + k;
      136 
      137 
      138 /* setup block */
      139 		blocklen_i, blocklines_i = 0;		/* block is null so far */
      140 gb_small:
      141 		k = index (substr (cp_i -> ch, (depth_i+blocklen_i)+1, len_i- (depth_i+blocklen_i)), NL);
      142 		if k > 0 then do;			/* was able to grow by another line */
      143 		     blocklen_i = blocklen_i + k;
      144 		     blocklines_i = blocklines_i + 1;
      145 
      146 		     if blocklen_i < minchars
      147 		     | blocklines_i < minlines then go to gb_small;
      148 		     n_blocks = n_blocks + 1;		/* one more defined */
      149 		end;
      150 		else do;				/* not able to define block */
      151 		     blocklen_i, blocklines_i = 0;
      152 		     votes_i = 0;
      153 		end;
      154 
      155 
      156 
      157 /* scan other texts for block(i) */
      158 		do j = lo to hi while (votes_i ^= 0);
      159 		     if i = j then i_in (j) = depth_i;
      160 		     else do;
      161 						/* scan one */
      162 			if substr (cp (j) -> ch, 1, blocklen_i)
      163 			= substr (cp_i -> ch, depth_i+1, blocklen_i) then do;
      164 			     i_in (j) = 0;		/* found at top */
      165 			     votes_i = votes_i + 1;	/* favor inserts/deletes if tie */
      166 			end;
      167 			else do;
      168 			     i_in (j) = index (substr (cp (j) -> ch, 1, depth (j)+blocklen_i),
      169 				substr (cp_i -> ch, depth_i, blocklen_i+1));
      170 			     if i_in (j) = 0 then votes_i = 0; /* not present */
      171 			end;
      172 		     end;
      173 		end;
      174 
      175 
      176 /* scan for block (i) is done, nb. */
      177 		depth (i) = depth_i;
      178 		votes (i) = votes_i;
      179 		if votes (i) > 0 then do;		/* worth remembering? */
      180 		     blocklen (i) = blocklen_i;
      181 		     blocklines (i) = blocklines_i;
      182 		     do j = lo to hi;
      183 			xiny (i, j) = i_in (j);
      184 		     end;
      185 		end;
      186 	     end;
      187 
      188 	     if n_blocks = 0 then do;			/* at EOF in all texts */
      189 		synch = "1"b;
      190 		EOF = "1"b;
      191 		return;
      192 	     end;
      193 
      194 	     synch = ""b;				/* VALIDATE SYNCH */
      195 	     do while (^synch);
      196 		call get_best;
      197 		if best = 0 then return;
      198 		call check_synch;			/* sets synch, synchlen, synchlines */
      199 		if ^synch then votes (best) = 0;
      200 	     end;
      201 
      202 	end try_deeper_resynch;
      203 
      204 
      205 /*  */
      206 check_synch: proc;					/* IP to see if block (best) is unique in each text */
      207 
      208 dcl (i, j, k) fixed bin;
      209 dcl  lo_ptr ptr;
      210 dcl  restlen_all_same bit (1);
      211 dcl  restlen fixed bin;
      212 
      213 	     lo_ptr = addr (cp (lo) -> skipchars (xiny (best, lo)));
      214 	     synchlen = blocklen (best);		/* this many chars in synch block so far */
      215 	     synchlines = blocklines (best);
      216 
      217 	     restlen_all_same = "1"b;
      218 	     i_in (lo) = xiny (best, lo);
      219 	     restlen = -i_in (lo) - synchlen + len (lo);
      220 	     do i = lo + 1 to hi;
      221 		i_in (i) = xiny (best, i);
      222 		if restlen > len (i) - i_in (i) - synchlen then do;
      223 		     restlen = len (i) - i_in (i) - synchlen;
      224 		     restlen_all_same = ""b;
      225 		end;
      226 	     end;
      227 
      228 grow_loop:					/* first make block as big as possible */
      229 	     j = index (substr (lo_ptr -> ch, synchlen+1, restlen), NL);
      230 	     if j = 0 then do;
      231 		if restlen_all_same then j = restlen;
      232 		if j = 0 then go to grow_done;	/* was not another NL in range */
      233 	     end;
      234 	     do i = lo + 1 to hi;
      235 		if substr (lo_ptr -> ch, synchlen+1, j)
      236 		^= substr (cp (i) -> ch, i_in (i)+synchlen+1, j) then go to grow_done;
      237 	     end;
      238 	     synchlen = synchlen + j;			/* grow synched chars */
      239 	     synchlines = synchlines + 1;		/* grow synched lines */
      240 	     restlen = restlen - j;
      241 	     if restlen > 0 then go to grow_loop;
      242 
      243 grow_done:					/* here when can't grow synched block further */
      244 	     if synchlen = 0 then go to real_synch;	/* in "synch" at EOF (*) */
      245 
      246 /* now see if stuff is unique */
      247 
      248 	     do i = lo to hi;
      249 		if index (substr (cp (i) -> ch, i_in (i)+synchlen, len (i)-i_in (i)-synchlen),
      250 		substr (lo_ptr -> ch, 1, synchlen)) ^= 0 then go to pseudo_synch;
      251 	     end;
      252 
      253 real_synch:
      254 	     synch = "1"b;
      255 	     return;
      256 
      257 pseudo_synch:
      258 	     synch = ""b;
      259 	     return;
      260 
      261 	end check_synch;
      262 
      263 
      264 /*  */
      265 DIFFLINES: proc (di) returns (fixed bin);		/* IP to count lines in difflen(*) */
      266 
      267 dcl  dc fixed bin;					/* chars left in diff */
      268 dcl  dl fixed bin;					/* lines in diff counted */
      269 dcl  dj fixed bin;					/* length of one line */
      270 dcl  di fixed bin;					/* text seg in question */
      271 dcl  dp ptr;					/* ptr to rest of diff */
      272 dcl  dch char (dc) based (dp);
      273 
      274 	     dc = difflen (di);
      275 	     dp = cp (di);
      276 	     dl = 0;
      277 	     do while (dc > 0);
      278 		dj = index (dch, NL);
      279 		if dj = 0 then dj = dc;
      280 		dc = dc - dj;
      281 		dp = addr (dp -> skipchars (dj));
      282 		dl = dl + 1;
      283 	     end;
      284 	     return (dl);
      285 
      286 	end DIFFLINES;
      287 
      288 
      289 SAME_AS:	proc (si) returns (fixed bin);		/* IP to det if diff matches other diff */
      290 
      291 dcl  si fixed bin;					/* text seg in question */
      292 dcl  sas fixed bin;					/* one other diff, being compared */
      293 dcl  sap ptr;					/* ptr to diff */
      294 dcl  sac fixed bin;					/* chars in diff */
      295 dcl  sa_ch char (sac) based;				/* handy template */
      296 
      297 	     sap = cp (si);
      298 	     sac = difflen (si);
      299 	     do sas = lo to si - 1;			/* loop over segs with lower indices */
      300 		if sac = difflen (sas) then
      301 		     if sap -> sa_ch = cp (sas) -> sa_ch then
      302 			return (sas);
      303 	     end;
      304 	     return (0);				/* evid not same as any other */
      305 
      306 	end SAME_AS;
      307 
      308 /*  */
      309 get_best:	proc;					/* IP to choose among synchs */
      310 
      311 dcl  gbi fixed bin;
      312 
      313 	     best, best_votes = 0;
      314 
      315 	     do gbi = lo to hi;
      316 		if votes (gbi) > best_votes then do;
      317 		     best = gbi;
      318 		     best_votes = votes (best);
      319 		end;
      320 	     end;
      321 
      322 	end get_best;
      323 
      324 
      325 /*  */
      326 shrink_diff: proc;					/* IP to avoid "abcdef" changed to "xyzef" foolishness */
      327 dcl (shi, shj, shk) fixed bin;
      328 
      329 dcl  max_same fixed bin;
      330 dcl  chars_same fixed bin;
      331 dcl  lines_same fixed bin;
      332 
      333 	     chars_same = 0;
      334 	     lines_same = 0;
      335 	     max_same = difflen (lo);
      336 	     do shi = lo + 1 to hi;
      337 		if difflen (shi) < max_same then max_same = difflen (shi);
      338 	     end;
      339 	     if max_same = 0 then return;		/* nothing to compress */
      340 
      341 	     do while (chars_same < max_same);
      342 		shj = index (reverse (substr
      343 		     (cp (lo) -> ch, difflen (lo)-max_same+1, max_same-chars_same-1)), NL);
      344 		if shj = 0 then go to sh_done;
      345 		do shi = lo + 1 to hi;
      346 						/* compare complete lines bracketed by NL */
      347 		     if substr (cp (lo) -> ch, difflen (lo)-chars_same-shj, shj+1)
      348 		     ^= substr (cp (shi) -> ch, difflen (shi)-chars_same-shj, shj+1)
      349 		     then go to sh_done;		/* not the same */
      350 		end;
      351 		chars_same = chars_same + shj;	/* discovered more the same */
      352 		lines_same = lines_same + 1;
      353 	     end;
      354 sh_done:
      355 	     if chars_same ^= 0 then do;
      356 		do shi = lo to hi;
      357 		     difflen (shi) = difflen (shi) - chars_same;
      358 		end;
      359 		synchlen = synchlen + chars_same;
      360 		synchlines = synchlines + lines_same;
      361 	     end;
      362 
      363 	end shrink_diff;
      364 
      365      end ma_resynch_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/04/82  1627.6  ma_resynch_.pl1                   >dumps>old>recomp>ma_resynch_.pl1
53           1    09/28/82  1437.6  merge_ascii_info.incl.pl1         >ldd>include>merge_ascii_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
EOF                             000101 automatic       bit(1)                   initial dcl 25 set ref 25* 95 99 190*
NL                                     constant        char(1)                  initial dcl 44 ref 133 140 228 278 342
a_info_ptr                             parameter       pointer                  dcl 22 ref 11 73
best                            000261 automatic       fixed bin(21,0)          dcl 41 set ref 105 197 199 213 214 215 218 221 313*
                                                                                  317* 318
best_votes                      000262 automatic       fixed bin(21,0)          dcl 41 set ref 313* 316 318*
blocklen                        000102 automatic       fixed bin(21,0)          array dcl 26 set ref 180* 214
blocklen_i                      000246 automatic       fixed bin(21,0)          dcl 36 set ref 139* 140 140 143* 143 146 151* 162
                                                                                  162 168 168 180
blocklines                      000112 automatic       fixed bin(21,0)          array dcl 27 set ref 181* 215
blocklines_i                    000247 automatic       fixed bin(21,0)          dcl 37 set ref 139* 144* 144 146 151* 181
ch                                     based           char(999)                unaligned dcl 46 ref 133 140 162 162 168 168 228 235
                                                                                  235 249 249 342 347 347
chars_same                      000401 automatic       fixed bin(21,0)          dcl 330 set ref 333* 341 342 347 347 351* 351 354
                                                                                  357 359
control                                based           structure                level 2 dcl 1-12
cp                      122            based           pointer                  array level 3 dcl 1-12 ref 128 162 168 213 235 249
                                                                                  275 297 300 342 347 347
cp_i                            000242 automatic       pointer                  dcl 33 set ref 128* 133 140 162 168
dc                              000336 automatic       fixed bin(21,0)          dcl 267 set ref 274* 277 278 279 280* 280
dch                                    based           char                     unaligned dcl 272 ref 278
depth                           000122 automatic       fixed bin(21,0)          array dcl 28 set ref 76* 129 168 177*
depth_i                         000245 automatic       fixed bin(21,0)          dcl 35 set ref 129* 133 133 134* 135* 135 140 140
                                                                                  159 162 168 177
di                                     parameter       fixed bin(21,0)          dcl 270 ref 265 274 275
difflen                 126            based           fixed bin(21,0)          array level 3 dcl 1-12 set ref 100* 105* 274 298 300
                                                                                  335 337 337 342 347 347 357* 357
difflines               127            based           fixed bin(21,0)          array level 3 dcl 1-12 set ref 112*
dj                              000340 automatic       fixed bin(21,0)          dcl 269 set ref 278* 279 279* 280 281
dl                              000337 automatic       fixed bin(21,0)          dcl 268 set ref 276* 282* 282 284
dp                              000342 automatic       pointer                  dcl 271 set ref 275* 278 281* 281
eof                       4            based           bit(1)                   level 3 dcl 1-12 set ref 95*
gbi                             000366 automatic       fixed bin(21,0)          dcl 311 set ref 315* 316 317*
hi                        3            based           fixed bin(21,0)          level 3 dcl 1-12 ref 75 98 111 125 158 182 220 234
                                                                                  248 315 336 345 356
i                               000316 automatic       fixed bin(21,0)          dcl 208 in procedure "check_synch" set ref 220* 221
                                                                                  221 222 222 223 223* 234* 235 235* 248* 249 249
                                                                                  249 249*
i                               000100 automatic       fixed bin(21,0)          dcl 24 in procedure "ma_resynch_" set ref 75* 76*
                                                                                  98* 100 100 105 105* 111* 112 112* 113 113*
i                               000302 automatic       fixed bin(21,0)          dcl 120 in procedure "try_deeper_resynch" set ref
                                                                                  125* 128 129 130 159 177 178 179 180 181 183*
i_in                            000251 automatic       fixed bin(21,0)          array dcl 39 set ref 159* 164* 168* 170 183 218* 219
                                                                                  221* 222 223 235 249 249
j                               000317 automatic       fixed bin(21,0)          dcl 208 in procedure "check_synch" set ref 228* 230
                                                                                  231* 232 235 235 238 240
j                               000303 automatic       fixed bin(21,0)          dcl 120 in procedure "try_deeper_resynch" set ref
                                                                                  158* 159 159 162 164 168 168 168 170* 182* 183
                                                                                  183*
k                               000304 automatic       fixed bin(21,0)          dcl 120 set ref 133* 134 135 140* 142 143
len                     124            based           fixed bin(21,0)          array level 3 dcl 1-12 ref 100 130 219 222 223 249
len_i                           000244 automatic       fixed bin(21,0)          dcl 34 set ref 130* 133 134 140
lines_same                      000402 automatic       fixed bin(21,0)          dcl 331 set ref 334* 352* 352 360
lo                        2            based           fixed bin(21,0)          level 3 dcl 1-12 ref 75 98 111 125 158 182 213 213
                                                                                  218 218 219 219 220 234 248 299 315 335 336 342
                                                                                  342 345 347 347 356
lo_ptr                          000320 automatic       pointer                  dcl 209 set ref 213* 228 235 249
ma_info                                based           structure                level 1 dcl 1-12
ma_info_ptr                     000266 automatic       pointer                  dcl 1-5 set ref 73* 75 75 95 98 98 100 100 101 101
                                                                                  105 111 111 112 113 125 125 128 130 146 146 158
                                                                                  158 162 168 182 182 213 213 213 214 215 218 218
                                                                                  219 219 219 219 220 220 222 222 223 223 228 234
                                                                                  234 235 235 235 238 238 239 239 243 248 248 249
                                                                                  249 249 249 249 274 275 297 298 299 300 300 315
                                                                                  315 335 335 336 336 337 337 342 342 342 342 345
                                                                                  345 347 347 347 347 347 347 356 356 357 357 359
                                                                                  359 360 360
max_same                        000400 automatic       fixed bin(21,0)          dcl 329 set ref 335* 337 337* 339 341 342 342
minchars                  1            based           fixed bin(21,0)          level 3 dcl 1-12 ref 146
minlines                               based           fixed bin(21,0)          level 3 dcl 1-12 ref 146
n_blocks                        000263 automatic       fixed bin(21,0)          dcl 42 set ref 123* 148* 148 188
per_text_info           116            based           structure                array level 2 dcl 1-12
restlen                         000323 automatic       fixed bin(21,0)          dcl 211 set ref 219* 222 223* 228 231 240* 240 241
restlen_all_same                000322 automatic       bit(1)                   unaligned dcl 210 set ref 217* 224* 231
sa_ch                                  based           char                     unaligned dcl 295 ref 300 300
sac                             000356 automatic       fixed bin(21,0)          dcl 294 set ref 298* 300 300 300
same_as                 130            based           fixed bin(21,0)          array level 3 dcl 1-12 set ref 113*
sap                             000354 automatic       pointer                  dcl 293 set ref 297* 300
sas                             000352 automatic       fixed bin(21,0)          dcl 292 set ref 299* 300 300 300*
shi                             000376 automatic       fixed bin(21,0)          dcl 327 set ref 336* 337 337* 345* 347 347* 356* 357
                                                                                  357*
shj                             000377 automatic       fixed bin(21,0)          dcl 327 set ref 342* 344 347 347 347 347 351
si                                     parameter       fixed bin(21,0)          dcl 291 ref 289 297 298 299
skipchars                              based           char(1)                  array unaligned dcl 47 set ref 213 281
synch                           000264 automatic       bit(1)                   dcl 50 set ref 84* 85 189* 194* 195 199 253* 257*
synchlen                  5            based           fixed bin(21,0)          level 3 dcl 1-12 set ref 101* 214* 219 222 223 228
                                                                                  235 235 238* 238 243 249 249 249 359* 359
synchlines                6            based           fixed bin(21,0)          level 3 dcl 1-12 set ref 101* 215* 239* 239 360* 360
votes                           000232 automatic       fixed bin(21,0)          array dcl 30 set ref 178* 179 199* 316 318
votes_i                         000250 automatic       fixed bin(21,0)          dcl 38 set ref 131* 152* 158 165* 165 170* 178
xiny                            000132 automatic       fixed bin(21,0)          array dcl 29 set ref 105 183* 213 218 221

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
MA_TEXT_IDS                            internal static char(8)                  initial unaligned dcl 1-57
ioa_                            000000 constant        entry                    external dcl 48
k                                      automatic       fixed bin(21,0)          dcl 208
ma_max_texts                           internal static fixed bin(21,0)          initial dcl 1-58
ma_text_ids                            internal static char(8)                  initial unaligned dcl 1-56
shk                                    automatic       fixed bin(21,0)          dcl 327

NAMES DECLARED BY EXPLICIT CONTEXT.
DIFFLINES                       000644 constant        entry                    internal dcl 265 ref 112
SAME_AS                         000712 constant        entry                    internal dcl 289 ref 113
check_synch                     000412 constant        entry                    internal dcl 206 ref 198
gb_small                        000207 constant        label                    dcl 140 ref 146
get_best                        000762 constant        entry                    internal dcl 309 ref 196
grow_done                       000576 constant        label                    dcl 243 ref 232 235
grow_loop                       000510 constant        label                    dcl 228 ref 241
ma_resynch_                     000005 constant        entry                    external dcl 11
pseudo_synch                    000642 constant        label                    dcl 257 ref 249
real_synch                      000637 constant        label                    dcl 253 ref 243
sh_done                         001141 constant        label                    dcl 354 ref 344 347
shrink_diff                     001007 constant        entry                    internal dcl 326 ref 109
try_deeper_resynch              000135 constant        entry                    internal dcl 118 ref 86

NAMES DECLARED BY CONTEXT OR IMPLICATION.
addr                                                   builtin function         ref 213 281
index                                                  builtin function         ref 133 140 168 228 249 278 342
reverse                                                builtin function         ref 342
substr                                                 builtin function         ref 133 140 162 162 168 168 228 235 235 249 249 342
                                                                                  347 347

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1214        1224    1170        1224
Length      1402    1170        10         141      24           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ma_resynch_                         283 external procedure  is an external procedure.  
try_deeper_resynch                      internal procedure  shares stack frame of external procedure ma_resynch_.  
check_synch                             internal procedure  shares stack frame of external procedure ma_resynch_.  
DIFFLINES                               internal procedure  shares stack frame of external procedure ma_resynch_.  
SAME_AS                                 internal procedure  shares stack frame of external procedure ma_resynch_.  
get_best                                internal procedure  shares stack frame of external procedure ma_resynch_.  
shrink_diff                             internal procedure  shares stack frame of external procedure ma_resynch_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
ma_resynch_              000100 i                           ma_resynch_
                         000101 EOF                         ma_resynch_
                         000102 blocklen                    ma_resynch_
                         000112 blocklines                  ma_resynch_
                         000122 depth                       ma_resynch_
                         000132 xiny                        ma_resynch_
                         000232 votes                       ma_resynch_
                         000242 cp_i                        ma_resynch_
                         000244 len_i                       ma_resynch_
                         000245 depth_i                     ma_resynch_
                         000246 blocklen_i                  ma_resynch_
                         000247 blocklines_i                ma_resynch_
                         000250 votes_i                     ma_resynch_
                         000251 i_in                        ma_resynch_
                         000261 best                        ma_resynch_
                         000262 best_votes                  ma_resynch_
                         000263 n_blocks                    ma_resynch_
                         000264 synch                       ma_resynch_
                         000266 ma_info_ptr                 ma_resynch_
                         000302 i                           try_deeper_resynch
                         000303 j                           try_deeper_resynch
                         000304 k                           try_deeper_resynch
                         000316 i                           check_synch
                         000317 j                           check_synch
                         000320 lo_ptr                      check_synch
                         000322 restlen_all_same            check_synch
                         000323 restlen                     check_synch
                         000336 dc                          DIFFLINES
                         000337 dl                          DIFFLINES
                         000340 dj                          DIFFLINES
                         000342 dp                          DIFFLINES
                         000352 sas                         SAME_AS
                         000354 sap                         SAME_AS
                         000356 sac                         SAME_AS
                         000366 gbi                         get_best
                         000376 shi                         shrink_diff
                         000377 shj                         shrink_diff
                         000400 max_same                    shrink_diff
                         000401 chars_same                  shrink_diff
                         000402 lines_same                  shrink_diff

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
return              ext_entry           set_cs_eis          index_cs_eis

NO EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000002        25 000012        73 000013        75 000017        76 000026        77 000027        84 000031
     85 000032        86 000034        87 000035        95 000036        98 000041        99 000050       100 000052
    101 000057       102 000061       105 000062       107 000072       109 000074       111 000075       112 000105
    113 000120       114 000132       365 000134       118 000135       123 000136       125 000137       128 000147
    129 000153       130 000157       131 000162       133 000164       134 000200       135 000204       139 000205
    140 000207       142 000227       143 000230       144 000231       146 000232       148 000241       149 000242
    151 000243       152 000245       158 000246       159 000260       162 000267       164 000303       165 000305
    166 000306       168 000307       170 000325       173 000327       177 000331       178 000334       179 000336
    180 000337       181 000341       182 000343       183 000353       184 000362       186 000364       188 000366
    189 000370       190 000372       191 000373       194 000374       195 000375       196 000377       197 000400
    198 000403       199 000404       200 000410       202 000411       206 000412       213 000413       214 000430
    215 000433       217 000435       218 000437       219 000444       220 000453       221 000463       222 000471
    223 000502       224 000505       226 000506       228 000510       230 000525       231 000526       232 000532
    234 000534       235 000544       237 000564       238 000566       239 000571       240 000572       241 000574
    243 000576       248 000600       249 000607       251 000635       253 000637       255 000641       257 000642
    259 000643       265 000644       274 000646       275 000654       276 000656       277 000657       278 000661
    279 000673       280 000676       281 000700       282 000704       283 000705       284 000706       289 000712
    297 000714       298 000721       299 000724       300 000734       303 000755       304 000757       309 000762
    313 000763       315 000765       316 000775       317 001000       318 001002       320 001004       322 001006
    326 001007       333 001010       334 001011       335 001012       336 001017       337 001027       338 001036
    339 001040       341 001043       342 001046       344 001072       345 001073       347 001104       350 001133
    351 001135       352 001137       353 001140       354 001141       356 001143       357 001153       358 001160
    359 001162       360 001165       363 001167


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
