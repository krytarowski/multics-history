	COMPILATION LISTING OF SEGMENT display_mrds_db_access
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/01/88  1332.2 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 display_mrds_db_access: dmdba: dmda: procedure ();
       10 
       11 /* DESCRIPTION:
       12*
       13*   This command will display the Multics acls, MRDS access, and  the
       14*   effective result of these two access controls, on both a relation
       15*   and attribute basis for a given view of a  database  provided  by
       16*   either a model or submodel opening of it. It accepts the pathname
       17*   that would be used in that opening. Any order  can  be  used  for
       18*   path  and  control  arguments,  with  the control arguments being
       19*   over-ridable, the last  one  taking  effect.  However,  the  path
       20*   argument  must  precede the -relation option. If the database has
       21*   been secured, then mrds/effective access use  the  r-a-m-d  modes
       22*   for  display, otherwise version 4 databases use the r-e-w multics
       23*   acls for display. If relation names exceed 50, or attribute names
       24*   exceed  40  characters,  the  display  will truncate them at that
       25*   length.
       26*
       27**/
       28 
       29 /* PARAMETERS:
       30*
       31*   path - - (input) char(*), the relative or absolute pathname of  a
       32*   database  model  or submodel, whose view is to be used, and whose
       33*   access controls are to be employed in determing the access to  be
       34*   displayed.  The  user  must  have the access to actually open the
       35*   referenced database in  order  to  obtain  view  information  and
       36*   access  modes.  Only  one  pathname may be given, and must appear
       37*   before any -relation option.
       38*
       39*   ===========
       40*
       41*   optional control arguments:
       42*
       43*   -brief, specifies the short form  of  the  display  This  may  be
       44*   overiden with a subsequent -long.
       45*
       46*   -long, specifies the verbose form of the  display  this  includes
       47*   multics and mrds access in addition to effective access. This can
       48*   be overiden with a subsequent -brief. The -long  control  is  the
       49*   default.
       50*
       51*   -relation rel_name1 ...  rel_nameN  specifies  that  only  listed
       52*   relations  acl's  be  displayed This argument must come after the
       53*   pathname. If two -relation controls are given, the  last  one  is
       54*   used. The default is to display all relations in the given view.
       55*
       56**/
       57 
       58 /* HISTORY:
       59*
       60*   81-04-06 Jim Gray : originally coded
       61*
       62*   81-07-16 Jim Gray : added add name dmdba
       63*
       64*   83-01-18  Roger Lackey : added mrds_error_$no_model_submodel to handle
       65*   the case where mrds_dsl_get_version$get_path_info
       66*   returns mrds_error_$no_database.  Also declared undeclared variables.
       67*
       68*
       69**/
       70 
       71 	if recursive_call then do;			/* we can't allow recursion because of dsl_$open */
       72 		error_code = mrds_error_$no_recursion;
       73 		call com_err_ (error_code, caller_name, "^/^a",
       74 		     "A release or a start must be done before continuing.");
       75 	     end;
       76 	else do;
       77 
       78 /* initialize */
       79 
       80 		error_code = 0;
       81 		db_index = 0;
       82 		area_ptr = null ();
       83 		long_format = "1"b;			/* default to -long option */
       84 		all_relations = "1"b;		/* default to showing all relations in the view */
       85 		path_seen = "0"b;
       86 		call cu_$af_arg_count (nargs, error_code); /* make sure we weren't called as an active function */
       87 		if error_code ^= error_table_$not_act_fnc then
       88 		     call com_err_ (error_code, caller_name, "^/^a",
       89 			"Command called as an active function, or unable to obtain argument count.");
       90 		else do;
       91 
       92 			error_code = 0;
       93 			on cleanup call clean_up ();
       94 			recursive_call = "1"b;	/* prevent recursion */
       95 
       96 /* check for a good call */
       97 
       98 			if nargs < 1 then do;
       99 				error_code = error_table_$wrong_no_of_args;
      100 				call com_err_ (error_code, caller_name, "^/^a",
      101 				     "Usage:  dmdba  path  {-brief|-long} {-relation rel_name1 ... rel_nameN}");
      102 			     end;
      103 			else do;
      104 
      105 /* get some work space */
      106 
      107 				call get_temp_segment_ (caller_name, area_ptr, error_code);
      108 				if error_code ^= 0 then
      109 				     call com_err_ (error_code, caller_name, "^/^a",
      110 					"Unable to get a temp segment.");
      111 				else do;
      112 
      113 					area_ptr -> work_area = empty ();
      114 
      115 /* gather all the arguments */
      116 
      117 					arg_count = 1;
      118 					args_finished = "0"b;
      119 					do while (^args_finished);
      120 
      121 /* get this argument, and decide if it is a control argument or not */
      122 
      123 					     call cu_$arg_ptr (arg_count, arg_ptr, arg_len, error_code);
      124 					     if error_code ^= 0 then do;
      125 						     args_finished = "1"b;
      126 						     call com_err_ (error_code, caller_name, "^/^a ^d",
      127 							"Unable to get argument number", arg_count);
      128 						end;
      129 					     else do;
      130 
      131 /* check for a null argument */
      132 
      133 						     if arg_len < 1 then do;
      134 							     args_finished = "1"b;
      135 							     error_code = error_table_$bad_arg;
      136 							     call com_err_ (error_code, caller_name, "^/^a ^d",
      137 								"A null character string was detected for argument number", arg_count);
      138 							end;
      139 						     else do;
      140 
      141 /* control arguments begin with a hyphen */
      142 
      143 							     if substr (arg, 1, 1) = "-" then
      144 								call process_control_arg ();
      145 							     else call process_path_arg ();
      146 
      147 							end;
      148 
      149 /* advance to the next argument */
      150 
      151 						     if arg_count < nargs then
      152 							arg_count = arg_count + 1;
      153 						     else args_finished = "1"b;
      154 
      155 						end;
      156 
      157 					end;
      158 
      159 /* check that we got a  pathname argument */
      160 
      161 					if error_code = 0 then do;
      162 
      163 						if ^path_seen then do;
      164 							error_code = error_table_$noarg;
      165 							call com_err_ (error_code, caller_name, "^/^a",
      166 							     "No pathname argument was given.");
      167 						     end;
      168 
      169 /* go display the requested access */
      170 
      171 						else call display_access ();
      172 
      173 					     end;
      174 				     end;
      175 
      176 			     end;
      177 
      178 
      179 /* clean up after finishing */
      180 
      181 			call clean_up ();
      182 
      183 		     end;
      184 
      185 	     end;
      186 
      187 	return;
      188 
      189 process_control_arg: procedure ();
      190 
      191 /* routine to determine if user has given one of the legal
      192*   control arguments of brief, long, or relation REL_NAME
      193*   and to save the corresponding information.
      194*   The logic is such as to allow duplicate control arguments
      195*   to override each other, with the last given taking effect. */
      196 
      197 /* BRIEF */
      198 
      199 	if arg = "-brief" | arg = "-bf" then do;
      200 		long_format = "0"b;			/* use short display format */
      201 	     end;
      202 
      203 /* LONG */
      204 
      205 	else if arg = "-long" | arg = "-lg" then do;
      206 		long_format = "1"b;			/* use verbose display format */
      207 	     end;
      208 
      209 /* UNKNOWN */
      210 
      211 	else if arg ^= "-relation" then do;
      212 		args_finished = "1"b;
      213 		error_code = error_table_$badopt;
      214 		call com_err_ (error_code, caller_name, "^/^a^a^a",
      215 		     "The control argument """, arg, """ is not supported by this command.");
      216 	     end;
      217 
      218 /* BAD ORDER */
      219 
      220 	else if ^path_seen then do;
      221 		args_finished = "1"b;
      222 		error_code = error_table_$noarg;
      223 		call com_err_ (error_code, caller_name, "^/^a",
      224 		     "The pathname argument did not appear before the ""-relation"" option.");
      225 	     end;
      226 	else do;
      227 
      228 /* RELATION LIST */
      229 
      230 		last_relation_seen = "0"b;
      231 		some_relation_seen = "0"b;
      232 		all_relations = "0"b;		/* only do the given relations */
      233 		last_relation_ptr, relation_list_ptr = null ();
      234 		arg_count = arg_count + 1;
      235 		relation_list_length = 0;
      236 
      237 /* go through all relation names given */
      238 
      239 		do while (^last_relation_seen);
      240 
      241 		     call cu_$arg_ptr (arg_count, arg_ptr, arg_len, error_code);
      242 		     if error_code ^= 0 then do;
      243 			     args_finished, last_relation_seen = "1"b;
      244 			     call com_err_ (error_code, caller_name, "^/^a ^d",
      245 				"Unable to get the relation name in argument", arg_count);
      246 			end;
      247 		     else if arg_len < 1 then do;
      248 			     args_finished, last_relation_seen = "1"b;
      249 			     error_code = error_table_$bad_arg;
      250 			     call com_err_ (error_code, caller_name, "^/^a ^d",
      251 				"A null character string was detected for agument number", arg_count);
      252 			end;
      253 		     else if substr (arg, 1, 1) = "-" then do;
      254 			     last_relation_seen = "1"b; /* end of list of relation names */
      255 			     arg_count = arg_count - 1; /* reset for processining remaining args */
      256 			end;
      257 		     else do;
      258 
      259 /* first relation name seen */
      260 
      261 			     some_relation_seen = "1"b;
      262 
      263 /* gather this name for the list */
      264 
      265 			     relation_name_length_init = arg_len;
      266 			     allocate relation set (relation_ptr) in (work_area);
      267 			     relation.name_length = relation_name_length_init;
      268 			     relation.name = arg;	/* remember this relation's name */
      269 
      270 /* add the name at the end of the list to maintain order */
      271 
      272 			     relation.next = null ();
      273 			     if last_relation_ptr = null () then
      274 				relation_list_ptr = relation_ptr;
      275 			     else last_relation_ptr -> relation.next = relation_ptr;
      276 			     last_relation_ptr = relation_ptr;
      277 			     relation_list_length = relation_list_length + 1;
      278 
      279 /* advance to the next name given */
      280 
      281 			     if arg_count < nargs then
      282 				arg_count = arg_count + 1;
      283 			     else last_relation_seen = "1"b;
      284 
      285 			end;
      286 
      287 		end;
      288 
      289 /* check that at least one name was given */
      290 
      291 		if ^some_relation_seen & error_code = 0 then do;
      292 			args_finished = "1"b;
      293 			error_code = error_table_$noarg;
      294 			call com_err_ (error_code, caller_name, "^/^a",
      295 			     "No relation name(s) given with the ""-relation"" control argument.");
      296 		     end;
      297 
      298 	     end;
      299 
      300      end;
      301 
      302 process_path_arg: procedure ();
      303 
      304 /* routine to verify the database model path or submodel path
      305*   argument, that supplies the view for access information.
      306*   Only one path argument is allowed */
      307 
      308 	if path_seen then do;
      309 
      310 /* duplicate path name arguments given */
      311 
      312 		args_finished = "1"b;
      313 		error_code = mrds_error_$duplicate_opt;
      314 		call com_err_ (error_code, caller_name, "^/^a ^a",
      315 		     "The pathname argument was given more than once:", arg);
      316 	     end;
      317 	else do;
      318 
      319 /* first pathname seen */
      320 
      321 		path_seen = "1"b;
      322 
      323 /* check for a valid path to a model or submodel */
      324 
      325 		call mrds_dsl_get_version$get_path_info (arg, area_ptr,
      326 		     mrds_path_info_structure_version, mrds_path_info_ptr, error_code);
      327 		if mrds_path_info_ptr = null () then
      328 		     abs_path = arg;
      329 		else abs_path = mrds_path_info.absolute_path;
      330 		if error_code ^= 0 then do;
      331 			if error_code = mrds_error_$no_database then
      332 			     error_code = mrds_error_$no_model_submodel;
      333 
      334 			args_finished = "1"b;
      335 			call com_err_ (error_code, caller_name, "^/^a^a^a",
      336 			     "Unable to find database information using the path """, abs_path, """.");
      337 		     end;
      338 
      339 /* check for a supported version model/submodel,
      340*   old version database will not work unless they had been
      341*   opened for exclusive update at least one,
      342*   and if there are any other old version databases already open. */
      343 
      344 		else if (mrds_path_info.type.model | mrds_path_info.type.submodel) &
      345 			mrds_path_info.mrds_version < 4 then do;
      346 			args_finished = "1"b;
      347 			error_code = mrds_error_$version_not_supported;
      348 			call com_err_ (error_code, caller_name, "^/^a^a^a",
      349 			     "The path """, abs_path,
      350 			     """ is to a database or submodel of version less than 4.");
      351 		     end;
      352 		else do;
      353 
      354 /* good path, use it to get an opening index */
      355 
      356 			call mrds_dsl_open (abs_path, db_index, retrieval_mode, error_code);
      357 			if error_code ^= 0 then do;
      358 				args_finished = "1"b;
      359 				call com_err_ (error_code, caller_name, "^/^a^a^a",
      360 				     "The database could not be opened to obtain view information using the path """,
      361 				     abs_path, """.");
      362 			     end;
      363 			else do;
      364 
      365 /*  get resultant model pointers */
      366 
      367 				call mu_database_index$get_resultant_model_pointer (db_index, dbcb_ptr);
      368 				if dbcb_ptr = null () then do;
      369 					args_finished = "1"b;
      370 					error_code = mrds_error_$invalid_db_index; /* logic error if this happens */
      371 					call com_err_ (error_code, caller_name, "^/^a",
      372 					     "Program LOGIC ERROR, database opening index gave null resultant model pointer.");
      373 				     end;
      374 				else do;
      375 
      376 					rdbi_ptr = dbcb.rdbi_ptr;
      377 				     end;
      378 
      379 			     end;
      380 
      381 		     end;
      382 	     end;
      383 
      384      end;
      385 
      386 display_access: procedure ();
      387 
      388 /* routine to display the relation and attribute
      389*   access details for the given view supplied by the caller
      390*   first, get the access info for all relations in this view */
      391 
      392 	call mrds_dsl_get_relation_list (db_index, area_ptr,
      393 	     mrds_relation_list_structure_version, mrds_relation_list_ptr, error_code);
      394 	if error_code ^= 0 then
      395 	     call com_err_ (error_code, caller_name, "^/^a^a^a",
      396 		"Unable to get the relation information using the path """, abs_path, """.");
      397 	else do;
      398 
      399 /* output details for the verbose format */
      400 
      401 		if long_format then do;
      402 			call ioa_ ("^/Database path:  ^a^/^6xversion:  ^d",
      403 			     rm_db_info.db_path, rm_db_info.db_version);
      404 			if rm_db_info.mdbm_secured then
      405 			     call ioa_ ("^16xDatabase is in a secure state.");
      406 			if dbcb.dsm_sw then
      407 			     call ioa_ ("^/Submodel path:  ^a^/^6xversion:  ^d",
      408 				rm_db_info.sm_path, rm_db_info.sm_version);
      409 			call ioa_ ("^/Relation  Attribute^4-System^-MRDS^-Effective"); /* output header */
      410 		     end;
      411 
      412 /* gather attribute access information for each relation
      413*   in the path provided view specified by the user,
      414*   or only the subset in his relation list */
      415 
      416 		if all_relations then
      417 		     relation_count = mrds_relation_list.num_rels_in_view;
      418 		else relation_count = relation_list_length;
      419 
      420 		do i = 1 to relation_count while (error_code = 0);
      421 
      422 		     if all_relations then do;
      423 			     j = i;		/* use definition order */
      424 			     found = "1"b;
      425 			end;
      426 		     else do;
      427 
      428 /* make sure we have a good relation name from the user's -relation option
      429*   by finding the relation name in the rmds_relation_list array */
      430 
      431 			     if i = 1 then
      432 				relation_ptr = relation_list_ptr;
      433 			     else relation_ptr = relation.next;
      434 
      435 			     found = "0"b;
      436 			     done = "0"b;
      437 			     j = 1;
      438 			     do while (^done);	/* find the value of j to use */
      439 
      440 				if relation.name = mrds_relation_list.relation (j).submodel_name then
      441 				     done, found = "1"b;
      442 				else if j < mrds_relation_list.num_rels_in_view then
      443 				     j = j + 1;
      444 				else done = "1"b;
      445 			     end;
      446 
      447 			     if ^found then
      448 				call ioa_ ("^/^a^a^a", /* non-fatal error, keep going */
      449 				     "The relation name """, relation.name,
      450 				     """ is unknown in this view of the database.");
      451 			end;
      452 
      453 		     if found then do;
      454 
      455 /* get the attribute access info for this relation */
      456 
      457 			     call mrds_dsl_get_attribute_list (db_index,
      458 				rtrim (mrds_relation_list.relation (j).submodel_name),
      459 				area_ptr, mrds_attribute_list_structure_version, mrds_attribute_list_ptr, error_code);
      460 			     if error_code ^= 0 then
      461 				call com_err_ (error_code, caller_name, "^/^a^a^a",
      462 				     "Unable to obtain the attribute access information for relation """,
      463 				     mrds_relation_list.relation (j).submodel_name, """.");
      464 			     else do;
      465 
      466 /* good relation and attribute access info obtained,
      467*   now we can display it according to the long/brief options
      468*   NOTE: relation names longer than 50, and attribute
      469*   names longer than 40 characters are truncated to that length
      470*   This is done to get all info on one "screen" width, for the more common shorter names.
      471*   first, output the relation access */
      472 
      473 				     if long_format then
      474 					call ioa_ ("^/^50a^1x^2a^-^1x^2a^-^2x^2a",
      475 					     mrds_relation_list.relation (j).submodel_name, /* output rel name and it's access */
      476 					     mrds_relation_list.relation (j).system_acl,
      477 					     mrds_relation_list.relation (j).mrds_access,
      478 					     mrds_relation_list.relation (j).effective_access);
      479 				     else call ioa_ ("^/^50a^1x^2a",
      480 					     mrds_relation_list.relation (j).submodel_name,
      481 					     mrds_relation_list.relation (j).effective_access);
      482 
      483 /* display all attributes for this relation */
      484 
      485 				     do k = 1 to mrds_attribute_list.num_attrs_in_view;
      486 
      487 					if long_format then
      488 					     call ioa_ ("^-^40a^1x^2a^-^1x^2a^-^2x^2a",
      489 						mrds_attribute_list.attribute (k).submodel_name,
      490 						mrds_attribute_list.attribute (k).system_acl,
      491 						mrds_attribute_list.attribute (k).mrds_access,
      492 						mrds_attribute_list.attribute (k).effective_access);
      493 					else call ioa_ ("^-^40a^1x^2a", mrds_attribute_list.attribute (k).submodel_name,
      494 						mrds_attribute_list.attribute (k).effective_access);
      495 				     end;
      496 				end;
      497 			end;
      498 		end;
      499 	     end;
      500      end;
      501 
      502 clean_up: procedure ();
      503 
      504 /* routine to clean up after a quit-release or an error */
      505 
      506 	if area_ptr ^= null () then do;
      507 		call release_temp_segment_ (caller_name, area_ptr, discard);
      508 		area_ptr = null ();
      509 	     end;
      510 
      511 	if db_index ^= 0 then do;
      512 		call mrds_dsl_close (db_index, discard);
      513 		db_index = 0;
      514 	     end;
      515 
      516 	recursive_call = "0"b;
      517 
      518      end;
      519 
      520 	declare abs_path		 char (200);	/* absolute pathname of model or submodel */
      521 	declare all_relations	 bit (1);		/* on => do all rels in view */
      522 	declare area_ptr		 ptr;		/* points to work space */
      523 	declare arg		 char (arg_len) based (arg_ptr); /* input argument */
      524 	declare arg_count		 fixed bin;	/* current arg under inspection */
      525 	declare arg_len		 fixed bin (21);	/* lengh of input arg */
      526 	declare arg_ptr		 ptr;		/* points to input argument */
      527 	declare args_finished	 bit (1);		/* on => all args seen, or error */
      528 	declare caller_name		 char (32) init ("display_mrds_db_access") int static options (constant); /* name of calling routine */
      529 	declare cleanup		 condition;	/* signaled upon quit/release */
      530 	declare com_err_		 entry options (variable); /* reports errors */
      531 	declare cu_$af_arg_count	 entry (fixed bin, fixed bin (35)); /* gets arg count/call type */
      532 	declare cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin (21), fixed bin (35)); /* gets Nth arg */
      533 	declare db_index		 fixed bin (35);	/* database opening index */
      534 	declare discard		 fixed bin (35);	/* ignored error code */
      535 	declare done		 bit (1);		/* loop control for relation name search */
      536 	declare mrds_dsl_close	 entry options (variable); /* closes databases */
      537 	declare mrds_dsl_open	 entry options (variable); /* opens a database through model or submodel */
      538 	declare error_code		 fixed bin (35);	/* error status encoding */
      539 	declare error_table_$bad_arg	 fixed bin (35) ext;/* null input arg */
      540 	declare error_table_$badopt	 fixed bin (35) ext;/* unknown control arg */
      541 	declare error_table_$noarg	 fixed bin (35) ext;/* missing argument */
      542 	declare error_table_$not_act_fnc fixed bin (35) ext; /* should get this normally */
      543 	declare error_table_$wrong_no_of_args fixed bin (35) ext; /* not minimum of 1 arg */
      544 	declare found		 bit (1);		/* on => known relation name supplied, and it's index found */
      545 	declare get_temp_segment_	 entry (char (*), ptr, fixed bin (35)); /* gets temp segs */
      546 	declare i			 fixed bin;	/* current count of relations displayed */
      547 	declare ioa_		 entry options (variable); /* does output display */
      548 	declare j			 fixed bin;	/* index into the relation_list structure */
      549 	declare k			 fixed bin;	/* index into the attribute_list structure */
      550 	declare last_relation_ptr	 ptr;		/* points to last relation in list */
      551 	declare last_relation_seen	 bit (1);		/* on => exit relation name loop */
      552 	declare long_format		 bit (1);		/* on => display all access info */
      553 	declare mu_database_index$get_resultant_model_pointer entry (fixed bin (35), ptr); /* gets r-model ptr from index */
      554 	declare mrds_dsl_get_attribute_list entry (fixed bin (35), char (*),
      555 				 ptr, fixed bin, ptr, fixed bin (35)); /* gets attrs in view of rel */
      556 	declare mrds_dsl_get_relation_list entry (fixed bin (35), ptr, fixed bin, ptr, fixed bin (35)); /* gets rels in view */
      557 	declare mrds_dsl_get_version$get_path_info entry (char (*), ptr, fixed bin, ptr, fixed bin (35));
      558 	declare mrds_error_$duplicate_opt fixed bin (35) ext; /* path arg given > 1 time */
      559 	declare mrds_error_$invalid_db_index fixed bin (35) ext; /* caused by logic error */
      560 	declare mrds_error_$no_database fixed bin (35) ext static;
      561 	dcl     mrds_error_$no_model_submodel fixed bin (35) ext static;
      562 	declare mrds_error_$no_recursion fixed bin (35) ext; /* recursion not allowed */
      563 	declare mrds_error_$version_not_supported fixed bin (35) ext; /* not version 4 db */
      564 	declare nargs		 fixed bin;	/* number of arguments presented */
      565 	declare path_seen		 bit (1);		/* on => path name argument given */
      566 	declare recursive_call	 bit (1) int static init ("0"b); /* on => attempt to use recursion */
      567 	declare relation_count	 fixed bin;	/* number of relations to be displayed */
      568 	declare relation_list_length	 fixed bin;	/* number of relations in -relation list  */
      569 	declare relation_list_ptr	 ptr;		/* points to head of relation list */
      570 	declare relation_name_length_init fixed bin (21); /* initial value for name length allocation */
      571 	declare relation_ptr	 ptr;		/* points to relation list element */
      572 	declare release_temp_segment_	 entry (char (*), ptr, fixed bin (35)); /* frees temp segs */
      573 	declare retrieval_mode	 fixed bin int static options (constant) init (1); /* lowest opening mode */
      574 	declare some_relation_seen	 bit (1);		/* on => at least one relation name given */
      575 	declare sys_info$max_seg_size	 fixed bin (35) ext;/* largest segment */
      576 	declare work_area		 area (sys_info$max_seg_size) based (area_ptr); /* space for temp storage */
      577 	declare (addr, empty, fixed, null, rel, substr, rtrim) builtin;
      578 	declare 1 relation		 based (relation_ptr), /* saved relation name for -relation options */
      579 		2 next		 ptr,		/* points to next in list */
      580 		2 name_length	 fixed bin (21),	/* length of the relation name */
      581 		2 name		 char (relation_name_length_init refer (relation.name_length)); /* relation's name */
      582 
  1     1 /* BEGIN mrds_dbcb.incl.pl1 -- jaw, 11/7/78 */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  1     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  1     8*     This entry is being made to cover the change made on 85-07-01 by Thanh
  1     9*     Nguyen. The scopes_changed flag was added to make checking for this
  1    10*     more efficient (mrds error list #137).
  1    11*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
  1    12*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
  1    13*     Add a bit called dont_check_txn_id to indicate whether or not we should
  1    14*     care if multiple txns use the same selection_expression. (mrds #156)
  1    15*  3) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  1    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  1    17*     Added parser_work_area_ptr and mrds_se_info_ptr for new parser.
  1    18*                                                   END HISTORY COMMENTS */
  1    19 
  1    20 
  1    21 /* WARNING
  1    22*          If the dbcb structure is changed then the mrds_data_
  1    23*          item saved_res_version MUST be incremented to invalidate all
  1    24*          existing saved resultants
  1    25**/
  1    26 
  1    27 /* HISTORY :
  1    28*
  1    29*   modified by Jim Gray - - 80-10-24, to add new_select_expr bit for
  1    30*   tid_list management
  1    31*
  1    32*   81-1-9 Jim Gray : added like reference for  ease  in  making  the
  1    33*   phony resultant in mu_database_index, without having the area dcl
  1    34*   included.
  1    35*
  1    36*   81-06-17 Roger Lackey :  added  last_store_rel_name  for  use  by
  1    37*   mrds_dsl_store
  1    38*
  1    39*   81-06-26 Roger Lackey : Added no_optimize and  print_search_order
  1    40*   switches
  1    41*
  1    42*   81-07-06 Jim Gray : added identifier for  the  current  selection
  1    43*   expression,  so  that relation statistics can be updated relative
  1    44*   to number of selection expressions seem. Also  removed  init  for
  1    45*   last_store_rel_name,   as   this   iw   now   properly   done  in
  1    46*   mrds_dsl_init_res.
  1    47*
  1    48*   81-07-17  Roger Lackey : added pred_ptr and unused_ptrs.
  1    49*
  1    50*   82-08-19  Mike Kubicar : added store_vector field.  This is needed
  1    51*   for the conversion to the relation manager.
  1    52*
  1    53*   82-08-23 Davids: added the relmgr_entries and access_costs
  1    54*   substructures so that the entries and costs can change
  1    55*   depending on the type of database that is opened.
  1    56*
  1    57*   82-09-09 Mike Kubicar : added modify_vector field.  This is needed
  1    58*   since modify uses a different vector type (general) than does store.
  1    59*
  1    60*   82-09-20 Davids: changed names of (store modify)_vector to
  1    61*   (store modify)_vector_ptr. Also (delete modify)_tuple_by_id to
  1    62*   (delete modify)_tuples_by_id. added the element cursor_storage_ptr
  1    63*   which should be inited to null and will be set by mu_cursor_manager_$get
  1    64*   during the first call.
  1    65*
  1    66*   82-09-21 Davids: renamed cursor_storage_ptr to cursor_ptrs_storage_ptr
  1    67*   since it deals with the pointers to the cursors and not the cursors
  1    68*   themelves and added the element cursor_storage_area_ptr which points
  1    69*   to the area where the cursors are kept.
  1    70*
  1    71*   82-09-22 Davids: renamed the transact_ctl_seg to transactions_needed.
  1    72*   the transact_ctl_seg always had a value of 0 and really didn't mean
  1    73*   anything.
  1    74*
  1    75*   82-09-22 Mike Kubicar : added create_relation, create_index and
  1    76*   destroy_relation_by_opening to relmgr_entries.  They are needed
  1    77*   by mrds_dsl_define_temp_rel.
  1    78*
  1    79*   82-09-24 Donna Woodka : added  put_tuple to  relmgr_entries. It
  1    80*   is needed by mu_store.
  1    81*
  1    82*   82-11-12 Davids: changed the declaration of the access_costs from fixed
  1    83*   bin to float bin since the values are not integers.
  1    84*
  1    85*   83-02-02 Davids: added the dbc_uid element. This will allow mrds to make
  1    86*   sure that the dbc_ptr still points to the correct segment. Element was 
  1    87*   added to the end of the structure to allow modules that don't use
  1    88*   the element to continue to reference the dbcb structure without recompiling.
  1    89*
  1    90*   83-02-25 Davids: added the concurrency_on and rollback_on elements. These
  1    91*   are needed so that temp rels can be created with the same file attributes
  1    92*   as the permanent relations.
  1    93*
  1    94*   83-05-02 Mike Kubicar : Deleted get_next_search_specification_ptr and
  1    95*   added the resultant_in_pdir bit.
  1    96*
  1    97*   83-05-18 Davids: reduced the number of reserved bits to 14 (from 15) and
  1    98*   added the res_already_made element.
  1    99*
  1   100*   83-05-24 Mike Kubicar : Updated the relation manager calling sequences.
  1   101*
  1   102*   83-08-03 Mike Kubicar : Added the element_id_list_segment_ptr and removed
  1   103*   one of the unused pointers.
  1   104*
  1   105*   83-09-20 Ron Harvey: Added relmgr_entries.get_population.
  1   106*
  1   107*   84-08-27 John Hergert:  Created compiled_se_info_ptr from unused_ptrs(2)
  1   108*   leaving unused_ptrs(1).
  1   109*
  1   110*   85-01-15 Thanh Nguyen:  Added the work_area_ptr and removed the last
  1   111*   unused_ptrs (1).
  1   112*
  1   113*   85-04-12 Thanh Nguyen:  Added user_started_transaction and 
  1   114*   non_shared_to_shared flags.  Also added se_transaction_id and some more
  1   115*   spare ptrs, entries and reserved storages for future enhancement, since
  1   116*   we changed the saved_res_version from rslt0001 to rslt0002.
  1   117*
  1   118*   85-07-01 Thanh Nguyen:  Added scopes_changed flag.  This flag is set by
  1   119*   common routine of mrds_dsl_set_scope, reset by mrds_dsl_optimize and 
  1   120*   mrds_dsl_gen_srch_prog when building of a new search_vars.
  1   121**/
  1   122 
  1   123 
  1   124 /* this structure is based on the {unique_name}.mrds.dbcb segment
  1   125*   that constitutes the non-secure portion of the resultant model that is
  1   126*   created during the opening of a database. it contains variables that
  1   127*   are used during the runtime access of the database, and an area
  1   128*   for evaluation of requests. it points to four other
  1   129*   segments in the resultant model, {unique_name}.mrds.rdbi, the secure
  1   130*   portion of the resultant(see mdbm_rm_db_info.incl.pl1),
  1   131*   {unique_name}.mrds.select, an area for selection expression evaluation,
  1   132*   {unique_name}.mrds.curdat, and {unique_name}.mrds.stadat, two segments
  1   133*   used in the elimination of duplicate tuples during a retrieve.
  1   134*   the dbcb area holds the structure in mdbm_scope_info.incl.pl1
  1   135*   that is used when the database is using the file scope mechanism
  1   136*   for concurrency control over file readying. the segment overlayed via
  1   137*   mrds_dbc.incl.pl1 structure is pointed to and also handles concurrency control,
  1   138*   across database openings. the pointer to this dbcb structure is kept in a table
  1   139*   which associates database indexes(returned from a call to dsl_$open), with particular
  1   140*   opening instances of resultant models. (see mu_database_index routine) */
  1   141 
  1   142      dcl	   1 dbcb		      aligned based (dbcb_ptr), /* DBCB -- non-secure portion */
  1   143 	     2 data	      like dbcb_data,
  1   144 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (dbcb.static_area))));
  1   145 
  1   146      dcl	   dbcb_ptr	      ptr;
  1   147 
  1   148      declare 1 dbcb_data	      based,		/* info part of dbcb, separated out so that
  1   149*						   like references can avoid getting the area declaration */
  1   150 	     2 rdbi_ptr	      ptr,		/* pointer to write protected mdbm_util_ info. */
  1   151 	     2 range_ptr	      ptr,		/*  ptr to range structure, or null */
  1   152 	     2 select_ptr	      ptr,		/* ptr to select list, or null */
  1   153 	     2 sv_ptr	      ptr,		/* pointer to search variables */
  1   154 	     2 so_ptr	      ptr,		/* pointer to search operators */
  1   155 	     2 ti_ptr	      ptr,		/* pointer to tuple info */
  1   156 	     2 lit_ptr	      ptr,		/* pointer to the literal area, or null */
  1   157 	     2 current_ptr	      ptr,		/* ptr to select list resulting from -current clause */
  1   158 	     2 ss_ptr	      ptr,		/* ptr to select sets block if not simple s.e. */
  1   159 	     2 retr_info_ptr      ptr,		/* ptr to retrieve info area */
  1   160 	     2 trel_info_ptr      ptr,		/* ptr to retrieve info area */
  1   161 	     2 sti_ptr	      ptr,		/* pointer to store info */
  1   162 	     2 dbc_ptr	      ptr,		/*  pointer to the data base control segment */
  1   163 	     2 sfi_ptr	      ptr,		/* points to head of scalar function list */
  1   164 	     2 scope_ptr	      ptr,		/* points to array of scope tuples */
  1   165 	     2 select_area_ptr    ptr,		/* ptr to area for current selection expression allocations */
  1   166 	     2 current_data_ptr   ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  1   167*						   for eliminating duplicate tuples. */
  1   168 	     2 static_data_ptr    ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  1   169*						   for eliminating duplicate tuples. */
  1   170 	     2 store_area_ptr     ptr,		/* temp storage area for dsl_$store */
  1   171 	     2 retrieve_area_ptr  ptr,		/* temp storage for dsl_$retrieve */
  1   172 	     2 modify_area_ptr    ptr,		/* temp storage area for dsl_$modify */
  1   173 	     2 delete_area_ptr    ptr,		/* temp storage area for dsl_$delete */
  1   174 	     2 def_temp_rel_area_ptr ptr,		/* temp storage area for dsl_$define_temp_rel */
  1   175 	     2 pred_ptr	      ptr,		/* Pointer to pred_array */
  1   176 	     2 store_vector_ptr   ptr,		/* Vector structure used during store operations */
  1   177 	     2 modify_vector_ptr  ptr,		/* Used during modifies */
  1   178 	     2 element_id_list_segment_ptr ptr,		/* Points to the segment used to hold element_id_list structures */
  1   179                2 compiled_se_info_ptr ptr,                  /* points to the segment containing all info on compiled sexs */
  1   180 	     2 work_area_ptr        ptr,		/* Work area for encode/decode value allocations in mu_retrieve */
  1   181 	     2 se_info_ptr          ptr,                  /* Points to se_info struct. Primarily for error reports */
  1   182 	     2 parser_work_area_ptr ptr,		/*  work area for parser */
  1   183 	     2 reserved_ptrs      (4) ptr,		/* Reserved for future use */
  1   184 	     2 another_flag	      bit (1) unal,		/* on if predicate was -another */
  1   185 	     2 current_flag	      bit (1) unal,		/* on if predicate was -current clause */
  1   186 	     2 dbc_incr	      bit (1) unal,		/* on if dbc open mode has been incremented for this user */
  1   187 	     2 delete_flag	      bit (1) unal,		/* On if search was called from mrds_dsl_sec_delete */
  1   188 	     2 dup_retain	      bit (1) unaligned,	/* On if dup tuples allowed for retrieval */
  1   189 	     2 prev_select	      bit (1) unal,		/* on if prev. select block processed in this s.e. */
  1   190 	     2 possible_op	      bit (1) unal,		/* on of arith op. allowed */
  1   191 	     2 sel_clause	      bit (1) unal,		/* on if currently in select clause */
  1   192 	     2 dsm_sw	      bit (1) unal,		/* on if data base was opened via data submodel */
  1   193 	     2 val_rtrv	      bit (1) unal,		/* if s.e. valid for retrieve */
  1   194 	     2 val_mod	      bit (1) unal,		/* for modify */
  1   195 	     2 val_del	      bit (1) unal,		/* for delete */
  1   196 	     2 val_dtr	      bit (1) unal,		/* for define temp rel */
  1   197 	     2 transactions_needed bit (1) unal,	/* On => transaction must be started or in progress does
  1   198*                                                                     not imply that the database is of type page_file */
  1   199 	     2 open_mode	      bit (3) unal,		/* 0=>unknown, 1=>r, 2=>u, 3=>er, 4=>eu, >4=>bad */
  1   200 	     2 new_select_expr    bit (1) unal,		/* on => starting a new tid list management period */
  1   201 	     2 no_optimize	      bit (1) unal,		/* On => no optimize */
  1   202 	     2 print_search_order bit (1) unal,		/*  On => print the search order */
  1   203 	     2 resultant_in_pdir  bit (1) unal,		/* On => Temp segments are in the process dir */
  1   204 	     2 res_already_made   bit (1) unal,           /* On => resultant has been made based on a saved copy */
  1   205 	     2 user_started_transaction bit (1) unal,     /* On => user already started his own transaction. */
  1   206 	     2 non_shared_to_shared bit (1) unal,         /* On => user changed the scope from non shared to shared
  1   207*						   inside a sequence of -another selection expression. */
  1   208 	     2 scopes_changed     bit (1) unal,           /* On => scopes had been changed by set_scopes or delete_scopes */
  1   209 	     2 dont_check_txn_id  bit (1) unal,           /* On => cpmd needs same selection exp across multiple txns */
  1   210 	     2 reserved	      bit (10) unal,	/* reserved for future use */
  1   211 	     2 nseq_sch	      fixed bin (35),	/* no. tuples located via sequential search */
  1   212 	     2 nind_sch	      fixed bin (35),	/* no. tuples located via index search */
  1   213 	     2 nhash_sch	      fixed bin (35),	/* no. tuples located via hash search */
  1   214 	     2 nlk_sch	      fixed bin (35),	/* no tuples located via link search */
  1   215 	     2 cur_lit_offset     fixed bin (35),	/* current bit offset in literal string */
  1   216 	     2 dbi	      fixed bin (35),	/* database index for this opening */
  1   217 	     2 last_s_e_id_num    fixed bin (35),	/* identifying number for last selection expression seen */
  1   218 	     2 se_transaction_id  bit (36) aligned,       /* transaction id from beginning of select expression */
  1   219 	     2 last_store_rel_name char (32),		/* Name of relation last used  for store */
  1   220 	     2 cursor_ptrs_storage_ptr ptr,		/* pointer to space where cursor ptrs are stored */
  1   221 	     2 cursor_storage_area_ptr ptr,		/* pointer to area where the cursors are kept */
  1   222 	     2 reserved_words     (10) fixed bin (35),	/* Reserved for future use */
  1   223 	     2 relmgr_entries,			/* relation manager entries */
  1   224 	       3 open	      entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  1   225 	       3 close	      entry (bit (36) aligned, fixed bin (35)),
  1   226 	       3 create_cursor    entry (bit (36) aligned, ptr, ptr, fixed bin (35)),
  1   227 	       3 destroy_cursor   entry (ptr, ptr, fixed bin (35)),
  1   228 	       3 set_scope	      entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35)),
  1   229 	       3 delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  1   230 	       3 modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35)),
  1   231 	       3 get_tuple_by_id  entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  1   232 	       3 get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)),
  1   233 	       3 get_tuple_id     entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  1   234 	       3 put_tuple	      entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  1   235 	       3 get_count	      entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  1   236 	       3 get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35)),
  1   237 	       3 get_population   entry (ptr, fixed bin (35), fixed bin (35)),
  1   238 	       3 create_relation  entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)),
  1   239 	       3 create_index     entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35)),
  1   240 	       3 destroy_relation_by_path entry (char (*), char (*), fixed bin (35)),
  1   241 	       3 reserved_entries (5) entry (),
  1   242 	     2 access_costs,			/* access costs for permute */
  1   243 	       3 total_primary_key_cost float bin,
  1   244 	       3 access_cost      float bin,
  1   245 	       3 access_overhead  float bin,
  1   246 	       3 us_access_cost   float bin,
  1   247 	       3 os_access_cost   float bin,
  1   248 	     2 dbc_uid	      bit (36) aligned,	/* uid of the segment containing the dbc structure */
  1   249 	     2 concurrency_on     bit (1) unal,		/* "1"b implies dmfile concurrency is being used */
  1   250 	     2 rollback_on	      bit (1) unal;		/* "1"b iomplies before journaling is to be done */
  1   251 
  1   252 /* END mrds_dbcb.incl.pl1 */
  1   253 
  1   254 
      583 
      584 
  2     1 /* BEGIN mdbm_rm_db_info.incl.pl1 -- jaw, 11/7/78 */
  2     2 
  2     3 
  2     4 
  2     5 /****^  HISTORY COMMENTS:
  2     6*  1) change(86-08-13,Hergert),, approve(88-06-28,MCR7903),
  2     7*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  2     8*     Removed change of 84-11-02. i.e. replaced even_word_pad.
  2     9*                                                   END HISTORY COMMENTS */
  2    10 
  2    11 
  2    12 /* WARNING
  2    13*          If the rm_db_info structure is changed then the mrds_data_
  2    14*          item saved_res_version MUST be incremented to invalidate all
  2    15*          existing saved resultants
  2    16**/
  2    17 
  2    18 /*  DESCRIPTION:  This  structure   is   based   on   a   segment
  2    19*   {unique_name}.mrds.rdbi that represents the secure portion of the
  2    20*   resultant model that is created partially at database open  time,
  2    21*   (the rm_file_array, and rm_rel_array) and partially at ready_file
  2    22*   time,    (the    rm_file_info,     rm_rel_info,     rm_attr_info,
  2    23*   rm_domain_info, rm_plink_info and rm_clink_info). it's purpose is
  2    24*   to  provide  an  efficient  means  of  accessing  database  model
  2    25*   information, as seen from the possibly submodel view of the user,
  2    26*   and his current state of "files readied". it is the  secure  part
  2    27*   because  it  contains  the  model  information  which needs to be
  2    28*   protected  from  general  knowledge,  and   this   segment   will
  2    29*   eventually  be  capable  of  being in a lower ring. the structure
  2    30*   itself points to four arrays that are  allocated  in  it's  area,
  2    31*   that  in  turn point to the other structures mentions above, also
  2    32*   allocated in  the  rm_db_info.static_area.  the  arrays  are  the
  2    33*   rm_file_array,  and  rm_rel_array. their are a pair for temporary
  2    34*   relations,  initially  empty,  and  a  pair  for   normal   model
  2    35*   files/relations.  the  normal  rm_file_array  is initialized to a
  2    36*   list of all known file names, the rm_rel_array only gets relation
  2    37*   names   as   files  are  readied.  the  rm_file_array  points  to
  2    38*   rm_file_infos for each file (see mdbm_rm_file_info.incl.pl1)  and
  2    39*   the   rm_rel_array   points  to  rm_rel_info  for  each  relation
  2    40*   "readied". (see mdbm_rm_rel_info.incl.pl1). (the  arrays  are  in
  2    41*   mdbm_rm_file_array.incl.pl1  and mdbm_rm_rel_array.incl.pl1). the
  2    42*   file infos point to contained rel infos, the rel infos  point  to
  2    43*   contained  attr  infos,  and  those in turn to domain infos. (see
  2    44*   mdbm_rm_attr_info.incl.pl1   and    mdbm_rm_domain_info.incl.pl1)
  2    45*   foreign     keys    are    represented    by    the    structures
  2    46*   mdbm_rm_plink_info.incl.pl1, and mdbm_rm_clink_info.incl.pl1. the
  2    47*   pathnames  of the model and submodel, if any, are also maintained
  2    48*   in rm_db_info. the pointer to this rm_db_info segment is obtained
  2    49*   from  the  dbcb  segment tructure(see mrds_dbcb.incl.pl1) see the
  2    50*   individual include files for  further  organization  information,
  2    51*   and particular data structures.
  2    52*
  2    53*   HISTORY:
  2    54*
  2    55*   80-02-01 Jim Gray : Modified to put area on even  word  boundary,
  2    56*   so that define_area_ could be used to make it an extensible area
  2    57*
  2    58*   81-1-9 Jim  Gray  :  added  like  reference  to  make  the  phony
  2    59*   resultant in mu_database_index easier to keep, since no reference
  2    60*   to the area is needed.
  2    61*
  2    62*   81-1-12 Jim Gray : added version of submodel used in  opening  to
  2    63*   resultant.
  2    64*
  2    65*   81-05-13 Rickie E. Brinegar: added the administrator bit  to  the
  2    66*   structure.
  2    67*
  2    68*   81-05-28 Jim Gray : removed pointers to file_arrays,  since  they
  2    69*   are  now  combined  into  the rel_array. Removed the control file
  2    70*   info which was unused. Added pointer  to  head  of  domain  list,
  2    71*   which is to be used to insure only one copy of each domain info.
  2    72*
  2    73*   83-05-19 Davids: Added the  saved_res_version element.
  2    74*
  2    75*   84-11-02 Thanh Nguyen:   Replaced  the  even_word_pad   by   the 
  2    76*   ref_name_proc_ptr  to point  to list  of reference  name of  the
  2    77*   check, encode, or decode proc.
  2    78*
  2    79*   CAUTION: The structure entries from db_version to sm_path  should
  2    80*   not  be moved or have their declarations changed because they are
  2    81*   used in the handling of old version database openings.
  2    82*
  2    83*
  2    84**/
  2    85 
  2    86      dcl	   1 rm_db_info	      aligned based (rdbi_ptr), /* data base info, located at base of res. dm. seg. */
  2    87 	     2 data	      like rm_db_info_data,
  2    88 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (rm_db_info.static_area))));
  2    89 
  2    90      dcl	   rdbi_ptr	      ptr;
  2    91 
  2    92      declare 1 rm_db_info_data      based,		/* separate declaration of info, so others can use
  2    93*						   like reference to it without getting the area as well */
  2    94 	     2 db_version	      fixed bin,		/* version no. of db */
  2    95 	     2 sm_version	      fixed bin unal,	/* version of submodel used unal, 0 if model opening */
  2    96 	     2 val_level	      fixed bin unal,	/* validation level for this db. */
  2    97 	     2 db_path	      char (168),		/* abs. path of db. */
  2    98 	     2 sm_path	      char (168),		/* path of submodel or model */
  2    99 	     2 mdbm_secured	      bit (1) unal,		/* ON => database is secured */
  2   100 	     2 administrator      bit (1) unal,		/* ON => user is an administrator */
  2   101 	     2 pad	      bit (34) unal,	/* for future use */
  2   102 	     2 saved_res_version  char (8),		/* version of the saved resultant in the 
  2   103*                                                               dbcb and rdbi segments in the db dir */
  2   104 	     2 domain_list_ptr    ptr,		/* pointer to head of list of domain_info's */
  2   105 	     2 ra_ptr	      ptr,		/* pointer to rel. array */
  2   106 	     2 tra_ptr	      ptr,		/* to rel array for temp rels */
  2   107 	     2 even_word_pad      fixed bin (71) aligned; /* padding to put area on even word boundary */
  2   108 
  2   109 /* END mdbm_rm_db_info.incl.pl1 */
  2   110 
  2   111 
      585 
      586 
  3     1 /* BEGIN INCLUDE FILE mrds_path_info.incl.pl1 - -  Jim Gray 81-01-22 */
  3     2 
  3     3 /* HISTORY:
  3     4*
  3     5*   81-01-22 Jim Gray : originaly created for the dsl_$get_path_info interface,
  3     6*   a slight extension to the undocumented mrds_dsl_get_version$header.
  3     7*
  3     8**/
  3     9 
  3    10 /* DESCRIPTION:
  3    11*
  3    12*   This structure returns information about a relative pathname, given
  3    13*   to a pathname accepting mrds interface. The information returned
  3    14*   is the absolute pathname, plus in the case that
  3    15*   the relative path points to a mrds database or submodel
  3    16*   whether it is a model or a submodel, the mrds version of
  3    17*   the model or submodel, it's creator, and the time of creation.
  3    18*
  3    19**/
  3    20 
  3    21 
  3    22 declare 1 mrds_path_info aligned based (mrds_path_info_ptr),
  3    23         2 version fixed bin,				/* version number for this structure */
  3    24         2 absolute_path char (168),			/* the absolute path from the input relative path */
  3    25         2 type,
  3    26 	3 not_mrds bit (1) unal,			/* on => path not to model or submodel */
  3    27 	3 model bit (1) unal,			/* on => path to database model, thus possible .db suffix */
  3    28 	3 submodel bit (1) unal,			/* on => path to submodel, thus possible .dsm suffix */
  3    29 	3 mbz1 bit (33) unal,
  3    30         2 mrds_version fixed bin,			/* the mrds version number of the model or submodel */
  3    31         2 creator_id char (32),			/* the person.project.tag of the creator */
  3    32         2 creation_time fixed bin (71),			/* convert date to binary form of time model/submodel created */
  3    33         2 mbz2 bit (36) unal ;
  3    34 
  3    35 
  3    36 declare  mrds_path_info_ptr ptr ;
  3    37 
  3    38 declare  mrds_path_info_structure_version fixed bin init (1) int static options (constant) ;
  3    39 
  3    40 /* END  INCLUDE FILE mrds_path_info.incl.pl1 */
      587 
      588 
  4     1 /* BEGIN INCLUDE FILE mrds_relation_list.incl.pl1 - - Jim Gray 81-01-14 */
  4     2 
  4     3 /* HISTORY:
  4     4*
  4     5*   81-01-14 Jim Gray : originally created for the dsl_$get_relation_list interface
  4     6*
  4     7**/
  4     8 
  4     9 /* DESCRIPTION:
  4    10*
  4    11*   For a given opening of a database via a model or submodel view,
  4    12*   this structure will contain the list of relations as seen from that view.
  4    13*   It contains the number of relations in that view, and both the
  4    14*   submodel and model names of the relation (model = submodel name if not submodel opening)
  4    15*   plus whether the opening was via a submodel or not.
  4    16*   The virtual relation bit indicates when the model name may not
  4    17*   be valid, due to a mapping over more than one relation in the model.
  4    18*
  4    19*   Access information for various versions of MRDS access is also returned, as follows:
  4    20*
  4    21*   system_acl entries refers strictly to "rew" type multics acl's.
  4    22*   for version 3 access info, attr system_acls are the same as the relation acls,
  4    23*   unless the attribute is inverted, in which case it is the acl
  4    24*   of the attribute as it appears under the invert_dir in the database.
  4    25*
  4    26*   mrds_access entries are version dependent, version 3 databases
  4    27*   with mrds_list/set_delete_acl commands used a mrds specific access
  4    28*   set of modes of retreive-store-modify-delete.
  4    29*   version 4 databases released in MR8 had no mrds specific
  4    30*   access, but used system acl's of "rew".
  4    31*   version 4 databases for MR9 mrds using submodel security have
  4    32*   mrds specific access mode of append/delete_tuple for relations,
  4    33*   and read/modify_attr for attributes.
  4    34*
  4    35*   effective_access entries use the same units as mrds_access.
  4    36*   it is the logical result of applying both mrds and system access,
  4    37*   and coming up with a user effective mode of access to the relation/attribute.
  4    38*   for version 3 databases, the effective access includes
  4    39*   in the relation effective access, the effect that access of inverted attributes
  4    40*   in the invert_dir may have.
  4    41*
  4    42**/
  4    43 
  4    44 
  4    45 declare 1 mrds_relation_list aligned based (mrds_relation_list_ptr),
  4    46         2 version fixed bin,				/* version number for this structure */
  4    47         2 access_info_version fixed bin,		/* version of mrds access modes
  4    48*						   3 => version 3 db with r-s-m-d access,
  4    49*						   4 => version 4 MR8 db with r-e-w access,
  4    50*						   5 => version 4 MR9 db with relation a-d, and attr r-m modes
  4    51*						   (submodel security) */
  4    52         2 num_rels_in_view fixed bin,			/* count of relations present in this view */
  4    53         2 submodel_view bit (1) unal,			/* ON => this opening was via a submodel */
  4    54         2 mbz1 bit (35) unal,
  4    55         2 relation (mrds_relation_list_num_rels_init refer (mrds_relation_list.num_rels_in_view)),
  4    56 	3 model_name char (32),			/* name of relation in database model */
  4    57 	3 submodel_name char (64),			/* alias name of relation in submodel, else model name */
  4    58 	3 system_acl char (8) varying,		/* the system access from r-e-w modes */
  4    59 	3 mrds_access char (8) varying,		/* version 3 => from r-s-m-d, 4 => from r-e-w, 5 => from a-d */
  4    60 	3 effective_access char (8) varying,		/* effect of system + mrds access, in mrds access units */
  4    61 	3 virtual_relation bit (1) unal,		/* ON => submodel relation defined over >1 model relation */
  4    62 	3 mbz2 bit (35) unal ;
  4    63 
  4    64 
  4    65 declare  mrds_relation_list_num_rels_init fixed bin ;
  4    66 
  4    67 declare  mrds_relation_list_ptr ptr ;
  4    68 
  4    69 declare  mrds_relation_list_structure_version fixed bin init (1) int static options (constant) ;
  4    70 
  4    71 /* END INCLUDE FILE mrds_relation_list.incl.pl1 */
      589 
      590 
  5     1 /* BEGIN INCLUDE FILE mrds_attribute_list.incl.pl1 - - 81-01-14 Jim Gray */
  5     2 
  5     3 /* HISTORY:
  5     4*
  5     5*   81-01-14 Jim Gray : originally created for the dsl_$get_attribute_list interface.
  5     6*
  5     7**/
  5     8 
  5     9 /* DESCRIPTION:
  5    10*
  5    11*   For a giving database opening via a model or submodel view,
  5    12*   this structure contains attribute information for a particular relation.
  5    13*   The number of attributes in this model/submodel view of the relation,
  5    14*   and the names in both the model and submodel are given
  5    15*   (these will be the same if opened with a model view)
  5    16*   The name of the domain for each attribute, and the descriptor
  5    17*   of the users view of the data type is given, as well as whether the attribute
  5    18*   can be used as an indexed attribute.
  5    19*
  5    20*   Access information is also returned for various versions of MRDS security, as follows:
  5    21*
  5    22*   system_acl entries refers strictly to "rew" type multics acl's.
  5    23*   for version 3 access info, attr system_acls are the same as the relation acls,
  5    24*   unless the attribute is inverted, in which case it is the acl
  5    25*   of the attribute as it appears under the invert_dir in the database.
  5    26*
  5    27*   mrds_access entries are version dependent, version 3 databases
  5    28*   with mrds_list/set_delete_acl commands used a mrds specific access
  5    29*   set of modes of retreive-store-modify-delete.
  5    30*   version 4 databases released in MR8 had no mrds specific
  5    31*   access, but used system acl's of "rew".
  5    32*   version 4 databases for MR9 mrds using submodel security have
  5    33*   mrds specific access mode of append/delete_tuple for relations,
  5    34*   and read/modify_attr for attributes.
  5    35*
  5    36*   effective_access entries use the same units as mrds_access.
  5    37*   it is the logical result of applying both mrds and system access,
  5    38*   and coming up with a user effective mode of access to the relation/attribute.
  5    39*   for version 3 databases, the effective access includes
  5    40*   in the relation effective access, the effect that access of inverted attributes
  5    41*   in the invert_dir may have.
  5    42*
  5    43**/
  5    44 
  5    45 
  5    46 declare 1 mrds_attribute_list aligned based (mrds_attribute_list_ptr),
  5    47         2 version fixed bin,				/* version number of this structure */
  5    48         2 access_info_version fixed bin,		/* version of mrds access modes
  5    49*						   3 => version 3 db with r-s-m-d access,
  5    50*						   4 => version 4 MR8 db with r-e-w access,
  5    51*						   5 => version 4 MR9 db with relation a-d, and attr r-m modes
  5    52*						   (submodel security) */
  5    53         2 num_attrs_in_view fixed bin,			/* number of attributes in this view of the relation */
  5    54         2 submodel_view bit (1) unal,			/* ON => the opening was via a submodel */
  5    55         2 mbz1 bit (35) unal,
  5    56         2 attribute (mrds_attribute_list_num_attrs_init refer (mrds_attribute_list.num_attrs_in_view)),
  5    57 	3 model_name char (32),			/* name of attribute in model */
  5    58 	3 submodel_name char (64),			/* alias name of attribute in submodel, else model name */
  5    59 	3 domain_name char (32),			/* name of the domain for this attribute */
  5    60 	3 user_data_type bit (36),			/* standard multics data descriptor for storage format
  5    61*						   users view if -decode_dcl, else same as db descriptor */
  5    62 	3 system_acl char (8) varying,		/* the system access from r-e-w modes */
  5    63 	3 mrds_access char (8) varying,		/* version 3 => from r-s-m-d, 4 => from r-e-w, 5 => from r-m */
  5    64 	3 effective_access char (8) varying,		/* effect of system + mrds access, in mrds access units */
  5    65 	3 indexed bit (1) unal,			/* ON => this is a secondary index attribute, or a key head */
  5    66 	3 mbz2 bit (35) unal ;
  5    67 
  5    68 
  5    69 declare  mrds_attribute_list_num_attrs_init fixed bin ;
  5    70 
  5    71 declare  mrds_attribute_list_ptr ptr ;
  5    72 
  5    73 declare  mrds_attribute_list_structure_version fixed bin init (1) int static options (constant) ;
  5    74 
  5    75 /* END INCLUDE FILE mrds_attribute_list.incl.pl1 */
      591 
      592 
      593 
      594      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/01/88  1313.8  display_mrds_db_access.pl1        >special_ldd>install>MR12.2-1073>display_mrds_db_access.pl1
583          1    08/01/88  1300.0  mrds_dbcb.incl.pl1                >special_ldd>install>MR12.2-1073>mrds_dbcb.incl.pl1
585          2    08/01/88  1310.7  mdbm_rm_db_info.incl.pl1          >special_ldd>install>MR12.2-1073>mdbm_rm_db_info.incl.pl1
587          3    10/14/83  1608.8  mrds_path_info.incl.pl1           >ldd>include>mrds_path_info.incl.pl1
589          4    10/14/83  1608.8  mrds_relation_list.incl.pl1       >ldd>include>mrds_relation_list.incl.pl1
591          5    10/14/83  1608.8  mrds_attribute_list.incl.pl1      >ldd>include>mrds_attribute_list.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
abs_path                        000100 automatic       char(200)                packed unaligned dcl 520 set ref 327* 329* 335* 348*
                                                                                  356* 359* 394*
absolute_path             1            based           char(168)                level 2 dcl 3-22 ref 329
all_relations                   000162 automatic       bit(1)                   packed unaligned dcl 521 set ref 84* 232* 416 422
area_ptr                        000164 automatic       pointer                  dcl 522 set ref 82* 107* 113 266 325* 392* 457* 506
                                                                                  507* 508*
arg                                    based           char                     packed unaligned dcl 523 set ref 143 199 199 205 205
                                                                                  211 214* 253 268 314* 325* 327
arg_count                       000166 automatic       fixed bin(17,0)          dcl 524 set ref 117* 123* 126* 136* 151 151* 151
                                                                                  234* 234 241* 244* 250* 255* 255 281 281* 281
arg_len                         000167 automatic       fixed bin(21,0)          dcl 525 set ref 123* 133 143 199 199 205 205 211 214
                                                                                  214 241* 247 253 265 268 314 314 325 325 327
arg_ptr                         000170 automatic       pointer                  dcl 526 set ref 123* 143 199 199 205 205 211 214
                                                                                  241* 253 268 314 325 327
args_finished                   000172 automatic       bit(1)                   packed unaligned dcl 527 set ref 118* 119 125* 134*
                                                                                  153* 212* 221* 243* 248* 292* 312* 334* 346* 358*
                                                                                  369*
attribute                 4            based           structure                array level 2 dcl 5-46
caller_name                     000000 constant        char(32)                 initial packed unaligned dcl 528 set ref 73* 87*
                                                                                  100* 107* 108* 126* 136* 165* 214* 223* 244* 250*
                                                                                  294* 314* 335* 348* 359* 371* 394* 460* 507*
cleanup                         000174 stack reference condition                dcl 529 ref 93
com_err_                        000012 constant        entry                    external dcl 530 ref 73 87 100 108 126 136 165 214
                                                                                  223 244 250 294 314 335 348 359 371 394 460
cu_$af_arg_count                000014 constant        entry                    external dcl 531 ref 86
cu_$arg_ptr                     000016 constant        entry                    external dcl 532 ref 123 241
data                                   based           structure                level 2 in structure "rm_db_info" dcl 2-86
                                                                                  in procedure "dmda"
data                                   based           structure                level 2 in structure "dbcb" dcl 1-142 in procedure
                                                                                  "dmda"
db_index                        000202 automatic       fixed bin(35,0)          dcl 533 set ref 81* 356* 367* 392* 457* 511 512*
                                                                                  513*
db_path                   2            based           char(168)                level 3 dcl 2-86 set ref 402*
db_version                             based           fixed bin(17,0)          level 3 dcl 2-86 set ref 402*
dbcb                                   based           structure                level 1 dcl 1-142
dbcb_data                              based           structure                level 1 unaligned dcl 1-148
dbcb_ptr                        000232 automatic       pointer                  dcl 1-146 set ref 367* 368 376 406
discard                         000203 automatic       fixed bin(35,0)          dcl 534 set ref 507* 512*
done                            000204 automatic       bit(1)                   packed unaligned dcl 535 set ref 436* 438 440* 444*
dsm_sw                  106(08)        based           bit(1)                   level 3 packed packed unaligned dcl 1-142 ref 406
effective_access         53            based           varying char(8)          array level 3 in structure "mrds_attribute_list"
                                                                                  dcl 5-46 in procedure "dmda" set ref 487* 493*
effective_access         42            based           varying char(8)          array level 3 in structure "mrds_relation_list"
                                                                                  dcl 4-45 in procedure "dmda" set ref 473* 479*
empty                                                  builtin function         dcl 577 ref 113
error_code                      000205 automatic       fixed bin(35,0)          dcl 538 set ref 72* 73* 80* 86* 87 87* 92* 99* 100*
                                                                                  107* 108 108* 123* 124 126* 135* 136* 161 164*
                                                                                  165* 213* 214* 222* 223* 241* 242 244* 249* 250*
                                                                                  291 293* 294* 313* 314* 325* 330 331 331* 335*
                                                                                  347* 348* 356* 357 359* 370* 371* 392* 394 394*
                                                                                  420 457* 460 460*
error_table_$bad_arg            000024 external static fixed bin(35,0)          dcl 539 ref 135 249
error_table_$badopt             000026 external static fixed bin(35,0)          dcl 540 ref 213
error_table_$noarg              000030 external static fixed bin(35,0)          dcl 541 ref 164 222 293
error_table_$not_act_fnc        000032 external static fixed bin(35,0)          dcl 542 ref 87
error_table_$wrong_no_of_args   000034 external static fixed bin(35,0)          dcl 543 ref 99
found                           000206 automatic       bit(1)                   packed unaligned dcl 544 set ref 424* 435* 440* 447
                                                                                  453
get_temp_segment_               000036 constant        entry                    external dcl 545 ref 107
i                               000207 automatic       fixed bin(17,0)          dcl 546 set ref 420* 423 431*
ioa_                            000040 constant        entry                    external dcl 547 ref 402 404 406 409 447 473 479 487
                                                                                  493
j                               000210 automatic       fixed bin(17,0)          dcl 548 set ref 423* 437* 440 442 442* 442 457 457
                                                                                  460 473 473 473 473 479 479
k                               000211 automatic       fixed bin(17,0)          dcl 549 set ref 485* 487 487 487 487 493 493*
last_relation_ptr               000212 automatic       pointer                  dcl 550 set ref 233* 273 275 276*
last_relation_seen              000214 automatic       bit(1)                   packed unaligned dcl 551 set ref 230* 239 243* 248*
                                                                                  254* 283*
long_format                     000215 automatic       bit(1)                   packed unaligned dcl 552 set ref 83* 200* 206* 401
                                                                                  473 487
mdbm_secured            126            based           bit(1)                   level 3 packed packed unaligned dcl 2-86 ref 404
model                    53(01)        based           bit(1)                   level 3 packed packed unaligned dcl 3-22 ref 344
mrds_access              37            based           varying char(8)          array level 3 in structure "mrds_relation_list"
                                                                                  dcl 4-45 in procedure "dmda" set ref 473*
mrds_access              50            based           varying char(8)          array level 3 in structure "mrds_attribute_list"
                                                                                  dcl 5-46 in procedure "dmda" set ref 487*
mrds_attribute_list                    based           structure                level 1 dcl 5-46
mrds_attribute_list_ptr         000242 automatic       pointer                  dcl 5-71 set ref 457* 485 487 487 487 487 493 493
mrds_attribute_list_structure_version
                                000060 constant        fixed bin(17,0)          initial dcl 5-73 set ref 457*
mrds_dsl_close                  000020 constant        entry                    external dcl 536 ref 512
mrds_dsl_get_attribute_list     000044 constant        entry                    external dcl 554 ref 457
mrds_dsl_get_relation_list      000046 constant        entry                    external dcl 556 ref 392
mrds_dsl_get_version$get_path_info
                                000050 constant        entry                    external dcl 557 ref 325
mrds_dsl_open                   000022 constant        entry                    external dcl 537 ref 356
mrds_error_$duplicate_opt       000052 external static fixed bin(35,0)          dcl 558 ref 313
mrds_error_$invalid_db_index    000054 external static fixed bin(35,0)          dcl 559 ref 370
mrds_error_$no_database         000056 external static fixed bin(35,0)          dcl 560 ref 331
mrds_error_$no_model_submodel   000060 external static fixed bin(35,0)          dcl 561 ref 331
mrds_error_$no_recursion        000062 external static fixed bin(35,0)          dcl 562 ref 72
mrds_error_$version_not_supported
                                000064 external static fixed bin(35,0)          dcl 563 ref 347
mrds_path_info                         based           structure                level 1 dcl 3-22
mrds_path_info_ptr              000236 automatic       pointer                  dcl 3-36 set ref 325* 327 329 344 344 344
mrds_path_info_structure_version
                                000060 constant        fixed bin(17,0)          initial dcl 3-38 set ref 325*
mrds_relation_list                     based           structure                level 1 dcl 4-45
mrds_relation_list_ptr          000240 automatic       pointer                  dcl 4-67 set ref 392* 416 440 442 457 457 460 473
                                                                                  473 473 473 479 479
mrds_relation_list_structure_version
                                000060 constant        fixed bin(17,0)          initial dcl 4-69 set ref 392*
mrds_version             54            based           fixed bin(17,0)          level 2 dcl 3-22 ref 344
mu_database_index$get_resultant_model_pointer
                                000042 constant        entry                    external dcl 553 ref 367
name                      3            based           char                     level 2 packed packed unaligned dcl 578 set ref 268*
                                                                                  440 447*
name_length               2            based           fixed bin(21,0)          level 2 dcl 578 set ref 266* 267* 268 440 447 447
nargs                           000216 automatic       fixed bin(17,0)          dcl 564 set ref 86* 98 151 281
next                                   based           pointer                  level 2 dcl 578 set ref 272* 275* 433
null                                                   builtin function         dcl 577 ref 82 233 272 273 327 368 506 508
num_attrs_in_view         2            based           fixed bin(17,0)          level 2 dcl 5-46 ref 485
num_rels_in_view          2            based           fixed bin(17,0)          level 2 dcl 4-45 ref 416 442
path_seen                       000217 automatic       bit(1)                   packed unaligned dcl 565 set ref 85* 163 220 308
                                                                                  321*
rdbi_ptr                        000234 automatic       pointer                  dcl 2-90 in procedure "dmda" set ref 376* 402 402
                                                                                  404 406 406
rdbi_ptr                               based           pointer                  level 3 in structure "dbcb" dcl 1-142 in procedure
                                                                                  "dmda" ref 376
recursive_call                  000010 internal static bit(1)                   initial packed unaligned dcl 566 set ref 71 94* 516*
relation                  4            based           structure                array level 2 in structure "mrds_relation_list"
                                                                                  dcl 4-45 in procedure "dmda"
relation                               based           structure                level 1 unaligned dcl 578 in procedure "dmda" set
                                                                                  ref 266
relation_count                  000220 automatic       fixed bin(17,0)          dcl 567 set ref 416* 418* 420
relation_list_length            000221 automatic       fixed bin(17,0)          dcl 568 set ref 235* 277* 277 418
relation_list_ptr               000222 automatic       pointer                  dcl 569 set ref 233* 273* 431
relation_name_length_init       000224 automatic       fixed bin(21,0)          dcl 570 set ref 265* 266 266 267
relation_ptr                    000226 automatic       pointer                  dcl 571 set ref 266* 267 268 272 273 275 276 431*
                                                                                  433* 433 440 447
release_temp_segment_           000066 constant        entry                    external dcl 572 ref 507
retrieval_mode                  000060 constant        fixed bin(17,0)          initial dcl 573 set ref 356*
rm_db_info                             based           structure                level 1 dcl 2-86
rm_db_info_data                        based           structure                level 1 unaligned dcl 2-92
rtrim                                                  builtin function         dcl 577 ref 457 457
sm_path                  54            based           char(168)                level 3 dcl 2-86 set ref 406*
sm_version                1            based           fixed bin(17,0)          level 3 packed packed unaligned dcl 2-86 set ref
                                                                                  406*
some_relation_seen              000230 automatic       bit(1)                   packed unaligned dcl 574 set ref 231* 261* 291
submodel                 53(02)        based           bit(1)                   level 3 packed packed unaligned dcl 3-22 ref 344
submodel_name            14            based           char(64)                 array level 3 in structure "mrds_attribute_list"
                                                                                  dcl 5-46 in procedure "dmda" set ref 487* 493*
submodel_name            14            based           char(64)                 array level 3 in structure "mrds_relation_list"
                                                                                  dcl 4-45 in procedure "dmda" set ref 440 457 457
                                                                                  460* 473* 479*
substr                                                 builtin function         dcl 577 ref 143 253
sys_info$max_seg_size           000070 external static fixed bin(35,0)          dcl 575 ref 113
system_acl               45            based           varying char(8)          array level 3 in structure "mrds_attribute_list"
                                                                                  dcl 5-46 in procedure "dmda" set ref 487*
system_acl               34            based           varying char(8)          array level 3 in structure "mrds_relation_list"
                                                                                  dcl 4-45 in procedure "dmda" set ref 473*
type                     53            based           structure                level 2 dcl 3-22
work_area                              based           area                     dcl 576 set ref 113* 266

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
addr                                                   builtin function         dcl 577
fixed                                                  builtin function         dcl 577
mrds_attribute_list_num_attrs_init     automatic       fixed bin(17,0)          dcl 5-69
mrds_relation_list_num_rels_init       automatic       fixed bin(17,0)          dcl 4-65
rel                                                    builtin function         dcl 577

NAMES DECLARED BY EXPLICIT CONTEXT.
clean_up                        003424 constant        entry                    internal dcl 502 ref 93 181
display_access                  002461 constant        entry                    internal dcl 386 ref 171
display_mrds_db_access          000651 constant        entry                    external dcl 9
dmda                            000633 constant        entry                    external dcl 9
dmdba                           000642 constant        entry                    external dcl 9
process_control_arg             001363 constant        entry                    internal dcl 189 ref 143
process_path_arg                002021 constant        entry                    internal dcl 302 ref 145

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4064        4156    3505        4074
Length      4542    3505        72         347     357           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
dmda                                474 external procedure  is an external procedure.  
on unit on line 93                   64 on unit               
process_control_arg                     internal procedure  shares stack frame of external procedure dmda.  
process_path_arg                        internal procedure  shares stack frame of external procedure dmda.  
display_access                          internal procedure  shares stack frame of external procedure dmda.  
clean_up                             78 internal procedure  is called by several nonquick procedures.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 recursive_call              dmda

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
dmda                     000100 abs_path                    dmda
                         000162 all_relations               dmda
                         000164 area_ptr                    dmda
                         000166 arg_count                   dmda
                         000167 arg_len                     dmda
                         000170 arg_ptr                     dmda
                         000172 args_finished               dmda
                         000202 db_index                    dmda
                         000203 discard                     dmda
                         000204 done                        dmda
                         000205 error_code                  dmda
                         000206 found                       dmda
                         000207 i                           dmda
                         000210 j                           dmda
                         000211 k                           dmda
                         000212 last_relation_ptr           dmda
                         000214 last_relation_seen          dmda
                         000215 long_format                 dmda
                         000216 nargs                       dmda
                         000217 path_seen                   dmda
                         000220 relation_count              dmda
                         000221 relation_list_length        dmda
                         000222 relation_list_ptr           dmda
                         000224 relation_name_length_init   dmda
                         000226 relation_ptr                dmda
                         000230 some_relation_seen          dmda
                         000232 dbcb_ptr                    dmda
                         000234 rdbi_ptr                    dmda
                         000236 mrds_path_info_ptr          dmda
                         000240 mrds_relation_list_ptr      dmda
                         000242 mrds_attribute_list_ptr     dmda

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac
enable_op           shorten_stack       ext_entry           int_entry           op_alloc_           op_empty_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$af_arg_count              cu_$arg_ptr                   get_temp_segment_
ioa_                          mrds_dsl_close                mrds_dsl_get_attribute_list   mrds_dsl_get_relation_list
mrds_dsl_get_version$get_path_info                          mrds_dsl_open
mu_database_index$get_resultant_model_pointer               release_temp_segment_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$badopt           error_table_$noarg            error_table_$not_act_fnc
error_table_$wrong_no_of_args mrds_error_$duplicate_opt     mrds_error_$invalid_db_index  mrds_error_$no_database
mrds_error_$no_model_submodel mrds_error_$no_recursion      mrds_error_$version_not_supported
sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      9 000632        71 000656        72 000660        73 000662        75 000713        80 000714        81 000715
     82 000716        83 000720        84 000722        85 000723        86 000724        87 000734        92 000772
     93 000773        94 001015        98 001020        99 001023       100 001025       102 001056       107 001057
    108 001077       113 001134       117 001140       118 001142       119 001143       123 001146       124 001163
    125 001165       126 001167       128 001225       133 001226       134 001231       135 001233       136 001236
    138 001273       143 001274       145 001303       151 001304       153 001311       157 001313       161 001314
    163 001316       164 001320       165 001323       167 001354       171 001355       181 001356       187 001362
    189 001363       199 001364       200 001376       201 001377       205 001400       206 001410       207 001412
    211 001413       212 001417       213 001421       214 001424       216 001473       220 001474       221 001476
    222 001500       223 001503       225 001534       230 001535       231 001536       232 001537       233 001540
    234 001543       235 001544       239 001545       241 001550       242 001565       243 001567       244 001572
    246 001630       247 001631       248 001634       249 001637       250 001642       252 001677       253 001700
    254 001705       255 001707       256 001711       261 001712       265 001714       266 001715       268 001727
    272 001734       273 001736       275 001743       276 001744       277 001745       281 001746       283 001753
    287 001755       291 001756       292 001762       293 001764       294 001767       300 002020       302 002021
    308 002022       312 002024       313 002026       314 002031       316 002071       321 002072       325 002074
    327 002127       329 002141       330 002145       331 002147       334 002154       335 002156       337 002221
    344 002222       346 002231       347 002233       348 002236       351 002303       356 002304       357 002330
    358 002332       359 002334       362 002400       367 002401       368 002412       369 002416       370 002420
    371 002423       373 002454       376 002455       384 002460       386 002461       392 002462       394 002501
    401 002550       402 002552       404 002577       406 002617       409 002650       416 002664       418 002672
    420 002674       422 002705       423 002707       424 002711       425 002713       431 002714       433 002722
    435 002725       436 002726       437 002727       438 002731       440 002734       442 002752       444 002760
    445 002762       447 002763       453 003031       457 003033       460 003120       473 003175       479 003245
    485 003301       487 003311       493 003361       495 003416       498 003420       500 003422       502 003423
    506 003431       507 003436       508 003456       511 003461       512 003463       513 003477       516 003501
    518 003503


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
