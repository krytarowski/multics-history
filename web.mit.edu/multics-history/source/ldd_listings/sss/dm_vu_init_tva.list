	COMPILATION LISTING OF SEGMENT dm_vu_init_tva
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 03/05/85  0850.7 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* DESCRIPTION:
        8*          This subroutine builds an "empty" typed_vector_array.  It has two
        9*     calling sequences:
       10*
       11*     call dm_vector_util_$init_tva (area_ptr, number_of_slots,
       12*     number_of_dimensions, maximum_dimension_name_length,
       13*     typed_vector_array_ptr, code);
       14*     
       15*     or,
       16*     
       17*     call dm_vector_util_$init_tva (area_ptr, number_of_slots,
       18*     dim_1_name, dim_1_variable,...dim_N_name, dim_N_variable,
       19*     typed_vector_array_ptr, code);
       20*     
       21*     The effective difference in the two calling sequences is whether or not
       22*     the dimension_table has the name and descriptor_ptr variables filled in.
       23*     In the first case, they are not filled in (they are initialized to "" and
       24*     null) and the caller is left with this responsibility.  In the second
       25*     case, they are filled in.  The descriptor for dimension I is the same as
       26*     the descriptor for dim_I_variable.  The name for dimension I is the
       27*     contents of the dim_I_name variable.
       28*
       29**/
       30 
       31 /* HISTORY:
       32*
       33*Written by Lindsey Spratt, 02/01/82.
       34*
       35*Modified:
       36*03/09/82 by Lindsey Spratt:  Changed to use named constants for the position
       37*	  of the arguments.  Added another calling sequence.
       38*06/28/82 by Lindsey Spratt: Changed from version 1 to version 2 of
       39*            typed_vector_array.
       40*06/17/83 by Lindsey L. Spratt:  Fixed to handle varying character strings as
       41*            input parameters correctly.
       42*12/18/84 by Lindsey L. Spratt:  Changed to use the ERROR_RETURN technology.
       43*            Moved the proc stmt to the standard place.  Fixed to free the tva
       44*            on cleanup.  Changed some uppercase automatic variables to
       45*            lowercase.  Modernized the sub_err_ calls.  Added additional
       46*            validity checks on the parameter list.
       47*12/19/84 by Lindsey L. Spratt:  Added GET_ARG_PTR function.
       48**/
       49 /* format: style2,ind3 */
       50 
       51 /* format: style2,ind3 */
       52 dm_vu_init_tva:
       53    proc () options (variable);
       54 
       55 /* START OF DECLARATIONS */
       56 /* Parameter */
       57 /* Automatic */
       58 
       59       dcl	    arg_idx	       fixed bin;
       60       dcl	    arg_len	       fixed bin (21);
       61       dcl	    arg_list_arg_count     fixed bin;
       62       dcl	    arg_list_ptr	       ptr;
       63       dcl	    arg_ptr	       ptr init (null);
       64       dcl	    code		       fixed bin (35) init (0);
       65       dcl	    code_arg_idx	       fixed bin;
       66       dcl	    descriptor_string_ptr  ptr;
       67       dcl	    dim_idx	       fixed bin;
       68       dcl	    is_dimension_value     bit (1) aligned;
       69       dcl	    names_given	       bit (1) aligned init ("0"b);
       70       dcl	    nargs		       fixed bin;
       71       dcl	    ndims		       fixed bin;
       72       dcl	    number_of_name_args    fixed bin init (0);
       73       dcl	    p_code_ptr	       ptr;
       74       dcl	    p_typed_vector_array_ptr_ptr
       75 			       ptr init (null);
       76       dcl	    packed	       bit (1) aligned;
       77       dcl	    scale		       fixed bin;
       78       dcl	    size		       fixed bin;
       79       dcl	    tva_ptr_arg_idx	       fixed bin;
       80       dcl	    type		       fixed bin;
       81       dcl	    work_area_ptr	       ptr;
       82 
       83 /* Based */
       84 
       85       dcl	    char_template	       based char (size);
       86       dcl	    descriptor_string      bit (36) aligned based (descriptor_string_ptr);
       87       dcl	    p_code	       based (p_code_ptr) fixed bin (35);
       88       dcl	    p_typed_vector_array_ptr
       89 			       based (p_typed_vector_array_ptr_ptr) ptr;
       90       dcl	    ptr_template	       based ptr;
       91       dcl	    s_fixed_real_template  based fixed bin;
       92       dcl	    v_char_template	       based char (size) varying;
       93       dcl	    work_area	       area based (work_area_ptr);
       94 
       95 /* Builtin */
       96 
       97       dcl	    (addrel, length, max, null, rtrim)
       98 			       builtin;
       99 
      100 /* Condition */
      101 
      102       dcl	    cleanup	       condition;
      103 
      104 /* Constant */
      105 
      106       dcl	    MYNAME	       init ("dm_vu_init_tva") char (40) varying internal static options (constant);
      107       dcl	    (
      108 	    AREA_PTR_ARG_IDX       init (1),
      109 	    NUMBER_OF_SLOTS_ARG_IDX
      110 			       init (2),
      111 	    NUMBER_OF_NONNAME_ARGS_AT_BEGINNING
      112 			       init (2),
      113 	    TVA_PTR_ARG_OFFSET_FROM_END
      114 			       init (1),
      115 	    NUMBER_OF_NONNAME_ARGS_AT_END
      116 			       init (2),
      117 	    NUMBER_OF_DIMENSIONS_ARG_IDX
      118 			       init (3),
      119 	    MAX_DIM_NAME_LEN_ARG_IDX
      120 			       init (4),
      121 	    NO_TYPE	       init (-1)
      122 	    )		       fixed bin (17) internal static options (constant);
      123       dcl	    (NO_PAD, NO_NL)	       init ("0"b) bit (1) aligned internal static options (constant);
      124 
      125 /* Entry */
      126 
      127       dcl	    cu_$arg_count	       entry (fixed bin, fixed bin (35));
      128       dcl	    cu_$arg_list_ptr       entry (ptr);
      129       dcl	    cu_$arg_ptr_rel	       entry (fixed bin, ptr, fixed bin (21), fixed bin (35), ptr);
      130       dcl	    decode_descriptor_     entry (ptr, fixed bin, fixed bin, bit (1) aligned, fixed bin, fixed bin, fixed bin);
      131       dcl	    dm_vector_util_$err_no_operation
      132 			       entry (ptr, fixed bin, fixed bin, ptr, ptr, fixed bin (35));
      133       dcl	    dm_vector_util_$free_typed_vector_array
      134 			       entry (ptr, ptr, fixed bin (35));
      135       dcl	    ioa_$general_rs	       entry (ptr, fixed bin, fixed bin, char (*), fixed bin (21), bit (1) aligned,
      136 			       bit (1) aligned);
      137       dcl	    sub_err_	       entry () options (variable);
      138 
      139 /* External */
      140 
      141       dcl	    (
      142 	    error_table_$bad_subr_arg,
      143 	    error_table_$badcall,
      144 	    error_table_$wrong_no_of_args
      145 	    )		       fixed bin (35) ext;
      146 
      147 
      148 /* END OF DECLARATIONS */
      149 
      150       typed_vector_array_ptr = null;
      151 
      152       on cleanup call ERROR_FINISH ();
      153 
      154       call cu_$arg_count (nargs, (0));
      155       arg_list_arg_count = nargs;
      156       call cu_$arg_list_ptr (arg_list_ptr);
      157 
      158       number_of_name_args = nargs - (NUMBER_OF_NONNAME_ARGS_AT_END + NUMBER_OF_NONNAME_ARGS_AT_BEGINNING);
      159       if number_of_name_args < 0
      160       then call sub_err_ (error_table_$wrong_no_of_args, MYNAME, ACTION_CANT_RESTART, null (), 0,
      161 	      "^/This program requires at least ^d arguments in its calling sequence^/and it was called with only ^d.",
      162 	      NUMBER_OF_NONNAME_ARGS_AT_END + NUMBER_OF_NONNAME_ARGS_AT_BEGINNING, nargs);
      163 
      164       code_arg_idx = nargs;
      165       tva_ptr_arg_idx = nargs - TVA_PTR_ARG_OFFSET_FROM_END;
      166 
      167       p_code_ptr = GET_ARG_PTR (arg_list_ptr, code_arg_idx, s_fixed_real_desc);
      168 
      169       p_code = 0;
      170 
      171       work_area_ptr = GET_ARG_PTR (arg_list_ptr, AREA_PTR_ARG_IDX, pointer_desc) -> ptr_template;
      172 
      173       tva_number_of_vector_slots =
      174 	 GET_ARG_PTR (arg_list_ptr, NUMBER_OF_SLOTS_ARG_IDX, s_fixed_real_desc) -> s_fixed_real_template;
      175 
      176       p_typed_vector_array_ptr_ptr = GET_ARG_PTR (arg_list_ptr, tva_ptr_arg_idx, pointer_desc);
      177 
      178       call decode_descriptor_ (arg_list_ptr, NUMBER_OF_DIMENSIONS_ARG_IDX, type, packed, ndims, size, scale);
      179       if type = s_fixed_real_desc
      180       then
      181          do;
      182 	  tva_number_of_dimensions =
      183 	       GET_ARG_PTR (arg_list_ptr, NUMBER_OF_DIMENSIONS_ARG_IDX, NO_TYPE) -> s_fixed_real_template;
      184 	  names_given = "0"b;
      185 
      186 	  if nargs ^= NUMBER_OF_NONNAME_ARGS_AT_END + NUMBER_OF_NONNAME_ARGS_AT_BEGINNING + 2
      187 	  then call sub_err_ (error_table_$wrong_no_of_args, MYNAME, ACTION_CANT_RESTART, null (), 0,
      188 		  "^/This program was apparently called with the calling sequence providing
      189 just the number of dimensions desired, rather than the names and data types
      190 of the dimensions.  However, this calling sequence requires exactly ^d 
      191 arguments and ^d were supplied.", NUMBER_OF_NONNAME_ARGS_AT_END + NUMBER_OF_NONNAME_ARGS_AT_BEGINNING + 2, nargs);
      192 
      193 	  tva_maximum_dimension_name_length =
      194 	       GET_ARG_PTR (arg_list_ptr, MAX_DIM_NAME_LEN_ARG_IDX, s_fixed_real_desc) -> s_fixed_real_template;
      195          end;
      196       else
      197          do;
      198 	  names_given = "1"b;
      199 	  if mod (number_of_name_args, 2) ^= 0
      200 	  then call sub_err_ (error_table_$wrong_no_of_args, MYNAME, ACTION_CANT_RESTART, null (), 0,
      201 		  "^/This program was apparently called with the calling sequence providing
      202 the names and data types of the desired dimensions, rather than just the 
      203 number of the dimensions." || "  However, this calling sequence requires two 
      204 arguments per dimension, and an odd number of dimension definition 
      205 arguments, ^d, was supplied.", number_of_name_args);
      206 
      207 	  tva_number_of_dimensions = number_of_name_args / 2;
      208 
      209 	  tva_maximum_dimension_name_length = 0;
      210 	  do arg_idx = NUMBER_OF_NONNAME_ARGS_AT_BEGINNING + 1 to nargs - NUMBER_OF_NONNAME_ARGS_AT_END by 2;
      211 	     call decode_descriptor_ (arg_list_ptr, arg_idx, type, packed, ndims, size, scale);
      212 	     call cu_$arg_ptr_rel (arg_idx, arg_ptr, arg_len, code, arg_list_ptr);
      213 	     if code ^= 0
      214 	     then call ERROR_RETURN (code, "^/Unable to get a pointer to parameter ^d.", arg_idx);
      215 
      216 
      217 	     if type = char_desc
      218 	     then tva_maximum_dimension_name_length =
      219 		     max (tva_maximum_dimension_name_length, length (rtrim (arg_ptr -> char_template)));
      220 	     else if type = v_char_desc
      221 	     then tva_maximum_dimension_name_length =
      222 		     max (tva_maximum_dimension_name_length, length (rtrim (addrel (arg_ptr, -1) -> v_char_template)))
      223 		     ;
      224 	     else call ERROR_RETURN (error_table_$bad_subr_arg,
      225 		     "^/Parameter ^d must be the name of a dimension, a variable having
      226 data type ^d or ^d, but has data type ^d.", arg_idx, char_desc, v_char_desc, type);
      227 
      228 	  end;
      229          end;
      230 
      231 
      232       alloc typed_vector_array in (work_area);
      233       typed_vector_array.version = TYPED_VECTOR_ARRAY_VERSION_2;
      234       typed_vector_array.number_of_vectors = 0;
      235       typed_vector_array.dimension_table (*).descriptor_ptr = null;
      236       typed_vector_array.dimension_table (*).cv_to_print = dm_vector_util_$err_no_operation;
      237       typed_vector_array.dimension_table (*).cv_to_typed = dm_vector_util_$err_no_operation;
      238 
      239       is_dimension_value = "1"b;
      240       dim_idx = 0;
      241 
      242       if names_given
      243       then
      244          do arg_idx = NUMBER_OF_NONNAME_ARGS_AT_BEGINNING + 1 to nargs - NUMBER_OF_NONNAME_ARGS_AT_END;
      245 	  is_dimension_value = ^is_dimension_value;
      246 	  call decode_descriptor_ (arg_list_ptr, arg_idx, type, packed, ndims, size, scale);
      247 	  call cu_$arg_ptr_rel (arg_idx, arg_ptr, arg_len, code, arg_list_ptr);
      248 	  if code ^= 0
      249 	  then call ERROR_RETURN (code, "^/Unable to get a pointer to parameter ^d.", arg_idx);
      250 
      251 	  if is_dimension_value
      252 	  then
      253 	     do;
      254 	        alloc descriptor_string in (work_area);
      255 	        descriptor_string = arg_list_ptr -> arg_list.desc_ptrs (arg_idx) -> descriptor_string;
      256 	        typed_vector_array.dimension_table (dim_idx).descriptor_ptr = descriptor_string_ptr;
      257 	     end;
      258 
      259 	  else if type = char_desc
      260 	  then
      261 	     do;
      262 	        dim_idx = dim_idx + 1;
      263 	        typed_vector_array.dimension_table (dim_idx).name = rtrim (arg_ptr -> char_template);
      264 	     end;
      265 	  else if type = v_char_desc
      266 	  then
      267 	     do;
      268 	        dim_idx = dim_idx + 1;
      269 	        typed_vector_array.dimension_table (dim_idx).name = rtrim (addrel (arg_ptr, -1) -> v_char_template);
      270 	     end;
      271 	  else call ERROR_RETURN (error_table_$bad_subr_arg,
      272 		  "^/Parameter ^d must be the name of a dimension, a variable having
      273 data type ^d or ^d, but has data type ^d.", arg_idx, char_desc, v_char_desc, type);
      274 
      275          end;
      276       else typed_vector_array.dimension_table.name = "";
      277 
      278       p_typed_vector_array_ptr = typed_vector_array_ptr;
      279 MAIN_RETURN:
      280       return;
      281 
      282 
      283 
      284 ERROR_RETURN:
      285    proc () options (variable);
      286       dcl	    er_arg_list_ptr	       ptr init (null);
      287       dcl	    er_code	       fixed bin (35);
      288       dcl	    er_msg	       varying based (addr (er_msg_struc)) char (length (er_msg_struc.str));
      289       dcl	    1 er_msg_struc,
      290 	      2 len	       fixed bin (21) aligned,
      291 	      2 str	       char (1024) unaligned;
      292       dcl	    er_nargs	       fixed bin;
      293       dcl	    er_s_fixed_real_template
      294 			       based fixed bin (35);
      295       call cu_$arg_list_ptr (er_arg_list_ptr);
      296       call cu_$arg_count (er_nargs, (0));
      297       if er_nargs = 0
      298       then er_code = 0;
      299       else er_code = er_arg_list_ptr -> arg_list.arg_ptrs (1) -> er_s_fixed_real_template;
      300       if er_nargs < 2
      301       then er_msg = "";
      302       else call ioa_$general_rs (er_arg_list_ptr, 2, 3, er_msg_struc.str, er_msg_struc.len, NO_PAD, NO_NL);
      303 
      304       call sub_err_ (er_code, MYNAME, ACTION_CANT_RESTART, null (), 0, er_msg);
      305 
      306    end ERROR_RETURN;
      307 
      308 ERROR_FINISH:
      309    proc ();
      310       if typed_vector_array_ptr ^= null
      311       then if p_typed_vector_array_ptr ^= typed_vector_array_ptr
      312 	 then call dm_vector_util_$free_typed_vector_array (work_area_ptr, typed_vector_array_ptr, (0));
      313    end ERROR_FINISH;
      314 
      315 GET_ARG_PTR:
      316    proc (gap_p_arg_list_ptr, gap_p_arg_idx, gap_p_required_type) returns (ptr);
      317       dcl	    gap_p_arg_list_ptr     ptr parm;
      318       dcl	    gap_p_arg_idx	       fixed bin parm;
      319       dcl	    gap_p_required_type    fixed bin parm;
      320 
      321       dcl	    gap_arg_ptr	       ptr init (null);
      322       dcl	    gap_arg_len	       fixed bin (21);
      323       dcl	    gap_code	       fixed bin (35) init (0);
      324       dcl	    gap_ndims	       fixed bin;
      325       dcl	    gap_packed	       bit (1) aligned;
      326       dcl	    gap_scale	       fixed bin;
      327       dcl	    gap_size	       fixed bin;
      328       dcl	    gap_type	       fixed bin;
      329 
      330       if gap_p_required_type ^= NO_TYPE
      331       then
      332          do;
      333 	  call decode_descriptor_ (gap_p_arg_list_ptr, gap_p_arg_idx, gap_type, gap_packed, gap_ndims, gap_size,
      334 	       gap_scale);
      335 	  if gap_type ^= gap_p_required_type
      336 	  then call ERROR_RETURN (error_table_$bad_subr_arg,
      337 		  "^/Parameter ^d must be of type ^d, but the one given was ^d.", gap_p_arg_idx, gap_p_required_type,
      338 		  gap_type);
      339          end;
      340 
      341       call cu_$arg_ptr_rel (gap_p_arg_idx, gap_arg_ptr, gap_arg_len, gap_code, gap_p_arg_list_ptr);
      342       if gap_code ^= 0
      343       then call ERROR_RETURN (gap_code, "^/Unable to get a pointer to parameter ^d.", gap_p_arg_idx);
      344 
      345       return (gap_arg_ptr);
      346    end GET_ARG_PTR;
      347 
  1     1 /* ***********************************************************
  1     2*   *                                                         *
  1     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
  1     4*   *                                                         *
  1     5*   *********************************************************** */
  1     6 /* BEGIN INCLUDE FILE vu_typed_vector_array.incl.pl1 */
  1     7 
  1     8 /* Written by Lindsey Spratt, 03/04/82.
  1     9*Modified:
  1    10*06/23/82 by Lindsey Spratt: Changed to version 2.  The cv entry declarations
  1    11*	  were altered.  cv_to_typed now takes ptr to the descriptor, ptr to
  1    12*	  the print_vector value (char varying), ptr to the typed_vector
  1    13*	  value location, and a code. cv_to_print now takes ptr to the
  1    14*	  descriptor, ptr to the typed_vector value, the print_vector value
  1    15*	  (char(*) varying), the maximum allowed length for the print_vector
  1    16*	  value, a temp_seg to put the value in if its to big to fit into
  1    17*	  the print_vector, and a code.
  1    18**/
  1    19 
  1    20 /* format: style2,ind3 */
  1    21      dcl	   1 typed_vector_array   based (typed_vector_array_ptr) aligned,
  1    22 	     2 version	      fixed bin (35),
  1    23 	     2 number_of_dimensions
  1    24 			      fixed bin (17),
  1    25 	     2 number_of_vectors  fixed bin (17),
  1    26 	     2 number_of_vector_slots
  1    27 			      fixed bin (17),
  1    28 	     2 maximum_dimension_name_length
  1    29 			      fixed bin (17),
  1    30 	     2 dimension_table    (tva_number_of_dimensions refer (typed_vector_array.number_of_dimensions)),
  1    31 	       3 name	      char (tva_maximum_dimension_name_length
  1    32 			      refer (typed_vector_array.maximum_dimension_name_length)) varying,
  1    33 	       3 descriptor_ptr   ptr,		/* call cv_to_print (descriptor_ptr, typed_value_ptr, */
  1    34 						/* temp_seg_ptr, max_length_for_print_value, */
  1    35 						/* print_value, code) */
  1    36 	       3 cv_to_print      entry (ptr, ptr, ptr, fixed bin (35), char (*) varying, fixed bin (35)),
  1    37 						/* call cv_to_typed (descriptor_ptr, area_ptr, */
  1    38 						/* print_value_ptr, typed_value_ptr, code) */
  1    39 	       3 cv_to_typed      entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  1    40 	     2 vector_slot	      (tva_number_of_vector_slots refer (typed_vector_array.number_of_vector_slots))
  1    41 			      pointer;
  1    42 
  1    43      dcl	   typed_vector_array_ptr ptr;
  1    44      dcl	   tva_number_of_vector_slots
  1    45 			      fixed bin;
  1    46      dcl	   tva_number_of_dimensions
  1    47 			      fixed bin;
  1    48      dcl	   tva_maximum_dimension_name_length
  1    49 			      fixed bin;
  1    50      dcl	   TYPED_VECTOR_ARRAY_VERSION_2
  1    51 			      fixed bin (35) int static options (constant) init (2);
  1    52 
  1    53 /* END INCLUDE FILE vu_typed_vector_array.incl.pl1 */
      348 
      349 
  2     1 dcl (	s_fixed_real_desc		init( 1),
  2     2 	d_fixed_real_desc		init( 2),
  2     3 	s_float_real_desc		init( 3),
  2     4 	d_float_real_desc		init( 4),
  2     5 	s_fixed_cplx_desc		init( 5),
  2     6 	d_fixed_cplx_desc		init( 6),
  2     7 	s_float_cplx_desc		init( 7),
  2     8 	d_float_cplx_desc		init( 8),
  2     9 
  2    10 	D_fixed_real_desc		init( 9),
  2    11 	D_float_real_desc		init(10),
  2    12 	D_fixed_cplx_desc		init(11),
  2    13 	D_float_cplx_desc		init(12),
  2    14 
  2    15 	pointer_desc		init(13),
  2    16 	offset_desc		init(14),
  2    17 	label_desc		init(15),
  2    18 	entry_desc		init(16),
  2    19 	structure_desc		init(17),
  2    20 	area_desc			init(18),
  2    21 
  2    22 	bit_desc			init(19),
  2    23 	v_bit_desc		init(20),
  2    24 
  2    25 	char_desc			init(21),
  2    26 	v_char_desc		init(22),
  2    27 
  2    28 	file_desc			init(23)
  2    29 					) fixed bin int static options(constant);
      350 
      351 
  3     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  3     2 /* format: style3 */
  3     3 
  3     4 /* These constants are to be used for the flags argument of sub_err_ */
  3     5 /* They are just "string (condition_info_header.action_flags)" */
  3     6 
  3     7 declare	(
  3     8 	ACTION_CAN_RESTART	init (""b),
  3     9 	ACTION_CANT_RESTART init ("1"b),
  3    10 	ACTION_DEFAULT_RESTART
  3    11 			init ("01"b),
  3    12 	ACTION_QUIET_RESTART
  3    13 			init ("001"b),
  3    14 	ACTION_SUPPORT_SIGNAL
  3    15 			init ("0001"b)
  3    16 	)		bit (36) aligned internal static options (constant);
  3    17 
  3    18 /* End include file */
      352 
      353 
  4     1 /*	BEGIN INCLUDE FILE ... descriptor.incl.pl1	*/
  4     2 
  4     3 dcl	1 desc_		aligned,
  4     4 	2 version2_	bit(1) unal,
  4     5 	2 type_		fixed bin(6) unsigned unal,
  4     6 	2 pack_		bit(1) unal,
  4     7 	2 dimension_	bit(4) unal,
  4     8 	2 scale_		fixed bin(11) unal,
  4     9 	2 precision_	fixed bin(11) unal;
  4    10 
  4    11 /*	END INCLUDE FILE ... descriptor.incl.pl1	*/
      354 
      355 
  5     1 /* BEGIN INCLUDE FILE ... arg_list.incl.pl1
  5     2*
  5     3*   James R. Davis 10 May 79 */
  5     4 
  5     5      dcl	   1 arg_list	      aligned based,
  5     6 	     2 header,
  5     7 	       3 arg_count	      fixed bin (17) unsigned unal,
  5     8 	       3 pad1	      bit (1) unal,
  5     9 	       3 call_type	      fixed bin (18) unsigned unal,
  5    10 	       3 desc_count	      fixed bin (17) unsigned unal,
  5    11 	       3 pad2	      bit (19) unal,
  5    12 	     2 arg_ptrs	      (arg_list_arg_count refer (arg_list.arg_count)) ptr,
  5    13 	     2 desc_ptrs	      (arg_list_arg_count refer (arg_list.arg_count)) ptr;
  5    14 
  5    15 
  5    16 
  5    17      dcl	   1 arg_list_with_envptr aligned based,	/* used with non-quick int and entry-var calls */
  5    18 	     2 header,
  5    19 	       3 arg_count	      fixed bin (17) unsigned unal,
  5    20 	       3 pad1	      bit (1) unal,
  5    21 	       3 call_type	      fixed bin (18) unsigned unal,
  5    22 	       3 desc_count	      fixed bin (17) unsigned unal,
  5    23 	       3 pad2	      bit (19) unal,
  5    24 	     2 arg_ptrs	      (arg_list_arg_count refer (arg_list_with_envptr.arg_count)) ptr,
  5    25 	     2 envptr	      ptr,
  5    26 	     2 desc_ptrs	      (arg_list_arg_count refer (arg_list_with_envptr.arg_count)) ptr;
  5    27 
  5    28 
  5    29      dcl	   (
  5    30 	   Quick_call_type	      init (0),
  5    31 	   Interseg_call_type     init (4),
  5    32 	   Envptr_supplied_call_type
  5    33 			      init (8)
  5    34 	   )		      fixed bin (18) unsigned unal int static options (constant);
  5    35 
  5    36 /* The user must declare arg_list_arg_count - if an adjustable automatic structure
  5    37*   is being "liked" then arg_list_arg_count may be a parameter, in order to allocate
  5    38*   an argument list of the proper size in the user's stack
  5    39*
  5    40**/
  5    41 /* END INCLUDE FILE ... arg_list.incl.pl1 */
      356 
      357    end dm_vu_init_tva;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/05/85  0756.0  dm_vu_init_tva.pl1                >spec>on>7138.pbf>dm_vu_init_tva.pl1
348          1    10/14/83  1609.1  vu_typed_vector_array.incl.pl1    >ldd>include>vu_typed_vector_array.incl.pl1
350          2    01/12/79  1059.7  desc_types.incl.pl1               >ldd>include>desc_types.incl.pl1
352          3    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
354          4    11/30/78  1227.5  descriptor.incl.pl1               >ldd>include>descriptor.incl.pl1
356          5    10/23/81  1948.6  arg_list.incl.pl1                 >ldd>include>arg_list.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000030 constant        bit(36)                  initial dcl 3-7 set ref 159* 186* 199* 304*
AREA_PTR_ARG_IDX                       constant        fixed bin(17,0)          initial dcl 107 set ref 171*
MAX_DIM_NAME_LEN_ARG_IDX               constant        fixed bin(17,0)          initial dcl 107 set ref 193*
MYNAME                          000003 constant        varying char(40)         initial dcl 106 set ref 159* 186* 199* 304*
NO_NL                           000042 constant        bit(1)                   initial dcl 123 set ref 302*
NO_PAD                          000042 constant        bit(1)                   initial dcl 123 set ref 302*
NO_TYPE                         000025 constant        fixed bin(17,0)          initial dcl 107 set ref 182* 330
NUMBER_OF_DIMENSIONS_ARG_IDX    000023 constant        fixed bin(17,0)          initial dcl 107 set ref 178* 182*
NUMBER_OF_NONNAME_ARGS_AT_BEGINNING    constant        fixed bin(17,0)          initial dcl 107 ref 158 159 186 186 210 242
NUMBER_OF_NONNAME_ARGS_AT_END          constant        fixed bin(17,0)          initial dcl 107 ref 158 159 186 186 210 242
NUMBER_OF_SLOTS_ARG_IDX                constant        fixed bin(17,0)          initial dcl 107 set ref 173*
TVA_PTR_ARG_OFFSET_FROM_END            constant        fixed bin(17,0)          initial dcl 107 ref 165
TYPED_VECTOR_ARRAY_VERSION_2           constant        fixed bin(35,0)          initial dcl 1-50 ref 233
addrel                                                 builtin function         dcl 97 ref 220 269
arg_count                              based           fixed bin(17,0)          level 3 packed unsigned unaligned dcl 5-5 ref 255
arg_idx                         000100 automatic       fixed bin(17,0)          dcl 59 set ref 210* 211* 212* 213* 224* 242* 246*
                                                                                  247* 248* 255 271*
arg_len                         000101 automatic       fixed bin(21,0)          dcl 60 set ref 212* 247*
arg_list                               based           structure                level 1 dcl 5-5
arg_list_arg_count              000102 automatic       fixed bin(17,0)          dcl 61 set ref 155*
arg_list_ptr                    000104 automatic       pointer                  dcl 62 set ref 156* 167* 171* 173* 176* 178* 182*
                                                                                  193* 211* 212* 246* 247* 255
arg_ptr                         000106 automatic       pointer                  initial dcl 63 set ref 63* 212* 217 220 247* 263 269
arg_ptrs                  2            based           pointer                  array level 2 dcl 5-5 ref 299
char_desc                       000001 constant        fixed bin(17,0)          initial dcl 2-1 set ref 217 224* 259 271*
char_template                          based           char                     unaligned dcl 85 ref 217 263
cleanup                         000136 stack reference condition                dcl 102 ref 152
code                            000110 automatic       fixed bin(35,0)          initial dcl 64 set ref 64* 212* 213 213* 247* 248
                                                                                  248*
code_arg_idx                    000111 automatic       fixed bin(17,0)          dcl 65 set ref 164* 167*
cu_$arg_count                   000010 constant        entry                    external dcl 127 ref 154 296
cu_$arg_list_ptr                000012 constant        entry                    external dcl 128 ref 156 295
cu_$arg_ptr_rel                 000014 constant        entry                    external dcl 129 ref 212 247 341
cv_to_print                            based           entry variable           array level 3 dcl 1-21 set ref 236*
cv_to_typed                            based           entry variable           array level 3 dcl 1-21 set ref 237*
decode_descriptor_              000016 constant        entry                    external dcl 130 ref 178 211 246 333
desc_ptrs                              based           pointer                  array level 2 dcl 5-5 ref 255
descriptor_ptr                         based           pointer                  array level 3 dcl 1-21 set ref 235* 256*
descriptor_string                      based           bit(36)                  dcl 86 set ref 254 255* 255
descriptor_string_ptr           000112 automatic       pointer                  dcl 66 set ref 254* 255 256
dim_idx                         000114 automatic       fixed bin(17,0)          dcl 67 set ref 240* 256 262* 262 263 268* 268 269
dimension_table           6            based           structure                array level 2 dcl 1-21
dm_vector_util_$err_no_operation
                                000020 constant        entry                    external dcl 131 ref 236 237
dm_vector_util_$free_typed_vector_array
                                000022 constant        entry                    external dcl 133 ref 310
er_arg_list_ptr                 000100 automatic       pointer                  initial dcl 286 set ref 286* 295* 299 302*
er_code                         000102 automatic       fixed bin(35,0)          dcl 287 set ref 297* 299* 304*
er_msg                                 based           varying char             dcl 288 set ref 300* 304*
er_msg_struc                    000103 automatic       structure                level 1 unaligned dcl 289 set ref 300 304
er_nargs                        000504 automatic       fixed bin(17,0)          dcl 292 set ref 296* 297 300
er_s_fixed_real_template               based           fixed bin(35,0)          dcl 293 ref 299
error_table_$bad_subr_arg       000030 external static fixed bin(35,0)          dcl 141 set ref 224* 271* 335*
error_table_$wrong_no_of_args   000032 external static fixed bin(35,0)          dcl 141 set ref 159* 186* 199*
gap_arg_len                     000164 automatic       fixed bin(21,0)          dcl 322 set ref 341*
gap_arg_ptr                     000162 automatic       pointer                  initial dcl 321 set ref 321* 341* 345
gap_code                        000165 automatic       fixed bin(35,0)          initial dcl 323 set ref 323* 341* 342 342*
gap_ndims                       000166 automatic       fixed bin(17,0)          dcl 324 set ref 333*
gap_p_arg_idx                          parameter       fixed bin(17,0)          dcl 318 set ref 315 333* 335* 341* 342*
gap_p_arg_list_ptr                     parameter       pointer                  dcl 317 set ref 315 333* 341*
gap_p_required_type                    parameter       fixed bin(17,0)          dcl 319 set ref 315 330 335 335*
gap_packed                      000167 automatic       bit(1)                   dcl 325 set ref 333*
gap_scale                       000170 automatic       fixed bin(17,0)          dcl 326 set ref 333*
gap_size                        000171 automatic       fixed bin(17,0)          dcl 327 set ref 333*
gap_type                        000172 automatic       fixed bin(17,0)          dcl 328 set ref 333* 335 335*
header                                 based           structure                level 2 dcl 5-5
ioa_$general_rs                 000024 constant        entry                    external dcl 135 ref 302
is_dimension_value              000115 automatic       bit(1)                   dcl 68 set ref 239* 245* 245 251
len                             000103 automatic       fixed bin(21,0)          level 2 dcl 289 set ref 302*
length                                                 builtin function         dcl 97 ref 217 220 300 304
max                                                    builtin function         dcl 97 ref 217 220
maximum_dimension_name_length
                          4            based           fixed bin(17,0)          level 2 dcl 1-21 set ref 232* 235 235 235 236 236
                                                                                  236 237 237 237 256 256 256 263 263 263 269 269
                                                                                  269 276 276 276
name                      6            based           varying char             array level 3 dcl 1-21 set ref 263* 269* 276*
names_given                     000116 automatic       bit(1)                   initial dcl 69 set ref 69* 184* 198* 242
nargs                           000117 automatic       fixed bin(17,0)          dcl 70 set ref 154* 155 158 159* 164 165 186 186*
                                                                                  210 242
ndims                           000120 automatic       fixed bin(17,0)          dcl 71 set ref 178* 211* 246*
null                                                   builtin function         dcl 97 ref 63 74 150 159 159 186 186 199 199 235 286
                                                                                  304 304 310 321
number_of_dimensions      1            based           fixed bin(17,0)          level 2 dcl 1-21 set ref 232* 235 236 237 276
number_of_name_args             000121 automatic       fixed bin(17,0)          initial dcl 72 set ref 72* 158* 159 199 199* 207
number_of_vector_slots
                          3            based           fixed bin(17,0)          level 2 dcl 1-21 set ref 232*
number_of_vectors         2            based           fixed bin(17,0)          level 2 dcl 1-21 set ref 234*
p_code                                 based           fixed bin(35,0)          dcl 87 set ref 169*
p_code_ptr                      000122 automatic       pointer                  dcl 73 set ref 167* 169
p_typed_vector_array_ptr               based           pointer                  dcl 88 set ref 278* 310
p_typed_vector_array_ptr_ptr    000124 automatic       pointer                  initial dcl 74 set ref 74* 176* 278 310
packed                          000126 automatic       bit(1)                   dcl 76 set ref 178* 211* 246*
pointer_desc                    000002 constant        fixed bin(17,0)          initial dcl 2-1 set ref 171* 176*
ptr_template                           based           pointer                  dcl 90 ref 171
rtrim                                                  builtin function         dcl 97 ref 217 220 263 269
s_fixed_real_desc                      constant        fixed bin(17,0)          initial dcl 2-1 set ref 167* 173* 179 193*
s_fixed_real_template                  based           fixed bin(17,0)          dcl 91 ref 173 182 193
scale                           000127 automatic       fixed bin(17,0)          dcl 77 set ref 178* 211* 246*
size                            000130 automatic       fixed bin(17,0)          dcl 78 set ref 178* 211* 217 246* 263
str                       1     000103 automatic       char(1024)               level 2 packed unaligned dcl 289 set ref 300 302*
                                                                                  304
sub_err_                        000026 constant        entry                    external dcl 137 ref 159 186 199 304
tva_maximum_dimension_name_length
                                000150 automatic       fixed bin(17,0)          dcl 1-48 set ref 193* 209* 217* 217 220* 220 232 232
tva_number_of_dimensions        000147 automatic       fixed bin(17,0)          dcl 1-46 set ref 182* 207* 232 232
tva_number_of_vector_slots      000146 automatic       fixed bin(17,0)          dcl 1-44 set ref 173* 232 232
tva_ptr_arg_idx                 000131 automatic       fixed bin(17,0)          dcl 79 set ref 165* 176*
type                            000132 automatic       fixed bin(17,0)          dcl 80 set ref 178* 179 211* 217 220 224* 246* 259
                                                                                  265 271*
typed_vector_array                     based           structure                level 1 dcl 1-21 set ref 232
typed_vector_array_ptr          000144 automatic       pointer                  dcl 1-43 set ref 150* 232* 233 234 235 236 237 256
                                                                                  263 269 276 278 310 310 310*
v_char_desc                     000000 constant        fixed bin(17,0)          initial dcl 2-1 set ref 220 224* 265 271*
v_char_template                        based           varying char             dcl 92 ref 220 269
version                                based           fixed bin(35,0)          level 2 dcl 1-21 set ref 233*
work_area                              based           area(1024)               dcl 93 ref 232 254
work_area_ptr                   000134 automatic       pointer                  dcl 81 set ref 171* 232 254 310*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 3-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 3-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 3-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 3-7
D_fixed_cplx_desc                      internal static fixed bin(17,0)          initial dcl 2-1
D_fixed_real_desc                      internal static fixed bin(17,0)          initial dcl 2-1
D_float_cplx_desc                      internal static fixed bin(17,0)          initial dcl 2-1
D_float_real_desc                      internal static fixed bin(17,0)          initial dcl 2-1
Envptr_supplied_call_type              internal static fixed bin(18,0)          initial unsigned unaligned dcl 5-29
Interseg_call_type                     internal static fixed bin(18,0)          initial unsigned unaligned dcl 5-29
Quick_call_type                        internal static fixed bin(18,0)          initial unsigned unaligned dcl 5-29
area_desc                              internal static fixed bin(17,0)          initial dcl 2-1
arg_list_with_envptr                   based           structure                level 1 dcl 5-17
bit_desc                               internal static fixed bin(17,0)          initial dcl 2-1
d_fixed_cplx_desc                      internal static fixed bin(17,0)          initial dcl 2-1
d_fixed_real_desc                      internal static fixed bin(17,0)          initial dcl 2-1
d_float_cplx_desc                      internal static fixed bin(17,0)          initial dcl 2-1
d_float_real_desc                      internal static fixed bin(17,0)          initial dcl 2-1
desc_                                  automatic       structure                level 1 dcl 4-3
entry_desc                             internal static fixed bin(17,0)          initial dcl 2-1
error_table_$badcall                   external static fixed bin(35,0)          dcl 141
file_desc                              internal static fixed bin(17,0)          initial dcl 2-1
label_desc                             internal static fixed bin(17,0)          initial dcl 2-1
offset_desc                            internal static fixed bin(17,0)          initial dcl 2-1
s_fixed_cplx_desc                      internal static fixed bin(17,0)          initial dcl 2-1
s_float_cplx_desc                      internal static fixed bin(17,0)          initial dcl 2-1
s_float_real_desc                      internal static fixed bin(17,0)          initial dcl 2-1
structure_desc                         internal static fixed bin(17,0)          initial dcl 2-1
v_bit_desc                             internal static fixed bin(17,0)          initial dcl 2-1

NAMES DECLARED BY EXPLICIT CONTEXT.
ERROR_FINISH                    002141 constant        entry                    internal dcl 308 ref 152
ERROR_RETURN                    001767 constant        entry                    internal dcl 284 ref 213 224 248 271 335 342
GET_ARG_PTR                     002170 constant        entry                    internal dcl 315 ref 167 171 173 176 182 193
MAIN_RETURN                     001765 constant        label                    dcl 279
dm_vu_init_tva                  000412 constant        entry                    external dcl 52

NAMES DECLARED BY CONTEXT OR IMPLICATION.
addr                                                   builtin function         ref 300 304
mod                                                    builtin function         ref 199

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2616        2652    2432        2626
Length      3152    2432        34         263     164           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
dm_vu_init_tva                      378 external procedure  is an external procedure.  
on unit on line 152                  80 on unit               
ERROR_RETURN                        370 internal procedure  is declared options(variable).  
ERROR_FINISH                            internal procedure  shares stack frame of on unit on line 152.  
GET_ARG_PTR                             internal procedure  shares stack frame of external procedure dm_vu_init_tva.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
ERROR_RETURN             000100 er_arg_list_ptr             ERROR_RETURN
                         000102 er_code                     ERROR_RETURN
                         000103 er_msg_struc                ERROR_RETURN
                         000504 er_nargs                    ERROR_RETURN
dm_vu_init_tva           000100 arg_idx                     dm_vu_init_tva
                         000101 arg_len                     dm_vu_init_tva
                         000102 arg_list_arg_count          dm_vu_init_tva
                         000104 arg_list_ptr                dm_vu_init_tva
                         000106 arg_ptr                     dm_vu_init_tva
                         000110 code                        dm_vu_init_tva
                         000111 code_arg_idx                dm_vu_init_tva
                         000112 descriptor_string_ptr       dm_vu_init_tva
                         000114 dim_idx                     dm_vu_init_tva
                         000115 is_dimension_value          dm_vu_init_tva
                         000116 names_given                 dm_vu_init_tva
                         000117 nargs                       dm_vu_init_tva
                         000120 ndims                       dm_vu_init_tva
                         000121 number_of_name_args         dm_vu_init_tva
                         000122 p_code_ptr                  dm_vu_init_tva
                         000124 p_typed_vector_array_ptr_ptr
                                                            dm_vu_init_tva
                         000126 packed                      dm_vu_init_tva
                         000127 scale                       dm_vu_init_tva
                         000130 size                        dm_vu_init_tva
                         000131 tva_ptr_arg_idx             dm_vu_init_tva
                         000132 type                        dm_vu_init_tva
                         000134 work_area_ptr               dm_vu_init_tva
                         000144 typed_vector_array_ptr      dm_vu_init_tva
                         000146 tva_number_of_vector_slots  dm_vu_init_tva
                         000147 tva_number_of_dimensions    dm_vu_init_tva
                         000150 tva_maximum_dimension_name_length
                                                            dm_vu_init_tva
                         000162 gap_arg_ptr                 GET_ARG_PTR
                         000164 gap_arg_len                 GET_ARG_PTR
                         000165 gap_code                    GET_ARG_PTR
                         000166 gap_ndims                   GET_ARG_PTR
                         000167 gap_packed                  GET_ARG_PTR
                         000170 gap_scale                   GET_ARG_PTR
                         000171 gap_size                    GET_ARG_PTR
                         000172 gap_type                    GET_ARG_PTR

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this_desc  return              mod_fx1             enable
ext_entry           int_entry           trunc_fx2           divide_fx1          alloc_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cu_$arg_count                 cu_$arg_list_ptr              cu_$arg_ptr_rel               decode_descriptor_
dm_vector_util_$err_no_operation                            dm_vector_util_$free_typed_vector_array
ioa_$general_rs               sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_subr_arg     error_table_$wrong_no_of_args




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     52 000411        63 000417        64 000421        69 000422        72 000423        74 000424       150 000425
    152 000426       154 000444       155 000456       156 000460       158 000467       159 000474       164 000552
    165 000554       167 000556       169 000560       171 000561       173 000566       176 000572       178 000574
    179 000617       182 000622       184 000626       186 000627       193 000712       195 000716       198 000717
    199 000721       207 000777       209 001006       210 001007       211 001017       212 001042       213 001061
    217 001106       220 001131       224 001154       228 001211       232 001214       233 001247       234 001251
    235 001252       236 001305       237 001344       239 001402       240 001404       242 001405       245 001417
    246 001422       247 001445       248 001464       251 001511       254 001513       255 001520       256 001533
    257 001556       259 001557       262 001562       263 001563       264 001625       265 001626       268 001630
    269 001631       270 001674       271 001675       275 001732       276 001735       278 001763       279 001765
    284 001766       286 001774       295 001776       296 002004       297 002016       299 002022       300 002025
    302 002032       304 002075       306 002140       308 002141       310 002142       313 002167       315 002170
    321 002172       323 002174       330 002175       333 002200       335 002224       341 002262       342 002302
    345 002330


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
