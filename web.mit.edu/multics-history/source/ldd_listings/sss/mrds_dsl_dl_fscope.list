	COMPILATION LISTING OF SEGMENT mrds_dsl_dl_fscope
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/01/88  1331.6 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 
       10 /* ******************************************************
       11*   *                                                    *
       12*   *                                                    *
       13*   * Copyright (c) 1972 by Massachusetts Institute of   *
       14*   * Technology and Honeywell Information Systems, Inc. *
       15*   *                                                    *
       16*   *                                                    *
       17*   ****************************************************** */
       18 
       19 
       20 /****^  HISTORY COMMENTS:
       21*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
       22*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
       23*     This entry is being made to cover the change made on 85-07-30 by Jim
       24*     Lippard. (see mrds #140, phx19621)
       25*                                                   END HISTORY COMMENTS */
       26 
       27 mrds_dsl_dl_fscope: dl_fscope: procedure;
       28 
       29 /*    DESCRIPTION:
       30*
       31*   This procedure deletes the user's scope of access to the database if it is open in the
       32*   shared mode.  Calling sequence is:
       33*
       34*   call dsl_$dl_fscope (db_index,rel_name,permit_ops,prevent_ops,...,rel_name,permit_ops,prevent_ops,code);
       35*
       36*   ---------------------------------------------------------------------------
       37*
       38*         
       39*   %page;
       40*   HISTORY:
       41*   Written April 28, 1976 by R. G. Luebke
       42*   Modified by Oris Friesen -- July 1977 -- to handle queueing of scope requests
       43*   Changed to dl_fscope by Oris D. Friesen - Sept. 1978 - to handle scopes at file level rather than relation level
       44*   Modified by Al Kepner, March 26, 1979, to allow deleting null fscope
       45*   from a scope tuple which is already null.
       46*   Modified by Jim Gray - - October 1979, to allow deleting null fscope
       47*   from a file that has never had scope set.
       48*   Modified by M. Pierret, December 1979, to change queueing strategy to
       49*   wake up only first waiter, and to change the use of set_lock_ in
       50*   detecting dead processes to use call by value.
       51*   Modified by Lindsey L. Spratt, February 1980, to look for match of fil_name
       52*   in rm_name_array.model_name instead of rm_name_array.name.  This is an
       53*   issue when an opening is done through a submodel and the model_name and
       54*   name are not the same.
       55*   Modified by M.Pierret 13 April 1980 to remove priority queueing.
       56*   Modified by Jim Gray - - June 1980, to not say dumb things like "no scope set"
       57*   when it is told to delete all current scope, regardless of what it is.
       58*   Modified 26 June 80 by M Pierret, changing fil_name to rel_name, file_name
       59*   to model_rel_name and clearing up name/model_name issues for submodels.
       60*   Also rewrote delete_scope, using more straightforward tests and
       61*   modifications of scope.
       62*   Modified 22 July 80 by M Pierret, removing unused variables
       63*
       64*   80-12-10 Jim Gray : added use of include file mdbm_scope_requests as part
       65*   of change from r-u to r-s-m-d type scope modes.
       66*   mdbm_scope_info and mdbm_users include files also changed as a result.
       67*   Added local declarations for actual_permits/prevents, and actual_conflicts.
       68*   The later was added to the check_conflict interface, in order
       69*   to be able to report exact details of why a dl_scope failed.
       70*
       71*   80-12-12 Jim Gray : added maintenance of the update bit in the fil_list structure.
       72*   Also, did a check for setting passive_sw in user_list on, if the delete
       73*   scope operation removed all active update type operation scope permission.
       74*
       75*   80-12-15 Jim Gray : fixed error routine to set users error code parameter.
       76*
       77*   80-12-30 Jim Gray : fixed routine sufficient_scope_exists, to look for model
       78*   rather than submodel name in fil_list list, since submodel names are not
       79*   known here. This allows close -all to work with submodels that have alias rel names.
       80*
       81*   81-1-11 Jim Gray : added reseting of touched bit, when del scope request
       82*   resulted in no more scope being set for a relation.
       83*   This allows displaying when null scope has been set.
       84*
       85*   81-05-29 Jim Gray : changed to use new resultant model structures.
       86*
       87*   81-12-15 R. Lackey : Modified to search rm_rel_array correctly for ful rel_name. TR11887.
       88*
       89*   82-01-08 R. Lackey : Added check to detect relation names longer then 30 characters.
       90*
       91*   82-10-01 Mike Kubicar : Converted to use relation manager.  Specifically
       92*   this meant changing this module to calculate the total scopes set on a
       93*   relation/database for the current process and pass that to relation
       94*   manager.  If changing scopes for on db opening does not change the total
       95*   scopes for the process, the relation manager call is not made as it
       96*   wouldn't be needed.
       97*
       98*   82-12-10 Davids: Modified the declarations of new_rmg_permits
       99*   and new_rmg_prevents to bit (2) aligned from unaligned. This was
      100*   needed because the declaration of the relation manager entries
      101*   in the dbcb was changed from options variable to reality. 
      102*
      103*   83-02-02 Davids: Added a call to hcs_$get_uid_seg to compare the uid of the
      104*   segment the dbc_ptr currently points at with what it was originally. If the
      105*   uids don't match or the uid cannot be obtained it is assumed that the
      106*   original segment was deleted. There is no need to delete any scopes so this
      107*   routine just returns without errors.
      108*
      109*   83-02-07 Davids: Modified the delete_scope internal procedure to 
      110*   create a copy of the rmri_ptr instead of using the copy in the fil_list
      111*   structure. This is needed because the ring brackets of the db.control
      112*   segment which is where the fil_list is kept may be 5,5,5 in which case the 
      113*   pointer cannot be used to reference the rm_rel_info structure which is in
      114*   the resultant and may have different ring brackets, i.e. 4,4,4.
      115*
      116*   85-07-30 Jim Lippard: Modified the cleanup handler to dequeue active
      117*   users.  If the user tried to delete scope on a relation for which he
      118*   didn't have scope set and he was listed as an active user, he would be
      119*   left in the active users list.  Later calls to set_scope resulted in
      120*   infinite loops.
      121*
      122*   ------------------------------------------------------------------------- */
      123 
      124 	dbc_ptr = null;				/* in case cleanup is called before dbc_ptr is set */
      125 	num_filns = 0;
      126 	entry_name = "dl_fscope";			/* normal entry */
      127 	args_exp = 5;				/* 5 calling arguments */
      128 
      129 	call cu_$arg_count (nargs);			/* get number of arguments */
      130 	if nargs < args_exp
      131 	then signal arg_error;			/* must be at least args_exp arguments (1 scope tuple */
      132 						/* plus db_index plus code */
      133 
      134 	call cu_$arg_ptr (nargs, cd_ptr, arg_len, icode); /* get pointer to last arg (code) */
      135 	if icode ^= 0
      136 	then signal arg_error;
      137 	code = 0;
      138 	call cu_$arg_ptr (1, dbi_ptr, arg_len, icode);	/* get db_index */
      139 	if icode ^= 0
      140 	then call error (icode);
      141 
      142 common_label:
      143 	call mu_database_index$get_resultant_model_pointer (db_index, dbcb_ptr);
      144 						/* get dbcb_ptr corresponding to db_index */
      145 	if dbcb_ptr = null ()
      146 	then call error (mrds_error_$invalid_db_index);
      147 
      148 pntr2:						/* entry here => dbc already locked by mrds_dsl_close */
      149 
      150 /* Get pointers, see if user has some files readied (scope_ptr non-null) and make sure user has no active scope. */
      151 
      152 	icode = 0;
      153 	call hcs_$get_uid_seg (dbcb.dbc_ptr, temp_uid, icode);
      154 	if icode ^= 0				/* if you cannot get the uid of the data base control */
      155 	then do;					/* assume its been deleted. Return without errors since */
      156 		code = 0;				/* the scopes have certainly been deleted */
      157 		goto exit;
      158 	     end;
      159 	if temp_uid ^= dbcb.dbc_uid			/* if the uid's don't match the original control segment */
      160 	then do;					/* was deleted and the segment number reused. Again don't */
      161 		code = 0;				/* do anything */
      162 		goto exit;
      163 	     end;
      164 	dbc_ptr = dbcb.dbc_ptr;			/* pointer to data base control segment */
      165 	on cleanup call clean_up;
      166 
      167 	if dbcb.scope_ptr = null
      168 	then call error (mrds_error_$non_scope_ready);
      169 	scope_ptr = dbcb.scope_ptr;
      170 	rdbi_ptr = dbcb.rdbi_ptr;
      171 	rmra_ptr = rm_db_info.ra_ptr;
      172 
      173 	if scope_info.active_scopes = 0
      174 	then call error ((mrds_error_$scope_empty));
      175 
      176 /* Lock the DBC. (If entry was from dl_fscope_all_ptr, dbc is already locked) */
      177 
      178 	if entry_name ^= "dl_fscope_all_pntr"
      179 	then call set_lock_$lock (dbc.scope_lock, (mrds_data_$lock_wait_time), icode);
      180 						/* lock scope portion of dbc */
      181 	if icode = error_table_$invalid_lock_reset | icode = error_table_$locked_by_this_process
      182 	then icode = 0;				/* ignore these error codes */
      183 	if icode ^= 0
      184 	then do;					/* something is messed up in the dbc */
      185 		dbc.trouble_switch = ON;		/* lock it to prevent further opens */
      186 		call error (icode);
      187 	     end;
      188 
      189 /* Find user in user_list list */
      190 
      191 	find_ul_ptr = convert (dbc_ptr, dbc.active_users_ofs);
      192 	ul_ptr = null;
      193 
      194 	my_pid = get_process_id_ ();
      195 	do while (find_ul_ptr ^= null);
      196 	     if find_ul_ptr -> user_list.process_id = my_pid
      197 	     then do;
      198 		     if find_ul_ptr -> user_list.rdbi_bits = addr (rdbi_ptr) -> ptr_bit_string
      199 		     then do;
      200 			     ul_ptr = find_ul_ptr;
      201 			     find_ul_ptr = null;
      202 			end;
      203 		     else find_ul_ptr = convert (dbc_ptr, find_ul_ptr -> user_list.next_active_ofs);
      204 		end;
      205 	     else find_ul_ptr = convert (dbc_ptr, find_ul_ptr -> user_list.next_active_ofs);
      206 	end;
      207 
      208 
      209 	if ul_ptr = null
      210 	then call error (mrds_error_$unknown_proc_id);
      211 
      212 /* =======Enclosed code is executed only if entry was from dl_fscope====== */
      213 
      214 	if entry_name = "dl_fscope"
      215 	then do;
      216 		if mod (nargs - 2, 3) = 0
      217 		then num_tuples = divide (nargs - 2, 3, 17);
      218 		else call error (error_table_$wrong_no_of_args);
      219 
      220 
      221 		make_user_inactive = OFF;
      222 
      223 		do i = 1 to num_tuples;		/* iterate once for each scope tuple */
      224 		     arg_index = 3 * (i - 1) + 2;	/* move arg_index to point to 1st arg of scope tuple i */
      225 		     call cu_$arg_ptr (arg_index, rel_ptr, rel_len, icode);
      226 						/* get relation name */
      227 		     if icode ^= 0
      228 		     then call error (icode);
      229 
      230 
      231 /* BEGIN 82-01-08 Roger Lackey ********************************************* */
      232 
      233 		     if length (rtrim (rel_name)) > 30 then call error (mrds_error_$rel_name_too_long);
      234 
      235 /* END   82-01-08 Roger Lackey ********************************************* */
      236 
      237 
      238 /* Since relation names stored in the dbc are stored by the name the data model knows (as opposed to the name known
      239*   by a submodel view) and the user may request scope giving the relation name seen in his view (rel_name), the model relation
      240*   name must be found.  rm_rel_array.rel_data.name holds the name in the user's view, and rm_rel_array.rel_data.model_name
      241*   holds the coresponding relation name in the model.  When rel_name is found, model_rel_name is set to rm...model_name */
      242 
      243 /* BEGIN CHANGE 81-12-15 RDL *********************************************** */
      244 
      245 		     rel_name_32 = rel_name;		/* Used to search rm_rel_array */
      246 		     pos_in_rmfa = index (string (rm_rel_array.name), "!" || rel_name_32);
      247 
      248 /* BEGIN CHANGE 81-12-15 RDL *********************************************** */
      249 
      250 		     if pos_in_rmfa = 0 then do;
      251 			     call sub_err_ (mrds_error_$unknown_relation_name, caller_name, continue, info_ptr, return_value,
      252 				"^/^a^a^a", "The relation name """, rel_name,
      253 				""" was not found in the users view of the database.");
      254 			     call error (mrds_error_$unknown_relation_name);
      255 			end;
      256 		     else do;
      257 			     pos_in_rmfa = ((pos_in_rmfa - 1) / 33) + 1;
      258 			     model_rel_name = rm_rel_array.rel_data.model_name (pos_in_rmfa);
      259 						/* Save rel name as per model */
      260 			end;
      261 
      262 		     rmri_ptr = rm_rel_array.rel_data.ri_ptr (pos_in_rmfa);
      263 
      264 		     if rm_rel_info.ready_mode < 5	/* ready_mode must be =5(scope_retrieve)
      265*						   or = 6 (scope_update)   */
      266 		     then call error (mrds_error_$non_scope_ready);
      267 
      268 /* Get permit, prevent ops */
      269 
      270 		     call cu_$arg_ptr (arg_index + 1, permit_requests_ptr, arg_len, icode);
      271 						/* get permit operations */
      272 		     if icode ^= 0
      273 		     then call error (icode);
      274 
      275 		     call cu_$arg_ptr (arg_index + 2, prevent_requests_ptr, arg_len, icode);
      276 						/* get prevent operations */
      277 		     if icode ^= 0
      278 		     then call error (icode);
      279 
      280 /* Check for existence of relation in scope_info array, and then if adequate scope exists for that relation.
      281*   scope_info.scope.name holds names of relations as per the data model, hence the check is made with model_rel_name */
      282 
      283 		     do pos_in_si = 1 to scope_info.nfiles /* look for model_rel_name in file table */
      284 			while (model_rel_name ^= scope_info.scope.name (pos_in_si));
      285 		     end;
      286 		     if pos_in_si > scope_info.nfiles	/* didn't find model_rel_name in view */
      287 		     then call error (mrds_error_$unknown_relation_name);
      288 
      289 		     if ^sufficient_scope_exists () then do; /* check that scope exists as it is to be deleted */
      290 			     call report_scope_detail ();
      291 			     call error (mrds_error_$scope_not_found);
      292 			end;
      293 
      294 /* Ready to delete */
      295 
      296 		     call delete_scope;		/* OK, so delete */
      297 		end;
      298 	     end;
      299 
      300 /* ------------END of dl_fscope block; goto COMMON -------------------- */
      301 
      302 /* ============BEGIN code for dl_fscope_all(_pntr)===================== */
      303 
      304 	if entry_name = "dl_fscope_all" | entry_name = "dl_fscope_all_pntr"
      305 	then do;
      306 
      307 /* note that it OK to delete_scope_all even when all files are not
      308*   using scope modes, just as it is OK to delete all scope when no scope is set */
      309 
      310 
      311 		do pos_in_si = 1 to scope_info.nfiles;
      312 		     scope_info.scope (pos_in_si).flags = "0"b;
      313 		end;
      314 
      315 		scope_info.active_scopes = 0;
      316 		make_user_inactive = ON;
      317 
      318 	     end;
      319 
      320 /* ---END of dl_fscope_all block ---- */
      321 
      322 /* ====COMMON==== */
      323 
      324 	if make_user_inactive			/* unlink from active user list */
      325 	then call mu_de_queue_user (NO_DQ_OPEN, FREE_FIL_LIST, dbc_ptr, ul_ptr, icode);
      326 	if icode ^= 0
      327 	then call error (icode);
      328 
      329 /* Finished deleting scope, now notify a waiting process that it may proceed to set scope */
      330 
      331 	call examine_queue;
      332 
      333 	code = 0;
      334 
      335 	if entry_name ^= "dl_fscope_all_pntr"
      336 	then call set_lock_$unlock (dbc.scope_lock, code);/* unlock scope lock */
      337 exit:
      338 	return;
      339 
      340 mrds_dsl_dl_fscope_all:
      341 dl_fscope_all:
      342      entry (a_db_index, a_code);
      343 
      344 /* call dsl_$mrds_dsl_dl_fscope_all (db_index, code);
      345*
      346**/
      347 	dcl     a_db_index		 fixed bin;	/* db$ata base index */
      348 	dcl     a_code		 fixed bin (35);	/* return code */
      349 
      350 	dbc_ptr = null;				/* in case cleanup is called before dbc_ptr is set */
      351 	dbi_ptr = addr (a_db_index);
      352 	cd_ptr = addr (a_code);
      353 
      354 	args_exp = 2;				/* two calling arguments */
      355 	entry_name = "dl_fscope_all";
      356 	goto common_label;
      357 
      358 pntr:
      359 dl_fscope_all_pntr:
      360 mrds_dsl_scope_all_pntr:
      361      entry (a_dbcb_ptr, a_cd_ptr);
      362 
      363 /*
      364*   call dsl_$mrds_dsl_dl_fscope_all_pntr (dbcb_ptr, code_ptr);
      365*
      366*   this entry allows dl_fscope_all to be called with ptr arguments only
      367**/
      368 
      369 	dcl     (
      370 	        a_dbcb_ptr,				/* ptr to dbcb */
      371 	        a_cd_ptr
      372 	        )			 ptr;		/* ptr to status return code */
      373 
      374 	entry_name = "dl_fscope_all_pntr";
      375 	dbc_ptr = null;				/* in case cleanup is called before dbc_ptr is set */
      376 	args_exp = 2;
      377 	dbcb_ptr = a_dbcb_ptr;
      378 	cd_ptr = a_cd_ptr;
      379 	goto pntr2;
      380 
      381 error:
      382      procedure (temp_code);
      383 
      384 	dcl     temp_code		 fixed bin (35);
      385 
      386 	if temp_code = mrds_error_$scope_empty & entry_name = "dl_fscope_all"
      387 	then cd_ptr -> code = 0;
      388 	else cd_ptr -> code = temp_code;
      389 
      390 	call clean_up;
      391 	go to exit;
      392 
      393      end error;
      394 
      395 examine_queue:
      396      proc;
      397 
      398 /*
      399*   This routine will scan the priority and normal waiting queues until it comes across a waiting process that is
      400*   eligble to set scope (ie, the scope requested does not conflict with current scopes now that the deleting process
      401*   has deleted its scope).  If it  finds one such process, it will send it a wakeup, notifying it that it can proceed
      402*   to set scope.  Only one (or none) such process will be awakened; it is the newly awakened process's job to see if
      403*   another waiter is eligble to be awakened.
      404**/
      405 
      406 	wakeup = OFF;				/* ON->wake this user up */
      407 	QUE_FREE = fixed (unspec (CHAR_Q_F), 71);	/*  Wakeup message */
      408 
      409 /* Check each waiting user. */
      410 
      411 	ul_ptr = convert (dbc_ptr, dbc.waiting_users_ofs);
      412 
      413 	do while (ul_ptr ^= null & ^wakeup);
      414 
      415 	     if ^user_list.event_signal_sw		/* no awakeners */
      416 	     then do;
      417 
      418 /* Check each relation(file) for conflict. */
      419 
      420 		     fl_ptr = convert (dbc_ptr, user_list.fil_list_ofs);
      421 		     wakeup = ON;
      422 		     conflict_sw = OFF;
      423 
      424 		     do while (fl_ptr ^= null & ^conflict_sw);
      425 
      426 			model_rel_name = fil_list.name;
      427 
      428 			unspec (actual_permits), unspec (actual_prevents) = "0"b; /* init */
      429 
      430 			actual_permits.read_attr = fil_list.permits.read_attr;
      431 			actual_permits.modify_attr = fil_list.permits.modify_attr;
      432 			actual_permits.append_tuple = fil_list.permits.append_tuple;
      433 			actual_permits.delete_tuple = fil_list.permits.delete_tuple;
      434 
      435 			actual_prevents.read_attr = fil_list.prevents.read_attr;
      436 			actual_prevents.modify_attr = fil_list.prevents.modify_attr;
      437 			actual_prevents.append_tuple = fil_list.prevents.append_tuple;
      438 			actual_prevents.delete_tuple = fil_list.prevents.delete_tuple;
      439 
      440 			call mu_check_scope (dbc_ptr, addr (model_rel_name), ul_ptr, addr (actual_permits),
      441 			     addr (actual_prevents), addr (unused_conflict_detail),
      442 			     conflict_sw, conflict_ul_ptr);
      443 
      444 
      445 /* if there was a conflict, see if it is because of a dead process.
      446*   if there is a dead process that was passive, it will be de-queued and this process will continue checking the files;
      447*   if dead proc was updating (non-passive) this process will awaken waiting user-where its attempt to set will fail;
      448*   if no dead proc, stop checking the files because there is a conflict with a live user, but continue checking */
      449 
      450 
      451 			if conflict_sw		/* There was conflict */
      452 			then do;
      453 				call check_dead_proc (conflict_sw, status);
      454 				if conflict_sw
      455 				then wakeup = OFF;	/* conflict was not worked out */
      456 			     end;
      457 
      458 			fl_ptr = convert (dbc_ptr, fil_list.next_ofs);
      459 		     end;
      460 
      461 /* Send the wakeup if user is eligble. */
      462 
      463 		     if wakeup
      464 		     then do;
      465 			     call hcs_$wakeup (user_list.process_id, user_list.ev_chn_id, QUE_FREE, state);
      466 			     if state ^= 0
      467 			     then wakeup = OFF;
      468 			     else do;
      469 				     user_list.event_signal_sw = ON;
      470 				     dbc.wakeup_waiters = dbc.wakeup_waiters + 1;
      471 				end;
      472 			end;
      473 
      474 /* A record of how many times this process was examined and NOT awakened is kept.  After a set limit is
      475*   surpassed (allowance_count) the process is made high priority. */
      476 
      477 		     if ^wakeup
      478 		     then do;
      479 			     user_list.bypass_count = user_list.bypass_count + 1;
      480 			     if user_list.bypass_count >= user_list.allowance_count
      481 			     then user_list.priority_high = ON;
      482 			end;
      483 		end;
      484 
      485 	     ul_ptr = convert (dbc_ptr, user_list.next_waiting_ofs);
      486 						/* Next user */
      487 	end;
      488 
      489 
      490      end examine_queue;
      491 
      492 check_dead_proc:
      493      proc (conflict_sw, status);
      494 
      495 /* this checks for a potential stiff (dead process -- pointed to by conflict_ul_ptr ) and does what it can about it.
      496*   if the process is dead and was a passive user, that process is de-queued and the dbc is somewhat cleaned up.
      497*   if the process was non-passive then it could have died in the middle of an update and this running process
      498*   can't do anything about it */
      499 
      500 	dcl     (conflict_sw, status)	 bit (1);
      501 
      502 
      503 /* Determine if process is alive or dead.  the technology for doing this is
      504*   by calling set_lock_$lock and examining the returned code */
      505 
      506 	if conflict_ul_ptr -> user_list.dead_proc
      507 	then status = DEAD;
      508 	else do;
      509 		status = ALIVE;
      510 		call set_lock_$lock ((conflict_ul_ptr -> user_list.db_lock_id), 0, state);
      511 						/* Note that the lock_id arg is passed by value
      512*						   so that the lock is not really set. */
      513 		if state ^= 0
      514 		then do;
      515 			if state = error_table_$invalid_lock_reset
      516 			then status = DEAD;
      517 			else if state = error_table_$locked_by_this_process
      518 			     | state = error_table_$lock_wait_time_exceeded
      519 			then status = ALIVE;
      520 			else icode = state;
      521 		     end;
      522 	     end;
      523 
      524 /* Now see what can be done if it is dead */
      525 
      526 	if status = ALIVE
      527 	then ;
      528 	else if conflict_ul_ptr -> user_list.passive_sw
      529 	then do;
      530 		conflict_sw = OFF;
      531 		call mu_de_queue_user (DQ_OPEN, FREE_FIL_LIST, dbc_ptr, conflict_ul_ptr, icode);
      532 	     end;
      533 
      534 	else do;
      535 		dbc.dead_proc_flag = ON;
      536 		conflict_ul_ptr -> user_list.dead_proc = ON;
      537 		user_list.dead_proc_conflict = ON;
      538 	     end;
      539 
      540 	if icode ^= 0
      541 	then call error (icode);
      542 
      543 	return;
      544 
      545      end check_dead_proc;
      546 
      547 report_scope_detail: procedure ();
      548 
      549 /* this rotuine reports on exactly why sufficient scope was not found
      550*   for this delete operation to be performed */
      551 
      552 	if conflict_detail_known then do;
      553 
      554 		permit_conflict = "";
      555 
      556 		if actual_conflict_detail.permits.read_attr then
      557 		     permit_conflict = permit_conflict || "read_attr ";
      558 
      559 		if actual_conflict_detail.permits.modify_attr then
      560 		     permit_conflict = permit_conflict || "modify_attr ";
      561 
      562 		if actual_conflict_detail.permits.append_tuple then
      563 		     permit_conflict = permit_conflict || "append_tuple ";
      564 
      565 		if actual_conflict_detail.permits.delete_tuple then
      566 		     permit_conflict = permit_conflict || "delete_tuple ";
      567 
      568 		if permit_conflict = "" then
      569 		     permit_conflict = "null ";
      570 
      571 		prevent_conflict = "";
      572 
      573 		if actual_conflict_detail.prevents.read_attr then
      574 		     prevent_conflict = prevent_conflict || "read_attr ";
      575 
      576 		if actual_conflict_detail.prevents.modify_attr then
      577 		     prevent_conflict = prevent_conflict || "modify_attr ";
      578 
      579 		if actual_conflict_detail.prevents.append_tuple then
      580 		     prevent_conflict = prevent_conflict || "append_tuple ";
      581 
      582 		if actual_conflict_detail.prevents.delete_tuple then
      583 		     prevent_conflict = prevent_conflict || "delete_tuple ";
      584 
      585 		if prevent_conflict = "" then
      586 		     prevent_conflict = "null ";
      587 
      588 		call sub_err_ (mrds_error_$scope_not_found, caller_name, continue, info_ptr, return_value,
      589 		     "^/^a^a^a^/^a^a^a^a^a",
      590 		     "The scope delete request contained extra permits of """, permit_conflict,
      591 		     """", "and/or extra prevents of """, prevent_conflict,
      592 		     """ that were not present in the scope currently set, on the relation """,
      593 		     conflict_relation, """.");
      594 
      595 	     end;
      596 
      597 	return;
      598 
      599 
      600 	declare (permit_conflict, prevent_conflict) char (80) varying; /* extra scope that was not present */
      601 
      602      end;
      603 
      604 sufficient_scope_exists:
      605      procedure () returns (bit (1));
      606 
      607 /*	This procedure checks to be sure the scope to be deleted in fact exists	*/
      608 
      609 	dcl     found		 bit (1);		/* ON => relation name found */
      610 
      611 /* find the specified relation */
      612 	fl_ptr = convert (dbc_ptr, user_list.fil_list_ofs);
      613 
      614 	found = OFF;
      615 	do while (^found);
      616 	     if fl_ptr = null ()
      617 	     then found = ON;
      618 	     else if model_rel_name = fil_list.name
      619 	     then found = ON;
      620 	     else fl_ptr = convert (dbc_ptr, fil_list.next_ofs);
      621 	end;
      622 
      623 /* Check the current scope */
      624 
      625 	suf_scope = "1"b;				/* assume innocent til proven guilty */
      626 	if fl_ptr = null then do;
      627 		actual_conflict_detail.permits = permit_requests;
      628 		actual_conflict_detail.prevents = prevent_requests;
      629 
      630 		if permit_requests.modify_attr | permit_requests.read_attr |
      631 		     permit_requests.append_tuple | permit_requests.delete_tuple |
      632 		     prevent_requests.modify_attr | prevent_requests.read_attr |
      633 		     prevent_requests.append_tuple | prevent_requests.delete_tuple
      634 		then do;
      635 			suf_scope = "0"b;		/* non-null scope deletion requested */
      636 		     end;
      637 		else suf_scope = "1"b;		/* it's ok to dl null scope on a
      638*						   rel that never had scope set */
      639 	     end;
      640 
      641 	else do;
      642 		conflict_detail_ptr = addr (actual_conflict_detail);
      643 		call mu_check_conflict (DEL, fl_ptr, permit_requests_ptr, prevent_requests_ptr,
      644 		     conflict_detail_ptr, conflict_sw);
      645 		if conflict_sw then do;
      646 			suf_scope = "0"b;
      647 			conflict_detail_known = "1"b;
      648 			conflict_relation = rel_name;
      649 		     end;
      650 	     end;
      651 
      652 	return (suf_scope);
      653 
      654 	declare suf_scope		 bit (1);		/* on => suf scope exists */
      655 
      656      end sufficient_scope_exists;
      657 
      658 delete_scope: procedure;
      659 
      660 /*    This routine deletes scope by updating accss bits in scope_info and dbc (fil_list), removes relation from dbc (fil_list)
      661*   if all scope is deleted and flags the user to be deactivated if all scope on all relations is deleted. */
      662 
      663 	dcl     (found_matching_fil_list, active_scope_seen, finished) bit (1);
      664 	dcl     ds_rmri_ptr		 ptr;		/* pointer to the rm_rel_info structure */
      665 
      666 /* Update resultant model scope_info -- access bits. */
      667 
      668 	if permit_requests.read_attr then
      669 	     scope_info.scope (pos_in_si).flags.permits.read_attr = OFF;
      670 
      671 	if permit_requests.modify_attr then
      672 	     scope_info.scope (pos_in_si).flags.permits.modify_attr = OFF;
      673 
      674 	if permit_requests.append_tuple then
      675 	     scope_info.scope (pos_in_si).flags.permits.append_tuple = OFF;
      676 
      677 	if permit_requests.delete_tuple then
      678 	     scope_info.scope (pos_in_si).flags.permits.delete_tuple = OFF;
      679 
      680 	if prevent_requests.read_attr then
      681 	     scope_info.scope (pos_in_si).flags.prevents.read_attr = OFF;
      682 
      683 	if prevent_requests.modify_attr then
      684 	     scope_info.scope (pos_in_si).flags.prevents.modify_attr = OFF;
      685 
      686 	if prevent_requests.append_tuple then
      687 	     scope_info.scope (pos_in_si).flags.prevents.append_tuple = OFF;
      688 
      689 	if prevent_requests.delete_tuple then
      690 	     scope_info.scope (pos_in_si).flags.prevents.delete_tuple = OFF;
      691 
      692 	if string (scope_info.scope (pos_in_si).flags.prevents) = "0"b &
      693 	     string (scope_info.scope (pos_in_si).flags.permits) = "0"b then
      694 	     scope_info.scope (pos_in_si).flags.touched = OFF;
      695 
      696 /* Find relation in fil_list list */
      697 
      698 	fl_ptr = convert (dbc_ptr, user_list.fil_list_ofs);
      699 	flo_ptr = addr (user_list.fil_list_ofs);
      700 	found_matching_fil_list = OFF;
      701 
      702 	do while (fl_ptr ^= null & ^found_matching_fil_list);
      703 	     if model_rel_name = fil_list.name
      704 	     then found_matching_fil_list = ON;
      705 	     else do;
      706 		     flo_ptr = addr (fil_list.next_ofs);/* save ptr for possible alteration next time around */
      707 		     fl_ptr = convert (dbc_ptr, fil_list.next_ofs);
      708 		end;
      709 	end;
      710 
      711 /* Tell relation manager about the scope change if necessary.  Calculate
      712*   scopes both before and after the deletion and call rel_mgr_ only if
      713*   they are different */
      714 
      715 	if fl_ptr ^= null
      716 	then do;					/*  if it is null, then there was no scope
      717*						   to be deleted for this fil */
      718 		call calc_process_scopes (/* Find relmgr scope */
      719 		     convert (dbc_ptr, dbc.active_users_ofs),
      720 		     model_rel_name, addr (rdbi_ptr) -> ptr_bit_string,
      721 		     other_rmg_permits, other_rmg_prevents, current_rmg_permits,
      722 		     current_rmg_prevents);
      723 		old_rmg_permits = other_rmg_permits | current_rmg_permits;
      724 		old_rmg_prevents = other_rmg_prevents | current_rmg_prevents;
      725 		new_rmg_permits = other_rmg_permits |
      726 		     (permit_requests.read_attr || (permit_requests.append_tuple
      727 		     | permit_requests.modify_attr
      728 		     | permit_requests.delete_tuple));
      729 		new_rmg_prevents = other_rmg_permits |
      730 		     (^prevent_requests.read_attr ||
      731 		     ^(prevent_requests.append_tuple
      732 		     & prevent_requests.delete_tuple
      733 		     & prevent_requests.modify_attr));
      734 		if (old_rmg_permits ^= new_rmg_permits) |
      735 		     (old_rmg_prevents ^= new_rmg_prevents) then do;
      736 			ds_rmri_ptr = pointer (baseptr (baseno (fil_list.rmri_ptr)), rel (fil_list.rmri_ptr));
      737 			call dbcb.relmgr_entries.set_scope (ds_rmri_ptr -> rm_rel_info.opening_id,
      738 			     new_rmg_permits, new_rmg_prevents, icode);
      739 			if icode ^= 0
      740 			then call error (icode);
      741 		     end;
      742 
      743 
      744 /* Update dbc scope info -- fil_list access bits. */
      745 
      746 		if string (scope_info.scope.flags (pos_in_si)) = "0"b
      747 		then do;				/* all scope for this relation is being deleted */
      748 			scope_info.active_scopes = scope_info.active_scopes - 1;
      749 						/* so indicate one less scope tuple */
      750 			flo_ptr -> ophset = fil_list.next_ofs;
      751 			free fil_list in (dbc.static_area);
      752 		     end;
      753 
      754 		else do;				/* scope must be modified rather than deleted */
      755 
      756 			fil_list.permits.read_attr = (fil_list.permits.read_attr &
      757 			     ^(permit_requests.read_attr));
      758 			fil_list.permits.modify_attr = (fil_list.permits.modify_attr &
      759 			     ^(permit_requests.modify_attr));
      760 			fil_list.permits.append_tuple = (fil_list.permits.append_tuple &
      761 			     ^(permit_requests.append_tuple));
      762 			fil_list.permits.delete_tuple = (fil_list.permits.delete_tuple &
      763 			     ^(permit_requests.delete_tuple));
      764 			fil_list.permits.update = (fil_list.permits.modify_attr |
      765 			     fil_list.permits.append_tuple | fil_list.permits.delete_tuple);
      766 
      767 
      768 			fil_list.prevents.read_attr = (fil_list.prevents.read_attr &
      769 			     ^(prevent_requests.read_attr));
      770 			fil_list.prevents.modify_attr = (fil_list.prevents.modify_attr &
      771 			     ^(prevent_requests.modify_attr));
      772 			fil_list.prevents.append_tuple = (fil_list.prevents.append_tuple &
      773 			     ^(prevent_requests.append_tuple));
      774 			fil_list.prevents.delete_tuple = (fil_list.prevents.delete_tuple &
      775 			     ^(prevent_requests.delete_tuple));
      776 			fil_list.prevents.update = (fil_list.prevents.modify_attr |
      777 			     fil_list.prevents.append_tuple | fil_list.prevents.delete_tuple);
      778 		     end;
      779 	     end;
      780 
      781 	if user_list.fil_list_ofs = NULL_OFS
      782 	then make_user_inactive = ON;			/* All scope gone */
      783 
      784 	saved_fl_ptr = fl_ptr;
      785 	fl_ptr = pointer (dbc_ptr, user_list.fil_list_ofs);
      786 	active_scope_seen = OFF;
      787 	finished = OFF;
      788 	do while (^finished);
      789 
      790 	     if rel (fl_ptr) = NULL_OFS then
      791 		finished = ON;
      792 	     else if fil_list.permits.modify_attr | fil_list.permits.append_tuple |
      793 		fil_list.permits.delete_tuple then do;
      794 		     active_scope_seen = ON;
      795 		     finished = ON;
      796 		end;
      797 	     else fl_ptr = pointer (dbc_ptr, fil_list.next_ofs);
      798 	end;
      799 
      800 	if ^active_scope_seen then
      801 	     user_list.passive_sw = ON;		/* no longer holding update type of scope */
      802 
      803 
      804 	fl_ptr = saved_fl_ptr;
      805 	return;
      806 
      807      end delete_scope;
      808 
      809 convert:
      810      proc (a_ptr, ofs) returns (ptr);
      811 
      812 /* this procedure function converts an offset from "0"b to null
      813*   or from the offset value to a pointer value within the segment denoted by a_ptr
      814**/
      815 
      816 	dcl     result		 ptr;		/* the reultant pointer value */
      817 	dcl     a_ptr		 ptr;		/* ptr to the segment to which the offset refers */
      818 	dcl     ofs		 bit (18) unal;	/* the bit offset */
      819 
      820 	dcl     (null, ptr)		 builtin;
      821 
      822 	if ofs ^= NULL_OFS
      823 	then result = ptr (a_ptr, ofs);
      824 	else result = null;
      825 
      826 	return (result);
      827 
      828      end convert;
      829 
      830 
      831 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      832 /*					       */
      833 /* This routine is used to find the total scopes set by  */
      834 /* a process on a particular database.  This is needed   */
      835 /* for the relation_manager_$set_scope entry point.      */
      836 /* The routine will look through the active user list    */
      837 /* in the dbc, combining scopes for the relation of      */
      838 /* interest if there are scopes set by the current       */
      839 /* process.  The scopes for the current db opening are   */
      840 /* not included in this but are returned separately.     */
      841 /* This is so that the combined scope just before and    */
      842 /* after the scope setting can be predicted	       */
      843 /*					       */
      844 /* Parameters (input):			       */
      845 /*					       */
      846 /*  user_list_ptr - the active user list of the database */
      847 /*                  of interest.		       */
      848 /*  relation_name - the name of the relation of interest */
      849 /*  rdbi_ptr_bits - bit representation of the pointer    */
      850 /*                  to the rm_db_info structure. It is   */
      851 /*                  used to tell which scopes	       */
      852 /*                  correspond to the current opening    */
      853 /*                  id.			       */
      854 /*					       */
      855 /* Results (output)				       */
      856 /*					       */
      857 /*  relmgr_my_permits - the permits (rw) of my process   */
      858 /*                      for the database.  This would    */
      859 /*		    not include the current opening  */
      860 /*		    id.                              */
      861 /*  relmgr_other_permit - everyone else's permits	       */
      862 /*                        (prevents)		       */
      863 /*  relmgr_except_my_permits - relmgr_ permits for the   */
      864 /*                             current opening.	       */
      865 /*  relmgr_except_other_permits - the prevents for       */
      866 /*                                current	       */
      867 /*					       */
      868 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      869 
      870 
      871 calc_process_scopes:
      872      proc (user_list_ptr, relation_name, rdbi_ptr_bits, relmgr_my_permits,
      873 	relmgr_other_permits, relmgr_except_my_permits,
      874 	relmgr_except_other_permits);
      875 
      876 
      877 /* Parameters */
      878 
      879 	dcl     user_list_ptr	 ptr;
      880 	dcl     relation_name	 char (30);
      881 	dcl     rdbi_ptr_bits	 bit (72);
      882 	dcl     relmgr_my_permits	 bit (2);
      883 	dcl     relmgr_other_permits	 bit (2);
      884 	dcl     relmgr_except_my_permits bit (2);
      885 	dcl     relmgr_except_other_permits bit (2);
      886 
      887 
      888 /* Automatic */
      889 
      890 	dcl     f_ptr		 ptr;		/* Current file_list entry */
      891 	dcl     my_process_id	 bit (36);	/* My pid */
      892 	dcl     temp_relmgr_my_permits bit (2);		/* permits for one db open */
      893 	dcl     temp_relmgr_other_permits bit (2);	/* prevents */
      894 	dcl     u_ptr		 ptr;		/* Current user_list entry */
      895 
      896 
      897 	u_ptr = user_list_ptr;
      898 	my_process_id = get_process_id_ ();
      899 	relmgr_my_permits, relmgr_other_permits = "00"b;
      900 	do while (u_ptr ^= null ());			/* Search user list */
      901 	     if u_ptr -> user_list.offsets.fil_list_ofs = NULL_OFS
      902 	     then f_ptr = null ();
      903 	     else f_ptr = ptr (u_ptr,
      904 		     u_ptr -> user_list.offsets.fil_list_ofs);
      905 	     if u_ptr -> user_list.ids.process_id = my_process_id then
      906 		do while (f_ptr ^= null ());		/* Search file list */
      907 		     if f_ptr -> fil_list.name = relation_name then do;
      908 			     temp_relmgr_my_permits =
      909 				f_ptr -> fil_list.permits.read_attr ||
      910 				f_ptr -> fil_list.permits.update;
      911 			     temp_relmgr_other_permits =
      912 				^f_ptr -> fil_list.prevents.read_attr |
      913 				^(f_ptr -> fil_list.prevents.modify_attr &
      914 				f_ptr -> fil_list.prevents.append_tuple &
      915 				f_ptr -> fil_list.prevents.delete_tuple);
      916 			     if rdbi_ptr_bits ^=
      917 				u_ptr -> user_list.ids.rdbi_bits then do;
      918 				     relmgr_my_permits = relmgr_my_permits
      919 					| temp_relmgr_my_permits;
      920 				     relmgr_other_permits = relmgr_other_permits
      921 					| temp_relmgr_other_permits;
      922 				end;
      923 			     else do;
      924 				     relmgr_except_my_permits =
      925 					temp_relmgr_my_permits;
      926 				     relmgr_except_other_permits =
      927 					temp_relmgr_other_permits;
      928 				end;
      929 			end;
      930 		     if f_ptr -> fil_list.next_ofs = NULL_OFS
      931 		     then f_ptr = null ();
      932 		     else f_ptr = ptr (u_ptr,
      933 			     f_ptr -> fil_list.next_ofs);
      934 		end;
      935 	     if u_ptr -> user_list.offsets.next_active_ofs = NULL_OFS
      936 	     then u_ptr = null ();
      937 	     else u_ptr = ptr (u_ptr,
      938 		     u_ptr -> user_list.offsets.next_active_ofs);
      939 	end;
      940      end calc_process_scopes;
      941 
      942 
      943 clean_up:
      944      proc;
      945 	if make_user_inactive
      946 	then call mu_de_queue_user (NO_DQ_OPEN, FREE_FIL_LIST, dbc_ptr, ul_ptr, (0));
      947 
      948 	if dbc_ptr ^= null
      949 	then do;
      950 		if code ^= error_table_$lock_wait_time_exceeded
      951 		then do;				/* if a timeout then leave scope as is */
      952 		     end;
      953 		call set_lock_$unlock (dbc.scope_lock, icode);
      954 	     end;
      955      end clean_up;
      956 
      957 
      958 /* *************************************************************
      959*   *    Logical end of program; include files of dcl's follow    *
      960*   ************************************************************** */
      961 
      962 
      963 	dcl     db_index		 fixed bin (35) based (dbi_ptr);
      964 						/* index of data base to perform dl_fscope upon */
      965 	dcl     rel_name		 char (rel_len) based (rel_ptr);
      966 						/* relation name part of scope tuple */
      967 
      968 /* operations to be prevented of other processes */
      969 	dcl     state		 fixed bin (35),
      970 	        code		 fixed bin (35) based (cd_ptr);
      971 						/* standard system return code */
      972 
      973 
      974 	dcl     my_pid		 bit (36);	/* Current process id */
      975 	dcl     conflict_sw		 bit (1) unal;	/* ON => scope conflict exists */
      976 	dcl     make_user_inactive	 bit (1) unal;	/* ON => no scope left, must takeoff the active list */
      977 	dcl     status		 bit (1) unal;	/* ON => process is alive; OFF => dead */
      978 	dcl     wakeup		 bit (1) unal;	/* ON => send a wakeup message to a waiting user */
      979 
      980 	dcl     current_rmg_permits	 bit (2);		/* Current combined permits of opening to change */
      981 	dcl     current_rmg_prevents	 bit (2);		/* Current combined prevents */
      982 	dcl     new_rmg_permits	 bit (2) aligned;	/* Combined permits after scope deletion */
      983 	dcl     new_rmg_prevents	 bit (2) aligned;	/* Combined prevents after scope deletion */
      984 	dcl     old_rmg_permits	 bit (2);		/* Total combined permits */
      985 	dcl     old_rmg_prevents	 bit (2);		/* Total combined prevents */
      986 	dcl     other_rmg_permits	 bit (2);		/* Current combined permits of everything else */
      987 	dcl     other_rmg_prevents	 bit (2);		/* Prevents of everything else */
      988 
      989 	dcl     (
      990 	        nargs,				/* number of arguments passed to dl_fscope */
      991 	        arg_len,				/* argument length in chars */
      992 	        num_tuples,				/* number of scope tuples represented by arg_list */
      993 	        i,
      994 	        pos_in_si,				/* index in scope_info array */
      995 	        pos_in_rmfa,			/* index in rm_rel_array */
      996 	        args_exp,				/* number of args in calling argument list */
      997 	        arg_index,				/* index to current scope tuple in arg_list */
      998 	        rel_len
      999 	        )			 fixed bin;	/* length of rel_name */
     1000 
     1001 	dcl     icode		 fixed bin (35);	/* internal status code */
     1002 
     1003 	dcl     temp_uid		 bit (36) aligned;	/* uid of the segment that the dbc_ptr points to */
     1004 
     1005 	dcl     ptr_bit_string	 bit (72) based;	/* bit string format of pointer variable */
     1006 
     1007 	dcl     rel_name_32		 char (32);	/* Used to search rm_rel_array */
     1008 	dcl     entry_name		 char (32);	/* name by which this procedure was called */
     1009 	dcl     model_rel_name	 char (30);	/* relation name parameter used by check_scope
     1010*						   --check_scope only knows of model relation names */
     1011 	dcl     ophset		 bit (18) unal based; /* offset format */
     1012 
     1013 	dcl     (
     1014 	        cd_ptr,				/* pointer to return code */
     1015 	        dbi_ptr,				/* pointer to data base index (db_index) */
     1016 	        rel_ptr,				/* pointer to rel_name */
     1017 	        find_ul_ptr,			/* ptr to user_list entry */
     1018 	        conflict_ul_ptr,			/* ptr to user who is causing a conflict with requested scopes */
     1019 	        flo_ptr				/* ptr to an offset to a file_list entry */
     1020 	        )			 ptr;		/* pointer to prevent operations */
     1021 
     1022 	dcl     (cleanup, arg_error)	 condition;
     1023 	dcl     (addr, rel, null, string)
     1024 				 builtin;
     1025 
     1026 
     1027 
     1028 /*		Multics subroutines 		*/
     1029 
     1030 	dcl     cu_$arg_count	 entry (fixed bin),
     1031 	        cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin, fixed bin (35)),
     1032 	        set_lock_$lock	 entry (bit (36) aligned, fixed bin, fixed bin (35)),
     1033 	        set_lock_$unlock	 entry (bit (36) aligned, fixed bin (35)),
     1034 	        hcs_$wakeup		 entry (bit (36), fixed bin (71), fixed bin (71), fixed bin (35)),
     1035 	        hcs_$get_uid_seg	 entry (ptr, bit (36) aligned, fixed bin (35)),
     1036 	        get_process_id_	 entry returns (bit (36));
     1037 
     1038 /*		Other subroutines		*/
     1039 
     1040 	dcl     mu_database_index$get_resultant_model_pointer
     1041 				 entry (fixed bin (35), ptr),
     1042 	        mu_check_scope	 entry (ptr, ptr, ptr, ptr, ptr, ptr, bit (1), ptr),
     1043 	        mu_de_queue_user
     1044 				 entry (bit (1), bit (1), ptr, ptr, fixed bin (35)),
     1045 	        mu_check_conflict
     1046 				 entry (bit (1), ptr, ptr, ptr, ptr, bit (1));
     1047 
     1048 /*		External data		*/
     1049 
     1050 	dcl     (error_table_$wrong_no_of_args,
     1051 	        error_table_$lock_wait_time_exceeded,
     1052 	        error_table_$invalid_lock_reset,
     1053 	        error_table_$locked_by_this_process,
     1054 	        mrds_data_$lock_wait_time,
     1055 	        mrds_error_$invalid_db_index,
     1056 	        mrds_error_$rel_name_too_long,
     1057 	        mrds_error_$scope_empty,
     1058 	        mrds_error_$unknown_relation_name,
     1059 	        mrds_error_$non_scope_ready,
     1060 	        mrds_error_$scope_not_found,
     1061 	        mrds_error_$unknown_proc_id,
     1062 	        sys_info$max_seg_size) fixed bin (35) ext;
     1063 	dcl     OFF		 bit (1) init ("0"b) static internal options (constant);
     1064 	dcl     ON		 bit (1) init ("1"b) static internal options (constant);
     1065 	declare 1 actual_permits	 like common;
     1066 	declare 1 actual_prevents	 like common;
     1067 	declare 1 actual_conflict_detail,		/* details of why dl_scope failed */
     1068 		2 permits		 like common,
     1069 		2 prevents	 like common;
     1070 	declare 1 unused_conflict_detail,		/* throw away detail */
     1071 		2 permits		 like common,
     1072 		2 prevents	 like common;
     1073 	declare sub_err_		 entry options (variable); /* reports errors */
     1074 	declare caller_name		 char (32) init ("mrds_dsl_dl_fscope"); /* name of calling routine */
     1075 	declare continue		 char (1) init ("c"); /* dont stop after printing error */
     1076 	declare info_ptr		 ptr init (null ());/* unused */
     1077 	declare return_value	 fixed bin (35) init (0); /* unused */
     1078 	declare conflict_relation	 char (32);	/* name of relation where tried to delete more scope than present */
     1079 	declare conflict_detail_known	 bit (1) init ("0"b); /* on => knwo details of conflict */
     1080 	declare saved_fl_ptr	 ptr;		/* remember old fl_ptr */
     1081 	dcl     divide		 builtin;
     1082 	dcl     fixed		 builtin;
     1083 	dcl     index		 builtin;
     1084 	dcl     length		 builtin;
     1085 	dcl     mod		 builtin;
     1086 	dcl     pointer		 builtin;
     1087 	dcl     baseno		 builtin;
     1088 	dcl     baseptr		 builtin;
     1089 	dcl     ptr		 builtin;
     1090 	dcl     rtrim		 builtin;
     1091 	dcl     unspec		 builtin;
     1092 
  1     1 /* BEGIN mrds_dbcb.incl.pl1 -- jaw, 11/7/78 */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  1     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  1     8*     This entry is being made to cover the change made on 85-07-01 by Thanh
  1     9*     Nguyen. The scopes_changed flag was added to make checking for this
  1    10*     more efficient (mrds error list #137).
  1    11*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
  1    12*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
  1    13*     Add a bit called dont_check_txn_id to indicate whether or not we should
  1    14*     care if multiple txns use the same selection_expression. (mrds #156)
  1    15*  3) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  1    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  1    17*     Added parser_work_area_ptr and mrds_se_info_ptr for new parser.
  1    18*                                                   END HISTORY COMMENTS */
  1    19 
  1    20 
  1    21 /* WARNING
  1    22*          If the dbcb structure is changed then the mrds_data_
  1    23*          item saved_res_version MUST be incremented to invalidate all
  1    24*          existing saved resultants
  1    25**/
  1    26 
  1    27 /* HISTORY :
  1    28*
  1    29*   modified by Jim Gray - - 80-10-24, to add new_select_expr bit for
  1    30*   tid_list management
  1    31*
  1    32*   81-1-9 Jim Gray : added like reference for  ease  in  making  the
  1    33*   phony resultant in mu_database_index, without having the area dcl
  1    34*   included.
  1    35*
  1    36*   81-06-17 Roger Lackey :  added  last_store_rel_name  for  use  by
  1    37*   mrds_dsl_store
  1    38*
  1    39*   81-06-26 Roger Lackey : Added no_optimize and  print_search_order
  1    40*   switches
  1    41*
  1    42*   81-07-06 Jim Gray : added identifier for  the  current  selection
  1    43*   expression,  so  that relation statistics can be updated relative
  1    44*   to number of selection expressions seem. Also  removed  init  for
  1    45*   last_store_rel_name,   as   this   iw   now   properly   done  in
  1    46*   mrds_dsl_init_res.
  1    47*
  1    48*   81-07-17  Roger Lackey : added pred_ptr and unused_ptrs.
  1    49*
  1    50*   82-08-19  Mike Kubicar : added store_vector field.  This is needed
  1    51*   for the conversion to the relation manager.
  1    52*
  1    53*   82-08-23 Davids: added the relmgr_entries and access_costs
  1    54*   substructures so that the entries and costs can change
  1    55*   depending on the type of database that is opened.
  1    56*
  1    57*   82-09-09 Mike Kubicar : added modify_vector field.  This is needed
  1    58*   since modify uses a different vector type (general) than does store.
  1    59*
  1    60*   82-09-20 Davids: changed names of (store modify)_vector to
  1    61*   (store modify)_vector_ptr. Also (delete modify)_tuple_by_id to
  1    62*   (delete modify)_tuples_by_id. added the element cursor_storage_ptr
  1    63*   which should be inited to null and will be set by mu_cursor_manager_$get
  1    64*   during the first call.
  1    65*
  1    66*   82-09-21 Davids: renamed cursor_storage_ptr to cursor_ptrs_storage_ptr
  1    67*   since it deals with the pointers to the cursors and not the cursors
  1    68*   themelves and added the element cursor_storage_area_ptr which points
  1    69*   to the area where the cursors are kept.
  1    70*
  1    71*   82-09-22 Davids: renamed the transact_ctl_seg to transactions_needed.
  1    72*   the transact_ctl_seg always had a value of 0 and really didn't mean
  1    73*   anything.
  1    74*
  1    75*   82-09-22 Mike Kubicar : added create_relation, create_index and
  1    76*   destroy_relation_by_opening to relmgr_entries.  They are needed
  1    77*   by mrds_dsl_define_temp_rel.
  1    78*
  1    79*   82-09-24 Donna Woodka : added  put_tuple to  relmgr_entries. It
  1    80*   is needed by mu_store.
  1    81*
  1    82*   82-11-12 Davids: changed the declaration of the access_costs from fixed
  1    83*   bin to float bin since the values are not integers.
  1    84*
  1    85*   83-02-02 Davids: added the dbc_uid element. This will allow mrds to make
  1    86*   sure that the dbc_ptr still points to the correct segment. Element was 
  1    87*   added to the end of the structure to allow modules that don't use
  1    88*   the element to continue to reference the dbcb structure without recompiling.
  1    89*
  1    90*   83-02-25 Davids: added the concurrency_on and rollback_on elements. These
  1    91*   are needed so that temp rels can be created with the same file attributes
  1    92*   as the permanent relations.
  1    93*
  1    94*   83-05-02 Mike Kubicar : Deleted get_next_search_specification_ptr and
  1    95*   added the resultant_in_pdir bit.
  1    96*
  1    97*   83-05-18 Davids: reduced the number of reserved bits to 14 (from 15) and
  1    98*   added the res_already_made element.
  1    99*
  1   100*   83-05-24 Mike Kubicar : Updated the relation manager calling sequences.
  1   101*
  1   102*   83-08-03 Mike Kubicar : Added the element_id_list_segment_ptr and removed
  1   103*   one of the unused pointers.
  1   104*
  1   105*   83-09-20 Ron Harvey: Added relmgr_entries.get_population.
  1   106*
  1   107*   84-08-27 John Hergert:  Created compiled_se_info_ptr from unused_ptrs(2)
  1   108*   leaving unused_ptrs(1).
  1   109*
  1   110*   85-01-15 Thanh Nguyen:  Added the work_area_ptr and removed the last
  1   111*   unused_ptrs (1).
  1   112*
  1   113*   85-04-12 Thanh Nguyen:  Added user_started_transaction and 
  1   114*   non_shared_to_shared flags.  Also added se_transaction_id and some more
  1   115*   spare ptrs, entries and reserved storages for future enhancement, since
  1   116*   we changed the saved_res_version from rslt0001 to rslt0002.
  1   117*
  1   118*   85-07-01 Thanh Nguyen:  Added scopes_changed flag.  This flag is set by
  1   119*   common routine of mrds_dsl_set_scope, reset by mrds_dsl_optimize and 
  1   120*   mrds_dsl_gen_srch_prog when building of a new search_vars.
  1   121**/
  1   122 
  1   123 
  1   124 /* this structure is based on the {unique_name}.mrds.dbcb segment
  1   125*   that constitutes the non-secure portion of the resultant model that is
  1   126*   created during the opening of a database. it contains variables that
  1   127*   are used during the runtime access of the database, and an area
  1   128*   for evaluation of requests. it points to four other
  1   129*   segments in the resultant model, {unique_name}.mrds.rdbi, the secure
  1   130*   portion of the resultant(see mdbm_rm_db_info.incl.pl1),
  1   131*   {unique_name}.mrds.select, an area for selection expression evaluation,
  1   132*   {unique_name}.mrds.curdat, and {unique_name}.mrds.stadat, two segments
  1   133*   used in the elimination of duplicate tuples during a retrieve.
  1   134*   the dbcb area holds the structure in mdbm_scope_info.incl.pl1
  1   135*   that is used when the database is using the file scope mechanism
  1   136*   for concurrency control over file readying. the segment overlayed via
  1   137*   mrds_dbc.incl.pl1 structure is pointed to and also handles concurrency control,
  1   138*   across database openings. the pointer to this dbcb structure is kept in a table
  1   139*   which associates database indexes(returned from a call to dsl_$open), with particular
  1   140*   opening instances of resultant models. (see mu_database_index routine) */
  1   141 
  1   142      dcl	   1 dbcb		      aligned based (dbcb_ptr), /* DBCB -- non-secure portion */
  1   143 	     2 data	      like dbcb_data,
  1   144 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (dbcb.static_area))));
  1   145 
  1   146      dcl	   dbcb_ptr	      ptr;
  1   147 
  1   148      declare 1 dbcb_data	      based,		/* info part of dbcb, separated out so that
  1   149*						   like references can avoid getting the area declaration */
  1   150 	     2 rdbi_ptr	      ptr,		/* pointer to write protected mdbm_util_ info. */
  1   151 	     2 range_ptr	      ptr,		/*  ptr to range structure, or null */
  1   152 	     2 select_ptr	      ptr,		/* ptr to select list, or null */
  1   153 	     2 sv_ptr	      ptr,		/* pointer to search variables */
  1   154 	     2 so_ptr	      ptr,		/* pointer to search operators */
  1   155 	     2 ti_ptr	      ptr,		/* pointer to tuple info */
  1   156 	     2 lit_ptr	      ptr,		/* pointer to the literal area, or null */
  1   157 	     2 current_ptr	      ptr,		/* ptr to select list resulting from -current clause */
  1   158 	     2 ss_ptr	      ptr,		/* ptr to select sets block if not simple s.e. */
  1   159 	     2 retr_info_ptr      ptr,		/* ptr to retrieve info area */
  1   160 	     2 trel_info_ptr      ptr,		/* ptr to retrieve info area */
  1   161 	     2 sti_ptr	      ptr,		/* pointer to store info */
  1   162 	     2 dbc_ptr	      ptr,		/*  pointer to the data base control segment */
  1   163 	     2 sfi_ptr	      ptr,		/* points to head of scalar function list */
  1   164 	     2 scope_ptr	      ptr,		/* points to array of scope tuples */
  1   165 	     2 select_area_ptr    ptr,		/* ptr to area for current selection expression allocations */
  1   166 	     2 current_data_ptr   ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  1   167*						   for eliminating duplicate tuples. */
  1   168 	     2 static_data_ptr    ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  1   169*						   for eliminating duplicate tuples. */
  1   170 	     2 store_area_ptr     ptr,		/* temp storage area for dsl_$store */
  1   171 	     2 retrieve_area_ptr  ptr,		/* temp storage for dsl_$retrieve */
  1   172 	     2 modify_area_ptr    ptr,		/* temp storage area for dsl_$modify */
  1   173 	     2 delete_area_ptr    ptr,		/* temp storage area for dsl_$delete */
  1   174 	     2 def_temp_rel_area_ptr ptr,		/* temp storage area for dsl_$define_temp_rel */
  1   175 	     2 pred_ptr	      ptr,		/* Pointer to pred_array */
  1   176 	     2 store_vector_ptr   ptr,		/* Vector structure used during store operations */
  1   177 	     2 modify_vector_ptr  ptr,		/* Used during modifies */
  1   178 	     2 element_id_list_segment_ptr ptr,		/* Points to the segment used to hold element_id_list structures */
  1   179                2 compiled_se_info_ptr ptr,                  /* points to the segment containing all info on compiled sexs */
  1   180 	     2 work_area_ptr        ptr,		/* Work area for encode/decode value allocations in mu_retrieve */
  1   181 	     2 se_info_ptr          ptr,                  /* Points to se_info struct. Primarily for error reports */
  1   182 	     2 parser_work_area_ptr ptr,		/*  work area for parser */
  1   183 	     2 reserved_ptrs      (4) ptr,		/* Reserved for future use */
  1   184 	     2 another_flag	      bit (1) unal,		/* on if predicate was -another */
  1   185 	     2 current_flag	      bit (1) unal,		/* on if predicate was -current clause */
  1   186 	     2 dbc_incr	      bit (1) unal,		/* on if dbc open mode has been incremented for this user */
  1   187 	     2 delete_flag	      bit (1) unal,		/* On if search was called from mrds_dsl_sec_delete */
  1   188 	     2 dup_retain	      bit (1) unaligned,	/* On if dup tuples allowed for retrieval */
  1   189 	     2 prev_select	      bit (1) unal,		/* on if prev. select block processed in this s.e. */
  1   190 	     2 possible_op	      bit (1) unal,		/* on of arith op. allowed */
  1   191 	     2 sel_clause	      bit (1) unal,		/* on if currently in select clause */
  1   192 	     2 dsm_sw	      bit (1) unal,		/* on if data base was opened via data submodel */
  1   193 	     2 val_rtrv	      bit (1) unal,		/* if s.e. valid for retrieve */
  1   194 	     2 val_mod	      bit (1) unal,		/* for modify */
  1   195 	     2 val_del	      bit (1) unal,		/* for delete */
  1   196 	     2 val_dtr	      bit (1) unal,		/* for define temp rel */
  1   197 	     2 transactions_needed bit (1) unal,	/* On => transaction must be started or in progress does
  1   198*                                                                     not imply that the database is of type page_file */
  1   199 	     2 open_mode	      bit (3) unal,		/* 0=>unknown, 1=>r, 2=>u, 3=>er, 4=>eu, >4=>bad */
  1   200 	     2 new_select_expr    bit (1) unal,		/* on => starting a new tid list management period */
  1   201 	     2 no_optimize	      bit (1) unal,		/* On => no optimize */
  1   202 	     2 print_search_order bit (1) unal,		/*  On => print the search order */
  1   203 	     2 resultant_in_pdir  bit (1) unal,		/* On => Temp segments are in the process dir */
  1   204 	     2 res_already_made   bit (1) unal,           /* On => resultant has been made based on a saved copy */
  1   205 	     2 user_started_transaction bit (1) unal,     /* On => user already started his own transaction. */
  1   206 	     2 non_shared_to_shared bit (1) unal,         /* On => user changed the scope from non shared to shared
  1   207*						   inside a sequence of -another selection expression. */
  1   208 	     2 scopes_changed     bit (1) unal,           /* On => scopes had been changed by set_scopes or delete_scopes */
  1   209 	     2 dont_check_txn_id  bit (1) unal,           /* On => cpmd needs same selection exp across multiple txns */
  1   210 	     2 reserved	      bit (10) unal,	/* reserved for future use */
  1   211 	     2 nseq_sch	      fixed bin (35),	/* no. tuples located via sequential search */
  1   212 	     2 nind_sch	      fixed bin (35),	/* no. tuples located via index search */
  1   213 	     2 nhash_sch	      fixed bin (35),	/* no. tuples located via hash search */
  1   214 	     2 nlk_sch	      fixed bin (35),	/* no tuples located via link search */
  1   215 	     2 cur_lit_offset     fixed bin (35),	/* current bit offset in literal string */
  1   216 	     2 dbi	      fixed bin (35),	/* database index for this opening */
  1   217 	     2 last_s_e_id_num    fixed bin (35),	/* identifying number for last selection expression seen */
  1   218 	     2 se_transaction_id  bit (36) aligned,       /* transaction id from beginning of select expression */
  1   219 	     2 last_store_rel_name char (32),		/* Name of relation last used  for store */
  1   220 	     2 cursor_ptrs_storage_ptr ptr,		/* pointer to space where cursor ptrs are stored */
  1   221 	     2 cursor_storage_area_ptr ptr,		/* pointer to area where the cursors are kept */
  1   222 	     2 reserved_words     (10) fixed bin (35),	/* Reserved for future use */
  1   223 	     2 relmgr_entries,			/* relation manager entries */
  1   224 	       3 open	      entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  1   225 	       3 close	      entry (bit (36) aligned, fixed bin (35)),
  1   226 	       3 create_cursor    entry (bit (36) aligned, ptr, ptr, fixed bin (35)),
  1   227 	       3 destroy_cursor   entry (ptr, ptr, fixed bin (35)),
  1   228 	       3 set_scope	      entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35)),
  1   229 	       3 delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  1   230 	       3 modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35)),
  1   231 	       3 get_tuple_by_id  entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  1   232 	       3 get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)),
  1   233 	       3 get_tuple_id     entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  1   234 	       3 put_tuple	      entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  1   235 	       3 get_count	      entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  1   236 	       3 get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35)),
  1   237 	       3 get_population   entry (ptr, fixed bin (35), fixed bin (35)),
  1   238 	       3 create_relation  entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)),
  1   239 	       3 create_index     entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35)),
  1   240 	       3 destroy_relation_by_path entry (char (*), char (*), fixed bin (35)),
  1   241 	       3 reserved_entries (5) entry (),
  1   242 	     2 access_costs,			/* access costs for permute */
  1   243 	       3 total_primary_key_cost float bin,
  1   244 	       3 access_cost      float bin,
  1   245 	       3 access_overhead  float bin,
  1   246 	       3 us_access_cost   float bin,
  1   247 	       3 os_access_cost   float bin,
  1   248 	     2 dbc_uid	      bit (36) aligned,	/* uid of the segment containing the dbc structure */
  1   249 	     2 concurrency_on     bit (1) unal,		/* "1"b implies dmfile concurrency is being used */
  1   250 	     2 rollback_on	      bit (1) unal;		/* "1"b iomplies before journaling is to be done */
  1   251 
  1   252 /* END mrds_dbcb.incl.pl1 */
  1   253 
  1   254 
     1093 
     1094 
  2     1 /* BEGIN INCLUDE FILE mdbm_scope_requests.incl.pl1 - - Jim Gray 80-12-10 */
  2     2 
  2     3 /* this include file contains overlays for the fixed bin (17)
  2     4*   permit/prevent scope mode encoding that set/dl_fscope and all lower
  2     5*   routines use in interface communications.
  2     6*   Note that is fixed bin(17) aligned, as recieved from
  2     7*   mrds_dsl_set_scope, thus the overlay is for a full 36 bit word.
  2     8*   The scope modes are encoded as a sum of the individual permissions,
  2     9*   with 1 => read_attr, 2 => append_tuple, 4 => delete_tuple, 8 => modify_attr,
  2    10*   thus individual bits in the fixed bin word can be used for each mode
  2    11*   These were known as r-s-m-d modes by old mrds users. */
  2    12 
  2    13 declare 1 common based,				/* common layout of bits for scope modes */
  2    14         2 mbz1 bit (32) unal,				/* unused upper part of word */
  2    15         2 modify_attr bit (1) unal,			/* mode sum has an 8 */
  2    16         2 delete_tuple bit (1) unal,			/* mode sum has a 4 */
  2    17         2 append_tuple bit (1) unal,			/* mode sum has a 2 */
  2    18         2 read_attr bit (1) unal ;			/* mode sum has a 1 */
  2    19 
  2    20 declare 1 permit_requests like common based (permit_requests_ptr) ; /* permit modes in scope call */
  2    21 
  2    22 declare 1 prevent_requests like common based (prevent_requests_ptr) ; /* prevent modes in scope call */
  2    23 
  2    24 declare (permit_requests_ptr, prevent_requests_ptr) ptr ;
  2    25 
  2    26 /* the following structure is used to describe in detail,
  2    27*   what scope conflict existed between a users requested
  2    28*   permit/prevent modes in a set/dl_scope call and the
  2    29*   actual usage of a file/relation currently with active scope in the database
  2    30*   Note that for delete_scope, the conflict check is that the requested deletion
  2    31*   be a subset of the users currently set scope.
  2    32*   For set_scope, the conflict check is that a permit does not conflict with
  2    33*   another users prevent, and that the requested prevent does not
  2    34*   conflict with an existing other users permit already granted. */
  2    35 
  2    36 declare 1 conflict_detail based (conflict_detail_ptr),
  2    37         2 permits like common,			/* conflicts in permit part of requests */
  2    38         2 prevents like common ;			/* conflicts in prevent part of requests */
  2    39 
  2    40 declare  conflict_detail_ptr ptr ;
  2    41 
  2    42 /* END INCLUDE FILE mdbm_scope_requests.incl.pl1 */
     1095 
     1096 
  3     1 /* BEGIN mdbm_scope_info.incl.pl1 -- odf 8/8/78 */
  3     2 
  3     3 /* WARNING
  3     4*          If the scope_info or scope_flags structure is changed then the
  3     5*          mrds_data_ item saved_res_version MUST be incremented to invalidate
  3     6*          all existing saved resultants
  3     7**/
  3     8 
  3     9 /* Modified by Jim Gray - - 80-11-17, to add back store/delete/modify permissions */
  3    10 
  3    11 /* 80-12-10 Jim Gray : change name of store to append_tuple, delete to delete_tuple,
  3    12*   modify to modify_attr, retrieve to read_attr, remvoe update, put level 4
  3    13*   qualifiers for permit/prevent modes and to put pads in standard format */
  3    14 
  3    15 /* 80-12-11 Jim Gray : added submodel version of file/rel name for convenience */
  3    16 
  3    17 /* 80-12-22 Jim Gray : added like referenced structure so linus_scope_data.incl
  3    18*   could make use of it for compatibility. */
  3    19 
  3    20 /* 81-1-11 Jim Gray : added touched bit to scope_flags, so that
  3    21*   the fact that null scope has been set can be displayed */
  3    22 
  3    23 /* 85-04-14 Thanh Nguyen: Made scope_flags to be aligned so we could access the
  3    24*   prevent flags from any pointer which directly pointed to scope_flags itself
  3    25*   (i.e rm_rel_info.scope_flags_ptr). */
  3    26 
  3    27 /* this structure is to be allocated in the mrds_dbcb.incl.pl1 static area,
  3    28*   and is used to maintain the scope mechanism for file access.
  3    29*   It contains the scope permit/prevent operations that this user
  3    30*   has set in his view for this opening instance. */
  3    31 
  3    32 dcl 1 scope_info aligned based (scope_ptr),		/* array of scope tuples for this user */
  3    33     2 mbz1 bit (144),				/* Reserved for future use */
  3    34     2 nfiles fixed bin,				/* Number of scope tuples in user's scope */
  3    35     2 active_scopes fixed bin,			/* number of scopes currently active for a given user */
  3    36     2 scope (max_file_init refer (scope_info.nfiles)),	/* defines user's scope of access to files */
  3    37       3 name char (30) aligned,			/* filename */
  3    38       3 sm_name char (32),				/* name of file(rel) in submodel */
  3    39       3 flags like scope_flags ;
  3    40 
  3    41 
  3    42 declare 1 scope_flags aligned based,			/* common layout of scope flag bits */
  3    43         2 permits,					/* modes to permit this user */
  3    44 	3 read_attr bit (1) unal,			/* read_attr access to this file in scope */
  3    45 	3 append_tuple bit (1) unal,			/* append_tuple concnrrency permission */
  3    46 	3 delete_tuple bit (1) unal,			/* delete_tuple concurrency permission on rel */
  3    47 	3 modify_attr bit (1) unal,			/* modify_attr concurrency permission */
  3    48 	3 mbz2 bit (10) unal,			/* for expansion of permit ops */
  3    49         2 prevents,					/* modes to be denyed to other users */
  3    50 	3 read_attr bit (1) unal,			/* on if user has prevent on read_attr for this file */
  3    51 	3 append_tuple bit (1) unal,			/* prevent of append_tuple concurrency */
  3    52 	3 delete_tuple bit (1) unal,			/* prevent of delete_tuple concurrency */
  3    53 	3 modify_attr bit (1) unal,			/* prevent of modify_attr concurrency */
  3    54 	3 mbz3 bit (10) unal,			/* for future prevent concurrency modes */
  3    55         2 touched bit (1) unal,			/* on => scope set for this relation */
  3    56         2 mbz4 bit (7) unal ;				/* for future flags */
  3    57 
  3    58 dcl  max_file_init fixed bin;				/* nbr. of files in data base */
  3    59 dcl  scope_ptr ptr init (null ());			/* points to scope_info array */
  3    60 dcl  scope_rdy bit (6) unal init ("000011"b) int static options (constant); /* scope file ready modes (5 or 6) */
  3    61 dcl  scope_rdy_array (6) bit (1) unal based;		/* array format of scope_rdy string */
  3    62 
  3    63 /* END mdbm_scope_info.incl.pl1 */
     1097 
     1098 
  4     1 /*	BEGIN INCLUDE FILE		mdbm_dbc.incl.pl1	08/23/78   odf			*/
  4     2 
  4     3 /* HISTORY:
  4     4*
  4     5*   Modified by odf for new version data bases in August 1978
  4     6*   Modified by Al Kepner, March 8, 1979 to add new flags for quiescing
  4     7*   Modified by M. Pierret, 8 April 1980 to look prettier, add pads
  4     8*   Modified by M. Pierret, 22 August 1980, grouping like fields (flags, offsets..)
  4     9*
  4    10*   80-11-19 Jim Gray : modified to change version number from 4  to 5 to allow
  4    11*   automatic update of dbc structures to new r-s-m-d-u scope codes from r-u.
  4    12**/
  4    13 
  4    14 dcl 1 dbc based (dbc_ptr),				/* data base control segment description */
  4    15     2 proper,
  4    16       3 version fixed bin,				/* version number of this structure */
  4    17       3 dtd_mrds fixed bin (71),			/* date time dumped by mrds utility */
  4    18       3 flags,
  4    19         4 trouble_switch bit (1) unal,			/* ON => ungraceful termination of a user process */
  4    20         4 dead_proc_flag bit (1) unal,			/* ON => dead process has access to part of data base */
  4    21         4 quiesce_sw bit (1) unal,			/* ON => db is quiesced for a administrative user */
  4    22         4 quiesce_db bit (1) unal,			/* ON => The entire data base is being quiesced. */
  4    23         4 quiesce_files bit (1) unal,			/* ON => A selected set of files is being quiesced. */
  4    24         4 pad bit (31) unal,				/* reserved for future use */
  4    25       3 quiesce_lock bit (36) aligned,			/* lock word for quiescing data base */
  4    26       3 wakeup_waiters fixed bin,			/* nbr users who have been sent a wakeup signal but have not yet
  4    27*						   received it */
  4    28       3 user_counts,
  4    29         4 open_users fixed bin,			/* nbr of users with data base open in any mode */
  4    30         4 active_users fixed bin,			/* nbr of users currently having a scope set */
  4    31         4 waiting_users fixed bin,			/* nbr of users waiting to set scope */
  4    32       3 open_lock bit (36) aligned,			/* lock word for opening data base */
  4    33       3 scope_lock bit (36) aligned,			/* lock word for setting and deleting scope */
  4    34       3 sa_size fixed bin (35),			/* size in words of static area  */
  4    35       3 pad2 bit (144),
  4    36       3 offsets,
  4    37         4 open_users_ofs bit (18) unal,			/* bit offset to list of users with data base currently open */
  4    38         4 active_users_ofs bit (18) unal,		/* bit offset to list of active users in shared mode */
  4    39         4 waiting_users_ofs bit (18) unal,		/* bit offset to list of waiting users in shared mode */
  4    40         4 obsolete bit (36) unal,			/* obsolete */
  4    41       3 pad3 bit (144),
  4    42     2 static_area area (sys_info$max_seg_size - fixed (rel (addr (dbc.static_area))) + 1);
  4    43 
  4    44 dcl  dbc_ptr ptr init (null ());
  4    45 
  4    46 dcl  VERSION_NBR fixed bin init (5) static internal options (constant);
  4    47 
  4    48 
  4    49 /* END mdbm_dcb.incl.pl1  */
  4    50 
  4    51 
     1099 
     1100 
  5     1 /* BEGIN mdbm_users.incl.pl1   -- odf, 08/10/78  */
  5     2 
  5     3 
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(86-10-03,Dupuis), approve(86-10-21,MCR7562), audit(86-10-22,Blair),
  5     7*     install(86-10-23,MR12.0-1199):
  5     8*     Deleted the DEFAULT_WAIT variable.
  5     9*                                                   END HISTORY COMMENTS */
  5    10 
  5    11 
  5    12 /* HISTORY:
  5    13*   Written by Oris Friesen August 10, 1978.
  5    14*   Modified by M. Pierret 13 December 1979, changing wakeup messages.
  5    15*   Modified by M. Pierret 13 April 1980 (Jason's birthday) to remove priority and wakeup structures
  5    16*   Modified by M. Pierret 13 August 1980 to group like fields (ids, offsets...)
  5    17*   Modified by Jim Gray - - 80-11-19, to add fields to fil_list to allow for complete
  5    18*   r-u-s-m-d scope codes, instead of just r-u.
  5    19*
  5    20*   80-12-10 Jim Gray : change names of fil_list prevent/permit modes
  5    21*   store to append_tuple, retreive to read_attr, delete to delete_tuple, modify to modify_attr,
  5    22*   and pad to mbz for consistency with MRDS access acl modes.
  5    23*
  5    24*   80-12-12 Jim Gray : Changed DEFAULT_WAIT declaration to fixed bin 35 from 71,
  5    25*   so that the wait_seconds fb35 overlay would not get 0 and thus never wait.
  5    26*   This is currently only used in mrds_dsl_set_fscope.
  5    27*
  5    28*   82-09-22 Davids: addede the opening_id element to the fil_list structure.
  5    29*   Put it at the end to make the new structure compatable with the old so
  5    30*   that testing could take place without having to recompile all the modules
  5    31*   that use the structure.
  5    32*
  5    33*   82-10-14 Davids: removed the opening_id element and added the rmri_ptr
  5    34*   element. This was done because set_fscope must be able to open the
  5    35*   relation if its not yet opened.
  5    36*   ---------------------------------------------------------------------------
  5    37*   DESCRIPTION:
  5    38*
  5    39*   The dbc contains the following information in its static area.
  5    40*   One group of information is composed of structures (user_list)
  5    41*   threaded 3 ways to form 3 lists. They are the list of active
  5    42*   scope users, of open users, and of users waiting to set scope.
  5    43*   The beginning of each of these lists is pointed to by fields
  5    44*   in the dbc proper.  All of these lists share the user_list structures,
  5    45*   and are completely contained within these structures, i.e., there
  5    46*   is no extraneous information in some knook in Scottsdale.
  5    47*
  5    48*   Associated with each user_list structure is a linked list of
  5    49*   fil_list structures.  The list is of all of the files (relations)
  5    50*   included in the user's scope request.  Unlike the user_list
  5    51*   structures which were shared by several different lists, the structures
  5    52*   in a user's file list are exclusively hers.  The entries contain
  5    53*   information about the scope request and the file name, and have
  5    54*   no real connection with the actual files in the resultant model.
  5    55*   --------------------------------------------------------------------------- */
  5    56 
  5    57 dcl 1 user_list based (ul_ptr),
  5    58     2 ids,
  5    59       3 group_id char (32),				/* group identifier of this user */
  5    60       3 process_id bit (36),				/* process identifier of this user */
  5    61       3 db_lock_id bit (36) aligned,			/* the unique lock id for this process --
  5    62*						   used to identify dead processes */
  5    63       3 ev_chn_id fixed bin (71),			/* event channel id for this process */
  5    64       3 rdbi_bits bit (72),				/* bit string of rdbi_ptr
  5    65*						   to allow concurrent openings by same process */
  5    66     2 flags,
  5    67       3 open_mode fixed bin unal,			/* the mode of the db. opening -- NORMAL or QUIESCE */
  5    68       3 passive_sw bit (1) unal,			/* OFF => -permit update on some file */
  5    69       3 active_sw bit (1) unal,			/* ON => user has a scope set */
  5    70       3 waiting_sw bit (1) unal,			/* ON => user is waiting for scope to be set */
  5    71       3 priority_high bit (1) unal,			/* obsolete */
  5    72       3 event_signal_sw bit (1) unal,			/* ON => user has been signalled thru event wait channel */
  5    73       3 dead_proc bit (1) unal,			/* ON => this user's process has died  and is inactive */
  5    74       3 dead_proc_conflict
  5    75      bit (1) unal,					/* this user's scope request conflicts with a dead process */
  5    76       3 queue_activ bit (1) unal,			/* activated from the waiting queue */
  5    77       3 pad bit (28),				/* reserved for future use */
  5    78     2 allowance_count fixed bin,			/* obsolete */
  5    79     2 bypass_count fixed bin,				/* obsolete */
  5    80     2 offsets,
  5    81       3 fil_list_ofs bit (18) unal,			/* bit offset to list of files in this user's scope request */
  5    82       3 next_active_ofs bit (18) unal,			/* bit offset to next user in this list of active scope users */
  5    83       3 next_waiting_ofs bit (18) unal,			/* bit offset to next user in user list waiting to set scope */
  5    84       3 next_open_ofs bit (18) unal,			/* bit offset to next user who has data base open in any mode */
  5    85     2 num_filns fixed bin,				/* number of files potentially accessible by this user */
  5    86     2 file (num_filns refer (user_list.num_filns)) char (30);
  5    87 						/* names of files accessible by this user */
  5    88 
  5    89 dcl 1 fil_list based (fl_ptr),			/* of files which a given user has specified for a scope  */
  5    90     2 name char (30),				/* data model name of the file specified in scope request */
  5    91     2 permits,					/* permit codes for scope setting or deleting */
  5    92       3 mbz1 bit (15) unal,
  5    93       3 modify_attr bit (1) unal,
  5    94       3 delete_tuple bit (1) unal,
  5    95       3 append_tuple bit (1) unal,
  5    96       3 update bit (1) unal,
  5    97       3 read_attr bit (1) unal,
  5    98     2 prevents,					/* prevent codes for scope setting or deleting */
  5    99       3 update bit (1) unal,
  5   100       3 read_attr bit (1) unal,
  5   101       3 append_tuple bit (1) unal,
  5   102       3 delete_tuple bit (1) unal,
  5   103       3 modify_attr bit (1) unal,
  5   104       3 mbz2 bit (29) unal,
  5   105     2 next_ofs bit (18) unal,				/* bit offset to next file entry for this user's scope request */
  5   106     2 rmri_ptr ptr;                                         /* pointer to the relation's rm_rel_info str */
  5   107                                                             /* needed so that the relation can be opened if need be */
  5   108 
  5   109 dcl  ul_ptr ptr init (null ());
  5   110 dcl  fl_ptr ptr init (null ());
  5   111 
  5   112 dcl  num_filns fixed bin;				/* number of files accessible by a given user */
  5   113 
  5   114 
  5   115 dcl  WAIT init (0) fixed bin int static options (constant);
  5   116 						/* the number of later user requests for which a user
  5   117*						   request will wait before it must be honored */
  5   118 dcl  NULL_OFS bit (18) init ("111111111111111111"b) unal int static options (constant);
  5   119 dcl  DQ_OPEN bit (1) unal init ("1"b) int static options (constant);
  5   120 						/* dequeue from open list */
  5   121 dcl  NO_DQ_OPEN bit (1) init ("0"b) int static options (constant);
  5   122 						/*  do not dequeue from open list */
  5   123 dcl  CHAR_Q_F char (8) init ("que_free") int static options (constant);
  5   124 dcl  QUE_FREE fixed bin (71);
  5   125 dcl  CHAR_ALARM char (8) init ("alarm___") int static options (constant);
  5   126 						/* wakeup up signal for time-out */
  5   127 dcl  ALARM fixed bin (71);
  5   128 dcl  FIRST_QUEUE bit (1) init ("1"b) int static options (constant);
  5   129 						/* this is the 1st time process will asleep */
  5   130 dcl  QUEUE_AGAIN bit (1) init ("0"b) int static options (constant);
  5   131 						/* being queued for the 2nd, 3rd ... time */
  5   132 dcl  SET bit (1) unal init ("1"b) int static options (constant);
  5   133 						/* check to see which scopes can be set */
  5   134 dcl  DEL bit (1) unal init ("0"b) int static options (constant);
  5   135 						/* check to see which scopes can be deleted */
  5   136 dcl  ALIVE init ("1"b) bit (1) unal int static options (constant);
  5   137 						/* process is alive */
  5   138 dcl  DEAD init ("0"b) bit (1) unal int static options (constant);
  5   139 						/* process is dead */
  5   140 dcl  Q_PRM init (3) fixed bin (35) int static options (constant);
  5   141 						/* permit retrieve, update */
  5   142 dcl  Q_PRV init (3) fixed bin (35) int static options (constant);
  5   143 						/* prevent retrieve, update */
  5   144 dcl  Q_PRM_BITS bit (2) unal init ("11"b) int static options (constant);
  5   145 						/* permit retrieve, update */
  5   146 dcl  Q_PRV_BITS bit (2) unal init ("11"b) int static options (constant);
  5   147 						/* prevent retrieve, update */
  5   148 dcl  REL_SEC bit (2) init ("11"b) int static options (constant);
  5   149 						/* measure wait time in relative seconds */
  5   150 dcl  FREE_FIL_LIST bit (1) unal init ("1"b) int static options (constant);
  5   151 						/* free this user's file lists */
  5   152 dcl  SAVE_FIL_LIST bit (1) unal init ("0"b) int static options (constant);
  5   153 						/* do not free this user's file lists */
  5   154 
  5   155 /* END mdbm_users.incl.pl1 */
  5   156 
     1101 
     1102 
  6     1 /* BEGIN mdbm_rm_db_info.incl.pl1 -- jaw, 11/7/78 */
  6     2 
  6     3 
  6     4 
  6     5 /****^  HISTORY COMMENTS:
  6     6*  1) change(86-08-13,Hergert),, approve(88-06-28,MCR7903),
  6     7*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  6     8*     Removed change of 84-11-02. i.e. replaced even_word_pad.
  6     9*                                                   END HISTORY COMMENTS */
  6    10 
  6    11 
  6    12 /* WARNING
  6    13*          If the rm_db_info structure is changed then the mrds_data_
  6    14*          item saved_res_version MUST be incremented to invalidate all
  6    15*          existing saved resultants
  6    16**/
  6    17 
  6    18 /*  DESCRIPTION:  This  structure   is   based   on   a   segment
  6    19*   {unique_name}.mrds.rdbi that represents the secure portion of the
  6    20*   resultant model that is created partially at database open  time,
  6    21*   (the rm_file_array, and rm_rel_array) and partially at ready_file
  6    22*   time,    (the    rm_file_info,     rm_rel_info,     rm_attr_info,
  6    23*   rm_domain_info, rm_plink_info and rm_clink_info). it's purpose is
  6    24*   to  provide  an  efficient  means  of  accessing  database  model
  6    25*   information, as seen from the possibly submodel view of the user,
  6    26*   and his current state of "files readied". it is the  secure  part
  6    27*   because  it  contains  the  model  information  which needs to be
  6    28*   protected  from  general  knowledge,  and   this   segment   will
  6    29*   eventually  be  capable  of  being in a lower ring. the structure
  6    30*   itself points to four arrays that are  allocated  in  it's  area,
  6    31*   that  in  turn point to the other structures mentions above, also
  6    32*   allocated in  the  rm_db_info.static_area.  the  arrays  are  the
  6    33*   rm_file_array,  and  rm_rel_array. their are a pair for temporary
  6    34*   relations,  initially  empty,  and  a  pair  for   normal   model
  6    35*   files/relations.  the  normal  rm_file_array  is initialized to a
  6    36*   list of all known file names, the rm_rel_array only gets relation
  6    37*   names   as   files  are  readied.  the  rm_file_array  points  to
  6    38*   rm_file_infos for each file (see mdbm_rm_file_info.incl.pl1)  and
  6    39*   the   rm_rel_array   points  to  rm_rel_info  for  each  relation
  6    40*   "readied". (see mdbm_rm_rel_info.incl.pl1). (the  arrays  are  in
  6    41*   mdbm_rm_file_array.incl.pl1  and mdbm_rm_rel_array.incl.pl1). the
  6    42*   file infos point to contained rel infos, the rel infos  point  to
  6    43*   contained  attr  infos,  and  those in turn to domain infos. (see
  6    44*   mdbm_rm_attr_info.incl.pl1   and    mdbm_rm_domain_info.incl.pl1)
  6    45*   foreign     keys    are    represented    by    the    structures
  6    46*   mdbm_rm_plink_info.incl.pl1, and mdbm_rm_clink_info.incl.pl1. the
  6    47*   pathnames  of the model and submodel, if any, are also maintained
  6    48*   in rm_db_info. the pointer to this rm_db_info segment is obtained
  6    49*   from  the  dbcb  segment tructure(see mrds_dbcb.incl.pl1) see the
  6    50*   individual include files for  further  organization  information,
  6    51*   and particular data structures.
  6    52*
  6    53*   HISTORY:
  6    54*
  6    55*   80-02-01 Jim Gray : Modified to put area on even  word  boundary,
  6    56*   so that define_area_ could be used to make it an extensible area
  6    57*
  6    58*   81-1-9 Jim  Gray  :  added  like  reference  to  make  the  phony
  6    59*   resultant in mu_database_index easier to keep, since no reference
  6    60*   to the area is needed.
  6    61*
  6    62*   81-1-12 Jim Gray : added version of submodel used in  opening  to
  6    63*   resultant.
  6    64*
  6    65*   81-05-13 Rickie E. Brinegar: added the administrator bit  to  the
  6    66*   structure.
  6    67*
  6    68*   81-05-28 Jim Gray : removed pointers to file_arrays,  since  they
  6    69*   are  now  combined  into  the rel_array. Removed the control file
  6    70*   info which was unused. Added pointer  to  head  of  domain  list,
  6    71*   which is to be used to insure only one copy of each domain info.
  6    72*
  6    73*   83-05-19 Davids: Added the  saved_res_version element.
  6    74*
  6    75*   84-11-02 Thanh Nguyen:   Replaced  the  even_word_pad   by   the 
  6    76*   ref_name_proc_ptr  to point  to list  of reference  name of  the
  6    77*   check, encode, or decode proc.
  6    78*
  6    79*   CAUTION: The structure entries from db_version to sm_path  should
  6    80*   not  be moved or have their declarations changed because they are
  6    81*   used in the handling of old version database openings.
  6    82*
  6    83*
  6    84**/
  6    85 
  6    86      dcl	   1 rm_db_info	      aligned based (rdbi_ptr), /* data base info, located at base of res. dm. seg. */
  6    87 	     2 data	      like rm_db_info_data,
  6    88 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (rm_db_info.static_area))));
  6    89 
  6    90      dcl	   rdbi_ptr	      ptr;
  6    91 
  6    92      declare 1 rm_db_info_data      based,		/* separate declaration of info, so others can use
  6    93*						   like reference to it without getting the area as well */
  6    94 	     2 db_version	      fixed bin,		/* version no. of db */
  6    95 	     2 sm_version	      fixed bin unal,	/* version of submodel used unal, 0 if model opening */
  6    96 	     2 val_level	      fixed bin unal,	/* validation level for this db. */
  6    97 	     2 db_path	      char (168),		/* abs. path of db. */
  6    98 	     2 sm_path	      char (168),		/* path of submodel or model */
  6    99 	     2 mdbm_secured	      bit (1) unal,		/* ON => database is secured */
  6   100 	     2 administrator      bit (1) unal,		/* ON => user is an administrator */
  6   101 	     2 pad	      bit (34) unal,	/* for future use */
  6   102 	     2 saved_res_version  char (8),		/* version of the saved resultant in the 
  6   103*                                                               dbcb and rdbi segments in the db dir */
  6   104 	     2 domain_list_ptr    ptr,		/* pointer to head of list of domain_info's */
  6   105 	     2 ra_ptr	      ptr,		/* pointer to rel. array */
  6   106 	     2 tra_ptr	      ptr,		/* to rel array for temp rels */
  6   107 	     2 even_word_pad      fixed bin (71) aligned; /* padding to put area on even word boundary */
  6   108 
  6   109 /* END mdbm_rm_db_info.incl.pl1 */
  6   110 
  6   111 
     1103 
     1104 
  7     1 /* BEGIN mdbm_rm_rel_array.incl.pl1 -- jaw, 8/9/78 */
  7     2 
  7     3 /* WARNING
  7     4*          If the rm_rel_array structure is changed then the mrds_data_
  7     5*          item saved_res_version MUST be incremented to invalidate all
  7     6*          existing saved resultants
  7     7**/
  7     8 
  7     9 /* HISTORY:
  7    10*
  7    11*   81-05-28 Jim Gray : added  model_name  and  file_id  as  part  of
  7    12*   combining   funtions   of   file_array  and  rel_array  into  one
  7    13*   structure. This will only allow 1 relation per file model now.
  7    14*   Also changed structure to allow more efficient searching
  7    15*   via and index builtin, rather than a programmed loop.
  7    16*   Search is now I = index(string(rm_rel_array.name), "!" || in_name)
  7    17*   with I = ((I - 1) / 33) + 1 to convert from a char to array index.
  7    18*
  7    19**/
  7    20 
  7    21 
  7    22 /* this structure is allocated in the static are of the structure
  7    23*   in  mdbm_rm_db_info.incl.pl1,  the secure portion of the database
  7    24*   resultant  model  upon  opening  the  database.  two  copies  are
  7    25*   allocated,  one for temporary relations, initially empty, and one
  7    26*   for relations known to the opener, which has a length  sufficient
  7    27*   for  all  relations known to the user, but whose names, etc. will
  7    28*   not be filled  in  until  the  file  containing  that  particular
  7    29*   relation  is readied. the rm_db_info structure contains a pointer
  7    30*   to the rel_arrays, and the array entries, when  "readied",  point
  7    31*   to  the  mdbm_rm_rel_info.incl.pl1  structures  containing  model
  7    32*   information about the relation, it's attributes, etc. */
  7    33 
  7    34 dcl 1 rm_rel_array aligned based (rmra_ptr),		/* array of open relations */
  7    35     2 num_rels fixed bin,				/* no. rels in db. */
  7    36     2 name (1:rm_num_rels_init refer (rm_rel_array.num_rels)) unal,
  7    37       3 mark char (1) unal,				/* separator character = "!" */
  7    38       3 submodel char (32) unal,			/* name of relation is submodel view, model opening => model name */
  7    39     2 rel_data (rm_num_rels_init refer (rm_rel_array.num_rels)),
  7    40       3 model_name char (30),				/* name of relation in model */
  7    41       3 ri_ptr ptr unal ;				/* pointer to rm_rel_info */
  7    42 
  7    43 dcl  rmra_ptr ptr;
  7    44 dcl  rm_num_rels_init fixed bin;
  7    45 
  7    46 /* END mdbm_rm_rel_array.incl.pl1 */
  7    47 
  7    48 
     1105 
     1106 
  8     1 /* BEGIN mdbm_rm_rel_info.incl.pl1 -- jaw, 11/16/78 */
  8     2 
  8     3 /* WARNING
  8     4*          If the rm_rel_info structure is changed then the mrds_data_
  8     5*          item saved_res_version MUST be incremented to invalidate all
  8     6*          existing saved resultants
  8     7**/
  8     8 
  8     9 /* HISTORY:
  8    10*
  8    11*   Modified by Jim Gray - - May 1980, to  include  model  number  of
  8    12*   attributes,   and   varying  attributes,  so  that  partial  view
  8    13*   submodels will have the  info  needed  to  properly  set  up  the
  8    14*   varying length array headers in the tuple structure.
  8    15*
  8    16*   Modified  by  Jim  Gray  -  -  80-11-06,  to  rename   r_perm   =
  8    17*   status_perm,     s_perm    =    append_tuple_perm,    d_perm    =
  8    18*   delete_tuple_perm, and make m_perm = unused_perm.
  8    19*
  8    20*   81-01-23 Jim Gray : added bit to indicate whether the last  model
  8    21*   view attribute was varying character or bit, since a partial view
  8    22*   submodel will not have this information in the resultant, and  it
  8    23*   is  needed for determining the new tuple length in mus_mod_ubtup,
  8    24*   since with exact length storage  of  varying  length  attributes,
  8    25*   each  tuple  can  be  a  different  length,  which is can only be
  8    26*   determined by examining the tuple itself.
  8    27*
  8    28*   81-01-29 Jim Gray : added curent  tuple  count,  to  provide  for
  8    29*   interface  to  allow  temp  rel  population  to  be known, and to
  8    30*   provide a more efficient means of finding an approx. current perm
  8    31*   relation population.
  8    32*
  8    33*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
  8    34*   blocked  files, foreign keys, and ids procedures. Also set number
  8    35*   of files per rel to a constant of 1.
  8    36*
  8    37*   81-05-28 Jim Gray : combined data  from  rm_file_info  into  this
  8    38*   structure so that only one structure per relation is needed.
  8    39*
  8    40*   81-07-02 Jim Gray : added total_key and dup_key vfile  statistics
  8    41*   counts.   Also  added  number  of  operations  count  since  last
  8    42*   statistics update, and a time  since  the  statistics  were  last
  8    43*   updated.
  8    44*
  8    45*   81-07-06 Jim Gray :  added  a  per  selection  expression  update
  8    46*   identifier so that small relations could be updated on a per S.E.
  8    47*   basis
  8    48*
  8    49*   82-04-21 R. Lackey : Added number_selected (ri_niocbs_init refer (rm_rel_info.niocbs)) fixed bin (35)
  8    50*   to end of structure   TR 12205 (Suggestion).
  8    51*   
  8    52*   82-08-19 D. Woodka :  Removed  rm_rel_info.max_data_len  field for
  8    53*   the DMS conversion. 
  8    54*
  8    55*   82-08-30 Davids: added the opening_id element and removed the iocb
  8    56*   array and the niocb element for DMS conversion. Also removed the
  8    57*   number_selected array (and ri_niocbs_init) since subsets are not
  8    58*   going to be used.
  8    59*
  8    60*   82-09-20 Mike Kubicar : changed rm_rel_info.rel_id to bit (36) aligned
  8    61*   so that it can be used with relation manager.  Also added
  8    62*   rm_rel_info.primary_key_index_id for relation manager.
  8    63*
  8    64*   82-09-22 Mike Kubicar : Removed the, now useless, fields var_attr_ptrs,
  8    65*   nvar_atts, model_nvar_atts.
  8    66*
  8    67*   82-09-24 Davids: Removed current_key_count and current_dup_key_count
  8    68*   since the duplicate key count for each secondary index is now being
  8    69*   kept in the attr_info structure and key_count was only needed to
  8    70*   help in calculating the average selectivity of each index which
  8    71*   can now be gotten directly from each index's dup key count. Also
  8    72*   removed the file_id element since it is no longer needed for
  8    73*   anything.
  8    74*
  8    75*   82-09-27 Mike Kubicar : removed file_id_len for the same reason file_id
  8    76*   was removed.
  8    77*
  8    78*   82-11-05 Mike Kubicar : added a pointer to an id_list structure to be
  8    79*   used when retrieving tuples from this relation.
  8    80*
  8    81*   83-04-06 Davids: Added the scope_flags_ptr which points to the scope_flags structure
  8    82*   for the relation. Note that this structure is part of the resultant NOT
  8    83*   part of the db.control structure. The scopes are duplicated in the resultant
  8    84*   to reduce contention for the db.control structure. Note also that the pointer
  8    85*   will always point to a scope_flags structure even if no scopes have been
  8    86*   set on the relation, the structure is allocated when the db is opened.
  8    87**/
  8    88 
  8    89 
  8    90 /* DESCRIPTION:
  8    91*
  8    92*   This structure is allocated in the area part of the structure  in
  8    93*   mdbm_rm_db_info.incl.pl1  as  part of the resultant model created
  8    94*   at open  time  for  a  database.  There  will  be  one  of  these
  8    95*   rm_rel_info   structures  for  each  relation  appearing  in  the
  8    96*   database view (there may be less than the total in  the  database
  8    97*   for  a  submodel  openings).  There  will  also  be  one for each
  8    98*   temporary relation currently defined for that opening.
  8    99*
  8   100*   The structure in mdbm_rm_rel_array.incl.pl1 contains pointers  to
  8   101*   all  rm_rel_info  structures  allocated. It is used for searching
  8   102*   for the appropriate  structure.  This  array  is  pointed  to  by
  8   103*   rm_db_info. There are two arrays, one for perm rels, one for temp
  8   104*   rels.
  8   105*
  8   106*   The      rm_rel_info      structure      points      to       the
  8   107*   mdbm_rm_attr_info.incl.pl1  structures,  one  for  each attribute
  8   108*   appearing in this view of the relation. Each  of  these  in  turn
  8   109*   point  to a mdbm_rm_domain_info.incl.pl1 structure for the domain
  8   110*   info for each attr.
  8   111*
  8   112*   Most of the other information here deals with  specifics  of  the
  8   113*   relation's  logical  definition,  such as key and secondary index
  8   114*   attribute inidicators, security permissions, and  tuple  physical
  8   115*   construction details.
  8   116*
  8   117**/
  8   118 
  8   119      dcl	   1 rm_rel_info	      aligned based (rmri_ptr), /* relation information */
  8   120 	     2 name	      char (32),		/* from submodel */
  8   121 	     2 model_name	      char (30),		/* from model */
  8   122 	     2 rel_id	      bit (36) aligned,	/* unique id. */
  8   123 	     2 retrieve	      bit (1) unal,		/* operations allowed by this view */
  8   124 	     2 modify	      bit (1) unal,
  8   125 	     2 delete	      bit (1) unal,
  8   126 	     2 store	      bit (1) unal,
  8   127 	     2 total_key	      bit (1) unal,		/* on if view includes full primary key */
  8   128 	     2 indexed	      bit (1) unal,		/* on if exists sec. index */
  8   129 	     2 mdbm_secured	      bit (1) unal,		/* on if mdbm must check security */
  8   130 	     2 status_perm	      bit (1) unal,		/* if user has status. perm. */
  8   131 	     2 append_tuple_perm  bit (1) unal,		/* if user has store perm. */
  8   132 	     2 delete_tuple_perm  bit (1) unal,		/* if user has del. perm. */
  8   133 	     2 unused_perm	      bit (1) unal,		/* for future use. */
  8   134 	     2 last_model_attr_char_var bit (1) unal,	/* on => last model varying attr is char */
  8   135 	     2 reserved	      bit (24) unal,	/* for future use */
  8   136 	     2 num_attr	      fixed bin,		/* total no. of attr. in rel. */
  8   137 	     2 model_num_attr     fixed bin,		/* total attrs in model relation */
  8   138 	     2 nkey_attr	      fixed bin,		/* no. of key attr. */
  8   139 	     2 model_nkey_attr    fixed bin,		/* total number of keys in model */
  8   140 	     2 primary_key_index_id bit (36) aligned,     /* Index id of relation's primary key */
  8   141 	     2 nsec_inds	      fixed bin,		/* no. sec. indexes */
  8   142 	     2 max_key_len	      fixed bin (35),	/* max length (chars) of primary key */
  8   143 	     2 current_tuple_population fixed bin (35),	/* last known total  tuple count for this relation */
  8   144 	     2 last_statistics_update_count fixed bin,	/* number of operations's, since this rels stats were updated */
  8   145 	     2 last_statistics_update_time fixed bin (71),/* last time this rels stats were updated */
  8   146 	     2 last_statistics_update_s_e_ref_num fixed bin (35), /* last select expr ID that updated this rels stats */
  8   147 	     2 ready_mode	      fixed bin,		/* 1 => r, 2 => mr, 3 => u, 4 => l, 5 => sr, 6 => su */
  8   148 	     2 file_type	      fixed bin,		/* 1 => unblocked, 2 => blocked, 3 => temporary */
  8   149 	     2 tuple_id_len	      fixed bin,		/* no. bits in local tuple id */
  8   150 	     2 opening_id	      bit (36) aligned,	/* relation manager opening is */
  8   151 	     2 key_attr_ptrs      (nkey_attr_init refer (rm_rel_info.nkey_attr)) ptr, /* ptrs to key attr. */
  8   152 	     2 attr_ptrs	      (natts_init refer (rm_rel_info.num_attr)) ptr, /* ptrs to all attr. */
  8   153 	     2 id_list_ptr        ptr,		/* Id list for retrieves from the relation */
  8   154                2 scope_flags_ptr    ptr;                    /* pointer to the scope_flags structure for the rel */
  8   155 
  8   156      dcl	   rmri_ptr	      ptr;
  8   157      dcl	   (nkey_attr_init,
  8   158 	   natts_init,
  8   159 	   nvar_atts_init)	      fixed bin;
  8   160 
  8   161 /* END mdbm_rm_rel_info.incl.pl1 */
  8   162 
  8   163 
     1107 
     1108 
     1109 
     1110 
     1111      end mrds_dsl_dl_fscope;
     1112 
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/01/88  1313.9  mrds_dsl_dl_fscope.pl1            >special_ldd>install>MR12.2-1073>mrds_dsl_dl_fscope.pl1
1093         1    08/01/88  1300.0  mrds_dbcb.incl.pl1                >special_ldd>install>MR12.2-1073>mrds_dbcb.incl.pl1
1095         2    10/14/83  1608.7  mdbm_scope_requests.incl.pl1      >ldd>include>mdbm_scope_requests.incl.pl1
1097         3    04/18/85  1628.1  mdbm_scope_info.incl.pl1          >ldd>include>mdbm_scope_info.incl.pl1
1099         4    10/14/83  1609.0  mdbm_dbc.incl.pl1                 >ldd>include>mdbm_dbc.incl.pl1
1101         5    10/23/86  1033.9  mdbm_users.incl.pl1               >ldd>include>mdbm_users.incl.pl1
1103         6    08/01/88  1310.7  mdbm_rm_db_info.incl.pl1          >special_ldd>install>MR12.2-1073>mdbm_rm_db_info.incl.pl1
1105         7    10/14/83  1609.1  mdbm_rm_rel_array.incl.pl1        >ldd>include>mdbm_rm_rel_array.incl.pl1
1107         8    10/14/83  1609.1  mdbm_rm_rel_info.incl.pl1         >ldd>include>mdbm_rm_rel_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ALIVE                           000006 constant        bit(1)                   initial packed unaligned dcl 5-136 ref 509 517 526
CHAR_Q_F                        000000 constant        char(8)                  initial packed unaligned dcl 5-123 ref 407
DEAD                                   constant        bit(1)                   initial packed unaligned dcl 5-138 ref 506 515
DEL                             000024 constant        bit(1)                   initial packed unaligned dcl 5-134 set ref 643*
DQ_OPEN                         000006 constant        bit(1)                   initial packed unaligned dcl 5-119 set ref 531*
FREE_FIL_LIST                   000006 constant        bit(1)                   initial packed unaligned dcl 5-150 set ref 324* 531*
                                                                                  945*
NO_DQ_OPEN                      000024 constant        bit(1)                   initial packed unaligned dcl 5-121 set ref 324* 945*
NULL_OFS                               constant        bit(18)                  initial packed unaligned dcl 5-118 ref 781 790 822
                                                                                  901 930 935
OFF                                    constant        bit(1)                   initial packed unaligned dcl 1063 ref 221 406 422
                                                                                  454 466 530 614 668 671 674 677 680 683 686 689
                                                                                  692 700 786 787
ON                                     constant        bit(1)                   initial packed unaligned dcl 1064 ref 185 316 421
                                                                                  469 480 535 536 537 616 618 703 781 790 794 795
                                                                                  800
QUE_FREE                        000272 automatic       fixed bin(71,0)          dcl 5-124 set ref 407* 465*
a_cd_ptr                               parameter       pointer                  dcl 369 ref 358 358 358 378
a_code                                 parameter       fixed bin(35,0)          dcl 348 set ref 340 340 352
a_db_index                             parameter       fixed bin(17,0)          dcl 347 set ref 340 340 351
a_dbcb_ptr                             parameter       pointer                  dcl 369 ref 358 358 358 377
a_ptr                                  parameter       pointer                  dcl 817 ref 809 822
active_scope_seen               000427 automatic       bit(1)                   packed unaligned dcl 663 set ref 786* 794* 800
active_scopes             5            based           fixed bin(17,0)          level 2 dcl 3-32 set ref 173 315* 748* 748
active_users_ofs         21(18)        based           bit(18)                  level 4 packed packed unaligned dcl 4-14 set ref
                                                                                  191* 718* 718*
actual_conflict_detail          000214 automatic       structure                level 1 packed packed unaligned dcl 1067 set ref 642
actual_permits                  000212 automatic       structure                level 1 packed packed unaligned dcl 1065 set ref
                                                                                  428* 440 440
actual_prevents                 000213 automatic       structure                level 1 packed packed unaligned dcl 1066 set ref
                                                                                  428* 440 440
addr                                                   builtin function         dcl 1023 ref 198 351 352 440 440 440 440 440 440 440
                                                                                  440 642 699 706 718
allowance_count          20            based           fixed bin(17,0)          level 2 dcl 5-57 ref 480
append_tuple              0(34) 000213 automatic       bit(1)                   level 2 in structure "actual_prevents" packed packed
                                                                                  unaligned dcl 1066 in procedure "dl_fscope" set
                                                                                  ref 437*
append_tuple             26(01)        based           bit(1)                   array level 5 in structure "scope_info" packed
                                                                                  packed unaligned dcl 3-32 in procedure "dl_fscope"
                                                                                  set ref 674*
append_tuple             10(04)        based           bit(1)                   level 3 in structure "fil_list" packed packed
                                                                                  unaligned dcl 5-89 in procedure "dl_fscope" set
                                                                                  ref 437 772* 772 776 911
append_tuple              7(35)        based           bit(1)                   level 3 in structure "fil_list" packed packed
                                                                                  unaligned dcl 5-89 in procedure "dl_fscope" set
                                                                                  ref 432 760* 760 764 792
append_tuple              0(34)        based           bit(1)                   level 2 in structure "prevent_requests" packed
                                                                                  packed unaligned dcl 2-22 in procedure "dl_fscope"
                                                                                  ref 630 686 729 772
append_tuple              0(34)        based           bit(1)                   level 2 in structure "permit_requests" packed packed
                                                                                  unaligned dcl 2-20 in procedure "dl_fscope" ref
                                                                                  630 674 725 760
append_tuple              0(34) 000214 automatic       bit(1)                   level 3 in structure "actual_conflict_detail" packed
                                                                                  packed unaligned dcl 1067 in procedure "dl_fscope"
                                                                                  set ref 562
append_tuple              1(34) 000214 automatic       bit(1)                   level 3 in structure "actual_conflict_detail" packed
                                                                                  packed unaligned dcl 1067 in procedure "dl_fscope"
                                                                                  set ref 579
append_tuple             27(01)        based           bit(1)                   array level 5 in structure "scope_info" packed
                                                                                  packed unaligned dcl 3-32 in procedure "dl_fscope"
                                                                                  set ref 686*
append_tuple              0(34) 000212 automatic       bit(1)                   level 2 in structure "actual_permits" packed packed
                                                                                  unaligned dcl 1065 in procedure "dl_fscope" set
                                                                                  ref 432*
arg_error                       000204 stack reference condition                dcl 1022 ref 130 135
arg_index                       000125 automatic       fixed bin(17,0)          dcl 989 set ref 224* 225* 270 275
arg_len                         000117 automatic       fixed bin(17,0)          dcl 989 set ref 134* 138* 270* 275*
args_exp                        000124 automatic       fixed bin(17,0)          dcl 989 set ref 127* 130 354* 376*
baseno                                                 builtin function         dcl 1087 ref 736
baseptr                                                builtin function         dcl 1088 ref 736
bypass_count             21            based           fixed bin(17,0)          level 2 dcl 5-57 set ref 479* 479 480
caller_name                     000220 automatic       char(32)                 initial packed unaligned dcl 1074 set ref 251* 588*
                                                                                  1074*
cd_ptr                          000162 automatic       pointer                  dcl 1013 set ref 134* 137 156 161 333 335 352* 378*
                                                                                  386 388 950
cleanup                         000176 stack reference condition                dcl 1022 ref 165
code                                   based           fixed bin(35,0)          dcl 969 set ref 137* 156* 161* 333* 335* 386* 388*
                                                                                  950
common                                 based           structure                level 1 packed packed unaligned dcl 2-13
conflict_detail_known           000245 automatic       bit(1)                   initial packed unaligned dcl 1079 set ref 552 647*
                                                                                  1079*
conflict_detail_ptr             000256 automatic       pointer                  dcl 2-40 set ref 642* 643*
conflict_relation               000235 automatic       char(32)                 packed unaligned dcl 1078 set ref 588* 648*
conflict_sw                     000102 automatic       bit(1)                   packed unaligned dcl 975 in procedure "dl_fscope"
                                                                                  set ref 422* 424 440* 451 453* 454 643* 645
conflict_sw                            parameter       bit(1)                   packed unaligned dcl 500 in procedure
                                                                                  "check_dead_proc" set ref 492 530*
conflict_ul_ptr                 000172 automatic       pointer                  dcl 1013 set ref 440* 506 510 528 531* 536
continue                        000230 automatic       char(1)                  initial packed unaligned dcl 1075 set ref 251* 588*
                                                                                  1075*
cu_$arg_count                   000010 constant        entry                    external dcl 1030 ref 129
cu_$arg_ptr                     000012 constant        entry                    external dcl 1030 ref 134 138 225 270 275
current_rmg_permits             000106 automatic       bit(2)                   packed unaligned dcl 980 set ref 718* 723
current_rmg_prevents            000107 automatic       bit(2)                   packed unaligned dcl 981 set ref 718* 724
data                                   based           structure                level 2 in structure "dbcb" dcl 1-142 in procedure
                                                                                  "dl_fscope"
data                                   based           structure                level 2 in structure "rm_db_info" dcl 6-86
                                                                                  in procedure "dl_fscope"
db_index                               based           fixed bin(35,0)          dcl 963 set ref 142*
db_lock_id               11            based           bit(36)                  level 3 dcl 5-57 ref 510
dbc                                    based           structure                level 1 unaligned dcl 4-14
dbc_ptr                         000262 automatic       pointer                  initial dcl 4-44 in procedure "dl_fscope" set ref
                                                                                  124* 164* 178 185 191* 191 203* 205* 324* 335 350*
                                                                                  375* 4-44* 411* 411 420* 440* 458* 470 470 485*
                                                                                  531* 535 612* 620* 698* 707* 718* 718 718* 718 751
                                                                                  785 797 945* 948 953
dbc_ptr                  30            based           pointer                  level 3 in structure "dbcb" dcl 1-142 in procedure
                                                                                  "dl_fscope" set ref 153* 164
dbc_uid                 303            based           bit(36)                  level 3 dcl 1-142 ref 159
dbcb                                   based           structure                level 1 dcl 1-142
dbcb_data                              based           structure                level 1 unaligned dcl 1-148
dbcb_ptr                        000250 automatic       pointer                  dcl 1-146 set ref 142* 145 153 159 164 167 169 170
                                                                                  377* 737
dbi_ptr                         000164 automatic       pointer                  dcl 1013 set ref 138* 142 351*
dead_proc                16(23)        based           bit(1)                   level 3 packed packed unaligned dcl 5-57 set ref 506
                                                                                  536*
dead_proc_conflict       16(24)        based           bit(1)                   level 3 packed packed unaligned dcl 5-57 set ref
                                                                                  537*
dead_proc_flag            4(01)        based           bit(1)                   level 4 packed packed unaligned dcl 4-14 set ref
                                                                                  535*
delete_tuple              0(33) 000214 automatic       bit(1)                   level 3 in structure "actual_conflict_detail" packed
                                                                                  packed unaligned dcl 1067 in procedure "dl_fscope"
                                                                                  set ref 565
delete_tuple              0(33)        based           bit(1)                   level 2 in structure "prevent_requests" packed
                                                                                  packed unaligned dcl 2-22 in procedure "dl_fscope"
                                                                                  ref 630 689 729 774
delete_tuple              7(34)        based           bit(1)                   level 3 in structure "fil_list" packed packed
                                                                                  unaligned dcl 5-89 in procedure "dl_fscope" set
                                                                                  ref 433 762* 762 764 792
delete_tuple             27(02)        based           bit(1)                   array level 5 in structure "scope_info" packed
                                                                                  packed unaligned dcl 3-32 in procedure "dl_fscope"
                                                                                  set ref 689*
delete_tuple              0(33) 000212 automatic       bit(1)                   level 2 in structure "actual_permits" packed packed
                                                                                  unaligned dcl 1065 in procedure "dl_fscope" set
                                                                                  ref 433*
delete_tuple             10(05)        based           bit(1)                   level 3 in structure "fil_list" packed packed
                                                                                  unaligned dcl 5-89 in procedure "dl_fscope" set
                                                                                  ref 438 774* 774 776 911
delete_tuple             26(02)        based           bit(1)                   array level 5 in structure "scope_info" packed
                                                                                  packed unaligned dcl 3-32 in procedure "dl_fscope"
                                                                                  set ref 677*
delete_tuple              0(33) 000213 automatic       bit(1)                   level 2 in structure "actual_prevents" packed packed
                                                                                  unaligned dcl 1066 in procedure "dl_fscope" set
                                                                                  ref 438*
delete_tuple              1(33) 000214 automatic       bit(1)                   level 3 in structure "actual_conflict_detail" packed
                                                                                  packed unaligned dcl 1067 in procedure "dl_fscope"
                                                                                  set ref 582
delete_tuple              0(33)        based           bit(1)                   level 2 in structure "permit_requests" packed packed
                                                                                  unaligned dcl 2-20 in procedure "dl_fscope" ref
                                                                                  630 677 725 762
divide                                                 builtin function         dcl 1081 ref 216
ds_rmri_ptr                     000432 automatic       pointer                  dcl 664 set ref 736* 737
entry_name                      000141 automatic       char(32)                 packed unaligned dcl 1008 set ref 126* 178 214 304
                                                                                  304 335 355* 374* 386
error_table_$invalid_lock_reset 000042 external static fixed bin(35,0)          dcl 1050 ref 181 515
error_table_$lock_wait_time_exceeded
                                000040 external static fixed bin(35,0)          dcl 1050 ref 517 950
error_table_$locked_by_this_process
                                000044 external static fixed bin(35,0)          dcl 1050 ref 181 517
error_table_$wrong_no_of_args   000036 external static fixed bin(35,0)          dcl 1050 set ref 218*
ev_chn_id                12            based           fixed bin(71,0)          level 3 dcl 5-57 set ref 465*
event_signal_sw          16(22)        based           bit(1)                   level 3 packed packed unaligned dcl 5-57 set ref 415
                                                                                  469*
f_ptr                           000452 automatic       pointer                  dcl 890 set ref 901* 903* 905 907 908 908 911 911
                                                                                  911 911 930 930* 932* 932
fil_list                               based           structure                level 1 unaligned dcl 5-89 set ref 751
fil_list_ofs             22            based           bit(18)                  level 3 packed packed unaligned dcl 5-57 set ref
                                                                                  420* 612* 698* 699 781 785 901 903
find_ul_ptr                     000170 automatic       pointer                  dcl 1013 set ref 191* 195 196 198 200 201* 203* 203
                                                                                  205* 205
finished                        000430 automatic       bit(1)                   packed unaligned dcl 663 set ref 787* 788 790* 795*
fixed                                                  builtin function         dcl 1082 ref 407
fl_ptr                          000266 automatic       pointer                  initial dcl 5-110 set ref 5-110* 420* 424 426 430
                                                                                  431 432 433 435 436 437 438 458* 458 612* 616 618
                                                                                  620* 620 626 643* 698* 702 703 706 707* 707 715
                                                                                  736 736 750 751 756 756 758 758 760 760 762 762
                                                                                  764 764 764 764 768 768 770 770 772 772 774 774
                                                                                  776 776 776 776 784 785* 790 792 792 792 797* 797
                                                                                  804*
flags                    26            based           structure                array level 3 in structure "scope_info" dcl 3-32
                                                                                  in procedure "dl_fscope" set ref 312* 746
flags                     4            based           structure                level 3 in structure "dbc" packed packed unaligned
                                                                                  dcl 4-14 in procedure "dl_fscope"
flags                    16            based           structure                level 2 in structure "user_list" packed packed
                                                                                  unaligned dcl 5-57 in procedure "dl_fscope"
flo_ptr                         000174 automatic       pointer                  dcl 1013 set ref 699* 706* 750
found                           000416 automatic       bit(1)                   packed unaligned dcl 609 set ref 614* 615 616* 618*
found_matching_fil_list         000426 automatic       bit(1)                   packed unaligned dcl 663 set ref 700* 702 703*
get_process_id_                 000024 constant        entry                    external dcl 1030 ref 194 898
hcs_$get_uid_seg                000022 constant        entry                    external dcl 1030 ref 153
hcs_$wakeup                     000020 constant        entry                    external dcl 1030 ref 465
i                               000121 automatic       fixed bin(17,0)          dcl 989 set ref 223* 224*
icode                           000127 automatic       fixed bin(35,0)          dcl 1001 set ref 134* 135 138* 139 139* 148* 153*
                                                                                  154 178* 181 181 181* 183 186* 225* 227 227* 270*
                                                                                  272 272* 275* 277 277* 324* 326 326* 520* 531* 540
                                                                                  540* 737* 739 739* 953*
ids                                    based           structure                level 2 unaligned dcl 5-57
index                                                  builtin function         dcl 1083 ref 246
info_ptr                        000232 automatic       pointer                  initial dcl 1076 set ref 251* 588* 1076*
length                                                 builtin function         dcl 1084 ref 233
make_user_inactive              000103 automatic       bit(1)                   packed unaligned dcl 976 set ref 221* 316* 324 781*
                                                                                  945
mod                                                    builtin function         dcl 1085 ref 216
model_name                             based           char(30)                 array level 3 dcl 7-34 ref 258
model_rel_name                  000151 automatic       char(30)                 packed unaligned dcl 1009 set ref 258* 283 426* 440
                                                                                  440 618 703 718*
modify_attr               0(32)        based           bit(1)                   level 2 in structure "prevent_requests" packed
                                                                                  packed unaligned dcl 2-22 in procedure "dl_fscope"
                                                                                  ref 630 683 729 770
modify_attr               7(33)        based           bit(1)                   level 3 in structure "fil_list" packed packed
                                                                                  unaligned dcl 5-89 in procedure "dl_fscope" set
                                                                                  ref 431 758* 758 764 792
modify_attr               0(32)        based           bit(1)                   level 2 in structure "permit_requests" packed packed
                                                                                  unaligned dcl 2-20 in procedure "dl_fscope" ref
                                                                                  630 671 725 758
modify_attr               0(32) 000214 automatic       bit(1)                   level 3 in structure "actual_conflict_detail" packed
                                                                                  packed unaligned dcl 1067 in procedure "dl_fscope"
                                                                                  set ref 559
modify_attr               0(32) 000213 automatic       bit(1)                   level 2 in structure "actual_prevents" packed packed
                                                                                  unaligned dcl 1066 in procedure "dl_fscope" set
                                                                                  ref 436*
modify_attr              26(03)        based           bit(1)                   array level 5 in structure "scope_info" packed
                                                                                  packed unaligned dcl 3-32 in procedure "dl_fscope"
                                                                                  set ref 671*
modify_attr               0(32) 000212 automatic       bit(1)                   level 2 in structure "actual_permits" packed packed
                                                                                  unaligned dcl 1065 in procedure "dl_fscope" set
                                                                                  ref 431*
modify_attr               1(32) 000214 automatic       bit(1)                   level 3 in structure "actual_conflict_detail" packed
                                                                                  packed unaligned dcl 1067 in procedure "dl_fscope"
                                                                                  set ref 576
modify_attr              27(03)        based           bit(1)                   array level 5 in structure "scope_info" packed
                                                                                  packed unaligned dcl 3-32 in procedure "dl_fscope"
                                                                                  set ref 683*
modify_attr              10(06)        based           bit(1)                   level 3 in structure "fil_list" packed packed
                                                                                  unaligned dcl 5-89 in procedure "dl_fscope" set
                                                                                  ref 436 770* 770 776 911
mrds_data_$lock_wait_time       000046 external static fixed bin(35,0)          dcl 1050 ref 178
mrds_error_$invalid_db_index    000050 external static fixed bin(35,0)          dcl 1050 set ref 145*
mrds_error_$non_scope_ready     000060 external static fixed bin(35,0)          dcl 1050 set ref 167* 264*
mrds_error_$rel_name_too_long   000052 external static fixed bin(35,0)          dcl 1050 set ref 233*
mrds_error_$scope_empty         000054 external static fixed bin(35,0)          dcl 1050 ref 173 386
mrds_error_$scope_not_found     000062 external static fixed bin(35,0)          dcl 1050 set ref 291* 588*
mrds_error_$unknown_proc_id     000064 external static fixed bin(35,0)          dcl 1050 set ref 209*
mrds_error_$unknown_relation_name
                                000056 external static fixed bin(35,0)          dcl 1050 set ref 251* 254* 286*
mu_check_conflict               000034 constant        entry                    external dcl 1040 ref 643
mu_check_scope                  000030 constant        entry                    external dcl 1040 ref 440
mu_database_index$get_resultant_model_pointer
                                000026 constant        entry                    external dcl 1040 ref 142
mu_de_queue_user                000032 constant        entry                    external dcl 1040 ref 324 531 945
my_pid                          000101 automatic       bit(36)                  packed unaligned dcl 974 set ref 194* 196
my_process_id                   000454 automatic       bit(36)                  packed unaligned dcl 891 set ref 898* 905
name                      6            based           char(30)                 array level 3 in structure "scope_info" dcl 3-32
                                                                                  in procedure "dl_fscope" ref 283
name                                   based           char(30)                 level 2 in structure "fil_list" packed packed
                                                                                  unaligned dcl 5-89 in procedure "dl_fscope" ref
                                                                                  426 618 703 907
name                      1            based           structure                array level 2 in structure "rm_rel_array" packed
                                                                                  packed unaligned dcl 7-34 in procedure "dl_fscope"
                                                                                  ref 246
nargs                           000116 automatic       fixed bin(17,0)          dcl 989 set ref 129* 130 134* 216 216
new_rmg_permits                 000110 automatic       bit(2)                   dcl 982 set ref 725* 734 737*
new_rmg_prevents                000111 automatic       bit(2)                   dcl 983 set ref 729* 734 737*
next_active_ofs          22(18)        based           bit(18)                  level 3 packed packed unaligned dcl 5-57 set ref
                                                                                  203* 205* 935 937
next_ofs                 11            based           bit(18)                  level 2 packed packed unaligned dcl 5-89 set ref
                                                                                  458* 620* 706 707* 750 797 930 932
next_waiting_ofs         23            based           bit(18)                  level 3 packed packed unaligned dcl 5-57 set ref
                                                                                  485*
nfiles                    4            based           fixed bin(17,0)          level 2 dcl 3-32 ref 283 286 311
null                                                   builtin function         dcl 1023 in procedure "dl_fscope" ref 124 145 167
                                                                                  192 195 201 209 350 375 1076 3-59 4-44 5-109 5-110
                                                                                  413 424 616 626 702 715 900 901 905 930 935 948
null                                                   builtin function         dcl 820 in procedure "convert" ref 824
num_filns                       000270 automatic       fixed bin(17,0)          dcl 5-112 set ref 125*
num_rels                               based           fixed bin(17,0)          level 2 dcl 7-34 ref 246 258 262
num_tuples                      000120 automatic       fixed bin(17,0)          dcl 989 set ref 216* 223
offsets                  21            based           structure                level 3 in structure "dbc" packed packed unaligned
                                                                                  dcl 4-14 in procedure "dl_fscope"
offsets                  22            based           structure                level 2 in structure "user_list" packed packed
                                                                                  unaligned dcl 5-57 in procedure "dl_fscope"
ofs                                    parameter       bit(18)                  packed unaligned dcl 818 ref 809 822 822
old_rmg_permits                 000112 automatic       bit(2)                   packed unaligned dcl 984 set ref 723* 734
old_rmg_prevents                000113 automatic       bit(2)                   packed unaligned dcl 985 set ref 724* 734
opening_id               42            based           bit(36)                  level 2 dcl 8-119 set ref 737*
ophset                                 based           bit(18)                  packed unaligned dcl 1011 set ref 750*
other_rmg_permits               000114 automatic       bit(2)                   packed unaligned dcl 986 set ref 718* 723 725 729
other_rmg_prevents              000115 automatic       bit(2)                   packed unaligned dcl 987 set ref 718* 724
passive_sw               16(18)        based           bit(1)                   level 3 packed packed unaligned dcl 5-57 set ref 528
                                                                                  800*
permit_conflict                 000336 automatic       varying char(80)         dcl 600 set ref 554* 556* 556 559* 559 562* 562 565*
                                                                                  565 568 568* 588*
permit_requests                        based           structure                level 1 packed packed unaligned dcl 2-20 ref 627
permit_requests_ptr             000252 automatic       pointer                  dcl 2-24 set ref 270* 627 630 630 630 630 643* 668
                                                                                  671 674 677 725 725 725 725 756 758 760 762
permits                  26            based           structure                array level 4 in structure "scope_info" dcl 3-32
                                                                                  in procedure "dl_fscope" set ref 692
permits                         000214 automatic       structure                level 2 in structure "actual_conflict_detail" packed
                                                                                  packed unaligned dcl 1067 in procedure "dl_fscope"
                                                                                  set ref 627*
permits                   7(18)        based           structure                level 2 in structure "fil_list" packed packed
                                                                                  unaligned dcl 5-89 in procedure "dl_fscope"
pointer                                                builtin function         dcl 1086 ref 736 785 797
pos_in_rmfa                     000123 automatic       fixed bin(17,0)          dcl 989 set ref 246* 250 257* 257 258 262
pos_in_si                       000122 automatic       fixed bin(17,0)          dcl 989 set ref 283* 283* 286 311* 312 312 312 312
                                                                                  312 312 312 312 312 312 312 312 312 312* 668 671
                                                                                  674 677 680 683 686 689 692 692 692 746
prevent_conflict                000363 automatic       varying char(80)         dcl 600 set ref 571* 573* 573 576* 576 579* 579 582*
                                                                                  582 585 585* 588*
prevent_requests                       based           structure                level 1 packed packed unaligned dcl 2-22 ref 628
prevent_requests_ptr            000254 automatic       pointer                  dcl 2-24 set ref 275* 628 630 630 630 630 643* 680
                                                                                  683 686 689 729 729 729 729 768 770 772 774
prevents                 27            based           structure                array level 4 in structure "scope_info" dcl 3-32
                                                                                  in procedure "dl_fscope" set ref 692
prevents                 10(02)        based           structure                level 2 in structure "fil_list" packed packed
                                                                                  unaligned dcl 5-89 in procedure "dl_fscope"
prevents                  1     000214 automatic       structure                level 2 in structure "actual_conflict_detail" packed
                                                                                  packed unaligned dcl 1067 in procedure "dl_fscope"
                                                                                  set ref 628*
priority_high            16(21)        based           bit(1)                   level 3 packed packed unaligned dcl 5-57 set ref
                                                                                  480*
process_id               10            based           bit(36)                  level 3 packed packed unaligned dcl 5-57 set ref 196
                                                                                  465* 905
proper                                 based           structure                level 2 unaligned dcl 4-14
ptr                                                    builtin function         dcl 1089 in procedure "dl_fscope" ref 903 932 937
ptr                                                    builtin function         dcl 820 in procedure "convert" ref 822
ptr_bit_string                         based           bit(72)                  packed unaligned dcl 1005 set ref 198 718*
ra_ptr                  134            based           pointer                  level 3 dcl 6-86 ref 171
rdbi_bits                14            based           bit(72)                  level 3 packed packed unaligned dcl 5-57 ref 198 916
rdbi_ptr                               based           pointer                  level 3 in structure "dbcb" dcl 1-142 in procedure
                                                                                  "dl_fscope" ref 170
rdbi_ptr                        000274 automatic       pointer                  dcl 6-90 in procedure "dl_fscope" set ref 170* 171
                                                                                  198 718
rdbi_ptr_bits                          parameter       bit(72)                  packed unaligned dcl 881 ref 871 916
read_attr                10(03)        based           bit(1)                   level 3 in structure "fil_list" packed packed
                                                                                  unaligned dcl 5-89 in procedure "dl_fscope" set
                                                                                  ref 435 768* 768 911
read_attr                10(01)        based           bit(1)                   level 3 in structure "fil_list" packed packed
                                                                                  unaligned dcl 5-89 in procedure "dl_fscope" set
                                                                                  ref 430 756* 756 908
read_attr                 0(35) 000214 automatic       bit(1)                   level 3 in structure "actual_conflict_detail" packed
                                                                                  packed unaligned dcl 1067 in procedure "dl_fscope"
                                                                                  set ref 556
read_attr                26            based           bit(1)                   array level 5 in structure "scope_info" packed
                                                                                  packed unaligned dcl 3-32 in procedure "dl_fscope"
                                                                                  set ref 668*
read_attr                 0(35) 000212 automatic       bit(1)                   level 2 in structure "actual_permits" packed packed
                                                                                  unaligned dcl 1065 in procedure "dl_fscope" set
                                                                                  ref 430*
read_attr                 0(35)        based           bit(1)                   level 2 in structure "prevent_requests" packed
                                                                                  packed unaligned dcl 2-22 in procedure "dl_fscope"
                                                                                  ref 630 680 729 768
read_attr                 1(35) 000214 automatic       bit(1)                   level 3 in structure "actual_conflict_detail" packed
                                                                                  packed unaligned dcl 1067 in procedure "dl_fscope"
                                                                                  set ref 573
read_attr                 0(35) 000213 automatic       bit(1)                   level 2 in structure "actual_prevents" packed packed
                                                                                  unaligned dcl 1066 in procedure "dl_fscope" set
                                                                                  ref 435*
read_attr                 0(35)        based           bit(1)                   level 2 in structure "permit_requests" packed packed
                                                                                  unaligned dcl 2-20 in procedure "dl_fscope" ref
                                                                                  630 668 725 756
read_attr                27            based           bit(1)                   array level 5 in structure "scope_info" packed
                                                                                  packed unaligned dcl 3-32 in procedure "dl_fscope"
                                                                                  set ref 680*
ready_mode               37            based           fixed bin(17,0)          level 2 dcl 8-119 ref 264
rel                                                    builtin function         dcl 1023 ref 736 790
rel_data                               based           structure                array level 2 dcl 7-34
rel_len                         000126 automatic       fixed bin(17,0)          dcl 989 set ref 225* 233 245 251 251 648
rel_name                               based           char                     packed unaligned dcl 965 set ref 233 245 251* 648
rel_name_32                     000131 automatic       char(32)                 packed unaligned dcl 1007 set ref 245* 246
rel_ptr                         000166 automatic       pointer                  dcl 1013 set ref 225* 233 245 251 648
relation_name                          parameter       char(30)                 packed unaligned dcl 880 ref 871 907
relmgr_entries          146            based           structure                level 3 dcl 1-142
relmgr_except_my_permits               parameter       bit(2)                   packed unaligned dcl 884 set ref 871 924*
relmgr_except_other_permits            parameter       bit(2)                   packed unaligned dcl 885 set ref 871 926*
relmgr_my_permits                      parameter       bit(2)                   packed unaligned dcl 882 set ref 871 899* 918* 918
relmgr_other_permits                   parameter       bit(2)                   packed unaligned dcl 883 set ref 871 899* 920* 920
result                          000442 automatic       pointer                  dcl 816 set ref 822* 824* 826
return_value                    000234 automatic       fixed bin(35,0)          initial dcl 1077 set ref 251* 588* 1077*
ri_ptr                                 based           pointer                  array level 3 packed packed unaligned dcl 7-34 ref
                                                                                  262
rm_db_info                             based           structure                level 1 dcl 6-86
rm_db_info_data                        based           structure                level 1 unaligned dcl 6-92
rm_rel_array                           based           structure                level 1 dcl 7-34
rm_rel_info                            based           structure                level 1 dcl 8-119
rmra_ptr                        000276 automatic       pointer                  dcl 7-43 set ref 171* 246 258 262
rmri_ptr                 12            based           pointer                  level 2 in structure "fil_list" dcl 5-89
                                                                                  in procedure "dl_fscope" ref 736 736
rmri_ptr                        000300 automatic       pointer                  dcl 8-156 in procedure "dl_fscope" set ref 262* 264
rtrim                                                  builtin function         dcl 1090 ref 233
saved_fl_ptr                    000246 automatic       pointer                  dcl 1080 set ref 784* 804
scope                     6            based           structure                array level 2 dcl 3-32
scope_flags                            based           structure                level 1 dcl 3-42
scope_info                             based           structure                level 1 dcl 3-32
scope_lock               13            based           bit(36)                  level 3 dcl 4-14 set ref 178* 335* 953*
scope_ptr                34            based           pointer                  level 3 in structure "dbcb" dcl 1-142 in procedure
                                                                                  "dl_fscope" ref 167 169
scope_ptr                       000260 automatic       pointer                  initial dcl 3-59 in procedure "dl_fscope" set ref
                                                                                  169* 173 283 283 286 311 312 315 3-59* 668 671 674
                                                                                  677 680 683 686 689 692 692 692 746 748 748
set_lock_$lock                  000014 constant        entry                    external dcl 1030 ref 178 510
set_lock_$unlock                000016 constant        entry                    external dcl 1030 ref 335 953
set_scope               166            based           entry variable           level 4 dcl 1-142 ref 737
state                           000100 automatic       fixed bin(35,0)          dcl 969 set ref 465* 466 510* 513 515 517 517 520
static_area              30            based           area                     level 2 dcl 4-14 ref 751
status                          000104 automatic       bit(1)                   packed unaligned dcl 977 in procedure "dl_fscope"
                                                                                  set ref 453*
status                                 parameter       bit(1)                   packed unaligned dcl 500 in procedure
                                                                                  "check_dead_proc" set ref 492 506* 509* 515* 517*
                                                                                  526
string                                                 builtin function         dcl 1023 ref 246 692 692 746
sub_err_                        000066 constant        entry                    external dcl 1073 ref 251 588
suf_scope                       000417 automatic       bit(1)                   packed unaligned dcl 654 set ref 625* 635* 637* 646*
                                                                                  652
temp_code                              parameter       fixed bin(35,0)          dcl 384 ref 381 386 388
temp_relmgr_my_permits          000455 automatic       bit(2)                   packed unaligned dcl 892 set ref 908* 918 924
temp_relmgr_other_permits       000456 automatic       bit(2)                   packed unaligned dcl 893 set ref 911* 920 926
temp_uid                        000130 automatic       bit(36)                  dcl 1003 set ref 153* 159
touched                  30            based           bit(1)                   array level 4 packed packed unaligned dcl 3-32 set
                                                                                  ref 692*
trouble_switch            4            based           bit(1)                   level 4 packed packed unaligned dcl 4-14 set ref
                                                                                  185*
u_ptr                           000460 automatic       pointer                  dcl 894 set ref 897* 900 901 903 903 905 916 932 935
                                                                                  935* 937* 937 937
ul_ptr                          000264 automatic       pointer                  initial dcl 5-109 set ref 192* 200* 209 324* 5-109*
                                                                                  411* 413 415 420 440* 465 465 469 479 479 480 480
                                                                                  480 485* 485 537 612 698 699 781 785 800 945*
unspec                                                 builtin function         dcl 1091 set ref 407 428* 428*
unused_conflict_detail          000216 automatic       structure                level 1 packed packed unaligned dcl 1070 set ref 440
                                                                                  440
update                   10(02)        based           bit(1)                   level 3 in structure "fil_list" packed packed
                                                                                  unaligned dcl 5-89 in procedure "dl_fscope" set
                                                                                  ref 776*
update                   10            based           bit(1)                   level 3 in structure "fil_list" packed packed
                                                                                  unaligned dcl 5-89 in procedure "dl_fscope" set
                                                                                  ref 764* 908
user_list                              based           structure                level 1 unaligned dcl 5-57
user_list_ptr                          parameter       pointer                  dcl 879 ref 871 897
waiting_users_ofs        22            based           bit(18)                  level 4 packed packed unaligned dcl 4-14 set ref
                                                                                  411*
wakeup                          000105 automatic       bit(1)                   packed unaligned dcl 978 set ref 406* 413 421* 454*
                                                                                  463 466* 477
wakeup_waiters            6            based           fixed bin(17,0)          level 3 dcl 4-14 set ref 470* 470

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALARM                                  automatic       fixed bin(71,0)          dcl 5-127
CHAR_ALARM                             internal static char(8)                  initial packed unaligned dcl 5-125
FIRST_QUEUE                            internal static bit(1)                   initial packed unaligned dcl 5-128
QUEUE_AGAIN                            internal static bit(1)                   initial packed unaligned dcl 5-130
Q_PRM                                  internal static fixed bin(35,0)          initial dcl 5-140
Q_PRM_BITS                             internal static bit(2)                   initial packed unaligned dcl 5-144
Q_PRV                                  internal static fixed bin(35,0)          initial dcl 5-142
Q_PRV_BITS                             internal static bit(2)                   initial packed unaligned dcl 5-146
REL_SEC                                internal static bit(2)                   initial packed unaligned dcl 5-148
SAVE_FIL_LIST                          internal static bit(1)                   initial packed unaligned dcl 5-152
SET                                    internal static bit(1)                   initial packed unaligned dcl 5-132
VERSION_NBR                            internal static fixed bin(17,0)          initial dcl 4-46
WAIT                                   internal static fixed bin(17,0)          initial dcl 5-115
conflict_detail                        based           structure                level 1 packed packed unaligned dcl 2-36
max_file_init                          automatic       fixed bin(17,0)          dcl 3-58
natts_init                             automatic       fixed bin(17,0)          dcl 8-157
nkey_attr_init                         automatic       fixed bin(17,0)          dcl 8-157
nvar_atts_init                         automatic       fixed bin(17,0)          dcl 8-157
rm_num_rels_init                       automatic       fixed bin(17,0)          dcl 7-44
scope_rdy                              internal static bit(6)                   initial packed unaligned dcl 3-60
scope_rdy_array                        based           bit(1)                   array packed unaligned dcl 3-61
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 1050

NAMES DECLARED BY EXPLICIT CONTEXT.
calc_process_scopes             003715 constant        entry                    internal dcl 871 ref 718
check_dead_proc                 002062 constant        entry                    internal dcl 492 ref 453
clean_up                        004135 constant        entry                    internal dcl 943 ref 165 390
common_label                    000334 constant        label                    dcl 142 ref 356
convert                         003672 constant        entry                    internal dcl 809 ref 191 203 205 411 420 458 485 612
                                                                                  620 698 707 718 718
delete_scope                    002740 constant        entry                    internal dcl 658 ref 296
dl_fscope                       000223 constant        entry                    external dcl 27
dl_fscope_all                   001433 constant        entry                    external dcl 340
dl_fscope_all_pntr              001504 constant        entry                    external dcl 358
error                           001542 constant        entry                    internal dcl 381 ref 139 145 167 173 186 209 218 227
                                                                                  233 254 264 272 277 286 291 326 540 739
examine_queue                   001564 constant        entry                    internal dcl 395 ref 331
exit                            001426 constant        label                    dcl 337 set ref 157 162 391
mrds_dsl_dl_fscope              000233 constant        entry                    external dcl 27
mrds_dsl_dl_fscope_all          001444 constant        entry                    external dcl 340
mrds_dsl_scope_all_pntr         001473 constant        entry                    external dcl 358
pntr                            001515 constant        entry                    external dcl 358
pntr2                           000360 constant        label                    dcl 148 ref 379
report_scope_detail             002221 constant        entry                    internal dcl 547 ref 290
sufficient_scope_exists         002537 constant        entry                    internal dcl 604 ref 289

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4662        4752    4243        4672
Length      5402    4243        70         414     416           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
dl_fscope                           604 external procedure  is an external procedure.  
on unit on line 165                  64 on unit               
error                                   internal procedure  shares stack frame of external procedure dl_fscope.  
examine_queue                           internal procedure  shares stack frame of external procedure dl_fscope.  
check_dead_proc                         internal procedure  shares stack frame of external procedure dl_fscope.  
report_scope_detail                     internal procedure  shares stack frame of external procedure dl_fscope.  
sufficient_scope_exists                 internal procedure  shares stack frame of external procedure dl_fscope.  
delete_scope                            internal procedure  shares stack frame of external procedure dl_fscope.  
convert                                 internal procedure  shares stack frame of external procedure dl_fscope.  
calc_process_scopes                     internal procedure  shares stack frame of external procedure dl_fscope.  
clean_up                             78 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
dl_fscope                000100 state                       dl_fscope
                         000101 my_pid                      dl_fscope
                         000102 conflict_sw                 dl_fscope
                         000103 make_user_inactive          dl_fscope
                         000104 status                      dl_fscope
                         000105 wakeup                      dl_fscope
                         000106 current_rmg_permits         dl_fscope
                         000107 current_rmg_prevents        dl_fscope
                         000110 new_rmg_permits             dl_fscope
                         000111 new_rmg_prevents            dl_fscope
                         000112 old_rmg_permits             dl_fscope
                         000113 old_rmg_prevents            dl_fscope
                         000114 other_rmg_permits           dl_fscope
                         000115 other_rmg_prevents          dl_fscope
                         000116 nargs                       dl_fscope
                         000117 arg_len                     dl_fscope
                         000120 num_tuples                  dl_fscope
                         000121 i                           dl_fscope
                         000122 pos_in_si                   dl_fscope
                         000123 pos_in_rmfa                 dl_fscope
                         000124 args_exp                    dl_fscope
                         000125 arg_index                   dl_fscope
                         000126 rel_len                     dl_fscope
                         000127 icode                       dl_fscope
                         000130 temp_uid                    dl_fscope
                         000131 rel_name_32                 dl_fscope
                         000141 entry_name                  dl_fscope
                         000151 model_rel_name              dl_fscope
                         000162 cd_ptr                      dl_fscope
                         000164 dbi_ptr                     dl_fscope
                         000166 rel_ptr                     dl_fscope
                         000170 find_ul_ptr                 dl_fscope
                         000172 conflict_ul_ptr             dl_fscope
                         000174 flo_ptr                     dl_fscope
                         000212 actual_permits              dl_fscope
                         000213 actual_prevents             dl_fscope
                         000214 actual_conflict_detail      dl_fscope
                         000216 unused_conflict_detail      dl_fscope
                         000220 caller_name                 dl_fscope
                         000230 continue                    dl_fscope
                         000232 info_ptr                    dl_fscope
                         000234 return_value                dl_fscope
                         000235 conflict_relation           dl_fscope
                         000245 conflict_detail_known       dl_fscope
                         000246 saved_fl_ptr                dl_fscope
                         000250 dbcb_ptr                    dl_fscope
                         000252 permit_requests_ptr         dl_fscope
                         000254 prevent_requests_ptr        dl_fscope
                         000256 conflict_detail_ptr         dl_fscope
                         000260 scope_ptr                   dl_fscope
                         000262 dbc_ptr                     dl_fscope
                         000264 ul_ptr                      dl_fscope
                         000266 fl_ptr                      dl_fscope
                         000270 num_filns                   dl_fscope
                         000272 QUE_FREE                    dl_fscope
                         000274 rdbi_ptr                    dl_fscope
                         000276 rmra_ptr                    dl_fscope
                         000300 rmri_ptr                    dl_fscope
                         000336 permit_conflict             report_scope_detail
                         000363 prevent_conflict            report_scope_detail
                         000416 found                       sufficient_scope_exists
                         000417 suf_scope                   sufficient_scope_exists
                         000426 found_matching_fil_list     delete_scope
                         000427 active_scope_seen           delete_scope
                         000430 finished                    delete_scope
                         000432 ds_rmri_ptr                 delete_scope
                         000442 result                      convert
                         000452 f_ptr                       calc_process_scopes
                         000454 my_process_id               calc_process_scopes
                         000455 temp_relmgr_my_permits      calc_process_scopes
                         000456 temp_relmgr_other_permits   calc_process_scopes
                         000460 u_ptr                       calc_process_scopes

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ent_var        call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac
mdfx1               signal_op           enable_op           ext_entry           int_entry           trunc_fx2
set_chars_eis       index_chars_eis     divide_fx1          op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cu_$arg_count                 cu_$arg_ptr                   get_process_id_               hcs_$get_uid_seg
hcs_$wakeup                   mu_check_conflict             mu_check_scope
mu_database_index$get_resultant_model_pointer               mu_de_queue_user              set_lock_$lock
set_lock_$unlock              sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$invalid_lock_reset                             error_table_$lock_wait_time_exceeded
error_table_$locked_by_this_process                         error_table_$wrong_no_of_args mrds_data_$lock_wait_time
mrds_error_$invalid_db_index  mrds_error_$non_scope_ready   mrds_error_$rel_name_too_long mrds_error_$scope_empty
mrds_error_$scope_not_found   mrds_error_$unknown_proc_id   mrds_error_$unknown_relation_name




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
   1074 000203      1075 000206      1076 000210      1077 000212      1079 000213    3   59 000214    4   44 000215
 5  109 000216    5  110 000217        27 000222       124 000241       125 000243       126 000244       127 000247
    129 000251       130 000260       134 000266       135 000303       137 000310       138 000311       139 000330
    142 000334       145 000345       148 000360       153 000361       154 000375       156 000377       157 000400
    159 000401       161 000405       162 000406       164 000407       165 000411       167 000433       169 000447
    170 000452       171 000455       173 000457       178 000466       181 000510       183 000517       185 000521
    186 000524       191 000526       192 000543       194 000545       195 000554       196 000560       198 000564
    200 000570       201 000571       202 000573       203 000574       204 000610       205 000611       206 000625
    209 000626       214 000641       216 000645       218 000657       221 000666       223 000667       224 000677
    225 000703       227 000720       233 000724       245 000750       246 000755       250 001000       251 001001
    254 001067       255 001076       257 001077       258 001113       262 001126       264 001143       270 001155
    272 001175       275 001201       277 001221       283 001225       285 001244       286 001246       289 001261
    290 001266       291 001267       296 001276       297 001277       304 001301       311 001311       312 001321
    313 001353       315 001355       316 001357       324 001361       326 001402       331 001406       333 001407
    335 001410       337 001426       340 001427       350 001452       351 001454       352 001457       354 001461
    355 001463       356 001466       358 001467       374 001523       375 001526       376 001530       377 001532
    378 001536       379 001541       381 001542       386 001544       388 001556       390 001557       391 001563
    395 001564       406 001565       407 001566       411 001570       413 001603       415 001612       420 001616
    421 001630       422 001632       424 001633       426 001643       428 001647       430 001651       431 001656
    432 001663       433 001670       435 001675       436 001702       437 001707       438 001714       440 001721
    451 001756       453 001761       454 001763       458 001767       459 002002       463 002003       465 002005
    466 002023       469 002027       470 002032       477 002034       479 002036       480 002040       485 002045
    487 002060       490 002061       492 002062       506 002064       509 002075       510 002101       513 002117
    515 002121       517 002132       520 002144       526 002145       528 002154       530 002160       531 002164
    532 002203       535 002204       536 002207       537 002211       540 002214       543 002220       547 002221
    552 002222       554 002224       556 002225       559 002242       562 002257       565 002274       568 002311
    571 002323       573 002324       576 002341       579 002356       582 002373       585 002410       588 002421
    597 002536       604 002537       612 002541       614 002554       615 002555       616 002560       618 002567
    620 002577       621 002611       625 002612       626 002614       627 002620       628 002625       630 002631
    635 002671       636 002672       639 002673       642 002674       643 002676       645 002717       646 002722
    647 002723       648 002725       652 002732       658 002740       668 002741       671 002753       674 002764
    677 002775       680 003006       683 003020       686 003031       689 003042       692 003053       698 003067
    699 003102       700 003105       702 003106       703 003114       706 003124       707 003126       709 003140
    715 003141       718 003145       723 003204       724 003213       725 003222       729 003251       734 003304
    736 003314       737 003325       739 003343       746 003347       748 003357       750 003362       751 003367
    752 003371       756 003372       758 003412       760 003430       762 003445       764 003463       768 003502
    770 003521       772 003537       774 003555       776 003573       781 003614       784 003624       785 003626
    786 003632       787 003633       788 003634       790 003636       792 003644       794 003650       795 003652
    796 003653       797 003654       798 003661       800 003662       804 003667       805 003671       809 003672
    822 003674       824 003710       826 003712       871 003715       897 003717       898 003722       899 003731
    900 003742       901 003746       903 003757       905 003762       907 003772       908 004001       911 004012
    916 004037       918 004045       920 004057       922 004071       924 004072       926 004076       930 004102
    932 004113       934 004116       935 004117       937 004130       939 004132       940 004133       943 004134
    945 004142       948 004164       950 004171       953 004175       955 004206


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
