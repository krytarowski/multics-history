	COMPILATION LISTING OF SEGMENT rs_open_seq_in_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phx, AZ, Sys-M  
	Compiled on: 09/10/87  1451.7 mst Thu
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* record_stream_ program for handling sequential input openings */
       12 rs_open_seq_in_:
       13      proc (iocb_ptr_arg, code);
       14 	iocb_ptr = iocb_ptr_arg;
       15 						/* set entries in iocb for valid operations in this mode */
       16 	read_record = read_record_rs;
       17 	read_length = read_length_rs;
       18 	position = position_seq_rs;
       19 	return;					/* end of opening routine */
       20 
       21 read_record_rs:
       22      entry (iocb_ptr_arg, buff_ptr_arg, buff_len, rec_len, code);
       23 	call initialize;
       24 	buff_ptr = buff_ptr_arg;
       25 	if n_left ^= 0
       26 	then /* internal buffer contains a record */
       27 	     do;					/* get record from rs_buffer */
       28 		if n_left > 0
       29 		then rec_len = n_left;
       30 		else rec_len = 0;
       31 		n_left = 0;			/* set rs_buffer empty */
       32 		if rec_len > buff_len
       33 		then code = error_table_$long_record;
       34 		n_moved = min (rec_len, buff_len);
       35 		if n_moved > 0
       36 		then substr (buffer, 1, n_moved) = substr (rs_buffer, 1, n_moved);
       37 	     end;					/* record moved between buffers */
       38 
       39 	else /* rs_buffer empty */
       40 	     if length_n > 0
       41 	then do;					/* -length n case */
       42 		rec_len = 0;
       43 		n_asked = min (buff_len, length_n);
       44 get_data:
       45 		call iox_$get_chars (target_iocb_ptr, buff_ptr, n_asked, n_read, code);
       46 		rec_len = rec_len + n_read;
       47 		if code ^= 0
       48 		then if code = error_table_$short_record
       49 		     then do;			/* pick up more chars */
       50 			     n_asked = n_asked - n_read;
       51 			     buff_ptr = addr (buff (n_read + 1));
       52 			     go to get_data;
       53 			end;
       54 		     else go to eof_exit;
       55 		else /* no errors yet */
       56 		     if length_n > buff_len
       57 		then /* long record case unless we are at EOF */
       58 		     do;				/* munch past record tail */
       59 			n_extra = length_n - buff_len;
       60 			call iox_$get_chars (target_iocb_ptr, rs_buff_ptr, n_extra, n_read, code);
       61 			rec_len = rec_len + n_read;
       62 			if n_read > 0
       63 			then code = error_table_$long_record;
       64 			else if code = error_table_$end_of_info
       65 			then code = 0;		/* short last record is OK */
       66 		     end;
       67 	     end;					/* end of -length n case */
       68 
       69 	else do;					/* default case */
       70 		call iox_$get_line (target_iocb_ptr, buff_ptr_arg, buff_len, rec_len, code);
       71 		if code = 0
       72 		then rec_len = rec_len - 1;		/* delete newline char */
       73 		else if code ^= error_table_$long_record
       74 		then do;				/* check for short record */
       75 eof_exit:
       76 			if rec_len > 0
       77 			then code = 0;
       78 		     end;				/* done */
       79 		else do;				/* line is longer than input buffer */
       80 			call iox_$get_chars (target_iocb_ptr, addr (next_char), 1, n_read, code);
       81 			if code = 0
       82 			then if substr (next_char, 1, 1) = newline
       83 						/* avoids compiler bug */
       84 			     then return;		/* normal return */
       85 			     else do;		/* munch record tail */
       86 				     rec_len = rec_len + 1;
       87 				     call iox_$get_line (target_iocb_ptr, rs_buff_ptr, max_bufsize, n_read, code);
       88 				     rec_len = rec_len + n_read;
       89 				end;
       90 			code = error_table_$long_record;
       91 		     end;				/* entire record processed */
       92 	     end;					/* end of default case */
       93 	return;					/* end of read record routine */
       94 
       95 
       96 read_length_rs:
       97      entry (iocb_ptr_arg, rec_len, code);
       98 	call initialize;
       99 	if n_left = 0				/* rs_buffer is empty */
      100 	then do;					/* get a new record */
      101 		call read_record_rs (iocb_ptr, rs_buff_ptr, max_bufsize, n_left, code);
      102 		if (n_left = 0) & (code = 0)
      103 		then n_left = -1;
      104 	     end;
      105 	if n_left > 0
      106 	then rec_len = n_left;
      107 	else rec_len = 0;
      108 	return;					/* end of read length routine */
      109 
      110 position_seq_rs:
      111      entry (iocb_ptr_arg, type, count, code);
      112 	call initialize;
      113 	n = count;
      114 	if type ^= 0
      115 	then do;					/* bof and eof cases */
      116 		n_left = 0;			/* discard rs_buffer contents */
      117 pass_call:
      118 		call iox_$position (target_iocb_ptr, type, n, code);
      119 						/* pass call to target */
      120 	     end;
      121 	else do;					/* skip case */
      122 		if n ^= 0
      123 		then do;				/* skip n records */
      124 			old_n_left = n_left;
      125 			if n_left ^= 0
      126 			then do;			/* skip record in rs_buffer */
      127 				n = n - 1;
      128 				n_left = 0;
      129 			     end;
      130 			if length_n = 0		/* default case */
      131 			then go to pass_call;
      132 			else /* -length case */
      133 			     if n < 0
      134 			then do;			/* error: no backwards skips */
      135 				code = error_table_$negative_nelem;
      136 				n_left = old_n_left;/* restore rs_buffer */
      137 			     end;
      138 			else /* read past n records */
      139 			     do while ((n > 0) & (code = 0));
      140 				call read_record_rs (iocb_ptr, rs_buff_ptr, max_bufsize, n_read, code);
      141 				n = n - 1;
      142 			     end;
      143 		     end;				/* n records skipped */
      144 	     end;					/* end of skip case */
      145 	return;					/* end of seq position routine */
      146 
      147 /* internal procedure for initializing pointers upon entry */
      148 initialize:
      149      proc;
      150 	iocb_ptr = iocb_ptr_arg -> actual_iocb_ptr;
      151 	rsab_ptr = attach_data_ptr;
      152 	rs_buff_ptr = open_data_ptr;
      153 	code = 0;
      154 	return;
      155 
      156      end initialize;
      157 
      158 /* declarations for entire program */
      159 	dcl     (iocb_ptr_arg, iocb_ptr)
      160 				 ptr;
      161 	dcl     code		 fixed bin (35);
  1     1 
  1     2      dcl	   1 iocb		      aligned based (iocb_ptr),
  1     3 						/* I/O control block. */
  1     4 	     2 iocb_version	      fixed init (1),	/* Version number of structure. */
  1     5 	     2 name	      char (32),		/* I/O name of this block. */
  1     6 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  1     7 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  1     8 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  1     9 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  1    10 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  1    11 	     2 reserved	      bit (72),		/* Reserved for future use. */
  1    12 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  1    13 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  1    14 						/* open(p,mode,not_used,s) */
  1    15 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  1    16 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  1    17 						/* get_line(p,bufptr,buflen,actlen,s) */
  1    18 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  1    19 						/* get_chars(p,bufptr,buflen,actlen,s) */
  1    20 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  1    21 						/* put_chars(p,bufptr,buflen,s) */
  1    22 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  1    23 						/* modes(p,newmode,oldmode,s) */
  1    24 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  1    25 						/* position(p,u1,u2,s) */
  1    26 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  1    27 						/* control(p,order,infptr,s) */
  1    28 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  1    29 						/* read_record(p,bufptr,buflen,actlen,s) */
  1    30 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  1    31 						/* write_record(p,bufptr,buflen,s) */
  1    32 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  1    33 						/* rewrite_record(p,bufptr,buflen,s) */
  1    34 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  1    35 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  1    36 						/* seek_key(p,key,len,s) */
  1    37 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  1    38 						/* read_key(p,key,len,s) */
  1    39 	     2 read_length	      entry (ptr, fixed (21), fixed (35));
  1    40 						/* read_length(p,len,s) */
  1    41 
      162 
  2     1 /*  BEGIN:   rs_attach_block.incl.pl1			  *  *  *  *  *  */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(75-02-13,Asherman), approve(), audit(), install():
  2     6*     Initial coding.
  2     7*  2) change(87-08-30,GWMay), approve(87-08-30,MCR7730), audit(87-09-10,GDixon),
  2     8*     install(87-09-10,MR12.1-1104):
  2     9*     Changed target_name to be unaligned.
  2    10*                                                   END HISTORY COMMENTS */
  2    11 
  2    12 
  2    13 dcl	   rsab_ptr	      ptr;
  2    14      dcl	   1 rs_attach_block      based (rsab_ptr) aligned,
  2    15 						/* record_stream_ attach block */
  2    16 						/* the following are set during attachment */
  2    17 	     2 attach_descrip,
  2    18 	       3 attach_descrip_len
  2    19 			      fixed (35),
  2    20 	       3 attach_descrip_string
  2    21 			      char (66),		/* "record_stream_ <targ_sw_name> <option>" */
  2    22 	     2 target_name	      char (32) unaligned,	/* name of the target switch */
  2    23 	     2 length_n	      fixed (21),		/* =-1 --> -nnl option, */
  2    24 						/* = 0 --> default option, */
  2    25 						/* > 0 --> -length option */
  2    26 	     2 i_attached_target  bit (1) aligned,	/* ="1"b --> target attached via -target option */
  2    27 						/* the following are set during opening */
  2    28 	     2 open_descrip,
  2    29 	       3 open_descrip_len fixed (35),
  2    30 	       3 open_descrip_string
  2    31 			      char (24),
  2    32 	     2 mode	      fixed,		/* opening mode-- may be 1,2,4, or 5 if open */
  2    33 	     2 target_iocb_ptr    ptr,		/* points to the iocb for the target switch */
  2    34 	     2 i_opened_target    bit (1) aligned,	/* ="1"b --> this opening caused target to be opened */
  2    35 	     2 base	      fixed (21),		/* offset of next byte in rs_buffer */
  2    36 	     2 n_left	      fixed (21);		/* number of unprocessed bytes in rs_buffer */
  2    37 
  2    38 /*  END OF:  rs_attach_block.incl.pl1			  *  *  *  *  *  */
      163 
  3     1 /* BEGIN INCLUDE FILE ..... rs_buffer.inc.pl1 ..... 14 Feb 1975, M. Asherman */
  3     2 
  3     3      dcl	   rs_buff_ptr	      ptr;		/* points to buffer segment */
  3     4      dcl	   rs_buffer	      char (max_bufsize) based (rs_buff_ptr) aligned;
  3     5 						/* internal record_stream_ line/record buffer */
  3     6      dcl	   max_bufsize	      static internal fixed (21) init (1044480);
  3     7 						/* 255 K words */
  3     8 
  3     9 /* END INCLUDE FILE ..... rs_buffer.inc.pl1 ..... */
      164 
      165 	dcl     (buff_ptr_arg, buff_ptr)
      166 				 ptr;
      167 	dcl     (buff_len, rec_len, n_moved)
      168 				 fixed (21);
      169 	dcl     (substr, min, addr)	 builtin;
      170 	dcl     error_table_$long_record
      171 				 external fixed (35);
      172 	dcl     error_table_$short_record
      173 				 external fixed (35);
      174 	dcl     (n_asked, n_read)	 fixed (21);
      175 	dcl     iox_$get_chars	 entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
      176 	dcl     buffer		 char (buff_len) based (buff_ptr);
      177 	dcl     buff		 (buff_len) char (1) based (buff_ptr);
      178 	dcl     n_extra		 fixed (21);
      179 	dcl     error_table_$end_of_info
      180 				 external fixed (35);
      181 	dcl     next_char		 char (2);
      182 	dcl     newline		 char (1) static internal aligned init ("
      183 ");
      184 	dcl     type		 fixed;
      185 	dcl     (count, n, old_n_left) fixed (21);
      186 	dcl     iox_$position	 entry (ptr, fixed, fixed (21), fixed (35));
      187 	dcl     error_table_$negative_nelem
      188 				 external fixed (35);
      189 	dcl     iox_$get_line	 entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
      190 
      191      end rs_open_seq_in_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    09/10/87  1448.2  rs_open_seq_in_.pl1               >special_ldd>install>MR12.1-1104>rs_open_seq_in_.pl1
162          1    07/02/81  1905.0  iocbv.incl.pl1                    >ldd>include>iocbv.incl.pl1
163          2    09/10/87  1444.7  rs_attach_block.incl.pl1          >special_ldd>install>MR12.1-1104>rs_attach_block.incl.pl1
164          3    07/19/79  1547.0  rs_buffer.incl.pl1                >ldd>include>rs_buffer.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
actual_iocb_ptr          12            based           pointer                  level 2 dcl 1-2 ref 150
addr                                                   builtin function         dcl 169 ref 51 80 80
attach_data_ptr          16            based           pointer                  level 2 dcl 1-2 ref 151
buff                                   based           char(1)                  array unaligned dcl 177 set ref 51
buff_len                               parameter       fixed bin(21,0)          dcl 167 set ref 21 32 34 35 43 55 59 70*
buff_ptr                        000106 automatic       pointer                  dcl 165 set ref 24* 35 44* 51* 51
buff_ptr_arg                           parameter       pointer                  dcl 165 set ref 21 24 70*
buffer                                 based           char                     unaligned dcl 176 set ref 35*
code                                   parameter       fixed bin(35,0)          dcl 161 set ref 12 21 32* 44* 47 47 60* 62* 64 64*
                                                                                  70* 71 73 75* 80* 81 87* 90* 96 101* 102 110 117*
                                                                                  135* 138 140* 153*
count                                  parameter       fixed bin(21,0)          dcl 185 ref 110 113
error_table_$end_of_info        000020 external static fixed bin(35,0)          dcl 179 ref 64
error_table_$long_record        000012 external static fixed bin(35,0)          dcl 170 ref 32 62 73 90
error_table_$negative_nelem     000024 external static fixed bin(35,0)          dcl 187 ref 135
error_table_$short_record       000014 external static fixed bin(35,0)          dcl 172 ref 47
iocb                                   based           structure                level 1 dcl 1-2
iocb_ptr                        000100 automatic       pointer                  dcl 159 set ref 14* 16 17 18 101* 140* 150* 151 152
iocb_ptr_arg                           parameter       pointer                  dcl 159 ref 12 14 21 96 110 150
iox_$get_chars                  000016 constant        entry                    external dcl 175 ref 44 60 80
iox_$get_line                   000026 constant        entry                    external dcl 189 ref 70 87
iox_$position                   000022 constant        entry                    external dcl 186 ref 117
length_n                 32            based           fixed bin(21,0)          level 2 dcl 2-14 ref 39 43 55 59 130
max_bufsize                     000010 internal static fixed bin(21,0)          initial dcl 3-6 set ref 35 87* 101* 140*
min                                                    builtin function         dcl 169 ref 34 43
n                               000115 automatic       fixed bin(21,0)          dcl 185 set ref 113* 117* 122 127* 127 132 138 141*
                                                                                  141
n_asked                         000111 automatic       fixed bin(21,0)          dcl 174 set ref 43* 44* 50* 50
n_extra                         000113 automatic       fixed bin(21,0)          dcl 178 set ref 59* 60*
n_left                   50            based           fixed bin(21,0)          level 2 dcl 2-14 set ref 25 28 28 31* 99 101* 102
                                                                                  102* 105 105 116* 124 125 128* 136*
n_moved                         000110 automatic       fixed bin(21,0)          dcl 167 set ref 34* 35 35 35
n_read                          000112 automatic       fixed bin(21,0)          dcl 174 set ref 44* 46 50 51 60* 61 62 80* 87* 88
                                                                                  140*
newline                                constant        char(1)                  initial dcl 182 ref 81
next_char                       000114 automatic       char(2)                  unaligned dcl 181 set ref 80 80 81
old_n_left                      000116 automatic       fixed bin(21,0)          dcl 185 set ref 124* 136
open_data_ptr            22            based           pointer                  level 2 dcl 1-2 ref 152
position                 62            based           entry variable           level 2 dcl 1-2 set ref 18*
read_length             122            based           entry variable           level 2 dcl 1-2 set ref 17*
read_record              72            based           entry variable           level 2 dcl 1-2 set ref 16*
rec_len                                parameter       fixed bin(21,0)          dcl 167 set ref 21 28* 30* 32 34 42* 46* 46 61* 61
                                                                                  70* 71* 71 75 86* 86 88* 88 96 105* 107*
rs_attach_block                        based           structure                level 1 dcl 2-14
rs_buff_ptr                     000104 automatic       pointer                  dcl 3-3 set ref 35 60* 87* 101* 140* 152*
rs_buffer                              based           char                     dcl 3-4 ref 35
rsab_ptr                        000102 automatic       pointer                  dcl 2-13 set ref 25 28 28 31 39 43 44 55 59 60 70 80
                                                                                  87 99 101 102 102 105 105 116 117 124 125 128 130
                                                                                  136 151*
substr                                                 builtin function         dcl 169 set ref 35* 35 81
target_iocb_ptr          44            based           pointer                  level 2 dcl 2-14 set ref 44* 60* 70* 80* 87* 117*
type                                   parameter       fixed bin(17,0)          dcl 184 set ref 110 114 117*

NAMES DECLARED BY EXPLICIT CONTEXT.
eof_exit                        000255 constant        label                    dcl 75 ref 47
get_data                        000124 constant        label                    dcl 44 ref 52
initialize                      000537 constant        entry                    internal dcl 148 ref 23 98 112
pass_call                       000444 constant        label                    dcl 117 ref 130
position_seq_rs                 000424 constant        entry                    external dcl 110 ref 18
read_length_rs                  000345 constant        entry                    external dcl 96 ref 17
read_record_rs                  000043 constant        entry                    external dcl 21 ref 16 101 140
rs_open_seq_in_                 000010 constant        entry                    external dcl 12

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       712         742     556         722
Length      1206     556        30         230     134           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rs_open_seq_in_                     105 external procedure  is an external procedure.  
initialize                              internal procedure  shares stack frame of external procedure rs_open_seq_in_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 max_bufsize                 rs_open_seq_in_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rs_open_seq_in_          000100 iocb_ptr                    rs_open_seq_in_
                         000102 rsab_ptr                    rs_open_seq_in_
                         000104 rs_buff_ptr                 rs_open_seq_in_
                         000106 buff_ptr                    rs_open_seq_in_
                         000110 n_moved                     rs_open_seq_in_
                         000111 n_asked                     rs_open_seq_in_
                         000112 n_read                      rs_open_seq_in_
                         000113 n_extra                     rs_open_seq_in_
                         000114 next_char                   rs_open_seq_in_
                         000115 n                           rs_open_seq_in_
                         000116 old_n_left                  rs_open_seq_in_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_in         call_ext_out        return_mac          ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
iox_$get_chars                iox_$get_line                 iox_$position

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$end_of_info      error_table_$long_record      error_table_$negative_nelem   error_table_$short_record


CONSTANTS
000554  aa     077777000043
000555  aa     000001000000

000000  aa     404000000021

000001  aa     404000000025

000002  aa     404000000043

000003  aa     464000000000

BEGIN PROCEDURE rs_open_seq_in_
ENTRY TO rs_open_seq_in_                                    STATEMENT 1 ON LINE 12
rs_open_seq_in_:
     proc (iocb_ptr_arg, code);

000004  at     000002000003
000005  ta     000002000000
000006  ta     000004000000
000007  da     000103300000
000010  aa   000160 6270 00	eax7 	112
000011  aa  7 00034 3521 20	epp2 	pr7|28,*
000012  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000013  aa     000004000000
000014  aa     000000000000
000015  aa  6 00032 3735 20	epp7 	pr6|26,*
000016  aa  7 00004 3715 20	epp5 	pr7|4,*
000017  aa  6 00120 6515 00	spri5	pr6|80
						STATEMENT 1 ON LINE 14
	iocb_ptr = iocb_ptr_arg;

000020  aa  7 00002 3535 20	epp3 	pr7|2,*		iocb_ptr_arg
000021  aa  3 00000 3535 20	epp3 	pr3|0,*		iocb_ptr_arg
000022  aa  6 00100 2535 00	spri3	pr6|64		iocb_ptr
						STATEMENT 1 ON LINE 16
	read_record = read_record_rs;

000023  aa   000020 3520 04	epp2 	16,ic		000043 = 000160627000
000024  aa  3 00072 2521 00	spri2	pr3|58		iocb.read_record
000025  aa   000527 2370 04	ldaq 	343,ic		000554 = 077777000043 000001000000
000026  aa  3 00074 7571 00	staq 	pr3|60		iocb.read_record
						STATEMENT 1 ON LINE 17
	read_length = read_length_rs;

000027  aa   000316 3520 04	epp2 	206,ic		000345 = 000160627000
000030  aa  3 00122 2521 00	spri2	pr3|82		iocb.read_length
000031  aa  3 00124 7571 00	staq 	pr3|84		iocb.read_length
						STATEMENT 1 ON LINE 18
	position = position_seq_rs;

000032  aa   000372 3520 04	epp2 	250,ic		000424 = 000160627000
000033  aa  3 00062 2521 00	spri2	pr3|50		iocb.position
000034  aa  3 00064 7571 00	staq 	pr3|52		iocb.position
						STATEMENT 1 ON LINE 19
	return;

000035  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO read_record_rs                                     STATEMENT 1 ON LINE 21
read_record_rs:
     entry (iocb_ptr_arg, buff_ptr_arg, buff_len, rec_len, code);

000036  at     000005000003
000037  tt     000003000001
000040  tt     000001000002
000041  ta     000036000000
000042  da     000112300000
000043  aa   000160 6270 00	eax7 	112
000044  aa  7 00034 3521 20	epp2 	pr7|28,*
000045  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000046  aa     000012000000
000047  aa     000000000000
000050  aa  6 00032 3735 20	epp7 	pr6|26,*
000051  aa  7 00010 3715 20	epp5 	pr7|8,*
000052  aa  6 00122 6515 00	spri5	pr6|82
000053  aa  7 00012 3535 20	epp3 	pr7|10,*
000054  aa  6 00120 2535 00	spri3	pr6|80
						STATEMENT 1 ON LINE 23
	call initialize;

000055  aa   000462 6700 04	tsp4 	306,ic		000537
						STATEMENT 1 ON LINE 24
	buff_ptr = buff_ptr_arg;

000056  aa  6 00032 3735 20	epp7 	pr6|26,*
000057  aa  7 00004 3715 20	epp5 	pr7|4,*		buff_ptr_arg
000060  aa  5 00000 3715 20	epp5 	pr5|0,*		buff_ptr_arg
000061  aa  6 00106 6515 00	spri5	pr6|70		buff_ptr
						STATEMENT 1 ON LINE 25
	if n_left ^= 0
	then /* internal buffer contains a record */
	     do;

000062  aa  6 00102 3535 20	epp3 	pr6|66,*		rsab_ptr
000063  aa  3 00050 2361 00	ldq  	pr3|40		rs_attach_block.n_left
000064  aa   000030 6000 04	tze  	24,ic		000114
						STATEMENT 1 ON LINE 28
		if n_left > 0
		then rec_len = n_left;

000065  aa   000003 6044 04	tmoz 	3,ic		000070
000066  aa  6 00122 7561 20	stq  	pr6|82,*		rec_len
000067  aa   000002 7100 04	tra  	2,ic		000071
						STATEMENT 1 ON LINE 30
		else rec_len = 0;

000070  aa  6 00122 4501 20	stz  	pr6|82,*		rec_len
						STATEMENT 1 ON LINE 31
		n_left = 0;

000071  aa  3 00050 4501 00	stz  	pr3|40		rs_attach_block.n_left
						STATEMENT 1 ON LINE 32
		if rec_len > buff_len
		then code = error_table_$long_record;

000072  aa  6 00122 2361 20	ldq  	pr6|82,*		rec_len
000073  aa  7 00006 1161 20	cmpq 	pr7|6,*		buff_len
000074  aa   000004 6044 04	tmoz 	4,ic		000100
000075  aa  6 00044 3701 20	epp4 	pr6|36,*
000076  la  4 00012 2361 20	ldq  	pr4|10,*		error_table_$long_record
000077  aa  6 00120 7561 20	stq  	pr6|80,*		code
						STATEMENT 1 ON LINE 34
		n_moved = min (rec_len, buff_len);

000100  aa  6 00122 2361 20	ldq  	pr6|82,*		rec_len
000101  aa  7 00006 1161 20	cmpq 	pr7|6,*		buff_len
000102  aa   000002 6040 04	tmi  	2,ic		000104
000103  aa  7 00006 2361 20	ldq  	pr7|6,*		buff_len
000104  aa  6 00110 7561 00	stq  	pr6|72		n_moved
						STATEMENT 1 ON LINE 35
		if n_moved > 0
		then substr (buffer, 1, n_moved) = substr (rs_buffer, 1, n_moved);

000105  aa  6 00110 2361 00	ldq  	pr6|72		n_moved
000106  aa   000232 6044 04	tmoz 	154,ic		000340
000107  aa  6 00104 3515 20	epp1 	pr6|68,*		rs_buff_ptr
000110  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000111  aa  1 00000 00 0006	desc9a	pr1|0,ql		rs_buffer
000112  aa  5 00000 00 0006	desc9a	pr5|0,ql		buffer
						STATEMENT 1 ON LINE 37
	     end;

000113  aa   000225 7100 04	tra  	149,ic		000340
						STATEMENT 1 ON LINE 39
	else /* rs_buffer empty */
	     if length_n > 0
	then do;

000114  aa  3 00032 2361 00	ldq  	pr3|26		rs_attach_block.length_n
000115  aa   000111 6044 04	tmoz 	73,ic		000226
						STATEMENT 1 ON LINE 42
		rec_len = 0;

000116  aa  6 00122 4501 20	stz  	pr6|82,*		rec_len
						STATEMENT 1 ON LINE 43
		n_asked = min (buff_len, length_n);

000117  aa  7 00006 2361 20	ldq  	pr7|6,*		buff_len
000120  aa  3 00032 1161 00	cmpq 	pr3|26		rs_attach_block.length_n
000121  aa   000002 6040 04	tmi  	2,ic		000123
000122  aa  3 00032 2361 00	ldq  	pr3|26		rs_attach_block.length_n
000123  aa  6 00111 7561 00	stq  	pr6|73		n_asked
						STATEMENT 1 ON LINE 44
get_data:
		call iox_$get_chars (target_iocb_ptr, buff_ptr, n_asked, n_read, code);

000124  aa  6 00102 3735 20	epp7 	pr6|66,*		rsab_ptr
000125  aa  7 00044 3521 00	epp2 	pr7|36		rs_attach_block.target_iocb_ptr
000126  aa  6 00134 2521 00	spri2	pr6|92
000127  aa  6 00106 3521 00	epp2 	pr6|70		buff_ptr
000130  aa  6 00136 2521 00	spri2	pr6|94
000131  aa  6 00111 3521 00	epp2 	pr6|73		n_asked
000132  aa  6 00140 2521 00	spri2	pr6|96
000133  aa  6 00112 3521 00	epp2 	pr6|74		n_read
000134  aa  6 00142 2521 00	spri2	pr6|98
000135  aa  6 00120 3521 20	epp2 	pr6|80,*		code
000136  aa  6 00144 2521 00	spri2	pr6|100
000137  aa  6 00132 6211 00	eax1 	pr6|90
000140  aa   024000 4310 07	fld  	10240,dl
000141  aa  6 00044 3701 20	epp4 	pr6|36,*
000142  la  4 00016 3521 20	epp2 	pr4|14,*		iox_$get_chars
000143  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 46
		rec_len = rec_len + n_read;

000144  aa  6 00112 2361 00	ldq  	pr6|74		n_read
000145  aa  6 00122 0561 20	asq  	pr6|82,*		rec_len
						STATEMENT 1 ON LINE 47
		if code ^= 0
		then if code = error_table_$short_record
		     then do;

000146  aa  6 00120 2361 20	ldq  	pr6|80,*		code
000147  aa   000013 6000 04	tze  	11,ic		000162
000150  aa  6 00044 3701 20	epp4 	pr6|36,*
000151  la  4 00014 1161 20	cmpq 	pr4|12,*		error_table_$short_record
000152  aa   000103 6010 04	tnz  	67,ic		000255
						STATEMENT 1 ON LINE 50
			     n_asked = n_asked - n_read;

000153  aa  6 00112 3361 00	lcq  	pr6|74		n_read
000154  aa  6 00111 0561 00	asq  	pr6|73		n_asked
						STATEMENT 1 ON LINE 51
			     buff_ptr = addr (buff (n_read + 1));

000155  aa  6 00112 2351 00	lda  	pr6|74		n_read
000156  aa  6 00106 3521 20	epp2 	pr6|70,*		buff
000157  aa  2 00000 5005 05	a9bd 	pr2|0,al
000160  aa  6 00106 2521 00	spri2	pr6|70		buff_ptr
						STATEMENT 1 ON LINE 52
			     go to get_data;

000161  aa   777743 7100 04	tra  	-29,ic		000124
						STATEMENT 1 ON LINE 53
			end;

						STATEMENT 1 ON LINE 55
		else /* no errors yet */
		     if length_n > buff_len
		then /* long record case unless we are at EOF */
		     do;

000162  aa  6 00102 3735 20	epp7 	pr6|66,*		rsab_ptr
000163  aa  7 00032 2361 00	ldq  	pr7|26		rs_attach_block.length_n
000164  aa  6 00032 3715 20	epp5 	pr6|26,*
000165  aa  5 00006 1161 20	cmpq 	pr5|6,*		buff_len
000166  aa   000152 6044 04	tmoz 	106,ic		000340
						STATEMENT 1 ON LINE 59
			n_extra = length_n - buff_len;

000167  aa  5 00006 1761 20	sbq  	pr5|6,*		buff_len
000170  aa  6 00113 7561 00	stq  	pr6|75		n_extra
						STATEMENT 1 ON LINE 60
			call iox_$get_chars (target_iocb_ptr, rs_buff_ptr, n_extra, n_read, code);

000171  aa  7 00044 3521 00	epp2 	pr7|36		rs_attach_block.target_iocb_ptr
000172  aa  6 00134 2521 00	spri2	pr6|92
000173  aa  6 00104 3521 00	epp2 	pr6|68		rs_buff_ptr
000174  aa  6 00136 2521 00	spri2	pr6|94
000175  aa  6 00113 3521 00	epp2 	pr6|75		n_extra
000176  aa  6 00140 2521 00	spri2	pr6|96
000177  aa  6 00112 3521 00	epp2 	pr6|74		n_read
000200  aa  6 00142 2521 00	spri2	pr6|98
000201  aa  6 00120 3521 20	epp2 	pr6|80,*		code
000202  aa  6 00144 2521 00	spri2	pr6|100
000203  aa  6 00132 6211 00	eax1 	pr6|90
000204  aa   024000 4310 07	fld  	10240,dl
000205  aa  6 00044 3701 20	epp4 	pr6|36,*
000206  la  4 00016 3521 20	epp2 	pr4|14,*		iox_$get_chars
000207  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 61
			rec_len = rec_len + n_read;

000210  aa  6 00112 2361 00	ldq  	pr6|74		n_read
000211  aa  6 00122 0561 20	asq  	pr6|82,*		rec_len
						STATEMENT 1 ON LINE 62
			if n_read > 0
			then code = error_table_$long_record;

000212  aa  6 00112 2361 00	ldq  	pr6|74		n_read
000213  aa   000005 6044 04	tmoz 	5,ic		000220
000214  aa  6 00044 3701 20	epp4 	pr6|36,*
000215  la  4 00012 2361 20	ldq  	pr4|10,*		error_table_$long_record
000216  aa  6 00120 7561 20	stq  	pr6|80,*		code
000217  aa   000121 7100 04	tra  	81,ic		000340
						STATEMENT 1 ON LINE 64
			else if code = error_table_$end_of_info
			then code = 0;

000220  aa  6 00120 2361 20	ldq  	pr6|80,*		code
000221  aa  6 00044 3701 20	epp4 	pr6|36,*
000222  la  4 00020 1161 20	cmpq 	pr4|16,*		error_table_$end_of_info
000223  aa   000115 6010 04	tnz  	77,ic		000340
000224  aa  6 00120 4501 20	stz  	pr6|80,*		code
						STATEMENT 1 ON LINE 66
		     end;

						STATEMENT 1 ON LINE 67
	     end;

000225  aa   000113 7100 04	tra  	75,ic		000340
						STATEMENT 1 ON LINE 69
	else do;

						STATEMENT 1 ON LINE 70
		call iox_$get_line (target_iocb_ptr, buff_ptr_arg, buff_len, rec_len, code);

000226  aa  3 00044 3521 00	epp2 	pr3|36		rs_attach_block.target_iocb_ptr
000227  aa  6 00134 2521 00	spri2	pr6|92
000230  aa  7 00004 3521 20	epp2 	pr7|4,*		buff_ptr_arg
000231  aa  6 00136 2521 00	spri2	pr6|94
000232  aa  7 00006 3521 20	epp2 	pr7|6,*		buff_len
000233  aa  6 00140 2521 00	spri2	pr6|96
000234  aa  6 00122 3521 20	epp2 	pr6|82,*		rec_len
000235  aa  6 00142 2521 00	spri2	pr6|98
000236  aa  6 00120 3521 20	epp2 	pr6|80,*		code
000237  aa  6 00144 2521 00	spri2	pr6|100
000240  aa  6 00132 6211 00	eax1 	pr6|90
000241  aa   024000 4310 07	fld  	10240,dl
000242  aa  6 00044 3701 20	epp4 	pr6|36,*
000243  la  4 00026 3521 20	epp2 	pr4|22,*		iox_$get_line
000244  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 71
		if code = 0
		then rec_len = rec_len - 1;

000245  aa  6 00120 2361 20	ldq  	pr6|80,*		code
000246  aa   000004 6010 04	tnz  	4,ic		000252
000247  aa   000001 3360 07	lcq  	1,dl
000250  aa  6 00122 0561 20	asq  	pr6|82,*		rec_len
000251  aa   000067 7100 04	tra  	55,ic		000340
						STATEMENT 1 ON LINE 73
		else if code ^= error_table_$long_record
		then do;

000252  aa  6 00044 3701 20	epp4 	pr6|36,*
000253  la  4 00012 1161 20	cmpq 	pr4|10,*		error_table_$long_record
000254  aa   000005 6000 04	tze  	5,ic		000261
						STATEMENT 1 ON LINE 75
eof_exit:
			if rec_len > 0
			then code = 0;

000255  aa  6 00122 2361 20	ldq  	pr6|82,*		rec_len
000256  aa   000062 6044 04	tmoz 	50,ic		000340
000257  aa  6 00120 4501 20	stz  	pr6|80,*		code
						STATEMENT 1 ON LINE 78
		     end;

000260  aa   000060 7100 04	tra  	48,ic		000340
						STATEMENT 1 ON LINE 79
		else do;

						STATEMENT 1 ON LINE 80
			call iox_$get_chars (target_iocb_ptr, addr (next_char), 1, n_read, code);

000261  aa  6 00114 3735 00	epp7 	pr6|76		next_char
000262  aa  6 00146 6535 00	spri7	pr6|102
000263  aa   000001 2360 07	ldq  	1,dl
000264  aa  6 00150 7561 00	stq  	pr6|104
000265  aa  6 00102 3715 20	epp5 	pr6|66,*		rsab_ptr
000266  aa  5 00044 3521 00	epp2 	pr5|36		rs_attach_block.target_iocb_ptr
000267  aa  6 00134 2521 00	spri2	pr6|92
000270  aa  6 00146 3521 00	epp2 	pr6|102
000271  aa  6 00136 2521 00	spri2	pr6|94
000272  aa  6 00150 3521 00	epp2 	pr6|104
000273  aa  6 00140 2521 00	spri2	pr6|96
000274  aa  6 00112 3521 00	epp2 	pr6|74		n_read
000275  aa  6 00142 2521 00	spri2	pr6|98
000276  aa  6 00120 3521 20	epp2 	pr6|80,*		code
000277  aa  6 00144 2521 00	spri2	pr6|100
000300  aa  6 00132 6211 00	eax1 	pr6|90
000301  aa   024000 4310 07	fld  	10240,dl
000302  la  4 00016 3521 20	epp2 	pr4|14,*		iox_$get_chars
000303  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 81
			if code = 0
			then if substr (next_char, 1, 1) = newline
						/* avoids compiler bug */
			     then return;

000304  aa  6 00120 2361 20	ldq  	pr6|80,*		code
000305  aa   000030 6010 04	tnz  	24,ic		000335
000306  aa  6 00114 2351 00	lda  	pr6|76		next_char
000307  aa  0 00022 3771 00	anaq 	pr0|18		= 777000000000 000000000000
000310  aa   012000 1150 03	cmpa 	5120,du
000311  aa  0 00631 6001 00	tze  	pr0|409		return_mac
						STATEMENT 1 ON LINE 85
			     else do;

						STATEMENT 1 ON LINE 86
				     rec_len = rec_len + 1;

000312  aa  6 00122 0541 20	aos  	pr6|82,*		rec_len
						STATEMENT 1 ON LINE 87
				     call iox_$get_line (target_iocb_ptr, rs_buff_ptr, max_bufsize, n_read, code);

000313  aa  6 00102 3735 20	epp7 	pr6|66,*		rsab_ptr
000314  aa  7 00044 3521 00	epp2 	pr7|36		rs_attach_block.target_iocb_ptr
000315  aa  6 00134 2521 00	spri2	pr6|92
000316  aa  6 00104 3521 00	epp2 	pr6|68		rs_buff_ptr
000317  aa  6 00136 2521 00	spri2	pr6|94
000320  aa  6 00044 3701 20	epp4 	pr6|36,*
000321  ia  4 00010 3521 00	epp2 	pr4|8		max_bufsize
000322  aa  6 00140 2521 00	spri2	pr6|96
000323  aa  6 00112 3521 00	epp2 	pr6|74		n_read
000324  aa  6 00142 2521 00	spri2	pr6|98
000325  aa  6 00120 3521 20	epp2 	pr6|80,*		code
000326  aa  6 00144 2521 00	spri2	pr6|100
000327  aa  6 00132 6211 00	eax1 	pr6|90
000330  aa   024000 4310 07	fld  	10240,dl
000331  la  4 00026 3521 20	epp2 	pr4|22,*		iox_$get_line
000332  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 88
				     rec_len = rec_len + n_read;

000333  aa  6 00112 2361 00	ldq  	pr6|74		n_read
000334  aa  6 00122 0561 20	asq  	pr6|82,*		rec_len
						STATEMENT 1 ON LINE 89
				end;

						STATEMENT 1 ON LINE 90
			code = error_table_$long_record;

000335  aa  6 00044 3701 20	epp4 	pr6|36,*
000336  la  4 00012 2361 20	ldq  	pr4|10,*		error_table_$long_record
000337  aa  6 00120 7561 20	stq  	pr6|80,*		code
						STATEMENT 1 ON LINE 91
		     end;

						STATEMENT 1 ON LINE 92
	     end;

						STATEMENT 1 ON LINE 93
	return;

000340  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO read_length_rs                                     STATEMENT 1 ON LINE 96
read_length_rs:
     entry (iocb_ptr_arg, rec_len, code);

000341  at     000003000003
000342  tt     000001000002
000343  ta     000341000000
000344  da     000121300000
000345  aa   000160 6270 00	eax7 	112
000346  aa  7 00034 3521 20	epp2 	pr7|28,*
000347  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000350  aa     000006000000
000351  aa     000000000000
000352  aa  6 00032 3735 20	epp7 	pr6|26,*
000353  aa  7 00004 3715 20	epp5 	pr7|4,*
000354  aa  6 00122 6515 00	spri5	pr6|82
000355  aa  7 00006 3535 20	epp3 	pr7|6,*
000356  aa  6 00120 2535 00	spri3	pr6|80
						STATEMENT 1 ON LINE 98
	call initialize;

000357  aa   000160 6700 04	tsp4 	112,ic		000537
						STATEMENT 1 ON LINE 99
	if n_left = 0				/* rs_buffer is empty */
	then do;

000360  aa  6 00102 3735 20	epp7 	pr6|66,*		rsab_ptr
000361  aa  7 00050 2361 00	ldq  	pr7|40		rs_attach_block.n_left
000362  aa   000027 6010 04	tnz  	23,ic		000411
						STATEMENT 1 ON LINE 101
		call read_record_rs (iocb_ptr, rs_buff_ptr, max_bufsize, n_left, code);

000363  aa  6 00100 3521 00	epp2 	pr6|64		iocb_ptr
000364  aa  6 00134 2521 00	spri2	pr6|92
000365  aa  6 00104 3521 00	epp2 	pr6|68		rs_buff_ptr
000366  aa  6 00136 2521 00	spri2	pr6|94
000367  aa  6 00044 3701 20	epp4 	pr6|36,*
000370  ia  4 00010 3521 00	epp2 	pr4|8		max_bufsize
000371  aa  6 00140 2521 00	spri2	pr6|96
000372  aa  7 00050 3521 00	epp2 	pr7|40		rs_attach_block.n_left
000373  aa  6 00142 2521 00	spri2	pr6|98
000374  aa  6 00120 3521 20	epp2 	pr6|80,*		code
000375  aa  6 00144 2521 00	spri2	pr6|100
000376  aa  6 00132 6211 00	eax1 	pr6|90
000377  aa   024000 4310 07	fld  	10240,dl
000400  aa   777443 3520 04	epp2 	-221,ic		000043 = 000160627000
000401  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 102
		if (n_left = 0) & (code = 0)
		then n_left = -1;

000402  aa  6 00102 3735 20	epp7 	pr6|66,*		rsab_ptr
000403  aa  7 00050 2361 00	ldq  	pr7|40		rs_attach_block.n_left
000404  aa   000005 6010 04	tnz  	5,ic		000411
000405  aa  6 00120 2361 20	ldq  	pr6|80,*		code
000406  aa   000003 6010 04	tnz  	3,ic		000411
000407  aa   000001 3360 07	lcq  	1,dl
000410  aa  7 00050 7561 00	stq  	pr7|40		rs_attach_block.n_left
						STATEMENT 1 ON LINE 104
	     end;

						STATEMENT 1 ON LINE 105
	if n_left > 0
	then rec_len = n_left;

000411  aa  7 00050 2361 00	ldq  	pr7|40		rs_attach_block.n_left
000412  aa   000003 6044 04	tmoz 	3,ic		000415
000413  aa  6 00122 7561 20	stq  	pr6|82,*		rec_len
000414  aa   000002 7100 04	tra  	2,ic		000416
						STATEMENT 1 ON LINE 107
	else rec_len = 0;

000415  aa  6 00122 4501 20	stz  	pr6|82,*		rec_len
						STATEMENT 1 ON LINE 108
	return;

000416  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO position_seq_rs                                    STATEMENT 1 ON LINE 110
position_seq_rs:
     entry (iocb_ptr_arg, type, count, code);

000417  at     000004000003
000420  tt     000000000001
000421  ta     000002000000
000422  ta     000417000000
000423  da     000130300000
000424  aa   000160 6270 00	eax7 	112
000425  aa  7 00034 3521 20	epp2 	pr7|28,*
000426  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000427  aa     000010000000
000430  aa     000000000000
000431  aa  6 00032 3735 20	epp7 	pr6|26,*
000432  aa  7 00010 3715 20	epp5 	pr7|8,*
000433  aa  6 00120 6515 00	spri5	pr6|80
						STATEMENT 1 ON LINE 112
	call initialize;

000434  aa   000103 6700 04	tsp4 	67,ic		000537
						STATEMENT 1 ON LINE 113
	n = count;

000435  aa  6 00032 3735 20	epp7 	pr6|26,*
000436  aa  7 00006 2361 20	ldq  	pr7|6,*		count
000437  aa  6 00115 7561 00	stq  	pr6|77		n
						STATEMENT 1 ON LINE 114
	if type ^= 0
	then do;

000440  aa  7 00004 2361 20	ldq  	pr7|4,*		type
000441  aa   000023 6000 04	tze  	19,ic		000464
						STATEMENT 1 ON LINE 116
		n_left = 0;

000442  aa  6 00102 3715 20	epp5 	pr6|66,*		rsab_ptr
000443  aa  5 00050 4501 00	stz  	pr5|40		rs_attach_block.n_left
						STATEMENT 1 ON LINE 117
pass_call:
		call iox_$position (target_iocb_ptr, type, n, code);

000444  aa  6 00102 3735 20	epp7 	pr6|66,*		rsab_ptr
000445  aa  7 00044 3521 00	epp2 	pr7|36		rs_attach_block.target_iocb_ptr
000446  aa  6 00134 2521 00	spri2	pr6|92
000447  aa  6 00032 3715 20	epp5 	pr6|26,*
000450  aa  5 00004 3521 20	epp2 	pr5|4,*		type
000451  aa  6 00136 2521 00	spri2	pr6|94
000452  aa  6 00115 3521 00	epp2 	pr6|77		n
000453  aa  6 00140 2521 00	spri2	pr6|96
000454  aa  6 00120 3521 20	epp2 	pr6|80,*		code
000455  aa  6 00142 2521 00	spri2	pr6|98
000456  aa  6 00132 6211 00	eax1 	pr6|90
000457  aa   020000 4310 07	fld  	8192,dl
000460  aa  6 00044 3701 20	epp4 	pr6|36,*
000461  la  4 00022 3521 20	epp2 	pr4|18,*		iox_$position
000462  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 120
	     end;

000463  aa   000053 7100 04	tra  	43,ic		000536
						STATEMENT 1 ON LINE 121
	else do;

						STATEMENT 1 ON LINE 122
		if n ^= 0
		then do;

000464  aa  6 00115 2361 00	ldq  	pr6|77		n
000465  aa   000051 6000 04	tze  	41,ic		000536
						STATEMENT 1 ON LINE 124
			old_n_left = n_left;

000466  aa  6 00102 3715 20	epp5 	pr6|66,*		rsab_ptr
000467  aa  5 00050 2361 00	ldq  	pr5|40		rs_attach_block.n_left
000470  aa  6 00116 7561 00	stq  	pr6|78		old_n_left
						STATEMENT 1 ON LINE 125
			if n_left ^= 0
			then do;

000471  aa   000004 6000 04	tze  	4,ic		000475
						STATEMENT 1 ON LINE 127
				n = n - 1;

000472  aa   000001 3360 07	lcq  	1,dl
000473  aa  6 00115 0561 00	asq  	pr6|77		n
						STATEMENT 1 ON LINE 128
				n_left = 0;

000474  aa  5 00050 4501 00	stz  	pr5|40		rs_attach_block.n_left
						STATEMENT 1 ON LINE 129
			     end;

						STATEMENT 1 ON LINE 130
			if length_n = 0		/* default case */
			then go to pass_call;

000475  aa  5 00032 2361 00	ldq  	pr5|26		rs_attach_block.length_n
000476  aa   777746 6000 04	tze  	-26,ic		000444
						STATEMENT 1 ON LINE 132
			else /* -length case */
			     if n < 0
			then do;

000477  aa  6 00115 2361 00	ldq  	pr6|77		n
000500  aa   000007 6050 04	tpl  	7,ic		000507
						STATEMENT 1 ON LINE 135
				code = error_table_$negative_nelem;

000501  aa  6 00044 3701 20	epp4 	pr6|36,*
000502  la  4 00024 2361 20	ldq  	pr4|20,*		error_table_$negative_nelem
000503  aa  6 00120 7561 20	stq  	pr6|80,*		code
						STATEMENT 1 ON LINE 136
				n_left = old_n_left;

000504  aa  6 00116 2361 00	ldq  	pr6|78		old_n_left
000505  aa  5 00050 7561 00	stq  	pr5|40		rs_attach_block.n_left
						STATEMENT 1 ON LINE 137
			     end;

000506  aa   000030 7100 04	tra  	24,ic		000536
						STATEMENT 1 ON LINE 138
			else /* read past n records */
			     do while ((n > 0) & (code = 0));

000507  aa   000000 0110 03	nop  	0,du
000510  aa  6 00115 2361 00	ldq  	pr6|77		n
000511  aa   000025 6044 04	tmoz 	21,ic		000536
000512  aa  6 00120 2361 20	ldq  	pr6|80,*		code
000513  aa   000023 6010 04	tnz  	19,ic		000536
						STATEMENT 1 ON LINE 140
				call read_record_rs (iocb_ptr, rs_buff_ptr, max_bufsize, n_read, code);

000514  aa  6 00100 3521 00	epp2 	pr6|64		iocb_ptr
000515  aa  6 00134 2521 00	spri2	pr6|92
000516  aa  6 00104 3521 00	epp2 	pr6|68		rs_buff_ptr
000517  aa  6 00136 2521 00	spri2	pr6|94
000520  aa  6 00044 3701 20	epp4 	pr6|36,*
000521  ia  4 00010 3521 00	epp2 	pr4|8		max_bufsize
000522  aa  6 00140 2521 00	spri2	pr6|96
000523  aa  6 00112 3521 00	epp2 	pr6|74		n_read
000524  aa  6 00142 2521 00	spri2	pr6|98
000525  aa  6 00120 3521 20	epp2 	pr6|80,*		code
000526  aa  6 00144 2521 00	spri2	pr6|100
000527  aa  6 00132 6211 00	eax1 	pr6|90
000530  aa   024000 4310 07	fld  	10240,dl
000531  aa   777312 3520 04	epp2 	-310,ic		000043 = 000160627000
000532  aa  0 00621 7001 00	tsx0 	pr0|401		call_ext_in
						STATEMENT 1 ON LINE 141
				n = n - 1;

000533  aa   000001 3360 07	lcq  	1,dl
000534  aa  6 00115 0561 00	asq  	pr6|77		n
						STATEMENT 1 ON LINE 142
			     end;

000535  aa   777753 7100 04	tra  	-21,ic		000510
						STATEMENT 1 ON LINE 143
		     end;

						STATEMENT 1 ON LINE 144
	     end;

						STATEMENT 1 ON LINE 145
	return;

000536  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 191
     end rs_open_seq_in_;

BEGIN PROCEDURE initialize
ENTRY TO initialize                                         STATEMENT 1 ON LINE 148
initialize:
     proc;

000537  aa  6 00124 6501 00	spri4	pr6|84
						STATEMENT 1 ON LINE 150
	iocb_ptr = iocb_ptr_arg -> actual_iocb_ptr;

000540  aa  6 00032 3735 20	epp7 	pr6|26,*
000541  aa  7 00002 3715 20	epp5 	pr7|2,*		iocb_ptr_arg
000542  aa  5 00000 3715 20	epp5 	pr5|0,*		iocb_ptr_arg
000543  aa  5 00012 3535 20	epp3 	pr5|10,*		iocb.actual_iocb_ptr
000544  aa  6 00100 2535 00	spri3	pr6|64		iocb_ptr
						STATEMENT 1 ON LINE 151
	rsab_ptr = attach_data_ptr;

000545  aa  3 00016 3515 20	epp1 	pr3|14,*		iocb.attach_data_ptr
000546  aa  6 00102 2515 00	spri1	pr6|66		rsab_ptr
						STATEMENT 1 ON LINE 152
	rs_buff_ptr = open_data_ptr;

000547  aa  3 00022 3715 20	epp5 	pr3|18,*		iocb.open_data_ptr
000550  aa  6 00104 6515 00	spri5	pr6|68		rs_buff_ptr
						STATEMENT 1 ON LINE 153
	code = 0;

000551  aa  6 00120 4501 20	stz  	pr6|80,*		code
						STATEMENT 1 ON LINE 154
	return;

000552  aa  6 00124 6101 00	rtcd 	pr6|84
						STATEMENT 1 ON LINE 156
     end initialize;

  END PROCEDURE initialize
  END PROCEDURE rs_open_seq_in_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
