	COMPILATION LISTING OF SEGMENT dump_segment
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 01/12/88  1245.0 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 dump_segment:
       13 ds:
       14      proc;
       15 
       16 
       17 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       18 /*							       */
       19 /* This command dumps the contents of a segment in octal, hex8, or hex9 with */
       20 /* optional ascii, bcd, ebcdic9, ebcdic8, or 4-bit translation. The segment  */
       21 /* to be dumped may be specified by octal segment number, SLT name,	       */
       22 /* (relative) pathname.					       */
       23 /*							       */
       24 /* Usage:							       */
       25 /*							       */
       26 /*    dump_segment seg start count -control_args			       */
       27 /* or:							       */
       28 /*    dump_segment virtual_pointer count -control_args		       */
       29 /*							       */
       30 /* where:							       */
       31 /*							       */
       32 /* seg		is the segment to dump			       */
       33 /* start		is the first word to dump			       */
       34 /* count		is the number of words to dump		       */
       35 /* virtual_pointer	is a pointer understood by cv_ptr_		       */
       36 /*							       */
       37 /* and control args can be:					       */
       38 /*							       */
       39 /* -long (-lg)						       */
       40 /* -short (-sh)						       */
       41 /* -character (-ch, -ascii)					       */
       42 /* -bcd							       */
       43 /* -ebcdic9						       */
       44 /* -ebcdic8						       */
       45 /* -4bit							       */
       46 /* -name (-nm) path						       */
       47 /* -hex8							       */
       48 /* -hex9							       */
       49 /* -block (-bk) N						       */
       50 /* -address (-addr)						       */
       51 /* -no_address (-nad, -naddr)					       */
       52 /* -offset (-ofs) N						       */
       53 /* -no_offset (-nofs)					       */
       54 /* -header (-he)						       */
       55 /* -no_header (-nhe)					       */
       56 /* -entry_point (-ep) name					       */
       57 /* -interpreted_data (-id)					       */
       58 /* -no_interpreted_data (-nid)				       */
       59 /* -raw_data (-rd)						       */
       60 /* -no_raw_data (-nrd)					       */
       61 /* -suppress_duplicates (-sd)					       */
       62 /* -no_suppress_duplicates (nsd)				       */
       63 /* -rest							       */
       64 /* -as structure_name					       */
       65 /* -in pathname						       */
       66 /*							       */
       67 /* Defaults for use as a command:				       */
       68 /*   -no_offset, -raw_data, -no_interpreted_data, -suppress_duplicates       */
       69 /* Defaults for use as an active function:			       */
       70 /*   -no_header, -no_address, -no_offset, -raw_data, -no_interpreted_data    */
       71 /*   -no_suppress_duplicates					       */
       72 /*							       */
       73 /* Last modified (date and reason):				       */
       74 /* 5/15/75	by S.Webber Initial coding (discarding earlier code)     */
       75 /* 11/15/75	by S.Webber to add -address, -offset, -header, and       */
       76 /*			         -block control args		       */
       77 /* 04/27/76	by T. Casey to fix "-block N -offset" to reset offset    */
       78 /*			  for each block, to make -name N work right,  */
       79 /* 			  to accept control argument abbreviations     */
       80 /*			  -addr and -bk, and clean up code and fix     */
       81 /*			  minor obscure bugs.		       */
       82 /* 10/18/76 	by R.Kissel to add -ebcdic9, -ebcdic8, -4bit, -hex8,     */
       83 /*			  hex9 to clean up code, and to change	       */
       84 /*  			  the output format.		       */
       85 /* 02/16/77	by R.Kissel to add the dump_segment_ subroutine entry    */
       86 /*			  point.				       */
       87 /* 01/16/79	by R.J.C. Kissel to fix error message bug.	       */
       88 /* 06/22/79	by S. Herbst to fix error message for MSF's.	       */
       89 /* 04/04/81	by W. Olin Sibert, to use			       */
       90 /*			         ring_zero_peek_$get_max_length_ptr    */
       91 /*			         instead of depending on SDW format.   */
       92 /* 11/03/81	by J. Bongiovanni for -entry_point		       */
       93 /* 09/26/83	by C. Spitzer				       */
       94 /*		phx07028 return more than 1 word if invoked as AF.       */
       95 /*		phx07253 add -raw_data -interpreted_data and complements */
       96 /*		phx08128 use current length instead of max length.       */
       97 /*		phx10338,phx12336 bugfix to print et_$dirseg for	       */
       98 /*			        directories.		       */
       99 /* 		phx08905 make -lg -hex9 -ch work together.	       */
      100 /*		phx14729 correct display for -hex8 and hex9 format.      */
      101 /*		suggestion: add -suppress_duplicates and complement      */
      102 /*			        format.			       */
      103 /*		bug: diagnose illegal CAs when used as active function.  */
      104 /*		bug: correct display for -ch and incompletely filled line*/
      105 /*							       */
      106 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      107 
      108 /****^  HISTORY COMMENTS:
      109*  1) change(85-12-17,Spitzer), approve(85-12-17,MCR7119),
      110*     audit(86-01-20,Lippard), install(86-01-29,MR12.0-1009):
      111*     Make -ep work same as octal offsets. Allow rzd dump stack_0.  Add -rest
      112*     CA.
      113*  2) change(85-12-17,Spitzer), approve(85-12-17,MCR7268),
      114*     audit(86-01-20,Lippard), install(86-01-29,MR12.0-1009):
      115*     Allow virtual pointers as input.
      116*  3) change(86-07-30,Kissel), approve(86-07-30,MCR7476), audit(86-08-01,Ex),
      117*     install(86-08-19,MR12.0-1132):
      118*     Changed to call translate_bytes_to_hex9_, which is the new name for
      119*     translate_to_hex9.
      120*  4) change(87-01-02,TLNguyen), approve(87-01-02,MCR7596),
      121*     audit(87-01-16,GWMay), install(87-03-19,MR12.1-1004):
      122*     Fixed the "dump_segment" active function to strip trailing spaces.
      123*  5) change(87-11-26,GDixon), approve(88-01-05,MCR7817),
      124*     audit(88-01-06,Farley), install(88-01-12,MR12.2-1012):
      125*      A) Add -as and -in to display data as a structure.
      126*                                                   END HISTORY COMMENTS */
      127 
      128 
      129 
      130 /* Automatic */
      131 
      132 	dcl     active_func		 bit (1) aligned;
      133 	dcl     arg_for_header_given
      134 				 bit (1);
      135 	dcl     argc		 fixed bin;
      136 	dcl     bit_count		 fixed bin (24);
      137 	dcl     block		 fixed bin (18);
      138 	dcl     buffer		 (64) fixed bin;
      139 	dcl     code		 fixed bin (35);
      140 	dcl     count		 fixed bin (18);
      141 	dcl     cur_length		 fixed bin (18);
      142 	dcl     defn_ptr		 ptr;
      143 	dcl     dir_len		 fixed bin;
      144 	dcl     dirname		 char (168);
      145 	dcl     ename		 char (32);
      146 	dcl     entry_point_name	 char (32);
      147 	dcl     entry_point_offset	 fixed bin (18);
      148 	dcl     entry_type		 fixed bin;
      149 	dcl     entry_var		 entry variable options (variable);
      150 	dcl     first		 fixed bin (18);
      151 	dcl     have_count		 bit (1);
      152 	dcl     have_entry_point	 bit (1);
      153 	dcl     have_first		 bit (1);
      154 	dcl     have_name		 bit (1);
      155 	dcl     have_structure	 bit (1);
      156 	dcl     have_structure_path	 bit (1);
      157 	dcl     hcsp		 (1) ptr;
      158 	dcl     hc_seg		 bit (1);
      159 	dcl     highseg		 fixed bin;
      160 	dcl     i			 fixed bin;
      161 	dcl     initsw		 bit (1);
      162 	dcl     iocbp		 ptr;
      163 	dcl     line_format		 char (28) var;
      164 	dcl     max_length		 fixed bin (19);
      165 	dcl     1 obj_info		 aligned like object_info;
      166 	dcl     p			 ptr;		/* pointer to the segment we are dumping */
      167 	dcl     rel_offset		 fixed bin (18);
      168 	dcl     rest		 bit (1) aligned;
      169 	dcl     ret_tc		 fixed bin (21);
      170 	dcl     ret_tp		 ptr;
      171 	dcl     output_line_len	 fixed bin (21);
      172 	dcl     output_line		 char (256);
      173 	dcl     rz_call		 bit (1);
      174 	dcl     rb2		 bit (6);		/* third ring bracket number */
      175 	dcl     segno		 fixed bin (18);
      176 	dcl     seg_num		 bit (1);
      177 	dcl     structure_name	 char(256) varying; /* name of structure to dump. */
      178 	dcl     structure_path	 char(168);	/* pathname of object pgm compiled with -table */
      179 	dcl     tc		 fixed bin;	/* count of chars in command_arg */
      180 	dcl     tca		 fixed bin;	/* count of chars in seg_name */
      181 	dcl     tp		 ptr;		/* pointer to command_arg */
      182 	dcl     tpa		 ptr;		/* pointer to seg_name */
      183 
      184 /* Format control flags */
      185 
  1     1 /*  START OF:	dump_segment_format.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1     2 
  1     3 /* Describes the output format understood by the dump_segment_ and
  1     4*   dump_segment_$return_string subroutines. */
  1     5 
  1     6 /* Created: 10/25/83 by C Spitzer */
  1     7 
  1     8 dcl dump_segment_format bit (36) based (addr (dump_segment_format_structure));
  1     9 
  1    10 dcl 1 dump_segment_format_structure aligned,		/* if = "1"b, then */
  1    11       2 address bit (1) unaligned,			/* display address part */
  1    12       2 offset bit (1) unaligned,			/* display offset part */
  1    13       2 short bit (1) unaligned,			/* format display to have 4 words per line */
  1    14       2 bcd bit (1) unaligned,			/* interpret data as BCD */
  1    15       2 ascii bit (1) unaligned,			/* interpret data as ASCII */
  1    16       2 long bit (1) unaligned,			/* format display to have 8 words per line */
  1    17       2 ebcdic9 bit (1) unaligned,			/* interpret data as EBCDIC (9 bits) */
  1    18       2 ebcdic8 bit (1) unaligned,			/* interpret data as EBCDIC (8 bits) */
  1    19       2 bit4 bit (1) unaligned,			/* interpret data as 4 bit data */
  1    20       2 hex8 bit (1) unaligned,			/* raw data is hexadecimal (8 bit) */
  1    21       2 hex9 bit (1) unaligned,			/* raw data is hexadecimal (9 bit) */
  1    22 
  1    23 /* Beginning of MR11 understood items */
  1    24 
  1    25       2 octal bit (1) unaligned,			/* raw data is octal */
  1    26       2 header bit (1) unaligned,			/* display header */
  1    27       2 raw_data bit (1) unaligned,			/* display raw data */
  1    28       2 interpreted_data bit (1) unaligned,		/* display interpreted data */
  1    29       2 suppress_duplicates bit (1) unaligned,		/* replace duplicate lines with equal signs */
  1    30       2 command_output bit (1) unaligned,		/* if returning output, return in command-type output format */
  1    31       2 mbz bit (19) unaligned;			/* future expansion */
  1    32 
  1    33 /*  END OF:	dump_segment_format.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      186 
      187 	dcl     address_fmt		 bit (1) defined (dump_segment_format) pos (1);
      188 	dcl     offset_fmt		 bit (1) defined (dump_segment_format) pos (2);
      189 	dcl     short_fmt		 bit (1) defined (dump_segment_format) pos (3);
      190 	dcl     bcd_fmt		 bit (1) defined (dump_segment_format) pos (4);
      191 	dcl     char_fmt		 bit (1) defined (dump_segment_format) pos (5);
      192 	dcl     long_fmt		 bit (1) defined (dump_segment_format) pos (6);
      193 	dcl     ebcdic9_fmt		 bit (1) defined (dump_segment_format) pos (7);
      194 	dcl     ebcdic8_fmt		 bit (1) defined (dump_segment_format) pos (8);
      195 	dcl     bit4_fmt		 bit (1) defined (dump_segment_format) pos (9);
      196 	dcl     hex8_fmt		 bit (1) defined (dump_segment_format) pos (10);
      197 	dcl     hex9_fmt		 bit (1) defined (dump_segment_format) pos (11);
      198 	dcl     octal_fmt		 bit (1) defined (dump_segment_format) pos (12);
      199 	dcl     header		 bit (1) defined (dump_segment_format) pos (13);
      200 	dcl     raw_data_fmt	 bit (1) defined (dump_segment_format) pos (14);
      201 	dcl     interpreted_data_fmt	 bit (1) defined (dump_segment_format) pos (15);
      202 	dcl     suppress_dup_fmt	 bit (1) defined (dump_segment_format) pos (16);
      203 	dcl     command_output_fmt	 bit (1) defined (dump_segment_format) pos (17);
      204 
      205 /* Based */
      206 
      207 	dcl     command_arg		 char (tc) based (tp);
      208 	dcl     seg_name		 char (tca) based (tpa);
      209 	dcl     return_arg		 char (ret_tc) based (ret_tp) var;
      210 
      211 /* Conditions */
      212 
      213 	dcl     linkage_error	 condition;
      214 	dcl     cleanup		 condition;
      215 	dcl     not_in_read_bracket
      216 				 condition;
      217 
      218 /* Static */
      219 
      220 	dcl     dots		 char (33) aligned internal static options (constant) init ((33)".");
      221 	dcl     first_time		 bit (1) static init ("1"b);
      222 	dcl     nonprinting_chars	 char (33) aligned internal static;
      223 	dcl     com_err_fmt		 (25) char (80) var options (constant) static
      224 				 init ("", "^a", "^s^a>^a", "Nonoctal number: ^a", "name/no of segment",
      225 				 "Hardcore segment won't be dumped.", "block size for dumping", "Zero is illegal for count",
      226 				 "First word is ^4s^o, max_length is only ^o", "No control arguments specified to dump any data.",
      227 				 "Control arguments were specified to dump both raw and interpreted data.", "-hex8 and -hex9.",
      228 				 "entry_point name", "^2s^a$^a", "^1s^a>^a$^a",
      229 				 "word count and -entry_point", "Nonpositive octal number: ^a",
      230 				 "Attempt to dump before the beginning of the referenced segment.",
      231 				 "Count argument and -rest.", 
      232 				 "-as must be followed by a structure name.",
      233 				 "-in must be followed by path of object segment.",
      234 				 "-as not allowed with active function.",
      235 				 "Parsing structure ^6s^a.",
      236 				 "Searching for structure ^6s^a in ^[^a^;library^].",
      237 				 "Displaying structure ^6s^a.");
      238 	dcl     active_all_rings_data_$stack_base_segno fixed bin (35) ext static;
      239 	dcl     hcscnt		 fixed bin static;
      240 	dcl     NL		 char (1) int static options (constant) init ("
      241 ");
      242 	dcl     me		 (0:1) char (14) internal static options (constant)
      243 				 init ("dump_segment", "ring_zero_dump");
      244 
      245 /* External */
      246 
      247 	dcl     error_table_$badopt	 fixed bin (35) ext;
      248 	dcl     error_table_$dirseg	 fixed bin (35) ext;
      249 	dcl     error_table_$inconsistent fixed bin(35) ext static;
      250 	dcl     error_table_$lower_ring fixed bin (35) ext;
      251 	dcl     error_table_$msf	 fixed bin (35) ext;
      252 	dcl     error_table_$no_s_permission fixed bin (35) ext;
      253 	dcl     error_table_$noarg	 fixed bin (35) ext;
      254 	dcl     error_table_$too_many_args fixed bin (35) ext;
      255 
      256 	dcl     iox_$user_output	 ptr ext;
      257 
      258 /* Builtin */
      259 
      260 	dcl     (addr, addrel, baseno, baseptr, binary, clock, collate,
      261 	         divide, fixed, index, length, min, mod, null, rel, ptr,
      262 	         reverse, rtrim, search, substr, string, translate, wordno,
      263 	         unspec, verify) builtin;
      264 
      265 /* Entries */
      266 
      267 	dcl     get_temp_segments_	 entry (char (*), (*) ptr, fixed bin (35));
      268 	dcl     release_temp_segments_ entry (char (*), (*) ptr, fixed bin (35));
      269 	dcl     expand_pathname_	 entry (char (*), char (*), char (*), fixed bin (35));
      270 	dcl     initiate_file_	 entry (char(*), char(*), bit(*), ptr, fixed bin(24), fixed bin(35));
      271 	dcl     phcs_$initiate	 entry (char (*), char (*), char (*), fixed bin, fixed bin, ptr, fixed bin (35));
      272 	dcl     requote_string_	 entry (char(*)) returns(char(*));
      273 	dcl     (ioa_$ioa_switch, com_err_, active_fnc_err_)
      274 				 entry options (variable);
      275 	dcl     hcs_$fs_get_path_name  entry (ptr, char (*), fixed bin, char (*), fixed bin (35));
      276 	dcl     hcs_$high_low_seg_count
      277 				 entry (fixed bin, fixed bin);
      278 	dcl     hcs_$status_minf	 entry (char (*), char (*), fixed bin (1), fixed bin (2),
      279 				 fixed bin (24), fixed bin (35));
      280 	dcl     ring0_get_$segptr	 entry (char (*), char (*), ptr, fixed bin (35));
      281 	dcl     ring0_get_$definition entry (ptr, char (*), char (*), fixed bin (18), fixed bin, fixed bin (35));
      282 	dcl     ring0_get_$name	 entry (char (*), char (*), ptr, fixed bin (35));
      283 	dcl     ring_zero_peek_	 entry (ptr, ptr, fixed bin (18), fixed bin (35));
      284 	dcl     ring_zero_peek_$get_max_length_ptr
      285 				 entry (ptr, fixed bin (19), fixed bin (35));
      286 	dcl     terminate_file_	 entry (ptr, fixed bin(24), bit(*), fixed bin(35));
      287 	dcl     cu_$af_return_arg	 entry (fixed bin, ptr, fixed bin(21), fixed bin(35));
      288 	dcl     (ioa_$rs, ioa_$rsnnl)	 entry options (variable);
      289 	dcl     iox_$put_chars	 entry (ptr, ptr, fixed bin (21), fixed bin (35));
      290 	dcl     cv_oct_check_	 entry (char (*), fixed bin (35)) returns (fixed bin);
      291 	dcl     translate_bytes_to_hex9_	 entry (bit (*), char (*));
      292 	dcl     get_ring_		 entry returns (fixed bin (3));
      293 	dcl     get_definition_	 entry (ptr, char (*), char (*), ptr, fixed bin (35));
      294 	dcl     object_info_$brief	 entry (ptr, fixed bin (24), ptr, fixed bin (35));
      295 	dcl     display_data_$for_azm  entry (ptr, bit(*) aligned, (*) char(*) var,
      296 				 fixed bin, ptr, ptr, fixed bin(18), ptr, ptr, (2,*) fixed bin(24),
      297 				 fixed bin, fixed bin(35));
      298 	dcl     structure_find_$pathname
      299 		        		 entry (char(*), char(*), ptr, fixed bin(35));
      300 	dcl     structure_find_$search entry (char(*), ptr, fixed bin(35));
      301 	dcl     structure_ref_$parse   entry (char(*), char(*), char(*), (2,*) fixed bin(24),
      302 				 fixed bin, (*) char(*) var, fixed bin, fixed bin(35));
      303 
      304 	rz_call = "0"b;
      305 
      306 	goto COMMON_CODE;				/* dump_segment entry */
      307 
      308 ring_zero_dump:
      309 rzd:
      310      entry;
      311 
      312 	rz_call = "1"b;				/* indicate it is legal to dump ring 0 segs */
      313 
      314 COMMON_CODE:
      315 	if first_time
      316 	then do;					/* only once get segment number of last hardcore segment */
      317 		call hcs_$high_low_seg_count (highseg, hcscnt);
      318 						/* so we can know if the given seg is hardcore or not */
      319 		nonprinting_chars = substr (collate (), 1, 32) || substr (collate (), 128, 1);
      320 		first_time = "0"b;
      321 	     end;
      322 
      323 
      324 /* Initialize */
      325 
      326 	string (dump_segment_format) = ""b;		/* initialize all the format flags to 0 */
      327 	iocbp = iox_$user_output;
      328 	have_name, seg_num, have_first, have_count, have_entry_point,
      329 	     have_structure, have_structure_path, initsw,
      330 	     arg_for_header_given, hc_seg = "0"b;
      331 	rest = "0"b;
      332 	rel_offset = 0;
      333 	entry_point_offset = 0;
      334 	block = 0;
      335 	max_length = 0;
      336 	hcsp (1) = null;
      337 	tp = null;
      338 	tc = 0;
      339 
      340 	call cu_$af_return_arg (argc, ret_tp, ret_tc, code);
      341 						/* see if active function, also get return string info */
      342 	if code = 0
      343 	then do;
      344 		active_func = "1"b;			/* active function call */
      345 		raw_data_fmt = "1"b;
      346 		return_arg = "";
      347 	     end;
      348 	else do;
      349 		active_func = "0"b;			/* command call */
      350 		address_fmt, raw_data_fmt, suppress_dup_fmt = "1"b;
      351 	     end;
      352 
      353 	if argc = 0
      354 	then call PRINT_ERROR (error_table_$noarg, 5);	/* need at least a segment name */
      355 
      356 	on cleanup
      357 	     call cleaner_upper;
      358 
      359 /* Loop through all arguments setting flags and variables */
      360 
      361 	do i = 1 to argc;
      362 	     call get_arg_ptr (i);			/* get pointer and length of i'th arg */
      363 	     if index (command_arg, "-") = 1
      364 	     then do;				/* process control arguments */
      365 		     if (command_arg = "-long" | command_arg = "-lg") & ^active_func
      366 		     then do;
      367 			     long_fmt = "1"b;
      368 			     short_fmt = "0"b;
      369 			end;
      370 		     else if (command_arg = "-suppress_duplicates" | command_arg = "-sd") & ^active_func
      371 		     then suppress_dup_fmt = "1"b;
      372 		     else if command_arg = "-no_suppress_duplicates" | command_arg = "-nsd"
      373 		     then suppress_dup_fmt = "0"b;
      374 		     else if command_arg = "-raw"
      375 		     then raw_data_fmt = "1"b;
      376 		     else if command_arg = "-no_raw" | command_arg = "-nraw"
      377 		     then raw_data_fmt = "0"b;
      378 		     else if command_arg = "-rest"
      379 		     then rest = "1"b;
      380 		     else if command_arg = "-interpreted" | command_arg = "-it"
      381 		     then interpreted_data_fmt = "1"b;
      382 		     else if command_arg = "-no_interpret" | command_arg = "-nit"
      383 		     then interpreted_data_fmt = "0"b;
      384 		     else if command_arg = "-character" | command_arg = "-ch" | command_arg = "-ascii"
      385 		     then do;
      386 			     char_fmt, interpreted_data_fmt = "1"b;
      387 			     bit4_fmt, ebcdic8_fmt, ebcdic9_fmt, bcd_fmt = "0"b;
      388 			     if active_func
      389 			     then raw_data_fmt = "0"b;
      390 			end;
      391 		     else if command_arg = "-bcd"
      392 		     then do;
      393 			     bcd_fmt, interpreted_data_fmt = "1"b;
      394 			     char_fmt, bit4_fmt, ebcdic8_fmt, ebcdic9_fmt = "0"b;
      395 			     if active_func
      396 			     then raw_data_fmt = "0"b;
      397 			end;
      398 		     else if command_arg = "-ebcdic9"
      399 		     then do;
      400 			     ebcdic9_fmt, interpreted_data_fmt = "1"b;
      401 			     char_fmt, bit4_fmt, ebcdic8_fmt = "0"b;
      402 			     if active_func
      403 			     then raw_data_fmt = "0"b;
      404 			end;
      405 		     else if command_arg = "-ebcdic8"
      406 		     then do;
      407 			     ebcdic8_fmt, interpreted_data_fmt = "1"b;
      408 			     char_fmt, bit4_fmt, ebcdic9_fmt = "0"b;
      409 			     if active_func
      410 			     then raw_data_fmt = "0"b;
      411 			end;
      412 		     else if command_arg = "-4bit"
      413 		     then do;
      414 			     bit4_fmt, interpreted_data_fmt = "1"b;
      415 			     char_fmt, ebcdic8_fmt, ebcdic9_fmt = "0"b;
      416 			     if active_func
      417 			     then raw_data_fmt = "0"b;
      418 			end;
      419 		     else if command_arg = "-hex8"
      420 		     then do;
      421 			     hex8_fmt, raw_data_fmt = "1"b;
      422 			     hex9_fmt, octal_fmt = "0"b;
      423 			     if active_func
      424 			     then interpreted_data_fmt = "0"b;
      425 			end;
      426 		     else if command_arg = "-hex9"
      427 		     then do;
      428 			     hex9_fmt, raw_data_fmt = "1"b;
      429 			     hex8_fmt, octal_fmt = "0"b;
      430 			     if active_func
      431 			     then interpreted_data_fmt = "0"b;
      432 			end;
      433 		     else if command_arg = "-octal" | command_arg = "-oc"
      434 		     then do;
      435 			     octal_fmt, raw_data_fmt = "1"b;
      436 			     hex8_fmt, hex9_fmt = "0"b;
      437 			     if active_func
      438 			     then interpreted_data_fmt = "0"b;
      439 			end;
      440 		     else if (command_arg = "-short" | command_arg = "-sh") & ^active_func
      441 		     then do;
      442 			     short_fmt = "1"b;
      443 			     long_fmt = "0"b;
      444 			end;
      445 		     else if (command_arg = "-address" | command_arg = "-ad" | command_arg = "-addr") & ^active_func
      446 		     then address_fmt = "1"b;
      447 		     else if (command_arg = "-no_address" | command_arg = "-naddr" | command_arg = "-nad") & ^active_func
      448 		     then address_fmt = "0"b;
      449 		     else if (command_arg = "-offset" | command_arg = "-ofs") & ^active_func
      450 		     then do;
      451 			     offset_fmt = "1"b;
      452 			     if i < argc
      453 			     then do;
      454 				     call get_arg_ptr (i + 1);
      455 						/* check next arg, if octal then use as offset */
      456 				     rel_offset = cv_oct_check_ (command_arg, code);
      457 				     if code = 0
      458 				     then i = i + 1;/* if octal, advance arg index past it */
      459 				     else rel_offset = 0;
      460 						/* else leave arg index alone and use default of zero */
      461 				end;
      462 			end;
      463 		     else if (command_arg = "-no_offset" | command_arg = "-nofs") & ^active_func
      464 		     then offset_fmt = "0"b;
      465 		     else if (command_arg = "-header" | command_arg = "-he") & ^active_func
      466 		     then header = "1"b;
      467 		     else if (command_arg = "-no_header" | command_arg = "-nhe") & ^active_func
      468 		     then do;
      469 			     header = "0"b;
      470 			     arg_for_header_given = "1"b;
      471 			end;
      472 		     else if (command_arg = "-block" | command_arg = "-bk") & ^active_func
      473 		     then do;
      474 			     if i < argc
      475 			     then do;		/* next argument is the block size */
      476 				     call get_arg_ptr (i + 1);
      477 				     block = cv_oct_check_ (command_arg, code);
      478 				     if code = 0
      479 				     then i = i + 1;
      480 				     else call PRINT_ERROR (0, 4); /* block size is non-octal */
      481 				end;		/* next argument is the block size */
      482 			     else call PRINT_ERROR (error_table_$noarg, 7);    /* no argument given for the block size */
      483 			end;
      484 		     else if command_arg = "-name" | command_arg = "-nm"
      485 		     then do;
      486 			     if i < argc
      487 			     then do;		/* next argument is the segment name */
      488 				     call get_arg_ptr (i + 1);
      489 				     tca = tc;	/* remember name of segment */
      490 				     tpa = tp;	/* in seg_name        */
      491 				     have_name = "1"b;
      492 				     i = i + 1;
      493 				end;		/* next argument is the segment name */
      494 			     else call PRINT_ERROR (error_table_$noarg, 7);    /* no argument given with -name */
      495 			end;
      496 		     else if command_arg = "-entry_point" | command_arg = "-ep"
      497 		     then do;
      498 			     if i < argc
      499 			     then do;
      500 				     call get_arg_ptr (i + 1);
      501 				     have_entry_point = "1"b;
      502 				     entry_point_name = command_arg;
      503 				     i = i + 1;
      504 				end;
      505 			     else call PRINT_ERROR (error_table_$noarg, 13);
      506 			end;
      507 		     else if command_arg = "-as" then do;
      508 			     if i < argc
      509 			     then do;
      510 				     have_structure = "1"b;
      511 				     call get_arg_ptr (i + 1);
      512 				     structure_name = command_arg;
      513 				     i = i + 1;
      514 				end;
      515 			     else call PRINT_ERROR (error_table_$noarg, 20);
      516 			end;
      517 		     else if command_arg = "-in" then do;
      518 			     if i < argc
      519 			     then do;
      520 				     have_structure_path = "1"b;
      521 				     call get_arg_ptr (i + 1);
      522 				     structure_path = command_arg;
      523 				     i = i + 1;
      524 				end;
      525 			     else call PRINT_ERROR (error_table_$noarg, 21);
      526 			end;
      527 		     else do;
      528 			     if verify (command_arg, "-0123456789") = 0
      529 			     then goto NON_CONTROL_ARG;
      530 			     else call PRINT_ERROR (error_table_$badopt, 2);   /* bad control argument */
      531 			end;
      532 		end;				/* process control arguments */
      533 	     else do;				/* process non-control arguments */
      534 
      535 NON_CONTROL_ARG:
      536 		     if ^have_name
      537 		     then do;			/* segment name, number or virtual pointer is the first non-control argument */
      538 			segno = cv_oct_check_ (command_arg, code);
      539 			if code = 0
      540 			then do;			/* segment number given */
      541 			     if segno < 0 then call PRINT_ERROR (0, 17);
      542 			     have_name = "1"b;
      543 			     tca = tc;
      544 			     tpa = tp;
      545 			     seg_num = "1"b;
      546 			     if segno < hcscnt
      547 			     then do;		/* do check for a hc segment */
      548 				if rz_call
      549 				then hc_seg = "1"b;
      550 				else call PRINT_ERROR (0, 6);
      551 						/* rzd must be used to dump a hc segment */
      552 				end;		/* do check for hc segment */
      553 			     end;			/* segment number given */
      554 			else do;			/* pathname or SLT name given */
      555 			     have_name = "1"b;
      556 			     tca = tc;		/* remember the segment name */
      557 			     tpa = tp;		/* in seg_name         */
      558 			     end;			/* pathname or SLT name given */
      559 		          end;			/* segment name or number is the first non-control argument */
      560 		     else if ^have_first
      561 		     then do;			/* first word is the second non-control argument */
      562 			     first = cv_oct_check_ (command_arg, code);
      563 			     if code ^= 0
      564 			     then call PRINT_ERROR (0, 4); /* non-octal number for first */
      565 			     have_first = "1"b;
      566 			end;			/* first word is the second non-control argument */
      567 		     else if ^have_count
      568 		     then do;			/* count is the third non-control argument */
      569 			     count = cv_oct_check_ (command_arg, code);
      570 			     if code ^= 0
      571 			     then call PRINT_ERROR (0, 4); /* non-octal number for count */
      572 			     if count < 0 then call PRINT_ERROR (0, 17);
      573 			     have_count = "1"b;
      574 			end;			/* count is the third non-control argument */
      575 		     else call PRINT_ERROR (error_table_$too_many_args, 2); /* four non-control arguments is an error */
      576 		end;				/* process non-control arguments */
      577 	end;					/* do loop thru command arguments */
      578 
      579 /* Check for legal formats and finish setting variables */
      580 
      581           if have_structure then
      582 	   raw_data_fmt = (octal_fmt | hex8_fmt | hex9_fmt);
      583 
      584 	if ^raw_data_fmt & ^interpreted_data_fmt & ^have_structure
      585 	then call PRINT_ERROR (0, 10);		/* asked to do nothing */
      586 
      587 	if have_structure & active_func		/* structures not allowed in AF output.*/
      588 	then call PRINT_ERROR (0, 22);
      589 
      590 	if raw_data & interpreted_data_fmt & active_func
      591 	then call PRINT_ERROR (0, 11);		/* asked for both as an AF */
      592 
      593 	if rest & have_count
      594 	then call PRINT_ERROR (error_table_$inconsistent, 19);
      595 
      596           if raw_data_fmt & (^hex8_fmt & ^hex9_fmt & ^octal_fmt)
      597 	then octal_fmt = "1"b;			/* default raw data */
      598 
      599 	if interpreted_data_fmt & (^bit4_fmt & ^bcd_fmt & ^char_fmt & ^ebcdic8_fmt & ^ebcdic9_fmt)
      600 	then char_fmt = "1"b;			/* default interpreted data */
      601 
      602 	if ^have_name
      603 	then call PRINT_ERROR (error_table_$noarg, 5);	/* segment must be specified */
      604 	else do;					/* obtain information about specified segment */
      605 		if seg_num
      606 		then do;				/* segment was specified by number in segno */
      607 			p = baseptr (segno);
      608 			if segno < hcscnt
      609 			then do;			/* this is a hc segment number */
      610 				if rz_call
      611 				then do;		/* rzd ok with hc segments */
      612 					call ring0_get_$name (dirname, ename, p, code);
      613 					if code ^= 0 then call PRINT_ERROR (code, 1);
      614 					call set_max_from_SDW;
      615 					cur_length = max_length;
      616 				     end;		/* rzd ok with hc segments */
      617 				else call PRINT_ERROR (0, 6); /* ds cannot be used with hc segments */
      618 			     end;			/* this is a hc segment number */
      619 			else if segno = active_all_rings_data_$stack_base_segno
      620 			     then do;		/* special case stack_0 */
      621 				     dirname = "";
      622 				     ename = "stack_0";
      623 				     call set_max_from_SDW;
      624 				     cur_length = max_length;
      625 				end;
      626 			else do;			/* this is a user segment number */
      627 				call hcs_$fs_get_path_name (p, dirname, dir_len, ename, code);
      628 				if code ^= 0
      629 				then do;		/* bad number specified */
      630 					tp = tpa;
      631 					tc = tca;
      632 					call PRINT_ERROR (code, 2);
      633 				     end;		/* bad number specified */
      634 				if dirname = " "
      635 				then dirname = ">"; /* handle the root special case */
      636 				call set_curlng_and_rb;
      637 			     end;			/* this is a user segment number */
      638 		     end;				/* segment was specified by number in segno */
      639 		else do;				/* segment was specified by SLT or pathname in seg_name */
      640 			if rz_call
      641 			then do;			/* try SLT name first for rzd call */
      642 				call ring0_get_$segptr ("", seg_name, p, code);
      643 				if p ^= null
      644 				then do;		/* SLT name, get length from SDW */
      645 					segno = fixed (baseno (p), 18);
      646 					hc_seg = "1"b;
      647 					call set_max_from_SDW;
      648 					cur_length = max_length;
      649 					ename = seg_name;
      650 				     end;		/* SLT name, get length from SDW */
      651 				else call process_name;  /* must be a pathname or a virtual pointer */
      652 			     end;			/* try SLT name first for rzd call */
      653 			else call process_name;	/* must be a pathname or virtual pointer */
      654 		     end;				/* segment was specified by SLT or pathname in seg_name */
      655 	     end;					/* obtain information about the specified segment */
      656 	if have_entry_point
      657 	then do;
      658 		if hc_seg
      659 		then do;
      660 			call ring0_get_$definition (p, "", entry_point_name, entry_point_offset, entry_type, code);
      661 			if code ^= 0 then call PRINT_ERROR (code, 14);
      662 		     end;
      663 		else do;
      664 			call hcs_$status_minf (dirname, ename, 1, 0, bit_count, code);
      665 			if code ^= 0
      666 			then call PRINT_ERROR (code, 5);
      667 
      668 			on not_in_read_bracket
      669 			     call PRINT_ERROR (error_table_$lower_ring, 15);
      670 			call object_info_$brief (p, bit_count, addr (obj_info), code);
      671 			revert not_in_read_bracket;
      672 			if code ^= 0
      673 			then call PRINT_ERROR (code, 15);
      674 			call get_definition_ (obj_info.defp, "", entry_point_name, defn_ptr, code);
      675 			if code ^= 0 then call PRINT_ERROR (code, 15);
      676 			entry_point_offset = binary (defn_ptr -> definition.value, 18);
      677 		     end;
      678 		if ^have_count & ^have_structure
      679 		then do;				/* make it look like we did have a count of 1 word */
      680 		          if ^have_first
      681 			then do;
      682 			          first = 0;
      683 				have_first = "1"b;
      684 			     end;
      685 			count = 1;
      686 			have_count = "1"b;
      687 		     end;
      688 	     end;
      689 	if max_length = 0
      690 	then do;					/* set max_length if it has'nt been done already */
      691 		max_length = cur_length;		/* set highest dumped address to current length of */
      692 						/* segment as guarenteed to be highest used page. */
      693 	     end;					/* set max_length if it has'nt been done already */
      694 	if have_structure & ^have_first
      695 	then do;
      696 		first = 0;
      697 		have_first = "1"b;
      698 	     end;
      699 
      700 	if have_structure & ^have_count
      701 	then do;
      702 		count = cur_length - first;
      703 		have_count = "1"b;
      704 	     end;
      705 
      706 	if ^have_first
      707 	then do;					/* don't have first or count */
      708 		if ^arg_for_header_given
      709 		then header = "1"b;			/* include header when dumping the whole segment */
      710 		first = 0;
      711 		count = max_length;			/* default to seg length for command */
      712 		have_first = "1"b;
      713 	     end;					/* don't have first or count */
      714 	else if ^have_count
      715 	then do;					/* have first but don't have count */
      716 		if rest
      717 		then count = max_length;
      718 		else count = 1;
      719 		have_count = "1"b;
      720 	     end;					/* have first but don't have count */
      721 	first = first + entry_point_offset;
      722 	if first >= max_length
      723 	then call PRINT_ERROR (0, 9);			/* can't dump past the end of the segment */
      724 	else if first < 0
      725 	     then call PRINT_ERROR (0, 18);		/*   or before the beginning of the segment */
      726 	if first + count > max_length
      727 	then do;					/* only dump to max_length with no error indicated */
      728 		count = max_length - first;
      729 	     end;
      730 	if block = 0 | block > count
      731 	then block = count;				/* set words per block if it has'nt been done yet */
      732 
      733 	if binary (rb2) < get_ring_ ()
      734 	then do;					/* make a final access check */
      735 		if rz_call
      736 		then hc_seg = "1"b;
      737 		else call PRINT_ERROR (0, 6);		/* error for ds call */
      738 	     end;					/* make a final access check */
      739 
      740 /* Now print what we are told to */
      741 
      742 
      743 	if hc_seg
      744 	then do;					/* output for hc segment */
      745 		if count <= 64
      746 		then hcsp (1) = addr (buffer);
      747 		else do;				/* get a temp seg to copy the hc seg into */
      748 			call get_temp_segments_ (me (binary (rz_call)), hcsp, code);
      749 			if code ^= 0
      750 			then call PRINT_ERROR (code, 1);	/* no temp segments available */
      751 		     end;				/* get a temp seg to copy the hc seg into */
      752 		call ring_zero_peek_ (addrel (p, first), hcsp (1), count, code);
      753 		if code ^= 0
      754 		then call PRINT_ERROR (code, 1);	/* we failed */
      755 
      756 		if active_func
      757 		then call return_dump (hcsp (1), first, count, cur_length, rel_offset);
      758 		else call print_dump (hcsp (1), first, count, cur_length, block, rel_offset);
      759 
      760 	     end;					/* output for hc segment */
      761 
      762 	else do;					/* output for user segment */
      763 		if active_func
      764 		then call return_dump (addrel (p, first), first, count, cur_length, rel_offset);
      765 		else call print_dump (addrel (p, first), first, count, cur_length, block, rel_offset);
      766 						/* output for user segment */
      767 	     end;					/* output for user segment */
      768 
      769 	if active_func
      770 	then return_arg = requote_string_ (rtrim (return_arg));
      771  /* fixed TR number 20051: want returned string without strailing spaces. */
      772 CLEANUP:
      773 	call cleaner_upper;
      774 	return;
      775 
      776 PRINT_ERROR:					/* come here to print all com_err_ messages. */
      777      proc (code, com_err_fmt_index);
      778 
      779 dcl code fixed bin (35) parameter;
      780 dcl com_err_fmt_index fixed bin parameter;
      781 
      782 	if active_func
      783 	then entry_var = active_fnc_err_;
      784 	else entry_var = com_err_;
      785 	if com_err_fmt_index = 3 then do;
      786 		if code = error_table_$dirseg then do;
      787 			bit_count = 0;
      788 			call hcs_$status_minf (dirname, ename, 1, 0, bit_count, code);
      789 			if code = 0
      790 			then if bit_count ^= 0
      791 			     then code = error_table_$msf;
      792 			     else code = error_table_$dirseg;
      793 			else code = error_table_$dirseg; /* couldn't get status on it, leave alone */
      794 		     end;
      795 	     end;
      796 	if dirname = ">" then dirname = "";
      797 	call entry_var (code, me (binary (rz_call)), com_err_fmt (com_err_fmt_index),
      798 	     command_arg, dirname, ename, entry_point_name, first, max_length,
      799 	     structure_name, have_structure_path, structure_path);
      800 	goto CLEANUP;
      801 
      802 	end PRINT_ERROR;
      803 
      804 
      805 cleaner_upper:
      806      proc;
      807 
      808 	if initsw & (^hc_seg)
      809 	then call terminate_file_ (p, 0, TERM_FILE_TERM, code);
      810 	if hcsp (1) ^= null
      811 	then call release_temp_segments_ (me (binary (rz_call)), hcsp, code);
      812      end cleaner_upper;
      813 
      814 
      815 process_name:
      816      proc;
      817 
      818 /* Global variables used:
      819*   Input:   seg_name char(tca) based(tpa)
      820*	  hcscnt   fixed bin internal static
      821*   Output:  dirname char (168)
      822*	  ename   char (32)
      823*	  p       pointer
      824*	  segno   fixed bin (18)
      825*	  initsw   bit (1)
      826*	  hc_seg   bit (1)
      827**/
      828 
      829 	tc = tca;					/* initialize for error messages */
      830 	tp = tpa;
      831 
      832 	call expand_pathname_ (seg_name, dirname, ename, code);
      833 	if code = 0 then do;
      834 	     call initiate_file_ (dirname, ename, R_ACCESS, p, (0), code);
      835 	     if p ^= null then do;
      836 		initsw = "1"b;
      837 		segno = binary (baseno (p), 18);
      838 		call set_curlng_and_rb;
      839 		end;
      840 	     else goto TRY_SEGNAME_AS_VIRTUAL_POINTER;
      841 	     end;
      842 	else do;
      843 TRY_SEGNAME_AS_VIRTUAL_POINTER:
      844 	     if rz_call				/* try through phcs_ */
      845 	     then do;
      846 		on linkage_error
      847 		     call PRINT_ERROR (0, 2);		/* in case no access to gate */
      848 		
      849 		call phcs_$initiate (dirname, ename, "", 0, 0, p, code);
      850 		revert linkage_error;
      851 
      852 		if p = null
      853 		then do;				/* try it as a virtual pointer */
      854 		     p = cv_ptr_ (seg_name, code);
      855 		     if code ^= 0
      856 		     then call PRINT_ERROR (code, 2);
      857 		     end;
      858 
      859 		segno = binary (baseno (p), 18);
      860 		call set_max_from_SDW;
      861 		cur_length = max_length;
      862 		end;
      863 	     else do;
      864 		p = cv_ptr_ (seg_name, code);
      865 		if code ^= 0
      866 		then call PRINT_ERROR (code, 2);
      867 
      868 		call hcs_$fs_get_path_name (p, dirname, dir_len, ename, code);
      869 		if code ^= 0
      870 		then call PRINT_ERROR (code, 2);
      871 
      872 		segno = binary (baseno (p), 18);
      873 		call set_curlng_and_rb;
      874 		end;
      875 	     end;
      876 
      877 	if segno < hcscnt
      878 	then hc_seg = "1"b;				/* hardcore segment */
      879 
      880 	if have_first
      881 	then first = first + wordno (p);
      882 	else do;
      883 	     first = wordno (p);
      884 	     have_first = (first ^= 0);
      885 	     end;
      886 	p = ptr (p, 0);				/* point p to base of segment */
      887 	have_name, seg_num = "1"b;
      888 
      889 	return;
      890      end process_name;
      891 
      892 get_arg_ptr:
      893      proc (argno);
      894 
      895 /* This procedure MUST be quick internal */
      896 
      897 /* Uses as input
      898*
      899*   active_func bit (1)
      900**/
      901 
      902 /* Sets
      903*
      904*   tp    pointer (command_arg)
      905*   tc    fixed bin (command_arg)
      906*   code  fixed bin (35)
      907**/
      908 
      909 /* Entries */
      910 
      911 	dcl     cu_$af_arg_ptr	 entry (fixed bin, ptr, fixed bin, fixed bin (35));
      912 	dcl     cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin, fixed bin (35));
      913 
      914 /* Automatic */
      915 
      916 	dcl     argno		 fixed bin;
      917 
      918 	if active_func
      919 	then call cu_$af_arg_ptr (argno, tp, tc, code);
      920 	else call cu_$arg_ptr (argno, tp, tc, code);
      921 
      922      end get_arg_ptr;
      923 
      924 
      925 
      926 set_curlng_and_rb:
      927      proc;
      928 
      929 /* Uses as input
      930*
      931*   dirname    char (168)
      932*   ename        char (32)
      933*   max_length   fixed bin (19)
      934**/
      935 
      936 /* Sets and uses
      937*
      938*   code fixed bin (35)
      939**/
      940 
      941 /* Sets
      942*
      943*   rb2		 bit (6)
      944*   cur_length        fixed bin (19)
      945*   com_err_fmt_index fixed bin
      946**/
      947 
      948 /* Automatic */
      949 
  2     1      declare		/* Structure returned by hcs_$status_long */
  2     2 
  2     3 	1 branch_status aligned,				/* automatic: hcs_$status uses a pointer */
  2     4 
  2     5 	  2 type bit(2) unaligned,				/* type of entry: link, segment, dir */
  2     6 	  2 number_names bit(16) unaligned,			/* unused by directory_status_ */
  2     7 	  2 names_rel_pointer bit(18) unaligned,		/* unused by directory_status_ */
  2     8 	  2 date_time_modified bit(36) unaligned,		/* date time modified */
  2     9 	  2 date_time_used bit(36) unaligned,			/* date time entry used */
  2    10 	  2 mode bit(5) unaligned,				/* effective access of caller */
  2    11 	  2 raw_mode bit(5) unaligned,
  2    12 	  2 pad1 bit(8) unaligned,
  2    13 	  2 records bit(18) unaligned,			/* number of records in use */
  2    14 	  2 date_time_dumped bit(36) unaligned,			/* date time last dumped */
  2    15 	  2 date_time_entry_modified bit(36) unaligned,		/* date time entry modified */
  2    16 	  2 lvid bit(36) unaligned,				/* logical volume id */
  2    17 	  2 current_length bit(12) unaligned,			/* number of blocks currently allocated */
  2    18 	  2 bit_count bit(24) unaligned,			/* bit count of entry */
  2    19 	  2 pad3 bit(8) unaligned,
  2    20 	  2 copy_switch bit(1) unaligned,			/* the copy switch */
  2    21 	  2 tpd bit(1) unaligned,				/* transparent to paging device */
  2    22 	  2 mdir bit(1) unaligned,				/* master directory switch */
  2    23 	  2 damaged_switch bit (1) unaligned,			/* true if contents damaged */
  2    24 	  2 synchronized_switch bit (1) unaligned,		/* true if a DM synchronized file */
  2    25 	  2 pad4 bit(5) unaligned,
  2    26 	  2 ring_brackets (0:2) bit(6) unaligned,		/* branch ring brackets */
  2    27 	  2 unique_id bit(36) unaligned,			/* entry unique id */
  2    28 
  2    29 
  2    30 	     /* The types of each class of branch */
  2    31 	segment_type bit(2) aligned internal static initial ("01"b),
  2    32 	directory_type bit(2) aligned internal static initial ("10"b),
  2    33 	msf_type bit(2) aligned internal static initial ("10"b),	/* will eventually be different */
  2    34 	link_type bit(2) aligned internal static initial ("00"b);
  2    35 
  2    36 
      950 
      951 
      952 /* External Variables */
      953 
      954 	dcl     error_table_$root	 external;
      955 
      956 /* Entries */
      957 
      958 	dcl     hcs_$status_long	 entry (char (*), char (*), fixed bin, ptr, ptr, fixed bin (35));
      959 
      960 	call hcs_$status_long (dirname, ename, 1, addr (branch_status), (null), code);
      961 	if code = error_table_$root
      962 	then do;					/* set cur_length of root using SDW */
      963 		call set_max_from_SDW;		/* this is required because of a bug in hcs_$status_long */
      964 		cur_length = max_length;
      965 	     end;					/* set cur_length  of root using SDW */
      966 	else if code = error_table_$no_s_permission | code = 0
      967 						/* normal segment */
      968 	then do;
      969 		cur_length = fixed (branch_status.current_length, 12) * 1024;
      970 		if cur_length = 0
      971 		then cur_length = 1;
      972 		if type = directory_type
      973 		then rb2 = "0"b;			/* this is a dir so the rb given by status_ is a extended */
      974 		else rb2 = ring_brackets (1);		/* other segment so ok */
      975 
      976 /* ------------------------------------------------------------------------------------------------- */
      977 /* The following must be eliminated when hcs_$status_ returns the ring brackets                    */
      978 
      979 		if code = error_table_$no_s_permission
      980 		then do;
      981 			if rz_call
      982 			then rb2 = "0"b;		/* assume ring_zero_peek must be used for rzd call */
      983 			else do;			/* handle ds call */
      984 				if mode ^= "0"b
      985 				then rb2 = "111"b;	/* ds can look at it */
      986 				else rb2 = "0"b;	/* ds cannot look at it */
      987 			     end;			/* handle ds call */
      988 		     end;
      989 
      990 /* ------------------------------------------------------------------------------------------------- */
      991 	     end;					/* normal segment */
      992 	else call PRINT_ERROR (code, 3);		/* status failed for some reason */
      993 
      994      end set_curlng_and_rb;
      995 
      996 
      997 
      998 set_max_from_SDW:
      999      proc;
     1000 
     1001 /* Uses as input
     1002*
     1003*   segno fixed bin (18)
     1004**/
     1005 
     1006 /* Sets
     1007*
     1008*   code		 fixed bin (35)
     1009*   max_length	 fixed bin (19)
     1010*   com_err_fmt_index fixed bin
     1011**/
     1012 
     1013 	call ring_zero_peek_$get_max_length_ptr (baseptr (segno), max_length, code);
     1014 	if code ^= 0
     1015 	then call PRINT_ERROR (code, 1);		/* we failed */
     1016 
     1017 	return;
     1018 
     1019      end set_max_from_SDW;
     1020 
     1021 
     1022 print_header:
     1023      proc;
     1024 
     1025 /* Uses as input
     1026*
     1027*   header bit (1)
     1028*   segno  fixed bin (18)
     1029*   hcscnt fixed bin static
     1030*   dirname char (168)
     1031*   ename   char (32)
     1032*   p       pointer
     1033**/
     1034 
     1035 /* Sets and uses
     1036*
     1037*   code fixed bin (35)
     1038**/
     1039 
     1040 /* Automatic */
     1041 
     1042 	dcl     date_time		 char (24);
     1043 	dcl     name		 char (168);
     1044 	dcl     dlen		 fixed bin;
     1045 
     1046 /* Entries */
     1047 
     1048 	dcl     date_time_		 entry (fixed bin (71), char (*));
     1049 	dcl     ring0_get_$name	 entry (char (*), char (*), ptr, fixed bin (35));
     1050 
     1051 
     1052 	call date_time_ (clock (), date_time);
     1053 	if segno < hcscnt
     1054 	then do;					/* header for hc seg */
     1055 		call ring0_get_$name ("", name, p, code);
     1056 		dlen = index (name, " ") - 1;
     1057 		name = "HARDCORE SEG -- " || substr (name, 1, dlen);
     1058 	     end;					/* header for hc seg */
     1059 	else if segno = active_all_rings_data_$stack_base_segno
     1060 	     then do;				/* special case stack_0 */
     1061 		name = "stack_0";
     1062 	     end;
     1063 	else do;					/* header for user seg */
     1064 		dlen = index (dirname, " ") - 1;
     1065 		if dlen <= 1
     1066 		then dlen = 0;			/* to avoid >>foo */
     1067 		if ename = "" & dirname = ""
     1068 		then name = "";			/* in case couldn't find the path out */
     1069 		else name = substr (dirname, 1, dlen) || ">" || ename;
     1070 	     end;					/* header for user seg */
     1071 	call ioa_$rs ("^/^2-^a^-^a^/", output_line, output_line_len, name, date_time);
     1072 	if active_func
     1073 	then return_arg = return_arg || substr (output_line, 1, output_line_len);
     1074 	else call iox_$put_chars (iocbp, addr (output_line), output_line_len, code);
     1075 
     1076 /* If no header is printed, no white space will be inserted  before the dump starts */
     1077 
     1078      end print_header;
     1079 
     1080 
     1081 translate_line_to_dump:
     1082      proc (wds_in_line, line_ptr, translation);
     1083 
     1084 /* Formal Parameters */
     1085 
     1086 	dcl     wds_in_line		 fixed bin;
     1087 	dcl     line_ptr		 ptr;
     1088 	dcl     translation		 char (32) varying;
     1089 
     1090 /* Automatic, structures for accessing the input line and subrutine return args */
     1091 
     1092 	dcl     ascii_chars		 char (wds_in_line * 4) based (line_ptr);
     1093 	dcl     bcd_chars		 bit (wds_in_line * 36) based (line_ptr);
     1094 	dcl     ebcdic9_chars	 char (wds_in_line * 4) based (line_ptr);
     1095 	dcl     ebcdic8_chars	 bit (divide (wds_in_line * 9, 2, 17) * 36) based (line_ptr);
     1096 	dcl     fourbit_chars	 bit (wds_in_line * 36) based (line_ptr);
     1097 
     1098 	dcl     overlay_return	 char (32);	/* used to make this a quick block */
     1099 	dcl     bcd_return		 char (wds_in_line * 6) based (addr (overlay_return));
     1100 	dcl     ebcdic9_return	 char (wds_in_line * 4) based (addr (overlay_return));
     1101 	dcl     ebcdic8_return	 char (divide (wds_in_line * 9, 2, 17)) based (addr (overlay_return));
     1102 	dcl     comp_8_return	 char (wds_in_line * 8) based (addr (overlay_return));
     1103 
     1104 	dcl     i			 fixed bin;	/* character string index */
     1105 	dcl     temp_overlay	 char (32);	/* used to make this a quick block */
     1106 	dcl     temp_ascii		 char (length (ascii_chars)) based (addr (temp_overlay));
     1107 	dcl     temp_ebcdic9	 char (length (ebcdic9_chars)) based (addr (temp_overlay));
     1108 
     1109 /* Constants */
     1110 
     1111 	dcl     last_ascii		 char (1) aligned internal static options (constant) initial ("");
     1112 						/* last ascii char code */
     1113 	dcl     last_ebcdic		 char (1) aligned internal static options (constant) initial ("");
     1114 						/* last ebcdic char code */
     1115 
     1116 
     1117 /* Entries */
     1118 
     1119 	dcl     bcd_to_ascii_	 entry (bit (*), char (*));
     1120 	dcl     ebcdic_to_ascii_	 entry (char (*), char (*));
     1121 	dcl     comp_8_to_ascii_	 entry (bit (*), char (*));
     1122 	dcl     ebcdic8_to_ascii_	 entry (bit (*), char (*));
     1123 
     1124 	translation = "";
     1125 
     1126 	if char_fmt
     1127 	then do;
     1128 		temp_ascii = ascii_chars;
     1129 		do i = 1 to length (ascii_chars) by 1;	/* set illegal characters to 0 */
     1130 		     if substr (ascii_chars, i, 1) > last_ascii
     1131 		     then substr (temp_ascii, i, 1) = " ";
     1132 		end;				/* set illegal characters to 0 */
     1133 		translation = translate (temp_ascii, dots, nonprinting_chars);
     1134 	     end;
     1135 
     1136 	else if bcd_fmt
     1137 	then do;
     1138 		call bcd_to_ascii_ (bcd_chars, bcd_return);
     1139 		translation = bcd_return;
     1140 	     end;
     1141 
     1142 	else if ebcdic9_fmt
     1143 	then do;
     1144 		temp_ebcdic9 = ebcdic9_chars;
     1145 		do i = 1 to length (ebcdic9_chars) by 1;/* set illegal characters to 0 */
     1146 		     if substr (ebcdic9_chars, i, 1) > last_ebcdic
     1147 		     then substr (temp_ebcdic9, i, 1) = " ";
     1148 		end;				/* set illegal characters to 0 */
     1149 		call ebcdic_to_ascii_ (temp_ebcdic9, ebcdic9_return);
     1150 		translation = translate (ebcdic9_return, dots, nonprinting_chars);
     1151 	     end;
     1152 
     1153 	else if ebcdic8_fmt
     1154 	then do;
     1155 		call ebcdic8_to_ascii_ (ebcdic8_chars, ebcdic8_return);
     1156 		translation = translate (ebcdic8_return, dots, nonprinting_chars);
     1157 	     end;
     1158 
     1159 	else if bit4_fmt
     1160 	then do;
     1161 		call comp_8_to_ascii_ (fourbit_chars, comp_8_return);
     1162 		translation = comp_8_return;
     1163 	     end;
     1164 
     1165 
     1166      end translate_line_to_dump;
     1167 
     1168 
     1169 return_dump:
     1170      proc (seg_ptr, first, count, cur_length, rel_offset);
     1171 
     1172 /* Return the dump when used as an active function. The format of the returned
     1173*   ascii string is set such that if -ascii is used, then the ascii
     1174*   translation is returned, otherwise the returned string is the octal, hex,
     1175*   bcd or ebcdic form of the translation. */
     1176 
     1177 /* Formal parameters */
     1178 
     1179 	dcl     seg_ptr		 ptr;		/* to segment to dump */
     1180 	dcl     first		 fixed bin (18);	/* in words */
     1181 	dcl     count		 fixed bin (18);	/* in words */
     1182 	dcl     cur_length		 fixed bin (18);	/* in blocks of 1024 words */
     1183 	dcl     rel_offset		 fixed bin (18);	/* in words */
     1184 
     1185 /* Based */
     1186 
     1187 	dcl     seg_wds		 (0:262143) bit (36) based (seg_ptr);
     1188 	dcl     word_mask		 (1:1024) fixed bin (35) based (blockp);
     1189 
     1190 /* Automatic */
     1191 
     1192 	dcl     tailx		 fixed bin;
     1193 	dcl     block_addr		 fixed bin;
     1194 	dcl     block_lng		 fixed bin;
     1195 	dcl     last_block		 bit (1) aligned;
     1196 	dcl     wds_in_line		 fixed bin;
     1197 	dcl     blockp		 ptr;
     1198 
     1199 /* Static */
     1200 
     1201 	dcl     af_format		 (0:7) char (15) var options (constant) static
     1202 				 init ("^v(^.3b ^)", "^vs^a", "^v(^.4b ^)", "^vs^a", "^v(^a ^)", "^vs^a",
     1203 				 "", "^vs^a");
     1204 
     1205 	wds_in_line = 8;				/* dump 8 words at a time */
     1206 
     1207 	if interpreted_data_fmt
     1208 	then tailx = 1;
     1209 	else tailx = 0;
     1210 	if raw_data_fmt
     1211 	then if hex8_fmt
     1212 	     then tailx = tailx + 2;
     1213 	     else if hex9_fmt
     1214 	     then tailx = tailx + 4;
     1215 	     else if octal_fmt
     1216 	     then ;				/* default */
     1217 	     else ;
     1218 	else tailx = tailx + 6;
     1219 
     1220 	line_format = af_format (tailx);
     1221 
     1222 	block_lng = min (count, 1024);		/* process by 1024 (or count if seg is less than 1024 long) */
     1223 						/* words until last block */
     1224 	last_block = "0"b;
     1225 
     1226 	do block_addr = first to first + count - block_lng - 1 by block_lng;
     1227 	     call return_block;
     1228 	end;
     1229 
     1230 	last_block = "1"b;				/* now do the last block in the segment */
     1231 
     1232 	if ^have_count
     1233 	then do;
     1234 		blockp = addrel (seg_ptr, block_addr);
     1235 		do block_lng = first + count - block_addr to 1 by -1
     1236 		     while (blockp -> word_mask (block_lng) = 0); /* look for last non_zero word */
     1237 		end;
     1238 		if block_lng = 0 then return;		/* was all zeros */
     1239 	     end;
     1240 	else block_lng = first + count - block_addr;
     1241 
     1242 	call return_block;
     1243 
     1244 	return;
     1245 
     1246 
     1247 return_block:
     1248      proc;
     1249 
     1250 /* Automatic */
     1251 
     1252 	dcl     line_addr		 fixed bin;
     1253 	dcl     first_line		 bit (1) aligned;
     1254 
     1255 	first_line = "0"b;
     1256 	do line_addr = block_addr to block_addr + block_lng - wds_in_line - 1 by wds_in_line;
     1257 	     call return_line (wds_in_line, line_addr + wds_in_line - 1);
     1258 	end;
     1259 
     1260 /* Now handle the last line */
     1261 
     1262 	if last_block
     1263 	then call return_line (block_addr + block_lng - line_addr, block_addr + block_lng - 1);
     1264 	return;
     1265 
     1266 
     1267 return_line:
     1268      proc (wds_in_line, line_addr_limit);
     1269 
     1270 /* Formal parameters */
     1271 
     1272 	dcl     wds_in_line		 fixed bin parameter;
     1273 	dcl     line_addr_limit	 fixed bin (18) parameter;
     1274 
     1275 /* Automatic */
     1276 
     1277 	dcl     output_words	 (1:wds_in_line) bit (36) based (addr (line_to_dump));
     1278 	dcl     bits_to_dump	 bit (wds_in_line * 36) based (addr (line_to_dump));
     1279 	dcl     translation		 char (32) varying;
     1280 	dcl     hex9_line		 char (64);
     1281 	dcl     hex9_array		 (1:wds_in_line) char (8) based (addr (hex9_line));
     1282 	dcl     wrd_addr		 fixed bin (18);
     1283 	dcl     line_to_dump	 (1:8) bit (36);
     1284 
     1285 	do wrd_addr = line_addr to line_addr_limit by 1;
     1286 	     if wrd_addr <= cur_length - 1
     1287 	     then line_to_dump (wrd_addr - line_addr + 1) = seg_wds (wrd_addr - first);
     1288 	     else line_to_dump (wrd_addr - line_addr + 1) = (36)"0"b;
     1289 	end;
     1290 
     1291 	if interpreted_data_fmt
     1292 	then call translate_line_to_dump (wds_in_line, addr (line_to_dump), translation);
     1293 	if hex9_fmt
     1294 	then do;
     1295 		call translate_bytes_to_hex9_ (bits_to_dump, hex9_line);
     1296 		call ioa_$rsnnl (line_format, output_line, output_line_len, wds_in_line, hex9_array, translation);
     1297 	     end;
     1298 	else call ioa_$rsnnl (line_format, output_line, output_line_len, wds_in_line, output_words, translation);
     1299 
     1300 	return_arg = return_arg || substr (output_line, 1, output_line_len);
     1301 
     1302      end return_line;
     1303 
     1304      end return_block;
     1305 
     1306      end return_dump;
     1307 
     1308 
     1309 print_dump:
     1310      proc (seg_ptr, first, count, cur_length, block_lng, rel_offset);
     1311 
     1312 /* Note for future improvments that there is a complete symmetry between blocks and lines:
     1313*   duplicates must be found; the first duplicate must print a message and subsequent ones
     1314*   are suppressed; the last one must be handled separately and always printed.             */
     1315 
     1316 /* Formal  parameters */
     1317 
     1318 	dcl     seg_ptr		 ptr;
     1319 	dcl     first		 fixed bin (18);
     1320 	dcl     count		 fixed bin (18);
     1321 	dcl     cur_length		 fixed bin (18);
     1322 	dcl     block_lng		 fixed bin (18);
     1323 	dcl     rel_offset		 fixed bin (18);
     1324 
     1325 /* Based */
     1326 
     1327 	dcl     seg_wds		 (0:262143) bit (36) based (seg_ptr);
     1328 
     1329 /* Automatic */
     1330 
     1331 	dcl     block_addr		 fixed bin (18);
     1332 	dcl     dup_block		 bit (1);
     1333 	dcl     first_block		 bit (1);
     1334 	dcl     first_dup_block	 bit (1);
     1335 	dcl     hfx		 fixed bin;
     1336 	dcl     i			 fixed bin;
     1337 	dcl     (j, k)		 fixed bin (18);
     1338 	dcl     last_block		 bit (1);
     1339 	dcl     shfx		 fixed bin;
     1340 	dcl     length_of_digit_field	 fixed bin;
     1341 	dcl     number_of_digit_fields fixed bin;
     1342 	dcl     tailx		 fixed bin;
     1343 	dcl     wds_in_line		 fixed bin;
     1344 
     1345 /* Static */
     1346 
     1347 	dcl     short_format	 (0:3) char (8) static init ("^6w^s", "^s^6w", "^6w^s", "^6w ^6w");
     1348 	dcl     head_format		 (0:7) char (12) var static init ("^2s",
     1349 						/* ^addr, ^off, ^short */
     1350 				 "^2s",		/* ^addr, ^off, short */
     1351 				 "^s^6w^x",	/* ^addr, off, ^short */
     1352 				 "^s^2w^x",	/* ^addr, off, short */
     1353 				 "^6w^x^s",	/* addr, ^off, ^short */
     1354 				 "^2w^x^s",	/* addr, ^off, short */
     1355 				 "^6w^x^6w^x",	/* addr, off, ^short */
     1356 				 "^2w^x^s");	/* addr, off, short */
     1357 	dcl     tail_format		 (0:7) char (15) var options (constant) static
     1358 				 init ("^v(^.3b ^)", "^v(^.3b ^)^vx^a", "^v(^.4b ^)", "^v(^.4b ^)^vx^a", "^v(^a ^)",
     1359 				 "^v(^a ^)^vx^a", "", "^vs^s^a");
     1360 
     1361 	if header
     1362 	then call print_header;
     1363 
     1364 	if long_fmt
     1365 	then wds_in_line = 8;
     1366 	else wds_in_line = 4;
     1367 	shfx = binary (substr (dump_segment_format, 1, 2), 2);
     1368 	hfx = binary (substr (dump_segment_format, 1, 3), 3);
     1369 	if interpreted_data_fmt
     1370 	then tailx = 1;
     1371 	else tailx = 0;
     1372 	if raw_data_fmt
     1373 	then if hex8_fmt
     1374 	     then tailx = tailx + 2;
     1375 	     else if hex9_fmt
     1376 	     then tailx = tailx + 4;
     1377 	     else if octal_fmt
     1378 	     then ;				/* default */
     1379 	     else ;
     1380 	else tailx = tailx + 6;
     1381 
     1382 	line_format = head_format (hfx) || tail_format (tailx);
     1383 
     1384 /* Set the length of the field that is used for printing the octal or hex
     1385*   information according to what type of info we're displaying. */
     1386 
     1387 	if hex9_fmt
     1388 	then length_of_digit_field = 9;		/* hex9 data */
     1389 	else if hex8_fmt
     1390 	then length_of_digit_field = 10;		/* hex8 data */
     1391 	else length_of_digit_field = 13;		/* octal data */
     1392 
     1393 /* Set the number of digit fields on a COMPLETE output line so we can
     1394*   later calculate how many spaces to put on the last line if it is not
     1395*   filled. */
     1396 
     1397 	if long_fmt
     1398 	then number_of_digit_fields = 8;
     1399 	else number_of_digit_fields = 4;
     1400 
     1401 	first_block = "1"b;
     1402 	first_dup_block = "1"b;
     1403 	last_block = "0"b;
     1404 	dup_block = "0"b;
     1405 	do block_addr = first to first + count - block_lng - 1 by block_lng;
     1406 	     if first_block
     1407 	     then do;				/* always print the first block */
     1408 		     if have_structure then
     1409 		     call print_structure;
     1410 		     if raw_data_fmt | interpreted_data_fmt
     1411 		     then call print_block;
     1412 		     if active_func			/* blank line between blocks */
     1413 		     then return_arg = return_arg || NL;
     1414 		     else call ioa_$ioa_switch (iocbp, " ");
     1415 		     first_block = "0"b;
     1416 		end;				/* always print the first block */
     1417 	     else do;				/* test subsequent blocks for duplicates */
     1418 		     if block_addr - block_lng <= cur_length - 1
     1419 		     then do;			/* check for dup blocks */
     1420 			     dup_block = "1"b;
     1421 			     do i = 0 to block_lng - 1;
     1422 				j = block_addr - block_lng + i;
     1423 				k = block_addr + i;
     1424 				if j <= cur_length - 1
     1425 				then do;		/* don't exceed the current length of old block */
     1426 					if k <= cur_length - 1
     1427 					then do;	/* don't exceed the current length of new block */
     1428 						if seg_wds (k - first) ^= seg_wds (j - first)
     1429 						then dup_block = "0"b;
     1430 					     end; /* don't exceed the current length of new block */
     1431 					else do;	/* use 0 past current length of new block */
     1432 						if "0"b ^= seg_wds (j - first)
     1433 						then dup_block = "0"b;
     1434 					     end; /* use 0 past current length of new block */
     1435 				     end;		/* don't exceed the current length of old block */
     1436 				else ;
     1437 			     end;
     1438 			end;			/* check for dup blocks */
     1439 		     else dup_block = "1"b;		/* must be duplicates */
     1440 		     if dup_block & first_dup_block
     1441 		     then do;			/* print message for first dup block */
     1442 			     if active_func
     1443 			     then return_arg = return_arg || "duplicate blocks" || NL || NL;
     1444 			     else call ioa_$ioa_switch (iocbp, "duplicate blocks^/");
     1445 			     first_dup_block = "0"b;
     1446 			     if have_structure then
     1447 			     call print_structure;
     1448 			     if raw_data_fmt | interpreted_data_fmt
     1449 			     then call print_block;
     1450 			end;			/* print message for first dup block */
     1451 		     else do;			/* check further before printing */
     1452 			     if ^dup_block
     1453 			     then do;		/* not a dup block, print it */
     1454 				     if have_structure then
     1455 				     call print_structure;
     1456 				     if raw_data_fmt | interpreted_data_fmt
     1457 				     then call print_block;
     1458 				     if active_func /* blank line between blocks */
     1459 				     then return_arg = return_arg || NL;
     1460 				     else call ioa_$ioa_switch (iocbp, " ");
     1461 				     first_dup_block = "1"b;
     1462 				end;		/* not a dup block, print it */
     1463 			     else ;		/* null because we don't print dup blocks  */
     1464 			end;			/* check further before printing */
     1465 		end;				/* test subsequent blocks for duplicates */
     1466 	end;
     1467 
     1468 /* Now handle the last block */
     1469 
     1470 	last_block = "1"b;
     1471 	block_lng = first + count - block_addr;
     1472 	if have_structure then
     1473 	call print_structure;
     1474 	if raw_data_fmt | interpreted_data_fmt
     1475 	then call print_block;			/* always print the last block */
     1476 
     1477 
     1478 
     1479 print_block:
     1480      proc;
     1481 
     1482 
     1483 /* Automatic */
     1484 
     1485 	dcl     cur_line		 char (wds_in_line * 4) based (addrel (seg_ptr, line_addr - first));
     1486 						/* dcled char instead of bit since CMPC is faster than CMPB */
     1487 	dcl     dup_line		 bit (1);
     1488 	dcl     first_dup_line	 bit (1);
     1489 	dcl     first_line		 bit (1);
     1490 	dcl     line_addr		 fixed bin (18);
     1491 	dcl     offset_addr		 fixed bin (18);
     1492 	dcl     prev_addr		 fixed bin (18);	/* for use by print_line */
     1493 	dcl     prev_line		 char (wds_in_line * 4) based (addrel (seg_ptr, prev_line_addr - first));
     1494 						/* dcled char instead of bit since CMPC is faster than CMPB */
     1495 	dcl     prev_line_addr	 fixed bin (18);
     1496 	dcl     i			 fixed bin;
     1497 	dcl     (j, k)		 fixed bin (18);
     1498 
     1499 	first_line = "1"b;
     1500 	first_dup_line = "1"b;
     1501 	offset_addr = rel_offset;
     1502 	prev_addr = block_addr;
     1503 	prev_line_addr = block_addr;
     1504 	do line_addr = block_addr to block_addr + block_lng - wds_in_line - 1 by wds_in_line;
     1505 	     if first_line
     1506 	     then do;				/* handle first line differently */
     1507 		     if last_block | ^dup_block
     1508 		     then do;			/* print first line unless a dup block */
     1509 			     call print_line (wds_in_line, line_addr + wds_in_line - 1);
     1510 			     first_line = "0"b;
     1511 			end;			/* print first line unless a dup block */
     1512 		end;				/* handle first line differently */
     1513 	     else do;				/* handle subsequent lines */
     1514 		     if line_addr - wds_in_line <= cur_length - 1
     1515 		     then do;			/* check for dup lines */
     1516 			     dup_line = "1"b;
     1517 			     if line_addr + wds_in_line <= cur_length - 1
     1518 			     then do;		/* everything less than cur_length */
     1519 				     if prev_line_addr ^= line_addr
     1520 				     then do;
     1521 					     if prev_line = cur_line
     1522 					     then dup_line = "1"b;
     1523 					     else dup_line = "0"b;
     1524 					end;
     1525 				end;		/* everything less than cur_length */
     1526 			     else do;		/* cross over cur_length */
     1527 				     do i = 0 to wds_in_line - 1;
     1528 					j = line_addr - wds_in_line + i;
     1529 					k = line_addr + i;
     1530 					if j <= cur_length - 1 & k <= cur_length - 1
     1531 					then do;
     1532 						if seg_wds (j - first) ^= seg_wds (k - first)
     1533 						then dup_line = "0"b;
     1534 					     end;
     1535 					else if j <= cur_length - 1
     1536 					then do;
     1537 						if seg_wds (j - first) ^= "0"b
     1538 						then dup_line = "0"b;
     1539 					     end;
     1540 					else ;	/* both words must be 0 so equal */
     1541 				     end;
     1542 				end;		/* cross over cur_length */
     1543 			end;			/* check for dup lines */
     1544 		     else dup_line = "1"b;		/* must be duplicates */
     1545 		     if dup_line & first_dup_line & suppress_dup_fmt
     1546 		     then do;			/* print message for first dup line */
     1547 			     if active_func
     1548 			     then return_arg = return_arg || "======" || NL;
     1549 			     else call ioa_$ioa_switch (iocbp, "======");
     1550 			     first_dup_line = "0"b;
     1551 			end;			/* print message for first dup line */
     1552 		     else if ^dup_line | ^suppress_dup_fmt
     1553 		     then do;			/* print this line */
     1554 			     call print_line (wds_in_line, line_addr + wds_in_line - 1);
     1555 			     first_dup_line = "1"b;
     1556 			end;			/* print this line */
     1557 		     else ;			/* null because we don't print dup lines */
     1558 		end;				/* handle subsequent lines */
     1559 	     offset_addr = offset_addr + wds_in_line;	/* keep offset_addr up with line_addr */
     1560 	     prev_line_addr = line_addr;
     1561 	end;
     1562 
     1563 /* Now handle the last line */
     1564 
     1565 	if last_block | ^dup_block
     1566 	then call print_line (block_addr + block_lng - line_addr, block_addr + block_lng - 1);
     1567 	return;
     1568 
     1569 
     1570 print_line:
     1571      proc (wds_in_line, line_addr_limit);
     1572 
     1573 /* Formal parameters */
     1574 
     1575 	dcl     wds_in_line		 fixed bin;
     1576 	dcl     line_addr_limit	 fixed bin (18);
     1577 
     1578 /* Automatic */
     1579 
     1580 	dcl     addr_col		 fixed bin (18);
     1581 	dcl     line_to_dump	 (1:8) bit (36);
     1582 	dcl     offset_col		 fixed bin (18);
     1583 	dcl     wrd_addr		 fixed bin (18);
     1584 	dcl     output_words	 (1:wds_in_line) bit (36) based (addr (line_to_dump));
     1585 	dcl     bits_to_dump	 bit (wds_in_line * 36) based (addr (line_to_dump));
     1586 	dcl     translation		 char (32) varying;
     1587 	dcl     hex9_line		 char (64);
     1588 	dcl     hex9_array		 (1:wds_in_line) char (8) based (addr (hex9_line));
     1589 
     1590 	addr_col = line_addr;
     1591 	offset_col = offset_addr;
     1592 	do wrd_addr = line_addr to line_addr_limit by 1;
     1593 	     if wrd_addr <= cur_length - 1
     1594 	     then line_to_dump (wrd_addr - line_addr + 1) = seg_wds (wrd_addr - first);
     1595 	     else line_to_dump (wrd_addr - line_addr + 1) = (36)"0"b;
     1596 	end;
     1597 	if short_fmt
     1598 	then do;					/* print out addresses if short format */
     1599 		addr_col = mod (line_addr, 64);
     1600 		offset_col = mod (offset_addr, 64);
     1601 		if line_addr >= prev_addr + (64 - mod (prev_addr, 64)) | line_addr = prev_addr
     1602 		then do;
     1603 			call ioa_$rs (short_format (shfx), output_line, output_line_len, line_addr, offset_addr);
     1604 			if active_func
     1605 			then return_arg = return_arg || substr (output_line, 1, output_line_len);
     1606 			else call iox_$put_chars (iocbp, addr (output_line), output_line_len, code);
     1607 		     end;
     1608 		prev_addr = line_addr;
     1609 	     end;					/* print out addresses if short format */
     1610 	if interpreted_data_fmt
     1611 	then call translate_line_to_dump (wds_in_line, addr (line_to_dump), translation);
     1612 	if hex9_fmt
     1613 	then do;					/* translate words to dump into hex9 format */
     1614 		call translate_bytes_to_hex9_ (bits_to_dump, hex9_line);
     1615 		call ioa_$rs (line_format, output_line, output_line_len, addr_col, offset_col, wds_in_line, hex9_array,
     1616 		     (number_of_digit_fields - wds_in_line) * length_of_digit_field, translation);
     1617 		if active_func
     1618 		then return_arg = return_arg || substr (output_line, 1, output_line_len);
     1619 		else call iox_$put_chars (iocbp, addr (output_line), output_line_len, code);
     1620 	     end;					/* translate words to dump into hex9 format */
     1621 	else do;
     1622 		call ioa_$rs (line_format, output_line, output_line_len, addr_col, offset_col, wds_in_line, output_words,
     1623 		     (number_of_digit_fields - wds_in_line) * length_of_digit_field, translation);
     1624 		if active_func
     1625 		then return_arg = return_arg || substr (output_line, 1, output_line_len);
     1626 		else call iox_$put_chars (iocbp, addr (output_line), output_line_len, code);
     1627 	     end;
     1628 
     1629      end print_line;
     1630 
     1631      end print_block;
     1632 
     1633 print_structure:
     1634     proc();
     1635 
     1636 	dcl     code	           fixed bin(35);
     1637 	dcl     full_name		 char(256);
     1638 	dcl     match_names		 (10) char (32) varying;
     1639 	dcl     n_match_names	 fixed bin;
     1640 	dcl     n_subscripts	 fixed bin;
     1641 	dcl     structure_ptr	 ptr;
     1642 	dcl     subscripts		 (2, 16) fixed bin(24);
     1643 	dcl     symbol_ptr		 ptr;
     1644 	dcl     unsubscripted_name	 char (256);
     1645 
     1646     if address_fmt then
     1647        call ioa_$ioa_switch (iocbp, "^6w", block_addr);
     1648     structure_ptr = addr(seg_wds(block_addr-first));
     1649     call structure_ref_$parse ((structure_name), full_name, unsubscripted_name,
     1650          subscripts, n_subscripts, match_names, n_match_names, code);
     1651     if code ^= 0 then call PRINT_ERROR (code, 23);
     1652     if have_structure_path
     1653     then call structure_find_$pathname (structure_path, unsubscripted_name,
     1654          symbol_ptr, code);
     1655     else call structure_find_$search (unsubscripted_name, symbol_ptr, code);
     1656     if code ^= 0 then call PRINT_ERROR (code, 24);
     1657     call display_data_$for_azm (iocbp, ^long_fmt, match_names, n_match_names,
     1658          null, structure_ptr, cur_length, structure_ptr, symbol_ptr,
     1659          subscripts, n_subscripts, code);
     1660     if code ^= 0 then call PRINT_ERROR (code, 25);
     1661     end print_structure;
     1662 
     1663     end print_dump;
     1664 
     1665 
     1666 
     1667 
     1668 
     1669 /* Parameters */
     1670 
     1671 	dcl     a_old_format	 bit (6);
     1672 
     1673 dump_seg_:
     1674      entry (a_iocbp, a_ptr, a_first, a_count, a_old_format);
     1675 
     1676 	if first_time
     1677 	then do;
     1678 		nonprinting_chars = substr (collate (), 1, 32) || substr (collate (), 128, 1);
     1679 		first_time = "0"b;
     1680 	     end;
     1681 
     1682 	active_func, have_structure, have_structure_path = "0"b;
     1683 	iocbp = a_iocbp;
     1684 	unspec (dump_segment_format) = ""b;
     1685 	dump_segment_format = a_old_format;
     1686 	first = a_first;
     1687 	count = a_count;
     1688 	cur_length = first + count;
     1689 	block = count;
     1690 	rel_offset = 0;
     1691 	if (short_fmt & long_fmt) | (bcd_fmt & char_fmt)
     1692 	then do;
     1693 		string (dump_segment_format) = ""b;
     1694 		address_fmt = "1"b;
     1695 	     end;					/* set format to default */
     1696 	else if bcd_fmt | char_fmt
     1697 	then interpreted_data_fmt = "1"b;
     1698 
     1699 	raw_data_fmt, octal_fmt = "1"b;
     1700 	command_output_fmt = "0"b;
     1701 
     1702 	call print_dump (a_ptr, first, count, cur_length, block, rel_offset);
     1703 	return;
     1704 
     1705 
     1706 
     1707 /* The following entry can be called by programs that want output in the same
     1708*   format as dump_segment. The arguments are:
     1709*
     1710*   a_iocbp	a pointer to the I/O switch to use
     1711*   a_ptr		a pointer to the first word of data to dump
     1712*   a_blk_size	output dump in blocks of this number of words
     1713*   a_first	the offset of the first word to dump
     1714*   a_count	the number of words to dump
     1715*   a_format	a format control string (bit string) indicating the output mode
     1716*
     1717**/
     1718 
     1719 /* Parameters */
     1720 
     1721 	dcl     a_count		 fixed bin (18);
     1722 	dcl     a_first		 fixed bin (18);
     1723 	dcl     a_blk_size		 fixed bin;
     1724 	dcl     a_format		 bit (*);
     1725 	dcl     a_iocbp		 ptr;
     1726 	dcl     a_ptr		 ptr;
     1727 	dcl     MR10_FORMAT_LENGTH	 fixed bin int static options (constant) init (11);
     1728 
     1729 dump_segment_:
     1730      entry (a_iocbp, a_ptr, a_blk_size, a_first, a_count, a_format);
     1731 
     1732 	if first_time
     1733 	then do;
     1734 		nonprinting_chars = substr (collate (), 1, 32) || substr (collate (), 128, 1);
     1735 		first_time = "0"b;
     1736 	     end;
     1737 
     1738 	active_func, have_structure, have_structure_path = "0"b;
     1739 	iocbp = a_iocbp;
     1740 	unspec (dump_segment_format) = ""b;
     1741 	dump_segment_format = a_format;
     1742 	first = fixed (rel (a_ptr), 18, 0);
     1743 	count = a_count;
     1744 	if count <= 0
     1745 	then count = 1;
     1746 	cur_length = first + count;
     1747 	if a_blk_size <= 0
     1748 	then block = count;
     1749 	else block = min (a_blk_size, count);
     1750 	rel_offset = a_first;
     1751 	if (short_fmt & long_fmt) | (hex8_fmt & hex9_fmt)
     1752 	     | ((binary (bcd_fmt) + binary (char_fmt) + binary (ebcdic9_fmt) + binary (ebcdic8_fmt) + binary (bit4_fmt))
     1753 	     >= 2)
     1754 	then do;
     1755 		string (dump_segment_format) = ""b;
     1756 		address_fmt = "1"b;
     1757 	     end;					/* set format to default */
     1758 
     1759 	if length (a_format) <= MR10_FORMAT_LENGTH
     1760 	then do;
     1761 		raw_data_fmt, suppress_dup_fmt = "1"b;
     1762 		if bcd_fmt | char_fmt | ebcdic9_fmt | ebcdic8_fmt | bit4_fmt
     1763 		then interpreted_data_fmt = "1"b;
     1764 		if ^hex8_fmt & ^hex9_fmt
     1765 		then octal_fmt = "1"b;
     1766 		header, command_output_fmt = "0"b;
     1767 	     end;
     1768 
     1769 	call hcs_$fs_get_path_name (a_ptr, dirname, dir_len, ename, code);
     1770 	if code ^= 0
     1771 	then do;		/* bad number specified */
     1772 	     dirname = "";
     1773 	     ename = "";
     1774 	     end;
     1775 
     1776 	call print_dump (a_ptr, first, count, cur_length, block, rel_offset);
     1777 	return;
     1778 
     1779 
     1780 
     1781 /* The following entry can be called by programs that want output returned
     1782*   in the same format as dump_segment when used as an active function. The
     1783*   arguments are:
     1784*
     1785*   a_string_ptr	a pointer to a varying char string
     1786*   a_string_length  maximum length of the char string
     1787*   a_ptr		a pointer to the first word of data to dump
     1788*   a_blk_size	output dump in blocks of this number of words
     1789*   a_first	the offset of the first word to dump
     1790*   a_count	the number of words to dump
     1791*   a_format	a format control string (bit string) indicating the output mode
     1792*
     1793**/
     1794 
     1795 /* Parameters */
     1796 
     1797 	dcl     a_string_ptr	 ptr;
     1798 	dcl     a_string_length	 fixed bin (21);
     1799 
     1800 dump_segment_$string:
     1801      entry (a_string_ptr, a_string_length, a_ptr, a_blk_size, a_first, a_count, a_format);
     1802 
     1803 	if first_time
     1804 	then do;
     1805 		nonprinting_chars = substr (collate (), 1, 32) || substr (collate (), 128, 1);
     1806 		first_time = "0"b;
     1807 	     end;
     1808 
     1809 	active_func = "1"b;
     1810 	ret_tc = a_string_length;
     1811 	ret_tp = a_string_ptr;
     1812 	if ret_tc <= 0 | ret_tp = null
     1813 	then return;
     1814 	return_arg = "";
     1815 	dump_segment_format = a_format;
     1816 	first = fixed (rel (a_ptr), 18, 0);
     1817 	count = a_count;
     1818 	if count <= 0
     1819 	then count = 1;
     1820 	cur_length = first + count;
     1821 	if a_blk_size <= 0
     1822 	then block = count;
     1823 	else block = min (a_blk_size, count);
     1824 	rel_offset = a_first;
     1825 	if short_fmt & long_fmt | hex8_fmt & hex9_fmt
     1826 	     | (binary (bcd_fmt) + binary (char_fmt) + binary (ebcdic9_fmt) + binary (ebcdic8_fmt) + binary (bit4_fmt))
     1827 	     >= 2
     1828 	then do;
     1829 		string (dump_segment_format) = ""b;
     1830 		address_fmt = "1"b;
     1831 	     end;					/* set format to default */
     1832 
     1833 	call hcs_$fs_get_path_name (a_ptr, dirname, dir_len, ename, code);
     1834 	if code ^= 0
     1835 	then do;		/* bad number specified */
     1836 	     dirname = "";
     1837 	     ename = "";
     1838 	     end;
     1839 
     1840 	if command_output_fmt
     1841 	then call print_dump (a_ptr, first, count, cur_length, block, rel_offset);
     1842 	else call return_dump (a_ptr, first, count, cur_length, rel_offset);
     1843 
     1844 	return_arg = requote_string_ ((return_arg));
     1845 
     1846 	return;
     1847 
     1848 /* This subroutine is really cv_ptr_, but we have to modify it to work on
     1849*   inner ring segments because cv_ptr_ doesn't do that. When it does, then
     1850*   we can remove this routine and call cv_ptr_ instead. */
     1851 
     1852 cv_ptr_:	procedure (string, Acode)
     1853 	returns 	(ptr);
     1854 
     1855      dcl						/*	Parameters			*/
     1856      	string			char (*),		/* virtual pointer character string. (In)	*/
     1857 	Acode			fixed bin(35);	/* status code. (Out)			*/
     1858 
     1859      dcl						/*	Automatic Variables			*/
     1860          (Lbit_offset, Lsegment_id, Lword_offset)
     1861 				fixed bin,	/* length of various parts of virtual pointer.	*/
     1862          (Pbit_offset, Psegment_id, Pword_offset, Pdelim)
     1863 				ptr,		/* pointer to various parts of virtual pointer.	*/
     1864 	P			ptr,		/* returned pointer.			*/
     1865 	Pdef			ptr,		/* pointer to entry point definition structure.	*/
     1866 
     1867 	bc			fixed bin(24),	/* bit count of target segment.		*/
     1868          (bit, segno, word)		fixed bin(35),	/* numeric parts of virtual pointer.		*/
     1869 	code			fixed bin(35),
     1870 	dir			char(168),	/* dir part of segment's pathname.		*/
     1871 	ent			char(32),		/* entry part of segment's pathname.		*/
     1872 	entry_point_offset		fixed bin (18),
     1873 	i			fixed bin,
     1874 	id_case			fixed bin,	/* type of segment identifier in virtual pointer.	*/
     1875 						/*   1 = PATHNAME, 2 = REF_NAME, 3 = SEGNO.	*/
     1876 	inner_ring_segment		bit (1) aligned,	/* determines whether we can terminate the segment in the user ring */
     1877 	offset_case		fixed bin,	/* type of offset value in virtual pointer.	*/
     1878 						/*   5 = MISSING, 6 = WORD, 7 = WORD_AND_BIT,	*/
     1879 						/*   8 = ENTRY_PT.				*/
     1880 	1 oi			aligned like object_info,
     1881 	segp			ptr;
     1882 
     1883      dcl						/*	Based Variables			*/
     1884      	bit_offset		char(Lbit_offset) based (Pbit_offset),
     1885 	bit_offset_array (Lbit_offset) char(1) based(Pbit_offset),
     1886      	bits (36)			bit(1) unaligned based,
     1887 	delim			char(1) based (Pdelim),
     1888 	segment_id		char(Lsegment_id) based (Psegment_id),
     1889 	string_array (length(string))	char(1) based (addr (string)),
     1890 	word_offset		char(Lword_offset) based (Pword_offset),
     1891 	word_offset_array (Lword_offset)
     1892 				char(1) based (Pword_offset);
     1893  
     1894      dcl						/*	Entries				*/
     1895 	cv_dec_check_		entry (char(*), fixed bin(35)) returns (fixed bin(35)),
     1896 	cv_oct_check_		entry (char(*), fixed bin(35)) returns (fixed bin(35)),
     1897 	expand_pathname_		entry (char(*), char(*), char(*), fixed bin(35)),
     1898 	get_definition_		entry (ptr, char(*), char(*), ptr, fixed bin(35)),
     1899 	hcs_$fs_get_path_name	entry (ptr, char(*), fixed bin, char(*), fixed bin(35)),
     1900 	hcs_$fs_get_seg_ptr		entry (char(*), ptr, fixed bin(35)),
     1901 	hcs_$initiate_count		entry (char(*), char(*), char(*), fixed bin(24),
     1902 				       fixed bin(2), ptr, fixed bin(35)),
     1903 	hcs_$terminate_noname	entry (ptr, fixed bin(35)),
     1904 	object_info_$brief		entry (ptr, fixed bin(24), ptr, fixed bin(35));
     1905 
     1906      dcl  length			builtin;
     1907 
     1908      dcl						/*	Static Variables and Constants	*/
     1909          (PATHNAME			init(1),		/* acceptable values which id_case may take on.	*/
     1910 	REF_NAME			init(2),
     1911 	SEGNO			init(3),
     1912 	MISSING			init(5),		/* acceptable values offset_case may take on.	*/
     1913 	WORD			init(6),
     1914 	WORD_AND_BIT		init(7),
     1915 	ENTRY_PT			init(8)) fixed bin int static options(constant),
     1916          (TEXT			init ("000"b),	/* values which definition.class may take on.	*/
     1917 	LINKAGE			init ("001"b),
     1918 	SYMBOL			init ("010"b),
     1919 	STATIC			init ("100"b)) bit(3) int static options(constant),
     1920 	V_BAR			char(1) int static options(constant) init("|"),
     1921          (error_table_$bad_class_def,
     1922 	error_table_$bad_conversion,
     1923 	error_table_$bigarg,
     1924 	error_table_$entlong,
     1925 	error_table_$lower_ring,
     1926           error_table_$improper_data_format,
     1927 	error_table_$out_of_bounds)	fixed bin(35) ext static,
     1928 	sys_info$max_seg_size	fixed bin(35) ext static;
     1929 
     1930 
  3     1 /* BEGIN INCLUDE FILE definition.incl.pl1 */
  3     2 
  3     3 
  3     4 
  3     5 /****^  HISTORY COMMENTS:
  3     6*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  3     7*     audit(86-07-18,DGHowe), install(86-11-20,MR12.0-1222):
  3     8*     Modified to add indirect bit to definition flags.
  3     9*                                                   END HISTORY COMMENTS */
  3    10 
  3    11 
  3    12 dcl	1 definition	aligned based,
  3    13 	2 forward		unal bit(18),	/* offset of next def */
  3    14 	2 backward	unal bit(18),	/* offset of previous def */
  3    15 	2 value		unal bit(18),
  3    16 	2 flags		unal,
  3    17 	  3 new		bit(1),
  3    18 	  3 ignore	bit(1),
  3    19 	  3 entry		bit(1),
  3    20 	  3 retain	bit(1),
  3    21 	  3 argcount	bit(1),
  3    22 	  3 descriptors	bit(1),
  3    23 	  3 indirect	bit(1),
  3    24 	  3 unused	bit(8),
  3    25 	2 class		unal bit(3),
  3    26 	2 symbol		unal bit(18),	/* offset of ACC for symbol */
  3    27 	2 segname		unal bit(18);	/* offset of segname def */
  3    28 
  3    29 /* END INCLUDE FILE definition.incl.pl1 */
     1931 
     1932 
  4     1 /* BEGIN INCLUDE FILE ... object_info.incl.pl1
  4     2*coded February 8, 1972 by Michael J. Spier	*/
  4     3 /* modified May 26, 1972 by M. Weaver */
  4     4 /* modified 15 April, 1975 by M. Weaver */
  4     5 
  4     6 declare	1 object_info aligned based,		/* structure containing object info based, returned by object_info_ */
  4     7 	2 version_number fixed bin,		/* version number of current structure format (=2) */
  4     8 	2 textp pointer,			/* pointer to beginning of text section */
  4     9 	2 defp pointer,			/* pointer to beginning of definition section */
  4    10 	2 linkp pointer,			/* pointer to beginning of linkage section */
  4    11 	2 statp pointer,			/* pointer to beginning of static section */
  4    12 	2 symbp pointer,			/* pointer to beginning of symbol section */
  4    13 	2 bmapp pointer,			/* pointer to beginning of break map (may be null) */
  4    14 	2 tlng fixed bin,			/* length in words of text section */
  4    15 	2 dlng fixed bin,			/* length in words of definition section */
  4    16 	2 llng fixed bin,			/* length in words of linkage section */
  4    17 	2 ilng fixed bin,			/* length in words of static section */
  4    18 	2 slng fixed bin,			/* length in words of symbol section */
  4    19 	2 blng fixed bin,			/* length in words of break map */
  4    20 	2 format,				/* word containing bit flags about object type */
  4    21 	  3 old_format bit(1) unaligned,	/* on if segment isn't in new format, i.e. has old style object map */
  4    22 	  3 bound bit(1) unaligned,		/* on if segment is bound */
  4    23 	  3 relocatable bit(1) unaligned,	/* on if seg has relocation info in its first symbol block */
  4    24 	  3 procedure bit(1) unaligned,	/* on if segment is an executable object program */
  4    25 	  3 standard bit(1) unaligned,	/* on if seg is in standard format (more than just standard map) */
  4    26 	  3 gate bit(1) unaligned,		/* on if segment is a gate */
  4    27 	  3 separate_static bit(1) unaligned,	/* on if static not in linkage */
  4    28 	  3 links_in_text bit(1) unaligned,	/* on if there are threaded links in text */
  4    29 	  3 perprocess_static bit (1) unaligned, /* on if static is not to be per run unit */
  4    30 	  3 pad bit(27) unaligned,
  4    31 	2 entry_bound fixed bin,		/* entry bound if segment is a gate */
  4    32 	2 textlinkp pointer,		/* ptr to first link in text */
  4    33 
  4    34 	/* LIMIT OF BRIEF STRUCTURE */
  4    35 
  4    36 	2 compiler char(8) aligned,		/* name of processor which generated segment */
  4    37 	2 compile_time fixed bin(71),		/* clock reading of date/time object was generated */
  4    38 	2 userid char(32) aligned,		/* standard Multics id of creator of object segment */
  4    39 	2 cvers aligned,			/* generator version name in printable char string form */
  4    40 	  3 offset bit(18) unaligned,		/* offset of name in words relative to base of symbol section */
  4    41 	  3 length bit(18) unaligned,		/* length of name in characters */
  4    42 	2 comment aligned,			/* printable comment concerning generator or generation of segment */
  4    43 	  3 offset bit(18) unaligned,		/* offset of comment in words relative to base of symbol section */
  4    44 	  3 length bit(18) unaligned,		/* length of comment in characters */
  4    45 	2 source_map fixed bin,		/* offset, relative to base of symbol section, of source map structure */
  4    46 
  4    47 	/* LIMIT OF DISPLAY STRUCTURE */
  4    48 
  4    49 	2 rel_text pointer,			/* pointer to text section relocation info */
  4    50 	2 rel_def pointer,			/* pointer to definition section relocation info */
  4    51 	2 rel_link pointer,			/* pointer to linkage section relocation info */
  4    52 	2 rel_static pointer,		/* pointer to static section relocation info */
  4    53 	2 rel_symbol pointer,		/* pointer to symbol section relocation info */
  4    54 	2 text_boundary fixed bin,		/* specifies mod  of text section base boundary */
  4    55 	2 static_boundary fixed bin,		/* specifies mod of internal static base boundary */
  4    56 					/* currently not used by system */
  4    57 	2 default_truncate fixed bin,		/* offset rel to symbp for binder to automatically trunc. symb sect. */
  4    58 	2 optional_truncate fixed bin;	/* offset rel to symbp for binder to optionally trunc. symb sect. */
  4    59 
  4    60 declare	object_info_version_2 fixed bin int static init(2);
  4    61 
  4    62 /* END INCLUDE FILE ... object_info.incl.pl1 */
     1933 
     1934 
     1935 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1936 
     1937 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1938 	/*									*/
     1939 	/* Acceptable virtual pointer strings have the following forms:			*/
     1940 	/*									*/
     1941 	/* CASES									*/
     1942 	/*  I O	FORM			COMMENT					*/
     1943 	/* -----	-----------------------	------------------------------------------	*/
     1944 	/*  1 5	path			= path|0(0)				*/
     1945 	/*  1 5	path|			= path|0(0)				*/
     1946 	/*  1 6	path|W			= path|W(0)				*/
     1947 	/*  1 7	path|W(B)			octal word W, decimal bit B of path		*/
     1948 	/*  1 8	path|entry_pt		word identified by entry point entry_pt in path	*/
     1949 	/*  1 8	path$entry_pt		word identified by entry point entry_pt in seg	*/
     1950 	/*				with pathname pat				*/
     1951 	/*									*/
     1952 	/*  2 5	ref_name$			= ref_name$0(0)				*/
     1953 	/*  2 6	ref_name$W		= ref_name$W(0)				*/
     1954 	/*  2 7	ref_name$W(B)		octal word W, decimal bit B of seg with reference	*/
     1955 	/*				name ref_name.				*/
     1956 	/*  2 8	ref_name$entry_pt		word identified by entry point entry_pt in seg	*/
     1957 	/*				with reference name ref_name			*/
     1958 	/*									*/
     1959 	/*  3 5	segno			= segno|0(0)				*/
     1960 	/*  3 5	segno|			= segno|0(0)				*/
     1961 	/*  3 6	segno|W			= segno|W(0)				*/
     1962 	/*  3 7	segno|W(B)		octal word W, decimal bit B of seg known by segno	*/
     1963 	/*  3 8	segno|entry_pt		word identified by entry point entry_pt in seg	*/
     1964 	/*				known by segno				*/
     1965 	/*									*/
     1966 	/* CASES:  I = segment identifier case (id_case), O = offset value case (offset_case).	*/
     1967 	/*	 I = 1 => PATHNAME			O = 5 => MISSING (no offset given)	*/
     1968 	/*	   = 2 => REF_NAME			  = 6 => WORD			*/
     1969 	/*	   = 3 => SEGNO			  = 7 => WORD_AND_BIT		*/
     1970 	/*					  = 8 => ENTRY_PT			*/
     1971 	/*									*/
     1972 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
     1973 
     1974 	Acode = 0;				/* initialize return code.			*/
     1975 	code = error_table_$improper_data_format;	/* initialize format error code.		*/
     1976 	id_case = PATHNAME;				/* start by assuming we have a path segment	*/
     1977 	offset_case = MISSING;			/*   identifier, and no offset value.		*/
     1978 
     1979 	Psegment_id = addr(string);			/* Split identifier into seg_id, delim, & offset. */
     1980 	i = search (reverse(string), "|$");		/* Look for the delimiter.			*/
     1981 	if i > 0 then i = length(string) - (i-1);
     1982 	if i = 0 then do;				/* CASE: No delimiter.			*/
     1983 	     Pdelim = addr(V_BAR);			/*   Assume |.				*/
     1984 	     Lsegment_id = length(rtrim(string));	/*   Address seg_id.			*/
     1985 	     Pword_offset = addr(Pword_offset);		/*   Indicate no word offset.			*/
     1986 	     Lword_offset = 0;
     1987 	     end;
     1988 	else do;					/* CASE: Delimiter found.			*/
     1989 	     Pdelim = addr(string_array(i));		/*   Remember delimiter.			*/
     1990 	     Lsegment_id = i-1;			/*   Address seg_id.			*/
     1991 	     Lsegment_id = length(rtrim(segment_id));
     1992 	     if i < length(string) then do;		/*   Look for word offset.			*/
     1993 		Pword_offset = addr(string_array(i+1)); /*     Remember where word offset is.		*/
     1994 		Lword_offset = length(string) - i;
     1995 		Lword_offset = length(rtrim(word_offset));
     1996 		i = verify(word_offset, " ");
     1997 		if i > 1 then do;
     1998 		     Pword_offset = addr(word_offset_array(i));
     1999 		     Lword_offset = Lword_offset - (i-1);
     2000 		     end;
     2001 		end;
     2002 	     else do;				/*   No word offset.			*/
     2003 		Pword_offset = addr(Pword_offset);
     2004 		Lword_offset = 0;
     2005 		end;
     2006 	     end;
     2007 
     2008 	if verify (segment_id, "01234567") = 0 then	/* check for segno identifier.		*/
     2009 	     id_case = SEGNO;
     2010 	else if segment_id = "-1" then		/*     this includes null pointer segno.	*/
     2011 	     id_case = SEGNO;
     2012 
     2013 	if  (delim = "$") & (search (segment_id, "><") > 0)  then do;
     2014 	     if id_case ^= PATHNAME then call ERROR;	/* CASE: seg_id is a pathname.		*/
     2015 	     if length(segment_id) > 168 then do;
     2016 		code = error_table_$bigarg;
     2017 		call ERROR;
     2018 		end;
     2019 	     end;
     2020 	else if delim = "$" then do;			/* CASE: seg_id is a ref_name.		*/
     2021 	     id_case = REF_NAME;
     2022 	     if length(segment_id) > 32 then do;
     2023 		code = error_table_$entlong;
     2024 		call ERROR;
     2025 		end;
     2026 	     end;
     2027 	else if delim = "|" then;			/* CASE: seg_id is path or segno.		*/
     2028 	else call ERROR;				/* CASE: seg_id followed by bad delim.  We should	*/
     2029 						/*   never get to this line.			*/
     2030 
     2031 	if length(word_offset) > 0 then do;		/* Evaluate word offset.			*/
     2032 	     offset_case = WORD;			/*   Start by assuming word offset.		*/
     2033 	     i = verify (word_offset, "01234567");	/*   Check for octal word offset.		*/
     2034 	     if i = 0 then;				/*   CASE: only word offset given.		*/
     2035 	     else if (word_offset_array(i) = "(")  then do;
     2036 		code = error_table_$bad_conversion;
     2037 		offset_case = WORD_AND_BIT;
     2038 		if word_offset_array(Lword_offset) ^= ")" then
     2039 		     call ERROR;
     2040 		Pbit_offset = addr(word_offset_array(i+1));
     2041 		Lbit_offset = Lword_offset - i - 1;	/*     Overlay the bit offset.		*/
     2042 		Lbit_offset = length(rtrim(bit_offset));
     2043 		Lword_offset = i - 1;		/*     Exclude bit from word offset.	*/
     2044 		Lword_offset = length(rtrim(word_offset));
     2045 		i = verify(bit_offset, " ");
     2046 		if i > 1 then do;
     2047 		     Pbit_offset = addr(bit_offset_array(i));
     2048 		     Lbit_offset = Lbit_offset - (i-1);
     2049 		     end;
     2050 		if verify (bit_offset, "0123456789") ^= 0 then do;
     2051 		     code = error_table_$bad_conversion;
     2052 		     call ERROR;
     2053 		end;
     2054 	     end;
     2055 	     else do;				/*   CASE: no word offset, just entry_pt.	*/
     2056 		offset_case = ENTRY_PT;
     2057 		if length(word_offset) > 256 then do;	/*     Validate entry point length.		*/
     2058 		     code = error_table_$entlong;
     2059 		     call ERROR;
     2060 		     end;
     2061 		end;
     2062 	     end;
     2063 	if  (delim = "$") & (id_case = PATHNAME) & (offset_case ^= ENTRY_PT) then do;
     2064 	     code = error_table_$improper_data_format;
     2065 	     call ERROR;
     2066 	     end;
     2067 
     2068 	if id_case = PATHNAME then do;		/* id_case = PATHNAME			*/
     2069 	     call expand_pathname_ (segment_id, dir, ent, code);
     2070 	     if code ^= 0 then call ERROR;		/*     Expand the pathname given in virtual ptr.	*/
     2071 	     end;
     2072 
     2073 	else do;
     2074 	     if id_case = REF_NAME then do;		/* id_case = REF_NAME.			*/
     2075 		call hcs_$fs_get_seg_ptr (segment_id, P, code);
     2076 		if code ^= 0 then do;		/*     Convert reference name to a pointer.	*/
     2077 		     call ring0_get_$segptr ("", segment_id, P, code);
     2078 		     if code ^= 0 then call ERROR;
     2079 		     end;
     2080 		end;
     2081 	     else do;				/* id_case = SEGNO				*/
     2082 		segno = cv_oct_check_ (segment_id, code);
     2083 		if code ^= 0 then do;
     2084 		     code = error_table_$bad_conversion;
     2085 		     call ERROR;
     2086 		     end;
     2087 		P = baseptr (segno);		/*     Convert segment number to a pointer.	*/
     2088 		if (segment_id = "-1") | (segment_id = "77777") | (segment_id = "777777") then do;
     2089 						/*     Special case null pointers.		*/
     2090 		     if offset_case = MISSING then return (null);
     2091 		     if offset_case = ENTRY_PT then do;
     2092 			code = error_table_$improper_data_format;
     2093 			call ERROR;
     2094 			end;
     2095 		     go to OFFSET;
     2096 		     end;
     2097 		end;
     2098 
     2099 	     segp = P;
     2100 	     call hcs_$fs_get_path_name (segp, dir, (0), ent, code);
     2101 	     if code ^= 0 then do;			/* try in inner ring */
     2102 		segno = binary (baseno (P));
     2103 		if segno < hcscnt
     2104 		then do;
     2105 		     call ring0_get_$name (dir, ent, segp, code);
     2106 		     if code ^= 0 then call ERROR;	/*     Convert pointer to a pathname.		*/
     2107 		     end;
     2108 		else if segno = active_all_rings_data_$stack_base_segno
     2109 		     then do;
     2110 			code = 0;
     2111 			dir = "";
     2112 			ent = "stack_0";
     2113 			end;
     2114 		else call ERROR;
     2115 		goto OFFSET;
     2116 		end;
     2117 	     end;
     2118 
     2119 	call hcs_$initiate_count (dir, ent, "", bc, 0, segp, code);
     2120 						/* Initiate segment identified by pathname	*/
     2121 						/*   with a null reference name.		*/
     2122 	if segp = null then do;			/* try in an inner ring */
     2123 
     2124 	     on linkage_error call ERROR;
     2125 	     call phcs_$initiate (dir, ent, "", 0, 0, segp, code);
     2126 	     revert linkage_error;
     2127 
     2128 	     if segp = null then call ERROR;
     2129 	     P = segp;
     2130 	     inner_ring_segment = "1"b;
     2131 	     end;
     2132 	else inner_ring_segment = "0"b;
     2133 
     2134 OFFSET:	if offset_case = MISSING then;		/* No offset was given.			*/
     2135 	else if offset_case = ENTRY_PT then do;		/* An entry point was given.			*/
     2136 	     oi.version_number = object_info_version_2;	/*     Call object_info_ to get ptr to obj defs.	*/
     2137 	     call object_info_$brief (P, bc, addr(oi), code);
     2138 	     if code = error_table_$lower_ring
     2139 	     then do;				/* try in a lower ring */
     2140 		call ring0_get_$definition (P, ent, word_offset, entry_point_offset, (0), code);
     2141 		if code ^= 0 then call ERROR;
     2142 		P = ptr (P, entry_point_offset);
     2143 		end;
     2144 	     else if code ^= 0 then call ERROR;
     2145 	     else do;
     2146 		if id_case = REF_NAME then		/*     Get ptr to definition for entry point.	*/
     2147 		     call get_definition_ (oi.defp, segment_id, word_offset, Pdef, code);
     2148 		else call get_definition_ (oi.defp, ent, word_offset, Pdef, code);
     2149 		if code ^= 0 then call ERROR;
     2150 		if      Pdef -> definition.class = TEXT then	/*     Apply definition to get word offset.	*/
     2151 		     P = addrel (oi.textp, Pdef -> definition.value);
     2152 		else if Pdef -> definition.class = LINKAGE then
     2153 		     P = addrel (oi.linkp, Pdef -> definition.value);
     2154 		else if Pdef -> definition.class = SYMBOL then
     2155 		     P = addrel (oi.symbp, Pdef -> definition.value);
     2156 		else if Pdef -> definition.class = STATIC then
     2157 		     P = addrel (oi.statp, Pdef -> definition.value);
     2158 		else do;
     2159 		     code = error_table_$bad_class_def;
     2160 		     call ERROR;
     2161 		     end;
     2162 		end;
     2163 	     end;
     2164 	else do;					/* A word, or word and bit offset was given.	*/
     2165 	     word = cv_oct_check_ (word_offset, code);	/*     Convert/validate word offset.		*/
     2166 	     if code ^= 0 then do;
     2167 		code = error_table_$bad_conversion;
     2168 		call ERROR;
     2169 		end;
     2170 	     if (0 <= word) & (word <= sys_info$max_seg_size) then;
     2171 	     else do;
     2172 		code = error_table_$out_of_bounds;
     2173 		call ERROR;
     2174 		end;
     2175 	     P = ptr (P, word);			/*     Apply word offset to pointer.		*/
     2176 	     if offset_case = WORD_AND_BIT then do;	/*     A bit offset was also given.		*/
     2177 		bit = cv_dec_check_ (bit_offset, code);	/*	 Convert/validate bit offset.		*/
     2178 		if code ^= 0 then do;
     2179 		     code = error_table_$bad_conversion;
     2180 		     call ERROR;
     2181 		     end;
     2182 		if (0 <= bit) & (bit <= 35) then;
     2183 		else do;
     2184 		     code = error_table_$out_of_bounds;
     2185 		     call ERROR;
     2186 		     end;
     2187 		P = addr (P -> bits (bit+1));		/*     Apply the bit offset.			*/
     2188 		end;
     2189 	     end;
     2190 
     2191 RETURN_TO_CALLER:
     2192 
     2193 	if ^inner_ring_segment
     2194 	then call hcs_$terminate_noname (segp, (0));
     2195 	return (P);				/* return the pointer.			*/
     2196 
     2197 ERROR:
     2198      proc;
     2199 
     2200 	Acode = code;
     2201 	P = null;					/* return a null pointer, with the error code.	*/
     2202 	goto RETURN_TO_CALLER;
     2203 	end ERROR;
     2204 
     2205 	end cv_ptr_;
     2206 
  5     1 /* BEGIN INCLUDE FILE definition.incl.pl1 */
  5     2 
  5     3 
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  5     7*     audit(86-07-18,DGHowe), install(86-11-20,MR12.0-1222):
  5     8*     Modified to add indirect bit to definition flags.
  5     9*                                                   END HISTORY COMMENTS */
  5    10 
  5    11 
  5    12 dcl	1 definition	aligned based,
  5    13 	2 forward		unal bit(18),	/* offset of next def */
  5    14 	2 backward	unal bit(18),	/* offset of previous def */
  5    15 	2 value		unal bit(18),
  5    16 	2 flags		unal,
  5    17 	  3 new		bit(1),
  5    18 	  3 ignore	bit(1),
  5    19 	  3 entry		bit(1),
  5    20 	  3 retain	bit(1),
  5    21 	  3 argcount	bit(1),
  5    22 	  3 descriptors	bit(1),
  5    23 	  3 indirect	bit(1),
  5    24 	  3 unused	bit(8),
  5    25 	2 class		unal bit(3),
  5    26 	2 symbol		unal bit(18),	/* offset of ACC for symbol */
  5    27 	2 segname		unal bit(18);	/* offset of segname def */
  5    28 
  5    29 /* END INCLUDE FILE definition.incl.pl1 */
     2207 
     2208 
  6     1 /* BEGIN INCLUDE FILE ... object_info.incl.pl1
  6     2*coded February 8, 1972 by Michael J. Spier	*/
  6     3 /* modified May 26, 1972 by M. Weaver */
  6     4 /* modified 15 April, 1975 by M. Weaver */
  6     5 
  6     6 declare	1 object_info aligned based,		/* structure containing object info based, returned by object_info_ */
  6     7 	2 version_number fixed bin,		/* version number of current structure format (=2) */
  6     8 	2 textp pointer,			/* pointer to beginning of text section */
  6     9 	2 defp pointer,			/* pointer to beginning of definition section */
  6    10 	2 linkp pointer,			/* pointer to beginning of linkage section */
  6    11 	2 statp pointer,			/* pointer to beginning of static section */
  6    12 	2 symbp pointer,			/* pointer to beginning of symbol section */
  6    13 	2 bmapp pointer,			/* pointer to beginning of break map (may be null) */
  6    14 	2 tlng fixed bin,			/* length in words of text section */
  6    15 	2 dlng fixed bin,			/* length in words of definition section */
  6    16 	2 llng fixed bin,			/* length in words of linkage section */
  6    17 	2 ilng fixed bin,			/* length in words of static section */
  6    18 	2 slng fixed bin,			/* length in words of symbol section */
  6    19 	2 blng fixed bin,			/* length in words of break map */
  6    20 	2 format,				/* word containing bit flags about object type */
  6    21 	  3 old_format bit(1) unaligned,	/* on if segment isn't in new format, i.e. has old style object map */
  6    22 	  3 bound bit(1) unaligned,		/* on if segment is bound */
  6    23 	  3 relocatable bit(1) unaligned,	/* on if seg has relocation info in its first symbol block */
  6    24 	  3 procedure bit(1) unaligned,	/* on if segment is an executable object program */
  6    25 	  3 standard bit(1) unaligned,	/* on if seg is in standard format (more than just standard map) */
  6    26 	  3 gate bit(1) unaligned,		/* on if segment is a gate */
  6    27 	  3 separate_static bit(1) unaligned,	/* on if static not in linkage */
  6    28 	  3 links_in_text bit(1) unaligned,	/* on if there are threaded links in text */
  6    29 	  3 perprocess_static bit (1) unaligned, /* on if static is not to be per run unit */
  6    30 	  3 pad bit(27) unaligned,
  6    31 	2 entry_bound fixed bin,		/* entry bound if segment is a gate */
  6    32 	2 textlinkp pointer,		/* ptr to first link in text */
  6    33 
  6    34 	/* LIMIT OF BRIEF STRUCTURE */
  6    35 
  6    36 	2 compiler char(8) aligned,		/* name of processor which generated segment */
  6    37 	2 compile_time fixed bin(71),		/* clock reading of date/time object was generated */
  6    38 	2 userid char(32) aligned,		/* standard Multics id of creator of object segment */
  6    39 	2 cvers aligned,			/* generator version name in printable char string form */
  6    40 	  3 offset bit(18) unaligned,		/* offset of name in words relative to base of symbol section */
  6    41 	  3 length bit(18) unaligned,		/* length of name in characters */
  6    42 	2 comment aligned,			/* printable comment concerning generator or generation of segment */
  6    43 	  3 offset bit(18) unaligned,		/* offset of comment in words relative to base of symbol section */
  6    44 	  3 length bit(18) unaligned,		/* length of comment in characters */
  6    45 	2 source_map fixed bin,		/* offset, relative to base of symbol section, of source map structure */
  6    46 
  6    47 	/* LIMIT OF DISPLAY STRUCTURE */
  6    48 
  6    49 	2 rel_text pointer,			/* pointer to text section relocation info */
  6    50 	2 rel_def pointer,			/* pointer to definition section relocation info */
  6    51 	2 rel_link pointer,			/* pointer to linkage section relocation info */
  6    52 	2 rel_static pointer,		/* pointer to static section relocation info */
  6    53 	2 rel_symbol pointer,		/* pointer to symbol section relocation info */
  6    54 	2 text_boundary fixed bin,		/* specifies mod  of text section base boundary */
  6    55 	2 static_boundary fixed bin,		/* specifies mod of internal static base boundary */
  6    56 					/* currently not used by system */
  6    57 	2 default_truncate fixed bin,		/* offset rel to symbp for binder to automatically trunc. symb sect. */
  6    58 	2 optional_truncate fixed bin;	/* offset rel to symbp for binder to optionally trunc. symb sect. */
  6    59 
  6    60 declare	object_info_version_2 fixed bin int static init(2);
  6    61 
  6    62 /* END INCLUDE FILE ... object_info.incl.pl1 */
     2209 
     2210 
  7     1 /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
  7     2 /* format: style2,^inddcls,idind32 */
  7     3 
  7     4 declare 1 terminate_file_switches	based,
  7     5 	2 truncate		bit (1) unaligned,
  7     6 	2 set_bc			bit (1) unaligned,
  7     7 	2 terminate		bit (1) unaligned,
  7     8 	2 force_write		bit (1) unaligned,
  7     9 	2 delete			bit (1) unaligned;
  7    10 
  7    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
  7    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
  7    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
  7    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
  7    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
  7    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
  7    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
  7    18 
  7    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
     2211 
     2212 
  8     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  8     2*
  8     3*   Values for the "access mode" argument so often used in hardcore
  8     4*   James R. Davis 26 Jan 81  MCR 4844
  8     5*   Added constants for SM access 4/28/82 Jay Pattin
  8     6*   Added text strings 03/19/85 Chris Jones
  8     7**/
  8     8 
  8     9 
  8    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  8    11 dcl	(
  8    12 	N_ACCESS		   init ("000"b),
  8    13 	R_ACCESS		   init ("100"b),
  8    14 	E_ACCESS		   init ("010"b),
  8    15 	W_ACCESS		   init ("001"b),
  8    16 	RE_ACCESS		   init ("110"b),
  8    17 	REW_ACCESS	   init ("111"b),
  8    18 	RW_ACCESS		   init ("101"b),
  8    19 	S_ACCESS		   init ("100"b),
  8    20 	M_ACCESS		   init ("010"b),
  8    21 	A_ACCESS		   init ("001"b),
  8    22 	SA_ACCESS		   init ("101"b),
  8    23 	SM_ACCESS		   init ("110"b),
  8    24 	SMA_ACCESS	   init ("111"b)
  8    25 	)		   bit (3) internal static options (constant);
  8    26 
  8    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  8    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  8    29 
  8    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  8    31 			   static options (constant);
  8    32 
  8    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  8    34 			   static options (constant);
  8    35 
  8    36 dcl	(
  8    37 	N_ACCESS_BIN	   init (00000b),
  8    38 	R_ACCESS_BIN	   init (01000b),
  8    39 	E_ACCESS_BIN	   init (00100b),
  8    40 	W_ACCESS_BIN	   init (00010b),
  8    41 	RW_ACCESS_BIN	   init (01010b),
  8    42 	RE_ACCESS_BIN	   init (01100b),
  8    43 	REW_ACCESS_BIN	   init (01110b),
  8    44 	S_ACCESS_BIN	   init (01000b),
  8    45 	M_ACCESS_BIN	   init (00010b),
  8    46 	A_ACCESS_BIN	   init (00001b),
  8    47 	SA_ACCESS_BIN	   init (01001b),
  8    48 	SM_ACCESS_BIN	   init (01010b),
  8    49 	SMA_ACCESS_BIN	   init (01011b)
  8    50 	)		   fixed bin (5) internal static options (constant);
  8    51 
  8    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
     2213 
     2214 
     2215      end dump_segment;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/12/88  1245.0  dump_segment.pl1                  >spec>install>1012>dump_segment.pl1
186          1    09/24/84  1459.2  dump_segment_format.incl.pl1      >ldd>include>dump_segment_format.incl.pl1
950          2    11/22/82  0955.6  branch_status.incl.pl1            >ldd>include>branch_status.incl.pl1
1931         3    11/24/86  1226.9  definition.incl.pl1               >ldd>include>definition.incl.pl1
1933         4    08/05/77  1022.5  object_info.incl.pl1              >ldd>include>object_info.incl.pl1
2207         5    11/24/86  1226.9  definition.incl.pl1               >ldd>include>definition.incl.pl1
2209         6    08/05/77  1022.5  object_info.incl.pl1              >ldd>include>object_info.incl.pl1
2211         7    04/06/83  1239.4  terminate_file.incl.pl1           >ldd>include>terminate_file.incl.pl1
2213         8    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Acode                                  parameter       fixed bin(35,0)          dcl 1855 set ref 1852 1974* 2200*
ENTRY_PT                               constant        fixed bin(17,0)          initial dcl 1908 ref 2056 2063 2091 2135
LINKAGE                                constant        bit(3)                   initial unaligned dcl 1908 ref 2152
Lbit_offset                     000100 automatic       fixed bin(17,0)          dcl 1859 set ref 2041* 2042* 2042 2045 2048* 2048
                                                                                  2050 2177 2177
Lsegment_id                     000101 automatic       fixed bin(17,0)          dcl 1859 set ref 1984* 1990* 1991* 1991 2008 2010
                                                                                  2013 2015 2022 2069 2069 2075 2075 2077 2077 2082
                                                                                  2082 2088 2088 2088 2146 2146
Lword_offset                    000102 automatic       fixed bin(17,0)          dcl 1859 set ref 1986* 1994* 1995* 1995 1996 1999*
                                                                                  1999 2004* 2031 2033 2038 2041 2043* 2044* 2044
                                                                                  2057 2140 2140 2146 2146 2148 2148 2165 2165
MISSING                                constant        fixed bin(17,0)          initial dcl 1908 ref 1977 2090 2134
MR10_FORMAT_LENGTH                     constant        fixed bin(17,0)          initial dcl 1727 ref 1759
NL                              016400 constant        char(1)                  initial unaligned dcl 240 ref 1412 1442 1442 1458
                                                                                  1547
P                               000114 automatic       pointer                  dcl 1859 set ref 2075* 2077* 2087* 2099 2102 2129*
                                                                                  2137* 2140* 2142* 2142 2150* 2152* 2154* 2156*
                                                                                  2175* 2175 2187* 2187 2195 2201*
PATHNAME                               constant        fixed bin(17,0)          initial dcl 1908 ref 1976 2014 2063 2068
Pbit_offset                     000104 automatic       pointer                  dcl 1859 set ref 2040* 2042 2045 2047* 2047 2050
                                                                                  2177
Pdef                            000116 automatic       pointer                  dcl 1859 set ref 2146* 2148* 2150 2150 2152 2152
                                                                                  2154 2154 2156 2156
Pdelim                          000112 automatic       pointer                  dcl 1859 set ref 1983* 1989* 2013 2020 2027 2063
Psegment_id                     000106 automatic       pointer                  dcl 1859 set ref 1979* 1991 2008 2010 2013 2015 2022
                                                                                  2069 2075 2077 2082 2088 2088 2088 2146
Pword_offset                    000110 automatic       pointer                  dcl 1859 set ref 1985* 1985 1993* 1995 1996 1998*
                                                                                  1998 2003* 2003 2031 2033 2035 2038 2040 2044 2057
                                                                                  2140 2146 2148 2165
REF_NAME                               constant        fixed bin(17,0)          initial dcl 1908 ref 2021 2074 2146
R_ACCESS                        001272 constant        bit(3)                   initial unaligned dcl 8-11 set ref 834*
SEGNO                                  constant        fixed bin(17,0)          initial dcl 1908 ref 2008 2010
STATIC                                 constant        bit(3)                   initial unaligned dcl 1908 ref 2156
SYMBOL                                 constant        bit(3)                   initial unaligned dcl 1908 ref 2154
TERM_FILE_TERM                  000160 constant        bit(3)                   initial unaligned dcl 7-14 set ref 808*
TEXT                                   constant        bit(3)                   initial unaligned dcl 1908 ref 2150
V_BAR                           001205 constant        char(1)                  initial unaligned dcl 1908 set ref 1983
WORD                                   constant        fixed bin(17,0)          initial dcl 1908 ref 2032
WORD_AND_BIT                           constant        fixed bin(17,0)          initial dcl 1908 ref 2037 2176
a_blk_size                             parameter       fixed bin(17,0)          dcl 1723 ref 1729 1747 1749 1800 1821 1823
a_count                                parameter       fixed bin(18,0)          dcl 1721 ref 1673 1687 1729 1743 1800 1817
a_first                                parameter       fixed bin(18,0)          dcl 1722 ref 1673 1686 1729 1750 1800 1824
a_format                               parameter       bit                      unaligned dcl 1724 ref 1729 1741 1759 1800 1815
a_iocbp                                parameter       pointer                  dcl 1725 ref 1673 1683 1729 1739
a_old_format                           parameter       bit(6)                   unaligned dcl 1671 ref 1673 1685
a_ptr                                  parameter       pointer                  dcl 1726 set ref 1673 1702* 1729 1742 1769* 1776*
                                                                                  1800 1816 1833* 1840* 1842*
a_string_length                        parameter       fixed bin(21,0)          dcl 1798 ref 1800 1810
a_string_ptr                           parameter       pointer                  dcl 1797 ref 1800 1811
active_all_rings_data_$stack_base_segno
                                000034 external static fixed bin(35,0)          dcl 238 ref 619 1059 2108
active_fnc_err_                 000100 constant        entry                    external dcl 273 ref 782
active_func                     000100 automatic       bit(1)                   dcl 132 set ref 344* 349* 365 370 388 395 402 409
                                                                                  416 423 430 437 440 445 447 449 463 465 467 472
                                                                                  587 590 756 763 769 782 918 1072 1412 1442 1458
                                                                                  1547 1604 1617 1624 1682* 1738* 1809*
addr                                                   builtin function         dcl 260 ref 326 345 350 350 350 367 368 370 372 374
                                                                                  376 380 382 386 386 387 387 387 387 388 393 393
                                                                                  394 394 394 394 395 400 400 401 401 401 402 407
                                                                                  407 408 408 408 409 414 414 415 415 415 416 421
                                                                                  421 422 422 423 428 428 429 429 430 435 435 436
                                                                                  436 437 442 443 445 447 451 463 465 469 581 581
                                                                                  581 581 584 584 590 596 596 596 596 596 599 599
                                                                                  599 599 599 599 599 670 670 708 745 960 960 1074
                                                                                  1074 1126 1128 1130 1133 1136 1138 1139 1142 1144
                                                                                  1146 1149 1149 1150 1153 1155 1156 1159 1161 1162
                                                                                  1207 1210 1210 1213 1215 1291 1291 1291 1293 1295
                                                                                  1296 1298 1361 1364 1367 1368 1369 1372 1372 1375
                                                                                  1377 1387 1389 1397 1410 1410 1448 1448 1456 1456
                                                                                  1474 1474 1545 1552 1597 1606 1606 1610 1610 1610
                                                                                  1612 1614 1615 1619 1619 1622 1626 1626 1646 1648
                                                                                  1657 1684 1685 1691 1691 1691 1691 1693 1694 1696
                                                                                  1696 1696 1699 1699 1700 1740 1741 1751 1751 1751
                                                                                  1751 1751 1751 1751 1751 1751 1755 1756 1761 1761
                                                                                  1762 1762 1762 1762 1762 1762 1764 1764 1764 1766
                                                                                  1766 1815 1825 1825 1825 1825 1825 1825 1825 1825
                                                                                  1825 1829 1830 1840 1979 1983 1985 1989 1989 1993
                                                                                  1993 1998 2003 2040 2047 2137 2137 2187
addr_col                        001304 automatic       fixed bin(18,0)          dcl 1580 set ref 1590* 1599* 1615* 1622*
addrel                                                 builtin function         dcl 260 ref 752 752 763 763 765 765 1234 1521 1521
                                                                                  2150 2152 2154 2156
address_fmt                            defined         bit(1)                   unaligned dcl 187 set ref 350* 445* 447* 1646 1694*
                                                                                  1756* 1830*
af_format                       000110 constant        varying char(15)         initial array dcl 1201 ref 1220
arg_for_header_given            000101 automatic       bit(1)                   unaligned dcl 133 set ref 328* 470* 708
argc                            000102 automatic       fixed bin(17,0)          dcl 135 set ref 340* 353 361 452 474 486 498 508 518
argno                                  parameter       fixed bin(17,0)          dcl 916 set ref 892 918* 920*
ascii_chars                            based           char                     unaligned dcl 1092 ref 1128 1128 1129 1130 1130 1133
baseno                                                 builtin function         dcl 260 ref 645 837 859 872 2102
baseptr                                                builtin function         dcl 260 ref 607 1013 1013 2087
bc                              000120 automatic       fixed bin(24,0)          dcl 1859 set ref 2119* 2137*
bcd_chars                              based           bit                      unaligned dcl 1093 set ref 1138*
bcd_fmt                                defined         bit(1)                   unaligned dcl 190 set ref 387* 393* 599 1136 1691
                                                                                  1696 1751 1762 1825
bcd_return                             based           char                     unaligned dcl 1099 set ref 1138* 1139
bcd_to_ascii_                   000172 constant        entry                    external dcl 1119 ref 1138
binary                                                 builtin function         dcl 260 ref 676 733 748 797 810 837 859 872 1367
                                                                                  1368 1751 1751 1751 1751 1751 1825 1825 1825 1825
                                                                                  1825 2102
bit                             000121 automatic       fixed bin(35,0)          dcl 1859 set ref 2177* 2182 2182 2187
bit4_fmt                               defined         bit(1)                   unaligned dcl 195 set ref 387* 394* 401* 408* 414*
                                                                                  599 1159 1751 1762 1825
bit_count                       000103 automatic       fixed bin(24,0)          dcl 136 set ref 664* 670* 787* 788* 789
bit_offset                             based           char                     unaligned dcl 1883 set ref 2042 2045 2050 2177*
bit_offset_array                       based           char(1)                  array unaligned dcl 1883 set ref 2047
bits                                   based           bit(1)                   array unaligned dcl 1883 set ref 2187
bits_to_dump                           based           bit                      unaligned dcl 1585 in procedure "print_line" set ref
                                                                                  1614*
bits_to_dump                           based           bit                      unaligned dcl 1278 in procedure "return_line" set
                                                                                  ref 1295*
block                           000104 automatic       fixed bin(18,0)          dcl 137 set ref 334* 477* 730 730 730* 758* 765*
                                                                                  1689* 1702* 1747* 1749* 1776* 1821* 1823* 1840*
block_addr                      001125 automatic       fixed bin(17,0)          dcl 1193 in procedure "return_dump" set ref 1226*
                                                                                  1234 1235 1240 1256 1256 1262 1262
block_addr                      001230 automatic       fixed bin(18,0)          dcl 1331 in procedure "print_dump" set ref 1405*
                                                                                  1418 1422 1423* 1471 1502 1503 1504 1504 1565 1565
                                                                                  1646* 1648
block_lng                       001126 automatic       fixed bin(17,0)          dcl 1194 in procedure "return_dump" set ref 1222*
                                                                                  1226 1226 1235* 1235* 1238 1240* 1256 1262 1262
block_lng                              parameter       fixed bin(18,0)          dcl 1322 in procedure "print_dump" set ref 1309 1405
                                                                                  1405 1418 1421 1422 1471* 1504 1565 1565
blockp                          001132 automatic       pointer                  dcl 1197 set ref 1234* 1235
branch_status                   000100 automatic       structure                level 1 dcl 2-1 set ref 960 960
buffer                          000105 automatic       fixed bin(17,0)          array dcl 138 set ref 745
char_fmt                               defined         bit(1)                   unaligned dcl 191 set ref 386* 394* 401* 408* 415*
                                                                                  599 599* 1126 1691 1696 1751 1762 1825
class                     1(33)        based           bit(3)                   level 2 packed unaligned dcl 3-12 ref 2150 2152 2154
                                                                                  2156
cleanup                         000734 stack reference condition                dcl 214 ref 356
clock                                                  builtin function         dcl 260 ref 1052 1052
code                            001360 automatic       fixed bin(35,0)          dcl 1636 in procedure "print_structure" set ref
                                                                                  1649* 1651 1651* 1652* 1655* 1656 1656* 1657* 1660
                                                                                  1660*
code                                   parameter       fixed bin(35,0)          dcl 779 in procedure "PRINT_ERROR" set ref 776 786
                                                                                  788* 789 789* 792* 793* 797*
code                            000205 automatic       fixed bin(35,0)          dcl 139 in procedure "ds" set ref 340* 342 456* 457
                                                                                  477* 478 538* 539 562* 563 569* 570 612* 613 613*
                                                                                  627* 628 632* 642* 660* 661 661* 664* 665 665*
                                                                                  670* 672 672* 674* 675 675* 748* 749 749* 752* 753
                                                                                  753* 808* 810* 832* 833 834* 849* 854* 855 855*
                                                                                  864* 865 865* 868* 869 869* 918* 920* 960* 961 966
                                                                                  966 979 992* 1013* 1014 1014* 1055* 1074* 1606*
                                                                                  1619* 1626* 1769* 1770 1833* 1834
code                            000124 automatic       fixed bin(35,0)          dcl 1859 in procedure "cv_ptr_" set ref 1975* 2016*
                                                                                  2023* 2036* 2051* 2058* 2064* 2069* 2070 2075*
                                                                                  2076 2077* 2078 2082* 2083 2084* 2092* 2100* 2101
                                                                                  2105* 2106 2110* 2119* 2125* 2137* 2138 2140* 2141
                                                                                  2144 2146* 2148* 2149 2159* 2165* 2166 2167* 2172*
                                                                                  2177* 2178 2179* 2184* 2200
collate                                                builtin function         dcl 260 ref 319 319 1678 1678 1734 1734 1805 1805
com_err_                        000076 constant        entry                    external dcl 273 ref 784
com_err_fmt                     000170 constant        varying char(80)         initial array dcl 223 set ref 797*
com_err_fmt_index                      parameter       fixed bin(17,0)          dcl 780 ref 776 785 797
command_arg                            based           char                     unaligned dcl 207 set ref 363 365 365 370 370 372
                                                                                  372 374 376 376 378 380 380 382 382 384 384 384
                                                                                  391 398 405 412 419 426 433 433 440 440 445 445
                                                                                  445 447 447 447 449 449 456* 463 463 465 465 467
                                                                                  467 472 472 477* 484 484 496 496 502 507 512 517
                                                                                  522 528 538* 562* 569* 797*
command_output_fmt                     defined         bit(1)                   unaligned dcl 203 set ref 1700* 1766* 1840
comp_8_return                          based           char                     unaligned dcl 1102 set ref 1161* 1162
comp_8_to_ascii_                000176 constant        entry                    external dcl 1121 ref 1161
count                           000206 automatic       fixed bin(18,0)          dcl 140 in procedure "ds" set ref 569* 572 685* 702*
                                                                                  711* 716* 718* 726 728* 730 730 745 752* 756* 758*
                                                                                  763* 765* 1687* 1688 1689 1702* 1743* 1744 1744*
                                                                                  1746 1747 1749 1776* 1817* 1818 1818* 1820 1821
                                                                                  1823 1840* 1842*
count                                  parameter       fixed bin(18,0)          dcl 1181 in procedure "return_dump" ref 1169 1222
                                                                                  1226 1235 1240
count                                  parameter       fixed bin(18,0)          dcl 1320 in procedure "print_dump" ref 1309 1405
                                                                                  1471
cu_$af_arg_ptr                  000156 constant        entry                    external dcl 911 ref 918
cu_$af_return_arg               000124 constant        entry                    external dcl 287 ref 340
cu_$arg_ptr                     000160 constant        entry                    external dcl 912 ref 920
cur_length                      000207 automatic       fixed bin(18,0)          dcl 141 in procedure "ds" set ref 615* 624* 648* 691
                                                                                  702 756* 758* 763* 765* 861* 964* 969* 970 970*
                                                                                  1688* 1702* 1746* 1776* 1820* 1840* 1842*
cur_length                             parameter       fixed bin(18,0)          dcl 1321 in procedure "print_dump" set ref 1309 1418
                                                                                  1424 1426 1514 1517 1530 1530 1535 1593 1657*
cur_length                             parameter       fixed bin(18,0)          dcl 1182 in procedure "return_dump" ref 1169 1286
cur_line                               based           char                     unaligned dcl 1485 ref 1521
current_length            7     000100 automatic       bit(12)                  level 2 packed unaligned dcl 2-1 set ref 969
cv_dec_check_                   000202 constant        entry                    external dcl 1894 ref 2177
cv_oct_check_                   000134 constant        entry                    external dcl 290 in procedure "ds" ref 456 477 538
                                                                                  562 569
cv_oct_check_                   000204 constant        entry                    external dcl 1894 in procedure "cv_ptr_" ref 2082
                                                                                  2165
date_time                       001002 automatic       char(24)                 unaligned dcl 1042 set ref 1052* 1071*
date_time_                      000166 constant        entry                    external dcl 1048 ref 1052
definition                             based           structure                level 1 dcl 5-12 in procedure "ds"
definition                             based           structure                level 1 dcl 3-12 in procedure "cv_ptr_"
defn_ptr                        000210 automatic       pointer                  dcl 142 set ref 674* 676
defp                      4     000214 automatic       pointer                  level 2 in structure "oi" dcl 1859 in procedure
                                                                                  "cv_ptr_" set ref 2146* 2148*
defp                      4     000346 automatic       pointer                  level 2 in structure "obj_info" dcl 165 in procedure
                                                                                  "ds" set ref 674*
delim                                  based           char(1)                  unaligned dcl 1883 ref 2013 2020 2027 2063
dir                             000125 automatic       char(168)                unaligned dcl 1859 set ref 2069* 2100* 2105* 2111*
                                                                                  2119* 2125*
dir_len                         000212 automatic       fixed bin(17,0)          dcl 143 set ref 627* 868* 1769* 1833*
directory_type                         constant        bit(2)                   initial dcl 2-1 ref 972
dirname                         000213 automatic       char(168)                unaligned dcl 144 set ref 612* 621* 627* 634 634*
                                                                                  664* 788* 796 796* 797* 832* 834* 849* 868* 960*
                                                                                  1064 1067 1069 1769* 1772* 1833* 1836*
display_data_$for_azm           000146 constant        entry                    external dcl 295 ref 1657
divide                                                 builtin function         dcl 260 ref 1155 1155 1155 1155 1156
dlen                            001062 automatic       fixed bin(17,0)          dcl 1044 set ref 1056* 1057 1064* 1065 1065* 1069
dots                            016401 constant        char(33)                 initial dcl 220 ref 1133 1150 1156
dump_segment_format                    based           bit(36)                  unaligned dcl 1-8 set ref 326* 345* 345 350* 350
                                                                                  350* 350 350* 350 367* 367 368* 368 370* 370 372*
                                                                                  372 374* 374 376* 376 380* 380 382* 382 386* 386
                                                                                  386* 386 387* 387 387* 387 387* 387 387* 387 388*
                                                                                  388 393* 393 393* 393 394* 394 394* 394 394* 394
                                                                                  394* 394 395* 395 400* 400 400* 400 401* 401 401*
                                                                                  401 401* 401 402* 402 407* 407 407* 407 408* 408
                                                                                  408* 408 408* 408 409* 409 414* 414 414* 414 415*
                                                                                  415 415* 415 415* 415 416* 416 421* 421 421* 421
                                                                                  422* 422 422* 422 423* 423 428* 428 428* 428 429*
                                                                                  429 429* 429 430* 430 435* 435 435* 435 436* 436
                                                                                  436* 436 437* 437 442* 442 443* 443 445* 445 447*
                                                                                  447 451* 451 463* 463 465* 465 469* 469 581* 581
                                                                                  581 581 581 581 581 581 584 584 584 584 590 590
                                                                                  596 596 596 596 596 596 596 596 596* 596 599 599
                                                                                  599 599 599 599 599 599 599 599 599 599 599* 599
                                                                                  708* 708 1126 1126 1136 1136 1142 1142 1153 1153
                                                                                  1159 1159 1207 1207 1210 1210 1210 1210 1213 1213
                                                                                  1215 1215 1291 1291 1293 1293 1361 1361 1364 1364
                                                                                  1367 1368 1369 1369 1372 1372 1372 1372 1375 1375
                                                                                  1377 1377 1387 1387 1389 1389 1397 1397 1410 1410
                                                                                  1410 1410 1448 1448 1448 1448 1456 1456 1456 1456
                                                                                  1474 1474 1474 1474 1545 1545 1552 1552 1597 1597
                                                                                  1610 1610 1612 1612 1646 1646 1657 1657 1684*
                                                                                  1685* 1691 1691 1691 1691 1691 1691 1691 1691
                                                                                  1693* 1694* 1694 1696 1696 1696 1696 1696* 1696
                                                                                  1699* 1699 1699* 1699 1700* 1700 1740* 1741* 1751
                                                                                  1751 1751 1751 1751 1751 1751 1751 1751 1751 1751
                                                                                  1751 1751 1751 1751 1751 1751 1751 1755* 1756*
                                                                                  1756 1761* 1761 1761* 1761 1762 1762 1762 1762
                                                                                  1762 1762 1762 1762 1762 1762 1762* 1762 1764 1764
                                                                                  1764 1764 1764* 1764 1766* 1766 1766* 1766 1815*
                                                                                  1825 1825 1825 1825 1825 1825 1825 1825 1825 1825
                                                                                  1825 1825 1825 1825 1825 1825 1825 1825 1829*
                                                                                  1830* 1830 1840 1840
dump_segment_format_structure   000732 automatic       structure                level 1 dcl 1-10 set ref 326 345 350 350 350 367 368
                                                                                  370 372 374 376 380 382 386 386 387 387 387 387
                                                                                  388 393 393 394 394 394 394 395 400 400 401 401
                                                                                  401 402 407 407 408 408 408 409 414 414 415 415
                                                                                  415 416 421 421 422 422 423 428 428 429 429 430
                                                                                  435 435 436 436 437 442 443 445 447 451 463 465
                                                                                  469 581 581 581 581 584 584 590 596 596 596 596
                                                                                  596 599 599 599 599 599 599 599 708 1126 1136 1142
                                                                                  1153 1159 1207 1210 1210 1213 1215 1291 1293 1361
                                                                                  1364 1367 1368 1369 1372 1372 1375 1377 1387 1389
                                                                                  1397 1410 1410 1448 1448 1456 1456 1474 1474 1545
                                                                                  1552 1597 1610 1612 1646 1657 1684 1685 1691 1691
                                                                                  1691 1691 1693 1694 1696 1696 1696 1699 1699 1700
                                                                                  1740 1741 1751 1751 1751 1751 1751 1751 1751 1751
                                                                                  1751 1755 1756 1761 1761 1762 1762 1762 1762 1762
                                                                                  1762 1764 1764 1764 1766 1766 1815 1825 1825 1825
                                                                                  1825 1825 1825 1825 1825 1825 1829 1830 1840
dup_block                       001231 automatic       bit(1)                   unaligned dcl 1332 set ref 1404* 1420* 1428* 1432*
                                                                                  1439* 1440 1452 1507 1565
dup_line                        001260 automatic       bit(1)                   unaligned dcl 1487 set ref 1516* 1521* 1523* 1532*
                                                                                  1537* 1544* 1545 1552
ebcdic8_chars                          based           bit                      unaligned dcl 1095 set ref 1155*
ebcdic8_fmt                            defined         bit(1)                   unaligned dcl 194 set ref 387* 394* 401* 407* 415*
                                                                                  599 1153 1751 1762 1825
ebcdic8_return                         based           char                     unaligned dcl 1101 set ref 1155* 1156
ebcdic8_to_ascii_               000200 constant        entry                    external dcl 1122 ref 1155
ebcdic9_chars                          based           char                     unaligned dcl 1094 ref 1144 1144 1145 1146 1146 1149
                                                                                  1149
ebcdic9_fmt                            defined         bit(1)                   unaligned dcl 193 set ref 387* 394* 400* 408* 415*
                                                                                  599 1142 1751 1762 1825
ebcdic9_return                         based           char                     unaligned dcl 1100 set ref 1149* 1150
ebcdic_to_ascii_                000174 constant        entry                    external dcl 1120 ref 1149
ename                           000265 automatic       char(32)                 unaligned dcl 145 set ref 612* 622* 627* 649* 664*
                                                                                  788* 797* 832* 834* 849* 868* 960* 1067 1069 1769*
                                                                                  1773* 1833* 1837*
ent                             000177 automatic       char(32)                 unaligned dcl 1859 set ref 2069* 2100* 2105* 2112*
                                                                                  2119* 2125* 2140* 2148*
entry_point_name                000275 automatic       char(32)                 unaligned dcl 146 set ref 502* 660* 674* 797*
entry_point_offset              000305 automatic       fixed bin(18,0)          dcl 147 in procedure "ds" set ref 333* 660* 676* 721
entry_point_offset              000207 automatic       fixed bin(18,0)          dcl 1859 in procedure "cv_ptr_" set ref 2140* 2142
entry_type                      000306 automatic       fixed bin(17,0)          dcl 148 set ref 660*
entry_var                       000310 automatic       entry variable           dcl 149 set ref 782* 784* 797
error_table_$bad_class_def      000224 external static fixed bin(35,0)          dcl 1908 ref 2159
error_table_$bad_conversion     000226 external static fixed bin(35,0)          dcl 1908 ref 2036 2051 2084 2167 2179
error_table_$badopt             000036 external static fixed bin(35,0)          dcl 247 set ref 530*
error_table_$bigarg             000230 external static fixed bin(35,0)          dcl 1908 ref 2016
error_table_$dirseg             000040 external static fixed bin(35,0)          dcl 248 ref 786 792 793
error_table_$entlong            000232 external static fixed bin(35,0)          dcl 1908 ref 2023 2058
error_table_$improper_data_format
                                000236 external static fixed bin(35,0)          dcl 1908 ref 1975 2064 2092
error_table_$inconsistent       000042 external static fixed bin(35,0)          dcl 249 set ref 593*
error_table_$lower_ring         000234 external static fixed bin(35,0)          dcl 1908 in procedure "cv_ptr_" ref 2138
error_table_$lower_ring         000044 external static fixed bin(35,0)          dcl 250 in procedure "ds" set ref 668*
error_table_$msf                000046 external static fixed bin(35,0)          dcl 251 ref 789
error_table_$no_s_permission    000050 external static fixed bin(35,0)          dcl 252 ref 966 979
error_table_$noarg              000052 external static fixed bin(35,0)          dcl 253 set ref 353* 482* 494* 505* 515* 525* 602*
error_table_$out_of_bounds      000240 external static fixed bin(35,0)          dcl 1908 ref 2172 2184
error_table_$root               000162 external static fixed bin(17,0)          dcl 954 ref 961
error_table_$too_many_args      000054 external static fixed bin(35,0)          dcl 254 set ref 575*
expand_pathname_                000064 constant        entry                    external dcl 269 in procedure "ds" ref 832
expand_pathname_                000206 constant        entry                    external dcl 1894 in procedure "cv_ptr_" ref 2069
first                           000314 automatic       fixed bin(18,0)          dcl 150 in procedure "ds" set ref 562* 682* 696* 702
                                                                                  710* 721* 721 722 724 726 728 752 752 756* 758*
                                                                                  763 763 763* 765 765 765* 797* 880* 880 883* 884
                                                                                  1686* 1688 1702* 1742* 1746 1776* 1816* 1820 1840*
                                                                                  1842*
first                                  parameter       fixed bin(18,0)          dcl 1319 in procedure "print_dump" ref 1309 1405
                                                                                  1405 1428 1428 1432 1471 1521 1521 1532 1532 1537
                                                                                  1593 1648
first                                  parameter       fixed bin(18,0)          dcl 1180 in procedure "return_dump" ref 1169 1226
                                                                                  1226 1235 1240 1286
first_block                     001232 automatic       bit(1)                   unaligned dcl 1333 set ref 1401* 1406 1415*
first_dup_block                 001233 automatic       bit(1)                   unaligned dcl 1334 set ref 1402* 1440 1445* 1461*
first_dup_line                  001261 automatic       bit(1)                   unaligned dcl 1488 set ref 1500* 1545 1550* 1555*
first_line                      001262 automatic       bit(1)                   unaligned dcl 1489 in procedure "print_block" set
                                                                                  ref 1499* 1505 1510*
first_line                      001145 automatic       bit(1)                   dcl 1253 in procedure "return_block" set ref 1255*
first_time                      000010 internal static bit(1)                   initial unaligned dcl 221 set ref 314 320* 1676
                                                                                  1679* 1732 1735* 1803 1806*
fixed                                                  builtin function         dcl 260 ref 645 969 1742 1816
fourbit_chars                          based           bit                      unaligned dcl 1096 set ref 1161*
full_name                       001361 automatic       char(256)                unaligned dcl 1637 set ref 1649*
get_definition_                 000142 constant        entry                    external dcl 293 in procedure "ds" ref 674
get_definition_                 000210 constant        entry                    external dcl 1894 in procedure "cv_ptr_" ref 2146
                                                                                  2148
get_ring_                       000140 constant        entry                    external dcl 292 ref 733
get_temp_segments_              000060 constant        entry                    external dcl 267 ref 748
have_count                      000315 automatic       bit(1)                   unaligned dcl 151 set ref 328* 567 573* 593 678 686*
                                                                                  700 703* 714 719* 1232
have_entry_point                000316 automatic       bit(1)                   unaligned dcl 152 set ref 328* 501* 656
have_first                      000317 automatic       bit(1)                   unaligned dcl 153 set ref 328* 560 565* 680 683* 694
                                                                                  697* 706 712* 880 884*
have_name                       000320 automatic       bit(1)                   unaligned dcl 154 set ref 328* 491* 535 542* 555*
                                                                                  602 887*
have_structure                  000321 automatic       bit(1)                   unaligned dcl 155 set ref 328* 510* 581 584 587 678
                                                                                  694 700 1408 1446 1454 1472 1682* 1738*
have_structure_path             000322 automatic       bit(1)                   unaligned dcl 156 set ref 328* 520* 797* 1652 1682*
                                                                                  1738*
hc_seg                          000326 automatic       bit(1)                   unaligned dcl 158 set ref 328* 548* 646* 658 735*
                                                                                  743 808 877*
hcs_$fs_get_path_name           000102 constant        entry                    external dcl 275 in procedure "ds" ref 627 868 1769
                                                                                  1833
hcs_$fs_get_path_name           000212 constant        entry                    external dcl 1894 in procedure "cv_ptr_" ref 2100
hcs_$fs_get_seg_ptr             000214 constant        entry                    external dcl 1894 ref 2075
hcs_$high_low_seg_count         000104 constant        entry                    external dcl 276 ref 317
hcs_$initiate_count             000216 constant        entry                    external dcl 1894 ref 2119
hcs_$status_long                000164 constant        entry                    external dcl 958 ref 960
hcs_$status_minf                000106 constant        entry                    external dcl 278 ref 664 788
hcs_$terminate_noname           000220 constant        entry                    external dcl 1894 ref 2191
hcscnt                          000022 internal static fixed bin(17,0)          dcl 239 set ref 317* 546 608 877 1053 2103
hcsp                            000324 automatic       pointer                  array dcl 157 set ref 336* 745* 748* 752* 756* 758*
                                                                                  810 810*
head_format                     000050 constant        varying char(12)         initial array dcl 1348 ref 1382
header                                 defined         bit(1)                   unaligned dcl 199 set ref 465* 469* 708* 1361 1766*
hex8_fmt                               defined         bit(1)                   unaligned dcl 196 set ref 421* 429* 436* 581 596
                                                                                  1210 1372 1389 1751 1764 1825
hex9_array                             based           char(8)                  array unaligned dcl 1281 in procedure "return_line"
                                                                                  set ref 1296*
hex9_array                             based           char(8)                  array unaligned dcl 1588 in procedure "print_line"
                                                                                  set ref 1615*
hex9_fmt                               defined         bit(1)                   unaligned dcl 197 set ref 422* 428* 436* 581 596
                                                                                  1213 1293 1375 1387 1612 1751 1764 1825
hex9_line                       001330 automatic       char(64)                 unaligned dcl 1587 in procedure "print_line" set ref
                                                                                  1614* 1615
hex9_line                       001167 automatic       char(64)                 unaligned dcl 1280 in procedure "return_line" set
                                                                                  ref 1295* 1296
hfx                             001234 automatic       fixed bin(17,0)          dcl 1335 set ref 1368* 1382
highseg                         000327 automatic       fixed bin(17,0)          dcl 159 set ref 317*
i                               000210 automatic       fixed bin(17,0)          dcl 1859 in procedure "cv_ptr_" set ref 1980* 1981
                                                                                  1981* 1981 1982 1989 1990 1992 1993 1994 1996*
                                                                                  1997 1998 1999 2033* 2034 2035 2040 2041 2043
                                                                                  2045* 2046 2047 2048
i                               001102 automatic       fixed bin(17,0)          dcl 1104 in procedure "translate_line_to_dump" set
                                                                                  ref 1129* 1130 1130* 1145* 1146 1146*
i                               000330 automatic       fixed bin(17,0)          dcl 160 in procedure "ds" set ref 361* 362* 452 454
                                                                                  457* 457 474 476 478* 478 486 488 492* 492 498 500
                                                                                  503* 503 508 511 513* 513 518 521 523* 523*
i                               001235 automatic       fixed bin(17,0)          dcl 1336 in procedure "print_dump" set ref 1421*
                                                                                  1422 1423*
i                               001267 automatic       fixed bin(17,0)          dcl 1496 in procedure "print_block" set ref 1527*
                                                                                  1528 1529*
id_case                         000211 automatic       fixed bin(17,0)          dcl 1859 set ref 1976* 2008* 2010* 2014 2021* 2063
                                                                                  2068 2074 2146
index                                                  builtin function         dcl 260 ref 363 1056 1064
initiate_file_                  000066 constant        entry                    external dcl 270 ref 834
initsw                          000331 automatic       bit(1)                   unaligned dcl 161 set ref 328* 808 836*
inner_ring_segment              000212 automatic       bit(1)                   dcl 1859 set ref 2130* 2132* 2191
interpreted_data_fmt                   defined         bit(1)                   unaligned dcl 201 set ref 380* 382* 386* 393* 400*
                                                                                  407* 414* 423* 430* 437* 584 590 599 1207 1291
                                                                                  1369 1410 1448 1456 1474 1610 1696* 1762*
ioa_$ioa_switch                 000074 constant        entry                    external dcl 273 ref 1414 1444 1460 1549 1646
ioa_$rs                         000126 constant        entry                    external dcl 288 ref 1071 1603 1615 1622
ioa_$rsnnl                      000130 constant        entry                    external dcl 288 ref 1296 1298
iocbp                           000332 automatic       pointer                  dcl 162 set ref 327* 1074* 1414* 1444* 1460* 1549*
                                                                                  1606* 1619* 1626* 1646* 1657* 1683* 1739*
iox_$put_chars                  000132 constant        entry                    external dcl 289 ref 1074 1606 1619 1626
iox_$user_output                000056 external static pointer                  dcl 256 ref 327
j                               001270 automatic       fixed bin(18,0)          dcl 1497 in procedure "print_block" set ref 1528*
                                                                                  1530 1532 1535 1537
j                               001236 automatic       fixed bin(18,0)          dcl 1337 in procedure "print_dump" set ref 1422*
                                                                                  1424 1428 1432
k                               001237 automatic       fixed bin(18,0)          dcl 1337 in procedure "print_dump" set ref 1423*
                                                                                  1426 1428
k                               001271 automatic       fixed bin(18,0)          dcl 1497 in procedure "print_block" set ref 1529*
                                                                                  1530 1532
last_ascii                      016377 constant        char(1)                  initial dcl 1111 ref 1130
last_block                      001240 automatic       bit(1)                   unaligned dcl 1338 in procedure "print_dump" set ref
                                                                                  1403* 1470* 1507 1565
last_block                      001127 automatic       bit(1)                   dcl 1195 in procedure "return_dump" set ref 1224*
                                                                                  1230* 1262
last_ebcdic                     016376 constant        char(1)                  initial dcl 1113 ref 1146
length                                                 builtin function         dcl 1906 in procedure "cv_ptr_" ref 1981 1984 1991
                                                                                  1992 1994 1995 2015 2022 2031 2042 2044 2057
length                                                 builtin function         dcl 260 in procedure "ds" ref 1128 1129 1130 1133
                                                                                  1144 1145 1146 1149 1149 1759
length_of_digit_field           001242 automatic       fixed bin(17,0)          dcl 1340 set ref 1387* 1389* 1391* 1615 1622
line_addr                       001144 automatic       fixed bin(17,0)          dcl 1252 in procedure "return_block" set ref 1256*
                                                                                  1257* 1262 1285 1286 1288
line_addr                       001263 automatic       fixed bin(18,0)          dcl 1490 in procedure "print_block" set ref 1504*
                                                                                  1509 1514 1517 1519 1521 1528 1529 1554 1560* 1565
                                                                                  1590 1592 1593 1595 1599 1601 1601 1603* 1608
line_addr_limit                        parameter       fixed bin(18,0)          dcl 1273 in procedure "return_line" ref 1267 1285
line_addr_limit                        parameter       fixed bin(18,0)          dcl 1576 in procedure "print_line" ref 1570 1592
line_format                     000334 automatic       varying char(28)         dcl 163 set ref 1220* 1296* 1298* 1382* 1615* 1622*
line_ptr                               parameter       pointer                  dcl 1087 ref 1081 1128 1128 1129 1130 1130 1133 1138
                                                                                  1144 1144 1145 1146 1146 1149 1149 1155 1161
line_to_dump                    001210 automatic       bit(36)                  array unaligned dcl 1283 in procedure "return_line"
                                                                                  set ref 1286* 1288* 1291 1291 1295 1298
line_to_dump                    001305 automatic       bit(36)                  array unaligned dcl 1581 in procedure "print_line"
                                                                                  set ref 1593* 1595* 1610 1610 1614 1622
linkage_error                   000000 stack reference condition                dcl 213 ref 846 850 2124 2126
linkp                     6     000214 automatic       pointer                  level 2 dcl 1859 set ref 2152
long_fmt                               defined         bit(1)                   unaligned dcl 192 set ref 367* 443* 1364 1397 1657
                                                                                  1691 1751 1825
match_names                     001461 automatic       varying char(32)         array dcl 1638 set ref 1649* 1657*
max_length                      000344 automatic       fixed bin(19,0)          dcl 164 set ref 335* 615 624 648 689 691* 711 716
                                                                                  722 726 728 797* 861 964 1013*
me                              000161 constant        char(14)                 initial array unaligned dcl 242 set ref 748* 797*
                                                                                  810*
min                                                    builtin function         dcl 260 ref 1222 1749 1823
mod                                                    builtin function         dcl 260 ref 1599 1600 1601
mode                      3     000100 automatic       bit(5)                   level 2 packed unaligned dcl 2-1 set ref 984
n_match_names                   001613 automatic       fixed bin(17,0)          dcl 1639 set ref 1649* 1657*
n_subscripts                    001614 automatic       fixed bin(17,0)          dcl 1640 set ref 1649* 1657*
name                            001010 automatic       char(168)                unaligned dcl 1043 set ref 1055* 1056 1057* 1057
                                                                                  1061* 1067* 1069* 1071*
nonprinting_chars               000011 internal static char(33)                 dcl 222 set ref 319* 1133 1150 1156 1678* 1734*
                                                                                  1805*
not_in_read_bracket             000742 stack reference condition                dcl 215 ref 668 671
null                                                   builtin function         dcl 260 ref 336 337 643 810 835 852 960 1657 1657
                                                                                  1812 2090 2122 2128 2201
number_of_digit_fields          001243 automatic       fixed bin(17,0)          dcl 1341 set ref 1397* 1399* 1615 1622
obj_info                        000346 automatic       structure                level 1 dcl 165 set ref 670 670
object_info                            based           structure                level 1 dcl 6-6 in procedure "ds"
object_info                            based           structure                level 1 dcl 4-6 in procedure "cv_ptr_"
object_info_$brief              000222 constant        entry                    external dcl 1894 in procedure "cv_ptr_" ref 2137
object_info_$brief              000144 constant        entry                    external dcl 294 in procedure "ds" ref 670
object_info_version_2                  constant        fixed bin(17,0)          initial dcl 4-60 ref 2136
octal_fmt                              defined         bit(1)                   unaligned dcl 198 set ref 422* 429* 435* 581 596
                                                                                  596* 1215 1377 1699* 1764*
offset_addr                     001264 automatic       fixed bin(18,0)          dcl 1491 set ref 1501* 1559* 1559 1591 1600 1603*
offset_case                     000213 automatic       fixed bin(17,0)          dcl 1859 set ref 1977* 2032* 2037* 2056* 2063 2090
                                                                                  2091 2134 2135 2176
offset_col                      001315 automatic       fixed bin(18,0)          dcl 1582 set ref 1591* 1600* 1615* 1622*
offset_fmt                             defined         bit(1)                   unaligned dcl 188 set ref 451* 463*
oi                              000214 automatic       structure                level 1 dcl 1859 set ref 2137 2137
output_line                     000445 automatic       char(256)                unaligned dcl 172 set ref 1071* 1072 1074 1074 1296*
                                                                                  1298* 1300 1603* 1604 1606 1606 1615* 1617 1619
                                                                                  1619 1622* 1624 1626 1626
output_line_len                 000444 automatic       fixed bin(21,0)          dcl 171 set ref 1071* 1072 1074* 1296* 1298* 1300
                                                                                  1603* 1604 1606* 1615* 1617 1619* 1622* 1624 1626*
output_words                           based           bit(36)                  array unaligned dcl 1277 in procedure "return_line"
                                                                                  set ref 1298*
output_words                           based           bit(36)                  array unaligned dcl 1584 in procedure "print_line"
                                                                                  set ref 1622*
overlay_return                  001072 automatic       char(32)                 unaligned dcl 1098 set ref 1138 1139 1149 1150 1155
                                                                                  1156 1161 1162
p                               000434 automatic       pointer                  dcl 166 set ref 607* 612* 627* 642* 643 645 660*
                                                                                  670* 752 752 763 763 765 765 808* 834* 835 837
                                                                                  849* 852 854* 859 864* 868* 872 880 883 886* 886
                                                                                  1055*
phcs_$initiate                  000070 constant        entry                    external dcl 271 ref 849 2125
prev_addr                       001265 automatic       fixed bin(18,0)          dcl 1492 set ref 1502* 1601 1601 1601 1608*
prev_line                              based           char                     unaligned dcl 1493 ref 1521
prev_line_addr                  001266 automatic       fixed bin(18,0)          dcl 1495 set ref 1503* 1519 1521 1560*
ptr                                                    builtin function         dcl 260 ref 886 2142 2175
raw_data                  0(13) 000732 automatic       bit(1)                   level 2 packed unaligned dcl 1-10 set ref 590
raw_data_fmt                           defined         bit(1)                   unaligned dcl 200 set ref 345* 350* 374* 376* 388*
                                                                                  395* 402* 409* 416* 421* 428* 435* 581* 584 596
                                                                                  1210 1372 1410 1448 1456 1474 1699* 1761*
rb2                             000546 automatic       bit(6)                   unaligned dcl 174 set ref 733 972* 974* 981* 984*
                                                                                  986*
rel                                                    builtin function         dcl 260 ref 1742 1816
rel_offset                      000436 automatic       fixed bin(18,0)          dcl 167 in procedure "ds" set ref 332* 456* 459*
                                                                                  756* 758* 763* 765* 1690* 1702* 1750* 1776* 1824*
                                                                                  1840* 1842*
rel_offset                             parameter       fixed bin(18,0)          dcl 1323 in procedure "print_dump" ref 1309 1501
rel_offset                             parameter       fixed bin(18,0)          dcl 1183 in procedure "return_dump" ref 1169
release_temp_segments_          000062 constant        entry                    external dcl 268 ref 810
requote_string_                 000072 constant        entry                    external dcl 272 ref 769 1844
rest                            000437 automatic       bit(1)                   dcl 168 set ref 331* 378* 593 716
ret_tc                          000440 automatic       fixed bin(21,0)          dcl 169 set ref 340* 346 769 1072 1300 1412 1442
                                                                                  1458 1547 1604 1617 1624 1810* 1812 1814 1844
ret_tp                          000442 automatic       pointer                  dcl 170 set ref 340* 346 769 769 769 1072 1072 1300
                                                                                  1300 1412 1412 1442 1442 1458 1458 1547 1547 1604
                                                                                  1604 1617 1617 1624 1624 1811* 1812 1814 1844 1844
return_arg                             based           varying char             dcl 209 set ref 346* 769* 769 769 1072* 1072 1300*
                                                                                  1300 1412* 1412 1442* 1442 1458* 1458 1547* 1547
                                                                                  1604* 1604 1617* 1617 1624* 1624 1814* 1844* 1844
reverse                                                builtin function         dcl 260 ref 1980
ring0_get_$definition           000112 constant        entry                    external dcl 281 ref 660 2140
ring0_get_$name                 000170 constant        entry                    external dcl 1049 in procedure "print_header" ref
                                                                                  1055
ring0_get_$name                 000114 constant        entry                    external dcl 282 in procedure "ds" ref 612 2105
ring0_get_$segptr               000110 constant        entry                    external dcl 280 ref 642 2077
ring_brackets            10(18) 000100 automatic       bit(6)                   array level 2 packed unaligned dcl 2-1 set ref 974
ring_zero_peek_                 000116 constant        entry                    external dcl 283 ref 752
ring_zero_peek_$get_max_length_ptr
                                000120 constant        entry                    external dcl 284 ref 1013
rtrim                                                  builtin function         dcl 260 ref 769 769 1984 1991 1995 2042 2044
rz_call                         000545 automatic       bit(1)                   unaligned dcl 173 set ref 304* 312* 548 610 640 735
                                                                                  748 797 810 843 981
search                                                 builtin function         dcl 260 ref 1980 2013
seg_name                               based           char                     unaligned dcl 208 set ref 642* 649 832* 854* 864*
seg_num                         000550 automatic       bit(1)                   unaligned dcl 176 set ref 328* 545* 605 887*
seg_ptr                                parameter       pointer                  dcl 1179 in procedure "return_dump" ref 1169 1234
                                                                                  1286
seg_ptr                                parameter       pointer                  dcl 1318 in procedure "print_dump" ref 1309 1428
                                                                                  1428 1432 1521 1521 1532 1532 1537 1593 1648
seg_wds                                based           bit(36)                  array unaligned dcl 1327 in procedure "print_dump"
                                                                                  set ref 1428 1428 1432 1532 1532 1537 1593 1648
seg_wds                                based           bit(36)                  array unaligned dcl 1187 in procedure "return_dump"
                                                                                  ref 1286
segment_id                             based           char                     unaligned dcl 1883 set ref 1991 2008 2010 2013 2015
                                                                                  2022 2069* 2075* 2077* 2082* 2088 2088 2088 2146*
segno                           000547 automatic       fixed bin(18,0)          dcl 175 in procedure "ds" set ref 538* 541 546 607
                                                                                  608 619 645* 837* 859* 872* 877 1013 1013 1053
                                                                                  1059
segno                           000122 automatic       fixed bin(35,0)          dcl 1859 in procedure "cv_ptr_" set ref 2082* 2087
                                                                                  2102* 2103 2108
segp                            000302 automatic       pointer                  dcl 1859 set ref 2099* 2100* 2105* 2119* 2122 2125*
                                                                                  2128 2129 2191*
shfx                            001241 automatic       fixed bin(17,0)          dcl 1339 set ref 1367* 1603
short_fmt                              defined         bit(1)                   unaligned dcl 189 set ref 368* 442* 1597 1691 1751
                                                                                  1825
short_format                    000023 internal static char(8)                  initial array unaligned dcl 1347 set ref 1603*
statp                    10     000214 automatic       pointer                  level 2 dcl 1859 set ref 2156
string                                                 builtin function         dcl 260 in procedure "ds" set ref 326* 1693* 1755*
                                                                                  1829*
string                                 parameter       char                     unaligned dcl 1855 in procedure "cv_ptr_" set ref
                                                                                  1852 1979 1980 1981 1984 1989 1992 1993 1994
string_array                           based           char(1)                  array unaligned dcl 1883 set ref 1989 1993
structure_find_$pathname        000150 constant        entry                    external dcl 298 ref 1652
structure_find_$search          000152 constant        entry                    external dcl 300 ref 1655
structure_name                  000551 automatic       varying char(256)        dcl 177 set ref 512* 797* 1649
structure_path                  000652 automatic       char(168)                unaligned dcl 178 set ref 522* 797* 1652*
structure_ptr                   001616 automatic       pointer                  dcl 1641 set ref 1648* 1657* 1657*
structure_ref_$parse            000154 constant        entry                    external dcl 301 ref 1649
subscripts                      001620 automatic       fixed bin(24,0)          array dcl 1642 set ref 1649* 1657*
substr                                                 builtin function         dcl 260 set ref 319 319 1057 1069 1072 1130 1130*
                                                                                  1146 1146* 1300 1367 1368 1604 1617 1624 1678 1678
                                                                                  1734 1734 1805 1805
suppress_dup_fmt                       defined         bit(1)                   unaligned dcl 202 set ref 350* 370* 372* 1545 1552
                                                                                  1761*
symbol_ptr                      001660 automatic       pointer                  dcl 1643 set ref 1652* 1655* 1657*
symbp                    12     000214 automatic       pointer                  level 2 dcl 1859 set ref 2154
sys_info$max_seg_size           000242 external static fixed bin(35,0)          dcl 1908 ref 2170
tail_format                     000000 constant        varying char(15)         initial array dcl 1357 ref 1382
tailx                           001124 automatic       fixed bin(17,0)          dcl 1192 in procedure "return_dump" set ref 1207*
                                                                                  1209* 1210* 1210 1213* 1213 1218* 1218 1220
tailx                           001244 automatic       fixed bin(17,0)          dcl 1342 in procedure "print_dump" set ref 1369*
                                                                                  1371* 1372* 1372 1375* 1375 1380* 1380 1382
tc                              000724 automatic       fixed bin(17,0)          dcl 179 set ref 338* 363 365 365 370 370 372 372 374
                                                                                  376 376 378 380 380 382 382 384 384 384 391 398
                                                                                  405 412 419 426 433 433 440 440 445 445 445 447
                                                                                  447 447 449 449 456 456 463 463 465 465 467 467
                                                                                  472 472 477 477 484 484 489 496 496 502 507 512
                                                                                  517 522 528 538 538 543 556 562 562 569 569 631*
                                                                                  797 797 829* 918* 920*
tca                             000725 automatic       fixed bin(17,0)          dcl 180 set ref 489* 543* 556* 631 642 642 649 829
                                                                                  832 832 854 854 864 864
temp_ascii                             based           char                     unaligned dcl 1106 set ref 1128* 1130* 1133
temp_ebcdic9                           based           char                     unaligned dcl 1107 set ref 1144* 1146* 1149*
temp_overlay                    001103 automatic       char(32)                 unaligned dcl 1105 set ref 1128 1130 1133 1144 1146
                                                                                  1149
terminate_file_                 000122 constant        entry                    external dcl 286 ref 808
textp                     2     000214 automatic       pointer                  level 2 dcl 1859 set ref 2150
tp                              000726 automatic       pointer                  dcl 181 set ref 337* 363 365 365 370 370 372 372 374
                                                                                  376 376 378 380 380 382 382 384 384 384 391 398
                                                                                  405 412 419 426 433 433 440 440 445 445 445 447
                                                                                  447 447 449 449 456 463 463 465 465 467 467 472
                                                                                  472 477 484 484 490 496 496 502 507 512 517 522
                                                                                  528 538 544 557 562 569 630* 797 830* 918* 920*
tpa                             000730 automatic       pointer                  dcl 182 set ref 490* 544* 557* 630 642 649 830 832
                                                                                  854 864
translate                                              builtin function         dcl 260 ref 1133 1150 1156
translate_bytes_to_hex9_        000136 constant        entry                    external dcl 291 ref 1295 1614
translation                            parameter       varying char(32)         dcl 1088 in procedure "translate_line_to_dump" set
                                                                                  ref 1081 1124* 1133* 1139* 1150* 1156* 1162*
translation                     001317 automatic       varying char(32)         dcl 1586 in procedure "print_line" set ref 1610*
                                                                                  1615* 1622*
translation                     001156 automatic       varying char(32)         dcl 1279 in procedure "return_line" set ref 1291*
                                                                                  1296* 1298*
type                            000100 automatic       bit(2)                   level 2 packed unaligned dcl 2-1 set ref 972
unspec                                                 builtin function         dcl 260 set ref 1684* 1740*
unsubscripted_name              001662 automatic       char(256)                unaligned dcl 1644 set ref 1649* 1652* 1655*
value                     1            based           bit(18)                  level 2 in structure "definition" packed unaligned
                                                                                  dcl 3-12 in procedure "cv_ptr_" ref 2150 2152 2154
                                                                                  2156
value                     1            based           bit(18)                  level 2 in structure "definition" packed unaligned
                                                                                  dcl 5-12 in procedure "ds" ref 676
verify                                                 builtin function         dcl 260 ref 528 1996 2008 2033 2045 2050
version_number                  000214 automatic       fixed bin(17,0)          level 2 dcl 1859 set ref 2136*
wds_in_line                            parameter       fixed bin(17,0)          dcl 1272 in procedure "return_line" set ref 1267
                                                                                  1291* 1295 1295 1296* 1296 1298* 1298
wds_in_line                     001245 automatic       fixed bin(17,0)          dcl 1343 in procedure "print_dump" set ref 1364*
                                                                                  1366* 1504 1504 1509* 1509 1514 1517 1521 1521
                                                                                  1527 1528 1554* 1554 1559
wds_in_line                            parameter       fixed bin(17,0)          dcl 1575 in procedure "print_line" set ref 1570
                                                                                  1610* 1614 1614 1615* 1615 1615 1622* 1622 1622
wds_in_line                            parameter       fixed bin(17,0)          dcl 1086 in procedure "translate_line_to_dump" ref
                                                                                  1081 1128 1128 1129 1130 1130 1133 1138 1138 1138
                                                                                  1138 1139 1144 1144 1145 1146 1146 1149 1149 1149
                                                                                  1149 1150 1155 1155 1155 1155 1156 1161 1161 1161
                                                                                  1161 1162
wds_in_line                     001130 automatic       fixed bin(17,0)          dcl 1196 in procedure "return_dump" set ref 1205*
                                                                                  1256 1256 1257* 1257
word                            000123 automatic       fixed bin(35,0)          dcl 1859 set ref 2165* 2170 2170 2175
word_mask                              based           fixed bin(35,0)          array dcl 1188 ref 1235
word_offset                            based           char                     unaligned dcl 1883 set ref 1995 1996 2031 2033 2044
                                                                                  2057 2140* 2146* 2148* 2165*
word_offset_array                      based           char(1)                  array unaligned dcl 1883 set ref 1998 2035 2038 2040
wordno                                                 builtin function         dcl 260 ref 880 883
wrd_addr                        001316 automatic       fixed bin(18,0)          dcl 1583 in procedure "print_line" set ref 1592*
                                                                                  1593 1593 1593 1595*
wrd_addr                        001207 automatic       fixed bin(18,0)          dcl 1282 in procedure "return_line" set ref 1285*
                                                                                  1286 1286 1286 1288*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 8-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 8-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 8-33
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 8-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 8-36
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 8-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 8-36
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 8-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 8-36
REW_ACCESS                             internal static bit(3)                   initial unaligned dcl 8-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 8-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 8-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 8-36
RW_ACCESS                              internal static bit(3)                   initial unaligned dcl 8-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 8-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 8-36
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 8-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 8-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 8-30
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 8-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 8-36
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 8-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 8-36
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 8-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 8-36
TERM_FILE_BC                           internal static bit(2)                   initial unaligned dcl 7-12
TERM_FILE_DELETE                       internal static bit(5)                   initial unaligned dcl 7-17
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial unaligned dcl 7-16
TERM_FILE_TRUNC                        internal static bit(1)                   initial unaligned dcl 7-11
TERM_FILE_TRUNC_BC                     internal static bit(2)                   initial unaligned dcl 7-13
TERM_FILE_TRUNC_BC_TERM                internal static bit(3)                   initial unaligned dcl 7-15
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 8-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 8-36
link_type                              internal static bit(2)                   initial dcl 2-1
msf_type                               internal static bit(2)                   initial dcl 2-1
object_info_version_2                  internal static fixed bin(17,0)          initial dcl 6-60
segment_type                           internal static bit(2)                   initial dcl 2-1
terminate_file_switches                based           structure                level 1 packed unaligned dcl 7-4

NAMES DECLARED BY EXPLICIT CONTEXT.
CLEANUP                         005043 constant        label                    dcl 772 ref 800
COMMON_CODE                     001606 constant        label                    dcl 314 ref 306
ERROR                           015003 constant        entry                    internal dcl 2197 ref 2014 2017 2024 2028 2038 2052
                                                                                  2059 2065 2070 2078 2085 2093 2106 2114 2124 2128
                                                                                  2141 2144 2149 2160 2168 2173 2180 2185
NON_CONTROL_ARG                 003146 constant        label                    dcl 535 ref 528
OFFSET                          014335 constant        label                    dcl 2134 ref 2095 2115
PRINT_ERROR                     006102 constant        entry                    internal dcl 776 ref 353 480 482 494 505 515 525 530
                                                                                  541 550 563 570 572 575 584 587 590 593 602 613
                                                                                  617 632 661 665 668 672 675 722 724 737 749 753
                                                                                  846 855 865 869 992 1014 1651 1656 1660
RETURN_TO_CALLER                014762 constant        label                    dcl 2191 ref 2202
TRY_SEGNAME_AS_VIRTUAL_POINTER  006550 constant        label                    dcl 843 ref 835
cleaner_upper                   006330 constant        entry                    internal dcl 805 ref 356 772
cv_ptr_                         013104 constant        entry                    internal dcl 1852 ref 854 864
ds                              001551 constant        entry                    external dcl 12
dump_seg_                       005056 constant        entry                    external dcl 1673
dump_segment                    001560 constant        entry                    external dcl 12
dump_segment_                   005225 constant        entry                    external dcl 1729
dump_segment_$string            005543 constant        entry                    external dcl 1800
get_arg_ptr                     007111 constant        entry                    internal dcl 892 ref 362 454 476 488 500 511 521
print_block                     011524 constant        entry                    internal dcl 1479 ref 1410 1448 1456 1474
print_dump                      010742 constant        entry                    internal dcl 1309 ref 758 765 1702 1776 1840
print_header                    007364 constant        entry                    internal dcl 1022 ref 1361
print_line                      012065 constant        entry                    internal dcl 1570 ref 1509 1554 1565
print_structure                 012563 constant        entry                    internal dcl 1633 ref 1408 1446 1454 1472
process_name                    006426 constant        entry                    internal dcl 815 ref 651 653
return_block                    010430 constant        entry                    internal dcl 1247 ref 1227 1242
return_dump                     010256 constant        entry                    internal dcl 1169 ref 756 763 1842
return_line                     010504 constant        entry                    internal dcl 1267 ref 1257 1262
ring_zero_dump                  001577 constant        entry                    external dcl 308
rzd                             001570 constant        entry                    external dcl 308
set_curlng_and_rb               007152 constant        entry                    internal dcl 926 ref 636 838 873
set_max_from_SDW                007321 constant        entry                    internal dcl 998 ref 614 623 647 860 963
translate_line_to_dump          007641 constant        entry                    internal dcl 1081 ref 1291 1610

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     17546       20012   16421       17556
Length     20602   16421       244         554    1125          24

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ds                                 1454 external procedure  is an external procedure.  
on unit on line 356                  64 on unit               
on unit on line 668                  74 on unit               
PRINT_ERROR                         146 internal procedure  is called by several nonquick procedures.  
cleaner_upper                        86 internal procedure  is called by several nonquick procedures.  
process_name                        148 internal procedure  enables or reverts conditions.  
on unit on line 846                  74 on unit               
get_arg_ptr                             internal procedure  shares stack frame of external procedure ds.  
set_curlng_and_rb                   106 internal procedure  is called by several nonquick procedures.  
set_max_from_SDW                     75 internal procedure  is called by several nonquick procedures.  
print_header                            internal procedure  shares stack frame of external procedure ds.  
translate_line_to_dump                  internal procedure  shares stack frame of external procedure ds.  
return_dump                             internal procedure  shares stack frame of external procedure ds.  
return_block                            internal procedure  shares stack frame of external procedure ds.  
return_line                             internal procedure  shares stack frame of external procedure ds.  
print_dump                              internal procedure  shares stack frame of external procedure ds.  
print_block                             internal procedure  shares stack frame of external procedure ds.  
print_line                              internal procedure  shares stack frame of external procedure ds.  
print_structure                         internal procedure  shares stack frame of external procedure ds.  
cv_ptr_                             280 internal procedure  enables or reverts conditions.  
on unit on line 2124                 64 on unit               
ERROR                                64 internal procedure  is called by several nonquick procedures.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 first_time                  ds
000011 nonprinting_chars           ds
000022 hcscnt                      ds
000023 short_format                print_dump

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cv_ptr_                  000100 Lbit_offset                 cv_ptr_
                         000101 Lsegment_id                 cv_ptr_
                         000102 Lword_offset                cv_ptr_
                         000104 Pbit_offset                 cv_ptr_
                         000106 Psegment_id                 cv_ptr_
                         000110 Pword_offset                cv_ptr_
                         000112 Pdelim                      cv_ptr_
                         000114 P                           cv_ptr_
                         000116 Pdef                        cv_ptr_
                         000120 bc                          cv_ptr_
                         000121 bit                         cv_ptr_
                         000122 segno                       cv_ptr_
                         000123 word                        cv_ptr_
                         000124 code                        cv_ptr_
                         000125 dir                         cv_ptr_
                         000177 ent                         cv_ptr_
                         000207 entry_point_offset          cv_ptr_
                         000210 i                           cv_ptr_
                         000211 id_case                     cv_ptr_
                         000212 inner_ring_segment          cv_ptr_
                         000213 offset_case                 cv_ptr_
                         000214 oi                          cv_ptr_
                         000302 segp                        cv_ptr_
ds                       000100 active_func                 ds
                         000101 arg_for_header_given        ds
                         000102 argc                        ds
                         000103 bit_count                   ds
                         000104 block                       ds
                         000105 buffer                      ds
                         000205 code                        ds
                         000206 count                       ds
                         000207 cur_length                  ds
                         000210 defn_ptr                    ds
                         000212 dir_len                     ds
                         000213 dirname                     ds
                         000265 ename                       ds
                         000275 entry_point_name            ds
                         000305 entry_point_offset          ds
                         000306 entry_type                  ds
                         000310 entry_var                   ds
                         000314 first                       ds
                         000315 have_count                  ds
                         000316 have_entry_point            ds
                         000317 have_first                  ds
                         000320 have_name                   ds
                         000321 have_structure              ds
                         000322 have_structure_path         ds
                         000324 hcsp                        ds
                         000326 hc_seg                      ds
                         000327 highseg                     ds
                         000330 i                           ds
                         000331 initsw                      ds
                         000332 iocbp                       ds
                         000334 line_format                 ds
                         000344 max_length                  ds
                         000346 obj_info                    ds
                         000434 p                           ds
                         000436 rel_offset                  ds
                         000437 rest                        ds
                         000440 ret_tc                      ds
                         000442 ret_tp                      ds
                         000444 output_line_len             ds
                         000445 output_line                 ds
                         000545 rz_call                     ds
                         000546 rb2                         ds
                         000547 segno                       ds
                         000550 seg_num                     ds
                         000551 structure_name              ds
                         000652 structure_path              ds
                         000724 tc                          ds
                         000725 tca                         ds
                         000726 tp                          ds
                         000730 tpa                         ds
                         000732 dump_segment_format_structure
                                                            ds
                         001002 date_time                   print_header
                         001010 name                        print_header
                         001062 dlen                        print_header
                         001072 overlay_return              translate_line_to_dump
                         001102 i                           translate_line_to_dump
                         001103 temp_overlay                translate_line_to_dump
                         001124 tailx                       return_dump
                         001125 block_addr                  return_dump
                         001126 block_lng                   return_dump
                         001127 last_block                  return_dump
                         001130 wds_in_line                 return_dump
                         001132 blockp                      return_dump
                         001144 line_addr                   return_block
                         001145 first_line                  return_block
                         001156 translation                 return_line
                         001167 hex9_line                   return_line
                         001207 wrd_addr                    return_line
                         001210 line_to_dump                return_line
                         001230 block_addr                  print_dump
                         001231 dup_block                   print_dump
                         001232 first_block                 print_dump
                         001233 first_dup_block             print_dump
                         001234 hfx                         print_dump
                         001235 i                           print_dump
                         001236 j                           print_dump
                         001237 k                           print_dump
                         001240 last_block                  print_dump
                         001241 shfx                        print_dump
                         001242 length_of_digit_field       print_dump
                         001243 number_of_digit_fields      print_dump
                         001244 tailx                       print_dump
                         001245 wds_in_line                 print_dump
                         001260 dup_line                    print_block
                         001261 first_dup_line              print_block
                         001262 first_line                  print_block
                         001263 line_addr                   print_block
                         001264 offset_addr                 print_block
                         001265 prev_addr                   print_block
                         001266 prev_line_addr              print_block
                         001267 i                           print_block
                         001270 j                           print_block
                         001271 k                           print_block
                         001304 addr_col                    print_line
                         001305 line_to_dump                print_line
                         001315 offset_col                  print_line
                         001316 wrd_addr                    print_line
                         001317 translation                 print_line
                         001330 hex9_line                   print_line
                         001360 code                        print_structure
                         001361 full_name                   print_structure
                         001461 match_names                 print_structure
                         001613 n_match_names               print_structure
                         001614 n_subscripts                print_structure
                         001616 structure_ptr               print_structure
                         001620 subscripts                  print_structure
                         001660 symbol_ptr                  print_structure
                         001662 unsubscripted_name          print_structure
set_curlng_and_rb        000100 branch_status               set_curlng_and_rb

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             alloc_char_temp     cat_realloc_chars   call_ent_var_desc   call_ext_out_desc   call_ext_out
call_int_this       call_int_other_desc call_int_other      return_mac          tra_ext_1           mpfx2
mdfx1               enable_op           shorten_stack       ext_entry           ext_entry_desc      int_entry
int_entry_desc      set_chars_eis       translate_3         clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
active_fnc_err_               bcd_to_ascii_                 com_err_                      comp_8_to_ascii_
cu_$af_arg_ptr                cu_$af_return_arg             cu_$arg_ptr                   cv_dec_check_
cv_oct_check_                 cv_oct_check_                 date_time_                    display_data_$for_azm
ebcdic8_to_ascii_             ebcdic_to_ascii_              expand_pathname_              expand_pathname_
get_definition_               get_definition_               get_ring_                     get_temp_segments_
hcs_$fs_get_path_name         hcs_$fs_get_path_name         hcs_$fs_get_seg_ptr           hcs_$high_low_seg_count
hcs_$initiate_count           hcs_$status_long              hcs_$status_minf              hcs_$terminate_noname
initiate_file_                ioa_$ioa_switch               ioa_$rs                       ioa_$rsnnl
iox_$put_chars                object_info_$brief            object_info_$brief            phcs_$initiate
release_temp_segments_        requote_string_               ring0_get_$definition         ring0_get_$name
ring0_get_$name               ring0_get_$segptr             ring_zero_peek_
ring_zero_peek_$get_max_length_ptr                          structure_find_$pathname      structure_find_$search
structure_ref_$parse          terminate_file_               translate_bytes_to_hex9_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
active_all_rings_data_$stack_base_segno                     error_table_$bad_class_def    error_table_$bad_conversion
error_table_$badopt           error_table_$bigarg           error_table_$dirseg           error_table_$entlong
error_table_$improper_data_format                           error_table_$inconsistent     error_table_$lower_ring
error_table_$lower_ring       error_table_$msf              error_table_$no_s_permission  error_table_$noarg
error_table_$out_of_bounds    error_table_$root             error_table_$too_many_args    iox_$user_output
sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     12 001550       304 001565       306 001566       308 001567       312 001604       314 001606       317 001611
    319 001621       320 001630       326 001631       327 001632       328 001635       331 001647       332 001650
    333 001651       334 001652       335 001653       336 001654       337 001656       338 001657       340 001660
    342 001674       344 001676       345 001700       346 001702       347 001703       349 001704       350 001705
    353 001713       356 001730       361 001752       362 001761       363 001763       365 001777       367 002013
    368 002015       369 002017       370 002020       372 002035       374 002050       376 002057       378 002072
    380 002101       382 002114       384 002127       386 002143       387 002147       388 002157       390 002163
    391 002164       393 002170       394 002174       395 002204       397 002210       398 002211       400 002215
    401 002221       402 002227       404 002233       405 002234       407 002240       408 002244       409 002252
    411 002256       412 002257       414 002263       415 002267       416 002275       418 002301       419 002302
    421 002306       422 002312       423 002316       425 002322       426 002323       428 002327       429 002333
    430 002337       432 002343       433 002344       435 002354       436 002360       437 002364       439 002370
    440 002371       442 002403       443 002405       444 002407       445 002410       447 002431       449 002452
    451 002464       452 002466       454 002471       456 002475       457 002523       459 002527       462 002530
    463 002531       465 002546       467 002563       469 002575       470 002577       471 002601       472 002602
    474 002614       476 002617       477 002623       478 002651       480 002655       481 002670       482 002671
    483 002704       484 002705       486 002715       488 002720       489 002724       490 002726       491 002730
    492 002732       493 002733       494 002734       495 002747       496 002750       498 002760       500 002763
    501 002767       502 002771       503 002776       504 002777       505 003000       506 003013       507 003014
    508 003020       510 003023       511 003025       512 003031       513 003042       514 003043       515 003044
    516 003057       517 003060       518 003064       520 003067       521 003071       522 003075       523 003102
    524 003103       525 003104       526 003117       528 003120       530 003132       532 003145       535 003146
    538 003150       539 003176       541 003200       542 003215       543 003217       544 003221       545 003223
    546 003224       548 003230       550 003235       553 003250       555 003251       556 003253       557 003255
    559 003257       560 003260       562 003262       563 003310       565 003325       566 003327       567 003330
    569 003332       570 003360       572 003375       573 003412       574 003414       575 003415       577 003430
    581 003432       584 003455       587 003501       590 003520       593 003543       596 003562       599 003602
    602 003626       605 003644       607 003646       608 003652       610 003655       612 003657       613 003703
    614 003717       615 003723       616 003725       617 003726       618 003741       619 003742       621 003744
    622 003747       623 003752       624 003756       625 003760       627 003761       628 004011       630 004013
    631 004015       632 004017       634 004031       636 004040       638 004044       640 004045       642 004047
    643 004077       645 004103       646 004107       647 004111       648 004115       649 004117       650 004124
    651 004125       652 004131       653 004132       656 004136       658 004140       660 004142       661 004177
    662 004213       664 004214       665 004254       668 004270       670 004320       671 004337       672 004340
    674 004354       675 004404       676 004420       678 004424       680 004430       682 004432       683 004433
    685 004435       686 004437       689 004441       691 004443       694 004445       696 004451       697 004452
    700 004454       702 004460       703 004463       706 004465       708 004467       710 004473       711 004474
    712 004476       713 004500       714 004501       716 004503       718 004510       719 004512       721 004514
    722 004516       724 004535       726 004552       728 004556       730 004561       733 004567       735 004605
    737 004612       743 004625       745 004627       748 004635       749 004665       752 004701       753 004722
    756 004736       758 004743       760 004745       763 004746       765 004757       769 004765       772 005043
    774 005050      1673 005051      1676 005072      1678 005075      1679 005103      1682 005104      1683 005110
   1684 005114      1685 005115      1686 005121      1687 005123      1688 005125      1689 005127      1690 005131
   1691 005132      1693 005156      1694 005157      1695 005161      1696 005162      1699 005170      1700 005174
   1702 005176      1703 005216      1729 005217      1732 005250      1734 005253      1735 005261      1738 005262
   1739 005266      1740 005272      1741 005273      1742 005303      1743 005311      1744 005313      1746 005320
   1747 005322      1749 005327      1750 005333      1751 005335      1755 005405      1756 005406      1759 005410
   1761 005413      1762 005417      1764 005440      1766 005450      1769 005454      1770 005504      1772 005506
   1773 005511      1776 005514      1777 005534      1800 005535      1803 005566      1805 005571      1806 005577
   1809 005600      1810 005602      1811 005605      1812 005610      1814 005615      1815 005616      1816 005626
   1817 005633      1818 005635      1820 005642      1821 005644      1823 005651      1824 005655      1825 005657
   1829 005727      1830 005730      1833 005732      1834 005762      1836 005764      1837 005767      1840 005772
   1842 006016      1844 006034      1846 006077       776 006101       782 006107       784 006117       785 006123
    786 006127       787 006132       788 006133       789 006172       792 006204       793 006210       796 006213
    797 006223       800 006324       805 006327       808 006335       810 006367       812 006424       815 006425
    829 006433       830 006436       832 006440       833 006466       834 006471       835 006527       836 006534
    837 006536       838 006542       841 006547       843 006550       846 006552       849 006603       850 006646
    852 006647       854 006654       855 006700       859 006716       860 006723       861 006730       862 006733
    864 006734       865 006760       868 006776       869 007030       872 007046       873 007053       877 007060
    880 007067       883 007075       884 007100       886 007103       887 007105       889 007110       892 007111
    918 007113       920 007133       922 007150       926 007151       960 007157       961 007221       963 007226
    964 007233       965 007236       966 007237       969 007243       970 007247       972 007253       974 007261
    979 007265       981 007270       984 007274       986 007302       991 007303       992 007304       994 007317
    998 007320      1013 007326      1014 007345      1017 007363      1022 007364      1052 007365      1053 007404
   1055 007410      1056 007434      1057 007444      1058 007460      1059 007462      1061 007464      1062 007467
   1064 007470      1065 007500      1067 007503      1069 007517      1070 007545      1071 007546      1072 007603
   1074 007621      1078 007640      1081 007641      1124 007643      1126 007645      1128 007652      1129 007661
   1130 007671      1132 007704      1133 007706      1134 007734      1136 007736      1138 007741      1139 007771
   1140 010004      1142 010005      1144 010010      1145 010017      1146 010027      1148 010042      1149 010044
   1150 010072      1151 010120      1153 010122      1155 010125      1156 010156      1157 010205      1159 010207
   1161 010212      1162 010242      1166 010255      1169 010256      1205 010260      1207 010262      1209 010272
   1210 010273      1213 010304      1215 010312      1217 010315      1218 010316      1220 010320      1222 010331
   1224 010336      1226 010337      1227 010362      1228 010363      1230 010366      1232 010370      1234 010372
   1235 010377      1237 010412      1238 010415      1239 010420      1240 010421      1242 010426      1244 010427
   1247 010430      1255 010431      1256 010432      1257 010456      1258 010464      1262 010467      1264 010503
   1267 010504      1285 010506      1286 010515      1288 010536      1289 010541      1291 010543      1293 010563
   1295 010566      1296 010611      1297 010657      1298 010660      1300 010726      1302 010741      1309 010742
   1361 010744      1364 010750      1366 010762      1367 010764      1368 010767      1369 010772      1371 011000
   1372 011001      1375 011012      1377 011020      1379 011023      1380 011024      1382 011026      1387 011061
   1389 011070      1391 011076      1397 011100      1399 011105      1401 011107      1402 011111      1403 011112
   1404 011113      1405 011114      1406 011140      1408 011142      1410 011145      1412 011156      1414 011171
   1415 011210      1416 011211      1418 011212      1420 011222      1421 011224      1422 011233      1423 011240
   1424 011243      1426 011250      1428 011252      1430 011267      1432 011270      1437 011301      1438 011303
   1439 011304      1440 011306      1442 011312      1444 011361      1445 011405      1446 011406      1448 011411
   1450 011422      1452 011423      1454 011425      1456 011430      1458 011441      1460 011454      1461 011473
   1466 011475      1470 011500      1471 011502      1472 011507      1474 011512      1663 011523      1479 011524
   1499 011525      1500 011527      1501 011530      1502 011533      1503 011535      1504 011536      1505 011560
   1507 011562      1509 011566      1510 011574      1512 011575      1514 011576      1516 011606      1517 011610
   1519 011614      1521 011617      1523 011641      1525 011642      1527 011643      1528 011653      1529 011657
   1530 011662      1532 011672      1534 011707      1535 011710      1537 011712      1541 011723      1543 011725
   1544 011726      1545 011730      1547 011741      1549 012000      1550 012020      1551 012021      1552 012022
   1554 012026      1555 012034      1559 012036      1560 012040      1561 012042      1565 012045      1567 012064
   1570 012065      1590 012067      1591 012071      1592 012073      1593 012103      1595 012124      1596 012127
   1597 012131      1599 012134      1600 012140      1601 012143      1603 012156      1604 012210      1606 012226
   1608 012245      1610 012247      1612 012267      1614 012272      1615 012315      1617 012402      1619 012420
   1620 012437      1622 012440      1624 012525      1626 012543      1629 012562      1633 012563      1646 012564
   1648 012612      1649 012620      1651 012673      1652 012710      1655 012741      1656 012762      1657 012776
   1660 013066      1661 013102      1852 013103      1974 013117      1975 013121      1976 013123      1977 013125
   1979 013127      1980 013131      1981 013145      1982 013153      1983 013154      1984 013156      1985 013170
   1986 013172      1987 013173      1989 013174      1990 013201      1991 013203      1992 013215      1993 013221
   1994 013224      1995 013227      1996 013240      1997 013253      1998 013255      1999 013261      2001 013265
   2003 013266      2004 013270      2008 013271      2010 013310      2013 013316      2014 013337      2015 013346
   2016 013351      2017 013354      2019 013360      2020 013361      2021 013363      2022 013365      2023 013370
   2024 013372      2026 013376      2027 013377      2028 013402      2031 013406      2032 013410      2033 013412
   2034 013426      2035 013430      2036 013434      2037 013437      2038 013441      2040 013451      2041 013455
   2042 013461      2043 013472      2044 013475      2045 013507      2046 013522      2047 013524      2048 013530
   2050 013534      2051 013547      2052 013552      2054 013556      2056 013557      2057 013561      2058 013564
   2059 013567      2063 013573      2064 013606      2065 013611      2068 013615      2069 013620      2070 013650
   2071 013656      2074 013657      2075 013661      2076 013705      2077 013707      2078 013737      2080 013745
   2082 013746      2083 013771      2084 013773      2085 013776      2087 014002      2088 014006      2090 014024
   2091 014033      2092 014035      2093 014040      2095 014044      2099 014045      2100 014047      2101 014101
   2102 014103      2103 014107      2105 014112      2106 014136      2107 014144      2108 014145      2110 014147
   2111 014150      2112 014153      2113 014156      2114 014157      2115 014163      2119 014164      2122 014226
   2124 014232      2125 014254      2126 014316      2128 014317      2129 014327      2130 014331      2131 014333
   2132 014334      2134 014335      2135 014341      2136 014343      2137 014345      2138 014364      2140 014370
   2141 014430      2142 014436      2143 014442      2144 014443      2146 014452      2148 014513      2149 014545
   2150 014553      2152 014566      2154 014576      2156 014606      2159 014616      2160 014621      2163 014625
   2165 014626      2166 014651      2167 014653      2168 014656      2170 014662      2172 014670      2173 014673
   2175 014677      2176 014703      2177 014706      2178 014731      2179 014733      2180 014736      2182 014742
   2184 014747      2185 014752      2187 014756      2191 014762      2195 014776      2197 015002      2200 015010
   2201 015014      2202 015016


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
