	COMPILATION LISTING OF SEGMENT tape_nstd_
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/04/82  1638.5 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* format: style3,linecom,ifthenstmt,indthenelse,^indnoniterdo,indend,dclind5,idind32 */
       12 
       13 tape_nstd_attach:
       14      proc (iocb_ptr, args, loud_sw, arg_code);
       15 
       16 /*
       17*
       18*   tape_nstd_ created 05/03/76 by Richard Bratt
       19*
       20*   This program is a temporary dim.  It is intended to serve as a rough iox_ writearound to
       21*   the ios_ dim nstd_.  This dim evolved from repeated attempts to bash ntape_ into usefulness.
       22*   When the smoke cleared little remained of ntape_; hence the new name, tape_nstd_.
       23*   This dim makes no pretense at being pretty or clever.
       24*
       25*   Last modified:
       26*   *	09/19/77 by R.J.C. Kissel to get buffer size from a control argument,
       27*   *		and to add the entry max_buf_size to return the buffer size.
       28*   *	11/01/77 by M. R. Jordan to fix forward_record control call.
       29*   *	04/07/78 by M. R. Jordan for major overhaul.  Changes included:
       30*   *		adding -density control argument, implementing all
       31*   *		nstd control orders, and changes to -block processing
       32*   *		such that nstd_ now handles it.
       33*   *      01/3/79  by Maria Bozzuto to add -com control argument.
       34*   *	4/79     by R.J.C. Kissel to add 6250 bpi support.
       35*   *	05/10/79 by C. D. Tavares to add name canonicalization support.
       36*   *	4/82     by J. A. Bush to compile with iocb.incl.pl1
       37*
       38*   NOTES:
       39*
       40*   * Since this dim does not copy buffers and since it calls nstd_ directly, bufptr
       41*   * in the read and write calls must be word aligned. In addition, buflen must be 0 modulo 4
       42*   * for write calls.
       43*
       44**/
       45 
       46 /* Parameters. */
       47 
       48 dcl  actlen		       fixed (21);
       49 dcl  args			       (*) char (*) varying;
       50 dcl  buflen		       fixed (21);
       51 dcl  bufptr		       ptr;
       52 dcl  extend_bit		       bit (1) aligned;
       53 dcl  iocb_ptr		       ptr;
       54 dcl  loud_sw		       bit (1) aligned;
       55 dcl  mode			       fixed;
       56 dcl  arg_code		       fixed bin (35);
       57 
       58 /* Automatic. */
       59 
       60 dcl  actual_iocb_ptr	       ptr;
       61 dcl  density		       char (9) varying;
       62 dcl  block		       char (13) varying;
       63 dcl  pic			       pic "zzzzz9";
       64 dcl  blkptr		       ptr;
       65 dcl  block_size		       fixed bin (21);
       66 dcl  fix_num		       fixed;
       67 dcl  nn			       fixed bin;
       68 dcl  code			       fixed (35);
       69 dcl  1 ics		       aligned,
       70        2 sdbptr		       ptr,
       71        2 dimptr		       ptr,
       72        2 entry		       fixed;
       73 dcl  mask			       fixed (35);
       74 dcl  comment		       char (256) aligned varying;
       75 dcl  n			       fixed (21);
       76 dcl  (leader_ok, eof_ok)	       bit (1) aligned;
       77 dcl  reel			       char (32) varying;
       78 dcl  track		       char (8) varying;
       79 dcl  chars		       fixed;
       80 dcl  st			       bit (12) aligned;
       81 dcl  status_story		       char (100) varying;
       82 dcl  1 status		       aligned,
       83        2 code		       fixed (35),
       84        2 bits		       bit (36);
       85 dcl  write_sw		       bit (1);
       86 dcl  order_index		       fixed bin;
       87 dcl  reel_name		       char (256);
       88 
       89 /* Based. */
       90 
       91 dcl  1 blk		       aligned based (blkptr),
       92        2 sdbptr		       ptr,
       93        2 dimptr		       ptr,
       94        2 attach		       char (59) varying,
       95        2 write_ring		       bit (1) unaligned,
       96        2 extend		       bit (1) unaligned,
       97        2 open		       char (31) varying,
       98        2 maxbuf		       fixed bin (18);
       99 
      100 /* Internal static. */
      101 
      102 dcl  free_blks_ptr		       ptr int static init (null ());
      103 
      104 /* Procedures. */
      105 
      106 dcl  com_err_		       ext entry options (variable);
      107 dcl  cv_dec_check_		       entry (char (*), fixed bin (35)) returns (fixed bin (35));
      108 dcl  cu_$arg_list_ptr	       ext entry () returns (ptr);
      109 dcl  cu_$gen_call		       ext entry (entry, ptr);
      110 dcl  default_handler_$set	       ext entry (entry);
      111 dcl  error		       entry variable options (variable) init (ERROR);
      112 dcl  hcs_$assign_linkage	       ext entry (fixed, ptr) returns (fixed (35));
      113 dcl  hcs_$set_ips_mask	       ext entry (fixed (35), fixed (35));
      114 dcl  hcs_$reset_ips_mask	       ext entry (fixed (35), fixed (35));
      115 dcl  iox_$ios_call		       ext entry options (variable);
      116 dcl  iox_$ios_call_attach	       ext entry options (variable);
      117 dcl  iox_$propagate		       ext entry (ptr);
      118 dcl  nstd_$nstd_module	       fixed ext;
      119 dcl  analyze_device_stat_$rsnnl      entry (char (*) varying, ptr, bit (72) aligned, bit (18) aligned);
      120 
      121 /* Constants. */
      122 
      123 dcl  error_table_$bad_arg	       fixed (35) ext;
      124 dcl  error_table_$bad_conversion     fixed bin (35) ext;
      125 dcl  error_table_$bad_mode	       fixed (35) ext;
      126 dcl  error_table_$bad_tapeid	       fixed bin (35) ext;
      127 dcl  error_table_$badopt	       fixed (35) ext;
      128 dcl  error_table_$end_of_info	       fixed (35) ext;
      129 dcl  error_table_$long_record	       fixed (35) ext;
      130 dcl  error_table_$noarg	       fixed (35) ext;
      131 dcl  error_table_$not_detached       fixed (35) ext;
      132 dcl  error_table_$tape_error	       fixed (35) ext;
      133 dcl  error_table_$invalid_record_length
      134 			       fixed (35) ext;
      135 dcl  error_table_$undefined_order_request
      136 			       fixed bin (35) ext;
      137 dcl  tape_status_table_$tape_status_table_
      138 			       ext;
      139 
      140 dcl  iox_$err_not_attached	       ext entry options (variable);
      141 dcl  iox_$err_not_closed	       ext entry options (variable);
      142 dcl  iox_$err_not_open	       ext entry options (variable);
      143 
      144 dcl  detach_offset		       fixed int static init (1);
      145 dcl  read_offset		       fixed int static init (2);
      146 dcl  write_offset		       fixed int static init (3);
      147 dcl  order_offset		       fixed int static init (5);
      148 
      149 dcl  leader_status		       fixed (35) based (addr (leader_bits));
      150 dcl  leader_bits		       bit (36) int static init ("100000000000000000000000000101001000"b);
      151 
      152 dcl  sequential_input_mode	       fixed int static init (4);
      153 dcl  sequential_output_mode	       fixed int static init (5);
      154 
      155 
      156 dcl  1 ORDER_TAB		       (24) internal static options (constant),
      157        2 NAME		       char (20)
      158 			       init ("backspace_file", "backspace_record", "bcd", "binary", "d1600", "d200", "d556",
      159 			       "d6250", "d800", "data_security_erase", "erase", "fixed_record_length",
      160 			       "forward_file", "forward_record", "io_call", "nine", "protect", "request_status",
      161 			       "reset_status", "retry_count", "rewind", "saved_status", "unload", "write_eof"),
      162        2 ACTION		       fixed bin
      163 			       init (1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 4, 0, 0, 0, 0, 5, 6, 0, 0, 7);
      164 dcl  sequential_input_output_mode    fixed int static init (6);
      165 
      166 /* Built-in. */
      167 
      168 dcl  (addr, divide, hbound, index, length, mod, null, rtrim, size, substr, bin, ltrim, min, maxlength)
      169 			       builtin;
      170 
      171 /* Beginning of entry point ..... tape_nstd_$tape_nstd_attach(iocb_ptr,args,loud_sw) ..... */
      172 
      173 
      174 	arg_code = 0;
      175 	mask = 0;
      176 	comment = "";
      177 	call default_handler_$set (HANDLER);
      178 	if hbound (args, 1) < 1 then call error (error_table_$noarg, "tape_nstd_", "No volume id specified.");
      179 	n = index (args (1), " ") - 1;
      180 	if n < 0 then n = length (args (1));
      181 	if n = 0 | n > maxlength (reel) then call error (error_table_$bad_tapeid, "tape_nstd_", "^a", args (1));
      182 	reel = substr (args (1), 1, n);
      183 	write_sw = "0"b;
      184 	track = "";
      185 	density = "";
      186 	block_size = 2800 * 4;
      187 	block = "";
      188 	do n = 2 to hbound (args, 1);
      189 	     if args (n) = "-write" then write_sw = "1"b;
      190 	     else if args (n) = "-track" | args (n) = "-tk"
      191 		then do;
      192 		     n = n + 1;
      193 		     if n > hbound (args, 1)
      194 			then call error (error_table_$noarg, "tape_nstd_",
      195 				"No value specified following the ^a control argument.", args (n - 1));
      196 		     fix_num = cv_dec_check_ ((args (n)), code);
      197 		     if code ^= 0 then fix_num = 0;
      198 		     if fix_num = 7 then track = ",7track";
      199 		     else if fix_num = 9 then track = ",9track";
      200 		     else call error (error_table_$bad_arg, "tape_nstd_", "Bad track specification. ^a", args (n));
      201 		end;
      202 
      203 	     else if args (n) = "-density" | args (n) = "-den"
      204 		then do;
      205 		     n = n + 1;
      206 		     if n > hbound (args, 1)
      207 			then call error (error_table_$noarg, "tape_nstd_",
      208 				"No value specified following the ^a control argument.", args (n - 1));
      209 		     fix_num = cv_dec_check_ ((args (n)), code);
      210 		     if code ^= 0 then fix_num = 0;
      211 		     if fix_num = 200 then density = ",den=200";
      212 		     else if fix_num = 556 then density = ",den=556";
      213 		     else if fix_num = 800 then density = ",den=800";
      214 		     else if fix_num = 1600 then density = ",den=1600";
      215 		     else if fix_num = 6250 then density = ",den=6250";
      216 		     else call error (error_table_$bad_arg, "tape_nstd_", "Bad density specification. ^a", args (n));
      217 		end;
      218 
      219 	     else if args (n) = "-block" | args (n) = "-bk"
      220 		then do;
      221 		     n = n + 1;
      222 
      223 		     if n > hbound (args, 1)
      224 			then call error (error_table_$noarg, "tape_nstd_",
      225 				"No size specified following the ^a control argument.", args (n - 1));
      226 
      227 		     block_size = cv_dec_check_ ((args (n)), code);
      228 
      229 		     if block_size = 0 | code ^= 0 | mod (block_size, 4) ^= 0
      230 			then call error (error_table_$bad_arg, "tape_nstd_", "Bad block size specification. ^a",
      231 				args (n));
      232 		end;
      233 	     else if args (n) = "-comment" | args (n) = "-com"
      234 		then do;
      235 		     n = n + 1;
      236 		     if n > hbound (args, 1)
      237 			then call error (error_table_$noarg, "tape_nstd_",
      238 				"No comment specified following the ^a control argument", args (n - 1));
      239 		     if length (args (n)) > maxlength (comment) - 2
      240 			then call error (error_table_$bad_arg, "tape_nstd_",
      241 				"Comment '^a' longer than ^d characters", args (n), maxlength (comment) - 2);
      242 		     comment = ",*" || args (n);
      243 		end;
      244 
      245 	     else call error (error_table_$badopt, "tape_nstd_", "^a", args (n));
      246 	     end;
      247 	pic = divide (block_size, 4, 18);
      248 	block = ",blk=" || ltrim (pic);
      249 
      250 	if iocb_ptr -> iocb.attach_data_ptr ^= null ()
      251 	     then call error (error_table_$not_detached, "tape_nstd_", "^a", iocb_ptr -> iocb.name);
      252 	ics.dimptr = addr (nstd_$nstd_module);
      253 	ics.sdbptr = null;
      254 	reel_name = reel || track || density || block || comment;
      255 	call iox_$ios_call_attach (iocb_ptr -> iocb.name, "nstd_", reel_name, substr ("rw", 1, 1 + bin (write_sw, 1)),
      256 	     status, addr (ics));
      257 	if status.code ^= 0 then call error (status.code, "tape_nstd_");
      258 	call hcs_$set_ips_mask (0, mask);
      259 	if iocb_ptr -> iocb.attach_descrip_ptr ^= null () then go to unattach;
      260 	blkptr = free_blks_ptr;
      261 	if blkptr ^= null ()
      262 	     then free_blks_ptr = blkptr -> blk.sdbptr;
      263 	     else code = hcs_$assign_linkage (size (blkptr -> blk), blkptr);
      264 	if blkptr = null ()
      265 	     then do;
      266 unattach:
      267 		call hcs_$reset_ips_mask (mask, mask);
      268 		ics.entry = detach_offset;
      269 		call iox_$ios_call (addr (ics), "", "", status);
      270 		call error (code, "tape_nstd_", "^a", iocb_ptr -> iocb.name);
      271 	     end;
      272 	blkptr -> blk.sdbptr = ics.sdbptr;
      273 	blkptr -> blk.dimptr = ics.dimptr;
      274 	blkptr -> blk.attach = "tape_nstd_ " || rtrim (reel_name);
      275 	if write_sw then blkptr -> blk.attach = blkptr -> blk.attach || " -write";
      276 	blkptr -> blk.open = "";
      277 	blkptr -> blk.write_ring = write_sw;
      278 	blkptr -> blk.extend = "0"b;
      279 	blkptr -> blk.maxbuf = divide (block_size, 4, 18);
      280 	iocb_ptr -> iocb.attach_descrip_ptr = addr (blkptr -> blk.attach);
      281 	iocb_ptr -> iocb.attach_data_ptr = blkptr;
      282 	iocb_ptr -> iocb.detach_iocb = tape_detach;
      283 	iocb_ptr -> iocb.open = tape_open;
      284 	call iox_$propagate (iocb_ptr);
      285 	call hcs_$reset_ips_mask (mask, mask);
      286 	return;
      287 
      288 /*
      289*
      290*   This entry processes iox_$detach_iocb requests for tape_nstd_.
      291*
      292**/
      293 
      294 
      295 tape_detach:
      296      entry (iocb_ptr, arg_code);
      297 
      298 
      299 	arg_code = 0;
      300 	mask = 0;
      301 	call default_handler_$set (HANDLER);
      302 	call hcs_$set_ips_mask (0, mask);
      303 	blkptr = iocb_ptr -> iocb.attach_data_ptr;
      304 	ics.sdbptr = blkptr -> blk.sdbptr;
      305 	ics.dimptr = blkptr -> blk.dimptr;
      306 	ics.entry = detach_offset;
      307 	call iox_$ios_call (addr (ics), "", "", status);
      308 	if status.code ^= 0
      309 	     then do;
      310 		call hcs_$reset_ips_mask (mask, mask);
      311 		arg_code = status.code;
      312 		return;
      313 	     end;
      314 	blkptr -> blk.sdbptr = free_blks_ptr;
      315 	free_blks_ptr = blkptr;
      316 	iocb_ptr -> iocb.attach_descrip_ptr, iocb_ptr -> iocb.attach_data_ptr = null;
      317 	iocb_ptr -> iocb.detach_iocb = iox_$err_not_attached;
      318 	iocb_ptr -> iocb.open = iox_$err_not_attached;
      319 	call iox_$propagate (iocb_ptr);
      320 	call hcs_$reset_ips_mask (mask, mask);
      321 	return;
      322 
      323 /*
      324*
      325*   This entry processes iox_$open requests for tape_nstd_.
      326*
      327**/
      328 
      329 
      330 tape_open:
      331      entry (iocb_ptr, mode, extend_bit, arg_code);
      332 
      333 
      334 	if extend_bit
      335 	     then do;
      336 		arg_code = error_table_$bad_arg;
      337 		return;
      338 	     end;
      339 	mask = 0;
      340 	call default_handler_$set (HANDLER);
      341 	call hcs_$set_ips_mask (0, mask);
      342 	call SETUP;
      343 	if mode = sequential_input_mode then blkptr -> blk.open = "sequential_input";
      344 	else if blkptr -> blk.write_ring & mode = sequential_output_mode then blkptr -> blk.open = "sequential_output";
      345 	else if blkptr -> blk.write_ring & mode = sequential_input_output_mode
      346 	     then blkptr -> blk.open = "sequential_input_output";
      347 	else do;
      348 	     call hcs_$reset_ips_mask (mask, mask);
      349 	     arg_code = error_table_$bad_mode;
      350 	     return;
      351 	end;
      352 	actual_iocb_ptr -> iocb.open_descrip_ptr = addr (blkptr -> blk.open);
      353 	actual_iocb_ptr -> iocb.detach_iocb = iox_$err_not_closed;
      354 	actual_iocb_ptr -> iocb.open = iox_$err_not_closed;
      355 	actual_iocb_ptr -> iocb.close = tape_close;
      356 	actual_iocb_ptr -> iocb.control = tape_control;
      357 	if mode ^= sequential_output_mode then actual_iocb_ptr -> iocb.read_record = tape_read;
      358 	if mode ^= sequential_input_mode then actual_iocb_ptr -> iocb.write_record = tape_write;
      359 	call iox_$propagate (actual_iocb_ptr);
      360 	call hcs_$reset_ips_mask (mask, mask);
      361 	return;
      362 
      363 /*
      364*
      365*   This entry processes all iox_$close requests for tape_nstd_.
      366*
      367**/
      368 
      369 
      370 tape_close:
      371      entry (iocb_ptr, arg_code);
      372 
      373 
      374 	call SETUP;
      375 	ics.entry = order_offset;
      376 	call iox_$ios_call (addr (ics), "rewind", null (), status);
      377 	mask = 0;
      378 	call default_handler_$set (HANDLER);
      379 	call hcs_$set_ips_mask (0, mask);
      380 	actual_iocb_ptr = iocb_ptr -> iocb.actual_iocb_ptr;
      381 	actual_iocb_ptr -> iocb.open_descrip_ptr = null;
      382 	actual_iocb_ptr -> iocb.detach_iocb = tape_detach;
      383 	actual_iocb_ptr -> iocb.open = tape_open;
      384 	actual_iocb_ptr -> iocb.close = iox_$err_not_open;
      385 	actual_iocb_ptr -> iocb.read_record = iox_$err_not_open;
      386 	actual_iocb_ptr -> iocb.write_record = iox_$err_not_open;
      387 	call iox_$propagate (actual_iocb_ptr);
      388 	call hcs_$reset_ips_mask (mask, mask);
      389 	return;
      390 
      391 /*
      392*
      393*   This entry processes all iox_$read_record requests for tape_nstd_.
      394*
      395**/
      396 
      397 
      398 tape_read:
      399      entry (iocb_ptr, bufptr, buflen, actlen, arg_code);
      400 
      401 
      402 	call SETUP;
      403 	actlen = 0;
      404 	if buflen < 1 then return;
      405 	ics.entry = read_offset;
      406 	call iox_$ios_call (addr (ics), bufptr, 0, (min (blkptr -> blk.maxbuf, divide (buflen, 4, 17, 0))), nn, status);
      407 	actlen, chars = 4 * nn;
      408 	call SET_CODE;
      409 	if buflen < chars
      410 	     then arg_code = error_table_$long_record;
      411 	     else arg_code = code;
      412 	return;
      413 
      414 /*
      415*
      416*   This entry processes all iox_$write_record requests for tape_nstd_.
      417*
      418**/
      419 
      420 
      421 tape_write:
      422      entry (iocb_ptr, bufptr, buflen, arg_code);
      423 
      424 
      425 	call SETUP;
      426 	if buflen < 1 then return;
      427 	if mod (buflen, 4) ^= 0
      428 	     then do;
      429 		arg_code = error_table_$invalid_record_length;
      430 		return;
      431 	     end;
      432 	ics.entry = write_offset;
      433 	nn = divide (buflen, 4, 17, 0);
      434 
      435 	if nn > blkptr -> blk.maxbuf
      436 	     then arg_code = error_table_$long_record;
      437 	     else do;
      438 		call iox_$ios_call (addr (ics), bufptr, 0, nn, 1, status);
      439 		call SET_CODE;
      440 		arg_code = code;
      441 	     end;
      442 	return;
      443 
      444 /*
      445*
      446*   This entry processes all iox_$control requests for tape_nstd_.
      447*
      448**/
      449 
      450 
      451 tape_control:
      452      entry (iocb_ptr, order, info_ptr, arg_code);
      453 
      454 dcl  order		       char (*);
      455 dcl  info_ptr		       ptr;
      456 
      457 
      458 	call SETUP;
      459 	ics.entry = order_offset;
      460 
      461 	do order_index = 1 to hbound (ORDER_TAB, 1);
      462 	     if ORDER_TAB.NAME (order_index) = order then goto ACT (ORDER_TAB.ACTION (order_index));
      463 	     end;
      464 
      465 	arg_code = error_table_$undefined_order_request;
      466 	return;
      467 
      468 ACT (0):						/* no mapping or special handling */
      469 	call iox_$ios_call (addr (ics), order, info_ptr, status);
      470 	call SET_CODE;
      471 	arg_code = code;
      472 	return;
      473 
      474 
      475 ACT (1):						/* backspace_file */
      476 	leader_ok, eof_ok = "1"b;
      477 	goto ACT (0);
      478 
      479 
      480 ACT (2):						/* backspace_record */
      481 	call MAPPED_ORDER ("back");
      482 	if status.code = leader_status
      483 	     then arg_code = error_table_$end_of_info;
      484 	     else arg_code = code;
      485 	return;
      486 
      487 
      488 ACT (3):						/* forward_file */
      489 	eof_ok = "1"b;
      490 	goto ACT (0);
      491 
      492 
      493 ACT (4):						/* io_call */
      494 	call IO_CALL ();
      495 	arg_code = code;
      496 	return;
      497 
      498 
      499 ACT (5):						/* retry_count */
      500 	call MAPPED_ORDER ("err_count");
      501 	arg_code = code;
      502 	return;
      503 
      504 
      505 ACT (6):						/* rewind */
      506 	leader_ok = "1"b;
      507 	goto ACT (0);
      508 
      509 
      510 ACT (7):						/* write_eof */
      511 	call MAPPED_ORDER ("eof");
      512 	arg_code = code;
      513 	return;
      514 
      515 /* Internal procedure to handle all attach errors.  Calls "com_err_" if the "loud_sw"
      516*   is set.  In any case, returns to caller of attach external procedure with proper
      517*   error code after ensuring that the IPS interrupt mask is restored. */
      518 
      519 ERROR:
      520      proc (c);
      521 
      522 
      523 dcl  c			       fixed (35);
      524 
      525 
      526 	if mask ^= 0 then call hcs_$reset_ips_mask (mask, mask);
      527 	if loud_sw then call cu_$gen_call (com_err_, (cu_$arg_list_ptr ()));
      528 	arg_code = c;
      529 	go to return;
      530 
      531 
      532      end ERROR;
      533 
      534 
      535 return:
      536 	return;
      537 
      538 /* Internal procedure to handle faults while IPS interrupts
      539*   are masked.  While not masked, any signals are simply
      540*   passed on up the stack to their normal handlers.  For a
      541*   fault while masked, the process is terminated (with the
      542*   reason "unable to do critical I/O") because the I/O
      543*   control blocks are in an inconsistent state, and we can
      544*   tolerate neither spawning a command loop with interrupts
      545*   masked nor a restart with a possibly changed mask. */
      546 
      547 
      548 HANDLER:
      549      proc (p1, name, p2, p3, continue);
      550 
      551 
      552 dcl  (p1, p2, p3)		       ptr;
      553 dcl  name			       char (*);
      554 dcl  continue		       bit (1) aligned;
      555 dcl  error_table_$unable_to_do_io    fixed (35) ext;
      556 dcl  terminate_process_	       ext entry (char (*), ptr);
      557 dcl  1 ti			       aligned,
      558        2 version		       fixed,
      559        2 code		       fixed (35);
      560 
      561 
      562 	if mask ^= 0
      563 	     then do;
      564 		ti.version = 0;
      565 		ti.code = error_table_$unable_to_do_io;
      566 		call terminate_process_ ("fatal_error", addr (ti));
      567 	     end;
      568 	if name ^= "cleanup" then continue = "1"b;
      569 	return;
      570 
      571 
      572      end HANDLER;
      573 
      574 /*
      575*
      576*   This procedure processes all order calls that must be handled special for io_call.
      577*
      578**/
      579 
      580 
      581 IO_CALL:
      582      proc ();
      583 
      584 
      585 	io_call_infop = info_ptr;
      586 	if io_call_info.order_name = "request_status" | io_call_info.order_name = "saved_status"
      587 	     then do;
      588 		call iox_$ios_call (addr (ics), io_call_info.order_name, addr (st), status);
      589 		if status.code = 0
      590 		     then do;
      591 			call analyze_device_stat_$rsnnl (status_story, addr (tape_status_table_$tape_status_table_),
      592 			     (st), ("0"b));
      593 			if status_story = ""
      594 			     then call io_call_info.report ("no interesting status");
      595 			     else call io_call_info.report ("status:^-^a", status_story);
      596 		     end;
      597 		code = status.code;
      598 	     end;
      599 	else if io_call_info.order_name = "fixed_record_length" then call IO_CALL_W_FB ("fixed_record_length");
      600 	else if io_call_info.order_name = "retry_count" then call IO_CALL_W_FB ("err_count");
      601 	else code = error_table_$undefined_order_request;
      602 
      603 	return;
      604 
      605 
      606 IO_CALL_W_FB:
      607      proc (ord);
      608 
      609 
      610 dcl  ord			       char (*);
      611 dcl  value		       fixed bin (35);
      612 
      613 
      614 	if io_call_info.nargs < 1
      615 	     then do;
      616 		call io_call_info
      617 		     .
      618 		     error (error_table_$noarg, io_call_info.caller_name, "Argument for ^a control order missing.",
      619 		     order);
      620 		code = 0;
      621 		return;
      622 	     end;
      623 	value = cv_dec_check_ ((io_call_info.args (1)), code);
      624 	if code ^= 0
      625 	     then do;
      626 		call io_call_info
      627 		     .
      628 		     error (error_table_$bad_conversion, io_call_info.caller_name,
      629 		     "Error converting ""^a"" to binary.", io_call_info.args (1));
      630 		code = 0;
      631 		return;
      632 	     end;
      633 	call iox_$ios_call (addr (ics), ord, addr (value), status);
      634 	call SET_CODE ();
      635 	return;
      636 
      637 
      638      end IO_CALL_W_FB;
      639 
      640 
      641      end IO_CALL;
      642 
      643 /*
      644*
      645*   The mapped order procedure handles nstd_ calls where the order name is
      646*   to be mapped to an nstd_ compatible order.
      647*
      648**/
      649 
      650 
      651 MAPPED_ORDER:
      652      proc (ord);
      653 
      654 
      655 dcl  ord			       char (*);
      656 
      657 
      658 	call iox_$ios_call (addr (ics), ord, info_ptr, status);
      659 	call SET_CODE;
      660 	return;
      661 
      662 
      663      end MAPPED_ORDER;
      664 
      665 /*
      666*
      667*   The SET_CODE procedure interprets status and sets code accordingly.
      668*
      669**/
      670 
      671 
      672 SET_CODE:
      673      proc;
      674 
      675 
      676 dcl  1 s			       aligned based (addr (status.code)),
      677        2 (
      678        io			       bit (1),
      679        junk		       bit (25),
      680        major		       bit (4),
      681        minor		       bit (6)
      682        )			       unaligned;
      683 
      684 
      685 	if status.code = 0 then code = 0;
      686 	else if ^s.io then code = status.code;
      687 	else if status.code = leader_status
      688 	     then if leader_ok
      689 		     then code = 0;
      690 		     else code = error_table_$tape_error;
      691 	else if (s.major = "0100"b) & s.io
      692 	     then if eof_ok
      693 		     then code = 0;
      694 		     else code = error_table_$end_of_info;
      695 	else code = error_table_$tape_error;
      696 	return;
      697 
      698 
      699      end SET_CODE;
      700 
      701 /*
      702*
      703*   The procedure setup performs setup common to a number of entries.
      704*
      705**/
      706 
      707 
      708 SETUP:
      709      proc;
      710 
      711 
      712 	actual_iocb_ptr = iocb_ptr -> iocb.actual_iocb_ptr;
      713 	blkptr = actual_iocb_ptr -> iocb.attach_data_ptr;
      714 	ics.sdbptr = blkptr -> blk.sdbptr;
      715 	ics.dimptr = blkptr -> blk.dimptr;
      716 	leader_ok, eof_ok = "0"b;
      717 	arg_code, code = 0;
      718 	return;
      719 
      720 
      721      end SETUP;
      722 
  1     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  1     2 /* format: style2 */
  1     3 
  1     4      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  1     5 	     2 version	      character (4) aligned,
  1     6 	     2 name	      char (32),		/* I/O name of this block. */
  1     7 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  1     8 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  1     9 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  1    10 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  1    11 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  1    12 	     2 reserved	      bit (72),		/* Reserved for future use. */
  1    13 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  1    14 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  1    15 						/* open(p,mode,not_used,s) */
  1    16 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  1    17 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  1    18 						/* get_line(p,bufptr,buflen,actlen,s) */
  1    19 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  1    20 						/* get_chars(p,bufptr,buflen,actlen,s) */
  1    21 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  1    22 						/* put_chars(p,bufptr,buflen,s) */
  1    23 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  1    24 						/* modes(p,newmode,oldmode,s) */
  1    25 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  1    26 						/* position(p,u1,u2,s) */
  1    27 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  1    28 						/* control(p,order,infptr,s) */
  1    29 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  1    30 						/* read_record(p,bufptr,buflen,actlen,s) */
  1    31 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  1    32 						/* write_record(p,bufptr,buflen,s) */
  1    33 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  1    34 						/* rewrite_record(p,bufptr,buflen,s) */
  1    35 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  1    36 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  1    37 						/* seek_key(p,key,len,s) */
  1    38 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  1    39 						/* read_key(p,key,len,s) */
  1    40 	     2 read_length	      entry (ptr, fixed (21), fixed (35));
  1    41 						/* read_length(p,len,s) */
  1    42 
  1    43      declare iox_$iocb_version_sentinel
  1    44 			      character (4) aligned external static;
  1    45 
  1    46 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
      723 
      724 
  2     1 /* Begin include file ..... io_call_info.incl.pl1 */
  2     2 
  2     3 /* This include file defines the info_structure used by an I/O module to perform an "io_call" order
  2     4*   on behalf of the io_call command. */
  2     5 /* Coded April 1976 by Larry Johnson */
  2     6 /* Changed June 1977 by Larry Johnson for "io_call_af" order */
  2     7 
  2     8      dcl	   io_call_infop	      ptr;
  2     9 
  2    10      dcl	   1 io_call_info	      aligned based (io_call_infop),
  2    11 	     2 version	      fixed bin,
  2    12 	     2 caller_name	      char (32),		/* Caller name for error messages */
  2    13 	     2 order_name	      char (32),		/* Actual name of the order to be performed */
  2    14 	     2 report	      entry variable options (variable),
  2    15 						/* Entry to ioa_ like procedure to report results */
  2    16 	     2 error	      entry variable options (variable),
  2    17 						/* Entry to com_err_ like procedure to report results */
  2    18 	     2 af_returnp	      ptr,		/* Pointer to return string if "io_call_af"  order */
  2    19 	     2 af_returnl	      fixed bin,		/* Length of string */
  2    20 	     2 fill	      (5) bit (36) aligned,
  2    21 	     2 nargs	      fixed bin,		/* Number of additional command arguments provided */
  2    22 	     2 max_arglen	      fixed bin,		/* Length of longest argument (used to define array) */
  2    23 	     2 args	      (0 refer (io_call_info.nargs)) char (0 refer (io_call_info.max_arglen)) varying;
  2    24 
  2    25      dcl	   io_call_af_ret	      char (io_call_info.af_returnl) based (io_call_info.af_returnp) varying;
  2    26 						/* Return string for active function */
  2    27 
  2    28 /* End include file ..... io_call_info.incl.pl1 */
      725 
      726 
      727 
      728      end tape_nstd_attach;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/04/82  1557.5  tape_nstd_.pl1                    >dumps>old>recomp>tape_nstd_.pl1
723          1    07/28/81  1333.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
725          2    07/19/79  1547.1  io_call_info.incl.pl1             >ldd>include>io_call_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION                    5     000000 constant        fixed bin(17,0)          initial array level 2 dcl 156 ref 462
NAME                            000000 constant        char(20)                 initial array level 2 packed unaligned dcl 156 ref
                                                                                  462
ORDER_TAB                       000000 constant        structure                array level 1 unaligned dcl 156 ref 461
actlen                                 parameter       fixed bin(21,0)          dcl 48 set ref 398 403* 407*
actual_iocb_ptr          12            based           pointer                  level 2 in structure "iocb" dcl 1-4 in procedure
                                                                                  "tape_nstd_attach" ref 380 712
actual_iocb_ptr                 000100 automatic       pointer                  dcl 60 in procedure "tape_nstd_attach" set ref 352
                                                                                  353 354 355 356 357 358 359* 380* 381 382 383 384
                                                                                  385 386 387* 712* 713
addr                                                   builtin function         dcl 168 ref 252 255 255 269 269 280 307 307 352 376
                                                                                  376 406 406 438 438 468 468 482 566 566 588 588
                                                                                  588 588 591 591 633 633 633 633 658 658 686 687
                                                                                  691 691
analyze_device_stat_$rsnnl      000044 constant        entry                    external dcl 119 ref 591
arg_code                               parameter       fixed bin(35,0)          dcl 56 set ref 13 174* 295 299* 311* 330 336* 349*
                                                                                  370 398 409* 411* 421 429* 435* 440* 451 465* 471*
                                                                                  482* 484* 495* 501* 512* 528* 717*
args                                   parameter       varying char             array dcl 49 in procedure "tape_nstd_attach" set ref
                                                                                  13 178 179 180 181* 182 188 189 190 190 193 193*
                                                                                  196 200* 203 203 206 206* 209 216* 219 219 223
                                                                                  223* 227 229* 233 233 236 236* 239 239* 242 245*
args                     44            based           varying char             array level 2 in structure "io_call_info" dcl 2-10
                                                                                  in procedure "tape_nstd_attach" set ref 623 626*
attach                    4            based           varying char(59)         level 2 dcl 91 set ref 274* 275* 275 280
attach_data_ptr          16            based           pointer                  level 2 dcl 1-4 set ref 250 281* 303 316* 713
attach_descrip_ptr       14            based           pointer                  level 2 dcl 1-4 set ref 259 280* 316*
bin                                                    builtin function         dcl 168 ref 255 255
blk                                    based           structure                level 1 dcl 91 set ref 263 263
blkptr                          000116 automatic       pointer                  dcl 64 set ref 260* 261 261 263 263 263* 264 272 273
                                                                                  274 275 275 276 277 278 279 280 281 303* 304 305
                                                                                  314 315 343 344 344 345 345 352 406 435 713* 714
                                                                                  715
block                           000106 automatic       varying char(13)         dcl 62 set ref 187* 248* 254
block_size                      000120 automatic       fixed bin(21,0)          dcl 65 set ref 186* 227* 229 229 247 279
buflen                                 parameter       fixed bin(21,0)          dcl 50 ref 398 404 406 409 421 426 427 433
bufptr                                 parameter       pointer                  dcl 51 set ref 398 406* 421 438*
c                                      parameter       fixed bin(35,0)          dcl 523 ref 519 528
caller_name               1            based           char(32)                 level 2 dcl 2-10 set ref 616* 626*
chars                           000252 automatic       fixed bin(17,0)          dcl 79 set ref 407* 409
close                    36            based           entry variable           level 2 dcl 1-4 set ref 355* 384*
code                            000306 automatic       fixed bin(35,0)          level 2 in structure "status" dcl 82 in procedure
                                                                                  "tape_nstd_attach" set ref 257 257* 308 311 482
                                                                                  589 597 685 686 686 687 691 691
code                            000123 automatic       fixed bin(35,0)          dcl 68 in procedure "tape_nstd_attach" set ref 196*
                                                                                  197 209* 210 227* 229 263* 270* 411 440 471 484
                                                                                  495 501 512 597* 601* 620* 623* 624 630* 685* 686*
                                                                                  687* 690* 691* 694* 695* 717*
code                      1     000100 automatic       fixed bin(35,0)          level 2 in structure "ti" dcl 557 in procedure
                                                                                  "HANDLER" set ref 565*
com_err_                        000014 constant        entry                    external dcl 106 ref 527 527
comment                         000132 automatic       varying char(256)        dcl 74 set ref 176* 239 239 242* 254
continue                               parameter       bit(1)                   dcl 554 set ref 548 568*
control                  66            based           entry variable           level 2 dcl 1-4 set ref 356*
cu_$arg_list_ptr                000020 constant        entry                    external dcl 108 ref 527
cu_$gen_call                    000022 constant        entry                    external dcl 109 ref 527
cv_dec_check_                   000016 constant        entry                    external dcl 107 ref 196 209 227 623
default_handler_$set            000024 constant        entry                    external dcl 110 ref 177 301 340 378
density                         000102 automatic       varying char(9)          dcl 61 set ref 185* 211* 212* 213* 214* 215* 254
detach_iocb              26            based           entry variable           level 2 dcl 1-4 set ref 282* 317* 353* 382*
detach_offset                          constant        fixed bin(17,0)          initial dcl 144 ref 268 306
dimptr                    2            based           pointer                  level 2 in structure "blk" dcl 91 in procedure
                                                                                  "tape_nstd_attach" set ref 273* 305 715
dimptr                    2     000124 automatic       pointer                  level 2 in structure "ics" dcl 69 in procedure
                                                                                  "tape_nstd_attach" set ref 252* 273 305* 715*
divide                                                 builtin function         dcl 168 ref 247 279 406 433
entry                     4     000124 automatic       fixed bin(17,0)          level 2 dcl 69 set ref 268* 306* 375* 405* 432* 459*
eof_ok                          000235 automatic       bit(1)                   dcl 76 set ref 475* 488* 691 716*
error                    26            based           entry variable           level 2 in structure "io_call_info" dcl 2-10
                                                                                  in procedure "tape_nstd_attach" ref 616 626
error                           000412 automatic       entry variable           initial dcl 111 in procedure "tape_nstd_attach" set
                                                                                  ref 111* 178 181 193 200 206 216 223 229 236 239
                                                                                  245 250 257 270
error_table_$bad_arg            000046 external static fixed bin(35,0)          dcl 123 set ref 200* 216* 229* 239* 336
error_table_$bad_conversion     000050 external static fixed bin(35,0)          dcl 124 set ref 626*
error_table_$bad_mode           000052 external static fixed bin(35,0)          dcl 125 ref 349
error_table_$bad_tapeid         000054 external static fixed bin(35,0)          dcl 126 set ref 181*
error_table_$badopt             000056 external static fixed bin(35,0)          dcl 127 set ref 245*
error_table_$end_of_info        000060 external static fixed bin(35,0)          dcl 128 ref 482 694
error_table_$invalid_record_length
                                000072 external static fixed bin(35,0)          dcl 133 ref 429
error_table_$long_record        000062 external static fixed bin(35,0)          dcl 129 ref 409 435
error_table_$noarg              000064 external static fixed bin(35,0)          dcl 130 set ref 178* 193* 206* 223* 236* 616*
error_table_$not_detached       000066 external static fixed bin(35,0)          dcl 131 set ref 250*
error_table_$tape_error         000070 external static fixed bin(35,0)          dcl 132 ref 690 695
error_table_$unable_to_do_io    000106 external static fixed bin(35,0)          dcl 555 ref 565
error_table_$undefined_order_request
                                000074 external static fixed bin(35,0)          dcl 135 ref 465 601
extend                   24(01)        based           bit(1)                   level 2 packed unaligned dcl 91 set ref 278*
extend_bit                             parameter       bit(1)                   dcl 52 ref 330 334
fix_num                         000121 automatic       fixed bin(17,0)          dcl 66 set ref 196* 197* 198 199 209* 210* 211 212
                                                                                  213 214 215
free_blks_ptr                   000010 internal static pointer                  initial dcl 102 set ref 260 261* 314 315*
hbound                                                 builtin function         dcl 168 ref 178 188 193 206 223 236 461
hcs_$assign_linkage             000026 constant        entry                    external dcl 112 ref 263
hcs_$reset_ips_mask             000032 constant        entry                    external dcl 114 ref 266 285 310 320 348 360 388 526
hcs_$set_ips_mask               000030 constant        entry                    external dcl 113 ref 258 302 341 379
ics                             000124 automatic       structure                level 1 dcl 69 set ref 255 255 269 269 307 307 376
                                                                                  376 406 406 438 438 468 468 588 588 633 633 658
                                                                                  658
index                                                  builtin function         dcl 168 ref 179
info_ptr                               parameter       pointer                  dcl 455 set ref 451 468* 585 658*
io                                     based           bit(1)                   level 2 packed unaligned dcl 676 ref 686 691
io_call_info                           based           structure                level 1 dcl 2-10
io_call_infop                   000416 automatic       pointer                  dcl 2-8 set ref 585* 586 586 588 593 595 599 600 614
                                                                                  616 616 623 626 626 626
iocb                                   based           structure                level 1 dcl 1-4
iocb_ptr                               parameter       pointer                  dcl 53 set ref 13 250 250 255 259 270 280 281 282
                                                                                  283 284* 295 303 316 316 317 318 319* 330 370 380
                                                                                  398 421 451 712
iox_$err_not_attached           000100 constant        entry                    external dcl 140 ref 317 318
iox_$err_not_closed             000102 constant        entry                    external dcl 141 ref 353 354
iox_$err_not_open               000104 constant        entry                    external dcl 142 ref 384 385 386
iox_$ios_call                   000034 constant        entry                    external dcl 115 ref 269 307 376 406 438 468 588 633
                                                                                  658
iox_$ios_call_attach            000036 constant        entry                    external dcl 116 ref 255
iox_$propagate                  000040 constant        entry                    external dcl 117 ref 284 319 359 387
leader_bits                     000012 internal static bit(36)                  initial unaligned dcl 150 set ref 482 687
leader_ok                       000234 automatic       bit(1)                   dcl 76 set ref 475* 505* 687 716*
leader_status                          based           fixed bin(35,0)          dcl 149 ref 482 687
length                                                 builtin function         dcl 168 ref 180 239
loud_sw                                parameter       bit(1)                   dcl 54 ref 13 527
ltrim                                                  builtin function         dcl 168 ref 248
major                     0(26)        based           bit(4)                   level 2 packed unaligned dcl 676 ref 691
mask                            000131 automatic       fixed bin(35,0)          dcl 73 set ref 175* 258* 266* 266* 285* 285* 300*
                                                                                  302* 310* 310* 320* 320* 339* 341* 348* 348* 360*
                                                                                  360* 377* 379* 388* 388* 526 526* 526* 562
max_arglen               43            based           fixed bin(17,0)          level 2 dcl 2-10 ref 623 623 626 626 626
maxbuf                   36            based           fixed bin(18,0)          level 2 dcl 91 set ref 279* 406 435
maxlength                                              builtin function         dcl 168 ref 181 239 239
min                                                    builtin function         dcl 168 ref 406
mod                                                    builtin function         dcl 168 ref 229 427
mode                                   parameter       fixed bin(17,0)          dcl 55 ref 330 343 344 345 357 358
n                               000233 automatic       fixed bin(21,0)          dcl 75 set ref 179* 180 180* 181 181 182 188* 189
                                                                                  190 190 192* 192 193 193 196 200 203 203 205* 205
                                                                                  206 206 209 216 219 219 221* 221 223 223 227 229
                                                                                  233 233 235* 235 236 236 239 239 242 245*
name                                   parameter       char                     unaligned dcl 553 in procedure "HANDLER" ref 548 568
name                      1            based           char(32)                 level 2 in structure "iocb" dcl 1-4 in procedure
                                                                                  "tape_nstd_attach" set ref 250* 255* 270*
nargs                    42            based           fixed bin(17,0)          level 2 dcl 2-10 ref 614
nn                              000122 automatic       fixed bin(17,0)          dcl 67 set ref 406* 407 433* 435 438*
nstd_$nstd_module               000042 external static fixed bin(17,0)          dcl 118 set ref 252
null                                                   builtin function         dcl 168 ref 250 253 259 261 264 316 376 376 381
open                     32            based           entry variable           level 2 in structure "iocb" dcl 1-4 in procedure
                                                                                  "tape_nstd_attach" set ref 283* 318* 354* 383*
open                     25            based           varying char(31)         level 2 in structure "blk" dcl 91 in procedure
                                                                                  "tape_nstd_attach" set ref 276* 343* 344* 345* 352
open_descrip_ptr         20            based           pointer                  level 2 dcl 1-4 set ref 352* 381*
ord                                    parameter       char                     unaligned dcl 610 in procedure "IO_CALL_W_FB" set
                                                                                  ref 606 633*
ord                                    parameter       char                     unaligned dcl 655 in procedure "MAPPED_ORDER" set
                                                                                  ref 651 658*
order                                  parameter       char                     unaligned dcl 454 set ref 451 462 468* 616*
order_index                     000311 automatic       fixed bin(17,0)          dcl 86 set ref 461* 462 462*
order_name               11            based           char(32)                 level 2 dcl 2-10 set ref 586 586 588* 599 600
order_offset                           constant        fixed bin(17,0)          initial dcl 147 ref 375 459
p1                                     parameter       pointer                  dcl 552 ref 548
p2                                     parameter       pointer                  dcl 552 ref 548
p3                                     parameter       pointer                  dcl 552 ref 548
pic                             000114 automatic       picture(6)               unaligned dcl 63 set ref 247* 248
read_offset                            constant        fixed bin(17,0)          initial dcl 145 ref 405
read_record              72            based           entry variable           level 2 dcl 1-4 set ref 357* 385*
reel                            000236 automatic       varying char(32)         dcl 77 set ref 181 182* 254
reel_name                       000312 automatic       char(256)                unaligned dcl 87 set ref 254* 255* 274
report                   22            based           entry variable           level 2 dcl 2-10 ref 593 595
rtrim                                                  builtin function         dcl 168 ref 274
s                                      based           structure                level 1 dcl 676
sdbptr                          000124 automatic       pointer                  level 2 in structure "ics" dcl 69 in procedure
                                                                                  "tape_nstd_attach" set ref 253* 272 304* 714*
sdbptr                                 based           pointer                  level 2 in structure "blk" dcl 91 in procedure
                                                                                  "tape_nstd_attach" set ref 261 272* 304 314* 714
sequential_input_mode                  constant        fixed bin(17,0)          initial dcl 152 ref 343 358
sequential_input_output_mode           constant        fixed bin(17,0)          initial dcl 164 ref 345
sequential_output_mode                 constant        fixed bin(17,0)          initial dcl 153 ref 344 357
size                                                   builtin function         dcl 168 ref 263 263
st                              000253 automatic       bit(12)                  dcl 80 set ref 588 588 591
status                          000306 automatic       structure                level 1 dcl 82 set ref 255* 269* 307* 376* 406* 438*
                                                                                  468* 588* 633* 658*
status_story                    000254 automatic       varying char(100)        dcl 81 set ref 591* 593 595*
substr                                                 builtin function         dcl 168 ref 182 255 255
tape_status_table_$tape_status_table_
                                000076 external static fixed bin(17,0)          dcl 137 set ref 591 591
terminate_process_              000110 constant        entry                    external dcl 556 ref 566
ti                              000100 automatic       structure                level 1 dcl 557 set ref 566 566
track                           000247 automatic       varying char(8)          dcl 78 set ref 184* 198* 199* 254
value                           000440 automatic       fixed bin(35,0)          dcl 611 set ref 623* 633 633
version                         000100 automatic       fixed bin(17,0)          level 2 dcl 557 set ref 564*
write_offset                           constant        fixed bin(17,0)          initial dcl 146 ref 432
write_record             76            based           entry variable           level 2 dcl 1-4 set ref 358* 386*
write_ring               24            based           bit(1)                   level 2 packed unaligned dcl 91 set ref 277* 344 345
write_sw                        000310 automatic       bit(1)                   unaligned dcl 85 set ref 183* 189* 255 255 275 277

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
io_call_af_ret                         based           varying char             dcl 2-25
iox_$iocb_version_sentinel             external static char(4)                  dcl 1-43

NAMES DECLARED BY EXPLICIT CONTEXT.
ACT                             000220 constant        label                    array(0:7) dcl 468 ref 462 477 490 507
ERROR                           004237 constant        entry                    internal dcl 519 ref 111
HANDLER                         004317 constant        entry                    internal dcl 548 ref 177 177 301 301 340 340 378 378
IO_CALL                         004375 constant        entry                    internal dcl 581 ref 493
IO_CALL_W_FB                    004610 constant        entry                    internal dcl 606 ref 599 600
MAPPED_ORDER                    005005 constant        entry                    internal dcl 651 ref 480 499 510
SETUP                           005123 constant        entry                    internal dcl 708 ref 342 374 402 425 458
SET_CODE                        005051 constant        entry                    internal dcl 672 ref 408 439 470 634 659
return                          004235 constant        label                    dcl 535 ref 529
tape_close                      003453 constant        entry                    external dcl 370 ref 355
tape_control                    004051 constant        entry                    external dcl 451 ref 356
tape_detach                     003057 constant        entry                    external dcl 295 ref 282 382
tape_nstd_attach                000613 constant        entry                    external dcl 13
tape_open                       003245 constant        entry                    external dcl 330 ref 283 383
tape_read                       003620 constant        entry                    external dcl 398 ref 357
tape_write                      003736 constant        entry                    external dcl 421 ref 358
unattach                        002627 constant        label                    dcl 266 ref 259

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5664        5776    5213        5674
Length      6320    5213       112         306     451           4

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
tape_nstd_attach                    513 external procedure  is an external procedure.  
ERROR                                82 internal procedure  is assigned to an entry variable.  
HANDLER                              84 internal procedure  is assigned to an entry variable.  
IO_CALL                                 internal procedure  shares stack frame of external procedure tape_nstd_attach.  
IO_CALL_W_FB                            internal procedure  shares stack frame of external procedure tape_nstd_attach.  
MAPPED_ORDER                            internal procedure  shares stack frame of external procedure tape_nstd_attach.  
SET_CODE                                internal procedure  shares stack frame of external procedure tape_nstd_attach.  
SETUP                                   internal procedure  shares stack frame of external procedure tape_nstd_attach.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 free_blks_ptr               tape_nstd_attach
000012 leader_bits                 tape_nstd_attach

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
HANDLER                  000100 ti                          HANDLER
tape_nstd_attach         000100 actual_iocb_ptr             tape_nstd_attach
                         000102 density                     tape_nstd_attach
                         000106 block                       tape_nstd_attach
                         000114 pic                         tape_nstd_attach
                         000116 blkptr                      tape_nstd_attach
                         000120 block_size                  tape_nstd_attach
                         000121 fix_num                     tape_nstd_attach
                         000122 nn                          tape_nstd_attach
                         000123 code                        tape_nstd_attach
                         000124 ics                         tape_nstd_attach
                         000131 mask                        tape_nstd_attach
                         000132 comment                     tape_nstd_attach
                         000233 n                           tape_nstd_attach
                         000234 leader_ok                   tape_nstd_attach
                         000235 eof_ok                      tape_nstd_attach
                         000236 reel                        tape_nstd_attach
                         000247 track                       tape_nstd_attach
                         000252 chars                       tape_nstd_attach
                         000253 st                          tape_nstd_attach
                         000254 status_story                tape_nstd_attach
                         000306 status                      tape_nstd_attach
                         000310 write_sw                    tape_nstd_attach
                         000311 order_index                 tape_nstd_attach
                         000312 reel_name                   tape_nstd_attach
                         000412 error                       tape_nstd_attach
                         000416 io_call_infop               tape_nstd_attach
                         000440 value                       IO_CALL_W_FB

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            cat_realloc_cs      call_var_desc       call_ext_out_desc   call_ext_out        return
tra_ext             mod_fx1             shorten_stack       ext_entry           ext_entry_desc      int_entry
int_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
analyze_device_stat_$rsnnl    com_err_                      cu_$arg_list_ptr              cu_$gen_call
cv_dec_check_                 default_handler_$set          hcs_$assign_linkage           hcs_$reset_ips_mask
hcs_$set_ips_mask             iox_$err_not_attached         iox_$err_not_closed           iox_$err_not_open
iox_$ios_call                 iox_$ios_call_attach          iox_$propagate                terminate_process_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$bad_conversion   error_table_$bad_mode         error_table_$bad_tapeid
error_table_$badopt           error_table_$end_of_info      error_table_$invalid_record_length
error_table_$long_record      error_table_$noarg            error_table_$not_detached     error_table_$tape_error
error_table_$unable_to_do_io  error_table_$undefined_order_request                        nstd_$nstd_module
tape_status_table_$tape_status_table_




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    111 000601        13 000606       174 000632       175 000633       176 000634       177 000635       178 000647
    179 000710       180 000733       181 000740       182 001003       183 001027       184 001030       185 001031
    186 001032       187 001034       188 001035       189 001044       190 001067       192 001101       193 001102
    196 001151       197 001217       198 001223       199 001233       200 001242       201 001313       203 001314
    205 001326       206 001327       209 001376       210 001444       211 001450       212 001461       213 001471
    214 001501       215 001511       216 001521       217 001572       219 001573       221 001605       223 001606
    227 001655       229 001723       232 002005       233 002006       235 002020       236 002021       239 002070
    242 002154       243 002211       245 002213       246 002253       247 002255       248 002270       250 002325
    252 002371       253 002374       254 002376       255 002451       257 002527       258 002553       259 002565
    260 002574       261 002577       263 002607       264 002623       266 002627       268 002637       269 002641
    270 002667       272 002725       273 002727       274 002732       275 002764       276 003001       277 003002
    278 003005       279 003007       280 003012       281 003017       282 003022       283 003030       284 003033
    285 003042       286 003052       295 003053       299 003070       300 003071       301 003072       302 003104
    303 003116       304 003123       305 003125       306 003127       307 003131       308 003157       310 003161
    311 003171       312 003173       314 003174       315 003177       316 003201       317 003211       318 003217
    319 003221       320 003227       321 003237       330 003240       334 003256       336 003262       337 003265
    339 003266       340 003267       341 003301       342 003313       343 003314       344 003327       345 003345
    348 003360       349 003370       350 003373       352 003374       353 003377       354 003404       355 003406
    356 003411       357 003414       358 003423       359 003432       360 003440       361 003450       370 003451
    374 003464       375 003465       376 003467       377 003521       378 003522       379 003534       380 003546
    381 003553       382 003555       383 003561       384 003564       385 003570       386 003572       387 003574
    388 003602       389 003612       398 003613       402 003631       403 003632       404 003634       405 003640
    406 003642       407 003710       408 003715       409 003716       411 003726       412 003730       421 003731
    425 003747       426 003750       427 003755       429 003760       430 003763       432 003764       433 003766
    435 003771       438 004000       439 004040       440 004041       442 004043       451 004044       458 004070
    459 004071       461 004073       462 004100       463 004114       465 004116       466 004121       468 004122
    470 004152       471 004153       472 004155       475 004156       477 004161       480 004162       482 004167
    484 004176       485 004200       488 004201       490 004203       493 004204       495 004205       496 004207
    499 004210       501 004217       502 004221       505 004222       507 004224       510 004225       512 004232
    513 004234       535 004235       519 004236       526 004244       527 004256       528 004307       529 004313
    548 004316       562 004332       564 004335       565 004336       566 004340       568 004363       569 004374
    581 004375       585 004376       586 004402       588 004412       589 004442       591 004444       593 004500
    595 004525       597 004547       598 004551       599 004552       600 004570       601 004604       603 004607
    606 004610       614 004621       616 004625       620 004657       621 004660       623 004661       624 004711
    626 004714       630 004747       631 004750       633 004751       634 005003       635 005004       651 005005
    658 005016       659 005047       660 005050       672 005051       685 005052       686 005056       687 005067
    690 005077       691 005102       694 005115       695 005120       696 005122       708 005123       712 005124
    713 005131       714 005133       715 005135       716 005140       717 005142       718 005144


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
