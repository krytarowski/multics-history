	COMPILATION LISTING OF SEGMENT page_trace
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 06/04/84  1250.6 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* ******************************************************
        8*   *                                                    *
        9*   *                                                    *
       10*   * Copyright (c) 1972 by Massachusetts Institute of   *
       11*   * Technology and Honeywell Information Systems, Inc. *
       12*   *                                                    *
       13*   *                                                    *
       14*   ****************************************************** */
       15 
       16 /* originally coded by Steve Webber  May 1971.
       17*   Modified by Steve Webber March 1974.
       18*   Modified by John Gintell June 1974 for MCR  598
       19*   Modified by John Gintell May 1975 for MCR's 957 and 970,
       20*   Modified by John Gintell Oct 1975 for MCR 1342.
       21*   Modified 760506 by PG for MCRs 1832 (fix bug in link fault printing) and 1833 (add ctl args).
       22*   Modified Feb 1979 by John Gintell for  MCR 3663 (fix bug in print_trace_entry).
       23*   Modified June 1981 by J. Bongiovanni to fix bug in -from processing
       24*   Modified January 1982 by J. Bongiovanni for extended page fault type
       25**/
       26 
       27 page_trace: pgt: proc;
       28 
       29 /* automatic */
       30 
       31 dcl (header, longsw, print_pagefaults, marker_seen, stop_at_marker, count_given) bit (1) aligned,
       32     (dp, eptr, tp) ptr,
       33      ring_no fixed bin (3),
       34     (from, to) char (4) aligned,
       35      string char (20),
       36     offset fixed bin(18),
       37     (next, total, count, i, tc, long, fmtx, start_index) fixed bin,
       38      code fixed bin (35),
       39      data_area (1024) fixed bin,
       40     (time, type, seg_no, page_no, hcscnt) fixed bin,
       41      dirname char (168),
       42      ename char (32),
       43      proc_name char (32),
       44      proc_offset fixed bin (18),
       45      proc_segno fixed bin,
       46      comp_name char (8),
       47      entry_name char (32),
       48      switch_ptr ptr,				/* pointer to I/O switch */
       49      ftime float bin;
       50 
       51 /* based */
       52 
       53 dcl  based_char_4 char (4) aligned based,
       54      packedptr ptr based unal,
       55      targ char (tc) based (tp);
       56 
       57 
       58 /* internal static */
       59 
       60 dcl  output_format (0:11) char (50) varying aligned internal static options (constant) initial (
       61      "^20x^s^8.2f^3o^6o^5o^2x^s^a",			/* 0 - short page fault */
       62      "^20x^s^8.2f^3o^6o^5o^2x^a>^a",			/* 1 - long page fault */
       63      "^20a^8.2f^3x^s^6o^5x^s^2x^s^a",			/* 2 - short (seg/bound) fault */
       64      "^20a^8.2f^3x^s^6o^5x^s^2x^a>^a",			/* 3 - long (seg/bound) fault */
       65      "^20a^8.2f^3x^s^6o^5x^s^2x^s^a$^a",		/* 4 - short end linkage fault */
       66      "^20a^8.2f^3x^s^6o^5x^s^2x^a>^a$^a",		/* 5 - long end linkage fault */
       67      "^20a^8.2f^3x^s^6x^s^5x^s^2x^s^a",			/* 6 - signal generated/user marker/etc */
       68      "^20a^8.2f",					/* 7 - make ptr/signal restarted/reschedule */
       69      "^20a^8.2f^3x^s^6o^5x^s^2x^s^a^a|^o",		/* 8 - short start linkage fault */
       70      "^20a^8.2f^3x^s^6o^5x^s^2x^a>^a^a|^o",		/* 9 - long  start linkage fault */
       71      "^20x^s^8.2f^3x^s^6o^5o^2x^s^a",			/* 10 - short page fault (extended) */
       72      "^20x^s^8.2f^3x^s^6o^5o^2x^a>^a^2s^/^46xby ^a|^o");	/* 11 - long page fault(extended)  */
       73 
       74 /* external static */
       75 
       76 dcl (active_all_rings_data_$hcscnt fixed bin,
       77      iox_$user_output ptr) external static;
       78 dcl  error_table_$badopt fixed bin (35) external static;
       79 dcl  error_table_$inconsistent fixed bin (35) external static;
       80 
       81 /* entries */
       82 
       83 dcl  hcs_$get_page_trace entry (ptr),
       84      hcs_$fs_get_path_name entry (ptr, char(*), fixed bin, char(*), fixed bin(35)),
       85      ioa_$ioa_switch entry options (variable),
       86      iox_$look_iocb entry (char (*), ptr, fixed bin (35)),
       87      get_entry_name_ entry (ptr, char (*), fixed bin, char (8), fixed bin (35)),
       88      com_err_ entry options (variable),
       89      cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35)),
       90      cu_$arg_count entry returns (fixed bin),
       91      interpret_bind_map_ entry (ptr, char(*), fixed bin(18), fixed bin(35)),
       92      ring0_get_$name entry (char(*), char(*), ptr, fixed bin (35));
       93 
       94 /* builtins */
       95 
       96 dcl (addr, baseno, baseptr, rel, binary, convert, substr, unspec) builtin;
       97 
       98 /* conditions */
       99 
      100 dcl (conversion, not_in_read_bracket) condition;
      101 
      102 /* include files */
      103 
  1     1 /* BEGIN INCLUDE FILE sys_trace.incl.pl1  --  Last modified Jan. 1982 */
  1     2 /* Modified for new pgt_ signal technology, Benson Margulies, 83-12 */
  1     3 /* format: style3 */
  1     4 
  1     5 declare	trace_ptr		ptr;
  1     6 
  1     7 declare	1 trace		based (trace_ptr) aligned,	/* system trace data structure */
  1     8 	  2 next_free	fixed bin (17) uns unal,	/* index to next free trace entry */
  1     9 	  2 pad1		bit (19) unal,
  1    10 	  2 last_available	fixed bin (17) uns unal,	/* index to first unusable entry in list */
  1    11 	  2 pad2		bit (19) unal,
  1    12 	  2 ttime		fixed bin (71),		/* time used to figure incremental times */
  1    13 	  2 temp		bit (36),			/* temporary used by page$enter_data */
  1    14 	  2 index		bit (17),			/* index to end of post purge list */
  1    15 	  2 threshold	fixed bin (17) unsigned unaligned,
  1    16 	  2 pad3		bit (1) unaligned,		/* to halfword */
  1    17 	  2 flags		unaligned,
  1    18 	    3 send_ips	bit (1) unaligned,		/* send pgt_ when index reached threshold */
  1    19 	    3 pad		bit (17) unaligned,
  1    20 	  2 pad4		bit (36) aligned,
  1    21 	  2 data		(1024),			/* trace data entry structure */
  1    22 	    3 data_word	char (4),			/* per-type data word */
  1    23 	    3 type	fixed bin (6) uns unaligned,	/* type of trace entry */
  1    24 	    3 pad		bit (14) unaligned,
  1    25 	    3 dtime	fixed bin (16) uns unaligned; /* time increment since last trace entry (in 64 micsec) */
  1    26 
  1    27 declare	1 page_trace_entry	based (trace_ptr) aligned,	/* entry for page fault data */
  1    28 	  2 pad		bit (18) unaligned,
  1    29 	  2 ring		fixed bin (3) uns unaligned,	/* ring number fault occured in */
  1    30 	  2 segment_number	fixed bin (15) uns unaligned, /* segment number of segment getting page fault */
  1    31 	  2 type		fixed bin (6) uns unaligned,	/* MBZ for page faults */
  1    32 	  2 page_number	fixed bin (12) uns unaligned, /* page number which caused fault */
  1    33 	  2 pad1		bit (2) unal,
  1    34 	  2 time		fixed bin (16) uns unaligned; /* time increment since last trace entry (res = 64 micro-secs) */
  1    35 
  1    36 declare	1 extended_page_trace_entry
  1    37 			based (trace_ptr) aligned,	/* page fault data with more info */
  1    38 	  2 psr_segno	fixed bin (12) uns unaligned, /* segment number of proc faulting */
  1    39 	  2 psr_offset	fixed bin (18) uns unaligned, /* IC of proc faulting */
  1    40 	  2 tsr_segno_1	bit (6) unaligned,		/* 1st 6 bits of segment number faulted */
  1    41 	  2 type		fixed bin (6) uns unaligned,	/* 15 decimal */
  1    42 	  2 tsr_segno_2	bit (6) unaligned,		/* last 6 bits of segment number faulted */
  1    43 	  2 tsr_pageno	fixed bin (8) uns unaligned,	/* page number faulted */
  1    44 	  2 time		fixed bin (16) uns unaligned; /* time increment since last trace entry (res = 64 micro-secs) */
  1    45 
  1    46 
  1    47 /* END INCLUDE FILE sys_trace.incl.pl1 */
      104 
  2     1 /* BEGIN INCLUDE FILE trace_types.incl.pl1  --  Last modified Jan 1982 */
  2     2 
  2     3      dcl	   (page_fault_type	      init (0),
  2     4 	   seg_fault_start	      init (2),
  2     5 	   seg_fault_end	      init (3),
  2     6 	   linkage_fault_start    init (4),
  2     7 	   linkage_fault_end      init (5),
  2     8 	   boundfault_start	      init (6),
  2     9 	   boundfault_end	      init (7),
  2    10 	   signaller_type	      init (8),
  2    11 	   restart_fault_type     init (9),
  2    12 	   reschedule_type	      init (10),
  2    13 	   marker_type	      init (11),
  2    14 	   interrupt_type	      init (12),
  2    15 	   extended_page_fault_type init (15)) fixed bin int static options (constant);
  2    16 
  2    17 
  2    18 /* END INCLUDE FILE trace_types.incl.pl1 */
      105 
      106 
      107 /*  */
      108 
      109 	dp = addr (data_area);			/* get a pointer to buffer */
      110 	call hcs_$get_page_trace (dp);		/* copy the trace information from ring 0 */
      111 
      112 	longsw = ""b;				/* default is short mode */
      113 	count_given = ""b;
      114 	print_pagefaults = "1"b;			/* default is to print page faults */
      115 	stop_at_marker = ""b;			/* default is to print until end */
      116 	from = "";				/* default is no from argument */
      117 	to = "";					/* default is no to argument */
      118 	marker_seen = "0"b;				/* haven't seen from marker yet. */
      119 
      120 	hcscnt = active_all_rings_data_$hcscnt;
      121 	switch_ptr = iox_$user_output;
      122 
      123 	next =  dp -> trace.next_free;		/* get index to last used cell */
      124 	count, total = dp -> trace.last_available;	/* get size of trace array */
      125 
      126 	do i = 1 to cu_$arg_count ();
      127 	     call cu_$arg_ptr (i, tp, tc, code);	/* pick up the argument (if it's given) */
      128 	     if targ = "-long" | targ = "-lg" then longsw = "1"b;
      129 	     else if targ = "-no_header" | targ = "-nhe" then header = "0"b;
      130 	     else if targ = "-output_switch" | targ = "-os" then do;
      131 		i = i + 1;
      132 		call cu_$arg_ptr (i, tp, tc, code);
      133 		if code ^= 0 then do;
      134 		     call com_err_ (code, "page_trace", "-output_switch must be followed by a switch name.");
      135 		     return;
      136 		end;
      137 		call iox_$look_iocb (targ, switch_ptr, code);
      138 		if code ^= 0 then do;
      139 		     call com_err_ (code, "page_trace", "Switch ^a not found.", targ);
      140 		     return;
      141 		end;
      142 	     end;
      143 	     else if targ = "-from" | targ = "-fm" then do;
      144 		i = i + 1;
      145 		call cu_$arg_ptr (i, tp, tc, code);
      146 		if code ^= 0 then do;
      147 		     call com_err_ (code, "page_trace", "-from must be followed by a character string.");
      148 		     return;
      149 		end;
      150 		from = targ;
      151 	     end;
      152 	     else if targ = "-to" then do;
      153 		i = i + 1;
      154 		call cu_$arg_ptr (i, tp, tc, code);
      155 		if code ^= 0 then do;
      156 		     call com_err_ (code, "page_trace", "-to must be followed by a character string.");
      157 		     return;
      158 		end;
      159 		stop_at_marker = "1"b;
      160 		to = targ;
      161 	     end;
      162 	     else if targ = "-npf" | targ = "-no_pagefaults" then print_pagefaults = ""b;
      163 	     else if substr (targ, 1, 1) = "-" then do;	/* mispelled ctl arg */
      164 		call com_err_ (error_table_$badopt, "page_trace", "^a", targ);
      165 		return;
      166 	     end;
      167 	     else do;
      168 		count_given = "1"b;
      169 		on conversion go to bad_count;	/* trap bad numbers */
      170 		count = convert (count, targ);	/* convert args to binary */
      171 		revert conversion;			/* make handler go away */
      172 		if count <= 0 | count > total then do;
      173 bad_count:
      174 		     call com_err_ (0, "page_trace", "Invalid count value given, ^a", targ);
      175 		     return;
      176 		end;
      177 	     end;
      178 	end;
      179 
      180 	if count_given & (from ^= "" | to ^= "") then do;
      181 	     call com_err_ (error_table_$inconsistent, "page_trace",
      182 		"count and ^[-from ^]^[-to ^]", (from ^= ""), (to ^= ""));
      183 	     return;
      184 	end;
      185 
      186 	if header
      187 	then call ioa_$ioa_switch (switch_ptr, "^/^-^-Elapsed^/     Trace Type    Time (ms) Ring Segno Page^-Segment^/");
      188 
      189 	if count > next
      190 	then start_index = total + next - count + 1;
      191 	else start_index = next - count + 1;
      192 
      193 	if from ^= ""				/* -from specified? */
      194 	then if count > next
      195 	     then do i = start_index to total, 1 to next;
      196 		trace_ptr = addr (dp -> trace.data (i));
      197 		if trace_ptr -> page_trace_entry.type = marker_type
      198 		then if trace_ptr -> based_char_4 = from
      199 		     then do;
      200 			start_index = i;
      201 			go to scan;
      202 		     end;
      203 		count = count - 1;
      204 	     end;
      205 	     else do i = start_index to next;
      206 		trace_ptr = addr (dp -> trace.data (i));
      207 		if trace_ptr -> page_trace_entry.type = marker_type
      208 		then if trace_ptr -> based_char_4 = from
      209 		     then do;
      210 			start_index = i;
      211 			go to scan;
      212 		     end;
      213 		count = count - 1;
      214 	     end;
      215 
      216 scan:
      217 	if count > next
      218 	then do i = start_index to total, 1 to next;	/* wrap-around ? */
      219 	     trace_ptr = addr (dp -> trace.data (i));	/* get pointer to entry */
      220 	     call output;
      221 	     if stop_at_marker
      222 	     then if trace_ptr -> page_trace_entry.type = marker_type
      223 		then if trace_ptr -> based_char_4 = to
      224 		     then go to done;
      225 	end;
      226 	else do i = start_index to next;		/* no wrap-around, just scan the last 'count' */
      227 	     trace_ptr = addr (dp -> trace.data (i));	/* get pointer to entry */
      228 	     call output;
      229 	     if stop_at_marker
      230 	     then if trace_ptr -> page_trace_entry.type = marker_type
      231 		then if trace_ptr -> based_char_4 = to
      232 		     then go to done;
      233 	end;
      234 
      235 done:
      236 	call ioa_$ioa_switch (switch_ptr, "");
      237 	return;
      238 
      239 output:	proc;
      240 
      241 	     if unspec (trace_ptr -> page_trace_entry) = "0"b
      242 		then return;
      243 
      244 	     type = trace_ptr -> page_trace_entry.type;
      245 	     time = trace_ptr -> page_trace_entry.time;
      246 	     if time = 65535 then ftime = 0e0;
      247 	     else ftime = time*64/1e3;		/* convert the time to milli-seconds */
      248 
      249 	     if type = page_fault_type | type = seg_fault_start
      250 		| type = seg_fault_end
      251 		| type = boundfault_start | type = boundfault_end
      252 		then seg_no = trace_ptr -> page_trace_entry.segment_number;
      253 
      254 	     else if type = extended_page_fault_type
      255 		then seg_no = binary (trace_ptr -> extended_page_trace_entry.tsr_segno_1 
      256 		|| trace_ptr -> extended_page_trace_entry.tsr_segno_2, 12);
      257 
      258 	     else if type = linkage_fault_end
      259 	     then do;
      260 		eptr = trace_ptr -> packedptr;
      261 		call get_entry_name_ (eptr, entry_name, seg_no, comp_name, code);
      262 		if entry_name = "" then entry_name = "0";
      263 	     end;
      264 
      265 	     else if type = linkage_fault_start then do;
      266 		eptr = trace_ptr->packedptr;
      267 		offset = binary(rel(eptr),18);
      268 		entry_name = "";
      269 		on not_in_read_bracket goto ISGATE;
      270 		call interpret_bind_map_(eptr,entry_name,offset,code );
      271 		revert not_in_read_bracket;
      272 ISGATE:
      273 		if entry_name ^= "" then entry_name = ": " || entry_name;
      274 		seg_no = binary(baseno(eptr),18);
      275 	     end;
      276 
      277 	     else seg_no = -1;
      278 
      279 	     if seg_no ^= -1 then call get_segment_name (seg_no, dirname, ename);
      280 	     else dirname, ename = "";
      281 	     
      282 
      283 
      284 	     page_no = 0;
      285 	     ring_no = 0;
      286 	     proc_name = "";
      287 	     proc_segno = 0;
      288 	     proc_offset = 0;
      289 	     long = binary (longsw, 1);
      290 
      291 	     if type = page_fault_type then do;
      292 		if ^print_pagefaults then return;
      293 		page_no = trace_ptr -> page_trace_entry.page_number;
      294 		ring_no = trace_ptr -> page_trace_entry.ring;
      295 		fmtx = 0 + long;
      296 	     end;
      297 	     else if type = extended_page_fault_type then do;
      298 		page_no = trace_ptr -> extended_page_trace_entry.tsr_pageno;
      299 		proc_segno = trace_ptr -> extended_page_trace_entry.psr_segno;
      300 		proc_offset = trace_ptr -> extended_page_trace_entry.psr_offset;
      301 		call get_segment_name (proc_segno, (""), proc_name);
      302 		fmtx = 10 + long;
      303 	     end;
      304 	     else if type = seg_fault_start then do;
      305 		string = "SEG-FAULT-START";
      306 		fmtx = 2 + long;
      307 	     end;
      308 	     else if type = seg_fault_end then do;
      309 		string = "SEG-FAULT-END";
      310 		fmtx = 2 + long;
      311 	     end;
      312 	     else if type = boundfault_start then do;
      313 		string = "BOUND-FAULT-START";
      314 		fmtx = 2 + long;
      315 	     end;
      316 	     else if type = boundfault_end then do;
      317 		string = "BOUND-FAULT-END";
      318 		fmtx = 2 + long;
      319 	     end;
      320 	     else if type = linkage_fault_start then do;
      321 		if seg_no = 0 then do;
      322 		     string = "MAKE-PTR-CALL";
      323 		     fmtx = 7;
      324 		end;
      325 		else do;
      326 		     string = "LINKAGE FAULT BY";
      327 		     fmtx = 8 + long;
      328 		end;
      329 	     end;
      330 	     else if type = linkage_fault_end then do;
      331 		string = "RESOLVED LINK TO";
      332 		fmtx = 4 + long;
      333 	     end;
      334 	     else if type = signaller_type then do;
      335 		string = "SIGNAL GENERATED";
      336 		fmtx = 6;
      337 		ename = trace_ptr -> based_char_4;
      338 	     end;
      339 	     else if type = restart_fault_type then do;
      340 		string = "SIGNAL RESTARTED";
      341 		fmtx = 7;
      342 	     end;
      343 	     else if type = reschedule_type then do;
      344 		string = "RESCHEDULING";
      345 		fmtx = 7;
      346 	     end;
      347 	     else if type = marker_type then do;
      348 		string = "USER MARKER";
      349 		fmtx = 6;
      350 		ename = trace_ptr -> based_char_4;
      351 	     end;
      352 	     else do;
      353 		string = "UNRECOGNIZABLE ENTRY";
      354 		fmtx = 6;
      355 		ename = trace_ptr -> based_char_4;
      356 	     end;
      357 
      358 	     call ioa_$ioa_switch (switch_ptr, output_format (fmtx),
      359 		string, ftime, ring_no, seg_no, page_no, dirname, ename,
      360 		entry_name, offset, proc_name, proc_offset);
      361 
      362 	     return;
      363 	end;
      364 
      365 print_trace_entry: entry (a_trace_ptr, a_switch_ptr, a_longsw);
      366 
      367 /*	internal interface provided for cumulative_page_trace.
      368*   *	It interprets and prints one entry from the system trace array.
      369**/
      370 
      371 dcl  a_trace_ptr ptr;				/* pointer to entry in system trace array */
      372 dcl  a_switch_ptr ptr;				/* switch_ptr onto which output is placed */
      373 dcl  a_longsw bit (1) aligned;			/* set to "1"b if -long was given */
      374 
      375 	hcscnt = active_all_rings_data_$hcscnt;
      376 	switch_ptr = a_switch_ptr;
      377 	trace_ptr = a_trace_ptr;
      378 	longsw = a_longsw;
      379 	print_pagefaults = "1"b;
      380 
      381 	call output;
      382 
      383 	return;
      384 
      385 
      386 get_segment_name:
      387 proc (segment_number, dname, ename);
      388 
      389 dcl segment_number fixed bin;
      390 dcl dname char (*);
      391 dcl ename char (*);
      392 
      393 dcl temp fixed bin;
      394 
      395 	     if segment_number >= active_all_rings_data_$hcscnt then do; /* if user initiated segment ... */
      396 		call hcs_$fs_get_path_name (baseptr (segment_number), dname, temp, ename, code);
      397 		if code ^= 0 then do;
      398 		     dname = "";
      399 		     ename = "*** unknown segment ***";
      400 		end;
      401 		else if ^longsw then if ename = "" then ename = ">"; /* root */
      402 	     end;
      403 	     else do;
      404 		call ring0_get_$name (dname, ename, baseptr (segment_number), code);
      405 		dname = "";
      406 	     end;
      407 
      408 end get_segment_name;
      409 
      410 end page_trace;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    06/04/84  1241.7  page_trace.pl1                    >spec>temp>bce>on>page_trace.pl1
104          1    06/01/84  1103.3  sys_trace.incl.pl1                >spec>temp>bce>on>sys_trace.incl.pl1
105          2    03/29/82  1006.9  trace_types.incl.pl1              >ldd>include>trace_types.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_longsw                               parameter       bit(1)                   dcl 373 ref 365 378
a_switch_ptr                           parameter       pointer                  dcl 372 ref 365 376
a_trace_ptr                            parameter       pointer                  dcl 371 ref 365 377
active_all_rings_data_$hcscnt   000010 external static fixed bin(17,0)          dcl 76 ref 120 375 395
addr                                                   builtin function         dcl 96 ref 109 196 206 219 227
based_char_4                           based           char(4)                  dcl 53 ref 197 207 221 229 337 350 355
baseno                                                 builtin function         dcl 96 ref 274
baseptr                                                builtin function         dcl 96 ref 396 396 404 404
binary                                                 builtin function         dcl 96 ref 254 267 274 289
boundfault_end                         constant        fixed bin(17,0)          initial dcl 2-3 ref 249 316
boundfault_start                       constant        fixed bin(17,0)          initial dcl 2-3 ref 249 312
code                            000135 automatic       fixed bin(35,0)          dcl 31 set ref 127* 132* 133 134* 137* 138 139* 145*
                                                                                  146 147* 154* 155 156* 261* 270* 396* 397 404*
com_err_                        000032 constant        entry                    external dcl 83 ref 134 139 147 156 164 173 181
comp_name                       002240 automatic       char(8)                  unaligned dcl 31 set ref 261*
conversion                      002256 stack reference condition                dcl 100 ref 169 171
convert                                                builtin function         dcl 96 ref 170
count                           000127 automatic       fixed bin(17,0)          dcl 31 set ref 124* 170* 170 172 172 189 189 191 193
                                                                                  203* 203 213* 213 216
count_given                     000105 automatic       bit(1)                   dcl 31 set ref 113* 168* 180
cu_$arg_count                   000036 constant        entry                    external dcl 83 ref 126
cu_$arg_ptr                     000034 constant        entry                    external dcl 83 ref 127 132 145 154
data                     10            based           structure                array level 2 dcl 1-7 set ref 196 206 219 227
data_area                       000136 automatic       fixed bin(17,0)          array dcl 31 set ref 109
dirname                         002143 automatic       char(168)                unaligned dcl 31 set ref 279* 280* 358*
dname                                  parameter       char                     unaligned dcl 390 set ref 386 396* 398* 404* 405*
dp                              000106 automatic       pointer                  dcl 31 set ref 109* 110* 123 124 196 206 219 227
ename                                  parameter       char                     unaligned dcl 391 in procedure "get_segment_name"
                                                                                  set ref 386 396* 399* 401 401* 404*
ename                           002215 automatic       char(32)                 unaligned dcl 31 in procedure "pgt" set ref 279*
                                                                                  280* 337* 350* 355* 358*
entry_name                      002242 automatic       char(32)                 unaligned dcl 31 set ref 261* 262 262* 268* 270* 272
                                                                                  272* 272 358*
eptr                            000110 automatic       pointer                  dcl 31 set ref 260* 261* 266* 267 270* 274
error_table_$badopt             000014 external static fixed bin(35,0)          dcl 78 set ref 164*
error_table_$inconsistent       000016 external static fixed bin(35,0)          dcl 79 set ref 181*
extended_page_fault_type               constant        fixed bin(17,0)          initial dcl 2-3 ref 254 297
extended_page_trace_entry              based           structure                level 1 dcl 1-36
fmtx                            000133 automatic       fixed bin(17,0)          dcl 31 set ref 295* 302* 306* 310* 314* 318* 323*
                                                                                  327* 332* 336* 341* 345* 349* 354* 358
from                            000115 automatic       char(4)                  dcl 31 set ref 116* 150* 180 181 193 197 207
ftime                           002254 automatic       float bin(27)            dcl 31 set ref 246* 247* 358*
get_entry_name_                 000030 constant        entry                    external dcl 83 ref 261
hcs_$fs_get_path_name           000022 constant        entry                    external dcl 83 ref 396
hcs_$get_page_trace             000020 constant        entry                    external dcl 83 ref 110
hcscnt                          002142 automatic       fixed bin(17,0)          dcl 31 set ref 120* 375*
header                          000100 automatic       bit(1)                   dcl 31 set ref 129* 186
i                               000130 automatic       fixed bin(17,0)          dcl 31 set ref 126* 127* 131* 131 132* 144* 144 145*
                                                                                  153* 153 154* 193* 196 200* 205* 206 210* 216*
                                                                                  219* 226* 227*
interpret_bind_map_             000040 constant        entry                    external dcl 83 ref 270
ioa_$ioa_switch                 000024 constant        entry                    external dcl 83 ref 186 235 358
iox_$look_iocb                  000026 constant        entry                    external dcl 83 ref 137
iox_$user_output                000012 external static pointer                  dcl 76 ref 121
last_available            1            based           fixed bin(17,0)          level 2 packed unsigned unaligned dcl 1-7 ref 124
linkage_fault_end                      constant        fixed bin(17,0)          initial dcl 2-3 ref 258 330
linkage_fault_start                    constant        fixed bin(17,0)          initial dcl 2-3 ref 265 320
long                            000132 automatic       fixed bin(17,0)          dcl 31 set ref 289* 295 302 306 310 314 318 327 332
longsw                          000101 automatic       bit(1)                   dcl 31 set ref 112* 128* 289 378* 401
marker_seen                     000103 automatic       bit(1)                   dcl 31 set ref 118*
marker_type                            constant        fixed bin(17,0)          initial dcl 2-3 ref 197 207 221 229 347
next                            000125 automatic       fixed bin(17,0)          dcl 31 set ref 123* 189 189 191 193 193 205 216 216
                                                                                  226
next_free                              based           fixed bin(17,0)          level 2 packed unsigned unaligned dcl 1-7 ref 123
not_in_read_bracket             000000 stack reference condition                dcl 100 ref 269 271
offset                          000124 automatic       fixed bin(18,0)          dcl 31 set ref 267* 270* 358*
output_format                   000000 constant        varying char(50)         initial array dcl 60 set ref 358*
packedptr                              based           pointer                  unaligned dcl 53 ref 260 266
page_fault_type                        constant        fixed bin(17,0)          initial dcl 2-3 ref 249 291
page_no                         002141 automatic       fixed bin(17,0)          dcl 31 set ref 284* 293* 298* 358*
page_number               1(06)        based           fixed bin(12,0)          level 2 packed unsigned unaligned dcl 1-27 ref 293
page_trace_entry                       based           structure                level 1 dcl 1-27 ref 241
print_pagefaults                000102 automatic       bit(1)                   dcl 31 set ref 114* 162* 292 379*
proc_name                       002225 automatic       char(32)                 unaligned dcl 31 set ref 286* 301* 358*
proc_offset                     002235 automatic       fixed bin(18,0)          dcl 31 set ref 288* 300* 358*
proc_segno                      002236 automatic       fixed bin(17,0)          dcl 31 set ref 287* 299* 301*
psr_offset                0(12)        based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 1-36 ref 300
psr_segno                              based           fixed bin(12,0)          level 2 packed unsigned unaligned dcl 1-36 ref 299
rel                                                    builtin function         dcl 96 ref 267
reschedule_type                        constant        fixed bin(17,0)          initial dcl 2-3 ref 343
restart_fault_type                     constant        fixed bin(17,0)          initial dcl 2-3 ref 339
ring                      0(18)        based           fixed bin(3,0)           level 2 packed unsigned unaligned dcl 1-27 ref 294
ring0_get_$name                 000042 constant        entry                    external dcl 83 ref 404
ring_no                         000114 automatic       fixed bin(3,0)           dcl 31 set ref 285* 294* 358*
seg_fault_end                          constant        fixed bin(17,0)          initial dcl 2-3 ref 249 308
seg_fault_start                        constant        fixed bin(17,0)          initial dcl 2-3 ref 249 304
seg_no                          002140 automatic       fixed bin(17,0)          dcl 31 set ref 249* 254* 261* 274* 277* 279 279* 321
                                                                                  358*
segment_number                         parameter       fixed bin(17,0)          dcl 389 in procedure "get_segment_name" ref 386 395
                                                                                  396 396 404 404
segment_number            0(21)        based           fixed bin(15,0)          level 2 in structure "page_trace_entry" packed
                                                                                  unsigned unaligned dcl 1-27 in procedure "pgt" ref
                                                                                  249
signaller_type                         constant        fixed bin(17,0)          initial dcl 2-3 ref 334
start_index                     000134 automatic       fixed bin(17,0)          dcl 31 set ref 189* 191* 193 200* 205 210* 216 226
stop_at_marker                  000104 automatic       bit(1)                   dcl 31 set ref 115* 159* 221 229
string                          000117 automatic       char(20)                 unaligned dcl 31 set ref 305* 309* 313* 317* 322*
                                                                                  326* 331* 335* 340* 344* 348* 353* 358*
substr                                                 builtin function         dcl 96 ref 163
switch_ptr                      002252 automatic       pointer                  dcl 31 set ref 121* 137* 186* 235* 358* 376*
targ                                   based           char                     unaligned dcl 53 set ref 128 128 129 129 130 130
                                                                                  137* 139* 143 143 150 152 160 162 162 163 164* 170
                                                                                  173*
tc                              000131 automatic       fixed bin(17,0)          dcl 31 set ref 127* 128 128 129 129 130 130 132* 137
                                                                                  137 139 139 143 143 145* 150 152 154* 160 162 162
                                                                                  163 164 164 170 173 173
temp                            000114 automatic       fixed bin(17,0)          dcl 393 set ref 396*
time                      1(20)        based           fixed bin(16,0)          level 2 in structure "page_trace_entry" packed
                                                                                  unsigned unaligned dcl 1-27 in procedure "pgt" ref
                                                                                  245
time                            002136 automatic       fixed bin(17,0)          dcl 31 in procedure "pgt" set ref 245* 246 247
to                              000116 automatic       char(4)                  dcl 31 set ref 117* 160* 180 181 221 229
total                           000126 automatic       fixed bin(17,0)          dcl 31 set ref 124* 172 189 193 216
tp                              000112 automatic       pointer                  dcl 31 set ref 127* 128 128 129 129 130 130 132* 137
                                                                                  139 143 143 145* 150 152 154* 160 162 162 163 164
                                                                                  170 173
trace                                  based           structure                level 1 dcl 1-7
trace_ptr                       002264 automatic       pointer                  dcl 1-5 set ref 196* 197 197 206* 207 207 219* 221
                                                                                  221 227* 229 229 241 244 245 249 254 254 260 266
                                                                                  293 294 298 299 300 337 350 355 377*
tsr_pageno                1(12)        based           fixed bin(8,0)           level 2 packed unsigned unaligned dcl 1-36 ref 298
tsr_segno_1               0(30)        based           bit(6)                   level 2 packed unaligned dcl 1-36 ref 254
tsr_segno_2               1(06)        based           bit(6)                   level 2 packed unaligned dcl 1-36 ref 254
type                            002137 automatic       fixed bin(17,0)          dcl 31 in procedure "pgt" set ref 244* 249 249 249
                                                                                  249 249 254 258 265 291 297 304 308 312 316 320
                                                                                  330 334 339 343 347
type                      1            based           fixed bin(6,0)           level 2 in structure "page_trace_entry" packed
                                                                                  unsigned unaligned dcl 1-27 in procedure "pgt" ref
                                                                                  197 207 221 229 244
unspec                                                 builtin function         dcl 96 ref 241

NAME DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
interrupt_type                         internal static fixed bin(17,0)          initial dcl 2-3

NAMES DECLARED BY EXPLICIT CONTEXT.
ISGATE                          002253 constant        label                    dcl 272 ref 269
bad_count                       001334 constant        label                    dcl 173 ref 169
done                            001757 constant        label                    dcl 235 ref 221 229
get_segment_name                002702 constant        entry                    internal dcl 386 ref 279 301
output                          002033 constant        entry                    internal dcl 239 ref 220 228 381
page_trace                      000552 constant        entry                    external dcl 27
pgt                             000543 constant        entry                    external dcl 27
print_trace_entry               002001 constant        entry                    external dcl 365
scan                            001643 constant        label                    dcl 216 ref 201 211

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3324        3370    3063        3334
Length      3630    3063        44         223     240           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
pgt                                1432 external procedure  is an external procedure.  
on unit on line 169                  64 on unit               
output                              180 internal procedure  enables or reverts conditions.  
on unit on line 269                  64 on unit               
get_segment_name                        internal procedure  shares stack frame of internal procedure output.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
output                   000114 temp                        get_segment_name
pgt                      000100 header                      pgt
                         000101 longsw                      pgt
                         000102 print_pagefaults            pgt
                         000103 marker_seen                 pgt
                         000104 stop_at_marker              pgt
                         000105 count_given                 pgt
                         000106 dp                          pgt
                         000110 eptr                        pgt
                         000112 tp                          pgt
                         000114 ring_no                     pgt
                         000115 from                        pgt
                         000116 to                          pgt
                         000117 string                      pgt
                         000124 offset                      pgt
                         000125 next                        pgt
                         000126 total                       pgt
                         000127 count                       pgt
                         000130 i                           pgt
                         000131 tc                          pgt
                         000132 long                        pgt
                         000133 fmtx                        pgt
                         000134 start_index                 pgt
                         000135 code                        pgt
                         000136 data_area                   pgt
                         002136 time                        pgt
                         002137 type                        pgt
                         002140 seg_no                      pgt
                         002141 page_no                     pgt
                         002142 hcscnt                      pgt
                         002143 dirname                     pgt
                         002215 ename                       pgt
                         002225 proc_name                   pgt
                         002235 proc_offset                 pgt
                         002236 proc_segno                  pgt
                         002240 comp_name                   pgt
                         002242 entry_name                  pgt
                         002252 switch_ptr                  pgt
                         002254 ftime                       pgt
                         002264 trace_ptr                   pgt

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
fx1_to_fl2          r_ne_as             alloc_cs            call_ext_out_desc   call_ext_out        call_int_this
return              tra_ext             enable              shorten_stack       ext_entry           int_entry
any_to_any_tr

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_count                 cu_$arg_ptr                   get_entry_name_
hcs_$fs_get_path_name         hcs_$get_page_trace           interpret_bind_map_           ioa_$ioa_switch
iox_$look_iocb                ring0_get_$name

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
active_all_rings_data_$hcscnt error_table_$badopt           error_table_$inconsistent     iox_$user_output




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     27 000542       109 000557       110 000561       112 000567       113 000570       114 000571       115 000573
    116 000574       117 000576       118 000577       120 000600       121 000603       123 000606       124 000611
    126 000616       127 000631       128 000646       129 000663       130 000675       131 000705       132 000706
    133 000723       134 000725       135 000755       137 000756       138 001002       139 001004       140 001043
    142 001044       143 001045       144 001055       145 001056       146 001073       147 001075       148 001125
    150 001126       151 001133       152 001134       153 001140       154 001141       155 001156       156 001160
    157 001210       159 001211       160 001213       161 001220       162 001221       163 001233       164 001237
    165 001275       168 001276       169 001300       170 001317       171 001327       172 001330       173 001334
    175 001374       178 001375       180 001377       181 001413       183 001466       186 001467       189 001511
    191 001522       193 001526       196 001547       197 001554       200 001563       201 001565       203 001566
    204 001570       205 001611       206 001621       207 001625       210 001634       211 001636       213 001637
    214 001641       216 001643       219 001657       220 001664       221 001670       225 001702       226 001723
    227 001733       228 001737       229 001743       233 001755       235 001757       237 001774       365 001775
    375 002006       376 002011       377 002015       378 002020       379 002023       381 002025       383 002031
    239 002032       241 002040       244 002046       245 002051       246 002054       247 002061       249 002065
    254 002103       258 002120       260 002122       261 002127       262 002157       263 002167       265 002170
    266 002172       267 002177       268 002202       269 002205       270 002224       271 002252       272 002253
    274 002273       275 002300       277 002301       279 002303       280 002327       284 002335       285 002337
    286 002340       287 002343       288 002344       289 002345       291 002350       292 002352       293 002354
    294 002361       295 002365       296 002370       297 002371       298 002373       299 002400       300 002403
    301 002407       302 002427       303 002433       304 002434       305 002436       306 002441       307 002444
    308 002445       309 002447       310 002452       311 002455       312 002456       313 002460       314 002463
    315 002466       316 002467       317 002471       318 002474       319 002477       320 002500       321 002502
    322 002504       323 002507       324 002511       326 002512       327 002515       329 002520       330 002521
    331 002523       332 002526       333 002531       334 002532       335 002534       336 002537       337 002541
    338 002545       339 002546       340 002550       341 002553       342 002555       343 002556       344 002560
    345 002563       346 002565       347 002566       348 002570       349 002573       350 002575       351 002601
    353 002602       354 002605       355 002607       358 002613       362 002701       386 002702       395 002720
    396 002725       397 002762       398 002765       399 002773       400 003000       401 003001       402 003015
    404 003016       405 003047       408 003055


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
