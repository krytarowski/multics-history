THIS FILE IS DAMAGED

	COMPILATION LISTING OF SEGMENT rbf_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/17/88  1041.0 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 /*****************************************************************************/
       11 /*							       */
       12 /*   DESCRIPTION:						       */
       13 /*							       */
       14 /*        This IO module is analogous to g115_.  It handles remote batch to  */
       15 /*   a Level 6M Satellite over an X.25 connection in the same way that g115_ */
       16 /*   does remote batch over an RCI connection.  It uses tty_ to do its IO.   */
       17 /*   The four possible devices which are supported, reader, punch, printer,  */
       18 /*   and teleprinter, all use the same communications channel, therefore,    */
       19 /*   the channel name can not contain stars.			       */
       20 /*							       */
       21 /*****************************************************************************/
       22 
       23 
       24 /****^  HISTORY COMMENTS:
       25*  1) change(82-06-01,RKissel), approve(), audit(), install():
       26*     Written.
       27*  2) change(87-03-17,LJAdams), approve(87-04-03,MCR7646),
       28*     audit(87-05-05,Gilcrease), install(87-05-14,MR12.1-1030):
       29*     Changed ttd_version to ttd_version_3.
       30*                                                   END HISTORY COMMENTS */
       31 
       32 
       33 /* format: style3,linecom,ifthenstmt,indthenelse,^indnoniterdo,indnoniterend,initcol3,dclind5,idind32 */
       34 
       35 rbf_:
       36      proc ();
       37 
       38 ERROR_EXIT:
       39 	return;
       40 
       41 /* Parameter */
       42 
       43 dcl  a_buffer_len		       fixed bin (21) parameter;
       44 dcl  a_bufferp		       ptr parameter;
       45 dcl  a_code		       fixed bin (35) parameter;
       46 dcl  a_comerr_sw		       bit (1) parameter;
       47 dcl  a_infop		       ptr parameter;
       48 dcl  a_iocbp		       ptr parameter;
       49 dcl  a_new_modes		       char (*) parameter;
       50 dcl  a_old_modes		       char (*) parameter;
       51 dcl  a_open_mode		       fixed bin parameter;
       52 dcl  a_option		       (*) char (*) var parameter;
       53 dcl  a_order		       char (*) parameter;
       54 dcl  a_record_len		       fixed bin (21) parameter;
       55 dcl  a_recordp		       ptr parameter;
       56 
       57 /* Automatic */
       58 
       59 dcl  1 auto_area_info	       aligned like area_info;
       60 dcl  1 auto_ttd		       aligned like terminal_type_data;
       61 
       62 dcl  based_area		       area (sys_info$max_seg_size) based (areap);
       63 
       64 dcl  bcd_equiv		       (0:63) char (1) unal defined (bcd_equiv_string);
       65 dcl  code			       fixed bin (35);
       66 dcl  comerr_sw		       bit (1);
       67 dcl  dummy_arg		       char (32);
       68 dcl  i			       fixed bin;
       69 dcl  input_trp		       ptr;
       70 dcl  iocbp		       ptr;
       71 dcl  mask			       bit (36) aligned;
       72 dcl  next_attach_description	       char (256) varying unaligned;
       73 dcl  next_attach_options	       char (256) varying unaligned;
       74 dcl  next_channel		       char (32) varying unaligned;
       75 dcl  next_io_module		       char (32) varying unaligned;
       76 dcl  next_io_switch_name	       char (32) varying unaligned;
       77 dcl  open_mode		       fixed bin;
       78 dcl  output_chars_to_write	       fixed bin (21);
       79 dcl  output_trp		       ptr;
       80 dcl  my_attach_description	       char (256) var;
       81 dcl  slew_by_count_char	       (0:15) char (1) unaligned defined (legal_slew_chars) pos (2);
       82 dcl  temp_ptr		       ptr;
       83 
       84 /* Structure to define per-attachment data for each rbf_ switch attachment. */
       85 
       86 dcl  radp			       ptr;
       87 
       88 dcl  1 rbf_attach_data	       based (radp),
       89        2 attach_description	       char (256) var,
       90        2 open_description	       char (256) var,
       91        2 modes		       char (256) var,
       92        2 translations,				/* translation tables */
       93          3 input		       char (512),
       94          3 output		       char (512),
       95        2 terminal_type	       char (32),
       96        2 device		       char (32),		/* name of generic type of remote device */
       97        2 device_type	       fixed bin,		/* generic device in fixed bin form */
       98        2 comm_data_ptr	       ptr;		/* common data for this attachment. */
       99 
      100 /* Structure for holding communication line specific data for all attachments to this line. */
      101 
      102 dcl  cdbp			       ptr;		/* pointer to the comm data block. */
      103 
      104 dcl  1 comm_data_block	       aligned based (cdbp),
      105        2 forward_ptr	       ptr,		/* Forward data block chain. */
      106        2 backward_ptr	       ptr,		/* Backward data block chain. */
      107        2 comm_channel	       char (32) unaligned,	/* Name of the channel for this RBF station. */
      108        2 comm_io_module	       char (32) unaligned,	/* Name of the IO module to use. */
      109        2 comm_iocbp		       ptr,		/* iocb ptr for this RBF station. */
      110        2 comm_event_channel	       fixed bin (71),	/* event channel used by the IO module. */
      111        2 timer_event_channel	       fixed bin (71),	/* event channel for use by runout control. */
      112        2 temp_seg_ptrs	       (2) ptr,		/* 1 is input buffer, 2 is output buffer */
      113        2 temp_seg_lens	       (2) fixed bin (21),
      114        2 number_of_attachments       fixed bin,
      115        2 input_chars_read	       fixed bin (21),
      116        2 input_buffer_position       fixed bin (21),
      117        2 flags		       aligned,
      118          3 comm_attached	       bit (1) unaligned,
      119          3 comm_open	       bit (1) unaligned,
      120          3 we_just_wrote	       bit (1) unaligned,
      121          3 pad		       bit (33) unaligned;
      122 
      123 dcl  input_buffer		       char (input_buffer_len) based (input_buffer_ptr);
      124 dcl  input_buffer_ptr	       ptr defined (comm_data_block.temp_seg_ptrs (1));
      125 dcl  input_buffer_len	       fixed bin (21) defined (comm_data_block.temp_seg_lens (1));
      126 
      127 dcl  output_buffer		       char (output_buffer_len) based (output_buffer_ptr);
      128 dcl  output_buffer_ptr	       ptr defined (comm_data_block.temp_seg_ptrs (2));
      129 dcl  output_buffer_len	       fixed bin (21) defined (comm_data_block.temp_seg_lens (2));
      130 
      131 /* Builtin Functions and Conditions */
      132 
      133 dcl  addr			       builtin;
      134 dcl  bin			       builtin;
      135 dcl  codeptr		       builtin;
      136 dcl  collate9		       builtin;
      137 dcl  copy			       builtin;
      138 dcl  currentsize		       builtin;
      139 dcl  dimension		       builtin;
      140 dcl  divide		       builtin;
      141 dcl  hbound		       builtin;
      142 dcl  index		       builtin;
      143 dcl  lbound		       builtin;
      144 dcl  length		       builtin;
      145 dcl  null			       builtin;
      146 dcl  rtrim		       builtin;
      147 dcl  substr		       builtin;
      148 dcl  translate		       builtin;
      149 dcl  unspec		       builtin;
      150 dcl  verify		       builtin;
      151 
      152 dcl  any_other		       condition;
      153 dcl  cleanup		       condition;
      154 
      155 /* Internal Static */
      156 
      157 dcl  areap		       ptr int static init (null);
      158 dcl  debug_flag		       bit (1) int static init ("0"b);
      159 dcl  first_cdbp		       ptr internal static init (null ());
      160 dcl  last_cdbp		       ptr internal static init (null ());
      161 
      162 /* Internal Constants */
      163 
      164 dcl  bcd_equiv_string	       char (64) unal int static options (constant)
      165 			       init ("0123456789[#@:>? ABCDEFGHI&.](<\^JKLMNOPQR-$*);'+/STUVWXYZ_,%=""!");
      166 dcl  CR			       char (1) internal static options (constant) init ("");
      167 dcl  default_modes		       char (14) init ("8bit,rawi,rawo") int static options (constant);
      168 dcl  device_names		       (4) char (32) int static options (constant)
      169 			       init ("teleprinter", "reader", "printer", "punch");
      170 dcl  legal_slew_chars	       char (19) int static options (constant) init (" 0123456789[#@:>?AB");
      171 						/* printer slew codes, in order:
      172*						   Top of form - space
      173*						   slew 0 to 15 lines - 0...?
      174*						   VFU_1 - A, VFU_2 - B */
      175 dcl  lowercase		       char (26) int static options (constant) init ("abcdefghijklmnopqrstuvwxyz");
      176 dcl  MY_NAME		       char (4) int static options (constant) init ("rbf_");
      177 dcl  REL_SECONDS		       bit (2) int static options (constant) init ("11"b);
      178 dcl  space		       char (1) int static options (constant) init (" ");
      179 dcl  uppercase		       char (26) int static options (constant) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
      180 
      181 /* The following are RBF specific constants. */
      182 
      183 dcl  1 RBF		       aligned internal static options (constant),
      184 						/* This group defines input/output media codes associated with records within the text of a message block */
      185        2 media_codes	       unal,
      186          3 bcd_input_mc	       char (1) init ("H"),	/* Input media code for BCD data - 110 octal */
      187          3 bin_input_mc	       char (1) init ("P"),	/* Input media code for Binary data - 120 octal */
      188          3 printer_mc	       char (1) init ("L"),	/* printer output media code - 114 octal */
      189          3 punch_bcd_mc	       char (1) init ("O"),	/* punch output media code (BCD data)  - 117 octal */
      190          3 punch_bin_mc	       char (1) init ("W"),	/* punch output media code (Binary data)  - 127 octal */
      191          3 teleprinter_mc	       char (1) init ("N"),	/* teleprinter output media code - 116 octal */
      192 						/* This group defines the message format codes which apply to all records in a single message block */
      193        2 format_codes	       unal,
      194          3 info_ns_nc	       bit (9) init ("110"b3),/* information message, no split, no compression */
      195          3 info_ns_c	       bit (9) init ("111"b3),/* information message, no split, compression */
      196          3 info_s_nc	       bit (9) init ("112"b3),/* information message, split, no compression */
      197          3 info_s_c		       bit (9) init ("113"b3),/* information message, split, compression */
      198          3 special_nc	       bit (9) init ("104"b3),/* Special control record, no compression */
      199          3 special_c	       bit (9) init ("105"b3),/* Special control record, compression */
      200 						/* This group defines reserved characters which appear in the message block */
      201        2 char_codes		       unal,
      202          3 stx_char		       bit (9) init ("002"b3),/* start-of-text (STX) char */
      203          3 etx_char		       bit (9) init ("003"b3),/* end-of-text (ETX) char */
      204          3 soh_char		       bit (9) init ("001"b3),/* start-of-header (SOH) char */
      205          3 addr_code_char	       bit (9) init ("100"b3),/* address code character */
      206          3 id_code_char	       bit (9) init ("100"b3),/* identification code character */
      207          3 RS		       char (1) init (""),	/* record separator - 036 octal */
      208          3 CC		       char (1) init (""),	/* compression character code - 037 octal */
      209 						/* The maximum size of a single rci message from SOH to ETX */
      210        2 max_msg_len	       fixed bin init (324);	/* max data in a message */
      211 
      212 /* External Entries */
      213 
      214 dcl  com_err_		       entry () options (variable);
      215 dcl  continue_to_signal_	       entry (fixed bin (35));
      216 dcl  convert_ipc_code_	       entry (fixed bin (35));
      217 dcl  get_system_free_area_	       entry () returns (ptr);
      218 dcl  get_temp_segments_	       entry (char (*), (*) ptr, fixed bin (35));
      219 dcl  hcs_$set_ips_mask	       entry (bit (36) aligned, bit (36) aligned);
      220 dcl  hcs_$reset_ips_mask	       entry (bit (36) aligned, bit (36) aligned);
      221 dcl  ipc_$block		       entry (ptr, ptr, fixed bin (35));
      222 dcl  ipc_$create_ev_chn	       entry (fixed bin (71), fixed bin (35));
      223 dcl  ipc_$delete_ev_chn	       entry (fixed bin (71), fixed bin (35));
      224 dcl  ipc_$drain_chn		       entry (fixed bin (71), fixed bin (35));
      225 dcl  l6_tran_util_$get_chars	       entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
      226 dcl  l6_tran_util_$put_chars	       entry (ptr, ptr, fixed bin (21), fixed bin (35));
      227 dcl  mode_string_$parse	       entry (char (*), ptr, ptr, fixed bin (35));
      228 dcl  release_temp_segments_	       entry (char (*), (*) ptr, fixed bin (35));
      229 dcl  timer_manager_$alarm_wakeup     entry (fixed bin (71), bit (2), fixed bin (71));
      230 dcl  timer_manager_$reset_alarm_wakeup
      231 			       entry (fixed bin (71));
      232 dcl  ttt_info_$terminal_data	       entry (char (*), fixed bin, fixed bin, ptr, fixed bin (35));
      233 dcl  unique_chars_		       entry (bit (*)) returns (char (15));
      234 
      235 /* External Constants */
      236 
      237 dcl  error_table_$bad_mode	       fixed bin (35) ext static;
      238 dcl  error_table_$bad_mode_value     fixed bin (35) ext static;
      239 dcl  error_table_$badopt	       fixed bin (35) ext static;
      240 dcl  error_table_$eof_record	       fixed bin (35) ext static;
      241 dcl  error_table_$improper_data_format
      242 			       fixed bin (35) ext static;
      243 dcl  error_table_$invalid_read       fixed bin (35) ext static;
      244 dcl  error_table_$long_record	       fixed bin (35) ext static;
      245 dcl  error_table_$noarg	       fixed bin (35) ext static;
      246 dcl  error_table_$not_attached       fixed bin (35) ext static;
      247 dcl  error_table_$not_closed	       fixed bin (35) ext static;
      248 dcl  error_table_$not_detached       fixed bin (35) ext static;
      249 dcl  error_table_$not_open	       fixed bin (35) ext static;
      250 dcl  error_table_$null_info_ptr      fixed bin (35) ext static;
      251 dcl  error_table_$short_record       fixed bin (35) ext static;
      252 dcl  error_table_$smallarg	       fixed bin (35) ext static;
      253 dcl  error_table_$unimplemented_version
      254 			       fixed bin (35) ext static;
      255 dcl  error_table_$wrong_no_of_args   fixed bin (35) ext static;
      256 
      257 dcl  sys_info$max_seg_size	       fixed bin (35) ext static;
      258 
      259 rbf_attach:
      260      entry (a_iocbp, a_option, a_comerr_sw, a_code);
      261 
      262 	comerr_sw = debug_flag | a_comerr_sw;
      263 	iocbp = a_iocbp;
      264 
      265 /* See if we are already attached. */
      266 
      267 	if iocbp -> iocb.attach_descrip_ptr ^= null
      268 	     then do;
      269 		a_code = error_table_$not_detached;
      270 		return;
      271 		end;
      272 
      273 /* Get an area to work in if we don't already have one. */
      274 
      275 	if areap = null () then areap = get_system_free_area_ ();
      276 
      277 /* Make a quick consistency check, must have: -tty arg -comm arg -device arg. */
      278 
      279 	if hbound (a_option, 1) < 6
      280 	     then call Abort_Attach (error_table_$wrong_no_of_args, MY_NAME, "Invalid attach description", "");
      281 
      282 /* Initialize for the cleanup handler. */
      283 
      284 	next_io_module = "";
      285 	next_channel = "";
      286 	next_attach_options = "";
      287 	my_attach_description = "";
      288 
      289 	cdbp = null ();
      290 	radp = null ();
      291 
      292 	on cleanup call Attach_Cleanup ();
      293 
      294 /* Allocate a structure to hold our attach data, and initialize it. */
      295 
      296 	allocate rbf_attach_data in (based_area) set (radp);
      297 
      298 	rbf_attach_data.attach_description = "";
      299 	rbf_attach_data.open_description = "";
      300 	rbf_attach_data.modes = default_modes;
      301 	rbf_attach_data.translations = "";
      302 	rbf_attach_data.terminal_type = "";
      303 	rbf_attach_data.device = "";
      304 	rbf_attach_data.device_type = 0;
      305 	rbf_attach_data.comm_data_ptr = null ();
      306 
      307 /* Process the attachment arguments. */
      308 
      309 	my_attach_description = MY_NAME;
      310 
      311 	do i = 1 to hbound (a_option, 1);
      312 
      313 	     my_attach_description = my_attach_description || space || a_option (i);
      314 
      315 	     if a_option (i) = "-device" then rbf_attach_data.device = Get_Option_Arg (i);
      316 
      317 	     else if a_option (i) = "-tty" then next_channel = Get_Option_Arg (i);
      318 
      319 	     else if a_option (i) = "-comm" then next_io_module = Get_Option_Arg (i);
      320 
      321 	     else if a_option (i) = "-ascii" then ;
      322 
      323 	     else if a_option (i) = "-ebcdic" then ;
      324 
      325 	     else if a_option (i) = "-physical_line_length" | a_option (i) = "-pll" then dummy_arg = Get_Option_Arg (i);
      326 
      327 	     else if a_option (i) = "-delay" then dummy_arg = Get_Option_Arg (i);
      328 
      329 	     else if a_option (i) = "-terminal_type" | a_option (i) = "-ttp"
      330 		then rbf_attach_data.terminal_type = Get_Option_Arg (i);
      331 
      332 	     else next_attach_options = next_attach_options || space || a_option (i);
      333 	end;					/* do i = ... */
      334 
      335 /* Make some checks on the arguments. */
      336 
      337 	if next_io_module ^= "tty_" then call Abort_Attach (0, MY_NAME, "Invalid or missing -comm option", "");
      338 
      339 	if next_channel = "" then call Abort_Attach (0, MY_NAME, "No -tty option given", "");
      340 
      341 	do i = lbound (device_names, 1) to hbound (device_names, 1) while (rbf_attach_data.device ^= device_names (i));
      342 	end;
      343 
      344 	if i > hbound (device_names, 1)
      345 	     then call Abort_Attach (error_table_$badopt, MY_NAME, "Invalid device specified", "");
      346 	     else rbf_attach_data.device_type = i;
      347 
      348 /* Get translation information and then set input and output translation. */
      349 
      350 	if rbf_attach_data.terminal_type ^= ""
      351 	     then do;
      352 		rbf_attach_data.terminal_type = translate (rbf_attach_data.terminal_type, uppercase, lowercase);
      353 
      354 		auto_ttd.version = ttd_version_3;
      355 		call ttt_info_$terminal_data (rbf_attach_data.terminal_type, -1, 0, addr (auto_ttd), code);
      356 		if code ^= 0 then call Abort_Attach (code, MY_NAME, "Unknown terminal type specified", "");
      357 
      358 		input_trp = auto_ttd.tables.input_tr_ptr;
      359 		output_trp = auto_ttd.tables.output_tr_ptr;
      360 		end;
      361 
      362 	     else do;
      363 		input_trp = null ();
      364 		output_trp = null ();
      365 		end;
      366 
      367 	call Set_Translation (rbf_attach_data.translations.input, input_trp);
      368 	call Set_Translation (rbf_attach_data.translations.output, output_trp);
      369 
      370 /* Now see if we already know about the target channel. */
      371 
      372 	do temp_ptr = first_cdbp repeat (temp_ptr -> comm_data_block.forward_ptr)
      373 	     while (temp_ptr ^= null () & cdbp = null ());
      374 	     if temp_ptr -> comm_data_block.comm_channel = next_channel then cdbp = temp_ptr;
      375 	end;
      376 
      377 /* See if we found a comm_data_block, if not create and initialize one. */
      378 
      379 	if cdbp = null ()
      380 	     then do;
      381 		allocate comm_data_block in (based_area) set (cdbp);
      382 
      383 		comm_data_block.forward_ptr = null ();
      384 		comm_data_block.backward_ptr = last_cdbp;
      385 		comm_data_block.comm_channel = next_channel;
      386 		comm_data_block.comm_io_module = next_io_module;
      387 		comm_data_block.comm_iocbp = null ();
      388 		comm_data_block.comm_event_channel = 0;
      389 		comm_data_block.timer_event_channel = 0;
      390 		comm_data_block.temp_seg_ptrs (*) = null ();
      391 						/* Input and output buffers. */
      392 		comm_data_block.temp_seg_lens (*) = sys_info$max_seg_size;
      393 		comm_data_block.number_of_attachments = 0;
      394 		comm_data_block.input_chars_read = 0;
      395 		comm_data_block.input_buffer_position = 1;
      396 		comm_data_block.flags = "0"b;
      397 
      398 		/*** Get temp segments for the input and output buffers. */
      399 
      400 		call get_temp_segments_ (MY_NAME, comm_data_block.temp_seg_ptrs, code);
      401 		if code ^= 0 then call Abort_Attach (code, MY_NAME, "Unable to get input and output buffers", "");
      402 
      403 		/*** Get an event channel for use by the timer used by the runout control order. */
      404 
      405 		call ipc_$create_ev_chn (comm_data_block.timer_event_channel, code);
      406 		if code ^= 0
      407 		     then do;
      408 			call convert_ipc_code_ (code);
      409 			call Abort_Attach (code, MY_NAME, "Unable to get a timer event channel during attachment.",
      410 			     "");
      411 			end;
      412 
      413 		/*** Link it into the chain of comm_data_blocks. */
      414 
      415 		if first_cdbp = null ()
      416 		     then first_cdbp = cdbp;
      417 		     else last_cdbp -> comm_data_block.forward_ptr = cdbp;
      418 
      419 		last_cdbp = cdbp;
      420 		end;
      421 
      422 /* Finish setting up our attach description data. */
      423 
      424 	rbf_attach_data.comm_data_ptr = cdbp;
      425 
      426 /* If necessary, attach and open the communications IO module we will use. */
      427 
      428 	if ^comm_data_block.flags.comm_attached
      429 	     then do;				/* We need to attach. */
      430 		next_io_switch_name = MY_NAME || "." || unique_chars_ (""b);
      431 		next_attach_description = next_io_module || space || next_channel || space || next_attach_options;
      432 
      433 		call iox_$attach_name ((next_io_switch_name), comm_data_block.comm_iocbp, (next_attach_description),
      434 		     codeptr (rbf_attach), code);
      435 		if code ^= 0 then call Abort_Attach (code, MY_NAME, "Unable to attach communications channel", "");
      436 
      437 		comm_data_block.flags.comm_attached = "1"b;
      438 		comm_data_block.flags.comm_open = "0"b;
      439 		end;				/* We need to attach. */
      440 
      441 	if ^comm_data_block.flags.comm_open
      442 	     then do;				/* We need to open. */
      443 		call iox_$open (comm_data_block.comm_iocbp, Stream_input_output, "0"b, code);
      444 		if code ^= 0 then call Abort_Attach (code, MY_NAME, "Unable to open the communications switch.", "");
      445 
      446 		/*** Set initial modes. */
      447 
      448 		call iox_$modes (comm_data_block.comm_iocbp, default_modes, (""), code);
      449 		if code ^= 0
      450 		     then call Abort_Attach (code, MY_NAME,
      451 			     "Unable to set initial modes on the communications switch.", "");
      452 
      453 		/*** Get the event channel used by the comm module. */
      454 
      455 		call iox_$control (comm_data_block.comm_iocbp, "get_event_channel",
      456 		     addr (comm_data_block.comm_event_channel), code);
      457 		if code ^= 0
      458 		     then call Abort_Attach (code, MY_NAME,
      459 			     "Unable to get the event channel for the communications switch.", "");
      460 
      461 		comm_data_block.flags.comm_open = "1"b;
      462 		end;				/* We need to open. */
      463 
      464 /* Remember that we have attached a device to this channel. */
      465 
      466 	comm_data_block.number_of_attachments = comm_data_block.number_of_attachments + 1;
      467 
      468 /* Make changes to iocb. */
      469 
      470 	mask = "0"b;
      471 	on any_other call Any_Other_Handler ();
      472 
      473 	call hcs_$set_ips_mask ("0"b, mask);
      474 
      475 	iocbp -> iocb.attach_descrip_ptr = addr (rbf_attach_data.attach_description);
      476 	iocbp -> iocb.attach_data_ptr = radp;
      477 	iocbp -> iocb.open = rbf_open;
      478 	iocbp -> iocb.detach_iocb = rbf_detach_iocb;
      479 
      480 	call iox_$propagate (iocbp);
      481 
      482 	call hcs_$reset_ips_mask (mask, mask);
      483 
      484 	revert any_other;
      485 
      486 	return;
      487 
      488 rbf_detach_iocb:
      489      entry (a_iocbp, a_code);
      490 
      491 	a_code = 0;
      492 	iocbp = a_iocbp;
      493 
      494 /* Make sure that switch is closed and attached. */
      495 
      496 	if iocbp -> iocb.attach_descrip_ptr = null
      497 	     then do;
      498 		a_code = error_table_$not_attached;
      499 		return;
      500 		end;
      501 
      502 	if iocbp -> iocb.open_descrip_ptr ^= null
      503 	     then do;
      504 		a_code = error_table_$not_closed;
      505 		return;
      506 		end;
      507 
      508 	radp = iocbp -> iocb.attach_data_ptr;
      509 	cdbp = rbf_attach_data.comm_data_ptr;
      510 
      511 /* Remove this device from the communications data. */
      512 
      513 	comm_data_block.number_of_attachments = comm_data_block.number_of_attachments - 1;
      514 
      515 	call Attach_Cleanup ();			/* Get rid of everything we should. */
      516 
      517 	mask = "0"b;
      518 	on any_other call Any_Other_Handler;
      519 
      520 	call hcs_$set_ips_mask ("0"b, mask);
      521 
      522 	iocbp -> attach_descrip_ptr = null;
      523 
      524 	call iox_$propagate (iocbp);
      525 
      526 	call hcs_$reset_ips_mask (mask, mask);
      527 
      528 	revert any_other;
      529 
      530 	return;
      531 
      532 rbf_open:
      533      entry (a_iocbp, a_open_mode, a_comerr_sw, a_code);
      534 
      535 	a_code = 0;
      536 	iocbp = a_iocbp -> iocb.actual_iocb_ptr;
      537 
      538 /* Make sure that switch is attached and closed. */
      539 
      540 	if iocbp -> iocb.attach_descrip_ptr = null
      541 	     then do;
      542 		a_code = error_table_$not_attached;
      543 		return;
      544 		end;
      545 
      546 	if iocbp -> iocb.open_descrip_ptr ^= null
      547 	     then do;
      548 		a_code = error_table_$not_closed;
      549 		return;
      550 		end;
      551 
      552 	radp = iocbp -> iocb.attach_data_ptr;
      553 
      554 /* Check opening modes. */
      555 
      556 	open_mode = a_open_mode;
      557 
      558 	if ^((open_mode = Sequential_input) | (open_mode = Sequential_output) | (open_mode = Sequential_input_output))
      559 	     then do;
      560 		a_code = error_table_$bad_mode;
      561 		return;
      562 		end;
      563 
      564 	rbf_attach_data.open_description = rtrim (iox_modes (open_mode));
      565 
      566 	mask = "0"b;
      567 	on any_other call Any_Other_Handler;
      568 
      569 	call hcs_$set_ips_mask ("0"b, mask);
      570 
      571 	if open_mode = Sequential_input | open_mode = Sequential_input_output
      572 	     then iocbp -> iocb.read_record = rbf_read_record;
      573 
      574 	if open_mode = Sequential_output | open_mode = Sequential_input_output
      575 	     then iocbp -> iocb.write_record = rbf_write_record;
      576 
      577 	iocbp -> iocb.control = rbf_control;
      578 	iocbp -> iocb.modes = rbf_modes;
      579 	iocbp -> iocb.close = rbf_close;
      580 	iocbp -> iocb.detach_iocb = rbf_detach_iocb;
      581 	iocbp -> iocb.open_descrip_ptr = addr (rbf_attach_data.open_description);
      582 
      583 	call iox_$propagate (iocbp);
      584 
      585 	call hcs_$reset_ips_mask (mask, mask);
      586 
      587 	revert any_other;
      588 
      589 	return;
      590 
      591 rbf_close:
      592      entry (a_iocbp, a_code);
      593 
      594 	a_code = 0;
      595 	iocbp = a_iocbp -> iocb.actual_iocb_ptr;
      596 
      597 /* Make sure that switch is attached and open. */
      598 
      599 	if iocbp -> iocb.attach_descrip_ptr = null ()
      600 	     then do;
      601 		a_code = error_table_$not_attached;
      602 		return;
      603 		end;
      604 
      605 	if iocbp -> iocb.open_descrip_ptr = null
      606 	     then do;
      607 		a_code = error_table_$not_open;
      608 		return;
      609 		end;
      610 
      611 	mask = "0"b;
      612 	on any_other call Any_Other_Handler;
      613 
      614 	call hcs_$set_ips_mask ("0"b, mask);
      615 
      616 	iocbp -> iocb.open_descrip_ptr = null;
      617 	iocbp -> iocb.open = rbf_open;
      618 	iocbp -> iocb.detach_iocb = rbf_detach_iocb;
      619 
      620 	iocbp -> iocb.control = iox_$err_no_operation;
      621 	iocbp -> iocb.modes = iox_$err_no_operation;
      622 	iocbp -> iocb.read_record = iox_$err_no_operation;
      623 	iocbp -> iocb.write_record = iox_$err_no_operation;
      624 
      625 	call iox_$propagate (iocbp);
      626 
      627 	call hcs_$reset_ips_mask (mask, mask);
      628 
      629 	revert any_other;
      630 
      631 	return;
      632 
      633 rbf_read_record:
      634      entry (a_iocbp, a_bufferp, a_buffer_len, a_record_len, a_code);
      635 
      636 dcl  compression_count	       fixed bin;
      637 dcl  current_char		       char (1);
      638 dcl  end_of_record		       bit (1);
      639 dcl  error_code		       fixed bin (35);
      640 dcl  read_record_state	       fixed bin;
      641 dcl  user_buffer_len	       fixed bin (21);
      642 
      643 
      644 	iocbp = a_iocbp -> iocb.actual_iocb_ptr;
      645 	a_record_len = 0;
      646 	a_code = 0;
      647 
      648 	radp = iocbp -> iocb.attach_data_ptr;
      649 	cdbp = rbf_attach_data.comm_data_ptr;
      650 
      651 	if rbf_attach_data.device_type ^= TELEPRINTER_DEVICE & rbf_attach_data.device_type ^= READER_DEVICE
      652 	     then do;				/* can't read from all devices */
      653 		a_code = error_table_$invalid_read;
      654 		return;
      655 		end;
      656 
      657 /* Validate that there is room in the buffer to hold some actual data in addition to a terminal_io_record header. */
      658 
      659 	terminal_io_record_ptr = a_bufferp;
      660 
      661 	user_buffer_len = a_buffer_len - divide (length (unspec (terminal_io_record.header)), 9, 21);
      662 
      663 	if user_buffer_len <= 0
      664 	     then do;
      665 		a_code = error_table_$smallarg;
      666 		return;
      667 		end;
      668 
      669 	terminal_io_record_data_chars_varying_max_len = user_buffer_len;
      670 
      671 /* Initialize the return structure. */
      672 
      673 	terminal_io_record.version = terminal_io_record_version_1;
      674 	terminal_io_record.device_type = 0;
      675 	terminal_io_record.slew_type = SLEW_BY_COUNT;
      676 	terminal_io_record.slew_count = 1;
      677 	terminal_io_record.flags = "0"b;
      678 	terminal_io_record.element_size = 9;
      679 	terminal_io_record.n_elements = 0;		/* Initially the null string. */
      680 
      681 /* Check to see if we have to tell the L6 that he can send, this is also done in the read_status order. */
      682 
      683 	if comm_data_block.flags.we_just_wrote
      684 	     then do;				/* Tell him he can send. */
      685 		call Check_Write_Status (code);
      686 		if code ^= 0 then goto READ_ERROR;
      687 
      688 		call Send_EOM (code);
      689 		if code ^= 0 then goto READ_ERROR;
      690 
      691 		call Check_Write_Status (code);
      692 		if code ^= 0 then goto READ_ERROR;
      693 
      694 		comm_data_block.flags.we_just_wrote = "0"b;
      695 		end;				/* Tell him he can send. */
      696 
      697 
      698 /* Read in the record, one character at a time since there may be compressed text. */
      699 
      700 	read_record_state = 1;
      701 	error_code = 0;
      702 	end_of_record = "0"b;
      703 
      704 	do while (^end_of_record);
      705 
      706 	     if comm_data_block.input_buffer_position > comm_data_block.input_chars_read
      707 		then do;				/* We need some more data. */
      708 		     call l6_tran_util_$get_chars (comm_data_block.comm_iocbp, input_buffer_ptr, input_buffer_len,
      709 			comm_data_block.input_chars_read, code);
      710 		     if code ^= error_table_$short_record & code ^= 0 then goto READ_ERROR;
      711 
      712 		     comm_data_block.input_buffer_position = 1;
      713 		     end;				/* We need some more data. */
      714 
      715 	     current_char = substr (input_buffer, comm_data_block.input_buffer_position, 1);
      716 
      717 	     goto RECORD_PARSER (read_record_state);
      718 
      719 RECORD_PARSER (1):					/* Handle the media code. */
      720 	     if current_char = RBF.media_codes.bcd_input_mc then terminal_io_record.device_type = READER_DEVICE;
      721 
      722 	     else if current_char = RBF.media_codes.bin_input_mc
      723 		then do;
      724 		     terminal_io_record.device_type = READER_DEVICE;
      725 		     terminal_io_record.flags.binary = "1"b;
      726 		     end;
      727 
      728 	     else if current_char = RBF.media_codes.teleprinter_mc
      729 		then terminal_io_record.device_type = TELEPRINTER_DEVICE;
      730 
      731 	     else do;				/* Not an input record but read it anyway. */
      732 		terminal_io_record.device_type = 0;
      733 		error_code = error_table_$improper_data_format;
      734 		end;
      735 
      736 	     comm_data_block.input_buffer_position = comm_data_block.input_buffer_position + 1;
      737 	     read_record_state = 2;
      738 
      739 	     goto NEXT_STATE;
      740 
      741 RECORD_PARSER (2):					/* Handle normal char, compression char, or EOR char. */
      742 	     if current_char = RBF.char_codes.CC then read_record_state = 3;
      743 						/* Decompress the previous char. */
      744 
      745 	     else if current_char = RBF.char_codes.RS then end_of_record = "1"b;
      746 						/* We are done. */
      747 
      748 	     else do;				/* A normal character. */
      749 		if length (terminal_io_record_data_chars_varying) < user_buffer_len
      750 		     then terminal_io_record_data_chars_varying =
      751 			     terminal_io_record_data_chars_varying || current_char;
      752 		     else error_code = error_table_$long_record;
      753 						/* Must throw it away. */
      754 
      755 		read_record_state = 2;
      756 		end;
      757 
      758 	     comm_data_block.input_buffer_position = comm_data_block.input_buffer_position + 1;
      759 
      760 	     goto NEXT_STATE;
      761 
      762 RECORD_PARSER (3):					/* Handle the compression count character. */
      763 	     compression_count = index (bcd_equiv_string, current_char);
      764 
      765 	     if compression_count <= 1
      766 		then do;				/* Min is 2, max is 63. */
      767 		     if current_char < substr (bcd_equiv_string, 2, 1)
      768 			then compression_count = 2;
      769 			else compression_count = 63;
      770 		     end;
      771 
      772 	     if user_buffer_len - length (terminal_io_record_data_chars_varying) < compression_count
      773 		then do;				/* Not enough room in the user buffer. */
      774 		     error_code = error_table_$long_record;
      775 		     compression_count = user_buffer_len - length (terminal_io_record_data_chars_varying);
      776 
      777 		     if compression_count <= 0 then compression_count = 0;
      778 		     end;
      779 
      780 	     terminal_io_record_data_chars_varying =
      781 		terminal_io_record_data_chars_varying
      782 		||
      783 		copy (
      784 		substr (terminal_io_record_data_chars_varying, length (terminal_io_record_data_chars_varying), 1),
      785 		compression_count);
      786 
      787 	     comm_data_block.input_buffer_position = comm_data_block.input_buffer_position + 1;
      788 	     read_record_state = 2;
      789 
      790 	     goto NEXT_STATE;
      791 
      792 NEXT_STATE:
      793 	end;					/* Loop through the record. */
      794 
      795 /* Finally, do the translation and we are done. */
      796 
      797 	terminal_io_record_data_chars_varying =
      798 	     translate (terminal_io_record_data_chars_varying, rbf_attach_data.translations.input, collate9 ());
      799 
      800 /* Check for a $*$ card, and if it is one, then give back a zero length record. */
      801 
      802 	if length (terminal_io_record_data_chars_varying) >= 3
      803 	     then if substr (terminal_io_record_data_chars_varying, 1, 3) = "$*$"
      804 		     then terminal_io_record.n_elements = 0;
      805 
      806 /* Check for an end of file record from the card reader and return the right code. */
      807 
      808 	if terminal_io_record_data_chars_varying = "++EOF" | terminal_io_record_data_chars_varying = "++eof"
      809 	     then error_code = error_table_$eof_record;
      810 
      811 	a_record_len = 4 * currentsize (terminal_io_record);
      812 	a_code = error_code;
      813 
      814 	return;
      815 
      816 READ_ERROR:
      817 	a_code = code;
      818 
      819 	return;
      820 
      821 rbf_write_record:
      822      entry (a_iocbp, a_recordp, a_record_len, a_code);
      823 
      824 dcl  media_code		       char (1);
      825 dcl  rep_count		       fixed bin;
      826 dcl  slew_char		       char (1);
      827 dcl  slew_count		       fixed bin (18);
      828 
      829 	iocbp = a_iocbp -> iocb.actual_iocb_ptr;
      830 	a_code = 0;
      831 
      832 	radp = iocbp -> iocb.attach_data_ptr;
      833 	cdbp = rbf_attach_data.comm_data_ptr;
      834 	terminal_io_record_ptr = a_recordp;
      835 
      836 /* Check arguments for inconsistencies. */
      837 
      838 	if terminal_io_record.version ^= terminal_io_record_version_1
      839 	     then do;
      840 		a_code = error_table_$unimplemented_version;
      841 		return;
      842 		end;
      843 
      844 	if terminal_io_record.preslew
      845 	     then do;
      846 		a_code = error_table_$improper_data_format;
      847 		return;
      848 		end;
      849 
      850 /* Set media code and slew character. */
      851 
      852 	slew_count = 0;
      853 
      854 	if terminal_io_record.device_type = TELEPRINTER_DEVICE
      855 	     then do;
      856 		media_code = RBF.media_codes.teleprinter_mc;
      857 		slew_char = CR;
      858 		end;
      859 
      860 	else if terminal_io_record.device_type = PRINTER_DEVICE
      861 	     then do;
      862 		media_code = RBF.media_codes.printer_mc;
      863 
      864 		if terminal_io_record.slew_type = SLEW_BY_COUNT
      865 		     then do;
      866 			slew_count = terminal_io_record.slew_count;
      867 
      868 			if slew_count < lbound (slew_by_count_char, 1)
      869 			     then do;
      870 				a_code = error_table_$improper_data_format;
      871 				return;
      872 				end;
      873 
      874 			if slew_count > hbound (slew_by_count_char, 1)
      875 			     then do;
      876 				slew_char = slew_by_count_char (hbound (slew_by_count_char, 1));
      877 						/* Do the most we can. */
      878 				slew_count = slew_count - hbound (slew_by_count_char, 1);
      879 						/* Figure what is left. */
      880 				end;
      881 
      882 			     else do;
      883 				slew_char = slew_by_count_char (slew_count);
      884 				slew_count = 0;	/* Nothing left. */
      885 				end;
      886 			end;
      887 
      888 		else if terminal_io_record.slew_type = SLEW_TO_TOP_OF_PAGE then slew_char = space;
      889 
      890 		else if terminal_io_record.slew_type = SLEW_TO_INSIDE_PAGE then slew_char = space;
      891 
      892 		else if terminal_io_record.slew_type = SLEW_TO_OUTSIDE_PAGE then slew_char = space;
      893 
      894 		else if terminal_io_record.slew_type = SLEW_TO_CHANNEL then slew_char = space;
      895 
      896 		else slew_char = "1";		/* All undefined slew types default to this */
      897 		end;
      898 
      899 	else if terminal_io_record.device_type = PUNCH_DEVICE
      900 	     then do;
      901 		if terminal_io_record.flags.binary
      902 		     then media_code = RBF.media_codes.punch_bin_mc;
      903 		     else media_code = RBF.media_codes.punch_bcd_mc;
      904 		end;
      905 
      906 	else media_code = "";
      907 
      908 /* If the data is binary, turn it into 6 bit chunks, otherwise, translate it. */
      909 
      910 	if (terminal_io_record.binary & terminal_io_record.element_size ^= 1)
      911 	     | (^terminal_io_record.binary & terminal_io_record.element_size ^= 9)
      912 	     then do;
      913 		a_code = error_table_$improper_data_format;
      914 		return;
      915 		end;
      916 
      917 	if terminal_io_record.binary
      918 	     then do;
      919 		terminal_io_record.n_elements = divide (terminal_io_record.n_elements + 5, 6, 18);
      920 		terminal_io_record.element_size = 6;
      921 
      922 		substr (output_buffer, 1, 1) = media_code;
      923 
      924 		do i = 1 to terminal_io_record.n_elements;
      925 		     substr (output_buffer, i + 1, 1) = bcd_equiv (bin (terminal_io_record.data.bits (i), 6));
      926 		end;
      927 		end;
      928 
      929 	     else do;
      930 		substr (output_buffer, 1, 1) = media_code;
      931 		substr (output_buffer, 2, terminal_io_record.n_elements) =
      932 		     translate (terminal_io_record_data_chars, rbf_attach_data.translations.output, collate9 ());
      933 		end;
      934 
      935 	output_chars_to_write = terminal_io_record.n_elements + 1;
      936 						/* Add the media_code length. */
      937 
      938 /* Perform data compression (except on teleprinter output). */
      939 
      940 	if rbf_attach_data.device_type ^= TELEPRINTER_DEVICE
      941 	     then do;
      942 		i = 2;
      943 
      944 		do while (i <= output_chars_to_write);	/* Do this since we may modify the counters. */
      945 
      946 		     rep_count =
      947 			verify (substr (output_buffer, i, output_chars_to_write - i + 1),
      948 			substr (output_buffer, i, 1)) - 1;
      949 
      950 		     if rep_count < 0 then rep_count = output_chars_to_write - i + 1;
      951 						/* everything matched. */
      952 
      953 		     if rep_count > 64 then rep_count = 64;
      954 						/* This is the limit. */
      955 
      956 		     if rep_count <= 3
      957 			then i = i + 1;		/* no compression needed. */
      958 
      959 			else do;			/* compress this one. */
      960 			     substr (output_buffer, i + 1, 1) = RBF.char_codes.CC;
      961 			     substr (output_buffer, i + 2, 1) = bcd_equiv (rep_count - 1);
      962 
      963 			     i = i + 3;
      964 			     output_chars_to_write = output_chars_to_write - rep_count + 3;
      965 
      966 			     substr (output_buffer, i, output_chars_to_write - i + 1) =
      967 				substr (output_buffer, i + rep_count - 3, output_chars_to_write - i + 1);
      968 						/* Shift the end of the data over the compressed chars. */
      969 			     end;
      970 		end;				/* Compression loop. */
      971 		end;				/* Perform data compression. */
      972 
      973 /* Now add slew control if necessary, and add the final record separator character. */
      974 
      975 	if media_code = RBF.media_codes.printer_mc | media_code = RBF.media_codes.teleprinter_mc
      976 	     then do;				/* Handle devices that slew. */
      977 		substr (output_buffer, output_chars_to_write + 1, 2) = slew_char || RBF.char_codes.RS;
      978 		output_chars_to_write = output_chars_to_write + 2;
      979 
      980 		if slew_count > 0
      981 		     then do;			/* Send null records to finish slewing. */
      982 			do while (slew_count > hbound (slew_by_count_char, 1));
      983 			     substr (output_buffer, output_chars_to_write + 1, 3) =
      984 				media_code || slew_by_count_char (hbound (slew_by_count_char, 1))
      985 				|| RBF.char_codes.RS;
      986 			     output_chars_to_write = output_chars_to_write + 3;
      987 			     slew_count = slew_count - hbound (slew_by_count_char, 1);
      988 			end;
      989 
      990 			if slew_count > 0
      991 			     then do;		/* Get the last bit. */
      992 				substr (output_buffer, output_chars_to_write + 1, 3) =
      993 				     media_code || slew_by_count_char (slew_count) || RBF.char_codes.RS;
      994 				output_chars_to_write = output_chars_to_write + 3;
      995 				end;
      996 			end;			/* Send null records to finish slewing. */
      997 		end;				/* Handle devices that slew. */
      998 
      999 	     else do;
     1000 		substr (output_buffer, output_chars_to_write + 1, 1) = RBF.char_codes.RS;
     1001 		output_chars_to_write = output_chars_to_write + 1;
     1002 		end;
     1003 
     1004 /* Transmit record to comm_io_module io switch. */
     1005 
     1006 	call l6_tran_util_$put_chars (comm_data_block.comm_iocbp, output_buffer_ptr, output_chars_to_write, a_code);
     1007 
     1008 /* Set a flag so the control and read_record entries can send the $*$EOM record. */
     1009 
     1010 	if rbf_attach_data.device_type = TELEPRINTER_DEVICE then comm_data_block.flags.we_just_wrote = "1"b;
     1011 
     1012 	return;
     1013 
     1014 rbf_control:
     1015      entry (a_iocbp, a_order, a_infop, a_code);
     1016 
     1017 
     1018 	a_code = 0;
     1019 
     1020 	iocbp = a_iocbp -> iocb.actual_iocb_ptr;
     1021 
     1022 /* Make sure the switch is attached and open. */
     1023 
     1024 	if iocbp -> iocb.attach_descrip_ptr = null
     1025 	     then do;
     1026 		a_code = error_table_$not_attached;
     1027 		return;
     1028 		end;
     1029 
     1030 	if iocbp -> iocb.open_descrip_ptr = null
     1031 	     then do;
     1032 		a_code = error_table_$not_open;
     1033 		return;
     1034 		end;
     1035 
     1036 	radp = iocbp -> iocb.attach_data_ptr;
     1037 	cdbp = rbf_attach_data.comm_data_ptr;
     1038 
     1039 	if a_order = "end_write_mode"
     1040 	     then do;				/* Handle end_write_mode. */
     1041 		call Check_Write_Status (code);
     1042 		if code ^= 0 then goto CONTROL_ERROR;
     1043 
     1044 		call Send_EOM (code);
     1045 		if code ^= 0 then goto CONTROL_ERROR;
     1046 
     1047 		call Check_Write_Status (code);
     1048 		if code ^= 0 then goto CONTROL_ERROR;
     1049 		end;				/* Handle end_write_mode. */
     1050 
     1051 	else if a_order = "runout"
     1052 	     then do;				/* Handle runout. */
     1053 		call Check_Write_Status (code);
     1054 		if code ^= 0 then goto CONTROL_ERROR;
     1055 		end;				/* Handle runout. */
     1056 
     1057 	else if a_order = "read_status"
     1058 	     then do;				/* Handle read_status. */
     1059 		tty_read_status_info_ptr = a_infop;
     1060 
     1061 		if tty_read_status_info_ptr = null ()
     1062 		     then do;
     1063 			a_code = error_table_$null_info_ptr;
     1064 			return;
     1065 			end;
     1066 
     1067 		if comm_data_block.flags.we_just_wrote
     1068 		     then do;			/* Tell him he can send. */
     1069 			call Check_Write_Status (code);
     1070 			if code ^= 0 then goto CONTROL_ERROR;
     1071 
     1072 			call Send_EOM (code);
     1073 			if code ^= 0 then goto CONTROL_ERROR;
     1074 
     1075 			call Check_Write_Status (code);
     1076 			if code ^= 0 then goto CONTROL_ERROR;
     1077 
     1078 			comm_data_block.flags.we_just_wrote = "0"b;
     1079 			end;			/* Tell him he can send. */
     1080 
     1081 /*
     1082*   We will assume that if we have any input then it is at least one record,
     1083*   even if it is only a $*$ card.  The same is true if tty_ has some input
     1084*   that we have'nt read yet.  Therefore, if we have any input, then our caller
     1085*   will not go blocked if he calls read_record.  If we don't then tty_ will
     1086*   return the right results.  That is, if it has some input, then we won't go
     1087*   blocked when we try to read a complete record, and if it does not have
     1088*   input, then it will send a wakeup when it gets some.
     1089**/
     1090 
     1091 		if comm_data_block.input_buffer_position <= comm_data_block.input_chars_read
     1092 		     then tty_read_status_info.input_pending = "1"b;
     1093 		     else tty_read_status_info.input_pending = "0"b;
     1094 
     1095 		/*** If we have input then just get the event channel else let tty_ do the work. */
     1096 
     1097 		if tty_read_status_info.input_pending
     1098 		     then call iox_$control (comm_data_block.comm_iocbp, "get_event_channel",
     1099 			     addr (tty_read_status_info.event_channel), a_code);
     1100 		     else call iox_$control (comm_data_block.comm_iocbp, "read_status", a_infop, a_code);
     1101 		end;				/* Handle read_status. */
     1102 
     1103 	else if a_order = "select_device" | a_order = "reset" | a_order = "binary_punch" then ;
     1104 						/* Ignore, done by magic in terminal_io_record. */
     1105 
     1106 /* Pass all other control orders on to the communications switch. */
     1107 
     1108 	else call iox_$control (comm_data_block.comm_iocbp, a_order, a_infop, a_code);
     1109 
     1110 	return;
     1111 
     1112 CONTROL_ERROR:
     1113 	a_code = code;
     1114 
     1115 	return;
     1116 
     1117 rbf_modes:
     1118      entry (a_iocbp, a_new_modes, a_old_modes, a_code);
     1119 
     1120 	a_code = 0;
     1121 	a_old_modes = "";
     1122 
     1123 	iocbp = a_iocbp -> iocb.actual_iocb_ptr;
     1124 
     1125 /* Make sure the switch is attached and open. */
     1126 
     1127 	if iocbp -> iocb.attach_descrip_ptr = null
     1128 	     then do;
     1129 		a_code = error_table_$not_attached;
     1130 		return;
     1131 		end;
     1132 
     1133 	if iocbp -> iocb.open_descrip_ptr = null
     1134 	     then do;
     1135 		a_code = error_table_$not_open;
     1136 		return;
     1137 		end;
     1138 
     1139 	radp = iocbp -> iocb.attach_data_ptr;
     1140 
     1141 	call mode_string_$parse (a_new_modes, areap, mode_string_info_ptr, a_code);
     1142 	if a_code ^= 0 then return;
     1143 
     1144 	if mode_string_info.version ^= mode_string_info_version_2
     1145 	     then do;
     1146 		a_code = error_table_$unimplemented_version;
     1147 		return;
     1148 		end;
     1149 
     1150 	do i = lbound (mode_string_info.modes, 1) to hbound (mode_string_info.modes, 1);
     1151 	     if mode_string_info.modes (i).mode_name = "rawi" | mode_string_info.modes (i).mode_name = "rawo"
     1152 		| mode_string_info.modes (i).mode_name = "8bit"
     1153 		then do;
     1154 		     if ^(mode_string_info.modes (i).boolean_valuep & mode_string_info.modes (i).boolean_value)
     1155 			then do;
     1156 			     a_code = error_table_$bad_mode_value;
     1157 			     return;
     1158 			     end;
     1159 		     end;
     1160 		else do;
     1161 		     a_code = error_table_$bad_mode;
     1162 		     return;
     1163 		     end;
     1164 	end;
     1165 
     1166 	a_old_modes = rbf_attach_data.modes;
     1167 	rbf_attach_data.modes = a_new_modes;
     1168 
     1169 	return;
     1170 
     1171 /* Internal routines */
     1172 
     1173 Get_Option_Arg:
     1174      proc (idx) returns (char (*) var);
     1175 
     1176 dcl  idx			       fixed bin parameter;
     1177 
     1178 	idx = idx + 1;
     1179 
     1180 	if idx > hbound (a_option, 1)
     1181 	     then call Abort_Attach (error_table_$noarg, MY_NAME, "No argument after ^a", (a_option (idx - 1)));
     1182 
     1183 	my_attach_description = my_attach_description || space || a_option (idx);
     1184 
     1185 	return (a_option (idx));
     1186 
     1187      end Get_Option_Arg;
     1188 
     1189 Any_Other_Handler:
     1190      proc ();
     1191 
     1192 	if mask then call hcs_$reset_ips_mask (mask, mask);
     1193 
     1194 	mask = "0"b;
     1195 
     1196 	call continue_to_signal_ ((0));
     1197 
     1198      end Any_Other_Handler;
     1199 
     1200 Attach_Cleanup:
     1201      proc ();
     1202 
     1203 dcl  code			       fixed bin (35);
     1204 
     1205 
     1206 	if radp ^= null then free rbf_attach_data in (based_area);
     1207 
     1208 	if cdbp ^= null ()
     1209 	     then do;
     1210 		if comm_data_block.number_of_attachments = 0
     1211 		     then do;
     1212 			if input_buffer_ptr ^= null () | output_buffer_ptr ^= null ()
     1213 			     then call release_temp_segments_ (MY_NAME, comm_data_block.temp_seg_ptrs, code);
     1214 
     1215 			if comm_data_block.comm_iocbp ^= null ()
     1216 			     then do;
     1217 				call iox_$close (comm_data_block.comm_iocbp, code);
     1218 				call iox_$detach_iocb (comm_data_block.comm_iocbp, code);
     1219 				call iox_$destroy_iocb (comm_data_block.comm_iocbp, code);
     1220 				end;
     1221 
     1222 			if comm_data_block.timer_event_channel ^= 0
     1223 			     then call ipc_$delete_ev_chn (comm_data_block.timer_event_channel, code);
     1224 
     1225 			call Free_Comm_Data_Block ();
     1226 			end;
     1227 		end;
     1228 
     1229 	return;
     1230 
     1231      end Attach_Cleanup;
     1232 
     1233 Abort_Attach:
     1234      proc (code, prog_name, control_str, arg_value);
     1235 
     1236 dcl  code			       fixed bin (35) parameter;
     1237 dcl  prog_name		       char (*) parameter;
     1238 dcl  control_str		       char (*) parameter;
     1239 dcl  arg_value		       char (*) parameter;
     1240 
     1241 	call Attach_Cleanup;
     1242 
     1243 	call Abort (code, prog_name, control_str, arg_value);
     1244 
     1245      end Abort_Attach;
     1246 
     1247 Abort:
     1248      proc (code, prog_name, control_str, arg_value);
     1249 
     1250 dcl  code			       fixed bin (35) parameter;
     1251 dcl  prog_name		       char (*) parameter;
     1252 dcl  control_str		       char (*) parameter;
     1253 dcl  arg_value		       char (*) parameter;
     1254 
     1255 
     1256 	if comerr_sw then call com_err_ (code, prog_name, control_str, arg_value);
     1257 	a_code = code;
     1258 
     1259 	go to ERROR_EXIT;
     1260 
     1261      end Abort;
     1262 
     1263 Check_Write_Status:
     1264      proc (code);
     1265 
     1266 /*
     1267*   This routine checks the write_status and loops until the write is complete.
     1268*   The timer is needed since write_status does not guarantee to send a
     1269*   wakeup if output_pending is set.
     1270**/
     1271 
     1272 dcl  code			       fixed bin (35) parameter;
     1273 
     1274 dcl  1 event_info		       aligned,
     1275        2 channel_id		       fixed bin (71),
     1276        2 message		       fixed bin (71),
     1277        2 sender		       bit (36),
     1278        2 origin,
     1279          3 dev_signal	       bit (18) unaligned,
     1280          3 ring		       bit (18) unaligned,
     1281        2 channel_index	       fixed bin;
     1282 
     1283 dcl  1 wait_list		       aligned,
     1284        2 nchan		       fixed bin,
     1285        2 pad		       fixed bin,
     1286        2 channel_id		       (2) fixed bin (71);
     1287 
     1288 dcl  1 write_status_info	       aligned,
     1289        2 ev_chan		       fixed bin (71),
     1290        2 output_pending	       bit (1);
     1291 
     1292 /* Set up a wait list for blocking in write_status. */
     1293 
     1294 	wait_list.nchan = 2;
     1295 	wait_list.pad = 0;
     1296 	wait_list.channel_id (1) = comm_data_block.comm_event_channel;
     1297 	wait_list.channel_id (2) = comm_data_block.timer_event_channel;
     1298 
     1299 	call iox_$control (comm_data_block.comm_iocbp, "write_status", addr (write_status_info), code);
     1300 	if code ^= 0 then return;
     1301 
     1302 	do while (write_status_info.output_pending & write_status_info.ev_chan ^= 0);
     1303 
     1304 	     call timer_manager_$alarm_wakeup (1, REL_SECONDS, comm_data_block.timer_event_channel);
     1305 
     1306 	     call ipc_$block (addr (wait_list), addr (event_info), code);
     1307 	     if code ^= 0
     1308 		then do;
     1309 		     call convert_ipc_code_ (code);
     1310 		     return;
     1311 		     end;
     1312 
     1313 	     call timer_manager_$reset_alarm_wakeup (comm_data_block.timer_event_channel);
     1314 
     1315 	     call ipc_$drain_chn (comm_data_block.timer_event_channel, code);
     1316 	     if code ^= 0
     1317 		then do;
     1318 		     call convert_ipc_code_ (code);
     1319 		     return;
     1320 		     end;
     1321 
     1322 	     call iox_$control (comm_data_block.comm_iocbp, "write_status", addr (write_status_info), code);
     1323 	     if code ^= 0 then return;
     1324 	end;					/* Write status loop. */
     1325 
     1326 	return;
     1327 
     1328      end Check_Write_Status;
     1329 
     1330 Free_Comm_Data_Block:
     1331      proc ();
     1332 
     1333 /* Unlinks and frees what cdbp points to. */
     1334 
     1335 	if comm_data_block.backward_ptr = null ()
     1336 	     then first_cdbp = comm_data_block.forward_ptr;
     1337 						/* It was the head of the chain. */
     1338 	     else comm_data_block.backward_ptr -> comm_data_block.forward_ptr = comm_data_block.forward_ptr;
     1339 
     1340 	if comm_data_block.forward_ptr = null ()
     1341 	     then last_cdbp = comm_data_block.backward_ptr;
     1342 						/* It was the tail of the chain. */
     1343 	     else comm_data_block.forward_ptr -> comm_data_block.backward_ptr = comm_data_block.backward_ptr;
     1344 
     1345 	free comm_data_block in (based_area);
     1346 	cdbp = null ();
     1347 
     1348 	return;
     1349 
     1350      end Free_Comm_Data_Block;
     1351 
     1352 Send_EOM:
     1353      proc (P_code);
     1354 
     1355 dcl  P_code		       fixed bin (35) parameter;
     1356 
     1357 	output_chars_to_write = length ("$*$EOM" || RBF.char_codes.RS);
     1358 	substr (output_buffer, 1, output_chars_to_write) = "$*$EOM" || RBF.char_codes.RS;
     1359 
     1360 	call l6_tran_util_$put_chars (comm_data_block.comm_iocbp, output_buffer_ptr, output_chars_to_write, P_code);
     1361 
     1362 
     1363 	return;
     1364 
     1365      end Send_EOM;
     1366 
     1367 Set_Translation:
     1368      proc (translate_table, trans_strucp);
     1369 
     1370 dcl  translate_table	       char (512) parameter;
     1371 dcl  trans_strucp		       ptr parameter;
     1372 
     1373 dcl  translate_string_len	       fixed bin (21);
     1374 dcl  translate_stringp	       ptr;
     1375 dcl  translate_string	       char (translate_string_len) based (translate_stringp);
     1376 
     1377 
     1378 	if trans_strucp = null
     1379 	     then translate_table = collate9 ();
     1380 
     1381 	     else do;
     1382 		translate_stringp = addr (trans_strucp -> cv_trans_struc.cv_trans.value);
     1383 		translate_string_len = dimension (trans_strucp -> cv_trans_struc.cv_trans.value, 1);
     1384 
     1385 		translate_table = translate_string;
     1386 
     1387 		if length (translate_table) > translate_string_len
     1388 		     then substr (translate_table, translate_string_len + 1) =
     1389 			     copy ("", length (translate_table) - translate_string_len);
     1390 		end;
     1391 
     1392 	return;
     1393 
     1394      end Set_Translation;
     1395 
  1     1 /* --------------- BEGIN include file iox_dcls.incl.pl1 --------------- */
  1     2 
  1     3 /* Written 05/04/78 by C. D. Tavares */
  1     4 /* Fixed declaration of iox_$find_iocb_n 05/07/80 by R. Holmstedt */
  1     5 /* Modified 5/83 by S. Krupp to add declarations for:  iox_$open_file,
  1     6*     iox_$close_file, iox_$detach and iox_$attach_loud entries. */
  1     7 
  1     8 dcl  iox_$attach_name entry (char (*), pointer, char (*), pointer, fixed bin (35)),
  1     9      iox_$attach_ptr entry (pointer, char (*), pointer, fixed bin (35)),
  1    10      iox_$close entry (pointer, fixed bin (35)),
  1    11      iox_$control entry (pointer, char (*), pointer, fixed bin (35)),
  1    12      iox_$delete_record entry (pointer, fixed bin (35)),
  1    13      iox_$destroy_iocb entry (pointer, fixed bin (35)),
  1    14      iox_$detach_iocb entry (pointer, fixed bin (35)),
  1    15      iox_$err_not_attached entry options (variable),
  1    16      iox_$err_not_closed entry options (variable),
  1    17      iox_$err_no_operation entry options (variable),
  1    18      iox_$err_not_open entry options (variable),
  1    19      iox_$find_iocb entry (char (*), pointer, fixed bin (35)),
  1    20      iox_$find_iocb_n entry (fixed bin, ptr, fixed bin(35)),
  1    21      iox_$get_chars entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  1    22      iox_$get_line entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  1    23      iox_$look_iocb entry (char (*), pointer, fixed bin (35)),
  1    24      iox_$modes entry (pointer, char (*), char (*), fixed bin (35)),
  1    25      iox_$move_attach entry (pointer, pointer, fixed bin (35)),
  1    26      iox_$open entry (pointer, fixed bin, bit (1) aligned, fixed bin (35)),
  1    27      iox_$position entry (pointer, fixed bin, fixed bin (21), fixed bin (35)),
  1    28      iox_$propagate entry (pointer),
  1    29      iox_$put_chars entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  1    30      iox_$read_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  1    31      iox_$read_length entry (pointer, fixed bin (21), fixed bin (35)),
  1    32      iox_$read_record entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  1    33      iox_$rewrite_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  1    34      iox_$seek_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  1    35      iox_$write_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  1    36      iox_$open_file entry(ptr, fixed bin, char(*), bit(1) aligned, fixed bin(35)),
  1    37      iox_$close_file entry(ptr, char(*), fixed bin(35)),
  1    38      iox_$detach entry(ptr, char(*), fixed bin(35)),
  1    39      iox_$attach_loud entry(ptr, char(*), ptr, fixed bin(35));
  1    40 
  1    41 dcl (iox_$user_output,
  1    42      iox_$user_input,
  1    43      iox_$user_io,
  1    44      iox_$error_output) external static pointer;
  1    45 
  1    46 /* ---------------- END include file iox_dcls.incl.pl1 ---------------- */
     1396 
     1397 
  2     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  2     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  2     3*      version number to IOX2. */
  2     4 /* format: style2 */
  2     5 
  2     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  2     7 	     2 version	      character (4) aligned,	/* IOX2 */
  2     8 	     2 name	      char (32),		/* I/O name of this block. */
  2     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  2    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  2    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  2    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  2    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  2    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
  2    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  2    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  2    17 						/* open(p,mode,not_used,s) */
  2    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  2    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  2    20 						/* get_line(p,bufptr,buflen,actlen,s) */
  2    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  2    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
  2    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  2    24 						/* put_chars(p,bufptr,buflen,s) */
  2    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  2    26 						/* modes(p,newmode,oldmode,s) */
  2    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  2    28 						/* position(p,u1,u2,s) */
  2    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  2    30 						/* control(p,order,infptr,s) */
  2    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  2    32 						/* read_record(p,bufptr,buflen,actlen,s) */
  2    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  2    34 						/* write_record(p,bufptr,buflen,s) */
  2    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  2    36 						/* rewrite_record(p,bufptr,buflen,s) */
  2    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  2    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  2    39 						/* seek_key(p,key,len,s) */
  2    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  2    41 						/* read_key(p,key,len,s) */
  2    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
  2    43 						/* read_length(p,len,s) */
  2    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  2    45 						/* open_file(p,mode,desc,not_used,s) */
  2    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  2    47 						/* close_file(p,desc,s) */
  2    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
  2    49 						/* detach(p,desc,s) */
  2    50 
  2    51      declare iox_$iocb_version_sentinel
  2    52 			      character (4) aligned external static;
  2    53 
  2    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
     1398 
     1399 
  3     1 /* Begin include file ..... iox_modes.incl.pl1 */
  3     2 
  3     3 /* Written by C. D. Tavares, 03/17/75 */
  3     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
  3     5 
  3     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
  3     7     ("stream_input", "stream_output", "stream_input_output",
  3     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
  3     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
  3    10      "direct_input", "direct_output", "direct_update");
  3    11 
  3    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
  3    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
  3    14 
  3    15 dcl (Stream_input initial (1),
  3    16      Stream_output initial (2),
  3    17      Stream_input_output initial (3),
  3    18      Sequential_input initial (4),
  3    19      Sequential_output initial (5),
  3    20      Sequential_input_output initial (6),
  3    21      Sequential_update initial (7),
  3    22      Keyed_sequential_input initial (8),
  3    23      Keyed_sequential_output initial (9),
  3    24      Keyed_sequential_update initial (10),
  3    25      Direct_input initial (11),
  3    26      Direct_output initial (12),
  3    27      Direct_update initial (13)) fixed bin int static options (constant);
  3    28 
  3    29 /* End include file ..... iox_modes.incl.pl1 */
     1400 
     1401 
  4     1 /*  BEGIN INCLUDE FILE   mode_string_info.incl.pl1							*/
  4     2 
  4     3 /* Structure for parse_mode_string_ JRDavis 20 October 1980
  4     4*   Last modified 12 January 1981 by J. Spencer Love for version 2, make char_value varying string */
  4     5 
  4     6 declare	mode_value_ptr		ptr,
  4     7 	number_of_modes		fixed bin;
  4     8 
  4     9 declare	1 mode_string_info		aligned based (mode_string_info_ptr),
  4    10 	  2 version		fixed bin,
  4    11 	  2 number		fixed bin,
  4    12 	  2 modes			(number_of_modes refer (mode_string_info.number)) like mode_value;
  4    13 
  4    14 declare	mode_string_info_ptr	ptr;
  4    15 
  4    16 declare	1 mode_value		aligned based (mode_value_ptr),
  4    17 	  2 version		fixed bin,
  4    18 	  2 mode_name		char (32) unaligned,
  4    19 	  2 flags,
  4    20 	    3 boolean_valuep	bit (1) unaligned,
  4    21 	    3 numeric_valuep	bit (1) unaligned,
  4    22 	    3 char_valuep		bit (1) unaligned,
  4    23 	    3 boolean_value		bit (1) unaligned,
  4    24 	    3 pad1		bit (32) unaligned,
  4    25 	  2 numeric_value		fixed bin (35),
  4    26 	  2 char_value		char (32) varying,
  4    27 	  2 code			fixed bin (35),
  4    28 	  2 pad2			bit (36);
  4    29 
  4    30 declare	mode_string_info_version_2	fixed bin static options (constant) initial (2),
  4    31 	mode_value_version_3	fixed bin static options (constant) initial (3);
  4    32 
  4    33 /* END INCLUDE FILE   mode_string_info.incl.pl1								*/
     1402 
     1403 
  5     1 /* BEGIN INCLUDE FILE area_info.incl.pl1  12/75 */
  5     2 
  5     3 dcl  area_info_version_1 fixed bin static init (1) options (constant);
  5     4 
  5     5 dcl  area_infop ptr;
  5     6 
  5     7 dcl 1 area_info aligned based (area_infop),
  5     8     2 version fixed bin,				/* version number for this structure is 1 */
  5     9     2 control aligned like area_control,		/* control bits for the area */
  5    10     2 owner char (32) unal,				/* creator of the area */
  5    11     2 n_components fixed bin,				/* number of components in the area (returned only) */
  5    12     2 size fixed bin (18),				/* size of the area in words */
  5    13     2 version_of_area fixed bin,			/* version of area (returned only) */
  5    14     2 areap ptr,					/* pointer to the area (first component on multisegment area) */
  5    15     2 allocated_blocks fixed bin,			/* number of blocks allocated */
  5    16     2 free_blocks fixed bin,				/* number of free blocks not in virgin */
  5    17     2 allocated_words fixed bin (30),			/* number of words allocated in the area */
  5    18     2 free_words fixed bin (30);			/* number of words free in area not in virgin */
  5    19 
  5    20 dcl 1 area_control aligned based,
  5    21     2 extend bit (1) unal,				/* says area is extensible */
  5    22     2 zero_on_alloc bit (1) unal,			/* says block gets zerod at allocation time */
  5    23     2 zero_on_free bit (1) unal,			/* says block gets zerod at free time */
  5    24     2 dont_free bit (1) unal,			/* debugging aid, turns off free requests */
  5    25     2 no_freeing bit (1) unal,			/* for allocation method without freeing */
  5    26     2 system bit (1) unal,				/* says area is managed by system */
  5    27     2 pad bit (30) unal;
  5    28 
  5    29 /* END INCLUDE FILE area_info.incl.pl1 */
     1404 
     1405 
  6     1 /* BEGIN INCLUDE FiLE ... terminal_type_data.incl.pl1 */
  6     2 
  6     3 
  6     4 /****^  HISTORY COMMENTS:
  6     5*  1) change(77-05-19,JStern), approve(), audit(), install():
  6     6*     Created
  6     7*     Modified 8/14/79 by Robert Coren to convert to version 2 by adding
  6     8*        flow control parameters
  6     9*  2) change(87-03-09,LJAdams), approve(87-04-03,MCR7646),
  6    10*     audit(87-05-05,Gilcrease), install(87-08-04,MR12.1-1056):
  6    11*     Change the ttd_version to ttd_version_3.  Add the protocol field.
  6    12*                                                   END HISTORY COMMENTS */
  6    13 
  6    14 
  6    15 dcl 1 terminal_type_data aligned based (ttdp),		/* info structure for set_terminal_data order */
  6    16       2 version fixed bin,				/* structure version */
  6    17       2 old_type fixed bin,				/* old terminal type number, -1 => none */
  6    18       2 name char (32) unaligned,			/* terminal type name */
  6    19       2 tables,
  6    20         3 input_tr_ptr ptr,				/* input translation table ptr */
  6    21         3 output_tr_ptr ptr,				/* output translation table ptr */
  6    22         3 input_cv_ptr ptr,				/* input conversion table ptr */
  6    23         3 output_cv_ptr ptr,				/* output conversion table ptr */
  6    24         3 special_ptr ptr,				/* special chars table ptr */
  6    25         3 delay_ptr ptr,				/* delay table ptr */
  6    26       2 editing_chars unaligned,
  6    27         3 erase char (1) unaligned,
  6    28         3 kill char (1) unaligned,
  6    29       2 framing_chars unaligned,
  6    30         3 frame_begin char (1) unaligned,
  6    31         3 frame_end char (1) unaligned,
  6    32       2 flags unal,
  6    33         3 keyboard_locking bit (1),			/* ON to request keyboard locking and unlocking */
  6    34         3 input_timeout bit (1),
  6    35         3 output_block_acknowledge bit (1),
  6    36         3 mbz bit (15),
  6    37       2 line_delimiter char (1) unal,
  6    38       2 mbz bit (9) unal,
  6    39 
  6    40       /* the remainder of this structure is only present if version is 2 or more */
  6    41 
  6    42       2 flow_control_chars unal,
  6    43         3 input_suspend char (1),
  6    44         3 input_resume char (1),
  6    45         3 output_suspend_etb char (1),
  6    46         3 output_resume_ack char (1),
  6    47       2 output_buffer_size fixed bin,
  6    48 
  6    49       /* the remainder of this structure is only present if version is 3 or more */
  6    50       2 protocol fixed bin; /* 0=NONE; 1=MOWSE */
  6    51 
  6    52 
  6    53 dcl  ttdp ptr;					/* ptr to terminal_type_data structure */
  6    54 dcl  ttd_version_3 fixed bin int static options (constant) init (3);
  6    55 						/* current version of structure */
  6    56 
  6    57 
  6    58 /* END INCLUDE FILE ... terminal_type_data.incl.pl1 */
     1406 
     1407 
  7     1 /*	BEGIN INCLUDE FILE ... tty_convert.incl.pl1	*/
  7     2 
  7     3 /* tty_ conversion tables */
  7     4 /* Created 11/3/75 by Robert S. Coren */
  7     5 /* Info structures added 5/19/77 by Robert S. Coren */
  7     6 /* Length of cv_trans changed from 128 to 256 05/03/78 by Robert Coren */
  7     7 /* conversion table mnemonics added JRDavis 21 Aug 80 */
  7     8 /* fix special_chars_struc to have good refers Fri 13 Feb 81 JRDavis */
  7     9 
  7    10 
  7    11 /****^  HISTORY COMMENTS:
  7    12*  1) change(85-12-01,Negaret), approve(87-07-23,MCR7742),
  7    13*     audit(87-07-23,GDixon), install(87-08-04,MR12.1-1056):
  7    14*      Added INPUT_CONVERT_DSA_CR_PROCESSING constant.
  7    15*  2) change(88-01-22,Brunelle), approve(88-01-22,MCR7813),
  7    16*     audit(88-10-05,Blair), install(88-10-17,MR12.2-1171):
  7    17*     Expand c_chars definition from 3 chars to 15.  Change SPECIAL_VERSION
  7    18*     from 1 to 2.  Add version variable to get_special_info_struc and define
  7    19*     SPECIAL_INFO_STRUCT_VERSION_1.
  7    20*                                                   END HISTORY COMMENTS */
  7    21 
  7    22 
  7    23 /* format: style2,linecom,^indnoniterdo,indcomtxt,^inditerdo,dclind5,idind25 */
  7    24 
  7    25 
  7    26      dcl	1 special_chars	     aligned based,		/* table of special character sequences */
  7    27 	  2 nl_seq	     aligned like c_chars,	/* new-line sequence */
  7    28 	  2 cr_seq	     aligned like c_chars,	/* carriage-return sequence */
  7    29 	  2 bs_seq	     aligned like c_chars,	/* backspace sequence */
  7    30 	  2 tab_seq	     aligned like c_chars,	/* horizontal tab sequence */
  7    31 	  2 vt_seq	     aligned like c_chars,	/* vertical tab sequence */
  7    32 	  2 ff_seq	     aligned like c_chars,	/* form-feed sequence */
  7    33 	  2 printer_on	     aligned like c_chars,	/* printer-on sequence */
  7    34 	  2 printer_off	     aligned like c_chars,	/* printer_off sequence */
  7    35 	  2 red_ribbon_shift     aligned like c_chars,	/* red ribbon shift sequence */
  7    36 	  2 black_ribbon_shift   aligned like c_chars,	/* black ribbon shift sequence */
  7    37 	  2 end_of_page	     aligned like c_chars,	/* end-of-page warning sequence */
  7    38 	  2 escape_length	     fixed bin,		/* number of escape sequences */
  7    39 	  2 not_edited_escapes   (sc_escape_len refer (special_chars.escape_length)) like c_chars,
  7    40 						/* use in ^edited mode */
  7    41 	  2 edited_escapes	     (sc_escape_len refer (special_chars.escape_length)) like c_chars,
  7    42 						/* use in edited mode */
  7    43 	  2 input_escapes	     aligned,
  7    44 	    3 len		     fixed bin (8) unaligned, /* length of string */
  7    45 	    3 str		     char (sc_input_escape_len refer (special_chars.input_escapes.len)) unaligned,
  7    46 						/* escape sequence characters */
  7    47 	  2 input_results	     aligned,
  7    48 	    3 pad		     bit (9) unaligned,	/* so that strings will look the same */
  7    49 	    3 str		     char (sc_input_escape_len refer (special_chars.input_escapes.len)) unaligned;
  7    50 						/* results of escape sequences */
  7    51 
  7    52 
  7    53      dcl	c_chars_ptr	     ptr;
  7    54      dcl	1 c_chars		     based (c_chars_ptr) aligned,
  7    55 	  2 count		     fixed bin (8) unaligned,
  7    56 	  2 chars		     (15) char (1) unaligned;
  7    57 
  7    58      dcl	sc_escape_len	     fixed bin;		/* count of output escapes to allocate in special_chars  */
  7    59      dcl	sc_input_escape_len	     fixed bin;		/* count of input escapes to allocate in special_chars  */
  7    60 
  7    61 
  7    62      dcl	1 cv_trans	     based aligned,		/* conversion/translation table format */
  7    63 	  2 value		     (0:255) fixed bin (8) unal;
  7    64 
  7    65 
  7    66      dcl	1 delay		     based aligned,		/* delay counts for output */
  7    67 	  2 vert_nl	     fixed bin,
  7    68 	  2 horz_nl	     float bin,
  7    69 	  2 const_tab	     fixed bin,
  7    70 	  2 var_tab	     float bin,
  7    71 	  2 backspace	     fixed bin,
  7    72 	  2 vt_ff		     fixed bin;
  7    73 
  7    74 /* info structures used with orders */
  7    75 
  7    76      dcl	1 special_chars_struc    aligned based,
  7    77 	  2 version	     fixed bin,
  7    78 	  2 default	     fixed bin,		/* non-zero indicates use default */
  7    79 	  2 special_chars,				/* same as level-1 above */
  7    80 						/* has to be spelled out instead of using like */
  7    81 						/* because of refer options */
  7    82 	    3 nl_seq	     aligned like c_chars,	/* new-line sequence */
  7    83 	    3 cr_seq	     aligned like c_chars,	/* carriage-return sequence */
  7    84 	    3 bs_seq	     aligned like c_chars,	/* backspace sequence */
  7    85 	    3 tab_seq	     aligned like c_chars,	/* horizontal tab sequence */
  7    86 	    3 vt_seq	     aligned like c_chars,	/* vertical tab sequence */
  7    87 	    3 ff_seq	     aligned like c_chars,	/* form-feed sequence */
  7    88 	    3 printer_on	     aligned like c_chars,	/* printer-on sequence */
  7    89 	    3 printer_off	     aligned like c_chars,	/* printer_off sequence */
  7    90 	    3 red_ribbon_shift   aligned like c_chars,	/* red ribbon shift sequence */
  7    91 	    3 black_ribbon_shift aligned like c_chars,	/* black ribbon shift sequence */
  7    92 	    3 end_of_page	     aligned like c_chars,	/* end-of-page warning sequence */
  7    93 	    3 escape_length	     fixed bin,		/* number of escape sequences */
  7    94 	    3 not_edited_escapes (sc_escape_len refer (special_chars_struc.escape_length)) like c_chars,
  7    95 						/* use in ^edited mode */
  7    96 	    3 edited_escapes     (sc_escape_len refer (special_chars_struc.escape_length)) like c_chars,
  7    97 						/* use in edited mode */
  7    98 	    3 input_escapes	     aligned,
  7    99 	      4 len	     fixed bin (8) unaligned, /* length of string */
  7   100 	      4 str	     char (sc_input_escape_len refer (special_chars_struc.input_escapes.len)) unaligned,
  7   101 						/* escape sequence characters */
  7   102 	    3 input_results	     aligned,
  7   103 	      4 pad	     bit (9) unaligned,	/* so that strings will look the same */
  7   104 	      4 str	     char (sc_input_escape_len refer (special_chars_struc.input_escapes.len)) unaligned;
  7   105 						/* results of escape sequences */
  7   106 
  7   107      dcl	1 cv_trans_struc	     aligned based,		/* all conversion/translation tables */
  7   108 	  2 version	     fixed bin,
  7   109 	  2 default	     fixed bin,		/* as above */
  7   110 	  2 cv_trans	     like cv_trans;
  7   111 
  7   112      dcl	1 delay_struc	     aligned based,
  7   113 	  2 version	     fixed bin,
  7   114 	  2 default	     fixed bin,		/* as above */
  7   115 	  2 delay		     like delay;
  7   116 
  7   117      dcl	1 get_special_info_struc based aligned,		/* get_special order */
  7   118 	  2 version	     char (8),
  7   119 	  2 area_ptr	     pointer,
  7   120 	  2 table_ptr	     pointer;
  7   121 
  7   122      dcl	SPECIAL_INFO_STRUCT_VERSION_1
  7   123 			     char (8) int static options (constant) init ("sisv1000");
  7   124      dcl	SPECIAL_VERSION	     fixed bin int static options (constant) init (1);
  7   125      dcl	SPECIAL_VERSION_2	     fixed bin int static options (constant) init (2);
  7   126      dcl	DELAY_VERSION	     fixed bin int static options (constant) init (1);
  7   127      dcl	CV_TRANS_VERSION	     fixed bin int static options (constant) init (2);
  7   128 
  7   129      dcl	CV_TRANS_SIZE	     (2) fixed bin int static options (constant) init (127, 255);
  7   130 						/* indexed by version number */
  7   131 
  7   132 
  7   133 /* values for input and output conversion tables */
  7   134 
  7   135      dcl	(
  7   136 	INPUT_CONVERT_ORDINARY   init (0),
  7   137 	INPUT_CONVERT_BREAK	     init (1),
  7   138 	INPUT_CONVERT_ESCAPE     init (2),
  7   139 	INPUT_CONVERT_DISCARD    init (3),
  7   140 	INPUT_CONVERT_FORMFEED   init (4),
  7   141 	INPUT_CONVERT_PRECEDENCE_DISCARD
  7   142 			     init (5),
  7   143 	INPUT_CONVERT_DSA_CR_PROCESSING
  7   144 			     init (6)
  7   145 	)		     fixed bin (8) unaligned internal static options (constant);
  7   146 
  7   147      dcl	(
  7   148 	OUTPUT_CONVERT_ORDINARY  init (0),
  7   149 	OUTPUT_CONVERT_NEWLINE   init (1),
  7   150 	OUTPUT_CONVERT_CR	     init (2),
  7   151 	OUTPUT_CONVERT_HT	     init (3),
  7   152 	OUTPUT_CONVERT_BS	     init (4),
  7   153 	OUTPUT_CONVERT_VT	     init (5),
  7   154 	OUTPUT_CONVERT_FF	     init (6),
  7   155 	OUTPUT_CONVERT_OCTAL     init (7),
  7   156 	OUTPUT_CONVERT_RRS	     init (8),
  7   157 	OUTPUT_CONVERT_BRS	     init (9),
  7   158 	OUTPUT_CONVERT_NO_MOTION init (10),
  7   159 	OUTPUT_CONVERT_PRECEDENCE_NO_MOTION
  7   160 			     init (11),
  7   161 	OUTPUT_CONVERT_DONT_SEND init (12),
  7   162 	OUTPUT_CONVERT_NOT_USED_13
  7   163 			     init (13),
  7   164 	OUTPUT_CONVERT_NOT_USED_14
  7   165 			     init (14),
  7   166 	OUTPUT_CONVERT_NOT_USED_15
  7   167 			     init (15),
  7   168 	OUTPUT_CONVERT_NOT_USED_16
  7   169 			     init (16),
  7   170 	OUTPUT_CONVERT_FIRST_SPECIAL
  7   171 			     init (17)
  7   172 	)		     fixed bin (8) unaligned internal static options (constant);
  7   173 
  7   174 /*	END INCLUDE FILE ... tty_convert.incl.pl1 */
     1408 
     1409 
  8     1 /* BEGIN INCLUDE FILE ... tty_read_status_info.incl.pl1
  8     2*
  8     3*   control structure for the read_status and write_status orders to tty_
  8     4*
  8     5*   Modified 2/1/83 by Olin Sibert to add tty_write_status_info structure in
  8     6*     support of lap_simplex_ MPX.
  8     7**/
  8     8 
  8     9 
  8    10 /****^  HISTORY COMMENTS:
  8    11*  1) change(88-07-07,Beattie), approve(88-06-27,MCR7926),
  8    12*     audit(88-07-22,Brunelle), install(88-08-08,MR12.2-1082):
  8    13*     Prepared for installation.
  8    14*                                                   END HISTORY COMMENTS */
  8    15 
  8    16 
  8    17      dcl	   1 tty_read_status_info aligned based (tty_read_status_info_ptr),
  8    18 	     2 event_channel      fixed bin (71),
  8    19 	     2 input_pending      bit (1);
  8    20 
  8    21      dcl	   tty_read_status_info_ptr ptr;
  8    22 
  8    23      dcl	   1 tty_write_status_info aligned based (tty_write_status_info_ptr),
  8    24 	     2 event_channel      fixed bin (71),
  8    25 	     2 output_pending     bit (1);
  8    26 
  8    27      dcl	   tty_write_status_info_ptr ptr;
  8    28 
  8    29 /* END INCLUDE FILE ... tty_read_status_info.incl.pl1 */
     1410 
     1411 
  9     1 /* BEGIN INCLUDE FILE ... terminal_io_record.incl.pl1 */
  9     2 /* Created:  November 1979 by G. Palter */
  9     3 /* Modified: 26 March 1982 by G. Palter to make the structure more compatible with use of the like attribute */
  9     4 
  9     5 
  9     6 /* Record format used by I/O modules designed for communcation with remote I/O daemon stations */
  9     7 
  9     8 dcl 1 terminal_io_record aligned based (terminal_io_record_ptr),
  9     9       2 header,
  9    10         3 version fixed binary,
  9    11         3 device_type fixed binary,			/* type of device sending/receiving this record --
  9    12*						   reader/printer/punch/teleprinter */
  9    13         3 slew_control,				/* slew control data: used for printer and teleprinter only */
  9    14 	4 slew_type fixed binary (18) unaligned unsigned,	/* type of slewing operation before/after this line --
  9    15*						   by-count/top-of-form/inside-page/outside-page/to-channel */
  9    16 	4 slew_count fixed binary (18) unaligned unsigned,/* # of lines if by count; channel # if to channel */
  9    17         3 flags,
  9    18 	4 binary bit (1) unaligned,			/* ON => data in record should be written in binary mode */
  9    19 	4 preslew bit (1) unaligned,			/* ON => perform above slew before printing data;
  9    20*						   OFF => perform above slew after printing data */
  9    21 	4 pad bit (34) unaligned,
  9    22         3 element_size fixed binary,			/* # of bits in a data element */
  9    23         3 n_elements fixed binary (24),			/* # of elements in the record */
  9    24       2 data,					/* force word alignment */
  9    25         3 bits (terminal_io_record_n_elements refer (terminal_io_record.n_elements))
  9    26 	  bit (terminal_io_record_element_size refer (terminal_io_record.element_size)) unaligned;
  9    27 
  9    28 dcl  terminal_io_record_ptr pointer;
  9    29 
  9    30 dcl  terminal_io_record_element_size fixed binary;	/* used for allocating terminal_io_record structures */
  9    31 dcl  terminal_io_record_n_elements fixed binary (24);
  9    32 
  9    33 
  9    34 /* Manifest constants */
  9    35 
  9    36 dcl  terminal_io_record_version_1 fixed binary static options (constant) initial (1);
  9    37 
  9    38 dcl (TELEPRINTER_DEVICE	initial (1),
  9    39      READER_DEVICE		initial (2),
  9    40      PRINTER_DEVICE		initial (3),
  9    41      PUNCH_DEVICE		initial (4))
  9    42 	fixed binary static options (constant);
  9    43 
  9    44 dcl (SLEW_BY_COUNT		initial (1),
  9    45      SLEW_TO_TOP_OF_PAGE	initial (2),
  9    46      SLEW_TO_INSIDE_PAGE	initial (3),		/* skip to top of next inside page (head sheet) */
  9    47      SLEW_TO_OUTSIDE_PAGE	initial (4),		/* skip to top of next outside page (tail sheet) */
  9    48      SLEW_TO_CHANNEL	initial (5))		/* skip to specified channel stop */
  9    49 	fixed binary static options (constant);
  9    50 
  9    51 
  9    52 /* Data in record as a character string (terminal_io_record.element_size = 9) */
  9    53 
  9    54 dcl  terminal_io_record_data_chars character (terminal_io_record.n_elements) unaligned
  9    55 	based (addr (terminal_io_record.bits));
  9    56 
  9    57 dcl  terminal_io_record_data_chars_varying_max_len fixed binary (21);  /* Set this before using the varying string. */
  9    58 dcl  terminal_io_record_data_chars_varying character (terminal_io_record_data_chars_varying_max_len) varying
  9    59 	based (addr (terminal_io_record.n_elements));	/* varying string consists of length and data */
  9    60 
  9    61 
  9    62 /* Data in record as a bit string (terminal_io_record.element_size = 1) */
  9    63 
  9    64 dcl terminal_io_record_data_bits bit (terminal_io_record.n_elements) unaligned based (addr (terminal_io_record.bits));
  9    65 
  9    66 /* END INCLUDE FILE ... terminal_io_record.incl.pl1 */
     1412 
     1413 
     1414 debug_on:
     1415      entry ();
     1416 
     1417 	debug_flag = "1"b;
     1418 
     1419 	return;
     1420 
     1421 
     1422 debug_off:
     1423      entry ();
     1424 
     1425 	debug_flag = "0"b;
     1426 
     1427 	return;
     1428 
     1429      end rbf_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/17/88  1033.4  rbf_.pl1                          >spec>install>MR12.2-1171>rbf_.pl1
1396         1    05/23/83  0916.6  iox_dcls.incl.pl1                 >ldd>include>iox_dcls.incl.pl1
1398         2    05/20/83  1846.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
1400         3    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
1402         4    03/19/81  1206.8  mode_string_info.incl.pl1         >ldd>include>mode_string_info.incl.pl1
1404         5    06/11/76  1043.4  area_info.incl.pl1                >ldd>include>area_info.incl.pl1
1406         6    08/06/87  0913.5  terminal_type_data.incl.pl1       >ldd>include>terminal_type_data.incl.pl1
1408         7    10/17/88  1024.1  tty_convert.incl.pl1              >spec>install>MR12.2-1171>tty_convert.incl.pl1
1410         8    08/11/88  2015.0  tty_read_status_info.incl.pl1     >ldd>include>tty_read_status_info.incl.pl1
1412         9    11/12/82  1624.8  terminal_io_record.incl.pl1       >ldd>include>terminal_io_record.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CC                        4(18) 000000 constant        char(1)                  initial level 3 packed packed unaligned dcl 183 ref
                                                                                  741 960
CR                                     constant        char(1)                  initial packed unaligned dcl 166 ref 857
MY_NAME                         000137 constant        char(4)                  initial packed unaligned dcl 176 set ref 279* 309
                                                                                  337* 339* 344* 356* 400* 401* 409* 430 435* 444*
                                                                                  449* 457* 1180* 1212*
PRINTER_DEVICE                         constant        fixed bin(17,0)          initial dcl 9-38 ref 860
PUNCH_DEVICE                           constant        fixed bin(17,0)          initial dcl 9-38 ref 899
P_code                                 parameter       fixed bin(35,0)          dcl 1355 set ref 1352 1360*
RBF                             000000 constant        structure                level 1 dcl 183
READER_DEVICE                          constant        fixed bin(17,0)          initial dcl 9-38 ref 651 719 724
REL_SECONDS                     000136 constant        bit(2)                   initial packed unaligned dcl 177 set ref 1304*
RS                        4(09) 000000 constant        char(1)                  initial level 3 packed packed unaligned dcl 183 ref
                                                                                  745 977 983 992 1000 1357 1358
SLEW_BY_COUNT                          constant        fixed bin(17,0)          initial dcl 9-44 ref 675 864
SLEW_TO_CHANNEL                        constant        fixed bin(17,0)          initial dcl 9-44 ref 894
SLEW_TO_INSIDE_PAGE                    constant        fixed bin(17,0)          initial dcl 9-44 ref 890
SLEW_TO_OUTSIDE_PAGE                   constant        fixed bin(17,0)          initial dcl 9-44 ref 892
SLEW_TO_TOP_OF_PAGE                    constant        fixed bin(17,0)          initial dcl 9-44 ref 888
Sequential_input                       constant        fixed bin(17,0)          initial dcl 3-15 ref 558 571
Sequential_input_output                constant        fixed bin(17,0)          initial dcl 3-15 ref 558 571 574
Sequential_output                      constant        fixed bin(17,0)          initial dcl 3-15 ref 558 574
Stream_input_output             000303 constant        fixed bin(17,0)          initial dcl 3-15 set ref 443*
TELEPRINTER_DEVICE                     constant        fixed bin(17,0)          initial dcl 9-38 ref 651 728 854 940 1010
a_buffer_len                           parameter       fixed bin(21,0)          dcl 43 ref 633 661
a_bufferp                              parameter       pointer                  dcl 44 ref 633 659
a_code                                 parameter       fixed bin(35,0)          dcl 45 set ref 259 269* 488 491* 498* 504* 532 535*
                                                                                  542* 548* 560* 591 594* 601* 607* 633 646* 653*
                                                                                  665* 812* 816* 821 830* 840* 846* 870* 913* 1006*
                                                                                  1014 1018* 1026* 1032* 1063* 1097* 1100* 1108*
                                                                                  1112* 1117 1120* 1129* 1135* 1141* 1142 1146*
                                                                                  1156* 1161* 1257*
a_comerr_sw                            parameter       bit(1)                   packed unaligned dcl 46 ref 259 262 532
a_infop                                parameter       pointer                  dcl 47 set ref 1014 1059 1100* 1108*
a_iocbp                                parameter       pointer                  dcl 48 ref 259 263 488 492 532 536 591 595 633 644
                                                                                  821 829 1014 1020 1117 1123
a_new_modes                            parameter       char                     packed unaligned dcl 49 set ref 1117 1141* 1167
a_old_modes                            parameter       char                     packed unaligned dcl 50 set ref 1117 1121* 1166*
a_open_mode                            parameter       fixed bin(17,0)          dcl 51 ref 532 556
a_option                               parameter       varying char             array dcl 52 ref 259 279 311 313 315 317 319 321 323
                                                                                  325 325 327 329 329 332 1180 1180 1183 1185
a_order                                parameter       char                     packed unaligned dcl 53 set ref 1014 1039 1051 1057
                                                                                  1103 1103 1103 1108*
a_record_len                           parameter       fixed bin(21,0)          dcl 54 set ref 633 645* 811* 821
a_recordp                              parameter       pointer                  dcl 55 ref 821 834
actual_iocb_ptr          12            based           pointer                  level 2 dcl 2-6 ref 536 595 644 829 1020 1123
addr                                                   builtin function         dcl 133 ref 355 355 455 455 475 581 749 749 749 772
                                                                                  775 780 780 780 780 797 797 802 802 808 808 931
                                                                                  1097 1097 1299 1299 1306 1306 1306 1306 1322 1322
                                                                                  1382
any_other                       000524 stack reference condition                dcl 152 ref 471 484 518 528 567 587 612 629
area_control                           based           structure                level 1 dcl 5-20
area_info                              based           structure                level 1 dcl 5-7
areap                           000010 internal static pointer                  initial dcl 157 set ref 275 275* 296 381 1141* 1206
                                                                                  1345
arg_value                              parameter       char                     packed unaligned dcl 1239 in procedure
                                                                                  "Abort_Attach" set ref 1233 1243*
arg_value                              parameter       char                     packed unaligned dcl 1253 in procedure "Abort" set
                                                                                  ref 1247 1256*
attach_data_ptr          16            based           pointer                  level 2 dcl 2-6 set ref 476* 508 552 648 832 1036
                                                                                  1139
attach_descrip_ptr       14            based           pointer                  level 2 dcl 2-6 set ref 267 475* 496 522* 540 599
                                                                                  1024 1127
attach_description                     based           varying char(256)        level 2 dcl 88 set ref 298* 475
auto_ttd                        000100 automatic       structure                level 1 dcl 60 set ref 355 355
backward_ptr              2            based           pointer                  level 2 dcl 104 set ref 384* 1335 1338 1340 1343*
                                                                                  1343
based_area                             based           area                     dcl 62 ref 296 381 1206 1345
bcd_equiv                              defined         char(1)                  array packed unaligned dcl 64 ref 925 961
bcd_equiv_string                000220 constant        char(64)                 initial packed unaligned dcl 164 ref 762 767 925 925
                                                                                  961 961
bcd_input_mc                    000000 constant        char(1)                  initial level 3 packed packed unaligned dcl 183 ref
                                                                                  719
bin                                                    builtin function         dcl 134 ref 925
bin_input_mc              0(09) 000000 constant        char(1)                  initial level 3 packed packed unaligned dcl 183 ref
                                                                                  722
binary                    3            based           bit(1)                   level 4 packed packed unaligned dcl 9-8 set ref 725*
                                                                                  901 910 910 917
bits                      6            based           bit                      array level 3 packed packed unaligned dcl 9-8 set
                                                                                  ref 925 931
boolean_value            13(03)        based           bit(1)                   array level 4 packed packed unaligned dcl 4-9 ref
                                                                                  1154
boolean_valuep           13            based           bit(1)                   array level 4 packed packed unaligned dcl 4-9 ref
                                                                                  1154
c_chars                                based           structure                level 1 dcl 7-54
cdbp                            000522 automatic       pointer                  dcl 102 set ref 289* 372 374* 379 381* 383 384 385
                                                                                  386 387 388 389 390 392 393 394 395 396 400 405
                                                                                  415 417 419 424 428 433 437 438 441 443 448 455
                                                                                  455 455 461 466 466 509* 513 513 649* 683 694 706
                                                                                  706 708 708 708 708 712 715 715 715 736 736 758
                                                                                  758 787 787 833* 922 922 925 925 930 930 931 931
                                                                                  946 946 946 946 960 960 961 961 966 966 966 966
                                                                                  977 977 983 983 992 992 1000 1000 1006 1006 1010
                                                                                  1037* 1067 1078 1091 1091 1097 1100 1108 1208 1210
                                                                                  1212 1212 1212 1215 1217 1218 1219 1222 1222 1296
                                                                                  1297 1299 1304 1313 1315 1322 1335 1335 1338 1338
                                                                                  1340 1340 1343 1343 1345 1346* 1358 1358 1360 1360
channel_id                2     000610 automatic       fixed bin(71,0)          array level 2 dcl 1283 set ref 1296* 1297*
char_codes                3     000000 constant        structure                level 2 packed packed unaligned dcl 183
cleanup                         000532 stack reference condition                dcl 153 ref 292
close                    36            based           entry variable           level 2 dcl 2-6 set ref 579*
code                                   parameter       fixed bin(35,0)          dcl 1236 in procedure "Abort_Attach" set ref 1233
                                                                                  1243*
code                                   parameter       fixed bin(35,0)          dcl 1250 in procedure "Abort" set ref 1247 1256*
                                                                                  1257
code                            000100 automatic       fixed bin(35,0)          dcl 1203 in procedure "Attach_Cleanup" set ref 1212*
                                                                                  1217* 1218* 1219* 1222*
code                            000133 automatic       fixed bin(35,0)          dcl 65 in procedure "rbf_" set ref 355* 356 356*
                                                                                  400* 401 401* 405* 406 408* 409* 433* 435 435*
                                                                                  443* 444 444* 448* 449 449* 455* 457 457* 685* 686
                                                                                  688* 689 691* 692 708* 710 710 816 1041* 1042
                                                                                  1044* 1045 1047* 1048 1053* 1054 1069* 1070 1072*
                                                                                  1073 1075* 1076 1112
code                                   parameter       fixed bin(35,0)          dcl 1272 in procedure "Check_Write_Status" set ref
                                                                                  1263 1299* 1300 1306* 1307 1309* 1315* 1316 1318*
                                                                                  1322* 1323
codeptr                                                builtin function         dcl 135 ref 433 433
collate9                                               builtin function         dcl 136 ref 797 931 1378
com_err_                        000020 constant        entry                    external dcl 214 ref 1256
comerr_sw                       000134 automatic       bit(1)                   packed unaligned dcl 66 set ref 262* 1256
comm_attached            43            based           bit(1)                   level 3 packed packed unaligned dcl 104 set ref 428
                                                                                  437*
comm_channel              4            based           char(32)                 level 2 packed packed unaligned dcl 104 set ref 374
                                                                                  385*
comm_data_block                        based           structure                level 1 dcl 104 set ref 381 1345
comm_data_ptr           724            based           pointer                  level 2 dcl 88 set ref 305* 424* 509 649 833 1037
comm_event_channel       26            based           fixed bin(71,0)          level 2 dcl 104 set ref 388* 455 455 1296
comm_io_module           14            based           char(32)                 level 2 packed packed unaligned dcl 104 set ref 386*
comm_iocbp               24            based           pointer                  level 2 dcl 104 set ref 387* 433* 443* 448* 455*
                                                                                  708* 1006* 1097* 1100* 1108* 1215 1217* 1218*
                                                                                  1219* 1299* 1322* 1360*
comm_open                43(01)        based           bit(1)                   level 3 packed packed unaligned dcl 104 set ref 438*
                                                                                  441 461*
compression_count               000540 automatic       fixed bin(17,0)          dcl 636 set ref 762* 765 767* 769* 772 775* 777 777*
                                                                                  780
continue_to_signal_             000022 constant        entry                    external dcl 215 ref 1196
control                  66            based           entry variable           level 2 dcl 2-6 set ref 577* 620*
control_str                            parameter       char                     packed unaligned dcl 1252 in procedure "Abort" set
                                                                                  ref 1247 1256*
control_str                            parameter       char                     packed unaligned dcl 1238 in procedure
                                                                                  "Abort_Attach" set ref 1233 1243*
convert_ipc_code_               000024 constant        entry                    external dcl 216 ref 408 1309 1318
copy                                                   builtin function         dcl 137 ref 780 1387
current_char                    000541 automatic       char(1)                  packed unaligned dcl 637 set ref 715* 719 722 728
                                                                                  741 745 749 762 767
currentsize                                            builtin function         dcl 138 ref 811
cv_trans                               based           structure                level 1 dcl 7-62 in procedure "rbf_"
cv_trans                  2            based           structure                level 2 in structure "cv_trans_struc" dcl 7-107
                                                                                  in procedure "rbf_"
cv_trans_struc                         based           structure                level 1 dcl 7-107
data                      6            based           structure                level 2 dcl 9-8
debug_flag                      000012 internal static bit(1)                   initial packed unaligned dcl 158 set ref 262 1417*
                                                                                  1425*
default_modes                   000214 constant        char(14)                 initial packed unaligned dcl 167 set ref 300 448*
delay                                  based           structure                level 1 dcl 7-66
detach_iocb              26            based           entry variable           level 2 dcl 2-6 set ref 478* 580* 618*
device                  713            based           char(32)                 level 2 packed packed unaligned dcl 88 set ref 303*
                                                                                  315* 341
device_names                    000154 constant        char(32)                 initial array packed unaligned dcl 168 ref 341 341
                                                                                  341 344
device_type               1            based           fixed bin(17,0)          level 3 in structure "terminal_io_record" dcl 9-8
                                                                                  in procedure "rbf_" set ref 674* 719* 724* 728*
                                                                                  732* 854 860 899
device_type             723            based           fixed bin(17,0)          level 2 in structure "rbf_attach_data" dcl 88
                                                                                  in procedure "rbf_" set ref 304* 346* 651 651 940
                                                                                  1010
dimension                                              builtin function         dcl 139 ref 1383
divide                                                 builtin function         dcl 140 ref 661 919
dummy_arg                       000135 automatic       char(32)                 packed unaligned dcl 67 set ref 325* 327*
element_size              4            based           fixed bin(17,0)          level 3 dcl 9-8 set ref 678* 811 910 910 920* 925
                                                                                  925 925 931
end_of_record                   000542 automatic       bit(1)                   packed unaligned dcl 638 set ref 702* 704 745*
error_code                      000543 automatic       fixed bin(35,0)          dcl 639 set ref 701* 733* 752* 774* 808* 812
error_table_$bad_mode           000066 external static fixed bin(35,0)          dcl 237 ref 560 1161
error_table_$bad_mode_value     000070 external static fixed bin(35,0)          dcl 238 ref 1156
error_table_$badopt             000072 external static fixed bin(35,0)          dcl 239 set ref 344*
error_table_$eof_record         000074 external static fixed bin(35,0)          dcl 240 ref 808
error_table_$improper_data_format
                                000076 external static fixed bin(35,0)          dcl 241 ref 733 846 870 913
error_table_$invalid_read       000100 external static fixed bin(35,0)          dcl 243 ref 653
error_table_$long_record        000102 external static fixed bin(35,0)          dcl 244 ref 752 774
error_table_$noarg              000104 external static fixed bin(35,0)          dcl 245 set ref 1180*
error_table_$not_attached       000106 external static fixed bin(35,0)          dcl 246 ref 498 542 601 1026 1129
error_table_$not_closed         000110 external static fixed bin(35,0)          dcl 247 ref 504 548
error_table_$not_detached       000112 external static fixed bin(35,0)          dcl 248 ref 269
error_table_$not_open           000114 external static fixed bin(35,0)          dcl 249 ref 607 1032 1135
error_table_$null_info_ptr      000116 external static fixed bin(35,0)          dcl 250 ref 1063
error_table_$short_record       000120 external static fixed bin(35,0)          dcl 251 ref 710
error_table_$smallarg           000122 external static fixed bin(35,0)          dcl 252 ref 665
error_table_$unimplemented_version
                                000124 external static fixed bin(35,0)          dcl 253 ref 840 1146
error_table_$wrong_no_of_args   000126 external static fixed bin(35,0)          dcl 255 set ref 279*
ev_chan                         000616 automatic       fixed bin(71,0)          level 2 dcl 1288 set ref 1302
event_channel                          based           fixed bin(71,0)          level 2 dcl 8-17 set ref 1097 1097
event_info                      000600 automatic       structure                level 1 dcl 1274 set ref 1306 1306
first_cdbp                      000014 internal static pointer                  initial dcl 159 set ref 372 415 415* 1335*
flags                    43            based           structure                level 2 in structure "comm_data_block" dcl 104
                                                                                  in procedure "rbf_" set ref 396*
flags                    13            based           structure                array level 3 in structure "mode_string_info"
                                                                                  dcl 4-9 in procedure "rbf_"
flags                     3            based           structure                level 3 in structure "terminal_io_record" dcl 9-8
                                                                                  in procedure "rbf_" set ref 677*
forward_ptr                            based           pointer                  level 2 dcl 104 set ref 375 383* 417* 1335 1338*
                                                                                  1338 1340 1343
get_system_free_area_           000026 constant        entry                    external dcl 217 ref 275
get_temp_segments_              000030 constant        entry                    external dcl 218 ref 400
hbound                                                 builtin function         dcl 141 ref 279 311 341 344 874 876 878 982 983 987
                                                                                  1150 1180
hcs_$reset_ips_mask             000034 constant        entry                    external dcl 220 ref 482 526 585 627 1192
hcs_$set_ips_mask               000032 constant        entry                    external dcl 219 ref 473 520 569 614
header                                 based           structure                level 2 dcl 9-8 set ref 661
i                               000145 automatic       fixed bin(17,0)          dcl 68 set ref 311* 313 315 315* 317 317* 319 319*
                                                                                  321 323 325 325 325* 327 327* 329 329 329* 332*
                                                                                  341* 341* 344 346 924* 925 925* 942* 944 946 946
                                                                                  946 950 956* 956 960 961 963* 963 966 966 966 966
                                                                                  1150* 1151 1151 1151 1154 1154*
idx                                    parameter       fixed bin(17,0)          dcl 1176 set ref 1173 1178* 1178 1180 1180 1183 1185
index                                                  builtin function         dcl 142 ref 762
input                   303            based           char(512)                level 3 packed packed unaligned dcl 88 set ref 367*
                                                                                  797
input_buffer                           based           char                     packed unaligned dcl 123 ref 715
input_buffer_len                       defined         fixed bin(21,0)          dcl 125 set ref 708* 715
input_buffer_position
                         42            based           fixed bin(21,0)          level 2 dcl 104 set ref 395* 706 712* 715 736* 736
                                                                                  758* 758 787* 787 1091
input_buffer_ptr                       defined         pointer                  dcl 124 set ref 708* 715 1212
input_chars_read         41            based           fixed bin(21,0)          level 2 dcl 104 set ref 394* 706 708* 1091
input_pending             2            based           bit(1)                   level 2 dcl 8-17 set ref 1091* 1093* 1097
input_tr_ptr             12     000100 automatic       pointer                  level 3 dcl 60 set ref 358
input_trp                       000146 automatic       pointer                  dcl 69 set ref 358* 363* 367*
iocb                                   based           structure                level 1 dcl 2-6
iocbp                           000150 automatic       pointer                  dcl 70 set ref 263* 267 475 476 477 478 480* 492*
                                                                                  496 502 508 522 524* 536* 540 546 552 571 574 577
                                                                                  578 579 580 581 583* 595* 599 605 616 617 618 620
                                                                                  621 622 623 625* 644* 648 829* 832 1020* 1024 1030
                                                                                  1036 1123* 1127 1133 1139
iox_$attach_name                000132 constant        entry                    external dcl 1-8 ref 433
iox_$close                      000134 constant        entry                    external dcl 1-8 ref 1217
iox_$control                    000136 constant        entry                    external dcl 1-8 ref 455 1097 1100 1108 1299 1322
iox_$destroy_iocb               000140 constant        entry                    external dcl 1-8 ref 1219
iox_$detach_iocb                000142 constant        entry                    external dcl 1-8 ref 1218
iox_$err_no_operation           000144 constant        entry                    external dcl 1-8 ref 620 621 622 623
iox_$modes                      000146 constant        entry                    external dcl 1-8 ref 448
iox_$open                       000150 constant        entry                    external dcl 1-8 ref 443
iox_$propagate                  000152 constant        entry                    external dcl 1-8 ref 480 524 583 625
iox_modes                       000011 constant        char(24)                 initial array dcl 3-6 ref 564
ipc_$block                      000036 constant        entry                    external dcl 221 ref 1306
ipc_$create_ev_chn              000040 constant        entry                    external dcl 222 ref 405
ipc_$delete_ev_chn              000042 constant        entry                    external dcl 223 ref 1222
ipc_$drain_chn                  000044 constant        entry                    external dcl 224 ref 1315
l6_tran_util_$get_chars         000046 constant        entry                    external dcl 225 ref 708
l6_tran_util_$put_chars         000050 constant        entry                    external dcl 226 ref 1006 1360
last_cdbp                       000016 internal static pointer                  initial dcl 160 set ref 384 417 419* 1340*
lbound                                                 builtin function         dcl 143 ref 341 868 1150
legal_slew_chars                000147 constant        char(19)                 initial packed unaligned dcl 170 ref 868 868 874 874
                                                                                  876 876 876 876 878 878 883 883 982 982 983 983
                                                                                  983 983 987 987 992 992
length                                                 builtin function         dcl 144 ref 661 749 772 775 780 802 1357 1387 1387
lowercase                       000140 constant        char(26)                 initial packed unaligned dcl 175 ref 352
mask                            000152 automatic       bit(36)                  dcl 71 set ref 470* 473* 482* 482* 517* 520* 526*
                                                                                  526* 566* 569* 585* 585* 611* 614* 627* 627* 1192
                                                                                  1192* 1192* 1194*
media_code                      000546 automatic       char(1)                  packed unaligned dcl 824 set ref 856* 862* 901* 903*
                                                                                  906* 922 930 975 975 983 992
media_codes                     000000 constant        structure                level 2 packed packed unaligned dcl 183
mode_name                 3            based           char(32)                 array level 3 packed packed unaligned dcl 4-9 ref
                                                                                  1151 1151 1151
mode_string_$parse              000052 constant        entry                    external dcl 227 ref 1141
mode_string_info                       based           structure                level 1 dcl 4-9
mode_string_info_ptr            000552 automatic       pointer                  dcl 4-14 set ref 1141* 1144 1150 1150 1151 1151 1151
                                                                                  1154 1154
mode_string_info_version_2             constant        fixed bin(17,0)          initial dcl 4-30 ref 1144
mode_value                             based           structure                level 1 dcl 4-16
modes                    56            based           entry variable           level 2 in structure "iocb" dcl 2-6 in procedure
                                                                                  "rbf_" set ref 578* 621*
modes                   202            based           varying char(256)        level 2 in structure "rbf_attach_data" dcl 88
                                                                                  in procedure "rbf_" set ref 300* 1166 1167*
modes                     2            based           structure                array level 2 in structure "mode_string_info"
                                                                                  dcl 4-9 in procedure "rbf_" ref 1150 1150
my_attach_description           000414 automatic       varying char(256)        dcl 80 set ref 287* 309* 313* 313 1183* 1183
n_elements                5            based           fixed bin(24,0)          level 3 dcl 9-8 set ref 679* 749 749 749 772 775 780
                                                                                  780 780 780 797 797 802 802 802* 808 808 811 919*
                                                                                  919 924 931 931 935
nchan                           000610 automatic       fixed bin(17,0)          level 2 dcl 1283 set ref 1294*
next_attach_description         000153 automatic       varying char(256)        dcl 72 set ref 431* 433
next_attach_options             000254 automatic       varying char(256)        dcl 73 set ref 286* 332* 332 431
next_channel                    000355 automatic       varying char(32)         dcl 74 set ref 285* 317* 339 374 385 431
next_io_module                  000366 automatic       varying char(32)         dcl 75 set ref 284* 319* 337 386 431
next_io_switch_name             000377 automatic       varying char(32)         dcl 76 set ref 430* 433
null                                                   builtin function         dcl 145 ref 267 275 289 290 305 363 364 372 372 379
                                                                                  383 387 390 415 496 502 522 540 546 599 605 616
                                                                                  1024 1030 1061 1127 1133 1206 1208 1212 1212 1215
                                                                                  1335 1340 1346 1378
number                    1            based           fixed bin(17,0)          level 2 dcl 4-9 ref 1150
number_of_attachments
                         40            based           fixed bin(17,0)          level 2 dcl 104 set ref 393* 466* 466 513* 513 1210
open                     32            based           entry variable           level 2 dcl 2-6 set ref 477* 617*
open_descrip_ptr         20            based           pointer                  level 2 dcl 2-6 set ref 502 546 581* 605 616* 1030
                                                                                  1133
open_description        101            based           varying char(256)        level 2 dcl 88 set ref 299* 564* 581
open_mode                       000410 automatic       fixed bin(17,0)          dcl 77 set ref 556* 558 558 558 564 571 571 574 574
output                  503            based           char(512)                level 3 packed packed unaligned dcl 88 set ref 368*
                                                                                  931
output_buffer                          based           char                     packed unaligned dcl 127 set ref 922* 925* 930* 931*
                                                                                  946 946 960* 961* 966* 966 977* 983* 992* 1000*
                                                                                  1358*
output_buffer_len                      defined         fixed bin(21,0)          dcl 129 ref 922 925 930 931 946 946 960 961 966 966
                                                                                  977 983 992 1000 1358
output_buffer_ptr                      defined         pointer                  dcl 128 set ref 922 925 930 931 946 946 960 961 966
                                                                                  966 977 983 992 1000 1006* 1212 1358 1360*
output_chars_to_write           000411 automatic       fixed bin(21,0)          dcl 78 set ref 935* 944 946 950 964* 964 966 966 977
                                                                                  978* 978 983 986* 986 992 994* 994 1000 1001* 1001
                                                                                  1006* 1357* 1358 1360*
output_pending            2     000616 automatic       bit(1)                   level 2 dcl 1288 set ref 1302
output_tr_ptr            14     000100 automatic       pointer                  level 3 dcl 60 set ref 359
output_trp                      000412 automatic       pointer                  dcl 79 set ref 359* 364* 368*
pad                       1     000610 automatic       fixed bin(17,0)          level 2 dcl 1283 set ref 1295*
preslew                   3(01)        based           bit(1)                   level 4 packed packed unaligned dcl 9-8 set ref 844
printer_mc                0(18) 000000 constant        char(1)                  initial level 3 packed packed unaligned dcl 183 ref
                                                                                  862 975
prog_name                              parameter       char                     packed unaligned dcl 1251 in procedure "Abort" set
                                                                                  ref 1247 1256*
prog_name                              parameter       char                     packed unaligned dcl 1237 in procedure
                                                                                  "Abort_Attach" set ref 1233 1243*
punch_bcd_mc              0(27) 000000 constant        char(1)                  initial level 3 packed packed unaligned dcl 183 ref
                                                                                  903
punch_bin_mc              1     000000 constant        char(1)                  initial level 3 packed packed unaligned dcl 183 ref
                                                                                  901
radp                            000520 automatic       pointer                  dcl 86 set ref 290* 296* 298 299 300 301 302 303 304
                                                                                  305 315 329 341 346 350 352 352 355 367 368 424
                                                                                  475 476 508* 509 552* 564 581 648* 649 651 651 797
                                                                                  832* 833 931 940 1010 1036* 1037 1139* 1166 1167
                                                                                  1206 1206
rbf_attach_data                        based           structure                level 1 unaligned dcl 88 set ref 296 1206
read_record              72            based           entry variable           level 2 dcl 2-6 set ref 571* 622*
read_record_state               000544 automatic       fixed bin(17,0)          dcl 640 set ref 700* 717 737* 741* 755* 788*
release_temp_segments_          000054 constant        entry                    external dcl 228 ref 1212
rep_count                       000547 automatic       fixed bin(17,0)          dcl 825 set ref 946* 950 950* 953 953* 956 961 964
                                                                                  966
rtrim                                                  builtin function         dcl 146 ref 564
slew_by_count_char                     defined         char(1)                  array packed unaligned dcl 81 ref 868 874 876 876
                                                                                  878 883 982 983 983 987 992
slew_char                       000550 automatic       char(1)                  packed unaligned dcl 826 set ref 857* 876* 883* 888*
                                                                                  890* 892* 894* 896* 977
slew_control              2            based           structure                level 3 dcl 9-8
slew_count                2(18)        based           fixed bin(18,0)          level 4 in structure "terminal_io_record" packed
                                                                                  packed unsigned unaligned dcl 9-8 in procedure
                                                                                  "rbf_" set ref 676* 866
slew_count                      000551 automatic       fixed bin(18,0)          dcl 827 in procedure "rbf_" set ref 852* 866* 868
                                                                                  874 878* 878 883 884* 980 982 987* 987 990 992
slew_type                 2            based           fixed bin(18,0)          level 4 packed packed unsigned unaligned dcl 9-8 set
                                                                                  ref 675* 864 888 890 892 894
space                           007331 constant        char(1)                  initial packed unaligned dcl 178 ref 313 332 431 431
                                                                                  888 890 892 894 1183
substr                                                 builtin function         dcl 147 set ref 715 767 780 802 922* 925* 930* 931*
                                                                                  946 946 960* 961* 966* 966 977* 983* 992* 1000*
                                                                                  1358* 1387*
sys_info$max_seg_size           000130 external static fixed bin(35,0)          dcl 257 ref 392
tables                   12     000100 automatic       structure                level 2 dcl 60
teleprinter_mc            1(09) 000000 constant        char(1)                  initial level 3 packed packed unaligned dcl 183 ref
                                                                                  728 856 975
temp_ptr                        000516 automatic       pointer                  dcl 82 set ref 372* 372* 374 374* 375
temp_seg_lens            36            based           fixed bin(21,0)          array level 2 dcl 104 set ref 392* 708 708 715 715
                                                                                  922 922 925 925 930 930 931 931 946 946 946 946
                                                                                  960 960 961 961 966 966 966 966 977 977 983 983
                                                                                  992 992 1000 1000 1358 1358
temp_seg_ptrs            32            based           pointer                  array level 2 dcl 104 set ref 390* 400* 708 708 715
                                                                                  715 922 922 925 925 930 930 931 931 946 946 946
                                                                                  946 960 960 961 961 966 966 966 966 977 977 983
                                                                                  983 992 992 1000 1000 1006 1006 1212 1212 1212
                                                                                  1212 1212* 1358 1358 1360 1360
terminal_io_record                     based           structure                level 1 dcl 9-8 set ref 811
terminal_io_record_data_chars          based           char                     packed unaligned dcl 9-54 ref 931
terminal_io_record_data_chars_varying  based           varying char             dcl 9-58 set ref 749 749* 749 772 775 780* 780 780
                                                                                  780 797* 797 802 802 808 808
terminal_io_record_data_chars_varying_max_len
                                000560 automatic       fixed bin(21,0)          dcl 9-57 set ref 669* 749 780 797
terminal_io_record_ptr          000556 automatic       pointer                  dcl 9-28 set ref 659* 661 673 674 675 676 677 678
                                                                                  679 719 724 725 728 732 749 749 749 772 775 780
                                                                                  780 780 780 797 797 802 802 802 808 808 811 834*
                                                                                  838 844 854 860 864 866 888 890 892 894 899 901
                                                                                  910 910 910 910 917 919 919 920 924 925 931 931
                                                                                  931 935
terminal_io_record_version_1           constant        fixed bin(17,0)          initial dcl 9-36 ref 673 838
terminal_type           703            based           char(32)                 level 2 packed packed unaligned dcl 88 set ref 302*
                                                                                  329* 350 352* 352 355*
terminal_type_data                     based           structure                level 1 dcl 6-15
timer_event_channel      30            based           fixed bin(71,0)          level 2 dcl 104 set ref 389* 405* 1222 1222* 1297
                                                                                  1304* 1313* 1315*
timer_manager_$alarm_wakeup     000056 constant        entry                    external dcl 229 ref 1304
timer_manager_$reset_alarm_wakeup
                                000060 constant        entry                    external dcl 230 ref 1313
trans_strucp                           parameter       pointer                  dcl 1371 ref 1367 1378 1382 1383
translate                                              builtin function         dcl 148 ref 352 797 931
translate_string                       based           char                     packed unaligned dcl 1375 ref 1385
translate_string_len            000636 automatic       fixed bin(21,0)          dcl 1373 set ref 1383* 1385 1387 1387 1387
translate_stringp               000640 automatic       pointer                  dcl 1374 set ref 1382* 1385
translate_table                        parameter       char(512)                packed unaligned dcl 1370 set ref 1367 1378* 1385*
                                                                                  1387 1387* 1387
translations            303            based           structure                level 2 packed packed unaligned dcl 88 set ref 301*
ttd_version_3                          constant        fixed bin(17,0)          initial dcl 6-54 ref 354
ttt_info_$terminal_data         000062 constant        entry                    external dcl 232 ref 355
tty_read_status_info                   based           structure                level 1 dcl 8-17
tty_read_status_info_ptr        000554 automatic       pointer                  dcl 8-21 set ref 1059* 1061 1091 1093 1097 1097 1097
unique_chars_                   000064 constant        entry                    external dcl 233 ref 430
unspec                                                 builtin function         dcl 149 ref 661
uppercase                       000127 constant        char(26)                 initial packed unaligned dcl 179 ref 352
user_buffer_len                 000545 automatic       fixed bin(21,0)          dcl 641 set ref 661* 663 669 749 772 775
value                     2            based           fixed bin(8,0)           array level 3 packed packed unaligned dcl 7-107 set
                                                                                  ref 1382 1383
verify                                                 builtin function         dcl 150 ref 946
version                                based           fixed bin(17,0)          level 3 in structure "terminal_io_record" dcl 9-8
                                                                                  in procedure "rbf_" set ref 673* 838
version                         000100 automatic       fixed bin(17,0)          level 2 in structure "auto_ttd" dcl 60 in procedure
                                                                                  "rbf_" set ref 354*
version                                based           fixed bin(17,0)          level 2 in structure "mode_string_info" dcl 4-9
                                                                                  in procedure "rbf_" ref 1144
wait_list                       000610 automatic       structure                level 1 dcl 1283 set ref 1306 1306
we_just_                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   d                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    @                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          l                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  H                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        $                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         

                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
