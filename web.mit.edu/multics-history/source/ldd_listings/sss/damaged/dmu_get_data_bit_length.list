THIS FILE IS DAMAGED

	COMPILATION LISTING OF SEGMENT dmu_get_data_bit_length
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 01/03/85  1644.5 mst Thu
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 /* format: style2,ind3 */
        7 dmu_get_data_bit_length:
        8    proc (p_descriptor, p_bit_length, p_code);
        9 
       10 /* DESCRIPTION:
       11*
       12*     Given an aligned 36-bit multics pl1 argument descriptor this routine
       13*     determines the number of bits of storage that the data type,
       14*     alignment, and precision or size requires when residing in memory,
       15*     not counting words skipped to obtain even word boundaries.  The
       16*     descriptor is assumed to be valid, with correct values for scale,
       17*     precision, size, etc.  For that data type, since this is to be an
       18*     efficient run-time routine having had error checks made elsewhere.
       19*     Also, the data is assumed to be scalar, i.e.  that there are no array
       20*     bounds, as this will be expanded elsewhere. Decimal 4-bit non-byte 
       21*     aligned are treated as byte aligned data.
       22**/
       23 
       24 /* HISTORY:
       25*Written by Matthew Pierret, 04/05/82.
       26*Modified:
       27*01/07/83 by Lindsey Spratt:  Fixed data-types 9 through 12 to always set the
       28*	  bit_length.  It wasn't being set when the packed flag was off.
       29*05/03/84 by Matthew Pierret:  Added the alignment entry, which returns the
       30*            required alignment in addition to the bit length.  Made
       31*            descriptor_string aligned.
       32**/
       33 
       34 /* START OF DECLARATIONS */
       35 /* Parameter */
       36 
       37       dcl	    p_descriptor	       bit (36) aligned;
       38       dcl	    p_bit_length	       fixed bin (35);
       39       dcl	    p_alignment	       fixed bin (17);
       40       dcl	    p_code	       fixed bin (35);
       41 
       42 /* Automatic */
       43 
       44       dcl	    get_alignment	       bit (1) aligned init ("0"b);
       45       dcl	    alignment	       fixed bin (17);
       46       dcl	    descriptor_string      bit (36) aligned;
       47       dcl	    bit_length	       fixed bin (35);	/* returned storage length */
       48 
       49 /* Based */
       50 
       51       dcl	    1 descriptor	       based (addr (descriptor_string)) unal,
       52 	      2 flag	       bit (1) unal,
       53 	      2 type	       unsigned fixed bin (6) unal,
       54 	      2 packed	       bit (1) unal,
       55 	      2 ndims	       unsigned fixed bin (4) unal,
       56 	      2 size	       unsigned fixed bin (24) unal;
       57 
       58       dcl	    1 precision_descriptor based (addr (descriptor_string)) unal,
       59 	      2 unused1	       bit (24) unal,
       60 	      2 precision	       unsigned fixed bin (12) unal;
       61 
       62 /* Builtin */
       63 
       64       dcl	    (mod, addr, null, floor)
       65 			       builtin;
       66 
       67 /* Controlled */
       68 /* Constant */
       69 
       70       dcl	    SIGN_AND_PAD	       fixed bin init (2) int static options (constant);
       71 						/* sign digit + 1/2 byte padding */
       72       dcl	    SIGN_EXPONENT_AND_PAD  fixed bin init (4) int static options (constant);
       73 						/* sign digit, exp byte, + 1/2 byte pad */
       74       dcl	    PAD		       fixed bin init (1) int static options (constant);
       75 						/* 1/2 byte padding */
       76       dcl	    PER_BYTE_FACTOR	       fixed bin init (2) int static options (constant);
       77 						/* number of digits per byte */
       78       dcl	    SIGN_AND_EXPONENT      fixed bin init (2) int static options (constant);
       79 						/* float decimal exp and sign char space */
       80       dcl	    DOUBLE	       fixed bin init (2) int static options (constant);
       81 						/* multiplier for complex numbers */
       82       dcl	    SIGN		       fixed bin init (1) int static options (constant);
       83 						/* space for sign */
       84       dcl	    ONE_WORD	       fixed bin init (36) int static options (constant);
       85 						/* bit length of a word */
       86       dcl	    TWO_WORD	       fixed bin init (72) int static options (constant);
       87 						/* bit length of two words */
       88       dcl	    FOUR_WORD	       fixed bin init (144) int static options (constant);
       89 						/* bit length of four words */
       90       dcl	    ONE_BYTE	       fixed bin init (9) int static options (constant);
       91 						/* bit length of a byte (character) */
       92       dcl	    BIT_ALIGNED	       fixed bin (17) init (1) int static options (constant);
       93 						/* data type is aligned at the bit level (not aligned) */
       94       dcl	    BYTE_ALIGNED	       fixed bin (17) init (9) int static options (constant);
       95 						/* data type is aligned at the byte level */
       96       dcl	    WORD_ALIGNED	       fixed bin (17) init (36) int static options (constant);
       97 						/* data type is aligned at the word level */
       98       dcl	    EVEN_WORD_ALIGNED      fixed bin (17) init (72) int static options (constant);
       99 						/* data type is aligned at the even word level */
      100 
      101 /* Entry */
      102 /* External */
      103 
      104       dcl	    dm_error_$unimplemented_data_type
      105 			       fixed bin (35) ext;
      106       dcl	    dm_error_$invalid_alignment
      107 			       fixed bin (35) ext;
      108 
      109 /* END OF DECLARATIONS */
      110 
      111       go to JOIN;
      112 
      113 alignment:
      114    entry (p_descriptor, p_bit_length, p_alignment, p_code);
      115 
      116       get_alignment = "1"b;
      117       alignment = BIT_ALIGNED;			/* Default alignment is bit-aligned, or not aligned. */
      118 
      119 JOIN:
      120       descriptor_string = p_descriptor;
      121       p_code = 0;
      122 
      123 /* CASE STRUCTURE BASED ON THE DATA TYPE */
      124 
      125       goto DATA_TYPE (descriptor.type);
      126 
      127 /* REAL FIXED BINARY SHORT */
      128 DATA_TYPE (1):
      129       if descriptor.packed
      130       then bit_length = precision_descriptor.precision + SIGN;
      131       else
      132          do;
      133 	  alignment = WORD_ALIGNED;
      134 	  bit_length = ONE_WORD;
      135          end;
      136       goto END_CASE;
      137 
      138 /* READ FIXED BINARY LONG */
      139 DATA_TYPE (2):
      140       if descriptor.packed
      141       then bit_length = precision_descriptor.precision + SIGN;
      142       else
      143          do;
      144 	  alignment = EVEN_WORD_ALIGNED;
      145 	  bit_length = TWO_WORD;
      146          end;
      147       goto END_CASE;
      148 
      149 /* REAL FLOATING BINARY SHORT */
      150 DATA_TYPE (3):
      151       if descriptor.packed
      152       then bit_length = precision_descriptor.precision + ONE_BYTE;
      153       else
      154          do;
      155 	  alignment = WORD_ALIGNED;
      156 	  bit_length = ONE_WORD;
      157          end;
      158       goto END_CASE;
      159 
      160 /*  REAL FLOATING BINARY LONG */
      161 DATA_TYPE (4):
      162       if descriptor.packed
      163       then bit_length = precision_descriptor.precision + ONE_BYTE;
      164       else
      165          do;
      166 	  alignment = EVEN_WORD_ALIGNED;
      167 	  bit_length = TWO_WORD;
      168          end;
      169       goto END_CASE;
      170 
      171 
      172 /* COMPLEX FIXED BINARY SHORT */
      173 DATA_TYPE (5):
      174       if descriptor.packed
      175       then bit_length = DOUBLE * (precision_descriptor.precision + SIGN);
      176       else
      177          do;
      178 	  alignment = EVEN_WORD_ALIGNED;
      179 	  bit_length = TWO_WORD;
      180          end;
      181       goto END_CASE;
      182 
      183 /* COMPLEX FIXED BINARY LONG */
      184 DATA_TYPE (6):
      185       if descriptor.packed
      186       then bit_length = DOUBLE * (precision_descriptor.precision + SIGN);
      187       else
      188          do;
      189 	  alignment = EVEN_WORD_ALIGNED;
      190 	  bit_length = FOUR_WORD;
      191          end;
      192       goto END_CASE;
      193 
      194 /* COMPLEX FLOATING BINARY SHORT */
      195 DATA_TYPE (7):
      196       if descriptor.packed
      197       then bit_length = DOUBLE * (precision_descriptor.precision + ONE_BYTE);
      198       else
      199          do;
      200 	  alignment = EVEN_WORD_ALIGNED;
      201 	  bit_length = TWO_WORD;
      202          end;
      203       goto END_CASE;
      204 
      205 /* COMPLEX FLOATING BINARY LONG */
      206 DATA_TYPE (8):
      207       if descriptor.packed
      208       then bit_length = DOUBLE * (precision_descriptor.precision + ONE_BYTE);
      209       else
      210          do;
      211 	  alignment = EVEN_WORD_ALIGNED;
      212 	  bit_length = FOUR_WORD;
      213          end;
      214       goto END_CASE;
      215 
      216 
      217 /* REAL FIXED DECIMAL */
      218 DATA_TYPE (9):
      219       bit_length = ONE_BYTE * (precision_descriptor.precision + SIGN);
      220       if descriptor.packed
      221       then alignment = BYTE_ALIGNED;
      222       else
      223          do;
      224 	  alignment = WORD_ALIGNED;
      225 	  call pad_to_word_boundary ();
      226          end;
      227       goto END_CASE;
      228 
      229 /* REAL FLOATING DECIMAL */
      230 DATA_TYPE (10):
      231       bit_length = ONE_BYTE * (precision_descriptor.precision + SIGN_AND_EXPONENT);
      232       if descriptor.packed
      233       then alignment = BYTE_ALIGNED;
      234       else
      235          do;
      236 	  alignment = WORD_ALIGNED;
      237 	  call pad_to_word_boundary ();
      238          end;
      239       goto END_CASE;
      240 
      241 /* COMPLEX FIXED DECIMAL */
      242 DATA_TYPE (11):
      243       bit_length = DOUBLE * ONE_BYTE * (precision_descriptor.precision + SIGN);
      244       if descriptor.packed
      245       then alignment = BYTE_ALIGNED;
      246       else
      247          do;
      248 	  alignment = WORD_ALIGNED;
      249 	  call pad_to_word_boundary ();
      250          end;
      251       goto END_CASE;
      252 
      253 /* COMPLEX FLOATING DECIMAL */
      254 DATA_TYPE (12):
      255       bit_length = DOUBLE * ONE_BYTE * (precision_descriptor.precision + SIGN_AND_EXPONENT);
      256       if descriptor.packed
      257       then alignment = BYTE_ALIGNED;
      258       else
      259          do;
      260 	  alignment = WORD_ALIGNED;
      261 	  call pad_to_word_boundary ();
      262          end;
      263       goto END_CASE;
      264 
      265 
      266 /* POINTER */
      267 DATA_TYPE (13):
      268       if descriptor.packed
      269       then bit_length = ONE_WORD;
      270       else
      271          do;
      272 	  alignment = EVEN_WORD_ALIGNED;
      273 	  bit_length = TWO_WORD;
      274          end;
      275       goto END_CASE;
      276 
      277 /* OFFSET */
      278 DATA_TYPE (14):
      279       if descriptor.packed
      280       then p_code = dm_error_$invalid_alignment;
      281       else
      282          do;
      283 	  alignment = WORD_ALIGNED;
      284 	  bit_length = ONE_WORD;
      285          end;
      286       goto END_CASE;
      287 
      288 /* LABEL */
      289 DATA_TYPE (15):
      290       if descriptor.packed
      291       then p_code = dm_error_$invalid_alignment;
      292       else
      293          do;
      294 	  alignment = EVEN_WORD_ALIGNED;
      295 	  bit_length = FOUR_WORD;
      296          end;
      297       goto END_CASE;
      298 
      299 /* ENTRY */
      300 DATA_TYPE (16):
      301       if descriptor.packed
      302       then p_code = dm_error_$invalid_alignment;
      303       else
      304          do;
      305 	  alignment = EVEN_WORD_ALIGNED;
      306 	  bit_length = FOUR_WORD;
      307          end;
      308       goto END_CASE;
      309 
      310 /* NOTE: this length is correct for structures declared
      311*   without arrays only. (i.e. only scalar elements) */
      312 
      313 /* STRUCTURE */
      314 DATA_TYPE (17):
      315       if ^descriptor.packed
      316       then alignment = WORD_ALIGNED;
      317       bit_length = ONE_WORD * descriptor.size;
      318       goto END_CASE;
      319 
      320 /* AREA */
      321 DATA_TYPE (18):
      322       alignment = EVEN_WORD_ALIGNED;
      323       bit_length = ONE_WORD * descriptor.size;
      324       goto END_CASE;
      325 
      326 
      327 /* BIT STRING */
      328 DATA_TYPE (19):
      329       bit_length = descriptor.size;
      330       if ^descriptor.packed
      331       then
      332          do;
      333 	  alignment = WORD_ALIGNED;
      334 	  call pad_to_word_boundary ();
      335          end;
      336       goto END_CASE;
      337 
      338 /* Note: varying strings are stored in a special fashion which makes them,
      339*   act as though they were bit-aligned. */
      340 
      341 /* VARYING BIT STRING */
      342 DATA_TYPE (20):
      343       bit_length = descriptor.size + ONE_WORD;
      344       if ^descriptor.packed
      345       then call pad_to_word_boundary ();
      346       goto END_CASE;
      347 
      348 /* CHARACTER STRING */
      349 DATA_TYPE (21):
      350       bit_length = ONE_BYTE * descriptor.size;
      351       if descriptor.packed
      352       then alignment = BYTE_ALIGNED;
      353       else
      354          do;
      355 	  alignment = WORD_ALIGNED;
      356 	  call pad_to_word_boundary ();
      357          end;
      358       goto END_CASE;
      359 
      360 /* Note: varying strings are stored in a special fashion which makes them,
      361*   act as though they were bit-aligned. */
      362 
      363 /* VARYING CHARACTER STRING */
      364 DATA_TYPE (22):
      365       bit_length = (ONE_BYTE * descriptor.size) + ONE_WORD;
      366       if ^descriptor.packed
      367       then call pad_to_word_boundary ();
      368       goto END_CASE;
      369 
      370 
      371 /* FILE */
      372 DATA_TYPE (23):
      373       alignment = EVEN_WORD_ALIGNED;
      374       bit_length = FOUR_WORD;
      375       goto END_CASE;
      376 
      377 /* REAL FIXED DECIMAL LEADING OVERPUNCHED SIGN 9-BIT */
      378 DATA_TYPE (29):
      379       bit_length = ONE_BYTE * precision_descriptor.precision;
      380       if descriptor.packed
      381       then alignment = BYTE_ALIGNED;
      382       else
      383          do;
      384 	  alignment = WORD_ALIGNED;
      385 	  call pad_to_word_boundary ();
      386          end;
      387       goto END_CASE;
      388 
      389 /* REAL FIXED DECIMAL TRAILING OVERPUNCHED SIGN 9-BIT */
      390 DATA_TYPE (30):
      391       bit_length = ONE_BYTE * precision_descriptor.precision;
      392       if descriptor.packed
      393       then alignment = BYTE_ALIGNED;
      394       else
      395          do;
      396 	  alignment = WORD_ALIGNED;
      397 	  call pad_to_word_boundary ();
      398          end;
      399       goto END_CASE;
      400 
      401 /* REAL FIXED BINARY SHORT UNSIGNED */
      402 DATA_TYPE (33):
      403       if descriptor.packed
      404       then bit_length = precision_descriptor.precision;
      405       else
      406          do;
      407 	  alignment = WORD_ALIGNED;
      408 	  bit_length = ONE_WORD;
      409          end;
      410       goto END_CASE;
      411 
      412 /* REAL FIXED BINARY LONG UNSIGNED */
      413 DATA_TYPE (34):
      414       if descriptor.packed
      415       then bit_length = precision_descriptor.precision;
      416       else
      417          do;
      418 	  alignment = EVEN_WORD_ALIGNED;
      419 	  bit_length = TWO_WORD;
      420          end;
      421       goto END_CASE;
      422 
      423 
      424 /* REAL FIXED DECIMAL UNSIGNED 9-BIT */
      425 DATA_TYPE (35):
      426       bit_length = ONE_BYTE * precision_descriptor.precision;
      427       if descriptor.packed
      428       then alignment = BYTE_ALIGNED;
      429       else
      430          do;
      431 	  alignment = WORD_ALIGNED;
      432 	  call pad_to_word_boundary ();
      433          end;
      434       goto END_CASE;
      435 
      436 /* REAL FIXED DECIMAL TRAILING SIGN 9-BIT */
      437 DATA_TYPE (36):
      438       bit_length = ONE_BYTE * (precision_descriptor.precision + SIGN);
      439       if descriptor.packed
      440       then alignment = BYTE_ALIGNED;
      441       else
      442          do;
      443 	  alignment = WORD_ALIGNED;
      444 	  call pad_to_word_boundary ();
      445          end;
      446       goto END_CASE;
      447 
      448 /* NOTE: non-byte-aligned decimal 4-bit requires knowledge of
      449*   physical 1/2 byte alignment to determine actual bit length,
      450*   thus it is unsupported by pl1, and MRDS, and the returned
      451*   bit length will be the same as if it were the corresponding
      452*   byte aligned decimal 4-bit data type. */
      453 
      454 /* REAL FIXED DECIMAL UNSIGNED 4-BIT */
      455 DATA_TYPE (38):
      456       bit_length = ONE_BYTE * floor ((precision_descriptor.precision + PAD) / PER_BYTE_FACTOR);
      457       if descriptor.packed
      458       then alignment = BYTE_ALIGNED;
      459       else
      460          do;
      461 	  alignment = WORD_ALIGNED;
      462 	  call pad_to_word_boundary ();
      463          end;
      464       goto END_CASE;
      465 
      466 /* REAL FIXED DECIMAL TRAILING SIGN 4-BIT */
      467 DATA_TYPE (39):
      468       bit_length = ONE_BYTE * floor ((precision_descriptor.precision + SIGN_AND_PAD) / PER_BYTE_FACTOR);
      469       if descriptor.packed
      470       then alignment = BYTE_ALIGNED;
      471       else
      472          do;
      473 	  alignment = WORD_ALIGNED;
      474 	  call pad_to_word_boundary ();
      475          end;
      476       goto END_CASE;
      477 
      478 /* REAL FIXED DECIMAL LEADING SIGN 4-BIT */
      479 DATA_TYPE (41):
      480       bit_length = ONE_BYTE * floor ((precision_descriptor.precision + SIGN_AND_PAD) / PER_BYTE_FACTOR);
      481       if descriptor.packed
      482       then alignment = BYTE_ALIGNED;
      483       else
      484          do;
      485 	  alignment = WORD_ALIGNED;
      486 	  call pad_to_word_boundary ();
      487          end;
      488       goto END_CASE;
      489 
      490 /* REAL FLOATING DECIMAL 4-BIT */
      491 DATA_TYPE (42):
      492       bit_length = ONE_BYTE * floor ((precision_descriptor.precision + SIGN_EXPONENT_AND_PAD) / PER_BYTE_FACTOR);
      493       if descriptor.packed
      494       then alignment = BYTE_ALIGNED;
      495       else
      496          do;
      497 	  alignment = WORD_ALIGNED;
      498 	  call pad_to_word_boundary ();
      499          end;
      500       goto END_CASE;
      501 
      502 
      503 /* REAL FIXED DECIMAL LEADING SIGN 4-BIT BYTE-ALIGNED */
      504 DATA_TYPE (43):
      505       bit_length = ONE_BYTE * floor ((precision_descriptor.precision + SIGN_AND_PAD) / PER_BYTE_FACTOR);
      506       if descriptor.packed
      507       then alignment = BYTE_ALIGNED;
      508       else
      509          do;
      510 	  alignment = WORD_ALIGNED;
      511 	  call pad_to_word_boundary ();
      512          end;
      513       goto END_CASE;
      514 
      515 /* REAL FLOATING DECIMAL 4-BIT BYTE-ALIGNED */
      516 DATA_TYPE (44):
      517       bit_length = ONE_BYTE * floor ((precision_descriptor.precision + SIGN_EXPONENT_AND_PAD) / PER_BYTE_FACTOR);
      518       if descriptor.packed
      519       then alignment = BYTE_ALIGNED;
      520       else
      521          do;
      522 	  alignment = WORD_ALIGNED;
      523 	  call pad_to_word_boundary ();
      524          end;
      525       goto END_CASE;
      526 
      527 /* COMPLEX FIXED DECIMAL LEADING SIGN 4-BIT BYTE-ALIGNED */
      528 DATA_TYPE (45):
      529       bit_length = DOUBLE * ONE_BYTE * floor ((precision_descriptor.precision + SIGN_AND_PAD) / PER_BYTE_FACTOR);
      530       if descriptor.packed
      531       then alignment = BYTE_ALIGNED;
      532       else
      533          do;
      534 	  alignment = WORD_ALIGNED;
      535 	  call pad_to_word_boundary ();
      536          end;
      537       goto END_CASE;
      538 
      539 /* COMPLEX FLOATING DECIMAL 4-BIT BYTE-ALIGNED */
      540 DATA_TYPE (46):
      541       bit_length = DOUBLE * ONE_BYTE * floor ((precision_descriptor.precision + SIGN_EXPONENT_AND_PAD) / PER_BYTE_FACTOR);
      542       if descriptor.packed
      543       then alignment = BYTE_ALIGNED;
      544       else
      545          do;
      546 	  alignment = WORD_ALIGNED;
      547 	  call pad_to_word_boundary ();
      548          end;
      549       goto END_CASE;
      550 
      551 /* UNUSED */
      552 DATA_TYPE (0):
      553 DATA_TYPE (24):
      554 DATA_TYPE (25):
      555 DATA_TYPE (26):
      556 DATA_TYPE (27):
      557 DATA_TYPE (28):
      558 DATA_TYPE (31):
      559 DATA_TYPE (32):
      560 DATA_TYPE (37):
      561 DATA_TYPE (40):
      562 DATA_TYPE (47):
      563 DATA_TYPE (48):
      564 DATA_TYPE (49):
      565 DATA_TYPE (50):
      566 DATA_TYPE (51):
      567 DATA_TYPE (52):
      568 DATA_TYPE (53):
      569 DATA_TYPE (54):
      570 DATA_TYPE (55):
      571 DATA_TYPE (56):
      572 DATA_TYPE (57):
      573 DATA_TYPE (58):
      574 DATA_TYPE (59):
      575 DATA_TYPE (60):
      576 DATA_TYPE (61):
      577 DATA_TYPE (62):
      578 DATA_TYPE (63):
      579       p_code = dm_error_$unimplemented_data_type;
      580       goto END_CASE;
      581 
      582 /* END OF DESCRIPTOR TYPE CASE STATEMENT */
      583 END_CASE:
      584       p_bit_length = bit_length;
      585       if get_alignment
      586       then p_alignment = alignment;
      587 
      588       return;
      589 
      590 
      591 pad_to_word_boundary:
      592    procedure ();
      593 
      594 /* fill out the bit length to reflect a word boundary aligned,
      595*   integral number of words storage space */
      596 
      597       if mod (bit_length, ONE_WORD) = 0
      598       then ;
      599       else bit_length = bit_length + (ONE_WORD - mod (bit_length, ONE_WORD));
      600 
      601    end;
      602 
      603 
      604    end dmu_get_data_bit_length;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/03/85  1150.0  dmu_get_data_bit_length.pl1       >spec>temp>famis1>dmu_get_data_bit_length.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BIT_ALIGNED                            constant        fixed bin(17,0)          initial dcl 92 ref 117
BYTE_ALIGNED                           constant        fixed bin(17,0)          initial dcl 94 ref 220 232 244 256 351 380 392 427
                                                                                  439 457 469 481 493 506 518 530 542
DOUBLE                                 constant        fixed bin(17,0)          initial dcl 80 ref 173 184 195 206 242 254 528 540
EVEN_WORD_ALIGNED                      constant        fixed bin(17,0)          initial dcl 98 ref 144 166 178 189 200 211 272 294
                                                                                  305 321 372 418
FOUR_WORD                              constant        fixed bin(17,0)          initial dcl 88 ref 190 212 295 306 374
ONE_BYTE                               constant        fixed bin(17,0)          initial dcl 90 ref 150 161 195 206 218 230 242 254
                                                                                  349 364 378 390 425 437 455 467 479 491 504 516
                                                                                  528 540
ONE_WORD                        001244 constant        fixed bin(17,0)          initial dcl 84 ref 134 156 267 284 317 323 342 364
                                                                                  408 597 599 599
PAD                                    constant        fixed bin(17,0)          initial dcl 74 ref 455
PER_BYTE_FACTOR                 001245 constant        fixed bin(17,0)          initial dcl 76 ref 455 467 479 491 504 516 528 540
SIGN                                   constant        fixed bin(17,0)          initial dcl 82 ref 128 139 173 184 218 242 437
SIGN_AND_EXPONENT                      constant        fixed bin(17,0)          initial dcl 78 ref 230 254
SIGN_AND_PAD                           constant        fixed bin(17,0)          initial dcl 70 ref 467 479 504 528
SIGN_EXPONENT_AND_PAD                  constant        fixed bin(17,0)          initial dcl 72 ref 491 516 540
TWO_WORD                               constant        fixed bin(17,0)          initial dcl 86 ref 145 167 179 201 273 419
WORD_ALIGNED                           constant        fixed bin(17,0)          initial dcl 96 ref 133 155 224 236 248 260 283 314
                                                                                  333 355 384 396 407 431 443 461 473 485 497 510
                                                                                  522 534 546
addr                                                   builtin function         dcl 64 ref 125 128 128 139 139 150 150 161 161 173
                                                                                  173 184 184 195 195 206 206 218 220 230 232 242
                                                                                  244 254 256 267 278 289 300 314 317 323 328 330
                                                                                  342 344 349 351 364 366 378 380 390 392 402 402
                                                                                  413 413 425 427 437 439 455 457 467 469 479 481
                                                                                  491 493 504 506 516 518 528 530 540 542
alignment                       000101 automatic       fixed bin(17,0)          dcl 45 set ref 117* 133* 144* 155* 166* 178* 189*
                                                                                  200* 211* 220* 224* 232* 236* 244* 248* 256* 260*
                                                                                  272* 283* 294* 305* 314* 321* 333* 351* 355* 372*
                                                                                  380* 384* 392* 396* 407* 418* 427* 431* 439* 443*
                                                                                  457* 461* 469* 473* 481* 485* 493* 497* 506* 510*
                                                                                  518* 522* 530* 534* 542* 546* 585
bit_length                      000103 automatic       fixed bin(35,0)          dcl 47 set ref 128* 134* 139* 145* 150* 156* 161*
                                                                                  167* 173* 179* 184* 190* 195* 201* 206* 212* 218*
                                                                                  230* 242* 254* 267* 273* 284* 295* 306* 317* 323*
                                                                                  328* 342* 349* 364* 374* 378* 390* 402* 408* 413*
                                                                                  419* 425* 437* 455* 467* 479* 491* 504* 516* 528*
                                                                                  540* 583 597 599* 599 599
descriptor                             based           structure                level 1 packed unaligned dcl 51
descriptor_string               000102 automatic       bit(36)                  dcl 46 set ref 119* 125 128 128 139 139 150 150 161
                                                                                  161 173 173 184 184 195 195 206 206 218 220 230
                                                                                  232 242 244 254 256 267 278 289 300 314 317 323
                                                                                  328 330 342 344 349 351 364 366 378 380 390 392
                                                                                  402 402 413 413 425 427 437 439 455 457 467 469
                                                                                  479 481 491 493 504 506 516 518 528 530 540 542
dm_error_$invalid_alignment     000012 external static fixed bin(35,0)          dcl 106 ref 278 289 300
dm_error_$unimplemented_data_type
                                000010 external static fixed bin(35,0)          dcl 104 ref 552
floor                                                  builtin function         dcl 64 ref 455 467 479 491 504 516 528 540
get_alignment                   000100 automatic       bit(1)                   initial dcl 44 set ref 44* 116* 585
mod                                                    builtin function         dcl 64 ref 597 599
p_alignment                            parameter       fixed bin(17,0)          dcl 39 set ref 113 585*
p_bit_length                           parameter       fixed bin(35,0)          dcl 38 set ref 7 113 583*
p_code                                 parameter       fixed bin(35,0)          dcl 40 set ref 7 113 121* 278* 289* 300* 552*
p_descriptor                           parameter       bit(36)                  dcl 37 ref 7 113 119
packed                    0(07)        based           bit(1)                   level 2 packed unaligned dcl 51 ref 128 139 150 161
                                                                                  173 184 195 206 220 232 244 256 267 278 289 300
                                                                                  314 330 344 351 366 380 392 402 413 427 439 457
                                                                                  469 481 493 506 518 530 542
precision                 0(24)        based           fixed bin(12,0)          level 2 packed unsigned unaligned dcl 58 ref 128 139
                                                                                  150 161 173 184 195 206 218 230 242 254 378 390
                                                                                  402 413 425 437 455 467 479 491 504 516 528 540
precision_descriptor                   based           structure                level 1 packed unaligned dcl 58
size                      0(12)        based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 51 ref 317 323
                                                                                  328 342 349 364
type                      0(01)        based           fixed bin(6,0)           level 2 packed unsigned unaligned dcl 51 ref 125

NAME DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
null                                                   builtin function         dcl 64

NAMES DECLARED BY EXPLICIT CONTEXT.
DATA_TYPE                       000000 constant        label                    array(0:63) dcl 128 ref 125
END_CASE                        001216 constant        label                    dcl 583 ref 136 147 158 169 181 192 203 214 227 239
                                                                                  251 263 275 286 297 308 318 324 336 346 358 368
                                                                                  375 387 399 410 421 434 446 464 476 488 500 513
                                                                                  525 537 549 580
JOIN                            000147 constant        label                    dcl 119 ref 111
alignment                       000132 constant        entry                    external dcl 113
dmu_get_data_bit_length         000113 constant        entry                    external dcl 7
pad_to_word_boundary            001226 constant        entry                    internal dcl 591 ref 225 237 249 261 334 344 356 366
                                                                                  385 397 432 444 462 474 486 498 511 523 535 547

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1330        1344    1246        1340
Length      1524    1246        14         143      61           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
dmu_get_data_bit_length              81 external procedure  is an external procedure.  
pad_to_word_boundary                    internal procedure  shares stack frame of external procedure dmu_get_data_bit_length.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
dmu_get_data_bit_length  000100 get_alignment               dmu_get_data_bit_length
                         000101 alignment                   dmu_get_data_bit_length
                         000102 descriptor_string           dmu_get_data_bit_length
                         000103 bit_length                  dmu_get_data_bit_length

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
return              mod_fx1             ext_entry           floor_fx2           divide_fx1

NO EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$invalid_alignment   dm_error_$unimplemented_data_type


CONSTANTS
001244  aa     000000000044

000100  aa     404000000021

001245  aa     000000000002

000101  aa     404000000043

000102  aa     514000000044

LABEL ARRAYS
000000  aa   001212 7100 04	tra  	650,ic		001212
000001  aa   000160 7100 04	tra  	112,ic		000161
000002  aa   000174 7100 04	tra  	124,ic		000176
000003  aa   000210 7100 04	tra  	136,ic		000213
000004  aa   000224 7100 04	tra  	148,ic		000230
000005  aa   000240 7100 04	tra  	160,ic		000245
000006  aa   000255 7100 04	tra  	173,ic		000263
000007  aa   000272 7100 04	tra  	186,ic		000301
000010  aa   000307 7100 04	tra  	199,ic		000317
000011  aa   000324 7100 04	tra  	212,ic		000335
000012  aa   000342 7100 04	tra  	226,ic		000354
000013  aa   000360 7100 04	tra  	240,ic		000373
000014  aa   000400 7100 04	tra  	256,ic		000414
000015  aa   000420 7100 04	tra  	272,ic		000435
000016  aa   000432 7100 04	tra  	282,ic		000450
000017  aa   000445 7100 04	tra  	293,ic		000464
000020  aa   000460 7100 04	tra  	304,ic		000500
000021  aa   000473 7100 04	tra  	315,ic		000514
000022  aa   000504 7100 04	tra  	324,ic		000526
000023  aa   000512 7100 04	tra  	330,ic		000535
000024  aa   000523 7100 04	tra  	339,ic		000547
000025  aa   000533 7100 04	tra  	347,ic		000560
000026  aa   000550 7100 04	tra  	360,ic		000576
000027  aa   000561 7100 04	tra  	369,ic		000610
000030  aa   001162 7100 04	tra  	626,ic		001212
000031  aa   001161 7100 04	tra  	625,ic		001212
000032  aa   001160 7100 04	tra  	624,ic		001212
000033  aa   001157 7100 04	tra  	623,ic		001212
000034  aa   001156 7100 04	tra  	622,ic		001212
000035  aa   000560 7100 04	tra  	368,ic		000615
000036  aa   000575 7100 04	tra  	381,ic		000633
000037  aa   001153 7100 04	tra  	619,ic		001212
000040  aa   001152 7100 04	tra  	618,ic		001212
000041  aa   000610 7100 04	tra  	392,ic		000651
000042  aa   000623 7100 04	tra  	403,ic		000665
000043  aa   000636 7100 04	tra  	414,ic		000701
000044  aa   000653 7100 04	tra  	427,ic		000717
000045  aa   001145 7100 04	tra  	613,ic		001212
000046  aa   000670 7100 04	tra  	440,ic		000736
000047  aa   000714 7100 04	tra  	460,ic		000763
000050  aa   001142 7100 04	tra  	610,ic		001212
000051  aa   000737 7100 04	tra  	479,ic		001010
000052  aa   000763 7100 04	tra  	499,ic		001035
000053  aa   001007 7100 04	tra  	519,ic		001062
000054  aa   001033 7100 04	tra  	539,ic		001107
000055  aa   001057 7100 04	tra  	559,ic		001134
000056  aa   001105 7100 04	tra  	581,ic		001163
000057  aa   001133 7100 04	tra  	603,ic		001212
000060  aa   001132 7100 04	tra  	602,ic		001212
000061  aa   001131 7100 04	tra  	601,ic		001212
000062  aa   001130 7100 04	tra  	600,ic		001212
000063  aa   001127 7100 04	tra  	599,ic		001212
000064  aa   001126 7100 04	tra  	598,ic		001212
000065  aa   001125 7100 04	tra  	597,ic		001212
000066  aa   001124 7100 04	tra  	596,ic		001212
000067  aa   001123 7100 04	tra  	595,ic		001212
000070  aa   001122 7100 04	tra  	594,ic		001212
000071  aa   001121 7100 04	tra  	593,ic		001212
000072  aa   001120 7100 04	tra  	592,ic		001212
000073  aa   001117 7100 04	tra  	591,ic		001212
000074  aa   001116 7100 04	tra  	590,ic		001212
000075  aa   001115 7100 04	tra  	589,ic		001212
000076  aa   001114 7100 04	tra  	588,ic		001212
000077  aa   001113 7100 04	tra  	587,ic		001212

BEGIN PROCEDURE dmu_get_data_bit_length
PROLOGUE SEQUENCE
000103  aa  6 00114 4401 00	sxl0 	pr6|76
						STATEMENT 1 ON LINE 44
000104  aa  6 00100 4501 00	stz  	pr6|64		get_alignment
000105  aa  6 00114 7201 00	lxl0 	pr6|76
000106  aa   000000 7100 10	tra  	0,0
MAIN SEQUENCE
ENTRY TO dmu_get_data_bit_length                            STATEMENT 1 ON LINE 7
dmu_get_data_bit_length:
   proc (p_descriptor, p_bit_length, p_code);

000107  at     000003000102
000110  tt     000101000101
000111  ta     000107000000
000112  da     000047300000
000113  aa   000140 6270 00	eax7 	96
000114  aa  7 00034 3521 20	epp2 	pr7|28,*
000115  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000116  aa     000006000000
000117  aa     000000000000
000120  aa  6 00032 3735 20	epp7 	pr6|26,*
000121  aa  7 00006 3715 20	epp5 	pr7|6,*
000122  aa  6 00104 6515 00	spri5	pr6|68
000123  aa   777760 7000 04	tsx0 	-16,ic		000103
						STATEMENT 1 ON LINE 111
      go to JOIN;

000124  aa   000023 7100 04	tra  	19,ic		000147
ENTRY TO alignment                                          STATEMENT 1 ON LINE 113
alignment:
   entry (p_descriptor, p_bit_length, p_alignment, p_code);

000125  at     000004000102
000126  tt     000101000100
000127  ta     000101000000
000130  ta     000125000000
000131  da     000055300000
000132  aa   000140 6270 00	eax7 	96
000133  aa  7 00034 3521 20	epp2 	pr7|28,*
000134  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000135  aa     000010000000
000136  aa     000000000000
000137  aa  6 00032 3735 20	epp7 	pr6|26,*
000140  aa  7 00010 3715 20	epp5 	pr7|8,*
000141  aa  6 00104 6515 00	spri5	pr6|68
000142  aa   777741 7000 04	tsx0 	-31,ic		000103
						STATEMENT 1 ON LINE 116
      get_alignment = "1"b;

000143  aa   400000 2350 03	lda  	131072,du
000144  aa  6 00100 7551 00	sta  	pr6|64		get_alignment
						STATEMENT 1 ON LINE 117
      alignment = BIT_ALIGNED;

000145  aa   000001 2360 07	ldq  	1,dl
000146  aa  6 00101 7561 00	stq  	pr6|65		alignment
						STATEMENT 1 ON LINE 119
JOIN:
      descriptor_string = p_descriptor;

000147  aa  6 00032 3735 20	epp7 	pr6|26,*
000150  aa  7 00002 2351 20	lda  	pr7|2,*		p_descriptor
000151  aa  6 00102 7551 00	sta  	pr6|66		descriptor_string
						STATEMENT 1 ON LINE 121
      p_code = 0;

000152  aa  6 00104 4501 20	stz  	pr6|68,*		p_code
						STATEMENT 1 ON LINE 125
      goto DATA_TYPE (descriptor.type);

000153  aa  6 00102 2351 00	lda  	pr6|66		descriptor.type
000154  aa   000001 7350 00	als  	1
000155  aa   000102 7730 00	lrl  	66
000156  aa  6 00102 3715 00	epp5 	pr6|66		descriptor_string
000157  aa  6 00116 6515 00	spri5	pr6|78
000160  ta   000000 7100 06	tra  	0,ql
						STATEMENT 1 ON LINE 128
DATA_TYPE (1):
      if descriptor.packed
      then bit_length = precision_descriptor.precision + SIGN;

000161  aa  5 00000 2351 00	lda  	pr5|0		descriptor.packed
000162  aa   002000 3150 03	cana 	1024,du
000163  aa   000006 6000 04	tze  	6,ic		000171
000164  aa  5 00000 2361 00	ldq  	pr5|0		precision_descriptor.precision
000165  aa  0 00410 3771 00	anaq 	pr0|264		= 000000000000 000000007777
000166  aa   000001 0760 07	adq  	1,dl
000167  aa  6 00103 7561 00	stq  	pr6|67		bit_length
000170  aa   001026 7100 04	tra  	534,ic		001216
						STATEMENT 1 ON LINE 131
      else
         do;

						STATEMENT 1 ON LINE 133
	  alignment = WORD_ALIGNED;

000171  aa   000044 2360 07	ldq  	36,dl
000172  aa  6 00101 7561 00	stq  	pr6|65		alignment
						STATEMENT 1 ON LINE 134
	  bit_length = ONE_WORD;

000173  aa   000044 2360 07	ldq  	36,dl
000174  aa  6 00103 7561 00	stq  	pr6|67		bit_length
						STATEMENT 1 ON LINE 135
         end;

						STATEMENT 1 ON LINE 136
      goto END_CASE;

000175  aa   001021 7100 04	tra  	529,ic		001216
						STATEMENT 1 ON LINE 139
DATA_TYPE (2):
      if descriptor.packed
      then bit_length = precision_descriptor.precision + SIGN;

000176  aa  5 00000 2351 00	lda  	pr5|0		descriptor.packed
000177  aa   002000 3150 03	cana 	1024,du
000200  aa   000006 6000 04	tze  	6,ic		000206
000201  aa  5 00000 2361 00	ldq  	pr5|0		precision_descriptor.precision
000202  aa  0 00410 3771 00	anaq 	pr0|264		= 000000000000 000000007777
000203  aa   000001 0760 07	adq  	1,dl
000204  aa  6 00103 7561 00	stq  	pr6|67		bit_length
000205  aa   001011 7100 04	tra  	521,ic		001216
						STATEMENT 1 ON LINE 142
      else
         do;

						STATEMENT 1 ON LINE 144
	  alignment = EVEN_WORD_ALIGNED;

000206  aa   000110 2360 07	ldq  	72,dl
000207  aa  6 00101 7561 00	stq  	pr6|65		alignment
						STATEMENT 1 ON LINE 145
	  bit_length = TWO_WORD;

000210  aa   000110 2360 07	ldq  	72,dl
000211  aa  6 00103 7561 00	stq  	pr6|67		bit_length
						STATEMENT 1 ON LINE 146
         end;

						STATEMENT 1 ON LINE 147
      goto END_CASE;

000212  aa   001004 7100 04	tra  	516,ic		001216
						STATEMENT 1 ON LINE 150
DATA_TYPE (3):
      if descriptor.packed
      then bit_length = precision_descriptor.precision + ONE_BYTE;

000213  aa  5 00000 2351 00	lda  	pr5|0		descriptor.packed
000214  aa   002000 3150 03	cana 	1024,du
000215  aa   000006 6000 04	tze  	6,ic		000223
000216  aa  5 00000 2361 00	ldq  	pr5|0		precision_descriptor.precision
000217  aa  0 00410 3771 00	anaq 	pr0|264		= 000000000000 000000007777
000220  aa   000011 0760 07	adq  	9,dl
000221  aa  6 00103 7561 00	stq  	pr6|67		bit_length
000222  aa   000774 7100 04	tra  	508,ic		001216
						STATEMENT 1 ON LINE 153
      else
         do;

						STATEMENT 1 ON LINE 155
	  alignment = WORD_ALIGNED;

000223  aa   000044 2360 07	ldq  	36,dl
000224  aa  6 00101 7561 00	stq  	pr6|65		alignment
						STATEMENT 1 ON LINE 156
	  bit_length = ONE_WORD;

000225  aa   000044 2360 07	ldq  	36,dl
000226  aa  6 00103 7561 00	stq  	pr6|67		bit_length
						STATEMENT 1 ON LINE 157
         end;

						STATEMENT 1 ON LINE 158
      goto END_CASE;

000227  aa   000767 7100 04	tra  	503,ic		001216
						STATEMENT 1 ON LINE 161
DATA_TYPE (4):
      if descriptor.packed
      then bit_length = precision_descriptor.precision + ONE_BYTE;

000230  aa  5 00000 2351 00	lda  	pr5|0		descriptor.packed
000231  aa   002000 3150 03	cana 	1024,du
000232  aa   000006 6000 04	tze  	6,ic		000240
000233  aa  5 00000 2361 00	ldq  	pr5|0		precision_descriptor.precision
000234  aa  0 00410 3771 00	anaq 	pr0|264		= 000000000000 000000007777
000235  aa   000011 0760 07	adq  	9,dl
000236  aa  6 00103 7561 00	stq  	pr6|67		bit_length
000237  aa   000757 7100 04	tra  	495,ic		001216
						STATEMENT 1 ON LINE 164
      else
         do;

						STATEMENT 1 ON LINE 166
	  alignment = EVEN_WORD_ALIGNED;

000240  aa   000110 2360 07	ldq  	72,dl
000241  aa  6 00101 7561 00	stq  	pr6|65		alignment
						STATEMENT 1 ON LINE 167
	  bit_length = TWO_WORD;

000242  aa   000110 2360 07	ldq  	72,dl
000243  aa  6 00103 7561 00	stq  	pr6|67		bit_length
						STATEMENT 1 ON LINE 168
         end;

						STATEMENT 1 ON LINE 169
      goto END_CASE;

000244  aa   000752 7100 04	tra  	490,ic		001216
						STATEMENT 1 ON LINE 173
DATA_TYPE (5):
      if descriptor.packed
      then bit_length = DOUBLE * (precision_descriptor.precision + SIGN);

000245  aa  5 00000 2351 00	lda  	pr5|0		descriptor.packed
000246  aa   002000 3150 03	cana 	1024,du
000247  aa   000007 6000 04	tze  	7,ic		000256
000250  aa  5 00000 2361 00	ldq  	pr5|0		precision_descriptor.precision
000251  aa  0 00410 3771 00	anaq 	pr0|264		= 000000000000 000000007777
000252  aa   000001 0760 07	adq  	1,dl
000253  aa   000002 4020 07	mpy  	2,dl
000254  aa  6 00103 7561 00	stq  	pr6|67		bit_length
000255  aa   000741 7100 04	tra  	481,ic		001216
						STATEMENT 1 ON LINE 176
      else
         do;

						STATEMENT 1 ON LINE 178
	  alignment = EVEN_WORD_ALIGNED;

000256  aa   000110 2360 07	ldq  	72,dl
000257  aa  6 00101 7561 00	stq  	pr6|65		alignment
						STATEMENT 1 ON LINE 179
	  bit_length = TWO_WORD;

000260  aa   000110 2360 07	ldq  	72,dl
000261  aa  6 00103 7561 00	stq  	pr6|67		bit_length
						STATEMENT 1 ON LINE 180
         end;

						STATEMENT 1 ON LINE 181
      goto END_CASE;

000262  aa   000734 7100 04	tra  	476,ic		001216
						STATEMENT 1 ON LINE 184
DATA_TYPE (6):
      if descriptor.packed
      then bit_length = DOUBLE * (precision_descriptor.precision + SIGN);

000263  aa  5 00000 2351 00	lda  	pr5|0		descriptor.packed
000264  aa   002000 3150 03	cana 	1024,du
000265  aa   000007 6000 04	tze  	7,ic		000274
000266  aa  5 00000 2361 00	ldq  	pr5|0		precision_descriptor.precision
000267  aa  0 00410 3771 00	anaq 	pr0|264		= 000000000000 000000007777
000270  aa   000001 0760 07	adq  	1,dl
000271  aa   000002 4020 07	mpy  	2,dl
000272  aa  6 00103 7561 00	stq  	pr6|67		bit_length
000273  aa   000723 7100 04	tra  	467,ic		001216
						STATEMENT 1 ON LINE 187
      else
         do;

						STATEMENT 1 ON LINE 189
	  alignment = EVEN_WORD_ALIGNED;

000274  aa   000110 2360 07	ldq  	72,dl
000275  aa  6 00101 7561 00	stq  	pr6|65		alignment
						STATEMENT 1 ON LINE 190
	  bit_length = FOUR_WORD;

000276  aa   000220 2360 07	ldq  	144,dl
000277  aa  6 00103 7561 00	stq  	pr6|67		bit_length
						STATEMENT 1 ON LINE 191
         end;

						STATEMENT 1 ON LINE 192
      goto END_CASE;

000300  aa   000716 7100 04	tra  	462,ic		001216
						STATEMENT 1 ON LINE 195
DATA_TYPE (7):
      if descriptor.packed
      then bit_length = DOUBLE * (precision_descriptor.precision + ONE_BYTE);

000301  aa  5 00000 2351 00	lda  	pr5|0		descriptor.packed
000302  aa   002000 3150 03	cana 	1024,du
000303  aa   000007 6000 04	tze  	7,ic		000312
000304  aa  5 00000 2361 00	ldq  	pr5|0		precision_descriptor.precision
000305  aa  0 00410 3771 00	anaq 	pr0|264		= 000000000000 000000007777
000306  aa   000011 0760 07	adq  	9,dl
000307  aa   000002 4020 07	mpy  	2,dl
000310  aa  6 00103 7561 00	stq  	pr6|67		bit_length
000311  aa   000705 7100 04	tra  	453,ic		001216
						STATEMENT 1 ON LINE 198
      else
         do;

						STATEMENT 1 ON LINE 200
	  alignment = EVEN_WORD_ALIGNED;

000312  aa   000110 2360 07	ldq  	72,dl
000313  aa  6 00101 7561 00	stq  	pr6|65		alignment
						STATEMENT 1 ON LINE 201
	  bit_length = TWO_WORD;

000314  aa   000110 2360 07	ldq  	72,dl
000315  aa  6 00103 7561 00	stq  	pr6|67		bit_length
						STATEMENT 1 ON LINE 202
         end;

						STATEMENT 1 ON LINE 203
      goto END_CASE;

000316  aa   000700 7100 04	tra  	448,ic		001216
						STATEMENT 1 ON LINE 206
DATA_TYPE (8):
      if descriptor.packed
      then bit_length = DOUBLE * (precision_descriptor.precision + ONE_BYTE);

000317  aa  5 00000 2351 00	lda  	pr5|0		descriptor.packed
000320  aa   002000 3150 03	cana 	1024,du
000321  aa   000007 6000 04	tze  	7,ic		000330
000322  aa  5 00000 2361 00	ldq  	pr5|0		precision_descriptor.precision
000323  aa  0 00410 3771 00	anaq 	pr0|264		= 000000000000 000000007777
000324  aa   000011 0760 07	adq  	9,dl
000325  aa   000002 4020 07	mpy  	2,dl
000326  aa  6 00103 7561 00	stq  	pr6|67		bit_length
000327  aa   000667 7100 04	tra  	439,ic		001216
						STATEMENT 1 ON LINE 209
      else
         do;

						STATEMENT 1 ON LINE 211
	  alignment = EVEN_WORD_ALIGNED;

000330  aa   000110 2360 07	ldq  	72,dl
000331  aa  6 00101 7561 00	stq  	pr6|65		alignment
						STATEMENT 1 ON LINE 212
	  bit_length = FOUR_WORD;

000332  aa   000220 2360 07	ldq  	144,dl
000333  aa  6 00103 7561 00	stq  	pr6|67		bit_length
						STATEMENT 1 ON LINE 213
         end;

						STATEMENT 1 ON LINE 214
      goto END_CASE;

000334  aa   000662 7100 04	tra  	434,ic		001216
						STATEMENT 1 ON LINE 218
DATA_TYPE (9):
      bit_length = ONE_BYTE * (precision_descriptor.precision + SIGN);

000335  aa  5 00000 2361 00	ldq  	pr5|0		precision_descriptor.precision
000336  aa  0 00410 3771 00	anaq 	pr0|264		= 000000000000 000000007777
000337  aa   000001 0760 07	adq  	1,dl
000340  aa   000011 4020 07	mpy  	9,dl
000341  aa  6 00103 7561 00	stq  	pr6|67		bit_length
						STATEMENT 1 ON LINE 220
      if descriptor.packed
      then alignment = BYTE_ALIGNED;

000342  aa  5 00000 2351 00	lda  	pr5|0		descriptor.packed
000343  aa   002000 3150 03	cana 	1024,du
000344  aa   000004 6000 04	tze  	4,ic		000350
000345  aa   000011 2360 07	ldq  	9,dl
000346  aa  6 00101 7561 00	stq  	pr6|65		alignment
000347  aa   000647 7100 04	tra  	423,ic		001216
						STATEMENT 1 ON LINE 222
      else
         do;

						STATEMENT 1 ON LINE 224
	  alignment = WORD_ALIGNED;

000350  aa   000044 2360 07	ldq  	36,dl
000351  aa  6 00101 7561 00	stq  	pr6|65		alignment
						STATEMENT 1 ON LINE 225
	  call pad_to_word_boundary ();

000352  aa   000654 6700 04	tsp4 	428,ic		001226
						STATEMENT 1 ON LINE 226
         end;

						STATEMENT 1 ON LINE 227
      goto END_CASE;

000353  aa   000643 7100 04	tra  	419,ic		001216
						STATEMENT 1 ON LINE 230
DATA_TYPE (10):
      bit_length = ONE_BYTE * (precision_descriptor.precision + SIGN_AND_EXPONENT);

000354  aa  5 00000 2361 00	ldq  	pr5|0		precision_descriptor.precision
000355  aa  0 00410 3771 00	anaq 	pr0|264		= 000000000000 000000007777
000356  aa   000002 0760 07	adq  	2,dl
000357  aa   000011 4020 07	mpy  	9,dl
000360  aa  6 00103 7561 00	stq  	pr6|67		bit_length
						STATEMENT 1 ON LINE 232
      if descriptor.packed
      then alignment = BYTE_ALIGNED;

000361  aa  5 00000 2351 00	lda  	pr5|0		descriptor.packed
000362  aa   002000 3150 03	cana 	1024,du
000363  aa   000004 6000 04	tze  	4,ic		000367
000364  aa   000011 2360 07	ldq  	9,dl
000365  aa  6 00101 7561 00	stq  	pr6|65		alignment
000366  aa   000630 7100 04	tra  	408,ic		001216
						STATEMENT 1 ON LINE 234
      else
         do;

						STATEMENT 1 ON LINE 236
	  alignment = WORD_ALIGNED;

000367  aa   000044 2360 07	ldq  	36,dl
000370  aa  6 00101 7561 00	stq  	pr6|65		alignment
						STATEMENT 1 ON LINE 237
	  call pad_to_word_boundary ();

000371  aa   000635 6700 04	tsp4 	413,ic		001226
						STATEMENT 1 ON LINE 238
         end;

						STATEMENT 1 ON LINE 239
      goto END_CASE;

000372  aa   000624 7100 04	tra  	404,ic		001216
						STATEMENT 1 ON LINE 242
DATA_TYPE (11):
      bit_length = DOUBLE * ONE_BYTE * (precision_descriptor.precision + SIGN);

000373  aa  5 00000 2361 00	ldq  	pr5|0		precision_descriptor.precision
000374  aa  0 00410 3771 00	anaq 	pr0|264		= 000000000000 000000007777
000375  aa   000001 0760 07	adq  	1,dl
000376  aa  6 00115 7561 00	stq  	pr6|77
000377  aa   000022 2360 07	ldq  	18,dl
000400  aa  6 00115 4021 00	mpy  	pr6|77
000401  aa  6 00103 7561 00	stq  	pr6|67		bit_length
						STATEMENT 1 ON LINE 244
      if descriptor.packed
      then alignment = BYTE_ALIGNED;

000402  aa  5 00000 2351 00	lda  	pr5|0		descriptor.packed
000403  aa   002000 3150 03	cana 	1024,du
000404  aa   000004 6000 04	tze  	4,ic		000410
000405  aa   000011 2360 07	ldq  	9,dl
000406  aa  6 00101 7561 00	stq  	pr6|65		alignment
000407  aa   000607 7100 04	tra  	391,ic		001216
						STATEMENT 1 ON LINE 246
      else
         do;

						STATEMENT 1 ON LINE 248
	  alignment = WORD_ALIGNED;

000410  aa   000044 2360 07	ldq  	36,dl
000411  aa  6 00101 7561 00	stq  	pr6|65		alignment
						STATEMENT 1 ON LINE 249
	  call pad_to_word_boundary ();

000412  aa   000614 6700 04	tsp4 	396,ic		001226
						STATEMENT 1 ON LINE 250
         end;

						STATEMENT 1 ON LINE 251
      goto END_CASE;

000413  aa   000603 7100 04	tra  	387,ic		001216
						STATEMENT 1 ON LINE 254
DATA_TYPE (12):
      bit_length = DOUBLE * ONE_BYTE * (precision_descriptor.precision + SIGN_AND_EXPONENT);

000414  aa  5 00000 2361 00	ldq  	pr5|0		precision_descriptor.precision
000415  aa  0 00410 3771 00	anaq 	pr0|264		= 000000000000 000000007777
000416  aa   000002 0760 07	adq  	2,dl
000417  aa  6 00115 7561 00	stq  	pr6|77
000420  aa   000022 2360 07	ldq  	18,dl
000421  aa  6 00115 4021 00	mpy  	pr6|77
000422  aa  6 00103 7561 00	stq  	pr6|67		bit_length
						STATEMENT 1 ON LINE 256
      if descriptor.packed
      then alignment = BYTE_ALIGNED;

000423  aa  5 00000 2351 00	lda  	pr5|0		descriptor.packed
000424  aa   002000 3150 03	cana 	1024,du
000425  aa   000004 6000 04	tze  	4,ic		000431
000426  aa   000011 2360 07	ldq  	9,dl
000427  aa  6 00101 7561 00	stq  	pr6|65		alignment
000430  aa   000566 7100 04	tra  	374,ic		001216
						STATEMENT 1 ON LINE 258
      else
         do;

						STATEMENT 1 ON LINE 260
	  alignment = WORD_ALIGNED;

000431  aa   000044 2360 07	ldq  	36,dl
000432  aa  6 00101 7561 00	stq  	pr6|65		alignment
						STATEMENT 1 ON LINE 261
	  call pad_to_word_boundary ();

000433  aa   000573 6700 04	tsp4 	379,ic		001226
						STATEMENT 1 ON LINE 262
         end;

						STATEMENT 1 ON LINE 263
      goto END_CASE;

000434  aa   000562 7100 04	tra  	370,ic		001216
						STATEMENT 1 ON LINE 267
DATA_TYPE (13):
      if descriptor.packed
      then bit_length = ONE_WORD;

000435  aa  5 00000 2351 00	lda  	pr5|0		descriptor.packed
000436  aa   002000 3150 03	cana 	1024,du
000437  aa   000004 6000 04	tze  	4,ic		000443
000440  aa   000044 2360 07	ldq  	36,dl
000441  aa  6 00103 7561 00	stq  	pr6|67		bit_length
000442  aa   000554 7100 04	tra  	364,ic		001216
						STATEMENT 1 ON LINE 270
      else
         do;

						STATEMENT 1 ON LINE 272
	  alignment = EVEN_WORD_ALIGNED;

000443  aa   000110 2360 07	ldq  	72,dl
000444  aa  6 00101 7561 00	stq  	pr6|65		alignment
						STATEMENT 1 ON LINE 273
	  bit_length = TWO_WORD;

000445  aa   000110 2360 07	ldq  	72,dl
000446  aa  6 00103 7561 00	stq  	pr6|67		bit_length
						STATEMENT 1 ON LINE 274
         end;

						STATEMENT 1 ON LINE 275
      goto END_CASE;

000447  aa   000547 7100 04	tra  	359,ic		001216
						STATEMENT 1 ON LINE 278
DATA_TYPE (14):
      if descriptor.packed
      then p_code = dm_error_$invalid_alignment;

000450  aa  5 00000 2351 00	lda  	pr5|0		descriptor.packed
000451  aa   002000 3150 03	cana 	1024,du
000452  aa   000005 6000 04	tze  	5,ic		000457
000453  aa  6 00044 3701 20	epp4 	pr6|36,*
000454  la  4 00012 2361 20	ldq  	pr4|10,*		dm_error_$invalid_alignment
000455  aa  6 00104 7561 20	stq  	pr6|68,*		p_code
000456  aa   000540 7100 04	tra  	352,ic		001216
						STATEMENT 1 ON LINE 281
      else
         do;

						STATEMENT 1 ON LINE 283
	  alignment = WORD_ALIGNED;

000457  aa   000044 2360 07	ldq  	36,dl
000460  aa  6 00101 7561 00	stq  	pr6|65		alignment
						STATEMENT 1 ON LINE 284
	  bit_length = ONE_WORD;

000461  aa   000044 2360 07	ldq  	36,dl
000462  aa  6 00103 7561 00	stq  	pr6|67		bit_length
						STATEMENT 1 ON LINE 285
         end;

						STATEMENT 1 ON LINE 286
      goto END_CASE;

000463  aa   000533 7100 04	tra  	347,ic		001216
						STATEMENT 1 ON LINE 289
DATA_TYPE (15):
      if descriptor.packed
      then p_code = dm_error_$invalid_alignment;

000464  aa  5 00000 2351 00	lda  	pr5|0		descriptor.packed
000465  aa   002000 3150 03	cana 	1024,du
000466  aa   000005 6000 04	tze  	5,ic		000473
000467  aa  6 00044 3701 20	epp4 	pr6|36,*
000470  la  4 00012 2361 20	ldq  	pr4|10,*		dm_error_$invalid_alignment
000471  aa  6 00104 7561 20	stq  	pr6|68,*		p_code
000472  aa   000524 7100 04	tra  	340,ic		001216
						STATEMENT 1 ON LINE 292
      else
         do;

						STATEMENT 1 ON LINE 294
	  alignment = EVEN_WORD_ALIGNED;

000473  aa   000110 2360 07	ldq  	72,dl
000474  aa  6 00101 7561 00	stq  	pr6|65		alignment
						STATEMENT 1 ON LINE 295
	  bit_length = FOUR_WORD;

000475  aa   000220 2360 07	ldq  	144,dl
000476  aa  6 00103 7561 00	stq  	pr6|67		bit_length
						STATEMENT 1 ON LINE 296
         end;

						STATEMENT 1 ON LINE 297
      goto END_CASE;

000477  aa   000517 7100 04	tra  	335,ic		001216
						STATEMENT 1 ON LINE 300
DATA_TYPE (16):
      if descriptor.packed                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 else
         do;

						STATEMENT 1 ON LINE 396
	  alignment = WORD_ALIGNED;

000645  aa   000044 2360 07	ldq  	36,dl
000646  aa  6 00101 7561 00	stq  	pr6|65		alignment
						STATEMENT 1 ON LINE 397
	  call pad_to_word_boundary ();

000647  aa   000357 6700 04	tsp4 	239,ic		001226
						STATEMENT 1 ON LINE 398
         end;

						STATEMENT 1 ON LINE 399
      goto END_CASE;

000650  aa   000346 7100 04	tra  	230,ic		001216
						STATEMENT 1 ON LINE 402
DATA_TYPE (33):
      if descriptor.packed
      then bit_length = precision_descriptor.precision;

000651  aa  5 00000 2351 00	lda  	pr5|0		descriptor.packed
000652  aa   002000 3150 03	cana 	1024,du
000653  aa   000005 6000 04	tze  	5,ic		000660
000654  aa  5 00000 2361 00	ldq  	pr5|0		precision_descriptor.precision
000655  aa  0 00410 3771 00	anaq 	pr0|264		= 000000000000 000000007777
000656  aa  6 00103 7561 00	stq  	pr6|67		bit_length
000657  aa   000337 7100 04	tra  	223,ic		001216
						STATEMENT 1 ON LINE 405
      else
         do;

						STATEMENT 1 ON LINE 407
	  alignment = WORD_ALIGNED;

000660  aa   000044 2360 07	ldq  	36,dl
000661  aa  6 00101 7561 00	stq  	pr6|65		alignment
						STATEMENT 1 ON LINE 408
	  bit_length = ONE_WORD;

000662  aa   000044 2360 07	ldq  	36,dl
000663  aa  6 00103 7561 00	stq  	pr6|67		bit_length
						STATEMENT 1 ON LINE 409
         end;

						STATEMENT 1 ON LINE 410
      goto END_CASE;

000664  aa   000332 7100 04	tra  	218,ic		001216
						STATEMENT 1 ON LINE 413
DATA_TYPE (34):
      if descriptor.packed
      then bit_length = precision_descriptor.precision;

000665  aa  5 00000 2351 00	lda  	pr5|0		descriptor.packed
000666  aa   002000 3150 03	cana 	1024,du
000667  aa   000005 6000 04	tze  	5,ic		000674
000670  aa  5 00000 2361 00	ldq  	pr5|0		precision_descriptor.precision
000671  aa  0 00410 3771 00	anaq 	pr0|264		= 000000000000 000000007777
000672  aa  6 00103 7561 00	stq  	pr6|67		bit_length
000673  aa   000323 7100 04	tra  	211,ic		001216
						STATEMENT 1 ON LINE 416
      else
         do;

						STATEMENT 1 ON LINE 418
	  alignment = EVEN_WORD_ALIGNED;

000674  aa   000110 2360 07	ldq  	72,dl
000675  aa  6 00101 7561 00	stq  	pr6|65		alignment
						STATEMENT 1 ON LINE 419
	  bit_length = TWO_WORD;

000676  aa   000110 2360 07	ldq  	72,dl
000677  aa  6 00103 7561 00	stq  	pr6|67		bit_length
						STATEMENT 1 ON LINE 420
         end;

						STATEMENT 1 ON LINE 421
      goto END_CASE;

000700  aa   000316 7100 04	tra  	206,ic		001216
						STATEMENT 1 ON LINE 425
DATA_TYPE (35):
      bit_length = ONE_BYTE * precision_descriptor.precision;

000701  aa  5 00000 2361 00	ldq  	pr5|0		precision_descriptor.precision
000702  aa  0 00410 3771 00	anaq 	pr0|264		= 000000000000 000000007777
000703  aa   000011 4020 07	mpy  	9,dl
000704  aa  6 00103 7561 00	stq  	pr6|67		bit_length
						STATEMENT 1 ON LINE 427
      if descriptor.packed
      then alignment = BYTE_ALIGNED;

000705  aa  5 00000 2351 00	lda  	pr5|0		descriptor.packed
000706  aa   002000 3150 03	cana 	1024,du
000707  aa   000004 6000 04	tze  	4,ic		000713
000710  aa   000011 2360 07	ldq  	9,dl
000711  aa  6 00101 7561 00	stq  	pr6|65		alignment
000712  aa   000304 7100 04	tra  	196,ic		001216
						STATEMENT 1 ON LINE 429
      else
         do;

						STATEMENT 1 ON LINE 431
	  alignment = WORD_ALIGNED;

000713  aa   000044 2360 07	ldq  	36,dl
000714  aa  6 00101 7561 00	stq  	pr6|65		alignment
						STATEMENT 1 ON LINE 432
	  call pad_to_word_boundary ();

000715  aa   000311 6700 04	tsp4 	201,ic		001226
						STATEMENT 1 ON LINE 433
         end;

						STATEMENT 1 ON LINE 434
      goto END_CASE;

000716  aa   000300 7100 04	tra  	192,ic		001216
						STATEMENT 1 ON LINE 437
DATA_TYPE (36):
      bit_length = ONE_BYTE * (precision_descriptor.precision + SIGN);

000717  aa  5 00000 2361 00	ldq  	pr5|0		precision_descriptor.precision
000720  aa  0 00410 3771 00	anaq 	pr0|264		= 000000000000 000000007777
000721  aa   000001 0760 07	adq  	1,dl
000722  aa   000011 4020 07	mpy  	9,dl
000723  aa  6 00103 7561 00	stq  	pr6|67		bit_length
						STATEMENT 1 ON LI                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 5 00000 2361 00	ldq  	pr5|0		precision_descriptor.precision
001011  aa  0 00410 3771 00	anaq 	pr0|264		= 000000000000 000000007777
001012  aa   000002 0760 07	adq  	2,dl
001013  aa   000232 3520 04	epp2 	154,ic		001245 = 000000000002
001014  aa  0 01262 7001 00	tsx0 	pr0|690		divide_fx1
001015  aa     000000000065
001016  aa   000065 7220 07	lxl2 	53,dl
001017  aa   777626 7230 07	lxl3 	262038,dl
001020  aa  0 01122 7001 00	tsx0 	pr0|594		floor_fx2
001021  aa   000011 4020 07	mpy  	9,dl
001022  aa  6 00103 7561 00	stq  	pr6|67		bit_length
						STATEMENT 1 ON LINE 481
      if descriptor.packed
      then alignment = BYTE_ALIGNED;

001023  aa  5 00000 2351 00	lda  	pr5|0		descriptor.packed
001024  aa   002000 3150 03	cana 	1024,du
001025  aa   000004 6000 04	tze  	4,ic		001031
001026  aa   000011 2360 07	ldq  	9,dl
001027  aa  6 00101 7561 00	stq  	pr6|65		alignment
001030  aa   000166 7100 04	tra  	118,ic		001216
						STATEMENT 1 ON LINE 483
      else
         do;

						STATEMENT 1 ON LINE 485
	  alignment = WORD_ALIGNED;

001031  aa   000044 2360 07	ldq  	36,dl
001032  aa  6 00101 7561 00	stq  	pr6|65		alignment
						STATEMENT 1 ON LINE 486
	  call pad_to_word_boundary ();

001033  aa   000173 6700 04	tsp4 	123,ic		001226
						STATEMENT 1 ON LINE 487
         end;

						STATEMENT 1 ON LINE 488
      goto END_CASE;

001034  aa   000162 7100 04	tra  	114,ic		001216
						STATEMENT 1 ON LINE 491
DATA_TYPE (42):
      bit_length = ONE_BYTE * floor ((precision_descriptor.precision + SIGN_EXPONENT_AND_PAD) / PER_BYTE_FACTOR);

001035  aa  5 00000 2361 00	ldq  	pr5|0		precision_descriptor.precision
001036  aa  0 00410 3771 00	anaq 	pr0|264		= 000000000000 000000007777
001037  aa   000004 0760 07	adq  	4,dl
001040  aa   000205 3520 04	epp2 	133,ic		001245 = 000000000002
001041  aa  0 01262 7001 00	tsx0 	pr0|690		divide_fx1
001042  aa     000000000065
001043  aa   000065 7220 07	lxl2 	53,dl
001044  aa   777626 7230 07	lxl3 	262038,dl
001045  aa  0 01122 7001 00	tsx0 	pr0|594		floor_fx2
001046  aa   000011 4020 07	mpy  	9,dl
001047  aa  6 00103 7561 00	stq  	pr6|67		bit_length
						STATEMENT 1 ON LINE 493
      if descriptor.packed
      then alignment = BYTE_ALIGNED;

001050  aa  5 00000 2351 00	lda  	pr5|0		descriptor.packed
001051  aa   002000 3150 03	cana 	1024,du
001052  aa   000004 6000 04	tze  	4,ic		001056
001053  aa   000011 2360 07	ldq  	9,dl
001054  aa  6 00101 7561 00	stq  	pr6|65		alignment
001055  aa   000141 7100 04	tra  	97,ic		001216
						STATEMENT 1 ON LINE 495
      else
         do;

						STATEMENT 1 ON LINE 497
	  alignment = WORD_ALIGNED;

001056  aa   000044 2360 07	ldq  	36,dl
001057  aa  6 00101 7561 00	stq  	pr6|65		alignment
						STATEMENT 1 ON LINE 498
	  call pad_to_word_boundary ();

001060  aa   000146 6700 04	tsp4 	102,ic		001226
						STATEMENT 1 ON LINE 499
         end;

						STATEMENT 1 ON LINE 500
      goto END_CASE;

001061  aa   000135 7100 04	tra  	93,ic		001216
						STATEMENT 1 ON LINE 504
DATA_TYPE (43):
      bit_length = ONE_BYTE * floor ((precision_descriptor.precision + SIGN_AND_PAD) / PER_BYTE_FACTOR);

001062  aa  5 00000 2361 00	ldq  	pr5|0		precision_descriptor.precision
001063  aa  0 00410 3771 00	anaq 	pr0|264		= 000000000000 000000007777
001064  aa   000002 0760 07	adq  	2,dl
001065  aa   000160 3520 04	epp2 	112,ic		001245 = 000000000002
001066  aa  0 01262 7001 00	tsx0 	pr0|690		divide_fx1
001067  aa     000000000065
001070  aa   000065 7220 07	lxl2 	53,dl
001071  aa   777626 7230 07	lxl3 	262038,dl
001072  aa  0 01122 7001 00	tsx0 	pr0|594		floor_fx2
001073  aa   000011 4020 07	mpy  	9,dl
001074  aa  6 00103 7561 00	stq  	pr6|67		bit_length
						STATEMENT 1 ON LINE 506
      if descriptor.packed
      then alignment = BYTE_ALIGNED;

001075  aa  5 00000 2351 00	lda  	pr5|0		descriptor.packed
001076  aa   002000 3150 03	cana 	1024,du
001077  aa   000004 6000 04	tze  	4,ic		001103
001100  aa   000011 2360 07	ldq  	9,dl
001101  aa  6 00101 7561 00	stq  	pr6|65		alignment
001102  aa   000114 7100 04	tra  	76,ic		001216
						STATEMENT 1 ON LINE 508
      else
         do;

						STATEMENT 1 ON LINE 510
	  alignment = WORD_ALIGNED;

001103  aa   000044 2360 07	ldq  	36,dl
001104  aa  6 00101 7561 00	stq  	pr6|65		alignment
						STATEMENT 1 ON LINE 511
	  call pad_to_word_boundary ();

001105  aa   000121 6700 04	tsp4 	81,ic		001226
						STATEMENT 1 ON LINE 512
         end;

						STATEMENT 1 ON LINE 513
      goto END_CASE;

001106  aa   000110 7100 04	tra  	72,ic		001216
						STATEMENT 1 ON LINE 516
DATA_TYPE (44):
      bit_length = ONE_BYTE * floor ((precision_descriptor.precision + SIGN_EXPONENT_AND_PAD) / PER_BYTE_FACTOR);

001107  aa  5 00000 2361 00	ldq  	pr5|0		precision_descriptor.precision
001110  aa  0 00410 3771 00	anaq 	pr0|264		= 000000000000 000000007777
001111  aa   000004 0760 07	adq  	4,dl
001112  aa   000133 3520 04	epp2 	91,ic		001245 = 000000000002
001113  aa  0 01262 7001 00	tsx0 	pr0|690		divide_fx1
001114  aa     000000000065
001115  aa   000065 7220 07	lxl2 	53,dl
001116  aa   777626 7230 07	lxl3 	262038,dl
001117  aa  0 01122 7001 00	tsx0 	pr0|594		floor_fx2
001120  aa   000011 4020 07	mpy  	9,dl
001121  aa  6 00103 7561 00	stq  	pr6|67		bit_length
						STATEMENT 1 ON LINE 518
      if descriptor.packed
      then alignment = BYTE_ALIGNED;

001122  aa  5 00000 2351 00	lda  	pr5|0		descriptor.packed
001123  aa   002000 3150 03	cana 	1024,du
001124  aa   000004 6000 04	tze  	4,ic		001130
001125  aa   000011 2360 07	ldq  	9,dl
001126  aa  6 00101 7561 00	stq  	pr6|65		alignment
001127  aa   000067 7100 04	tra  	55,ic		001216
						STATEMENT 1 ON LINE 520
      else
         do;

						STATEMENT 1 ON LINE 522
	  alignment = WORD_ALIGNED;

001130  aa   000044 2360 07	ldq  	36,dl
001131  aa  6 00101 7561 00	stq  	pr6|65		alignment
						STATEMENT 1 ON LINE 523
	  call pad_to_word_boundary ();

001132  aa   000074 6700 04	tsp4 	60,ic		001226
						STATEMENT 1 ON LINE 524
         end;

						STATEMENT 1 ON LINE 525
      goto END_CASE;

001133  aa   000063 7100 04	tra  	51,ic		001216
						STATEMENT 1 ON LINE 528
DATA_TYPE (45):
      bit_length = DOUBLE * ONE_BYTE * floor ((precision_descriptor.precision + SIGN_AND_PAD) / PER_BYTE_FACTOR);

001134  aa  5 00000 2361 00	ldq  	pr5|0		precision_descriptor.precision
001135  aa  0 00410 3771 00	anaq 	pr0|264		= 000000000000 000000007777
001136  aa   000002 0760 07	adq  	2,dl
001137  aa   000106 3520 04	epp2 	70,ic		001245 = 000000000002
001140  aa  0 01262 7001 00	tsx0 	pr0|690		divide_fx1
001141  aa     000000000065
001142  aa   000065 7220 07	lxl2 	53,dl
001143  aa   777626 7230 07	lxl3 	262038,dl
001144  aa  0 01122 7001 00	tsx0 	pr0|594		floor_fx2
001145  aa  6 00115 7561 00	stq  	pr6|77
001146  aa   000022 2360 07	ldq  	18,dl
001147  aa  6 00115 4021 00	mpy  	pr6|77
001150  aa  6 00103 7561 00	stq  	pr6|67		bit_length
						STATEMENT 1 ON LINE 530
      if descriptor.packed
      then alignment = BYTE_ALIGNED;

001151  aa  5 00000 2351 00	lda  	pr5|0		descriptor.packed
001152  aa   002000 3150 03	cana 	1024,du
001153  aa   000004 6000 04	tze  	4,ic		001157
001154  aa   000011 2360 07	ldq  	9,dl
001155  aa  6 00101 7561 00	stq  	pr6|65		alignment
001156  aa   000040 7100 04	tra  	32,ic		001216
						STATEMENT 1 ON LINE 532
      else
         do;

						STATEMENT 1 ON LINE 534
	  alignment = WORD_ALIGNED;

001157  aa   000044 2360 07	ldq  	36,dl
001160  aa  6 00101 7561 00	stq  	pr6|65		alignment
						STATEMENT 1 ON LINE 535
	  call pad_to_word_boundary ();

001161  aa   000045 6700 04	tsp4 	37,ic		001226
						STATEMENT 1 ON LINE 536
         end;

						STATEMENT 1 ON LINE 537
      goto END_CASE;

001162  aa   000034 7100 04	tra  	28,ic		001216
						STATEMENT 1 ON LINE 540
DATA_TYPE (46):
      bit_length = DOUBLE * ONE_BYTE * floor ((precision_descriptor.precision + SIGN_EXPONENT_AND_PAD) / PER_BYTE_FACTOR);

001163  aa  5 00000 2361 00	ldq  	pr5|0		precision_descriptor.precision
001164  aa  0 00410 3771 00	anaq 	pr0|264		= 000000000000 000000007777
001165  aa   000004 0760 07	adq  	4,dl
001166  aa   000057 3520 04	epp2 	47,ic		001245 = 000000000002
001167  aa  0 01262 7001 00	tsx0 	pr0|690		divide_fx1
001170  aa     000000000065
001171  aa   000065 7220 07	lxl2 	53,dl
001172  aa   777626 7230 07	lxl3 	262038,dl
001173  aa  0 01122 7001 00	tsx0 	pr0|594		floor_fx2
001174  aa  6 00115 7561 00	stq  	pr6|77
001175  aa   000022 2360 07	ldq  	18,dl
001176  aa  6 00115 4021 00	mpy  	pr6|77
001177  aa  6 00103 7561 00	stq  	pr6|67		bit_length
						STATEMENT 1 ON LINE 542
      if descriptor.packed
      then alignment = BYTE_ALIGNED;

001200  aa  5 00000 2351 00	lda  	pr5|0		descriptor.packed
001201  aa   002000 3150 03	cana 	1024,du
001202  aa   000004 6000 04	tze  	4,ic		001206
001203  aa   000011 2360 07	ldq  	9,dl
001204  aa  6 00101 7561 00	stq  	pr6|65		alignment
001205  aa   000011 7100 04	tra  	9,ic		001216
						STATEMENT 1 ON LINE 544
      else
         do;

						STATEMENT 1 ON LINE 546
	  alignment = WORD_ALIGNED;

001206  aa   000044 2360 07	ldq  	36,dl
001207  aa  6 00101 7561 00	stq  	pr6|65		alignment
						STATEMENT 1 ON LINE 547
	  call pad_to_word_boundary ();

001210  aa   000016 6700 04	tsp4 	14,ic		001226
						STATEMENT 1 ON LINE 548
         end;

						STATEMENT 1 ON LINE 549
      goto END_CASE;

001211  aa   000005 7100 04	tra  	5,ic		001216
						STATEMENT 1 ON LINE 552
DATA_TYPE (0):
DATA_TYPE (24):
DATA_TYPE (25):
DATA_TYPE (26):
DATA_TYPE (27):
DATA_TYPE (28):
DATA_TYPE (31):
DATA_TYPE (32):
DATA_TYPE (37):
DATA_TYPE (40):
DATA_TYPE (47):
DATA_TYPE (48):
DATA_TYPE (49):
DATA_TYPE (50):
DATA_TYPE (51):
DATA_TYPE (52):
DATA_TYPE (53):
DATA_TYPE (54):
DATA_TYPE (55):
DATA_TYPE (56):
DATA_TYPE (57):
DATA_TYPE (58):
DATA_TYPE (59):
DATA_TYPE (60):
DATA_TYPE (61):
DATA_TYPE (62):
DATA_TYPE (63):
      p_code = dm_error_$unimplemented_data_type;

001212  aa  6 00044 3701 20	epp4 	pr6|36,*
001213  la  4 00010 2361 20	ldq  	pr4|8,*		dm_error_$unimplemented_data_type
001214  aa  6 00104 7561 20	stq  	pr6|68,*		p_code
						STATEMENT 1 ON LINE 580
      goto END_CASE;

001215  aa   000001 7100 04	tra  	1,ic		001216
						STATEMENT 1 ON LINE 583
END_CASE:
      p_bit_length = bit_length;

001216  aa  6 00103 2361 00	ldq  	pr6|67		bit_length
001217  aa  6 00032 3735 20	epp7 	pr6|26,*
001220  aa  7 00004 7561 20	stq  	pr7|4,*		p_bit_length
						STATEMENT 1 ON LINE 585
      if get_alignment
      then p_alignment = alignment;

001221  aa  6 00100 2351 00	lda  	pr6|64		get_alignment
001222  aa   000003 6000 04	tze  	3,ic		001225
001223  aa  6 00101 2361 00	ldq  	pr6|65		alignment
001224  aa  7 00006 7561 20	stq  	pr7|6,*		p_alignment
						STATEMENT 1 ON LINE 588
      return;

001225  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 604
   end dmu_get_data_bit_length;

BEGIN PROCEDURE pad_to_word_boundary
ENTRY TO pad_to_word_boundary                               STATEMENT 1 ON LINE 591
pad_to_word_boundary:
   procedure ();

001226  aa  6 00106 6501 00	spri4	pr6|70
						STATEMENT 1 ON LINE 597
      if mod (bit_length, ONE_WORD) = 0
      then ;

001227  aa  6 00103 2361 00	ldq  	pr6|67		bit_length
001230  aa   000014 3520 04	epp2 	12,ic		001244 = 000000000044
001231  aa  0 00704 7001 00	tsx0 	pr0|452		mod_fx1
001232  aa  6 00120 7561 00	stq  	pr6|80
001233  aa   000002 6010 04	tnz  	2,ic		001235
001234  aa   000007 7100 04	tra  	7,ic		001243
						STATEMENT 1 ON LINE 599
      else bit_length = bit_length + (ONE_WORD - mod (bit_length, ONE_WORD));

001235  aa  2 00000 2361 00	ldq  	pr2|0		ONE_WORD
001236  aa  6 00120 1761 00	sbq  	pr6|80
001237  aa   000044 7770 00	llr  	36
001240  aa   000044 7330 00	lrs  	36
001241  aa  6 00103 0331 00	adl  	pr6|67		bit_length
001242  aa  6 00103 7561 00	stq  	pr6|67		bit_length
						STATEMENT 1 ON LINE 601
   end;

001243  aa  6 00106 6101 00	rtcd 	pr6|70
  END PROCEDURE pad_to_word_boundary
  END PROCEDURE dmu_get_data_bit_length


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
