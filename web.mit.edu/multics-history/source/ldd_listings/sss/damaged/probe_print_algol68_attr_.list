THIS FILE IS DAMAGED

	COMPILATION LISTING OF SEGMENT probe_print_algol68_attr_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 11/11/88  1549.5 mst Fri
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(88-09-07,WAAnderson), approve(88-09-30,MCR7952),
       16*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
       17*     Added format control comment to make the source more readable.
       18*                                                   END HISTORY COMMENTS */
       19 
       20 
       21 /* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       22 
       23 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       24 
       25 probe_print_algol68_attr_:
       26   proc (P_probe_info_ptr, P_refp, P_long_sw, P_code);
       27 
       28   /* 17 August 1981 Melanie Weaver  this version is just a copy of
       29*   probe_print_pl1_attr_ with type names for new algol68 data types */
       30   /* probe_print_pl1_attr_ written by Jim Davis 25 May 79 */
       31 
       32   dcl P_probe_info_ptr	ptr parameter;
       33   dcl P_refp		ptr parameter;
       34   dcl P_long_sw		bit (1) aligned parameter;
       35   dcl P_code		fixed bin (35) parameter;
       36 
       37   dcl 1 P_reference		aligned like reference_node based (refp);
       38   dcl refp		ptr;
       39   dcl sym			ptr;	/* to symbol node */
       40   dcl sp			ptr;
       41   dcl next		ptr;
       42   dcl (addrel, bin, fixed, hbound, lbound, null, rtrim)
       43 			builtin;
       44   dcl (
       45       ioa_$ioa_switch,
       46       ioa_$rsnnl
       47       )			entry options (variable);
       48   dcl probe_block_name_	entry (ptr, ptr, bit (1) aligned)
       49 			returns (char (256) varying);
       50 
       51   probe_info_ptr = P_probe_info_ptr;
       52   P_code = 0;
       53   refp = P_refp;
       54   sym = P_reference.symbol_ptr;
       55 
       56   if sym = null () then do;
       57       if P_reference.type = ext_procedure_runtime_dtype
       58         then call ioa_$ioa_switch (probe_info.output_switch, "external entry")
       59 	        ;
       60         else call ioa_$ioa_switch (probe_info.output_switch,
       61 	        "unknown type (^d)", P_reference.type);
       62 
       63       /* sure wish there was a way to display attributes of external entries */
       64 
       65       return;
       66     end;				/* non-symbol case */
       67 
       68   call ioa_$ioa_switch (probe_info.output_switch, "^a ^a ^a ^a",
       69        get_pl1_attr_str (sym),
       70        get_pl1_class_str (sym),
       71        get_pl1_dims_str (sym, 0, "1"b),
       72        get_pl1_level_str (sym));
       73 
       74   if fixed (sym -> runtime_symbol.type, 6) = structure_dtype & P_long_sw
       75     then
       76       do sp = addrel (sym, sym -> runtime_symbol.son) /* for son */
       77 	 repeat next while (sp ^= null ());
       78       call print_member (sp, fixed (sym -> runtime_symbol.ndims, 6));
       79       if sp -> runtime_symbol.brother ^= (18)"0"b
       80         then next = addrel (sp, sp -> runtime_symbol.brother);
       81         else next = null ();
       82     end;
       83 
       84   call ioa_$ioa_switch (probe_info.output_switch, "Declared in ^a",
       85        probe_block_name_ (probe_info_ptr, P_reference.source_info_ptr, "0"b));
       86   return;
       87 
       88 print_member:
       89   proc (s, inheritance);
       90 
       91   dcl s			ptr parameter;
       92 				/* to a symbol node */
       93   dcl inheritance		fixed bin parameter;
       94   dcl q			ptr;	/* to son and sons' siblings */
       95   dcl nextq		ptr;
       96   dcl level		fixed bin;
       97 
       98   level = fixed (s -> runtime_symbol.level, 6);
       99 
      100   call ioa_$ioa_switch (probe_info.output_switch, "  ^vx^d ^A ^a ^a",
      101        (level - 2) * 2, level, addrel (s, s -> runtime_symbol.name),
      102        get_pl1_dims_str (s, inheritance, "0"b),
      103        get_pl1_attr_str (s));
      104 
      105   if s -> runtime_symbol.son ^= (18)"0"b
      106     then
      107       do q = addrel (s, s -> runtime_symbol.son) /* for our son, and for */
      108 	 repeat nextq /* all his brothers, until */
      109 	 while (q ^= null ());	/* curse PL/I, becasue it lacks do-until */
      110       call print_member (q, fixed (s -> runtime_symbol.ndims, 6));
      111       if q -> runtime_symbol.brother = (18)"0"b
      112         then nextq = null ();		/* have reached the end */
      113         else nextq = addrel (q, q -> runtime_symbol.brother);
      114     end;				/* son,sibling loop */
      115 
      116 
      117   end print_member;
      118 
      119 get_pl1_attr_str:
      120   proc (sym) returns (char (168) varying);
      121 
      122   dcl sym			ptr parameter;
      123 
      124   dcl attr		char (168) varying;
      125   dcl temp		char (64) varying;
      126   dcl type		fixed bin;
      127   dcl p			ptr;
      128 
      129   dcl ptr			builtin;
      130 
      131 
      132   type = fixed (sym -> runtime_symbol.type, 6);
      133   if ^legal_type (type)
      134     then return ("?");
      135 
      136   attr = "";
      137   temp = "";
      138 
      139   if data_type_info_$info (type).computational
      140     then if data_type_info_$info (type).arithmetic
      141 	 then do;
      142 	   attr = attr
      143 	        ||
      144 	        branch_on (data_type_info_$info (type).complex, " complex",
      145 	        "");
      146 	   attr = attr
      147 	        ||
      148 	        branch_on (data_type_info_$info (type).fixed, " fixed",
      149 	        " float");
      150 	   attr = attr
      151 	        ||
      152 	        branch_on (data_type_info_$info (type).decimal, " dec",
      153 	        " bin");
      154 
      155 	   if data_type_info_$info (type).arithmetic_attributes.fixed
      156 	     then if sym -> runtime_symbol.scale = "0"b
      157 		  then call ioa_$rsnnl (" (^d)", temp, (0),
      158 			  sym -> runtime_symbol.size);
      159 		  else call ioa_$rsnnl (" (^d,^d)", temp, (0),
      160 			  sym -> runtime_symbol.size,
      161 			  bit8_to_bin8 (sym -> runtime_symbol.scale));
      162 	     else call ioa_$rsnnl (" (^d)", temp, (0),
      163 		     sym -> runtime_symbol.size);
      164 				/* float, has no scale */
      165 	   attr = attr || rtrim (temp);
      166 
      167 	   attr = attr
      168 	        ||
      169 	        branch_on (data_type_info_$info (type)
      170 	        .arithmetic_attributes.signed, "", " unsigned");
      171 	 end;			/* arithmetic */
      172 	 else do;			/* string or picture */
      173 	   if data_type_info_$info (type).char_string
      174 	        | data_type_info_$info (type).bit_string
      175 	     then do;
      176 	       attr = attr
      177 		  ||
      178 		  branch_on (data_type_info_$info (type).varying,
      179 		  " varying", "");
      180 	       attr = attr
      181 		  ||
      182 		  branch_on (data_type_info_$info (type).char_string,
      183 		  " char", " bit");
      184 	       attr = attr || "(";
      185 	       attr = attr || value (sym -> runtime_symbol.size, sym);
      186 	       attr = attr || ")";
      187 	     end;			/* strings */
      188 	   else if type = picture_runtime_dtype
      189 	     then do;
      190 	       p = ptr (sym, sym -> runtime_symbol.size);
      191 				/* to picture_info_block */
      192 	       if p -> picture_image.type = picture_complexfix_type |
      193 		  p -> picture_image.type = picture_complexflo_type
      194 	         then attr = attr || " complex picture";
      195 	         else attr = attr || " picture";
      196 	       attr = attr || " """;	/* to begin picture with */
      197 	       attr = attr || p -> picture_image.chars;
      198 	       attr = attr || """";
      199 	     end;			/* picture */
      200 	   else attr = "?";		/* some random computational type */
      201 	 end;			/* non-arithmetic computational */
      202     else do;			/* non-computational */
      203       if type = pointer_dtype
      204         then attr = " pointer";
      205       else if type = offset_dtype
      206         then do;
      207 	attr = " offset";
      208 	if sym -> runtime_symbol.size ^= 0
      209 	  then do;
      210 	    attr = attr || "(";
      211 	    attr = attr
      212 	         || symbol_name (addrel (sym, sym -> runtime_symbol.size));
      213 	    attr = attr || ")";
      214 	  end;			/* getting default area */
      215         end;			/* offset */
      216       else if type = label_dtype
      217         then attr = " label variable";
      218       else if type = entry_dtype
      219         then attr = " entry variable";
      220       else if type = structure_dtype
      221         then attr = " structure";
      222       else if type = area_dtype
      223         then do;
      224 	attr = " area (";
      225 	attr = attr || value (sym -> runtime_symbol.size, sym);
      226 	attr = attr || ")";
      227         end;
      228       else if type = file_dtype
      229         then attr = " file";
      230       else if type = label_constant_runtime_dtype
      231         then attr = " label";
      232       else if type = int_entry_runtime_dtype
      233         then attr = " internal entry";
      234       else if type = ext_entry_runtime_dtype
      235         then attr = " external entry";
      236       else if type = ext_procedure_runtime_dtype
      237         then attr = " external procedure";
      238       else if type = algol68_straight_dtype
      239         then attr = " algol68 straight";
      240       else if type = algol68_format_dtype
      241         then attr = " algol68 format";
      242       else if type = algol68_array_descriptor_dtype
      243         then attr = " algol68 array descriptor";
      244       else if type = algol68_union_dtype
      245         then attr = " algol68 union";
      246       else attr = "?";
      247     end;				/* non-computational */
      248 
      249   attr = attr || branch_on (sym -> runtime_symbol.bits.packed, " unal", "");
      250   return (attr);
      251 
      252 branch_on:
      253   proc (t_or_f, true_str, false_str) returns (char (*));
      254   dcl t_or_f		bit (1) unal parameter;
      255   dcl true_str		char (*) parameter;
      256   dcl false_str		char (*) parameter;
      257 
      258   if t_or_f
      259     then return (true_str);
      260     else return (false_str);
      261   end branch_on;
      262   end get_pl1_attr_str;
      263 
      264 get_pl1_dims_str:
      265   proc (P_sym, P_inherited, P_verbose) returns (char (168) varying);
      266 
      267   dcl P_sym		ptr parameter;
      268   dcl P_inherited		fixed bin parameter;
      269   dcl P_verbose		bit (1) aligned parameter;
      270 
      271   dcl n			fixed bin;
      272   dcl i			fixed bin;
      273   dcl dims_str		char (168) varying;
      274 
      275   n = fixed (P_sym -> runtime_symbol.ndims, 6);
      276   if n <= P_inherited
      277     then dims_str = "";
      278     else do;
      279       if P_verbose
      280         then dims_str = " dimension (";
      281         else dims_str = " (";
      282       do i = P_inherited + 1 to n;
      283         if P_sym -> runtime_symbol.bounds (i).lower ^= 1
      284 	then do;
      285 	  dims_str =
      286 	       dims_str
      287 	       || value (P_sym -> runtime_symbol.bounds (i).lower, P_sym);
      288 	  dims_str = dims_str || ":";
      289 	end;
      290         dims_str =
      291 	   dims_str
      292 	   || value (P_sym -> runtime_symbol.bounds (i).upper, P_sym);
      293         if i < n			/* more to come */
      294 	then dims_str = dims_str || ",";
      295       end;			/* dims loop */
      296       dims_str = dims_str || ")";
      297     end;
      298 
      299   return (dims_str);
      300   end get_pl1_dims_str;
      301 
      302 get_pl1_level_str:
      303   proc (symb) returns (char (168) varying);
      304   dcl symb		ptr parameter;
      305 
      306   dcl l			fixed bin;/* level */
      307   dcl level_str		char (168) varying;
      308 
      309   l = fixed (symb -> runtime_symbol.level, 6);
      310   if l < 1
      311     then return ("");
      312   else if l = 1
      313     then return (" level 1");
      314   else do;
      315     call ioa_$rsnnl (" level ^d in ^a", level_str, (0), l,
      316          king_of_structure ());
      317     return (level_str);
      318   end;
      319 
      320 king_of_structure:
      321   proc () returns (char (64));
      322   dcl i			fixed bin;
      323   dcl p			ptr;
      324   p = symb;
      325   do i = l - 1 to 1 by -1;
      326     p = addrel (p, p -> runtime_symbol.father);
      327   end;
      328   return (addrel (p, p -> runtime_symbol.name) -> acc.string);
      329   end king_of_structure;
      330 
      331   end get_pl1_level_str;
      332 
      333 get_pl1_class_str:
      334   proc (symb) returns (char (168) varying);
      335   dcl symb		ptr parameter;
      336   dcl based_class		internal static fixed bin
      337 			options (constant) init (3);
      338   dcl c			fixed bin;/* the class */
      339   dcl class_str		char (168) varying;
      340 
      341   dcl class_name		(15) char (20) internal static
      342 			options (constant) init (
      343 			"automatic", "automatic", "based",
      344 			"internal static",
      345 			"external static", "internal controlled",
      346 			"external controlled", "parameter",
      347 			"parameter", "?", "?", "constant", "constant",
      348 			"?", "?");
      349 
      350   c = fixed (symb -> runtime_symbol.class, 4);
      351   class_str = class_name (c);
      352 
      353   if c = based_class
      354     then if symb -> runtime_symbol.location
      355 	    ^= (18)"0"b /* got implicit qualifier */
      356 	 then do;
      357 	   class_str = class_str || " (";
      358 	   class_str =
      359 	        class_str
      360 	        ||
      361 	        symbol_name (addrel (symb, symb -> runtime_symbol.location))
      362 	        ;
      363 	   class_str = class_str || ")";
      364 	 end;			/* getting implicit locator */
      365 
      366   return (class_str);
      367   end get_pl1_class_str;
      368 
      369 
      370   /* VARIOUS HANDY LITTLE PROCS */
      371 
      372 symbol_name:
      373   proc (sp) returns (char (256) varying);
      374 
      375   dcl sp			ptr parameter;
      376 				/* to the symbol node */
      377   dcl name		char (256) varying;
      378 				/* its fully qualified name */
      379   dcl p			ptr;
      380 
      381   p = sp;
      382   name = addrel (p, p -> runtime_symbol.name) -> acc.string;
      383 				/* our name */
      384   do while (fixed (p -> runtime_symbol.level, 6) > 1);
      385 				/* invariant: we have a father */
      386     p = addrel (p, p -> runtime_symbol.father);
      387 				/* point to father */
      388     name = addrel (p, p -> runtime_symbol.name) -> acc.string || "." || name;
      389 				/* copy name */
      390   end;
      391   return (name);
      392   end symbol_name;
      393 
      394 
      395 
      396 legal_type:
      397   proc (stype) returns (bit (1) aligned);
      398   dcl stype		fixed bin parameter;
      399   return (stype >= lbound (data_type_info_$info, 1) &
      400        stype <= hbound (data_type_info_$info, 1));
      401   end legal_type;
      402 
      403 
      404 bit8_to_bin8:
      405   proc (b) returns (fixed bin (8));
      406   dcl b			bit (8) parameter;
      407   if bin (b, 8) <= 127
      408     then return (bin (b, 8));
      409     else return (bin (b, 8) - 256);
      410   end bit8_to_bin8;
      411 
      412 
      413 value:
      414   procedure (ev, context) returns (character (10) varying);
      415 
      416   dcl ev			fixed bin (35) parameter;
      417 				/* input: an encoded value */
      418   dcl context		ptr parameter;
      419 				/* input: to symbol node of ev */
      420 
      421   dcl val			fixed bin (35);
      422   dcl 1 an_ev		aligned like encoded_value;
      423   dcl refp		ptr;	/* to data itself, for decoding */
      424   dcl block_ptr		ptr;
      425   dcl stack_ptr		ptr;
      426   dcl linkage_ptr		ptr;
      427   dcl based_class		bit (4) internal static options (constant)
      428 			init ("0011"b);
      429   dcl code		fixed bin (35);
      430   dcl (char, ltrim, null, rtrim, string, unspec)
      431 			builtin;
      432 
      433   dcl stu_$get_implicit_qualifier
      434 			entry (ptr, ptr, ptr, ptr, ptr) returns (ptr);
      435   dcl stu_$decode_runtime_value
      436 			entry (fixed bin (35), ptr, ptr, ptr, ptr, ptr,
      437 			fixed bin (35)) returns (fixed bin (35));
      438 
      439   /* GLOBAL imports P_reference */
      440 
      441   string (an_ev) = unspec (ev);
      442   if an_ev.flag = "10"b
      443     then do;			/* it is encoded */
      444       stack_ptr = P_reference.source_info_ptr -> source_info.stack_ptr;
      445       linkage_ptr =
      446 	 P_reference.source_info_ptr -> source_info.seg_info_ptr
      447 	 -> seg_info.linkage_ptr;
      448       block_ptr = P_reference.source_info_ptr -> source_info.block_ptr;
      449       refp = P_reference.address_ptr;
      450       if refp = null
      451         then if context -> runtime_symbol.class = based_class
      452 				/* can try for implicit */
      453 	     then refp =
      454 		     stu_$get_implicit_qualifier (block_ptr, context,
      455 		     stack_ptr, linkage_ptr, block_ptr);
      456       val = stu_$decode_runtime_value (ev, block_ptr, stack_ptr, linkage_ptr,
      457 	 block_ptr, refp, code);
      458       if code ^= 0
      459         then return ("*");
      460     end;
      461     else val = ev;
      462 
      463   return (rtrim (ltrim (char (val))));
      464 
      465   end value;
      466 
  1     1 /*	BEGIN INCLUDE FILE probe_info.incl.pl1		*/
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(88-10-24,WAAnderson), approve(88-10-24,MCR7952),
  1     7*     audit(88-10-24,RWaters), install(88-10-27,MR12.2-1194):
  1     8*     Added field 'retry_using_main' to add new C feature.
  1     9*                                                   END HISTORY COMMENTS */
  1    10 
  1    11 
  1    12 /* Created: 04/22/79 W. Olin Sibert, from subsystem_info	
  1    13*   Modified: 22 Sept 79 JRd to remove: 	default (ptr & (auto|based)) init (null ());
  1    14*   Added flags.setting_break 08/22/83 Steve Herbst
  1    15*   Added flags.executing_quit_request 01/15/85 Steve Herbst
  1    16**/
  1    17 
  1    18 dcl 1 probe_info aligned based (probe_info_ptr),		/* standard data for a probe invocation */
  1    19     2 probe_info_version fixed bin,			/* version of this structure */
  1    20 
  1    21     2 static_info_ptr pointer unaligned,		/* pointer to static information structure */
  1    22     2 modes_ptr pointer unaligned,			/* pointer to probe_modes structure */
  1    23 
  1    24     2 ptr_to_current_source ptr,			/* current_source is based on this */
  1    25     2 ptr_to_initial_source ptr,			/* initial_source is based on this */
  1    26     2 machine_cond_ptr pointer,			/* pointer to machine conditions, if we faulted to get here */
  1    27 
  1    28     2 token_info aligned,				/* information about token chain currently being processed */
  1    29       3 first_token pointer unaligned,			/* first token in chain */
  1    30       3 ct pointer unaligned, 			/* pointer to current token; updated in MANY places */
  1    31       3 end_token bit (18) aligned,			/* token type at which to stop scanning token chain */
  1    32       3 buffer_ptr pointer unaligned,			/* pointer to input buffer */
  1    33       3 buffer_lth fixed bin (21),			/* and length */
  1    34 
  1    35     2 random_info aligned,
  1    36       3 current_stack_frame pointer unaligned,		/* stack frame pointer for frame in which probe was invoked */
  1    37       3 input_type fixed bin, 			/* current input type */
  1    38       3 language_type fixed bin,			/* current language being processed */
  1    39       3 return_method fixed bin,			/* how we should return after exiting probe */
  1    40       3 entry_method fixed bin,			/* how we got here in the first place */
  1    41       3 pad1 (19) bit (36) aligned,
  1    42 
  1    43     2 break_info,					/* break info -- only interesting if we got here via a break */
  1    44       3 break_slot_ptr pointer,			/* pointer to break slot -- non-null IFF at a break */
  1    45       3 last_break_slot_ptr pointer unaligned,		/* pointer to previous break slot, not presently used */
  1    46       3 break_reset bit (1) aligned,			/* this break has been reset by somebody further on */
  1    47       3 real_break_return_loc pointer,			/* where to REALLY return to, modulo previous bit */
  1    48 
  1    49     2 probe_area_info,				/* information about various probe areas */
  1    50       3 break_segment_ptr pointer unaligned,		/* pointer to Personid.probe */
  1    51       3 break_area_ptr pointer unaligned,		/* pointer to area in break segment */
  1    52       3 scratch_area_ptr pointer unaligned,		/* pointer to probe scratch seg in process dir */
  1    53       3 probe_area_ptr pointer unaligned,		/* This area lasts as long as an invocation of probe. */
  1    54       3 work_area_ptr pointer unaligned,		/* This area lasts as long as the current request line */
  1    55       3 expression_area_ptr pointer unaligned,		/* This area lasts as long as the current command */
  1    56 
  1    57     2 flags aligned,				/* this, in particular, should be saved and restored correctly */
  1    58      (3 execute,					/* "1"b => execute requests, "0"b => just check syntax */
  1    59       3 in_listener,				/* ON => in probe listener loop */
  1    60       3 executing_request,				/* ON => executing a request */
  1    61       3 in_interpret_line,				/* executing in probe_listen_$interpret_line */
  1    62       3 setting_break,				/* executing "after" or "before": check syntax of "if" */
  1    63       3 executing_quit_request,			/* to prevent error looping during "quit" request */
  1    64       3 pad (30)) bit (1) unaligned,
  1    65 
  1    66     2 io_switches,					/* switches probe will do normal I/O on */
  1    67       3 input_switch pointer,
  1    68       3 output_switch pointer,
  1    69 
  1    70     2 error_info,					/* information about the last error saved for later printing */
  1    71       3 error_code fixed bin (35),
  1    72       3 error_message char (300) varying,
  1    73 
  1    74     2 listener_info,				/* internal use by probe listener */
  1    75       3 request_name character (32) varying,		/* primary name of the request being processed */
  1    76       3 abort_probe_label label variable,
  1    77       3 abort_line_label label variable,
  1    78       3 depth fixed binary,				/* count of active invocations of probe */
  1    79       3 previous pointer unaligned,			/* -> previous invocation's info */
  1    80       3 next pointer unaligned,
  1    81 
  1    82     2 end_of_probe_info pointer aligned,
  1    83     2 retry_using_main fixed bin aligned;
  1    84    
  1    85 
  1    86 dcl  probe_info_ptr pointer;
  1    87 
  1    88 dcl  probe_info_version fixed bin static options (constant) initial (1);
  1    89 
  1    90 dcl  probe_info_version_1 fixed bin static options (constant) initial (1);
  1    91 
  1    92 dcl  scratch_area area based (probe_info.scratch_area_ptr);
  1    93 dcl  probe_area area based (probe_info.probe_area_ptr);
  1    94 dcl  work_area area based (probe_info.work_area_ptr);
  1    95 dcl  expression_area area based (probe_info.expression_area_ptr);
  1    96 
  1    97 /*	END INCLUDE FILE probe_info.incl.pl1		*/
      467 
  2     1 /* BEGIN INCLUDE FILE ... probe_source_info.incl.pl1
  2     2*
  2     3*  James R. Davis 2 July 79 */
  2     4 
  2     5 dcl 1 source_info based aligned,
  2     6       2 stmnt_map_entry_index fixed bin,		/* index in stmnt map for this stmnt */
  2     7       2 instruction_ptr ptr,				/* to last instruction executed  */
  2     8       2 block_ptr ptr,				/* to runtime_block node */
  2     9       2 stack_ptr ptr,				/* to a stack frame */
  2    10       2 entry_ptr ptr,				/* to entry seq. for this proc */
  2    11       2 seg_info_ptr ptr;				/* to seg_info */
  2    12 
  2    13 dcl 1 current_source aligned like source_info based (probe_info.ptr_to_current_source);
  2    14 dcl 1 initial_source aligned like source_info based (probe_info.ptr_to_initial_source);
  2    15 
  2    16 /* END INCLUDE FILE ... probe_source_info.incl.pl1 */
      468 
  3     1 /* BEGIN INCLUDE FILE ... probe_seg_info.incl.pl1
  3     2*
  3     3*   25 June 79 JRDavis
  3     4*
  3     5*   Modified  7 April 1983, TO - Add fields for character offset/line
  3     6*	correction per file.
  3     7**/
  3     8 
  3     9 dcl 1 seg_info based aligned,				/* place to remember information about object seg */
  3    10     2 language_type fixed bin,			/* language of source program */
  3    11     2 bits aligned,
  3    12       3 ignore_case bit (1) unal,
  3    13       3 bound_segment bit (1) unaligned,
  3    14       3 component bit (1) unaligned,
  3    15       3 pad bit (33) unal,
  3    16     2 names,					/* where to find it */
  3    17       3 directory_name character (168) unal,		/* what directory */
  3    18       3 entry_name character (32) unal,			/* what segment */
  3    19       3 segname character (32) unal,			/* procedure segname definition */
  3    20     2 identifier fixed bin (71),			/* time of object creation */
  3    21     2 pointers,					/* location of various parts of segment */
  3    22       3 symbol_header_ptr ptr unal,			/* to symbol section */
  3    23       3 original_source_ptr ptr unal,			/* to segment source map */
  3    24       3 statement_map_ptr ptr unal,			/* to segment statement map */
  3    25       3 break_info ptr unal,				/* for unbound segments, and start of chain for
  3    26*						   bound ones, -> break_map !obsolete, I think! */
  3    27       3 chain ptr unal,				/* to entry for next component if bound */
  3    28       3 linkage_ptr ptr unal,				/* to linkage section */
  3    29     2 bounds aligned,				/* structure of bounds information */
  3    30       3 text_bounds,
  3    31         4 start fixed bin (35),
  3    32         4 end fixed bin (35),
  3    33       3 symbol_bounds,
  3    34         4 start fixed bin (35),
  3    35         4 end fixed bin (35),
  3    36     2 map_size fixed bin,				/* size of statement map */
  3    37     2 error_code fixed bin (35),			/* errors encoutered while getting info, are recorded here */
  3    38     2 bound_create_time fixed bin (71),			/* time seg containing was bound or compiled. */
  3    39     2 bound_sym_header ptr unal,			/* to sym. section header for bound seg */
  3    40     2 pad (1) fixed bin (35),
  3    41 
  3    42     2 nfiles fixed bin,
  3    43     2 per_file (seg_info_nfiles refer (seg_info.nfiles)),
  3    44       3 file_pointers ptr unal,
  3    45       3 break_line (0:3) fixed bin (18) unsigned unaligned;
  3    46 
  3    47 dcl  seg_info_nfiles fixed bin;			/* for allocation purposes */
  3    48 
  3    49 
  3    50 /* END INCLUDE FILE ... probe_seg_info.incl.pl1 */
      469 
  4     1 /*	BEGIN INCLUDE FILE probe_references.incl.pl1	*/
  4     2 
  4     3 /****^  HISTORY COMMENTS:
  4     4*  1) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  4     5*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  4     6*     Added new field (c_symbol) for C-Probe support.
  4     7*  2) change(88-10-28,WAAnderson), approve(88-10-28,MCR7952),
  4     8*     audit(88-10-31,RWaters), install(88-11-11,MR12.2-1210):
  4     9*     Added new field (c_sub_c_ptr) for C-Probe_support.
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 /*	Split out of probe_tokens, 04/22/79 WOS 	*/
  4    13 /*       modified for probe variables Feb 19 80 JRD         */
  4    14 /*   Modified June 83 JMAthane to add "type_ptr" and "builtin" fields */
  4    15 
  4    16      dcl	   1 reference_node	      aligned based,	/* information about a reference */
  4    17 	     2 symbol_ptr	      pointer aligned,	/* to symbol table entry for reference */
  4    18 	     2 type_ptr	      pointer aligned,	/* to symbol table entry for type (null if none) */
  4    19 	     2 address_ptr	      pointer aligned,	/* to location of variable */
  4    20 	     2 base_addr	      pointer aligned,	/* pointer on which whole symbol is based */
  4    21 	     2 source_info_ptr    pointer aligned,	/* to symbol structure for reference */
  4    22 
  4    23 	     2 name	      char (256) unaligned varying, /* symbol name */
  4    24 
  4    25 	     2 type	      fixed bin (35),	/* data type */
  4    26 	     2 descriptor	      fixed bin (35),	/* type || packed */
  4    27 	     2 precision	      fixed bin (35),	/* scale and precision */
  4    28 	     2 flags,
  4    29 	       3 packed	      bit (1) unal,		/* data is in packed format */
  4    30 	       3 constant	      bit (1) unal,		/* data is really a constant */
  4    31 	       3 cross_section    bit (1) unal,		/* reference is an array cross-section */
  4    32 	       3 function	      bit (1) unal,		/* reference is function value */
  4    33 	       3 octal	      bit (1) unal,		/* indicates that this is the octal bif */
  4    34 	       3 star_extent      bit (1) unal,		/* reference is a star subscript for father */
  4    35 	       3 have_generation  bit (1) unal,		/* this reference has an explicitly specified generation */
  4    36 	       3 pseudo_var	      bit (1) unal,		/* it is ok to assign to it */
  4    37 	       3 probe_variable   bit (1) unal,
  4    38 	       3 path	      bit (1) unal,		/* it's a pathname/virtual entry */
  4    39 	       3 builtin	      bit (1) unal,		/* probe builtinvalue */
  4    40 	       3 c_ptr_to_char    bit (1)  unal,
  4    41                  3 c_sub_c_ptr      bit (1)  unal,
  4    42 	       3 pad2	      bit (23) unal,
  4    43 
  4    44 	     2 optional_info,			/* information which may or may not be present */
  4    45 	       3 argument_list    pointer unaligned,	/* pointer to reference_arg_list */
  4    46 	       3 subscript_ptr    pointer unaligned,	/* pointer to reference_subscripts */
  4    47 	       3 n_arguments      fixed bin,		/* number of arguments in argument list */
  4    48 	       3 n_subscripts     fixed bin,		/* number of subscripts present */
  4    49 
  4    50 	     2 constant_token_ptr pointer unaligned,	/* pointer to constant token if this is a constant */
  4    51 	     2 subscript_refs_ptr pointer unaligned,	/* pointer to array of subscript reference node pointers */
  4    52 	     2 invocation_level   fixed bin,		/* invocation level number ("[-17]") for this reference */
  4    53 	     2 probe_var_info_ptr ptr unal,		/* only if flags.probe_variable */
  4    54                2 c_symbol_ptr  ptr unal,
  4    55 	     2 pad1	      (9) pointer unaligned,
  4    56 	     2 end_of_reference_node pointer aligned;
  4    57 
  4    58 
  4    59      dcl	   1 reference_arg_list   aligned based,	/* argument list; based on reference.argument_list */
  4    60 	     2 number	      fixed bin,		/* number of arguments actually present */
  4    61 	     2 node	      (16) pointer aligned;	/* reference node pointers for each argument */
  4    62 
  4    63 
  4    64      dcl	   1 reference_subscripts aligned based,	/* subscript array; based on reference.subscript_ptr */
  4    65 	     2 number	      fixed bin,		/* number actually present */
  4    66 	     2 value	      (2, 16) fixed bin (24); /* values for lower and upper bound for each */
  4    67 
  4    68 
  4    69      dcl	   1 subscript_reference_ptrs aligned based,	/* array of pointers to subscript reference nodes */
  4    70 	     2 ptr	      (2, 16) pointer aligned;
  4    71 
  4    72 /*	END INCLUDE FILE probe_references.incl.pl1	*/
      470 
  5     1 /* BEGIN INCLUDE FILE ... std_descriptor_types.incl.pl1 */
  5     2 
  5     3 
  5     4 /****^  HISTORY COMMENTS:
  5     5*  1) change(86-09-05,JMAthane), approve(86-09-05,MCR7525),
  5     6*     audit(86-09-11,Martinson), install(86-11-12,MR12.0-1208):
  5     7*     Added pascal_string_type_dtype descriptor type.  Its number is 87.
  5     8*     Objects of this type are PASCAL string types.
  5     9*  2) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  5    10*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  5    11*     Added the new C types.
  5    12*                                                   END HISTORY COMMENTS */
  5    13 
  5    14 /* This include file defines mnemonic names for the Multics
  5    15*   standard descriptor types, using both pl1 and cobol terminology.
  5    16*   PG 780613
  5    17*   JRD 790530
  5    18*   JRD 791016
  5    19*   MBW 810731
  5    20*   TGO 830614 Add hex types.
  5    21*   Modified June 83 JMAthane to add PASCAL data types
  5    22*   TGO 840120 Add float dec extended and generic, float binary generic
  5    23**/
  5    24 
  5    25      dcl	   (real_fix_bin_1_dtype  init (1),
  5    26 	   real_fix_bin_2_dtype   init (2),
  5    27 	   real_flt_bin_1_dtype   init (3),
  5    28 	   real_flt_bin_2_dtype   init (4),
  5    29 	   cplx_fix_bin_1_dtype   init (5),
  5    30 	   cplx_fix_bin_2_dtype   init (6),
  5    31 	   cplx_flt_bin_1_dtype   init (7),
  5    32 	   cplx_flt_bin_2_dtype   init (8),
  5    33 	   real_fix_dec_9bit_ls_dtype init (9),
  5    34 	   real_flt_dec_9bit_dtype init (10),
  5    35 	   cplx_fix_dec_9bit_ls_dtype init (11),
  5    36 	   cplx_flt_dec_9bit_dtype init (12),
  5    37 	   pointer_dtype	      init (13),
  5    38 	   offset_dtype	      init (14),
  5    39 	   label_dtype	      init (15),
  5    40 	   entry_dtype	      init (16),
  5    41 	   structure_dtype	      init (17),
  5    42 	   area_dtype	      init (18),
  5    43 	   bit_dtype	      init (19),
  5    44 	   varying_bit_dtype      init (20),
  5    45 	   char_dtype	      init (21),
  5    46 	   varying_char_dtype     init (22),
  5    47 	   file_dtype	      init (23),
  5    48 	   real_fix_dec_9bit_ls_overp_dtype init (29),
  5    49 	   real_fix_dec_9bit_ts_overp_dtype init (30),
  5    50 	   real_fix_bin_1_uns_dtype init (33),
  5    51 	   real_fix_bin_2_uns_dtype init (34),
  5    52 	   real_fix_dec_9bit_uns_dtype init (35),
  5    53 	   real_fix_dec_9bit_ts_dtype init (36),
  5    54 	   real_fix_dec_4bit_uns_dtype init (38),	/* digit-aligned */
  5    55 	   real_fix_dec_4bit_ts_dtype init (39),	/* byte-aligned */
  5    56 	   real_fix_dec_4bit_bytealigned_uns_dtype init (40), /* COBOL */
  5    57 	   real_fix_dec_4bit_ls_dtype init (41),	/* digit-aligned */
  5    58 	   real_flt_dec_4bit_dtype init (42),		/* digit-aligned */
  5    59 	   real_fix_dec_4bit_bytealigned_ls_dtype init (43),
  5    60 	   real_flt_dec_4bit_bytealigned_dtype init (44),
  5    61 	   cplx_fix_dec_4bit_bytealigned_ls_dtype init (45),
  5    62 	   cplx_flt_dec_4bit_bytealigned_dtype init (46),
  5    63 	   real_flt_hex_1_dtype   init (47),
  5    64 	   real_flt_hex_2_dtype   init (48),
  5    65 	   cplx_flt_hex_1_dtype   init (49),
  5    66 	   cplx_flt_hex_2_dtype   init (50),
  5    67 	   c_typeref_dtype        init (54),
  5    68 	   c_enum_dtype           init (55),
  5    69              c_enum_const_dtype     init (56),
  5    70 	   c_union_dtype          init (57),
  5    71 	   algol68_straight_dtype init (59),
  5    72 	   algol68_format_dtype   init (60),
  5    73 	   algol68_array_descriptor_dtype init (61),
  5    74 	   algol68_union_dtype    init (62),
  5    75 
  5    76 	   cobol_comp_6_dtype     init (1),
  5    77 	   cobol_comp_7_dtype     init (1),
  5    78 	   cobol_display_ls_dtype init (9),
  5    79 	   cobol_structure_dtype  init (17),
  5    80 	   cobol_char_string_dtype init (21),
  5    81 	   cobol_display_ls_overp_dtype init (29),
  5    82 	   cobol_display_ts_overp_dtype init (30),
  5    83 	   cobol_display_uns_dtype init (35),
  5    84 	   cobol_display_ts_dtype init (36),
  5    85 	   cobol_comp_8_uns_dtype init (38),		/* digit aligned */
  5    86 	   cobol_comp_5_ts_dtype  init (39),		/* byte aligned */
  5    87 	   cobol_comp_5_uns_dtype init (40),
  5    88 	   cobol_comp_8_ls_dtype  init (41),		/* digit aligned */
  5    89 	   real_flt_dec_extended_dtype init (81),	/* 9-bit exponent */
  5    90 	   cplx_flt_dec_extended_dtype init (82),	/* 9-bit exponent */
  5    91 	   real_flt_dec_generic_dtype init (83),	/* generic float decimal */
  5    92 	   cplx_flt_dec_generic_dtype init (84),
  5    93 	   real_flt_bin_generic_dtype init (85),	/* generic float binary */
  5    94 	   cplx_flt_bin_generic_dtype init (86)) fixed bin internal static options (constant);
  5    95 
  5    96      dcl	   (ft_integer_dtype      init (1),
  5    97 	   ft_real_dtype	      init (3),
  5    98 	   ft_double_dtype	      init (4),
  5    99 	   ft_complex_dtype	      init (7),
  5   100 	   ft_complex_double_dtype init (8),
  5   101 	   ft_external_dtype      init (16),
  5   102 	   ft_logical_dtype	      init (19),
  5   103 	   ft_char_dtype	      init (21),
  5   104 	   ft_hex_real_dtype      init (47),
  5   105 	   ft_hex_double_dtype    init (48),
  5   106 	   ft_hex_complex_dtype   init (49),
  5   107 	   ft_hex_complex_double_dtype init (50)
  5   108 	   )		      fixed bin internal static options (constant);
  5   109 
  5   110      dcl	   (algol68_short_int_dtype init (1),
  5   111 	   algol68_int_dtype      init (1),
  5   112 	   algol68_long_int_dtype init (2),
  5   113 	   algol68_real_dtype     init (3),
  5   114 	   algol68_long_real_dtype init (4),
  5   115 	   algol68_compl_dtype    init (7),
  5   116 	   algol68_long_compl_dtype init (8),
  5   117 	   algol68_bits_dtype     init (19),
  5   118 	   algol68_bool_dtype     init (19),
  5   119 	   algol68_char_dtype     init (21),
  5   120 	   algol68_byte_dtype     init (21),
  5   121 	   algol68_struct_struct_char_dtype init (22),
  5   122 	   algol68_struct_struct_bool_dtype init (20)
  5   123 	   )		      fixed bin internal static options (constant);
  5   124 
  5   125      dcl	   (label_constant_runtime_dtype init (24),
  5   126 	   int_entry_runtime_dtype init (25),
  5   127 	   ext_entry_runtime_dtype init (26),
  5   128 	   ext_procedure_runtime_dtype init (27),
  5   129 	   picture_runtime_dtype  init (63)
  5   130 	   )		      fixed bin internal static options (constant);
  5   131 
  5   132      dcl	   (pascal_integer_dtype  init (1),
  5   133 	   pascal_real_dtype      init (4),
  5   134 	   pascal_label_dtype     init (24),
  5   135 	   pascal_internal_procedure_dtype init (25),
  5   136 	   pascal_exportable_procedure_dtype init (26),
  5   137 	   pascal_imported_procedure_dtype init (27),
  5   138 	   pascal_typed_pointer_type_dtype init (64),
  5   139 	   pascal_char_dtype      init (65),
  5   140 	   pascal_boolean_dtype   init (66),
  5   141 	   pascal_record_file_type_dtype init (67),
  5   142 	   pascal_record_type_dtype init (68),
  5   143 	   pascal_set_dtype	      init (69),
  5   144 	   pascal_enumerated_type_dtype init (70),
  5   145 	   pascal_enumerated_type_element_dtype init (71),
  5   146 	   pascal_enumerated_type_instance_dtype init (72),
  5   147 	   pascal_user_defined_type_dtype init (73),
  5   148 	   pascal_user_defined_type_instance_dtype init (74),
  5   149 	   pascal_text_file_dtype init (75),
  5   150 	   pascal_procedure_type_dtype init (76),
  5   151 	   pascal_variable_formal_parameter_dtype init (77),
  5   152 	   pascal_value_formal_parameter_dtype init (78),
  5   153 	   pascal_entry_formal_parameter_dtype init (79),
  5   154 	   pascal_parameter_procedure_dtype init (80),
  5   155 	   pascal_string_type_dtype init (87)) fixed bin int static options (constant);
  5   156 
  5   157 
  5   158 /* END INCLUDE FILE ... std_descriptor_types.incl.pl1 */
      471 
  6     1 /*	BEGIN INCLUDE FILE ... runtime_symbol.incl.pl1 ... Modified 07/79 */
  6     2 
  6     3 dcl	1 runtime_symbol	aligned based,
  6     4 	2 flag		unal bit(1),	/* always "1"b for Version II */
  6     5 	2 use_digit	unal bit(1),	/* if "1"b and units are half words units are really digits */
  6     6 	2 array_units	unal bit(2),
  6     7 	2 units		unal bit(2),	/* addressing units */
  6     8 	2 type		unal bit(6),	/* data type */
  6     9 	2 level		unal bit(6),	/* structure level */
  6    10 	2 ndims		unal bit(6),	/* number of dimensions */
  6    11 	2 bits		unal,
  6    12 	  3 aligned	bit(1),
  6    13 	  3 packed	bit(1),
  6    14 	  3 simple	bit(1),
  6    15 	2 skip		unal bit(1),
  6    16 	2 scale		unal bit(8),	/* arithmetic scale factor */
  6    17 	2 name		unal bit(18),	/* rel ptr to acc name */
  6    18 	2 brother		unal bit(18),	/* rel ptr to brother entry */
  6    19 	2 father		unal bit(18),	/* rel ptr to father entry */
  6    20 	2 son		unal bit(18),	/* rel ptr to son entry */
  6    21 	2 address		unal,
  6    22 	  3 location	bit(18),		/* location in storage class */
  6    23 	  3 class		bit(4),		/* storage class */
  6    24 	  3 next		bit(14),		/* rel ptr to next of same class */
  6    25 	2 size		fixed bin(35),	/* encoded string|arith size */
  6    26 	2 offset		fixed bin(35),	/* encoded offset from address */
  6    27 	2 virtual_org	fixed bin(35),
  6    28 	2 bounds(1),
  6    29 	  3 lower		fixed bin(35),	/* encoded lower bound */
  6    30 	  3 upper		fixed bin(35),	/* encoded upper bound */
  6    31 	  3 multiplier	fixed bin(35);	/* encoded multiplier */
  6    32 
  6    33 dcl	1 runtime_bound	based,
  6    34 	2 lower		fixed bin(35),
  6    35 	2 upper		fixed bin(35),
  6    36 	2 multiplier	fixed bin(35);
  6    37 
  6    38 dcl	1 runtime_block	aligned based,
  6    39 	2 flag		unal bit(1),	/* always "1"b for Version II */
  6    40 	2 quick		unal bit(1),	/* "1"b if quick block */
  6    41 	2 fortran		unal bit(1),	/* "1"b if fortran program */
  6    42 	2 standard	unal bit(1),	/* "1"b if program has std obj segment */
  6    43 	2 owner_flag	unal bit(1),	/* "1"b if block has valid owner field */
  6    44 	2 skip		unal bit(1),
  6    45 	2 type		unal bit(6),	/* = 0 for a block node */
  6    46 	2 number		unal bit(6),	/* begin block number */
  6    47 	2 start		unal bit(18),	/* rel ptr to start of symbols */
  6    48 	2 name		unal bit(18),	/* rel ptr to name of proc */
  6    49 	2 brother		unal bit(18),	/* rel ptr to brother block */
  6    50 	2 father		unal bit(18),	/* rel ptr to father block */
  6    51 	2 son		unal bit(18),	/* rel ptr to son block */
  6    52 	2 map		unal,
  6    53 	  3 first		bit(18),		/* rel ptr to first word of map */
  6    54 	  3 last		bit(18),		/* rel ptr to last word of map */
  6    55 	2 entry_info	unal bit(18),	/* info about entry of quick block */
  6    56 	2 header		unal bit(18),	/* rel ptr to symbol header */
  6    57 	2 chain(4)	unal bit(18),	/* chain(i) is rel ptr to first symbol
  6    58*					   on start list with length >= 2**i */
  6    59 	2 token(0:5)	unal bit(18),	/* token(i) is rel ptr to first token
  6    60*					   on list with length >= 2 ** i */
  6    61 	2 owner		unal bit(18);	/* rel ptr to owner block */
  6    62 
  6    63 dcl	1 runtime_token	aligned based,
  6    64 	2 next		unal bit(18),	/* rel ptr to next token */
  6    65 	2 dcl		unal bit(18),	/* rel ptr to first dcl of this token */
  6    66 	2 name,				/* ACC */
  6    67 	  3 size		unal unsigned fixed bin (9), /* number of chars in token */
  6    68 	  3 string	unal char(n refer(runtime_token.size));
  6    69 
  6    70 dcl	1 encoded_value	aligned based,
  6    71 	2 flag		bit (2) unal,
  6    72 	2 code		bit (4) unal,
  6    73 	2 n1		bit (6) unal,
  6    74 	2 n2		bit (6) unal,
  6    75 	2 n3		bit (18) unal;
  6    76 
  6    77 /*	END INCLUDE FILE ... runtime_symbol.incl.pl1 */
      472 
  7     1 dcl	1 statement_map	aligned based,
  7     2 	2 location	bit(18) unaligned,
  7     3 	2 source_id	unaligned,
  7     4 	  3 file		bit(8),
  7     5 	  3 line		bit(14),
  7     6 	  3 statement	bit(5),
  7     7 	2 source_info	unaligned,
  7     8 	  3 start		bit(18),
  7     9 	  3 length	bit(9);
      473 
  8     1 /* BEGIN INCLUDE FILE --- acc.incl.pl1 
  8     2*
  8     3*James R. Davis 21 Nov 78
  8     4**/
  8     5 
  8     6 dcl 1 acc based aligned,
  8     7     2 num_chars fixed bin (9) unsigned unaligned,
  8     8     2 string char (0 refer (acc.num_chars)) unaligned;
  8     9 
  8    10 /* END INCLUDE FILE --- acc.incl.pl1 */
      474 
  9     1 /* BEGIN INCLUDE FILE ... data_type_info_.incl.pl1
  9     2*
  9     3*   attributes of each Multics data type.  You may not rely on the dimension never exceeding 64
  9     4*   James R. Davis 6 Apr 79
  9     5*   Modified JMAthane June 83 to add "type" bit field 
  9     6*   Upped bound from 64 to 80 10/18/83 S. Herbst
  9     7*   Added "hex" and "generic" bits 01/23/84 S. Herbst
  9     8*   Upped bound from 80 to 86 01/81/84 R. Gray
  9     9*   Upper bound from 86 to 87 JMAthane (for Pascal strings type dtype)
  9    10**/
  9    11 
  9    12      
  9    13 /****^  HISTORY COMMENTS:
  9    14*  1) change(86-09-05,JMAthane), approve(86-09-05,MCR7525),
  9    15*     audit(86-09-11,Martinson), install(86-11-12,MR12.0-1208):
  9    16*     The data_type_info array now has 87 entries instead of 86 due to
  9    17*     introduction of pascal_string_type_dtype.
  9    18*                                                   END HISTORY COMMENTS */
  9    19 
  9    20 dcl	   data_type_info_$version_number fixed bin external static;
  9    21      dcl	   data_type_info_this_version fixed bin internal static options (constant) init (1);
  9    22 
  9    23      dcl	   1 data_type_info_$info (87) aligned external static,
  9    24 	     2 computational      bit (1) unal,
  9    25 	     2 arithmetic	      bit (1) unal,
  9    26 	     2 arithmetic_attributes unal,		/* only valid if arithmetic */
  9    27 	       3 fixed	      bit (1) unal,		/* PL/I type */
  9    28 	       3 complex	      bit (1) unal,		/* PL/I mode */
  9    29 	       3 decimal	      bit (1) unal,		/* PL/I base */
  9    30 	       3 signed	      bit (1) unal,
  9    31 	       3 trailing_sign    bit (1) unal,		/* only valid if signed */
  9    32 	       3 decimal_attributes unal,		/* only valid if decimal */
  9    33 	         4 packed_dec     bit (1) unal,		/* 4 bits per digit or 9 */
  9    34 	         4 digit_aligned  bit (1) unal,		/* valid for packed_dec only */
  9    35 	         4 overpunched    bit (1) unal,
  9    36 	     2 char_string	      bit (1) unal,		/* valid for non-arithmetic */
  9    37 	     2 bit_string	      bit (1) unal,		/* valid for non-arithmetic */
  9    38 	     2 varying	      bit (1) unal,		/* for bit or char only */
  9    39 	     2 type	      bit (1) unal,		/* this symbol is a type */
  9    40 	     2 hex	      bit (1) unal,		/* a hexadecimal type (eg., hex floating point) */
  9    41 	     2 generic	      bit (1) unal,		/* eg., real_flt_dec_generic_dtype */
  9    42 	     2 pad	      bit (20) unal;
  9    43 
  9    44      dcl	   data_type_info_$ninebit_sign_chars char (2) external static;
  9    45      dcl	   data_type_info_$ninebit_digit_chars char (10) external static;
  9    46      dcl	   data_type_info_$ninebit_overpunched_sign_chars char (22) external static;
  9    47 
  9    48      dcl	   data_type_info_$max_decimal_precision fixed bin external static;
  9    49      dcl	   data_type_info_$max_float_binary_precision fixed bin external static;
  9    50      dcl	   data_type_info_$max_fixed_binary_precision fixed bin external static;
  9    51 
  9    52 
  9    53 /* END INCLUDE FILE ... data_type_info_.incl.pl1 */
      475 
 10     1 /* BEGIN INCLUDE FILE ... picture_image.incl.pl1
 10     2*
 10     3*   James R. Davis  12 Mar 79
 10     4**/
 10     5 
 10     6      dcl	   1 picture_image	      aligned based,
 10     7 	     2 type	      fixed bin (8) unal,
 10     8 	     2 prec	      fixed bin (8) unal,	/* precision or length of associated value */
 10     9 	     2 scale	      fixed bin (8) unal,	/* for both fixed and float pictures,
 10    10*							=ndigits after "v" - scale_factor */
 10    11 	     2 piclength	      fixed bin (8) unal,	/* length of picture_constant.chars, <64
 10    12*							=length of normalized-picture-string */
 10    13 	     2 varlength	      fixed bin (8) unal,	/* length of pictured variable in chars, <64
 10    14*							=length of normalized_picture_string - "k" and "v" */
 10    15 	     2 scalefactor	      fixed bin (8) unal,	/* value of pict-sc-f, -256<=x<256  */
 10    16 	     2 explength	      fixed bin (8) unal,	/* length of exp field for float */
 10    17 	     2 drift_character    char (1) unal,
 10    18 	     2 chars	      char (0 refer (picture_image.piclength)) aligned;
 10    19 
 10    20      dcl	   (
 10    21 	   picture_char_type      init (24),
 10    22 	   picture_realfix_type   init (25),
 10    23 	   picture_complexfix_type
 10    24 			      init (26),
 10    25 	   picture_realflo_type   init (27),
 10    26 	   picture_complexflo_type
 10    27 			      init (28)
 10    28 	   )		      fixed bin (8) unal static internal options (constant);
 10    29 
 10    30 /* END INCLUDE FILE  ... picture_image.incl.pl1  */
      476 
      477 
      478   end;				/* print_algol68_attr; */
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/88  1545.0  probe_print_algol68_attr_.pl1     >spec>install>MR12.2-1210>probe_print_algol68_attr_.pl1
467          1    10/27/88  1339.2  probe_info.incl.pl1               >ldd>include>probe_info.incl.pl1
468          2    11/26/79  1320.6  probe_source_info.incl.pl1        >ldd>include>probe_source_info.incl.pl1
469          3    11/02/83  1845.0  probe_seg_info.incl.pl1           >ldd>include>probe_seg_info.incl.pl1
470          4    11/11/88  1543.8  probe_references.incl.pl1         >spec>install>MR12.2-1210>probe_references.incl.pl1
471          5    10/26/88  1255.5  std_descriptor_types.incl.pl1     >ldd>include>std_descriptor_types.incl.pl1
472          6    11/26/79  1320.6  runtime_symbol.incl.pl1           >ldd>include>runtime_symbol.incl.pl1
473          7    05/06/74  1751.6  statement_map.incl.pl1            >ldd>include>statement_map.incl.pl1
474          8    01/15/79  2202.9  acc.incl.pl1                      >ldd>include>acc.incl.pl1
475          9    11/12/86  1748.0  data_type_info_.incl.pl1          >ldd>include>data_type_info_.incl.pl1
476         10    06/28/79  1204.8  picture_image.incl.pl1            >ldd>include>picture_image.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
P_code                                 parameter       fixed bin(35,0)          dcl 35 set ref 25 52*
P_inherited                            parameter       fixed bin(17,0)          dcl 268 ref 264 276 282
P_long_sw                              parameter       bit(1)                   dcl 34 ref 25 74
P_probe_info_ptr                       parameter       pointer                  dcl 32 ref 25 51
P_reference                            based           structure                level 1 dcl 37
P_refp                                 parameter       pointer                  dcl 33 ref 25 53
P_sym                                  parameter       pointer                  dcl 267 set ref 264 275 283 285 285* 290 290*
P_verbose                              parameter       bit(1)                   dcl 269 ref 264 279
acc                                    based           structure                level 1 dcl 8-6
addrel                                                 builtin function         dcl 42 ref 74 79 100 100 105 113 211 211 326 328 358
                                                                                  358 382 386 388
address                   3            based           structure                level 2 packed packed unaligned dcl 6-3
address_ptr               4            based           pointer                  level 2 dcl 37 ref 449
algol68_array_descriptor_dtype         constant        fixed bin(17,0)          initial dcl 5-25 ref 242
algol68_format_dtype                   constant        fixed bin(17,0)          initial dcl 5-25 ref 240
algol68_straight_dtype                 constant        fixed bin(17,0)          initial dcl 5-25 ref 238
algol68_union_dtype                    constant        fixed bin(17,0)          initial dcl 5-25 ref 244
an_ev                           000101 automatic       structure                level 1 dcl 422 set ref 441*
area_dtype                             constant        fixed bin(17,0)          initial dcl 5-25 ref 222
arithmetic                0(01) 000016 external static bit(1)                   array level 2 packed packed unaligned dcl 9-23 ref
                                                                                  139
arithmetic_attributes
                          0(02) 000016 external static structure                array level 2 packed packed unaligned dcl 9-23
attr                            000100 automatic       varying char(168)        dcl 124 set ref 136* 142* 142 146* 146 150* 150 165*
                                                                                  165 167* 167 176* 176 180* 180 184* 184 185* 185
                                                                                  186* 186 192* 192 195* 195 196* 196 197* 197 198*
                                                                                  198 200* 203* 207* 210* 210 211* 211 213* 213 216*
                                                                                  218* 220* 224* 225* 225 226* 226 228* 230* 232*
                                                                                  234* 236* 238* 240* 242* 244* 246* 249* 249 250
b                                      parameter       bit(8)                   packed unaligned dcl 406 ref 404 407 407 409
based_class                            constant        bit(4)                   initial packed unaligned dcl 427 in procedure
                                                                                  "value" ref 450
based_class                            constant        fixed bin(17,0)          initial dcl 336 in procedure "get_pl1_class_str" ref
                                                                                  353
bin                                                    builtin function         dcl 42 ref 407 407 409
bit_string                0(11) 000016 external static bit(1)                   array level 2 packed packed unaligned dcl 9-23 ref
                                                                                  173
bits                      0(24)        based           structure                level 2 packed packed unaligned dcl 6-3
block_ptr                       000104 automatic       pointer                  dcl 424 in procedure "value" set ref 448* 450* 450*
                                                                                  456* 456*
block_ptr                 4            based           pointer                  level 2 in structure "source_info" dcl 2-5
                                                                                  in procedure "probe_print_algol68_attr_" ref 448
bounds                    7            based           structure                array level 2 dcl 6-3
brother                   1(18)        based           bit(18)                  level 2 packed packed unaligned dcl 6-3 ref 79 79
                                                                                  111 113
c                               000214 automatic       fixed bin(17,0)          dcl 338 set ref 350* 351 353
char                                                   builtin function         dcl 430 ref 463
char_string               0(10) 000016 external static bit(1)                   array level 2 packed packed unaligned dcl 9-23 set
                                                                                  ref 173 180*
chars                     2            based           char                     level 2 dcl 10-6 ref 197
class                     3(18)        based           bit(4)                   level 3 packed packed unaligned dcl 6-3 ref 350 450
class_name                      000000 constant        char(20)                 initial array packed unaligned dcl 341 ref 351
class_str                       000215 automatic       varying char(168)        dcl 339 set ref 351* 357* 357 358* 358 363* 363 366
code                            000112 automatic       fixed bin(35,0)          dcl 429 set ref 456* 458
complex                   0(03) 000016 external static bit(1)                   array level 3 packed packed unaligned dcl 9-23 set
                                                                                  ref 142*
computational                   000016 external static bit(1)                   array level 2 packed packed unaligned dcl 9-23 ref
                                                                                  139
context                                parameter       pointer                  dcl 418 set ref 413 450 450*
data_type_info_$info            000016 external static structure                array level 1 dcl 9-23 set ref 399 399
decimal                   0(04) 000016 external static bit(1)                   array level 3 packed packed unaligned dcl 9-23 set
                                                                                  ref 150*
dims_str                        000102 automatic       varying char(168)        dcl 273 set ref 276* 279* 281* 285* 285 288* 288
                                                                                  290* 290 293* 293 296* 296 299
encoded_value                          based           structure                level 1 dcl 6-70
entry_dtype                            constant        fixed bin(17,0)          initial dcl 5-25 ref 218
ev                                     parameter       fixed bin(35,0)          dcl 416 set ref 413 441 456* 461
ext_entry_runtime_dtype                constant        fixed bin(17,0)          initial dcl 5-125 ref 234
ext_procedure_runtime_dtype            constant        fixed bin(17,0)          initial dcl 5-125 ref 57 236
false_str                              parameter       char                     packed unaligned dcl 256 ref 252 260
father                    2            based           bit(18)                  level 2 packed packed unaligned dcl 6-3 ref 326 386
file_dtype                             constant        fixed bin(17,0)          initial dcl 5-25 ref 228
fixed                     0(02) 000016 external static bit(1)                   array level 3 in structure "data_type_info_$info"
                                                                                  packed packed unaligned dcl 9-23 in procedure
                                                                                  "probe_print_algol68_attr_" set ref 146* 155
fixed                                                  builtin function         dcl 42 in procedure "probe_print_algol68_attr_" ref
                                                                                  74 78 78 98 110 110 132 275 309 350 384
flag                            000101 automatic       bit(2)                   level 2 packed packed unaligned dcl 422 set ref 442
hbound                                                 builtin function         dcl 42 ref 399
i                               000202 automatic       fixed bin(17,0)          dcl 322 in procedure "king_of_structure" set ref
                                                                                  325*
i                               000101 automatic       fixed bin(17,0)          dcl 272 in procedure "get_pl1_dims_str" set ref 282*
                                                                                  283 285 290 293*
inheritance                            parameter       fixed bin(17,0)          dcl 93 set ref 88 100*
int_entry_runtime_dtype                constant        fixed bin(17,0)          initial dcl 5-125 ref 232
io_switches              66            based           structure                level 2 dcl 1-18
ioa_$ioa_switch                 000010 constant        entry                    external dcl 44 ref 57 60 68 84 100
ioa_$rsnnl                      000012 constant        entry                    external dcl 44 ref 155 159 162 315
l                               000120 automatic       fixed bin(17,0)          dcl 306 set ref 309* 310 312 315* 325
label_constant_runtime_dtype           constant        fixed bin(17,0)          initial dcl 5-125 ref 230
label_dtype                            constant        fixed bin(17,0)          initial dcl 5-25 ref 216
lbound                                                 builtin function         dcl 42 ref 399
level                           000104 automatic       fixed bin(17,0)          dcl 96 in procedure "print_member" set ref 98* 100
                                                                                  100*
level                     0(12)        based           bit(6)                   level 2 in structure "runtime_symbol" packed packed
                                                                                  unaligned dcl 6-3 in procedure
                                                                                  "probe_print_algol68_attr_" ref 98 309 384
level_str                       000121 automatic       varying char(168)        dcl 307 set ref 315* 317
linkage_ptr                     000110 automatic       pointer                  dcl 426 in procedure "value" set ref 445* 450* 456*
linkage_ptr             103            based           pointer                  level 3 in structure "seg_info" packed packed
                                                                                  unaligned dcl 3-9 in procedure
                                                                                  "probe_print_algol68_attr_" ref 445
location                  3            based           bit(18)                  level 3 packed packed unaligned dcl 6-3 ref 353 358
                                                                                  358
lower                     7            based           fixed bin(35,0)          array level 3 dcl 6-3 set ref 283 285*
ltrim                                                  builtin function         dcl 430 ref 463
n                               000100 automatic       fixed bin(17,0)          dcl 271 set ref 275* 276 282 293
name                            000100 automatic       varying char(256)        dcl 377 in procedure "symbol_name" set ref 382* 388*
                                                                                  388 391
name                      1            based           bit(18)                  level 2 in structure "runtime_symbol" packed packed
                                                                                  unaligned dcl 6-3 in procedure
                                                                                  "probe_print_algol68_attr_" ref 100 100 328 382
                                                                                  388
ndims                     0(18)        based           bit(6)                   level 2 packed packed unaligned dcl 6-3 ref 78 78
                                                                                  110 110 275
next                            000106 automatic       pointer                  dcl 41 set ref 79* 81* 82
nextq                           000102 automatic       pointer                  dcl 95 set ref 111* 113* 114
null                                                   builtin function         dcl 430 in procedure "value" ref 450
null                                                   builtin function         dcl 42 in procedure "probe_print_algol68_attr_" ref
                                                                                  56 74 81 105 111
num_chars                              based           fixed bin(9,0)           level 2 packed packed unsigned unaligned dcl 8-6 ref
                                                                                  328 382 388
offset_dtype                           constant        fixed bin(17,0)          initial dcl 5-25 ref 205
output_switch            70            based           pointer                  level 3 dcl 1-18 set ref 57* 60* 68* 84* 100*
p                               000202 automatic       pointer                  dcl 379 in procedure "symbol_name" set ref 381* 382
                                                                                  382 384 386* 386 386 388 388
p                               000176 automatic       pointer                  dcl 127 in procedure "get_pl1_attr_str" set ref 190*
                                                                                  192 192 197
p                               000204 automatic       pointer                  dcl 323 in procedure "king_of_structure" set ref
                                                                                  324* 326* 326 326 328 328
packed                    0(25)        based           bit(1)                   level 3 packed packed unaligned dcl 6-3 set ref 249*
piclength                 0(27)        based           fixed bin(8,0)           level 2 packed packed unaligned dcl 10-6 ref 197
picture_complexfix_type                constant        fixed bin(8,0)           initial packed unaligned dcl 10-20 ref 192
picture_complexflo_type                constant        fixed bin(8,0)           initial packed unaligned dcl 10-20 ref 192
picture_image                          based           structure                level 1 dcl 10-6
picture_runtime_dtype                  constant        fixed bin(17,0)          initial dcl 5-125 ref 188
pointer_dtype                          constant        fixed bin(17,0)          initial dcl 5-25 ref 203
pointers                 76            based           structure                level 2 dcl 3-9
probe_block_name_               000014 constant        entry                    external dcl 48 ref 84
probe_info                             based           structure                level 1 dcl 1-18
probe_info_ptr                  000110 automatic       pointer                  dcl 1-86 set ref 51* 57 60 68 84 84* 100
ptr                                                    builtin function         dcl 129 ref 190
q                               000100 automatic       pointer                  dcl 94 set ref 105* 105* 110* 111 113 113*
reference_node                         based           structure                level 1 dcl 4-16
refp                            000100 automatic       pointer                  dcl 38 in procedure "probe_print_algol68_attr_" set
                                                                                  ref 53* 54 57 60 84 444 445 448 449
refp                            000102 automatic       pointer                  dcl 423 in procedure "value" set ref 449* 450 450*
                                                                                  456*
rtrim                                                  builtin function         dcl 430 in procedure "value" ref 463
rtrim                                                  builtin function         dcl 42 in procedure "probe_print_algol68_attr_" ref
                                                                                                                                                                                                                                                                                                                        F       'McDonald                Office                           SV@t   h             FN                                                                                                                                                                                                                                                                             F      (McFadden                HIS                                      Kl+       <          F    (  <.O   (0s \                                                                        $                                                                       D  @                                                   @@    @                     F  \   )Lupton                  Multics                                  MF  "      N  N    , @   )                                                                     @                                                                                  ,     *Mabey                   Multics           	              TkD  ,$    d*           zFraser                  Multics           Ed@              T_P9       ,    ,        +Mailnet-Slave           Mailnet                                 O\       <@        F    +  <.O   (0s \                                                                        $                                      z.YW>X4b=\L  @                                                   @@    @                     F  z   ,Mallmes                 Multics           s2               T  `    L        *    &^   L                                              &  8   -MAgar                   CDC               E	J              T0Ff  H    -    h  h    "   jEngAdmin                EngAdmin          }              Qy       	    	                           "     .MQuintin                CDC               =Z              SiUr   P                F

                                                                                                                                                                                                                                                                             F      /Leskiw                  Multics           # 
*              Rt               |   iClayton                 Multics           E5{              TX   .            F    `	                                                R   0Lodermeier              Develcon                                 L	^K   ,    <    r  r    F 6   0  <.O   (0s \                                                                        $                                                                       D  @                                                   @@    @                     F     1Luk                     Multics                         T$       ~  f      F
                                                                                                                                                                                                                                                                              F      2Lastuka                 OperDevel                               OG?  ^              r   2                                                                                              353 358 358 358 358
symb                                   parameter       pointer                  dcl 304 in procedure "get_pl1_level_str" ref 302 309
                                                                                  324
symbol_ptr                             based           pointer                  level 2 dcl 37 ref 54
t_or_f                                 parameter       bit(1)                   packed unaligned dcl 254 ref 252 258
temp                            000153 automatic       varying char(64)         dcl 125 set ref 137* 155* 159* 162* 165
true_str                               parameter       char                     packed unaligned dcl 255 ref 252 258
type                    113            based           fixed bin(35,0)          level 2 in structure "P_reference" dcl 37
                                                                                  in procedure "probe_print_algol68_attr_" set ref
                                                                                  57 60*
type                            000174 automatic       fixed bin(17,0)          dcl 126 in procedure "get_pl1_attr_str" set ref 132*
                                                                                  133* 139 139 142 146 150 155 167 173 173 176 180
                                                                                  188 203 205 216 218 220 222 228 230 232 234 236
                                                                                  238 240 242 244
type                      0(06)        based           bit(6)                   level 2 in structure "runtime_symbol" packed packed
                                                                                  unaligned dcl 6-3 in procedure
                                                                                  "probe_print_algol68_attr_" ref 74 132
type                                   based           fixed bin(8,0)           level 2 in structure "picture_image" packed packed
                                                                                  unaligned dcl 10-6 in procedure
                                                                                  "probe_print_algol68_attr_" ref 192 192
unspec                                                 builtin function         dcl 430 ref 441
upper                    10            based           fixed bin(35,0)          array level 3 dcl 6-3 set ref 290*
val                             000100 automatic       fixed bin(35,0)          dcl 421 set ref 456* 461* 463
varying                   0(12) 000016 external static bit(1)                   array level 2 packed packed unaligned dcl 9-23 set
                                                                                  ref 176*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
algol68_bits_dtype                     internal static fixed bin(17,0)          initial dcl 5-110
algol68_bool_dtype                     internal static fixed bin(17,0)          initial dcl 5-110
algol68_byte_dtype                     internal static fixed bin(17,0)          initial dcl 5-110
algol68_char_dtype                     internal static fixed bin(17,0)          initial dcl 5-110
algol68_compl_dtype                    internal static fixed bin(17,0)          initial dcl 5-110
algol68_int_dtype                      internal static fixed bin(17,0)          initial dcl 5-110
algol68_long_compl_dtype               internal static fixed bin(17,0)          initial dcl 5-110
algol68_long_int_dtype                 internal static fixed bin(17,0)          initial dcl 5-110
algol68_long_real_dtype                internal static fixed bin(17,0)          initial dcl 5-110
algol68_real_dtype                     internal static fixed bin(17,0)          initial dcl 5-110
algol68_short_int_dtype                internal static fixed bin(17,0)          initial dcl 5-110
algol68_struct_struct_bool_dtype       internal static fixed bin(17,0)          initial            (?.           >udd>m>Gray     S                                 f         Gee                                 S                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           VLMyers                 OperDevel                                MP=[      G    F  F    * F     G                                                            @                                                                                   *     Vu                      Multics           E               TeR   
              F                                                                                                                                                                                                                                                                              F      Stearns                 Office                                  PA       <4  
  
    F      <.O   (0s \                                                                        $                                                                       D  @  @                                                @@    @                     F  X   Strakhovsky             Multics                                  M]  &        &  T    . <        H                                                                    0                                                                                     .     Runions                 Multics                                  Lh2F  p    X        4                                  $                                                                       D  @                                                   @@    @                         4     Schroth                 SysMaint          b2@d              TQE  ,v               BHarvey                 Office            e $j              Sr                                                                            v   Sherwood                Operator                                O=      {Z  ,  ,    $ Z     {           ?   @`                                                                                    $  6   Siler                   Office            Eg               Tc]               Z    >                                                                   Schwartz                Multics                                 P   v    <          F      <.O   )0s \                                                                        $                                                                       D  @     
                   ?  @@    @                     F     SHarris                 SysMaint                                 Mh      Z    
  
    2      Z                      $                                                                       D  @                                                   @@    @                       2  X   Samanani                Multics           `V              T  @          X    <   oThompson                Multics           y7'              S  ,    $l      l                                                                                     
   RWaters                 Multics           @              T_                 mDonaldson               Multics           3{               S
       s                Rohs                    Multics                                 PcH      V              V                                           Rosin                   SysAdmin          E@              Tx_  E    ~            ~   Radlowsky               Multics           E) :              T3O               <    b      @                        S2                     @                                                                    T                         = L <     >IS                                                  SwX     "            &   H                  &<"                `        :    @  Ht l 
      .  LZ |                         S         Daemon                              S      !    SysAdmin                            S       8    SysDaemon                           S      U    SysMaint                            Sn         Gray                                S  z  r &  fwm                                 U*         Operator                            S  j         UOFC                                S         Fudge                               S  |  t 1(  rw                                  y n         Holmstedt                           S          Hoover                              S (         IMFT                                S          Initializer                         S  d  \ (    mtgs                                y ` R         Perez                               S D     	    Oke                                 SX D         Repair                              S         SHarris                             S^         Transfer                            S:^     	    WAAnderson                          S  P         Zwick                               Sl8  &q9);       a          $    Armstrong                           q9@       >udd>m>Armstrong    S                                   ;    mba                                 q9    &S'N\a     ( z         6    daf                                 S'Ry                   8 \ ( z           S             MacDonald                           S     "    df                                  S'\$     *@          S'    T     *@         S'    4    *@         S'    |,    *@          S'    Dt   n  *@          S'    L<     *@         S'    TD     *@         S'    $L     *@          S'            *@          S'    6D     *         E;    2^     *@          ]B    <|    *@         S'    t4    r*@          S'       &S*N\bt    ( z   (     3    Oke                                 S*Ry                    	 ( z           S      (       to                                  S*     *@         S*       *@         S*          a@         S*         *@         S*         *@         S*         *@          S*       R  *@         S*       | *@          S*      &S+N\bx      ( z          5    SHarris                             S+N])    	               8 L ( z           S             Card_Input                          Sz     *@         S+    z<     *@          S+    4D   n  *@         S+    <T    *@         S+    T      m@         S+    DL   *@         S+    t  &yN\dx   d 6 a    6    \ .    meetings                            yN]7    `                 a           S    0     *@         9           *@         9          *@         y    ,     *@         S'            *@          S*      &S-Q2^   . ` a        '    SysMaint.pmf                        S-Q3    	E             $   a =            S    .   4    SysMaint                            S-      *          S-       ` *@          S-           *          S-         *          S-             *@         V      L     *@         S    \   ( *@          z7A    (     *@         }u    f(  ^  *@         }u       ^ *@         }u    d     *@         y     d  &}uN\c   @@ ( z         8     Vu                                  }uN],    z4                f ( z           S      |         Vu                                  S         wa                                  z7A,4     *@         S+        r*@          U*    N  ^  *@         z7A    l  &{P7   f ( z   f         Schroth                             {Ry    		                 ( z           S       *@         {    |  *@         {              Martinson                           S   ,    rg                                  (?.    *@         {         *@          9    @  &9N\dl    a   "     
  Support                             9RoV    zG                  a           S    0     *@         9           sup                                 9    *@          9    f     *@               &N\dm   HH ( z         @ !  Hindbo                              N]                     8n ( z           S    n8  n *@                        Hindbo                              S  *@         {     | n     (    Schroth                             S     *@         {              TR                                  S|    *@         {            *@          {         *@         {     r           ASPD                                S           Multics                             Sv
   *@             t@  &N\dn    ( z          l  Huen                                N]!    	                
~ ( z           S         *@                        Huen                                S    *@         y       1    tom                                 S*>d     *@          E;      6     *@         E;            *@         V    4   R  *@         z7A           *@          z7A+         *@          U*            *@         }u      f     *@             ~    *@               v     *@               f  *@          ]B         *@         E;    D    *@         E;    *     *@         ]B        *@          ]B       6   MSS                                 ]B   #    mss                                 ]B       Site_Support                        ]B     ( 6  ss                                  ]B     *@         ]B        *@          ]B        *@         ]B      :  *@          ]B             Elliott                             S2   R  *@          ]B     R         Neal                                SH     *@         ]B    l  P  *@          ]B              Westcott                            S  *     *@         ]B              Zimmerman                           Slt  ^  *@          ]B             Gatha                               S^      *@          ]B          t *@         {zU           *@          $    lJ    *@                         ACTC_SYSM                           S  "       support                             9  `  X      mrt                                   (         Johnson                             S nX         SA1                                 Sf         GJohnson                            S         Beattie                             S          Farley                  probe_info_ptr              probe_print_algol68_attr_
                         000120 l                           get_pl1_level_str
                         000121 level_str                   get_pl1_level_str
                         000202 i                           king_of_structure
                         000204 p                           king_of_structure
                         000214 c                           get_pl1_class_str
                         000215 class_str                   get_pl1_class_str
symbol_name              000100 name                        symbol_name
                         000202 p                           symbol_name
value                    000100 val                         value
                         000101 an_ev                       value
                         000102 refp                        value
                         000104 block_ptr                   value
                         000106 stack_ptr                   value
                         000110 linkage_ptr                 value
                         000112 code                        value

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_le_a              r_ge_a              alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out
call_int_this_desc  call_int_this       call_int_other      return_mac          shorten_stack       ext_entry
int_entry           int_entry_desc      return_chars_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ioa_$ioa_switch               ioa_$rsnnl                    probe_block_name_             stu_$decode_runtime_value
stu_$get_implicit_qualifier

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
data_type_info_$info




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     25 000336        51 000350        52 000354        53 000355        54 000360        56 000362        57 000366
     60 000412        65 000440        68 000441        74 000534        78 000560        79 000574        81 000605
     82 000607        84 000612        86 000660        88 000661        98 000667       100 000675       105 001004
    110 001020       111 001037       113 001047       114 001052       117 001055       119 001056       132 001064
    133 001072       136 001106       137 001107       139 001110       142 001121       146 001171       150 001246
    155 001323       159 001370       162 001442       165 001474       167 001521       171 001576       173 001600
    176 001603       180 001653       184 001731       185 001741       186 001771       187 002000       188 002001
    190 002004       192 002012       195 002040       196 002052       197 002064       198 002102       199 002111
    200 002112       201 002116       203 002117       205 002130       207 002132       208 002137       210 002144
    211 002153       213 002201       215 002210       216 002211       218 002221       220 002231       222 002241
    224 002243       225 002250       226 002300       227 002307       228 002310       230 002320       232 002330
    234 002340       236 002350       238 002360       240 002370       242 002400       244 002410       246 002420
    249 002424       250 002476       252 002507       258 002530       260 002545       264 002553       275 002561
    276 002567       279 002573       281 002604       282 002610       283 002621       285 002631       288 002657
    290 002666       293 002720       295 002732       296 002734       299 002743       302 002753       309 002755
    310 002762       312 002767       315 002777       317 003037       320 003047       324 003051       325 003055
    326 003063       327 003070       328 003073       333 003110       350 003112       351 003120       353 003130
    357 003136       358 003150       363 003174       366 003203       372 003213       381 003221       382 003225
    384 003242       386 003247       388 003254       390 003316       391 003320       396 003330       399 003332
    404 003343       407 003345       409 003360       413 003363       441 003371       442 003374       444 003400
    445 003405       448 003410       449 003412       450 003415       456 003451       458 003477       460 003510
    461 003511       463 003513


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
