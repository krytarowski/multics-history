THIS FILE IS DAMAGED

	COMPILATION LISTING OF SEGMENT db_break_map
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/04/82  1821.4 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 
       12 db_break_map:	procedure;
       13 
       14 /*	This procedure is called to manipulate break maps.  It is called by  db_break
       15**	to perform the following tasks:
       16**
       17**	init:		Returns a pointer to the break map in  a specified segment.
       18**			If no break map exists then one will be created.
       19**
       20**	check:		Returns a pointer to the break map in a specified segment.
       21**			However, if no break map exists it will not create one.
       22**
       23**	get_slots:	It will add anothere page full of break slots to an existing
       24**			break map.
       25**
       26**	delete:		It deletes the break map from the specified segment.
       27**
       28**	Rewritten  Dec 72  for the  6180  by  Bill Silver.
       29**/
       30 
       31 
       32 
       33 
       34 /*		PARAMETERS		*/
       35 
       36 dcl	arg_seg_ptr	ptr,		/* (I) Pointer to segment that contains
       37*					*   or will contain a break map.  */
       38 	arg_bit_count	fixed bin(24),	/* (I) Bit count of this segment. */
       39 	arg_break_map_ptr	ptr;		/* (I/O) Pointer to break map of a segment.
       40*					*  If there is any ERROR it is returned null. */
       41 
       42 
       43 
       44 /*		AUTOMATIC  DATA		*/
       45 
       46 dcl	access_mode	fixed bin(5),	/* Access mode of the segment.  */
       47 	bit_count		fixed bin(24),	/* The total number of bits in a segment. */
       48 	bits_left		fixed bin,	/* The number of bits left unused in the
       49*					*  last page of the segment.  */
       50 	code		fixed bin(35),	/* Error return code.  */
       51 	dir_name		char(168) aligned,	/* Directory name of the segment. */
       52 	ent_name		char(32)  aligned,	/* Entry name of the segment.  */
       53 	end_ptr		ptr,		/* Pointer to the last word in the segment or
       54*					*  where the last word in the segment will be. */
       55 	i		fixed bin,	/* A work index. */
       56 	mapp		ptr,		/* Just declared to get rid of warning.  */
       57 	max_length	fixed bin(19),	/* The max number of words in the object segment. */
       58 	max_num_pages	fixed bin,	/* Number of pages in object segment. */
       59 	new_bits		fixed bin(24),	/* Number of new bits being added to a segment. */
       60 	new_slots		fixed bin,	/* Number of new break slots being added
       61*					*  to the break map. */
       62 	new_words		fixed bin(18),	/* Number of new words being added to a segment. */
       63 	new_slots_ptr	ptr,		/* Pointer to where new break slots will be added. */
       64 	obj_map_ptr	ptr,		/* Pointer to the object map in the segment
       65*					*  or where the object map will go.  */
       66 	page_bits		fixed bin,	/* The number of bits in a page. */
       67 	page_num		fixed bin,	/* The number of the last page in the segment -
       68*					*  starting with page  1.  */
       69 	page_words	fixed bin,	/* The number of words in a page. */
       70 	seg_ptr		ptr,		/* Pointer to the base of the object segment. */
       71 	word_count	fixed bin(19);	/* Total number of words in segment. */
       72 
       73 dcl    1	seg_acl		aligned,		/* Structure used to add an ACL entry to the object segment. */
       74 	2 user_id char(32),
       75 	2 access bit(36),
       76 	2 pad bit(36),
       77 	2 status fixed bin(35);
       78 
       79 dcl     1	delete_acl	aligned,		/* Used to delete an ACL. */
       80 	2  user_id	char(32),
       81 	2  status		fixed bin(35);
       82 dcl 1 oi like object_info;
       83 
       84 
       85 
       86 /*		BASED  DATA		*/
       87 
       88 /*	This is an overlay of an instruction.  We only want to reference the  offset
       89**	field of the instruction.
       90**/
       91 dcl    1	based_inst    based    aligned,
       92         (	2  offset     bit(18),
       93 	2  pad        bit(18)) unaligned;
       94 
       95 
       96 /*	These are the two formats of the object map offset found at the end of an object segment. */
       97 
       98 dcl	ns_obj_map_off	fixed bin(18)	based	aligned,
       99 	stand_obj_map_off	bit(18)		based 	aligned;
      100 
      101 
      102 dcl 1 map_ver_1 aligned based (obj_map_ptr),	/* version 1 object map */
      103 	2 decl_vers fixed bin,		/* version number of current structure format */
      104 	2 identifier char(8) aligned,		/* must be the constant "obj_map" */
      105 	2 text_offset bit(18) unaligned,	/* offset rel to base of object segment of base of text section */
      106 	2 text_length bit(18) unaligned,	/* length in words of text section */
      107 	2 def_offset bit(18) unaligned,	/* offset rel to base of object seg of base of definition section */
      108 	2 def_length bit(18) unaligned,	/* length in words of definition section */
      109 	2 link_offset bit(18) unaligned,	/* offset rel to base of object seg of base of linkage section */
      110 	2 link_length bit(18) unaligned,	/* length in words of linkage section */
      111 	2 symb_offset bit(18) unaligned,	/* offset rel to base of object seg of base of symbol section */
      112 	2 symb_length bit(18) unaligned,	/* length in words of symbol section */
      113 	2 bmap_offset bit(18) unaligned,	/* offset rel to base of object seg of base of break map */
      114 	2 bmap_length bit(18) unaligned;	/* length in words of break map */
      115 
      116 
      117 
      118 /*		INTERNAL  STATIC  DATA	*/
      119 
      120 /*	The following constants are used to restart a break that was set on an EIS type
      121**	instruction.  The transfer constant is a "tra" instruction which temporarily replaces
      122**	the instruction which follows the EIS instruction.  This "tra" transfers to the
      123**	first instruction in the break map header.  When  the break map header is created
      124**	the "tra" is saved in the break map header and its offset is relocated.
      125**	The following seven instructions in the break map header put the mme2 back into
      126**	the break location, replace the tra with the instruction that originally followed
      127**	the eis instruction, and returns control to the instruction after the eis instruction.
      128**/
      129 dcl	tra_con	bit(36)	internal static
      130 	init  (	"000000000000000000111001000000000000"b); /* 000000710000 tra eis.instructions */
      131 
      132 
      133 
      134 
      135 
      136 /*		EXTERNAL ENTRIES		*/
      137 
      138 dcl     (	addr, addrel, bit, divide, fixed, null, ptr, rel, size )  builtin;
      139 
      140 dcl	sys_info$page_size  fixed bin  external;
  1     1 /*	BEGIN INCLUDE FILE . . .  db_ext_stat_.incl.pl1
  1     2*   *
  1     3*   *	This include file is used to reference the common data  that is passed from the
  1     4*   *	main debug procedure  "debug" to other debug procedures.  This data is in db_ext_stat_.alm
  1     5*   *
  1     6*   *	modified 7/75 by S.E. Barr for the break instructions
  1     7**/
  1     8 
  1     9 dcl 1 db_ext_stat_$db_ext_stat_ ext static aligned,
  1    10 
  1    11     2 debug_input char (32) aligned,			/* Input switch name.  Initially "user_input" */
  1    12     2 debug_output char (32) aligned,			/* output switch name.  Initially "user_output" */
  1    13     2 return_label label,				/* The label used to do a non local goto out of debug when
  1    14*						   it was entered via a fault.  It will go to debug in
  1    15*						   another frame.  */
  1    16 
  1    17     2 debug_io_ptr (2) ptr,				/* pointers to iocb for i/o
  1    18*						   1 = input switch iocb ptr
  1    19*						   2 = output switch iocb ptr      */
  1    20     2 flags aligned,
  1    21       3 debug_io_attach (2) bit (1) unaligned,		/* 1= debug made the attachment */
  1    22       3 debug_io_open (2) bit (1) unaligned,		/* 1 = debug opened the switch */
  1    23       3 in_debug bit (1) unaligned,			/* Switch for the any_other condition.  0 = send the
  1    24*						   condition on;  1 = use the debug condition handler */
  1    25       3 static_handler_call bit (1) unal,		/* ON if mme2 call from static handler */
  1    26       3 pad bit (30) unaligned;			/* Reserved for future use */
  1    27 dcl  db_ext_stat_$break_instructions (9) bit (36) ext static aligned;
  1    28 
  1    29 /*	END OF INCLUDE FILE  ... db_ext_stat_.incl.pl1  */
      141 
      142 
      143 dcl	com_err_		     entry  options(variable),
      144 	get_group_id_	     entry  returns (char(32) aligned),
      145 	hcs_$add_acl_entries     entry  (char(*) aligned, char(*) aligned, ptr, fixed bin, fixed bin(35)),
      146 	hcs_$delete_acl_entries  entry  (char(*) aligned, char(*) aligned, ptr, fixed bin, fixed bin(35)),
      147 	hcs_$fs_get_mode	     entry  (ptr, fixed bin (5), fixed bin(35)),
      148 	hcs_$fs_get_path_name    entry  (ptr, char(*) aligned, fixed bin, char(*) aligned, fixed bin(35)),
      149 	hcs_$get_max_length_seg  entry (ptr, fixed bin(19), fixed bin(35)),
      150 	hcs_$set_bc_seg	     entry  (ptr, fixed bin(24), fixed bin(35)),
      151 	hcs_$truncate_seg	     entry  (ptr, fixed bin(19), fixed bin(35)),
      152 	ioa_$ioa_stream	     entry options (variable),
      153 	object_info_$brief	     entry  (ptr, fixed bin(24), ptr, fixed bin(35));
      154 /**/
  2     1 /* BEGIN INCLUDE FILE ... object_info.incl.pl1
  2     2*coded February 8, 1972 by Michael J. Spier	*/
  2     3 /* modified May 26, 1972 by M. Weaver */
  2     4 /* modified 15 April, 1975 by M. Weaver */
  2     5 
  2     6 declare	1 object_info aligned based,		/* structure containing object info based, returned by object_info_ */
  2     7 	2 version_number fixed bin,		/* version number of current structure format (=2) */
  2     8 	2 textp pointer,			/* pointer to beginning of text section */
  2     9 	2 defp pointer,			/* pointer to beginning of definition section */
  2    10 	2 linkp pointer,			/* pointer to beginning of linkage section */
  2    11 	2 statp pointer,			/* pointer to beginning of static section */
  2    12 	2 symbp pointer,			/* pointer to beginning of symbol section */
  2    13 	2 bmapp pointer,			/* pointer to beginning of break map (may be null) */
  2    14 	2 tlng fixed bin,			/* length in words of text section */
  2    15 	2 dlng fixed bin,			/* length in words of definition section */
  2    16 	2 llng fixed bin,			/* length in words of linkage section */
  2    17 	2 ilng fixed bin,			/* length in words of static section */
  2    18 	2 slng fixed bin,			/* length in words of symbol section */
  2    19 	2 blng fixed bin,			/* length in words of break map */
  2    20 	2 format,				/* word containing bit flags about object type */
  2    21 	  3 old_format bit(1) unaligned,	/* on if segment isn't in new format, i.e. has old style object map */
  2    22 	  3 bound bit(1) unaligned,		/* on if segment is bound */
  2    23 	  3 relocatable bit(1) unaligned,	/* on if seg has relocation info in its first symbol block */
  2    24 	  3 procedure bit(1) unaligned,	/* on if segment is an executable object program */
  2    25 	  3 standard bit(1) unaligned,	/* on if seg is in standard format (more than just standard map) */
  2    26 	  3 gate bit(1) unaligned,		/* on if segment is a gate */
  2    27 	  3 separate_static bit(1) unaligned,	/* on if static not in linkage */
  2    28 	  3 links_in_text bit(1) unaligned,	/* on if there are threaded links in text */
  2    29 	  3 perprocess_static bit (1) unaligned, /* on if static is not to be per run unit */
  2    30 	  3 pad bit(27) unaligned,
  2    31 	2 entry_bound fixed bin,		/* entry bound if segment is a gate */
  2    32 	2 textlinkp pointer,		/* ptr to first link in text */
  2    33 
  2    34 	/* LIMIT OF BRIEF STRUCTURE */
  2    35 
  2    36 	2 compiler char(8) aligned,		/* name of processor which generated segment */
  2    37 	2 compile_time fixed bin(71),		/* clock reading of date/time object was generated */
  2    38 	2 userid char(32) aligned,		/* standard Multics id of creator of object segment */
  2    39 	2 cvers aligned,			/* generator version name in printable char string form */
  2    40 	  3 offset bit(18) unaligned,		/* offset of name in words relative to base of symbol section */
  2    41 	  3 length bit(18) unaligned,		/* length of name in characters */
  2    42 	2 comment aligned,			/* printable comment concerning generator or generation of segment */
  2    43 	  3 offset bit(18) unaligned,		/* offset of comment in words relative to base of symbol section */
  2    44 	  3 length bit(18) unaligned,		/* length of comment in characters */
  2    45 	2 source_map fixed bin,		/* offset, relative to base of symbol section, of source map structure */
  2    46 
  2    47 	/* LIMIT OF DISPLAY STRUCTURE */
  2    48 
  2    49 	2 rel_text pointer,			/* pointer to text section relocation info */
  2    50 	2 rel_def pointer,			/* pointer to definition section relocation info */
  2    51 	2 rel_link pointer,			/* pointer to linkage section relocation info */
  2    52 	2 rel_static pointer,		/* pointer to static section relocation info */
  2    53 	2 rel_symbol pointer,		/* pointer to symbol section relocation info */
  2    54 	2 text_boundary fixed bin,		/* specifies mod  of text section base boundary */
  2    55 	2 static_boundary fixed bin,		/* specifies mod of internal static base boundary */
  2    56 					/* currently not used by system */
  2    57 	2 default_truncate fixed bin,		/* offset rel to symbp for binder to automatically trunc. symb sect. */
  2    58 	2 optional_truncate fixed bin;	/* offset rel to symbp for binder to optionally trunc. symb sect. */
  2    59 
  2    60 declare	object_info_version_2 fixed bin int static init(2);
  2    61 
  2    62 /* END INCLUDE FILE ... object_info.incl.pl1 */
      155 
  3     1 /* BEGIN INCLUDE FILE ... object_map.incl.pl1 */
  3     2 /* coded February 8, 1972 by Michael J. Spier */
  3     3 /* Last modified on 05/20/72 at 13:29:38 by R F Mabee. */
  3     4 /* Made to agree with Spier's document on 20 May 1972 by R F Mabee. */
  3     5 /* modified on 6 May 1972 by R F Mabee to add map_ptr at end of object map. */
  3     6 /* modified May, 1972 by M. Weaver */
  3     7 /* modified 5/75 by E. Wiatrowski and 6/75 by M. Weaver */
  3     8 /* modified 5/77 by M. Weaver to add perprocess_static bit */
  3     9 
  3    10  declare	1 object_map aligned based,		/* Structure describing standard object map */
  3    11 
  3    12 	  2 decl_vers fixed bin,		/* Version number of current structure format */
  3    13 	  2 identifier char (8) aligned,	/* Must be the constant "obj_map" */
  3    14 	  2 text_offset bit (18) unaligned,	/* Offset relative to base of object segment of base of text section */
  3    15 	  2 text_length bit (18) unaligned,	/* Length in words of text section */
  3    16 	  2 definition_offset bit (18) unaligned, /* Offset relative to base of object seg of base of definition section */
  3    17 	  2 definition_length bit (18) unaligned, /* Length in words of definition section */
  3    18 	  2 linkage_offset bit (18) unaligned,	/* Offset relative to base of object seg of base of linkage section */
  3    19 	  2 linkage_length bit (18) unaligned,	/* Length in words of linkage section */
  3    20 	  2 static_offset bit (18) unaligned,   /* Offset relative to base of obj seg of static section */
  3    21 	  2 static_length bit (18) unaligned,   /* Length in words of static section */
  3    22 	  2 symbol_offset bit (18) unaligned,	/* Offset relative to base of object seg of base of symbol section */
  3    23 	  2 symbol_length bit (18) unaligned,	/* Length in words of symbol section */
  3    24 	  2 break_map_offset bit (18) unaligned, /* Offset relative to base of object seg of base of break map */
  3    25 	  2 break_map_length bit (18) unaligned, /* Length in words of break map */
  3    26 	  2 entry_bound bit (18) unaligned,	/* Offset in text of last gate entry */
  3    27 	  2 text_link_offset bit (18) unaligned, /* Offset of first text-embedded link */
  3    28 	  2 format aligned,			/* Word containing bit flags about object type */
  3    29 	    3 bound bit (1) unaligned,	/* On if segment is bound */
  3    30 	    3 relocatable bit (1) unaligned,	/* On if segment has relocation info in its first symbol block */
  3    31 	    3 procedure bit (1) unaligned,	/* On if segment is an executable object program */
  3    32 	    3 standard bit (1) unaligned,	/* On if segment is in standard format (more than just standard map) */
  3    33 	    3 separate_static bit(1) unaligned, /* On if static is a separate section from linkage */
  3    34 	    3 links_in_text bit (1) unaligned,	/* On if there are text-embedded links */
  3    35 	    3 perprocess_static bit (1) unaligned, /* On if static is not to be per run unit */
  3    36 	    3 unused bit (29) unaligned;        /* Reserved */
  3    37 
  3    38 declare	map_ptr bit(18) aligned based;	/* Last word of the segment. It points to the base of the object map. */
  3    39 
  3    40 declare	object_map_version_2 fixed bin static init(2);
  3    41 
  3    42 /* END INCLUDE FILE ... object_map.incl.pl1 */
      156 
      157 /**/
  4     1 /* BEGIN INCLUDE SEGMENT ... obj_map.incl.pl1
  4     2*coded February 8, 1972 by Michael J. Spier	*/
  4     3 /* last modified May, 1972 by M. Weaver */
  4     4 
  4     5 declare	1 map aligned based(mapp),		/* structure describing standard object map */
  4     6 	2 decl_vers fixed bin,		/* version number of current structure format */
  4     7 	2 identifier char(8) aligned,		/* must be the constant "obj_map" */
  4     8 	2 text_offset bit(18) unaligned,	/* offset rel to base of object segment of base of text section */
  4     9 	2 text_length bit(18) unaligned,	/* length in words of text section */
  4    10 	2 def_offset bit(18) unaligned,	/* offset rel to base of object seg of base of definition section */
  4    11 	2 def_length bit(18) unaligned,	/* length in words of definition section */
  4    12 	2 link_offset bit(18) unaligned,	/* offset rel to base of object seg of base of linkage section */
  4    13 	2 link_length bit(18) unaligned,	/* length in words of linkage section */
  4    14 	2 symb_offset bit(18) unaligned,	/* offset rel to base of object seg of base of symbol section */
  4    15 	2 symb_length bit(18) unaligned,	/* length in words of symbol section */
  4    16 	2 bmap_offset bit(18) unaligned,	/* offset rel to base of object seg of base of break map */
  4    17 	2 bmap_length bit(18) unaligned,	/* length in words of break map */
  4    18 	2 format aligned,			/* word containing bit flags about object type */
  4    19 	  3 bound bit(1) unaligned,		/* on if segment is bound */
  4    20 	  3 relocatable bit(1) unaligned,	/* on if seg has relocation info in its first symbol block */
  4    21 	  3 procedure bit(1) unaligned,	/* on if segment is an executable object program */
  4    22 	  3 standard bit(1) unaligned,	/* on if seg is in standard format (more than just standard map) */
  4    23 	  3 unused bit(14) unaligned;		/* not currently used */
  4    24 
  4    25 /* END INCLUDE SEGMENT ... obj_map.incl.pl1 */
      158 
      159 /**/
  5     1 /*	BEGIN INCLUDE FILE ...  db_break_map_map.incl.pl1
  5     2**	Written  Dec 72  for the  6180  by  Bill Silver.
  5     3**	Changed  Feb 73  for eis restart by Bill Silver.
  5     4**
  5     5**	This include file contains the declaration for the debug break map.
  5     6**/
  5     7 
  5     8 dcl	break_map_ptr	ptr,		/* Pointer to break map       @                        £(HšÛ	ÍbYÎ        
j Z  $   ¶   ¶ Ä       @                                                                                                   = L          ‰]ƒš  ®                                                ¡Îâk     ¬  ™ÿ ø       ž &   H   ‚               &                        ,                              b                                                                                  £(Hšv          QÄŸæ         ¶  a          r     gctimm.list                         £E8            	È              $        ¶  a}o            £(Hš     ®         Ä*@          £E8     t           NMLPROD                             £(Hšœ       ¶  *@          £E8                 Fregonas                            £(Hš   t         SysDaemon                           £(Hš >          QÄ’¢         ¶  a          Ò ;    gcdela.f                            £E8O            
—              $        ¶  a mv            £(Hš               Ä*@          ¤`³    Ä       ¶  *À          ¤`³     Ò          RsLŽ         ¶  a           '    grdch2.unml                         ¤`¦            =              $        ¶  a ñB            £(Hš      €     Ä*@          £„Ë      J     Ä*@          £E2û    Æ          QÄ’ø         ¶  a          > *    gcgstl.unml                         £E8_            	Ó              $        ¶  a a'            £(Hš     l         Ä*@          £E8_    ì       ¶  *@          £E8_     Ä           STDSPPT                             £(Hš ¸          Qeò         ¶  a          ‚ b  dndpr.l6d                           £„Î                          $        ¶  a:Ý            £(Hš     °         Ä*@          £„Î     Þ       ¶  *@          £„Î    
          QeDh         ¶  a          ¸ 5    dnpcd.log                           £„            	.              $        t Äz m            £(Hš     æ         Ä*@          £„    0       ¶  *@          £„     r          QÄžz         ¶  a          î 5    laf                                 £E8‰             Ü              $        ¶  a               £(Hš             Ä*@          £E8‰     ˜       ¶  *@          £E8‰      Z  &£E2ûQÍE@   ,, ¶  a         $     dfpr3702                            £E2û        bY+               $  R 6 ¶  ae‚            £(Hš     6R     t*À          £E2û    J     ¶  *À          £E2û    $    &£„ËQÍE<   bb ¶  a         Z     dndpr                               £„Ë        Í!i	·              $  ˆ . ¶  a  q            £(Hš     .ˆ     t*À          £„Ë    €     ¶  *@          £„Ë     ‚          Qe z         ¶  a          )    dnpcd.l6d                           £„            ,              $        ¶  a ŒË            £(Hš    ¾         Ä*@          £„     ¨       ¶  *@          £„    Ô          QÄ’S         ¶  a         Æ     gcmsin.unml                         £E8e            3              $        ¶  a Òt            £(Hš    ô         Ä*@          £E8e    ú       ¶  *@          £E8e     î          QÄ¢Þ         ¶  a         ü &    gcgcom.unml                         £E8            	Ú              $        ¶  a ‹(            £(Hš    *         Ä*@          £E8           ¶  *@          £E8    ü          QÄ“          ¶  a         2     gcmstl.unml                         £E8b            
?              $        ¶  a ­»            £(Hš    `         Ä*@          £E8b    "       ¶  *@          £E8b                Q<ß¯         ¶ Äa         h 7,  urlst.ex.nml                        £sÇ1                          $        ¶ Äa ¸¯            £(Hš    –          *@          £sÇ1             ¶ Ä*@          £sÇ1               RsQ         ¶  a         ž (    gctimm.unml                         ¤`³                          $        ¶  a ñ            £(Hš    Ì         Ä*@          ¤`¦     d       ¶  *@          ¤`¦    2          QÄ’®         ¶  a         Ô /    gcmstk.unml                         £E8Z            |              $        ¶  a Þ¿            £(Hš             Ä*@          £E8Z    X       ¶  *À          £E8Z    @          Qe:         ¶  a         
 (    dndpr.log                           £„Ó                          $        t Äz  V            £(Hš    8         Ä*@          £„Ó    f       ¶  *@          £„Ó    h          Q<âs         ¶ Äa         @ 7,  urlst.ex.nml                        £sÇ:            I              $        ¶ Äa ¸¸            £(Hš    n          *@          £sÇ:    Ž       ¶ Ä*@          £sÇ:              QÄŸ†         ¶  a         v ; Ú  gctimm.ex.nml                       £E8Œ            
™              $        ¶  a VØ            £(Hš    ¤         Ä*@          £E8Œ    ¶       ¶  *@          £E8Œ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Tà/"¸Ù          abb01                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      TóÅŸÀa                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              pub_07                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  437**	map is now.
      438**/
      439 
      440 	obj_map_ptr  =  ptr(seg_ptr, end_ptr -> stand_obj_map_off);
      441 	if obj_map_ptr -> object_map.decl_vers = 1 then do;
      442 	     map_ver_1.bmap_offset,
      443 	     map_ver_1.bmap_length  =  "0"b;
      444 	end;
      445 
      446 	else do;
      447 	     obj_map_ptr -> object_map.break_map_offset = "0"b;
      448 	     obj_map_ptr -> object_map.break_map_length = "0"b;
      449 	end;
      450 
      451 	break_map_ptr -> stand_obj_map_off  =  end_ptr -> stand_obj_map_off;
      452 
      453 
      454 /*	Now that we have correctly rearrainged the segment we can reset the bit count
      455**	and truncate the unused portion of the segment.
      456**/
      457 	bit_count  =  bit_count  -  new_bits;
      458 	call hcs_$set_bc_seg (seg_ptr, bit_count, code);
      459 	if   code ^= 0
      460 	     then goto ERROR;
      461 
      462 	word_count=  divide(bit_count+35, 36, 17, 0);
      463 	call hcs_$truncate_seg(seg_ptr, word_count, code);
      464 	if   code ^= 0
      465 	     then goto ERROR;
      466 
      467 
      468 /*	Now all we have to do is reset that  ACL  entry that we added (possibly)
      469**	when the beak map was created.
      470**/
      471 	call hcs_$fs_get_path_name (seg_ptr, dir_name, (0), ent_name, code);
      472 	if   code ^= 0
      473 	     then goto ERROR;
      474 
      475 	delete_acl.user_id  =  get_group_id_();
      476 	call hcs_$delete_acl_entries (dir_name, ent_name, addr(delete_acl), 1, code);
      477 
      478 
      479 	return;			/* End of the  delete  entry.  */
      480 /**/
      481 CHECK_MAP:	procedure;
      482 
      483 dcl  probe (3) char(4) based (arg_break_map_ptr);		/* (2,3) = "breakmap" in a probe break map  */
      484 
      485 
      486 /*  This procedure initializes some variables and then checks to see if we have a
      487**  break map in this segment.  The break map pointer (either valid or null) will
      488**  br put in  arg_break_map_ptr.
      489**/
      490 
      491 	seg_ptr  =  ptr(arg_seg_ptr, 0);		/* Get pointer to the base of segment. */
      492 	bit_count  =  arg_bit_count;			/* Copy argument. */
      493 
      494 
      495 /*  Get some info about this segment.  This will tell us whether there is a
      496**  break map or not.  
      497**/
      498 	oi.version_number = object_info_version_2;
      499 	call object_info_$brief (seg_ptr, bit_count, addr(oi), code);
      500 	if   code ^= 0
      501 	     then goto ERROR;
      502 
      503 	if oi.old_format then goto ERROR_OLD_FORMAT;
      504 
      505 	arg_break_map_ptr  =  oi.bmapp;		/* Get break map pointer. */
      506 
      507 /*  The 2-3 words of a probe break map are "breakmap".  The probe and debug break maps are not compatible */
      508 
      509 	if arg_break_map_ptr ^= null then if probe (2) = "brea" then do;
      510 	     call ioa_$ioa_stream (debug_output, "probe breaks are still set in this segment");
      511 	     arg_break_map_ptr = null();
      512 	     goto ERROR;
      513 	end;
      514 
      515 /* Convert from version 2 to version 3 break map */
      516 
      517 	if   arg_break_map_ptr ^= null() then do;
      518 	     break_map_ptr = arg_break_map_ptr;
      519 	     if bmap.version = "ver2" then do;
      520 		bmap.version = "ver3";
      521 		do i = 1 to 9;
      522 		     bmap.instructions (i) = db_ext_stat_$break_instructions (i);
      523 		end;
      524 	     end;
      525 	     return;
      526 	end;
      527 
      528 	end  CHECK_MAP;
      529 /**/
      530 CHECK_ACCESS:	procedure;
      531 
      532 
      533 /*	This procedure is called to check that this segment has write access.  Since
      534**	we must write into the break map this is necessary.  If we don't have  W  access
      535**	we will try to add ourselves to the  ACL of the segment and thus give ourselves
      536**	W  access.
      537**/
      538 
      539 	call hcs_$fs_get_mode (seg_ptr, access_mode, code);
      540 	if   code ^= 0
      541 	     then goto ERROR;
      542 
      543 	if   (bit(access_mode,5) & ("00010"b))  ^=  "00000"b
      544 	     then return;			/* YES, we do have  W  access.  */
      545 
      546 
      547 /*	NO, we don't have write access.  The  W  bit is off.  We will get the path name
      548**	of the segment and the validation level and we will try to add ourselves to the
      549**	ACL of the segment.  Note we will be added under the  group_id  name  and with
      550**	REWA access.  
      551**/
      552 	call hcs_$fs_get_path_name (seg_ptr, dir_name, (0), ent_name, code);
      553 	if   code ^= 0
      554 	     then goto ERROR;
      555 
      556 	seg_acl.user_id = get_group_id_();
      557 	seg_acl.access = "1111"b;
      558 	seg_acl.pad = "0"b;
      559 
      560 	call hcs_$add_acl_entries (dir_name, ent_name, addr(seg_acl), 1, code);
      561 	if   code ^= 0
      562 	     then goto ERROR;
      563 
      564 
      565 	end  CHECK_ACCESS;
      566 /**/
      567 /*	This is the location transfered to when any error occurs due to a call to one
      568**	of the system procedures.  This is part of the main block of  db_break_map  so
      569**	when it is called by an internal procedure control will be returned directly
      570**	to the caller of  db_break_map.  Note, regardless of the error,  we will
      571**	return a null  break map pointer.
      572**/
      573 
      574 ERROR:
      575 	arg_break_map_ptr  =  null();
      576 
      577 	call com_err_(code, "debug", "Error in  db_break_map.  ");
      578 	return;
      579 
      580 ERROR_OLD_FORMAT:
      581 
      582 	call com_err_ (0, "debug", "Version 1 object segments are not supported by debug");
      583 	arg_seg_ptr = null;
      584 
      585 	return;
      586 
      587 
      588 	end  db_break_map;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/04/82  1609.4  db_break_map.pl1                  >dumps>old>recomp>db_break_map.pl1
141          1    08/12/76  1010.2  db_ext_stat_.incl.pl1             >ldd>include>db_ext_stat_.incl.pl1
155          2    08/05/77  1022.5  object_info.incl.pl1              >ldd>include>object_info.incl.pl1
156          3    08/05/77  1022.5  object_map.incl.pl1               >ldd>include>object_map.incl.pl1
158          4    07/25/75  1334.6  obj_map_old_1_.incl.pl1           >ldd>include>obj_map_old_1_.incl.pl1
160          5    11/06/75  1110.0  db_break_map_map.incl.pl1         >ldd>include>db_break_map_map.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
access                   10     000207 automatic       bit(36)                  level 2 dcl 73 set ref 557*
access_mode                     000100 automatic       fixed bin(5,0)           dcl 46 set ref 539* 543
addr                                                   builtin function         dcl 138 ref 271 271 279 325 325 373 421 421 476 476
                                                                                  499 499 560 560
addrel                                                 builtin function         dcl 138 ref 239 358
arg_bit_count                          parameter       fixed bin(24,0)          dcl 36 ref 162 382 492
arg_break_map_ptr                      parameter       pointer                  dcl 36 set ref 162 179 282* 286 296 314* 382 395 405
                                                                                  416 505* 509 509 511* 517 518 574*
arg_seg_ptr                            parameter       pointer                  dcl 36 set ref 162 382 491 583*
based_inst                             based           structure                level 1 dcl 91
bit                                                    builtin function         dcl 138 ref 248 252 351 355 543
bit_count                 2            based           fixed bin(24,0)          level 2 in structure "bmap" dcl 5-17 in procedure
                                                                                  "db_break_map" set ref 267* 297 370* 417
bit_count                       000101 automatic       fixed bin(24,0)          dcl 46 in procedure "db_break_map" set ref 187 188
                                                                                  229 260* 260 261* 267 297* 303 325* 331 339 366*
                                                                                  366 367* 370 417* 421* 431 457* 457 458* 462 492*
                                                                                  499*
bits_left                       000102 automatic       fixed bin(17,0)          dcl 46 set ref 188* 189 209* 209 214 214* 214 221
                                                                                  331* 336
blng                     23     000234 automatic       fixed bin(17,0)          level 2 dcl 82 set ref 432
bmap                                   based           structure                level 1 dcl 5-17 set ref 189 209 222
bmap_length               7(18)        based           bit(18)                  level 2 packed unaligned dcl 102 set ref 248* 351*
                                                                                  351 442*
bmap_offset               7            based           bit(18)                  level 2 packed unaligned dcl 102 set ref 247* 442*
bmapp                    14     000234 automatic       pointer                  level 2 dcl 82 set ref 505
break_map_length         10(18)        based           bit(18)                  level 2 packed unaligned dcl 3-10 set ref 252* 355*
                                                                                  355 448*
break_map_offset         10            based           bit(18)                  level 2 packed unaligned dcl 3-10 set ref 251* 447*
break_map_ptr                   000322 automatic       pointer                  dcl 5-8 set ref 189 209 222 237* 239 244 247 251 265
                                                                                  266 267 268 270 271 271 272 272 275 279 282 296*
                                                                                  297 305 370 372 372 373 373 378 378 416* 417 418
                                                                                  451 518* 519 520 522
break_slot                             based           structure                level 1 dcl 5-35 set ref 189 189 209 214 221 222 222
                                                                                  279 279 336 337 373 373
break_slot_ptr                  000324 automatic       pointer                  dcl 5-8 set ref 189 189 209 214 221 222 222 279 279
                                                                                  336 337 373* 373 373 375
breaks                   40            based           structure                array level 2 dcl 5-17 set ref 279 373
code                            000103 automatic       fixed bin(35,0)          dcl 46 set ref 191* 192 261* 262 307* 308 325* 326
                                                                                  367* 368 392 399 421* 422 458* 459 463* 464 471*
                                                                                  472 476* 499* 500 539* 540 552* 553 560* 561 577*
com_err_                        000016 constant        entry                    external dcl 143 ref 577 580
db_ext_stat_$break_instructions 000014 external static bit(36)                  array dcl 1-27 ref 275 522
db_ext_stat_$db_ext_stat_       000012 external static structure                level 1 dcl 1-9
debug_output             10     000012 external static char(32)                 level 2 dcl 1-9 set ref 198* 510*
decl_vers                              based           fixed bin(17,0)          level 2 dcl 3-10 ref 246 351 441
delete_acl                      000222 automatic       structure                level 1 dcl 79 set ref 476 476
dir_name                        000104 automatic       char(168)                dcl 46 set ref 471* 476* 552* 560*
divide                                                 builtin function         dcl 138 ref 187 195 221 229 303 311 336 339 431 462
eis                       4            based           structure                level 2 dcl 5-17
end_ptr                         000166 automatic       pointer                  dcl 46 set ref 229* 237 238 238 239* 244 339* 350
                                                                                  350 358 358 431* 440 451
ent_name                        000156 automatic       char(32)                 dcl 46 set ref 471* 476* 552* 560*
fixed                                                  builtin function         dcl 138 ref 248 252 351 351 355 355
format                   24     000234 automatic       structure                level 2 packed unaligned dcl 82
get_group_id_                   000020 constant        entry                    external dcl 143 ref 475 556
hcs_$add_acl_entries            000022 constant        entry                    external dcl 143 ref 560
hcs_$delete_acl_entries         000024 constant        entry                    external dcl 143 ref 476
hcs_$fs_get_mode                000026 constant        entry                    external dcl 143 ref 539
hcs_$fs_get_path_name           000030 constant        entry                    external dcl 143 ref 471 552
hcs_$get_max_length_seg         000032 constant        entry                    external dcl 143 ref 191 307
hcs_$set_bc_seg                 000034 constant        entry                    external dcl 143 ref 261 367 458
hcs_$truncate_seg               000036 constant        entry                    external dcl 143 ref 463
i                               000170 automatic       fixed bin(17,0)          dcl 46 set ref 274* 275 275* 278* 279* 372* 373*
                                                                                  521* 522 522*
inst_indw                17            based           bit(18)                  level 3 dcl 5-17 set ref 272*
instructions              5            based           bit(36)                  array level 3 dcl 5-17 set ref 271 275* 522*
ioa_$ioa_stream                 000040 constant        entry                    external dcl 143 ref 198 510
map_ver_1                              based           structure                level 1 dcl 102
max_length                      000171 automatic       fixed bin(19,0)          dcl 46 set ref 191* 195 307* 311
max_num_pages                   000172 automatic       fixed bin(17,0)          dcl 46 set ref 195* 196 311* 312
mme2_indw                16            based           bit(18)                  level 3 dcl 5-17 set ref 272*
new_bits                        000173 automatic       fixed bin(24,0)          dcl 46 set ref 223* 260 338* 366 432* 457
new_slots                       000174 automatic       fixed bin(17,0)          dcl 46 set ref 221* 222 265 278 336* 337 372 378
new_words                       000175 automatic       fixed bin(18,0)          dcl 46 set ref 222* 223 239 248 252 337* 338 351 355
                                                                                  358
null                                                   builtin function         dcl 138 ref 179 314 395 509 511 517 574 583
num_set                   1            based           fixed bin(17,0)          level 2 dcl 5-17 set ref 266*
num_slots                              based           fixed bin(17,0)          level 2 dcl 5-17 set ref 265* 372 372 378* 378
obj_map_ptr                     000176 automatic       pointer                  dcl 46 set ref 238* 246 247 248 251 252 350* 351 351
                                                                                  351 355 355 440* 441 442 442 447 448
object_info                            based           structure                level 1 dcl 2-6
object_info_$brief              000042 constant        entry                    external dcl 143 ref 325 421 499
object_info_version_2                  constant        fixed bin(17,0)          initial dcl 2-60 ref 324 420 4                Tß„æ          rpv                                root_01                            root_02                            root_03                            root_04                            tr01                               bull01                             bull02                             bull03                             bull04                             bull05                             pub_01                             pub_02                             pub_03                             pub_04                             pub_05                             pub_06                             pub_07                             pub_08                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              dcl 46
ns_obj_map_off                         based           fixed bin(18,0)          dcl 98
object_map_version_2                   internal static fixed bin(17,0)          initial dcl 3-40
old_bmap                               based           structure                level 1 dcl 5-12

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_ACCESS                    001361 constant        entry                    internal dcl 530 ref 177 398
CHECK_MAP                       001232 constant        entry                    internal dcl 481 ref 175 391
ERROR                           001146 constant        label                    dcl 574 ref 192 262 308 326 368 392 399 422 459 464
                                                                                  472 500 512 540 553 561
ERROR_OLD_FORMAT                001177 constant        label                    dcl 580 ref 329 425 503
check                           000660 constant        entry                    external dcl 382
db_break_map                    000072 constant        entry                    external dcl 12
delete                          000705 constant        entry                    external dcl 405
get_slots                       000411 constant        entry                    external dcl 286
init                            000104 constant        entry                    external dcl 162

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1740        2004    1514        1750
Length      2310    1514        44         270     224           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
db_break_map                        344 external procedure  is an external procedure.  
CHECK_MAP                               internal procedure  shares stack frame of external procedure db_break_map.  
CHECK_ACCESS                            internal procedure  shares stack frame of external procedure db_break_map.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
db_break_map             000100 access_mode                 db_break_map
                         000101 bit_count                   db_break_map
                         000102 bits_left                   db_break_map
                         000103 code                        db_break_map
                         000104 dir_name                    db_break_map
                         000156 ent_name                    db_break_map
                         000166 end_ptr                     db_break_map
                         000170 i                           db_break_map
                         000171 max_length                  db_break_map
                         000172 max_num_pages               db_break_map
                         000173 new_bits                    db_break_map
                         000174 new_slots                   db_break_map
                         000175 new_words                   db_break_map
                         000176 obj_map_ptr                 db_break_map
                         000200 page_bits                   db_break_map
                         000201 page_num                    db_break_map
                         000202 page_words                  db_break_map
                         000204 seg_ptr                     db_break_map
                         000206 word_count                  db_break_map
                         000207 seg_acl                     db_break_map
                         000222 delete_acl                  db_break_map
                         000234 oi                          db_break_map
                         000322 break_map_ptr               db_break_map
                         000324 break_slot_ptr              db_break_map

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      get_group_id_                 hcs_$add_acl_entries          hcs_$delete_acl_entries
hcs_$fs_get_mode              hcs_$fs_get_path_name         hcs_$get_max_length_seg       hcs_$set_bc_seg
hcs_$truncate_seg             ioa_$ioa_stream               object_info_$brief

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
db_ext_stat_$break_instructions                             db_ext_stat_$db_ext_stat_     sys_info$page_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     12 000071       162 000077       175 000114       177 000115       179 000116       185 000122       186 000125
    187 000127       188 000133       189 000143       191 000151       192 000163       195 000165       196 000172
    198 000174       199 000220       209 000221       214 000230       221 000236       222 000241       223 000244
    229 000246       237 000254       238 000255       239 000261       244 000265       246 000267       247 000272
    248 000275       249 000302       251 000303       252 000306       260 000313       261 000315       262 000330
    265 000332       266 000334       267 000336       268 000340       270 000342       271 000344       272 000347
    274 000351       275 000356       276 000363       278 000365       279 000374       280 000401       282 000403
    284 000405       286 000406       296 000421       297 000424       298 000426       299 000431       303 000433
    305 000437       307 000441       308 000453       311 000455       312 000462       314 000464       315 000466
    324 000467       325 000471       326 000510       329 000512       331 000515       336 000527       337 000534
    338 000536       339 000540       350 000546       351 000552       355 000567       358 000600       366 000605
    367 000607       368 000622       370 000624       372 000627       373 000640       375 000647       376 000651
    378 000653       380 000655       382 000656       391 000670       392 000671       395 000673       398 000677
    399 000700       403 000702       405 000703       416 000715       417 000720       418 000722       420 000724
    421 000726       422 000745       425 000747       431 000752       432 000760       440 000763       441 000767
    442 000772       444 000776       447 000777       448 001001       451 001003       457 001005       458 001007
    459 001022       462 001024       463 001030       464 001043       471 001045       472 001077       475 001101
    476 001110       479 001145       574 001146       577 001150       578 001176       580 001177       583 001226
    585 001231       481 001232       491 001233       492 001237       498 001241       499 001243       500 001262
    503 001264       505 001267       509 001271       510 001303       511 001324       512 001326       517 001327
    518 001333       519 001336       520 001341       521 001343       522 001350       523 001355       525 001357
    528 001360       530 001361       539 001362       540 001375       543 001377       552 001406       553 001440
    556 001442       557 001451       558 001453       560 001454       561 001511       565 001513


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
