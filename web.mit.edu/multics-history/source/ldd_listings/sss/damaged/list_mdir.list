THIS FILE IS DAMAGED

	COMPILATION LISTING OF SEGMENT list_mdir
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/19/84  1008.1 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 /* format: style2,indcomtxt */
       11 /* LIST_MDIR: Command for listing master directory information */
       12 
       13 /* Written May 1976 by Larry Johnson */
       14 /* Modified September 1977 by Larry Johnson to fix some bugs */
       15 /* Modified 83-12-07 BIM for quota precisions */
       16 
       17 list_mdir:
       18 lmd:
       19      procedure options (variable);
       20 
       21 	dcl     name		 char (9) int static options (constant) init ("list_mdir");
       22 	dcl     code		 fixed bin (35);
       23 	dcl     ptr_array		 (1) ptr init (null);
       24 						/* Used by get_temp_segments_ */
       25 	dcl     acct		 char (32);	/* Name of a user or quota account */
       26 	dcl     quota_sum		 fixed bin (35) init (0);
       27 						/* Total quota chaged to users account */
       28 	dcl     quota_other		 fixed bin (35) init (0);
       29 						/* Total quota charged to other accounts */
       30 	dcl     quota_total		 fixed bin (35) init (0);
       31 						/* Total for all directories */
       32 	dcl     max_dir_name_len	 fixed bin;
       33 	dcl     max_account_len	 fixed bin;
       34 	dcl     max_owner_len	 fixed bin;
       35 	dcl     entry_name		 entry variable;
       36 
       37 	dcl     quota_sw		 bit (1) init ("0"b);
       38 						/* Set if -quota used */
       39 	dcl     dir_sw		 bit (1) init ("0"b);
       40 						/* Set if -dr used  */
       41 	dcl     brief_sw		 bit (1) init ("0"b);
       42 						/* Set if -brief used */
       43 	dcl     long_sw		 bit (1) init ("0"b);
       44 						/* Set if -long used */
       45 	dcl     all_sw		 bit (1) init ("0"b);
       46 						/* Set if -all used */
       47 	dcl     restrict_sw		 bit (1) init ("0"b);
       48 						/* Set if -restrict used */
       49 	dcl     account_sw		 bit (1) init ("0"b);
       50 						/* Set if -account used */
       51 	dcl     owner_sw		 bit (1) init ("0"b);
       52 						/* Set if -owner used */
       53 	dcl     volume		 char (32);	/* Logical volume name */
       54 
       55 	dcl     arg_no		 fixed bin init (1);/* Current argument being processed */
       56 	dcl     nargs		 fixed bin;	/* Argument count */
       57 	dcl     arg_ptr		 ptr;
       58 	dcl     arg_len		 fixed bin;
       59 	dcl     arg		 char (arg_len) based (arg_ptr);
       60 	dcl     arg_list_ptr	 ptr;		/* Pointer to argument list */
       61 	dcl     more_args		 bit (1) init ("0"b);
       62 						/* Set while args remain to process */
       63 
       64 	dcl     list_length		 fixed bin int static options (constant) init (256);
       65 						/*  length of allocated arrays */
       66 	dcl     1 based_list	 aligned based,	/* Model list */
       67 		2 name		 (list_length) aligned,
       68 		  3 person	 char (22) unal,
       69 		  3 project	 char (9) unal;
       70 
       71 	dcl     owner_listl		 fixed bin init (0);/* Number of entries in list */
       72 	dcl     account_listl	 fixed bin init (0);/* Number of entries in list */
       73 	dcl     work_seg_ptr	 ptr;
       74 
       75 	dcl     1 work_seg		 aligned based (work_seg_ptr),
       76 		2 owner_list	 like based_list aligned,
       77 		2 account_list	 like based_list aligned,
       78 		2 rest_of_seg	 bit (36) aligned;
       79 
       80 	dcl     1 auto_msargs	 aligned automatic like msargs;
       81 
       82 
       83 /* External stuff */
       84 
       85 	dcl     com_err_		 entry options (variable);
       86 	dcl     cu_$arg_count	 entry (fixed bin);
       87 	dcl     cu_$arg_ptr_rel	 entry (fixed bin, ptr, fixed bin, fixed bin (35), ptr);
       88 	dcl     cu_$arg_list_ptr	 entry (ptr);
       89 	dcl     get_temp_segments_	 entry (char (*), dim (*) ptr, fixed bin (35));
       90 	dcl     release_temp_segments_ entry (char (*), dim (*) ptr, fixed bin (35));
       91 	dcl     ioa_		 entry options (variable);
       92 	dcl     mdc_$status		 entry (char (*), ptr, ptr, fixed bin (35));
       93 	dcl     convert_status_code_	 entry (fixed bin (35), char (8) aligned, char (100) aligned);
       94 
       95 	dcl     error_table_$badopt	 ext fixed bin (35);
       96 	dcl     error_table_$mdc_illegal_account
       97 				 ext fixed bin (35);
       98 	dcl     error_table_$bad_uidpath
       99 				 ext fixed bin (35);
      100 	dcl     sys_info$max_seg_size	 ext fixed bin (19);
      101 
      102 	dcl     (addr, index, length, rtrim, string, verify, null, substr, bin, rel, max)
      103 				 builtin;
      104 
      105 	dcl     cleanup		 condition;
      106 
  1     1 /* Begin include file ..... mdc_status_args.incl.pl1 */
  1     2 
  1     3 /* This include file defines the param structure used to call mdc_$status */
  1     4 
  1     5 /* Written April 1976 by Larry Johnson */
  1     6 
  1     7 dcl  argp ptr;
  1     8 
  1     9 dcl 1 msargs aligned based (argp),
  1    10     2 version fixed bin,
  1    11     2 output_size fixed bin (19),			/* Number of words in output area */
  1    12     2 flags,
  1    13       3 exec bit (1) unal,				/* Set if user wants to exercixe exec access */
  1    14       3 dirs bit (1) unal,				/* Set if user wants info in directories returned */
  1    15       3 account bit (1) unal,				/* Set is user has passed a list of accounts (exec only) */
  1    16       3 owner bit (1) unal,				/* Set if user has passed a list of owners (exec only) */
  1    17       3 backup bit (1) unal,				/* Set if backup data wanted (exec only) */
  1    18       3 restrict bit (1) unal,			/* Set if caller wants restricting paths returnd */
  1    19       3 accounting bit (1) unal,			/* Set if caller wants accounting data */
  1    20       3 fill bit (29) unal,
  1    21     2 nnames fixed bin,				/* Number of names passed (if account or owner set) */
  1    22     2 namesp ptr,					/* Pointer to the names */
  1    23     2 output_ptr ptr;				/* Pointer to place for results */
  1    24 
  1    25 /* End include file ..... mdc_status_args.incl.pl1 */
      107 
      108 
  2     1 /* Begin include file ..... mdc_status_info.incl.pl1 */
  2     2 
  2     3 /* This include file defines the format of data returned by mdc_$status operations. */
  2     4 
  2     5 /* Coded April 1976 by Larry Johnson */
  2     6 /* Modified 83-12-07 BIM for correct quota precisions */
  2     7 
  2     8 dcl  volume_datap ptr;
  2     9 
  2    10 dcl 1 volume_data aligned based (volume_datap),
  2    11     2 version fixed bin,
  2    12     2 accountp ptr,					/* Pointer to first account_data entry returned */
  2    13     2 ownerp ptr,					/* Pointer to list of owner_data entries */
  2    14     2 restrictp ptr,				/* Pointer to list of path restrictions */
  2    15     2 defaultp ptr,					/* Pointer to list of path defaults */
  2    16     2 backup (3) fixed bin (35);			/* Data for backup accounting */
  2    17 
  2    18 dcl  account_datap ptr;
  2    19 
  2    20 dcl 1 account_data aligned based (account_datap),		/* Structure returned for each quota account */
  2    21     2 next ptr,					/* Pointer to next one */
  2    22     2 name,					/* Name of account */
  2    23       3 person char (22) unal,
  2    24       3 project char (9) unal,
  2    25     2 quota fixed bin (35),				/* Total quota available to account */
  2    26     2 quota_used fixed bin (35),			/* Total used currently */
  2    27     2 trp fixed bin (71),				/* Time-record prodecut of deleted directories */
  2    28     2 backup (3) fixed bin (35),			/* Backup account data */
  2    29     2 dirp ptr,					/* Pointer to first directory charaged agains account */
  2    30     2 restrictp ptr;				/* Pointer to pathame restriction list */
  2    31 
  2    32 dcl  dir_datap ptr;
  2    33 
  2    34 dcl 1 dir_data aligned based (dir_datap),		/* Structure allocated for each master directory */
  2    35     2 next ptr,					/* Pointer to next one */
  2    36     2 pathp ptr,					/* Pointer to pathane entry */
  2    37     2 name,
  2    38       3 person char (22) unal,
  2    39       3 project char (9) unal,
  2    40     2 quota fixed bin (18),				/* Quota allocated to directory */
  2    41     2 backup (3) fixed bin (35);			/* Backup account data */
  2    42 
  2    43 dcl  owner_datap ptr;
  2    44 
  2    45 dcl 1 owner_data aligned based (owner_datap),		/* Structure allocated for each master dir owner */
  2    46     2 next ptr,
  2    47     2 name,					/* Owner name */
  2    48       3 person char (22) unal,
  2    49       3 project char (9) unal,
  2    50     2 dirp ptr;					/* Pointer to list of owners dirs */
  2    51 
  2    52 dcl  path_datap ptr;
  2    53 
  2    54 dcl 1 path_data aligned based (path_datap),		/* One of these is allocated for each pathname */
  2    55     2 next ptr,
  2    56     2 code fixed bin (35),				/* Status code from decoding pathname */
  2    57     2 dir char (168) unal,
  2    58     2 ename char (32) unal;
  2    59 
  2    60 /* End include file ..... mdc_status_info.incl.pl1 */
      109 
      110 
      111 /* Command starts here */
      112 
      113 	call cu_$arg_count (nargs);			/* See if any args */
      114 	if nargs = 0
      115 	then do;					/* None */
      116 		call com_err_ (0, name, "Usage: ^a volume -control_args-", name);
      117 		return;
      118 	     end;
      119 
      120 	call cu_$arg_list_ptr (arg_list_ptr);
      121 
      122 	on cleanup call clean_up;
      123 
      124 	call get_work_seg;				/* This allocates a work area */
      125 
      126 	call scan_args;				/* Process the argument list */
      127 
      128 	call make_call;				/* Call mdc_ for data */
      129 
      130 	call print_results;				/* This does all the work */
      131 
      132 done:
      133 	call clean_up;
      134 
      135 	return;
      136 
      137 
      138 /* Procedure that allocates a temp segment for a work area */
      139 
      140 get_work_seg:
      141      proc;
      142 
      143 	call get_temp_segments_ (name, ptr_array, code);
      144 	if code ^= 0
      145 	then do;
      146 		call com_err_ (code, name, "Allocating temp segment");
      147 		go to done;
      148 	     end;
      149 
      150 	work_seg_ptr = ptr_array (1);
      151 	return;
      152 
      153      end get_work_seg;
      154 
      155 /* Procedure to process the argument list */
      156 
      157 scan_args:
      158      proc;
      159 
      160 	call get_arg;				/* Get first argument */
      161 	volume = arg;				/* Which is volume name */
      162 
      163 	do while (more_args);			/* Now check for control arguments */
      164 	     call get_arg;
      165 	     if arg = "-quota"
      166 	     then quota_sw = "1"b;
      167 	     else if arg = "-directory" | arg = "-dr"
      168 	     then dir_sw = "1"b;
      169 	     else if arg = "-brief" | arg = "-bf"
      170 	     then brief_sw = "1"b;
      171 	     else if arg = "-long" | arg = "-lg"
      172 	     then long_sw = "1"b;
      173 	     else if arg = "-all" | arg = "-a"
      174 	     then all_sw = "1"b;
      175 	     else if arg = "-restrict"
      176 	     then restrict_sw = "1"b;
      177 	     else if arg = "-owner"
      178 	     then do;
      179 		     call build_list (addr (owner_list), owner_listl);
      180 		     owner_sw = "1"b;
      181 		end;
      182 	     else if arg = "-account"
      183 	     then do;
      184 		     call build_list (addr (account_list), account_listl);
      185 		     account_sw = "1"b;
      186 		end;
      187 	     else do;
      188 		     call com_err_ (error_table_$badopt, name, "^a", arg);
      189 		     go to done;
      190 		end;
      191 	end;
      192 	if ^(quota_sw | dir_sw)
      193 	then quota_sw, dir_sw = "1"b;
      194 	if all_sw & ^owner_sw
      195 	then account_sw = "1"b;
      196 	return;
      197 
      198      end scan_args;
      199 
      200 
      201 /* Procedure to get the next argument from the command line */
      202 
      203 get_arg:
      204      proc;
      205 
      206 	call cu_$arg_ptr_rel (arg_no, arg_ptr, arg_len, code, arg_list_ptr);
      207 	if code ^= 0
      208 	then do;					/* This is a programming error */
      209 		call com_err_ (code, name, "Arg ^d.", arg_no);
      210 		go to done;
      211 	     end;
      212 
      213 	arg_no = arg_no + 1;
      214 	more_args = (arg_no <= nargs);
      215 
      216 	return;
      217 
      218 put_arg:
      219      entry;					/* Entry to "return" an arg if too many checked */
      220 
      221 	arg_no = arg_no - 1;
      222 	more_args = (arg_no <= nargs);
      223 	return;
      224 
      225      end get_arg;
      226 
      227 /* Procedure to build a list of account names */
      228 
      229 build_list:
      230      proc (p, n);
      231 
      232 	dcl     p			 ptr;		/* Pointer to list */
      233 	dcl     n			 fixed bin;	/* Current length of list */
      234 	dcl     arg_name		 char (16);	/* For error messages */
      235 
      236 	arg_name = arg;				/* Save control arg name */
      237 	do while (more_args);			/* Scan for elements */
      238 	     call get_arg;
      239 	     if substr (arg, 1, 1) = "-"
      240 	     then do;				/* Control arg found, scanned too far */
      241 		     call put_arg;			/* Back up over control arg */
      242 		     return;
      243 		end;
      244 	     if n = list_length
      245 	     then do;				/* Too many ags */
      246 		     call com_err_ (0, name, "Too many arguments after ^a.", arg_name);
      247 		     go to done;
      248 		end;
      249 
      250 	     n = n + 1;
      251 	     call parse_acct (p, n);
      252 	end;
      253 
      254 	return;
      255 
      256      end build_list;
      257 
      258 /* Procedure to parse an account name into components */
      259 
      260 parse_acct:
      261      proc (p, n);
      262 
      263 	dcl     p			 ptr;		/* Pointer to list to store result */
      264 	dcl     n			 fixed bin;	/* Position in list */
      265 
      266 	dcl     person		 char (22);
      267 	dcl     project		 char (9);
      268 	dcl     tag		 char (1);
      269 	dcl     i			 fixed bin;
      270 
      271 	if arg_len > length (acct)
      272 	then /* Check for argument too long */
      273 	     if substr (arg, length (acct) + 1) ^= ""
      274 	     then do;
      275 bad_acct:
      276 		     call com_err_ (error_table_$mdc_illegal_account, name, "^a", arg);
      277 		     go to done;
      278 		end;
      279 
      280 	acct = arg;
      281 	i = index (acct, " ");			/* Check for imbedded blanks */
      282 	if i > 0
      283 	then if substr (acct, i) ^= " "
      284 	     then go to bad_acct;
      285 
      286 	call parse_acct_comp (person);		/* Strip off person */
      287 	if code ^= 0
      288 	then go to bad_acct;
      289 	call parse_acct_comp (project);		/* Strip off project */
      290 	if code ^= 0
      291 	then go to bad_acct;
      292 	call parse_acct_comp (tag);			/* And the tag */
      293 	if code ^= 0
      294 	then go to bad_acct;
      295 
      296 	if acct ^= ""
      297 	then go to bad_acct;			/* Should not be any thing left */
      298 
      299 	p -> based_list.person (n) = person;		/* Store result */
      300 	p -> based_list.project (n) = project;
      301 	return;
      302 
      303      end parse_acct;
      304 
      305 /* Internal procedure that strips the next component off the input string */
      306 
      307 parse_acct_comp:
      308      proc (s);
      309 
      310 	dcl     s			 char (*);
      311 	dcl     i			 fixed bin;
      312 
      313 	code = 0;
      314 	if acct = ""
      315 	then do;					/* If string is exhausted */
      316 		s = "";
      317 		return;
      318 	     end;
      319 
      320 	i = index (acct, ".");			/* Find bounds of component */
      321 
      322 	if i = 0
      323 	then do;					/* No more points */
      324 		i = index (acct, " ");		/* Find end of word */
      325 		if i = 0
      326 		then i = length (acct) + 1;
      327 		if i - 1 > length (s)
      328 		then do;				/* Too long */
      329 			code = -1;
      330 			return;
      331 		     end;
      332 		s = acct;				/* Use rest of string */
      333 		acct = "";			/* String exhausted */
      334 	     end;
      335 	else if i = 1
      336 	then do;					/* Point is first */
      337 		s = "";				/* This component is null */
      338 		acct = substr (acct, 2);		/* Strip off point */
      339 	     end;
      340 	else do;					/* Something before point */
      341 		if i - 1 > length (s)
      342 		then do;				/* Too much */
      343 			code = -1;
      344 			return;
      345 		     end;
      346 		s = substr (acct, 1, i - 1);		/* Copy it */
      347 		if i + 1 > length (acct)
      348 		then acct = "";			/* Finished out string */
      349 		else acct = substr (acct, i + 1);	/* Save rest */
      350 	     end;
      351 
      352 	return;
      353 
      354      end parse_acct_comp;
      355 
      356 /* Procedure to build mdc_$status param list and make the call */
      357 
      358 make_call:
      359      proc;
      360 
      361 	argp = addr (auto_msargs);			/* Param list built here */
      362 	msargs.version = 1;
      363 	string (msargs.flags) = "0"b;
      364 	msargs.nnames = 0;
      365 	msargs.namesp = null;
      366 	msargs.output_ptr = addr (work_seg.rest_of_seg);
      367 	msargs.output_size = sys_info$max_seg_size - bin (rel (msargs.output_ptr), 18);
      368 
      369 	msargs.exec = owner_sw | account_sw | all_sw;
      370 	msargs.dirs = dir_sw;
      371 	msargs.restrict = restrict_sw;
      372 
      373 	if account_sw
      374 	then do;
      375 		msargs.account = "1"b;
      376 		msargs.nnames = account_listl;
      377 		msargs.namesp = addr (work_seg.account_list);
      378 	     end;
      379 	else if owner_sw
      380 	then do;
      381 		msargs.owner = "1"b;
      382 		msargs.nnames = owner_listl;
      383 		msargs.namesp = addr (work_seg.owner_list);
      384 	     end;
      385 
      386 	call mdc_$status (volume, argp, volume_datap, code);
      387 	if code ^= 0
      388 	then do;
      389 		call com_err_ (code, name, "^a", volume);
      390 		go to done;
      391 	     end;
      392 	return;
      393 
      394      end make_call;
      395 
      396 /* Procedure that prints the results of the mdc_$status calll */
      397 
      398 print_results:
      399      proc;
      400 
      401 	if msargs.exec
      402 	then call print_exec_results;			/* Volume executive call */
      403 	else call print_user_results;			/* User call */
      404 	return;
      405 
      406      end print_results;
      407 
      408 
      409 print_user_results:
      410      proc;
      411 
      412 	dcl     flag		 char (1);	/* Used to "star" funny directories */
      413 	dcl     print_star		 bit (1) init ("0"b);
      414 						/* Set if star must be explained  */
      415 	dcl     ndirs		 fixed bin init (0);/* Number of directories printed */
      416 
      417 	account_datap = volume_data.accountp;
      418 	owner_datap = volume_data.ownerp;
      419 	if dir_sw
      420 	then do;					/* Directorues requested */
      421 		call ioa_ ("");
      422 		if owner_data.dirp = null
      423 		then call ioa_ ("No master directories on ^a", volume);
      424 		else do;
      425 			if ^brief_sw
      426 			then call ioa_ ("QUOTA^-PATHNAME");
      427 			do dir_datap = owner_data.dirp repeat (dir_data.next) while (dir_datap ^= null);
      428 			     path_datap = dir_data.pathp;
      429 			     flag = "";
      430 			     if quota_sw & account_datap ^= null
      431 			     then do;
      432 				     if string (account_data.name) = string (dir_data.name)
      433 				     then /* Charged to users account */
      434 					quota_sum = quota_sum + dir_data.quota;
      435 				     else do;	/* Charged to some other account */
      436 					     flag = "*";
      437 					     print_star = "1"b;
      438 					     quota_other = quota_other + dir_data.quota;
      439 					end;
      440 				end;
      441 			     call ioa_ ("^d^a^-^a", dir_data.quota, flag, pathname ());
      442 			     ndirs = ndirs + 1;
      443 			     quota_total = quota_total + dir_data.quota;
      444 			     if path_data.code ^= 0
      445 			     then call print_path_error (10);
      446 						/* Some error converting name */
      447 			end;
      448 			if print_star & ^brief_sw
      449 			then call ioa_ ("* indicates directories not charged to the ^a quota account.", account ());
      450 		     end;
      451 	     end;
      452 	if quota_sw
      453 	then do;
      454 		call ioa_ ("");
      455 		if account_datap = null
      456 		then do;
      457 			call ioa_ ("No quota account for ^a on logical volume ^a.", owner (), volume);
      458 			if ndirs > 1
      459 			then call quota_p1;
      460 		     end;
      461 		else do;
      462 			call quota_p2;
      463 			if dir_sw
      464 			then if quota_sum ^= account_data.quota_used
      465 			     then call quota_p3;
      466 			if quota_other > 0
      467 			then call quota_p1;
      468 		     end;
      469 	     end;
      470 	call ioa_ ("");
      471 	if restrict_sw
      472 	then if account_datap ^= null
      473 	     then do;
      474 		     if account_data.restrictp = null
      475 		     then call ioa_ ("There is no master directory path restriction for ^a", account ());
      476 		     else call print_restrict (1, account_data.restrictp);
      477 		end;
      478 	return;
      479 
      480      end print_user_results;
      481 
      482 /* Print variuos quota messages */
      483 
      484 quota_p1:
      485      proc;
      486 
      487 	if brief_sw
      488 	then call ioa_ ("Total assigned to ^a is ^d.", owner (), quota_total);
      489 	else call ioa_ ("Total quota assigned to directories owned by ^a is ^d.", owner (), quota_total);
      490 
      491      end quota_p1;
      492 
      493 quota_p2:
      494      proc;
      495 
      496 	if brief_sw
      497 	then call ioa_ ("Quota available is ^d, assigned is ^d.", account_data.quota, account_data.quota_used);
      498 	else call ioa_ ("Quota available to ^a is ^d, quota assigned is ^d.", account (), account_data.quota,
      499 		account_data.quota_used);
      500 
      501      end quota_p2;
      502 
      503 quota_p3:
      504      proc;
      505 
      506 	call ioa_ ("Quota assigned to ^a is ^d.", owner (), quota_sum);
      507 
      508      end quota_p3;
      509 
      510 /* Procedure to do printing for volume executive */
      511 
      512 print_exec_results:
      513      proc;
      514 
      515 	if account_sw
      516 	then do;
      517 		max_account_len = 7;
      518 		call walk_account (volume_data.accountp, get_max_account_len);
      519 		if dir_sw
      520 		then call print_dir_list_by_account;
      521 		if quota_sw
      522 		then call print_quota_by_account;
      523 	     end;
      524 	else do;
      525 		max_owner_len = 5;
      526 		call walk_owner (volume_data.ownerp, get_max_owner_len);
      527 		if dir_sw
      528 		then call print_dir_list_by_owner;
      529 		if quota_sw
      530 		then call print_quota_by_owner;
      531 	     end;
      532 
      533 	return;
      534 
      535      end print_exec_results;
      536 
      537 /* Procedures that print exec data by account */
      538 
      539 print_dir_list_by_account:
      540      proc;
      541 
      542 
      543 	if volume_data.accountp = null
      544 	then do;					/* No accounts returned */
      545 		if account_listl = 0
      546 		then call ioa_ ("No quota accounts on volume ^a.", volume);
      547 		else call ioa_ ("No quota accounts on ^a match requests.", volume);
      548 		go to done;
      549 	     end;
      550 
      551 	max_account_len = 7;			/* Compute length of longest account */
      552 	call walk_account (volume_data.accountp, get_max_account_len);
      553 
      554 	if long_sw
      555 	then do;
      556 		max_dir_name_len = 5;		/* Get length of longes owner */
      557 		call walk_account_then_dir (volume_data.accountp, get_max_dir_name_len);
      558 		entry_name = print_account_owner_and_dir;
      559 		call ioa_ ("^/^va  ^va  QUOTA  PATHNAME", max_account_len, "ACCOUNT", max_dir_name_len, "OWNER");
      560 	     end;
      561 	else do;
      562 		entry_name = print_account_and_dir;
      563 		call ioa_ ("^/^va  QUOTA  PATHNAME", max_account_len, "ACCOUNT");
      564 	     end;
      565 
      566 	call walk_account_then_dir (volume_data.accountp, entry_name);
      567 
      568 	return;
      569 
      570      end print_dir_list_by_account;
      571 
      572 
      573 print_quota_by_account:
      574      proc;
      575 
      576 	call ioa_ ("^/^va  ASSIGNED  AVAILABLE", max_account_len, "ACCOUNT");
      577 	call walk_account (volume_data.accountp, print_account_quota);
      578 	return;
      579 
      580      end print_quota_by_account;
      581 
      582 /* Procedures that print exec data by owner */
      583 
      584 print_dir_list_by_owner:
      585      proc;
      586 	if volume_data.ownerp = null
      587 	then do;
      588 		call ioa_ ("No directory owners on ^a match requests.", volume);
      589 		go to done;
      590 	     end;
      591 
      592 	if long_sw
      593 	then do;
      594 		max_dir_name_len = 7;		/* Must get longest account name */
      595 		call walk_owner_then_dir (volume_data.ownerp, get_max_dir_name_len);
      596 		call ioa_ ("^/^va  ^va  QUOTA PATHNAME", max_owner_len, "OWNER", max_dir_name_len, "ACCOUNT");
      597 		entry_name = print_owner_account_and_dir;
      598 	     end;
      599 	else do;
      600 		call ioa_ ("^/^va  QUOTA  PATHNAME", max_owner_len, "OWNER");
      601 		entry_name = print_owner_and_dir;
      602 	     end;
      603 
      604 	call walk_owner_then_dir (volume_data.ownerp, entry_name);
      605 	return;
      606 
      607      end print_dir_list_by_owner;
      608 
      609 
      610 print_quota_by_owner:
      611      proc;
      612 
      613 	call ioa_ ("^/^va  QUOTA", max_owner_len, "OWNER");
      614 	call walk_owner (volume_data.ownerp, print_owner_quota);
      615 	return;
      616 
      617      end print_quota_by_owner;
      618 
      619 /* Procedures that walk lists in various ways, making calls as they go */
      620 
      621 walk_account_then_dir:
      622      proc (p, e);
      623 
      624 	dcl     p			 ptr;
      625 	dcl     e			 entry variable;
      626 
      627 	do account_datap = p repeat (account_data.next) while (account_datap ^= null);
      628 	     do dir_datap = account_data.dirp repeat (dir_data.next) while (dir_datap ^= null);
      629 		call e;
      630 	     end;
      631 	end;
      632 
      633 	return;
      634 
      635      end walk_account_then_dir;
      636 
      637 walk_account:
      638      proc (p, e);
      639 
      640 	dcl     p			 ptr;
      641 	dcl     e			 entry variable;
      642 
      643 	do account_datap = p repeat (account_data.next) while (account_datap ^= null);
      644 	     call e;
      645 	end;
      646 	return;
      647 
      648      end walk_account;
      649 
      650 walk_owner:
      651      proc (p, e);
      652 
      653 	dcl     p			 ptr;
      654 	dcl     e			 entry variable;
      655 
      656 	do owner_datap = p repeat (owner_data.next) while (owner_datap ^= null);
      657 	     call e;
      658 	end;
      659 	return;
      660 
      661      end walk_owner;
      662 
      663 walk_owner_then_dir:
      664      proc (p, e);
      665 
      666 	dcl     p			 ptr;
      667 	dcl     e			 entry variable;
      668 
      669 	do owner_datap = p repeat (owner_data.next) while (owner_datap ^= null);
      670 	     do dir_datap = owner_data.dirp repeat (dir_data.next) while (dir_datap ^= null);
      671 		call e;
      672 	     end;
      673 	end;
      674 	return;
      675 
      676      end walk_owner_then_dir;
      677 
      678 /* These procedures are the targets of proc_caller and do all the work of printing exec data */
      679 
      680 print_account_and_dir:
      681      proc;
      682 
      683 	path_datap = dir_data.pathp;
      684 	call ioa_ ("^va  ^6a ^a", max_account_len, account (), qedit (dir_data.quota), pathname ());
      685 	if path_data.code ^= 0
      686 	then call print_path_error (max_account_len + 9);
      687 	return;
      688 
      689      end print_account_and_dir;
      690 
      691 print_account_owner_and_dir:
      692      proc;
      693 
      694 	path_datap = dir_data.pathp;
      695 	call ioa_ ("^va  ^va  ^6a ^a", max_account_len, account (), max_dir_name_len, dir_name (),
      696 	     qedit (dir_data.quota), pathname ());
      697 	if path_data.code ^= 0
      698 	then call print_path_error (max_account_len + max_dir_name_len + 11);
      699 	return;
      700 
      701      end print_account_owner_and_dir;
      702 
      703 
      704 print_account_quota:
      705      proc;
      706 
      707 	call ioa_ ("^va  ^9a ^a", max_account_len, account (), qedit (account_data.quota_used),
      708 	     qedit (account_data.quota));
      709 	return;
      710 
      711      end print_account_quota;
      712 
      713 print_owner_and_dir:
      714      proc;
      715 
      716 	path_datap = dir_data.pathp;
      717 	call ioa_ ("^va  ^6a ^a", max_owner_len, owner (), qedit (dir_data.quota), pathname ());
      718 	if path_data.code ^= 0
      719 	then call print_path_error (max_owner_len + 9);
      720 	return;
      721 
      722      end print_owner_and_dir;
      723 
      724 print_owner_account_and_dir:
      725      proc;
      726 
      727 	path_datap = dir_data.pathp;
      728 	call ioa_ ("^va  ^va  ^6a ^a", max_owner_len, owner (), max_dir_name_len, dir_name (), qedit (dir_data.quota),
      729 	     pathname ());
      730 	if path_data.code ^= 0
      731 	then call print_path_error (max_owner_len + max_dir_name_len + 11);
      732 	return;
      733 
      734      end print_owner_account_and_dir;
      735 
      736 get_max_dir_name_len:
      737      proc;
      738 
      739 	max_dir_name_len = max (max_dir_name_len, length (dir_name ()));
      740 	return;
      741 
      742      end get_max_dir_name_len;
      743 
      744 get_max_account_len:
      745      proc;
      746 
      747 	max_account_len = max (max_account_len, length (account ()));
      748 	return;
      749 
      750      end get_max_account_len;
      751 
      752 get_max_owner_len:
      753      proc;
      754 
      755 	max_owner_len = max (max_owner_len, length (owner ()));
      756 	return;
      757 
      758      end get_max_owner_len;
      759 
      760 
      761 print_owner_quota:
      762      proc;
      763 
      764 	quota_sum = 0;
      765 	do dir_datap = owner_data.dirp repeat (dir_data.next) while (dir_datap ^= null);
      766 	     quota_sum = quota_sum + dir_data.quota;
      767 	end;
      768 	call ioa_ ("^va  ^a", max_owner_len, owner (), qedit (quota_sum));
      769 	return;
      770 
      771      end print_owner_quota;
      772 
      773 /* Procedure to print a pathname restriction list */
      774 
      775 print_restrict:
      776      proc (n, p);
      777 
      778 	dcl     n			 fixed bin;	/* Index to messages */
      779 	dcl     p			 ptr;		/* Pointer to list */
      780 
      781 	dcl     restrict_msg	 (1) char (64) var int static options (constant)
      782 				 init ("Master directories are restricted to");
      783 
      784 	path_datap = p;
      785 	if path_data.next = null & path_data.code = 0
      786 	then do;					/* Simple case, 1 dir, no errors */
      787 		call ioa_ ("^a ^a", restrict_msg (n), pathname ());
      788 		return;
      789 	     end;
      790 	call ioa_ ("^a:", restrict_msg (n));		/* Heading for a long list */
      791 	do path_datap = p repeat (path_data.next) while (path_datap ^= null);
      792 	     call ioa_ ("^-^a", pathname ());
      793 	     if path_data.code ^= 0
      794 	     then call print_path_error (10);
      795 	end;
      796 	return;
      797 
      798      end print_restrict;
      799 
      800 /* Procedure called for bad pathnames to print an error */
      801 
      802 print_path_error:
      803      proc (n);
      804 
      805 	dcl     n			 fixed bin;	/* Number of columns to indent */
      806 	dcl     (
      807 	        long_info		 char (100),
      808 	        short_info		 char (8)
      809 	        )			 aligned;
      810 
      811 	call convert_status_code_ (path_data.code, short_info, long_info);
      812 	call ioa_ ("^vx(Error: ^a)", n, long_info);
      813 	return;
      814 
      815      end print_path_error;
      816 
      817 /* Internal procedure that edit various things */
      818 
      819 pathname:
      820      proc returns (char (201) var);
      821 
      822 	dcl     work		 char (201) var;
      823 
      824 	if path_data.dir = ""
      825 	then work = "-????-";
      826 	else work = rtrim (path_data.dir);
      827 	if work ^= ">"
      828 	then work = work || ">";
      829 	if path_data.ename = ""
      830 	then do;
      831 		if work ^= ">" | path_data.code = error_table_$bad_uidpath
      832 		then work = work || "-????-";
      833 	     end;
      834 	else work = work || rtrim (path_data.ename);
      835 
      836 	return (work);
      837 
      838      end pathname;
      839 
      840 account:
      841      proc returns (char (32) var);
      842 
      843 	return (rtrim (account_data.person) || "." || rtrim (account_data.project));
      844 
      845      end account;
      846 
      847 owner:
      848      proc returns (char (32) var);
      849 
      850 	return (rtrim (owner_data.person) || "." || rtrim (owner_data.project));
      851 
      852      end owner;
      853 
      854 dir_name:
      855      proc returns (char (32) var);
      856 
      857 	return (rtrim (dir_data.person) || "." || rtrim (dir_data.project));
      858 
      859      end dir_name;
      860 
      861 	declare qedit		 generic (DQ when (fixed bin (18)), VQ when (fixed bin (35)));
      862 DQ:
      863      proc (d) returns (char (16) varying);
      864 
      865 	dcl     d			 fixed bin (18);
      866 	dcl     edit		 picture "zzzzzzzz9";
      867 
      868 	edit = d;
      869 	go to COMMON;
      870 
      871 VQ:
      872      entry (v) returns (char (16) varying);
      873 
      874 	declare v			 fixed bin (35);
      875 
      876 	edit = v;
      877 
      878 COMMON:
      879 	return (ltrim (edit));
      880 
      881      end DQ;
      882 
      883 
      884 /* Cleanup handler */
      885 
      886 clean_up:
      887      proc;
      888 
      889 	if ptr_array (1) ^= null
      890 	then call release_temp_segments_ (name, ptr_array, code);
      891 	return;
      892 
      893      end clean_up;
      894 
      895      end list_mdir;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/18/84  1429.7  list_mdir.pl1                     >spec>on>40-16>list_mdir.pl1
107          1    06/22/76  0904.8  mdc_status_args.incl.pl1          >ldd>include>mdc_status_args.incl.pl1
109          2    11/18/84  1430.0  mdc_status_info.incl.pl1          >spec>on>40-16>mdc_status_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
account                   2(02)        based           bit(1)                   level 3 packed unaligned dcl 1-9 set ref 375*
account_data                           based           structure                level 1 dcl 2-20
account_datap                   000206 automatic       pointer                  dcl 2-18 set ref 417* 430 432 455 463 471 474 476
                                                                                  496 496 498 498 627* 627* 628* 631 643* 643* 645
                                                                                  707 707 843 843
account_list                           based           structure                level 2 dcl 75 set ref 184 184 377
account_listl                   000160 automatic       fixed bin(17,0)          initial dcl 72 set ref 72* 184* 376 545
account_sw                      000134 automatic       bit(1)                   initial unaligned dcl 49 set ref 49* 185* 194* 369
                                                                                  373 515
accountp                  2            based           pointer                  level 2 dcl 2-10 set ref 417 518* 543 552* 557* 566*
                                                                                  577*
acct                            000104 automatic       char(32)                 unaligned dcl 25 set ref 271 271 280* 281 282 296
                                                                                  314 320 324 325 332 333* 338* 338 346 347 347*
                                                                                  349* 349
addr                                                   builtin function         dcl 102 ref 179 179 184 184 361 366 377 383
all_sw                          000132 automatic       bit(1)                   initial unaligned dcl 45 set ref 45* 173* 194 369
arg                                    based           char                     unaligned dcl 59 set ref 161 165 167 167 169 169 171
                                                                                  171 173 173 175 177 182 188* 236 239 271 275* 280
arg_len                         000152 automatic       fixed bin(17,0)          dcl 58 set ref 161 165 167 167 169 169 171 171 173
                                                                                  173 175 177 182 188 188 206* 236 239 271 271 275
                                                                                  275 280
arg_list_ptr                    000154 automatic       pointer                  dcl 60 set ref 120* 206*
arg_name                        000250 automatic       char(16)                 unaligned dcl 234 set ref 236* 246*
arg_no                          000146 automatic       fixed bin(17,0)          initial dcl 55 set ref 55* 206* 209* 213* 213 214
                                                                                  221* 221 222
arg_ptr                         000150 automatic       pointer                  dcl 57 set ref 161 165 167 167 169 169 171 171 173
                                                                                  173 175 177 182 188 206* 236 239 271 275 280
argp                            000202 automatic       pointer                  dcl 1-7 set ref 361* 362 363 364 365 366 367 367 369
                                                                                  370 371 375 376 377 381 382 383 386* 401
auto_msargs                     000164 automatic       structure                level 1 dcl 80 set ref 361
based_list                             based           structure                level 1 dcl 66
bin                                                    builtin function         dcl 102 ref 367
brief_sw                        000130 automatic       bit(1)                   initial unaligned dcl 41 set ref 41* 169* 425 448
                                                                                  487 496
cleanup                         000174 stack reference condition                dcl 105 ref 122
code                      2            based           fixed bin(35,0)          level 2 in structure "path_data" dcl 2-54
                                                                                  in procedure "lmd" set ref 444 685 697 718 730 785
                                                                                  793 811* 831
code                            000100 automatic       fixed bin(35,0)          dcl 22 in procedure "lmd" set ref 143* 144 146* 206*
                                                                                  207 209* 287 290 293 313* 329* 343* 386* 387 389*
                                                                                  889*
com_err_                        000010 constant        entry                    external dcl 85 ref 116 146 188 209 246 275 389
convert_status_code_            000030 constant        entry                    external dcl 93 ref 811
cu_$arg_count                   000012 constant        entry                    external dcl 86 ref 113
cu_$arg_list_ptr                000016 constant        entry                    external dcl 88 ref 120
cu_$arg_ptr_rel                 000014 constant        entry                    external dcl 87 ref 206
d                                      parameter       fixed bin(18,0)          dcl 865 ref 862 868
dir                       3            based           char(168)                level 2 packed unaligned dcl 2-54 ref 824 826
dir_data                               based           structure                level 1 dcl 2-34
dir_datap                       000210 automatic       pointer                  dcl 2-32 set ref 427* 427* 428 432 432 438 441 443*
                                                                                  447 628* 628* 630 670* 670* 672 683 684 694 695
                                                                                  716 717 727 728 765* 765* 766* 767 857 857
dir_sw                          000127 automatic       bit(1)                   initial unaligned dcl 39 set ref 39* 167* 192 192*
                                                                                  370 419 463 519 527
dirp                     22            based           pointer                  level 2 in structure "account_data" dcl 2-20
                                                                                  in procedure "lmd" ref 628
dirp                     12            based           pointer                  level 2 in structure "owner_data" dcl 2-45
                                                                                  in procedure "lmd" ref 422 427 670 765
dirs                      2(01)        based           bit(1)                   level 3 packed unaligned dcl 1-9 set ref 370*
e                                      parameter       entry variable           dcl 667 in procedure "walk_owner_then_dir" ref 663
                                                                                  671
e                                      parameter       entry variable           dcl 625 in procedure "walk_account_then_dir" ref 621
                                                                                  629
e                                      parameter       entry variable           dcl 654 in procedure "walk_owner" ref 650 657
e                                      parameter       entry variable           dcl 641 in procedure "walk_account" ref 637 644
edit                            000100 automatic       picture(9)               unaligned dcl 866 set ref 868* 876* 878
ename                    55            based           char(32)                 level 2 packed unaligned dcl 2-54 ref 829 834
entry_name                      000122 automatic       entry variable           dcl 35 set ref 558* 562* 566* 597* 601* 604*
error_table_$bad_uidpath        000036 external static fixed bin(35,0)          dcl 98 ref 831
error_table_$badopt             000032 external static fixed bin(35,0)          dcl 95 set ref 188*
error_table_$mdc_illegal_account
                                000034 external static fixed bin(35,0)          dcl 96 set ref 275*
exec                      2            based           bit(1)                   level 3 packed unaligned dcl 1-9 set ref 369* 401
flag                            000330 automatic       char(1)                  unaligned dcl 412 set ref 429* 436* 441*
flags                     2            based           structure                level 2 dcl 1-9 set ref 363*
get_temp_segments_              000020 constant        entry                    external dcl 89 ref 143
i                               000274 automatic       fixed bin(17,0)          dcl 269 in procedure "parse_acct" set ref 281* 282
                                                                                  282
i                               000304 automatic       fixed bin(17,0)          dcl 311 in procedure "parse_acct_comp" set ref 320*
                                                                                  322 324* 325 325* 327 335 341 346 347 349
index                                                  builtin function         dcl 102 ref 281 320 324
ioa_                            000024 constant        entry                    external dcl 91 ref 421 422 425 441 448 454 457 470
                                                                                  474 487 489 496 498 506 545 547 559 563 576 588
                                                                                  596 600 613 684 695 707 717 728 768 787 790 792
                                                                                  812
length                                                 builtin function         dcl 102 ref 271 271 325 327 341 347 739 747 755
list_length                            constant        fixed bin(17,0)          initial dcl 64 ref 184 184 244 366 366 377
long_info                       000100 automatic       char(100)                dcl 806 set ref 811* 812*
long_sw                         000131 automatic       bit(1)                   initial unaligned dcl 43 set ref 43* 171* 554 592
max                                                    builtin function         dcl 102 ref 739 747 755
max_account_len                 000120 automatic       fixed bin(17,0)          dcl 33 set ref 517* 551* 559* 563* 576* 684* 685
                                                                                  695* 697 707* 747* 747
max_dir_name_len                000117 automatic       fixed bin(17,0)          dcl 32 set ref 556* 559* 594* 596* 695* 697 728* 730
                                                                                  739* 739
max_owner_len                   000121 automatic       fixed bin(17,0)          dcl 34 set ref 525* 596* 600* 613* 717* 718 728* 730
                                                                                  755* 755 768*
mdc_$status                     000026 constant        entry                    external dcl 92 ref 386
more_args                       000156 automatic       bit(1)                   initial unaligned dcl 61 set ref 61* 163 214* 222*
                                                                                  237
msargs                                 based           structure                level 1 dcl 1-9
n                                      parameter       fixed bin(17,0)          dcl 805 in procedure "print_path_error" set ref 802
                                                                                  812*
n                                      parameter       fixed bin(17,0)          dcl 778 in procedure "print_restrict" ref 775 787
                                                                                  790
n                                      parameter       fixed bin(17,0)          dcl 233 in procedure "build_list" set ref 229 244
                                                                                  250* 250 251*
n                                      parameter       fixed bin(17,0)          dcl 264 in procedure "parse_acct" ref 260 299 300
name                      2            based           structure                level 2 in structure "account_data" dcl 2-20
                                                                                  in procedure "lmd" ref 432
name                            000021 constant        char(9)                  initial unaligned dcl 21 in procedure "lmd" set ref
                                                                                  116* 116* 143* 146* 188* 209* 246* 275* 389* 889*
name                                   based           structure                array level 2 in structure "based_list" dcl 66
                                                                                  in procedure "lmd"
name                      2            based           structure                level 2 in structure "owner_data" dcl 2-45
                                                                                  in procedure "lmd"
name                      4            based           structure                level 2 in structure "dir_data" dcl 2-34
                                                                                  in procedure "lmd" ref 432
namesp                    4            based           pointer                  level 2 dcl 1-9 set ref 365* 377* 383*
nargs                           000147 automatic       fixed bin(17,0)          dcl 56 set ref 113* 114 214 222
ndirs                           000332 automatic       fixed bin(17,0)          initial dcl 415 set ref 415* 442* 442 458
next                                   based           pointer                  level 2 in structure "account_data" dcl 2-20
                                                                                  in procedure "lmd" ref 631 645
next                                   based           pointer                  level 2 in structure "owner_data" dcl 2-45
                                                                                  in procedure "lmd" ref 658 673
next                                   based           pointer                  level 2 in structure "path_data" dcl 2-54
                                                                                  in procedure "lmd" ref 785 795
next                                   based           pointer                  level 2 in structure "dir_data" dcl 2-34
                                                                                  in procedure "lmd" ref 447 630 672 767
nnames                    3            based           fixed bin(17,0)          level 2 dcl 1-9 set ref 364* 376* 382*
null                                                   builtin function         dcl 102 ref 23 365 422 427 430 455 471 474 543 586
                                                                                  627 628 643 656 669 670 765 785 791 889
output_ptr                6            based           pointer                  level 2 dcl 1-9 set ref 366* 367
output_size               1            based           fixed bin(19,0)          level 2 dcl 1-9 set ref 367*
owner                     2(03)        based           bit(1)                   level 3 packed unaligned dcl 1-9 set ref 381*
owner_data                             based           structure                level 1 dcl 2-45
owner_datap                     000212 automatic       pointer                  dcl 2-43 set ref 418* 422 427 656* 656* 658 669*
                                                                                  669* 670* 673 765 850 850
owner_list                             based           structure                level 2 dcl 75 set ref 179 179 383
owner_listl                     000157 automatic       fixed bin(17,0)          initial dcl 71 set ref 71* 179* 382
owner_sw                        000135 automatic       bit(1)                   initial unaligned dcl 51 set ref 51* 180* 194 369
                                                                                  379
ownerp                    4            based           pointer                  level 2 dcl 2-10 set ref 418 526* 586 595* 604* 614*
p                                      parameter       pointer                  dcl 666 in procedure "walk_owner_then_dir" ref 663
                                                                                  669
p                                      parameter       pointer                  dcl 640 in procedure "walk_account" ref 637 643
p                                      parameter       pointer                  dcl 653 in procedure "walk_owner" ref 650 656
p                                      parameter       pointer                  dcl 263 in procedure "parse_acct" ref 260 299 300
p                                      parameter       pointer                  dcl 624 in procedure "walk_account_then_dir" ref 621
                                                                                  627
p                                      parameter       pointer                  dcl 232 in procedure "build_list" set ref 229 251*
p                                      parameter       pointer                  dcl 779 in procedure "print_restrict" ref 775 784
                                                                                  791
path_data                              based           structure                level 1 dcl 2-54
path_datap                      000214 automatic       pointer                  dcl 2-52 set ref 428* 444 683* 685 694* 697 716* 718
                                                                                  727* 730 784* 785 785 791* 791* 793* 795 811 824
                                                                                  826 829 831 834
pathp                     2            based           pointer                  level 2 dcl 2-34 ref 428 683 694 716 727
person                    4            based           char(22)                 level 3 in structure "dir_data" packed unaligned
                                                                                  dcl 2-34 in procedure "lmd" ref 857
person                                 based           char(22)                 array level 3 in structure "based_list" packed
                                                                                  unaligned dcl 66 in procedure "lmd" set ref 299*
person                          000262 automatic       char(22)                 unaligned dcl 266 in procedure "parse_acct" set ref
                                                                                  286* 299
person                    2            based           char(22)                 level 3 in structure "account_data" packed unaligned
                                                                                  dcl 2-20 in procedure "lmd" ref 843
person                    2            based           char(22)                 level 3 in structure "owner_data" packed unaligned
                                                                                  dcl 2-45 in procedure "lmd" ref 850
print_star                      000331 automatic       bit(1)                   initial unaligned dcl 413 set ref 413* 437* 448
project                   5(18)        based           char(9)                  array level 3 in structure "based_list" packed
                                                                                  unaligned dcl 66 in procedure "lmd" set ref 300*
project                         000270 automatic       char(9)                  unaligned dcl 267 in procedure "parse_acct" set ref
                                                                                  289* 300
project                   7(18)        based           char(9)                  level 3 in structure "owner_data" packed unaligned
                                                                                  dcl 2-45 in procedure "lmd" ref 850
project                  11(18)        based           char(9)                  level 3 in structure "dir_data" packed unaligned
                                                                                  dcl 2-34 in procedure "lmd" ref 857
project                   7(18)        based           char(9)                  level 3 in structure "account_data" packed unaligned
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Lastuka                               F6>                                                        Lastuka                         tina    OperDevel                     OGEa  OO  OByW;none   VIP7400                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           v    Zwick                                 $X4                                                        Zwick                           dz      Multics              
         SzL  TS  TE>none   VIP7400_DTR                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              _/    gw                                    N".>                                                        GWong                           gw      Multics                                  J9m7                                                                                                                                                                  c    Berlin                                &>l.                        T8                        Berlin                                  NMLPROD               h   
      QZ  Rf  R>Anone   WY50_80C                                                                  QjF                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              Neer                                  bH.                        ^(^                        Neer                                    NMLPROD               V         Qd)  R~  Qcnone   WY50_80C                                                                  Qj>d.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            internal procedure  shares stack frame of external procedure lmd.  
walk_owner                              internal procedure  shares stack frame of external procedure lmd.  
walk_owner_then_dir                     internal procedure  shares stack frame of external procedure lmd.  
print_account_and_dir               166 internal procedure  is assigned to an entry variable.  
print_account_owner_and_dir         184 internal procedure  is assigned to an entry variable.  
print_account_quota                 122 internal procedure  is assigned to an entry variable.  
print_owner_and_dir                 166 internal procedure  is assigned to an entry variable.  
print_owner_account_and_dir         184 internal procedure  is assigned to an entry variable.  
get_max_dir_name_len                 80 internal procedure  is assigned to an entry variable.  
get_max_account_len                  80 internal procedure  is assigned to an entry variable.  
get_max_owner_len                    80 internal procedure  is assigned to an entry variable.  
print_owner_quota                   108 internal procedure  is assigned to an entry variable.  
print_restrict                          internal procedure  shares stack frame of external procedure lmd.  
print_path_error                    114 internal procedure  is called by several nonquick procedures.  
pathname                            117 internal procedure  is called by several nonquick procedures.  
account                              67 internal procedure  is called by several nonquick procedures.  
owner                                67 internal procedure  is called by several nonquick procedures.  
dir_name                             67 internal procedure  is called by several nonquick procedures.  
DQ                                   71 internal procedure  is called by several nonquick procedures.  
clean_up                             78 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
DQ                       000100 edit                        DQ
lmd                      000100 code                        lmd
                         000102 ptr_array                   lmd
                         000104 acct                        lmd
                         000114 quota_sum                   lmd
                         000115 quota_other                 lmd
                         000116 quota_total                 lmd
                         000117 max_dir_name_len            lmd
                         000120 max_account_len             lmd
                         000121 max_owner_len               lmd
                         000122 entry_name                  lmd
                         000126 quota_sw                    lmd
                         000127 dir_sw                      lmd
                         000130 brief_sw                    lmd
                         000131 long_sw                     lmd
                         000132 all_sw                      lmd
                         000133 restrict_sw                 lmd
                         000134 account_sw                  lmd
                         000135 owner_sw                    lmd
                         000136 volume                      lmd
                         000146 arg_no                      lmd
                         000147 nargs                       lmd
                         000150 arg_ptr                     lmd
                         000152 arg_len                     lmd
                         000154 arg_list_ptr                lmd
                         000156 more_args                   lmd
                         000157 owner_listl                 lmd
                         000160 account_listl               lmd
                         000162 work_seg_ptr                lmd
                         000164 auto_msargs                 lmd
                         000202 argp                        lmd
                         000204 volume_datap                lmd
                         000206 account_datap               lmd
                         000210 dir_datap                   lmd
                         000212 owner_datap                 lmd
                         000214 path_datap                  lmd
                         000250 arg_name                    build_list
                         000262 person                      parse_acct
                         000270 project                     parse_acct
                         000273 tag                         parse_acct
                         000274 i                           parse_acct
                         000304 i                           parse_acct_comp
                         000330 flag                        print_user_results
                         000331 print_star                  print_user_results
                         000332 ndirs                       print_user_results
pathname                 000100 work                        pathname
print_path_error         000100 long_info                   print_path_error
                         000132 short_info                  print_path_error

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_le_a              alloc_cs            cat_realloc_cs      call_var            call_ext_out_desc   call_ext_out
call_int_this       call_int_other      return              enable              ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      convert_status_code_          cu_$arg_count                 cu_$arg_list_ptr
cu_$arg_ptr_rel               get_temp_segments_            ioa_                          mdc_$status
release_temp_segments_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_uidpath      error_table_$badopt           error_table_$mdc_illegal_account
sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     23 000456        26 000465        28 000466        30 000467        37 000470        39 000471        41 000472
     43 000473        45 000474        47 000475        49 000476        51 000477        55 000500        61 000502
     71 000503        72 000504        17 000507       113 000526       114 000535       116 000537       117 000567
    120 000570       122 000577       124 000621       126 000622       128 000623       130 000624       132 000625
    135 000631       140 000632       143 000633       144 000654       146 000656       147 000705       150 000706
    151 000710       157 000711       160 000712       161 000713       163 000720       164 000722       165 000723
    167 000734       169 000747       171 000762       173 000775       175 001010       177 001017       179 001023
    180 001027       181 001031       182 001032       184 001036       185 001043       186 001045       188 001046
    189 001100       191 001101       192 001102       194 001111       196 001117       203 001120       206 001121
    207 001140       209 001142       210 001171       213 001172       214 001173       216 001177       218 001200
    221 001201       222 001203       223 001207       229 001210       236 001212       237 001217       238 001222
    239 001223       241 001230       242 001231       244 001232       246 001236       247 001267       250 001270
    251 001271       252 001301       254 001302       260 001303       271 001305       275 001316       277 001350
    280 001351       281 001356       282 001367       286 001401       287 001404       289 001406       290 001411
    292 001413       293 001416       296 001420       299 001424       300 001435       301 001442       307 001443
    313 001454       314 001455       316 001461       317 001466       320 001467       322 001500       324 001501
    325 001512       327 001515       329 001520       330 001522       332 001523       333 001531       334 001534
    335 001535       337 001537       338 001545       339 001550       341 001551       343 001554       344 001556
    346 001557       347 001567       349 001577       352 001605       358 001606       361 001607       362 001611
    363 001613       364 001614       365 001615       366 001617       367 001625       369 001635       370 001643
    371 001650       373 001655       375 001657       376 001661       377 001663       378 001666       379 001667
    381 001671       382 001673       383 001675       386 001677       387 001722       389 001724       390 001753
    392 001754       398 001755       401 001756       403 001764       404 001765       409 001766       413 001767
    415 001770       417 001771       418 001774       419 001777       421 002001       422 002012       425 002040
    427 002057       428 002066       429 002071       430 002073       432 002101       436 002114       437 002116
    438 002120       441 002124       442 002162       443 002163       444 002170       447 002203       448 002207
    452 002241       454 002243       455 002254       457 002260       458 002312       460 002316       462 002317
    463 002320       466 002327       470 002332       471 002343       474 002351       476 002405       478 002417
    484 002420       487 002421       489 002456       491 002510       493 002511       496 002512       498 002541
    501 002577       503 002600       506 002601       508 002633       512 002634       515 002635       517 002637
    518 002641       519 002655       521 002660       523 002663       525 002664       526 002666       527 002702
    529 002705       533 002710       539 002711       543 002712       545 002717       547 002742       548 002762
    551 002763       552 002765       554 003000       556 003002       557 003004       558 003020       559 003023
    560 003062       562 003063       563 003066       566 003117       568 003130       573 003131       576 003132
    577 003160       578 003174       584 003175       586 003176       588 003203       589 003223       592 003224
    594 003226       595 003230       596 003243       597 003302       598 003305       600 003306       601 003337
    604 003342       605 003353       610 003354       613 003355       614 003404       615 003420       621 003421
    627 003423       628 003432       629 003442       630 003447       631 003453       633 003457       637 003460
    643 003462       644 003472       645 003477       646 003503       650 003504       656 003506       657 003516
    658 003523       659 003527       663 003530       669 003532       670 003542       671 003552       672 003557
    673 003563       674 003567       680 003570       683 003576       684 003603       685 003673       687 003711
    691 003712       694 003720       695 003725       697 004031       699 004050       704 004051       707 004057
    709 004151       713 004152       716 004160       717 004165       718 004255       720 004273       724 004274
    727 004302       728 004307       730 004413       732 004432       736 004433       739 004441       740 004456
    744 004457       747 004465       748 004502       752 004503       755 004511       756 004526       761 004527
    764 004535       765 004537       766 004547       767 004554       768 004557       769 004630       775 004631
    784 004633       785 004636       787 004644       788 004701       790 004702       791 004723       792 004734
    793 004761       795 004774       796 005000       802 005001       811 005007       812 005023       813 005051
    819 005052       824 005060       826 005074       827 005114       829 005130       831 005134       833 005156
    834 005157       836 005203       840 005213       843 005221       847 005304       850 005312       854 005375
    857 005403       862 005466       868 005474       869 005505       871 005506       876 005514       878 005525
    886 005550       889 005556       891 005603


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
