THIS FILE IS DAMAGED

	COMPILATION LISTING OF SEGMENT cm_compact_ci
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 01/03/85  1630.1 mst Thu
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* DESCRIPTION:
        8*
        9*         This module implements collection_manager_$compact_control_interval.
       10*
       11*         Given an identifier of  a  control interval in a file, re-arrange the
       12*     contents of the control interval so as to concentrate  all  of  the  free
       13*     space  in one contiguous area of the control interval.  This is necessary
       14*     at times to recover scattered free space and is known as  compacting  the
       15*     control  interval.    In normal use of collection_manager_, this entry is
       16*     never needed.  It is only used by applications which attempt at their own
       17*     risk to make simple modifications  to  control  intervals  without  going
       18*     through collection_manager_.
       19**/
       20 
       21 /* HISTORY:
       22*
       23*Written by Matthew Pierret, 04/03/84.
       24*Modified:
       25*09/26/84 by Matthew Pierret:  Changed to use file_manager_$simple_put, thus
       26*            removing the need for the ci_parts structure.  Added
       27*            CHECK_CI_VERSION to verify the correctness of the control interval
       28*            layout type.
       29**/
       30 
       31 /* format: style2,ind3 */
       32 
       33 cm_compact_ci:
       34    proc (p_file_opening_id, p_control_interval_id, p_code);
       35 
       36 
       37 /* START OF DECLARATIONS */
       38 /* Parameter */
       39 
       40       dcl	    p_file_opening_id      bit (36) aligned;	/*is the opening identifier of the file.*/
       41       dcl	    p_control_interval_id  fixed bin (24) uns;	/* identifies a control interval to be compacted. */
       42       dcl	    p_code	       fixed bin (35);	/*is a standard system error code.*/
       43 
       44 /* Automatic */
       45 
       46       dcl	    ci_id		       fixed bin (24) uns;
       47       dcl	    ci_length_in_bytes     fixed bin (21) init (-1);
       48       dcl	    code		       fixed bin (35) init (0);
       49       dcl	    datum_length_in_bytes  fixed bin (35) init (-1);
       50       dcl	    file_opening_id	       bit (36) aligned;
       51       dcl	    local_ci_buffer	       (512) fixed bin (71) init ((512) 0);
       52       dcl	    new_datum_offset_in_bytes
       53 			       fixed bin (35);
       54       dcl	    new_ci_ptr	       ptr init (null);
       55       dcl	    new_datum_ptr	       ptr init (null);
       56       dcl	    new_slot_ptr	       ptr init (null);
       57       dcl	    old_ci_ptr	       ptr init (null);
       58       dcl	    old_datum_ptr	       ptr init (null);
       59       dcl	    old_slot_ptr	       ptr init (null);
       60       dcl	    slot_idx	       fixed bin;
       61       dcl	    slot_offset_in_bytes   fixed bin init (-1);
       62 
       63 /* Based */
       64 
       65       dcl	    datum_string	       char (datum_length_in_bytes) unal based;
       66       dcl	    1 new_slot	       aligned like datum_slot based (new_slot_ptr);
       67       dcl	    1 old_slot	       aligned like datum_slot based (old_slot_ptr);
       68 
       69 /* Builtin */
       70 
       71       dcl	    (addcharno, addr, ceil, divide, null)
       72 			       builtin;
       73 
       74 /* Constant */
       75 
       76       dcl	    myname	       init ("cm_compact_ci") char (32) varying internal static options (constant);
       77       dcl	    BITS_PER_BYTE	       init (9) fixed bin internal static options (constant);
       78       dcl	    BYTES_PER_WORD	       init (4) fixed bin internal static options (constant);
       79       dcl	    START_OF_CI_OFFSET     init (0) fixed bin (21) internal static options (constant);
       80 
       81 /* Entry */
       82 
       83       dcl	    file_manager_$get_ci_ptr
       84 			       entry (bit (36) aligned, fixed bin (27), ptr, fixed bin (35));
       85       dcl	    file_manager_$simple_put
       86 			       entry (bit (36) aligned, fixed bin (27), fixed bin (21), ptr, fixed bin (21),
       87 			       fixed bin (35));
       88       dcl	    sub_err_	       entry () options (variable);
       89 
       90 /* External */
       91 
       92       dcl	    dm_error_$unimplemented_ci_version
       93 			       fixed bin (35) ext;
       94 
       95 /* END OF DECLARATIONS */
       96 
       97       file_opening_id = p_file_opening_id;
       98 
       99       ci_id = p_control_interval_id;
      100 
      101       call file_manager_$get_ci_ptr (file_opening_id, (ci_id), old_ci_ptr, code);
      102       if code ^= 0
      103       then call ERROR_RETURN (code);
      104       else call CHECK_CI_VERSION (old_ci_ptr -> bci_header.layout_type);
      105 
      106       new_ci_ptr = addr (local_ci_buffer);
      107       new_ci_ptr -> bci_header = old_ci_ptr -> bci_header;
      108 
      109       if ci_id = 0
      110       then ci_length_in_bytes = CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES;
      111       else ci_length_in_bytes = CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES;
      112 
      113       new_datum_offset_in_bytes = ci_length_in_bytes;
      114 
      115       slot_offset_in_bytes = DATUM_POSITION_TABLE_OFFSET_IN_BYTES;
      116 
      117       do slot_idx = 1 to old_ci_ptr -> bci_header.number_of_datums;
      118 
      119          old_slot_ptr = addcharno (old_ci_ptr, slot_offset_in_bytes);
      120          new_slot_ptr = addcharno (new_ci_ptr, slot_offset_in_bytes);
      121 
      122          new_slot = old_slot;
      123 
      124          if old_slot.offset_in_bytes ^= FREE_SLOT
      125          then
      126 	  do;
      127 	     datum_length_in_bytes = ceil (divide (old_slot.length_in_bits, BITS_PER_BYTE, 35, 18));
      128 
      129 	     new_datum_offset_in_bytes = new_datum_offset_in_bytes - datum_length_in_bytes;
      130 	     new_slot.offset_in_bytes = new_datum_offset_in_bytes;
      131 
      132 	     new_datum_ptr = addcharno (new_ci_ptr, new_slot.offset_in_bytes);
      133 	     old_datum_ptr = addcharno (old_ci_ptr, old_slot.offset_in_bytes);
      134 
      135 	     new_datum_ptr -> datum_string = old_datum_ptr -> datum_string;
      136 
      137 	  end;
      138 
      139          slot_offset_in_bytes = slot_offset_in_bytes + BYTES_PER_WORD;
      140 
      141       end;
      142 
      143       new_ci_ptr -> bci_header.start_of_used_space = new_datum_offset_in_bytes;
      144       new_ci_ptr -> bci_header.scattered_free_space = 0;
      145 
      146       call file_manager_$simple_put (file_opening_id, (ci_id), START_OF_CI_OFFSET, new_ci_ptr, ci_length_in_bytes, code);
      147       if code ^= 0
      148       then call ERROR_RETURN (code);
      149 
      150       p_code = 0;
      151 MAIN_RETURN:
      152       return;
      153 
      154 ERROR_RETURN:
      155    proc (er_p_code);
      156 
      157       dcl	    er_p_code	       fixed bin (35);
      158 
      159       p_code = er_p_code;
      160       call FINISH ();
      161       go to MAIN_RETURN;
      162 
      163    end ERROR_RETURN;
      164 
      165 FINISH:
      166    proc ();
      167 
      168    end FINISH;
      169 
      170 
      171 
      172 CHECK_CI_VERSION:
      173    proc (ccv_p_version_received);
      174 
      175       dcl	    ccv_p_version_received char (4) aligned;
      176 
      177       if ccv_p_version_received ^= BASIC_CI_LAYOUT_1
      178       then call sub_err_ (dm_error_$unimplemented_ci_version, myname, ACTION_CANT_RESTART, null (), 0,
      179 	      "^/Expected version ^4a; received version ^4a.", BASIC_CI_LAYOUT_1, ccv_p_version_received);
      180       else return;
      181 
      182    end CHECK_CI_VERSION;
      183 
  1     1 /* BEGIN INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*
  1     5*        The collection_manager_ manages the structure of the addressable
  1     6*   portion of a control interval.  The addressable portion is that portion of
  1     7*   a control interval which the file_manager_ will allow the
  1     8*   collection_manager_ to address.  In this description control interval will
  1     9*   be used to mean the addressable portion of a control interval.
  1    10*   
  1    11*        A control interval is divided into four parts: the header, the datum
  1    12*   position table (also known as the slot table or slots), un-used space and
  1    13*   used space.  The beginning of the header is at offset 0, and the end of the
  1    14*   used space is at the end of the control interval (curently offset 4072).
  1    15*   Pictoriarly, a control interval is structured as follows:
  1    16*   
  1    17*   ----------------------------------------------------------------------
  1    18*   |        || | | | | | ||               ||   | / / |       |/|   |    |
  1    19*   | Header || | slot  | || un-used space ||   |/ / /|       |/|   |    |
  1    20*   |        || | table | ||               ||   | / / |       |/|   |    |
  1    21*   |        || | | | | | ||               ||   |/ / /|       |/|   |    |
  1    22*   ----------------------------------------------------------------------
  1    23*                                           ^ ^    ^      ^    ^  ^   ^
  1    24*                                           | |    |      |    |  |   |
  1    25*                                           | |...........|.......|...|
  1    26*                        start of used space|      |           |      |
  1    27*                                                  |           |  each|
  1    28*                                          scattered free space|  is a used
  1    29*                                                                 datum
  1    30*   
  1    31*      The basic_control_interval structure describes the header
  1    32*   (basic_control_interval.header, bci_header) and the slots
  1    33*   (basic_control_interval.datum_position_table, datum_slot for one only).
  1    34*   Each datum_slot contains the offset (in bytes) and the length (in bits) of
  1    35*   a datum in the used space.  If the offset is equal to FREE_SLOT (declared
  1    36*   in dm_cm_basic_ci_const.incl.pl1), the slot is un-used.  The slot also
  1    37*   contains flags describing the type of datum (see dm_cm_datum.incl.pl1).
  1    38**/
  1    39 
  1    40 /* HISTORY:
  1    41*Written by Matthew Pierret, 02/07/82.
  1    42*Modified:
  1    43*03/25/82 by Matthew Pierret: Fixed alignment differences basic_control_interval
  1    44*            and its sub-structures.
  1    45*06/14/82 by Matthew Pierret: Removed common header and buffers. Changed
  1    46*            basic_ci_header to bci_header. Added previous_control_interval.
  1    47*07/12/82 by Matthew Pierret: Changed collection_id to be bit (36) aligned.
  1    48*10/29/82 by Matthew Pierret: Added flags to datum slots. 
  1    49*11/10/82 by Matthew Pierret: Removed continued_datum_is_present flag, as it
  1    50*            is not used.
  1    51*03/28/84 by Matthew Pierret: Added the constants BCI_HEADER_LENGTH_IN_BYTES
  1    52*            and DATUM_POSITION_TABLE_OFFSET_IN_BYTES.
  1    53**/
  1    54 
  1    55 /* format: style2 */
  1    56      dcl	   1 basic_control_interval
  1    57 			      aligned based (basic_control_interval_ptr),
  1    58 	     2 header	      like bci_header,
  1    59 	     2 datum_position_table
  1    60 			      (0 refer (basic_control_interval.number_of_datums)) like datum_slot;
  1    61 
  1    62 
  1    63      dcl	   1 bci_header	      aligned based (bci_header_ptr),
  1    64 	     2 layout_type	      char (4) aligned,
  1    65 	     2 collection_id      bit (36) aligned,
  1    66 	     2 next_control_interval
  1    67 			      fixed bin (24) uns unal,
  1    68 	     2 previous_control_interval
  1    69 			      fixed bin (24) uns unal,
  1    70 	     2 flags	      unal,
  1    71 	       3 continuation_datum_is_present
  1    72 			      bit (1) unal,
  1    73 	       3 free_slot_is_present
  1    74 			      bit (1) unal,
  1    75 	       3 must_be_zero     bit (4) unal,		/* reserved */
  1    76 	     2 scattered_free_space
  1    77 			      fixed bin (17) unal,
  1    78 	     2 start_of_used_space
  1    79 			      fixed bin (17) unal,
  1    80 	     2 number_of_datums   fixed bin (17) unal;
  1    81 
  1    82      dcl	   1 datum_slot	      aligned based (datum_slot_ptr),
  1    83 	     2 flags	      unal,
  1    84 	       3 special_format_datum
  1    85 			      bit (1) unal,		/* reserved */
  1    86 	       3 is_continued     bit (1) unal,
  1    87 	       3 is_continuation  bit (1) unal,
  1    88 	       3 mbz	      bit (1) unal,		/* reserved */
  1    89 	     2 offset_in_bytes    fixed bin (15) uns unal,
  1    90 	     2 length_in_bits     fixed bin (17) uns unal;
  1    91 
  1    92      dcl	   basic_control_interval_ptr
  1    93 			      ptr;
  1    94      dcl	   bci_header_ptr	      ptr;
  1    95      dcl	   datum_slot_ptr	      ptr;
  1    96 
  1    97      dcl	   BASIC_CI_LAYOUT_1      char (4) aligned init ("bci1") internal static options (constant);
  1    98 
  1    99 /* END INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
      184 
      185 
  2     1 /* BEGIN INCLUDE FILE dm_cm_basic_ci_const.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*   Contains constants useful in describing parts of a basic control interval.
  2     6**/
  2     7 
  2     8 /* HISTORY:
  2     9*Written by Matthew Pierret, 09/20/84.
  2    10*Modified:
  2    11**/
  2    12 
  2    13      dcl	   FREE_SLOT	      init (0) fixed bin (15) uns internal static options (constant);
  2    14      dcl	   BCI_HEADER_LENGTH_IN_BYTES
  2    15 			      init (20) fixed bin internal static options (constant);
  2    16      dcl	   DATUM_POSITION_TABLE_OFFSET_IN_BYTES
  2    17 			      init (20) fixed bin internal static options (constant);
  2    18 
  2    19 
  2    20 /* END INCLUDE FILE dm_cm_basic_ci_const.incl.pl1 */
      186 
      187 
  3     1 /* BEGIN INCLUDE FILE dm_ci_lengths.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*       This include file contains constants which are the length in bytes
  3     5*   of the addressable portion of a control interval.  The addressable portion
  3     6*   is that part of the control interval which callers of file_manager_
  3     7*   may access, specifically, everything between the end of the control
  3     8*   interval header (ci_header) and the control interval trailer (ci_trailer).
  3     9*   Control interval 0 is slightly different, as it also contains an 
  3    10*   unaddressable portion in which it maintains the file attributes.  For
  3    11*   control interval 0 the addressable portion is everything between the end
  3    12*   of the control interval header and the beginning of the file attributes.
  3    13**/
  3    14 
  3    15 /* HISTORY:
  3    16*Written by Matthew Pierret, 11/02/84.
  3    17*Modified:
  3    18**/
  3    19 
  3    20 /* format: style2,ind3 */
  3    21 
  3    22      dcl	   CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES
  3    23 			      fixed bin (17) init (4072) int static options (constant);
  3    24 
  3    25      dcl	   CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES
  3    26 			      fixed bin (17) init (3176) int static options (constant);
  3    27 
  3    28 
  3    29      dcl	   CI_ADDRESSABLE_LENGTH  fixed bin (17) init (4072) int static options (constant);
  3    30 
  3    31      dcl	   CI_0_ADDRESSABLE_LENGTH
  3    32 			      fixed bin (17) init (3176) int static options (constant);
  3    33 
  3    34 /                                                          ˆp    DGHowe                             Ä   Z¥>‚ﬁ^                                                        DGHowe                          doug    Multics              
1   X      J©xÒù  T∆ÎË?  T˘]3c≤none   STY_TELNET                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                òÚ    Henry                                  Zx*∆*R$                                                        Henry                                   Multics              @         Rfñølä  SÎèm¨¥  S∂§øInone   ASCII_CRT                                                                 R],Í*7                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Ä JÁ    Bensoussan                         Ä   »Ù‹–öò,                                                        Bensoussan                              Multics                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   Àg    Radlowsky                              phXîpÇn                                                        Radlowsky                               Multics               9         T∂Ã ê  TΩ3u  TA+sÌ¸none   STY_TELNET                                                                S˚¥«á                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                Ä ~ÿ    Clingen                            Ä   V∆t¯™‚™F                                                        Clingen                                 Multics                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Ä ö"    Roughsedge                             ñ∆Bdp
¸Ë                                                        Roughsedge                              HFED                                   NÛ∫VoO  NÛ∫ËUnone   VIP7205                                                                   Nmy9?                                                                Ä ˙:    TapeLib                            Ä   B~»8ñ\ä                                                        TapeLib                                 Operator                       K	vr$  K,öWˆ<  KÓjr<none   VIP7400                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         TION_CAN_RESTART                     internal static bit(36)                  initial dcl 4-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 4-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 4-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 4-7
BCI_HEADER_LENGTH_IN_BYTES             internal static fixed bin(17,0)          initial dcl 2-14
CI_0_ADDRESSABLE_LENGTH                internal static fixed bin(17,0)          initial dcl 3-31
CI_ADDRESSABLE_LENGTH                  internal static fixed bin(17,0)          initial dcl 3-29
basic_control_interval                 based           structure                level 1 dcl 1-56
basic_control_interval_ptr             automatic       pointer                  dcl 1-92
bci_header_ptr                         automatic       pointer                  dcl 1-94
datum_slot_ptr                         automatic       pointer                  dcl 1-95

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_CI_VERSION                000335 constant        entry                    internal dcl 172 ref 104
ERROR_RETURN                    000324 constant        entry                    internal dcl 154 ref 102 147
FINISH                          000333 constant        entry                    internal dcl 165 ref 160
MAIN_RETURN                     000323 constant        label                    dcl 151 ref 161
cm_compact_ci                   000050 constant        entry                    external dcl 33

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       520         540     427         530
Length      1002     427        20         226      70           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cm_compact_ci                      1224 external procedure  is an external procedure.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure cm_compact_ci.  
FINISH                                  internal procedure  shares stack frame of external procedure cm_compact_ci.  
CHECK_CI_VERSION                        internal procedure  shares stack frame of external procedure cm_compact_ci.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cm_compact_ci            000100 ci_id                       cm_compact_ci
                         000101 ci_length_in_bytes          cm_compact_ci
                         000102 code                        cm_compact_ci
                         000103 datum_length_in_bytes       cm_compact_ci
                         000104 file_opening_id             cm_compact_ci
                         000106 local_ci_buffer             cm_compact_ci
                         002106 new_datum_offset_in_bytes   cm_compact_ci
                         002110 new_ci_ptr                  cm_compact_ci
                         002112 new_datum_ptr               cm_compact_ci
                         002114 new_slot_ptr                cm_compact_ci
                         002116 old_ci_ptr                  cm_compact_ci
                         002120 old_datum_ptr               cm_compact_ci
                         002122 old_slot_ptr                cm_compact_ci
                         002124 slot_idx                    cm_compact_ci
                         002125 slot_offset_in_bytes        cm_compact_ci

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              ext_entry           ceil_fx1            divide_fx1

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
file_manager_$get_ci_ptr      file_manager_$simple_put      sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$unimplemented_ci_version


CONSTANTS
000420  aa     037777400000

000422  aa     000002000000
000423  aa     000000000000
000424  aa     600000000041
000425  aa     000102000000

000000  aa     400000000000

000001  aa  142 143 151 061	bci1

000002  aa     000000000015
000003  aa  143 155 137 143	cm_c
000004  aa  157 155 160 141	ompa
000005  aa  143 164 137 143	ct_c
000006  aa  151 040 040 040	i   
000007  aa  040 040 040 040	    
000010  aa  040 040 040 040	    
000011  aa  040 040 040 040	    
000012  aa  040 040 040 040	    

000013  aa     524000000055

000014  aa     404000000005

000015  aa     464000000000

000016  aa     530000000040

000017  aa     524000000004

000426  aa     000000000011

000020  aa     000000000000

000021  aa     404000000043

000022  aa     604000000030

000023  aa     514000000044

000024  aa     077777000043
000025  aa     000001000000

000026  aa     000000000000
000027  aa     000000000000

000030  aa  136 057 105 170	^/Ex
000031  aa  160 145 143 164	pect
000032  aa  145 144 040 166	ed v
000033  aa  145 162 163 151	ersi
000034  aa  157 156 040 136	on ^
000035  aa  064 141 073 040	4a; 
000036  aa  162 145 143 145	rece
000037  aa  151 166 145 144	ived
000040  aa  040 166 145 162	 ver
000041  aa  163 151 157 156	sion
000042  aa  040 136 064 141	 ^4a
000043  aa  056 000 000 000	.

BEGIN PROCEDURE cm_compact_ci
ENTRY TO cm_compact_ci                                      STATEMENT 1 ON LINE 33
cm_compact_ci:
   proc (p_file_opening_id, p_control_interval_id, p_code);

000044  at     000003000023
000045  tt     000022000021
000046  ta     000044000000
000047  da     000064300000
000050  aa   002320 6270 00	eax7 	1232
000051  aa  7 00034 3521 20	epp2 	pr7|28,*
000052  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000053  aa     000006000000
000054  aa     000000000000
						STATEMENT 1 ON LINE 47
000055  aa   000001 3360 07	lcq  	1,dl
000056  aa  6 00101 7561 00	stq  	pr6|65		ci_length_in_bytes
						STATEMENT 1 ON LINE 48
000057  aa  6 00102 4501 00	stz  	pr6|66		code
						STATEMENT 1 ON LINE 49
000060  aa   000001 3360 07	lcq  	1,dl
000061  aa  6 00103 7561 00	stq  	pr6|67		datum_length_in_bytes
						STATEMENT 1 ON LINE 51
000062  aa  6 02126 4501 00	stz  	pr6|1110
000063  aa   000001 2360 07	ldq  	1,dl
000064  aa  6 02127 7561 00	stq  	pr6|1111
000065  aa   000000 0110 03	nop  	0,du
000066  aa  6 02126 0541 00	aos  	pr6|1110
000067  aa  6 02126 2361 00	ldq  	pr6|1110
000070  aa   000001 7360 00	qls  	1
000071  aa   000000 6270 06	eax7 	0,ql
000072  aa   777734 2370 04	ldaq 	-36,ic		000026 = 000000000000 000000000000
000073  aa  6 00104 7571 17	staq 	pr6|68,7		local_ci_buffer
000074  aa  6 02127 2361 00	ldq  	pr6|1111
000075  aa  6 02127 0541 00	aos  	pr6|1111
000076  aa   001000 1160 07	cmpq 	512,dl
000077  aa   777767 6040 04	tmi  	-9,ic		000066
						STATEMENT 1 ON LINE 54
000100  aa   777724 2370 04	ldaq 	-44,ic		000024 = 077777000043 000001000000
000101  aa  6 02110 7571 00	staq 	pr6|1096		new_ci_ptr
						STATEMENT 1 ON LINE 55
000102  aa  6 02112 7571 00	staq 	pr6|1098		new_datum_ptr
						STATEMENT 1 ON LINE 56
000103  aa  6 02114 7571 00	staq 	pr6|1100		new_slot_ptr
						STATEMENT 1 ON LINE 57
000104  aa  6 02116 7571 00	staq 	pr6|1102		old_ci_ptr
						STATEMENT 1 ON LINE 58
000105  aa  6 02120 7571 00	staq 	pr6|1104		old_datum_ptr
						STATEMENT 1 ON LINE 59
000106  aa  6 02122 7571 00	staq 	pr6|1106		old_slot_ptr
						STATEMENT 1 ON LINE 61
000107  aa   000001 3360 07	lcq  	1,dl
000110  aa  6 02125 7561 00	stq  	pr6|1109		slot_offset_in_bytes
						STATEMENT 1 ON LINE 97
      file_opening_id = p_file_opening_id;

000111  aa  6 00032 3735 20	epp7 	pr6|26,*
000112  aa  7 00002 2351 20	lda  	pr7|2,*		p_file_opening_id
000113  aa  6 00104 7551 00	sta  	pr6|68		file_opening_id
						STATEMENT 1 ON LINE 99
      ci_id = p_control_interval_id;

000114  aa  7 00004 2361 20	ldq  	pr7|4,*		p_control_interval_id
000115  aa  6 00100 7561 00	stq  	pr6|64		ci_id
						STATEMENT 1 ON LINE 101
      call file_manager_$get_ci_ptr (file_opening_id, (ci_id), old_ci_ptr, code);

000116  aa  6 02174 7561 00	stq  	pr6|1148
000117  aa  6 00104 3521 00	epp2 	pr6|68		file_opening_id
000120  aa  6 02200 2521 00	spri2	pr6|1152
000121  aa  6 02174 3521 00	epp2 	pr6|1148
000122  aa  6 02202 2521 00	spri2	pr6|1154
000123  aa  6 02116 3521 00	epp2 	pr6|1102		old_ci_ptr
000124  aa  6 02204 2521 00	spri2	pr6|1156
000125  aa  6 00102 3521 00	epp2 	pr6|66		code
000126  aa  6 02206 2521 00	spri2	pr6|1158
000127  aa  6 02176 6211 00	eax1 	pr6|1150
000130  aa   020000 4310 07	fld  	8192,dl
000131  aa  6 00044 3701 20	epp4 	pr6|36,*
000132  la  4 00010 3521 20	epp2 	pr4|8,*		file_manager_$get_ci_ptr
000133  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 102
      if code ^= 0
      then call ERROR_RETURN (code);

000134  aa  6 00102 2361 00	ldq  	pr6|66		code
000135  aa   000004 6000 04	tze  	4,ic		000141
000136  aa   000264 3520 04	epp2 	180,ic		000422 = 000002000000
000137  aa   000165 6700 04	tsp4 	117,ic		000324
000140  aa   000007 7100 04	tra  	7,ic		000147
						STATEMENT 1 ON LINE 104
      else call CHECK_CI_VERSION (old_ci_ptr -> bci_header.layout_type);

000141  aa  6 02116 3521 20	epp2 	pr6|1102,*	bci_header.layout_type
000142  aa  6 02200 2521 00	spri2	pr6|1152
000143  aa  6 02176 3521 00	epp2 	pr6|1150
000144  aa   004000 4310 07	fld  	2048,dl
000145  aa  2 00000 7571 00	staq 	pr2|0
000146  aa   000167 6700 04	tsp4 	119,ic		000335
						STATEMENT 1 ON LINE 106
      new_ci_ptr = addr (local_ci_buffer);

000147  aa  6 00106 3735 00	epp7 	pr6|70		local_ci_buffer
000150  aa  6 02110 6535 00	spri7	pr6|1096		new_ci_ptr
						STATEMENT 1 ON LINE 107
      new_ci_ptr -> bci_header = old_ci_ptr -> bci_header;

000151  aa  6 02116 3715 20	epp5 	pr6|1102,*	old_ci_ptr
000152  aa  000 100 100 500	mlr  	(pr),(pr),fill(000)
000153  aa  5 00000 00 0024	desc9a	pr5|0,20		bci_header
000154  aa  7 00000 00 0024	desc9a	pr7|0,20		bci_header
						STATEMENT 1 ON LINE 109
      if ci_id = 0
      then ci_length_in_bytes = CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES;

000155  aa  6 00100 2361 00	ldq  	pr6|64		ci_id
000156  aa   000004 6010 04	tnz  	4,ic		000162
000157  aa   006150 2360 07	ldq  	3176,dl
000160  aa  6 00101 7561 00	stq  	pr6|65		ci_length_in_bytes
000161  aa   000003 7100 04	tra  	3,ic		000164
						STATEMENT 1 ON LINE 111
      else ci_length_in_bytes = CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES;

000162  aa   007750 2360 07	ldq  	4072,dl
000163  aa  6 00101 7561 00	stq  	pr6|65		ci_length_in_bytes
						STATEMENT 1 ON LINE 113
      new_datum_offset_in_bytes = ci_length_in_bytes;

000164  aa  6 02106 7561 00	stq  	pr6|1094		new_datum_offset_in_bytes
						STATEMENT 1 ON LINE 115
      slot_offset_in_bytes = DATUM_POSITION_TABLE_OFFSET_IN_BYTES;

000165  aa   000024 2360 07	ldq  	20,dl
000166  aa  6 02125 7561 00	stq  	pr6|1109		slot_offset_in_bytes
						STATEMENT 1 ON LINE 117
      do slot_idx = 1 to old_ci_ptr -> bci_header.number_of_datums;

000167  aa  5 00004 2351 00	lda  	pr5|4		bci_header.number_of_datums
000170  aa   000022 7350 00	als  	18
000171  aa   000066 7330 00	lrs  	54
000172  aa  6 02130 7561 00	stq  	pr6|1112
000173  aa   000001 2360 07	ldq  	1,dl
000174  aa  6 02124 7561 00	stq  	pr6|1108		slot_idx
000175  aa   000000 0110 03	nop  	0,du
000176  aa  6 02124 2361 00	ldq  	pr6|1108		slot_idx
000177  aa  6 02130 1161 00	cmpq 	pr6|1112
000200  aa   000064 6054 04	tpnz 	52,ic		000264
						STATEMENT 1 ON LINE 119
         old_slot_ptr = addcharno (old_ci_ptr, slot_offset_in_bytes);

000201  aa  6 02116 3521 20	epp2 	pr6|1102,*	old_ci_ptr
000202  aa  6 02125 2361 00	ldq  	pr6|1109		slot_offset_in_bytes
000203  aa  2 00000 5005 06	a9bd 	pr2|0,ql
000204  aa  6 02122 2521 00	spri2	pr6|1106		old_slot_ptr
						STATEMENT 1 ON LINE 120
         new_slot_ptr = addcharno (new_ci_ptr, slot_offset_in_bytes);

000205  aa  6 02110 3515 20	epp1 	pr6|1096,*	new_ci_ptr
000206  aa  1 00000 5005 06	a9bd 	pr1|0,ql
000207  aa  6 02114 2515 00	spri1	pr6|1100		new_slot_ptr
						STATEMENT 1 ON LINE 122
         new_slot = old_slot;

000210  aa  2 00000 2351 00	lda  	pr2|0		old_slot
000211  aa  1 00000 7551 00	sta  	pr1|0		new_slot
						STATEMENT 1 ON LINE 124
         if old_slot.offset_in_bytes ^= FREE_SLOT
         then
	  do;

000212  aa  2 00000 2351 00	lda  	pr2|0		old_slot.offset_in_bytes
000213  aa   000004 7350 00	als  	4
000214  aa   000071 7730 00	lrl  	57
000215  aa   000043 6000 04	tze  	35,ic		000260
						STATEMENT 1 ON LINE 127
	     datum_length_in_bytes = ceil (divide (old_slot.length_in_bits, BITS_PER_BYTE, 35, 18));

000216  aa  2 00000 2361 00	ldq  	pr2|0		old_slot.length_in_bits
000217  aa  0 00376 3771 00	anaq 	pr0|254		= 000000000000 000000377777
000220  aa   000206 3520 04	epp2 	134,ic		000426 = 000000000011
000221  aa  0 01262 7001 00	tsx0 	pr0|690		divide_fx1
000222  aa     000000000022
000223  aa   000022 7220 07	lxl2 	18,dl
000224  aa  0 01116 7001 00	tsx0 	pr0|590		ceil_fx1
000225  aa  6 00103 7561 00	stq  	pr6|67		datum_length_in_bytes
						STATEMENT 1 ON LINE 129
	     new_datum_offset_in_bytes = new_datum_offset_in_bytes - datum_length_in_bytes;

000226  aa  6 02106 3361 00	lcq  	pr6|1094		new_datum_offset_in_bytes
000227  aa   000044 7770 00	llr  	36
000230  aa   000044 7330 00	lrs  	36
000231  aa  6 00103 0331 00	adl  	pr6|67		datum_length_in_bytes
000232  aa   000000 5330 00	negl 	0
000233  aa  6 02106 7561 00	stq  	pr6|1094		new_datum_offset_in_bytes
						STATEMENT 1 ON LINE 130
	     new_slot.offset_in_bytes = new_datum_offset_in_bytes;

000234  aa   000065 7370 00	lls  	53
000235  aa  1 00000 6751 00	era  	pr1|0		new_slot.offset_in_bytes
000236  aa   000162 3750 04	ana  	114,ic		000420 = 037777400000
000237  aa  1 00000 6551 00	ersa 	pr1|0		new_slot.offset_in_bytes
						STATEMENT 1 ON LINE 132
	     new_datum_ptr = addcharno (new_ci_ptr, new_slot.offset_in_bytes);

000240  aa  6 02110 3535 20	epp3 	pr6|1096,*	new_ci_ptr
000241  aa  1 00000 2351 00	lda  	pr1|0		new_slot.offset_in_bytes
000242  aa   000004 7350 00	als  	4
000243  aa   000071 7730 00	lrl  	57
000244  aa  3 00000 5005 06	a9bd 	pr3|0,ql
000245  aa  6 02112 2535 00	spri3	pr6|1098		new_datum_ptr
						STATEMENT 1 ON LINE 133
	     old_datum_ptr = addcharno (old_ci_ptr, old_slot.offset_in_bytes);

000246  aa  6 02116 3715 20	epp5 	pr6|1102,*	old_ci_ptr
000247  aa  6 02122 2351 20	lda  	pr6|1106,*	old_slot.offset_in_bytes
000250  aa   000004 7350 00	als  	4
000251  aa   000071 7730 00	lrl  	57
000252  aa  5 00000 5005 06	a9bd 	pr5|0,ql
000253  aa  6 02120 6515 00	spri5	pr6|1104		old_datum_ptr
						STATEMENT 1 ON LINE 135
	     new_datum_ptr -> datum_string = old_datum_ptr -> datum_string;

000254  aa  6 00103 2351 00	lda  	pr6|67		datum_length_in_bytes
000255  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000256  aa  5 00000 00 0005	desc9a	pr5|0,al		datum_string
000257  aa  3 00000 00 0005	desc9a	pr3|0,al		datum_string
						STATEMENT 1 ON LINE 137
	  end;

						STATEMENT 1 ON LINE 139
         slot_offset_in_bytes = slot_offset_in_bytes + BYTES_PER_WORD;

000260  aa   000004 2360 07	ldq  	4,dl
000261  aa  6 02125 0561 00	asq  	pr6|1109		slot_offset_in_bytes
						STATEMENT 1 ON LINE 141
      end;

000262  aa  6 02124 0541 00	aos  	pr6|1108		slot_idx
000263  aa   777713 7100 04	tra  	-53,ic		000176
						STATEMENT 1 ON LINE 143
      new_ci_ptr -> bci_header.start_of_used_space = new_datum_offset_in_bytes;

000264  aa  6 02106 2361 00	ldq  	pr6|1094		new_datum_offset_in_bytes
000265  aa   000066 7370 00	lls  	54
000266  aa  6 02110 3735 20	epp7 	pr6|1096,*	new_ci_ptr
000267  aa  7 00004 5511 60	stba 	pr7|4,60		bci_header.start_of_used_space
						STATEMENT 1 ON LINE 144
      new_ci_ptr -> bci_header.scattered_free_space = 0;

000270  aa   000000 2350 03	lda  	0,du
000271  aa  7 00003 5511 14	stba 	pr7|3,14		bci_header.scattered_free_space
						STATEMENT 1 ON LINE 146
      call file_manager_$simple_put (file_opening_id, (ci_id), START_OF_CI_OFFSET, new_ci_ptr, ci_length_in_bytes, code);

000272  aa  6 00100 2361 00	ldq  	pr6|64		ci_id
000273  aa  6 02174 7561 00	stq  	pr6|1148
000274  aa  6 00104 3521 00	epp2 	pr6|68		file_opening_id
000275  aa  6 02212 2521 00	spri2	pr6|1162
000276  aa  6 02174 3521 00	epp2 	pr6|1148
000277  aa  6 02214 2521 00	spri2	pr6|1164
000300  aa   777520 3520 04	epp2 	-176,ic		000020 = 000000000000
000301  aa  6 02216 2521 00	spri2	pr6|1166
000302  aa  6 02110 3521 00	epp2 	pr6|1096		new_ci_ptr
000303  aa  6 02220 2521 00	spri2	pr6|1168
000304  aa  6 00101 3521 00	epp2 	pr6|65		ci_length_in_bytes
000305  aa  6 02222 2521 00	spri2	pr6|1170
000306  aa  6 00102 3521 00	epp2 	pr6|66		code
000307  aa  6 02224 2521 00	spri2	pr6|1172
000310  aa  6 02210 6211 00	eax1 	pr6|1160
000311  aa   030000 4310 07	fld  	12288,dl
000312  aa  6 00044 3701 20	epp4 	pr6|36,*
000313  la  4 00012 3521 20	epp2 	pr4|10,*		file_manager_$simple_put
000314  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 147
      if code ^= 0
      then call ERROR_RETURN (code);

000315  aa  6 00102 2361 00	ldq  	pr6|66		code
000316  aa   000003 6000 04	tze  	3,ic		000321
000317  aa   000103 3520 04	epp2 	67,ic		000422 = 000002000000
000320  aa   000004 6700 04	tsp4 	4,ic		000324
						STATEMENT 1 ON LINE 150
      p_code = 0;

000321  aa  6 00032 3735 20	epp7 	pr6|26,*
000322  aa  7 00006 4501 20	stz  	pr7|6,*		p_code
						STATEMENT 1 ON LINE 151
MAIN_RETURN:
      return;

000323  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 191
   end cm_compact_ci;

BEGIN PROCEDURE ERROR_RETURN
ENTRY TO ERROR_RETURN                                       STATEMENT 1 ON LINE 154
ERROR_RETURN:
   proc (er_p_code);

000324  aa  6 02152 6501 00	spri4	pr6|1130
000325  aa  6 02154 2521 00	spri2	pr6|1132
						STATEMENT 1 ON LINE 159
      p_code = er_p_code;

000326  aa  2 00002 2361 20	ldq  	pr2|2,*		er_p_code
000327  aa  6 00032 3735 20	epp7 	pr6|26,*
000330  aa  7 00006 7561 20	stq  	pr7|6,*		p_code
						STATEMENT 1 ON LINE 160
      call FINISH ();

000331  aa   000002 6700 04	tsp4 	2,ic		000333
						STATEMENT 1 ON LINE 161
      go to MAIN_RETURN;

000332  aa   777771 7100 04	tra  	-7,ic		000323
						STATEMENT 1 ON LINE 163
   end ERROR_RETURN;

  END PROCEDURE ERROR_RETURN
BEGIN PROCEDURE FINISH
ENTRY TO FINISH                                             STATEMENT 1 ON LINE 165
FINISH:
   proc ();

000333  aa  6 02160 6501 00	spri4	pr6|1136
						STATEMENT 1 ON LINE 168
   end FINISH;

000334  aa  6 02160 6101 00	rtcd 	pr6|1136
  END PROCEDURE FINISH
BEGIN PROCEDURE CHECK_CI_VERSION
ENTRY TO CHECK_CI_VERSION                                   STATEMENT 1 ON LINE 172
CHECK_CI_VERSION:
   proc (ccv_p_version_received);

000335  aa  6 02166 6501 00	spri4	pr6|1142
000336  aa  6 02170 2521 00	spri2	pr6|1144
						STATEMENT 1 ON LINE 177
      if ccv_p_version_received ^= BASIC_CI_LAYOUT_1
      then call sub_err_ (dm_error_$unimplemented_ci_version, myname, ACTION_CANT_RESTART, null (), 0,
	      "^/Expected version ^4a; received version ^4a.", BASIC_CI_LAYOUT_1, ccv_p_version_received);

000337  aa  2 00002 2351 20	lda  	pr2|2,*		ccv_p_version_received
000340  aa   777441 1150 04	cmpa 	-223,ic		000001 = 142143151061
000341  aa   000055 6000 04	tze  	45,ic		000416
000342  aa   777462 3734 24	epp7 	-206,ic*
000343  aa  6 02226 6535 00	spri7	pr6|1174
000344  aa  6 02230 4501 00	stz  	pr6|1176
000345  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000346  aa   777463 00 0060	desc9a	-205,48		000030 = 136057105170
000347  aa  6 02232 00 0060	desc9a	pr6|1178,48
000350  aa  6 00044 3701 20	epp4 	pr6|36,*
000351  la  4 00016 3521 20	epp2 	pr4|14,*		dm_error_$unimplemented_ci_version
000352  aa  6 02250 2521 00	spri2	pr6|1192
000353  aa   777430 3520 04	epp2 	-232,ic		000003 = 143155137143
000354  aa  6 02252 2521 00	spri2	pr6|1194
000355  aa   777423 3520 04	epp2 	-237,ic		000000 = 400000000000
000356  aa  6 02254 2521 00	spri2	pr6|1196
000357  aa  6 02226 3521 00	epp2 	pr6|1174
000360  aa  6 02256 2521 00	spri2	pr6|1198
000361  aa  6 02230 3521 00	epp2 	pr6|1176
000362  aa  6 02260 2521 00	spri2	pr6|1200
000363  aa  6 02232 3521 00	epp2 	pr6|1178
000364  aa  6 02262 2521 00	spri2	pr6|1202
000365  aa   777414 3520 04	epp2 	-244,ic		000001 = 142143151061
000366  aa  6 02264 2521 00	spri2	pr6|1204
000367  aa  6 02170 3715 20	epp5 	pr6|1144,*
000370  aa  5 00002 3521 20	epp2 	pr5|2,*		ccv_p_version_received
000371  aa  6 02266 2521 00	spri2	pr6|1206
000372  aa   777427 3520 04	epp2 	-233,ic		000021 = 404000000043
000373  aa  6 02270 2521 00	spri2	pr6|1208
000374  aa   777422 3520 04	epp2 	-238,ic		000016 = 530000000040
000375  aa  6 02272 2521 00	spri2	pr6|1210
000376  aa   777425 3520 04	epp2 	-235,ic		000023 = 514000000044
000377  aa  6 02274 2521 00	spri2	pr6|1212
000400  aa   777415 3520 04	epp2 	-243,ic		000015 = 464000000000
000401  aa  6 02276 2521 00	spri2	pr6|1214
000402  aa   777412 3520 04	epp2 	-246,ic		000014 = 404000000005
000403  aa  6 02300 2521 00	spri2	pr6|1216
000404  aa   777407 3520 04	epp2 	-249,ic		000013 = 524000000055
000405  aa  6 02302 2521 00	spri2	pr6|1218
000406  aa   777411 3520 04	epp2 	-247,ic		000017 = 524000000004
000407  aa  6 02304 2521 00	spri2	pr6|1220
000410  aa  6 02306 2521 00	spri2	pr6|1222
000411  aa  6 02246 6211 00	eax1 	pr6|1190
000412  aa   040000 4310 07	fld  	16384,dl
000413  la  4 00014 3521 20	epp2 	pr4|12,*		sub_err_
000414  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
000415  aa   000002 7100 04	tra  	2,ic		000417
						STATEMENT 1 ON LINE 180
      else return;

000416  aa  6 02166 6101 00	rtcd 	pr6|1142
						STATEMENT 1 ON LINE 182
   end CHECK_CI_VERSION;

000417  aa  6 02166 6101 00	rtcd 	pr6|1142
  END PROCEDURE CHECK_CI_VERSION
  END PROCEDURE cm_compact_ci


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
