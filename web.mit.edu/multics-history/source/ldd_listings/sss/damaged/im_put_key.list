THIS FILE IS DAMAGED

	COMPILATION LISTING OF SEGMENT im_put_key
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phx. Az., Sys-M 
	Compiled on: 07/17/87  1059.9 mst Fri
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 /*  DESCRIPTION:
       11*     This module puts keys into an index collection.  
       12*
       13*          If the index is empty, a "node" is created and the key(s) is
       14*     inserted into it.
       15*
       16*          Otherwise, the existing index is searched for the key to be "put".
       17*     If the key is found (and duplicates aren't allowed) then an error is
       18*     noted and the module returns to its caller.
       19*
       20*          If the key was not found, then an attempt is made to insert the new
       21*     key at the location specified by the im_search_$location operation.  If
       22*     this attempt succeeds then the task is completed and the module returns
       23*     to its caller.
       24*
       25*          If there isn't room in the "target" control interval for the new
       26*     key, then sufficient keys are "rotated" into the left-sibling control
       27*     interval to make room for the new key.  This rotation may move the
       28*     location of the new key into the left-sibling control interval, making
       29*     the left-sibling the target control interval.  The branching key which
       30*     divides the two nodes being rotated between is updated  to reflect the
       31*     new values in the rotated nodes.  If not enough room can be made in this
       32*     fashion for the new key, then the procedure is repeated on the
       33*     right-sibling.
       34*
       35*          If there isn't room for the new key in either the left or right
       36*     sibling nodes, then the original target node is "split".  Half of its
       37*     keys are moved into a new node, which becomes its new right sibling.  The
       38*     new key is inserted into the appropriate one of the nodes involved in the
       39*     split, and a new branching key is added to the parent node of the
       40*     original target node.  
       41*
       42*          In those cases where a branching key is added or changed, the new
       43*     value is put into the parent node using the same algorithm outlined above
       44*     for inserting a new leaf key.  This may cause splits to take place all
       45*     the way up to the root of the tree (index).  When the root splits, a new
       46*     root is created to go above it, and the index has grown a level deeper.
       47**/
       48 
       49 /* HISTORY:
       50*Written by Lindsey Spratt, 04/01/82
       51*Modified:
       52*06/30/82 by Lindsey Spratt: Changed to use im_basic_search instead of
       53*	  im_search_$location (which is  now obsolete).
       54*07/27/82 by Lindsey Spratt: Changed to use
       55*	  index_header.number_of_duplication_fields to enforce the
       56*	  duplication constraint for the index.
       57*08/02/82 by Lindsey Spratt:  Changed to use the new calling sequence for
       58*	  im_compare_vector_and_key.  There is now an argument (which is
       59*	  ignored) which identifies the first field which is not-equal.
       60*08/09/82 by Matthew Pierret:  Changed to use calling sequence of 
       61*            collection_manager_$get_element which does not require specifying
       62*            offset and length. Changed use of 0 for header collection id to
       63*            HEADER_COLLECTION_ID, a constant declared in dm_cm_header.incl.pl1.
       64*            Also added that include file.
       65*08/19/82 by Lindsey Spratt:  Added the array entry point.  Created the
       66*	  put_vector internal subroutine.
       67*08/27/82 by Lindsey Spratt:  Changed to use the new calling sequence to
       68*	  im_basic_search.
       69*08/30/82 by Lindsey Spratt:  Changed to set the cursor to the last
       70*	  successfully "put" key.  Changed the calling sequence of
       71*	  im_initial_insert to return the element_id of the key inserted.
       72*10/13/82 by Matthew Pierret:  Changed to initialize key_string_buffer to "0"b;
       73*11/02/82 by Lindsey Spratt:  Changed to use new calling sequence of
       74*	  im_initial_insert; removing cursor_ptr and index_header_ptr and
       75*	  adding the index_opening_info_ptr.  Changed to set
       76*	  key_count_array.count(0) to 1 when doing the initial_insert rather
       77*	  than invoking im_update_key_counts.  Capitalized internal
       78*	  procedure names.
       79*11/04/82 by Lindsey Spratt:  Changed to use the insert entry of
       80*	  im_basic_search.  This returns the maximum_duplication_field for
       81*	  the given insertion, which interval_specification used to update
       82*	  the key_count_array.
       83*12/09/82 by Lindsey Spratt:  Changed to use the dm_key_count_array incl file.
       84*12/22/82 by Lindsey Spratt:  Changed to use 
       85*	  data_mgmt_util_$cv_vector_to_string.
       86*02/28/83 by Lindsey Spratt:  Changed to use version 3 index_cursor, and to set
       87*	  the cursor using im_set_cursor.
       88*03/24/83 by Lindsey Spratt:  Changed to use version 2 of the field_table.
       89*	  Changed im_compare* to data_mgmt_util_$compare.
       90*09/20/83 by Lindsey L. Spratt:  Fixed to free the key_count_array.  Changed to
       91*            use the ERROR_RETURN and FINISH protocol (eliminating code-passing
       92*            for internal procedures).  Added the internal_debug_sw which can
       93*            be set via the $debug_on and $debug_off entries.  This controls
       94*            the check of the conversion from the vector to the string format.
       95*            (Off by default.)  Changed to not initialize the key_string_buffer.
       96*03/21/84 by Matthew Pierret:  Changed im_basic_search$insert to 
       97*            im_basic_search_insert.
       98*04/09/84 by Matthew Pierret:  Changed im_basic_search_insert to
       99*            im_basic_search$insert.  Jeez, I wish these guys would make up
      100*            their minds.
      101*05/04/84 by Matthew Pierret:  Changed to use FIELD_TABLE_VERSION_3, to use
      102*            get_dm_free_area_ instead of get_system_free_area_, and to remove
      103*            un-used variables.
      104*05/10/84 by Matthew Pierret:  Changed to align key_string_buffer on an
      105*            even-word boundary.  Changed references to data_mgmt_util_ to be
      106*            to data_format_util_.  Removed the put_key procedure label.
      107*10/28/84 by Lindsey L. Spratt:  Changed to use version 2 of
      108*            index_opening_info, and version 2 of key_count_array.
      109*12/03/84 by Matthew Pierret:  Changed to use dm_hdr_collection_id.incl.pl1
      110*            instead of the obsolete dm_cm_header.incl.pl1.
      111**/
      112 
      113 /****^  HISTORY COMMENTS:
      114*  1) change(87-05-06,Dupuis), approve(87-05-29,MCR7695), audit(87-06-02,Blair),
      115*     install(87-07-17,MR12.1-1042):
      116*     Changed the buffer alignment so that key.string would be on a double-word
      117*     boundary. The key string was being aligned on an odd-word boundary and
      118*     this was causing bad comparisons when dealing with fields that needed to
      119*     be aligned on double-word boundaries.
      120*                                                   END HISTORY COMMENTS */
      121 
      122 
      123 /* format: style2,ind3 */
      124 
      125 im_put_key:
      126    proc (p_typed_vector_ptr, p_cursor_ptr, p_code);
      127 
      128 /* START OF DECLARATIONS */
      129 /* Parameter */
      130 
      131       dcl	    p_typed_vector_ptr     ptr;
      132       dcl	    p_typed_vector_array_ptr
      133 			       ptr parameter;
      134       dcl	    p_cursor_ptr	       ptr;
      135       dcl	    p_code	       fixed bin (35);
      136 
      137 /* Automatic */
      138 
      139       dcl	    1 local_leaf_ci_header like leaf_ci_header;
      140       dcl	    maximum_duplication_field
      141 			       fixed bin;
      142 
      143       dcl	    (vector_idx, count_idx)
      144 			       fixed bin (35);
      145       dcl	    use_array	       bit (1) aligned init ("0"b);
      146       dcl	    vector_equal_to_key    bit (1) aligned;
      147       dcl	    vector_less_than_key   bit (1) aligned;
      148       dcl	    myname	       char (32) init ("im_put_key") varying;
      149       dcl	    key_string_buffer      (DOUBLE_WORDS_PER_PAGE) fixed bin (71);
      150 						/* Forces even-word alignment */
      151       dcl	    key_string_buffer_length /* Force key.string to double-word boundary */
      152 			       fixed bin (35) init (BITS_PER_PAGE - BITS_PER_WORD);
      153 
      154       dcl	    key_string_ptr	       ptr;
      155 
      156       dcl	    1 key_element_id       like element_id aligned;
      157 
      158 /* Based */
      159 
      160       dcl	    work_area	       based (work_area_ptr) area;
      161 
      162       dcl	    1 key		       based (key_string_ptr),
      163 	      2 length	       fixed bin (35),
      164 	      2 string	       bit (0 refer (key.length));
      165 
      166       dcl	    key_element_id_string  bit (36) aligned based (addr (key_element_id));
      167 
      168 /* Builtin */
      169 
      170       dcl	    (null, addr, length)   builtin;
      171 
      172 /* Controlled */
      173 /* Constant */
      174 
      175       dcl	    INSERT_KEY	       init ("1"b) bit (1) aligned internal static options (constant);
      176       dcl	    ALL_FIELDS_ARE_PRESENT init (-1) fixed bin (17) unal internal static options (constant);
      177       dcl	    BITS_PER_PAGE	       init (1024 * 36) fixed bin (35) internal static options (constant);
      178       dcl	    BITS_PER_WORD	       init (36) fixed bin (35) internal static options (constant);
      179       dcl	    DOUBLE_WORDS_PER_PAGE  init (512) fixed bin (17) internal static options (constant);
      180 
      181 /* Entry */
      182 
      183       dcl	    im_get_opening_info    entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
      184       dcl	    im_update_opening_info$key_count_array
      185 			       entry (ptr, ptr, fixed bin (35));
      186       dcl	    get_dm_free_area_      entry () returns (ptr);
      187       dcl	    sub_err_	       entry () options (variable);
      188       dcl	    data_format_util_$cv_vector_to_string
      189 			       entry (ptr, ptr, ptr, fixed bin (35), ptr, ptr, fixed bin (35), fixed bin (35));
      190       dcl	    data_format_util_$compare_vector_to_string
      191 			       entry (ptr, ptr, ptr, fixed bin (24), fixed bin unal, fixed bin, bit (1) aligned,
      192 			       bit (1) aligned, fixed bin (35));
      193       dcl	    im_initial_insert      entry (ptr, bit (*), bit (36) aligned, fixed bin (35));
      194       dcl	    im_general_insert      entry (ptr, ptr, bit (1) aligned, bit (*), bit (36) aligned, fixed bin (35));
      195       dcl	    im_basic_search$insert entry (ptr, ptr, ptr, bit (36) aligned, fixed bin, ptr, fixed bin (35));
      196       dcl	    im_set_cursor$at_current
      197 			       entry (ptr, bit (36) aligned, ptr, fixed bin (24), fixed bin (35));
      198 
      199 /* External */
      200 
      201       dcl	    (
      202 	    error_table_$unimplemented_version,
      203 	    dm_error_$key_duplication,
      204 	    dm_error_$wrong_cursor_type,
      205 	    dm_error_$key_not_found,
      206 	    dm_error_$programming_error
      207 	    )		       fixed bin (35) ext;
      208 
      209 /* Internal Static */
      210 
      211       dcl	    work_area_ptr	       ptr init (null) internal static;
      212       dcl	    internal_debug_sw      bit (1) aligned init ("0"b) internal static;
      213 
      214 /* END OF DECLARATIONS */
      215 
      216       typed_vector_array_ptr = null;
      217       use_array = "0"b;
      218       goto JOIN;
      219 
      220 array:
      221    entry (p_typed_vector_array_ptr, p_cursor_ptr, p_code);
      222       typed_vector_array_ptr = p_typed_vector_array_ptr;
      223       use_array = "1"b;
      224       goto JOIN;
      225 
      226 debug_on:
      227    entry ();
      228       internal_debug_sw = "1"b;
      229       return;
      230 
      231 debug_off:
      232    entry ();
      233       internal_debug_sw = "0"b;
      234       return;
      235 
      236 JOIN:
      237       if work_area_ptr = null
      238       then work_area_ptr = get_dm_free_area_ ();
      239 
      240       index_cursor_ptr = p_cursor_ptr;
      241       if index_cursor.type ^= INDEX_CURSOR_TYPE
      242       then call sub_err_ (dm_error_$wrong_cursor_type, myname, ACTION_CANT_RESTART, null, 0,
      243 	      "^/Expected an index cursor, type ^d.  Recieved a cursor of type ^d instead.", INDEX_CURSOR_TYPE,
      244 	      index_cursor.type);
      245 
      246       call CHECK_VERSION ((index_cursor.version), (INDEX_CURSOR_VERSION_3), "index_cursor");
      247 
      248       call im_get_opening_info (index_cursor.file_opening_id, index_cursor.collection_id, index_opening_info_ptr, p_code);
      249       if p_code ^= 0
      250       then call ERROR_RETURN (p_code);
      251 
      252       index_header_ptr = index_opening_info.index_header_ptr;
      253       call CHECK_VERSION_CHAR (index_header.version, INDEX_HEADER_VERSION_4, "index_header");
      254 
      255       field_table_ptr = index_opening_info.field_table_ptr;
      256       call CHECK_VERSION_CHAR (field_table.version, FIELD_TABLE_VERSION_3, "field_table");
      257 
      258       call CHECK_VERSION_CHAR (index_opening_info.key_count_array_ptr -> key_count_array.version,
      259 	 KEY_COUNT_ARRAY_VERSION_2, "key_count_array");
      260 
      261       kca_number_of_counts = index_opening_info.key_count_array_ptr -> key_count_array.number_of_counts;
      262       alloc key_count_array in (work_area);
      263       key_count_array = index_opening_info.key_count_array_ptr -> key_count_array;
      264 
      265       if use_array
      266       then
      267          do vector_idx = 1 to typed_vector_array.number_of_vectors;
      268 	  call PUT_VECTOR ((typed_vector_array.vector_slot (vector_idx)));
      269 	  call im_set_cursor$at_current (index_cursor_ptr, key_element_id_string, addr (key.string),
      270 	       length (key.string), p_code);
      271 	  if p_code ^= 0
      272 	  then call ERROR_RETURN (p_code);
      273          end;
      274       else
      275          do;
      276 	  call PUT_VECTOR (p_typed_vector_ptr);
      277 	  call im_set_cursor$at_current (index_cursor_ptr, key_element_id_string, addr (key.string),
      278 	       length (key.string), p_code);
      279 	  if p_code ^= 0
      280 	  then call ERROR_RETURN (p_code);
      281          end;
      282 
      283       call im_update_opening_info$key_count_array (index_opening_info_ptr, key_count_array_ptr, p_code);
      284       if p_code ^= 0
      285       then call ERROR_RETURN (p_code);
      286 
      287       call FINISH;
      288 
      289 MAIN_RETURN:
      290       return;					/* Effective end of im_put_key */
      291 
      292 FINISH:
      293    proc;
      294       if key_count_array_ptr ^= null
      295       then free key_count_array;
      296    end FINISH;
      297 
      298 ERROR_RETURN:
      299    proc (er_p_code);
      300       dcl	    er_p_code	       fixed bin (35) parameter;
      301       p_code = er_p_code;
      302       call FINISH;
      303       goto MAIN_RETURN;
      304    end ERROR_RETURN;
      305 
      306 PUT_VECTOR:
      307    proc (pv_p_vector_ptr);
      308       dcl	    pv_p_vector_ptr	       ptr;
      309       dcl	    pv_code	       fixed bin (35);
      310 
      311       call data_format_util_$cv_vector_to_string (field_table_ptr, pv_p_vector_ptr, addrel (addr (key_string_buffer), 1),
      312 	 key_string_buffer_length, null, key_string_ptr, (0), pv_code);
      313       if pv_code ^= 0
      314       then call ERROR_RETURN (pv_code);
      315 
      316       if internal_debug_sw
      317       then
      318          do;					/* Validate that the converted string is equal to the vector from which it was created. */
      319 	  call data_format_util_$compare_vector_to_string (field_table_ptr, pv_p_vector_ptr, addr (key.string),
      320 	       (key.length), ALL_FIELDS_ARE_PRESENT, (0), vector_equal_to_key, vector_less_than_key, pv_code);
      321 	  if pv_code ^= 0
      322 	  then call sub_err_ (pv_code, myname, ACTION_CANT_RESTART, null, 0,
      323 		  "^/Unable to compare the input typed_vector and its converted bit string form.");
      324 	  else if ^vector_equal_to_key
      325 	  then call sub_err_ (dm_error_$programming_error, myname, ACTION_CANT_RESTART, null, 0,
      326 		  "^/The input typed vector does not compare equal to its internal bit string form.");
      327          end;
      328 
      329       if index_header.root_id = 0			/* Canonical value meaning no root has been allocated. */
      330       then
      331          do;
      332 	  call im_initial_insert (index_opening_info_ptr, key.string, key_element_id_string, pv_code);
      333 	  if pv_code ^= 0
      334 	  then call ERROR_RETURN (pv_code);
      335 	  key_count_array.count (0) = 1;
      336          end;
      337       else call SEARCH_AND_INSERT;
      338       return;
      339 
      340 SEARCH_AND_INSERT:
      341    proc;
      342       dcl	    sai_code	       fixed bin (35);
      343 
      344       call im_basic_search$insert (index_opening_info_ptr, p_cursor_ptr, pv_p_vector_ptr, key_element_id_string,
      345 	 maximum_duplication_field, addr (local_leaf_ci_header), sai_code);
      346       if sai_code = 0
      347       then call ERROR_RETURN (dm_error_$key_duplication);
      348       else if sai_code ^= dm_error_$key_not_found
      349       then call ERROR_RETURN (sai_code);
      350 
      351       call im_general_insert (index_opening_info_ptr, addr (local_leaf_ci_header), INSERT_KEY, key.string,
      352 	 key_element_id_string, sai_code);
      353       if sai_code ^= 0
      354       then call ERROR_RETURN (sai_code);
      355 
      356       do count_idx = 0 to maximum_duplication_field;
      357          key_count_array.count (count_idx) = key_count_array.count (count_idx) + 1;
      358       end;
      359 
      360    end SEARCH_AND_INSERT;
      361    end PUT_VECTOR;
      362 
      363 CHECK_VERSION:
      364    proc (p_received_version, p_expected_version, p_structure_name);
      365       dcl	    p_received_version     fixed bin (35);
      366       dcl	    p_expected_version     fixed bin (35);
      367       dcl	    p_structure_name       char (*);
      368 
      369       if p_expected_version ^= p_received_version
      370       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      371 	      "^/Expected version ^d of the ^a structure. Received version ^d instead.", p_expected_version,
      372 	      p_structure_name, p_received_version);
      373 
      374    end CHECK_VERSION;
      375 
      376 CHECK_VERSION_CHAR:
      377    proc (p_expected_version, p_received_version, p_structure_name);
      378       dcl	    (p_expected_version, p_received_version)
      379 			       char (8) aligned;
      380       dcl	    p_structure_name       char (*) parameter;
      381 
      382       if p_expected_version ^= p_received_version
      383       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      384 	      "^/Expected version ^a of the ^a structure.  
      385 Received version ^a, instead.", p_expected_version, p_structure_name, p_received_version);
      386    end CHECK_VERSION_CHAR;
      387 
  1     1 /* BEGIN INCLUDE FILE - dm_im_cursor.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*
  1     5*          This structure specifies a DM file, an index collection in that DM
  1     6*file, and a position (key) in that index collection.
  1     7*
  1     8**/
  1     9 
  1    10 /* HISTORY:
  1    11*
  1    12*Written by Lindsey Spratt, 03/29/82
  1    13*Modified:
  1    14*08/09/82 by Matthew Pierret: Changed collection_id from "fixed bin (17)" to
  1    15*            "bit (35) aligned".
  1    16*08/26/82 by Lindsey Spratt:  Changed to version 2.  Added the is_valid and
  1    17*	  is_at_end_of_index flags.  Changed the key_check_value to fixed
  1    18*	  bin (35).  Added the IM_HASH_BIAS, which is used to increment the
  1    19*	  value developed by hash_index_, and IM_HASH_NUMBER_OF_BUCKETS,
  1    20*	  which is a unique number used by hash_index_ to develop the
  1    21*	  key_check_value.
  1    22*02/23/83 by Lindsey Spratt: Changed to keep the current key value in the
  1    23*	  cursor.  Also, implemented the ability to have the cursor
  1    24*	  positioned before or after the index.  
  1    25*10/23/84 by Lindsey L. Spratt:  Added a description section.
  1    26**/
  1    27 
  1    28 /* format: style2,ind3 */
  1    29      dcl	   1 index_cursor	      based (index_cursor_ptr),
  1    30 	     2 type	      fixed bin (17) unaligned,
  1    31 	     2 version	      fixed bin (17) unaligned,
  1    32 	     2 file_opening_id    bit (36) aligned,
  1    33 	     2 collection_id      bit (36) aligned,
  1    34 	     2 key_id_string      bit (36) aligned,	/* Is the location of the current key, */
  1    35 						/* if flags.current_key_exists is on. Is the location */
  1    36 						/* of the end of the index if flags.is_at_end_of_index */
  1    37 						/* is on, which is only available via an operation */
  1    38 						/* requiring the "previous" key.  Is the location of */
  1    39 						/* the "next" key, otherwise. */
  1    40 	     2 area_ptr	      ptr,		/* Area in which the cursor and key_string area allocated. */
  1    41 						/* Must be a freeing area. */
  1    42 	     2 current_key_string_ptr
  1    43 			      ptr,		/* Points to the value of the current key. */
  1    44 	     2 current_key_string_length
  1    45 			      fixed bin (24) unal,	/* Is the length of the current key in bits. */
  1    46 	     2 pad	      bit (12) unal,
  1    47 	     2 flags	      aligned,
  1    48 	       3 is_at_beginning_of_index
  1    49 			      bit (1) unaligned,	/* Only the "next" key is defined. */
  1    50 	       3 is_at_end_of_index
  1    51 			      bit (1) unaligned,	/* Only the "previous" key is defined. */
  1    52 	       3 current_key_exists
  1    53 			      bit (1) unaligned,	/* If on, indicates that the "current" key is identified */
  1    54 						/* by the key_id_string.  If off, the "current" position */
  1    55 						/* is undefined, and the key_id_string identifies the */
  1    56 						/* previous or next key, depending on whether */
  1    57 						/* flags.is_at_end_of_index is off or on, respectively. */
  1    58 	       3 is_valid	      bit (1) unaligned,	/* If off, the index_manager_ was interrupted while */
  1    59 						/* setting the cursor position and the cursor is not */
  1    60 						/* to be trusted for relative position operations. */
  1    61 	       3 pad	      bit (32) unal;
  1    62 
  1    63 
  1    64      dcl	   index_cursor_ptr	      ptr;
  1    65 
  1    66      dcl	   INDEX_CURSOR_VERSION_3 fixed bin (17) init (3) internal static options (constant);
  1    67      dcl	   INDEX_CURSOR_TYPE      init (2) fixed bin (17) internal static options (constant);
  1    68 
  1    69 /* END INCLUDE FILE - dm_im_cursor.incl.pl1 */
      388 
      389 
  2     1 /* BEGIN INCLUDE FILE - dm_im_header.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*          The index_header structure is stored in the header element of an
  2     6*     index collection and describes basic information about the index.
  2     7**/
  2     8 
  2     9 /* HISTORY:
  2    10*
  2    11*Written by Lindsey Spratt, 04/02/82.
  2    12*Modified:
  2    13*10/28/82 by Lindsey Spratt:  Changed to version 3.  Added the key_count_array.
  2    14*	  count(0) is the number of keys in the index.  count(N) is the
  2    15*	  number of keys in the index which have at least fields 1 through N
  2    16*	  having the same value as another key in the index, i.e. count(N)
  2    17*	  is the number of partial duplicates with number of partial
  2    18*	  duplication fields equal to N.
  2    19*10/24/84 by Lindsey L. Spratt:  Added a description. Converted to version 4.
  2    20*	  Replaced the key_count_array with a key_count_array_element_id.
  2    21*	  Changed the version field to char(8).  Aligned the structure.
  2    22**/
  2    23 
  2    24 /* format: style2,ind3 */
  2    25      dcl	   1 index_header	      aligned based (index_header_ptr),
  2    26 	     2 version	      char (8) aligned,
  2    27 	     2 field_table_element_id
  2    28 			      like element_id,
  2    29 	     2 root_id	      fixed bin (24) unsigned unaligned,
  2    30 	     2 pad1	      bit (12) unaligned,
  2    31 	     2 number_of_duplication_fields
  2    32 			      fixed bin (17) unal,
  2    33 	     2 pad2	      bit (18) unal,
  2    34 	     2 key_count_array_element_id
  2    35 			      like element_id;
  2    36 
  2    37      dcl	   index_header_ptr	      ptr;
  2    38      dcl	   INDEX_HEADER_VERSION_4 init ("IdxHdr 4") char (8) aligned internal static options (constant);
  2    39 
  2    40 /* END INCLUDE FILE - dm_im_header.incl.pl1 */
      390 
      391 
  3     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*
  3     5*        Contains the declaration of an element identifier.  Element
  3     6*   identifiers consist of two parts, the id (number) of the control interval
  3     7*   in which the element resides, and the index into the slot table of
  3     8*   the element in the control interval.  The declaration of the element_id 
  3     9*   structure reflects this division of the element identifier.  The structure 
  3    10*   is based on the automatic bit string element_id_string because programs
  3    11*   generally pass bit strings (element_id_string) to each other, then 
  3    12*   interpret the bit string by overlaying the element_id structure ony if
  3    13*   it is necessary to access the parts of the id.  Basing element_id on
  3    14*   addr(element_id_string) instead of on a pointer removes the necessity
  3    15*   for always setting that pointer explicitly and guarantees that changes
  3    16*   made to the string or structure do not get inconsistent.
  3    17*
  3    18*   Changes made to element_id must also be made to datum_id, declared in 
  3    19*   dm_cm_datum.incl.pl1.
  3    20**/
  3    21 
  3    22 /* HISTORY:
  3    23*Written by Matthew Pierret, 04/01/82.
  3    24*Modified:
  3    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  3    26**/
  3    27 
  3    28 /* format: style2,ind3,ll79 */
  3    29 
  3    30      dcl	   element_id_string      bit (36) aligned;
  3    31 
  3    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  3    33 	     2 control_interval_id
  3    34 			      fixed bin (24) unal unsigned,
  3    35 	     2 index	      fixed bin (12) unal unsigned;
  3    36 
  3    37 
  3    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      392 
      393 
  4     1 /* BEGIN INCLUDE FILE - dm_im_ci_header.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*
  4     5*          Each node (control interval) in the index has a header which
  4     6*     describes the contents of that node.  Although there are two diffe      ¯ˇ                                                         ˛Pˇˇˇ÷   Eichele                 Multics     ê   Ä   ãl`< ‹)              Qı]ﬁO4   .     ¯        @     ˛4      ¯ˇ                                                         ˛"ˇˇˇ÷   Samanani                Multics     ê   Ä   ãl]q ‹              Qı!%ˇº   \     ¯        n     ˛      ¯Á                                                         ˝Ùˇˇˇ÷   Oke                     Multics     ê   Ä   ã≤¢ÄÏ∑              Q˜„r   ä     ¯    h  ú     ˝ÿ      ¯ˇ                                                         ˝∆ˇˇˇ÷   Mabey                   Multics     ê   Ä   ã≤≥¿Ì,              Q¯†≠Ì¯   ∏     ¯              ˝™      ¯ˇ                                                         ˝òˇˇˇ÷   Leskiw                  Multics     ê   Ä   ã≤˝ï@Ïx              QˆŸ”¿Å   Ê     ¯        ¯     ˝|      ¯ˇ                                                         ˝jˇˇˇ÷   Fudge                   SysAdmin    ê   Ä   ãl]¿‹Ï              QıSÁ\         ¯        &     ˝N      ¯ˇ                                                         ˝<ˇˇˇ÷   McDonald                Office      ê   Ä   ô¶;¨ ™$              SVö≥Q   B     ¯    ﬁ  T     ˝       ¯ˇ                                                         ˝ˇˇˇ÷   Westcott                Multics     ê   Ä   äÒ∫∂ =∂              Q°C=ë   p     ¯ñ      Ç     ˝Ú      ¯ˇ                                                          ˝‡ˇˇˇ÷   Clayton                 Multics     ê   Ä   ãlaJÄ‹D              Qıázl!   û     ¯        ∞     ˝ƒ      ¯ˇ                                                         ˝≤ˇˇˇ÷   Lausen                  Office      ê   Ä   ãò‰¿¶ï              Q÷∏5   Ã     ¯        ﬁ     ˝ñ      ¯ˇ                                                          ˝Ñˇˇˇ÷   McRory                  CDC         ê   Ä   åçY@$≈              Q•ã   ˙     ¯             ˝h      ¯ˇ                                                         ˝Vˇˇˇ÷    Siler                   Office      ê   Ä   éedrÄ‚              Qî:EÁ©   (     ¯    :  :     ˝:       ¯ˇ                                                         ˝(ˇˇˇ÷   !Thompson                Multics     ê   Ä   ê(ñ« 
ﬂ              R…ÂX/   V     ¯        h     ˝   !   ¯                                                          ¸˙ˇˇˇ÷   "Platnich                Office      ê   Ä   íÎZÄ;6              RûÚ9.«   Ñ     ¯        ñ     ¸ﬁ   "   ¯                                                           ¸Ãˇˇˇ÷   #WAAnderson              SysMaint    Ä   Ä   úÃ «¿:V              S0¬ÊZC   ≤     ¯               ¸∞   #   ¯                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     @                        }6„Z¬üzå‚~2r        
ø  “  b   ∂ ƒ, †      @                                                                                                   = L          SwXë  _                                                S÷˝.     ò  ôˇ            &   H   Ç               &                  †   ≤÷  j   ˛¯  2      å  |      j      ÿX         Ñ˛      ¢ z  f    ‚       ⁄4 »4                    }6„Z > |  &Äq	WJÇ=á    z z ∂ ƒa          r /    Falck.profile                       Äq	WJÖªÂ    G†2í               $   ò Æ ∂ ƒa l            }6„Z     Æ     ∂ ƒ*@          Äq	W      :         SysDaemon                           }6„Z   ò     †*@          Äq	W    v       0    Falck                               }6„Z:       .    Office                              }6„Z |    &}z÷.>ÑôC    ⁄ ⁄ ∂ ƒa          “ 8    start_up.ec                         }z÷.>Ö·g    Gù`H               $     ¯ ∂ ƒa G            }6„Z             †*@          }z÷.     ¯     ∂ ƒ*@          }z÷.    , >  &Äq–M€ˆ      ∂ ƒa           9    Falck.value                         Äq–Mïu    Gwß˘              $   6 . ∂ ƒa 	ê            }6„Z       6     †*@          Äq–     .     ∂ ƒ*@          Äq–      r  &ÄqÕ>=˘–    F F ∂ ƒa          > .    Falck.mbx                           ÄqÕRyÀí    GõL‰Á              I   t l ∂ ƒa               }6„Z     l t     †*@  (       ÄqÕ       d      *@  (       ÄqÕ     d     ∂  *@  ¯       ÄqÕ     r “  &}z‹Go2Ü    Ñ Ñ ∂ ƒa          | (    Falck.mlsys                         }z‹Hœ∞˘    €Ó2Æå                  ™ ¢ ∂ ƒa   ‚~2r        }6„Z       ™     †*¿  ¿       }z‹     ¢     ∂  *¿  ¿       }z‹      2  *     mssmi.forum                         ãRyÃö  &îLjÛRz;M    » » ∂ ƒa          ¿ :    all.mls                             îLjÛJ©Äz    GwßÛ              $   Ó Ê ∂ ƒa ë            }6„Z       Ó     †*@          îLjÛ     Ê     ∂ ƒ*¿          îLjÛ    b,  &àõCYM„ÂŸ    ˛ ˛ ∂ ƒa          ˆ     xps3.dial_out                       àõCYM‰7E    Göæ•ô              $  H,:a 3            }6„Z    $    ,:*@          àõCY    H   ∂ ƒ*@          àõCY     ˆ   &àõC]DaD"   44 ∂ ƒa         , ;    dialing.doc                         àõC]Dbü0    GõL‰}              $  ZR ∂ ƒa $            }6„Z      Z     †*@          àõC]    R     ∂ ƒ*@          àõC]    ò ˆ  &àõPmDu,S   jj ∂ ƒa         b     start_up.dial_out                   àõPmDäº¶    G£≠Q*              $  êà ∂ ƒa P            }6„Z      ê     †*@          àõPm    à     ∂ ƒ*¿          àõPm    b  &à–ù‘DuŒ   †† ∂ ƒa         ò 	    ait -nnl -tm 10                     à–ù‘Däº§    G£≠Q$              $  ∆æ ∂ ƒa Y            }6„Z      ∆     †*@          à–ù‘    æ     ∂ ƒ*@          à–ù‘    ˆ–  &üQáîO∆s   ÷÷ ∂ ƒa         Œ X  manage.mls                          üQáîO«    Gwß	y              $  ¸Ù ∂ ƒa ñ            }6„Z      ¸     †*@          üQáî    Ù     ∂ ƒ*¿          üQáî    *ò  &ãRyÀEDVΩ    ∂ ƒa          . F  meetings                            ãRyÀ           >udd>Office>Falck       }6„Z                        t  &ãRyÃEDV«   2 ≤ ∂ ƒa    ≤    *     MSS_Marketing_Issues.forum          ãRyÃ           *>udd>sm>ss>mtgs>MSS_Marketing_Issues.forum      }6„Z       †*@          ïÚÂ±      ¢  ö "    scb.forum                           írêY  |  t 1    org_roles.forum                     êòpö*  &êòpHŒ‘
   |f ∂ ƒa   f    t     sei_org_roles.forum                 êòp           #>udd>Multics>Collin>org_roles.forum     }6„Z         ¿t  HírêYIªŸ3   ¢X ∂ ƒa   X    ö -    Social_Club.forum                   írêY           ->udd>Multics>Mabey>meetings>Social_Club.forum       }6„Z                                                                                                                                    ¯   4    sun.telnet                          ïÚÂ±P ¿  &ïÚÂ±JÇLR   ¯ ∂ ƒa   ‚         uofc.telnet                         ïÚÂ±JÖªÁ    G°¶É              $  P ∂ ƒa &s            }6„Z    P     ∂ ƒ*¿          ïÚÂ±      ‚   '    xps3.telnet                         ïÚÂ±  v         WAAnderson                          }6„Z † ƒ         SysAdmin                            }6„Z  $     †*@          àõCY    Ñ  &úŒ≠ÂN1   XXv:a         P     admin.mls                           úŒ≠Â           >sc1>admin.mls      }6„Z                            , ∂         Rosin                               }6„Z™P  &úŒ≠ËN1   ååv:a         Ñ     peritus.mls                         úŒ≠Ë           >sc1>peritus.mls    }6„Z                            –Ñ  &úŒ≠ﬂN1   ≤≤v:a         ™ )    exec.mls                            úŒ≠ﬂ           >sc1>exec.mls       }6„Z                            Œ™  &úŒ≠›N1   ÿÿv:a         – !    directors.mls                       úŒ≠›           >sc1>directors.mls      }6„Z                        ,Œ  &¢@)˜QAsM   ˛˛ ∂ ƒa         ˆ )≤  q                                   ¢@)˜QBêë    Göæ•Y              $  $ ∂ ƒa 0è            }6„Z      $     †*@          ¢@)˜         ∂ ƒ*@          ¢@)˜    bˆ  &§`ø†RyÎ'   44 ∂ ƒa         , 9   Storage.mail                        §`ø†        Gwß              $  ZR ∂ ƒa Ç            }6„Z      Z     †*@          §`ø†    R     ∂ ƒ*@          §`ø†      ,  &§`ø‰Rzg   jj ∂ ƒa         b     all.mls1                            §`ø‰        G£≠Q•              $  êà ∂ ƒa 	2            }6„Z      ê     †*@          §`ø‰    à     ∂ ƒ*¿          §`ø‰                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    he formatted string */
  9    43 	     2 field	      (ft_number_of_fields refer (field_table.number_of_fields)),
  9    44 	       3 flags	      aligned,
  9    45 	         4 descriptor_is_varying
  9    46 			      bit (1) unal,		/* if on, the descriptor is not limited to the standard 36 bits */
  9    47 						/* and is stored in a stand-alone fashion, with field.descriptor */
  9    48 						/* containing the id of the element in which the descriptor is stored. */
  9    49 	         4 length_is_in_characters
  9    50 			      bit (1) unal,		/* if field is varying, the length field describes its length */
  9    51 						/* in characters instead of in bits */
  9    52 	         4 must_be_zero   bit (34) unal,
  9    53 	       3 descriptor	      bit (36) aligned,
  9    54 	       3 location	      fixed bin (35),	/* location of first bit of field in formatted string */
  9    55 	       3 length_in_bits   fixed bin (35),	/* length of field in bits */
  9    56 	     3 location_of_name   fixed bin (17),	/* location of first character of field name in field_names */
  9    57 	     3 length_of_name     fixed bin (17),	/* length of name in characters */
  9    58 	     2 varying_field_map  (ft_number_of_fields refer (field_table.number_of_fields)),
  9    59 	       3 field_id	      fixed bin (17),	/* field_id of Nth varying field */
  9    60 	       3 varying_field_index
  9    61 			      fixed bin (17),	/* ordinality among varying fields of field N */
  9    62 	     2 field_names	      char (ft_length_of_field_names refer (field_table.length_of_field_names));
  9    63 
  9    64 
  9    65      dcl	   field_table_ptr	      ptr;
  9    66      dcl	   ft_length_of_field_names
  9    67 			      fixed bin;
  9    68      dcl	   ft_number_of_fields    fixed bin;
  9    69      dcl	   FIELD_TABLE_VERSION_3  char (8) aligned init ("FldTbl 3") internal static options (constant);
  9    70 
  9    71 dcl field_name char (field_name_length) based (field_name_ptr);
  9    72 
  9    73 dcl field_name_length fixed bin;
  9    74 dcl field_name_ptr ptr;
  9    75 
  9    76 /* END INCLUDE FILE dm_field_table.incl.pl1 */
      404 
      405 
 10     1 /* BEGIN INCLUDE FILE - dm_key_count_array.incl.pl1 */
 10     2 
 10     3 
 10     4 
 10     5 /****^  HISTORY COMMENTS:
 10     6*  1) change(87-01-15,Hergert), approve(87-04-01,MCR7632),
 10     7*     audit(87-02-09,Dupuis), install(87-04-02,MR12.1-1020):
 10     8*     Added the KEY_COUNT_OFFSET_IN_CHARACTERS. This is the offset from the
 10     9*     beginning of the structure to the element key_count_array.count in
 10    10*     characters. Using this it is possible to calculate the key_count_array_ptr
 10    11*     given the "addr (key_count_array.count (0))".
 10    12*                                                   END HISTORY COMMENTS */
 10    13 
 10    14 
 10    15 /* DESCRIPTION:
 10    16*
 10    17*          The key_count_array holds counts of the number of unique key values
 10    18*     in an index.  These values are used by the search optimization done by
 10    19*     MRDS.  count(0) is the number of keys in the index.  count(N) is the
 10    20*     number of keys in the index which have at least fields 1 through N
 10    21*     having the same value as another key in the index, i.e. count(N)
 10    22*     is the number of partial duplicates with number of partial
 10    23*     duplication fields equal to N.
 10    24*
 10    25**/
 10    26 
 10    27 /* HISTORY:
 10    28*
 10    29*Written by Lindsey Spratt, 11/09/82.
 10    30*Modified:
 10    31*10/27/84 by Lindsey L. Spratt:  Changed the version to char(8) aligned.
 10    32*	  Added a description, fixed the history section.
 10    33**/
 10    34 
 10    35 /* format: style2,ind3 */
 10    36      dcl	   1 key_count_array      aligned based (key_count_array_ptr),
 10    37 	     2 version	      char (8) aligned,
 10    38 	     2 number_of_counts   fixed bin (17) unal,
 10    39 	     2 pad	      bit (18) unal,
 10    40 	     2 count	      (0:kca_number_of_counts refer (key_count_array.number_of_counts)) fixed
 10    41 			      bin (35) aligned;
 10    42 
 10    43      dcl	   KEY_COUNT_ARRAY_VERSION_2
 10    44 			      init ("KeyCnt 2") char (8) aligned internal static options (constant);
 10    45      dcl     KEY_COUNT_OFFSET_IN_CHARACTERS
 10    46 			      init (12) fixed bin internal static options (constant);
 10    47 
 10    48      dcl	   key_count_array_ptr    ptr init (null);
 10    49      dcl	   kca_number_of_counts   fixed bin (17) init (0);
 10    50 
 10    51 
 10    52 /* END INCLUDE FILE - dm_key_count_array.incl.pl1 */
      406 
      407 
 11     1 /* BEGIN INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
 11     2 
 11     3 /* DESCRIPTION:
 11     4*     This include file contains declarations of all collection_manager_ 
 11     5*     entrypoints.
 11     6**/
 11     7 
 11     8 /* HISTORY:
 11     9*Written by Matthew Pierret 
 11    10*Modified:
 11    11*04/14/82 by Lindsey Spratt: Changed the control_interval_id parameter of the
 11    12*	  allocate_control_interval operation to be unaligned, as well as
 11    13*	  unsigned.
 11    14*06/17/82 by Matthew Pierret: Added the put_element_portion opertion and
 11    15*            removed the beginning_location parameter from the put_element
 11    16*            operation. Added the create_page_file_operation.
 11    17*08/09/82 by Matthew Pierret: Changed "fixed bin (17)"s to "bit (36) aligned"s
 11    18*            wherever collection_id was required.
 11    19*            Also changed the control_interval_id parameter of the 
 11    20*            allocate_control_interval operation back to be aligned. So there.
 11    21*10/20/82 by Matthew Pierret: Changed $create_page_file to $create_file,
 11    22*            added the argument file_create_info_ptr to $create_file.
 11    23*12/13/82 by Lindsey Spratt:  Corrected $free_control_interval to
 11    24*	  include the zero_on_free bit.
 11    25*12/17/82 by Matthew Pierret: Added cm_$get_id.
 11    26*01/07/83 by Matthew Pierret: Added cm_$put_element_buffered, 
 11    27*            cm_$allocate_element_buffered, cm_$free_element_buffered.
 11    28*04/27/83 by Matthew Pierret: Added cm_$put_unprotected_element,
 11    29*            cm_$put_unprotected_header.
 11    30*11/07/83 by Matthew Pierret: Added $get_element_portion_buffered,
 11    31*             $simple_get_buffered_element.
 11    32*02/08/84 by Matthew Pierret:  Changed $get_id to have only one bit(1)aligned
 11    33*            parameter for specifying absolute/relative nature of search.
 11    34*03/16/84 by Matthew Pierret:  Added cm_$get_control_interval_ptr,
 11    35*            $get_element_ptr, $get_element_portion_ptr, $simple_get_element_ptr
 11    36*04/03/84 by Matthew Pierret:  Added cm_$compact_control_interval.
 11    37*06/06/84 by Matthew Pierret:  Re-named free_element* to delete and
 11    38*            delete_from_ci_buffer.
 11    39*            Re-named *_buffered_ci to =_ci_buffer.
 11    40*            get entries.
 11    41*            modify entries.
 11    42*            Changed calling sequence of modify entries to have a ptr/length
 11    43*            instead of length/ptr parameter pair.
 11    44*03/11/85 by R. Michael Tague:  Added $postcommit_increments.
 11    45**/
 11    46 
 11    47 /* This include file contains declarations of collection_manager_ entrypoints */
 11    48 
 11    49 /* format: style2,ind3 */
 11    50      dcl	   collection_manager_$allocate_control_interval
 11    51 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
 11    52      dcl	   collection_manager_$compact_control_interval
 11    53 			      entry (bit (36) aligned, fixed bin (24) uns, fixed bin (35));
 11    54      dcl	   collection_manager_$create_collection
 11    55 			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
 11    56      dcl	   collection_manager_$create_file
 11    57 			      entry (char (*), char (*), ptr, bit (36) aligned, fixed bin (35));
 11    58      dcl	   collection_manager_$destroy_collection
 11    59 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
 11    60      dcl	   collection_manager_$free_control_interval
 11    61 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, bit (1) aligned,
 11    62 			      fixed bin (35));
 11    63 
 11    64      dcl	   collection_manager_$delete
 11    65 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
 11    66 			      fixed bin (35));
 11    67      dcl	   collection_manager_$delete_from_ci_buffer
 11    68 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
 11    69 			      fixed bin (35));
 11    70 
 11    71      dcl	   collection_manager_$get
 11    72 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
 11    73 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
 11    74      dcl	   collection_manager_$get_control_interval_ptr
 11    75 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, ptr,
 11    76 			      fixed bin (35));
 11    77      dcl	   collection_manager_$get_from_ci_buffer
 11    78 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
 11    79 			      ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
 11    80      dcl	   collection_manager_$get_by_ci_ptr
 11    81 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
 11    82 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), ptr, fixed bin (35));
 11    83      dcl	   collection_manager_$get_header
 11    84 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (17), ptr, bit (1) aligned,
 11    85 			      ptr, fixed bin (35), fixed bin (35));
 11    86      dcl	   collection_manager_$get_id
 11    87 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17),
 11    88 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
 11    89      dcl	   collection_manager_$get_portion
 11    90 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
 11    91 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
 11    92 			      fixed bin (35), fixed bin (35));
 11    93      dcl	   collection_manager_$get_portion_from_ci_buffer
 11    94 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
 11    95 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
 11    96 			      fixed bin (35));
 11    97      dcl	   collection_manager_$get_portion_by_ci_ptr
 11    98 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
 11    99 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
 11   100 			      fixed bin (35));
 11   101      dcl	   collection_manager_$modify
 11   102 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
 11   103 			      fixed bin (35), fixed bin (35));
 11   104      dcl	   collection_manager_$modify_unprotected
 11   105 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
 11   106 			      fixed bin (35), fixed bin (35));
 11   107      dcl	   collection_manager_$modify_in_ci_buffer
 11   108 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
 11   109 			      fixed bin (35), fixed bin (35));
 11   110      dcl	   collection_manager_$modify_portion
 11   111 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35), ptr,
 11   112 			      fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
 11   113      dcl	   collection_manager_$postcommit_increments
 11   114 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
 11   115      dcl	   collection_manager_$put
 11   116 			      entry (bit (36)      @                        Sâî”¬üzå‚~2r        ◊   
   ‹Ú  !  s @                                                                åú§¨                         ˚ L S     Cr‰ƒSwXë   ø                                                SwXë     “  ôˇÃ ƒ    î &   H   Ç               Ç      
í  (  L  X    ≤          ò      ™      ¸      r
†      Ç
    	&        V      	l\                          	
t                ﬁt      
¸    *                          &            ∏    
:  
z    j      	˙                ∞
∏      ¸0^      V          
ﬁ        (              ¶^&÷      ú          Ú      
,:	ƒ      –
      
    \  ∆0    (¥  Œ        	                   L    
|        
n  ∞
í          ˙        å|        
P  ¸            Sâî”J`     Q    Fortran                             Sâî”J     2    Multics                             Sâî” ¯4     $    SysAdmin                            Sâî”  Í     X    SysDaemon                           Sâî”Ú ¯         SysMaint                            Sâî” "           BWong                               Sâî” 0          DGHowe                              Sâî” > "         DRobinson                           Sâî” L 0         Fudge                               Sâî” Z >         Ginter                              Sâî” h L         Gray                                Sâî” v Z         Ho                                  Sâî” Ñ h     #    Hoover                              Sâî” í v     *    Huen                                Sâî” † Ñ         IMFT                                Sâî” Æ í         Initializer                         Sâî” º †         MPresser                            Sâî”   Æ         Mabey                               Sâî” ÿ º     .    Oke                                 Sâî” Ê           RWaters                             Sâî” Ù ÿ         Repair                              Sâî” Ê         Samanani                            Sâî” Ù         Vu                                  Sâî”       	    Westcott                            Sâî”î    &Sâî‘Go¬T   && † ¯z          û    exl                                 Sâî‘GoƒN    ‡˝∞Ñ Ü               ¯ 
Då † ¯z   ‚~2r        Sâî”    L     í ¯z@  ¿       Sâî‘    TD   Ñ ‹*@  ¿       Sâî‘    \L   Z  *@  ¿       Sâî‘    dT   ÿ  *@  ¿       Sâî‘    l\      *@  ¿       Sâî‘    td   v  *@  ¿       Sâî‘    |l   Ñ  *@  ¿       Sâî‘    Ñt     *@  ¿       Sâî‘    å|     ¯*@  ¿       Sâî‘      Ñ      *@          Sâî‘    "  &SâïGo√Û   úú † ¯z         î £    fips_mike                           SâïRQBV    ‡˝∞Ñ 3               ¯ ∫ † ¯z   ‚~2r        Sâî”    ¬     í ¯z@  ¿       Sâï     ∫   > Ím@  ¿       Sâï    “¬   º ‹*@  ¿       Sâï    ⁄    Ñ ‹*@  ¿       Sâï    ‚“   º Œ*@  ¿       Sâï    Í⁄   Ê Í*@  ¿       Sâï    Ú‚   > Í*@  ¿       Sâï    ˙Í   Z  *@  ¿       Sâï    Ú     *@  ¿       Sâï    
˙   Ñ  *@  ¿       Sâï          *@  ¿       Sâï    
     ¯*@  ¿       Sâï            *@          Sâï    êî  &Sâó-Cpú   ** v Œa         " S    2649.acs                            Sâó-Cp‘¸    Gwß/              $  	àH v Œa               Sâî”      P     Œ*           Sâó-    HX     ¯*@          Sâó-    P`    *Ä          Sâó-    Xh      *Ä          Sâó-    `p   v  *Ä          Sâó-    hx   Ñ  *Ä          Sâó-    pÄ   Z  *Ä          Sâó-    xà   v Œ*@          Sâó-    Ä     > Í*¿          Sâó-    Œ"  &Sâó0Cpú   òò h Ía         ê     Fortran.old.pmf                     Sâó0Cp‘˝    Gù`H             $  ∆¥   Œa ›            Sâî”    ¥æ      *@          Sâó0    ∂∆   v  *@          Sâó0    æ     > Í*¿          Sâó0    0ê  &Sâó1Go√1   ÷ † ¯z   Ù    Œ ü    Gray                                Sâó1G¶JH    ‡˝∞Ñ 5               x ( † ¯z   ‚~2r        Sâî”    ÷  Œ ú    rg                              _VERSION_4          000004 constant        char(8)                  initial dcl 2-38 set ref 253*
INSERT_KEY                      000030 constant        bit(1)                   initial dcl 175 set ref 351*
KEY_COUNT_ARRAY_VERSION_2       000000 constant        char(8)                  initial dcl 10-43 set ref 258*
addr                                                   builtin function         dcl 170 ref 269 269 269 277 277 277 311 311 319 319
                                                                                  332 344 344 344 351 351 351
collection_id             2            based           bit(36)                  level 2 dcl 1-29 set ref 248*
common_ci_header                       based           structure                level 1 unaligned dcl 4-26
count                     3            based           fixed bin(35,0)          array level 2 dcl 10-36 set ref 335* 357* 357
count_idx                       000107 automatic       fixed bin(35,0)          dcl 143 set ref 356* 357 357*
data_format_util_$compare_vector_to_string
                                000026 constant        entry                    external dcl 190 ref 319
data_format_util_$cv_vector_to_string
                                000024 constant        entry                    external dcl 188 ref 311
dm_error_$key_duplication       000042 external static fixed bin(35,0)          dcl 201 set ref 346*
dm_error_$key_not_found         000046 external static fixed bin(35,0)          dcl 201 ref 348
dm_error_$programming_error     000050 external static fixed bin(35,0)          dcl 201 set ref 324*
dm_error_$wrong_cursor_type     000044 external static fixed bin(35,0)          dcl 201 set ref 241*
element_id                             based           structure                level 1 dcl 3-32
er_p_code                              parameter       fixed bin(35,0)          dcl 300 ref 298 301
error_table_$unimplemented_version
                                000040 external static fixed bin(35,0)          dcl 201 set ref 369* 382*
field_table                            based           structure                level 1 dcl 9-36
field_table_ptr           6            based           pointer                  initial level 2 in structure "index_opening_info"
                                                                                  dcl 8-26 in procedure "im_put_key" ref 255
field_table_ptr                 000142 automatic       pointer                  dcl 9-65 in procedure "im_put_key" set ref 255* 256
                                                                                  311* 319*
file_opening_id           1            based           bit(36)                  level 2 dcl 1-29 set ref 248*
get_dm_free_area_               000020 constant        entry                    external dcl 186 ref 236
im_basic_search$insert          000034 constant        entry                    external dcl 195 ref 344
im_general_insert               000032 constant        entry                    external dcl 194 ref 351
im_get_opening_info             000014 constant        entry                    external dcl 183 ref 248
im_initial_insert               000030 constant        entry                    external dcl 193 ref 332
im_set_cursor$at_current        000036 constant        entry                    external dcl 196 ref 269 277
im_update_opening_info$key_count_array
                                000016 constant        entry                    external dcl 184 ref 283
index_cursor                           based           structure                level 1 unaligned dcl 1-29
index_cursor_ptr                000132 automatic       pointer                  dcl 1-64 set ref 240* 241 241 246 248 248 269* 277*
index_header                           based           structure                level 1 dcl 2-25
index_header_ptr                000134 automatic       pointer                  dcl 2-37 in procedure "im_put_key" set ref 252* 253
                                                                                  329
index_header_ptr          4            based           pointer                  initial level 2 in structure "index_opening_info"
                                                                                  dcl 8-26 in procedure "im_put_key" ref 252
index_opening_info                     based           structure                level 1 dcl 8-26
index_opening_info_ptr          000140 automatic       pointer                  initial dcl 8-46 set ref 248* 252 255 258 261 263
                                                                                  283* 8-46* 332* 344* 351*
internal_debug_sw               000012 internal static bit(1)                   initial dcl 212 set ref 228* 233* 316
kca_number_of_counts            000146 automatic       fixed bin(17,0)          initial dcl 10-49 set ref 261* 262 262 10-49*
key                                    based           structure                level 1 unaligned dcl 162
key_count_array                        based           structure                level 1 dcl 10-36 set ref 262 263* 263 294
key_count_array_ptr      10            based           pointer                  initial level 2 in structure "index_opening_info"
                                                                                  dcl 8-26 in procedure "im_put_key" ref 258 261 263
key_count_array_ptr             000144 automatic       pointer                  initial dcl 10-48 in procedure "im_put_key" set ref
                                                                                  262* 263 283* 10-48* 294 294 335 357 357
key_element_id                  000130 automatic       structure                level 1 dcl 156 set ref 269 277 332 344 351
key_element_id_string                  based           bit(36)                  dcl 166 set ref 269* 277* 332* 344* 351*
key_string_buffer               000124 automatic       fixed bin(71,0)          array dcl 149 set ref 311 311
key_string_buffer_length        000124 automatic       fixed bin(35,0)          initial dcl 151 set ref 151* 311*
key_string_ptr                  000126 automatic       pointer                  dcl 154 set ref 269 269 269 269 277 277 277 277 311*
                                                                                  319 319 319 332 351
leaf_ci_header                         based           structure                level 1 unaligned dcl 4-43
length                                                 builtin function         dcl 170 in procedure "im_put_key" ref 269 269 277
                                                                                  277
length                                 based           fixed bin(35,0)          level 2 in structure "key" dcl 162 in procedure
                                                                                  "im_put_key" ref 269 269 269 269 277 277 277 277
                                                                                  319 319 319 332 332 351 351
local_leaf_ci_header            000100 automatic       structure                level 1 unaligned dcl 139 set ref 344 344 351 351
maximum_dimension_name_length
                          4            based           fixed bin(17,0)          level 2 dcl 6-21 ref 268
maximum_duplication_field       000105 automatic       fixed bin(17,0)          dcl 140 set ref 344* 356
myname                          000113 automatic       varying char(32)         initial dcl 148 set ref 148* 241* 321* 324* 369*
                                                                                  382*
null                                                   builtin function         dcl 170 ref 216 236 241 241 8-46 10-48 294 311 311
                                                                                  321 321 324 324 369 369 382 382
number_of_counts          2            based           fixed bin(17,0)          level 2 packed unaligned dcl 10-36 set ref 261 262*
                                                                                  263 294
number_of_dimensions      1            based           fixed bin(17,0)          level 2 dcl 6-21 ref 268
number_of_vectors         2            based           fixed bin(17,0)          level 2 dcl 6-21 ref 265
p_code                                 parameter       fixed bin(35,0)          dcl 135 set ref 125 220 248* 249 249* 269* 271 271*
                                                                                  277* 279 279* 283* 284 284* 301*
p_cursor_ptr                           parameter       pointer                  dcl 134 set ref 125 220 240 344*
p_expected_version                     parameter       char(8)                  dcl 378 in procedure "CHECK_VERSION_CHAR" set ref
                                                                                  376 382 382*
p_expected_version                     parameter       fixed bin(35,0)          dcl 366 in procedure "CHECK_VERSION" set ref 363 369
                                                                                  369*
p_received_version                     parameter       fixed bin(35,0)          dcl 365 in procedure "CHECK_VERSION" set ref 363 369
                                                                                  369*
p_received_version                     parameter       char(8)                  dcl 378 in procedure "CHECK_VERSION_CHAR" set ref
                                                                                  376 382 382*
p_structure_name                       parameter       char                     unaligned dcl 380 in procedure "CHECK_VERSION_CHAR"
                                                                                  set ref 376 382*
p_structure_name                       parameter       char                     unaligned dcl 367 in procedure "CHECK_VERSION" set
                                                                                  ref 363 369*
p_typed_vector_array_ptr               parameter       pointer                  dcl 132 ref 220 222
p_typed_vector_ptr                     parameter       pointer                  dcl 131 set ref 125 276*
pv_code                         000200 automatic       fixed bin(35,0)          dcl 309 set ref 311* 313 313* 319* 321 321* 332* 333
                                                                                  333*
pv_p_vector_ptr                        parameter       pointer                  dcl 308 set ref 306 311* 319* 344*
root_id                   3            based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 2-25 ref 329
sai_code                        000210 automatic       fixed bin(35,0)          dcl 342 set ref 344* 346 348 348* 351* 353 353*
string                    1            based           bit                      level 2 packed unaligned dcl 162 set ref 269 269 269
                                                                                  269 277 277 277 277 319 319 332* 351*
sub_err_                        000022 constant        entry                    external dcl 187 ref 241 321 324 369 382
type                                   based           fixed bin(17,0)          level 2 packed unaligned dcl 1-29 set ref 241 241*
typed_vector_array                     based           structure                level 1 dcl 6-21
typed_vector_array_ptr          000136 automatic       pointer                  dcl 6-43 set ref 216* 222* 265 268
use_array                       000110 automatic       bit(1)                   initial dcl 145 set ref 145* 217* 223* 265
vector_equal_to_key             000111 automatic       bit(1)                   dcl 146 set ref 319* 324
vector_idx                      000106 automatic       fixed bin(35,0)          dcl 143 set ref 265* 268*
vector_less_than_key            000112 automatic       bit(1)                   dcl 147 set ref 319*
vector_slot                            based           pointer                  array level 2 dcl 6-21 ref 268
version                                based           char(8)                  level 2 in structure "key_count_array" dcl 10-36
                                                                                  in procedure "im_put_key" set ref 258*
version                                based           char(8)                  level 2 in structure "index_header" dcl 2-25
                                                                                  in procedure "im_put_key" set ref 253*
version                                based           char(8)                  initial level 2 in structure "field_table" dcl 9-36
                                                                                  in procedure "im_put_key" set ref 256*
version                   0(18)        based           fixed bin(17,0)          level 2 in structure "index_cursor" packed unaligned
                                                                                  dcl 1-29 in procedure "im_put_key" ref 246
work_area                              based           area(1024)               dcl 160 ref 262
work_area_ptr                   000010 internal static pointer                  initial dcl 211 set ref 236 236* 262

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 7-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 7-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 7-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 7-7
BRANCH_CI_HEADER_LENGTH_IN_BITS        internal static fixed bin(17,0)          initial dcl 4-56
DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT
                                       internal static fixed bin(17,0)          initial dcl 4-56
DEFAULT_INITIAL_KEY_SLOT               internal static fixed bin(17,0)          initial dcl 4-56
HEADER_COLLECTION_ID                   internal static bit(36)                  initial dcl 5-19
INDEX_OPENING_INFO_VERSION_3           internal static char(8)                  initial dcl 8-47
KEY_COUNT_OFFSET_IN_CHARACTERS         internal static fixed bin(17,0)          initial dcl 10-45
LEAF_CI_HEADER_LENGTH_IN_BITS          internal static fixed bin(17,0)          initial dcl 4-56
TYPED_VECTOR_ARRAY_VERSION_2           internal static fixed bin(35,0)          initial dcl 6-50
branch_ci_header                       based           structure                level 1 unaligned dcl 4-48
branch_ci_header_ptr                   automatic       pointer                  dcl 4-53
collection_manager_$allocate_control_interval
                                000000 constant        entry                    external dcl 11-50
collection_manager_$compact_control_interval
                                000000 constant        entry                    external dcl 11-52
collection_manager_$create_collection
                                000000 constant        entry                    external dcl 11-54
collection_manager_$create_file 000000 constant        entry                    external dcl 11-56
collection_manager_$delete      000000 constant        entry                    external dcl 11-64
collection_manager_$delete_from_ci_buffer
                                000000 constant        entry                    external dcl 11-67
collection_manager_$destroy_collection
                                000000 constant        entry                    external dcl 11-58
collection_manager_$free_control_interval
                                000000 constant        entry                    external dcl 11-60
collection_manager_$get         000000 constant        entry                    external dcl 11-71
collection_manager_$get_by_ci_ptr
                                000000 constant        entry                    external dcl 11-80
collection_manager_$get_control_interval_ptr
                                000000 constant        entry                    external dcl 11-74
collection_manager_$get_from_ci_buffer
                                000000 constant        entry                    external dcl 11-77
collection_manager_$get_header  000000 constant        entry                    external dcl 11-83
collection_manager_$get_id      000000 constant        entry                    external dcl 11-86
collection_manager_$get_portion 000000 constant        entry                    external dcl 11-89
collection_manager_$get_portion_by_ci_ptr
                                000000 constant        entry                    external dcl 11-97
collection_manager_$get_portion_from_ci_buffer
                                000000 constant        entry                    external dcl 11-93
collection_manager_$modify      000000 constant        entry                    external dcl 11-101
collection_manager_$modify_in_ci_buffer
                                000000 constant        entry                    external dcl 11-107
collection_manager_$modify_portion
                                000000 constant        entry                    external dcl 11-110
collection_manager_$modify_unprotected
                                000000 constant        entry                    external dcl 11-104
collection_manager_$postcommit_increments
                                000000 constant        entry                    external dcl 11-113
collection_manager_$put         000000 constant        entry                    external dcl 11-115
collection_manager_$put_header  000000 constant        entry                    external dcl 11-121
collection_manager_$put_in_ci_buffer
                                000000 constant        entry                    external dcl 11-118
collection_manager_$put_unprotected_header
                                000000 constant        entry                    external dcl 11-123
collection_manager_$replace_ci_buffer
                                000000 constant        entry                    external dcl 11-126
collection_manager_$setup_ci_buffer
                                000000 constant        entry                    external dcl 11-129
collection_manager_$simple_get_by_ci_ptr
                                000000 constant        entry                    external dcl 11-132
collection_manager_$simple_get_from_ci_buffer
                                000000 constant        entry                    external dcl 11-135
common_ci_header_ptr                   automatic       pointer                  dcl 4-41
element_id_string                      automatic       bit(36)                  dcl 3-30
field_name                             based           char                     unaligned dcl 9-71
field_name_length                      automatic       fixed bin(17,0)          dcl 9-73
field_name_ptr                         automatic       pointer                  dcl 9-74
ft_length_of_field_names               automatic       fixed bin(17,0)          dcl 9-66
ft_number_of_fields                    automatic       fixed bin(17,0)          dcl 9-68
leaf_ci_header_ptr                     automatic       pointer                  dcl 4-46
tva_maximum_dimension_name_length      automatic       fixed bin(17,0)          dcl 6-48
tva_number_of_dimensions               automatic       fixed bin(17,0)          dcl 6-46
tva_number_of_vector_slots             automatic       fixed bin(17,0)          dcl 6-44

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_VERSION                   001475 constant        entry                    internal dcl 363 ref 246
CHECK_VERSION_CHAR              001571 constant        entry                    internal dcl 376 ref 253 256 258
ERROR_RETURN                    001040 constant        entry                    internal dcl 298 ref 249 271 279 284 313 333 346 348
                                                                                  353
FINISH                          001024 constant        entry                    internal dcl 292 ref 287 302
JOIN                            000331 constant        label                    dcl 236 ref 218 224
MAIN_RETURN                     001023 constant        label                    dcl 289 ref 303
PUT_VECTOR                      001047 constant        entry                    internal dcl 306 ref 268 276
SEARCH_AND_INSERT               001336 constant        entry                    internal dcl 340 ref 337
array                           000267 constant        entry                    external dcl 220
debug_off                       000320 constant        entry                    external dcl 231
debug_on                        000305 constant        entry                    external dcl 226
im_put_key                      000253 constant        entry                    external dcl 125

NAME DECLARED BY CONTEXT OR IMPLICATION.
addrel                                                 builtin function         ref 311 311

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2206        2260    1726        2216
Length      2716    1726        52         422     260           4

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
im_put_key                          452 external procedure  is an external procedure.  
FINISH                                  internal procedure  shares stack frame of external procedure im_put_key.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure im_put_key.  
PUT_VECTOR                              internal procedure  shares stack frame of external procedure im_put_key.  
SEARCH_AND_INSERT                       internal procedure  shares stack frame of external procedure im_put_key.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure im_put_key.  
CHECK_VERSION_CHAR                      internal procedure  shares stack frame of external procedure im_put_key.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 work_area_ptr               im_put_key
000012 internal_debug_sw           im_put_key

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
im_put_key               000100 local_leaf_ci_header        im_put_key
                         000105 maximum_duplication_field   im_put_key
                         000106 vector_idx                  im_put_key
                         000107 count_idx                   im_put_key
                         000110 use_array                   im_put_key
                         000111 vector_equal_to_key         im_put_key
                         000112 vector_less_than_key        im_put_key
                         000113 myname                      im_put_key
                         000124 key_string_buffer_length    im_put_key
                         000124 key_string_buffer           im_put_key
                         000126 key_string_ptr              im_put_key
                         000130 key_element_id              im_put_key
                         000132 index_cursor_ptr            im_put_key
                         000134 index_header_ptr            im_put_key
                         000136 typed_vector_array_ptr      im_put_key
                         000140 index_opening_info_ptr      im_put_key
                         000142 field_table_ptr             im_put_key
                         000144 key_count_array_ptr         im_put_key
                         000146 kca_number_of_counts        im_put_key
                         000200 pv_code                     PUT_VECTOR
                         000210 sai_code                    SEARCH_AND_INSERT

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          alloc_auto_adj      ext_entry           op_alloc_
op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
data_format_util_$compare_vector_to_string                  data_format_util_$cv_vector_to_string
get_dm_free_area_             im_basic_search$insert        im_general_insert             im_get_opening_info
im_initial_insert             im_set_cursor$at_current      im_update_opening_info$key_count_array
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$key_duplication     dm_error_$key_not_found       dm_error_$programming_error   dm_error_$wrong_cursor_type
error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    145 000217       148 000220       149 000225       151 000233    8   46 000241   10   48 000243   10   49 000244
    125 000247       216 000261       217 000263       218 000264       220 000265       222 000275       223 000301
    224 000303       226 000304       228 000313       229 000316       231 000317       233 000326       234 000330
    236 000331       240 000344       241 000350       246 000427       248 000445       249 000464       252 000475
    253 000500       255 000523       256 000526       258 000552       261 000576       262 000603       263 000615
    265 000626       268 000641       269 000664       271 000711       273 000722       276 000730       277 000737
    279 000764       283 000775       284 001011       287 001022       289 001023       292 001024       294 001025
    296 001037       298 001040       301 001042       302 001045       303 001046       306 001047       311 001051
    313 001107       316 001113       319 001116       321 001153       324 001221       329 001267       332 001273
    333 001324       335 001330       336 001333       337 001334       338 001335       340 001336       344 001337
    346 001366       348 001400       351 001405       353 001447       356 001453       357 001461       358 001467
    360 001474       363 001475       369 001506       374 001570       376 001571       382 001602       386 001672


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
