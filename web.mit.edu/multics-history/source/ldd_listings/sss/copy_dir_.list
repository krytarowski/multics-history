	COMPILATION LISTING OF SEGMENT copy_dir_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 03/15/89  0828.9 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 
       11 
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(87-02-17,TLNguyen), approve(87-02-17,MCR7624),
       15*     audit(87-02-27,Lippard), install(87-03-20,MR12.1-1006):
       16*     - Change "copy_dir_" to always set its returned code parameter before
       17*       returning.
       18*     - Change "copy_dir_" to properly delete the target dir when "-replace"
       19*       is given.  It currently calls "hcs_$del_dir_tree" rather than calling
       20*       "delete_$path".  Therefore it fails to delete Data Managment files.
       21*     - Change "copy_dir_" to properly copy ACLs when -acl is specified.  It
       22*       currently copies only ACLs on 2nd-Nth segments of a directory.
       23*  2) change(88-08-30,TLNguyen), approve(88-08-30,MCR7949),
       24*     audit(88-09-09,Parisek), install(88-11-1,MR12.2-1202):	
       25*     - Change the copy_dir_ to do the containment check before deleting
       26*       the contents of the target which indicated by the replace flag.
       27*     - Change copy_dir_ so that -replace will work as documented for
       28*       the copy_dir command.
       29*                                                   END HISTORY COMMENTS */
       30 
       31 
       32 /* format: style2,idind30,indcomtxt */
       33 copy_dir_:
       34      procedure (whoami, source_dir, source_ename, target_dir, target_ename, pcopy_dir_options, acode);
       35 
       36 /****
       37*
       38*      * Most of this code is from the original copy_dir command.
       39*
       40*      * Status:
       41*      0) Original by LLS in 1978
       42*      1) Modified: 11/80 by GAT to make the subroutines
       43*      2) Gutted: 6/30/83 by Jay Pattin for extended objects
       44*      3) 831002 BIM for extended object cleanup
       45*      4) Modified: 12/84 by Keith Loepere to set dir_quota at append.
       46*      5)  Modified:  2/15/85 M. Sharpe to give up if can't create target */
       47 
       48 /**** * Entries */
       49 	dcl     command_query_	        entry options (variable);
       50 	dcl     copy_		        entry (ptr);
       51 	dcl     com_err_		        entry options (variable);
       52 	dcl     copy_acl_		        entry (char (*), char (*), char (*), char (*), bit (1), fixed bin (35));
       53 	dcl     copy_iacl_		        entry (char (*), char (*), char (*), char (*), bit (1), fixed bin (35));
       54 	dcl     move_names_		        entry (char (*), char (*), char (*), char (*), char (*), bit (1),
       55 				        fixed bin (35));
       56 	dcl     copy_names_		        entry (char (*), char (*), char (*), char (*), char (*), bit (1),
       57 				        fixed bin (35));
       58 
       59 	dcl     continue_to_signal_	        entry (fixed bin (35));
       60 	dcl     expand_pathname_	        entry (char (*), char (*), char (*), fixed bin (35));
       61 	dcl     find_condition_info_	        entry (ptr, ptr, fixed bin (35));
       62 	dcl     get_group_id_$tag_star        entry returns (char (32));
       63 	dcl     get_max_authorization_        entry () returns (bit (72) aligned);
       64 	dcl     get_ring_		        entry () returns (fixed bin (3));
       65 	dcl     get_system_free_area_	        entry returns (ptr);
       66 	dcl     hcs_$get_dir_ring_brackets    entry (char (*), char (*), (2) fixed bin (3), fixed bin (35));
       67 	dcl     hcs_$get_access_class	        entry (char (*), char (*), bit (72) aligned, fixed bin (35));
       68 	dcl     hcs_$append_link	        entry (char (*), char (*), char (*), fixed bin (35));
       69 	dcl     hcs_$create_branch_	        entry (char (*), char (*), ptr, fixed bin (35));
       70 	dcl     hcs_$get_safety_sw	        entry (char (*), char (*), bit (1), fixed bin (35));
       71 	dcl     hcs_$get_uid_file	        entry (char (*), char (*), bit (36) aligned, fixed bin (35));
       72 	dcl     hcs_$get_link_target	        entry (char (*), char (*), char (*), char (*), fixed bin (35));
       73 	dcl     hcs_$set_safety_sw	        entry (char (*), char (*), bit (1), fixed bin (35));
       74 	dcl     hcs_$star_		        entry (char (*), char (*), fixed bin (2), ptr, fixed bin, ptr, ptr,
       75 				        fixed bin (35));
       76 	dcl     hcs_$status_	        entry (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35));
       77 	dcl     hcs_$status_minf	        entry (char (*), char (*), fixed bin (1), fixed bin (2), fixed bin (24),
       78 				        fixed bin (35));
       79 	dcl     cu_$arg_list_ptr	        entry (ptr);
       80 	dcl     cu_$arg_count	        entry (fixed bin, fixed bin (35));
       81 	dcl     cu_$arg_ptr		        entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
       82 	dcl     ioa_$general_rs	        entry (ptr, fixed bin, fixed bin, char (*), fixed bin, bit (1) aligned,
       83 				        bit (1) aligned);
       84 	dcl     ioa_		        entry options (variable);
       85 	dcl     ioa_$rsnnl		        entry options (variable);
       86 	dcl     nd_handler_		        entry (char (*), char (*), char (*), fixed bin (35));
       87 	dcl     nd_handler_$switches	        entry (char (*), char (*), char (*), bit (36) aligned, fixed bin (35));
       88 	dcl     delete_$path	        entry (char (*), char (*), bit (36) aligned, char (*), fixed bin (35));
       89 	dcl     fs_util_$get_type	        entry (character (*), character (*), character (*), fixed binary (35));
       90 	dcl     fs_util_$suffix_info	        entry (char (*), char (*), ptr, fixed bin (35));
       91 	dcl     pathname_		        entry (char (*), char (*)) returns (char (168));
       92 	dcl     sub_err_		        entry () options (variable);
       93 
       94 /* Constants */
       95 
       96 	dcl     no_translation	        fixed bin (35) internal static options (constant) init (1);
       97 
       98 /*  Conditions  */
       99 
      100 	dcl     (cleanup, sub_error_)	        condition;
      101 
      102 /*  Based  */
      103 
      104 	dcl     1 comp		        based (cptr),
      105 		2 name		        char (32) varying,
      106 		2 next		        ptr;
      107 
      108 	dcl     area		        area based (area_ptr);
      109 
      110 /*  Automatic  */
      111 
      112 	dcl     acode		        fixed bin (35);
      113 	dcl     parent_access	        bit (1);
      114 	dcl     (source_dir, source_ename, target_dir, target_ename)
      115 				        char (*);	/* from where to where                            */
      116 	dcl     whoami		        char (*);	/* name of entry into code ("copy_dir" or "move_dir"). */
      117 	dcl     (tt, type)		        fixed bin (2);
      118 						/*  type of entry returned by hcs_$status_minf,
      119*						   0 = link, 1 = seg, 2 = dir. */
      120 	dcl     ln		        fixed bin (21);
      121 						/* length of a char string returned by ioa_$rsnnl. */
      122 	dcl     (code, code1)	        fixed bin (35);
      123 						/* the returned error code from a system call. */
      124 	dcl     bc		        fixed bin (24);
      125 						/* bit count returned by hcs_$status_minf. */
      126 	dcl     answer		        char (3) varying;
      127 						/* answer from user via command_query_ */
      128 	dcl     dir_rings		        (2) fixed bin (3);
      129 						/* ring validation for a directory. */
      130 	dcl     (
      131 	        acl,				/* acl on copy is same as original */
      132 	        all_entries,			/* all entries are copied */
      133 	        all_names,				/* all names on an entry are copied */
      134 	        brief,				/* comments are suppressed */
      135 	        chase,				/* copy targets of links */
      136 	        force,				/* user is not queried about existing target */
      137 	        raw,				/* don't use object_type_ */
      138 	        replace,				/* truncate target_dir before copying */
      139 	        translate_links,			/* translate links */
      140 	        update,				/* name duplications are deleted or unlinked without asking the user */
      141 	        clink,				/* copy links. */
      142 	        cseg,				/* copy segments. */
      143 	        cmsf,				/* copy multisegment files. */
      144 	        cnnl,				/* copy non-null links. */
      145 	        cdir,				/* copy directories. */
      146 	        errors,				/* one or more errors occurred while processing */
      147 	        ersw,				/* used in calls to copy_ utilities to indicate which
      148*						   entry an error occurred on. */
      149 	        source_contains_target,		/* if "1"b, the source directory contains the target directory. */
      150 	        target_contains_source,		/* If "1"b, the target_directory contains the source directory. */
      151 	        safety_sw,				/* used in setting the safety_switch of a branch. */
      152 	        same_dir,				/* se_name and te_name are in the same directory. */
      153 	        move
      154 	        )			        bit (1);	/* delete source_dir after copying */
      155 	dcl     fs_util_type	        char (32);
      156 	dcl     (entry_index, lcomp_count, scomp_count, tcomp_count, ii)
      157 				        fixed bin;
      158 	dcl     (dir1_uid, dir2_uid, uid)     bit (36) aligned;
      159 	dcl     (sd_name, td_name, temp_target_dir)
      160                                                 char (168);
      161 
      162 	dcl     (se_name, le, userid, te_name)
      163 				        char (32);
      164 	dcl     (
      165 	        area_ptr,				/* ptr on which area is based. */
      166 	        cb_ptr,				/* ptr on which create_branch_info is based. */
      167 	        lcomp_root,				/* Path info for link_target(lcomp). */
      168 	        scomp_root,				/* Path info for source_dir. */
      169 	        tcomp_root,				/* Path info for target_dir. */
      170 	        cptr				/* Ptr on which comp is based. */
      171 	        )			        ptr;
      172 
      173 /*  External  */
      174 
      175 	dcl     (
      176 	        error_table_$action_not_performed,
      177 	        error_table_$inconsistent,
      178                   error_table_$bad_ring_brackets,
      179 	        error_table_$incorrect_access,
      180 	        error_table_$no_dir,
      181 	        error_table_$no_s_permission,
      182 	        error_table_$not_seg_type,
      183 	        error_table_$segnamedup,
      184 	        error_table_$namedup,
      185 	        error_table_$noentry,
      186 	        error_table_$nomatch,
      187 	        error_table_$notadir,
      188 	        error_table_$sameseg,
      189 	        error_table_$unimplemented_version
      190 	        )			        fixed bin (35) external;
      191 
      192 /*  Builtins  */
      193 
      194 	dcl     (addr, index, null, reverse, rtrim, ptr, string, substr, sum)
      195 				        builtin;
      196 
      197 
      198 /**** ** Copy all the parameters into local variables. In the case of
      199*      * the structure, this is unneccessary, but is convienient since this
      200*      * did not used to be a seperate routine from the command. */
      201 
      202 	cb_ptr = null ();
      203 	acode = 0; /* must be initialized */
      204 
      205 	on condition (cleanup)
      206 	     begin;
      207 		if cb_ptr ^= null ()
      208 		then free cb_ptr -> create_branch_info in (area);
      209 	     end;
      210 
      211 	if copy_dir_options.version ^= copy_dir_options_version_0
      212 	then do;
      213 		call sub_err_ (error_table_$unimplemented_version, ACTION_CANT_RESTART, null (), (0),
      214 		     "copy_dir_ has been invoked with the wrong version of the copy_dir_options structure.
      215 The version provided was ^d, the expected version is ^d.", copy_dir_options.version, copy_dir_options_version_0);
      216 		return;
      217 	     end;
      218 
      219 	userid = get_group_id_$tag_star ();
      220 	area_ptr = get_system_free_area_ ();
      221 	move = copy_dir_options.delete;
      222 	if ^(copy_dir_options.link | copy_dir_options.dir | copy_dir_options.seg | copy_dir_options.msf
      223 	     | copy_dir_options.nnlk)
      224 	then do;
      225 		call complain (error_table_$action_not_performed, "^/No entries specified to be ^[copied^;moved^].",
      226 		     (^copy_dir_options.delete));
      227 		return;
      228 	     end;
      229 	if (copy_dir_options.link & copy_dir_options.dir & copy_dir_options.seg & copy_dir_options.msf)
      230 	then do;
      231 		all_entries = "1"b;
      232 		clink, cseg, cdir, cmsf, cnnl = "0"b;
      233 	     end;
      234 	else do;
      235 		all_entries = "0"b;
      236 		clink = copy_dir_options.link;
      237 		cseg = copy_dir_options.seg;
      238 		cdir = copy_dir_options.dir;
      239 		cmsf = copy_dir_options.msf;
      240 		cnnl = copy_dir_options.nnlk;
      241 	     end;
      242 	parent_access = copy_dir_options.parent_ac_sw;
      243 	brief = copy_dir_options.brief;
      244 	force = copy_dir_options.force;
      245 	replace = copy_dir_options.replace;
      246 	update = copy_dir_options.update;
      247 	acl = copy_dir_options.acl;
      248 	primary = copy_dir_options.primary;
      249 	translate_links = copy_dir_options.link_translation;
      250 	chase = copy_dir_options.chase;
      251 	raw = copy_dir_options.raw;
      252 	if (replace & update)
      253 	then do;
      254 		call complain (error_table_$inconsistent, "^/Options replace and update specified.");
      255 		return;
      256 	     end;
      257 
      258 	if primary
      259 	then all_names = "0"b;
      260 	else all_names = "1"b;
      261 
      262 
      263 	allocate create_branch_info in (area) set (cb_ptr);
      264 	cb_ptr -> create_branch_info.version = create_branch_version_2;
      265 	cb_ptr -> create_branch_info.quota = 0;
      266 	cb_ptr -> create_branch_info.dir_quota = 0;
      267 	cb_ptr -> create_branch_info.mode = "111"b;
      268 	cb_ptr -> create_branch_info.switches.dir_sw = "1"b;
      269 	cb_ptr -> create_branch_info.switches.copy_sw = "0"b;
      270 	cb_ptr -> create_branch_info.switches.chase_sw = "1"b;
      271 	cb_ptr -> create_branch_info.switches.parent_ac_sw = parent_access;
      272 	cb_ptr -> create_branch_info.priv_upgrade_sw = "0"b;
      273 	cb_ptr -> create_branch_info.userid = userid;
      274 	cb_ptr -> create_branch_info.bitcnt = 0;
      275 
      276 	sd_name = source_dir;			/* copy the name args to the "old" variables      */
      277 	se_name = source_ename;			/* and proceed with existing code                 */
      278 	td_name = target_dir;
      279 	te_name = target_ename;
      280 
      281 	if sd_name = td_name
      282 	then same_dir = "1"b;
      283 	else same_dir = (get_uid (sd_name) = get_uid (td_name));
      284 
      285 /*  check that arg 1 is a directory. */
      286 	call hcs_$status_minf (sd_name, se_name, 0, type, bc, code);
      287 	if code ^= 0 & code ^= error_table_$no_s_permission
      288 	then do;
      289 BAD_STAT:
      290 		call complain (code, "^/Unable to get the status of ^a^[>^]^a.", sd_name, sd_name ^= ">", se_name);
      291 		return;
      292 	     end;
      293 
      294 	if type ^= Directory | bc ^= 0
      295 	then do;
      296 NOT_A_DIR:
      297 		call complain (error_table_$notadir,
      298 		     "^/The source pathname must be a directory. ^a^[>^]^a is not a directory", sd_name,
      299 		     sd_name ^= ">", se_name);
      300 		return;
      301 	     end;
      302 
      303 	if ^raw
      304 	then do;					/* check if it is an extended object */
      305 		call fs_util_$get_type (sd_name, se_name, fs_util_type, code);
      306 		if fs_util_type ^= FS_OBJECT_TYPE_DIRECTORY
      307 		then goto NOT_A_DIR;
      308 	     end;
      309 
      310 	call hcs_$get_uid_file (sd_name, se_name, uid, code);
      311 	if code ^= 0
      312 	then goto BAD_STAT;
      313 
      314 	dir1_uid = uid;
      315 
      316 /* if the target doesn't exist, create it. If it does exist,
      317*   but is not a directory, complain and get next entry. */
      318 
      319 	call hcs_$status_minf (td_name, te_name, 0, type, bc, code);
      320 	if code ^= 0
      321 	then if code = error_table_$noentry
      322 	     then do;
      323 		     if ^brief
      324 		     then call ioa_ ("^a: Creating target directory ^a.", whoami, pathname_ (td_name, te_name));
      325 
      326 		     call create_directory;
      327 		     if code ^= 0
      328 		     then goto finish;
      329 		end;
      330 	     else do;
      331 BAD_TSTAT:
      332 		     call complain (code, "^/Unable to get the status of the target directory ^a^[>^]^a.", td_name,
      333 			td_name ^= ">", te_name);
      334 		     return;
      335 		end;
      336 	else if type ^= Directory | bc ^= 0
      337 	then do;
      338 T_NOT_DIR:
      339 		call nd_handler_ (whoami, td_name, te_name, code);
      340 		if code ^= 0
      341 		then do;
      342 			acode = code;
      343 			return;
      344 		     end;
      345 
      346 		call create_directory;
      347 		if code ^= 0
      348 		then goto finish;
      349 	     end;
      350 	else do;					/*  target_dir exists */
      351 		if ^raw
      352 		then do;
      353 			call fs_util_$get_type (td_name, te_name, fs_util_type, code);
      354 			if fs_util_type ^= FS_OBJECT_TYPE_DIRECTORY
      355 			then goto T_NOT_DIR;
      356 		     end;
      357 
      358 		call hcs_$get_uid_file (td_name, te_name, dir2_uid, code);
      359 		if code ^= 0
      360 		then go to BAD_TSTAT;
      361 
      362 		if dir1_uid = dir2_uid
      363 		then do;
      364 			call complain (error_table_$action_not_performed,
      365 			     "Attempt to specify the same directory as both old and new");
      366 			return;
      367 		     end;
      368 		if ^(force | replace)
      369 		then do;
      370 			query_info.version = 1;
      371 			query_info.yes_or_no_sw = "1"b;
      372 			query_info.suppress_name_sw = "0"b;
      373 			query_info.status_code = 0;
      374 			query_info.query_code = 0;
      375 			call command_query_ (addr (query_info), answer, whoami,
      376 			     "^a^[>^]^a  already exists.  Do you wish to continue?", td_name, td_name ^= ">",
      377 			     te_name);
      378 			if query_info.status_code ^= 0
      379 			then do;
      380 				call complain (query_info.status_code, "^/Unable to use answer from query.");
      381 				return;
      382 			     end;
      383 			if answer = "no"
      384 			then goto finish;
      385 		     end;
      386 
      387                                                           /* perform the containment check */
      388 		call contains (source_contains_target, target_contains_source, code);
      389 		if code ^= 0
      390 		then do;
      391 			call complain (code,
      392 			     "^/Unable to check containment of source and target directories, ^a^[>^]^a and ^a^[>^]^a respectively.",
      393 			     sd_name, sd_name ^= ">", se_name, td_name, td_name ^= ">", te_name);
      394 			return;
      395 		     end;
      396 
      397 		if source_contains_target             /* the source directory contains the target directory */
      398 		then do;
      399 			call complain (error_table_$action_not_performed,
      400 			     "^/The source directory cannot contain the target directory;^/^a contains ^a.",
      401 			     pathname_ (sd_name, se_name), pathname_ (td_name, te_name));
      402 			return;
      403 		     end;
      404 
      405 		if target_contains_source            /* the target directory contains the source directory */
      406 		then do;
      407 			call complain (error_table_$action_not_performed,
      408 			     "^/The target directory cannot contain the source directory;^/^a contains ^a.",
      409 			     pathname_ (td_name, te_name), pathname_ (sd_name, se_name));
      410 			return;
      411 		     end;
      412 
      413 		if replace                             /* want to delete the contents of the specified existent target */
      414 		then do;
      415 		          string (delete_options) = ""b;
      416 			delete_options.force = force;
      417 			delete_options.question,
      418 			delete_options.directory,
      419 			delete_options.segment,
      420 			delete_options.link = "1"b;
      421 			delete_options.chase = chase;
      422 			delete_options.library = "0"b;
      423 			delete_options.raw = raw;
      424 
      425 			temp_target_dir = pathname_ (td_name, te_name);
      426 
      427 			star_entry_count = 0;        /* initialize variable declared in star_structures.incl.pl1 */
      428 			star_entry_ptr = null;       /* initialize variable declared in star_structures.incl.pl1 */
      429 			star_names_ptr = null;       /* initialize variabel declared in start_structures.incl.pl1 */
      430 
      431                                                            /* get information on all entries in the specified existent target */
      432 			call hcs_$star_ (temp_target_dir, "**", star_ALL_ENTRIES, area_ptr, star_entry_count, star_entry_ptr, star_names_ptr, code);
      433 			if code ^= 0 then do;
      434                                                             /* if the existent target is empty (star_entry_count = 0), then keep going */
      435 			     if code ^= error_table_$nomatch then do;
      436 				call complain (code, "Unable to return information on all entries in target directory ^a.", temp_target_dir);
      437 				return;
      438 			     end;
      439 			end;
      440 
      441                                                             /* delete all entries in the specified existent target */
      442 			do entry_index = 1 to star_entry_count;
      443 			     call delete_$path (temp_target_dir, star_names (entry_index), string (delete_options), whoami, code);
      444 			     if code ^= 0 & code ^= error_table_$bad_ring_brackets
      445 			     then do;
      446 				call complain (code, "^/Unable to delete the entryname ^a in the directory ^a.",
      447 				     rtrim (star_names (entry_index)), rtrim (temp_target_dir));
      448 				return;
      449 			     end;
      450 			end;                          /* make the specified existent target directory become empty */
      451 		     end;				/* want to delete the contents of a specified existent directory */
      452 	     end;                                         /* case the specified target directory exists */
      453 
      454 	errors = "0"b;				/* start fresh */
      455 
      456 	call hcs_$get_safety_sw (sd_name, se_name, safety_sw, code);
      457 	if code ^= 0
      458 	then call complain (code, "^/Unable to get the safety switch for the source directory ^a^[>^]^a.", sd_name,
      459 		sd_name ^= ">", se_name);
      460 	else do;
      461 		call hcs_$set_safety_sw (td_name, te_name, safety_sw, code);
      462 		if code ^= 0
      463 		then call complain (code, "^/Unable to set the safety switch on the target directory ^a^[>^]^a.",
      464 			td_name, td_name ^= ">", te_name);
      465 	     end;
      466 
      467 	call copy_iacl_ (sd_name, se_name, td_name, te_name, ersw, code);
      468 	if code ^= 0
      469 	then call complain (code,
      470 		"^/Unable to copy the initial ACL from the source directory ^a^[>^]^a to the target directory ^a^[>^]^a.
      471 Error occurred on the ^[source^;target^] directory.",
      472 		sd_name, sd_name ^= ">", se_name, td_name, td_name ^= ">", te_name, ^ersw);
      473 
      474 	cpo.version = COPY_OPTIONS_VERSION_1;
      475 	cpo.caller_name = "copy_dir_";
      476 
      477 /* Now call the recursive procedure which does the actual copying */
      478 
      479 	call work (sd_name, se_name, td_name, te_name, acl, move);
      480 
      481 	if acl | move
      482 	then do;
      483 		call copy_acl_ (sd_name, se_name, td_name, te_name, ersw, code);
      484 		if code ^= 0
      485 		then call complain (code, "^/Unable to copy the ACL from  ^a^[>^]^a to  ^a^[>^]^a.
      486 Error occurred on the ^[source^;target^].", sd_name, sd_name ^= ">", se_name, td_name, td_name ^= ">", te_name, ^ersw);
      487 
      488 	     end;
      489 	if all_names
      490 	then do;
      491 		if same_dir
      492 		then call move_names_ (sd_name, se_name, td_name, te_name, whoami, ersw, code);
      493 
      494 		else call copy_names_ (sd_name, se_name, td_name, te_name, whoami, ersw, code);
      495 		if code ^= 0
      496 		then if code ^= error_table_$segnamedup
      497 		     then if code ^= error_table_$namedup
      498 			then call complain (code, "^/Unable to ^[move^;copy^] names of ^a^[>^]^a to  ^a^[>^]^a.
      499 Error occurred on the ^[source^;target^].", same_dir, sd_name, (sd_name ^= ">"), se_name, td_name, td_name ^= ">",
      500 				te_name, ^ersw);
      501 	     end;
      502 	if move
      503 	then if errors
      504 	     then do;
      505 		     if ^brief
      506 		     then call com_err_ (error_table_$action_not_performed, whoami,
      507 			     "Source directory not deleted due to error in copying.");
      508 		     if acode = 0
      509 		     then acode = error_table_$action_not_performed;
      510 						/* tell caller something!                         */
      511 		end;
      512 	     else do;
      513 		     string (delete_options) = ""b;
      514 		     delete_options.question, delete_options.directory = "1"b;
      515 		     delete_options.raw = raw;
      516 		     call delete_$path (sd_name, se_name, string (delete_options), whoami, code);
      517 		     if code ^= 0
      518 		     then call complain (code, "^/Unable to delete ^a^[>^]^a.", sd_name, (sd_name ^= ">"), se_name);
      519 		end;
      520 finish:
      521 	if cb_ptr ^= null ()
      522 	then free cb_ptr -> create_branch_info in (area);
      523 	return;
      524 
      525 /* The directory tree is recursively followed, copying the links,
      526*   files, and directories along the way. If a copy fails for any
      527*   reason on a particular entry,processing continues with the next one
      528*   and nothing is done with the failed entry. */
      529 
      530 work:
      531      proc (d1, e1, d2, e2, acl, move) recursive;
      532 	dcl     i			        fixed bin;
      533 	dcl     (from_dir, to_dir)	        char (168);
      534 	dcl     name		        char (32);
      535 	dcl     names		        (500) char (32) aligned based (nptr);
      536 						/* info from hcs_$star_ */
      537 	dcl     nptr		        ptr;
      538 	dcl     1 branches		        (entry_count) aligned based (sptr),
      539 						/* info from hcs_$star_ */
      540 	        ( 2 type		        bit (2),
      541 		2 nnames		        fixed bin (15),
      542 		2 nindex		        fixed bin (17)
      543 		)		        unaligned;
      544 	dcl     (d1, d2, e1, e2)	        char (*);
      545           dcl     (acl, move)                   bit (1);    /* save these flags for later reference in the "file" procedure. */
      546 	dcl     sptr		        ptr;
      547 	dcl     entry_count		        fixed bin;
      548 
      549 /* construct directory pathnames */
      550 	call ioa_$rsnnl ("^a^[>^]^a", from_dir, ln, d1, (d1 ^= ">"), e1);
      551 	call ioa_$rsnnl ("^a^[>^]^a", to_dir, ln, d2, (d2 ^= ">"), e2);
      552 
      553 /* set up cleanup handler */
      554 	on condition (cleanup)
      555 	     begin;
      556 		if sptr ^= null
      557 		then free branches in (area);
      558 		if nptr ^= null
      559 		then free nptr -> names in (area);
      560 	     end;
      561 
      562 /* get all of the entries in from_dir */
      563 
      564 	call hcs_$star_ (from_dir, "**", 3, area_ptr, entry_count, sptr, nptr, code);
      565 	if code ^= 0
      566 	then if code = error_table_$nomatch
      567 	     then goto finish_work;
      568 	     else do;
      569 
      570 		     call complain (code, "^/Unable to get the entries in the directory ^a.", from_dir);
      571 		     return;
      572 		end;
      573 
      574 /* call appropriate entry copier */
      575 
      576 	do i = 1 to entry_count;
      577 	     name = names (branches (i).nindex);
      578 	     if branches (i).type = "00"b
      579 	     then do;
      580 		     if (all_entries | clink | cnnl)
      581 		     then call link;
      582 		end;
      583 	     else if branches (i).type = "01"b
      584 	     then do;
      585 FILE:
      586 		     if (all_entries | cseg)
      587 		     then call file (from_dir, name, to_dir, name, acl, move);
      588 		end;
      589 	     else if branches (i).type = "10"b
      590 	     then do;
      591 		     if ^raw
      592 		     then do;
      593 			     call fs_util_$get_type (from_dir, name, fs_util_type, code);
      594 			     if code ^= error_table_$not_seg_type & substr (fs_util_type, 1, 1) ^= "-"
      595 			     then goto FILE;
      596 			end;
      597 
      598 		     call hcs_$status_minf (from_dir, name, 1, tt, bc, code);
      599 		     if code ^= 0
      600 		     then do;
      601 			     call complain (code, "^/Unable to get status on the file  ^a^[>^]^a.", from_dir,
      602 				from_dir ^= ">", name);
      603 			     return;
      604 			end;
      605 		     if bc ^= 0
      606 		     then do;
      607 			     if (all_entries | cmsf)
      608 			     then call file (from_dir, name, to_dir, name, acl, move);
      609 			end;
      610 		     else do;
      611 			     if (all_entries | cdir)
      612 			     then call directory;
      613 			end;
      614 		end;
      615 	     else do;
      616 		     call complain (0, "Illegal branch type ""11""b ^a^[>^]^a", from_dir, from_dir ^= ">", name);
      617 		     return;			/* tell caller something                          */
      618 		end;
      619 	end;
      620 
      621 finish_work:
      622 	if sptr ^= null
      623 	then free sptr -> branches in (area);
      624 	if nptr ^= null
      625 	then free nptr -> names in (area);
      626 
      627 	return;					/* Effective end of work. */
      628 
      629 link:
      630      proc;
      631 	dcl     pptr		        ptr;
      632 	dcl     1 links		        aligned like status_link;
      633 	dcl     pathname		        char (links.pathname_length) aligned based (pptr);
      634 	dcl     (link_target, new_target, ld) char (168);
      635 
      636 	call hcs_$status_ (from_dir, name, 0, addr (links), area_ptr, code);
      637 	if code ^= 0
      638 	then do;
      639 		call complain (code, "^/Unable to get detailed status on the link ^a^[>^]^a.", from_dir,
      640 		     from_dir ^= ">", name);
      641 		return;
      642 	     end;
      643 
      644 	pptr = ptr (area_ptr, links.names_relp);
      645 	free pptr -> names in (area);
      646 
      647 	pptr = ptr (area_ptr, links.pathname_relp);
      648 
      649 	link_target = pathname;
      650 
      651 	call expand_pathname_ (link_target, ld, le, code);
      652 	if code ^= 0
      653 	then do;
      654 		call complain (code, "^/Unable to expand the target pathname ^a for the link ^a^[>^]^a.", link_target,
      655 		     from_dir, from_dir ^= ">", name);
      656 		return;
      657 	     end;
      658 	if translate_links
      659 	then do;
      660 		call contains_target (ld, le, new_target, code);
      661 		if code = 0
      662 		then link_target = new_target;
      663 		else if code = no_translation
      664 		then code = 0;
      665 		else do;
      666 			call complain (code,
      667 			     "^/Unable to analyze  ^a^[>^]^a for containment in the target directory.", ld,
      668 			     ld ^= ">", le);
      669 			return;
      670 		     end;
      671 	     end;
      672 	free pptr -> pathname in (area);
      673 
      674 	if chase
      675 	then do;
      676 		call hcs_$get_link_target (ld, le, ld, le, code);
      677 		if code ^= 0
      678 		then if code = error_table_$noentry | code = error_table_$no_dir
      679 		     then do;
      680 			     if clink
      681 			     then goto append_link;
      682 			     return;
      683 			end;
      684 		     else do;
      685 			     call complain (code,
      686 				"^/Unable to get the link target of  ^a^[>^]^a, with target pathname of  ^a^[>^]^a.",
      687 				from_dir, (from_dir ^= ">"), name, ld, ld ^= ">", le);
      688 			     return;
      689 			end;
      690 		call hcs_$status_minf (ld, le, 0, tt, bc, code);
      691 		if code ^= 0
      692 		then if code = error_table_$noentry | code = error_table_$no_dir
      693 		     then do;
      694 			     if clink
      695 			     then goto append_link;
      696 			     return;
      697 			end;
      698 		     else do;
      699 			     call complain (code,
      700 				"^/Unable to get status on  ^a^[>^]^a, the link target of  ^a^[>^]^a.", ld,
      701 				ld ^= ">", le, from_dir, from_dir ^= ">", name);
      702 			     return;
      703 			end;
      704 
      705 		if ^raw
      706 		then do;
      707 			call fs_util_$get_type (ld, le, fs_util_type, code);
      708 			if code ^= error_table_$not_seg_type & substr (fs_util_type, 1, 1) ^= "-"
      709 						/* if it is an extended object, or if it dont exist */
      710 			then tt = 1;
      711 		     end;
      712 
      713 		if (tt = 1 & (cseg | all_entries)) | (tt = 2 & bc ^= 0 & (cmsf | all_entries))
      714 		then call file (ld, le, to_dir, name, acl, move);
      715 		else if (tt = 2 & bc = 0 & (cdir | all_entries))
      716 		then goto append_link;
      717 		else return;
      718 	     end;
      719 	else do;
      720 		if cnnl
      721 		then do;
      722 			call hcs_$status_minf (ld, le, 1, tt, bc, code);
      723 			if code ^= 0
      724 			then if code = error_table_$noentry | code = error_table_$no_dir
      725 			     then return;
      726 			     else do;
      727 				     call complain (code,
      728 					"^/Unable to get status on ^a^[>^]^a, the link target of  ^a^[>^]^a.",
      729 					ld, ld ^= ">", le, from_dir, from_dir ^= ">", name);
      730 				     return;
      731 				end;
      732 		     end;
      733 append_link:
      734 		call hcs_$append_link (to_dir, name, link_target, code);
      735 		if code ^= 0
      736 		then if code = error_table_$namedup
      737 		     then do;
      738 			     string (nd_handler_options) = ""b;
      739 			     nd_handler_options.raw = raw;
      740 			     nd_handler_options.delete_force = update;
      741 			     call nd_handler_$switches (whoami, to_dir, name, string (nd_handler_options), code1);
      742 			     if code1 = 0
      743 			     then goto append_link;
      744 			     else if code1 = error_table_$action_not_performed
      745 			     then return;
      746 			     else do;
      747 				     acode = code1;
      748 				     errors = "1"b;
      749 				     return;
      750 				end;
      751 			end;
      752 		     else do;
      753 			     call complain (code,
      754 				"^/Unable to copy  from ^a^[>^]^a to ^a^[>^]^a. Error occurred on the ^[source^;target^].",
      755 				from_dir, (from_dir ^= ">"), name, to_dir, (to_dir ^= ">"), name, ^ersw);
      756 			     return;
      757 			end;
      758 
      759 		call copy_names_ (from_dir, name, to_dir, name, whoami, ersw, code);
      760 		if code ^= 0 & code ^= error_table_$segnamedup & code ^= error_table_$namedup
      761 		then do;
      762 			call complain (code, "^/Unable to copy the names from ^a^[>^]^a to ^a^[>^]^a.
      763 Error occurred on the ^[source^;target^] entry.", from_dir, from_dir ^= ">", name, to_dir, to_dir ^= ">", name, ^ersw);
      764 			return;
      765 		     end;
      766 	     end;
      767      end link;
      768 
      769 file:
      770      proc (from_dir, from_en, to_dir, to_en, acl, move);
      771 
      772 	dcl     (from_dir, from_en, to_dir, to_en)
      773 				        char (*);
      774           dcl     (acl, move)                   bit (1); /* They are originally received from the "copy_dir_" procedure. */
      775 
      776 	dcl     1 local_suffix_info	        aligned like suffix_info;
      777 
      778 	cpo.source_dir = from_dir;
      779 	cpo.source_name = from_en;
      780 	cpo.target_dir = to_dir;
      781 	cpo.target_name = to_en;
      782 
      783 	string (cpo.flags) = ""b;
      784 	cpo.raw = raw;
      785 	cpo.no_name_dup = update;
      786 
      787 	string (cpo.copy_items) = ""b;
      788 	cpo.names = all_names;
      789 	cpo.acl = acl | move;
      790 
      791 	local_suffix_info.version = SUFFIX_INFO_VERSION_1;
      792 
      793 	call fs_util_$suffix_info (from_dir, from_en, addr (local_suffix_info), code);
      794 	if code ^= 0
      795 	then do;
      796 		call complain (code, "^/Unable to get the suffix_info for ^a.", pathname_ (from_dir, from_en));
      797 		return;
      798 	     end;
      799 
      800 	if tt = 1
      801 	then do;
      802 		cpo.max_length = local_suffix_info.copy_flags.max_length;
      803 		cpo.dumper_switches = local_suffix_info.copy_flags.dumper_switches;
      804 	     end;
      805 	cpo.safety_switch = local_suffix_info.copy_flags.safety_switch;
      806 
      807 	on sub_error_ call sub_err_handler ();
      808 
      809 	call copy_ (addr (cpo));
      810 
      811 PUNT_FILE:
      812 	return;
      813 
      814 sub_err_handler:
      815      proc ();
      816 
      817 	ci.version = condition_info_version_1;
      818 	call find_condition_info_ (null (), addr (ci), (0));
      819 	sub_error_info_ptr = ci.info_ptr;
      820 
      821 	if sub_error_info.name ^= "copy_" | copy_error_info.copy_options_ptr ^= addr (cpo)
      822 	then do;
      823 		call continue_to_signal_ ((0));
      824 		return;
      825 	     end;
      826 
      827 	code = sub_error_info.status_code;
      828 
      829 	call complain (code,
      830 	     "^[^a^/^-^;^s^]^[Copying^;Unable to copy^] from ^a to ^a. Error occurred on the ^[target^;source^].",
      831 	     sub_error_info.info_string ^= "", sub_error_info.info_string, sub_error_info.default_restart,
      832 	     pathname_ (from_dir, from_en), pathname_ (to_dir, to_en), copy_error_info.target_err_switch);
      833 
      834 	if sub_error_info.cant_restart
      835 	then goto PUNT_FILE;
      836 
      837 	return;
      838      end sub_err_handler;
      839 
      840      end file;
      841 
      842 directory:
      843      proc;
      844 
      845 	call hcs_$status_minf (to_dir, name, 1, tt, bc, code);
      846 	if code ^= 0
      847 	then do;
      848 		tt = 0;
      849 		call hcs_$get_dir_ring_brackets (from_dir, name, dir_rings, code);
      850 		if code ^= 0
      851 		then do;
      852 			call complain (code, "^/Unable to get the directory ring brackets of ^a^[>^]^a.", from_dir,
      853 			     (from_dir ^= ">"), name);
      854 			return;
      855 		     end;
      856 	     end;
      857 	else if tt ^= 2
      858 	then do;
      859 		call nd_handler_ (whoami, to_dir, name, code);
      860 		if code ^= 0
      861 		then if code = error_table_$action_not_performed
      862 		     then return;
      863 		     else do;
      864 			     errors = "1"b;
      865 			     acode = code;
      866 			     return;
      867 			end;
      868 
      869 		call hcs_$get_dir_ring_brackets (from_dir, name, dir_rings, code);
      870 		if code ^= 0
      871 		then do;
      872 			call complain (code, "^/Unable to get the directory ring brackets of ^a^[>^]^a.", from_dir,
      873 			     (from_dir ^= ">"), name);
      874 			return;
      875 		     end;
      876 
      877 	     end;
      878 	if tt ^= 2
      879 	then do;
      880 		cb_ptr -> create_branch_info.rings (1) = dir_rings (1);
      881 		cb_ptr -> create_branch_info.rings (2) = dir_rings (2);
      882 		cb_ptr -> create_branch_info.rings (3) = 7;
      883 		call hcs_$get_access_class (from_dir, name, cb_ptr -> create_branch_info.access_class, code);
      884 		if code ^= 0
      885 		then do;
      886 			call complain (code, "^/Unable to get the access class of  ^a^[>^]^a.", from_dir,
      887 			     (from_dir ^= ">"), name);
      888 			return;
      889 		     end;
      890 
      891 		cb_ptr -> create_branch_info.switches.dir_sw = "1"b;
      892 		cb_ptr -> create_branch_info.switches.copy_sw = "0"b;
      893 		cb_ptr -> create_branch_info.switches.chase_sw = "1"b;
      894 		cb_ptr -> create_branch_info.mode = "111"b;
      895 		call hcs_$create_branch_ (to_dir, name, cb_ptr, code);
      896 		if code ^= 0
      897 		then do;
      898 			call complain (code, "^/Unable to create the directory branch ^a^[>^]^a.", to_dir,
      899 			     (to_dir ^= ">"), name);
      900 			return;
      901 		     end;
      902 
      903 	     end;
      904 
      905 	if all_names
      906 	then do;
      907 		call copy_names_ (from_dir, name, to_dir, name, whoami, ersw, code);
      908 		if code ^= 0 & code ^= error_table_$segnamedup & code ^= error_table_$namedup
      909 		then call complain (code,
      910 			"^/Unable to copy the names from ^a^[>^]^a to ^a^[>^]^a. Error occurred on the ^[source^;target^].",
      911 			from_dir, (from_dir ^= ">"), name, to_dir, (to_dir ^= ">"), name, ^ersw);
      912 	     end;
      913 
      914 	call hcs_$get_safety_sw (from_dir, name, safety_sw, code);
      915 	if code ^= 0
      916 	then call complain (code, "^/Unable to get the safety_switch of ^a^[>^]^a.", from_dir, (from_dir ^= ">"), name);
      917 	else do;
      918 		call hcs_$set_safety_sw (to_dir, name, safety_sw, code);
      919 		if code ^= 0
      920 		then call complain (code, "^/Unable to set the safety switch of ^a^[>^]^a.", to_dir, (to_dir ^= ">"),
      921 			name);
      922 	     end;
      923 
      924 
      925 	call copy_iacl_ (from_dir, name, to_dir, name, ersw, code);
      926 	if code ^= 0
      927 	then call complain (code,
      928 		"^/Unable to copy the initial ACL from ^a^[>^]^a to ^a^[>^]^a. Error occurred on the ^[source^;target^].",
      929 		from_dir, from_dir ^= ">", name, to_dir, to_dir ^= ">", name, ^ersw);
      930 
      931 	call work (from_dir, name, to_dir, name, acl, move);
      932 
      933 	if acl | move
      934 	then do;
      935 		call copy_acl_ (from_dir, name, to_dir, name, ersw, code);
      936 		if code ^= 0
      937 		then call complain (code,
      938 			"^/Unable to copy ACL from ^a^[>^]^a to ^a^[>^]^a. Error occurred on the ^[source^;target^].",
      939 			from_dir, from_dir ^= ">", name, to_dir, to_dir ^= ">", name, ^ersw);
      940 	     end;
      941      end directory;
      942      end work;
      943 
      944 create_directory:
      945      proc;
      946           code = 0;
      947 
      948 	call hcs_$get_dir_ring_brackets (sd_name, se_name, dir_rings, code);
      949 	if code ^= 0
      950 	then do;
      951 		if code = error_table_$no_s_permission | code = error_table_$incorrect_access
      952 		then do;
      953 			cb_ptr -> create_branch_info.rings (1) = get_ring_ ();
      954 			cb_ptr -> create_branch_info.rings (2) = cb_ptr -> create_branch_info.rings (1);
      955 			cb_ptr -> create_branch_info.rings (3) = 7;
      956 		     end;
      957 		else do;
      958 			call complain (code, "^/Unable to get the directory ring brackets of ^a^[>^]^a.", sd_name,
      959 			     sd_name ^= ">", se_name);
      960 			return;
      961 		     end;
      962 	     end;
      963 	else do;
      964 		cb_ptr -> create_branch_info.rings (1) = dir_rings (1);
      965 		cb_ptr -> create_branch_info.rings (2) = dir_rings (2);
      966 		cb_ptr -> create_branch_info.rings (3) = 7;
      967 	     end;
      968 	call hcs_$get_access_class (sd_name, se_name, cb_ptr -> create_branch_info.access_class, code);
      969 	if code ^= 0
      970 	then do;
      971 		if code = error_table_$no_s_permission | code = error_table_$incorrect_access
      972 		then cb_ptr -> create_branch_info.access_class = get_max_authorization_ ();
      973 		else do;
      974 			call complain (code, "^/Unable to get access class for ^a^[>^]^a.", sd_name, sd_name ^= ">",
      975 			     se_name);
      976 			return;
      977 		     end;
      978 	     end;
      979 	call hcs_$create_branch_ (td_name, te_name, cb_ptr, code);
      980 	if code ^= 0
      981 	then do;
      982 		call complain (code, "^/Unable to create the branch ^a^[>^]^a.", td_name, td_name ^= ">", te_name);
      983 		return;
      984 	     end;
      985 	call hcs_$get_uid_file (td_name, te_name, dir2_uid, code);
      986 	if code ^= 0
      987 	then do;
      988 		call complain (code, "^/Unable to get uid of the target directory  ^a^[>^]^a.", td_name,
      989 		     td_name ^= ">", te_name);
      990 		return;
      991 	     end;
      992 
      993 	call contains (source_contains_target, target_contains_source, code);
      994 	if code ^= 0
      995 	then do;
      996 		call complain (code, "^/Unable to check containment of source and target directories,
      997 ^a^[>^]^a and ^a^[>^]^a respectively.", sd_name, sd_name ^= ">", se_name, td_name, td_name ^= ">", te_name);
      998 		return;
      999 	     end;
     1000 
     1001 	if source_contains_target             /* the source directory contains the target directory */
     1002 	then do;
     1003 	     call complain (error_table_$action_not_performed,
     1004 		"^/The source directory cannot contain the target directory;^/^a contains ^a.", pathname_ (sd_name, se_name),
     1005 		pathname_ (td_name, te_name));
     1006                                                 /* indicate that error has been found */
     1007 	     code = error_table_$action_not_performed;
     1008 
     1009 	     return;
     1010 	     end;
     1011 
     1012 	if target_contains_source            /* the target directory contains the source directory */
     1013 	then do;
     1014 	     call complain (error_table_$action_not_performed,
     1015 		"^/The target directory cannot contain the source directory;^/^a contains ^a.", pathname_ (td_name, te_name),
     1016 		pathname_ (sd_name, se_name));
     1017                                                /* indicate that an error has been found */
     1018 	     code = error_table_$action_not_performed;
     1019 
     1020 	     return;
     1021 	     end;
     1022 
     1023 	return;
     1024 
     1025      end create_directory;
     1026 
     1027 contains:
     1028      proc (p_source_contains_target, p_target_contains_source, code);
     1029 
     1030 /* check of target_dir in source_dir and vice-versa. */
     1031 
     1032 	dcl     (dir1, dir2)	        char (168);
     1033 	dcl     (en1, en2)		        char (32);
     1034 	dcl     p_source_contains_target      bit (1);
     1035 	dcl     p_target_contains_source      bit (1);
     1036 	dcl     code		        fixed bin (35);
     1037 
     1038           code = 0;
     1039 	p_source_contains_target = "0"b;
     1040 	p_target_contains_source = "0"b;
     1041 
     1042 	call hcs_$get_link_target (sd_name, se_name, dir1, en1, code);
     1043 	if code ^= 0
     1044 	then return;
     1045 
     1046 	call hcs_$get_link_target (td_name, te_name, dir2, en2, code);
     1047 	if code ^= 0
     1048 	then return;
     1049 
     1050 	call path_info (dir1, en1, scomp_count, scomp_root, code);
     1051 	if code ^= 0
     1052 	then return;
     1053 
     1054 	if dir1 = dir2 & en1 = en2
     1055 	then do;
     1056 	     code = error_table_$sameseg;
     1057 	     p_target_contains_source = "1"b;
     1058 	     p_source_contains_target = "1"b;
     1059 	     end;
     1060 	else do;
     1061 	     call path_info (dir2, en2, tcomp_count, tcomp_root, code);
     1062 	     if code ^= 0
     1063 		then return;
     1064 
     1065 	     if scomp_count = tcomp_count
     1066 		then return;
     1067 
     1068 	     else if scomp_count > tcomp_count
     1069 		then do;
     1070 		     call csub (scomp_root, tcomp_count, uid, code);
     1071 		     if code ^= 0
     1072 			then return;
     1073 
     1074 		     if uid = dir2_uid
     1075 		     then p_source_contains_target = "1"b;
     1076 		     end;
     1077 
     1078 	     else do;                             /* for example: source and target pathnames are ">udd>m>x" and ">udd>m>x>y", respectively */
     1079 		call csub (tcomp_root, scomp_count, uid, code);
     1080 		if code ^= 0
     1081 		     then return;
     1082 
     1083 		if uid = dir1_uid
     1084 		     then p_target_contains_source = "1"b;
     1085 		end;
     1086 	end;
     1087 
     1088 csub:
     1089      proc (p_root, p_count, p_uid, p_code);
     1090 
     1091 	dcl     (p, p_root)		        ptr;
     1092 	dcl     (code, p_code)	        fixed bin (35);
     1093 	dcl     dir		        char (128);
     1094 	dcl     en		        char (32);
     1095 	dcl     p_count		        fixed bin;
     1096 	dcl     comp_index		        fixed bin;
     1097 	dcl     p_uid		        bit (36) aligned;
     1098 
     1099 	dir = "";
     1100 	p = p_root;
     1101 	p_code = 0;
     1102 
     1103 	if p_count = 1
     1104 	then dir = ">";
     1105 	else do comp_index = 1 to p_count - 1;
     1106 		dir = rtrim (dir) || ">" || p -> comp.name;
     1107 		p = p -> comp.next;
     1108 	     end;
     1109 
     1110 	en = p -> comp.name;
     1111 	call hcs_$get_uid_file (dir, en, p_uid, code);
     1112 	if code ^= 0
     1113 	then p_code = code;
     1114 
     1115      end;
     1116      end;
     1117 path_info:
     1118      proc (d, e, count, root, code);
     1119 
     1120 /* Turn pathname into threaded list of component names. */
     1121 
     1122 	dcl     code		        fixed bin (35);
     1123 	dcl     (d, e)		        char (*);
     1124 	dcl     count		        fixed bin;
     1125 	dcl     optr		        ptr;
     1126 	dcl     dirstr		        char (168);
     1127 	dcl     root		        ptr;
     1128 	count = 0;
     1129 	if d = ">"
     1130 	then dirstr = reverse (">" || rtrim (e));
     1131 	else dirstr = reverse (rtrim (d) || ">" || rtrim (e));
     1132 	ii = index (dirstr, ">");
     1133 	cptr = null;
     1134 
     1135 	optr = null;
     1136 	do while (ii > 1);
     1137 	     alloc comp in (area);
     1138 	     comp.name = reverse (substr (dirstr, 1, ii - 1));
     1139 	     comp.next = optr;
     1140 	     optr = cptr;
     1141 	     dirstr = substr (dirstr, ii + 1);
     1142 	     count = count + 1;
     1143 	     ii = index (dirstr, ">");
     1144 	end;
     1145 
     1146 	root = cptr;
     1147      end;						/*						*/
     1148 						/* containment subroutine for the link copier. */
     1149 
     1150 contains_target:
     1151      proc (ld, le, new_target, code) recursive;
     1152 
     1153 /* Check whether source link's target pathname is contained in the source
     1154*   directory and if so, translate the link target pathname to a pathname in the
     1155*   target directory.  Only the components of the target pathname which are
     1156*   target directory.  Only the components of the target pathname which are
     1157*   be used in the check.  If one of the components being checked is a link, contains_target
     1158*   is re-called with the new link target pathname and the unprocessed portion of the
     1159*   old one. */
     1160 
     1161 	dcl     i			        fixed bin;
     1162 	dcl     en		        char (32);
     1163 	dcl     dir		        char (168);
     1164 	dcl     new_target		        char (168);
     1165 	dcl     p			        ptr;
     1166 	dcl     (ld, le)		        char (*);
     1167 	dcl     code		        fixed bin (35);
     1168 	dcl     uid		        bit (36) aligned;
     1169 
     1170 	call path_info (ld, le, lcomp_count, lcomp_root, code);
     1171 	if code ^= 0
     1172 	then goto finish;
     1173 
     1174 	if lcomp_count < scomp_count
     1175 	then do;
     1176 		code = no_translation;
     1177 		return;
     1178 	     end;
     1179 
     1180 	p = lcomp_root;
     1181 	dir = "";
     1182 
     1183 /* Catenate the 2nd through lcomp_count'th components, checking at each one
     1184*   for links or matching with unique id's. */
     1185 
     1186 	do i = 1 to lcomp_count - 1;
     1187 	     dir = rtrim (dir) || ">" || p -> comp.name;
     1188 	     p = p -> comp.next;
     1189 	     en = p -> comp.name;
     1190 	     call hcs_$status_minf (dir, en, 0, type, (0), code);
     1191 	     if code ^= 0
     1192 	     then if code = error_table_$noentry | code = error_table_$no_dir
     1193 						/*  The part of the link target pathname which is non-null is not
     1194*						   contained in source_dir.  Therefore, don't translate the link. */
     1195 		then do;
     1196 			code = no_translation;
     1197 			return;
     1198 		     end;
     1199 		else do;
     1200 			code = no_translation;
     1201 			goto check_dir_level;
     1202 		     end;
     1203 	     if type = Link
     1204 	     then do;
     1205 		     code = no_translation;
     1206 		     return;
     1207 		end;
     1208 	     else if type ^= Directory
     1209 	     then do;
     1210 		     if i <= scomp_count - 1
     1211 		     then do;
     1212 			     code = no_translation;
     1213 			     return;
     1214 			end;
     1215 		end;
     1216 	     else
     1217 check_dir_level:
     1218 		call hcs_$get_uid_file (dir, en, uid, code);
     1219 	     if code ^= 0
     1220 	     then do;
     1221 		     code = no_translation;
     1222 		     return;
     1223 		end;
     1224 
     1225 	     if i = scomp_count - 1
     1226 	     then if dir1_uid ^= uid
     1227 		then do;
     1228 			code = no_translation;
     1229 			return;
     1230 		     end;
     1231 		else do;
     1232 			call ioa_$rsnnl ("^a^[>^]^a", new_target, ln, td_name, (td_name ^= ">"), te_name);
     1233 			p = p -> comp.next;
     1234 			do while (p ^= null);
     1235 			     new_target = rtrim (new_target) || ">" || p -> comp.name;
     1236 			     p = p -> comp.next;
     1237 			end;
     1238 			code = 0;
     1239 			return;
     1240 		     end;
     1241 next_comp:
     1242 	end;
     1243 	new_target = rtrim (new_target) || ">" || rtrim (le);
     1244 
     1245 	return;
     1246      end contains_target;
     1247 
     1248 get_uid:
     1249      proc (p_path) returns (bit (36));
     1250 	dcl     p_path		        char (168);
     1251 	dcl     dir		        char (168);
     1252 	dcl     entry		        char (32);
     1253 	dcl     code		        fixed bin (35);
     1254 	dcl     uid		        bit (36) aligned;
     1255 
     1256 	call expand_pathname_ (p_path, dir, entry, code);
     1257 	if code ^= 0
     1258 	then return ("0"b);
     1259 
     1260 	call hcs_$get_uid_file (dir, entry, uid, code);
     1261 	if code ^= 0
     1262 	then return ("0"b);
     1263 
     1264 	return (uid);
     1265 
     1266      end get_uid;
     1267 
     1268 complain:
     1269      proc () options (variable);
     1270 	dcl     p_code		        fixed bin (35) based (argp);
     1271 	dcl     argp		        ptr;
     1272 	dcl     argl		        fixed bin (21);
     1273 	dcl     nargs		        fixed bin;
     1274 	dcl     arg_list_ptr	        ptr;
     1275 	dcl     error_message	        char (512);
     1276 	dcl     error_message_length	        fixed bin;
     1277 
     1278 	call cu_$arg_ptr (1, argp, argl, 0);
     1279 	if ^brief
     1280 	then do;
     1281 		call cu_$arg_count (nargs, 0);
     1282 		if nargs > 1
     1283 		then do;
     1284 			call cu_$arg_list_ptr (arg_list_ptr);
     1285 			call ioa_$general_rs (arg_list_ptr, 2, 3, error_message, error_message_length, "0"b, "0"b);
     1286 			call com_err_ (p_code, whoami, substr (error_message, 1, error_message_length));
     1287 		     end;
     1288 		else call com_err_ (p_code, whoami);
     1289 	     end;
     1290 	errors = "1"b;
     1291 	acode = p_code;
     1292      end complain;
     1293 
     1294 /* format: off */
     1295  /* BEGIN INCLUDE FILE: suffix_info.incl.pl1 */
  1     2 /* format: style3,indcomtxt,idind30 */
  1     3 /**** Jay Pattin 2/13/83
  1     4*      M. Pandolf 1984.11.30 to set FS_OBJECT_TYPE_MSF to -multisegment_file
  1     5*
  1     6*      The include file copy_flags.incl.pl1 must be included in any program using this include file.
  1     7*
  1     8*      This structure is returned by the suffix_XXX_$suffix_info subroutines */
  1     9 
  1    10 declare   suffix_info_ptr               ptr;
  1    11 
  1    12 declare   1 suffix_info                 aligned based (suffix_info_ptr),
  1    13             2 version                   char (8),
  1    14             2 type                      char (32) unaligned,
  1    15             2 type_name                 char (32) unaligned,          /* Singular name of the object type, e.g. "mailbox" */
  1    16             2 plural_name               char (32) unaligned,          /* Plural of above, e.g. "mailboxes" */
  1    17             2 flags                     unaligned,
  1    18               3 standard_object         bit (1) unaligned,  /* ON if not an extended object (no suffix_XXX_) */
  1    19               3 extended_acl            bit (1) unaligned,  /* ON if uses extended ACLs, off if regular ACLs */
  1    20               3 has_switches            bit (1) unaligned,  /* ON if supports switches for objects */
  1    21               3 mbz1                    bit (33) unaligned,
  1    22             2 modes                     char (36),          /* correspondence between bits and chars for extended modes */
  1    23             2 max_mode_len              fixed bin,          /* maximum number of modes on an object */
  1    24             2 num_ring_brackets         fixed bin,          /* number of ring brackets on object */
  1    25             2 copy_flags                like copy_flags,    /* See copy_flags.incl.pl1 */
  1    26             2 info_pathname             char (168) unaligned;
  1    27                                                             /* pathname of info segment containing more info */
  1    28 
  1    29 declare   SUFFIX_INFO_VERSION_1         char (8) static options (constant) init ("SUFFIX01");
  1    30 
  1    31 /* This information is returned by the suffix_XXX_$list_switches subroutines */
  1    32 
  1    33 declare   switch_list_ptr               ptr,
  1    34           alloc_switch_count            fixed bin,
  1    35           alloc_switch_name_count       fixed bin;
  1    36 
  1    37 declare   1 switch_list                 aligned based (switch_list_ptr),
  1    38             2 version                   char (8),           /* SWITCH_LIST_VERSION_1 */
  1    39             2 switch_count              fixed bin,          /* total number of switches */
  1    40             2 switch_name_count         fixed bin,          /* total number of names */
  1    41             2 switches                  (alloc_switch_count refer (switch_list.switch_count)),
  1    42               3 name_index              fixed bin,          /* index of first name for this switch */
  1    43               3 name_count              fixed bin,          /* number of names for this switch */
  1    44               3 default_value           bit (1) aligned,    /* default setting for this switch */
  1    45               3 mbz1                    bit (36) aligned,   /* reserved for future use */
  1    46             2 names                     (alloc_switch_name_count refer (switch_list.switch_name_count)) char (32);
  1    47 
  1    48 declare   SWITCH_LIST_VERSION_1         char (8) static options (constant) init ("SWLIST01");
  1    49 
  1    50 declare   (
  1    51           FS_OBJECT_TYPE_SEGMENT        init ("-segment"),
  1    52           FS_OBJECT_TYPE_DIRECTORY      init ("-directory"),
  1    53           FS_OBJECT_TYPE_MSF            init ("-multisegment_file"),
  1    54           FS_OBJECT_TYPE_DM_FILE        init ("-dm_file"),
  1    55           FS_OBJECT_TYPE_LINK           init ("-link")
  1    56           )                             char (32) unaligned int static options (constant);
  1    57 
  1    58 /* END INCLUDE FILE: suffix_info.incl.pl1 */
     1295 
  2     1 /* BEGIN INCLUDE FILE:  copy_flags.incl.pl1 */
  2     2 
  2     3 /* Flags for attributes that should/may be copied by the copy_ subroutine. This include file is
  2     4*   required by suffix_info.incl.pl1 and copy_options.incl.pl1
  2     5*
  2     6*   Jay Pattin 6/23/83 */
  2     7 
  2     8 declare   1 copy_flags                  aligned based,      /* ON means that this attribute may be copied by copy_ */
  2     9           2 names                       bit (1) unaligned,
  2    10           2 acl                         bit (1) unaligned,
  2    11           2 ring_brackets               bit (1) unaligned,
  2    12           2 max_length                  bit (1) unaligned,
  2    13           2 copy_switch                 bit (1) unaligned,
  2    14           2 safety_switch               bit (1) unaligned,
  2    15           2 dumper_switches             bit (1) unaligned,
  2    16           2 entry_bound                 bit (1) unaligned,  /* only for vanilla object segments */
  2    17           2 extend                      bit (1) unaligned,  /* copy_ may append to end of existing object */
  2    18           2 update                      bit (1) unaligned,  /* copy_ may replace contents of existing object */
  2    19           2 mbz                         bit (26) unaligned;
  2    20 
  2    21 /* END INCLUDE FILE:  copy_flags.incl.pl1 */
     1296 
     1297  /*  BEGIN INCLUDE FILE - - - create_branch_info.incl.pl1 - - - created January 1975 */
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(89-01-16,TLNguyen), approve(89-01-16,MCR8049),
  3     6*     audit(89-02-03,Parisek), install(89-03-15,MR12.3-1025):
  3     7*       1. Declare version constant properly.
  3     8*       2. Remove version 1 since it was never referenced and to force
  3     9*          callers to upgrade their programs.
  3    10*                                                   END HISTORY COMMENTS */
  3    11 
  3    12 
  3    13 /* Modified December 1984 for dir_quota, Keith Loepere. */
  3    14 
  3    15 /* this include files gives the argument structure for create_branch_ */
  3    16 
  3    17 dcl 1 create_branch_info aligned based,
  3    18     2 version fixed bin,				/* set this to the largest value given below */
  3    19     2 switches unaligned,
  3    20       3 dir_sw bit (1) unaligned,			/* if on, a directory branch is wanted */
  3    21       3 copy_sw bit (1) unaligned,			/* if on, initiating segment will be done by copying */
  3    22       3 chase_sw bit (1) unaligned,			/* if on, if pathname is a link, it will be chased */
  3    23       3 priv_upgrade_sw bit (1) unaligned,		/* privileged creation (ring 1) of upgraded object */
  3    24       3 parent_ac_sw bit (1) unaligned,			/* if on, use parent's access class for seg or dir created */
  3    25       3 mbz1 bit (31) unaligned,			/* pad to full word */
  3    26     2 mode bit (3) unaligned,				/* segment or directory for acl for userid */
  3    27     2 mbz2 bit (33) unaligned,			/* pad to full word */
  3    28     2 rings (3) fixed bin (3),			/* branch's ring brackets */
  3    29     2 userid char (32),				/* user's access control name */
  3    30     2 bitcnt fixed bin (24),				/* bit count of the segment */
  3    31     2 quota fixed bin (18),				/* for directories, this am't of quota will be moved to it */
  3    32     2 access_class bit (72),				/* is the access class of the body of the branch */
  3    33     2 dir_quota fixed bin (18);			/* for directories, this am't of dir quota will be moved to it */
  3    34 
  3    35 dcl  create_branch_version_2 fixed bin int static options (constant) init (2);
  3    36 
  3    37 /* END INCLUDE FILE - - - create_branch_info.incl.pl1 - - - */
  3    38 
     1297 
     1298  /*	BEGIN INCLUDE FILE query_info.incl.pl1		TAC June 1, 1973 */
  4     2 /*        Renamed to query_info.incl.pl1 and cp_escape_control added, 08/10/78 WOS */
  4     3 /*	version number changed to 4, 08/10/78 WOS */
  4     4 /* Version 5 adds explanation_(ptr len) 05/08/81 S. Herbst */
  4     5 /* Version 6 adds literal_sw, prompt_after_explanation switch 12/15/82 S. Herbst */
  4     6 
  4     7 dcl 1 query_info aligned,				/* argument structure for command_query_ call */
  4     8     2 version fixed bin,				/* version of this structure - must be set, see below */
  4     9     2 switches aligned,                                     /* various bit switch values */
  4    10       3 yes_or_no_sw bit (1) unaligned init ("0"b),		/* not a yes-or-no question, by default */
  4    11       3 suppress_name_sw bit (1) unaligned init ("0"b),	/* do not suppress command name */
  4    12       3 cp_escape_control bit (2) unaligned init ("00"b),   /* obey static default value */
  4    13                                                             /* "01" -> invalid, "10" -> don't allow, "11" -> allow */
  4    14       3 suppress_spacing bit (1) unaligned init ("0"b),     /* whether to print extra spacing */
  4    15       3 literal_sw bit (1) unaligned init ("0"b),		/* ON => do not strip leading/trailing white space */
  4    16       3 prompt_after_explanation bit (1) unaligned init ("0"b),  /* ON => repeat question after explanation */
  4    17       3 padding bit (29) unaligned init (""b),		/* pads it out to t word */
  4    18     2 status_code fixed bin (35) init (0),		/* query not prompted by any error, by default */
  4    19     2 query_code fixed bin (35) init (0),		/* currently has no meaning */
  4    20 
  4    21 /*  Limit of data defined for version 2 */
  4    22 
  4    23     2 question_iocbp ptr init (null ()),		/* IO switch to write question */
  4    24     2 answer_iocbp ptr init (null ()),			/* IO switch to read answer */
  4    25     2 repeat_time fixed bin (71) init (0),		/* repeat question every N seconds if no answer */
  4    26 						/* minimum of 30 seconds required for repeat */
  4    27 						/* otherwise, no repeat will occur */
  4    28 /* Limit of data defined for version 4 */
  4    29 
  4    30     2 explanation_ptr ptr init (null ()),		/* explanation of question to be printed if */
  4    31     2 explanation_len fixed bin (21) init (0);		/* user answers "?" (disabled if ptr=null or len=0) */
  4    32 
  4    33 dcl  query_info_version_3 fixed bin int static options (constant) init (3);
  4    34 dcl  query_info_version_4 fixed bin int static options (constant) init (4);
  4    35 dcl  query_info_version_5 fixed bin int static options (constant) init (5);
  4    36 dcl  query_info_version_6 fixed bin int static options (constant) init (6); /* the current version number */
  4    37 
  4    38 /*	END INCLUDE FILE query_info.incl.pl1 */
     1298 
     1299  /* --------------- BEGIN include file status_structures.incl.pl1 --------------- */
  5     2 
  5     3 /* Revised from existing include files 09/26/78 by C. D. Tavares */
  5     4 
  5     5 /* This include file contains branch and link structures returned by
  5     6*   hcs_$status_ and hcs_$status_long. */
  5     7 
  5     8 dcl 1 status_branch aligned based (status_ptr),
  5     9     2 short aligned,
  5    10       3 type fixed bin (2) unaligned unsigned,		/* seg, dir, or link */
  5    11       3 nnames fixed bin (16) unaligned unsigned,		/* number of names */
  5    12       3 names_relp bit (18) unaligned,			/* see entry_names dcl */
  5    13       3 dtcm bit (36) unaligned,			/* date/time contents last modified */
  5    14       3 dtu bit (36) unaligned,			/* date/time last used */
  5    15       3 mode bit (5) unaligned,			/* caller's effective access */
  5    16       3 raw_mode bit (5) unaligned,			/* caller's raw "rew" modes */
  5    17       3 pad1 bit (8) unaligned,
  5    18       3 records_used fixed bin (18) unaligned unsigned,	/* number of NONZERO pages used */
  5    19 
  5    20 /* Limit of information returned by hcs_$status_ */
  5    21 
  5    22     2 long aligned,
  5    23       3 dtd bit (36) unaligned,			/* date/time last dumped */
  5    24       3 dtem bit (36) unaligned,			/* date/time branch last modified */
  5    25       3 lvid bit (36) unaligned,			/* logical volume ID */
  5    26       3 current_length fixed bin (12) unaligned unsigned,	/* number of last page used */
  5    27       3 bit_count fixed bin (24) unaligned unsigned,	/* reported length in bits */
  5    28       3 pad2 bit (8) unaligned,
  5    29       3 copy_switch bit (1) unaligned,			/* copy switch */
  5    30       3 tpd_switch bit (1) unaligned,			/* transparent to paging device switch */
  5    31       3 mdir_switch bit (1) unaligned,			/* is a master dir */
  5    32       3 damaged_switch bit (1) unaligned,		/* salvager warned of possible damage */
  5    33       3 synchronized_switch bit (1) unaligned,		/* DM synchronized file */
  5    34       3 pad3 bit (5) unaligned,
  5    35       3 ring_brackets (0:2) fixed bin (6) unaligned unsigned, 
  5    36       3 uid bit (36) unaligned;			/* unique ID */
  5    37 
  5    38 dcl 1 status_link aligned based (status_ptr),
  5    39     2 type fixed bin (2) unaligned unsigned,		/* as above */
  5    40     2 nnames fixed bin (16) unaligned unsigned,
  5    41     2 names_relp bit (18) unaligned,
  5    42     2 dtem bit (36) unaligned,
  5    43     2 dtd bit (36) unaligned,
  5    44     2 pathname_length fixed bin (17) unaligned,		/* see pathname */
  5    45     2 pathname_relp bit (18) unaligned;			/* see pathname */
  5    46 
  5    47 dcl  status_entry_names (status_branch.nnames) character (32) aligned
  5    48 	based (pointer (status_area_ptr, status_branch.names_relp)),
  5    49 						/* array of names returned */
  5    50      status_pathname character (status_link.pathname_length) aligned
  5    51 	based (pointer (status_area_ptr, status_link.pathname_relp)),
  5    52 						/* link target path */
  5    53      status_area_ptr pointer,
  5    54      status_ptr pointer;
  5    55 
  5    56 dcl (Link initial (0),
  5    57      Segment initial (1),
  5    58      Directory initial (2)) fixed bin internal static options (constant);
  5    59 						/* values for type fields declared above */
  5    60 
  5    61 /* ---------------- END include file status_structures.incl.pl1 ---------------- */
     1299 
     1300  /*  START OF:       copy_dir_options.incl.pl1  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *    */
  6     2 
  6     3           /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6     4           /*                                                                                        */
  6     5           /* This include file is used with the copy_dir_ subroutine to control the                 */
  6     6           /* type of entries copied or moved, and to control the operation of the subroutine.       */
  6     7           /* Status:                                                                                */
  6     8           /*                                                                                        */
  6     9           /* 0) Created:     11/14/80 by GA Texada                                                  */
  6    10 	/* 1) Modified:    09/25/84 by B. Braun to add the parent_ac_sw.			*/
  6    11           /*                                                                                        */
  6    12           /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6    13 
  6    14           dcl 1 copy_dir_options        aligned based(pcopy_dir_options),
  6    15                 2 version               fixed bin,          /* version of this structure, see below           */
  6    16                 2 entry_control         aligned,            /* these switches control what type of storage    */
  6    17                                                             /* system entries in the subtree are copied/moved */
  6    18                   3 link                bit(1) unal,        /* copy links                                     */
  6    19                   3 seg                 bit(1) unal,        /* copy segments                                  */
  6    20                   3 dir                 bit(1) unal,        /* copy directories                               */
  6    21                   3 msf                 bit(1) unal,        /* copy multisegment_files                        */
  6    22                   3 nnlk                bit(1) unal,        /* copy non_null_links                            */
  6    23                   3 raw                 bit (1) unal,       /* treat all objects as primitive types */
  6    24                   3 pad1                bit(30) unal,       /* mbz                                            */
  6    25                 2 operation_control     aligned,            /* the following switches control appropriate     */
  6    26                                                             /* portions of the subroutines execution          */
  6    27                   3 delete              bit(1) unal,        /* delete the source_dir                          */
  6    28                   3 brief               bit(1) unal,        /* suppresses warning messages                    */
  6    29                   3 force               bit(1) unal,        /* if target dir exists, do anyway without query  */
  6    30                   3 replace             bit(1) unal,        /* delete contents of target_dir (if any)         */
  6    31                   3 update              bit(1) unal,        /* update name dups without query                 */
  6    32                   3 acl                 bit(1) unal,        /* copy acl from source_dir                       */
  6    33                   3 primary             bit(1) unal,        /* copy only primary names                        */
  6    34                   3 link_translation    bit(1) unal,        /* copies links with translation                  */
  6    35                   3 chase               bit(1) unal,        /* copies the target of a link                    */
  6    36 	        3 parent_ac_sw	bit(1) unal,	/* if on, use the target parent's access class    */
  6    37 						/* for seg or dir created			*/
  6    38                   3 pad2                bit(26) unal;       /* mbz                                            */
  6    39 
  6    40           dcl copy_dir_options_version_0          fixed bin init(0)
  6    41                                         int static options(constant);
  6    42 
  6    43           dcl pcopy_dir_options                   ptr;
  6    44 
  6    45 /*  END OF:         copy_dir_options.incl.pl1  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *    */
     1300 
     1301  /* BEGIN INCLUDE FILE: copy_options.incl.pl1 */
  7     2 
  7     3 /* This structure declares the input structure used by the copy_ subroutine.
  7     4*
  7     5*   NOTE: This include file depends on declarations in the include file
  7     6*   copy_flags.incl.pl1.
  7     7*
  7     8*   Jay Pattin 6/1/83 */
  7     9 
  7    10 declare   copy_options_ptr              ptr;
  7    11 
  7    12 declare   1 copy_options                aligned based (copy_options_ptr),
  7    13           2 version                     char (8),           /* currently COPY_OPTIONS_VERSION_1 */
  7    14           2 caller_name                 char (32) unal,     /* Used in nd_handler_ call */
  7    15           2 source_dir                  char (168) unal,
  7    16           2 source_name                 char (32) unal,
  7    17           2 target_dir                  char (168) unal,
  7    18           2 target_name                 char (32) unal,
  7    19           2 flags,
  7    20             3 no_name_dup               bit (1) unaligned,  /* ON = don't call nd_handler_ */
  7    21             3 raw                       bit (1) unaligned,  /* ON = don't call object_type_, use hcs_ */
  7    22             3 force                     bit (1) unaligned,  /* ON = delete or force access to target */
  7    23             3 delete                    bit (1) unaligned,  /* ON = delete original after copy (for move) */
  7    24             3 target_err_switch         bit (1) unaligned,
  7    25             3 mbz                       bit (31) unaligned,
  7    26           2 copy_items                  like copy_flags;    /* see copy_flags.incl.pl1 */
  7    27 
  7    28 declare   COPY_OPTIONS_VERSION_1        char (8) static options (constant) init ("CPOPT001");
  7    29 
  7    30 /* END INCLUDE FILE: copy_options.incl.pl1 */
     1301 
     1302 declare   1 cpo                         aligned like copy_options;
     1303  /* BEGIN INCLUDE FILE:  delete_options.incl.pl1 */
  8     2 
  8     3 /* control flag bit string passed to delete_$path and delete_$ptr
  8     4*
  8     5*   Jay Pattin 6/6/83 */
  8     6 
  8     7 declare   1 delete_options,
  8     8           2 force                       bit (1) unaligned,  /* ON = delete w/o asking is safety switch on */
  8     9           2 question                    bit (1) unaligned,  /* ON = ask user if safety switch on */
  8    10           2 directory                   bit (1) unaligned,  /* ON = delete directories */
  8    11           2 segment                     bit (1) unaligned,  /* ON = delete segments */
  8    12           2 link                        bit (1) unaligned,  /* ON = delete links */
  8    13           2 chase                       bit (1) unaligned,  /* ON = delete through links */
  8    14           2 library                     bit (1) unaligned,  /* ON = use installation_tools_ */
  8    15           2 raw                         bit (1) unaligned,  /* ON = use hcs_, not object_type_ */
  8    16           2 mbz                         bit (28) unaligned;
  8    17 
  8    18 /* END INCLUDE FILE:  delete_options.incl.pl1 */
     1303 
  9     1 /* BEGIN INCLUDE FILE: nd_handler_options.incl.pl1 */
  9     2 
  9     3 /* This structure is used as the switches argument to nd_handler_$switches
  9     4*
  9     5*   Jay Pattin 2/27/83 */
  9     6 
  9     7 declare   1 nd_handler_options,
  9     8           2 force                       bit (1) unaligned,  /* ON = delete without query if removing last name */
  9     9           2 delete                      bit (1) unaligned,  /* ON = query to delete regardless of number of names */
  9    10           2 delete_force                bit (1) unaligned,  /* ON = always delete without query */
  9    11           2 raw                         bit (1) unaligned,  /* ON = call hcs_, not object_type_ */
  9    12           2 library                     bit (1) unaligned,  /* ON = call installation_tools_ for chname */
  9    13           2 mbz                         bit (31) unaligned;
  9    14 
  9    15 /* END INCLUDE FILE: nd_handler_options.incl.pl1 */
     1304 
     1305  /* BEGIN INCLUDE FILE:  copy_error_info.incl.pl1
 10     2*
 10     3*   This is the structure pointed to by sub_error_info.info_ptr when copy_
 10     4*   signals the sub_err_ condition.
 10     5*
 10     6*   Jay Pattin 6/13/83 */
 10     7 
 10     8 declare   1 copy_error_info             aligned based (sub_error_info.info_ptr),
 10     9           2 copy_options_ptr            ptr,                /* Pointer to input argument of copy_ */
 10    10           2 operation                   char (32),          /* Name of operation that failed. */
 10    11           2 target_err_switch           bit (1) aligned;    /* ON = error was on the target */
 10    12 
 10    13 /* END INCLUDE FILE:  copy_error_info.incl.pl1 */
     1305 
 11     1 /* BEGIN INCLUDE FILE sub_error_info.incl.pl1 */
 11     2 /* format: style2 */
 11     3 
 11     4 /* The include file condition_info_header must be used with this file */
 11     5 
 11     6      declare sub_error_info_ptr     pointer;
 11     7      declare 1 sub_error_info	      aligned based (sub_error_info_ptr),
 11     8 	     2 header	      aligned like condition_info_header,
 11     9 	     2 retval	      fixed bin (35),	/* return value */
 11    10 	     2 name	      char (32),		/* module name */
 11    11 	     2 info_ptr	      ptr;
 11    12 
 11    13      declare sub_error_info_version_1
 11    14 			      internal static options (constant) fixed bin init (1);
 11    15 
 11    16 /* END INCLUDE FILE sub_error_info.incl.pl1 */
     1306 
 12     1 /* BEGIN INCLUDE FILE condition_info_header.incl.pl1 BIM 1981 */
 12     2 /* format: style2 */
 12     3 
 12     4      declare condition_info_header_ptr
 12     5 			      pointer;
 12     6      declare 1 condition_info_header
 12     7 			      aligned based (condition_info_header_ptr),
 12     8 	     2 length	      fixed bin,		/* length in words of this structure */
 12     9 	     2 version	      fixed bin,		/* version number of this structure */
 12    10 	     2 action_flags	      aligned,		/* tell handler how to proceed */
 12    11 	       3 cant_restart     bit (1) unaligned,	/* caller doesn't ever want to be returned to */
 12    12 	       3 default_restart  bit (1) unaligned,	/* caller can be returned to with no further action */
 12    13 	       3 quiet_restart    bit (1) unaligned,	/* return, and print no message */
 12    14 	       3 support_signal   bit (1) unaligned,	/* treat this signal as if the signalling procedure had the support bit set */
 12    15 						/* if the signalling procedure had the support bit set, do the same for its caller */
 12    16 	       3 pad	      bit (32) unaligned,
 12    17 	     2 info_string	      char (256) varying,	/* may contain printable message */
 12    18 	     2 status_code	      fixed bin (35);	/* if^=0, code interpretable by com_err_ */
 12    19 
 12    20 /* END INCLUDE FILE condition_info_header.incl.pl1 */
     1307 
 13     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
 13     2 
 13     3 /* Structure for find_condition_info_.
 13     4*
 13     5*   Written 1-Mar-79 by M. N. Davidoff.
 13     6**/
 13     7 
 13     8 /* automatic */
 13     9 
 13    10      declare condition_info_ptr     pointer;
 13    11 
 13    12 /* based */
 13    13 
 13    14      declare 1 condition_info	      aligned based (condition_info_ptr),
 13    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
 13    16 	     2 version	      fixed binary,		/* Must be 1 */
 13    17 	     2 condition_name     char (32) varying,	/* name of condition */
 13    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
 13    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
 13    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
 13    21 	     2 flags	      unaligned,
 13    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
 13    23 	       3 pad1	      bit (35),
 13    24 	     2 pad2	      bit (36),
 13    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
 13    26 	     2 pad3	      (4) bit (36);
 13    27 
 13    28 /* internal static */
 13    29 
 13    30      declare condition_info_version_1
 13    31 			      fixed binary internal static options (constant) initial (1);
 13    32 
 13    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
     1308 
     1309 declare   1 ci                          aligned like condition_info;
 14     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
 14     2 /* format: style3 */
 14     3 
 14     4 /* These constants are to be used for the flags argument of sub_err_ */
 14     5 /* They are just "string (condition_info_header.action_flags)" */
 14     6 
 14     7 declare	(
 14     8 	ACTION_CAN_RESTART	init (""b),
 14     9 	ACTION_CANT_RESTART init ("1"b),
 14    10 	ACTION_DEFAULT_RESTART
 14    11 			init ("01"b),
 14    12 	ACTION_QUIET_RESTART
 14    13 			init ("001"b),
 14    14 	ACTION_SUPPORT_SIGNAL
 14    15 			init ("0001"b)
 14    16 	)		bit (36) aligned internal static options (constant);
 14    17 
 14    18 /* End include file */
     1310 
 15     1 /* BEGIN INCLUDE FILE . . . star_structures.incl.pl1 */
 15     2 
 15     3 /* This include file contains structures for the hcs_$star_,
 15     4*   hcs_$star_list_ and hcs_$star_dir_list_ entry points.
 15     5*
 15     6*   Written 23 October 1978 by Monte Davidoff.
 15     7*   Modified January 1979 by Michael R. Jordan to use unsigned and different pointers for different structures.
 15     8*   Modified June 1981 by C. Hornig to count link pathnames more efficiently.
 15     9**/
 15    10 
 15    11 /* automatic */
 15    12 
 15    13 declare  star_branch_count fixed binary;		/* hcs_$star_list_, hcs_$star_dir_list_: matching branch count */
 15    14 declare  star_entry_count fixed binary;			/* hcs_$star_: number of matching entries */
 15    15 declare  star_entry_ptr pointer;			/* hcs_$star_: pointer to array of entry information */
 15    16 declare  star_list_branch_ptr pointer;			/* hcs_$star_list_, hcs_$star_dir_list_: ptr to array of info */
 15    17 declare  star_link_count fixed binary;			/* hcs_$star_list_, hcs_$star_dir_list_: matching link count */
 15    18 declare  star_linkx fixed binary;			/* hcs_$star_list_, hcs_$star_dir_list_: index into star_links */
 15    19 declare  star_names_ptr pointer;			/* hcs_$star_: pointer to array of entry names */
 15    20 declare  star_list_names_ptr pointer;			/* hcs_$star_list_, hcs_$star_dir_list_: ptr to entry names */
 15    21 declare  star_select_sw fixed binary (3);		/* hcs_$star_list_, hcs_$star_dir_list_: what info to return */
 15    22 
 15    23 /* based */
 15    24 
 15    25 /* hcs_$star_ entry structure */
 15    26 
 15    27 declare 1 star_entries (star_entry_count) aligned based (star_entry_ptr),
 15    28         2 type fixed binary (2) unsigned unaligned,
 15    29 						/* storage system type */
 15    30         2 nnames fixed binary (16) unsigned unaligned,
 15    31 						/* number of names of entry that match star_name */
 15    32         2 nindex fixed binary (18) unsigned unaligned;
 15    33 						/* index of first name in star_names */
 15    34 
 15    35 /* hcs_$star_ name structure */
 15    36 
 15    37 declare  star_names (sum (star_entries (*).nnames)) char (32) based (star_names_ptr);
 15    38 
 15    39 /* hcs_$star_list_ branch structure */
 15    40 
 15    41 declare 1 star_list_branch (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
 15    42         2 type fixed binary (2) unsigned unaligned,
 15    43 						/* storage system type */
 15    44         2 nnames fixed binary (16) unsigned unaligned,
 15    45 						/* number of names of entry that match star_name */
 15    46         2 nindex fixed binary (18) unsigned unaligned,
 15    47 						/* index of first name in star_list_names */
 15    48         2 dtcm bit (36) unaligned,			/* date-time contents of branch were last modified */
 15    49         2 dtu bit (36) unaligned,			/* date-time branch was last used */
 15    50         2 mode bit (5) unaligned,			/* user's access mode to the branch */
 15    51         2 raw_mode bit (5) unaligned,			/* user's ACL access mode */
 15    52         2 master_dir bit (1) unaligned,			/* is branch a master directory */
 15    53         2 pad bit (7) unaligned,
 15    54         2 records fixed binary (18) unsigned unaligned;
 15    55 						/* records used by branch */
 15    56 
 15    57 /* hcs_$star_dir_list_ branch structure */
 15    58 
 15    59 declare 1 star_dir_list_branch (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
 15    60         2 type fixed binary (2) unsigned unaligned,
 15    61 						/* storage system type */
 15    62         2 nnames fixed binary (16) unsigned unaligned,
 15    63 						/* number of names of entry that match star_name */
 15    64         2 nindex fixed binary (18) unsigned unaligned,
 15    65 						/* index of first name in star_list_names */
 15    66         2 dtem bit (36) unaligned,			/* date-time directory entry of branch was last modified */
 15    67         2 pad bit (36) unaligned,
 15    68         2 mode bit (5) unaligned,			/* user's access mode to the branch */
 15    69         2 raw_mode bit (5) unaligned,			/* user's ACL access mode */
 15    70         2 master_dir bit (1) unaligned,			/* is branch a master directory */
 15    71         2 bit_count fixed binary (24) unaligned;
 15    72 						/* bit count of the branch */
 15    73 
 15    74 /* hcs_$star_list_ and hcs_$star_dir_list_ link structure */
 15    75 
 15    76 declare 1 star_links (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
 15    77         2 type fixed binary (2) unsigned unaligned,
 15    78 						/* storage system type */
 15    79         2 nnames fixed binary (16) unsigned unaligned,
 15    80 						/* number of names of entry that match star_name */
 15    81         2 nindex fixed binary (18) unsigned unaligned,
 15    82 						/* index of first name in star_list_names */
 15    83         2 dtem bit (36) unaligned,			/* date-time link was last modified */
 15    84         2 dtd bit (36) unaligned,			/* date-time the link was last dumped */
 15    85         2 pathname_len fixed binary (18) unsigned unaligned,
 15    86 						/* length of the pathname of the link */
 15    87         2 pathname_index fixed binary (18) unsigned unaligned;
 15    88 						/* index of start of pathname in star_list_names */
 15    89 
 15    90 /* hcs_$star_list_ and hcs_$star_dir_list_ name array */
 15    91 
 15    92 declare  star_list_names char (32) based (star_list_names_ptr)
 15    93 	dimension (star_links (star_branch_count + star_link_count).nindex
 15    94 	 + star_links (star_branch_count + star_link_count).nnames
 15    95 	 + divide (star_links (star_branch_count + star_link_count).pathname_len + 31, 32, 17, 0)
 15    96 	   * binary (
 15    97 	     (star_links (star_branch_count + star_link_count).type = star_LINK)
 15    98 	     & (star_select_sw >= star_LINKS_ONLY_WITH_LINK_PATHS), 1));
 15    99 
 15   100 /* hcs_$star_list_ and hcs_$star_dir_list_ link pathname */
 15   101 
 15   102 declare  star_link_pathname char (star_links (star_linkx).pathname_len)
 15   103          based (addr (star_list_names (star_links (star_linkx).pathname_index)));
 15   104 
 15   105 /* internal static */
 15   106 
 15   107 /* star_select_sw values */
 15   108 
 15   109 declare  star_LINKS_ONLY fixed binary (2) internal static options (constant) initial (1);
 15   110 declare  star_BRANCHES_ONLY fixed binary (2) internal static options (constant) initial (2);
 15   111 declare  star_ALL_ENTRIES fixed binary (2) internal static options (constant) initial (3);
 15   112 declare  star_LINKS_ONLY_WITH_LINK_PATHS
 15   113          fixed binary (3) internal static options (constant) initial (5);
 15   114 declare  star_ALL_ENTRIES_WITH_LINK_PATHS
 15   115          fixed binary (3) internal static options (constant) initial (7);
 15   116 
 15   117 /* storage system types */
 15   118 
 15   119 declare  star_LINK fixed binary (2) unsigned internal static options (constant) initial (0);
 15   120 declare  star_SEGMENT fixed binary (2) unsigned internal static options (constant) initial (1);
 15   121 declare  star_DIRECTORY fixed binary (2) unsigned internal static options (constant) initial (2);
 15   122 
 15   123 /* END INCLUDE FILE . . . star_structures.incl.pl1 */
     1311 
     1312 
     1313      end copy_dir_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/15/89  0800.0  copy_dir_.pl1                     >special_ldd>install>MR12.3-1025>copy_dir_.pl1
1295         1    03/05/85  1807.3  suffix_info.incl.pl1              >ldd>include>suffix_info.incl.pl1
1296         2    10/14/83  1606.7  copy_flags.incl.pl1               >ldd>include>copy_flags.incl.pl1
1297         3    03/15/89  0759.4  create_branch_info.incl.pl1       >special_ldd>install>MR12.3-1025>create_branch_info.incl.pl1
1298         4    03/11/83  1204.3  query_info_.incl.pl1              >ldd>include>query_info.incl.pl1
1299         5    11/22/82  0955.7  status_structures.incl.pl1        >ldd>include>status_structures.incl.pl1
1300         6    10/04/84  1320.9  copy_dir_options.incl.pl1         >ldd>include>copy_dir_options.incl.pl1
1301         7    10/14/83  1606.7  copy_options.incl.pl1             >ldd>include>copy_options.incl.pl1
1303         8    10/14/83  1606.7  delete_options.incl.pl1           >ldd>include>delete_options.incl.pl1
1304         9    10/14/83  1606.7  nd_handler_options.incl.pl1       >ldd>include>nd_handler_options.incl.pl1
1305        10    10/14/83  1606.7  copy_error_info.incl.pl1          >ldd>include>copy_error_info.incl.pl1
1306        11    07/18/81  1100.0  sub_error_info.incl.pl1           >ldd>include>sub_error_info.incl.pl1
1307        12    03/24/82  1347.2  condition_info_header.incl.pl1    >ldd>include>condition_info_header.incl.pl1
1308        13    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
1310        14    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
1311        15    06/10/82  1045.5  star_structures.incl.pl1          >ldd>include>star_structures.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000071 constant        bit(36)                  initial dcl 14-7 set ref 213*
COPY_OPTIONS_VERSION_1          000000 constant        char(8)                  initial packed unaligned dcl 7-28 ref 474
Directory                              constant        fixed bin(17,0)          initial dcl 5-56 ref 294 336 1208
FS_OBJECT_TYPE_DIRECTORY        000002 constant        char(32)                 initial packed unaligned dcl 1-50 ref 306 354
Link                                   constant        fixed bin(17,0)          initial dcl 5-56 ref 1203
SUFFIX_INFO_VERSION_1           000012 constant        char(8)                  initial packed unaligned dcl 1-29 ref 791
access_class             20            based           bit(72)                  level 2 dcl 3-17 set ref 883* 968* 971*
acl                       2(05)        based           bit(1)                   level 3 in structure "copy_dir_options" packed
                                                                                  packed unaligned dcl 6-14 in procedure "copy_dir_"
                                                                                  ref 247
acl                                    parameter       bit(1)                   packed unaligned dcl 774 in procedure "file" ref 769
                                                                                  789
acl                     157(01) 000457 automatic       bit(1)                   level 3 in structure "cpo" packed packed unaligned
                                                                                  dcl 1302 in procedure "copy_dir_" set ref 789*
acl                                    parameter       bit(1)                   packed unaligned dcl 545 in procedure "work" set ref
                                                                                  530 585* 607* 713* 931* 933
acl                             000122 automatic       bit(1)                   packed unaligned dcl 130 in procedure "copy_dir_"
                                                                                  set ref 247* 479* 481
acode                                  parameter       fixed bin(35,0)          dcl 112 set ref 33 203* 342* 508 508* 747* 865*
                                                                                  1291*
action_flags              2            based           structure                level 3 dcl 11-7
addr                                                   builtin function         dcl 194 ref 375 375 636 636 793 793 809 809 818 818
                                                                                  821
all_entries                     000123 automatic       bit(1)                   packed unaligned dcl 130 set ref 231* 235* 580 585
                                                                                  607 611 713 713 715
all_names                       000124 automatic       bit(1)                   packed unaligned dcl 130 set ref 258* 260* 489 788
                                                                                  905
answer                          000116 automatic       varying char(3)          dcl 126 set ref 375* 383
answer_iocbp              6     000442 automatic       pointer                  initial level 2 dcl 4-7 set ref 4-7*
area                                   based           area(1024)               dcl 108 ref 207 263 520 556 558 621 624 645 672 1137
area_ptr                        000426 automatic       pointer                  dcl 164 set ref 207 220* 263 432* 520 556 558 564*
                                                                                  621 624 636* 644 645 647 672 1137
arg_list_ptr                    000104 automatic       pointer                  dcl 1274 set ref 1284* 1285*
argl                            000102 automatic       fixed bin(21,0)          dcl 1272 set ref 1278*
argp                            000100 automatic       pointer                  dcl 1271 set ref 1278* 1286 1288 1291
bc                              000114 automatic       fixed bin(24,0)          dcl 124 set ref 286* 294 319* 336 598* 605 690* 713
                                                                                  715 722* 845*
bitcnt                   16            based           fixed bin(24,0)          level 2 dcl 3-17 set ref 274*
branches                               based           structure                array level 1 dcl 538 ref 556 621
brief                     2(01)        based           bit(1)                   level 3 in structure "copy_dir_options" packed
                                                                                  packed unaligned dcl 6-14 in procedure "copy_dir_"
                                                                                  ref 243
brief                           000125 automatic       bit(1)                   packed unaligned dcl 130 in procedure "copy_dir_"
                                                                                  set ref 243* 323 505 1279
caller_name               2     000457 automatic       char(32)                 level 2 packed packed unaligned dcl 1302 set ref
                                                                                  475*
cant_restart              2            based           bit(1)                   level 4 packed packed unaligned dcl 11-7 ref 834
cb_ptr                          000430 automatic       pointer                  dcl 164 set ref 202* 207 207 263* 264 265 266 267
                                                                                  268 269 270 271 272 273 274 520 520 880 881 882
                                                                                  883 891 892 893 894 895* 953 954 954 955 964 965
                                                                                  966 968 971 979*
cdir                            000140 automatic       bit(1)                   packed unaligned dcl 130 set ref 232* 238* 611 715
chase                     2(08)        based           bit(1)                   level 3 in structure "copy_dir_options" packed
                                                                                  packed unaligned dcl 6-14 in procedure "copy_dir_"
                                                                                  ref 250
chase                     0(05) 000637 automatic       bit(1)                   level 2 in structure "delete_options" packed packed
                                                                                  unaligned dcl 8-7 in procedure "copy_dir_" set ref
                                                                                  421*
chase                           000126 automatic       bit(1)                   packed unaligned dcl 130 in procedure "copy_dir_"
                                                                                  set ref 250* 421 674
chase_sw                  1(02)        based           bit(1)                   level 3 packed packed unaligned dcl 3-17 set ref
                                                                                  270* 893*
ci                              000644 automatic       structure                level 1 dcl 1309 set ref 818 818
cleanup                         000100 stack reference condition                dcl 100 ref 205 554
clink                           000134 automatic       bit(1)                   packed unaligned dcl 130 set ref 232* 236* 580 680
                                                                                  694
cmsf                            000136 automatic       bit(1)                   packed unaligned dcl 130 set ref 232* 239* 607 713
cnnl                            000137 automatic       bit(1)                   packed unaligned dcl 130 set ref 232* 240* 580 720
code                            001076 automatic       fixed bin(35,0)          dcl 1092 in procedure "csub" set ref 1111* 1112 1112
code                                   parameter       fixed bin(35,0)          dcl 1122 in procedure "path_info" ref 1117
code                                   parameter       fixed bin(35,0)          dcl 1036 in procedure "contains" set ref 1027 1038*
                                                                                  1042* 1043 1046* 1047 1050* 1051 1056* 1061* 1062
                                                                                  1070* 1071 1079* 1080
code                                   parameter       fixed bin(35,0)          dcl 1167 in procedure "contains_target" set ref 1150
                                                                                  1170* 1171 1176* 1190* 1191 1191 1191 1196* 1200*
                                                                                  1205* 1212* 1216* 1219 1221* 1228* 1238*
code                            000112 automatic       fixed bin(35,0)          dcl 122 in procedure "copy_dir_" set ref 286* 287
                                                                                  287 289* 305* 310* 311 319* 320 320 327 331* 338*
                                                                                  340 342 347 353* 358* 359 388* 389 391* 432* 433
                                                                                  435 436* 443* 444 444 446* 456* 457 457* 461* 462
                                                                                  462* 467* 468 468* 483* 484 484* 491* 494* 495 495
                                                                                  495 495* 516* 517 517* 564* 565 565 570* 593* 594
                                                                                  598* 599 601* 636* 637 639* 651* 652 654* 660* 661
                                                                                  663 663* 666* 676* 677 677 677 685* 690* 691 691
                                                                                  691 699* 707* 708 722* 723 723 723 727* 733* 735
                                                                                  735 753* 759* 760 760 760 762* 793* 794 796* 827*
                                                                                  829* 845* 846 849* 850 852* 859* 860 860 865 869*
                                                                                  870 872* 883* 884 886* 895* 896 898* 907* 908 908
                                                                                  908 908* 914* 915 915* 918* 919 919* 925* 926 926*
                                                                                  935* 936 936* 946* 948* 949 951 951 958* 968* 969
                                                                                  971 971 974* 979* 980 982* 985* 986 988* 993* 994
                                                                                  996* 1007* 1018*
code                            001242 automatic       fixed bin(35,0)          dcl 1253 in procedure "get_uid" set ref 1256* 1257
                                                                                                                     P   Lastuka                 OperDevel         }De               OK'   .           @     4                                                      "   NMills                  Multics           C@BA              R$@   \     h      n                                                Elhard                  Multics           7	@              PG:                                                            Fudge                   SysAdmin          7               PH                                                                  Leskiw                  Multics           7	              PG j                   |                                      j   Gee                     Multics           7%              PH
;O            4  &     N                                      <   Humeniuk                CDC               }@9              Oh<v   B            T                                                             Vu                      Multics           7	              PH   p     B                                                  Mabey                   Multics           7
              PI\W+                                                            Luk                     Multics           -p              Qd=p                                                              Wright                  Multics           7	@)              PH                   h                                      V    Kittlitz                Multics           7f .              PH   (           :     :                                         (   !Rohs                    Multics           7H              PJI   V       N  h        !                                      "Miko                    Multics           7<              PH]            \          "       ?                                         #Westcott                Fortran           7              PI&
                     #                                         $Durand                  Multics           76              PH@7                      $                                   p   %AWTaylor                Multics                H'    z     P&,$                      T   %                                      B   &Hoover                  Multics           7 @              PH   <     .      N     &   &                                      'Rosin                   Operator          7}              PI=(   j           |        '            ?                                   (Opr                     Operator          7              PI8	                        (              x                                   )WAAnderson              SysMaint           :V              S0n                        )           ?                                   *Samanani                Multics           7              PHT                   n   *                             ref 530 550* 550
d2                                     parameter       char                     packed unaligned dcl 544 set ref 530 551* 551
default_restart           2(01)        based           bit(1)                   level 4 packed packed unaligned dcl 11-7 set ref
                                                                                  829*
delete                    2            based           bit(1)                   level 3 packed packed unaligned dcl 6-14 ref 221 225
delete_$path                    000112 constant        entry                    external dcl 88 ref 443 516
delete_force              0(02) 000640 automatic       bit(1)                   level 2 packed packed unaligned dcl 9-7 set ref 740*
delete_options                  000637 automatic       structure                level 1 packed packed unaligned dcl 8-7 set ref 415*
                                                                                  443 443 513* 516 516
dir                             001160 automatic       char(168)                packed unaligned dcl 1251 in procedure "get_uid" set
                                                                                  ref 1256* 1260*
dir                             001077 automatic       char(128)                packed unaligned dcl 1093 in procedure "csub" set
                                                                                  ref 1099* 1103* 1106* 1106 1111*
dir                       1(02)        based           bit(1)                   level 3 in structure "copy_dir_options" packed
                                                                                  packed unaligned dcl 6-14 in procedure "copy_dir_"
                                                                                  ref 222 229 238
dir                             000513 automatic       char(168)                packed unaligned dcl 1163 in procedure
                                                                                  "contains_target" set ref 1181* 1187* 1187 1190*
                                                                                  1216*
dir1                            000722 automatic       char(168)                packed unaligned dcl 1032 set ref 1042* 1050* 1054
dir1_uid                        000165 automatic       bit(36)                  dcl 158 set ref 314* 362 1083 1225
dir2                            000774 automatic       char(168)                packed unaligned dcl 1032 set ref 1046* 1054 1061*
dir2_uid                        000166 automatic       bit(36)                  dcl 158 set ref 358* 362 985* 1074
dir_quota                22            based           fixed bin(18,0)          level 2 dcl 3-17 set ref 266*
dir_rings                       000120 automatic       fixed bin(3,0)           array dcl 128 set ref 849* 869* 880 881 948* 964 965
dir_sw                    1            based           bit(1)                   level 3 packed packed unaligned dcl 3-17 set ref
                                                                                  268* 891*
directory                 0(02) 000637 automatic       bit(1)                   level 2 packed packed unaligned dcl 8-7 set ref 417*
                                                                                  514*
dirstr                          000102 automatic       char(168)                packed unaligned dcl 1126 set ref 1129* 1131* 1132
                                                                                  1138 1141* 1141 1143
dumper_switches          46(06) 000100 automatic       bit(1)                   level 3 in structure "local_suffix_info" packed
                                                                                  packed unaligned dcl 776 in procedure "file" set
                                                                                  ref 803
dumper_switches         157(06) 000457 automatic       bit(1)                   level 3 in structure "cpo" packed packed unaligned
                                                                                  dcl 1302 in procedure "copy_dir_" set ref 803*
e                                      parameter       char                     packed unaligned dcl 1123 ref 1117 1129 1131
e1                                     parameter       char                     packed unaligned dcl 544 set ref 530 550*
e2                                     parameter       char                     packed unaligned dcl 544 set ref 530 551*
en                              000503 automatic       char(32)                 packed unaligned dcl 1162 in procedure
                                                                                  "contains_target" set ref 1189* 1190* 1216*
en                              001137 automatic       char(32)                 packed unaligned dcl 1094 in procedure "csub" set
                                                                                  ref 1110* 1111*
en1                             001046 automatic       char(32)                 packed unaligned dcl 1033 set ref 1042* 1050* 1054
en2                             001056 automatic       char(32)                 packed unaligned dcl 1033 set ref 1046* 1054 1061*
entry                           001232 automatic       char(32)                 packed unaligned dcl 1252 set ref 1256* 1260*
entry_control             1            based           structure                level 2 dcl 6-14
entry_count                     000242 automatic       fixed bin(17,0)          dcl 547 set ref 556 564* 576 621
entry_index                     000160 automatic       fixed bin(17,0)          dcl 156 set ref 442* 443 446 446*
error_message                   000106 automatic       char(512)                packed unaligned dcl 1275 set ref 1285* 1286 1286
error_message_length            000306 automatic       fixed bin(17,0)          dcl 1276 set ref 1285* 1286 1286
error_table_$action_not_performed
                                000124 external static fixed bin(35,0)          dcl 175 set ref 225* 364* 399* 407* 505* 508 744 860
                                                                                  1003* 1007 1014* 1018
error_table_$bad_ring_brackets  000130 external static fixed bin(35,0)          dcl 175 ref 444
error_table_$inconsistent       000126 external static fixed bin(35,0)          dcl 175 set ref 254*
error_table_$incorrect_access   000132 external static fixed bin(35,0)          dcl 175 ref 951 971
error_table_$namedup            000144 external static fixed bin(35,0)          dcl 175 ref 495 735 760 908
error_table_$no_dir             000134 external static fixed bin(35,0)          dcl 175 ref 677 691 723 1191
error_table_$no_s_permission    000136 external static fixed bin(35,0)          dcl 175 ref 287 951 971
error_table_$noentry            000146 external static fixed bin(35,0)          dcl 175 ref 320 677 691 723 1191
error_table_$nomatch            000150 external static fixed bin(35,0)          dcl 175 ref 435 565
error_table_$not_seg_type       000140 external static fixed bin(35,0)          dcl 175 ref 594 708
error_table_$notadir            000152 external static fixed bin(35,0)          dcl 175 set ref 296*
error_table_$sameseg            000154 external static fixed bin(35,0)          dcl 175 ref 1056
error_table_$segnamedup         000142 external static fixed bin(35,0)          dcl 175 ref 495 760 908
error_table_$unimplemented_version
                                000156 external static fixed bin(35,0)          dcl 175 set ref 213*
errors                          000141 automatic       bit(1)                   packed unaligned dcl 130 set ref 454* 502 748* 864*
                                                                                  1290*
ersw                            000142 automatic       bit(1)                   packed unaligned dcl 130 set ref 467* 468 483* 484
                                                                                  491* 494* 495 753 759* 762 907* 908 925* 926 935*
                                                                                  936
expand_pathname_                000030 constant        entry                    external dcl 60 ref 651 1256
explanation_len          14     000442 automatic       fixed bin(21,0)          initial level 2 dcl 4-7 set ref 4-7*
explanation_ptr          12     000442 automatic       pointer                  initial level 2 dcl 4-7 set ref 4-7*
find_condition_info_            000032 constant        entry                    external dcl 61 ref 818
flags                   156     000457 automatic       structure                level 2 dcl 1302 set ref 783*
force                           000637 automatic       bit(1)                   level 2 in structure "delete_options" packed packed
                                                                                  unaligned dcl 8-7 in procedure "copy_dir_" set ref
                                                                                  416*
force                           000127 automatic       bit(1)                   packed unaligned dcl 130 in procedure "copy_dir_"
                                                                                  set ref 244* 368 416
force                     2(02)        based           bit(1)                   level 3 in structure "copy_dir_options" packed
                                                                                  packed unaligned dcl 6-14 in procedure "copy_dir_"
                                                                                  ref 244
from_dir                               parameter       char                     packed unaligned dcl 772 in procedure "file" set ref
                                                                                  769 778 793* 796* 796* 829* 829*
from_dir                        000101 automatic       char(168)                packed unaligned dcl 533 in procedure "work" set ref
                                                                                  550* 564* 570* 585* 593* 598* 601* 601 607* 616*
                                                                                  616 636* 639* 639 654* 654 685* 685 699* 699 727*
                                                                                  727 753* 753 759* 762* 762 849* 852* 852 869* 872*
                                                                                  872 883* 886* 886 907* 908* 908 914* 915* 915 925*
                                                                                  926* 926 931* 935* 936* 936
from_en                                parameter       char                     packed unaligned dcl 772 set ref 769 779 793* 796*
                                                                                  796* 829* 829*
fs_util_$get_type               000114 constant        entry                    external dcl 89 ref 305 353 593 707
fs_util_$suffix_info            000116 constant        entry                    external dcl 90 ref 793
fs_util_type                    000150 automatic       char(32)                 packed unaligned dcl 155 set ref 305* 306 353* 354
                                                                                  593* 594 707* 708
get_group_id_$tag_star          000034 constant        entry                    external dcl 62 ref 219
get_max_authorization_          000036 constant        entry                    external dcl 63 ref 971
get_ring_                       000040 constant        entry                    external dcl 64 ref 953
get_system_free_area_           000042 constant        entry                    external dcl 65 ref 220
hcs_$append_link                000050 constant        entry                    external dcl 68 ref 733
hcs_$create_branch_             000052 constant        entry                    external dcl 69 ref 895 979
hcs_$get_access_class           000046 constant        entry                    external dcl 67 ref 883 968
hcs_$get_dir_ring_brackets      000044 constant        entry                    external dcl 66 ref 849 869 948
hcs_$get_link_target            000060 constant        entry                    external dcl 72 ref 676 1042 1046
hcs_$get_safety_sw              000054 constant        entry                    external dcl 70 ref 456 914
hcs_$get_uid_file               000056 constant        entry                    external dcl 71 ref 310 358 985 1111 1216 1260
hcs_$set_safety_sw              000062 constant        entry                    external dcl 73 ref 461 918
hcs_$star_                      000064 constant        entry                    external dcl 74 ref 432 564
hcs_$status_                    000066 constant        entry                    external dcl 76 ref 636
hcs_$status_minf                000070 constant        entry                    external dcl 77 ref 286 319 598 690 722 845 1190
header                                 based           structure                level 2 dcl 11-7
i                               000502 automatic       fixed bin(17,0)          dcl 1161 in procedure "contains_target" set ref
                                                                                  1186* 1210 1225*
i                               000100 automatic       fixed bin(17,0)          dcl 532 in procedure "work" set ref 576* 577 578 583
                                                                                  589*
ii                              000164 automatic       fixed bin(17,0)          dcl 156 set ref 1132* 1136 1138 1141 1143*
index                                                  builtin function         dcl 194 ref 1132 1143
info_ptr                116            based           pointer                  level 2 in structure "sub_error_info" dcl 11-7
                                                                                  in procedure "copy_dir_" ref 821 829
info_ptr                 14     000644 automatic       pointer                  level 2 in structure "ci" dcl 1309 in procedure
                                                                                  "copy_dir_" set ref 819
info_string               3            based           varying char(256)        level 3 dcl 11-7 set ref 829 829*
ioa_                            000102 constant        entry                    external dcl 84 ref 323
ioa_$general_rs                 000100 constant        entry                    external dcl 82 ref 1285
ioa_$rsnnl                      000104 constant        entry                    external dcl 85 ref 550 551 1232
lcomp_count                     000161 automatic       fixed bin(17,0)          dcl 156 set ref 1170* 1174 1186
lcomp_root                      000432 automatic       pointer                  dcl 164 set ref 1170* 1180
ld                              000414 automatic       char(168)                packed unaligned dcl 634 in procedure "link" set ref
                                                                                  651* 660* 666* 666 676* 676* 685* 685 690* 699*
                                                                                  699 707* 713* 722* 727* 727
ld                                     parameter       char                     packed unaligned dcl 1166 in procedure
                                                                                  "contains_target" set ref 1150 1170*
le                                     parameter       char                     packed unaligned dcl 1166 in procedure
                                                                                  "contains_target" set ref 1150 1170* 1243
le                              000376 automatic       char(32)                 packed unaligned dcl 162 in procedure "copy_dir_"
                                                                                  set ref 651* 660* 666* 676* 676* 685* 690* 699*
                                                                                  707* 713* 722* 727*
library                   0(06) 000637 automatic       bit(1)                   level 2 packed packed unaligned dcl 8-7 set ref 422*
link                      1            based           bit(1)                   level 3 in structure "copy_dir_options" packed
                                                                                  packed unaligned dcl 6-14 in procedure "copy_dir_"
                                                                                  ref 222 229 236
link                      0(04) 000637 automatic       bit(1)                   level 2 in structure "delete_options" packed packed
                                                                                  unaligned dcl 8-7 in procedure "copy_dir_" set ref
                                                                                  417*
link_target                     000270 automatic       char(168)                packed unaligned dcl 634 set ref 649* 651* 654* 661*
                                                                                  733*
link_translation          2(07)        based           bit(1)                   level 3 packed packed unaligned dcl 6-14 ref 249
links                           000264 automatic       structure                level 1 dcl 632 set ref 636 636
literal_sw                1(05) 000442 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 4-7 set
                                                                                  ref 4-7*
ln                              000111 automatic       fixed bin(21,0)          dcl 120 set ref 550* 551* 1232*
local_suffix_info               000100 automatic       structure                level 1 dcl 776 set ref 793 793
max_length              157(03) 000457 automatic       bit(1)                   level 3 in structure "cpo" packed packed unaligned
                                                                                  dcl 1302 in procedure "copy_dir_" set ref 802*
max_length               46(03) 000100 automatic       bit(1)                   level 3 in structure "local_suffix_info" packed
                                                                                  packed unaligned dcl 776 in procedure "file" set
                                                                                  ref 802
mode                      2            based           bit(3)                   level 2 packed packed unaligned dcl 3-17 set ref
                                                                                  267* 894*
move                            000147 automatic       bit(1)                   packed unaligned dcl 130 in procedure "copy_dir_"
                                                                                  set ref 221* 479* 481 502
move                                   parameter       bit(1)                   packed unaligned dcl 774 in procedure "file" ref 769
                                                                                  789
move                                   parameter       bit(1)                   packed unaligned dcl 545 in procedure "work" set ref
                                                                                  530 585* 607* 713* 931* 933
move_names_                     000022 constant        entry                    external dcl 54 ref 491
msf                       1(03)        based           bit(1)                   level 3 packed packed unaligned dcl 6-14 ref 222 229
                                                                                  239
name                                   based           varying char(32)         level 2 in structure "comp" dcl 104 in procedure
                                                                                  "copy_dir_" set ref 1106 1110 1138* 1187 1189 1235
name                            000225 automatic       char(32)                 packed unaligned dcl 534 in procedure "work" set ref
                                                                                  577* 585* 585* 593* 598* 601* 607* 607* 616* 636*
                                                                                  639* 654* 685* 699* 713* 727* 733* 741* 753* 753*
                                                                                  759* 759* 762* 762* 845* 849* 852* 859* 869* 872*
                                                                                  883* 886* 895* 898* 907* 907* 908* 908* 914* 915*
                                                                                  918* 919* 925* 925* 926* 926* 931* 931* 935* 935*
                                                                                  936* 936*
name                    106            based           char(32)                 level 2 in structure "sub_error_info" dcl 11-7
                                                                                  in procedure "copy_dir_" ref 821
names                                  based           char(32)                 array dcl 535 in procedure "work" ref 558 577 624
                                                                                  645
names                   157     000457 automatic       bit(1)                   level 3 in structure "cpo" packed packed unaligned
                                                                                  dcl 1302 in procedure "copy_dir_" set ref 788*
names_relp                0(18) 000264 automatic       bit(18)                  level 2 packed packed unaligned dcl 632 set ref 644
nargs                           000103 automatic       fixed bin(17,0)          dcl 1273 set ref 1281* 1282
nd_handler_                     000106 constant        entry                    external dcl 86 ref 338 859
nd_handler_$switches            000110 constant        entry                    external dcl 87 ref 741
nd_handler_options              000640 automatic       structure                level 1 packed packed unaligned dcl 9-7 set ref 738*
                                                                                  741 741
new_target                      000342 automatic       char(168)                packed unaligned dcl 634 in procedure "link" set ref
                                                                                  660* 661
new_target                             parameter       char(168)                packed unaligned dcl 1164 in procedure
                                                                                  "contains_target" set ref 1150 1232* 1235* 1235
                                                                                  1243* 1243
next                     12            based           pointer                  level 2 dcl 104 set ref 1107 1139* 1188 1233 1236
nindex                    0(18)        based           fixed bin(17,0)          array level 2 packed packed unaligned dcl 538 ref
                                                                                  577
nnlk                      1(04)        based           bit(1)                   level 3 packed packed unaligned dcl 6-14 ref 222 240
no_name_dup             156     000457 automatic       bit(1)                   level 3 packed packed unaligned dcl 1302 set ref
                                                                                  785*
no_translation                         constant        fixed bin(35,0)          initial dcl 96 ref 663 1176 1196 1200 1205 1212 1221
                                                                                  1228
nptr                            000236 automatic       pointer                  dcl 537 set ref 558 558 564* 577 624 624
null                                                   builtin function         dcl 194 ref 202 213 213 428 429 520 4-7 4-7 4-7 207
                                                                                  556 558 621 624 818 818 1133 1135 1234
operation_control         2            based           structure                level 2 dcl 6-14
optr                            000100 automatic       pointer                  dcl 1125 set ref 1135* 1139 1140*
p                               000566 automatic       pointer                  dcl 1165 in procedure "contains_target" set ref
                                                                                  1180* 1187 1188* 1188 1189 1233* 1233 1234 1235
                                                                                  1236* 1236
p                               001074 automatic       pointer                  dcl 1091 in procedure "csub" set ref 1100* 1106
                                                                                  1107* 1107 1110
p_code                                 based           fixed bin(35,0)          dcl 1270 in procedure "complain" set ref 1286* 1288*
                                                                                  1291
p_code                                 parameter       fixed bin(35,0)          dcl 1092 in procedure "csub" set ref 1088 1101*
                                                                                  1112*
p_count                                parameter       fixed bin(17,0)          dcl 1095 ref 1088 1103 1105
p_path                                 parameter       char(168)                packed unaligned dcl 1250 set ref 1248 1256*
p_root                                 parameter       pointer                  dcl 1091 ref 1088 1100
p_source_contains_target               parameter       bit(1)                   packed unaligned dcl 1034 set ref 1027 1039* 1058*
                                                                                  1074*
p_target_contains_source               parameter       bit(1)                   packed unaligned dcl 1035 set ref 1027 1040* 1057*
                                                                                  1083*
p_uid                                  parameter       bit(36)                  dcl 1097 set ref 1088 1111*
padding                   1(07) 000442 automatic       bit(29)                  initial level 3 packed packed unaligned dcl 4-7 set
                                                                                  ref 4-7*
parent_ac_sw              2(09)        based           bit(1)                   level 3 in structure "copy_dir_options" packed
                                                                                  packed unaligned dcl 6-14 in procedure "copy_dir_"
                                                                                  ref 242
parent_ac_sw              1(04)        based           bit(1)                   level 3 in structure "create_branch_info" packed
                                                                                  packed unaligned dcl 3-17 in procedure "copy_dir_"
                                                                                  set ref 271*
parent_access                   000106 automatic       bit(1)                   packed unaligned dcl 113 set ref 242* 271
pathname                               based           char                     dcl 633 ref 649 672
pathname_                       000120 constant        entry                    external dcl 91 ref 323 323 399 399 399 399 407 407
                                                                                  407 407 425 796 796 829 829 829 829 1003 1003 1003
                                                                                  1003 1014 1014 1014 1014
pathname_length           3     000264 automatic       fixed bin(17,0)          level 2 packed packed unaligned dcl 632 set ref 649
                                                                                  672 672
pathname_relp             3(18) 000264 automatic       bit(18)                  level 2 packed packed unaligned dcl 632 set ref 647
pcopy_dir_options                      parameter       pointer                  dcl 6-43 ref 33 211 213 221 222 222 222 222 222 225
                                                                                  229 229 229 229 236 237 238 239 240 242 243 244
                                                                                  245 246 247 248 248 249 250 251 258
pptr                            000262 automatic       pointer                  dcl 631 set ref 644* 645 647* 649 672
primary                   2(06)        based           bit(1)                   level 3 packed packed unaligned dcl 6-14 set ref
                                                                                  248* 248 258
priv_upgrade_sw           1(03)        based           bit(1)                   level 3 packed packed unaligned dcl 3-17 set ref
                                                                                  272*
prompt_after_explanation
                          1(06) 000442 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 4-7 set
                                                                                  ref 4-7*
ptr                                                    builtin function         dcl 194 ref 644 647
query_code                3     000442 automatic       fixed bin(35,0)          initial level 2 dcl 4-7 set ref 374* 4-7*
query_info                      000442 automatic       structure                level 1 dcl 4-7 set ref 375 375
question                  0(01) 000637 automatic       bit(1)                   level 2 packed packed unaligned dcl 8-7 set ref 417*
                                                                                  514*
question_iocbp            4     000442 automatic       pointer                  initial level 2 dcl 4-7 set ref 4-7*
quota                    17            based           fixed bin(18,0)          level 2 dcl 3-17 set ref 265*
raw                       0(07) 000637 automatic       bit(1)                   level 2 in structure "delete_options" packed packed
                                                                                  unaligned dcl 8-7 in procedure "copy_dir_" set ref
                                                                                  423* 515*
raw                     156(01) 000457 automatic       bit(1)                   level 3 in structure "cpo" packed packed unaligned
                                                                                  dcl 1302 in procedure "copy_dir_" set ref 784*
raw                       0(03) 000640 automatic       bit(1)                   level 2 in structure "nd_handler_options" packed
                                                                                  packed unaligned dcl 9-7 in procedure "copy_dir_"
                                                                                  set ref 739*
raw                       1(05)        based           bit(1)                   level 3 in structure "copy_dir_options" packed
                                                                                  packed unaligned dcl 6-14 in procedure "copy_dir_"
                                                                                  ref 251
raw                             000130 automatic       bit(1)                   packed unaligned dcl 130 in procedure "copy_dir_"
                                                                                  set ref 251* 303 351 423 515 591 705 739 784
repeat_time              10     000442 automatic       fixed bin(71,0)          initial level 2 dcl 4-7 set ref 4-7*
replace                   2(03)        based           bit(1)                   level 3 in structure "copy_dir_options" packed
                                                                                  packed unaligned dcl 6-14 in procedure "copy_dir_"
                                                                                  ref 245
replace                         000131 automatic       bit(1)                   packed unaligned dcl 130 in procedure "copy_dir_"
                                                                                  set ref 245* 252 368 413
reverse                                                builtin function         dcl 194 ref 1129 1131 1138
rings                     3            based           fixed bin(3,0)           array level 2 dcl 3-17 set ref 880* 881* 882* 953*
                                                                                  954* 954 955* 964* 965* 966*
root                                   parameter       pointer                  dcl 1127 set ref 1117 1146*
rtrim                                                  builtin function         dcl 194 ref 446 446 446 446 1106 1129 1131 1131 1187
                                                                                  1235 1243 1243
safety_sw                       000145 automatic       bit(1)                   packed unaligned dcl 130 set ref 456* 461* 914* 918*
safety_switch           157(05) 000457 automatic       bit(1)                   level 3 in structure "cpo" packed packed unaligned
                                                                                  dcl 1302 in procedure "copy_dir_" set ref 805*
safety_switch            46(05) 000100 automatic       bit(1)                   level 3 in structure "local_suffix_info" packed
                                                                                  packed unaligned dcl 776 in procedure "file" set
                                                                                  ref 805
same_dir                        000146 automatic       bit(1)                   packed unaligned dcl 130 set ref 281* 283* 491 495*
scomp_count                     000162 automatic       fixed bin(17,0)          dcl 156 set ref 1050* 1065 1068 1079* 1174 1210 1225
scomp_root                      000434 automatic       pointer                  dcl 164 set ref 1050* 1070*
sd_name                         000170 automatic       char(168)                packed unaligned dcl 159 set ref 276* 281 283* 286*
                                                                                  289* 289 296* 296 305* 310* 391* 391 399* 399*
                                                                                  407* 407* 456* 457* 457 467* 468* 468 479* 483*
                                                                                  484* 484 491* 494* 495* 495 516* 517* 517 948*
                                                                                  958* 958 968* 974* 974 996* 996 1003* 1003* 1014*
                                                                                  1014* 1042*
se_name                         000366 automatic       char(32)                 packed unaligned dcl 162 set ref 277* 286* 289* 296*
                                                                                  305* 310* 391* 399* 399* 407* 407* 456* 457* 467*
                                                                                  468* 479* 483* 484* 491* 494* 495* 516* 517* 948*
                                                                                  958* 968* 974* 996* 1003* 1003* 1014* 1014* 1042*
seg                       1(01)        based           bit(1)                   level 3 packed packed unaligned dcl 6-14 ref 222 229
                                                                                  237
segment                   0(03) 000637 automatic       bit(1)                   level 2 packed packed unaligned dcl 8-7 set ref 417*
source_contains_target          000143 automatic       bit(1)                   packed unaligned dcl 130 set ref 388* 397 993* 1001
source_dir                             parameter       char                     packed unaligned dcl 114 in procedure "copy_dir_"
                                                                                  ref 33 276
source_dir               12     000457 automatic       char(168)                level 2 in structure "cpo" packed packed unaligned
                                                                                  dcl 1302 in procedure "copy_dir_" set ref 778*
source_ename                           parameter       char                     packed unaligned dcl 114 ref 33 277
source_name              64     000457 automatic       char(32)                 level 2 packed packed unaligned dcl 1302 set ref
                                                                                  779*
sptr                            000240 automatic       pointer                  dcl 546 set ref 556 556 564* 577 578 583 589 621 621
star_ALL_ENTRIES                000102 constant        fixed bin(2,0)           initial dcl 15-111 set ref 432*
star_entry_count                000676 automatic       fixed bin(17,0)          dcl 15-14 set ref 427* 432* 442
star_entry_ptr                  000700 automatic       pointer                  dcl 15-15 set ref 428* 432*
star_names                             based           char(32)                 array packed unaligned dcl 15-37 set ref 443* 446
                                                                                  446
star_names_ptr                  000702 automatic       pointer                  dcl 15-19 set ref 429* 432* 443 446 446
status_code               2     000442 automatic       fixed bin(35,0)          initial level 2 in structure "query_info" dcl 4-7
                                                                                  in procedure "copy_dir_" set ref 373* 378 380*
                                                                                  4-7*
status_code             104            based           fixed bin(35,0)          level 3 in structure "sub_error_info" dcl 11-7
                                                                                  in procedure "copy_dir_" ref 827
status_link                            based           structure                level 1 dcl 5-38
string                                                 builtin function         dcl 194 set ref 415* 443 443 513* 516 516 738* 741
                                                                                  741 783* 787*
sub_err_                        000122 constant        entry                    external dcl 92 ref 213
sub_error_                      000000 stack reference condition                dcl 100 ref 807
sub_error_info                         based           structure                level 1 dcl 11-7
sub_error_info_ptr              000642 automatic       pointer                  dcl 11-6 set ref 819* 821 821 827 829 829 829 829
                                                                                  834
substr                                                 builtin function         dcl 194 ref 594 708 1138 1141 1286 1286
suffix_info                            based           structure                level 1 dcl 1-12
suppress_name_sw          1(01) 000442 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 4-7 set
                                                                                  ref 372* 4-7*
suppress_spacing          1(04) 000442 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 4-7 set
                                                                                  ref 4-7*
switches                  1     000442 automatic       structure                level 2 in structure "query_info" dcl 4-7
                                                                                  in procedure "copy_dir_"
switches                  1            based           structure                level 2 in structure "create_branch_info" packed
                                                                                  packed unaligned dcl 3-17 in procedure "copy_dir_"
target_contains_source          000144 automatic       bit(1)                   packed unaligned dcl 130 set ref 388* 405 993* 1012
target_dir               74     000457 automatic       char(168)                level 2 in structure "cpo" packed packed unaligned
                                                                                  dcl 1302 in procedure "copy_dir_" set ref 780*
target_dir                             parameter       char                     packed unaligned dcl 114 in procedure "copy_dir_"
                                                                                  ref 33 278
target_ename                           parameter       char                     packed unaligned dcl 114 ref 33 279
target_err_switch        12            based           bit(1)                   level 2 dcl 10-8 set ref 829*
target_name             146     000457 automatic       char(32)                 level 2 packed packed unaligned dcl 1302 set ref
                                                                                  781*
tcomp_count                     000163 automatic       fixed bin(17,0)          dcl 156 set ref 1061* 1065 1068 1070*
tcomp_root                      000436 automatic       pointer                  dcl 164 set ref 1061* 1079*
td_name                         000242 automatic       char(168)                packed unaligned dcl 159 set ref 278* 281 283* 319*
                                                                                  323* 323* 331* 331 338* 353* 358* 375* 375 391*
                                                                                  391 399* 399* 407* 407* 425* 461* 462* 462 467*
                                                                                  468* 468 479* 483* 484* 484 491* 494* 495* 495
                                                                                  979* 982* 982 985* 988* 988 996* 996 1003* 1003*
                                                                                  1014* 1014* 1046* 1232* 1232
te_name                         000416 automatic       char(32)                 packed unaligned dcl 162 set ref 279* 319* 323* 323*
                                                                                  331* 338* 353* 358* 375* 391* 399* 399* 407* 407*
                                                                                  425* 461* 462* 467* 468* 479* 483* 484* 491* 494*
                                                                                  495* 979* 982* 985* 988* 996* 1003* 1003* 1014*
                                                                                  1014* 1046* 1232*
temp_target_dir                 000314 automatic       char(168)                packed unaligned dcl 159 set ref 425* 432* 436* 443*
                                                                                  446 446
to_dir                          000153 automatic       char(168)                packed unaligned dcl 533 in procedure "work" set ref
                                                                                  551* 585* 607* 713* 733* 741* 753* 753 759* 762*
                                                                                  762 845* 859* 895* 898* 898 907* 908* 908 918*
                                                                                  919* 919 925* 926* 926 931* 935* 936* 936
to_dir                                 parameter       char                     packed unaligned dcl 772 in procedure "file" set ref
                                                                                  769 780 829* 829*
to_en                                  parameter       char                     packed unaligned dcl 772 set ref 769 781 829* 829*
translate_links                 000132 automatic       bit(1)                   packed unaligned dcl 130 set ref 249* 658
tt                              000107 automatic       fixed bin(2,0)           dcl 117 set ref 598* 690* 708* 713 713 715 722* 800
                                                                                  845* 848* 857 878
type                                   based           bit(2)                   array level 2 in structure "branches" packed packed
                                                                                  unaligned dcl 538 in procedure "work" ref 578 583
                                                                                  589
type                            000110 automatic       fixed bin(2,0)           dcl 117 in procedure "copy_dir_" set ref 286* 294
                                                                                  319* 336 1190* 1203 1208
uid                             000167 automatic       bit(36)                  dcl 158 in procedure "copy_dir_" set ref 310* 314
                                                                                  1070* 1074 1079* 1083
uid                             001243 automatic       bit(36)                  dcl 1254 in procedure "get_uid" set ref 1260* 1264
uid                             000570 automatic       bit(36)                  dcl 1168 in procedure "contains_target" set ref
                                                                                  1216* 1225
update                   46(09) 000100 automatic       bit(1)                   level 3 in structure "local_suffix_info" packed
                                                                                  packed unaligned dcl 776 in procedure "file" set
                                                                                  ref 785
update                          000133 automatic       bit(1)                   packed unaligned dcl 130 in procedure "copy_dir_"
                                                                                  set ref 246* 252 740
update                    2(04)        based           bit(1)                   level 3 in structure "copy_dir_options" packed
                                                                                  packed unaligned dcl 6-14 in procedure "copy_dir_"
                                                                                  ref 246
userid                    6            based           char(32)                 level 2 in structure "create_branch_info" dcl 3-17
                                                                                  in procedure "copy_dir_" set ref 273*
userid                          000406 automatic       char(32)                 packed unaligned dcl 162 in procedure "copy_dir_"
                                                                                  set ref 219* 273
version                         000442 automatic       fixed bin(17,0)          level 2 in structure "query_info" dcl 4-7
                                                                                  in procedure "copy_dir_" set ref 370*
version                         000100 automatic       char(8)                  level 2 in structure "local_suffix_info" dcl 776
                                                                                  in procedure "file" set ref 791*
version                         000457 automatic       char(8)                  level 2 in structure "cpo" dcl 1302 in procedure
                                                                                  "copy_dir_" set ref 474*
version                                based           fixed bin(17,0)          level 2 in structure "create_branch_info" dcl 3-17
                                                                                  in procedure "copy_dir_" set ref 264*
version                                based           fixed bin(17,0)          level 2 in structure "copy_dir_options" dcl 6-14
                                                                                  in procedure "copy_dir_" set ref 211 213*
version                   2     000644 automatic       fixed bin(17,0)          level 2 in structure "ci" dcl 1309 in procedure
                                                                                  "copy_dir_" set ref 817*
whoami                                 parameter       char                     packed unaligned dcl 116 set ref 33 323* 338* 375*
                                                                                  443* 491* 494* 505* 516* 741* 759* 859* 907* 1286*
                                                                                  1288*
yes_or_no_sw              1     000442 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 4-7 set
                                                                                  ref 371* 4-7*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 14-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 14-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 14-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 14-7
FS_OBJECT_TYPE_DM_FILE                 internal static char(32)                 initial packed unaligned dcl 1-50
FS_OBJECT_TYPE_LINK                    internal static char(32)                 initial packed unaligned dcl 1-50
FS_OBJECT_TYPE_MSF                     internal static char(32)                 initial packed unaligned dcl 1-50
FS_OBJECT_TYPE_SEGMENT                 internal static char(32)                 initial packed unaligned dcl 1-50
SWITCH_LIST_VERSION_1                  internal static char(8)                  initial packed unaligned dcl 1-48
Segment                                internal static fixed bin(17,0)          initial dcl 5-56
alloc_switch_count                     automatic       fixed bin(17,0)          dcl 1-33
alloc_switch_name_count                automatic       fixed bin(17,0)          dcl 1-33
condition_info_header_ptr              automatic       pointer                  dcl 12-4
condition_info_ptr                     automatic       pointer                  dcl 13-10
copy_options_ptr                       automatic       pointer                  dcl 7-10
query_info_version_3                   internal static fixed bin(17,0)          initial dcl 4-33
query_info_version_4                   internal static fixed bin(17,0)          initial dcl 4-34
query_info_version_5                   internal static fixed bin(17,0)          initial dcl 4-35
query_info_version_6                   internal static fixed bin(17,0)          initial dcl 4-36
star_ALL_ENTRIES_WITH_LINK_PATHS       internal static fixed bin(3,0)           initial dcl 15-114
star_BRANCHES_ONLY                     internal static fixed bin(2,0)           initial dcl 15-110
star_DIRECTORY                         internal static fixed bin(2,0)           initial unsigned dcl 15-121
star_LINK                              internal static fixed bin(2,0)           initial unsigned dcl 15-119
star_LINKS_ONLY                        internal static fixed bin(2,0)           initial dcl 15-109
star_LINKS_ONLY_WITH_LINK_PATHS        internal static fixed bin(3,0)           initial dcl 15-112
star_SEGMENT                           internal static fixed bin(2,0)           initial unsigned dcl 15-120
star_branch_count                      automatic       fixed bin(17,0)          dcl 15-13
star_dir_list_branch                   based           structure                array level 1 dcl 15-59
star_entries                           based           structure                array level 1 dcl 15-27
star_link_count                        automatic       fixed bin(17,0)          dcl 15-17
star_link_pathname                     based           char                     packed unaligned dcl 15-102
star_links                             based           structure                array level 1 dcl 15-76
star_linkx                             automatic       fixed bin(17,0)          dcl 15-18
star_list_branch                       based           structure                array level 1 dcl 15-41
star_list_branch_ptr                   automatic       pointer                  dcl 15-16
star_list_names                        based           char(32)                 array packed unaligned dcl 15-92
star_list_names_ptr                    automatic       pointer                  dcl 15-20
star_select_sw                         automatic       fixed bin(3,0)           dcl 15-21
status_area_ptr                        automatic       pointer                  dcl 5-47
status_branch                          based           structure                level 1 dcl 5-8
status_entry_names                     based           char(32)                 array dcl 5-47
status_pathname                        based           char                     dcl 5-47
status_ptr                             automatic       pointer                  dcl 5-47
sub_error_info_version_1               internal static fixed bin(17,0)          initial dcl 11-13
suffix_info_ptr                        automatic       pointer                  dcl 1-10
sum                                                    builtin function         dcl 194
switch_list                            based           structure                level 1 dcl 1-37
switch_list_ptr                        automatic       pointer                  dcl 1-33

NAMES DECLARED BY EXPLICIT CONTEXT.
BAD_STAT                        002425 constant        label                    dcl 289 ref 311
BAD_TSTAT                       002736 constant        label                    dcl 331 ref 359
FILE                            005547 constant        label                    dcl 585 ref 594
NOT_A_DIR                       002473 constant        label                    dcl 296 ref 306
PUNT_FILE                       010051 constant        label                    dcl 811 ref 834
T_NOT_DIR                       003005 constant        label                    dcl 338 ref 354
append_link                     007203 constant        label                    dcl 733 ref 680 694 715 742
check_dir_level                 013734 constant        label                    dcl 1216 ref 1201
complain                        014314 constant        entry                    internal dcl 1268 ref 225 254 289 296 331 364 380
                                                                                  391 399 407 436 446 457 462 468 484 495 517 570
                                                                                  601 616 639 654 666 685 699 727 753 762 796 829
                                                                                  852 872 886 898 908 915 919 926 936 958 974 982
                                                                                  988 996 1003 1014
contains                        012554 constant        entry                    internal dcl 1027 ref 388 993
contains_target                 013460 constant        entry                    internal dcl 1150 ref 660
copy_dir_                       001616 constant        entry                    external dcl 33
create_directory                011662 constant        entry                    internal dcl 944 ref 326 346
csub                            013057 constant        entry                    internal dcl 1088 ref 1070 1079
directory                       010304 constant        entry                    internal dcl 842 ref 611
file                            007553 constant        entry                    internal dcl 769 ref 585 607 713
finish                          005161 constant        label                    dcl 520 ref 327 347 383 1171
finish_work                     006072 constant        label                    dcl 621 ref 565
get_uid                         014212 constant        entry                    internal dcl 1248 ref 283 283
link                            006107 constant        entry                    internal dcl 629 ref 580
next_comp                       014130 constant        label                    dcl 1241
path_info                       013216 constant        entry                    internal dcl 1117 ref 1050 1061 1170
sub_err_handler                 010052 constant        entry                    internal dcl 814 ref 807
work                            005171 constant        entry                    internal dcl 530 ref 479 931

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     15414       15574   14555       15424
Length     16454   14555       160         644     636           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
copy_dir_                          1160 external procedure  is an external procedure.  
on unit on line 205                  64 on unit               
work                                787 internal procedure  enables or reverts conditions.  
on unit on line 554                  64 on unit               
link                                    internal procedure  shares stack frame of internal procedure work.  
file                                250 internal procedure  enables or reverts conditions.  
on unit on line 807                 244 on unit               
sub_err_handler                         internal procedure  shares stack frame of on unit on line 807.  
directory                               internal procedure  shares stack frame of internal procedure work.  
create_directory                        internal procedure  shares stack frame of external procedure copy_dir_.  
contains                                internal procedure  shares stack frame of external procedure copy_dir_.  
csub                                    internal procedure  shares stack frame of external procedure copy_dir_.  
path_info                           113 internal procedure  is called by several nonquick procedures.  
contains_target                         internal procedure  shares stack frame of internal procedure work.  
get_uid                                 internal procedure  shares stack frame of external procedure copy_dir_.  
complain                            246 internal procedure  is called during a stack extension, and is declared options(variable).  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
complain                 000100 argp                        complain
                         000102 argl                        complain
                         000103 nargs                       complain
                         000104 arg_list_ptr                complain
                         000106 error_message               complain
                         000306 error_message_length        complain
copy_dir_                000106 parent_access               copy_dir_
                         000107 tt                          copy_dir_
                         000110 type                        copy_dir_
                         000111 ln                          copy_dir_
                         000112 code                        copy_dir_
                         000113 code1                       copy_dir_
                         000114 bc                          copy_dir_
                         000116 answer                      copy_dir_
                         000120 dir_rings                   copy_dir_
                         000122 acl                         copy_dir_
                         000123 all_entries                 copy_dir_
                         000124 all_names                   copy_dir_
                         000125 brief                       copy_dir_
                         000126 chase                       copy_dir_
                         000127 force                       copy_dir_
                         000130 raw                         copy_dir_
                         000131 replace                     copy_dir_
                         000132 translate_links             copy_dir_
                         000133 update                      copy_dir_
                         000134 clink                       copy_dir_
                         000135 cseg                        copy_dir_
                         000136 cmsf                        copy_dir_
                         000137 cnnl                        copy_dir_
                         000140 cdir                        copy_dir_
                         000141 errors                      copy_dir_
                         000142 ersw                        copy_dir_
                         000143 source_contains_target      copy_dir_
                         000144 target_contains_source      copy_dir_
                         000145 safety_sw                   copy_dir_
                         000146 same_dir                    copy_dir_
                         000147 move                        copy_dir_
                         000150 fs_util_type                copy_dir_
                         000160 entry_index                 copy_dir_
                         000161 lcomp_count                 copy_dir_
                         000162 scomp_count                 copy_dir_
                         000163 tcomp_count                 copy_dir_
                         000164 ii                          copy_dir_
                         000165 dir1_uid                    copy_dir_
                         000166 dir2_uid                    copy_dir_
                         000167 uid                         copy_dir_
                         000170 sd_name                     copy_dir_
                         000242 td_name                     copy_dir_
                         000314 temp_target_dir             copy_dir_
                         000366 se_name                     copy_dir_
                         000376 le                          copy_dir_
                         000406 userid                      copy_dir_
                         000416 te_name                     copy_dir_
                         000426 area_ptr                    copy_dir_
                         000430 cb_ptr                      copy_dir_
                         000432 lcomp_root                  copy_dir_
                         000434 scomp_root                  copy_dir_
                         000436 tcomp_root                  copy_dir_
                         000440 cptr                        copy_dir_
                         000442 query_info                  copy_dir_
                         000457 cpo                         copy_dir_
                         000637 delete_options              copy_dir_
                         000640 nd_handler_options          copy_dir_
                         000642 sub_error_info_ptr          copy_dir_
                         000644 ci                          copy_dir_
                         000676 star_entry_count            copy_dir_
                         000700 star_entry_ptr              copy_dir_
                         000702 star_names_ptr              copy_dir_
                         000722 dir1                        contains
                         000774 dir2                        contains
                         001046 en1                         contains
                         001056 en2                         contains
                         001074 p                           csub
                         001076 code                        csub
                         001077 dir                         csub
                         001137 en                          csub
                         001147 comp_index                  csub
                         001160 dir                         get_uid
                         001232 entry                       get_uid
                         001242 code                        get_uid
                         001243 uid                         get_uid
file                     000100 local_suffix_info           file
path_info                000100 optr                        path_info
                         000102 dirstr                      path_info
work                     000100 i                           work
                         000101 from_dir                    work
                         000153 to_dir                      work
                         000225 name                        work
                         000236 nptr                        work
                         000240 sptr                        work
                         000242 entry_count                 work
                         000262 pptr                        link
                         000264 links                       link
                         000270 link_target                 link
                         000342 new_target                  link
                         000414 ld                          link
                         000502 i                           contains_target
                         000503 en                          contains_target
                         000513 dir                         contains_target
                         000566 p                           contains_target
                         000570 uid                         contains_target

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out
call_int_this_desc  call_int_other_desc return_mac          tra_ext_1           enable_op           shorten_stack
ext_entry_desc      int_entry           int_entry_desc      reverse_cs          set_chars_eis       op_alloc_
op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      command_query_                continue_to_signal_           copy_
copy_acl_                     copy_iacl_                    copy_names_                   cu_$arg_count
cu_$arg_list_ptr              cu_$arg_ptr                   delete_$path                  expand_pathname_
find_condition_info_          fs_util_$get_type             fs_util_$suffix_info          get_group_id_$tag_star
get_max_authorization_        get_ring_                     get_system_free_area_         hcs_$append_link
hcs_$create_branch_           hcs_$get_access_class         hcs_$get_dir_ring_brackets    hcs_$get_link_target
hcs_$get_safety_sw            hcs_$get_uid_file             hcs_$set_safety_sw            hcs_$star_
hcs_$status_                  hcs_$status_minf              ioa_                          ioa_$general_rs
ioa_$rsnnl                    move_names_                   nd_handler_                   nd_handler_$switches
pathname_                     sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$bad_ring_brackets
error_table_$inconsistent     error_table_$incorrect_access error_table_$namedup          error_table_$no_dir
error_table_$no_s_permission  error_table_$noentry          error_table_$nomatch          error_table_$not_seg_type
error_table_$notadir          error_table_$sameseg          error_table_$segnamedup
error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     33 001610    4    7 001655       202 001705       203 001707       205 001711       207 001725       209 001734
    211 001735       213 001741       216 002007       219 002010       220 002017       221 002026       222 002034
    225 002071       227 002120       229 002121       231 002131       232 002133       233 002140       235 002141
    236 002142       237 002144       238 002146       239 002150       240 002152       242 002154       243 002160
    244 002164       245 002170       246 002174       247 002200       248 002204       249 002210       250 002214
    251 002220       252 002224       254 002230       255 002250       258 002251       260 002256       263 002260
    264 002265       265 002267       266 002270       267 002271       268 002273       269 002275       270 002277
    271 002301       272 002306       273 002310       274 002313       276 002314       277 002322       278 002327
    279 002334       281 002341       283 002350       286 002362       287 002420       289 002425       291 002465
    294 002466       296 002473       300 002534       303 002535       305 002537       306 002563       310 002567
    311 002614       314 002616       319 002620       320 002656       323 002663       326 002732       327 002733
    329 002735       331 002736       334 002776       335 002777       336 003000       338 003005       340 003034
    342 003036       343 003040       346 003041       347 003042       349 003044       351 003045       353 003047
    354 003073       358 003077       359 003124       362 003126       364 003131       366 003151       368 003152
    370 003156       371 003160       372 003162       373 003164       374 003165       375 003166       378 003243
    380 003245       381 003264       383 003265       388 003272       389 003274       391 003276       394 003354
    397 003355       399 003360       402 003447       405 003450       407 003453       410 003542       413 003543
    415 003545       416 003546       417 003552       421 003562       422 003567       423 003571       425 003576
    427 003616       428 003617       429 003621       432 003622       433 003667       435 003671       436 003674
    437 003717       442 003720       443 003727       444 003771       446 003776       448 004077       450 004101
    454 004103       456 004104       457 004131       461 004174       462 004221       467 004263       468 004316
    474 004405       475 004410       479 004413       481 004444       483 004452       484 004505       489 004574
    491 004576       494 004643       495 004704       502 005004       505 005011       508 005041       511 005047
    513 005050       514 005051       515 005055       516 005062       517 005117       520 005161       523 005167
    530 005170       550 005223       551 005274       554 005347       556 005363       558 005372       560 005401
    564 005402       565 005452       570 005460       571 005504       576 005505       577 005515       578 005527
    580 005534       582 005544       583 005545       585 005547       588 005606       589 005607       591 005611
    593 005614       594 005640       598 005651       599 005711       601 005714       603 005755       605 005756
    607 005760       609 006016       611 006017       614 006024       616 006025       617 006067       619 006070
    621 006072       624 006100       627 006106       629 006107       636 006110       637 006150       639 006153
    641 006214       644 006215       645 006222       647 006224       649 006232       651 006236       652 006262
    654 006265       656 006331       658 006332       660 006334       661 006357       663 006366       666 006372
    669 006433       672 006434       674 006443       676 006446       677 006475       680 006505       682 006507
    685 006510       688 006567       690 006570       691 006626       694 006636       696 006640       699 006641
    702 006720       705 006721       707 006723       708 006747       713 006762       715 007037       717 007047
    718 007050       720 007051       722 007053       723 007112       727 007123       730 007202       733 007203
    735 007230       738 007236       739 007237       740 007244       741 007251       742 007305       744 007310
    747 007314       748 007316       749 007320       753 007321       756 007407       759 007410       760 007452
    762 007462       764 007550       767 007551       769 007552       778 007605       779 007615       780 007622
    781 007627       783 007634       784 007635       785 007642       787 007647       788 007650       789 007654
    791 007672       793 007674       794 007723       796 007727       797 010000       800 010001       802 010004
    803 010010       805 010014       807 010020       809 010036       811 010051       814 010052       817 010053
    818 010060       819 010100       821 010110       823 010123       824 010133       827 010134       829 010136
    834 010271       837 010303       842 010304       845 010305       846 010345       848 010350       849 010351
    850 010376       852 010401       854 010442       856 010443       857 010444       859 010447       860 010476
    864 010505       865 010507       866 010511       869 010512       870 010537       872 010542       874 010603
    878 010604       880 010610       881 010613       882 010615       883 010617       884 010644       886 010647
    888 010710       891 010711       892 010714       893 010716       894 010720       895 010722       896 010747
    898 010752       900 011013       905 011014       907 011016       908 011057       914 011155       915 011203
    918 011250       919 011275       925 011341       926 011375       931 011466       933 011521       935 011534
    936 011570       941 011661       944 011662       946 011663       948 011664       949 011711       951 011713
    953 011720       954 011727       955 011732       956 011734       958 011735       960 011775       962 011776
    964 011777       965 012002       966 012004       968 012006       969 012034       971 012036       974 012053
    976 012113       979 012114       980 012141       982 012143       983 012203       985 012204       986 012231
    988 012233       990 012273       993 012274       994 012276       996 012300       998 012356      1001 012357
   1003 012362      1007 012451      1009 012454      1012 012455      1014 012460      1018 012547      1020 012552
   1023 012553      1027 012554      1038 012556      1039 012557      1040 012563      1042 012567      1043 012617
   1046 012623      1047 012652      1050 012656      1051 012706      1054 012712      1056 012722      1057 012725
   1058 012731      1059 012735      1061 012736      1062 012766      1065 012772      1068 012776      1070 012777
   1071 013013      1074 013017      1076 013026      1079 013027      1080 013043      1083 013047      1116 013056
   1088 013057      1099 013061      1100 013064      1101 013067      1103 013070      1105 013077      1106 013107
   1107 013150      1108 013153      1110 013155      1111 013162      1112 013210      1115 013214      1117 013215
   1128 013236      1129 013240      1131 013301      1132 013356      1133 013371      1135 013373      1136 013374
   1137 013400      1138 013407      1139 013426      1140 013431      1141 013432      1142 013440      1143 013442
   1144 013453      1146 013454      1147 013457      1150 013460      1170 013476      1171 013532      1174 013540
   1176 013544      1177 013547      1180 013550      1181 013552      1186 013555      1187 013565      1188 013626
   1189 013631      1190 013635      1191 013676      1196 013706      1197 013710      1200 013711      1201 013713
   1203 013714      1205 013717      1206 013721      1208 013722      1210 013724      1212 013730      1213 013732
   1215 013733      1216 013734      1219 013761      1221 013764      1222 013766      1225 013767      1228 013777
   1229 014001      1232 014002      1233 014047      1234 014052      1235 014056      1236 014121      1237 014124
   1238 014125      1239 014127      1241 014130      1243 014132      1245 014210      1248 014212      1256 014214
   1257 014240      1260 014250      1261 014275      1264 014305      1268 014313      1278 014321      1279 014340
   1281 014343      1282 014355      1284 014360      1285 014367      1286 014434      1287 014467      1288 014471
   1290 014511      1291 014514      1292 014517


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
