	COMPILATION LISTING OF SEGMENT cv_ptr_
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-05-05_1832.63_Fri_mdt
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 
       11 	
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(86-03-12,Ranzenbach), approve(86-03-12,MCR7143),
       15*     audit(86-03-12,GWMay), install(86-05-01,MR12.0-1051):
       16*     modified to support archive component names.
       17*  2) change(86-07-08,Elhard), approve(86-07-08,MCR7391),
       18*     audit(86-07-18,DGHowe), install(86-11-20,MR12.0-1222):
       19*     Modified to call object_lib_$initiate to initiate non-archive pathname
       20*     references, and to call object_lib_$get_def_target to perform definition
       21*     search on segments or MSFs.
       22*                                                   END HISTORY COMMENTS */
       23 
       24 
       25 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       26 	/*									*/
       27 	/* NAME:  cv_ptr_								*/
       28 	/*									*/
       29 	/*      This subroutine converts virtual pointer character strings to pointer values.	*/
       30 	/*									*/
       31 	/* Status:								*/
       32 	/*									*/
       33 	/* 0) Created by  Gary C. Dixon  on October 22, 1976.				*/
       34 	/* 1) Modified by Gary C. Dixon  on October 22, 1979 - support path$entry_pt, cleanup code*/
       35 	/* 2) Modified by Paul W. Benjamin on August 31, 1981 - remove entrypoint name validation */
       36 	/* 3) Modified 841128 by E. A. Ranzenbach for archive pathname support...		*/
       37 	/*									*/
       38 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       39 
       40 
       41 
       42 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       43 
       44 
       45 cv_ptr_:	procedure (string, Acode)
       46 	returns 	(ptr);
       47 
       48      dcl						/*	Parameters			*/
       49      	string			char (*),		/* virtual pointer character string. (In)	*/
       50 	Acode			fixed bin(35),	/* status code. (Out)			*/
       51 	Aptr			ptr;		/* ptr to seg to be terminated. (In)		*/
       52 
       53      dcl						/*	Automatic Variables			*/
       54          (Lbit_offset, Lsegment_id, Lword_offset)
       55 				fixed bin,	/* length of various parts of virtual pointer.	*/
       56          (Pbit_offset, Psegment_id, Pword_offset, Pdelim)
       57 				ptr,		/* pointer to various parts of virtual pointer.	*/
       58 	P			ptr,		/* returned pointer.			*/
       59 	Ptarget			ptr,		/* pointer to target of searched definition	*/
       60 	bc			fixed bin(24),	/* bit count of target segment.		*/
       61          (bit, segno, word)		fixed bin(35),	/* numeric parts of virtual pointer.		*/
       62 	code			fixed bin(35),
       63 	dir			char(168),	/* dir part of segment's pathname.		*/
       64 	ent			char(32),		/* entry part of segment's pathname.		*/
       65 	component			char(32),		/* component name...			*/
       66 	i			fixed bin,
       67 	id_case			fixed bin,	/* type of segment identifier in virtual pointer.	*/
       68 						/*   1 = PATHNAME, 2 = REF_NAME, 3 = SEGNO.	*/
       69 	offset_case		fixed bin;	/* type of offset value in virtual pointer.	*/
       70 						/*   5 = MISSING, 6 = WORD, 7 = WORD_AND_BIT,	*/
       71 						/*   8 = ENTRY_PT.				*/
       72 
       73      dcl						/*	Based Variables			*/
       74      	bit_offset		char(Lbit_offset) based (Pbit_offset),
       75 	bit_offset_array (Lbit_offset) char(1) based(Pbit_offset),
       76      	bits (36)			bit(1) unaligned based,
       77 	delim			char(1) based (Pdelim),
       78 	segment_id		char(Lsegment_id) based (Psegment_id),
       79 	string_array (length(string))	char(1) based (addr (string)),
       80 	word_offset		char(Lword_offset) based (Pword_offset),
       81 	word_offset_array (Lword_offset)
       82 				char(1) based (Pword_offset);
       83  
       84      dcl (addr, baseno, baseptr, length, null, ptr, reverse, rtrim, search, verify)
       85 				builtin;
       86 
       87      dcl						/*	Entries				*/
       88 	cv_dec_check_		entry (char(*), fixed bin(35)) returns (fixed bin(35)),
       89 	cv_oct_check_		entry (char(*), fixed bin(35)) returns (fixed bin(35)),
       90 	expand_pathname_$component	entry (char(*), char(*), char(*), char(*), fixed bin(35)),
       91 	initiate_file_$component	entry (char(*), char(*), char(*), bit(*), ptr, fixed bin(24), fixed bin(35)),
       92 	hcs_$fs_get_path_name	entry (ptr, char(*), fixed bin, char(*), fixed bin(35)),
       93 	hcs_$fs_get_seg_ptr		entry (char(*), ptr, fixed bin(35)),
       94 	object_lib_$initiate	entry (char(*), char(*), char(*), bit(1), ptr, fixed bin(24), bit(1), fixed bin(35)),
       95 	object_lib_$get_def_target	entry (ptr, fixed bin(24), char(*), char(*), bit(1), ptr, fixed bin(35)),
       96 	terminate_file_		entry (ptr, fixed bin(24), bit(*), fixed bin(35));
       97 
       98      dcl						/*	Static Variables and Constants	*/
       99          (PATHNAME			init(1),		/* acceptable values which id_case may take on.	*/
      100 	REF_NAME			init(2),
      101 	SEGNO			init(3),
      102 	MISSING			init(5),		/* acceptable values offset_case may take on.	*/
      103 	WORD			init(6),
      104 	WORD_AND_BIT		init(7),
      105 	ENTRY_PT			init(8)) fixed bin int static options(constant),
      106 	V_BAR			char(1) int static options(constant) init("|"),
      107          (error_table_$bad_conversion,
      108 	error_table_$bigarg,
      109 	error_table_$entlong,
      110           error_table_$improper_data_format,
      111 	error_table_$out_of_bounds)	fixed bin(35) ext static,
      112 	sys_info$max_seg_size	fixed bin(35) ext static;
      113 
      114 
  1     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      115 
      116 
  2     1 /* BEGIN INCLUDE FILE definition.incl.pl1 */
  2     2 
  2     3 
  2     4 
  2     5 /****^  HISTORY COMMENTS:
  2     6*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  2     7*     audit(86-07-18,DGHowe), install(86-11-20,MR12.0-1222):
  2     8*     Modified to add indirect bit to definition flags.
  2     9*                                                   END HISTORY COMMENTS */
  2    10 
  2    11 
  2    12 dcl	1 definition	aligned based,
  2    13 	2 forward		unal bit(18),	/* offset of next def */
  2    14 	2 backward	unal bit(18),	/* offset of previous def */
  2    15 	2 value		unal bit(18),
  2    16 	2 flags		unal,
  2    17 	  3 new		bit(1),
  2    18 	  3 ignore	bit(1),
  2    19 	  3 entry		bit(1),
  2    20 	  3 retain	bit(1),
  2    21 	  3 argcount	bit(1),
  2    22 	  3 descriptors	bit(1),
  2    23 	  3 indirect	bit(1),
  2    24 	  3 unused	bit(8),
  2    25 	2 class		unal bit(3),
  2    26 	2 symbol		unal bit(18),	/* offset of ACC for symbol */
  2    27 	2 segname		unal bit(18);	/* offset of segname def */
  2    28 
  2    29 /* END INCLUDE FILE definition.incl.pl1 */
      117 
      118 
  3     1 /* BEGIN INCLUDE FILE ... object_info.incl.pl1
  3     2*coded February 8, 1972 by Michael J. Spier	*/
  3     3 /* modified May 26, 1972 by M. Weaver */
  3     4 /* modified 15 April, 1975 by M. Weaver */
  3     5 
  3     6 declare	1 object_info aligned based,		/* structure containing object info based, returned by object_info_ */
  3     7 	2 version_number fixed bin,		/* version number of current structure format (=2) */
  3     8 	2 textp pointer,			/* pointer to beginning of text section */
  3     9 	2 defp pointer,			/* pointer to beginning of definition section */
  3    10 	2 linkp pointer,			/* pointer to beginning of linkage section */
  3    11 	2 statp pointer,			/* pointer to beginning of static section */
  3    12 	2 symbp pointer,			/* pointer to beginning of symbol section */
  3    13 	2 bmapp pointer,			/* pointer to beginning of break map (may be null) */
  3    14 	2 tlng fixed bin,			/* length in words of text section */
  3    15 	2 dlng fixed bin,			/* length in words of definition section */
  3    16 	2 llng fixed bin,			/* length in words of linkage section */
  3    17 	2 ilng fixed bin,			/* length in words of static section */
  3    18 	2 slng fixed bin,			/* length in words of symbol section */
  3    19 	2 blng fixed bin,			/* length in words of break map */
  3    20 	2 format,				/* word containing bit flags about object type */
  3    21 	  3 old_format bit(1) unaligned,	/* on if segment isn't in new format, i.e. has old style object map */
  3    22 	  3 bound bit(1) unaligned,		/* on if segment is bound */
  3    23 	  3 relocatable bit(1) unaligned,	/* on if seg has relocation info in its first symbol block */
  3    24 	  3 procedure bit(1) unaligned,	/* on if segment is an executable object program */
  3    25 	  3 standard bit(1) unaligned,	/* on if seg is in standard format (more than just standard map) */
  3    26 	  3 gate bit(1) unaligned,		/* on if segment is a gate */
  3    27 	  3 separate_static bit(1) unaligned,	/* on if static not in linkage */
  3    28 	  3 links_in_text bit(1) unaligned,	/* on if there are threaded links in text */
  3    29 	  3 perprocess_static bit (1) unaligned, /* on if static is not to be per run unit */
  3    30 	  3 pad bit(27) unaligned,
  3    31 	2 entry_bound fixed bin,		/* entry bound if segment is a gate */
  3    32 	2 textlinkp pointer,		/* ptr to first link in text */
  3    33 
  3    34 	/* LIMIT OF BRIEF STRUCTURE */
  3    35 
  3    36 	2 compiler char(8) aligned,		/* name of processor which generated segment */
  3    37 	2 compile_time fixed bin(71),		/* clock reading of date/time object was generated */
  3    38 	2 userid char(32) aligned,		/* standard Multics id of creator of object segment */
  3    39 	2 cvers aligned,			/* generator version name in printable char string form */
  3    40 	  3 offset bit(18) unaligned,		/* offset of name in words relative to base of symbol section */
  3    41 	  3 length bit(18) unaligned,		/* length of name in characters */
  3    42 	2 comment aligned,			/* printable comment concerning generator or generation of segment */
  3    43 	  3 offset bit(18) unaligned,		/* offset of comment in words relative to base of symbol section */
  3    44 	  3 length bit(18) unaligned,		/* length of comment in characters */
  3    45 	2 source_map fixed bin,		/* offset, relative to base of symbol section, of source map structure */
  3    46 
  3    47 	/* LIMIT OF DISPLAY STRUCTURE */
  3    48 
  3    49 	2 rel_text pointer,			/* pointer to text section relocation info */
  3    50 	2 rel_def pointer,			/* pointer to definition section relocation info */
  3    51 	2 rel_link pointer,			/* pointer to linkage section relocation info */
  3    52 	2 rel_static pointer,		/* pointer to static section relocation info */
  3    53 	2 rel_symbol pointer,		/* pointer to symbol section relocation info */
  3    54 	2 text_boundary fixed bin,		/* specifies mod  of text section base boundary */
  3    55 	2 static_boundary fixed bin,		/* specifies mod of internal static base boundary */
  3    56 					/* currently not used by system */
  3    57 	2 default_truncate fixed bin,		/* offset rel to symbp for binder to automatically trunc. symb sect. */
  3    58 	2 optional_truncate fixed bin;	/* offset rel to symbp for binder to optionally trunc. symb sect. */
  3    59 
  3    60 declare	object_info_version_2 fixed bin int static init(2);
  3    61 
  3    62 /* END INCLUDE FILE ... object_info.incl.pl1 */
      119 
      120 
  4     1 /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
  4     2 /* format: style2,^inddcls,idind32 */
  4     3 
  4     4 declare 1 terminate_file_switches	based,
  4     5 	2 truncate		bit (1) unaligned,
  4     6 	2 set_bc			bit (1) unaligned,
  4     7 	2 terminate		bit (1) unaligned,
  4     8 	2 force_write		bit (1) unaligned,
  4     9 	2 delete			bit (1) unaligned;
  4    10 
  4    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
  4    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
  4    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
  4    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
  4    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
  4    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
  4    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
  4    18 
  4    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
      121 
      122 
      123 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      124 
      125 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      126 	/*									*/
      127 	/* Acceptable virtual pointer strings have the following forms:			*/
      128 	/*									*/
      129 	/* CASES									*/
      130 	/*  I O	FORM			COMMENT					*/
      131 	/* -----	-----------------------	------------------------------------------	*/
      132 	/*  1 5	path			= path|0(0)				*/
      133 	/*  1 5	path|			= path|0(0)				*/
      134 	/*  1 6	path|W			= path|W(0)				*/
      135 	/*  1 7	path|W(B)			octal word W, decimal bit B of path		*/
      136 	/*  1 8	path|entry_pt		word identified by entry point entry_pt in path	*/
      137 	/*  1 8	path$entry_pt		word identified by entry point entry_pt in seg	*/
      138 	/*				with pathname pat				*/
      139 	/*									*/
      140 	/*  2 5	ref_name$			= ref_name$0(0)				*/
      141 	/*  2 6	ref_name$W		= ref_name$W(0)				*/
      142 	/*  2 7	ref_name$W(B)		octal word W, decimal bit B of seg with reference	*/
      143 	/*				name ref_name.				*/
      144 	/*  2 8	ref_name$entry_pt		word identified by entry point entry_pt in seg	*/
      145 	/*				with reference name ref_name			*/
      146 	/*									*/
      147 	/*  3 5	segno			= segno|0(0)				*/
      148 	/*  3 5	segno|			= segno|0(0)				*/
      149 	/*  3 6	segno|W			= segno|W(0)				*/
      150 	/*  3 7	segno|W(B)		octal word W, decimal bit B of seg known by segno	*/
      151 	/*  3 8	segno|entry_pt		word identified by entry point entry_pt in seg	*/
      152 	/*				known by segno				*/
      153 	/*									*/
      154 	/* CASES:  I = segment identifier case (id_case), O = offset value case (offset_case).	*/
      155 	/*	 I = 1 => PATHNAME			O = 5 => MISSING (no offset given)	*/
      156 	/*	   = 2 => REF_NAME			  = 6 => WORD			*/
      157 	/*	   = 3 => SEGNO			  = 7 => WORD_AND_BIT		*/
      158 	/*					  = 8 => ENTRY_PT			*/
      159 	/*									*/
      160 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      161 
      162 	Acode = 0;				/* initialize return code.			*/
      163 	code = error_table_$improper_data_format;	/* initialize format error code.		*/
      164 	id_case = PATHNAME;				/* start by assuming we have a path segment	*/
      165 	offset_case = MISSING;			/*   identifier, and no offset value.		*/
      166 	component = "";
      167 
      168 	Psegment_id = addr(string);			/* Split identifier into seg_id, delim, & offset. */
      169 	i = search (reverse(string), "|$");		/* Look for the delimiter.			*/
      170 	if i > 0 then i = length(string) - (i-1);
      171 	if i = 0 then do;				/* CASE: No delimiter.			*/
      172 	     Pdelim = addr(V_BAR);			/*   Assume |.				*/
      173 	     Lsegment_id = length(rtrim(string));	/*   Address seg_id.			*/
      174 	     Pword_offset = addr(Pword_offset);		/*   Indicate no word offset.			*/
      175 	     Lword_offset = 0;
      176 	     end;
      177 	else do;					/* CASE: Delimiter found.			*/
      178 	     Pdelim = addr(string_array(i));		/*   Remember delimiter.			*/
      179 	     Lsegment_id = i-1;			/*   Address seg_id.			*/
      180 	     Lsegment_id = length(rtrim(segment_id));
      181 	     if i < length(string) then do;		/*   Look for word offset.			*/
      182 		Pword_offset = addr(string_array(i+1)); /*     Remember where word offset is.		*/
      183 		Lword_offset = length(string) - i;
      184 		Lword_offset = length(rtrim(word_offset));
      185 		i = verify(word_offset, " ");
      186 		if i > 1 then do;
      187 		     Pword_offset = addr(word_offset_array(i));
      188 		     Lword_offset = Lword_offset - (i-1);
      189 		     end;
      190 		end;
      191 	     else do;				/*   No word offset.			*/
      192 		Pword_offset = addr(Pword_offset);
      193 		Lword_offset = 0;
      194 		end;
      195 	     end;
      196 
      197 	if verify (segment_id, "01234567") = 0 then	/* check for segno identifier.		*/
      198 	     id_case = SEGNO;
      199 	else if segment_id = "-1" then		/*     this includes null pointer segno.	*/
      200 	     id_case = SEGNO;
      201 
      202 	if  (delim = "$") & (search (segment_id, "><") > 0)  then do;
      203 	     if id_case ^= PATHNAME then go to ERROR;	/* CASE: seg_id is a pathname.		*/
      204 	     if length(segment_id) > 168 then do;
      205 		code = error_table_$bigarg;
      206 		go to ERROR;
      207 		end;
      208 	     end;
      209 	else if delim = "$" then do;			/* CASE: seg_id is a ref_name.		*/
      210 	     id_case = REF_NAME;
      211 	     if length(segment_id) > 32 then do;
      212 		code = error_table_$entlong;
      213 		go to ERROR;
      214 		end;
      215 	     end;
      216 	else if delim = "|" then;			/* CASE: seg_id is path or segno.		*/
      217 	else go to ERROR;				/* CASE: seg_id followed by bad delim.  We should	*/
      218 						/*   never get to this line.			*/
      219 
      220 	if length(word_offset) > 0 then do;		/* Evaluate word offset.			*/
      221 	     offset_case = WORD;			/*   Start by assuming word offset.		*/
      222 	     i = verify (word_offset, "01234567");	/*   Check for octal word offset.		*/
      223 	     if i = 0 then;				/*   CASE: only word offset given.		*/
      224 	     else if (word_offset_array(i) = "(")  then do;
      225 		code = error_table_$bad_conversion;
      226 		offset_case = WORD_AND_BIT;
      227 		if word_offset_array(Lword_offset) ^= ")" then
      228 		     go to ERROR;
      229 		Pbit_offset = addr(word_offset_array(i+1));
      230 		Lbit_offset = Lword_offset - i - 1;	/*     Overlay the bit offset.		*/
      231 		Lbit_offset = length(rtrim(bit_offset));
      232 		Lword_offset = i - 1;		/*     Exclude bit from word offset.	*/
      233 		Lword_offset = length(rtrim(word_offset));
      234 		i = verify(bit_offset, " ");
      235 		if i > 1 then do;
      236 		     Pbit_offset = addr(bit_offset_array(i));
      237 		     Lbit_offset = Lbit_offset - (i-1);
      238 		     end;
      239 		if verify (bit_offset, "0123456789") ^= 0 then do;
      240 		     code = error_table_$bad_conversion;
      241 		     go to ERROR;
      242 		end;
      243 	     end;
      244 	     else do;			/*   CASE: no word offset, just entry_pt.	*/
      245 		offset_case = ENTRY_PT;
      246 		if length(word_offset) > 256 then do;	/*     Validate entry point length.		*/
      247 		     code = error_table_$entlong;
      248 		     go to ERROR;
      249 		     end;
      250 		end;
      251 	     end;
      252 	if  (delim = "$") & (id_case = PATHNAME) & (offset_case ^= ENTRY_PT) then do;
      253 	     code = error_table_$improper_data_format;
      254 	     go to ERROR;
      255 	     end;
      256 
      257 	if id_case = PATHNAME then do;		/* id_case = PATHNAME			*/
      258 	     call expand_pathname_$component (segment_id, dir, ent, component, code);
      259 	     if code ^= 0 then go to ERROR;		/*     Expand the pathname given in virtual ptr.	*/
      260 	     end;
      261 
      262 	else do;
      263 	     if id_case = REF_NAME then do;		/* id_case = REF_NAME.			*/
      264 		call hcs_$fs_get_seg_ptr (segment_id, P, code);
      265 		if code ^= 0 then go to ERROR;	/*     Convert reference name to a pointer.	*/
      266 		end;
      267 	     else do;				/* id_case = SEGNO				*/
      268 		segno = cv_oct_check_ (segment_id, code);
      269 		if code ^= 0 then do;
      270 		     code = error_table_$bad_conversion;
      271 		     go to ERROR;
      272 		     end;
      273 		P = baseptr (segno);		/*     Convert segment number to a pointer.	*/
      274 		if (segment_id = "-1") | (segment_id = "77777") | (segment_id = "777777") then do;
      275 						/*     Special case null pointers.		*/
      276 		     if offset_case = MISSING then return (null);
      277 		     if offset_case = ENTRY_PT then do;
      278 			code = error_table_$improper_data_format;
      279 			go to ERROR;
      280 			end;
      281 		     go to OFFSET;
      282 		     end;
      283 		end;
      284 
      285 	     call hcs_$fs_get_path_name (P, dir, 0, ent, code);
      286 	     if code ^= 0 then go to ERROR;		/*     Convert pointer to a pathname.		*/
      287 	     end;
      288 
      289 	if component = "" then call object_lib_$initiate (dir, ent, "", ""b, P, bc, (""b), code);
      290 	else call initiate_file_$component (dir, ent, component, R_ACCESS, P, bc, code);
      291 	if P = null then go to ERROR;			/* Initiate segment identified by pathname	*/
      292 	else code = 0;
      293 						/*   with a null reference name.		*/
      294 
      295 OFFSET:	if offset_case = MISSING then;		/* No offset was given.			*/
      296 	else if offset_case = ENTRY_PT then do;		/* An entry point was given.			*/
      297 	     if id_case = REF_NAME then
      298 	          call object_lib_$get_def_target (P, bc, segment_id, word_offset, ""b, Ptarget, code);
      299 	     else if component = "" then
      300 		call object_lib_$get_def_target (P, bc, ent, word_offset, ""b, Ptarget, code);
      301 	     else call object_lib_$get_def_target (P, bc, component, word_offset, ""b, Ptarget, code);
      302 
      303 	     if code ^= 0 then goto ERROR;
      304 	     P = Ptarget;
      305 	end;
      306 	else do;					/* A word, or word and bit offset was given.	*/
      307 	     word = cv_oct_check_ (word_offset, code);	/*     Convert/validate word offset.		*/
      308 	     if code ^= 0 then do;
      309 		code = error_table_$bad_conversion;
      310 		go to ERROR;
      311 		end;
      312 	     if (0 <= word) & (word <= sys_info$max_seg_size) then;
      313 	     else do;
      314 		code = error_table_$out_of_bounds;
      315 		go to ERROR;
      316 		end;
      317 	     P = ptr (P, word);			/*     Apply word offset to pointer.		*/
      318 	     if offset_case = WORD_AND_BIT then do;	/*     A bit offset was also given.		*/
      319 		bit = cv_dec_check_ (bit_offset, code);	/*	 Convert/validate bit offset.		*/
      320 		if code ^= 0 then do;
      321 		     code = error_table_$bad_conversion;
      322 		     go to ERROR;
      323 		     end;
      324 		if (0 <= bit) & (bit <= 35) then;
      325 		else do;
      326 		     code = error_table_$out_of_bounds;
      327 		     go to ERROR;
      328 		     end;
      329 		P = addr (P -> bits (bit+1));		/*     Apply the bit offset.			*/
      330 		end;
      331 	     end;
      332 
      333 	return (P);				/* return the pointer.			*/
      334 
      335 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      336 
      337 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      338 
      339 
      340 ERROR:	Acode = code;
      341 	return (null);				/* return a null pointer, with the error code.	*/
      342 
      343 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      344 
      345 
      346 terminate:	entry (Aptr);			/* Entry to terminate segs initiated by cv_ptr_.	*/
      347 
      348 	if baseno(Aptr) = baseno(null) then return;	/* Do nothing about terminating null pointers.	*/
      349 	call terminate_file_ (Aptr, 0, TERM_FILE_TERM, code);
      350 
      351 	end cv_ptr_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/05/00  1832.6  cv_ptr_.pl1                       >udd>sm>ds>w>ml>cv_ptr_.pl1
115          1    04/11/85  1552.6  access_mode_values.incl.pl1       >ldd>incl>access_mode_values.incl.pl1
117          2    11/24/86  1326.9  definition.incl.pl1               >ldd>incl>definition.incl.pl1
119          3    08/05/77  1122.5  object_info.incl.pl1              >ldd>incl>object_info.incl.pl1
121          4    04/06/83  1339.4  terminate_file.incl.pl1           >ldd>incl>terminate_file.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Acode                                  parameter       fixed bin(35,0)          dcl 48 set ref 45 162* 340*
Aptr                                   parameter       pointer                  dcl 48 set ref 346 348 349*
ENTRY_PT                               constant        fixed bin(17,0)          initial dcl 98 ref 245 252 277 296
Lbit_offset                     000100 automatic       fixed bin(17,0)          dcl 53 set ref 230* 231* 231 234 237* 237 239 319
                                                                                  319
Lsegment_id                     000101 automatic       fixed bin(17,0)          dcl 53 set ref 173* 179* 180* 180 197 199 202 204
                                                                                  211 258 258 264 264 268 268 274 274 274 297 297
Lword_offset                    000102 automatic       fixed bin(17,0)          dcl 53 set ref 175* 183* 184* 184 185 188* 188 193*
                                                                                  220 222 227 230 232* 233* 233 246 297 297 299 299
                                                                                  301 301 307 307
MISSING                                constant        fixed bin(17,0)          initial dcl 98 ref 165 276 295
P                               000114 automatic       pointer                  dcl 53 set ref 264* 273* 285* 289* 290* 291 297*
                                                                                  299* 301* 304* 317* 317 329* 329 333
PATHNAME                               constant        fixed bin(17,0)          initial dcl 98 ref 164 203 252 257
Pbit_offset                     000104 automatic       pointer                  dcl 53 set ref 229* 231 234 236* 236 239 319
Pdelim                          000112 automatic       pointer                  dcl 53 set ref 172* 178* 202 209 216 252
Psegment_id                     000106 automatic       pointer                  dcl 53 set ref 168* 180 197 199 202 204 211 258 264
                                                                                  268 274 274 274 297
Ptarget                         000116 automatic       pointer                  dcl 53 set ref 297* 299* 301* 304
Pword_offset                    000110 automatic       pointer                  dcl 53 set ref 174* 174 182* 184 185 187* 187 192*
                                                                                  192 220 222 224 227 229 233 246 297 299 301 307
REF_NAME                               constant        fixed bin(17,0)          initial dcl 98 ref 210 263 297
R_ACCESS                        000001 constant        bit(3)                   initial packed unaligned dcl 1-11 set ref 290*
SEGNO                                  constant        fixed bin(17,0)          initial dcl 98 ref 197 199
TERM_FILE_TERM                  000000 constant        bit(3)                   initial packed unaligned dcl 4-14 set ref 349*
V_BAR                           000012 constant        char(1)                  initial packed unaligned dcl 98 set ref 172
WORD                                   constant        fixed bin(17,0)          initial dcl 98 ref 221
WORD_AND_BIT                           constant        fixed bin(17,0)          initial dcl 98 ref 226 318
addr                                                   builtin function         dcl 84 ref 168 172 174 178 178 182 182 187 192 229
                                                                                  236 329
baseno                                                 builtin function         dcl 84 ref 348 348
baseptr                                                builtin function         dcl 84 ref 273
bc                              000120 automatic       fixed bin(24,0)          dcl 53 set ref 289* 290* 297* 299* 301*
bit                             000121 automatic       fixed bin(35,0)          dcl 53 set ref 319* 324 324 329
bit_offset                             based           char                     packed unaligned dcl 73 set ref 231 234 239 319*
bit_offset_array                       based           char(1)                  array packed unaligned dcl 73 set ref 236
bits                                   based           bit(1)                   array packed unaligned dcl 73 set ref 329
code                            000124 automatic       fixed bin(35,0)          dcl 53 set ref 163* 205* 212* 225* 240* 247* 253*
                                                                                  258* 259 264* 265 268* 269 270* 278* 285* 286 289*
                                                                                  290* 292* 297* 299* 301* 303 307* 308 309* 314*
                                                                                  319* 320 321* 326* 340 349*
component                       000207 automatic       char(32)                 packed unaligned dcl 53 set ref 166* 258* 289 290*
                                                                                  299 301*
cv_dec_check_                   000010 constant        entry                    external dcl 87 ref 319
cv_oct_check_                   000012 constant        entry                    external dcl 87 ref 268 307
delim                                  based           char(1)                  packed unaligned dcl 73 ref 202 209 216 252
dir                             000125 automatic       char(168)                packed unaligned dcl 53 set ref 258* 285* 289* 290*
ent                             000177 automatic       char(32)                 packed unaligned dcl 53 set ref 258* 285* 289* 290*
                                                                                  299*
error_table_$bad_conversion     000032 external static fixed bin(35,0)          dcl 98 ref 225 240 270 309 321
error_table_$bigarg             000034 external static fixed bin(35,0)          dcl 98 ref 205
error_table_$entlong            000036 external static fixed bin(35,0)          dcl 98 ref 212 247
error_table_$improper_data_format
                                000040 external static fixed bin(35,0)          dcl 98 ref 163 253 278
error_table_$out_of_bounds      000042 external static fixed bin(35,0)          dcl 98 ref 314 326
expand_pathname_$component      000014 constant        entry                    external dcl 87 ref 258
hcs_$fs_get_path_name           000020 constant        entry                    external dcl 87 ref 285
hcs_$fs_get_seg_ptr             000022 constant        entry                    external dcl 87 ref 264
i                               000217 automatic       fixed bin(17,0)          dcl 53 set ref 169* 170 170* 170 171 178 179 181 182
                                                                                  183 185* 186 187 188 222* 223 224 229 230 232 234*
                                                                                  235 236 237
id_case                         000220 automatic       fixed bin(17,0)          dcl 53 set ref 164* 197* 199* 203 210* 252 257 263
                                                                                  297
initiate_file_$component        000016 constant        entry                    external dcl 87 ref 290
length                                                 builtin function         dcl 84 ref 170 173 180 181 183 184 204 211 220 231
                                                                                  233 246
null                                                   builtin function         dcl 84 ref 276 291 341 348
object_lib_$get_def_target      000026 constant        entry                    external dcl 87 ref 297 299 301
object_lib_$initiate            000024 constant        entry                    external dcl 87 ref 289
offset_case                     000221 automatic       fixed bin(17,0)          dcl 53 set ref 165* 221* 226* 245* 252 276 277 295
                                                                                  296 318
ptr                                                    builtin function         dcl 84 ref 317
reverse                                                builtin function         dcl 84 ref 169
rtrim                                                  builtin function         dcl 84 ref 173 180 184 231 233
search                                                 builtin function         dcl 84 ref 169 202
segment_id                             based           char                     packed unaligned dcl 73 set ref 180 197 199 202 204
                                                                                  211 258* 264* 268* 274 274 274 297*
segno                           000122 automatic       fixed bin(35,0)          dcl 53 set ref 268* 273
string                                 parameter       char                     packed unaligned dcl 48 set ref 45 168 169 170 173
                                                                                  178 181 182 183
string_array                           based           char(1)                  array packed unaligned dcl 73 set ref 178 182
sys_info$max_seg_size           000044 external static fixed bin(35,0)          dcl 98 ref 312
terminate_file_                 000030 constant        entry                    external dcl 87 ref 349
verify                                                 builtin function         dcl 84 ref 185 197 222 234 239
word                            000123 automatic       fixed bin(35,0)          dcl 53 set ref 307* 312 312 317
word_offset                            based           char                     packed unaligned dcl 73 set ref 184 185 220 222 233
                                                                                  246 297* 299* 301* 307*
word_offset_array                      based           char(1)                  array packed unaligned dcl 73 set ref 187 224 227
                                                                                  229

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-33
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RW_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-30
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
TERM_FILE_BC                           internal static bit(2)                   initial packed unaligned dcl 4-12
TERM_FILE_DELETE                       internal static bit(5)                   initial packed unaligned dcl 4-17
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial packed unaligned dcl 4-16
TERM_FILE_TRUNC                        internal static bit(1)                   initial packed unaligned dcl 4-11
TERM_FILE_TRUNC_BC                     internal static bit(2)                   initial packed unaligned dcl 4-13
TERM_FILE_TRUNC_BC_TERM                internal static bit(3)                   initial packed unaligned dcl 4-15
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
definition                             based           structure                level 1 dcl 2-12
object_info                            based           structure                level 1 dcl 3-6
object_info_version_2                  internal static fixed bin(17,0)          initial dcl 3-60
terminate_file_switches                based           structure                level 1 packed packed unaligned dcl 4-4

NAMES DECLARED BY EXPLICIT CONTEXT.
ERROR                           001423 constant        label                    dcl 340 ref 203 206 213 216 227 241 248 254 259 265
                                                                                  271 279 286 291 303 310 315 322 327
OFFSET                          001066 constant        label                    dcl 295 ref 281
cv_ptr_                         000043 constant        entry                    external dcl 45
terminate                       001442 constant        entry                    external dcl 346

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2750        3016    2527        2760
Length      3274    2527        46         242     220           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cv_ptr_                             210 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cv_ptr_                  000100 Lbit_offset                 cv_ptr_
                         000101 Lsegment_id                 cv_ptr_
                         000102 Lword_offset                cv_ptr_
                         000104 Pbit_offset                 cv_ptr_
                         000106 Psegment_id                 cv_ptr_
                         000110 Pword_offset                cv_ptr_
                         000112 Pdelim                      cv_ptr_
                         000114 P                           cv_ptr_
                         000116 Ptarget                     cv_ptr_
                         000120 bc                          cv_ptr_
                         000121 bit                         cv_ptr_
                         000122 segno                       cv_ptr_
                         000123 word                        cv_ptr_
                         000124 code                        cv_ptr_
                         000125 dir                         cv_ptr_
                         000177 ent                         cv_ptr_
                         000207 component                   cv_ptr_
                         000217 i                           cv_ptr_
                         000220 id_case                     cv_ptr_
                         000221 offset_case                 cv_ptr_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_ext_out_desc   return_mac          signal_op           ext_entry           ext_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cv_dec_check_                 cv_oct_check_                 expand_pathname_$component    hcs_$fs_get_path_name
hcs_$fs_get_seg_ptr           initiate_file_$component      object_lib_$get_def_target    object_lib_$initiate
terminate_file_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_conversion   error_table_$bigarg           error_table_$entlong
error_table_$improper_data_format                           error_table_$out_of_bounds    sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     45 000037       162 000060       163 000062       164 000064       165 000066       166 000070       168 000073
    169 000075       170 000111       171 000117       172 000120       173 000122       174 000134       175 000136
    176 000137       178 000140       179 000145       180 000147       181 000161       182 000165       183 000170
    184 000173       185 000204       186 000217       187 000221       188 000225       190 000231       192 000232
    193 000234       197 000235       199 000254       202 000262       203 000305       204 000310       205 000313
    206 000315       208 000316       209 000317       210 000322       211 000324       212 000327       213 000331
    215 000332       216 000333       220 000335       221 000337       222 000341       223 000355       224 000357
    225 000363       226 000366       227 000370       229 000374       230 000400       231 000404       232 000415
    233 000420       234 000431       235 000444       236 000446       237 000452       239 000456       241 000471
    243 000472       245 000473       246 000475       247 000500       248 000503       252 000504       253 000514
    254 000517       257 000520       258 000523       259 000556       260 000560       263 000561       264 000563
    265 000607       266 000611       268 000612       269 000635       270 000637       271 000642       273 000643
    274 000647       276 000665       277 000702       278 000704       279 000707       281 000710       285 000711
    286 000743       289 000745       290 001021       291 001061       292 001065       295 001066       296 001072
    297 001074       299 001150       301 001222       303 001267       304 001271       305 001273       307 001274
    308 001317       309 001321       310 001324       312 001325       314 001333       315 001336       317 001337
    318 001342       319 001345       320 001367       321 001371       322 001374       324 001375       326 001402
    327 001405       329 001406       333 001411       340 001423       341 001426       346 001437       348 001450
    349 001470       351 001516


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
