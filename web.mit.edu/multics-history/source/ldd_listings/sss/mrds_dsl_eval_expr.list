	COMPILATION LISTING OF SEGMENT mrds_dsl_eval_expr
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/18/85  1025.3 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 mrds_dsl_eval_expr:
       19 eval_expr:
       20      proc (area_ptr, expr_ptr, rmri_ptr, simple_typed_vector_ptr, code);
       21 
       22 /* DESCRIPTION:
       23*
       24*   This routine evaluates functions and arithmetic expressions appearing in the
       25*   where clause.
       26*
       27*
       28*   MRDS_DEBUG_TOOL SWITCHES:
       29*
       30*   bit 1 = display intermediate expressions.
       31*   bits 2 through 9 = not used.
       32*
       33*
       34*   HISTORY:
       35*
       36*   79-02-01 J. A. Weeldreyer: Modified for MR7.0.
       37*
       38*   79-05-10 Al Kepner: Modified to add a handler for the conversion condition.
       39*
       40*   79-05-22 Al Kepner: Modified to prevent misuse of the expression stack which
       41*   resulted in a subscriptrange condition.
       42*
       43*   79-08-28  NSDavids:  Removed  special  handling of the first argument of the
       44*   expression.   Why  it  was there I don't know but it was not handling a real
       45*   argument and an expression type of complex correcly.
       46*
       47*   79-11-30  Rickie  E.   Brinegar:  Modified  to  use mrds_debug_tool switches
       48*   instead of the entry points db_on and db_off.
       49*
       50*   79-12-01  Jim  Gray: Modified to make calls to mu_data_class$complex_data_class
       51*   and $real_data_class for determining data categories, so that packed decimal
       52*   was included.
       53*
       54*   80-02-01 Jim Gray: Modified to add area_ptr parameter.
       55*
       56*   80-05-07  Davids: Modified assignments of tuple_num_atts and tuple_nvar_atts
       57*   to  take  values  from rm_rel_info.model_num_attr and model_nvar_atts rather
       58*   than  rm_rel_info.num_attr  and  nvar_atts.   This was to fix a problem with
       59*   submodels  were the submodel view did not contain a varying string attribute
       60*   and the model did.
       61*
       62*   80-08-01  Rickie  E.   Brinegar:  Modified  to  make  the stack structure an
       63*   automatic variable and remove unreferenced declared variables not in include
       64*   files.
       65*
       66*   81-02-20  Rickie  E.  Brinegar: Changed calls to mdb_display_value_ to calls
       67*   to  mdb_display_data_value$ptr.  The latter routine does not truncate at 256
       68*   characters of output.
       69*
       70*   81-06-01 Jim Gray : modified to use new resultant structure.
       71*
       72*   82-08-25 Mike Kubicar : converted from tuple structure to simple typed
       73*   vector.
       74*
       75**/
       76 
       77 	display_intermed_expr = substr (db_mrds_dsl_eval_expr, 1, 1);
       78 	num_dims = 0;
       79 
       80 	on conversion goto conversion_error;
       81 
       82 
       83 	wa_ptr = area_ptr;
       84 	stack.top_entry = 0;			/* init for no operands */
       85 	call determine_result_type (expr.nitems);	/* set result_type switch for the first entry in the expression structure */
       86 
       87 
       88 /*
       89*   now process each entry in the expression
       90**/
       91 
       92 	do i = 1 to expr.nitems;
       93 
       94 /* the operand will be DATA type or SCAL_FUN type
       95*   which will be processed when an OPERATOR is encountered
       96**/
       97 
       98 
       99 	     if expr.item.type (i) = DATA then do;
      100 		     if expr.item.data_type (i) = DATABASE then
      101 			call get_db_item (i);	/* must initialize ptr for assign_ */
      102 
      103 		     if expr.item.desc (i) = expr.item.desc (expr.nitems)
      104 						/* no need for conversion */
      105 		     then call increment_stack (i, expr.item.assn_ptr (i));
      106 
      107 		     else do;			/* must convert to intermediate type and precision */
      108 			     stack.top_entry = stack.top_entry + 1; /* push up by 1 */
      109 			     if result_type = CMPX then do; /* mode is complex */
      110 				     assign_desc = CFLTD59;
      111 				     op_ptr = addr (stack.operand.cmpx_op (stack.top_entry));
      112 						/* ptr to intermediate value */
      113 				end;
      114 
      115 			     else do;		/* treat as if mode is rea */
      116 				     assign_desc = RFLTD59;
      117 				     op_ptr = addr (stack.operand.real_op (stack.top_entry));
      118 				end;
      119 
      120 			     call
      121 				mu_convert$convert_data (expr.item.assn_ptr (i),
      122 				addr (expr.item.desc (i)), op_ptr, addr (assign_desc), icode);
      123 			     if icode ^= 0 then
      124 				call error (icode);
      125 			     stack.operand.index (stack.top_entry) = i; /* index to entry in expr structure */
      126 			     stack.operand.data_ptr (stack.top_entry) = op_ptr;
      127 						/* ptr to operand data */
      128 
      129 			end;
      130 		end;				/* end of DATA type processing;
      131*						   */
      132 
      133 
      134 /* is it a SCAL_FUN type */
      135 
      136 	     else if expr.item.type (i) = SCAL_FUN then do; /* is a scalar function */
      137 		     call
      138 			mrds_dsl_eval_func (area_ptr, expr.item.fn_ptr (i), rmri_ptr,
      139 			simple_typed_vector_ptr, icode);
      140 		     if icode ^= 0 then
      141 			call error (icode);
      142 		     call increment_stack (i, expr.item.assn_ptr (i));
      143 						/* result of function is predetermined to
      144*						   be float dec (59)
      145*						   add index and pointer to the operand stack
      146*						   */
      147 		end;
      148 
      149 /* is it an OPERATOR type */
      150 
      151 	     else if expr.item.type (i) = OPERATOR then do; /* is an operator,
      152*						   so result of operation will be pointed to by this entry in the expr structure */
      153 		     call process_op (i, result_type);
      154 		     call increment_stack (i, expr.item.assn_ptr (i));
      155 						/*
      156*						   add the index and data pointer of the operand to the stack ...
      157*						   it will always be float dec (59)
      158*						   */
      159 
      160 		end;
      161 	end;					/* end of do loop which processes each item in the expr structure
      162*						   list */
      163 
      164 	code = 0;
      165 
      166 	if display_intermed_expr then do;
      167 		call ioa_$nnl ("Expression value: ");
      168 
      169 /* 81-02-20 Rickie E. Brinegar: Start changes ****************************** */
      170 
      171 		call
      172 		     mdb_display_data_value$ptr (expr.item (expr.nitems).assn_ptr,
      173 		     addr (expr.item (expr.nitems).desc));
      174 
      175 /* 81-02-20 Rickie E. Brinegar: End changes ******************************** */
      176 
      177 	     end;
      178 exit:
      179 	return;
      180 
      181 
      182 conversion_error:
      183 	;
      184 	code = mrds_error_$conversion_condition;
      185 	go to exit;
      186 
      187 determine_result_type:
      188      proc (i);
      189 
      190 /* is the mode for this entry complex or real
      191*   or character or bit */
      192 
      193 	dcl     i			 fixed bin;	/* index value to expression entry */
      194 
      195 /* see if the mode for this entry is complex */
      196 
      197 	if mu_data_class$complex_data_class (addr (expr.item.desc (i))) then
      198 	     result_type = CMPX;
      199 
      200 	else if mu_data_class$real_data_class (addr (expr.item.desc (i))) then
      201 	     result_type = REAL;
      202 
      203 
      204 	else result_type = CHAR_BIT;			/* mode is character or bit,
      205*						   will be treated as real */
      206 
      207      end determine_result_type;
      208 
      209 process_op:
      210      proc (indx, result_type);
      211 
      212 /* This procedure performs the operation designated by the indx element of
      213*   the expr structure upon
      214*   the first operand comes from the top entry in the stack
      215*   and the second operand comes from the next to top entry
      216*
      217*   The result is placed in the location pointed to by the assn_ptr variable
      218*   in the indx element of the expr structure.
      219**/
      220 
      221 	dcl     indx		 fixed bin;	/* indx to the expr structure list */
      222 	dcl     result_type		 bit (1) unal;	/* ON => complex mode;  OFF => real mode */
      223 
      224 	goto case (expr.item.op_code (indx));
      225 
      226 case (1):						/* ADDITION */
      227 	if result_type = CMPX then
      228 	     expr.item.assn_ptr (indx) -> op_cmpx =
      229 		stack.operand.data_ptr (stack.top_entry - 1) -> op_cmpx
      230 		+ stack.operand.data_ptr (stack.top_entry) -> op_cmpx;
      231 
      232 	else expr.item.assn_ptr (indx) -> op_real =
      233 		stack.operand.data_ptr (stack.top_entry - 1) -> op_real
      234 		+ stack.operand.data_ptr (stack.top_entry) -> op_real;
      235 	goto exit;
      236 
      237 
      238 case (2):						/* SUBTRACTION */
      239 	if result_type = CMPX then
      240 	     expr.item.assn_ptr (indx) -> op_cmpx =
      241 		stack.operand.data_ptr (stack.top_entry - 1) -> op_cmpx
      242 		- stack.operand.data_ptr (stack.top_entry) -> op_cmpx;
      243 
      244 	else expr.item.assn_ptr (indx) -> op_real =
      245 		stack.operand.data_ptr (stack.top_entry - 1) -> op_real
      246 		- stack.operand.data_ptr (stack.top_entry) -> op_real;
      247 	goto exit;
      248 
      249 case (3):						/* MULTIPLY */
      250 	if result_type = CMPX then
      251 	     expr.item.assn_ptr (indx) -> op_cmpx =
      252 		stack.operand.data_ptr (stack.top_entry - 1) -> op_cmpx
      253 		* stack.operand.data_ptr (stack.top_entry) -> op_cmpx;
      254 
      255 	else expr.item.assn_ptr (indx) -> op_real =
      256 		stack.operand.data_ptr (stack.top_entry - 1) -> op_real
      257 		* stack.operand.data_ptr (stack.top_entry) -> op_real;
      258 	goto exit;
      259 
      260 case (4):						/* DIVISION */
      261 	if result_type = CMPX then
      262 	     expr.item.assn_ptr (indx) -> op_cmpx =
      263 		stack.operand.data_ptr (stack.top_entry - 1) -> op_cmpx
      264 		/ stack.operand.data_ptr (stack.top_entry) -> op_cmpx;
      265 
      266 	else expr.item.assn_ptr (indx) -> op_real =
      267 		stack.operand.data_ptr (stack.top_entry - 1) -> op_real
      268 		/ stack.operand.data_ptr (stack.top_entry) -> op_real;
      269 	goto exit;
      270 
      271 
      272 exit:						/* decrement the stack by 2 because we always operate on two
      273*						   operands at a time
      274*						   */
      275 	stack.top_entry = stack.top_entry - 2;
      276 
      277 	return;
      278      end process_op;
      279 
      280 get_db_item:
      281      proc (ii);
      282 
      283 /* procedure to move an attr. value out of the tuple, and decode it if necessary. */
      284 
      285 	dcl     ii		 fixed bin;	/* item index */
      286 
      287 	rai_ptr = expr.item.ai_ptr (ii);
      288 
      289 	call
      290 	     mu_get_data$get_data_item (rai_ptr, area_ptr,
      291 	     (simple_typed_vector.dimension (rm_attr_info.defn_order).value_ptr),
      292 	     expr.item.assn_ptr (ii), addr (expr.item.desc (ii)), icode);
      293 	if icode ^= 0 then
      294 	     call error (icode);
      295 
      296      end get_db_item;
      297 
      298 error:
      299      proc (cd);
      300 
      301 /* error procedure */
      302 
      303 	dcl     cd		 fixed bin (35);
      304 
      305 	code = cd;
      306 	go to exit;
      307 
      308      end error;
      309 
      310 
      311 increment_stack:
      312      proc (indx, data_ptr);
      313 
      314 /* this procedure adds an expression index value and a pointer to the
      315*
      316*   relevant data to a stack to facilitate processing of the expression
      317*   structure list
      318**/
      319 
      320 	dcl     indx		 fixed bin;	/* index to the relevant entry in the expr structure list */
      321 	dcl     data_ptr		 ptr;		/* pointer to the data to be used as an operand */
      322 
      323 	if stack.top_entry ^< mrds_data_$max_expr_stack_size then
      324 	     call error (mrds_error_$expr_stack_ovfl);
      325 
      326 	stack.top_entry = stack.top_entry + 1;		/* push up by 1 */
      327 	stack.operand.index (stack.top_entry) = indx;	/* index to entry in expr structure */
      328 	stack.operand.data_ptr (stack.top_entry) = data_ptr; /* ptr to operand data */
      329 
      330      end increment_stack;
      331 
      332 	declare area_ptr		 ptr;
      333 	dcl     1 stack,
      334 		2 top_entry	 fixed bin,	/* top entry in the operand stack */
      335 		2 operand		 (mrds_data_$max_expr_stack_size), /* (expr.nitems refer (stack.top_entry)), */
      336 		  3 index		 fixed bin,	/* index to expr structure for this operand */
      337 		  3 data_ptr	 ptr,		/* ptr to data for this operand */
      338 		  3 real_op	 real float dec (59) aligned, /* intermediate value for real operand */
      339 		  3 cmpx_op	 complex float dec (59) aligned; /* intermediate value for complex operands */
      340 
      341 	dcl     assign_desc		 bit (36);	/* descriptor for REAL or COMPLEX float dec (59) */
      342 	dcl     op_cmpx		 complex float dec (59) aligned based; /* if mode is complex */
      343 	dcl     op_real		 real float dec (59) aligned based; /* format for first operand if mode is real */
      344 
      345 	dcl     (
      346 	        display_intermed_expr,		/* debug_tool switch */
      347 	        result_type
      348 	        )			 bit (1) unal;	/* ON => complex; OFF => treat as real */
      349 
      350 	dcl     (
      351 	        op_ptr,				/* ptr to operand */
      352 	        wa_ptr
      353 	        )			 ptr;
      354 
      355 	dcl     (
      356 	        CHAR_BIT		 bit (1) unal init ("0"b), /* mode is char or bit */
      357 	        CMPX		 bit (1) unal init ("1"b), /* complex mode */
      358 	        REAL		 bit (1) unal init ("0"b)
      359 	        )			 internal static options (constant); /* real mode */
      360 
      361 	dcl     i			 fixed bin;	/* index value */
      362 
      363 	dcl     (
      364 	        code,				/* Output:  status code */
      365 	        icode				/* internal status code */
      366 	        )			 fixed bin (35);	/* to data in tuple.data */
      367 
      368 	dcl     (addr, null, substr)	 builtin;
      369 
      370 	dcl     conversion		 condition;
      371 
      372 	dcl     ioa_$nnl		 entry options (variable);
      373 
      374 /* 81-02-20 Rickie E. Brinegar: Start changes ****************************** */
      375 
      376 	dcl     mdb_display_data_value$ptr entry (ptr, ptr);
      377 
      378 /* 81-02-20 Rickie E. Brinegar: End changes ******************************** */
      379 
      380 	dcl     mu_data_class$complex_data_class entry (ptr) returns (bit (1) aligned);
      381 	dcl     mu_convert$convert_data entry (ptr, ptr, ptr, ptr, fixed bin (35));
      382 	dcl     mu_get_data$get_data_item entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35));
      383 	dcl     mu_data_class$real_data_class entry (ptr) returns (bit (1) aligned);
      384 	dcl     mrds_dsl_eval_func	 entry (ptr, ptr, ptr, ptr, fixed bin (35));
      385 
      386 	dcl     mrds_data_$max_expr_stack_size fixed bin (35) ext;
      387 	dcl     mrds_error_$conversion_condition fixed bin (35) ext;
      388 	dcl     mrds_error_$expr_stack_ovfl fixed bin (35) ext;
      389 
  1     1 /* BEGIN mdbm_descriptor.incl.pl1 -- jaw 5/31/78 */
  1     2 /* modified by Jim Gray - - Nov. 1979, to change type from fixed bin(5) to
  1     3*   unsigned fixed bin(6), so new packed decimal data types could be handled.
  1     4*   also the duplicate mrds_descriptor.incl.pl1 was eliminated. */
  1     5 
  1     6 dcl 1 descriptor based (desc_ptr),			/* map of Multics descriptor */
  1     7     2 version bit (1) unal,				/* DBM handles vers. 1 only */
  1     8     2 type unsigned fixed bin (6) unal,			/* data type */
  1     9     2 packed bit (1) unal,				/* on if data item is packed */
  1    10     2 number_dims bit (4) unal,			/* dimensions */
  1    11     2 size,					/* size for string data */
  1    12       3 scale bit (12) unal,				/* scale for num. data */
  1    13       3 precision bit (12) unal,			/* prec. for num. data */
  1    14     2 array_info (num_dims),
  1    15       3 lower_bound fixed bin (35),			/* lower bound of dimension */
  1    16       3 upper_bound fixed bin (35),			/* upper bound of dimension */
  1    17       3 multiplier fixed bin (35);			/*  element separation */
  1    18 
  1    19 dcl  desc_ptr ptr;
  1    20 dcl  num_dims fixed bin init (0) ;			/* more useful form of number_dims */
  1    21 
  1    22 /* END mdbm_descriptor.incl.pl1 */
  1    23 
  1    24 
      390 
      391 
  2     1 /*  BEGIN  mdbm_rm_attr_info.incl.pl1  --  jaw,  11/16/78  */
  2     2 
  2     3 /* WARNING
  2     4*          If the rm_attr_info structure is changed then the mrds_data_
  2     5*          item saved_res_version MUST be incremented to invalidate all
  2     6*          existing saved resultants
  2     7**/
  2     8 
  2     9 /*
  2    10*
  2    11*   Modified  by  Jim  Gray - - 80-11-05, to add mdbm_secured bit, so
  2    12*   that rm_rel_info does not have to be checked
  2    13*
  2    14*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
  2    15*   foreign keys.
  2    16*
  2    17*   82-08-19  D. Woodka : removed rm_attr_info.bit_offset for the DMS
  2    18*   conversion.
  2    19*
  2    20*   82-09-15 Davids: added the number_of_dups field.
  2    21*
  2    22*   82-09-20 Mike Kubicar : changed the index_id field to be bit (36)
  2    23*   aligned.  This is to conform with the new definition in the database
  2    24*   model.  Also removed the now useless field varying.
  2    25*
  2    26*   82-11-05 Davids: added the field model_defn_order and clarified the
  2    27*   comment for the field defn_order.
  2    28*
  2    29*   83-05-23 Mike Kubicar : changed number_of_dups to fixed bin (35) since
  2    30*   that's what relation manager returns.
  2    31*
  2    32**/
  2    33 
  2    34 
  2    35 /*
  2    36*   this   structure   is   allocated   in   the   static   area   of
  2    37*   mdbm_rm_db_info.incl.pl1  once for each attribute per relation in
  2    38*   a     readied     file.      it     in     turn     points     to
  2    39*   mdbm_rm_domain_info.incl.pl1  for  the  attributes  domain.   the
  2    40*   rm_attr_info  is  pointed  to  by mdbm_rm_rel_info.incl.pl1.  all
  2    41*   structures  are  in  the  rm_db_info  area.   the  attribute data
  2    42*   position  within  a  tuple as stored in the data file are kept in
  2    43*   this resultant model of the attribute.
  2    44* */
  2    45 
  2    46 dcl 1 rm_attr_info aligned based (rai_ptr),		/* resultant attr. info */
  2    47     2 name char (32),				/* from submodel */
  2    48     2 model_name char (32),				/* from model */
  2    49     2 key_attr bit (1) unal,				/* if key attribute */
  2    50     2 index_attr bit (1) unal,			/* if secondary index */
  2    51     2 read_perm bit (1) unal,				/* user has retr. permission */
  2    52     2 modify_perm bit (1) unal,			/* user has modify permission */
  2    53     2 mdbm_secured bit (1) unal,			/* on => database secured */
  2    54     2 reserved bit (30) unal,				/* for future use */
  2    55     2 index_id bit (36) aligned,			/* index id if index_attr */
  2    56     2 defn_order fixed bin,				/* relative order in which attr is defined in the view */
  2    57     2 key_order fixed bin,				/* relative order defined in prim. key */
  2    58     2 bit_length fixed bin (35),			/* length if fixed, max. len. if var. */
  2    59     2 domain_ptr ptr,				/* to domain info */
  2    60     2 number_of_dups fixed bin (35),                        /* if the attribute is indexed this will
  2    61*                                                               be the number of duplicate values, exact
  2    62*                                                               for a page_file database, an estimate for a vfile type */
  2    63     2 model_defn_order fixed bin;                           /* relative order in which attr is defined in the model */
  2    64 
  2    65 dcl  rai_ptr ptr int automatic init (null ());
  2    66 
  2    67 /* END mdbm_rm_attr_info.incl.pl1 */
  2    68 
  2    69 
      392 
      393 
  3     1 /* BEGIN mdbm_rm_rel_info.incl.pl1 -- jaw, 11/16/78 */
  3     2 
  3     3 /* WARNING
  3     4*          If the rm_rel_info structure is changed then the mrds_data_
  3     5*          item saved_res_version MUST be incremented to invalidate all
  3     6*          existing saved resultants
  3     7**/
  3     8 
  3     9 /* HISTORY:
  3    10*
  3    11*   Modified by Jim Gray - - May 1980, to  include  model  number  of
  3    12*   attributes,   and   varying  attributes,  so  that  partial  view
  3    13*   submodels will have the  info  needed  to  properly  set  up  the
  3    14*   varying length array headers in the tuple structure.
  3    15*
  3    16*   Modified  by  Jim  Gray  -  -  80-11-06,  to  rename   r_perm   =
  3    17*   status_perm,     s_perm    =    append_tuple_perm,    d_perm    =
  3    18*   delete_tuple_perm, and make m_perm = unused_perm.
  3    19*
  3    20*   81-01-23 Jim Gray : added bit to indicate whether the last  model
  3    21*   view attribute was varying character or bit, since a partial view
  3    22*   submodel will not have this information in the resultant, and  it
  3    23*   is  needed for determining the new tuple length in mus_mod_ubtup,
  3    24*   since with exact length storage  of  varying  length  attributes,
  3    25*   each  tuple  can  be  a  different  length,  which is can only be
  3    26*   determined by examining the tuple itself.
  3    27*
  3    28*   81-01-29 Jim Gray : added curent  tuple  count,  to  provide  for
  3    29*   interface  to  allow  temp  rel  population  to  be known, and to
  3    30*   provide a more efficient means of finding an approx. current perm
  3    31*   relation population.
  3    32*
  3    33*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
  3    34*   blocked  files, foreign keys, and ids procedures. Also set number
  3    35*   of files per rel to a constant of 1.
  3    36*
  3    37*   81-05-28 Jim Gray : combined data  from  rm_file_info  into  this
  3    38*   structure so that only one structure per relation is needed.
  3    39*
  3    40*   81-07-02 Jim Gray : added total_key and dup_key vfile  statistics
  3    41*   counts.   Also  added  number  of  operations  count  since  last
  3    42*   statistics update, and a time  since  the  statistics  were  last
  3    43*   updated.
  3    44*
  3    45*   81-07-06 Jim Gray :  added  a  per  selection  expression  update
  3    46*   identifier so that small relations could be updated on a per S.E.
  3    47*   basis
  3    48*
  3    49*   82-04-21 R. Lackey : Added number_selected (ri_niocbs_init refer (rm_rel_info.niocbs)) fixed bin (35)
  3    50*   to end of structure   TR 12205 (Suggestion).
  3    51*   
  3    52*   82-08-19 D. Woodka :  Removed  rm_rel_info.max_data_len  field for
  3    53*   the DMS conversion. 
  3    54*
  3    55*   82-08-30 Davids: added the opening_id element and removed the iocb
  3    56*   array and the niocb element for DMS conversion. Also removed the
  3    57*   number_selected array (and ri_niocbs_init) since subsets are not
  3    58*   going to be used.
  3    59*
  3    60*   82-09-20 Mike Kubicar : changed rm_rel_info.rel_id to bit (36) aligned
  3    61*   so that it can be used with relation manager.  Also added
  3    62*   rm_rel_info.primary_key_index_id for relation manager.
  3    63*
  3    64*   82-09-22 Mike Kubicar : Removed the, now useless, fields var_attr_ptrs,
  3    65*   nvar_atts, model_nvar_atts.
  3    66*
  3    67*   82-09-24 Davids: Removed current_key_count and current_dup_key_count
  3    68*   since the duplicate key count for each secondary index is now being
  3    69*   kept in the attr_info structure and key_count was only needed to
  3    70*   help in calculating the average selectivity of each index which
  3    71*   can now be gotten directly from each index's dup key count. Also
  3    72*   removed the file_id element since it is no longer needed for
  3    73*   anything.
  3    74*
  3    75*   82-09-27 Mike Kubicar : removed file_id_len for the same reason file_id
  3    76*   was removed.
  3    77*
  3    78*   82-11-05 Mike Kubicar : added a pointer to an id_list structure to be
  3    79*   used when retrieving tuples from this relation.
  3    80*
  3    81*   83-04-06 Davids: Added the scope_flags_ptr which points to the scope_flags structure
  3    82*   for the relation. Note that this structure is part of the resultant NOT
  3    83*   part of the db.control structure. The scopes are duplicated in the resultant
  3    84*   to reduce contention for the db.control structure. Note also that the pointer
  3    85*   will always point to a scope_flags structure even if no scopes have been
  3    86*   set on the relation, the structure is allocated when the db is opened.
  3    87**/
  3    88 
  3    89 
  3    90 /* DESCRIPTION:
  3    91*
  3    92*   This structure is allocated in the area part of the structure  in
  3    93*   mdbm_rm_db_info.incl.pl1  as  part of the resultant model created
  3    94*   at open  time  for  a  database.  There  will  be  one  of  these
  3    95*   rm_rel_info   structures  for  each  relation  appearing  in  the
  3    96*   database view (there may be less than the total in  the  database
  3    97*   for  a  submodel  openings).  There  will  also  be  one for each
  3    98*   temporary relation currently defined for that opening.
  3    99*
  3   100*   The structure in mdbm_rm_rel_array.incl.pl1 contains pointers  to
  3   101*   all  rm_rel_info  structures  allocated. It is used for searching
  3   102*   for the appropriate  structure.  This  array  is  pointed  to  by
  3   103*   rm_db_info. There are two arrays, one for perm rels, one for temp
  3   104*   rels.
  3   105*
  3   106*   The      rm_rel_info      structure      points      to       the
  3   107*   mdbm_rm_attr_info.incl.pl1  structures,  one  for  each attribute
  3   108*   appearing in this view of the relation. Each  of  these  in  turn
  3   109*   point  to a mdbm_rm_domain_info.incl.pl1 structure for the domain
  3   110*   info for each attr.
  3   111*
  3   112*   Most of the other information here deals with  specifics  of  the
  3   113*   relation's  logical  definition,  such as key and secondary index
  3   114*   attribute inidicators, security permissions, and  tuple  physical
  3   115*   construction details.
  3   116*
  3   117**/
  3   118 
  3   119      dcl	   1 rm_rel_info	      aligned based (rmri_ptr), /* relation information */
  3   120 	     2 name	      char (32),		/* from submodel */
  3   121 	     2 model_name	      char (30),		/* from model */
  3   122 	     2 rel_id	      bit (36) aligned,	/* unique id. */
  3   123 	     2 retrieve	      bit (1) unal,		/* operations allowed by this view */
  3   124 	     2 modify	      bit (1) unal,
  3   125 	     2 delete	      bit (1) unal,
  3   126 	     2 store	      bit (1) unal,
  3   127 	     2 total_key	      bit (1) unal,		/* on if view includes full primary key */
  3   128 	     2 indexed	      bit (1) unal,		/* on if exists sec. index */
  3   129 	     2 mdbm_secured	      bit (1) unal,		/* on if mdbm must check security */
  3   130 	     2 status_perm	      bit (1) unal,		/* if user has status. perm. */
  3   131 	     2 append_tuple_perm  bit (1) unal,		/* if user has store perm. */
  3   132 	     2 delete_tuple_perm  bit (1) unal,		/* if user has del. perm. */
  3   133 	     2 unused_perm	      bit (1) unal,		/* for future use. */
  3   134 	     2 last_model_attr_char_var bit (1) unal,	/* on => last model varying attr is char */
  3   135 	     2 reserved	      bit (24) unal,	/* for future use */
  3   136 	     2 num_attr	      fixed bin,		/* total no. of attr. in rel. */
  3   137 	     2 model_num_attr     fixed bin,		/* total attrs in model relation */
  3   138 	     2 nkey_attr	      fixed bin,		/* no. of key attr. */
  3   139 	     2 model_nkey_attr    fixed bin,		/* total number of keys in model */
  3   140 	     2 primary_key_index_id bit (36) aligned,     /* Index id of relation's primary key */
  3   141 	     2 nsec_inds	      fixed bin,		/* no. sec. indexes */
  3   142 	     2 max_key_len	      fixed bin (35),	/* max length (chars) of primary key */
  3   143 	     2 current_tuple_population fixed bin (35),	/* last known total  tuple count for this relation */
  3   144 	     2 last_statistics_update_count fixed bin,	/* number of operations's, since this rels stats were updated */
  3   145 	     2 last_statistics_update_time fixed bin (71),/* last time this rels stats were updated */
  3   146 	     2 last_statistics_update_s_e_ref_num fixed bin (35), /* last select expr ID that updated this rels stats */
  3   147 	     2 ready_mode	      fixed bin,		/* 1 => r, 2 => mr, 3 => u, 4 => l, 5 => sr, 6 => su */
  3   148 	     2 file_type	      fixed bin,		/* 1 => unblocked, 2 => blocked, 3 => temporary */
  3   149 	     2 tuple_id_len	      fixed bin,		/* no. bits in local tuple id */
  3   150 	     2 opening_id	      bit (36) aligned,	/* relation manager opening is */
  3   151 	     2 key_attr_ptrs      (nkey_attr_init refer (rm_rel_info.nkey_attr)) ptr, /* ptrs to key attr. */
  3   152 	     2 attr_ptrs	      (natts_init refer (rm_rel_info.num_attr)) ptr, /* ptrs to all attr. */
  3   153 	     2 id_list_ptr        ptr,		/* Id list for retrieves from the relation */
  3   154                2 scope_flags_ptr    ptr;                    /* pointer to the scope_flags structure for the rel */
  3   155 
  3   156      dcl	   rmri_ptr	      ptr;
  3   157      dcl	   (nkey_attr_init,
  3   158 	   natts_init,
  3   159 	   nvar_atts_init)	      fixed bin;
  3   160 
  3   161 /* END mdbm_rm_rel_info.incl.pl1 */
  3   162 
  3   163 
      394 
      395 
  4     1 /* BEGIN INCLUDE FILE mrds_debug_names.incl.pl1     Jim Gray 8/7/79 */
  4     2 
  4     3 /* this include file associates module names with debug switches
  4     4*   that are stored in the data segment mrds_debug_
  4     5*   each module has it's own bit(9) debug switch, to define for various
  4     6*   debug actions, with new module names to be added to the end
  4     7*   of this list using the next in order array index in mrds_debug_
  4     8*   the convention for naming is db_{module's full name}
  4     9*   for the defined declaration over mrds_debug_$switch.
  4    10*   module.name array is then changed to reflect the new
  4    11*   number of modules, with the full module name added to the bottom
  4    12*   of the initialize list for the name array.
  4    13*   the module name array is used by the command level interface that sets/resets
  4    14*   the current status of the debug switches for each module.
  4    15*   the modules themselves use the db_{module name} declared variable for
  4    16*   that module to interagate the bits for proper debug action to take.
  4    17*   the definition of the meaning of the 9-bits is up to each individual module's
  4    18*   designer. */
  4    19 
  4    20 
  4    21 /*
  4    22*   HISTORY
  4    23*
  4    24*   80-11-12 Davids: added db_mus_mod_ubtup
  4    25*
  4    26*   80-11-13 Davids: added db_mu_sec_get_tuple and db_mu_sec_get_tid
  4    27*
  4    28*   80-12-15 Jim Gray :  added  mrds_dsl_set_fscope  to  display  non
  4    29*   error  info  about  being queued, and request being granted after
  4    30*   being queued.
  4    31*
  4    32*   81-01-15 Jim Gray : added  mu_concurrency_control  bit  to  allow
  4    33*   running  MR8  and  MR9 mrds against the same database at the same
  4    34*   time.
  4    35*
  4    36*   81-02-02  Jim  Gray  :  added  bit  for  mrds_rst_dmdm  to  allow
  4    37*   displaying internal tuple format bit offset, rather than the user
  4    38*   view.
  4    39*
  4    40*   81-02-06 Jim Gray : added bit for  new  mu_open_name_manager,  to
  4    41*   dump  an  element  from  the  list, when display_open_names entry
  4    42*   called with switch set.
  4    43*
  4    44*   81-05-20 Jim Gray : added bit for  mrds_dsl_where_clause  display
  4    45*   of sub_err_ messages, when cross domain compare occurs.
  4    46*
  4    47*   81-06-17 Jim Gray : added bit for mu_open_iocb_manager to display
  4    48*   iocb slot and rel name.
  4    49*
  4    50*   81-07-08 Jim Gray : added comment for bit 4 in mrds_dsl_permute
  4    51*
  4    52*   81-07-17 Jim Gray : added comment for bit 5 in mrds_dsl_permute
  4    53*
  4    54*   81-07-18 Jim Gray : added bit 1 for  mrds_dsl_gen_srch_prog  that
  4    55*   allows  key  searches, other than than specified by permute to be
  4    56*   done as comparisons instead.
  4    57*
  4    58*   81-07-22  Jim   Gray   :   added   comment   about   bit   2   in
  4    59*   mrds_dsl_gen_srch_prog
  4    60**/
  4    61 
  4    62 declare (
  4    63          db_mrds_dsl_eval_expr bit (9) unal defined (mrds_debug_$switch (1)),
  4    64          db_mrds_dsl_get_token bit (9) unal defined (mrds_debug_$switch (2)),
  4    65          db_mrds_dsl_permute bit (9) unal defined (mrds_debug_$switch (3)),
  4    66          db_mrds_dsl_optimize bit (9) unal defined (mrds_debug_$switch (4)),
  4    67          db_mrds_dsl_search bit (9) unal defined (mrds_debug_$switch (5)),
  4    68          db_mrds_dsl_translate bit (9) unal defined (mrds_debug_$switch (6)),
  4    69          db_mu_retrieve bit (9) unal defined (mrds_debug_$switch (7)),
  4    70          db_mrds_dsl_open bit (9) unal defined (mrds_debug_$switch (8)),
  4    71          db_mrds_dsl_close bit (9) unal defined (mrds_debug_$switch (9)),
  4    72          db_mrds_dsl_init_res bit (9) unal defined (mrds_debug_$switch (10)),
  4    73          db_mu_sec_init_res bit (9) unal defined (mrds_debug_$switch (11)),
  4    74          db_mus_mod_ubtup bit (9) unal defined (mrds_debug_$switch (12)),
  4    75          db_mu_sec_get_tuple bit (9) unal defined (mrds_debug_$switch (13)),
  4    76          db_mu_sec_get_tid bit (9) unal defined (mrds_debug_$switch (14)),
  4    77          db_mrds_dsl_set_fscope bit (9) unal defined (mrds_debug_$switch (15)),
  4    78          db_mu_concurrency_control bit (9) unal defined (mrds_debug_$switch (16)),
  4    79          db_mrds_rst_dmdm bit (9) unal defined (mrds_debug_$switch (17)),
  4    80          db_mu_open_name_manager bit (9) unal defined (mrds_debug_$switch (18)),
  4    81          db_mrds_dsl_where_clause bit (9) unal defined (mrds_debug_$switch (19)),
  4    82          db_mu_open_iocb_manager bit (9) unal defined (mrds_debug_$switch (20)),
  4    83          db_mrds_dsl_gen_srch_prog bit (9) unal defined (mrds_debug_$switch (21))
  4    84          ) ;
  4    85 
  4    86 /* list of known module names, with index into name array
  4    87*   the same as that into mrds_debug_$switch,
  4    88*   number is the current count of defined module names,
  4    89*   name is the modules full name. */
  4    90 
  4    91 declare 1 module options (constant) internal static,
  4    92         2 number fixed bin init (21),
  4    93         2 name char (32) dimension (21) init (
  4    94          "mrds_dsl_eval_expr",			/* 1 => display value of each expression */
  4    95          "mrds_dsl_get_token",			/* 1 => display the current token */
  4    96          "mrds_dsl_permute",				/* each 1 => lost cost path found,
  4    97*						   2 => reverse partial path
  4    98*						   3 => use range order for path
  4    99*						   4 => display access method costs
  4   100*						   5 => display details of final low cost path */
  4   101          "mrds_dsl_optimize",				/* 1 => pred tree,
  4   102*						   2 => paths to consider, 3 => calc_cost on */
  4   103          "mrds_dsl_search",				/* 1 => display each tuple located */
  4   104          "mrds_dsl_translate",			/* 1 => display the search program */
  4   105          "mu_retrieve",				/* 1 => display values compared, 2 => display tuple data */
  4   106          "mrds_dsl_open",				/* 1 => allow cleanup sub_error_ */
  4   107          "mrds_dsl_close",				/* 1 => allow cleanup sub_error_ */
  4   108          "mrds_dsl_init_res",				/* 1 => allow cleanup sub_error_ */
  4   109          "mu_sec_init_res",				/* 1 => allow cleanup sub_error_ */
  4   110          "mus_mod_ubtup",				/* 1 => consistency checking between the old
  4   111*						   and new tuple during modifies will be done */
  4   112          "mu_sec_get_tuple",				/* 1 => attribute values
  4   113*						   will be zeroed in the tuple structure
  4   114*						   is don't have read permission. */
  4   115          "mu_sec_get_tid",				/* 1 => read permission to the key
  4   116*						   is checked (if db is secured) */
  4   117          "mrds_dsl_set_fscope",			/* 1 => display being queued,
  4   118*						   and request granted from queue messages */
  4   119          "mu_concurrency_control",			/* 1 => allow both dbc and db.control segs under db
  4   120*						   so can test both MR8 and MR9 mrds
  4   121*						   against the same database at the same time */
  4   122          "mrds_rst_dmdm",				/* 1 => allow internal form of bit offset value
  4   123*						   for attributes to be displayed, rather than user view */
  4   124          "mu_open_name_manager",			/* 1 => dump mrds_open_name tree node structure,
  4   125*						   when display_open_names entry called */
  4   126          "mrds_dsl_where_clause",			/* 1 => display details of cross domain compares */
  4   127          "mu_open_iocb_manager",			/* 1 => display relation and slot getting iocb for */
  4   128          "mrds_dsl_gen_srch_prog"			/* 1 => do additional conditions as sequential, not key searches
  4   129*						   when the original access was a key,
  4   130*						   and the additional conditions can be done as key also
  4   131*						   2 => force key searches, regardless of strategy
  4   132*						   used to decide between compare or key search */
  4   133          ) ;
  4   134 
  4   135 declare  mrds_debug_$switch (1:400) bit (9) unal ext ;	/* data segment debug array */
  4   136 
  4   137 /* END INCLUDE FILE mrds_debug_names.incl.pl1 */
  4   138 
      396 
      397 
  5     1 /* BEGIN INCLUDE FILE mrds_expressions.incl.pl1 -- jaw 2/15/79 */
  5     2 
  5     3 /* HISTORY:
  5     4*
  5     5*   81-06-01 Jim Gray : removed assn len and type elements
  5     6*   since mu_covnert is now being used.
  5     7*
  5     8**/
  5     9 
  5    10 
  5    11 dcl 1 expr aligned based (expr_ptr),			/* internal representation of an expression,
  5    12*						   expression is stored in postfix polish form */
  5    13     2 nitems fixed bin,				/* no. items in expression */
  5    14     2 item (nexp_items_init refer (expr.nitems)),
  5    15       3 type fixed bin (3) unal,			/* 1 => data item
  5    16*						   2 => operator
  5    17*						   3 => scalar function */
  5    18       3 op_code fixed bin (3) unal,			/* 1 => add
  5    19*						   2 => subtract
  5    20*						   3 => multiply
  5    21*						   4 => divide */
  5    22       3 data_type fixed bin (2) unal,			/* 1 => literal
  5    23*						   2 => database */
  5    24       3 reserved bit (25) unal,
  5    25       3 desc bit (36),				/* data descriptor of data item or fun. result */
  5    26       3 loc_index fixed bin (18),			/* location index of data item or fun. result */
  5    27       3 bit_length fixed bin (18),			/* bit length of data item or fun. result */
  5    28       3 assn_ptr ptr,				/* pointer to item storage loc. */
  5    29       3 ai_ptr ptr,					/* to attr info if database item */
  5    30       3 fn_ptr ptr;					/* pointer to function structure if scalar function */
  5    31 
  5    32 dcl  expr_ptr ptr;
  5    33 dcl  nexp_items_init fixed bin;
  5    34 
  5    35 dcl 1 scalfn aligned based (sfn_ptr),			/* internal representation of a scalar function */
  5    36     2 entry_ptr ptr,				/* pointer to entry to be called */
  5    37     2 arg_list_ptr ptr,				/* pointer to arg list to be used for calling function */
  5    38     2 rslt_desc bit (36),				/* descriptor for result */
  5    39     2 nargs fixed bin,				/* number of input args */
  5    40     2 arg (nsf_args_init refer (scalfn.nargs)),		/* arg info */
  5    41       3 type fixed bin (3) unal,			/* 1 => literal
  5    42*						   2 => database
  5    43*						   3 => scalar function
  5    44*						   4 => expression */
  5    45       3 must_convert bit (1) unal,			/* on if arg must be converted to match requirements */
  5    46       3 reserved bit (31) unal,
  5    47       3 desc bit (36),				/* descriptor of data or result */
  5    48       3 loc_index fixed bin (18),			/* location index of data item or result */
  5    49       3 bit_length fixed bin (18),			/* bit length of data item or result */
  5    50       3 assn_ptr ptr,				/* pointer to item storage loc. */
  5    51       3 arg_desc bit (36),				/* descriptor for arg if must convert */
  5    52       3 arg_assn_ptr ptr,				/* assign_ ptr for arg in must convert */
  5    53       3 ai_ptr ptr,					/* to attr info if database item */
  5    54       3 ef_ptr ptr;					/* pointer to expression or function structure, or null */
  5    55 
  5    56 dcl  sfn_ptr ptr;
  5    57 dcl  nsf_args_init fixed bin;
  5    58 
  5    59 dcl ((DATA init (1)),
  5    60     (OPERATOR init (2)),
  5    61     (SCAL_FUN init (3)),
  5    62     (EXPR init (4)),
  5    63     (ADD init (1)),
  5    64     (SUBT init (2)),
  5    65     (MULT init (3)),
  5    66     (DIV init (4)),
  5    67     (LITERAL init (1)),
  5    68     (DATABASE init (2))) fixed bin int static options (constant);
  5    69 
  5    70 dcl  CFLTD59 bit (36) aligned int static options (constant)
  5    71      init ("100110000000000000000000000000111011"b);
  5    72 dcl  RFLTD59 bit (36) aligned int static options (constant)
  5    73      init ("100101000000000000000000000000111011"b);
  5    74 
  5    75 /* END INCLUDE FILE mrds_expressions.incl.pl1 */
  5    76 
      398 
      399 
  6     1 /* ***********************************************************
  6     2*   *                                                         *
  6     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
  6     4*   *                                                         *
  6     5*   *********************************************************** */
  6     6 /* BEGIN INCLUDE FILE - vu_typed_vector.incl.pl1 */
  6     7 
  6     8 /* Written by Lindsey Spratt, 04/02/82.
  6     9*Modified:
  6    10*09/01/82 by Lindsey Spratt:  Changed value_ptr in simple_typed_vector to be
  6    11*	  unaligned.  Changed the type number of the simple_typed_vector to
  6    12*	  "3" from "1".  The OLD_SIMPLE_TYPED_VECTOR_TYPE is now an invalid
  6    13*	  type.
  6    14**/
  6    15 
  6    16 /* format: style2,ind3 */
  6    17      dcl	   1 simple_typed_vector  based (simple_typed_vector_ptr),
  6    18 	     2 type	      fixed bin (17) unal,
  6    19 	     2 number_of_dimensions
  6    20 			      fixed bin (17) unal,
  6    21 	     2 dimension	      (stv_number_of_dimensions refer (simple_typed_vector.number_of_dimensions)),
  6    22 	       3 value_ptr	      ptr unaligned;
  6    23 
  6    24      dcl	   1 general_typed_vector based (general_typed_vector_ptr),
  6    25 	     2 type	      fixed bin (17) unal,
  6    26 	     2 number_of_dimensions
  6    27 			      fixed bin (17) unal,
  6    28 	     2 dimension	      (gtv_number_of_dimensions refer (general_typed_vector.number_of_dimensions)),
  6    29 	       3 identifier	      fixed bin (17) unal,
  6    30 	       3 pad	      bit (18) unal,
  6    31 	       3 value_ptr	      ptr unal;
  6    32 
  6    33      dcl	   simple_typed_vector_ptr
  6    34 			      ptr;
  6    35      dcl	   stv_number_of_dimensions
  6    36 			      fixed bin (17);
  6    37 
  6    38      dcl	   general_typed_vector_ptr
  6    39 			      ptr;
  6    40      dcl	   gtv_number_of_dimensions
  6    41 			      fixed bin (17);
  6    42 
  6    43      dcl	   (
  6    44 	   OLD_SIMPLE_TYPED_VECTOR_TYPE
  6    45 			      init (1),		/* value_ptr was aligned. */
  6    46 	   GENERAL_TYPED_VECTOR_TYPE
  6    47 			      init (2),
  6    48 	   SIMPLE_TYPED_VECTOR_TYPE
  6    49 			      init (3)
  6    50 	   )		      fixed bin (17) internal static options (constant);
  6    51 
  6    52 /* END INCLUDE FILE - vu_typed_vector.incl.pl1 */
      400 
      401 
      402      end mrds_dsl_eval_expr;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/85  0907.3  mrds_dsl_eval_expr.pl1            >special_ldd>online>mrds.pbf-04/18/85>mrds_dsl_eval_expr.pl1
390          1    10/14/83  1608.6  mdbm_descriptor.incl.pl1          >ldd>include>mdbm_descriptor.incl.pl1
392          2    10/14/83  1609.1  mdbm_rm_attr_info.incl.pl1        >ldd>include>mdbm_rm_attr_info.incl.pl1
394          3    10/14/83  1609.1  mdbm_rm_rel_info.incl.pl1         >ldd>include>mdbm_rm_rel_info.incl.pl1
396          4    10/14/83  1609.0  mrds_debug_names.incl.pl1         >ldd>include>mrds_debug_names.incl.pl1
398          5    10/14/83  1608.9  mrds_expressions.incl.pl1         >ldd>include>mrds_expressions.incl.pl1
400          6    10/14/83  1609.1  vu_typed_vector.incl.pl1          >ldd>include>vu_typed_vector.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CFLTD59                         000005 constant        bit(36)                  initial dcl 5-70 ref 110
CHAR_BIT                               constant        bit(1)                   initial unaligned dcl 355 ref 204
CMPX                            001074 constant        bit(1)                   initial unaligned dcl 355 ref 109 197 226 238 249
                                                                                  260
DATA                                   constant        fixed bin(17,0)          initial dcl 5-59 ref 99
DATABASE                               constant        fixed bin(17,0)          initial dcl 5-59 ref 100
OPERATOR                               constant        fixed bin(17,0)          initial dcl 5-59 ref 151
REAL                                   constant        bit(1)                   initial unaligned dcl 355 ref 200
RFLTD59                         000004 constant        bit(36)                  initial dcl 5-72 ref 116
SCAL_FUN                               constant        fixed bin(17,0)          initial dcl 5-59 ref 136
addr                                                   builtin function         dcl 368 ref 111 117 120 120 120 120 171 171 197 197
                                                                                  200 200 289 289
ai_ptr                   10            based           pointer                  array level 3 dcl 5-11 ref 287
area_ptr                               parameter       pointer                  dcl 332 set ref 18 18 83 137* 289*
assign_desc                     000100 automatic       bit(36)                  unaligned dcl 341 set ref 110* 116* 120 120
assn_ptr                  6            based           pointer                  array level 3 dcl 5-11 set ref 103* 120* 142* 154*
                                                                                  171* 226 232 238 244 249 255 260 266 289*
cd                                     parameter       fixed bin(35,0)          dcl 303 ref 298 305
cmpx_op                  26     000100 automatic       complex float dec(59)    array level 3 dcl 333 set ref 111
code                                   parameter       fixed bin(35,0)          dcl 363 set ref 18 18 164* 184* 305*
conversion                      000112 stack reference condition                dcl 370 ref 80
data_ptr                  4     000100 automatic       pointer                  array level 3 in structure "stack" dcl 333
                                                                                  in procedure "eval_expr" set ref 126* 226 226 232
                                                                                  232 238 238 244 244 249 249 255 255 260 260 266
                                                                                  266 328*
data_ptr                               parameter       pointer                  dcl 321 in procedure "increment_stack" ref 311 328
data_type                 2(08)        based           fixed bin(2,0)           array level 3 packed unaligned dcl 5-11 ref 100
db_mrds_dsl_eval_expr                  defined         bit(9)                   unaligned dcl 4-62 ref 77
defn_order               22            based           fixed bin(17,0)          level 2 dcl 2-46 ref 289
desc                      3            based           bit(36)                  array level 3 dcl 5-11 set ref 103 103 120 120 171
                                                                                  171 197 197 200 200 289 289
dimension                 1            based           structure                array level 2 packed unaligned dcl 6-17
display_intermed_expr           000101 automatic       bit(1)                   unaligned dcl 345 set ref 77* 166
expr                                   based           structure                level 1 dcl 5-11
expr_ptr                               parameter       pointer                  dcl 5-32 ref 18 18 85 92 99 100 103 103 103 103 120
                                                                                  120 120 136 137 142 151 154 171 171 171 171 171
                                                                                  171 197 197 200 200 224 226 232 238 244 249 255
                                                                                  260 266 287 289 289 289
fn_ptr                   12            based           pointer                  array level 3 dcl 5-11 set ref 137*
i                                      parameter       fixed bin(17,0)          dcl 193 in procedure "determine_result_type" ref 187
                                                                                  197 197 200 200
i                               000110 automatic       fixed bin(17,0)          dcl 361 in procedure "eval_expr" set ref 92* 99 100
                                                                                  100* 103 103* 103 120 120 120 125 136 137 142* 142
                                                                                  151 153* 154* 154*
icode                           000111 automatic       fixed bin(35,0)          dcl 363 set ref 120* 123 123* 137* 140 140* 289* 293
                                                                                  293*
ii                                     parameter       fixed bin(17,0)          dcl 285 ref 280 287 289 289 289
index                     2     000100 automatic       fixed bin(17,0)          array level 3 dcl 333 set ref 125* 327*
indx                                   parameter       fixed bin(17,0)          dcl 221 in procedure "process_op" ref 209 224 226
                                                                                  232 238 244 249 255 260 266
indx                                   parameter       fixed bin(17,0)          dcl 320 in procedure "increment_stack" ref 311 327
ioa_$nnl                        000010 constant        entry                    external dcl 372 ref 167
item                      2            based           structure                array level 2 dcl 5-11
mdb_display_data_value$ptr      000012 constant        entry                    external dcl 376 ref 171
mrds_data_$max_expr_stack_size  000026 external static fixed bin(35,0)          dcl 386 ref 323 333
mrds_debug_$switch              000034 external static bit(9)                   array unaligned dcl 4-135 ref 77 77
mrds_dsl_eval_func              000024 constant        entry                    external dcl 384 ref 137
mrds_error_$conversion_condition
                                000030 external static fixed bin(35,0)          dcl 387 ref 184
mrds_error_$expr_stack_ovfl     000032 external static fixed bin(35,0)          dcl 388 set ref 323*
mu_convert$convert_data         000016 constant        entry                    external dcl 381 ref 120
mu_data_class$complex_data_class
                                000014 constant        entry                    external dcl 380 ref 197
mu_data_class$real_data_class   000022 constant        entry                    external dcl 383 ref 200
mu_get_data$get_data_item       000020 constant        entry                    external dcl 382 ref 289
nitems                                 based           fixed bin(17,0)          level 2 dcl 5-11 set ref 85* 92 103 171 171 171
null                                                   builtin function         dcl 368 ref 2-65
num_dims                        000120 automatic       fixed bin(17,0)          initial dcl 1-20 set ref 78* 1-20*
op_cmpx                                based           complex float dec(59)    dcl 342 set ref 226* 226 226 238* 238 238 249* 249
                                                                                  249 260* 260 260
op_code                   2(04)        based           fixed bin(3,0)           array level 3 packed unaligned dcl 5-11 ref 224
op_ptr                          000104 automatic       pointer                  dcl 350 set ref 111* 117* 120* 126
op_real                                based           float dec(59)            dcl 343 set ref 232* 232 232 244* 244 244 255* 255
                                                                                  255 266* 266 266
operand                   2     000100 automatic       structure                array level 2 unaligned dcl 333
rai_ptr                         000122 automatic       pointer                  initial dcl 2-65 set ref 2-65* 287* 289* 289
real_op                   6     000100 automatic       float dec(59)            array level 3 dcl 333 set ref 117
result_type                     000102 automatic       bit(1)                   unaligned dcl 345 in procedure "eval_expr" set ref
                                                                                  109 153* 197* 200* 204*
result_type                            parameter       bit(1)                   unaligned dcl 222 in procedure "process_op" ref 209
                                                                                  226 238 249 260
rm_attr_info                           based           structure                level 1 dcl 2-46
rmri_ptr                               parameter       pointer                  dcl 3-156 set ref 18 18 137*
simple_typed_vector                    based           structure                level 1 packed unaligned dcl 6-17
simple_typed_vector_ptr                parameter       pointer                  dcl 6-33 set ref 18 18 137* 289
stack                           000100 automatic       structure                level 1 unaligned dcl 333
substr                                                 builtin function         dcl 368 ref 77
top_entry                       000100 automatic       fixed bin(17,0)          level 2 dcl 333 set ref 84* 108* 108 111 117 125 126
                                                                                  226 226 232 232 238 238 244 244 249 249 255 255
                                                                                  260 260 266 266 272* 272 323 326* 326 327 328
type                      2            based           fixed bin(3,0)           array level 3 packed unaligned dcl 5-11 ref 99 136
                                                                                  151
value_ptr                 1            based           pointer                  array level 3 packed unaligned dcl 6-17 ref 289
wa_ptr                          000106 automatic       pointer                  dcl 350 set ref 83*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ADD                                    internal static fixed bin(17,0)          initial dcl 5-59
DIV                                    internal static fixed bin(17,0)          initial dcl 5-59
EXPR                                   internal static fixed bin(17,0)          initial dcl 5-59
GENERAL_TYPED_VECTOR_TYPE              internal static fixed bin(17,0)          initial dcl 6-43
LITERAL                                internal static fixed bin(17,0)          initial dcl 5-59
MULT                                   internal static fixed bin(17,0)          initial dcl 5-59
OLD_SIMPLE_TYPED_VECTOR_TYPE           internal static fixed bin(17,0)          initial dcl 6-43
SIMPLE_TYPED_VECTOR_TYPE               internal static fixed bin(17,0)          initial dcl 6-43
SUBT                                   internal static fixed bin(17,0)          initial dcl 5-59
db_mrds_dsl_close                      defined         bit(9)                   unaligned dcl 4-62
db_mrds_dsl_gen_srch_prog              defined         bit(9)                   unaligned dcl 4-62
db_mrds_dsl_get_token                  defined         bit(9)                   unaligned dcl 4-62
db_mrds_dsl_init_res                   defined         bit(9)                   unaligned dcl 4-62
db_mrds_dsl_open                       defined         bit(9)                   unaligned dcl 4-62
db_mrds_dsl_optimize                   defined         bit(9)                   unaligned dcl 4-62
db_mrds_dsl_permute                    defined         bit(9)                   unaligned dcl 4-62
db_mrds_dsl_search                     defined         bit(9)                   unaligned dcl 4-62
db_mrds_dsl_set_fscope                 defined         bit(9)                   unaligned dcl 4-62
db_mrds_dsl_translate                  defined         bit(9)                   unaligned dcl 4-62
db_mrds_dsl_where_clause               defined         bit(9)                   unaligned dcl 4-62
db_mrds_rst_dmdm                       defined         bit(9)                   unaligned dcl 4-62
db_mu_concurrency_control              defined         bit(9)                   unaligned dcl 4-62
db_mu_open_iocb_manager                defined         bit(9)                   unaligned dcl 4-62
db_mu_open_name_manager                defined         bit(9)                   unaligned dcl 4-62
db_mu_retrieve                         defined         bit(9)                   unaligned dcl 4-62
db_mu_sec_get_tid                      defined         bit(9)                   unaligned dcl 4-62
db_mu_sec_get_tuple                    defined         bit(9)                   unaligned dcl 4-62
db_mu_sec_init_res                     defined         bit(9)                   unaligned dcl 4-62
db_mus_mod_ubtup                       defined         bit(9)                   unaligned dcl 4-62
desc_ptr                               automatic       pointer                  dcl 1-19
descriptor                             based           structure                level 1 unaligned dcl 1-6
general_typed_vector                   based           structure                level 1 packed unaligned dcl 6-24
general_typed_vector_ptr               automatic       pointer                  dcl 6-38
gtv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 6-40
module                                 internal static structure                level 1 unaligned dcl 4-91
natts_init                             automatic       fixed bin(17,0)          dcl 3-157
nexp_items_init                        automatic       fixed bin(17,0)          dcl 5-33
nkey_attr_init                         automatic       fixed bin(17,0)          dcl 3-157
nsf_args_init                          automatic       fixed bin(17,0)          dcl 5-57
nvar_atts_init                         automatic       fixed bin(17,0)          dcl 3-157
rm_rel_info                            based           structure                level 1 dcl 3-119
scalfn                                 based           structure                level 1 dcl 5-35
sfn_ptr                                automatic       pointer                  dcl 5-56
stv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 6-35

NAMES DECLARED BY EXPLICIT CONTEXT.
case                            000000 constant        label                    array(4) dcl 226 ref 224
conversion_error                000425 constant        label                    dcl 182 ref 80
determine_result_type           000433 constant        entry                    internal dcl 187 ref 85
error                           001013 constant        entry                    internal dcl 298 ref 123 140 293 323
eval_expr                       000050 constant        entry                    external dcl 18
exit                            000424 constant        label                    dcl 178 in procedure "eval_expr" set ref 185 306
exit                            000735 constant        label                    dcl 272 in procedure "process_op" ref 235 247 258
                                                                                  269
get_db_item                     000740 constant        entry                    internal dcl 280 ref 100
increment_stack                 001021 constant        entry                    internal dcl 311 ref 103 142 154
mrds_dsl_eval_expr              000061 constant        entry                    external dcl 18
process_op                      000515 constant        entry                    internal dcl 209 ref 153

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1306        1344    1075        1316
Length      1666    1075        36         306     210           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
eval_expr                           239 external procedure  is an external procedure.  
on unit on line 80                   64 on unit               
determine_result_type                   internal procedure  shares stack frame of external procedure eval_expr.  
process_op                              internal procedure  shares stack frame of external procedure eval_expr.  
get_db_item                             internal procedure  shares stack frame of external procedure eval_expr.  
error                                   internal procedure  shares stack frame of external procedure eval_expr.  
increment_stack                         internal procedure  shares stack frame of external procedure eval_expr.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
eval_expr                000100 assign_desc                 eval_expr
                         000100 stack                       eval_expr
                         000101 display_intermed_expr       eval_expr
                         000102 result_type                 eval_expr
                         000104 op_ptr                      eval_expr
                         000106 wa_ptr                      eval_expr
                         000110 i                           eval_expr
                         000111 icode                       eval_expr
                         000120 num_dims                    eval_expr
                         000122 rai_ptr                     eval_expr

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              tra_ext             alloc_auto_adj      enable
ext_entry           int_entry           mpcdec              dvcdec

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ioa_$nnl                      mdb_display_data_value$ptr    mrds_dsl_eval_func            mu_convert$convert_data
mu_data_class$complex_data_class                            mu_data_class$real_data_class mu_get_data$get_data_item

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
mrds_data_$max_expr_stack_size                              mrds_debug_$switch
mrds_error_$conversion_condition                            mrds_error_$expr_stack_ovfl




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    333 000027    1   20 000036    2   65 000037        18 000043        77 000067        78 000073        80 000074
     83 000113        84 000117        85 000120        92 000127        99 000141       100 000153       103 000163
    108 000210       109 000211       110 000215       111 000217       113 000225       116 000226       117 000230
    120 000235       123 000260       125 000264       126 000272       130 000274       136 000275       137 000277
    140 000317       142 000323       147 000340       151 000341       153 000343       154 000345       161 000362
    164 000364       166 000366       167 000370       171 000404       178 000424       182 000425       184 000426
    185 000432       187 000433       197 000435       200 000463       204 000512       207 000514       209 000515
    224 000517       226 000531       232 000557       235 000573       238 000574       244 000622       247 000636
    249 000637       255 000660       258 000674       260 000675       266 000716       269 000734       272 000735
    277 000737       280 000740       287 000742       289 000751       293 001006       296 001012       298 001013
    305 001015       306 001020       311 001021       323 001023       326 001035       327 001036       328 001045
    330 001050


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
