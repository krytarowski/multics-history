	COMPILATION LISTING OF SEGMENT le_emit_text_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 12/10/86  1254.5 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1986 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 /****^  HISTORY COMMENTS:
        8*  1) change(86-08-12,Elhard), approve(86-08-12,MCR7505),
        9*     audit(86-12-10,DGHowe), install(86-12-10,MR12.0-1241):
       10*     Originally written to relocate and emit the text section of a single input
       11*     component.
       12*                                                   END HISTORY COMMENTS */
       13 
       14 /* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       15 
       16 le_emit_text_:
       17   proc (ocudp,			/** ocu_data pointer    (in )	*/
       18        lecp,			/** components pointer  (i/o) */
       19        c);			/** component index	    (in ) */
       20 
       21   /*** ****************************************************************/
       22   /***							*/
       23   /***	Name:	le_emit_text_				*/
       24   /***	Input:	ocudp, lecp, c				*/
       25   /***	Function:	emits the text section of the given input	*/
       26   /***		component and relocates references.		*/
       27   /***	Output:	lecp					*/
       28   /***							*/
       29   /*** ****************************************************************/
       30 
       31   /* constants */
       32 
       33   dcl true		bit (1) static options (constant) init ("1"b);
       34   dcl false		bit (1) static options (constant) init ("0"b);
       35   dcl Left		fixed bin static options (constant) init (1);
       36   dcl Right		fixed bin static options (constant) init (2);
       37   dcl Section_Rel_15	(0:4) char (1) static options (constant)
       38 			init ("t", "l", "a", "d", "i");
       39   dcl special_case		(1:4) bit (18) static options (constant)
       40 			init ("551"b3, "552"b3, "751"b3, "752"b3);
       41   dcl special_case_name	(1:4) char (4) static options (constant)
       42 			init ("stba", "stbq", "stca", "stcq");
       43   dcl Indirect_and_Tally	bit (2) static options (constant) init ("10"b);
       44   dcl Indirect_then_Register	bit (2) static options (constant) init ("11"b);
       45 
       46   /* parameters */
       47 
       48   dcl ocudp		ptr parameter;
       49   dcl lecp		ptr parameter;
       50   dcl c			fixed bin parameter;
       51 
       52   /* procedures */
       53 
       54   dcl le_backpatch_		entry (fixed bin, fixed bin, uns fixed bin (18),
       55 			fixed bin, fixed bin);
       56   dcl le_error_		entry options (variable);
       57   dcl le_snap_		entry (ptr, ptr, fixed bin, fixed bin (3),
       58 			uns fixed bin (18), uns fixed bin (18), bit (1),
       59 			fixed bin (3), uns fixed bin (18), bit (6),
       60 			bit (1));
       61   dcl le_util_$scan_relinfo	entry (ptr, fixed bin, bit (1), fixed bin,
       62 			char (*));
       63 
       64   /* external */
       65 
       66   dcl le_et_$bad_def_reference
       67 			external fixed bin (35);
       68   dcl le_et_$bad_instr_format external fixed bin (35);
       69   dcl le_et_$implementation_error
       70 			external fixed bin (35);
       71   dcl le_et_$invalid_relinfo	external fixed bin (35);
       72 
       73   /* based */
       74 
       75   dcl 01 lec		aligned based (lecp),
       76        02 header		aligned like le_components.header,
       77        02 comp		dim (0 refer (lec.n_components)) like le_comp;
       78   dcl 01 led		aligned based (ledp),
       79        02 header		aligned like le_definitions.header,
       80        02 def		dim (0 refer (led.n_defs)) like le_definition;
       81   dcl 01 lel		aligned based (lelp),
       82        02 header		aligned like le_links.header,
       83        02 link		dim (0 refer (lel.n_links)) like le_link;
       84   dcl 01 word15		aligned based (addr (instr)),
       85        02 halfword		(1:2) unaligned,
       86         03 pad		bit (3),
       87         03 side		fixed bin (15) unsigned;
       88   dcl 01 word18		aligned based (addr (instr)),
       89        02 side		(1:2) fixed bin (18) unsigned unaligned;
       90 
       91   /* automatic */
       92 
       93   dcl abort		bit (1) automatic;
       94   dcl d			fixed bin automatic;
       95   dcl found		bit (1) automatic;
       96   dcl initial_relp		fixed bin (19) automatic;
       97   dcl 01 instr		aligned automatic,
       98        02 pr		fixed bin (3) unsigned unaligned,
       99        02 offset		fixed bin (15) unsigned unaligned,
      100        02 op_code		bit (9) unaligned,
      101        02 extension		bit (1) unaligned,
      102        02 inhibit		bit (1) unaligned,
      103        02 use_pr		bit (1) unaligned,
      104        02 modifier		bit (6) unaligned;
      105   dcl internal		bit (1) automatic;
      106   dcl ledp		ptr automatic;
      107   dcl lelp		ptr automatic;
      108   dcl lx			fixed bin automatic;
      109   dcl modifier		bit (6) automatic;
      110   dcl n_words		fixed bin automatic;
      111   dcl odd			bit (1) automatic;
      112   dcl pad			(1:16) bit (36) aligned automatic;
      113   dcl rel			char (2) automatic;
      114   dcl rel_char		char (1) automatic;
      115   dcl relindex		fixed bin automatic;
      116   dcl relinfop		ptr automatic;
      117   dcl relp		fixed bin (18) unsigned automatic;
      118   dcl relstr		char (4096) automatic;
      119   dcl s			fixed bin automatic;
      120   dcl sc			fixed bin automatic;
      121   dcl section		fixed bin (3) automatic;
      122   dcl size		fixed bin (18) unsigned automatic;
      123   dcl skip		fixed bin automatic;
      124   dcl stat_relp		fixed bin (18) unsigned automatic;
      125   dcl symb_relp		fixed bin (18) unsigned automatic;
      126   dcl td			bit (4) automatic;
      127   dcl text_relp		fixed bin (18) unsigned automatic;
      128   dcl textp		ptr automatic;
      129   dcl tm			bit (2) automatic;
      130   dcl value		fixed bin (35) automatic;
      131 
      132   /* builtin */
      133 
      134   dcl addr		builtin;
      135   dcl addrel		builtin;
      136   dcl bin			builtin;
      137   dcl copy		builtin;
      138   dcl hbound		builtin;
      139   dcl min			builtin;
      140   dcl substr		builtin;
      141   dcl unspec		builtin;
      142 
      143   textp = lec.comp (c).orig.textp;
      144   relinfop = lec.comp (c).orig.rel_textp;
      145   relindex = 1;
      146   odd = false;
      147   initial_relp = -1;
      148 
      149   /* extract the relocation counters */
      150 
      151   text_relp = lec.comp (c).new.rel_text;
      152   symb_relp = lec.comp (c).new.rel_symb;
      153   stat_relp = lec.comp (c).new.rel_stat;
      154 
      155   /* emit pad words to align the text section */
      156 
      157   n_words = lec.comp (c).new.text_pad;
      158   unspec (pad) = ""b;
      159 
      160   do while (n_words > 0);
      161     size = min (hbound (pad, 1), n_words);
      162     substr (relstr, 1, size+size) = copy ("aa", size);
      163     relp = ocu_$emit_text (ocudp, addr (pad), addr (relstr), size);
      164     n_words = n_words - size;
      165   end;
      166 
      167   n_words = 0;
      168 
      169   do while (n_words < lec.comp (c).orig.textl);
      170 
      171     /* find the next word containing non-absolute relinfo */
      172 
      173     call le_util_$scan_relinfo (relinfop, relindex, odd, skip, rel);
      174 
      175     /* emit the intervening text words with absolute relocation */
      176 
      177     do while (skip > 0);
      178       size = min (skip, 2048);
      179       substr (relstr, 1, size+size) = copy ("aa", size);
      180       relp = ocu_$emit_text (ocudp, textp, addr (relstr), size);
      181       if initial_relp < 0
      182         then initial_relp = relp;
      183       textp = addrel (textp, size);
      184       skip = skip - size;
      185       n_words = n_words + size;
      186     end;
      187 
      188     /* copy the word to be relocated */
      189 
      190     unspec (instr) = unspec (textp -> word18);
      191 
      192     do s = Left to Right while (n_words < lec.comp (c).orig.textl);
      193 
      194       /* for each side of the non-absolute word */
      195 
      196       rel_char = substr (rel, s, 1);
      197 
      198       if rel_char = "a" | rel_char = "r"
      199         then ;			/* no relocation required	*/
      200 
      201       else if rel_char = "t" | rel_char = "1"
      202         then do;			/* text relative reference	*/
      203 	value = word18.side (s) + text_relp;
      204 	word18.side (s) = addr (value) -> word18.side (Right);
      205         end;
      206 
      207       else if rel_char = "2" | rel_char = "3"
      208         then do;
      209 
      210 	/* link reference, snap the link and then adjust the	*/
      211 	/* reference					*/
      212 
      213 	value = word18.side (s);
      214 	call le_snap_ (ocudp, lecp, c, Text, (n_words), (value), true,
      215 	     section, relp, modifier, internal);
      216 	word18.side (s) = relp;
      217         end;
      218 
      219       else if rel_char = "l"
      220         then do;
      221 
      222 	/* standard pointer register link reference */
      223 
      224 	value = word15.side (s);
      225 	abort = false;
      226 
      227 	if s ^= Left
      228 	  then do;
      229 
      230 	    /* link 15 relocation is only allowed in the left halfword */
      231 
      232 	    call le_error_ (LE_FATAL_ERROR, le_et_$invalid_relinfo,
      233 	         "^/Relocation code ""link 15"" is invalid in the right" ||
      234 	         "^/halfword ^o of text|^o in ^a.", value, n_words,
      235 	         lec.comp (c).name);
      236 	    abort = true;
      237 	  end;
      238 
      239 	if instr.use_pr = false & ^abort
      240 	  then do;
      241 	    call le_error_ (LE_FATAL_ERROR, le_et_$bad_instr_format,
      242 	         "^/Invalid instruction format at text|^o in ^a.",
      243 	         n_words, lec.comp (c).name);
      244 	    abort = true;
      245 	  end;
      246 
      247 	do sc = 1 to 4 while (^abort);
      248 	  if instr.op_code = special_case (sc)
      249 	    then do;
      250 	      call le_error_ (LE_FATAL_ERROR, le_et_$bad_instr_format,
      251 		 "^/Invalid op_code (^a) for link ref at text|^o in ^a.",
      252 		 special_case_name (sc), n_words, lec.comp (c).name);
      253 	      abort = true;
      254 	    end;
      255 	end;
      256 
      257 	tm = substr (instr.modifier, 1, 2);
      258 	td = substr (instr.modifier, 3, 4);
      259 
      260 	if ^abort & ((tm = Indirect_and_Tally) |
      261 	     (tm ^= Indirect_then_Register & td ^= ""b))
      262 	  then do;
      263 
      264 	    call le_error_ (LE_FATAL_ERROR, le_et_$bad_instr_format,
      265 	         "^/Invalid modifier ^o for link ref at text|^o of ^a.",
      266 	         bin (tm || td), n_words, lec.comp (c).name);
      267 	    abort = true;
      268 	  end;
      269 
      270 	if ^abort
      271 	  then do;
      272 	    call le_snap_ (ocudp, lecp, c, Text, (n_words), (value), false,
      273 	         section, relp, modifier, internal);
      274 
      275 	    /* patch the returned offset */
      276 
      277 	    if section = Static | section = Linkage
      278 	      then word15.side (s) = relp;
      279 	      else do;
      280 	        word18.side (s) = relp;
      281 	        instr.use_pr = false;
      282 	      end;
      283 
      284 	    /* schedule a backpatch since we don't know where the	*/
      285 	    /* symbol section will be placed			*/
      286 
      287 	    if section = Symbol
      288 	      then call le_backpatch_ (Patch_Symbol_Ref,
      289 		      lec.comp (c).target, n_words +
      290 		      lec.comp (c).new.rel_text, s, 0);
      291 
      292 	    /* remove the indirection modifier if the link was	*/
      293 	    /* resolved internally.				*/
      294 
      295 	    if internal
      296 	      then if modifier = ""b
      297 		   then substr (instr.modifier, 1, 2) = ""b;
      298 		   else instr.modifier = modifier;
      299 
      300 	    /* convert the relocation info */
      301 
      302 	    substr (rel, s, 1) = Section_Rel_15 (section);
      303 	  end;
      304         end;
      305 
      306       else if rel_char = "d"
      307         then do;
      308 
      309 	/* look for a definition that this points to */
      310 
      311 	ledp = lec.comp (c).tables.ledp;
      312 	value = word18.side (s);
      313 
      314 	found = false;
      315 
      316 	/* scan the definition list */
      317 
      318 	do d = 1 to led.n_defs while (^found);
      319 	  if value = led.def (d).offset
      320 	    then do;
      321 	      word18.side (s) = led.def (d).new_offset;
      322 	      found = true;
      323 	    end;
      324 	end;
      325 
      326 	if ^found
      327 	  then call le_error_ (LE_FATAL_ERROR, le_et_$bad_def_reference,
      328 		  "^/Reference to definition|^o at text|^o in ^a.",
      329 		  value, n_words, lec.comp (c).name);
      330         end;
      331 
      332       /* symbol reference */
      333 
      334       else if rel_char = "s" | rel_char = "7"
      335         then do;
      336 	value = word18.side (s) + symb_relp;
      337 	word18.side (s) = addr (value) -> word18.side (Right);
      338         end;
      339 
      340       /* 18 bit static reference */
      341 
      342       else if rel_char = "8"
      343         then do;
      344 	if ^lec.comp (c).flags.separate_static
      345 	  then word18.side (s) = word18.side (s) + stat_relp - 8;
      346 	  else word18.side (s) = word18.side (s) + stat_relp;
      347         end;
      348 
      349       /* normal 15 bit static reference */
      350 
      351       else if rel_char = "i"
      352         then do;
      353 
      354 	/* must be in the left halfword */
      355 
      356 	if s ^= Left
      357 	  then do;
      358 	    call le_error_ (LE_FATAL_ERROR, le_et_$invalid_relinfo,
      359 	         "^/Relocation code ""static 15"" is invalid in the" ||
      360 	         "^/right halfword ^o of text|^o of ^a.",
      361 	         word15.side (s), n_words, lec.comp (c).name);
      362 	  end;
      363 	  else do;
      364 	    if ^lec.comp (c).flags.separate_static
      365 	      then word15.side (s) = word15.side (s) + stat_relp - 8;
      366 	      else word15.side (s) = word15.side (s) + stat_relp;
      367 	  end;
      368         end;
      369       else call le_error_ (LE_ABORT_ERROR, le_et_$invalid_relinfo, "");
      370     end;
      371 
      372     /* if we are not off the end, then emit the word */
      373 
      374     if n_words < lec.comp (c).orig.textl
      375       then do;
      376         relp = ocu_$emit_text (ocudp, addr (instr), addr (rel), 1);
      377         if initial_relp < 0
      378 	then initial_relp = relp;
      379         textp = addrel (textp, 1);
      380         n_words = n_words + 1;
      381       end;
      382   end;
      383 
      384   /* make sure the section started at the offset we calculated earlier */
      385 
      386   if initial_relp ^= lec.comp (c).new.rel_text & initial_relp >= 0
      387     then call le_error_ (LE_ABORT_ERROR, le_et_$implementation_error,
      388 	    "^/Text for ^a relocated to ^d instead of ^d as expected.",
      389 	    lec.comp (c).name, initial_relp, lec.comp (c).new.rel_text);
      390 
      391   /* make a pass down the link table and forcibly emit any *system	*/
      392   /* or *heap links which are the target link of a deferred_init	*/
      393   /* group to make sure there is something at the end of the chain	*/
      394 
      395   lelp = lec.comp (c).tables.lelp;
      396 
      397   do lx = 1 to lel.n_links;
      398     if lel.link (lx).target_comp = c & lel.link (lx).target_link = lx &
      399          lel.link (lx).type = Self_Offsetname
      400       then call le_snap_ (ocudp, lecp, c, Text, 0,
      401 	      lel.offset_adjustment + 2 * lx,
      402 	      false, section, relp, modifier, internal);
      403   end;
      404 
      405   return;
      406 
      407 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      408 
      409 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      410 
      411 
  1     1 /****  START OF:	le_data.incl.pl1			 *  *  *  *  *  */
  1     2 
  1     3 /****^  HISTORY COMMENTS:
  1     4*  1) change(86-08-12,Elhard), approve(86-08-12,MCR7505),
  1     5*     audit(86-12-10,DGHowe), install(86-12-10,MR12.0-1241):
  1     6*     Originally written to define the structures used internally by le_.
  1     7*                                                   END HISTORY COMMENTS */
  1     8 
  1     9   /*** ****************************************************************/
  1    10   /***							*/
  1    11   /***	Name:	le_data					*/
  1    12   /***	Function:	This include file defines the data structures	*/
  1    13   /***		used internally by the linkage_editor subroutine.	*/
  1    14   /***							*/
  1    15   /*** ****************************************************************/
  1    16   
  1    17   /* error severity constants */
  1    18   
  1    19   dcl LE_WARNING		fixed bin static options (constant) init (1);
  1    20   dcl LE_ERROR		fixed bin static options (constant) init (2);
  1    21   dcl LE_FATAL_ERROR	fixed bin static options (constant) init (3);
  1    22   dcl LE_ABORT_ERROR	fixed bin static options (constant) init (4);
  1    23   
  1    24   /* section identifier constants */
  1    25   
  1    26   dcl Text		fixed bin (3) static options (constant)
  1    27 			init (0);
  1    28   dcl Linkage		fixed bin (3) static options (constant)
  1    29 			init (1);
  1    30   dcl Symbol		fixed bin (3) static options (constant)
  1    31 			init (2);
  1    32   dcl Definition		fixed bin (3) static options (constant)
  1    33 			init (3);
  1    34   dcl Static		fixed bin (3) static options (constant)
  1    35 			init (4);
  1    36   dcl System		fixed bin (3) static options (constant)
  1    37 			init (5);
  1    38   dcl Heap		fixed bin (3) static options (constant)
  1    39 			init (6);
  1    40   
  1    41   dcl section_nm		(0:6) char (16) static options (constant)
  1    42 			init ("text", "linkage", "symbol", "definition",
  1    43 			"static", "system", "heap");
  1    44   
  1    45   /* link type constants */
  1    46   
  1    47   dcl Self_Base		fixed bin (3) static options (constant)
  1    48 			init (1);
  1    49   dcl Refname_Base		fixed bin (3) static options (constant)
  1    50 			init (3);
  1    51   dcl Refname_Offsetname	fixed bin (3) static options (constant)
  1    52 			init (4);
  1    53   dcl Self_Offsetname	fixed bin (3) static options (constant)
  1    54 			init (5);
  1    55   
  1    56   /* backpatch type constants */
  1    57   
  1    58   dcl Patch_Link		fixed bin static options (constant) init (1);
  1    59   dcl Patch_Init		fixed bin static options (constant) init (2);
  1    60   dcl Patch_Symbol_Ref	fixed bin static options (constant) init (3);
  1    61   dcl Patch_Self_Init	fixed bin static options (constant) init (4);
  1    62   
  1    63   /*** ****************************************************************/
  1    64   /***							*/
  1    65   /***	Name:	le_components				*/
  1    66   /***	Function:	the component table is used to keep information	*/
  1    67   /***		about the input components being used and their	*/
  1    68   /***		disposition in output components.		*/
  1    69   /***							*/
  1    70   /*** ****************************************************************/
  1    71   
  1    72   dcl 01 le_components	aligned based,
  1    73        02 header		aligned,
  1    74         03 flags		aligned,
  1    75          04 separate_static	bit (1) unaligned,
  1    76          04 perprocess_static	bit (1) unaligned,
  1    77          04 mbz		bit (34) unaligned,
  1    78         03 n_components	fixed bin,
  1    79        02 comp		(0 refer (le_components.n_components))
  1    80 			like le_comp;
  1    81   
  1    82   /*** ****************************************************************/
  1    83   /***							*/
  1    84   /***	Name:	le_comp					*/
  1    85   /***	Function:	this is a single component table entry.		*/
  1    86   /***							*/
  1    87   /*** ****************************************************************/
  1    88   
  1    89   dcl 01 le_comp		aligned based,
  1    90        02 segp		ptr,
  1    91        02 bc		fixed bin (24),
  1    92        02 uid		bit (36) aligned,
  1    93        02 dtcm		fixed bin (71),
  1    94        02 name		char (32) varying,
  1    95        02 path		char (194) varying,
  1    96        02 compiler		char (8),
  1    97        02 target		fixed bin,
  1    98        02 flags		aligned,
  1    99         03 library		bit (1) unaligned,
  1   100         03 include		bit (1) unaligned,
  1   101         03 delete_table	bit (1) unaligned,
  1   102         03 separate_static	bit (1) unaligned,
  1   103         03 io_table		bit (1) unaligned,
  1   104         03 unique_path	bit (1) unaligned,
  1   105         03 mbz		bit (30) unaligned,
  1   106        02 tables		aligned,
  1   107         03 lesp		ptr,
  1   108         03 ledp		ptr,
  1   109         03 lelp		ptr,
  1   110        02 orig		aligned,
  1   111         03 textp		ptr,
  1   112         03 defnp		ptr,
  1   113         03 linkp		ptr,
  1   114         03 statp		ptr,
  1   115         03 symbp		ptr,
  1   116         03 rel_textp	ptr,
  1   117         03 rel_symbp	ptr,
  1   118         03 rel_linkp	ptr,
  1   119         03 textl		fixed bin (18) unsigned unaligned,
  1   120         03 defnl		fixed bin (18) unsigned unaligned,
  1   121         03 linkl		fixed bin (18) unsigned unaligned,
  1   122         03 statl		fixed bin (18) unsigned unaligned,
  1   123         03 symbl		fixed bin (18) unsigned unaligned,
  1   124         03 symbl_no_rel	fixed bin (18) unsigned unaligned,
  1   125         03 symbl_no_table	fixed bin (18) unsigned unaligned,
  1   126         03 n_symb_blocks	fixed bin (18) unsigned unaligned,
  1   127         03 text_boundary	fixed bin (9) unsigned unaligned,
  1   128         03 static_boundary	fixed bin (9) unsigned unaligned,
  1   129         03 next_comp	fixed bin (18) unsigned unaligned,
  1   130        02 new		aligned,
  1   131         03 rel_text		fixed bin (18) unsigned unaligned,
  1   132         03 rel_symb		fixed bin (18) unsigned unaligned,
  1   133         03 rel_stat		fixed bin (18) unsigned unaligned,
  1   134         03 text_pad		fixed bin (18) unsigned unaligned,
  1   135         03 static_pad	fixed bin (18) unsigned unaligned,
  1   136         03 symbol_pad	fixed bin (18) unsigned unaligned;
  1   137   
  1   138   /*** ****************************************************************/
  1   139   /***							*/
  1   140   /***	Name:	le_segnames				*/
  1   141   /***	Function:	the segname table is used for two purposes:	*/
  1   142   /***		 - to determine the target components of links	*/
  1   143   /***		   being resolved internally.			*/
  1   144   /***		 - to determine the segname definitions to be	*/
  1   145   /***		   emited for definitions being retained.	*/
  1   146   /***							*/
  1   147   /*** ****************************************************************/
  1   148   
  1   149   dcl 01 le_segnames	aligned based,
  1   150        02 header		aligned,
  1   151         03 n_segnames	fixed bin,
  1   152        02 segname		(segname_count refer (le_segnames.n_segnames)),
  1   153         03 str		char (32) varying,
  1   154         03 relp		fixed bin (18) unsigned unaligned,
  1   155         03 pad		bit (18) unaligned;
  1   156   dcl segname_count		fixed bin automatic;
  1   157   
  1   158   /*** ****************************************************************/
  1   159   /***							*/
  1   160   /***	Name:	le_definitions				*/
  1   161   /***	Function:	the definition table contains the definitions	*/
  1   162   /***		from the input components and is used to resolve	*/
  1   163   /***		link targets, and regenerate definition entries	*/
  1   164   /***							*/
  1   165   /*** ****************************************************************/
  1   166   
  1   167   dcl 01 le_definitions	aligned based,
  1   168        02 header		aligned,
  1   169         03 n_defs		fixed bin,
  1   170         03 pad		bit (36),
  1   171        02 def		(def_count refer (le_definitions.n_defs))
  1   172 			like le_definition;
  1   173   dcl def_count		fixed bin automatic;
  1   174   
  1   175   dcl 01 le_definition	aligned based,
  1   176        02 str		char (256) varying,
  1   177        02 type		fixed bin (18) unsigned unaligned,
  1   178        02 relp		fixed bin (18) unsigned unaligned,
  1   179        02 offset		fixed bin (18) unsigned unaligned,
  1   180        02 new_offset	fixed bin (18) unsigned unaligned,
  1   181        02 flags		aligned,
  1   182         03 force_retain	bit (1) unaligned,
  1   183         03 entrypoint	bit (1) unaligned,
  1   184         03 ignore		bit (1) unaligned,
  1   185         03 referenced	bit (1) unaligned,
  1   186         03 no_link		bit (1) unaligned,
  1   187         03 retain		bit (1) unaligned,
  1   188         03 delete		bit (1) unaligned,
  1   189         03 mbz		bit (29) unaligned;
  1   190   
  1   191   /*** ****************************************************************/
  1   192   /***							*/
  1   193   /***	Name:	le_options				*/
  1   194   /***	Function:	the option table contains definition retention	*/
  1   195   /***		information.  The input retentions options are	*/
  1   196   /***		ordered such that a linear search of the option	*/
  1   197   /***		table for the first matching starname will give	*/
  1   198   /***		the correct retention state.			*/
  1   199   /***							*/
  1   200   /*** ****************************************************************/
  1   201   
  1   202   dcl 01 le_options		aligned based,
  1   203        02 header		aligned,
  1   204         03 n_opts		fixed bin,
  1   205        02 opt		(0 refer (le_options.n_opts)),
  1   206         03 type		fixed bin (8) unaligned,
  1   207         03 used		bit (1) unaligned,
  1   208         03 inhibit_error	bit (1) unaligned,
  1   209         03 class		fixed bin (6) unaligned,
  1   210         03 order		fixed bin (17) unaligned,
  1   211         03 segname		char (32) unaligned,
  1   212         03 ep_name		char (256) unaligned;
  1   213   
  1   214   /*** ****************************************************************/
  1   215   /***							*/
  1   216   /***	Name:	le_links					*/
  1   217   /***	Function:	the link table contains information on all of the	*/
  1   218   /***		links in the input components. It is used to	*/
  1   219   /***		determine link targets, which library components	*/
  1   220   /***		will be included, and what init_info will be	*/
  1   221   /***		used, and where it will be placed.		*/
  1   222   /***							*/
  1   223   /*** ****************************************************************/
  1   224   
  1   225   dcl 01 le_links		aligned based,
  1   226        02 header		aligned,
  1   227         03 offset_adjustment	fixed bin (18),
  1   228         03 n_links		fixed bin,
  1   229        02 link		(link_count refer (le_links.n_links))
  1   230 			like le_link;
  1   231   dcl link_count		fixed bin automatic;
  1   232 
  1   233   dcl 01 le_link		aligned based,
  1   234        02 flags		unaligned,
  1   235         03 used		bit (1),
  1   236         03 mbx		bit (35),
  1   237        02 type		fixed bin (6) unsigned unaligned,
  1   238        02 class		fixed bin (6) unsigned unaligned,
  1   239        02 mod		bit (6) unaligned,
  1   240        02 exp		fixed bin (17) unaligned,
  1   241        02 target		fixed bin (18) unsigned unaligned,
  1   242        02 defx		fixed bin (18) unsigned unaligned,
  1   243        02 relp		fixed bin (18) unsigned unaligned,
  1   244        02 target_comp	fixed bin (18) unsigned unaligned,
  1   245        02 target_link	fixed bin (18) unsigned unaligned,
  1   246        02 extension		fixed bin (18) unsigned unaligned,
  1   247        02 initp		ptr unaligned,
  1   248        02 segnamep		ptr unaligned,
  1   249        02 offsetp		ptr unaligned;
  1   250   
  1   251   /*** ****************************************************************/
  1   252   /***							*/
  1   253   /***	Name:	le_binaries				*/
  1   254   /***	Function:	This table contains information about the output	*/
  1   255   /***		binaries.  It is primarily used for creation and	*/
  1   256   /***		backpatching of MSF output.			*/
  1   257   /***							*/
  1   258   /*** ****************************************************************/
  1   259   
  1   260   dcl 01 le_binaries	aligned based,
  1   261        02 header		aligned,
  1   262         03 n_binaries	fixed bin,
  1   263         03 pad		bit (36),
  1   264        02 binary		(0:0 refer (le_binaries.n_binaries)),
  1   265         03 segp		ptr,
  1   266         03 bc		fixed bin (24),
  1   267         03 uid		bit (36),
  1   268         03 aclc		fixed bin,
  1   269         03 aclp		ptr,
  1   270         03 textp		ptr,
  1   271         03 defnp		ptr,
  1   272         03 linkp		ptr,
  1   273         03 symbp		ptr,
  1   274         03 statp		ptr,
  1   275         03 textl		fixed bin (18) unsigned unaligned,
  1   276         03 defnl		fixed bin (18) unsigned unaligned,
  1   277         03 linkl		fixed bin (18) unsigned unaligned,
  1   278         03 symbl		fixed bin (18) unsigned unaligned,
  1   279         03 statl		fixed bin (18) unsigned unaligned,
  1   280         03 mbz2		bit (18) unaligned;
  1   281   
  1   282   /*** ****************************************************************/
  1   283   /***							*/
  1   284   /***	Name:	le_patches				*/
  1   285   /***	Function:	This table contains the list of backpatches to be	*/
  1   286   /***		performed when the rest of the object creation is	*/
  1   287   /***		complete. Since le_backpatch_ is the only routine	*/
  1   288   /***		concerned with this,  it is maintained completely	*/
  1   289   /***		internal to le_backpatch_.			*/
  1   290   /***							*/
  1   291   /*** ****************************************************************/
  1   292   
  1   293   dcl 01 le_patches		aligned based,
  1   294        02 header		aligned,
  1   295         03 n_patches	fixed bin,
  1   296        02 patch		(0 refer (le_patches.n_patches)) like le_patch;
  1   297        
  1   298   dcl 01 le_patch		aligned based,
  1   299        02 type		fixed bin,
  1   300        02 comp		fixed bin,
  1   301        02 relp		fixed bin (18) unsigned,
  1   302        02 target		fixed bin,
  1   303        02 index		fixed bin;
  1   304   
  1   305 /****  END OF:	le_data.incl.pl1			 *  *  *  *  *  */
      412 
  2     1 /*  START OF:	ocu_dcls.incl.pl1			 *  *  *  *  *  */
  2     2 
  2     3 /****^  HISTORY COMMENTS:
  2     4*  1) change(86-08-12,Elhard), approve(86-08-12,MCR7505),
  2     5*     audit(86-12-10,DGHowe), install(86-12-10,MR12.0-1241):
  2     6*     Originally written to define the subroutines and data structures used by
  2     7*     callers of ocu_.
  2     8*                                                   END HISTORY COMMENTS */
  2     9 
  2    10   /*** ****************************************************************/
  2    11   /***							*/
  2    12   /***	Name:	ocu_dcls					*/
  2    13   /***	Function: These are the entrypoints and structures required	*/
  2    14   /***		to use the ocu_ object creation utilities.	*/
  2    15   /***							*/
  2    16   /*** ****************************************************************/
  2    17   
  2    18   /* open option flags */
  2    19   
  2    20   dcl OPEN_FLAGS_BOUND	bit (6) static options (constant)
  2    21 			init ("100000"b);
  2    22   dcl OPEN_FLAGS_RELOCATABLE	bit (6) static options (constant)
  2    23 			init ("010000"b);
  2    24   dcl OPEN_FLAGS_PROCEDURE	bit (6) static options (constant)
  2    25 			init ("001000"b);
  2    26   dcl OPEN_FLAGS_SEPARATE_STATIC
  2    27 			bit (6) static options (constant)
  2    28 			init ("000100"b);
  2    29   dcl OPEN_FLAGS_PERPROCESS_STATIC
  2    30 			bit (6) static options (constant)
  2    31 			init ("000010"b);
  2    32   dcl OPEN_FLAGS_NO_HASHTABLE bit (6) static options (constant)
  2    33 			init ("000001"b);
  2    34 			
  2    35   /* definition flags */
  2    36   
  2    37   dcl DEFINITION_FLAGS_IGNORE bit (4) static options (constant) init ("1000"b);
  2    38   dcl DEFINITION_FLAGS_ENTRY	bit (4) static options (constant) init ("0100"b);
  2    39   dcl DEFINITION_FLAGS_RETAIN bit (4) static options (constant) init ("0010"b);
  2    40   dcl DEFINITION_FLAGS_INDIRECT
  2    41 			bit (4) static options (constant) init ("0001"b);
  2    42   
  2    43   /* input structures */
  2    44   
  2    45   dcl word_arrayp		ptr;
  2    46   dcl word_arrayl		fixed bin (18) unsigned;
  2    47   
  2    48   dcl word_array(word_arrayl) bit (36) based (word_arrayp);
  2    49   
  2    50   dcl reloc_strp		ptr;
  2    51   dcl reloc_strl		fixed bin (21);
  2    52   
  2    53   dcl reloc_str		char (reloc_strl) based (reloc_strp);
  2    54   
  2    55   dcl component_listp	ptr;
  2    56   dcl component_count	fixed bin (15) unsigned;
  2    57   
  2    58   dcl component_list (1:component_count)
  2    59 			ptr based (component_listp);
  2    60   
  2    61   dcl 01 gen_info		aligned based,
  2    62        02 gen_created	fixed bin (71),
  2    63        02 generator		char (8),
  2    64        02 gen_number	fixed bin,
  2    65        02 gen_version	char (512) varying;
  2    66   
  2    67   /* entrypoint declarations */
  2    68   
  2    69   dcl ocu_$open		/* setup to create an object		*/
  2    70 	entry (char(*),		/* directory name	    (in )	*/
  2    71 	       char(*),		/* entry name	    (in )	*/
  2    72 	       bit(*),		/* option flags	    (in ) */
  2    73 	       ptr,		/* ocu_data pointer	    (out) */
  2    74 	       fixed bin(35));	/* error code	    (out) */
  2    75   
  2    76   dcl ocu_$close		/* create the object segment		*/
  2    77 	entry (ptr,		/* ocu_data pointer     (in )	*/
  2    78 	       fixed bin(35));	/* error code	    (out) */
  2    79   
  2    80   dcl ocu_$release		/* release storage on cleanup		*/
  2    81 	entry (ptr);		/* ocu_data pointer	    (in )	*/
  2    82   
  2    83   dcl ocu_$emit_text	/* emit a block of text words		*/
  2    84 	entry (ptr,		/* ocu_data pointer	    (in )	*/
  2    85 	       ptr,		/* word array pointer   (in ) */
  2    86 	       ptr,		/* reloc string pointer (in ) */
  2    87 	       fixed bin (18) uns)	/* word count	    (in ) */
  2    88 	returns(fixed bin (18) uns);	/* text relp	    (out) */
  2    89   
  2    90   dcl ocu_$emit_definition	/* emit a single definition entry	*/
  2    91 	entry (ptr,		/* ocu_data pointer	    (in )	*/
  2    92 	       char(*) var,		/* definition name	    (in ) */
  2    93 	       fixed bin (3),	/* target section	    (in ) */
  2    94 	       fixed bin (18) uns,	/* offset in section    (in ) */
  2    95 	       bit(*))		/* definition flags	    (in ) */
  2    96 	returns(fixed bin (18) uns);	/* definition relp	    (out) */
  2    97   
  2    98   dcl ocu_$emit_segname	/* emit a single segname definition	*/
  2    99 	entry (ptr,		/* ocu_data pointer	    (in )	*/
  2   100 	       char(*) var,		/* segname	    (in ) */
  2   101 	       bit(*))		/* definition flags	    (in ) */
  2   102 	returns(fixed bin (18) uns);	/* definition relp	    (out) */
  2   103   
  2   104   dcl ocu_$emit_msf_map	/* emit an msf map (MSF components)	*/
  2   105 	entry (ptr,		/* ocu_data pointer	    (in )	*/
  2   106 	       fixed bin (15) uns,	/* component count	    (in ) */
  2   107 	       fixed bin (15) uns);	/* my component	    (in ) */
  2   108   
  2   109   dcl ocu_$emit_static	/* emit a block of static words	*/
  2   110 	entry (ptr,		/* ocu_data pointer	    (in )	*/
  2   111 	       ptr,		/* word array pointer   (in ) */
  2   112 	       fixed bin (18) uns)	/* word count	    (in ) */
  2   113 	returns(fixed bin (18) uns);	/* static relp	    (out) */
  2   114   
  2   115   dcl ocu_$emit_link	/* emit a single external link	*/
  2   116 	entry (ptr,		/* ocu_data pointer	    (in )	*/
  2   117 	       fixed bin (3),	/* link type	    (in ) */
  2   118 	       fixed bin (3),	/* link class	    (in ) */
  2   119 	       char(*) var,		/* target refname	    (in ) */
  2   120 	       char(*) var,		/* target definition    (in ) */
  2   121 	       fixed bin,		/* expression offset    (in ) */
  2   122 	       bit(6),		/* link modifier	    (in ) */
  2   123 	       ptr)		/* init info pointer    (in ) */
  2   124 	returns(fixed bin (18) uns);	/* link relp	    (out) */
  2   125   
  2   126   dcl ocu_$emit_partial_link	/* emit a single partial link		*/
  2   127 	entry (ptr,		/* ocu_data pointer	    (in ) */
  2   128 	       fixed bin (15) uns,	/* target component	    (in ) */
  2   129 	       fixed bin (3),	/* target section	    (in ) */
  2   130 	       fixed bin (18) uns,	/* offset in section    (in ) */
  2   131 	       bit(6))		/* link modifier	    (in ) */
  2   132 	returns(fixed bin (18) uns);	/* link relp	    (out) */
  2   133   
  2   134   dcl ocu_$emit_firstref_trap	/* add a trap to the firstref block	*/
  2   135 	entry (ptr,		/* ocu_data pointer	    (in ) */
  2   136 	       fixed bin (18) uns,	/* call relp	    (in ) */
  2   137 	       fixed bin (18) uns);	/* info relp	    (in ) */
  2   138   
  2   139   dcl ocu_$emit_symbol	/* emit a block of symbol words	*/
  2   140 	entry (ptr,		/* ocu_data pointer	    (in ) */
  2   141 	       ptr,		/* word array pointer   (in ) */
  2   142 	       ptr,		/* reloc string pointer (in ) */
  2   143 	       fixed bin (18) uns)	/* word count	    (in ) */
  2   144 	returns(fixed bin (18) uns);	/* symbol relp	    (out) */
  2   145   
  2   146   dcl ocu_$backpatch	/* patch a word in the text/symbol scn	*/
  2   147 	entry (ptr,		/* ocu_data pointer	    (in ) */
  2   148 	       char(*),		/* section	    (in ) */
  2   149 	       fixed bin (18) uns,	/* offset in section    (in ) */
  2   150 	       char(*),		/* side and size	    (in ) */
  2   151 	       fixed bin (35));	/* new value to patch   (in ) */
  2   152   
  2   153   dcl ocu_$create_msf	/* create component 0 of the MSF	*/
  2   154 	entry (ptr,		/* component array ptr  (in ) */
  2   155 	       fixed bin (15) uns,	/* component count	    (in ) */
  2   156 	       ptr,		/* generator info ptr   (in ) */
  2   157 	       fixed bin(35));	/* error code	    (out) */
  2   158   
  2   159 /*  END OF:	ocu_dcls.incl.pl1			 *  *  *  *  *  */
      413 
      414 
      415   end le_emit_text_;
      416 
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    12/10/86  1251.5  le_emit_text_.pl1                 >special_ldd>install>MR12.0-1241>le_emit_text_.pl1
412          1    12/10/86  1248.4  le_data.incl.pl1                  >special_ldd>install>MR12.0-1241>le_data.incl.pl1
413          2    12/10/86  1248.0  ocu_dcls.incl.pl1                 >special_ldd>install>MR12.0-1241>ocu_dcls.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Indirect_and_Tally                     constant        bit(2)                   initial unaligned dcl 43 ref 260
Indirect_then_Register                 constant        bit(2)                   initial unaligned dcl 44 ref 260
LE_ABORT_ERROR                  000033 constant        fixed bin(17,0)          initial dcl 1-22 set ref 369* 386*
LE_FATAL_ERROR                  000034 constant        fixed bin(17,0)          initial dcl 1-21 set ref 232* 241* 250* 264* 326*
                                                                                  358*
Left                                   constant        fixed bin(17,0)          initial dcl 35 ref 192 227 356
Linkage                                constant        fixed bin(3,0)           initial dcl 1-28 ref 277
Patch_Symbol_Ref                000034 constant        fixed bin(17,0)          initial dcl 1-60 set ref 287*
Right                                  constant        fixed bin(17,0)          initial dcl 36 ref 192 204 337
Section_Rel_15                  000006 constant        char(1)                  initial array unaligned dcl 37 ref 302
Self_Offsetname                        constant        fixed bin(3,0)           initial dcl 1-53 ref 398
Static                                 constant        fixed bin(3,0)           initial dcl 1-34 ref 277
Symbol                                 constant        fixed bin(3,0)           initial dcl 1-30 ref 287
Text                            000031 constant        fixed bin(3,0)           initial dcl 1-26 set ref 214* 272* 398*
abort                           000100 automatic       bit(1)                   unaligned dcl 93 set ref 225* 236* 239 244* 247 253*
                                                                                  260 267* 270
addr                                                   builtin function         dcl 134 ref 163 163 163 163 180 180 203 204 204 213
                                                                                  216 224 277 280 312 321 336 337 337 344 344 346
                                                                                  346 358 364 364 366 366 376 376 376 376
addrel                                                 builtin function         dcl 135 ref 183 379
bin                                                    builtin function         dcl 136 ref 264 264
c                                      parameter       fixed bin(17,0)          dcl 50 set ref 16 143 144 151 152 153 157 169 192
                                                                                  214* 232 241 250 264 272* 287 287 311 326 344 358
                                                                                  364 374 386 386 386 395 398 398*
comp                      2            based           structure                array level 2 dcl 75
copy                                                   builtin function         dcl 137 ref 162 179
d                               000101 automatic       fixed bin(17,0)          dcl 94 set ref 318* 319 321*
def                       2            based           structure                array level 2 dcl 78
false                           000031 constant        bit(1)                   initial unaligned dcl 34 set ref 146 225 239 272*
                                                                                  281 314 398*
flags                   106            based           structure                array level 3 dcl 75
found                           000102 automatic       bit(1)                   unaligned dcl 95 set ref 314* 318 322* 326
halfword                               based           structure                array level 2 packed unaligned dcl 84
hbound                                                 builtin function         dcl 138 ref 161
header                                 based           structure                level 2 in structure "led" dcl 78 in procedure
                                                                                  "le_emit_text_"
header                                 based           structure                level 2 in structure "le_links" dcl 1-225
                                                                                  in procedure "le_emit_text_"
header                                 based           structure                level 2 in structure "lel" dcl 81 in procedure
                                                                                  "le_emit_text_"
header                                 based           structure                level 2 in structure "le_definitions" dcl 1-167
                                                                                  in procedure "le_emit_text_"
header                                 based           structure                level 2 in structure "le_components" dcl 1-72
                                                                                  in procedure "le_emit_text_"
initial_relp                    000103 automatic       fixed bin(19,0)          dcl 96 set ref 147* 181 181* 377 377* 386 386 386*
instr                           000104 automatic       structure                level 1 dcl 97 set ref 190* 203 204 213 216 224 277
                                                                                  280 312 321 336 337 344 344 346 346 358 364 364
                                                                                  366 366 376 376
internal                        000105 automatic       bit(1)                   unaligned dcl 105 set ref 214* 272* 295 398*
le_backpatch_                   000010 constant        entry                    external dcl 54 ref 287
le_comp                                based           structure                level 1 dcl 1-89
le_components                          based           structure                level 1 dcl 1-72
le_definition                          based           structure                level 1 dcl 1-175
le_definitions                         based           structure                level 1 dcl 1-167
le_error_                       000012 constant        entry                    external dcl 56 ref 232 241 250 264 326 358 369 386
le_et_$bad_def_reference        000020 external static fixed bin(35,0)          dcl 66 set ref 326*
le_et_$bad_instr_format         000022 external static fixed bin(35,0)          dcl 68 set ref 241* 250* 264*
le_et_$implementation_error     000024 external static fixed bin(35,0)          dcl 69 set ref 386*
le_et_$invalid_relinfo          000026 external static fixed bin(35,0)          dcl 71 set ref 232* 358* 369*
le_link                                based           structure                level 1 dcl 1-233
le_links                               based           structure                level 1 dcl 1-225
le_patch                               based           structure                level 1 dcl 1-298
le_snap_                        000014 constant        entry                    external dcl 57 ref 214 272 398
le_util_$scan_relinfo           000016 constant        entry                    external dcl 61 ref 173
lec                                    based           structure                level 1 dcl 75
lecp                                   parameter       pointer                  dcl 49 set ref 16 143 144 151 152 153 157 169 192
                                                                                  214* 232 241 250 264 272* 287 287 311 326 344 358
                                                                                  364 374 386 386 386 395 398*
led                                    based           structure                level 1 dcl 78
ledp                    112            based           pointer                  array level 4 in structure "lec" dcl 75 in procedure
                                                                                  "le_emit_text_" ref 311
ledp                            000106 automatic       pointer                  dcl 106 in procedure "le_emit_text_" set ref 311*
                                                                                  318 319 321
lel                                    based           structure                level 1 dcl 81
lelp                    114            based           pointer                  array level 4 in structure "lec" dcl 75 in procedure
                                                                                  "le_emit_text_" ref 395
lelp                            000110 automatic       pointer                  dcl 107 in procedure "le_emit_text_" set ref 395*
                                                                                  397 398 398 398 398
link                      2            based           structure                array level 2 dcl 81
lx                              000112 automatic       fixed bin(17,0)          dcl 108 set ref 397* 398 398 398 398 398*
min                                                    builtin function         dcl 139 ref 161 178
modifier                  0(30) 000104 automatic       bit(6)                   level 2 in structure "instr" packed unaligned dcl 97
                                                                                  in procedure "le_emit_text_" set ref 257 258 295*
                                                                                  298*
modifier                        000113 automatic       bit(6)                   unaligned dcl 109 in procedure "le_emit_text_" set
                                                                                  ref 214* 272* 295 298 398*
n_defs                                 based           fixed bin(17,0)          level 3 dcl 78 ref 318
n_links                   1            based           fixed bin(17,0)          level 3 dcl 81 ref 397
n_words                         000114 automatic       fixed bin(17,0)          dcl 110 set ref 157* 160 161 164* 164 167* 169 185*
                                                                                  185 192 214 232* 241* 250* 264* 272 287 326* 358*
                                                                                  374 380* 380
name                     10            based           varying char(32)         array level 3 dcl 75 set ref 232* 241* 250* 264*
                                                                                  326* 358* 386*
new                     143            based           structure                array level 3 dcl 75
new_offset              104(18)        based           fixed bin(18,0)          array level 3 packed unsigned unaligned dcl 78 ref
                                                                                  321
ocu_$emit_text                  000030 constant        entry                    external dcl 2-83 ref 163 180 376
ocudp                                  parameter       pointer                  dcl 48 set ref 16 163* 180* 214* 272* 376* 398*
odd                             000115 automatic       bit(1)                   unaligned dcl 111 set ref 146* 173*
offset                  104            based           fixed bin(18,0)          array level 3 packed unsigned unaligned dcl 78 ref
                                                                                  319
offset_adjustment                      based           fixed bin(18,0)          level 3 dcl 81 ref 398
op_code                   0(18) 000104 automatic       bit(9)                   level 2 packed unaligned dcl 97 set ref 248
orig                    116            based           structure                array level 3 dcl 75
pad                             000116 automatic       bit(36)                  array dcl 112 set ref 158* 161 163 163
rel                             000136 automatic       char(2)                  unaligned dcl 113 set ref 173* 196 302* 376 376
rel_char                        000137 automatic       char(1)                  unaligned dcl 114 set ref 196* 198 198 201 201 207
                                                                                  207 219 306 334 334 342 351
rel_stat                144            based           fixed bin(18,0)          array level 4 packed unsigned unaligned dcl 75 ref
                                                                                  153
rel_symb                143(18)        based           fixed bin(18,0)          array level 4 packed unsigned unaligned dcl 75 ref
                                                                                  152
rel_text                143            based           fixed bin(18,0)          array level 4 packed unsigned unaligned dcl 75 set
                                                                                  ref 151 287 386 386*
rel_textp               130            based           pointer                  array level 4 dcl 75 ref 144
relindex                        000140 automatic       fixed bin(17,0)          dcl 115 set ref 145* 173*
relinfop                        000142 automatic       pointer                  dcl 116 set ref 144* 173*
relp                            000144 automatic       fixed bin(18,0)          unsigned dcl 117 set ref 163* 180* 181 214* 216 272*
                                                                                  277 280 376* 377 398*
relstr                          000145 automatic       char(4096)               unaligned dcl 118 set ref 162* 163 163 179* 180 180
s                               002145 automatic       fixed bin(17,0)          dcl 119 set ref 192* 196 203 204 213 216 224 227 277
                                                                                  280 287* 302 312 321 336 337 344 344 346 346 356
                                                                                  358 364 364 366 366*
sc                              002146 automatic       fixed bin(17,0)          dcl 120 set ref 247* 248 250*
section                         002147 automatic       fixed bin(3,0)           dcl 121 set ref 214* 272* 277 277 287 302 398*
separate_static         106(03)        based           bit(1)                   array level 4 packed unaligned dcl 75 ref 344 364
side                      0(03)        based           fixed bin(15,0)          array level 3 in structure "word15" packed unsigned
                                                                                  unaligned dcl 84 in procedure "le_emit_text_" set
                                                                                  ref 224 277* 358* 364* 364 366* 366
side                                   based           fixed bin(18,0)          array level 2 in structure "word18" packed unsigned
                                                                                  unaligned dcl 88 in procedure "le_emit_text_" set
                                                                                  ref 203 204* 204 213 216* 280* 312 321* 336 337*
                                                                                  337 344* 344 346* 346
size                            002150 automatic       fixed bin(18,0)          unsigned dcl 122 set ref 161* 162 162 162 163* 164
                                                                                  178* 179 179 179 180* 183 184 185
skip                            002151 automatic       fixed bin(17,0)          dcl 123 set ref 173* 177 178 184* 184
special_case                    000004 constant        bit(18)                  initial array unaligned dcl 39 ref 248
special_case_name               000000 constant        char(4)                  initial array unaligned dcl 41 set ref 250*
stat_relp                       002152 automatic       fixed bin(18,0)          unsigned dcl 124 set ref 153* 344 346 364 366
substr                                                 builtin function         dcl 140 set ref 162* 179* 196 257 258 295* 302*
symb_relp                       002153 automatic       fixed bin(18,0)          unsigned dcl 125 set ref 152* 336
tables                  110            based           structure                array level 3 dcl 75
target                  105            based           fixed bin(17,0)          array level 3 dcl 75 set ref 287*
target_comp               5(18)        based           fixed bin(18,0)          array level 3 packed unsigned unaligned dcl 81 ref
                                                                                  398
target_link               6            based           fixed bin(18,0)          array level 3 packed unsigned unaligned dcl 81 ref
                                                                                  398
td                              002154 automatic       bit(4)                   unaligned dcl 126 set ref 258* 260 264 264
text_pad                144(18)        based           fixed bin(18,0)          array level 4 packed unsigned unaligned dcl 75 ref
                                                                                  157
text_relp                       002155 automatic       fixed bin(18,0)          unsigned dcl 127 set ref 151* 203
textl                   136            based           fixed bin(18,0)          array level 4 packed unsigned unaligned dcl 75 ref
                                                                                  169 192 374
textp                           002156 automatic       pointer                  dcl 128 in procedure "le_emit_text_" set ref 143*
                                                                                  180* 183* 183 190 379* 379
textp                   116            based           pointer                  array level 4 in structure "lec" dcl 75 in procedure
                                                                                  "le_emit_text_" ref 143
tm                              002160 automatic       bit(2)                   unaligned dcl 129 set ref 257* 260 260 264 264
true                            000010 constant        bit(1)                   initial unaligned dcl 33 set ref 214* 236 244 253
                                                                                  267 322
type                      3            based           fixed bin(6,0)           array level 3 packed unsigned unaligned dcl 81 ref
                                                                                  398
unspec                                                 builtin function         dcl 141 set ref 158* 190* 190
use_pr                    0(29) 000104 automatic       bit(1)                   level 2 packed unaligned dcl 97 set ref 239 281*
value                           002161 automatic       fixed bin(35,0)          dcl 130 set ref 203* 204 213* 214 224* 232* 272 312*
                                                                                  319 326* 336* 337
word15                                 based           structure                level 1 dcl 84
word18                                 based           structure                level 1 dcl 88 set ref 190

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
DEFINITION_FLAGS_ENTRY                 internal static bit(4)                   initial unaligned dcl 2-38
DEFINITION_FLAGS_IGNORE                internal static bit(4)                   initial unaligned dcl 2-37
DEFINITION_FLAGS_INDIRECT              internal static bit(4)                   initial unaligned dcl 2-40
DEFINITION_FLAGS_RETAIN                internal static bit(4)                   initial unaligned dcl 2-39
Definition                             internal static fixed bin(3,0)           initial dcl 1-32
Heap                                   internal static fixed bin(3,0)           initial dcl 1-38
LE_ERROR                               internal static fixed bin(17,0)          initial dcl 1-20
LE_WARNING                             internal static fixed bin(17,0)          initial dcl 1-19
OPEN_FLAGS_BOUND                       internal static bit(6)                   initial unaligned dcl 2-20
OPEN_FLAGS_NO_HASHTABLE                internal static bit(6)                   initial unaligned dcl 2-32
OPEN_FLAGS_PERPROCESS_STATIC           internal static bit(6)                   initial unaligned dcl 2-29
OPEN_FLAGS_PROCEDURE                   internal static bit(6)                   initial unaligned dcl 2-24
OPEN_FLAGS_RELOCATABLE                 internal static bit(6)                   initial unaligned dcl 2-22
OPEN_FLAGS_SEPARATE_STATIC             internal static bit(6)                   initial unaligned dcl 2-26
Patch_Init                             internal static fixed bin(17,0)          initial dcl 1-59
Patch_Link                             internal static fixed bin(17,0)          initial dcl 1-58
Patch_Self_Init                        internal static fixed bin(17,0)          initial dcl 1-61
Refname_Base                           internal static fixed bin(3,0)           initial dcl 1-49
Refname_Offsetname                     internal static fixed bin(3,0)           initial dcl 1-51
Self_Base                              internal static fixed bin(3,0)           initial dcl 1-47
System                                 internal static fixed bin(3,0)           initial dcl 1-36
component_count                        automatic       fixed bin(15,0)          unsigned dcl 2-56
component_list                         based           pointer                  array dcl 2-58
component_listp                        automatic       pointer                  dcl 2-55
def_count                              automatic       fixed bin(17,0)          dcl 1-173
gen_info                               based           structure                level 1 dcl 2-61
le_binaries                            based           structure                level 1 dcl 1-260
le_options                             based           structure                level 1 dcl 1-202
le_patches                             based           structure                level 1 dcl 1-293
le_segnames                            based           structure                level 1 dcl 1-149
link_count                             automatic       fixed bin(17,0)          dcl 1-231
ocu_$backpatch                  000000 constant        entry                    external dcl 2-146
ocu_$close                      000000 constant        entry                    external dcl 2-76
ocu_$create_msf                 000000 constant        entry                    external dcl 2-153
ocu_$emit_definition            000000 constant        entry                    external dcl 2-90
ocu_$emit_firstref_trap         000000 constant        entry                    external dcl 2-134
ocu_$emit_link                  000000 constant        entry                    external dcl 2-115
ocu_$emit_msf_map               000000 constant        entry                    external dcl 2-104
ocu_$emit_partial_link          000000 constant        entry                    external dcl 2-126
ocu_$emit_segname               000000 constant        entry                    external dcl 2-98
ocu_$emit_static                000000 constant        entry                    external dcl 2-109
ocu_$emit_symbol                000000 constant        entry                    external dcl 2-139
ocu_$open                       000000 constant        entry                    external dcl 2-69
ocu_$release                    000000 constant        entry                    external dcl 2-80
reloc_str                              based           char                     unaligned dcl 2-53
reloc_strl                             automatic       fixed bin(21,0)          dcl 2-51
reloc_strp                             automatic       pointer                  dcl 2-50
section_nm                             internal static char(16)                 initial array unaligned dcl 1-41
segname_count                          automatic       fixed bin(17,0)          dcl 1-156
word_array                             based           bit(36)                  array unaligned dcl 2-48
word_arrayl                            automatic       fixed bin(18,0)          unsigned dcl 2-46
word_arrayp                            automatic       pointer                  dcl 2-45

NAME DECLARED BY EXPLICIT CONTEXT.
le_emit_text_                   000216 constant        entry                    external dcl 16

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2260        2312    2123        2270
Length      2552    2123        32         223     134           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
le_emit_text_                      1236 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
le_emit_text_            000100 abort                       le_emit_text_
                         000101 d                           le_emit_text_
                         000102 found                       le_emit_text_
                         000103 initial_relp                le_emit_text_
                         000104 instr                       le_emit_text_
                         000105 internal                    le_emit_text_
                         000106 ledp                        le_emit_text_
                         000110 lelp                        le_emit_text_
                         000112 lx                          le_emit_text_
                         000113 modifier                    le_emit_text_
                         000114 n_words                     le_emit_text_
                         000115 odd                         le_emit_text_
                         000116 pad                         le_emit_text_
                         000136 rel                         le_emit_text_
                         000137 rel_char                    le_emit_text_
                         000140 relindex                    le_emit_text_
                         000142 relinfop                    le_emit_text_
                         000144 relp                        le_emit_text_
                         000145 relstr                      le_emit_text_
                         002145 s                           le_emit_text_
                         002146 sc                          le_emit_text_
                         002147 section                     le_emit_text_
                         002150 size                        le_emit_text_
                         002151 skip                        le_emit_text_
                         002152 stat_relp                   le_emit_text_
                         002153 symb_relp                   le_emit_text_
                         002154 td                          le_emit_text_
                         002155 text_relp                   le_emit_text_
                         002156 textp                       le_emit_text_
                         002160 tm                          le_emit_text_
                         002161 value                       le_emit_text_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          shorten_stack       ext_entry           repeat
set_chars_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
le_backpatch_                 le_error_                     le_snap_                      le_util_$scan_relinfo
ocu_$emit_text

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
le_et_$bad_def_reference      le_et_$bad_instr_format       le_et_$implementation_error   le_et_$invalid_relinfo




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     16 000212       143 000223       144 000232       145 000234       146 000237       147 000240       151 000242
    152 000245       153 000250       157 000253       158 000256       160 000261       161 000264       162 000270
    163 000304       164 000331       165 000333       167 000334       169 000335       173 000350       177 000400
    178 000402       179 000406       180 000422       181 000445       183 000451       184 000455       185 000457
    186 000461       190 000462       192 000464       196 000505       198 000512       201 000520       203 000524
    204 000536       205 000542       207 000543       213 000547       214 000560       216 000617       217 000626
    219 000627       224 000631       225 000641       227 000642       232 000645       236 000706       239 000710
    241 000715       244 000757       247 000761       248 000771       250 000776       253 001045       255 001047
    257 001051       258 001055       260 001060       264 001071       267 001144       270 001146       272 001150
    277 001210       280 001227       281 001240       287 001242       295 001277       298 001310       302 001312
    304 001317       306 001320       311 001322       312 001325       314 001335       318 001336       319 001347
    321 001355       322 001366       324 001370       326 001372       330 001441       334 001442       336 001446
    337 001460       338 001464       342 001465       344 001467       346 001513       347 001531       351 001532
    356 001534       358 001537       362 001605       364 001606       366 001631       368 001646       369 001647
    370 001670       374 001672       376 001703       377 001730       379 001734       380 001737       382 001740
    386 001741       395 002014       397 002023       398 002033       403 002115       405 002117


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
