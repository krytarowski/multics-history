	COMPILATION LISTING OF SEGMENT probe_find_procedure_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/27/88  1241.4 mst Thu
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(88-09-07,WAAnderson), approve(88-09-30,MCR7952),
       15*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
       16*     Added format control comment to make the source more readable.
       17*  2) change(88-10-21,WAAnderson), approve(88-10-21,MCR7952),
       18*     audit(88-10-24,RWaters), install(88-10-27,MR12.2-1194):
       19*     Modified code to implement a C feature. If the user specifes 'seg' instead
       20*     of 'seg$main', probe will now assume the user wants 'seg$main' if no
       21*     statement map is found for 'seg'.  This is not particularily elegant
       22*     because it will try using the 'seg$main' convention for any object,
       23*     regardless of the compiler used to generate the object.  There was a
       24*     problem getting back the error code 'probe_et_$no_map' from
       25*     'probe_seg_info_' when no statement map existed.  To make the
       26*     necessary change to 'probe_seg_info_' , the probe_info.entry_method'
       27*     was set to 1, to act as a flag. Other modules affected to implement
       28*     this feature are 'probe_command_' and 'probe_seg_info_'. The include
       29*     'probe_info.incl.pl1' was modified to include the new file
       30*     'retry_using_main'.
       31*                                                   END HISTORY COMMENTS */
       32 
       33 /* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       34 
       35 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       36 
       37 probe_find_procedure_:
       38   proc (P_probe_info_ptr, P_procedure_name, P_switches, P_sourcep, P_code);
       39 
       40   /* given a name, get a source_info for it */
       41   /* Changed to accept all kinds of virtual entries 09/11/81 S. Herbst */
       42   /* Changed to suppress foo|0 msg unless entry point specified, use component base if bound 09/21/81 S. Herbst */
       43   /* Changed refname warning to include the path that the refname DOES refer to 10/18/82 S. Herbst */
       44   /* Fixed bug that uses initiated copy despite pathname specified 05/02/84 S. Herbst */
       45 
       46   dcl P_probe_info_ptr	ptr parameter;
       47   dcl P_procedure_name	char (*) parameter;
       48 				/* may be refname, abspathname or relpathname */
       49   dcl P_switches		bit (36) aligned parameter;
       50   dcl P_sourcep		ptr parameter;
       51   dcl P_code		fixed bin (35) parameter;
       52 
       53   dcl switches		bit (36);
       54   dcl want_external_sw	bit (1) unaligned defined (switches) pos (1);
       55   dcl default_external_sw	bit (1) unaligned defined (switches) pos (2);
       56   dcl default_offset_zero_sw	bit (1) unaligned defined (switches) pos (3);
       57 
       58   dcl (segp, unique_refname_ptr)
       59 			ptr;
       60   dcl assume_ref		bit (1) aligned;
       61 				/* did give explicit path or are we using ref name */
       62   dcl (actual_dn, dir_name)	char (168);
       63 				/* name of containing dir */
       64   dcl pathname		char (210);
       65   dcl (actual_en, entry_name, refname, segname, unique_refname)
       66 			char (32);
       67   dcl entry_point		char (32);
       68   dcl explicit_entry_sw	bit (1) aligned;
       69   dcl code		fixed bin (35);
       70   dcl offset		fixed bin (18) unsigned;
       71   dcl offset_string		char (32);
       72   dcl sourcep		ptr;	/* to source_ptr we'll build */
       73   dcl hp			ptr;	/* to symbol_header */
       74 
       75   dcl probe_seg_info_	entry (ptr, ptr, fixed bin (35)) returns (ptr);
       76   dcl probe_stack_trace_$find_proc_frame
       77 			entry (ptr, ptr, ptr, fixed bin);
       78   dcl probe_error_$record	entry options (variable);
       79   dcl probe_error_$warning	entry options (variable);
       80 
       81   dcl component_info_$name	entry (ptr, char (32) aligned, ptr,
       82 			fixed bin (35));
       83   dcl cv_oct_check_		entry (char (*), fixed bin (35))
       84 			returns (fixed bin);
       85   dcl stu_$get_map_index	entry (ptr, fixed bin (18) unsigned, fixed bin,
       86 			ptr);
       87   dcl stu_$find_containing_block
       88 			entry (ptr, fixed bin (18) unsigned)
       89 			returns (ptr);
       90   dcl expand_pathname_	entry (char (*), char (*), char (*),
       91 			fixed bin (35));
       92   dcl hcs_$fs_get_path_name	entry (ptr, char (*), fixed bin, char (*),
       93 			fixed bin (35));
       94   dcl hcs_$initiate		entry (char (*), char (*), char (*),
       95 			fixed bin (1), fixed bin (2), ptr,
       96 			fixed bin (35));
       97   dcl pathname_		entry (char (*), char (*)) returns (char (168));
       98   dcl hcs_$make_ptr		entry (ptr, char (*), char (*), ptr,
       99 			fixed bin (35));
      100   dcl term_$single_refname	entry (char (*), fixed bin (35));
      101   dcl unique_chars_		entry (bit (*)) returns (char (15));
      102 
      103   dcl (
      104       probe_et_$recorded_message,
      105       probe_et_$no_map,
      106       error_table_$namedup,
      107       error_table_$no_ext_sym
      108       )			fixed bin (35) external static;
      109 
      110   dcl (addr, after, before, fixed, index, null, ptr, rel, search)
      111 			builtin;
      112 				/*  */
      113 
      114   probe_info_ptr = P_probe_info_ptr;
      115   sourcep = P_sourcep;
      116   switches = P_switches;
      117 
      118   offset_string = "";
      119   unique_refname_ptr = null;
      120 
      121   if search (P_procedure_name, "<>") ^= 0 then do;
      122 				/* must be a path name */
      123       assume_ref = "0"b;
      124       if index (P_procedure_name, "$") ^= 0 then do;
      125 	explicit_entry_sw = "1"b;
      126 	pathname = before (P_procedure_name, "$");
      127 	entry_point = after (P_procedure_name, "$");
      128         end;
      129       else if index (P_procedure_name, "|") ^= 0 then do;
      130 	explicit_entry_sw = "1"b;
      131 	pathname = before (P_procedure_name, "|");
      132 	entry_point = "";
      133 	offset_string = after (P_procedure_name, "|");
      134         end;
      135       else do;
      136         explicit_entry_sw = "0"b;
      137         pathname = P_procedure_name;
      138         entry_point = "";
      139       end;
      140 
      141       call expand_pathname_ (pathname, dir_name, entry_name, code);
      142       if code ^= 0 then do;
      143 	call probe_error_$record (probe_info_ptr, code, "^a",
      144 	     P_procedure_name);
      145 	goto RECORDED_MESSAGE;
      146         end;
      147 
      148       segname = entry_name;
      149       if entry_point = ""
      150         then
      151 	   entry_point = entry_name;
      152 
      153       call hcs_$initiate (dir_name, segname, entry_point, 0, 0, segp, code);
      154       if segp = null () then do;
      155 CANT_INITIATE:
      156 	call probe_error_$record (probe_info_ptr, code, "^a^[>^]^a^[$^a^]",
      157 	     dir_name, (dir_name ^= ">"), segname, (segname ^= entry_point),
      158 	     entry_point);
      159 	goto RECORDED_MESSAGE;
      160         end;
      161       if code = error_table_$namedup then do;
      162 				/* reference name already in use */
      163 	unique_refname = unique_chars_ ("0"b);
      164 	call hcs_$initiate (dir_name, segname, unique_refname, 0, 0,
      165 	     unique_refname_ptr, code);
      166 	if unique_refname_ptr = null
      167 	  then go to CANT_INITIATE;
      168 	call probe_error_$warning (probe_info_ptr, 0,
      169 	     "Warning: ^a is not the initiated version of ^a",
      170 	     pathname_ (dir_name, segname), segname);
      171         end;
      172     end;				/* pathname */
      173 
      174     else do;			/* assume ref name */
      175       assume_ref = "1"b;
      176       if index (P_procedure_name, "$") ^= 0 then do;
      177 	explicit_entry_sw = "1"b;
      178 	segname = before (P_procedure_name, "$");
      179 	entry_point = after (P_procedure_name, "$");
      180 	if entry_point = ""
      181 	  then
      182 	       entry_point = segname;
      183         end;
      184       else if index (P_procedure_name, "|") ^= 0 then do;
      185 	explicit_entry_sw = "1"b;
      186 	pathname = before (P_procedure_name, "|");
      187 	entry_point = "";
      188 	offset_string = after (P_procedure_name, "|");
      189         end;
      190       else do;
      191         explicit_entry_sw = "0"b;
      192         segname = P_procedure_name;
      193         entry_point = P_procedure_name;
      194       end;
      195     end;				/* of getting ref name */
      196 
      197   /* now segname and entry_point are set, so lets try to find the
      198*   specific entry in mind. */
      199 
      200   if offset_string ^= "" then do;	/* path|N */
      201       segp = ptr (segp, cv_oct_check_ (offset_string, code));
      202       if code ^= 0 then do;
      203 	call probe_error_$record (probe_info_ptr, code, "Bad offset ^a",
      204 	     offset_string);
      205 	go to RECORDED_MESSAGE;
      206         end;
      207     end;
      208     else do;
      209       if unique_refname_ptr ^= null
      210         then refname = unique_refname;
      211         else refname = segname;
      212 
      213       call hcs_$make_ptr (null (), refname, entry_point, segp, code);
      214       if code = error_table_$no_ext_sym & default_offset_zero_sw then do;
      215 				/* warn user, and use whole seg */
      216 	call hcs_$make_ptr (null (), refname, "", segp, (0));
      217 	if segp ^= null then do;
      218 	    call component_info_$name (segp, (segname), addr (ci), code);
      219 	    if code = 0
      220 	      then
      221 		 if ci.text_start ^= null & ci.text_start ^= segp then do;
      222 		     if explicit_entry_sw
      223 		       then call probe_error_$warning
      224 			       (probe_info_ptr, 0,
      225 			       "Entry point ^a not found in segment ^a. Using base of component instead.",
      226 			       entry_point, segname);
      227 		     segp = ci.text_start;
      228 		     go to CHECK_REFNAME;
      229 		   end;
      230 
      231 	    if explicit_entry_sw
      232 	      then call probe_error_$warning (probe_info_ptr, 0,
      233 		      "Entry point ^a not found in segment ^a. Using ^a|0 instead.",
      234 		      entry_point, segname, segname);
      235 	  end;
      236         end;
      237     end;
      238 
      239   if unique_refname_ptr ^= null
      240     then
      241          call term_$single_refname (unique_refname, (0));
      242 
      243   if segp = null () then do;
      244       call probe_error_$record (probe_info_ptr, code, "^a^[$^a^]",
      245 	 segname, (segname ^= entry_point), entry_point);
      246       goto RECORDED_MESSAGE;
      247     end;
      248 CHECK_REFNAME:
      249   if assume_ref
      250     then
      251       begin;
      252       ;				/* must check it for plausibility */
      253       dcl seg_uid		    bit (36) aligned;
      254       dcl 1 status_branch_auto    aligned like status_branch;
      255 
      256 
      257       dcl get_wdir_		    entry () returns (char (168));
      258       dcl hcs_$get_uid_seg	    entry (ptr, bit (36) aligned,
      259 			    fixed bin (35));
      260       dcl hcs_$status_long	    entry (char (*), char (*), fixed bin (1),
      261 			    ptr, ptr, fixed bin (35));
      262 
      263       status_ptr = addr (status_branch_auto);
      264 				/* see of copy in wdir is same one as picked up by */
      265       dir_name = get_wdir_ ();	/* call to hcs_$make_ptr */
      266       call hcs_$status_long (dir_name, segname, 1, status_ptr, (null ()),
      267 	 code);
      268       if code = 0 & status_branch.type = Segment then do;
      269 	call hcs_$get_uid_seg (segp, seg_uid, code);
      270 	if code = 0
      271 	  then
      272 	       if seg_uid ^= status_branch.uid then do;
      273 				/* it's not the same */
      274 		 call hcs_$fs_get_path_name (segp, actual_dn, 0,
      275 		      actual_en, code);
      276 		 call probe_error_$warning (probe_info_ptr, 0,
      277 		      "Warning: Reference name ""^a"" does not refer to  ^a^[^/^-It refers to ^a^]",
      278 		      segname, pathname_ (dir_name, segname), code = 0,
      279 		      pathname_ (actual_dn, actual_en));
      280 	         end;
      281         end;			/* of checking for sameness */
      282     end;
      283 
      284   /* now look for frame */
      285 
      286   call probe_stack_trace_$find_proc_frame (probe_info_ptr, sourcep, segp, 1);
      287 
      288   if sourcep -> source_info.stack_ptr = null () then do;
      289 				/* not active */
      290       sourcep -> source_info.entry_ptr = segp;
      291 				/* must find out about it ourseleves */
      292       sourcep -> source_info.instruction_ptr = null;
      293 				/* not active */
      294 
      295       probe_info.entry_method = 1;
      296 
      297       sourcep -> source_info.seg_info_ptr =
      298 	 probe_seg_info_ (probe_info_ptr, segp, code);
      299 
      300 /* Check for the statement map. If not present we'll try seg$main */
      301 
      302       if code = probe_et_$no_map then do;
      303          probe_info.retry_using_main = 1;
      304          code = 0;
      305          goto MAIN_RETURN;
      306        end;
      307 
      308       if code ^= 0 
      309         then goto MAIN_RETURN;
      310 
      311       offset = fixed (rel (segp), 18);
      312       hp = sourcep -> source_info.seg_info_ptr -> seg_info.symbol_header_ptr;
      313 
      314       call stu_$get_map_index (hp, offset,
      315 	 sourcep -> source_info.stmnt_map_entry_index, null);
      316 
      317       sourcep -> source_info.block_ptr =
      318 	 stu_$find_containing_block (hp, offset);
      319     end;				/* doing it ourselves */
      320 
      321   code = 0;			/* all done */
      322   goto MAIN_RETURN;
      323 
      324 
      325 RECORDED_MESSAGE:
      326   code = probe_et_$recorded_message;
      327   goto MAIN_RETURN;
      328 
      329 
      330 MAIN_RETURN:
      331   P_code = code;
      332   return;
      333 
      334   /*  */
      335 
  1     1 /* BEGIN INCLUDE FILE ... probe_source_info.incl.pl1
  1     2*
  1     3*  James R. Davis 2 July 79 */
  1     4 
  1     5 dcl 1 source_info based aligned,
  1     6       2 stmnt_map_entry_index fixed bin,		/* index in stmnt map for this stmnt */
  1     7       2 instruction_ptr ptr,				/* to last instruction executed  */
  1     8       2 block_ptr ptr,				/* to runtime_block node */
  1     9       2 stack_ptr ptr,				/* to a stack frame */
  1    10       2 entry_ptr ptr,				/* to entry seq. for this proc */
  1    11       2 seg_info_ptr ptr;				/* to seg_info */
  1    12 
  1    13 dcl 1 current_source aligned like source_info based (probe_info.ptr_to_current_source);
  1    14 dcl 1 initial_source aligned like source_info based (probe_info.ptr_to_initial_source);
  1    15 
  1    16 /* END INCLUDE FILE ... probe_source_info.incl.pl1 */
      336 
      337 
      338   /* ;;;;;;; */
      339 
  2     1 /* BEGIN INCLUDE FILE ... probe_seg_info.incl.pl1
  2     2*
  2     3*   25 June 79 JRDavis
  2     4*
  2     5*   Modified  7 April 1983, TO - Add fields for character offset/line
  2     6*	correction per file.
  2     7**/
  2     8 
  2     9 dcl 1 seg_info based aligned,				/* place to remember information about object seg */
  2    10     2 language_type fixed bin,			/* language of source program */
  2    11     2 bits aligned,
  2    12       3 ignore_case bit (1) unal,
  2    13       3 bound_segment bit (1) unaligned,
  2    14       3 component bit (1) unaligned,
  2    15       3 pad bit (33) unal,
  2    16     2 names,					/* where to find it */
  2    17       3 directory_name character (168) unal,		/* what directory */
  2    18       3 entry_name character (32) unal,			/* what segment */
  2    19       3 segname character (32) unal,			/* procedure segname definition */
  2    20     2 identifier fixed bin (71),			/* time of object creation */
  2    21     2 pointers,					/* location of various parts of segment */
  2    22       3 symbol_header_ptr ptr unal,			/* to symbol section */
  2    23       3 original_source_ptr ptr unal,			/* to segment source map */
  2    24       3 statement_map_ptr ptr unal,			/* to segment statement map */
  2    25       3 break_info ptr unal,				/* for unbound segments, and start of chain for
  2    26*						   bound ones, -> break_map !obsolete, I think! */
  2    27       3 chain ptr unal,				/* to entry for next component if bound */
  2    28       3 linkage_ptr ptr unal,				/* to linkage section */
  2    29     2 bounds aligned,				/* structure of bounds information */
  2    30       3 text_bounds,
  2    31         4 start fixed bin (35),
  2    32         4 end fixed bin (35),
  2    33       3 symbol_bounds,
  2    34         4 start fixed bin (35),
  2    35         4 end fixed bin (35),
  2    36     2 map_size fixed bin,				/* size of statement map */
  2    37     2 error_code fixed bin (35),			/* errors encoutered while getting info, are recorded here */
  2    38     2 bound_create_time fixed bin (71),			/* time seg containing was bound or compiled. */
  2    39     2 bound_sym_header ptr unal,			/* to sym. section header for bound seg */
  2    40     2 pad (1) fixed bin (35),
  2    41 
  2    42     2 nfiles fixed bin,
  2    43     2 per_file (seg_info_nfiles refer (seg_info.nfiles)),
  2    44       3 file_pointers ptr unal,
  2    45       3 break_line (0:3) fixed bin (18) unsigned unaligned;
  2    46 
  2    47 dcl  seg_info_nfiles fixed bin;			/* for allocation purposes */
  2    48 
  2    49 
  2    50 /* END INCLUDE FILE ... probe_seg_info.incl.pl1 */
      340 
      341 
      342   /* ;;;;;;; */
      343 
  3     1 /*	BEGIN INCLUDE FILE probe_info.incl.pl1		*/
  3     2 
  3     3 
  3     4 
  3     5 /****^  HISTORY COMMENTS:
  3     6*  1) change(88-10-24,WAAnderson), approve(88-10-24,MCR7952),
  3     7*     audit(88-10-24,RWaters), install(88-10-27,MR12.2-1194):
  3     8*     Added field 'retry_using_main' to add new C feature.
  3     9*                                                   END HISTORY COMMENTS */
  3    10 
  3    11 
  3    12 /* Created: 04/22/79 W. Olin Sibert, from subsystem_info	
  3    13*   Modified: 22 Sept 79 JRd to remove: 	default (ptr & (auto|based)) init (null ());
  3    14*   Added flags.setting_break 08/22/83 Steve Herbst
  3    15*   Added flags.executing_quit_request 01/15/85 Steve Herbst
  3    16**/
  3    17 
  3    18 dcl 1 probe_info aligned based (probe_info_ptr),		/* standard data for a probe invocation */
  3    19     2 probe_info_version fixed bin,			/* version of this structure */
  3    20 
  3    21     2 static_info_ptr pointer unaligned,		/* pointer to static information structure */
  3    22     2 modes_ptr pointer unaligned,			/* pointer to probe_modes structure */
  3    23 
  3    24     2 ptr_to_current_source ptr,			/* current_source is based on this */
  3    25     2 ptr_to_initial_source ptr,			/* initial_source is based on this */
  3    26     2 machine_cond_ptr pointer,			/* pointer to machine conditions, if we faulted to get here */
  3    27 
  3    28     2 token_info aligned,				/* information about token chain currently being processed */
  3    29       3 first_token pointer unaligned,			/* first token in chain */
  3    30       3 ct pointer unaligned, 			/* pointer to current token; updated in MANY places */
  3    31       3 end_token bit (18) aligned,			/* token type at which to stop scanning token chain */
  3    32       3 buffer_ptr pointer unaligned,			/* pointer to input buffer */
  3    33       3 buffer_lth fixed bin (21),			/* and length */
  3    34 
  3    35     2 random_info aligned,
  3    36       3 current_stack_frame pointer unaligned,		/* stack frame pointer for frame in which probe was invoked */
  3    37       3 input_type fixed bin, 			/* current input type */
  3    38       3 language_type fixed bin,			/* current language being processed */
  3    39       3 return_method fixed bin,			/* how we should return after exiting probe */
  3    40       3 entry_method fixed bin,			/* how we got here in the first place */
  3    41       3 pad1 (19) bit (36) aligned,
  3    42 
  3    43     2 break_info,					/* break info -- only interesting if we got here via a break */
  3    44       3 break_slot_ptr pointer,			/* pointer to break slot -- non-null IFF at a break */
  3    45       3 last_break_slot_ptr pointer unaligned,		/* pointer to previous break slot, not presently used */
  3    46       3 break_reset bit (1) aligned,			/* this break has been reset by somebody further on */
  3    47       3 real_break_return_loc pointer,			/* where to REALLY return to, modulo previous bit */
  3    48 
  3    49     2 probe_area_info,				/* information about various probe areas */
  3    50       3 break_segment_ptr pointer unaligned,		/* pointer to Personid.probe */
  3    51       3 break_area_ptr pointer unaligned,		/* pointer to area in break segment */
  3    52       3 scratch_area_ptr pointer unaligned,		/* pointer to probe scratch seg in process dir */
  3    53       3 probe_area_ptr pointer unaligned,		/* This area lasts as long as an invocation of probe. */
  3    54       3 work_area_ptr pointer unaligned,		/* This area lasts as long as the current request line */
  3    55       3 expression_area_ptr pointer unaligned,		/* This area lasts as long as the current command */
  3    56 
  3    57     2 flags aligned,				/* this, in particular, should be saved and restored correctly */
  3    58      (3 execute,					/* "1"b => execute requests, "0"b => just check syntax */
  3    59       3 in_listener,				/* ON => in probe listener loop */
  3    60       3 executing_request,				/* ON => executing a request */
  3    61       3 in_interpret_line,				/* executing in probe_listen_$interpret_line */
  3    62       3 setting_break,				/* executing "after" or "before": check syntax of "if" */
  3    63       3 executing_quit_request,			/* to prevent error looping during "quit" request */
  3    64       3 pad (30)) bit (1) unaligned,
  3    65 
  3    66     2 io_switches,					/* switches probe will do normal I/O on */
  3    67       3 input_switch pointer,
  3    68       3 output_switch pointer,
  3    69 
  3    70     2 error_info,					/* information about the last error saved for later printing */
  3    71       3 error_code fixed bin (35),
  3    72       3 error_message char (300) varying,
  3    73 
  3    74     2 listener_info,				/* internal use by probe listener */
  3    75       3 request_name character (32) varying,		/* primary name of the request being processed */
  3    76       3 abort_probe_label label variable,
  3    77       3 abort_line_label label variable,
  3    78       3 depth fixed binary,				/* count of active invocations of probe */
  3    79       3 previous pointer unaligned,			/* -> previous invocation's info */
  3    80       3 next pointer unaligned,
  3    81 
  3    82     2 end_of_probe_info pointer aligned,
  3    83     2 retry_using_main fixed bin aligned;
  3    84    
  3    85 
  3    86 dcl  probe_info_ptr pointer;
  3    87 
  3    88 dcl  probe_info_version fixed bin static options (constant) initial (1);
  3    89 
  3    90 dcl  probe_info_version_1 fixed bin static options (constant) initial (1);
  3    91 
  3    92 dcl  scratch_area area based (probe_info.scratch_area_ptr);
  3    93 dcl  probe_area area based (probe_info.probe_area_ptr);
  3    94 dcl  work_area area based (probe_info.work_area_ptr);
  3    95 dcl  expression_area area based (probe_info.expression_area_ptr);
  3    96 
  3    97 /*	END INCLUDE FILE probe_info.incl.pl1		*/
      344 
      345 
      346   /* ;;;;;;; */
      347 
      348 
  4     1 	/* BEGIN INCLUDE SEGMENT ...  component_info.incl.pl1   M. Weaver  4/26/72  */
  4     2 
  4     3 declare	1 ci aligned,
  4     4 	2 dcl_version fixed bin,		/* version number of this structure */
  4     5 	2 name char(32) aligned,		/* objectname of component segment */
  4     6 	2 text_start pointer,		/* ptr to component's section of text */
  4     7 	2 stat_start pointer,		/* pointer to component's section of internal static */
  4     8 	2 symb_start pointer,		/* pointer to component's first symbol block */
  4     9 	2 defblock_ptr pointer,		/* ptr to component's definition block */
  4    10 	2 text_lng fixed bin,		/* length of text section */
  4    11 	2 stat_lng fixed bin,		/* length of internal static */
  4    12 	2 symb_lng fixed bin,		/* length of symbol section */
  4    13 	2 n_blocks fixed bin,		/* number of symbol blocks in component's symbol section */
  4    14 	2 standard bit(1) aligned,		/* indicates whether component is in standard (new) format */
  4    15 	2 compiler char(8) aligned,		/* name of component's compiler */
  4    16 	2 compile_time fixed bin(71),		/* time component was compiled */
  4    17 	2 userid char(32) aligned,		/* id of creator of component */
  4    18 	2 cvers aligned,			/* version of component's compiler in printable form */
  4    19 	  3 offset bit(18) unaligned,		/* offset in words relative to symb_start */
  4    20 	  3 length bit(18) unaligned,		/* length of name in characters */
  4    21 	2 comment aligned,			/* component's comment */
  4    22 	  3 offset bit(18) unaligned,		/* offset in words relative to symb_start */
  4    23 	  3 length bit(18) unaligned,		/* length of comment in characters */
  4    24 	2 source_map fixed bin;		/* offset, rel to beg of symbol block, of component's source map */
  4    25 
  4    26 	/* END INCLUDE SEGMENT ... component_info.incl.pl1 */
      349 
      350 
      351   /* ;;;;;;; */
      352 
  5     1 /* --------------- BEGIN include file status_structures.incl.pl1 --------------- */
  5     2 
  5     3 /* Revised from existing include files 09/26/78 by C. D. Tavares */
  5     4 
  5     5 /* This include file contains branch and link structures returned by
  5     6*   hcs_$status_ and hcs_$status_long. */
  5     7 
  5     8 dcl 1 status_branch aligned based (status_ptr),
  5     9     2 short aligned,
  5    10       3 type fixed bin (2) unaligned unsigned,		/* seg, dir, or link */
  5    11       3 nnames fixed bin (16) unaligned unsigned,		/* number of names */
  5    12       3 names_relp bit (18) unaligned,			/* see entry_names dcl */
  5    13       3 dtcm bit (36) unaligned,			/* date/time contents last modified */
  5    14       3 dtu bit (36) unaligned,			/* date/time last used */
  5    15       3 mode bit (5) unaligned,			/* caller's effective access */
  5    16       3 raw_mode bit (5) unaligned,			/* caller's raw "rew" modes */
  5    17       3 pad1 bit (8) unaligned,
  5    18       3 records_used fixed bin (18) unaligned unsigned,	/* number of NONZERO pages used */
  5    19 
  5    20 /* Limit of information returned by hcs_$status_ */
  5    21 
  5    22     2 long aligned,
  5    23       3 dtd bit (36) unaligned,			/* date/time last dumped */
  5    24       3 dtem bit (36) unaligned,			/* date/time branch last modified */
  5    25       3 lvid bit (36) unaligned,			/* logical volume ID */
  5    26       3 current_length fixed bin (12) unaligned unsigned,	/* number of last page used */
  5    27       3 bit_count fixed bin (24) unaligned unsigned,	/* reported length in bits */
  5    28       3 pad2 bit (8) unaligned,
  5    29       3 copy_switch bit (1) unaligned,			/* copy switch */
  5    30       3 tpd_switch bit (1) unaligned,			/* transparent to paging device switch */
  5    31       3 mdir_switch bit (1) unaligned,			/* is a master dir */
  5    32       3 damaged_switch bit (1) unaligned,		/* salvager warned of possible damage */
  5    33       3 synchronized_switch bit (1) unaligned,		/* DM synchronized file */
  5    34       3 pad3 bit (5) unaligned,
  5    35       3 ring_brackets (0:2) fixed bin (6) unaligned unsigned, 
  5    36       3 uid bit (36) unaligned;			/* unique ID */
  5    37 
  5    38 dcl 1 status_link aligned based (status_ptr),
  5    39     2 type fixed bin (2) unaligned unsigned,		/* as above */
  5    40     2 nnames fixed bin (16) unaligned unsigned,
  5    41     2 names_relp bit (18) unaligned,
  5    42     2 dtem bit (36) unaligned,
  5    43     2 dtd bit (36) unaligned,
  5    44     2 pathname_length fixed bin (17) unaligned,		/* see pathname */
  5    45     2 pathname_relp bit (18) unaligned;			/* see pathname */
  5    46 
  5    47 dcl  status_entry_names (status_branch.nnames) character (32) aligned
  5    48 	based (pointer (status_area_ptr, status_branch.names_relp)),
  5    49 						/* array of names returned */
  5    50      status_pathname character (status_link.pathname_length) aligned
  5    51 	based (pointer (status_area_ptr, status_link.pathname_relp)),
  5    52 						/* link target path */
  5    53      status_area_ptr pointer,
  5    54      status_ptr pointer;
  5    55 
  5    56 dcl (Link initial (0),
  5    57      Segment initial (1),
  5    58      Directory initial (2)) fixed bin internal static options (constant);
  5    59 						/* values for type fields declared above */
  5    60 
  5    61 /* ---------------- END include file status_structures.incl.pl1 ---------------- */
      353 
  6     1 /* BEGIN INCLUDE FILE  ... probe_lang_types.incl.pl1
  6     2*
  6     3*   JRD 26 June 79
  6     4*   MBW 31 July 1981 to add algol68 */
  6     5 
  6     6 
  6     7 /****^  HISTORY COMMENTS:
  6     8*  1) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  6     9*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  6    10*     Added C Language type.
  6    11*                                                   END HISTORY COMMENTS */
  6    12 
  6    13 
  6    14 /*   Modified June 83 JMAthane to add PASCAL language type */
  6    15 /*   Modified April 88 Hinatsu to add C language type */
  6    16 
  6    17      dcl	   (UNKNOWN_lang_type     init (1),
  6    18 	   OTHER_lang_type	      init (2),
  6    19 	   PL1_lang_type	      init (3),
  6    20 	   FORTRAN_lang_type      init (4),
  6    21 	   COBOL_lang_type	      init (5),
  6    22 	   ALM_lang_type	      init (6),
  6    23 	   ALGOL68_lang_type      init (7),
  6    24 	   PASCAL_lang_type	      init (8),
  6    25 	   C_lang_type	      init (9)) fixed bin internal static options (constant);
  6    26 
  6    27      dcl	   official_language_names (9) char (32) internal static options (constant) init
  6    28 			      ("Unknown", "other", "PL/I", "FORTRAN", "COBOL", "ALM", "Algol 68", "Pascal", "C");
  6    29 
  6    30      dcl	   palatable_language_names (9) char (32) internal static options (constant) init
  6    31 			      ("Unknown", "Other", "pl1", "fortran", "cobol", "alm", "algol68", "pascal", "c");
  6    32 
  6    33 /* END INCLUDE FILE ... probe_lang_types.incl.pl1 */
      354 
      355 
      356 
      357   end;				/* external procedure probe_find_procedure_ */
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/27/88  1222.0  probe_find_procedure_.pl1         >spec>install>MR12.2-1194>probe_find_procedure_.pl1
336          1    11/26/79  1320.6  probe_source_info.incl.pl1        >ldd>include>probe_source_info.incl.pl1
340          2    11/02/83  1845.0  probe_seg_info.incl.pl1           >ldd>include>probe_seg_info.incl.pl1
344          3    10/27/88  1223.7  probe_info.incl.pl1               >spec>install>MR12.2-1194>probe_info.incl.pl1
349          4    05/06/74  1741.0  component_info.incl.pl1           >ldd>include>component_info.incl.pl1
353          5    11/22/82  0955.7  status_structures.incl.pl1        >ldd>include>status_structures.incl.pl1
354          6    10/26/88  1255.5  probe_lang_types.incl.pl1         >ldd>include>probe_lang_types.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
P_code                                 parameter       fixed bin(35,0)          dcl 51 set ref 37 330*
P_probe_info_ptr                       parameter       pointer                  dcl 46 ref 37 114
P_procedure_name                       parameter       char                     packed unaligned dcl 47 set ref 37 121 124 126 127
                                                                                  129 131 133 137 143* 176 178 179 184 186 188 192
                                                                                  193
P_sourcep                              parameter       pointer                  dcl 50 ref 37 115
P_switches                             parameter       bit(36)                  dcl 49 ref 37 116
Segment                                constant        fixed bin(17,0)          initial dcl 5-56 ref 268
actual_dn                       000107 automatic       char(168)                packed unaligned dcl 62 set ref 274* 276* 276*
actual_en                       000320 automatic       char(32)                 packed unaligned dcl 65 set ref 274* 276* 276*
addr                                                   builtin function         dcl 110 ref 218 218 263
after                                                  builtin function         dcl 110 ref 127 133 179 188
assume_ref                      000106 automatic       bit(1)                   dcl 60 set ref 123* 175* 248
before                                                 builtin function         dcl 110 ref 126 131 178 186
block_ptr                 4            based           pointer                  level 2 dcl 1-5 set ref 317*
ci                              000422 automatic       structure                level 1 dcl 4-3 set ref 218 218
code                            000401 automatic       fixed bin(35,0)          dcl 69 set ref 141* 142 143* 153* 155* 161 164* 201*
                                                                                  202 203* 213* 214 218* 219 244* 266* 268 269* 270
                                                                                  274* 276 297* 302 304* 308 321* 325* 330
component_info_$name            000020 constant        entry                    external dcl 81 ref 218
cv_oct_check_                   000022 constant        entry                    external dcl 83 ref 201
default_offset_zero_sw                 defined         bit(1)                   packed unaligned dcl 56 ref 214
dir_name                        000161 automatic       char(168)                packed unaligned dcl 62 set ref 141* 153* 155* 155
                                                                                  164* 168* 168* 265* 266* 276* 276*
entry_method             23            based           fixed bin(17,0)          level 3 dcl 3-18 set ref 295*
entry_name                      000330 automatic       char(32)                 packed unaligned dcl 65 set ref 141* 148 149
entry_point                     000370 automatic       char(32)                 packed unaligned dcl 67 set ref 127* 132* 138* 149
                                                                                  149* 153* 155 155* 179* 180 180* 187* 193* 213*
                                                                                  222* 231* 244 244*
entry_ptr                10            based           pointer                  level 2 dcl 1-5 set ref 290*
error_table_$namedup            000052 external static fixed bin(35,0)          dcl 103 ref 161
error_table_$no_ext_sym         000054 external static fixed bin(35,0)          dcl 103 ref 214
expand_pathname_                000030 constant        entry                    external dcl 90 ref 141
explicit_entry_sw               000400 automatic       bit(1)                   dcl 68 set ref 125* 130* 136* 177* 185* 191* 222 231
fixed                                                  builtin function         dcl 110 ref 311
get_wdir_                       000056 constant        entry                    external dcl 257 ref 265
hcs_$fs_get_path_name           000032 constant        entry                    external dcl 92 ref 274
hcs_$get_uid_seg                000060 constant        entry                    external dcl 258 ref 269
hcs_$initiate                   000034 constant        entry                    external dcl 94 ref 153 164
hcs_$make_ptr                   000040 constant        entry                    external dcl 98 ref 213 216
hcs_$status_long                000062 constant        entry                    external dcl 260 ref 266
hp                              000416 automatic       pointer                  dcl 73 set ref 312* 314* 317*
index                                                  builtin function         dcl 110 ref 124 129 176 184
instruction_ptr           2            based           pointer                  level 2 dcl 1-5 set ref 292*
long                      4            based           structure                level 2 dcl 5-8
null                                                   builtin function         dcl 110 ref 119 154 166 209 213 213 216 216 217 219
                                                                                  239 243 266 288 292 314 314
offset                          000402 automatic       fixed bin(18,0)          unsigned dcl 70 set ref 311* 314* 317*
offset_string                   000403 automatic       char(32)                 packed unaligned dcl 71 set ref 118* 133* 188* 200
                                                                                  201* 203*
pathname                        000233 automatic       char(210)                packed unaligned dcl 64 set ref 126* 131* 137* 141*
                                                                                  186*
pathname_                       000036 constant        entry                    external dcl 97 ref 168 168 276 276 276 276
pointers                 76            based           structure                level 2 dcl 2-9
probe_error_$record             000014 constant        entry                    external dcl 78 ref 143 155 203 244
probe_error_$warning            000016 constant        entry                    external dcl 79 ref 168 222 231 276
probe_et_$no_map                000050 external static fixed bin(35,0)          dcl 103 ref 302
probe_et_$recorded_message      000046 external static fixed bin(35,0)          dcl 103 ref 325
probe_info                             based           structure                level 1 dcl 3-18
probe_info_ptr                  000420 automatic       pointer                  dcl 3-86 set ref 114* 143* 155* 168* 203* 222* 231*
                                                                                  244* 276* 286* 295 297* 303
probe_seg_info_                 000010 constant        entry                    external dcl 75 ref 297
probe_stack_trace_$find_proc_frame
                                000012 constant        entry                    external dcl 76 ref 286
ptr                                                    builtin function         dcl 110 ref 201
random_info              17            based           structure                level 2 dcl 3-18
refname                         000340 automatic       char(32)                 packed unaligned dcl 65 set ref 209* 211* 213* 216*
rel                                                    builtin function         dcl 110 ref 311
retry_using_main        240            based           fixed bin(17,0)          level 2 dcl 3-18 set ref 303*
search                                                 builtin function         dcl 110 ref 121
seg_info                               based           structure                level 1 dcl 2-9
seg_info_ptr             12            based           pointer                  level 2 dcl 1-5 set ref 297* 312
seg_uid                         000474 automatic       bit(36)                  dcl 253 set ref 269* 270
segname                         000350 automatic       char(32)                 packed unaligned dcl 65 set ref 148* 153* 155* 155
                                                                                  164* 168* 168* 168* 178* 180 192* 211 218 222*
                                                                                  231* 231* 244* 244 266* 276* 276* 276*
segp                            000102 automatic       pointer                  dcl 58 set ref 153* 154 201* 201 213* 216* 217 218*
                                                                                  219 227* 243 269* 274* 286* 290 297* 311
short                                  based           structure                level 2 dcl 5-8
source_info                            based           structure                level 1 dcl 1-5
sourcep                         000414 automatic       pointer                  dcl 72 set ref 115* 286* 288 290 292 297 312 314 317
stack_ptr                 6            based           pointer                  level 2 dcl 1-5 ref 288
status_branch                          based           structure                level 1 dcl 5-8
status_branch_auto              000475 automatic       structure                level 1 dcl 254 set ref 263
status_ptr                      000472 automatic       pointer                  dcl 5-47 set ref 263* 266* 268 270
stmnt_map_entry_index                  based           fixed bin(17,0)          level 2 dcl 1-5 set ref 314*
stu_$find_containing_block      000026 constant        entry                    external dcl 87 ref 317
stu_$get_map_index              000024 constant        entry                    external dcl 85 ref 314
switches                        000100 automatic       bit(36)                  packed unaligned dcl 53 set ref 116* 214 214
symbol_header_ptr        76            based           pointer                  level 3 packed packed unaligned dcl 2-9 ref 312
term_$single_refname            000042 constant        entry                    external dcl 100 ref 239
text_start               12     000422 automatic       pointer                  level 2 dcl 4-3 set ref 219 219 227
type                                   based           fixed bin(2,0)           level 3 packed packed unsigned unaligned dcl 5-8 ref
                                                                                  268
uid                      11            based           bit(36)                  level 3 packed packed unaligned dcl 5-8 ref 270
unique_chars_                   000044 constant        entry                    external dcl 101 ref 163
unique_refname                  000360 automatic       char(32)                 packed unaligned dcl 65 set ref 163* 164* 209 239*
unique_refname_ptr              000104 automatic       pointer                  dcl 58 set ref 119* 164* 166 209 239

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALGOL68_lang_type                      internal static fixed bin(17,0)          initial dcl 6-17
ALM_lang_type                          internal static fixed bin(17,0)          initial dcl 6-17
COBOL_lang_type                        internal static fixed bin(17,0)          initial dcl 6-17
C_lang_type                            internal static fixed bin(17,0)          initial dcl 6-17
Directory                              internal static fixed bin(17,0)          initial dcl 5-56
FORTRAN_lang_type                      internal static fixed bin(17,0)          initial dcl 6-17
Link                                   internal static fixed bin(17,0)          initial dcl 5-56
OTHER_lang_type                        internal static fixed bin(17,0)          initial dcl 6-17
PASCAL_lang_type                       internal static fixed bin(17,0)          initial dcl 6-17
PL1_lang_type                          internal static fixed bin(17,0)          initial dcl 6-17
UNKNOWN_lang_type                      internal static fixed bin(17,0)          initial dcl 6-17
current_source                         based           structure                level 1 dcl 1-13
default_external_sw                    defined         bit(1)                   packed unaligned dcl 55
expression_area                        based           area(1024)               dcl 3-95
initial_source                         based           structure                level 1 dcl 1-14
official_language_names                internal static char(32)                 initial array packed unaligned dcl 6-27
palatable_language_names               internal static char(32)                 initial array packed unaligned dcl 6-30
probe_area                             based           area(1024)               dcl 3-93
probe_info_version                     internal static fixed bin(17,0)          initial dcl 3-88
probe_info_version_1                   internal static fixed bin(17,0)          initial dcl 3-90
scratch_area                           based           area(1024)               dcl 3-92
seg_info_nfiles                        automatic       fixed bin(17,0)          dcl 2-47
status_area_ptr                        automatic       pointer                  dcl 5-47
status_entry_names                     based           char(32)                 array dcl 5-47
status_link                            based           structure                level 1 dcl 5-38
status_pathname                        based           char                     dcl 5-47
want_external_sw                       defined         bit(1)                   packed unaligned dcl 54
work_area                              based           area(1024)               dcl 3-94

NAMES DECLARED BY EXPLICIT CONTEXT.
CANT_INITIATE                   000502 constant        label                    dcl 155 ref 166
CHECK_REFNAME                   001524 constant        label                    dcl 248 ref 228
MAIN_RETURN                     002121 constant        label                    dcl 330 set ref 305 308 322 327
RECORDED_MESSAGE                002115 constant        label                    dcl 325 ref 145 159 205 246
probe_find_procedure_           000152 constant        entry                    external dcl 37

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2626        2712    2326        2636
Length      3256    2326        64         327     277           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
probe_find_procedure_               618 external procedure  is an external procedure.  
begin block on line 248                 begin block         shares stack frame of external procedure probe_find_procedure_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
probe_find_procedure_    000100 switches                    probe_find_procedure_
                         000102 segp                        probe_find_procedure_
                         000104 unique_refname_ptr          probe_find_procedure_
                         000106 assume_ref                  probe_find_procedure_
                         000107 actual_dn                   probe_find_procedure_
                         000161 dir_name                    probe_find_procedure_
                         000233 pathname                    probe_find_procedure_
                         000320 actual_en                   probe_find_procedure_
                         000330 entry_name                  probe_find_procedure_
                         000340 refname                     probe_find_procedure_
                         000350 segname                     probe_find_procedure_
                         000360 unique_refname              probe_find_procedure_
                         000370 entry_point                 probe_find_procedure_
                         000400 explicit_entry_sw           probe_find_procedure_
                         000401 code                        probe_find_procedure_
                         000402 offset                      probe_find_procedure_
                         000403 offset_string               probe_find_procedure_
                         000414 sourcep                     probe_find_procedure_
                         000416 hp                          probe_find_procedure_
                         000420 probe_info_ptr              probe_find_procedure_
                         000422 ci                          probe_find_procedure_
                         000472 status_ptr                  probe_find_procedure_
                         000474 seg_uid                     begin block on line 248
                         000475 status_branch_auto          begin block on line 248

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             call_ext_out_desc   call_ext_out        return_mac          ext_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
component_info_$name          cv_oct_check_                 expand_pathname_              get_wdir_
hcs_$fs_get_path_name         hcs_$get_uid_seg              hcs_$initiate                 hcs_$make_ptr
hcs_$status_long              pathname_                     probe_error_$record           probe_error_$warning
probe_seg_info_               probe_stack_trace_$find_proc_frame                          stu_$find_containing_block
stu_$get_map_index            term_$single_refname          unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$namedup          error_table_$no_ext_sym       probe_et_$no_map              probe_et_$recorded_message




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     37 000145       114 000165       115 000171       116 000174       118 000176       119 000201       121 000203
    123 000217       124 000220       125 000231       126 000233       127 000244       128 000263       129 000264
    130 000275       131 000277       132 000310       133 000313       134 000332       136 000333       137 000334
    138 000337       141 000342       142 000366       143 000370       145 000421       148 000422       149 000425
    153 000434       154 000476       155 000502       159 000565       161 000566       163 000572       164 000613
    166 000655       168 000661       172 000736       175 000737       176 000741       177 000753       178 000754
    179 000765       180 001003       183 001012       184 001013       185 001025       186 001027       187 001040
    188 001043       189 001062       191 001063       192 001064       193 001067       200 001072       201 001076
    202 001123       203 001125       205 001160       207 001161       209 001162       211 001172       213 001175
    214 001226       216 001235       217 001267       218 001273       219 001315       222 001327       227 001365
    228 001367       231 001370       239 001430       243 001452       244 001456       246 001523       248 001524
    263 001526       265 001530       266 001537       268 001577       269 001605       270 001620       274 001626
    276 001660       286 001767       288 002006       290 002013       292 002015       295 002017       297 002022
    302 002037       303 002043       304 002046       305 002047       308 002050       311 002052       312 002055
    314 002061       317 002077       321 002113       322 002114       325 002115       327 002120       330 002121
    332 002124


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
