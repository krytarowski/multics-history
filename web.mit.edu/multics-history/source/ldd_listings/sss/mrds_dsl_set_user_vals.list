	COMPILATION LISTING OF SEGMENT mrds_dsl_set_user_vals
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/01/88  1336.7 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 
       11 /****^  HISTORY COMMENTS:
       12*  1) change(87-01-22,Hergert), approve(88-07-11,MCR7903),
       13*     audit(88-07-07,Dupuis), install(88-08-01,MR12.2-1073):
       14*     For new parser, changed references of sel_ptr to select_list_ptr.
       15*                                                   END HISTORY COMMENTS */
       16 
       17 
       18 
       19 mrds_dsl_set_user_vals:
       20     procedure (dbcb_ptr, area_ptr, argp_ptr, descp_ptr, num_args, arg_sel_ptr,
       21         code);
       22 
       23 /* HISTORY: 
       24*   84-07-19 Hergert: Extracted from mrds_dsl_select_clause. This was done
       25*   to avoid expensive initializations in mrds_dsl_select_clause that werent
       26*   necessary when processing -another's. update_movelists was eliminated
       27*   and the code was put inline in the entry "another" */
       28 
       29         select_list_ptr = arg_sel_ptr;
       30         call set_u_vals;
       31         code = 0;
       32         return;
       33 
       34 another:
       35     entry (dbcb_ptr, area_ptr, argp_ptr, descp_ptr, num_args, code);
       36 
       37 /* This entry is called by translate to reset the user value items in
       38*   the select list to correspond to the new arguments in case of a -another. */
       39 
       40         select_list_ptr = dbcb.select_ptr;
       41         call set_u_vals;				/* this is the beginning of what was update_movelist */
       42         do k = 1 to select_list.num_vars;		/* loop through for each var */
       43 	  ml_ptr = move_list_array.ml_ptr (k);
       44 	  mli = 0;
       45 	  do i = 1 to select_list.num_items;		/* update each item */
       46 	      if select_list.item.var_index (i)
       47 		= move_list_array.var_index (k) then do;
       48 		mli = mli + 1;
       49 		move_list.item.attr_index (mli) =
       50 		    select_list.item.ai_ptr (i) -> rm_attr_info.defn_order;
       51 		move_list.item.user_ptr (mli) =
       52 		    select_list.item.user_ptr (i);
       53 		move_list.item.user_desc_ptr (mli) =
       54 		    select_list.item.user_desc_ptr (i);
       55 	      end;
       56 	  end;
       57         end;					/* this is the end of what was update movelist */
       58 
       59         code = 0;
       60 exit:
       61         return;					/* that's all, folks */
       62 
       63 error:
       64     proc (cd);
       65 
       66 /* Internal error procedure */
       67 
       68 dcl     cd		 fixed bin (35);		/* internal status code */
       69 
       70         code = cd;					/* pass bad news back to caller */
       71         go to exit;
       72 
       73     end error;
       74 
       75 set_u_vals:
       76     proc;						/* Procedure to fill in user value items in the select list */
       77 
       78         arg_ptr = null;				/* initialize */
       79 
       80         pa_size = num_args;				/* set size of template array */
       81         desc_ptr = descp_ptr -> ptr_array (num_args);	/* get last of value args */
       82         skip_flag = "0"b;
       83 
       84         if descriptor.type = STRUCTURE then do;		/* if everything included in structure */
       85 
       86 	  call mu_break_structure (area_ptr,
       87 	      argp_ptr -> ptr_array (num_args),
       88 	      descp_ptr -> ptr_array (num_args), arg_ptr, arg_count, icode);
       89 	  if icode ^= 0 then call error (icode);
       90 	  if arg_count ^= select_list.num_items then do;	/* if no. components doesn't match no. sel. items */
       91 	      dbcb.val_mod, dbcb.val_rtrv = "0"b;
       92 	      skip_flag = "1"b;
       93 	  end;
       94 
       95 	  else do;
       96 	      num_args = num_args - 1;		/* update unused value counter */
       97 	      pa_size = arg_count;			/* set size of template array */
       98 	      a_ptr = addr (str_args (1));		/* point to first of arg pointers */
       99 	      d_ptr = addr (str_args (arg_count + 1));	/* point to first of desc. pointers */
      100 	      was_structure = "1"b;			/* remember was struct. */
      101 	  end;
      102 
      103         end;					/* breaking up structure */
      104 
      105         else do;					/* if value for each select item specified separately */
      106 
      107 	  if select_list.num_items > num_args then do;	/* if not enougn values to cover all items */
      108 	      dbcb.val_mod, dbcb.val_rtrv = "0"b;
      109 	      skip_flag = "1"b;
      110 	  end;
      111 
      112 	  else do;
      113 	      num_args = num_args - select_list.num_items;/* update unused value count, we will use sufficient values from the end of the list to cover all select items. */
      114 
      115 	      a_ptr = addr (argp_ptr -> ptr_array (num_args + 1));
      116 						/* point to first used arg pointer */
      117 	      d_ptr = addr (descp_ptr -> ptr_array (num_args + 1));
      118 						/* point to first used desc. pointer */
      119 	      pa_size = select_list.num_items;		/* set template size */
      120 	      was_structure = "0"b;			/* remember was not struct. */
      121 	  end;
      122 
      123         end;					/* item values specified separately */
      124 
      125         if ^skip_flag then do;			/* if have user values to set */
      126 
      127 	  do i = 1 to select_list.num_items;		/* for each specified select item */
      128 
      129 	      select_list.item.user_desc_ptr (i), desc_ptr =
      130 		d_ptr -> ptr_array (i);		/* pick up pointer to current value descriptor */
      131 	      rdi_ptr =
      132 		select_list.item.ai_ptr (i) -> rm_attr_info.domain_ptr;
      133 
      134 	      if desc_ptr -> bit36
      135 		= rm_domain_info.user_desc /* if no conversion required */
      136 		| descriptor.type = STRUCTURE
      137 		| descriptor.number_dims ^= "0"b then do;
      138 
      139 		select_list.item.must_convert (i) = "0"b;
      140 						/* remember no conversion required */
      141 		select_list.item.user_ptr (i) = a_ptr -> ptr_array (i);
      142 						/* pick up pointer to user value */
      143 		if ^was_structure
      144 		then /* if vals. specified separately */
      145 		     if descriptor.type = VAR_CHAR
      146 		         | descriptor.type = VAR_BIT
      147 		     then /* if varying */
      148 			select_list.item.user_ptr (i) =
      149 			    addrel (select_list.item.user_ptr (i), -1);
      150 						/* to include length */
      151 
      152 	      end;				/* if no conversion required */
      153 
      154 	      else do;				/* if conversion is required */
      155 
      156 		select_list.item.must_convert (i) = "1"b;
      157 						/* remember to convert */
      158 		select_list.item.user_ptr (i) = a_ptr -> ptr_array (i);
      159 						/* pick up pointer to user value */
      160 		if ^was_structure
      161 		then /* if vals. specified separately */
      162 		     if descriptor.type = VAR_CHAR
      163 		         | descriptor.type = VAR_BIT
      164 		     then /* if varying */
      165 			select_list.item.user_ptr (i) =
      166 			    addrel (select_list.item.user_ptr (i), -1);
      167 						/* to include length */
      168 
      169 		if ^mu_valid_data_type$valid_scalar_data_type (desc_ptr
      170 		    -> bit36)
      171 		then call error (mrds_error_$bad_select_value);
      172 						/* if unsupported data type */
      173 
      174 	      end;				/* where conversion is required */
      175 
      176 	  end;					/* filling in user value info. */
      177 
      178 	  if arg_ptr ^= null then arg_ptr = null;
      179 
      180         end;					/* if had user values */
      181     end set_u_vals;
      182 
  1     1 /* BEGIN mrds_dbcb.incl.pl1 -- jaw, 11/7/78 */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  1     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  1     8*     This entry is being made to cover the change made on 85-07-01 by Thanh
  1     9*     Nguyen. The scopes_changed flag was added to make checking for this
  1    10*     more efficient (mrds error list #137).
  1    11*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
  1    12*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
  1    13*     Add a bit called dont_check_txn_id to indicate whether or not we should
  1    14*     care if multiple txns use the same selection_expression. (mrds #156)
  1    15*  3) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  1    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  1    17*     Added parser_work_area_ptr and mrds_se_info_ptr for new parser.
  1    18*                                                   END HISTORY COMMENTS */
  1    19 
  1    20 
  1    21 /* WARNING
  1    22*          If the dbcb structure is changed then the mrds_data_
  1    23*          item saved_res_version MUST be incremented to invalidate all
  1    24*          existing saved resultants
  1    25**/
  1    26 
  1    27 /* HISTORY :
  1    28*
  1    29*   modified by Jim Gray - - 80-10-24, to add new_select_expr bit for
  1    30*   tid_list management
  1    31*
  1    32*   81-1-9 Jim Gray : added like reference for  ease  in  making  the
  1    33*   phony resultant in mu_database_index, without having the area dcl
  1    34*   included.
  1    35*
  1    36*   81-06-17 Roger Lackey :  added  last_store_rel_name  for  use  by
  1    37*   mrds_dsl_store
  1    38*
  1    39*   81-06-26 Roger Lackey : Added no_optimize and  print_search_order
  1    40*   switches
  1    41*
  1    42*   81-07-06 Jim Gray : added identifier for  the  current  selection
  1    43*   expression,  so  that relation statistics can be updated relative
  1    44*   to number of selection expressions seem. Also  removed  init  for
  1    45*   last_store_rel_name,   as   this   iw   now   properly   done  in
  1    46*   mrds_dsl_init_res.
  1    47*
  1    48*   81-07-17  Roger Lackey : added pred_ptr and unused_ptrs.
  1    49*
  1    50*   82-08-19  Mike Kubicar : added store_vector field.  This is needed
  1    51*   for the conversion to the relation manager.
  1    52*
  1    53*   82-08-23 Davids: added the relmgr_entries and access_costs
  1    54*   substructures so that the entries and costs can change
  1    55*   depending on the type of database that is opened.
  1    56*
  1    57*   82-09-09 Mike Kubicar : added modify_vector field.  This is needed
  1    58*   since modify uses a different vector type (general) than does store.
  1    59*
  1    60*   82-09-20 Davids: changed names of (store modify)_vector to
  1    61*   (store modify)_vector_ptr. Also (delete modify)_tuple_by_id to
  1    62*   (delete modify)_tuples_by_id. added the element cursor_storage_ptr
  1    63*   which should be inited to null and will be set by mu_cursor_manager_$get
  1    64*   during the first call.
  1    65*
  1    66*   82-09-21 Davids: renamed cursor_storage_ptr to cursor_ptrs_storage_ptr
  1    67*   since it deals with the pointers to the cursors and not the cursors
  1    68*   themelves and added the element cursor_storage_area_ptr which points
  1    69*   to the area where the cursors are kept.
  1    70*
  1    71*   82-09-22 Davids: renamed the transact_ctl_seg to transactions_needed.
  1    72*   the transact_ctl_seg always had a value of 0 and really didn't mean
  1    73*   anything.
  1    74*
  1    75*   82-09-22 Mike Kubicar : added create_relation, create_index and
  1    76*   destroy_relation_by_opening to relmgr_entries.  They are needed
  1    77*   by mrds_dsl_define_temp_rel.
  1    78*
  1    79*   82-09-24 Donna Woodka : added  put_tuple to  relmgr_entries. It
  1    80*   is needed by mu_store.
  1    81*
  1    82*   82-11-12 Davids: changed the declaration of the access_costs from fixed
  1    83*   bin to float bin since the values are not integers.
  1    84*
  1    85*   83-02-02 Davids: added the dbc_uid element. This will allow mrds to make
  1    86*   sure that the dbc_ptr still points to the correct segment. Element was 
  1    87*   added to the end of the structure to allow modules that don't use
  1    88*   the element to continue to reference the dbcb structure without recompiling.
  1    89*
  1    90*   83-02-25 Davids: added the concurrency_on and rollback_on elements. These
  1    91*   are needed so that temp rels can be created with the same file attributes
  1    92*   as the permanent relations.
  1    93*
  1    94*   83-05-02 Mike Kubicar : Deleted get_next_search_specification_ptr and
  1    95*   added the resultant_in_pdir bit.
  1    96*
  1    97*   83-05-18 Davids: reduced the number of reserved bits to 14 (from 15) and
  1    98*   added the res_already_made element.
  1    99*
  1   100*   83-05-24 Mike Kubicar : Updated the relation manager calling sequences.
  1   101*
  1   102*   83-08-03 Mike Kubicar : Added the element_id_list_segment_ptr and removed
  1   103*   one of the unused pointers.
  1   104*
  1   105*   83-09-20 Ron Harvey: Added relmgr_entries.get_population.
  1   106*
  1   107*   84-08-27 John Hergert:  Created compiled_se_info_ptr from unused_ptrs(2)
  1   108*   leaving unused_ptrs(1).
  1   109*
  1   110*   85-01-15 Thanh Nguyen:  Added the work_area_ptr and removed the last
  1   111*   unused_ptrs (1).
  1   112*
  1   113*   85-04-12 Thanh Nguyen:  Added user_started_transaction and 
  1   114*   non_shared_to_shared flags.  Also added se_transaction_id and some more
  1   115*   spare ptrs, entries and reserved storages for future enhancement, since
  1   116*   we changed the saved_res_version from rslt0001 to rslt0002.
  1   117*
  1   118*   85-07-01 Thanh Nguyen:  Added scopes_changed flag.  This flag is set by
  1   119*   common routine of mrds_dsl_set_scope, reset by mrds_dsl_optimize and 
  1   120*   mrds_dsl_gen_srch_prog when building of a new search_vars.
  1   121**/
  1   122 
  1   123 
  1   124 /* this structure is based on the {unique_name}.mrds.dbcb segment
  1   125*   that constitutes the non-secure portion of the resultant model that is
  1   126*   created during the opening of a database. it contains variables that
  1   127*   are used during the runtime access of the database, and an area
  1   128*   for evaluation of requests. it points to four other
  1   129*   segments in the resultant model, {unique_name}.mrds.rdbi, the secure
  1   130*   portion of the resultant(see mdbm_rm_db_info.incl.pl1),
  1   131*   {unique_name}.mrds.select, an area for selection expression evaluation,
  1   132*   {unique_name}.mrds.curdat, and {unique_name}.mrds.stadat, two segments
  1   133*   used in the elimination of duplicate tuples during a retrieve.
  1   134*   the dbcb area holds the structure in mdbm_scope_info.incl.pl1
  1   135*   that is used when the database is using the file scope mechanism
  1   136*   for concurrency control over file readying. the segment overlayed via
  1   137*   mrds_dbc.incl.pl1 structure is pointed to and also handles concurrency control,
  1   138*   across database openings. the pointer to this dbcb structure is kept in a table
  1   139*   which associates database indexes(returned from a call to dsl_$open), with particular
  1   140*   opening instances of resultant models. (see mu_database_index routine) */
  1   141 
  1   142      dcl	   1 dbcb		      aligned based (dbcb_ptr), /* DBCB -- non-secure portion */
  1   143 	     2 data	      like dbcb_data,
  1   144 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (dbcb.static_area))));
  1   145 
  1   146      dcl	   dbcb_ptr	      ptr;
  1   147 
  1   148      declare 1 dbcb_data	      based,		/* info part of dbcb, separated out so that
  1   149*						   like references can avoid getting the area declaration */
  1   150 	     2 rdbi_ptr	      ptr,		/* pointer to write protected mdbm_util_ info. */
  1   151 	     2 range_ptr	      ptr,		/*  ptr to range structure, or null */
  1   152 	     2 select_ptr	      ptr,		/* ptr to select list, or null */
  1   153 	     2 sv_ptr	      ptr,		/* pointer to search variables */
  1   154 	     2 so_ptr	      ptr,		/* pointer to search operators */
  1   155 	     2 ti_ptr	      ptr,		/* pointer to tuple info */
  1   156 	     2 lit_ptr	      ptr,		/* pointer to the literal area, or null */
  1   157 	     2 current_ptr	      ptr,		/* ptr to select list resulting from -current clause */
  1   158 	     2 ss_ptr	      ptr,		/* ptr to select sets block if not simple s.e. */
  1   159 	     2 retr_info_ptr      ptr,		/* ptr to retrieve info area */
  1   160 	     2 trel_info_ptr      ptr,		/* ptr to retrieve info area */
  1   161 	     2 sti_ptr	      ptr,		/* pointer to store info */
  1   162 	     2 dbc_ptr	      ptr,		/*  pointer to the data base control segment */
  1   163 	     2 sfi_ptr	      ptr,		/* points to head of scalar function list */
  1   164 	     2 scope_ptr	      ptr,		/* points to array of scope tuples */
  1   165 	     2 select_area_ptr    ptr,		/* ptr to area for current selection expression allocations */
  1   166 	     2 current_data_ptr   ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  1   167*						   for eliminating duplicate tuples. */
  1   168 	     2 static_data_ptr    ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  1   169*						   for eliminating duplicate tuples. */
  1   170 	     2 store_area_ptr     ptr,		/* temp storage area for dsl_$store */
  1   171 	     2 retrieve_area_ptr  ptr,		/* temp storage for dsl_$retrieve */
  1   172 	     2 modify_area_ptr    ptr,		/* temp storage area for dsl_$modify */
  1   173 	     2 delete_area_ptr    ptr,		/* temp storage area for dsl_$delete */
  1   174 	     2 def_temp_rel_area_ptr ptr,		/* temp storage area for dsl_$define_temp_rel */
  1   175 	     2 pred_ptr	      ptr,		/* Pointer to pred_array */
  1   176 	     2 store_vector_ptr   ptr,		/* Vector structure used during store operations */
  1   177 	     2 modify_vector_ptr  ptr,		/* Used during modifies */
  1   178 	     2 element_id_list_segment_ptr ptr,		/* Points to the segment used to hold element_id_list structures */
  1   179                2 compiled_se_info_ptr ptr,                  /* points to the segment containing all info on compiled sexs */
  1   180 	     2 work_area_ptr        ptr,		/* Work area for encode/decode value allocations in mu_retrieve */
  1   181 	     2 se_info_ptr          ptr,                  /* Points to se_info struct. Primarily for error reports */
  1   182 	     2 parser_work_area_ptr ptr,		/*  work area for parser */
  1   183 	     2 reserved_ptrs      (4) ptr,		/* Reserved for future use */
  1   184 	     2 another_flag	      bit (1) unal,		/* on if predicate was -another */
  1   185 	     2 current_flag	      bit (1) unal,		/* on if predicate was -current clause */
  1   186 	     2 dbc_incr	      bit (1) unal,		/* on if dbc open mode has been incremented for this user */
  1   187 	     2 delete_flag	      bit (1) unal,		/* On if search was called from mrds_dsl_sec_delete */
  1   188 	     2 dup_retain	      bit (1) unaligned,	/* On if dup tuples allowed for retrieval */
  1   189 	     2 prev_select	      bit (1) unal,		/* on if prev. select block processed in this s.e. */
  1   190 	     2 possible_op	      bit (1) unal,		/* on of arith op. allowed */
  1   191 	     2 sel_clause	      bit (1) unal,		/* on if currently in select clause */
  1   192 	     2 dsm_sw	      bit (1) unal,		/* on if data base was opened via data submodel */
  1   193 	     2 val_rtrv	      bit (1) unal,		/* if s.e. valid for retrieve */
  1   194 	     2 val_mod	      bit (1) unal,		/* for modify */
  1   195 	     2 val_del	      bit (1) unal,		/* for delete */
  1   196 	     2 val_dtr	      bit (1) unal,		/* for define temp rel */
  1   197 	     2 transactions_needed bit (1) unal,	/* On => transaction must be started or in progress does
  1   198*                                                                     not imply that the database is of type page_file */
  1   199 	     2 open_mode	      bit (3) unal,		/* 0=>unknown, 1=>r, 2=>u, 3=>er, 4=>eu, >4=>bad */
  1   200 	     2 new_select_expr    bit (1) unal,		/* on => starting a new tid list management period */
  1   201 	     2 no_optimize	      bit (1) unal,		/* On => no optimize */
  1   202 	     2 print_search_order bit (1) unal,		/*  On => print the search order */
  1   203 	     2 resultant_in_pdir  bit (1) unal,		/* On => Temp segments are in the process dir */
  1   204 	     2 res_already_made   bit (1) unal,           /* On => resultant has been made based on a saved copy */
  1   205 	     2 user_started_transaction bit (1) unal,     /* On => user already started his own transaction. */
  1   206 	     2 non_shared_to_shared bit (1) unal,         /* On => user changed the scope from non shared to shared
  1   207*						   inside a sequence of -another selection expression. */
  1   208 	     2 scopes_changed     bit (1) unal,           /* On => scopes had been changed by set_scopes or delete_scopes */
  1   209 	     2 dont_check_txn_id  bit (1) unal,           /* On => cpmd needs same selection exp across multiple txns */
  1   210 	     2 reserved	      bit (10) unal,	/* reserved for future use */
  1   211 	     2 nseq_sch	      fixed bin (35),	/* no. tuples located via sequential search */
  1   212 	     2 nind_sch	      fixed bin (35),	/* no. tuples located via index search */
  1   213 	     2 nhash_sch	      fixed bin (35),	/* no. tuples located via hash search */
  1   214 	     2 nlk_sch	      fixed bin (35),	/* no tuples located via link search */
  1   215 	     2 cur_lit_offset     fixed bin (35),	/* current bit offset in literal string */
  1   216 	     2 dbi	      fixed bin (35),	/* database index for this opening */
  1   217 	     2 last_s_e_id_num    fixed bin (35),	/* identifying number for last selection expression seen */
  1   218 	     2 se_transaction_id  bit (36) aligned,       /* transaction id from beginning of select expression */
  1   219 	     2 last_store_rel_name char (32),		/* Name of relation last used  for store */
  1   220 	     2 cursor_ptrs_storage_ptr ptr,		/* pointer to space where cursor ptrs are stored */
  1   221 	     2 cursor_storage_area_ptr ptr,		/* pointer to area where the cursors are kept */
  1   222 	     2 reserved_words     (10) fixed bin (35),	/* Reserved for future use */
  1   223 	     2 relmgr_entries,			/* relation manager entries */
  1   224 	       3 open	      entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  1   225 	       3 close	      entry (bit (36) aligned, fixed bin (35)),
  1   226 	       3 create_cursor    entry (bit (36) aligned, ptr, ptr, fixed bin (35)),
  1   227 	       3 destroy_cursor   entry (ptr, ptr, fixed bin (35)),
  1   228 	       3 set_scope	      entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35)),
  1   229 	       3 delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  1   230 	       3 modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35)),
  1   231 	       3 get_tuple_by_id  entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  1   232 	       3 get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)),
  1   233 	       3 get_tuple_id     entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  1   234 	       3 put_tuple	      entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  1   235 	       3 get_count	      entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  1   236 	       3 get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35)),
  1   237 	       3 get_population   entry (ptr, fixed bin (35), fixed bin (35)),
  1   238 	       3 create_relation  entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)),
  1   239 	       3 create_index     entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35)),
  1   240 	       3 destroy_relation_by_path entry (char (*), char (*), fixed bin (35)),
  1   241 	       3 reserved_entries (5) entry (),
  1   242 	     2 access_costs,			/* access costs for permute */
  1   243 	       3 total_primary_key_cost float bin,
  1   244 	       3 access_cost      float bin,
  1   245 	       3 access_overhead  float bin,
  1   246 	       3 us_access_cost   float bin,
  1   247 	       3 os_access_cost   float bin,
  1   248 	     2 dbc_uid	      bit (36) aligned,	/* uid of the segment containing the dbc structure */
  1   249 	     2 concurrency_on     bit (1) unal,		/* "1"b implies dmfile concurrency is being used */
  1   250 	     2 rollback_on	      bit (1) unal;		/* "1"b iomplies before journaling is to be done */
  1   251 
  1   252 /* END mrds_dbcb.incl.pl1 */
  1   253 
  1   254 
      183 
      184 
  2     1 /* BEGIN mrds_select_list.incl.pl1 -- jaw 10/20/78 */
  2     2 
  2     3 /* HISTORY:
  2     4*
  2     5*   81-06-01 Jim Gray : removed user len and type elements,
  2     6*   since mu_convert rather than assign_ is now used.
  2     7*
  2     8*   84-11-22 John Hergert: added fr_ptr
  2     9*
  2    10*/****^  HISTORY COMMENTS:
  2    11*  1) change(86-07-17,Dupuis), approve(86-08-05,MCR7491), audit(86-08-08,Blair),
  2    12*     install(86-08-15,MR12.0-1127):
  2    13*     85-11-22 Hergert: Added variable var_exists so that it may be kept
  2    14*     around per select expression (in sets) and when compiling. (mrds #158)
  2    15*  2) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  2    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  2    17*     For new parser, (and general readability) renamed sel_ptr to
  2    18*     select_list_ptr.
  2    19*                                                   END HISTORY COMMENTS */
  2    20 
  2    21 
  2    22 dcl 1 select_list based (select_list_ptr),			/* tabular representation of -select clause */
  2    23     2 num_vars fixed bin,				/* number of free variables */
  2    24     2 mla_ptr ptr,					/* pointer to array of move list pointers */
  2    25     2 fr_ptr ptr,                                           /* pointer to free_raltions struct in mrds_dsl_select_clause */
  2    26     2 num_items fixed bin,				/* number of attributes specified in select list */
  2    27     2 var_exists (36) bit(1),
  2    28     2 item (mrds_data_$max_select_items refer (select_list.num_items)),
  2    29       3 must_convert bit (1) unal,			/* on if conversion required */
  2    30       3 key bit (1) unal,				/* on if to be key attr. in temp. rel. */
  2    31       3 index bit (1) unal,				/* on if index attribute in temp rel */
  2    32       3 reserved bit (33) unal,			/* reserved for future use */
  2    33       3 var_index fixed bin,				/*  index of assoc. tuple variable */
  2    34       3 ai_ptr ptr,					/* ptr to attr_info */
  2    35       3 user_desc_ptr ptr,				/* to descriptor for user value */
  2    36       3 user_ptr ptr ;				/* pointer to user's area */
  2    37 
  2    38 dcl  select_list_ptr ptr int automatic init (null ());
  2    39 
  2    40 dcl 1 move_list_array (select_list.num_vars) based (select_list.mla_ptr),
  2    41     2 var_index fixed bin,
  2    42     2 ml_ptr ptr;
  2    43 
  2    44 /* END mrds_select_list.incl.pl1 */
  2    45 
      185 
      186 
  3     1 /*  BEGIN  mdbm_rm_attr_info.incl.pl1  --  jaw,  11/16/78  */
  3     2 
  3     3 /* WARNING
  3     4*          If the rm_attr_info structure is changed then the mrds_data_
  3     5*          item saved_res_version MUST be incremented to invalidate all
  3     6*          existing saved resultants
  3     7**/
  3     8 
  3     9 /*
  3    10*
  3    11*   Modified  by  Jim  Gray - - 80-11-05, to add mdbm_secured bit, so
  3    12*   that rm_rel_info does not have to be checked
  3    13*
  3    14*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
  3    15*   foreign keys.
  3    16*
  3    17*   82-08-19  D. Woodka : removed rm_attr_info.bit_offset for the DMS
  3    18*   conversion.
  3    19*
  3    20*   82-09-15 Davids: added the number_of_dups field.
  3    21*
  3    22*   82-09-20 Mike Kubicar : changed the index_id field to be bit (36)
  3    23*   aligned.  This is to conform with the new definition in the database
  3    24*   model.  Also removed the now useless field varying.
  3    25*
  3    26*   82-11-05 Davids: added the field model_defn_order and clarified the
  3    27*   comment for the field defn_order.
  3    28*
  3    29*   83-05-23 Mike Kubicar : changed number_of_dups to fixed bin (35) since
  3    30*   that's what relation manager returns.
  3    31*
  3    32**/
  3    33 
  3    34 
  3    35 /*
  3    36*   this   structure   is   allocated   in   the   static   area   of
  3    37*   mdbm_rm_db_info.incl.pl1  once for each attribute per relation in
  3    38*   a     readied     file.      it     in     turn     points     to
  3    39*   mdbm_rm_domain_info.incl.pl1  for  the  attributes  domain.   the
  3    40*   rm_attr_info  is  pointed  to  by mdbm_rm_rel_info.incl.pl1.  all
  3    41*   structures  are  in  the  rm_db_info  area.   the  attribute data
  3    42*   position  within  a  tuple as stored in the data file are kept in
  3    43*   this resultant model of the attribute.
  3    44* */
  3    45 
  3    46 dcl 1 rm_attr_info aligned based (rai_ptr),		/* resultant attr. info */
  3    47     2 name char (32),				/* from submodel */
  3    48     2 model_name char (32),				/* from model */
  3    49     2 key_attr bit (1) unal,				/* if key attribute */
  3    50     2 index_attr bit (1) unal,			/* if secondary index */
  3    51     2 read_perm bit (1) unal,				/* user has retr. permission */
  3    52     2 modify_perm bit (1) unal,			/* user has modify permission */
  3    53     2 mdbm_secured bit (1) unal,			/* on => database secured */
  3    54     2 reserved bit (30) unal,				/* for future use */
  3    55     2 index_id bit (36) aligned,			/* index id if index_attr */
  3    56     2 defn_order fixed bin,				/* relative order in which attr is defined in the view */
  3    57     2 key_order fixed bin,				/* relative order defined in prim. key */
  3    58     2 bit_length fixed bin (35),			/* length if fixed, max. len. if var. */
  3    59     2 domain_ptr ptr,				/* to domain info */
  3    60     2 number_of_dups fixed bin (35),                        /* if the attribute is indexed this will
  3    61*                                                               be the number of duplicate values, exact
  3    62*                                                               for a page_file database, an estimate for a vfile type */
  3    63     2 model_defn_order fixed bin;                           /* relative order in which attr is defined in the model */
  3    64 
  3    65 dcl  rai_ptr ptr int automatic init (null ());
  3    66 
  3    67 /* END mdbm_rm_attr_info.incl.pl1 */
  3    68 
  3    69 
      187 
      188 
  4     1 /* BEGIN mdbm_move_list.incl.pl1 -- jaw, 7/13/78 */
  4     2 
  4     3 /* HISTORY:
  4     4*
  4     5*   81-06-01 Jim Gray : removed assn type and len elements,
  4     6*   now that mu_convert is used.
  4     7*
  4     8**/
  4     9 
  4    10 
  4    11 dcl 1 move_list aligned based (ml_ptr),			/* info for moving data in and out of tuple */
  4    12     2 nitems fixed bin,				/* number of items */
  4    13     2 item (ml_nitems_init refer (move_list.nitems)),
  4    14       3 attr_index fixed bin,				/* index to attr info in rel_info */
  4    15       3 user_ptr ptr,				/* pointer to user data value */
  4    16       3 user_desc_ptr ptr;				/* pointer to descriptor for user */
  4    17 
  4    18 dcl  ml_ptr ptr;
  4    19 dcl  ml_nitems_init fixed bin;
  4    20 
  4    21 /* END mdbm_move_list.incl.pl1 */
  4    22 
      189 
      190 
  5     1 /* BEGIN mdbm_rm_domain_info.incl.pl1 -- jaw, 9/26/78 */
  5     2 
  5     3 /* WARNING
  5     4*          If the rm_domain_info structure is changed then the mrds_data_
  5     5*          item saved_res_version MUST be incremented to invalidate all
  5     6*          existing saved resultants
  5     7**/
  5     8 
  5     9 /* DESCRIPTION:
  5    10*
  5    11*   This  structure  is  allocated  in  the  mdbm_rm_db_info.incl.pl1
  5    12*   static  area,  once per attribute used in a relation in a readied
  5    13*   file. it is pointed to by the mdbm_rm_attr_info.incl.pl1, and may
  5    14*   point  to  mdbm_rm_ck_and_group.incl.pl1  if  a  "-check"  option
  5    15*   boolean expression was declared for this domain. it contains  the
  5    16*   descriptor  for  this domain data type, and other resultant model
  5    17*   information.
  5    18*
  5    19*
  5    20*   HISTORY:
  5    21*
  5    22*   81-05-06  Rickie  E.  Brinegar:  Modified  ck_proc,  encode_proc,
  5    23*   decode_proc to be entry variables instead of entry pointers. This
  5    24*   allows these programs to be written in languages other than pl1.
  5    25*
  5    26*   81-05-28 Jim Gray : removed unused procedure points,  and  unused
  5    27*   check  stack  structure  elements.  Also made the descriptors bit
  5    28*   (36) in this structure, rather than pointers to  the  descriptors
  5    29*   elsewhere.  Also  removed un-needed redundant assign_ parameters,
  5    30*   that are actually available in the descriptors.
  5    31*
  5    32*
  5    33**/
  5    34 
  5    35 dcl 1 rm_domain_info aligned based (rdi_ptr),		/* domain information */
  5    36     2 name char (32),				/* domain name */
  5    37     2 db_desc bit (36),				/*  to desc. for db. */
  5    38     2 user_desc bit (36),				/* desc for user visible data */
  5    39     2 user_bit_len fixed bin,				/* storage length of users data */
  5    40     2 ck_proc_entry entry variable,			/* to check proc. entry */
  5    41     2 encd_proc_entry entry variable,			/* to encode proc entry */
  5    42     2 decd_proc_entry entry variable,			/* to decode proc entry */
  5    43     2 ck_proc bit (1) unal,				/* Is there a check proc */
  5    44     2 encd_proc bit (1) unal,				/* Is there an encode proc */
  5    45     2 decd_proc bit (1) unal,				/* Is there a decode proc */
  5    46     2 pad bit (33) unal,
  5    47     2 next_domain_ptr ptr ;				/* to next domain, in list of all domains */
  5    48 						/* to check stack and groups */
  5    49 
  5    50 
  5    51 dcl  rdi_ptr ptr int automatic init (null ());
  5    52 
  5    53 /* END mdbm_rm_domain_info.incl.pl1 */
  5    54 
  5    55 
      191 
      192 
  6     1 /* BEGIN mdbm_descriptor.incl.pl1 -- jaw 5/31/78 */
  6     2 /* modified by Jim Gray - - Nov. 1979, to change type from fixed bin(5) to
  6     3*   unsigned fixed bin(6), so new packed decimal data types could be handled.
  6     4*   also the duplicate mrds_descriptor.incl.pl1 was eliminated. */
  6     5 
  6     6 dcl 1 descriptor based (desc_ptr),			/* map of Multics descriptor */
  6     7     2 version bit (1) unal,				/* DBM handles vers. 1 only */
  6     8     2 type unsigned fixed bin (6) unal,			/* data type */
  6     9     2 packed bit (1) unal,				/* on if data item is packed */
  6    10     2 number_dims bit (4) unal,			/* dimensions */
  6    11     2 size,					/* size for string data */
  6    12       3 scale bit (12) unal,				/* scale for num. data */
  6    13       3 precision bit (12) unal,			/* prec. for num. data */
  6    14     2 array_info (num_dims),
  6    15       3 lower_bound fixed bin (35),			/* lower bound of dimension */
  6    16       3 upper_bound fixed bin (35),			/* upper bound of dimension */
  6    17       3 multiplier fixed bin (35);			/*  element separation */
  6    18 
  6    19 dcl  desc_ptr ptr;
  6    20 dcl  num_dims fixed bin init (0) ;			/* more useful form of number_dims */
  6    21 
  6    22 /* END mdbm_descriptor.incl.pl1 */
  6    23 
  6    24 
      193 
      194 
      195 
      196 dcl     (
      197         argp_ptr,					/* Input/Output -- pointer to next arg pointer */
      198         arg_sel_ptr,
      199         descp_ptr,					/* Input/Output -- pointer to next descriptor pointer */
      200         arg_ptr,					/* pointer to pointer list returned by break_structure */
      201         a_ptr,					/* points to list of arg pointers */
      202         d_ptr
      203         )			 ptr;			/* points to list of descriptor pointers */
      204 
      205 dcl     skip_flag		 bit (1);			/* on if no user vaos to set */
      206 
      207 dcl     (
      208         num_args,					/* Input/Output -- number of unused value args */
      209         i,					/* internal index */
      210         k,					/* internal index */
      211         mli,					/* internal index */
      212         pa_size,					/* current size of ptr_array */
      213         arg_count
      214         )			 fixed bin;		/* number of arguments out of break_structure */
      215 
      216 dcl     (
      217         code,					/* Output -- return code */
      218         icode
      219         )			 fixed bin (35);		/* internal status code */
      220 
      221 dcl     was_structure	 bit (1) unal;		/* on if user vals in structure */
      222 dcl     str_args		 (2 * arg_count) ptr based (arg_ptr);
      223 						/* structure items from break_structure */
      224 dcl     ptr_array		 (pa_size) ptr based;	/* template */
      225 dcl     bit36		 bit (36) based;		/* template */
      226 
      227 dcl     STRUCTURE		 fixed bin (5) int static init (17)
      228 			 options (constant);
      229 dcl     VAR_BIT		 fixed bin (5) int static init (20)
      230 			 options (constant);
      231 dcl     VAR_CHAR		 fixed bin (5) int static init (22)
      232 			 options (constant);
      233 
      234 dcl     (
      235         mrds_error_$bad_select_value,
      236         sys_info$max_seg_size
      237         )			 fixed bin (35) ext;
      238 
      239 dcl     (addr, addrel, fixed, null, rel)
      240 			 builtin;
      241 
      242 /* Multics subroutines */
      243 
      244 /* MRDS subroutines */
      245 
      246 dcl     mu_break_structure	 entry (ptr, ptr, ptr, ptr, fixed bin,
      247 			 fixed bin (35));
      248 dcl     mu_valid_data_type$valid_scalar_data_type
      249 			 entry (bit (36)) returns (bit (1) aligned);
      250 						/* decides if supported data type */
      251 dcl     area_ptr		 ptr;
      252 dcl     continue		 char (1) init ("c");	/* dont stop after printing error mesg */
      253 dcl     info_ptr		 ptr init (null ());	/* unused */
      254 dcl     return_value	 fixed bin (35) init (0);	/* unused */
      255 dcl     caller_name		 char (32) init ("mrds_dsl_set_user_vals");
      256 						/* name of calling module */
      257 
      258     end mrds_dsl_set_user_vals;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/01/88  1300.0  mrds_dsl_set_user_vals.pl1        >special_ldd>install>MR12.2-1073>mrds_dsl_set_user_vals.pl1
183          1    08/01/88  1300.0  mrds_dbcb.incl.pl1                >special_ldd>install>MR12.2-1073>mrds_dbcb.incl.pl1
185          2    08/01/88  1300.0  mrds_select_list.incl.pl1         >special_ldd>install>MR12.2-1073>mrds_select_list.incl.pl1
187          3    10/14/83  1609.1  mdbm_rm_attr_info.incl.pl1        >ldd>include>mdbm_rm_attr_info.incl.pl1
189          4    10/14/83  1608.9  mdbm_move_list.incl.pl1           >ldd>include>mdbm_move_list.incl.pl1
191          5    10/14/83  1609.1  mdbm_rm_domain_info.incl.pl1      >ldd>include>mdbm_rm_domain_info.incl.pl1
193          6    10/14/83  1608.6  mdbm_descriptor.incl.pl1          >ldd>include>mdbm_descriptor.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
STRUCTURE                              constant        fixed bin(5,0)           initial dcl 227 ref 84 134
VAR_BIT                                constant        fixed bin(5,0)           initial dcl 229 ref 143 160
VAR_CHAR                               constant        fixed bin(5,0)           initial dcl 231 ref 143 160
a_ptr                           000116 automatic       pointer                  dcl 196 set ref 98* 115* 141 158
addr                                                   builtin function         dcl 239 ref 98 99 115 117
addrel                                                 builtin function         dcl 239 ref 143 160
ai_ptr                   12            based           pointer                  array level 3 dcl 2-22 ref 49 131
area_ptr                               parameter       pointer                  dcl 251 set ref 19 34 86*
arg_count                       000127 automatic       fixed bin(17,0)          dcl 207 set ref 86* 90 97 99
arg_ptr                         000114 automatic       pointer                  dcl 196 set ref 78* 86* 98 99 178 178*
arg_sel_ptr                            parameter       pointer                  dcl 196 ref 19 29
argp_ptr                               parameter       pointer                  dcl 196 ref 19 34 86 115
attr_index                2            based           fixed bin(17,0)          array level 3 dcl 4-11 set ref 49*
bit36                                  based           bit(36)                  packed unaligned dcl 225 set ref 134 169*
caller_name                     000137 automatic       char(32)                 initial packed unaligned dcl 255 set ref 255*
cd                                     parameter       fixed bin(35,0)          dcl 68 ref 63 70
code                                   parameter       fixed bin(35,0)          dcl 216 set ref 19 31* 34 59* 70*
continue                        000132 automatic       char(1)                  initial packed unaligned dcl 252 set ref 252*
d_ptr                           000120 automatic       pointer                  dcl 196 set ref 99* 117* 129
data                                   based           structure                level 2 dcl 1-142
dbcb                                   based           structure                level 1 dcl 1-142
dbcb_data                              based           structure                level 1 unaligned dcl 1-148
dbcb_ptr                               parameter       pointer                  dcl 1-146 ref 19 34 40 91 91 108 108
defn_order               22            based           fixed bin(17,0)          level 2 dcl 3-46 ref 49
desc_ptr                        000110 automatic       pointer                  dcl 6-19 set ref 81* 84 129* 134 134 134 143 143 160
                                                                                  160 169
descp_ptr                              parameter       pointer                  dcl 196 ref 19 34 81 86 117
descriptor                             based           structure                level 1 unaligned dcl 6-6
domain_ptr               26            based           pointer                  level 2 dcl 3-46 ref 131
i                               000123 automatic       fixed bin(17,0)          dcl 207 set ref 45* 46 49 51 53* 127* 129 129 131
                                                                                  139 141 141 143 143 156 158 158 160 160*
icode                           000130 automatic       fixed bin(35,0)          dcl 216 set ref 86* 89 89*
info_ptr                        000134 automatic       pointer                  initial dcl 253 set ref 253*
item                      2            based           structure                array level 2 in structure "move_list" dcl 4-11
                                                                                  in procedure "mrds_dsl_set_user_vals"
item                     10            based           structure                array level 2 in structure "select_list" unaligned
                                                                                  dcl 2-22 in procedure "mrds_dsl_set_user_vals"
k                               000124 automatic       fixed bin(17,0)          dcl 207 set ref 42* 43 46*
ml_ptr                    2            based           pointer                  array level 2 in structure "move_list_array"
                                                                                  dcl 2-40 in procedure "mrds_dsl_set_user_vals" ref
                                                                                  43
ml_ptr                          000104 automatic       pointer                  dcl 4-18 in procedure "mrds_dsl_set_user_vals" set
                                                                                  ref 43* 49 51 53
mla_ptr                   2            based           pointer                  level 2 dcl 2-22 ref 43 46
mli                             000125 automatic       fixed bin(17,0)          dcl 207 set ref 44* 48* 48 49 51 53
move_list                              based           structure                level 1 dcl 4-11
move_list_array                        based           structure                array level 1 unaligned dcl 2-40
mrds_error_$bad_select_value    000010 external static fixed bin(35,0)          dcl 234 set ref 169*
mu_break_structure              000012 constant        entry                    external dcl 246 ref 86
mu_valid_data_type$valid_scalar_data_type
                                000014 constant        entry                    external dcl 248 ref 169
must_convert             10            based           bit(1)                   array level 3 packed packed unaligned dcl 2-22 set
                                                                                  ref 139* 156*
null                                                   builtin function         dcl 239 ref 2-38 3-65 5-51 78 178 178 253
num_args                               parameter       fixed bin(17,0)          dcl 207 set ref 19 34 80 81 86 86 96* 96 107 113*
                                                                                  113 115 117
num_dims                        000112 automatic       fixed bin(17,0)          initial dcl 6-20 set ref 6-20*
num_items                 6            based           fixed bin(17,0)          level 2 dcl 2-22 ref 45 90 107 113 119 127
num_vars                               based           fixed bin(17,0)          level 2 dcl 2-22 ref 42
number_dims               0(08)        based           bit(4)                   level 2 packed packed unaligned dcl 6-6 ref 134
pa_size                         000126 automatic       fixed bin(17,0)          dcl 207 set ref 80* 97* 119*
ptr_array                              based           pointer                  array dcl 224 set ref 81 86* 86* 115 117 129 141 158
rai_ptr                         000102 automatic       pointer                  initial dcl 3-65 set ref 3-65*
rdi_ptr                         000106 automatic       pointer                  initial dcl 5-51 set ref 5-51* 131* 134
return_value                    000136 automatic       fixed bin(35,0)          initial dcl 254 set ref 254*
rm_attr_info                           based           structure                level 1 dcl 3-46
rm_domain_info                         based           structure                level 1 dcl 5-35
select_list                            based           structure                level 1 unaligned dcl 2-22
select_list_ptr                 000100 automatic       pointer                  initial dcl 2-38 set ref 29* 40* 42 43 45 46 46 49
                                                                                  51 53 2-38* 90 107 113 119 127 129 131 139 141 143
                                                                                  143 156 158 160 160
select_ptr                4            based           pointer                  level 3 dcl 1-142 ref 40
skip_flag                       000122 automatic       bit(1)                   packed unaligned dcl 205 set ref 82* 92* 109* 125
str_args                               based           pointer                  array dcl 222 set ref 98 99
type                      0(01)        based           fixed bin(6,0)           level 2 packed packed unsigned unaligned dcl 6-6 ref
                                                                                  84 134 143 143 160 160
user_desc                11            based           bit(36)                  level 2 dcl 5-35 ref 134
user_desc_ptr            14            based           pointer                  array level 3 in structure "select_list" dcl 2-22
                                                                                  in procedure "mrds_dsl_set_user_vals" set ref 53
                                                                                  129*
user_desc_ptr             6            based           pointer                  array level 3 in structure "move_list" dcl 4-11
                                                                                  in procedure "mrds_dsl_set_user_vals" set ref 53*
user_ptr                 16            based           pointer                  array level 3 in structure "select_list" dcl 2-22
                                                                                  in procedure "mrds_dsl_set_user_vals" set ref 51
                                                                                  141* 143* 143 158* 160* 160
user_ptr                  4            based           pointer                  array level 3 in structure "move_list" dcl 4-11
                                                                                  in procedure "mrds_dsl_set_user_vals" set ref 51*
val_mod                 106(10)        based           bit(1)                   level 3 packed packed unaligned dcl 1-142 set ref
                                                                                  91* 108*
val_rtrv                106(09)        based           bit(1)                   level 3 packed packed unaligned dcl 1-142 set ref
                                                                                  91* 108*
var_index                              based           fixed bin(17,0)          array level 2 in structure "move_list_array"
                                                                                  dcl 2-40 in procedure "mrds_dsl_set_user_vals" ref
                                                                                  46
var_index                11            based           fixed bin(17,0)          array level 3 in structure "select_list" dcl 2-22
                                                                                  in procedure "mrds_dsl_set_user_vals" ref 46
was_structure                   000131 automatic       bit(1)                   packed unaligned dcl 221 set ref 100* 120* 143 160

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
fixed                                                  builtin function         dcl 239
ml_nitems_init                         automatic       fixed bin(17,0)          dcl 4-19
rel                                                    builtin function         dcl 239
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 234

NAMES DECLARED BY EXPLICIT CONTEXT.
another                         000070 constant        entry                    external dcl 34
error                           000172 constant        entry                    internal dcl 63 ref 89 169
exit                            000171 constant        label                    dcl 60 ref 71
mrds_dsl_set_user_vals          000042 constant        entry                    external dcl 19
set_u_vals                      000177 constant        entry                    internal dcl 75 ref 30 41

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       604         622     506         614
Length      1140     506        16         301      75           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_dsl_set_user_vals              143 external procedure  is an external procedure.  
error                                   internal procedure  shares stack frame of external procedure mrds_dsl_set_user_vals.  
set_u_vals                              internal procedure  shares stack frame of external procedure mrds_dsl_set_user_vals.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mrds_dsl_set_user_vals   000100 select_list_ptr             mrds_dsl_set_user_vals
                         000102 rai_ptr                     mrds_dsl_set_user_vals
                         000104 ml_ptr                      mrds_dsl_set_user_vals
                         000106 rdi_ptr                     mrds_dsl_set_user_vals
                         000110 desc_ptr                    mrds_dsl_set_user_vals
                         000112 num_dims                    mrds_dsl_set_user_vals
                         000114 arg_ptr                     mrds_dsl_set_user_vals
                         000116 a_ptr                       mrds_dsl_set_user_vals
                         000120 d_ptr                       mrds_dsl_set_user_vals
                         000122 skip_flag                   mrds_dsl_set_user_vals
                         000123 i                           mrds_dsl_set_user_vals
                         000124 k                           mrds_dsl_set_user_vals
                         000125 mli                         mrds_dsl_set_user_vals
                         000126 pa_size                     mrds_dsl_set_user_vals
                         000127 arg_count                   mrds_dsl_set_user_vals
                         000130 icode                       mrds_dsl_set_user_vals
                         000131 was_structure               mrds_dsl_set_user_vals
                         000132 continue                    mrds_dsl_set_user_vals
                         000134 info_ptr                    mrds_dsl_set_user_vals
                         000136 return_value                mrds_dsl_set_user_vals
                         000137 caller_name                 mrds_dsl_set_user_vals

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return_mac          ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
mu_break_structure            mu_valid_data_type$valid_scalar_data_type

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
mrds_error_$bad_select_value




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 2   38 000015    3   65 000017    5   51 000020    6   20 000021       252 000022       253 000024       254 000026
    255 000027        19 000034        29 000053        30 000057        31 000060        32 000061        34 000062
     40 000101        41 000106        42 000107        43 000117        44 000124        45 000125        46 000135
     48 000150        49 000151        51 000160        53 000162        56 000164        57 000166        59 000170
     60 000171        63 000172        70 000174        71 000176        75 000177        78 000200        80 000202
     81 000205        82 000212        84 000213        86 000221        89 000245        90 000251        91 000255
     92 000264        93 000266        96 000267        97 000272        98 000274        99 000276       100 000301
    103 000303       107 000304       108 000310       109 000316       110 000320       113 000321       115 000323
    117 000330       119 000332       120 000335       125 000336       127 000340       129 000351       131 000362
    134 000365       139 000403       141 000406       143 000412       152 000422       156 000423       158 000426
    160 000432       169 000442       176 000465       178 000467       181 000475


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
