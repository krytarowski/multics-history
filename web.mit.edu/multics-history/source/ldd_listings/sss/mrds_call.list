	COMPILATION LISTING OF SEGMENT mrds_call
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/18/85  1013.5 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 /* DESCRIPTION:
       19*
       20*		      BEGIN_DESCRIPTION
       21*   This procedure provides a command interface to the Multics Relational Data Store (MRDS)
       22*   Data Sub Language (DSL).  This interface is not intended to be a true End User Facility, but
       23*   rather is intended to  be used as an instructional tool when introducing new users to the
       24*   MRDS.  Also, mrds_call will be useful to data base application programmers as an experimental
       25*   vehicle during the development of MRDS application programs.
       26*		       END_DESCRIPTION
       27**/
       28 
       29 /* PARAMETERS:
       30*
       31*   operation - - (input) the first argument corresponding to the dsl routine
       32*   to be called from command level, such as "open" for mrds_dsl_open
       33*
       34*   operation_args - - (input) the second and succeeding arguments, this varies
       35*   depending on the operation called, for example "ready_file database_index file_name file_ready_mode"
       36*   are the arguments needed for ready_file
       37*   most mrds_call operations and their arguments are documented in the MRDS manual AW53
       38*
       39*   (output) error messages, ready/open lists, and terminal output of
       40*   command results, such as tuples returned by retrieve
       41**/
       42 
       43 mrds_call: mrc: proc;
       44 
       45 /* HISTORY:
       46*
       47*   76-08-01 J. A. Weeldreyer: Initially written.
       48*
       49*   76-10-01  J.  A.  Weeldreyer:  Modified  to  fix  arg.  aquisition  problem   in
       50*   define_temp_rel operation.
       51*
       52*   77-09-01 O. D. Friesen and J. A. Weeldreyer: Modified for MR6.0.
       53*
       54*   79-07-01 Jim Gray: Modified to  1)  correct  MR7  version  of  list_dbs  2)  add
       55*   list_files   operation,   and  incorporate  in  ready_file  3)  improve  integer
       56*   conversion error messages  4)  add  set_modes  operation  with  list  and  error
       57*   suboperations 5) add the "-all" option to the close, ready_file, and finish_file
       58*   operations 6) add operations listing to the "no operation given  error"  7)  put
       59*   work area in temp segment, instead of system_free_
       60*
       61*   80-01-01 Mary Ward: Modified to eliminate ready_file,  finish_file,  list_files,
       62*   set_fscope,  set_fscope_all,  dl_fscope,  and  dl_fscope_all, to require the old
       63*   open syntax, and to improve error messages.
       64*
       65*   80-06-01 Jim Gray: Modified  to  change  method  of  remembering  open  database
       66*   pathnames and opening modes to accommadate new opening order.
       67*
       68*   80-12-08 Rickie E. Brinegar: Use of the internal variable mode_list removed  and
       69*   replaced  with the new mrds_dbs_modes_list.incl.pl1 structures. At the same time
       70*   val_str and hd_str were replaced with control strings in the ioa_ calls.
       71*
       72*   80-12-11 Jim Gray : added use of mrds_new_scope_modes include file in process of
       73*   changing  from  old  r-u to r-s-m-d type scope modes. Now a is acceptable for s,
       74*   and u now means a+d+m, but with an integer conversion of 14, not 2.
       75*
       76*   80-12-12 Jim Gray : Changed declaration of wait_time to fixed bin(35)  from  71,
       77*   the  fact  that mrds_dsl_set_scope expects a fb35 was causing 0 wait times to be
       78*   sent by mrds_call, because the upper (zero) part of  a  fb71  number  was  being
       79*   sent.
       80*
       81*   81-1-12 Jim Gray : added get_scope function to interface to dsl_$get_scope.
       82*
       83*   81-01-30  Jim  Gray  :   added   get_population   function   to   interface   to
       84*   mrds_dsl_define_temp_rel$get_temp_rel_population.  The  routine  for  permantent
       85*   relations  is  not  yet  available.  It  will  be  part  of  a  common   routine
       86*   dsl_$get_population.
       87*
       88*   81-01-30  Jim  Gray  :  changed  open  database  listing  routine  called   from
       89*   mrds_dsl_lsit_dbs$list_dbs_with_modes  to  mrds_dsl_db_openings$list_openings to
       90*   take advantage of the improved interface.
       91*
       92*   81-03-25 Jim Gray : extended get_population to call general  dsl_$get_population
       93*   routine that handles perm rels as well as temp rels.
       94*
       95*   81-07-19 Jim Gray :  added  a  new  set_modes  option  no_retrieve_output/nro  -
       96*   retreieve_output/ro that turns the output of values from retrieve off and on. If
       97*   the output values are turned off, then -all is forced, and a  number  of  tuples
       98*   retrieved  is  returned instead. Also deleted all commented out code, as removal
       99*   of blocked file stuff makes it unuseable.
      100*
      101*   81-09-22 Davids: added code to set the  num_ptrs  variable  right
      102*   after  a  pointer to the arg_list is obtained. Also added code in
      103*   build_arg_list to make sure that the value of num_ptrs is the max
      104*   of  the  number  of  pointers in the arg_list that mrc was called
      105*   with and the arg_list that is generated to call the  dsl_  entry.
      106*   See the comment in build_arg_list
      107*
      108*   82-06-14 Mike Kubicar : Rewrote the dashed argument parser for retrieve
      109*   to work the way the manual desribes it.  This fixes TR phx12237.
      110*
      111**/
      112 
      113 /* initialize */
      114 
      115 	a_ptr, filen_ptr,
      116 	     num_ptr,
      117 	     mode_ptr,
      118 	     pm_ptr,
      119 	     pv_ptr,
      120 	     se_ptr,
      121 	     rmode_ptr,
      122 	     val_ptr = null;
      123 	code = 0;
      124 	ready_cnt = 0;
      125 	on cleanup call cleanup_proc;
      126 	on arg_err_ call arg_err_hndlr;
      127 	if area_initialized then ;
      128 	else do;
      129 		call get_temp_segment_ ("mrds_call", wa_ptr, code);
      130 		if code ^= 0 then do;
      131 			call com_err_ (code, MRC, "Creating temp segment");
      132 			go to Exit;
      133 		     end;
      134 		wa_ptr -> work_area = empty ();
      135 		area_initialized = ON;
      136 	     end;
      137 
      138 	call cu_$arg_list_ptr (al_ptr);
      139 	num_ptrs = arg_list.arg_count;		/* CHANGE 81-09-22 ********** */
      140 	nargs = divide (arg_list.arg_count, 2, 17);
      141 
      142 	on sub_error_
      143 	     begin;
      144 		if ^error_display_flag then ;		/* ignore, dont print extra info */
      145 		else call continue_to_signal_ (handler_found_code);
      146 	     end;
      147 
      148 	call cu_$arg_ptr (1, f_ptr, f_len, code);	/* get operation name */
      149 
      150 	if code ^= 0 then do;			/* nothing there */
      151 		call com_err_ (code, MRC, " Usage: mrc opname {args} {control_args}.");
      152 		if error_display_flag		/* if more info desired */
      153 		then call com_err_ (0, MRC, "Valid opnames: ^/^- ^a,^/^- ^a,^/^- ^a,^/^- ^a",
      154 			"open, o, close, c, store, s, modify, m, delete, d, retrieve, r",
      155 			"list_dbs, ld, set_scope, ss, set_scope_all, ssa, set_modes, sm",
      156 			"dl_scope, ds, dl_scope_all, dsa, define_temp_rel, dtr",
      157 			"get_scope, gs, get_population, gp, declare, dcl");
      158 	     end;
      159 
      160 	else if operation = "o" | operation = "open" then do;
      161 
      162 		call open_old_ver;
      163 
      164 /* if nargs >= 3 then do;
      165*   call cu_$arg_ptr (3, arg_ptr, arg_len, code); ** is mode present? **
      166*   if code ^= 0 then
      167*   call error (code, "open");
      168*   do i = 1 to 8
      169*   while (arg ^= ms_array (i));
      170*   end;
      171*   end;
      172*   if i > 8 | nargs < 3 then
      173*   call open_new_ver;
      174*   else call open_old_ver;
      175*   */
      176 
      177 		al_ptr = a_ptr;
      178 		nargs = divide (arg_list.arg_count, 2, 17);
      179 		arg_list.arg_des_ptr (nargs) = addr (code);
      180 		arg_list.arg_des_ptr (nargs + desc_off_o) = addr (fb_35_desc);
      181 
      182 		call cu_$generate_call (mrds_dsl_open$open, al_ptr);
      183 
      184 		if code ^= 0 then do;
      185 			call com_err_ (code, MRC, "(From dsl_$open)");
      186 			go to Exit;
      187 		     end;
      188 
      189 		free temp_mode_list in (work_area);
      190 		tml_ptr = null ();
      191 
      192 		if list_display_flag
      193 		then call print_dbi;		/* tell user what he did */
      194 
      195 		free arg_list in (work_area);
      196 		free num in (work_area);
      197 		free mode in (work_area);
      198 	     end;					/* open */
      199 
      200 	else if operation = "c" | operation = "close" then do;
      201 		if nargs < 2			/* not enough */
      202 		then call com_err_ (error_table_$wrong_no_of_args, MRC,
      203 			"^/^- Usage: mrc close [dbi1 {... dbiN} | -all]"); /* give user hint */
      204 		else do;
      205 			call cu_$arg_ptr (2, arg_ptr, arg_len, code); /* get 1st arg to close */
      206 
      207 			if code ^= 0		/* should never happen */
      208 			then call com_err_ (code, MRC, "Getting second argument");
      209 
      210 			else if arg = "-all" | arg = "-a" then do;
      211 				call mrds_dsl_close_all (code); /* go doit toit */
      212 				call free_open_lists; /* free work space */
      213 				if code ^= 0	/* now put out error, if any */
      214 				then call com_err_ (code, MRC, "(From dsl_$close_all)");
      215 			     end;
      216 
      217 			else do;
      218 				on conversion begin;/* for certain argument errors */
      219 					if a_ptr ^= null then free a_ptr -> arg_list in (work_area);
      220 					if num_ptr ^= null then free num in (work_area);
      221 					call com_err_ (0, MRC, "No data bases closed"); /* tell user no go */
      222 					goto Exit;
      223 				     end;
      224 
      225 				call build_arg_list (nargs);
      226 
      227 				open_cnt = nargs - 1;
      228 				allocate num in (work_area);
      229 
      230 				do i = 2 to nargs;
      231 				     num (i - 1) = conv_int (i, DBI);
      232 				     a_ptr -> arg_list.arg_des_ptr (i - 1) = addr (num (i - 1));
      233 				     a_ptr -> arg_list.arg_des_ptr (desc_off_o + i - 1) = addr (fb_35_desc);
      234 				end;
      235 
      236 
      237 				al_ptr = a_ptr;
      238 				arg_list.arg_des_ptr (nargs) = addr (code);
      239 				arg_list.arg_des_ptr (nargs + desc_off_o) = addr (fb_35_desc);
      240 
      241 				call cu_$generate_call (mrds_dsl_close$close, al_ptr);
      242 
      243 				free arg_list in (work_area);
      244 				free num in (work_area);
      245 
      246 				call mrds_dsl_db_openings$list_dbs (wa_ptr, database_list_ptr);
      247 				if database_list_ptr = null () then
      248 				     call free_open_lists (); /* get rid of temp seg */
      249 				else free database_list in (work_area);
      250 
      251 				if code ^= 0	/* give out errors, if any */
      252 				then call com_err_ (code, MRC, "(From dsl_$close)");
      253 			     end;
      254 		     end;
      255 	     end;					/* close */
      256 
      257 	else if operation = "ld" | operation = "list_dbs" then
      258 	     call print_dbi;
      259 
      260 
      261 	else if operation = "s" | operation = "store" then
      262 	     call call_mod_fun (mrds_dsl_store$store, 3);
      263 
      264 
      265 	else if operation = "d" | operation = "delete" | operation = "dl" then
      266 	     call call_mod_fun (mrds_dsl_delete$delete, 1);
      267 
      268 
      269 	else if operation = "m" | operation = "modify" then
      270 	     call call_mod_fun (mrds_dsl_modify$modify, 2);
      271 
      272 
      273 	else if operation = "set_modes" | operation = "sm" then do;
      274 		if nargs < 2 then
      275 		     call com_err_ (error_table_$wrong_no_of_args, MRC,
      276 			"^/^- Usage: mrc set_modes {list | no_list} {long_err | short_err}");
      277 		else do;
      278 			do arg_cnt = 2 by 1 to nargs;
      279 
      280 			     call cu_$arg_ptr (arg_cnt, mrc_mode_ptr, mrc_mode_len, code);
      281 			     if code ^= 0 then
      282 				call com_err_ (code, MRC, "Getting mode argument.");
      283 			     else do;
      284 
      285 				     if mrc_mode = "no_list" then
      286 					list_display_flag = OFF;
      287 				     else if mrc_mode = "list" then
      288 					list_display_flag = ON;
      289 				     else if mrc_mode = "long_err" then
      290 					error_display_flag = ON;
      291 				     else if mrc_mode = "short_err" then
      292 					error_display_flag = OFF;
      293 
      294 /* BEGIN CHANGE 81-07-19 ******************************************** */
      295 
      296 				     else if mrc_mode = "no_retrieve_output" | mrc_mode = "nro" then
      297 					no_output_mode = ON;
      298 				     else if mrc_mode = "retrieve_output" | mrc_mode = "ro" then
      299 					no_output_mode = "0"b;
      300 
      301 /* END CHANGE 81-07-19 ************************************************ */
      302 
      303 				     else call com_err_ (error_table_$bad_arg, MRC, "Invalid mode ^a.", mrc_mode);
      304 				end;
      305 			end;
      306 		     end;
      307 	     end;
      308 
      309 	else if operation = "r" | operation = "retrieve" then do;
      310 
      311 		if nargs < 4
      312 		then call com_err_ (error_table_$wrong_no_of_args, MRC,
      313 			"^/^- Usage: mrc retrieve nvals dbi ^/^2-{selection_expression} {se_values} {-segment path} {-all}");
      314 		else do;
      315 			n_vals = conv_int (2, NVALS);
      316 			dbi = conv_int (3, DBI);
      317 			se_seg_sw = 0;		/* init switches */
      318 			all_sw = "0"b;
      319 			done_scanning = "0"b;
      320 			current_arg = nargs;
      321 			se_path = "";
      322 
      323 /* 
      324**
      325**  Now check for the possible command argument (all two of them).  They
      326**  (by the command definition) must appear as the last two control arguments
      327**  in the command line.  So, we just start at the end and scan backwords.
      328**  We check for -all, which is a single arg, or -sm which has to be two.
      329**  If we find the wrong thing or both -all and -sm, we assume we're done
      330**  and look no farther.  Thus, it is quite possible to have command lines of
      331**  the form:
      332**
      333** mrc retrieve 4 1 a b c d -all -all -sm foo -sm foo.input -all
      334**
      335**  since scanning for arguments will stop when it sees -sm foo.input -all.
      336**  This allows arbitrary and random things to be given for selection
      337**  expression values.
      338**
      339**/
      340 
      341 			do while (^done_scanning);
      342 			     call cu_$arg_ptr (current_arg, arg_ptr,
      343 				arg_len, code);
      344 			     if code ^= 0 then do;
      345 				     call com_err_ (code, MRC,
      346 					"^/Could not get command argument.");
      347 				     go to Exit;
      348 				end;
      349 			     if ^all_sw & ((arg = "-all") | (arg = "-a")) /* All is easy, it's a single arg */
      350 			     then if (se_seg_sw = 0) & se_path ^= "" /* Make sure we're not in the middle of a -segment argument */
      351 				then done_scanning = "1"b; /* Impossible arg combination, must be se values */
      352 				else do;		/* Saw a legal -all */
      353 					all_sw = "1"b;
      354 					nargs = nargs - 1;
      355 					done_scanning = all_sw & (se_seg_sw ^= 0);
      356 				     end;
      357 			     else if (se_seg_sw = 0) &
      358 				     ((arg = "-segment") | (arg = "-sm"))
      359 			     then if se_path = "" then do; /* Must have seen pathname */
      360 					call com_err_ (error_table_$noarg,
      361 					     MRC, "^/A pathname must be given with the ^a argument.", arg);
      362 					go to Exit;
      363 				     end;
      364 				else do;		/* Valid -segment arg */
      365 					se_seg_sw = 1;
      366 					call get_se (sea_ptr, sed_ptr);
      367 					nargs = nargs - 1;
      368 					done_scanning = all_sw;
      369 				     end;
      370 			     else if se_path ^= ""	/* End of arg scanning? */
      371 			     then done_scanning = "1"b; /* Yes, two non-recognized args in a row */
      372 			     else do;		/* Assume it's an se_path */
      373 				     if length (arg) > length (se_path) then do;
      374 					     se_path = substr (arg, 1, length (se_path));
      375 					     se_len = length (se_path);
      376 					end;
      377 				     else do;
      378 					     se_path = arg;
      379 					     se_len = arg_len;
      380 					end;
      381 				end;
      382 			     current_arg = current_arg - 1;
      383 			end;
      384 
      385 			call build_arg_list (nargs + n_vals - 1);
      386 			allocate values in (work_area);
      387 
      388 			if se_seg_sw > 0 then do;	/* if seg se. move in arg and desc. ptrs */
      389 				a_ptr -> arg_list.arg_des_ptr (2) = sea_ptr;
      390 				a_ptr -> arg_list.arg_des_ptr (desc_off_o + 2) = sed_ptr;
      391 			     end;
      392 
      393 			do i = 2 to nargs - 2 - se_seg_sw;
      394 			     a_ptr -> arg_list.arg_des_ptr (i + se_seg_sw) = arg_list.arg_des_ptr (i + 2);
      395 			     a_ptr -> arg_list.arg_des_ptr (desc_off_o + i + se_seg_sw) =
      396 				true_ptr (al_ptr, arg_list.arg_des_ptr (desc_off_i + i + 2));
      397 			end;
      398 
      399 			al_ptr = a_ptr;
      400 			arg_list.arg_des_ptr (1) = addr (dbi);
      401 			arg_list.arg_des_ptr (nargs + n_vals - 1) = addr (code);
      402 			arg_list.arg_des_ptr (desc_off_o + 1),
      403 			     arg_list.arg_des_ptr (desc_off_o + nargs + n_vals - 1) = addr (fb_35_desc);
      404 
      405 			do i = nargs - 1 to nargs + n_vals - 2;
      406 			     arg_list.arg_des_ptr (i) = addr (values (i - nargs + 2));
      407 			     arg_list.arg_des_ptr (i + desc_off_o) = addr (char_desc);
      408 			end;
      409 
      410 			call cu_$generate_call (mrds_dsl_retrieve$retrieve, al_ptr);
      411 
      412 			if code ^= 0 then do;
      413 				call retr_cleanup;
      414 				call com_err_ (code, MRC, "(From dsl_$retrieve)");
      415 				go to Exit;
      416 			     end;
      417 
      418 /* BEGIN CHANGE 81-07-19 ******************************************** */
      419 
      420 			if ^no_output_mode then do;
      421 				call ioa_ ("^/Value^[ is^;s are^]:^/", (n_vals = 1));
      422 
      423 				do i = 1 to n_vals;
      424 				     call ioa_ ("^a", values (i));
      425 				end;
      426 			     end;
      427 			else do;
      428 
      429 /* for no_retrieve_output mode, force -all,
      430*   and just prepare a count of the tuples retrieved */
      431 
      432 				tuples_retrieved = 1;
      433 				all_sw = "1"b;
      434 			     end;
      435 
      436 			if all_sw then do;		/* if auto anothers */
      437 				arg_list.arg_des_ptr (2) = addr (anoth_str); /* change select. expr. to -another */
      438 				arg_list.arg_des_ptr (desc_off_o + 2) = addr (anoth_desc);
      439 
      440 				do while (code = 0);/* for as long as we find something */
      441 
      442 				     call cu_$generate_call (mrds_dsl_retrieve$retrieve, al_ptr); /* $retrieve (-another) */
      443 
      444 				     if code = 0 then do; /* if got something */
      445 					     tuples_retrieved = tuples_retrieved + 1;
      446 					     if ^no_output_mode then do;
      447 						     call ioa_ ("^/******^/"); /* write separator */
      448 						     do i = 1 to n_vals; /* write out all found values */
      449 							call ioa_ ("^a", values (i));
      450 						     end;
      451 						end;
      452 					end;
      453 				end;
      454 				if code = mrds_error_$tuple_not_found then do;
      455 					if no_output_mode then
      456 					     call ioa_ ("^/Tuples retrieved:  ^d^/", tuples_retrieved);
      457 					else call ioa_ ("^/(END)^/"); /* let user know at end */
      458 				     end;
      459 				else call com_err_ (code, MRC, "(From dsl_$retrieve)"); /* otherwise give error */
      460 			     end;			/* if auto anothers */
      461 
      462 /* END CHANGE 81-07-19 **************************************************** */
      463 
      464 
      465 			else call ioa_ ("^/");
      466 			call retr_cleanup;
      467 
      468 retr_cleanup: procedure;
      469 	free arg_list in (work_area);
      470 	free values in (work_area);
      471      end retr_cleanup;
      472 
      473 		     end;				/* retrieve */
      474 	     end;
      475 
      476 	else if operation = "dtr" | operation = "define_temp_rel" then do;
      477 		if nargs < 4 then do;		/* not enough */
      478 			call com_err_ (error_table_$wrong_no_of_args, MRC,
      479 			     "^/^- Usage: mrc define_temp_rel dbi ^/^2-^a^/^2-^a",
      480 			     "[selection_expression {se_values} rel_index",
      481 			     "| rel_index -sm path]");
      482 			go to Exit;
      483 		     end;
      484 
      485 		dbi = conv_int (2, DBI);
      486 
      487 		call cu_$arg_ptr (nargs - 1, arg_ptr, arg_len, code); /* see if separate sel. expr. */
      488 
      489 		if code ^= 0 then do;
      490 			call com_err_ (code, MRC, "Getting argument ^i", nargs - 1);
      491 			go to Exit;
      492 		     end;
      493 		if arg = "-sm" | arg = "-segment" then do; /* if separate */
      494 			call cu_$arg_ptr (nargs, arg_ptr, arg_len, code); /* get path */
      495 			if code ^= 0 then do;
      496 				call com_err_ (code, MRC, "Pathname for -segment");
      497 				go to Exit;
      498 			     end;
      499 
      500 			se_path = arg;
      501 			se_len = arg_len;
      502 			call get_se (sea_ptr, sed_ptr); /* init and set ptrs for sel. expr. */
      503 			nargs = nargs - 1;		/* dont look at ctl arg again */
      504 			se_seg_sw = 1;		/* remember */
      505 		     end;
      506 		else se_seg_sw = 0;			/* if sel. expr in command line */
      507 
      508 		rel_ind = conv_int (nargs - se_seg_sw, TRI);
      509 
      510 		call build_arg_list (nargs);
      511 
      512 		if se_seg_sw > 0 then do;		/* if se. in seg */
      513 			a_ptr -> arg_list.arg_des_ptr (2) = sea_ptr; /* move in arg and desc ptrs */
      514 			a_ptr -> arg_list.arg_des_ptr (desc_off_o + 2) = sed_ptr;
      515 		     end;
      516 
      517 		do i = 2 to nargs - 2 - se_seg_sw;
      518 		     a_ptr -> arg_list.arg_des_ptr (i + se_seg_sw) = arg_list.arg_des_ptr (i + 1);
      519 		     a_ptr -> arg_list.arg_des_ptr (desc_off_o + i + se_seg_sw) =
      520 			true_ptr (al_ptr, arg_list.arg_des_ptr (desc_off_i + i + 1));
      521 		end;
      522 
      523 		al_ptr = a_ptr;
      524 		arg_list.arg_des_ptr (1) = addr (dbi);
      525 		arg_list.arg_des_ptr (nargs - 1) = addr (rel_ind);
      526 		arg_list.arg_des_ptr (nargs) = addr (code);
      527 		arg_list.arg_des_ptr (desc_off_o + 1),
      528 		     arg_list.arg_des_ptr (desc_off_o + nargs - 1),
      529 		     arg_list.arg_des_ptr (desc_off_o + nargs) = addr (fb_35_desc);
      530 
      531 		call cu_$generate_call (mrds_dsl_define_temp_rel$define_temp_rel, al_ptr);
      532 
      533 		free arg_list in (work_area);
      534 
      535 		if code ^= 0
      536 		then call com_err_ (code, MRC, "(From dsl_$define_temp_rel)");
      537 		else call ioa_ ("^/Temporary relation index is:  ^d.^/", rel_ind);
      538 
      539 	     end;					/* retrieve */
      540 
      541 	else if operation = "set_scope" | operation = "ss" then
      542 	     call call_scope_fun (mrds_dsl_set_scope$set_scope, 1);
      543 
      544 	else if operation = "ssa" | operation = "set_scope_all" then
      545 	     call call_set_scope_all_fun (mrds_dsl_set_scope$set_scope_all);
      546 
      547 	else if operation = "ds" | operation = "dl_scope" then
      548 	     call call_scope_fun (mrds_dsl_set_scope$dl_scope, 2);
      549 
      550 	else if operation = "dl_scope_all" | operation = "dsa" then do;
      551 		if nargs ^= 2
      552 		then call com_err_ (error_table_$wrong_no_of_args, MRC, " Usage: mrc dl_scope_all dbi");
      553 		else do;
      554 			dbi = conv_int (2, DBI);
      555 			call mrds_dsl_set_scope$dl_scope_all (dbi, code);
      556 			if code ^= 0
      557 			then call com_err_ (code, MRC, "(From dsl_$dl_scope_all)");
      558 		     end;
      559 	     end;
      560 	else if operation = "get_scope" | operation = "gs" then do;
      561 		if nargs ^= 3 then
      562 		     call com_err_ (error_table_$wrong_no_of_args, MRC, "^/    Usage: mrc get_scope dbi relation_name");
      563 		else do;
      564 			dbi = conv_int (2, DBI);
      565 			call cu_$arg_ptr_rel (3, relation_name_ptr, relation_name_len, code, al_ptr);
      566 			if code ^= 0 then
      567 			     call com_err_ (code, MRC, "^/Cannot get relation name argument.");
      568 			else do;
      569 				call mrds_dsl_get_scope (dbi, relation_name, permits, prevents, scope_version, code);
      570 				if code ^= 0 then
      571 				     call com_err_ (code, MRC, "(From dsl_$get_scope)");
      572 				else do;
      573 					permit_requests_ptr = addr (permits);
      574 					prevent_requests_ptr = addr (prevents);
      575 					if scope_version < 5 then
      576 					     store_scope = "s";
      577 					else store_scope = "a";
      578 					permit_string = "";
      579 					if permit_requests.read_attr then permit_string = permit_string || "r";
      580 					if permit_requests.append_tuple then permit_string = permit_string || store_scope;
      581 					if permit_requests.modify_attr then permit_string = permit_string || "m";
      582 					if permit_requests.delete_tuple then permit_string = permit_string || "d";
      583 					if permit_string = "" then permit_string = "n";
      584 					prevent_string = "";
      585 					if prevent_requests.read_attr then prevent_string = prevent_string || "r";
      586 					if prevent_requests.append_tuple then prevent_string = prevent_string || store_scope;
      587 					if prevent_requests.modify_attr then prevent_string = prevent_string || "m";
      588 					if prevent_requests.delete_tuple then prevent_string = prevent_string || "d";
      589 					if prevent_string = "" then prevent_string = "n";
      590 					call ioa_ ("^/Permits:  ^a ^-Prevents:  ^a^/", permit_string, prevent_string);
      591 				     end;
      592 			     end;
      593 		     end;
      594 	     end;
      595 
      596 	else if operation = "get_population" | operation = "gp" then do;
      597 		if nargs ^= 3 then
      598 		     call com_err_ (error_table_$wrong_no_of_args, MRC,
      599 			"^/    Usage: mrc get_population dbi rel_id");
      600 		else do;
      601 			dbi = conv_int (2, DBI);
      602 			call cu_$arg_ptr_rel (3, relation_name_ptr, relation_name_len, code, al_ptr);
      603 			if code ^= 0 then
      604 			     call com_err_ (code, MRC, "^/Cannot get relation name argument.");
      605 			else do;
      606 
      607 				call mrds_dsl_get_population (dbi, relation_name, tuple_count, code);
      608 
      609 				if code ^= 0 then
      610 				     call com_err_ (code, MRC, "(From dsl_$get_population)");
      611 				else do;
      612 
      613 					call ioa_ ("^/Tuple count:  ^d^/", tuple_count);
      614 
      615 				     end;
      616 
      617 			     end;
      618 
      619 		     end;
      620 
      621 	     end;
      622 
      623 	else if operation = "declare" | operation = "dcl" then do;
      624 		if nargs ^= 3
      625 		then call com_err_ (error_table_$wrong_no_of_args, "^/^- Usage: mrc declare dbi function_name");
      626 		else do;
      627 			dbi = conv_int (2, DBI);
      628 
      629 			call cu_$arg_ptr_rel (3, fn_ptr, fn_len, code, al_ptr);
      630 
      631 			if code ^= 0
      632 			then call com_err_ (code, MRC, "Cannot get function_name");
      633 			else do;
      634 				call mrds_dsl_declare (dbi, fn_name, code);
      635 				if code ^= 0
      636 				then call com_err_ (code, MRC, "(From dsl_$declare)");
      637 			     end;
      638 		     end;
      639 	     end;
      640 
      641 	else call com_err_ (error_table_$bad_arg, MRC, operation);
      642 Exit:
      643 	if se_ptr ^= null				/* if any segment initiated */
      644 	then call hcs_$terminate_noname (se_ptr, discard_code);
      645 	return;
      646 
      647 call_mod_fun: proc (dsl_entry, index);
      648 	dcl     dsl_entry		 entry;
      649 	dcl     index		 fixed bin;
      650 
      651 	if nargs < 3 then do;			/* not right number */
      652 		if index = 3			/* special call for store */
      653 		then call com_err_ (error_table_$wrong_no_of_args, MRC,
      654 			"^/^- Usage: mrc store dbi [rel_name | -another] new_values");
      655 		else call com_err_ (error_table_$wrong_no_of_args, MRC,
      656 			"^/^- Usage: mrc ^[delete^;modify^] dbi [selection_expression {se_values} ^[^;new_values^] | ^[^;new_values^] -sm path]", index, index, index);
      657 	     end;
      658 
      659 	else do;
      660 		dbi = conv_int (2, DBI);
      661 		se_seg_sw = 0;			/* init off */
      662 
      663 		if index ^= 3 then do;		/* delete or modify */
      664 			call cu_$arg_ptr (nargs - 1, arg_ptr, arg_len, code); /* see if -sm given */
      665 			if code ^= 0 then do;
      666 				call com_err_ (code, MRC, "Getting argument ^i", nargs - 1);
      667 				go to Exit;
      668 			     end;
      669 
      670 			else if arg = "-segment" | arg = "-sm" then do;
      671 				call cu_$arg_ptr (nargs, arg_ptr, arg_len, code);
      672 				if code ^= 0 then do;
      673 					call com_err_ (code, MRC, "Unable to get pathname for -segment");
      674 					go to Exit;
      675 				     end;
      676 				else do;
      677 					se_path = arg;
      678 					se_len = arg_len;
      679 					call get_se (sea_ptr, sed_ptr);
      680 					nargs = nargs - 1;
      681 					se_seg_sw = 1;
      682 				     end;
      683 			     end;
      684 		     end;
      685 
      686 		call build_arg_list (nargs);		/* build dsl_ arg list */
      687 
      688 		if se_seg_sw > 0 then do;		/* if separate sel. expr. */
      689 			a_ptr -> arg_list.arg_des_ptr (2) = sea_ptr; /* move in sel. expr. ptrs */
      690 			a_ptr -> arg_list.arg_des_ptr (desc_off_o + 2) = sed_ptr;
      691 		     end;
      692 		do i = 2 to nargs - 1 - se_seg_sw;
      693 		     a_ptr -> arg_list.arg_des_ptr (i + se_seg_sw) = arg_list.arg_des_ptr (i + 1);
      694 		     a_ptr -> arg_list.arg_des_ptr (desc_off_o + i + se_seg_sw) =
      695 			true_ptr (al_ptr, arg_list.arg_des_ptr (desc_off_i + i + 1));
      696 		end;
      697 
      698 		al_ptr = a_ptr;
      699 		arg_list.arg_des_ptr (1) = addr (dbi);
      700 		arg_list.arg_des_ptr (nargs) = addr (code);
      701 		arg_list.arg_des_ptr (desc_off_o + 1),
      702 		     arg_list.arg_des_ptr (desc_off_o + nargs) = addr (fb_35_desc);
      703 
      704 		call cu_$generate_call (dsl_entry, al_ptr);
      705 
      706 		free arg_list in (work_area);
      707 
      708 		if code ^= 0
      709 		then call com_err_ (code, MRC,	/* give user error */
      710 			"(From dsl_$^[delete^;modify^;store^])", index);
      711 	     end;
      712 
      713      end call_mod_fun;
      714 
      715 call_scope_fun: proc (dsl_entry, index);
      716 
      717 	dcl     dsl_entry		 entry;
      718 	dcl     index		 fixed bin;
      719 
      720 
      721 	if nargs < 5
      722 	then call com_err_ (error_table_$wrong_no_of_args, MRC,
      723 		"^/^- Usage: mrc ^[set^;dl^]_scope dbi ^a ^/^2-^a ^[{wait_sec}^]",
      724 		index,
      725 		"rel_name1 permit_ops1 prevent_ops1",
      726 		"{... rel_nameN permit_opsN prevent_opsN}",
      727 		index);
      728 
      729 	else do;
      730 		dbi = conv_int (2, DBI);
      731 
      732 		wait_time = mod (nargs - 2, 3);
      733 		if wait_time ^= 0 then wait_time = conv_int (nargs, WT);
      734 
      735 		call build_arg_list (nargs);
      736 
      737 		scope_cnt = divide (nargs - 2, 3, 17);
      738 		allocate perm_ops in (work_area);
      739 		allocate prev_ops in (work_area);
      740 
      741 		do i = 2 to nargs - 2 by 3;
      742 
      743 		     a_ptr -> arg_list.arg_des_ptr (i) = arg_list.arg_des_ptr (i + 1);
      744 		     a_ptr -> arg_list.arg_des_ptr (i + desc_off_o) =
      745 			true_ptr (al_ptr, arg_list.arg_des_ptr (desc_off_i + i + 1));
      746 		     perm_ops (divide (i + 1, 3, 17)) = conv_ops (i + 2);
      747 		     prev_ops (divide (i + 1, 3, 17)) = conv_ops (i + 3);
      748 		     a_ptr -> arg_list.arg_des_ptr (i + 1) = addr (perm_ops (divide (i + 1, 3, 17)));
      749 		     a_ptr -> arg_list.arg_des_ptr (i + 2) = addr (prev_ops (divide (i + 1, 3, 17)));
      750 		     a_ptr -> arg_list.arg_des_ptr (desc_off_o + i + 1),
      751 			a_ptr -> arg_list.arg_des_ptr (desc_off_o + i + 2) = addr (fb_17_desc);
      752 
      753 		end;
      754 
      755 		al_ptr = a_ptr;
      756 		arg_list.arg_des_ptr (1) = addr (dbi);
      757 		arg_list.arg_des_ptr (nargs) = addr (code);
      758 		if wait_time ^= 0 then do;		/* wait time specified */
      759 			arg_list.arg_des_ptr (nargs - 1) = addr (wait_time);
      760 			arg_list.arg_des_ptr (desc_off_o + nargs - 1) = addr (fb_35_desc);
      761 		     end;
      762 		arg_list.arg_des_ptr (desc_off_o + 1),
      763 		     arg_list.arg_des_ptr (desc_off_o + nargs) = addr (fb_35_desc);
      764 
      765 		call cu_$generate_call (dsl_entry, al_ptr); /* call out */
      766 
      767 		free perm_ops in (work_area);
      768 		free prev_ops in (work_area);
      769 		free arg_list in (work_area);
      770 
      771 		if code ^= 0
      772 		then call com_err_ (code, MRC,	/* give user sad story */
      773 			"(From dsl_$^[set^;dl^]_scope)", index);
      774 	     end;
      775 
      776      end call_scope_fun;
      777 
      778 call_set_scope_all_fun: proc (dsl_entry);
      779 
      780 	dcl     dsl_entry		 entry;
      781 
      782 	if nargs < 4 | nargs > 5
      783 	then call com_err_ (error_table_$wrong_no_of_args, MRC,
      784 		"^/^- Usage: mrc set_scope_all dbi permit_ops prevent_ops {wait_sec}");
      785 	else do;
      786 
      787 		dbi = conv_int (2, DBI);
      788 
      789 		if nargs = 5 then wait_time = conv_int (nargs, WT);
      790 
      791 		call build_arg_list (nargs);
      792 
      793 		scope_cnt = 1;
      794 		allocate perm_ops in (work_area);
      795 		allocate prev_ops in (work_area);
      796 
      797 		perm_ops (1) = conv_ops (3);
      798 		prev_ops (1) = conv_ops (4);
      799 		a_ptr -> arg_list.arg_des_ptr (2) = addr (perm_ops (1));
      800 		a_ptr -> arg_list.arg_des_ptr (3) = addr (prev_ops (1));
      801 		a_ptr -> arg_list.arg_des_ptr (desc_off_o + 2),
      802 		     a_ptr -> arg_list.arg_des_ptr (desc_off_o + 3) = addr (fb_17_desc);
      803 
      804 		al_ptr = a_ptr;
      805 		arg_list.arg_des_ptr (1) = addr (dbi);
      806 		arg_list.arg_des_ptr (nargs) = addr (code);
      807 
      808 		if nargs = 5
      809 		then do;
      810 			arg_list.arg_des_ptr (nargs - 1) = addr (wait_time);
      811 			arg_list.arg_des_ptr (desc_off_o + nargs - 1) = addr (fb_35_desc);
      812 		     end;
      813 		arg_list.arg_des_ptr (desc_off_o + 1),
      814 		     arg_list.arg_des_ptr (desc_off_o + nargs) = addr (fb_35_desc);
      815 
      816 		call cu_$generate_call (dsl_entry, al_ptr); /* call out */
      817 
      818 		free perm_ops in (work_area);
      819 		free prev_ops in (work_area);
      820 		free arg_list in (work_area);
      821 
      822 		if code ^= 0 then
      823 		     call com_err_ (code, MRC, "(From dsl_$set_scope_all)");
      824 	     end;
      825 
      826      end call_set_scope_all_fun;
      827 
      828 open_old_ver: proc;
      829 
      830 	dcl     odd		 fixed bin;	/* to see if odd num of args */
      831 	dcl     al_index		 fixed bin;	/* index for arg_list processing */
      832 
      833 	odd = mod (nargs, 2);			/* see if odd num */
      834 
      835 	if nargs < 3 | odd = 0 then do;		/* need odd num & at least 3 */
      836 		call com_err_ (error_table_$wrong_no_of_args, MRC,
      837 		     "^/^- Usage: mrc open path1 mode1 {... pathN modeN}");
      838 		go to Exit;
      839 	     end;
      840 
      841 	num_open,
      842 	     open_cnt = divide (nargs - 1, 2, 17);
      843 	call build_arg_list (open_cnt * 3 + 1);
      844 
      845 	allocate num in (work_area) set (num_ptr);
      846 	allocate mode in (work_area) set (mode_ptr);
      847 	if tml_ptr ^= null then free temp_mode_list in (work_area);
      848 	allocate temp_mode_list set (tml_ptr) in (work_area);
      849 
      850 	do i = 1 to (open_cnt);
      851 	     al_index = (i - 1) * 3;
      852 
      853 	     a_ptr -> arg_list.arg_des_ptr (al_index + 1) = arg_list.arg_des_ptr (2 * i);
      854 	     a_ptr -> arg_list.arg_des_ptr (al_index + 2) = addr (num (i));
      855 	     a_ptr -> arg_list.arg_des_ptr (al_index + 3) = addr (mode (i));
      856 
      857 	     call cu_$arg_ptr (2 * i + 1, ms_ptr, ms_len, code);
      858 	     if code ^= 0 then do;
      859 		     call com_err_ (code, MRC, "Unable to get opening mode.");
      860 		     go to Exit;
      861 		end;
      862 
      863 	     do j = 1 to 8 while (mode_string ^= ms_array (j)); /* look for specified mode */
      864 	     end;
      865 	     if j > 8 then do;
      866 		     call com_err_ (code, MRC,
      867 			"Invalid opening mode ^a. ^/^-Valid modes are: r, u, er, and eu", mode_string);
      868 		     go to Exit;
      869 		end;
      870 	     else mode (i) = mv_array (j);		/* if valid, pick up corr. number */
      871 	     a_ptr -> arg_list.arg_des_ptr (desc_off_o + al_index + 1) =
      872 		true_ptr (al_ptr, arg_list.arg_des_ptr (desc_off_i + 2 * i));
      873 	     a_ptr -> arg_list.arg_des_ptr (desc_off_o + al_index + 2),
      874 		a_ptr -> arg_list.arg_des_ptr (desc_off_o + al_index + 3) = addr (fb_35_desc);
      875 
      876 	     temp_mode_list (i) = ms_array (2 * mode (i) - 1); /* save expanded opening mode */
      877 
      878 	     call cu_$arg_ptr (2 * i, arg_ptr, arg_len, code); /* get and save submodel path */
      879 	     if code ^= 0 then do;			/* not there */
      880 		     call com_err_ (code, MRC, "Unable to get pathname");
      881 		     go to Exit;
      882 		end;
      883 
      884 	     if code ^= 0 then do;
      885 		     call com_err_ (code, MRC, arg);	/* let user know */
      886 		     go to Exit;			/* and get out */
      887 		end;
      888 
      889 	end;
      890 
      891      end open_old_ver;
      892 
      893 build_arg_list: proc (count);
      894 
      895 	dcl     count		 fixed bin;
      896 	dcl     old_num_ptrs	 fixed bin;	/* CHANGE 81-09-22 ********** */
      897 
      898 	old_num_ptrs = num_ptrs;			/* CHANGE 81-09-22 ********** */
      899 
      900 	num_ptrs = 2 * count;
      901 	allocate arg_list in (work_area) set (a_ptr);
      902 
      903 	a_ptr -> arg_list.arg_count,
      904 	     a_ptr -> arg_list.desc_count = 2 * count;
      905 	a_ptr -> arg_list.code = 4;
      906 
      907 	desc_off_o = count;
      908 	desc_off_i = divide (arg_list.arg_count, 2, 17) + fixed (arg_list.code = 8);
      909 
      910 /* BEGIN CHANGE 81-09-22 ******************************
      911*
      912*   old_num_ptrs contains the number of pointers in the argument list
      913*   that  mrds_call  was called with. num_ptrs contains the number of
      914*   pointers that the corresponding dsl_ entry will be  called  with.
      915*   Since  only  1 structure is used (arg_list) the value of num_ptrs
      916*   after it leaves this procedure must be  the  larger  of  the  two
      917*   numbers  to  prevent  subscriptrange conditions from occuring, of
      918*   course this means that subscriptrange conditions can occur on the
      919*   other   structure.  Ideally  two  separate  structures  with  two
      920*   separate limits should be used. This has not been  done  at  this
      921*   time becuase while it is a simple change it is also extensive and
      922*   it would be easy to make a mistake at  the  same  time  the  test
      923*   routines  cannot  be  run  becuase  almost  every  routine  has a
      924*   stringrange or subscriptrange condition  in  it.  After  mrds  is
      925*   again running this change should be made. */
      926 
      927 	if old_num_ptrs > num_ptrs
      928 	then num_ptrs = old_num_ptrs;
      929 
      930 /* END   CHANGE 81-09-22 ****************************** */
      931 
      932      end build_arg_list;
      933 
      934 conv_int: proc (index, argument_type) returns (fixed bin (35));
      935 
      936 	declare argument_type	 char (*);
      937 	dcl     i			 fixed bin;
      938 	dcl     num_char		 char (nc_len) based (nc_ptr);
      939 	dcl     nc_ptr		 ptr;
      940 	dcl     (nc_len,
      941 	        index)		 fixed bin;
      942 
      943 	call cu_$arg_ptr_rel (index, nc_ptr, nc_len, code, al_ptr);
      944 
      945 	if code ^= 0 then do;			/* can't find arg */
      946 		call com_err_ (code, MRC, "Unable to get ^a", argument_type);
      947 		go to Exit;			/* not much past this */
      948 	     end;
      949 
      950 	if argument_type = TRI
      951 	then i = verify (num_char, "-0123456789");
      952 	else i = verify (num_char, "0123456789");	/* no negatives allowed */
      953 
      954 	if i ^= 0 then do;				/* not numeric */
      955 		call com_err_ (error_table_$bad_arg, MRC,
      956 		     "Non-numeric ^a: ^a", argument_type, num_char);
      957 		if operation = "close" | operation = "c"/* special handling for close */
      958 		then signal conversion;		/* so can clean up properly */
      959 		else go to Exit;			/* otherwise, just die */
      960 	     end;
      961 	return (fixed (num_char));
      962 
      963      end conv_int;
      964 
      965 conv_ops: proc (index) returns (fixed bin (35));
      966 
      967 /* Internal procedure to create an operations number from a given scope operations string */
      968 
      969 	dcl     st_ptr		 ptr;		/* points to input string */
      970 	dcl     (st_len,				/* length of input str. */
      971 	        index)		 fixed bin;	/* index of string arg. */
      972 	dcl     string		 char (st_len) based (st_ptr); /* scope ops. string */
      973 	dcl     op_num		 fixed bin (35);	/* scope ops number to be returned */
      974 
      975 	call cu_$arg_ptr_rel (index, st_ptr, st_len, code, al_ptr); /* get input string */
      976 	if code ^= 0 then do;
      977 		call com_err_ (code, MRC, "Unable to get scope code");
      978 		go to Exit;
      979 	     end;
      980 	op_num = 0;				/* initialize */
      981 
      982 	if string ^= "n" then do;			/* if non-null op. */
      983 		op_num = verify (string, "nrasudm");
      984 		if op_num ^= 0 then do;		/* invalid code */
      985 			call com_err_ (error_table_$bad_arg, MRC,
      986 			     "Invalid scope code: ^a. ^/^-Valid codes are: n, r, a or s, d, m, and u = ""a+d+m""",
      987 			     substr (string, op_num, 1));
      988 			go to Exit;
      989 		     end;
      990 		if search (string, "r") ^= 0 then op_num = op_num + READ_ATTR; /* convert to number */
      991 		if search (string, "s") ^= 0 | search (string, "a") ^= 0 then op_num = op_num + APPEND_TUPLE;
      992 		if search (string, "d") ^= 0 then op_num = op_num + DELETE_TUPLE;
      993 		if search (string, "m") ^= 0 then op_num = op_num + MODIFY_ATTR;
      994 		if search (string, "u") ^= 0 then op_num = op_num + UPDATE_OPS;
      995 	     end;
      996 
      997 	return (op_num);
      998 
      999      end conv_ops;
     1000 
     1001 print_dbi: proc;
     1002 
     1003 /* Procedure to print open data bases, modes, and indices */
     1004 
     1005 
     1006 	call mrds_dsl_db_openings$list_openings (wa_ptr,
     1007 	     mrds_database_openings_structure_version, mrds_database_openings_ptr, code);
     1008 	if code ^= 0 then
     1009 	     call com_err_ (code, MRC, "(From dsl_$list_openings)");
     1010 	else do;
     1011 
     1012 		if mrds_database_openings.number_open = 0 then
     1013 		     call ioa_ ("^/No data bases open.^/"); /* if we dont have list */
     1014 
     1015 		else do;				/* print out list */
     1016 			call ioa_ ("^/Open data base^[ is^;s are^]:",
     1017 			     (mrds_database_openings.number_open = 1)); /* write out header */
     1018 
     1019 			do i = 1 to mrds_database_openings.number_open; /* write out index,
     1020*						   mode, path of each db curr. open */
     1021 
     1022 			     call ioa_ ("^d^-^a^/^-^a", mrds_database_openings.db.index (i),
     1023 				mrds_database_openings.db.path (i),
     1024 				mrds_database_openings.db.mode (i));
     1025 			end;
     1026 			call ioa_ ("^/");
     1027 		     end;
     1028 
     1029 	     end;
     1030 
     1031 
     1032 	if mrds_database_openings_ptr ^= null () then
     1033 	     free mrds_database_openings in (work_area);
     1034 
     1035      end print_dbi;
     1036 
     1037 get_se: proc (a_ptr, d_ptr);
     1038 
     1039 /* Internal procedure to obtain selection expression if user has specified -segment.
     1040*   On output, a_ptr will point to the start of the selection expression, and d_ptr will point to a
     1041*   descriptor for the selection expression.
     1042**/
     1043 
     1044 	dcl     (a_ptr,				/* place to put arg ptr. for sel.exp. */
     1045 	        d_ptr)		 ptr;		/* place to put descr. ptr. for sel. exp. */
     1046 	dcl     dname		 char (168);	/* dir name of se. expr. */
     1047 	dcl     ename		 char (32);	/* entry name of se. expr. */
     1048 	dcl     bcount		 fixed bin (24);	/* se. expr. bit count */
     1049 	dcl     1 se_desc		 aligned,		/* descriptor template */
     1050 		2 const		 bit (12) unal init ("101010110000"b),
     1051 		2 len		 fixed bin (23) unal;
     1052 
     1053 	call expand_path_ (addr (se_path), se_len, addr (dname), addr (ename), code);
     1054 
     1055 	if code ^= 0 then do;
     1056 		call com_err_ (code, MRC, se_path);
     1057 		go to Exit;			/* can't do anything with it */
     1058 	     end;
     1059 
     1060 	call hcs_$initiate_count (dname, ename, "", bcount, 0, se_ptr, code); /* get ptr and length of sel. expr. */
     1061 
     1062 	if se_ptr = null then do;			/* couldn't init segment */
     1063 		call com_err_ (code, MRC, "Initiating ^a>^a", dname, ename);
     1064 		go to Exit;			/* can't go any farther now */
     1065 	     end;
     1066 
     1067 	a_ptr = se_ptr;				/* arg ptr */
     1068 	d_ptr = addr (se_desc);			/* point to descriptor */
     1069 	se_desc.len = divide (bcount, 9, 17);		/* set length in descriptor */
     1070 
     1071      end get_se;
     1072 
     1073 true_ptr: proc (a_ptr, d_ptr) returns (ptr);
     1074 
     1075 /* Procedure to insure that descriptor pointers passed to dsl_ are its ptrs, rathher than offsets. */
     1076 
     1077 	dcl     (a_ptr,				/* arg list ptr */
     1078 	        d_ptr)		 ptr;		/* descriptor ptr */
     1079 	dcl     1 its_wd1		 based (addr (d_ptr)),
     1080 		2 offset		 bit (18) unal,
     1081 		2 pad		 bit (12) unal,
     1082 		2 tag		 bit (6) unal;
     1083 
     1084 	if its_wd1.tag = "100011"b then return (d_ptr);	/* is already its ptr */
     1085 	else return (ptr (a_ptr, its_wd1.offset));	/* otherwise make its ptr */
     1086 
     1087      end true_ptr;
     1088 
     1089 cleanup_proc: proc;
     1090 
     1091 /* cleanup procedure to free any temporary. storage */
     1092 
     1093 	if a_ptr ^= null then free a_ptr -> arg_list in (work_area);
     1094 	if num_ptr ^= null then free num in (work_area);
     1095 	if mode_ptr ^= null then free mode in (work_area);
     1096 	if rmode_ptr ^= null then free rmode in (work_area);
     1097 	if val_ptr ^= null then free values in (work_area);
     1098 	if pm_ptr ^= null then free perm_ops in (work_area);
     1099 	if pv_ptr ^= null then free prev_ops in (work_area);
     1100 
     1101 	if se_ptr ^= null then do;
     1102 		call hcs_$terminate_noname (se_ptr, code);
     1103 		se_ptr = null ();
     1104 	     end;
     1105 
     1106 
     1107      end cleanup_proc;
     1108 
     1109 arg_err_hndlr: proc;
     1110 
     1111 	call com_err_ (error_table_$noarg, "mrds_call");
     1112 	call cleanup_proc;
     1113 
     1114      end arg_err_hndlr;
     1115 
     1116 free_open_lists: procedure;
     1117 
     1118 /* this procedure wipes out the temp seg used as a work area.  It is called
     1119*   whenever there is an error in open and after all data bases have
     1120*   been closed.  By deleting this area, we effectively free everything allocated
     1121*   in it. */
     1122 
     1123 	if wa_ptr ^= null then do;			/* got something to get rid of */
     1124 		call release_temp_segment_ (MRC, wa_ptr, discard_code);
     1125 		area_initialized = OFF;		/* remember that its not there any more */
     1126 	     end;
     1127 
     1128      end free_open_lists;
     1129 
  1     1 /* BEGIN mdbm_arg_list.incl.pl1 -- jaw 5/31/78 */
  1     2 /* the duplicate mrds_arg_list.incl.pl1 was eliminated by Jim Gray, Nov. 1979 */
  1     3 
  1     4 /* layout of argument list for IDS and DBM entries with options (variable) */
  1     5 
  1     6 dcl 1 arg_list based (al_ptr),
  1     7     2 arg_count fixed bin (17) unal,			/* 2 * no. of args. */
  1     8     2 code fixed bin (17) unal,			/* 4 => normal, 8 => special */
  1     9     2 desc_count fixed bin (17) unal,			/* 2 * no. of descriptors */
  1    10     2 pad fixed bin (17) unal,			/* must be 0 */
  1    11     2 arg_des_ptr (num_ptrs) ptr;			/* argument/descriptor pointer */
  1    12 
  1    13 dcl  al_ptr ptr;
  1    14 dcl  num_ptrs fixed bin;
  1    15 
  1    16 /* END mdbm_arg_list.incl.pl1  */
  1    17 
     1130 
     1131 
  2     1 /* BEGIN INCLUDE FILE mdbm_scope_requests.incl.pl1 - - Jim Gray 80-12-10 */
  2     2 
  2     3 /* this include file contains overlays for the fixed bin (17)
  2     4*   permit/prevent scope mode encoding that set/dl_fscope and all lower
  2     5*   routines use in interface communications.
  2     6*   Note that is fixed bin(17) aligned, as recieved from
  2     7*   mrds_dsl_set_scope, thus the overlay is for a full 36 bit word.
  2     8*   The scope modes are encoded as a sum of the individual permissions,
  2     9*   with 1 => read_attr, 2 => append_tuple, 4 => delete_tuple, 8 => modify_attr,
  2    10*   thus individual bits in the fixed bin word can be used for each mode
  2    11*   These were known as r-s-m-d modes by old mrds users. */
  2    12 
  2    13 declare 1 common based,				/* common layout of bits for scope modes */
  2    14         2 mbz1 bit (32) unal,				/* unused upper part of word */
  2    15         2 modify_attr bit (1) unal,			/* mode sum has an 8 */
  2    16         2 delete_tuple bit (1) unal,			/* mode sum has a 4 */
  2    17         2 append_tuple bit (1) unal,			/* mode sum has a 2 */
  2    18         2 read_attr bit (1) unal ;			/* mode sum has a 1 */
  2    19 
  2    20 declare 1 permit_requests like common based (permit_requests_ptr) ; /* permit modes in scope call */
  2    21 
  2    22 declare 1 prevent_requests like common based (prevent_requests_ptr) ; /* prevent modes in scope call */
  2    23 
  2    24 declare (permit_requests_ptr, prevent_requests_ptr) ptr ;
  2    25 
  2    26 /* the following structure is used to describe in detail,
  2    27*   what scope conflict existed between a users requested
  2    28*   permit/prevent modes in a set/dl_scope call and the
  2    29*   actual usage of a file/relation currently with active scope in the database
  2    30*   Note that for delete_scope, the conflict check is that the requested deletion
  2    31*   be a subset of the users currently set scope.
  2    32*   For set_scope, the conflict check is that a permit does not conflict with
  2    33*   another users prevent, and that the requested prevent does not
  2    34*   conflict with an existing other users permit already granted. */
  2    35 
  2    36 declare 1 conflict_detail based (conflict_detail_ptr),
  2    37         2 permits like common,			/* conflicts in permit part of requests */
  2    38         2 prevents like common ;			/* conflicts in prevent part of requests */
  2    39 
  2    40 declare  conflict_detail_ptr ptr ;
  2    41 
  2    42 /* END INCLUDE FILE mdbm_scope_requests.incl.pl1 */
     1132 
     1133 
  3     1 /* START OF:	mrds_new_scope_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3     2 
  3     3 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3     4 /* 									*/
  3     5 /* Name:  mrds_new_scope_modes.incl.pl1						*/
  3     6 /* 									*/
  3     7 /*      This include file defines named constants which can be used to specify the MRDS	*/
  3     8 /* operations to be permitted and prevented in a call to dsl_$set_scope.		*/
  3     9 /* 									*/
  3    10 /* Status									*/
  3    11 /* 									*/
  3    12 /* 0)   Created on January 25, 1980 by Jim Gray          				*/
  3    13 /* 1)   80-12-10 Jim Gray : r-u scope modes changed to r-s-m-d type scope modes,          */
  3    14 /*    also, names were changed to agree with security acl modes in MRDS.	          */
  3    15 /*									*/
  3    16 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3    17 
  3    18 dcl (NO_OP init (0),
  3    19      READ_ATTR init (1),
  3    20      APPEND_TUPLE init (2),
  3    21      DELETE_TUPLE init (4),
  3    22      MODIFY_ATTR init (8),
  3    23      UPDATE_OPS init (14),
  3    24      ALL_OPS init (15)) fixed bin int static options (constant);
  3    25 
  3    26 /* END OF:	mrds_new_scope_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1134 
     1135 
  4     1 /* BEGIN INCLUDE FILE mrds_database_list.incl.pl1 - - Jim Gray July 1979 */
  4     2 
  4     3 /* used by mrds_dsl_list_dbs to return an array of database opening information,
  4     4*   the databases opened for the calling process have their opening index
  4     5*   and opening model or submodel pathname returned in the array */
  4     6 
  4     7 declare  database_list_ptr ptr ;			/* points to array of indexes/pathnames */
  4     8 
  4     9 declare 1 database_list aligned based (database_list_ptr),	/* array of paths/indexes */
  4    10         2 number_open fixed bin,			/* total open by this process */
  4    11         2 db (number_of_openings refer (database_list.number_open)), /* array of open db info */
  4    12 	3 index fixed bin (35),			/* database opening index */
  4    13  	3 path char (168);                                /* model or submodel opening pathname */
  4    14 
  4    15 declare  number_of_openings fixed bin ;			/* total number open by this process */
  4    16 
  4    17 /* END INCLUDE FILE mrds_database_list.incl.pl1 */
  4    18 
     1136 
     1137 
  5     1 /* BEGIN INCLUDE FILE mrds_database_openings.incl.pl1 - - Jim Gray July 1979 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*
  5     5*   used by dsl_$list_openings to return an array of database opening information,
  5     6*   the mrds_databases opened for the calling process have their opening index
  5     7*   and opening model or submodel pathname returned in the array
  5     8*
  5     9**/
  5    10 
  5    11 /* HISTORY:
  5    12*   80-12-08 Rickie E. Brinegar: added the opening mode to the structure. Taken
  5    13*   from mrds_database_list.incl.pl1
  5    14*
  5    15*   81-01-27 Jim Gray : changed name to mrds_database_openings in process of adding
  5    16*   structure version information, plus pad bits after extending info
  5    17*   to include whether opening was via a model or submodel.
  5    18**/
  5    19 
  5    20 declare 1 mrds_database_openings aligned based (mrds_database_openings_ptr), /* array of paths/indexes */
  5    21         2 version fixed bin,				/* the version number of this structure */
  5    22         2 number_open fixed bin,			/* total open by this process */
  5    23         2 mbz1 bit (36) unal,
  5    24         2 db (mrds_database_openings_num_open_init
  5    25          refer (mrds_database_openings.number_open)),	/* array of open db info */
  5    26 	3 index fixed bin (35),			/* database opening index */
  5    27 	3 path char (168),				/* model or submodel opening pathname */
  5    28 	3 mode char (20),				/* opening mode of the database */
  5    29 	3 model bit (1) unal,			/* on => opened via the model */
  5    30 	3 submodel bit (1) unal,			/* on => opened via a submodel */
  5    31 	3 mbz2 bit (34) unal ;
  5    32 
  5    33 declare  mrds_database_openings_ptr ptr ;		/* points to array of indexes/pathnames */
  5    34 
  5    35 declare  mrds_database_openings_num_open_init fixed bin ;	/* total number open by this process */
  5    36 
  5    37 declare  mrds_database_openings_structure_version fixed bin int static options (constant) init (1) ; /* current version */
  5    38 
  5    39 /* END INCLUDE FILE mrds_database_openings.incl.pl1 */
  5    40 
     1138 
     1139 
     1140 	dcl     (a_ptr,
     1141 	        arg_ptr,				/* ptr to arg. of interest */
     1142 	        f_ptr,
     1143 	        filen_ptr,
     1144 	        fn_ptr,
     1145 	        num_ptr,
     1146 	        mode_ptr,
     1147 	        ms_ptr,				/* ptr to input mode string */
     1148 	        pm_ptr,
     1149 	        pv_ptr,
     1150 	        rmode_ptr,
     1151 	        se_ptr,				/* ptr to selection expr to be passed to dsl_ */
     1152 	        sea_ptr,				/* arg ptr for seg se. */
     1153 	        sed_ptr,				/* desc ptr for seg se. */
     1154 	        val_ptr)		 ptr;
     1155 
     1156 	dcl     (arg_len,				/* length of arg of interest */
     1157 	        desc_off_i,
     1158 	        desc_off_o,
     1159 	        f_len,
     1160 	        fn_len,
     1161 	        i,
     1162 	        j,				/* internal index */
     1163 	        ms_len,				/* length of mode string */
     1164 	        n_vals,
     1165 	        nargs,
     1166 	        open_cnt,
     1167 	        ready_cnt,
     1168 	        scope_cnt,
     1169 	        se_len,				/* length of se. seg. path */
     1170 	        se_seg_sw)		 fixed bin;	/* indicates if seg se. expr. */
     1171 
     1172 	dcl     (code,
     1173 	        dbi,
     1174 	        rel_ind)		 fixed bin (35);
     1175 
     1176 	dcl     all_sw		 bit (1) unal;	/* on => outo anothers */
     1177 	dcl     anoth_desc		 bit (36) aligned int static options (constant) init ("101010100000000000000000000000001000"b);
     1178 	dcl     anoth_str		 char (8) aligned int static options (constant) init ("-another");
     1179 	dcl     arg		 char (arg_len) based (arg_ptr); /* arg of current interest */
     1180 	dcl     current_arg		 fixed bin;	/* Used in retrieve argument scanning */
     1181 	dcl     done_scanning	 bit (1);		/* Are we done parsing the dashed args */
     1182 	dcl     fn_name		 char (fn_len) based (fn_ptr);
     1183 	dcl     mode		 (open_cnt) fixed bin (35) based (mode_ptr);
     1184 	dcl     mode_string		 char (ms_len) based (ms_ptr); /* opening mode */
     1185 	dcl     num		 (open_cnt) fixed bin (35) based (num_ptr);
     1186 	dcl     num_open		 fixed bin int static init (0); /* num. of open data bases */
     1187 	dcl     operation		 char (f_len) based (f_ptr);
     1188 	dcl     perm_ops		 (scope_cnt) fixed bin (35) based (pm_ptr);
     1189 	dcl     prev_ops		 (scope_cnt) fixed bin (35) based (pv_ptr);
     1190 	dcl     rmode		 (ready_cnt) fixed bin (35) based (rmode_ptr);
     1191 	dcl     se_path		 char (168) aligned;/* path name of selection expr. */
     1192 	dcl     values		 (n_vals) char (256) based (val_ptr);
     1193 	dcl     wa_ptr		 static pointer init (null); /* ptr to temp seg containing the above */
     1194 	dcl     wait_time		 fixed bin (35);	/* optional maximum wait time for scope setting */
     1195 						/* NOTE: this MUST be declared fixed bin 35 NOT 71,
     1196*						   since mrds_dsl_set_scope expects a fb35 number, and is documented that way for users */
     1197 
     1198 	dcl     ms_array		 (8) char (20) int static options (constant) init (/* allowable opening modes */
     1199 				 "retrieval", "r",
     1200 				 "update", "u",
     1201 				 "exclusive_retrieval", "er",
     1202 				 "exclusive_update", "eu");
     1203 
     1204 	dcl     mv_array		 (8) fixed bin int static options (constant) /* corresponding numeric values */
     1205 				 init (1, 1, 2, 2, 3, 3, 4, 4);
     1206 
     1207 	dcl     char_desc		 bit (36) aligned init ("101010100000000000000000000100000000"b);
     1208 	declare fb_17_desc		 bit (36) aligned init ("100000100000000000000000000000010001"b);
     1209 	dcl     fb_35_desc		 bit (36) aligned init ("100000100000000000000000000000100011"b);
     1210 
     1211 	dcl     work_area		 area (sys_info$max_seg_size) based (wa_ptr);
     1212 
     1213 	dcl     (error_table_$bad_arg,
     1214 	        error_table_$noarg,
     1215 	        mrds_error_$tuple_not_found,
     1216 	        sys_info$max_seg_size) fixed bin (35) ext;
     1217 
     1218 	dcl     (addr,
     1219 	        divide,
     1220 	        empty,
     1221 	        fixed,
     1222 	        length,
     1223 	        mod,
     1224 	        null,
     1225 	        ptr,
     1226 	        search,
     1227 	        substr,
     1228 	        verify)		 builtin;
     1229 
     1230 	dcl     (arg_err_,
     1231 	        cleanup,
     1232 	        conversion,
     1233 	        sub_error_)		 condition;	/* signaled when sub_error_ called */
     1234 
     1235 	dcl     (com_err_,
     1236 	        ioa_,
     1237 	        mrds_dsl_close$close,
     1238 	        mrds_dsl_define_temp_rel$define_temp_rel,
     1239 	        mrds_dsl_delete$delete,
     1240 	        mrds_dsl_modify$modify,
     1241 	        mrds_dsl_open$open,
     1242 	        mrds_dsl_retrieve$retrieve,
     1243 	        mrds_dsl_set_scope$dl_scope,
     1244 	        mrds_dsl_set_scope$set_scope,
     1245 	        mrds_dsl_set_scope$set_scope_all,
     1246 	        mrds_dsl_store$store)	 entry options (variable);
     1247 
     1248 	dcl     mrds_dsl_declare	 entry (fixed bin (35), char (*), fixed bin (35));
     1249 	declare mrds_dsl_get_scope	 entry (fixed bin (35), char (*), fixed bin, fixed bin, fixed bin, fixed bin (35)); /* gets permits/prevents scope on rel */
     1250 	declare relation_name	 char (relation_name_len) based (relation_name_ptr);
     1251 	declare relation_name_ptr	 ptr;
     1252 	declare relation_name_len	 fixed bin;
     1253 	declare (permits, prevents)	 fixed bin;
     1254 	declare scope_version	 fixed bin;	/* 5 => r-a-m-d, < 5 => r-s-m-d */
     1255 	declare store_scope		 char (1);	/* either "s" or "a" */
     1256 	declare (permit_string, prevent_string) char (4) varying; /* for displaying scope */
     1257 	declare tuple_count		 fixed bin (35);	/* number of tuples in relation */
     1258 	declare mrds_dsl_get_population entry options (variable); /* get population of rels */
     1259 	dcl     mrds_dsl_set_scope$dl_scope_all entry (fixed bin (35), fixed bin (35));
     1260 
     1261 	dcl     (DBI		 char (15) init ("data_base_index"),
     1262 	        MRC		 char (9) init ("mrds_call"),
     1263 	        NVALS		 char (5) init ("nvals"),
     1264 	        TRI		 char (14) init ("temp_rel_index"),
     1265 	        WT		 char (9) init ("wait_time")) static options (constant);
     1266 
     1267 	dcl     arg_cnt		 fixed bin;	/* number of set_mode arguments + 1 */
     1268 	dcl     continue_to_signal_	 entry (fixed bin (35)); /* to keep signaling */
     1269 	dcl     error_display_flag	 bit (1) internal static init ("1"b); /* on => output sub error mesg */
     1270 	dcl     error_table_$wrong_no_of_args fixed bin (35) ext;
     1271 	dcl     handler_found_code	 fixed bin (35);
     1272 	dcl     list_display_flag	 bit (1) internal static init ("1"b); /* on => list open dbs, and ready files after open/ready */
     1273 	dcl     mrc_mode		 char (mrc_mode_len) based (mrc_mode_ptr); /* set_modes mode arg */
     1274 	dcl     mrc_mode_len	 fixed bin;	/* length of set_mode mode arg */
     1275 	dcl     mrc_mode_ptr	 ptr;		/* set_mode mode pointer */
     1276 	dcl     mrds_dsl_close_all	 entry (fixed bin (35)); /* close all open dbs */
     1277 	dcl     NL		 char (1) init ("
     1278 ");						/* new line character */
     1279 	dcl     ON		 bit (1) init ("1"b); /* true value */
     1280 	dcl     OFF		 bit (1) init ("0"b); /* false value */
     1281 
     1282 	dcl     area_initialized	 bit (1) internal static init ("0"b); /* on => work area created */
     1283 	dcl     discard_code	 fixed bin (35);	/* unused */
     1284 	dcl     get_temp_segment_	 entry (char (*), ptr, fixed bin (35)); /* gets space for work area */
     1285 	dcl     mrds_data_$max_dbs	 fixed bin (35) ext;/* max num of open dbs */
     1286 	dcl     mrds_dsl_db_openings$list_dbs entry (ptr, ptr); /* gets list of open dbs */
     1287 	declare mrds_dsl_db_openings$list_openings entry (ptr, fixed bin, ptr, fixed bin (35)); /* extended open info */
     1288 	declare no_output_mode	 bit (1) int static init ("0"b); /* on => don't return retreived values */
     1289 	declare tuples_retrieved	 fixed bin (35);	/* number of values not seen */
     1290 	dcl     NA		 char (20) init ("Mode not available");
     1291 	dcl     release_temp_segment_	 entry (char (*), ptr, fixed bin (35)); /* removes work space */
     1292 	dcl     temp_mode_list	 (1:mrds_data_$max_dbs) char (20) based (tml_ptr); /* temp store for opening modes */
     1293 	dcl     tml_ptr		 ptr init (null ());/* points to temp_mode_list */
     1294 
     1295 	dcl     cu_$arg_list_ptr	 entry (ptr);
     1296 	dcl     cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin, fixed bin (35));
     1297 	dcl     cu_$arg_ptr_rel	 entry (fixed bin, ptr, fixed bin, fixed bin (35), ptr);
     1298 	dcl     cu_$generate_call	 entry (entry, ptr);
     1299 	dcl     expand_path_	 entry (ptr, fixed bin, ptr, ptr, fixed bin (35));
     1300 	dcl     hcs_$initiate_count	 entry (char (*), char (*), char (*), fixed bin (24), fixed bin (2), ptr, fixed bin (35));
     1301 	dcl     hcs_$terminate_noname	 entry (ptr, fixed bin (35));
     1302 
     1303      end mrds_call;
     1304 
     1305 
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/85  0906.3  mrds_call.pl1                     >special_ldd>online>mrds.pbf-04/18/85>mrds_call.pl1
1130         1    10/14/83  1609.0  mdbm_arg_list.incl.pl1            >ldd>include>mdbm_arg_list.incl.pl1
1132         2    10/14/83  1608.7  mdbm_scope_requests.incl.pl1      >ldd>include>mdbm_scope_requests.incl.pl1
1134         3    10/14/83  1608.7  mrds_new_scope_modes.incl.pl1     >ldd>include>mrds_new_scope_modes.incl.pl1
1136         4    10/14/83  1608.7  mrds_database_list.incl.pl1       >ldd>include>mrds_database_list.incl.pl1
1138         5    10/14/83  1608.7  mrds_database_openings.incl.pl1   >ldd>include>mrds_database_openings.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
APPEND_TUPLE                           constant        fixed bin(17,0)          initial dcl 3-18 ref 991
DBI                             000015 constant        char(15)                 initial unaligned dcl 1261 set ref 231* 316* 485*
                                                                                  554* 564* 601* 627* 660* 730* 787*
DELETE_TUPLE                           constant        fixed bin(17,0)          initial dcl 3-18 ref 992
MODIFY_ATTR                            constant        fixed bin(17,0)          initial dcl 3-18 ref 993
MRC                             000012 constant        char(9)                  initial unaligned dcl 1261 set ref 131* 151* 152*
                                                                                  185* 201* 207* 213* 221* 251* 274* 281* 303* 311*
                                                                                  345* 360* 414* 459* 478* 490* 496* 535* 551* 556*
                                                                                  561* 566* 570* 597* 603* 609* 631* 635* 641* 652*
                                                                                  655* 666* 673* 708* 721* 771* 782* 822* 836* 859*
                                                                                  866* 880* 885* 946* 955* 977* 985* 1008* 1056*
                                                                                  1063* 1124*
NA                              000335 automatic       char(20)                 initial unaligned dcl 1290 set ref 1290*
NL                              000330 automatic       char(1)                  initial unaligned dcl 1277 set ref 1277*
NVALS                           000010 constant        char(5)                  initial unaligned dcl 1261 set ref 315*
OFF                             000332 automatic       bit(1)                   initial unaligned dcl 1280 set ref 285 291 1125
                                                                                  1280*
ON                              000331 automatic       bit(1)                   initial unaligned dcl 1279 set ref 135 287 289 296
                                                                                  1279*
READ_ATTR                              constant        fixed bin(17,0)          initial dcl 3-18 ref 990
TRI                             000003 constant        char(14)                 initial unaligned dcl 1261 set ref 508* 950
UPDATE_OPS                             constant        fixed bin(17,0)          initial dcl 3-18 ref 994
WT                              000000 constant        char(9)                  initial unaligned dcl 1261 set ref 733* 789*
a_ptr                                  parameter       pointer                  dcl 1044 in procedure "get_se" set ref 1037 1067*
a_ptr                           000114 automatic       pointer                  dcl 1140 in procedure "mrc" set ref 115* 177 219 219
                                                                                  232 233 237 389 390 394 395 399 513 514 518 519
                                                                                  523 689 690 693 694 698 743 744 748 749 750 750
                                                                                  755 799 800 801 801 804 853 854 855 871 873 873
                                                                                  901* 903 903 905 1093 1093
a_ptr                                  parameter       pointer                  dcl 1077 in procedure "true_ptr" ref 1073 1085
addr                                                   builtin function         dcl 1218 ref 179 180 232 233 238 239 400 401 402 406
                                                                                  407 437 438 524 525 526 527 573 574 699 700 701
                                                                                  748 749 750 756 757 759 760 762 799 800 801 805
                                                                                  806 810 811 813 854 855 873 1053 1053 1053 1053
                                                                                  1053 1053 1068 1084 1085
al_index                        000417 automatic       fixed bin(17,0)          dcl 831 set ref 851* 853 854 855 871 873 873
al_ptr                          000100 automatic       pointer                  dcl 1-13 set ref 138* 139 140 177* 178 179 180 182*
                                                                                  195 237* 238 239 241* 243 394 395* 395 399* 400
                                                                                  401 402 402 406 407 410* 437 438 442* 469 518 519*
                                                                                  519 523* 524 525 526 527 527 527 531* 533 565*
                                                                                  602* 629* 693 694* 694 698* 699 700 701 701 704*
                                                                                  706 743 744* 744 755* 756 757 759 760 762 762 765*
                                                                                  769 804* 805 806 810 811 813 813 816* 820 853 871*
                                                                                  871 908 908 943* 975*
all_sw                          000174 automatic       bit(1)                   unaligned dcl 1176 set ref 318* 349 353* 355 368
                                                                                  433* 436
anoth_desc                      000104 constant        bit(36)                  initial dcl 1177 set ref 438
anoth_str                       000102 constant        char(8)                  initial dcl 1178 set ref 437
append_tuple              0(34)        based           bit(1)                   level 2 in structure "permit_requests" packed
                                                                                  unaligned dcl 2-20 in procedure "mrc" ref 580
append_tuple              0(34)        based           bit(1)                   level 2 in structure "prevent_requests" packed
                                                                                  unaligned dcl 2-22 in procedure "mrc" ref 586
area_initialized                000016 internal static bit(1)                   initial unaligned dcl 1282 set ref 127 135* 1125*
arg                                    based           char                     unaligned dcl 1179 set ref 210 210 349 349 357 357
                                                                                  360* 373 374 378 493 493 500 670 670 677 885*
arg_cnt                         000323 automatic       fixed bin(17,0)          dcl 1267 set ref 278* 280*
arg_count                              based           fixed bin(17,0)          level 2 packed unaligned dcl 1-6 set ref 139 140 178
                                                                                  903* 908
arg_des_ptr               2            based           pointer                  array level 2 dcl 1-6 set ref 179* 180* 232* 233*
                                                                                  238* 239* 389* 390* 394* 394 395* 395* 400* 401*
                                                                                  402* 402* 406* 407* 437* 438* 513* 514* 518* 518
                                                                                  519* 519* 524* 525* 526* 527* 527* 527* 689* 690*
                                                                                  693* 693 694* 694* 699* 700* 701* 701* 743* 743
                                                                                  744* 744* 748* 749* 750* 750* 756* 757* 759* 760*
                                                                                  762* 762* 799* 800* 801* 801* 805* 806* 810* 811*
                                                                                  813* 813* 853* 853 854* 855* 871* 871* 873* 873*
arg_err_                        000256 stack reference condition                dcl 1230 ref 126
arg_len                         000152 automatic       fixed bin(17,0)          dcl 1156 set ref 205* 210 210 342* 349 349 357 357
                                                                                  360 360 373 374 378 379 487* 493 493 494* 500 501
                                                                                  664* 670 670 671* 677 678 878* 885 885
arg_list                               based           structure                level 1 unaligned dcl 1-6 set ref 195 219 243 469
                                                                                  533 706 769 820 901 1093
arg_ptr                         000116 automatic       pointer                  dcl 1140 set ref 205* 210 210 342* 349 349 357 357
                                                                                  360 373 374 378 487* 493 493 494* 500 664* 670 670
                                                                                  671* 677 878* 885
argument_type                          parameter       char                     unaligned dcl 936 set ref 934 946* 950 955*
bcount                          000566 automatic       fixed bin(24,0)          dcl 1048 set ref 1060* 1069
char_desc                       000252 automatic       bit(36)                  initial dcl 1207 set ref 407 1207*
cleanup                         000264 stack reference condition                dcl 1230 ref 125
code                      0(18)        based           fixed bin(17,0)          level 2 in structure "arg_list" packed unaligned
                                                                                  dcl 1-6 in procedure "mrc" set ref 905* 908
code                            000171 automatic       fixed bin(35,0)          dcl 1172 in procedure "mrc" set ref 123* 129* 130
                                                                                  131* 148* 150 151* 179 184 185* 205* 207 207* 211*
                                                                                  213 213* 238 251 251* 280* 281 281* 342* 344 345*
                                                                                  401 412 414* 440 444 454 459* 487* 489 490* 494*
                                                                                  495 496* 526 535 535* 555* 556 556* 565* 566 566*
                                                                                  569* 570 570* 602* 603 603* 607* 609 609* 629* 631
                                                                                  631* 634* 635 635* 664* 665 666* 671* 672 673* 700
                                                                                  708 708* 757 771 771* 806 822 822* 857* 858 859*
                                                                                  866* 878* 879 880* 884 885* 943* 945 946* 975* 976
                                                                                  977* 1006* 1008 1008* 1053* 1055 1056* 1060* 1063*
                                                                                  1102*
com_err_                        000030 constant        entry                    external dcl 1235 ref 131 151 152 185 201 207 213
                                                                                  221 251 274 281 303 311 345 360 414 459 478 490
                                                                                  496 535 551 556 561 566 570 597 603 609 624 631
                                                                                  635 641 652 655 666 673 708 721 771 782 822 836
                                                                                  859 866 880 885 946 955 977 985 1008 1056 1063
                                                                                  1111
common                                 based           structure                level 1 packed unaligned dcl 2-13
const                           000567 automatic       bit(12)                  initial level 2 packed unaligned dcl 1049 set ref
                                                                                  1049*
continue_to_signal_             000070 constant        entry                    external dcl 1268 ref 145
conversion                      000272 stack reference condition                dcl 1230 ref 218 957
count                                  parameter       fixed bin(17,0)          dcl 895 ref 893 900 903 907
cu_$arg_list_ptr                000110 constant        entry                    external dcl 1295 ref 138
cu_$arg_ptr                     000112 constant        entry                    external dcl 1296 ref 148 205 280 342 487 494 664
                                                                                  671 857 878
cu_$arg_ptr_rel                 000114 constant        entry                    external dcl 1297 ref 565 602 629 943 975
cu_$generate_call               000116 constant        entry                    external dcl 1298 ref 182 241 410 442 531 704 765
                                                                                  816
current_arg                     000175 automatic       fixed bin(17,0)          dcl 1180 set ref 320* 342* 382* 382
d_ptr                                  parameter       pointer                  dcl 1044 in procedure "get_se" set ref 1037 1068*
d_ptr                                  parameter       pointer                  dcl 1077 in procedure "true_ptr" set ref 1073 1084
                                                                                  1084 1085
database_list                          based           structure                level 1 dcl 4-9 ref 249
database_list_ptr               000110 automatic       pointer                  dcl 4-7 set ref 246* 247 249
db                        3            based           structure                array level 2 dcl 5-20
dbi                             000172 automatic       fixed bin(35,0)          dcl 1172 set ref 316* 400 485* 524 554* 555* 564*
                                                                                  569* 601* 607* 627* 634* 660* 699 730* 756 787*
                                                                                  805
delete_tuple              0(33)        based           bit(1)                   level 2 in structure "permit_requests" packed
                                                                                  unaligned dcl 2-20 in procedure "mrc" ref 582
delete_tuple              0(33)        based           bit(1)                   level 2 in structure "prevent_requests" packed
                                                                                  unaligned dcl 2-22 in procedure "mrc" ref 588
desc_count                1            based           fixed bin(17,0)          level 2 packed unaligned dcl 1-6 set ref 903*
desc_off_i                      000153 automatic       fixed bin(17,0)          dcl 1156 set ref 395 519 694 744 871 908*
desc_off_o                      000154 automatic       fixed bin(17,0)          dcl 1156 set ref 180 233 239 390 395 402 402 407 438
                                                                                  514 519 527 527 527 690 694 701 701 744 750 750
                                                                                  760 762 762 801 801 811 813 813 871 873 873 907*
discard_code                    000333 automatic       fixed bin(35,0)          dcl 1283 set ref 642* 1124*
divide                                                 builtin function         dcl 1218 ref 140 178 737 746 747 748 749 841 908
                                                                                  1069
dname                           000504 automatic       char(168)                unaligned dcl 1046 set ref 1053 1053 1060* 1063*
done_scanning                   000176 automatic       bit(1)                   unaligned dcl 1181 set ref 319* 341 349* 355* 368*
                                                                                  370*
dsl_entry                              parameter       entry variable           dcl 717 in procedure "call_scope_fun" set ref 715
                                                                                  765*
dsl_entry                              parameter       entry variable           dcl 780 in procedure "call_set_scope_all_fun" set
                                                                                  ref 778 816*
dsl_entry                              parameter       entry variable           dcl 648 in procedure "call_mod_fun" set ref 647 704*
empty                                                  builtin function         dcl 1218 ref 134
ename                           000556 automatic       char(32)                 unaligned dcl 1047 set ref 1053 1053 1060* 1063*
error_display_flag              000014 internal static bit(1)                   initial unaligned dcl 1269 set ref 144 152 289* 291*
error_table_$bad_arg            000020 external static fixed bin(35,0)          dcl 1213 set ref 303* 641* 955* 985*
error_table_$noarg              000022 external static fixed bin(35,0)          dcl 1213 set ref 360* 1111*
error_table_$wrong_no_of_args   000072 external static fixed bin(35,0)          dcl 1270 set ref 201* 274* 311* 478* 551* 561* 597*
                                                                                  624* 652* 655* 721* 782* 836*
expand_path_                    000120 constant        entry                    external dcl 1299 ref 1053
f_len                           000155 automatic       fixed bin(17,0)          dcl 1156 set ref 148* 160 160 200 200 257 257 261
                                                                                  261 265 265 265 269 269 273 273 309 309 476 476
                                                                                  541 541 544 544 547 547 550 550 560 560 596 596
                                                                                  623 623 641 641 957 957
f_ptr                           000120 automatic       pointer                  dcl 1140 set ref 148* 160 160 200 200 257 257 261
                                                                                  261 265 265 265 269 269 273 273 309 309 476 476
                                                                                  541 541 544 544 547 547 550 550 560 560 596 596
                                                                                  623 623 641 957 957
fb_17_desc                      000253 automatic       bit(36)                  initial dcl 1208 set ref 750 801 1208*
fb_35_desc                      000254 automatic       bit(36)                  initial dcl 1209 set ref 180 233 239 402 527 701 760
                                                                                  762 811 813 873 1209*
filen_ptr                       000122 automatic       pointer                  dcl 1140 set ref 115*
fixed                                                  builtin function         dcl 1218 ref 908 961
fn_len                          000156 automatic       fixed bin(17,0)          dcl 1156 set ref 629* 634 634
fn_name                                based           char                     unaligned dcl 1182 set ref 634*
fn_ptr                          000124 automatic       pointer                  dcl 1140 set ref 629* 634
get_temp_segment_               000076 constant        entry                    external dcl 1284 ref 129
handler_found_code              000324 automatic       fixed bin(35,0)          dcl 1271 set ref 145*
hcs_$initiate_count             000122 constant        entry                    external dcl 1300 ref 1060
hcs_$terminate_noname           000124 constant        entry                    external dcl 1301 ref 642 1102
i                               000157 automatic       fixed bin(17,0)          dcl 1156 in procedure "mrc" set ref 230* 231 231*
                                                                                  232 232 233* 393* 394 394 395 395* 405* 406 406
                                                                                  407* 423* 424* 448* 449* 517* 518 518 519 519*
                                                                                  692* 693 693 694 694* 741* 743 743 744 744 746 746
                                                                                  747 747 748 748 749 749 750 750* 850* 851 853 854
                                                                                  855 857 870 871 876 876 878* 1019* 1022 1022 1022*
i                               000440 automatic       fixed bin(17,0)          dcl 937 in procedure "conv_int" set ref 950* 952*
                                                                                  954
index                                  parameter       fixed bin(17,0)          dcl 970 in procedure "conv_ops" set ref 965 975*
index                                  parameter       fixed bin(17,0)          dcl 940 in procedure "conv_int" set ref 934 943*
index                     3            based           fixed bin(35,0)          array level 3 in structure "mrds_database_openings"
                                                                                  dcl 5-20 in procedure "mrc" set ref 1022*
index                                  parameter       fixed bin(17,0)          dcl 718 in procedure "call_scope_fun" set ref 715
                                                                                  721* 721* 771*
index                                  parameter       fixed bin(17,0)          dcl 649 in procedure "call_mod_fun" set ref 647 652
                                                                                  655* 655* 655* 663 708*
ioa_                            000032 constant        entry                    external dcl 1235 ref 421 424 447 449 455 457 465
                                                                                  537 590 613 1012 1016 1022 1026
its_wd1                                based           structure                level 1 packed unaligned dcl 1079
j                               000160 automatic       fixed bin(17,0)          dcl 1156 set ref 863* 863* 865 870
len                       0(12) 000567 automatic       fixed bin(23,0)          level 2 packed unaligned dcl 1049 set ref 1069*
length                                                 builtin function         dcl 1218 ref 373 373 374 375
list_display_flag               000015 internal static bit(1)                   initial unaligned dcl 1272 set ref 192 285* 287*
mod                                                    builtin function         dcl 1218 ref 732 833
mode                                   based           fixed bin(35,0)          array dcl 1183 in procedure "mrc" set ref 197 846
                                                                                  855 870* 876 1095
mode                     56            based           char(20)                 array level 3 in structure "mrds_database_openings"
                                                                                  dcl 5-20 in procedure "mrc" set ref 1022*
mode_ptr                        000130 automatic       pointer                  dcl 1140 set ref 115* 197 846* 855 870 876 1095 1095
mode_string                            based           char                     unaligned dcl 1184 set ref 863 866*
modify_attr               0(32)        based           bit(1)                   level 2 in structure "prevent_requests" packed
                                                                                  unaligned dcl 2-22 in procedure "mrc" ref 587
modify_attr               0(32)        based           bit(1)                   level 2 in structure "permit_requests" packed
                                                                                  unaligned dcl 2-20 in procedure "mrc" ref 581
mrc_mode                               based           char                     unaligned dcl 1273 set ref 285 287 289 291 296 296
                                                                                  298 298 303*
mrc_mode_len                    000325 automatic       fixed bin(17,0)          dcl 1274 set ref 280* 285 287 289 291 296 296 298
                                                                                  298 303 303
mrc_mode_ptr                    000326 automatic       pointer                  dcl 1275 set ref 280* 285 287 289 291 296 296 298
                                                                                  298 303
mrds_data_$max_dbs              000100 external static fixed bin(35,0)          dcl 1285 ref 189 847 848
mrds_database_openings                 based           structure                level 1 dcl 5-20 set ref 1032
mrds_database_openings_ptr      000112 automatic       pointer                  dcl 5-33 set ref 1006* 1012 1016 1019 1022 1022 1022
                                                                                  1032 1032
mrds_database_openings_structure_version
                                000214 constant        fixed bin(17,0)          initial dcl 5-37 set ref 1006*
mrds_dsl_close$close            000034 constant        entry                    external dcl 1235 ref 241 241
mrds_dsl_close_all              000074 constant        entry                    external dcl 1276 ref 211
mrds_dsl_db_openings$list_dbs   000102 constant        entry                    external dcl 1286 ref 246
mrds_dsl_db_openings$list_openings
                                000104 constant        entry                    external dcl 1287 ref 1006
mrds_dsl_declare                000060 constant        entry                    external dcl 1248 ref 634
mrds_dsl_define_temp_rel$define_temp_rel
                                000036 constant        entry                    external dcl 1235 ref 531 531
mrds_dsl_delete$delete          000040 constant        entry                    external dcl 1235 ref 265 265
mrds_dsl_get_population         000064 constant        entry                    external dcl 1258 ref 607
mrds_dsl_get_scope              000062 constant        entry                    external dcl 1249 ref 569
mrds_dsl_modify$modify          000042 constant        entry                    external dcl 1235 ref 269 269
mrds_dsl_open$open              000044 constant        entry                    external dcl 1235 ref 182 182
mrds_dsl_retrieve$retrieve      000046 constant        entry                    external dcl 1235 ref 410 410 442 442
mrds_dsl_set_scope$dl_scope     000050 constant        entry                    external dcl 1235 ref 547 547
mrds_dsl_set_scope$dl_scope_all 000066 constant        entry                    external dcl 1259 ref 555
mrds_dsl_set_scope$set_scope    000052 constant        entry                    external dcl 1235 ref 541 541
mrds_dsl_set_scope$set_scope_all
                                000054 constant        entry                    external dcl 1235 ref 544 544
mrds_dsl_store$store            000056 constant        entry                    external dcl 1235 ref 261 261
mrds_error_$tuple_not_found     000024 external static fixed bin(35,0)          dcl 1213 ref 454
ms_array                        000031 constant        char(20)                 initial array unaligned dcl 1198 ref 863 876
ms_len                          000161 automatic       fixed bin(17,0)          dcl 1156 set ref 857* 863 866 866
ms_ptr                          000132 automatic       pointer                  dcl 1140 set ref 857* 863 866
mv_array                        000021 constant        fixed bin(17,0)          initial array dcl 1204 ref 870
n_vals                          000162 automatic       fixed bin(17,0)          dcl 1156 set ref 315* 385 386 401 402 405 421 423
                                                                                  448 470 1097
nargs                           000163 automatic       fixed bin(17,0)          dcl 1156 set ref 140* 178* 179 180 201 225* 227 230
                                                                                  238 239 274 278 311 320 354* 354 367* 367 385 393
                                                                                  401 402 405 405 406 477 487 490 494* 503* 503 508
                                                                                  510* 517 525 526 527 527 551 561 597 624 651 664
                                                                                  666 671* 680* 680 686* 692 700 701 721 732 733*
                                                                                  735* 737 741 757 759 760 762 782 782 789 789* 791*
                                                                                  806 808 810 811 813 833 835 841
nc_len                          000444 automatic       fixed bin(17,0)          dcl 940 set ref 943* 950 952 955 955 961
nc_ptr                          000442 automatic       pointer                  dcl 939 set ref 943* 950 952 955 961
no_output_mode                  000017 internal static bit(1)                   initial unaligned dcl 1288 set ref 296* 298* 420 446
                                                                                  455
null                                                   builtin function         dcl 1218 ref 115 190 219 220 247 642 847 1032 1062
                                                                                  1093 1094 1095 1096 1097 1098 1099 1101 1103 1123
                                                                                  1293
num                                    based           fixed bin(35,0)          array dcl 1185 set ref 196 220 228 231* 232 244 845
                                                                                  854 1094
num_char                               based           char                     unaligned dcl 938 set ref 950 952 955* 961
num_open                        000010 internal static fixed bin(17,0)          initial dcl 1186 set ref 841*
num_ptr                         000126 automatic       pointer                  dcl 1140 set ref 115* 196 220 220 228* 231 232 244
                                                                                  845* 854 1094 1094
num_ptrs                        000102 automatic       fixed bin(17,0)          dcl 1-14 set ref 139* 195 219 243 469 533 706 769
                                                                                  820 898 900* 901 927 927* 1093
number_open               1            based           fixed bin(17,0)          level 2 in structure "mrds_database_openings"
                                                                                  dcl 5-20 in procedure "mrc" ref 1012 1016 1019
                                                                                  1032
number_open                            based           fixed bin(17,0)          level 2 in structure "database_list" dcl 4-9
                                                                                  in procedure "mrc" ref 249
odd                             000416 automatic       fixed bin(17,0)          dcl 830 set ref 833* 835
offset                                 based           bit(18)                  level 2 packed unaligned dcl 1079 ref 1085
old_num_ptrs                    000430 automatic       fixed bin(17,0)          dcl 896 set ref 898* 927 927
op_num                          000465 automatic       fixed bin(35,0)          dcl 973 set ref 980* 983* 984 985 985 990* 990 991*
                                                                                  991 992* 992 993* 993 994* 994 997
open_cnt                        000164 automatic       fixed bin(17,0)          dcl 1156 set ref 196 197 220 227* 228 244 841* 843
                                                                                  845 846 850 1094 1095
operation                              based           char                     unaligned dcl 1187 set ref 160 160 200 200 257 257
                                                                                  261 261 265 265 265 269 269 273 273 309 309 476
                                                                                  476 541 541 544 544 547 547 550 550 560 560 596
                                                                                  596 623 623 641* 957 957
path                      4            based           char(168)                array level 3 dcl 5-20 set ref 1022*
perm_ops                               based           fixed bin(35,0)          array dcl 1188 set ref 738 746* 748 767 794 797* 799
                                                                                  818 1098
permit_requests                        based           structure                level 1 packed unaligned dcl 2-20
permit_requests_ptr             000104 automatic       pointer                  dcl 2-24 set ref 573* 579 580 581 582
permit_string                   000316 automatic       varying char(4)          dcl 1256 set ref 578* 579* 579 580* 580 581* 581
                                                                                  582* 582 583 583* 590*
permits                         000311 automatic       fixed bin(17,0)          dcl 1253 set ref 569* 573
pm_ptr                          000134 automatic       pointer                  dcl 1140 set ref 115* 738* 746 748 767 794* 797 799
                                                                                  818 1098 1098
prev_ops                               based           fixed bin(35,0)          array dcl 1189 set ref 739 747* 749 768 795 798* 800
                                                                                  819 1099
prevent_requests                       based           structure                level 1 packed unaligned dcl 2-22
prevent_requests_ptr            000106 automatic       pointer                  dcl 2-24 set ref 574* 585 586 587 588
prevent_string                  000320 automatic       varying char(4)          dcl 1256 set ref 584* 585* 585 586* 586 587* 587
                                                                                  588* 588 589 589* 590*
prevents                        000312 automatic       fixed bin(17,0)          dcl 1253 set ref 569* 574
ptr                                                    builtin function         dcl 1218 ref 1085
pv_ptr                          000136 automatic       pointer                  dcl 1140 set ref 115* 739* 747 749 768 795* 798 800
                                                                                  819 1099 1099
read_attr                 0(35)        based           bit(1)                   level 2 in structure "permit_requests" packed
                                                                                  unaligned dcl 2-20 in procedure "mrc" ref 579
read_attr                 0(35)        based           bit(1)                   level 2 in structure "prevent_requests" packed
                                                                                  unaligned dcl 2-22 in procedure "mrc" ref 585
ready_cnt                       000165 automatic       fixed bin(17,0)          dcl 1156 set ref 124* 1096
rel_ind                         000173 automatic       fixed bin(35,0)          dcl 1172 set ref 508* 525 537*
relation_name                          based           char                     unaligned dcl 1250 set ref 569* 607*
relation_name_len               000310 automatic       fixed bin(17,0)          dcl 1252 set ref 565* 569 569 602* 607 607
relation_name_ptr               000306 automatic       pointer                  dcl 1251 set ref 565* 569 602* 607
release_temp_segment_           000106 constant        entry                    external dcl 1291 ref 1124
rmode                                  based           fixed bin(35,0)          array dcl 1190 ref 1096
rmode_ptr                       000140 automatic       pointer                  dcl 1140 set ref 115* 1096 1096
scope_cnt                       000166 automatic       fixed bin(17,0)          dcl 1156 set ref 737* 738 739 767 768 793* 794 795
                                                                                  818 819 1098 1099
scope_version                   000313 automatic       fixed bin(17,0)          dcl 1254 set ref 569* 575
se_desc                         000567 automatic       structure                level 1 dcl 1049 set ref 1068
se_len                          000167 automatic       fixed bin(17,0)          dcl 1156 set ref 375* 379* 501* 678* 1053*
se_path                         000177 automatic       char(168)                dcl 1191 set ref 321* 349 357 370 373 374* 374 375
                                                                                  378* 500* 677* 1053 1053 1056*
se_ptr                          000142 automatic       pointer                  dcl 1140 set ref 115* 642 642* 1060* 1062 1067 1101
                                                                                  1102* 1103*
se_seg_sw                       000170 automatic       fixed bin(17,0)          dcl 1156 set ref 317* 349 355 357 365* 388 393 394
                                                                                  395 504* 506* 508 512 517 518 519 661* 681* 688
                                                                                  692 693 694
sea_ptr                         000144 automatic       pointer                  dcl 1140 set ref 366* 389 502* 513 679* 689
search                                                 builtin function         dcl 1218 ref 990 991 991 992 993 994
sed_ptr                         000146 automatic       pointer                  dcl 1140 set ref 366* 390 502* 514 679* 690
st_len                          000464 automatic       fixed bin(17,0)          dcl 970 set ref 975* 982 983 985 985 990 991 991 992
                                                                                  993 994
st_ptr                          000462 automatic       pointer                  dcl 969 set ref 975* 982 983 985 985 990 991 991 992
                                                                                  993 994
store_scope                     000314 automatic       char(1)                  unaligned dcl 1255 set ref 575* 577* 580 586
string                                 based           char                     unaligned dcl 972 ref 982 983 985 985 990 991 991
                                                                                  992 993 994
sub_error_                      000300 stack reference condition                dcl 1230 ref 142
substr                                                 builtin function         dcl 1218 ref 374 985 985
sys_info$max_seg_size           000026 external static fixed bin(35,0)          dcl 1213 ref 134
tag                       0(30)        based           bit(6)                   level 2 packed unaligned dcl 1079 ref 1084
temp_mode_list                         based           char(20)                 array unaligned dcl 1292 set ref 189 847 848 876*
tml_ptr                         000342 automatic       pointer                  initial dcl 1293 set ref 189 190* 847 847 848* 876
                                                                                  1293*
tuple_count                     000322 automatic       fixed bin(35,0)          dcl 1257 set ref 607* 613*
tuples_retrieved                000334 automatic       fixed bin(35,0)          dcl 1289 set ref 432* 445* 445 455*
val_ptr                         000150 automatic       pointer                  dcl 1140 set ref 115* 386* 406 424 449 470 1097 1097
values                                 based           char(256)                array unaligned dcl 1192 set ref 386 406 424* 449*
                                                                                  470 1097
verify                                                 builtin function         dcl 1218 ref 950 952 983
wa_ptr                          000012 internal static pointer                  initial dcl 1193 set ref 129* 134 189 195 196 197
                                                                                  219 220 228 243 244 246* 249 386 469 470 533 706
                                                                                  738 739 767 768 769 794 795 818 819 820 845 846
                                                                                  847 848 901 1006* 1032 1093 1094 1095 1096 1097
                                                                                  1098 1099 1123 1124*
wait_time                       000251 automatic       fixed bin(35,0)          dcl 1194 set ref 732* 733 733* 758 759 789* 810
work_area                              based           area                     dcl 1211 set ref 134* 189 195 196 197 219 220 228
                                                                                  243 244 249 386 469 470 533 706 738 739 767 768
                                                                                  769 794 795 818 819 820 845 846 847 848 901 1032
                                                                                  1093 1094 1095 1096 1097 1098 1099

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALL_OPS                                internal static fixed bin(17,0)          initial dcl 3-18
NO_OP                                  internal static fixed bin(17,0)          initial dcl 3-18
conflict_detail                        based           structure                level 1 packed unaligned dcl 2-36
conflict_detail_ptr                    automatic       pointer                  dcl 2-40
mrds_database_openings_num_open_init   automatic       fixed bin(17,0)          dcl 5-35
number_of_openings                     automatic       fixed bin(17,0)          dcl 4-15

NAMES DECLARED BY EXPLICIT CONTEXT.
Exit                            006235 constant        label                    dcl 642 ref 132 186 222 347 362 415 482 491 497 667
                                                                                  674 838 860 868 881 886 947 957 978 988 1057 1064
arg_err_hndlr                   011546 constant        entry                    internal dcl 1109 ref 126
build_arg_list                  010213 constant        entry                    internal dcl 893 ref 225 385 510 686 735 791 843
call_mod_fun                    006266 constant        entry                    internal dcl 647 ref 261 265 269
call_scope_fun                  006730 constant        entry                    internal dcl 715 ref 541 547
call_set_scope_all_fun          007307 constant        entry                    internal dcl 778 ref 544
cleanup_proc                    011431 constant        entry                    internal dcl 1089 ref 125 1112
conv_int                        010270 constant        entry                    internal dcl 934 ref 231 315 316 485 508 554 564 601
                                                                                  627 660 730 733 787 789
conv_ops                        010515 constant        entry                    internal dcl 965 ref 746 747 797 798
free_open_lists                 011576 constant        entry                    internal dcl 1116 ref 212 247
get_se                          011211 constant        entry                    internal dcl 1037 ref 366 502 679
mrc                             001524 constant        entry                    external dcl 43
mrds_call                       001534 constant        entry                    external dcl 43
open_old_ver                    007546 constant        entry                    internal dcl 828 ref 162
print_dbi                       010773 constant        entry                    internal dcl 1001 ref 192 257
retr_cleanup                    006253 constant        entry                    internal dcl 468 ref 413 466
true_ptr                        011405 constant        entry                    internal dcl 1073 ref 395 519 694 744 871

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     15012       15140   14260       15022
Length     15644   14260       126         467     532          10

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrc                                1162 external procedure  is an external procedure.  
on unit on line 125                  64 on unit               
on unit on line 126                  84 on unit               
on unit on line 142                  68 on unit               
on unit on line 218                  86 on unit               
retr_cleanup                            internal procedure  shares stack frame of external procedure mrc.  
call_mod_fun                            internal procedure  shares stack frame of external procedure mrc.  
call_scope_fun                          internal procedure  shares stack frame of external procedure mrc.  
call_set_scope_all_fun                  internal procedure  shares stack frame of external procedure mrc.  
open_old_ver                            internal procedure  shares stack frame of external procedure mrc.  
build_arg_list                          internal procedure  shares stack frame of external procedure mrc.  
conv_int                                internal procedure  shares stack frame of external procedure mrc.  
conv_ops                                internal procedure  shares stack frame of external procedure mrc.  
print_dbi                               internal procedure  shares stack frame of external procedure mrc.  
get_se                                  internal procedure  shares stack frame of external procedure mrc.  
true_ptr                                internal procedure  shares stack frame of external procedure mrc.  
cleanup_proc                         70 internal procedure  is called by several nonquick procedures.  
arg_err_hndlr                           internal procedure  shares stack frame of on unit on line 126.  
free_open_lists                         internal procedure  shares stack frame of external procedure mrc.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 num_open                    mrc
000012 wa_ptr                      mrc
000014 error_display_flag          mrc
000015 list_display_flag           mrc
000016 area_initialized            mrc
000017 no_output_mode              mrc

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mrc                      000100 al_ptr                      mrc
                         000102 num_ptrs                    mrc
                         000104 permit_requests_ptr         mrc
                         000106 prevent_requests_ptr        mrc
                         000110 database_list_ptr           mrc
                         000112 mrds_database_openings_ptr  mrc
                         000114 a_ptr                       mrc
                         000116 arg_ptr                     mrc
                         000120 f_ptr                       mrc
                         000122 filen_ptr                   mrc
                         000124 fn_ptr                      mrc
                         000126 num_ptr                     mrc
                         000130 mode_ptr                    mrc
                         000132 ms_ptr                      mrc
                         000134 pm_ptr                      mrc
                         000136 pv_ptr                      mrc
                         000140 rmode_ptr                   mrc
                         000142 se_ptr                      mrc
                         000144 sea_ptr                     mrc
                         000146 sed_ptr                     mrc
                         000150 val_ptr                     mrc
                         000152 arg_len                     mrc
                         000153 desc_off_i                  mrc
                         000154 desc_off_o                  mrc
                         000155 f_len                       mrc
                         000156 fn_len                      mrc
                         000157 i                           mrc
                         000160 j                           mrc
                         000161 ms_len                      mrc
                         000162 n_vals                      mrc
                         000163 nargs                       mrc
                         000164 open_cnt                    mrc
                         000165 ready_cnt                   mrc
                         000166 scope_cnt                   mrc
                         000167 se_len                      mrc
                         000170 se_seg_sw                   mrc
                         000171 code                        mrc
                         000172 dbi                         mrc
                         000173 rel_ind                     mrc
                         000174 all_sw                      mrc
                         000175 current_arg                 mrc
                         000176 done_scanning               mrc
                         000177 se_path                     mrc
                         000251 wait_time                   mrc
                         000252 char_desc                   mrc
                         000253 fb_17_desc                  mrc
                         000254 fb_35_desc                  mrc
                         000306 relation_name_ptr           mrc
                         000310 relation_name_len           mrc
                         000311 permits                     mrc
                         000312 prevents                    mrc
                         000313 scope_version               mrc
                         000314 store_scope                 mrc
                         000316 permit_string               mrc
                         000320 prevent_string              mrc
                         000322 tuple_count                 mrc
                         000323 arg_cnt                     mrc
                         000324 handler_found_code          mrc
                         000325 mrc_mode_len                mrc
                         000326 mrc_mode_ptr                mrc
                         000330 NL                          mrc
                         000331 ON                          mrc
                         000332 OFF                         mrc
                         000333 discard_code                mrc
                         000334 tuples_retrieved            mrc
                         000335 NA                          mrc
                         000342 tml_ptr                     mrc
                         000416 odd                         open_old_ver
                         000417 al_index                    open_old_ver
                         000430 old_num_ptrs                build_arg_list
                         000440 i                           conv_int
                         000442 nc_ptr                      conv_int
                         000444 nc_len                      conv_int
                         000462 st_ptr                      conv_ops
                         000464 st_len                      conv_ops
                         000465 op_num                      conv_ops
                         000504 dname                       get_se
                         000556 ename                       get_se
                         000566 bcount                      get_se
                         000567 se_desc                     get_se

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             call_ext_out_desc   call_ext_out        call_int_other      return
tra_ext             mod_fx1             signal              enable              ext_entry           int_entry
any_to_any_tr       alloc_based         free_based          empty

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      continue_to_signal_           cu_$arg_list_ptr              cu_$arg_ptr
cu_$arg_ptr_rel               cu_$generate_call             expand_path_                  get_temp_segment_
hcs_$initiate_count           hcs_$terminate_noname         ioa_                          mrds_dsl_close$close
mrds_dsl_close_all            mrds_dsl_db_openings$list_dbs mrds_dsl_db_openings$list_openings
mrds_dsl_declare              mrds_dsl_define_temp_rel$define_temp_rel                    mrds_dsl_delete$delete
mrds_dsl_get_population       mrds_dsl_get_scope            mrds_dsl_modify$modify        mrds_dsl_open$open
mrds_dsl_retrieve$retrieve    mrds_dsl_set_scope$dl_scope   mrds_dsl_set_scope$dl_scope_all
mrds_dsl_set_scope$set_scope  mrds_dsl_set_scope$set_scope_all                            mrds_dsl_store$store
release_temp_segment_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$noarg            error_table_$wrong_no_of_args mrds_data_$max_dbs
mrds_error_$tuple_not_found   sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
   1207 001501      1208 001503      1209 001505      1277 001507      1279 001511      1280 001513      1290 001514
   1293 001517        43 001523       115 001542       123 001554       124 001555       125 001556       126 001600
    127 001616       129 001622       130 001646       131 001650       132 001677       134 001700       135 001704
    138 001707       139 001715       140 001720       142 001722       144 001736       145 001741       146 001750
    148 001751       150 001770       151 001772       152 002016       158 002100       160 002101       162 002113
    177 002114       178 002116       179 002122       180 002125       182 002132       184 002147       185 002151
    186 002200       189 002201       190 002206       192 002210       195 002214       196 002221       197 002223
    198 002225       200 002226       201 002236       205 002266       207 002305       210 002337       211 002351
    212 002360       213 002361       215 002412       218 002413       219 002427       220 002441       221 002450
    222 002500       225 002503       227 002505       228 002510       230 002516       231 002525       232 002546
    233 002555       234 002562       237 002564       238 002566       239 002572       241 002577       243 002614
    244 002621       246 002623       247 002634       249 002642       251 002647       255 002675       257 002676
    261 002710       265 002732       269 002760       273 003002       274 003012       278 003042       280 003051
    281 003066       285 003120       287 003132       289 003142       291 003152       296 003162       298 003176
    303 003211       305 003247       307 003251       309 003252       311 003262       315 003312       316 003321
    317 003326       318 003327       319 003330       320 003331       321 003333       341 003336       342 003340
    344 003355       345 003357       347 003403       349 003404       353 003431       354 003433       355 003435
    356 003441       357 003442       360 003462       362 003515       365 003516       366 003520       367 003522
    368 003524       369 003526       370 003527       373 003536       374 003541       375 003545       376 003547
    378 003550       379 003554       382 003555       383 003557       385 003560       386 003566       388 003575
    389 003577       390 003602       393 003606       394 003617       395 003627       397 003652       399 003654
    400 003656       401 003661       402 003666       405 003700       406 003713       407 003723       408 003730
    410 003732       412 003747       413 003751       414 003752       415 003776       420 003777       421 004002
    423 004030       424 004037       425 004063       426 004065       432 004066       433 004070       436 004072
    437 004074       438 004077       440 004103       442 004106       444 004123       445 004125       446 004131
    447 004134       448 004151       449 004161       450 004205       453 004207       454 004210       455 004213
    457 004235       458 004251       459 004252       460 004275       465 004276       466 004311       474 004312
    476 004313       477 004323       478 004326       482 004373       485 004374       487 004401       489 004421
    490 004423       491 004461       493 004462       494 004474       495 004511       496 004513       497 004542
    500 004543       501 004550       502 004552       503 004554       504 004556       505 004560       506 004561
    508 004562       510 004570       512 004572       513 004574       514 004577       517 004603       518 004615
    519 004625       521 004650       523 004652       524 004654       525 004657       526 004663       527 004665
    531 004677       533 004714       535 004721       537 004750       539 004770       541 004771       544 005013
    547 005033       550 005055       551 005065       554 005115       555 005122       556 005133       559 005164
    560 005165       561 005175       564 005225       565 005232       566 005253       569 005302       570 005337
    573 005371       574 005373       575 005375       577 005403       578 005405       579 005406       580 005421
    581 005434       582 005447       583 005462       584 005473       585 005474       586 005507       587 005522
    588 005535       589 005550       590 005561       594 005604       596 005605       597 005615       601 005645
    602 005652       603 005673       607 005722       609 005750       613 005777       621 006017       623 006020
    624 006030       627 006054       629 006061       631 006102       634 006134       635 006157       639 006210
    641 006211       642 006235       645 006252       468 006253       469 006254       470 006261       471 006265
    647 006266       651 006270       652 006273       655 006323       657 006362       660 006363       661 006370
    663 006371       664 006375       665 006415       666 006417       667 006455       670 006456       671 006470
    672 006505       673 006507       674 006533       677 006534       678 006541       679 006543       680 006545
    681 006547       686 006551       688 006553       689 006555       690 006560       692 006564       693 006575
    694 006605       696 006630       698 006632       699 006634       700 006637       701 006643       704 006655
    706 006667       708 006674       713 006727       715 006730       721 006732       730 007010       732 007015
    733 007022       735 007026       737 007030       738 007034       739 007042       741 007050       743 007061
    744 007065       746 007107       747 007127       748 007144       749 007153       750 007156       753 007165
    755 007170       756 007172       757 007175       758 007201       759 007204       760 007210       762 007216
    765 007230       767 007242       768 007244       769 007246       771 007253       776 007306       778 007307
    782 007311       787 007343       789 007350       791 007356       793 007360       794 007362       795 007370
    797 007376       798 007410       799 007422       800 007425       801 007427       804 007435       805 007436
    806 007441       808 007446       810 007452       811 007456       813 007463       816 007474       818 007506
    819 007510       820 007512       822 007517       826 007545       828 007546       833 007547       835 007553
    836 007560       838 007604       841 007605       843 007613       845 007620       846 007626       847 007634
    848 007645       850 007654       851 007663       853 007666       854 007676       855 007702       857 007705
    858 007726       859 007730       860 007754       863 007755       864 007773       865 007775       866 010000
    868 010033       870 010034       871 010040       873 010064       876 010072       878 010110       879 010130
    880 010132       881 010161       884 010162       885 010163       886 010207       889 010210       891 010212
    893 010213       898 010215       900 010217       901 010222       903 010232       905 010243       907 010245
    908 010247       927 010263       932 010267       934 010270       943 010301       945 010321       946 010323
    947 010360       950 010361       952 010405       954 010421       955 010422       957 010462       961 010477
    965 010515       975 010517       976 010536       977 010540       978 010567       980 010570       982 010571
    983 010577       984 010611       985 010612       988 010646       990 010647       991 010665       992 010715
    993 010733       994 010751       997 010767      1001 010773      1006 010774      1008 011011      1012 011040
   1016 011063      1019 011106      1022 011117      1025 011161      1026 011163      1032 011176      1035 011210
   1037 011211      1049 011213      1053 011215      1055 011242      1056 011244      1057 011265      1060 011266
   1062 011330      1063 011334      1064 011373      1067 011374      1068 011377      1069 011401      1071 011404
   1073 011405      1084 011407      1085 011421      1089 011430      1093 011436      1094 011450      1095 011457
   1096 011466      1097 011475      1098 011506      1099 011515      1101 011524      1102 011531      1103 011542
   1107 011545      1109 011546      1111 011547      1112 011570      1114 011575      1116 011576      1123 011577
   1124 011604      1125 011624      1128 011627


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
