	COMPILATION LISTING OF SEGMENT im_update_key_counts
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phx. Az., Sys-M 
	Compiled on: 04/02/87  1308.9 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* DESCRIPTION:
        8*
        9*         This subroutine takes a key_count_array and increments or decrements
       10*     it  by  one  in each partial duplicate count for which the "current" is a
       11*     partial duplicate of the previous or following keys.
       12**/
       13 
       14 /* HISTORY:
       15*
       16*Written by Lindsey L. Spratt, 10/28/82.
       17*Modified:
       18*11/15/82 by Matthew Pierret:  Changed to not try to free the leaf_ci_header
       19*            pointed to by temp_leaf_ci_header_ptr if equal to
       20*	  leaf_ci_header_ptr.
       21*12/09/82 by Lindsey Spratt:  Changed to use the dm_key_count_array incl file.
       22*	  Changed to check error codes after calls.
       23*02/10/83 by Lindsey Spratt:  Changed to use automatic buffers for local,
       24*	  temporary  copies of leaf_ci_headers.  There is no longer any
       25*	  explicit freeing or allocation of leaf_ci_headers.  Also, fixed to
       26*	  not set the 0-th key_count when doing the "previous key" key_count
       27*	  adjustment and there was no previous key.  This was done by
       28*	  initializing the previous_first_inequal_field_id to 1 instead of 0.
       29*02/28/83 by Lindsey Spratt:  Changed to use version 3 of the index_cursor.
       30*04/03/83 by Lindsey L. Spratt:  Changed to call
       31*            data_mgmt_util_$compare_string_to_string instead of
       32*            im_compare_key_and_key.
       33*11/08/83 by Lindsey L. Spratt:  Changed to use the "buffered" access method.
       34*            Also, converted to use the "call ERROR RETURN(code)" protocol.
       35*06/07/84 by Matthew Pierret:  Re-named cm_$setup_buffered_ci to
       36*            cm_$setup_ci_buffer, cm_$simple_get_buffered_element to
       37*            cm_$simple_get_from_ci_buffer, cm_$get_element_buffered to
       38*            cm_$get_from_ci_buffer.
       39*            Changed to use data_format_util_ instead of data_mgmt_util_.
       40*10/13/84 by Lindsey L. Spratt:  Added the current_key_string_length to the
       41*            calling sequence.  This is necessary for using a caller supplied
       42*            key.
       43*10/29/84 by Lindsey L. Spratt:
       44*
       45*
       46*
       47*            Changed to use version 2 key_count_array.
       48**/
       49 /* format: style2,ind3 */
       50 
       51 /* format: style2,ind3 */
       52 
       53 im_update_key_counts:
       54    proc (p_node_buffer_ptr, p_index_cursor_ptr, p_work_area_ptr, p_field_table_ptr, p_is_being_inserted,
       55         p_leaf_ci_header_ptr, p_current_key_id, p_current_key_ptr, p_current_key_string_length, p_key_count_array_ptr,
       56         p_code);
       57 
       58 
       59 /* START OF DECLARATIONS */
       60 /* Parameter */
       61 
       62       dcl	    p_node_buffer_ptr      ptr parameter;
       63       dcl	    p_index_cursor_ptr     ptr parameter;
       64       dcl	    p_work_area_ptr	       ptr parameter;
       65       dcl	    p_field_table_ptr      ptr parameter;
       66       dcl	    p_is_being_inserted    bit (1) aligned parameter;
       67       dcl	    p_leaf_ci_header_ptr   ptr parameter;
       68       dcl	    p_current_key_id       bit (36) aligned parameter;
       69       dcl	    p_current_key_ptr      ptr parameter;
       70       dcl	    p_current_key_string_length
       71 			       fixed bin (35) parameter;
       72       dcl	    p_key_count_array_ptr  ptr parameter;
       73       dcl	    p_code	       fixed bin (35) parameter;
       74 
       75 /* Automatic */
       76 
       77       dcl	    count_idx	       fixed bin;
       78       dcl	    current_key_ptr	       ptr init (null);
       79       dcl	    current_key_string_length
       80 			       fixed bin (35) init (0);
       81       dcl	    current_node_buffer_ptr
       82 			       ptr init (null);
       83 
       84       dcl	    (local_main_ci_header_buffer, local_temp_ci_header_buffer)
       85 			       bit (LEAF_CI_HEADER_LENGTH_IN_BITS) aligned;
       86       dcl	    local_node_buffer      bit (CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES * BITS_PER_BYTE) aligned;
       87 
       88       dcl	    temp_key_ptr	       init (null) ptr;
       89       dcl	    temp_key_string_length fixed bin (35) init (0);
       90       dcl	    temp_leaf_ci_header_ptr
       91 			       ptr init (null);
       92       dcl	    (previous_first_inequal_field_id, next_first_inequal_field_id)
       93 			       fixed bin (17) init (1);
       94       dcl	    work_area_ptr	       ptr init (null);
       95 
       96 /* Based */
       97 
       98       dcl	    temp_key	       bit (temp_key_string_length) based (temp_key_ptr);
       99       dcl	    current_key	       bit (current_key_string_length) based (current_key_ptr);
      100       dcl	    work_area	       area based (work_area_ptr);
      101 
      102 /* Builtin */
      103 
      104       dcl	    (null, bin)	       builtin;
      105 
      106 /* Condition */
      107 
      108       dcl	    cleanup	       condition;
      109 
      110 /* Constant */
      111 
      112       dcl	    ALL_FIELDS	       init (-1) fixed bin (17) internal static options (constant);
      113       dcl	    BITS_PER_BYTE	       init (9) fixed bin (17) internal static options (constant);
      114 
      115       dcl	    myname	       init ("im_update_key_counts") char (32) varying internal static options (constant);
      116 
      117 /* Entry */
      118 
      119       dcl	    data_format_util_$compare_string_to_string
      120 			       entry (ptr, ptr, fixed bin (24), ptr, fixed bin (24), fixed bin unal, fixed bin,
      121 			       bit (1) aligned, bit (1) aligned, fixed bin (35));
      122 
      123 
      124       dcl	    sub_err_	       entry () options (variable);
      125 
      126 /* External */
      127 
      128       dcl	    (
      129 	    dm_error_$wrong_cursor_type,
      130 	    dm_error_$bad_first_key_idx,
      131 	    dm_error_$bad_last_key_idx,
      132 	    dm_error_$bad_leaf_node
      133 	    )		       fixed bin (35) ext;
      134       dcl	    error_table_$unimplemented_version
      135 			       fixed bin (35) ext;
      136 
      137 /* END OF DECLARATIONS */
      138 
      139       p_code = 0;
      140       work_area_ptr = p_work_area_ptr;
      141       index_cursor_ptr = p_index_cursor_ptr;
      142       if index_cursor.type ^= INDEX_CURSOR_TYPE
      143       then call sub_err_ (dm_error_$wrong_cursor_type, myname, ACTION_CANT_RESTART, null, 0,
      144 	      "^/Expected a an index type cursor, type ^d,. Received a cursor of type ^d.", INDEX_CURSOR_TYPE,
      145 	      index_cursor.type);
      146 
      147       call CHECK_VERSION ((index_cursor.version), (INDEX_CURSOR_VERSION_3), "index_cursor");
      148 
      149       current_node_buffer_ptr = p_node_buffer_ptr;
      150       element_id_string = p_current_key_id;
      151       leaf_ci_header_ptr = p_leaf_ci_header_ptr;
      152 
      153       on cleanup call FINISH;
      154 
      155 
      156       if leaf_ci_header_ptr = null
      157       then
      158          do;
      159 	  leaf_ci_header_ptr = addr (local_main_ci_header_buffer);
      160 	  call GET_CI_HEADER (current_node_buffer_ptr, (element_id.control_interval_id), leaf_ci_header_ptr);
      161          end;
      162 
      163       current_key_ptr = p_current_key_ptr;
      164       current_key_string_length = p_current_key_string_length;
      165       if current_key_ptr = null
      166       then call GET_KEY (current_node_buffer_ptr, element_id_string, current_key_ptr, current_key_string_length);
      167 
      168 
      169       key_count_array_ptr = p_key_count_array_ptr;
      170       call CHECK_VERSION_CHAR (key_count_array.version, KEY_COUNT_ARRAY_VERSION_2, "key_count_array");
      171 
      172 /* check previous key. */
      173 
      174       element_id.index = element_id.index - 1;
      175       if element_id.index < leaf_ci_header.common.key_range.first
      176       then
      177          do;
      178 	  element_id.control_interval_id = leaf_ci_header.common.previous_id;
      179 	  if element_id.control_interval_id ^= 0
      180 	  then
      181 	     do;
      182 
      183 	        current_node_buffer_ptr = addr (local_node_buffer);
      184 	        call SETUP_NODE_BUFFER ((element_id.control_interval_id), current_node_buffer_ptr);
      185 
      186 	        temp_leaf_ci_header_ptr = addr (local_temp_ci_header_buffer);
      187 	        call GET_CI_HEADER (current_node_buffer_ptr, element_id.control_interval_id, temp_leaf_ci_header_ptr);
      188 	        element_id.index = temp_leaf_ci_header_ptr -> leaf_ci_header.common.key_range.last;
      189 	     end;
      190          end;
      191       else temp_leaf_ci_header_ptr = leaf_ci_header_ptr;
      192 
      193       if temp_leaf_ci_header_ptr ^= null
      194       then
      195          do;
      196 	  call GET_KEY (current_node_buffer_ptr, element_id_string, temp_key_ptr, temp_key_string_length);
      197 	  call data_format_util_$compare_string_to_string (p_field_table_ptr, current_key_ptr,
      198 	       (current_key_string_length), temp_key_ptr, (temp_key_string_length), (ALL_FIELDS),
      199 	       previous_first_inequal_field_id, "0"b, "0"b, p_code);
      200 	  if p_code ^= 0
      201 	  then call ERROR_RETURN (p_code);
      202 
      203 	  do count_idx = 1 to previous_first_inequal_field_id - 1;
      204 	     key_count_array.count (count_idx) =
      205 		key_count_array.count (count_idx) + 1 + -2 * bin (^p_is_being_inserted);
      206 	  end;
      207          end;
      208 
      209       if temp_key_ptr ^= null
      210       then
      211          do;
      212 
      213 	  free temp_key_ptr -> temp_key in (work_area);
      214 	  temp_key_ptr = null;
      215          end;
      216 
      217       element_id_string = p_current_key_id;		/* Reset to the current key. */
      218 
      219 /* Check for duplications with next key. */
      220 
      221       current_node_buffer_ptr = p_node_buffer_ptr;
      222 
      223       element_id.index = element_id.index + 1;
      224       if element_id.index > leaf_ci_header.common.key_range.last
      225       then
      226          do;
      227 	  element_id.control_interval_id = leaf_ci_header.common.next_id;
      228 	  if element_id.control_interval_id ^= 0
      229 	  then
      230 	     do;
      231 
      232 	        current_node_buffer_ptr = addr (local_node_buffer);
      233 	        call SETUP_NODE_BUFFER ((element_id.control_interval_id), current_node_buffer_ptr);
      234 	        temp_leaf_ci_header_ptr = addr (local_temp_ci_header_buffer);
      235 	        call GET_CI_HEADER (current_node_buffer_ptr, element_id.control_interval_id, temp_leaf_ci_header_ptr);
      236 						/* If a ci_header was gotten for the previous key, this would overwrite it. */
      237 	        element_id.index = temp_leaf_ci_header_ptr -> leaf_ci_header.common.key_range.first;
      238 	     end;
      239          end;
      240       else temp_leaf_ci_header_ptr = leaf_ci_header_ptr;
      241 
      242       if element_id.control_interval_id ^= 0
      243       then
      244          do;
      245 	  call GET_KEY (current_node_buffer_ptr, element_id_string, temp_key_ptr, temp_key_string_length);
      246 
      247 	  call data_format_util_$compare_string_to_string (p_field_table_ptr, current_key_ptr,
      248 	       (current_key_string_length), temp_key_ptr, (temp_key_string_length), (ALL_FIELDS),
      249 	       next_first_inequal_field_id, "0"b, "0"b, p_code);
      250 	  if p_code ^= 0
      251 	  then call ERROR_RETURN (p_code);
      252 
      253 	  do count_idx = max (1, previous_first_inequal_field_id) to next_first_inequal_field_id - 1;
      254 	     key_count_array.count (count_idx) =
      255 		key_count_array.count (count_idx) + 1 + -2 * bin (^p_is_being_inserted);
      256 	  end;
      257          end;
      258 
      259       if temp_key_ptr ^= null
      260       then free temp_key_ptr -> temp_key in (work_area);
      261       temp_key_ptr = null;
      262 
      263       key_count_array.count (0) = key_count_array.count (0) + 1 + -2 * bin (^p_is_being_inserted);
      264 MAIN_RETURN:
      265       call FINISH;
      266       return;
      267 
      268 FINISH:
      269    proc;
      270       if current_key_ptr ^= null & p_current_key_ptr ^= current_key_ptr
      271       then free current_key in (work_area);
      272       if temp_key_ptr ^= null
      273       then free temp_key in (work_area);
      274    end FINISH;
      275 
      276 
      277 ERROR_RETURN:
      278    proc (er_p_code);
      279       dcl	    er_p_code	       fixed bin (35);
      280       call FINISH;
      281       p_code = er_p_code;
      282       goto MAIN_RETURN;
      283    end ERROR_RETURN;
      284 
      285 
      286 CHECK_VERSION:
      287    proc (p_received_version, p_expected_version, p_structure_name);
      288       dcl	    p_received_version     fixed bin (35);
      289       dcl	    p_expected_version     fixed bin (35);
      290       dcl	    p_structure_name       char (*);
      291 
      292       if p_received_version ^= p_expected_version
      293       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      294 	      "^/Expected version ^d of the ^a structure.
      295 Received version ^d instead.", p_expected_version, p_structure_name, p_received_version);
      296 
      297    end CHECK_VERSION;
      298 
      299 CHECK_VERSION_CHAR:
      300    proc (p_received_version, p_expected_version, p_structure_name);
      301       dcl	    p_received_version     char (8) aligned parameter;
      302       dcl	    p_expected_version     char (8) aligned parameter;
      303       dcl	    p_structure_name       char (*);
      304 
      305       if p_received_version ^= p_expected_version
      306       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      307 	      "^/Expected version ^a of the ^a structure.
      308 Received version ^a instead.", p_expected_version, p_structure_name, p_received_version);
      309 
      310    end CHECK_VERSION_CHAR;
      311 
      312 GET_CI_HEADER:
      313    proc (gch_p_node_buffer_ptr, gch_p_control_interval_id, gch_p_leaf_ci_header_ptr);
      314       dcl	    gch_p_node_buffer_ptr  ptr;
      315       dcl	    gch_p_control_interval_id
      316 			       fixed bin (24) unsigned unal;
      317       dcl	    gch_p_leaf_ci_header_ptr
      318 			       ptr;
      319       dcl	    gch_code	       fixed bin (35) init (0);
      320 
      321 
      322       element_id.control_interval_id = gch_p_control_interval_id;
      323       element_id.index = DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT;
      324 
      325       call collection_manager_$simple_get_from_ci_buffer (gch_p_node_buffer_ptr, index_cursor.collection_id,
      326 	 element_id_string, gch_p_leaf_ci_header_ptr, length (unspec (gch_p_leaf_ci_header_ptr -> leaf_ci_header)), (0),
      327 	 gch_code);
      328       if gch_code ^= 0
      329       then call ERROR_RETURN (gch_code);
      330 
      331       if ^gch_p_leaf_ci_header_ptr -> common_ci_header.is_leaf
      332       then call ERROR_RETURN (dm_error_$bad_leaf_node);
      333       else if gch_p_leaf_ci_header_ptr -> leaf_ci_header.common.key_range.first < 0
      334       then call ERROR_RETURN (dm_error_$bad_first_key_idx);
      335       else if gch_p_leaf_ci_header_ptr -> leaf_ci_header.common.key_range.last
      336 	      < gch_p_leaf_ci_header_ptr -> leaf_ci_header.common.key_range.first
      337       then call ERROR_RETURN (dm_error_$bad_last_key_idx);
      338 
      339       return;
  1     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*
  1     5*        Contains the declaration of an element identifier.  Element
  1     6*   identifiers consist of two parts, the id (number) of the control interval
  1     7*   in which the element resides, and the index into the slot table of
  1     8*   the element in the control interval.  The declaration of the element_id 
  1     9*   structure reflects this division of the element identifier.  The structure 
  1    10*   is based on the automatic bit string element_id_string because programs
  1    11*   generally pass bit strings (element_id_string) to each other, then 
  1    12*   interpret the bit string by overlaying the element_id structure ony if
  1    13*   it is necessary to access the parts of the id.  Basing element_id on
  1    14*   addr(element_id_string) instead of on a pointer removes the necessity
  1    15*   for always setting that pointer explicitly and guarantees that changes
  1    16*   made to the string or structure do not get inconsistent.
  1    17*
  1    18*   Changes made to element_id must also be made to datum_id, declared in 
  1    19*   dm_cm_datum.incl.pl1.
  1    20**/
  1    21 
  1    22 /* HISTORY:
  1    23*Written by Matthew Pierret, 04/01/82.
  1    24*Modified:
  1    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  1    26**/
  1    27 
  1    28 /* format: style2,ind3,ll79 */
  1    29 
  1    30      dcl	   element_id_string      bit (36) aligned;
  1    31 
  1    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  1    33 	     2 control_interval_id
  1    34 			      fixed bin (24) unal unsigned,
  1    35 	     2 index	      fixed bin (12) unal unsigned;
  1    36 
  1    37 
  1    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      340 
      341    end GET_CI_HEADER;
      342 
      343 GET_KEY:
      344    proc (gk_p_node_buffer_ptr, gk_p_key_id_string, gk_p_leaf_key_ptr, gk_p_leaf_key_string_length);
      345       dcl	    gk_p_node_buffer_ptr   ptr;
      346       dcl	    gk_p_key_id_string     bit (36) aligned;
      347       dcl	    gk_p_leaf_key_ptr      ptr;
      348       dcl	    gk_p_leaf_key_string_length
      349 			       fixed bin (35);
      350       dcl	    gk_code	       fixed bin (35);
      351 
      352 
      353       call collection_manager_$get_from_ci_buffer (gk_p_node_buffer_ptr, index_cursor.file_opening_id,
      354 	 index_cursor.collection_id, gk_p_key_id_string, gk_p_leaf_key_ptr, gk_p_leaf_key_string_length, work_area_ptr,
      355 	 "0"b, gk_p_leaf_key_ptr, gk_p_leaf_key_string_length, gk_code);
      356       if gk_code ^= 0
      357       then call ERROR_RETURN (gk_code);
      358 
      359    end GET_KEY;
      360 
      361 SETUP_NODE_BUFFER:
      362    proc (snb_p_control_interval_id, snb_p_buffer_ptr);
      363       dcl	    snb_p_control_interval_id
      364 			       fixed bin (24) unsigned;
      365       dcl	    snb_p_buffer_ptr       ptr;
      366 
      367       dcl	    snb_code	       fixed bin (35) init (0);
      368 
      369       call collection_manager_$setup_ci_buffer (index_cursor.file_opening_id, index_cursor.collection_id,
      370 	 snb_p_control_interval_id, snb_p_buffer_ptr, CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES * BITS_PER_BYTE,
      371 	 snb_code);
      372       if snb_code ^= 0
      373       then call ERROR_RETURN (snb_code);
      374 
      375    end SETUP_NODE_BUFFER;
      376 
  2     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  2     2 /* format: style3 */
  2     3 
  2     4 /* These constants are to be used for the flags argument of sub_err_ */
  2     5 /* They are just "string (condition_info_header.action_flags)" */
  2     6 
  2     7 declare	(
  2     8 	ACTION_CAN_RESTART	init (""b),
  2     9 	ACTION_CANT_RESTART init ("1"b),
  2    10 	ACTION_DEFAULT_RESTART
  2    11 			init ("01"b),
  2    12 	ACTION_QUIET_RESTART
  2    13 			init ("001"b),
  2    14 	ACTION_SUPPORT_SIGNAL
  2    15 			init ("0001"b)
  2    16 	)		bit (36) aligned internal static options (constant);
  2    17 
  2    18 /* End include file */
      377 
      378 
  3     1 /* BEGIN INCLUDE FILE - dm_im_cursor.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*
  3     5*          This structure specifies a DM file, an index collection in that DM
  3     6*file, and a position (key) in that index collection.
  3     7*
  3     8**/
  3     9 
  3    10 /* HISTORY:
  3    11*
  3    12*Written by Lindsey Spratt, 03/29/82
  3    13*Modified:
  3    14*08/09/82 by Matthew Pierret: Changed collection_id from "fixed bin (17)" to
  3    15*            "bit (35) aligned".
  3    16*08/26/82 by Lindsey Spratt:  Changed to version 2.  Added the is_valid and
  3    17*	  is_at_end_of_index flags.  Changed the key_check_value to fixed
  3    18*	  bin (35).  Added the IM_HASH_BIAS, which is used to increment the
  3    19*	  value developed by hash_index_, and IM_HASH_NUMBER_OF_BUCKETS,
  3    20*	  which is a unique number used by hash_index_ to develop the
  3    21*	  key_check_value.
  3    22*02/23/83 by Lindsey Spratt: Changed to keep the current key value in the
  3    23*	  cursor.  Also, implemented the ability to have the cursor
  3    24*	  positioned before or after the index.  
  3    25*10/23/84 by Lindsey L. Spratt:  Added a description section.
  3    26**/
  3    27 
  3    28 /* format: style2,ind3 */
  3    29      dcl	   1 index_cursor	      based (index_cursor_ptr),
  3    30 	     2 type	      fixed bin (17) unaligned,
  3    31 	     2 version	      fixed bin (17) unaligned,
  3    32 	     2 file_opening_id    bit (36) aligned,
  3    33 	     2 collection_id      bit (36) aligned,
  3    34 	     2 key_id_string      bit (36) aligned,	/* Is the location of the current key, */
  3    35 						/* if flags.current_key_exists is on. Is the location */
  3    36 						/* of the end of the index if flags.is_at_end_of_index */
  3    37 						/* is on, which is only available via an operation */
  3    38 						/* requiring the "previous" key.  Is the location of */
  3    39 						/* the "next" key, otherwise. */
  3    40 	     2 area_ptr	      ptr,		/* Area in which the cursor and key_string area allocated. */
  3    41 						/* Must be a freeing area. */
  3    42 	     2 current_key_string_ptr
  3    43 			      ptr,		/* Points to the value of the current key. */
  3    44 	     2 current_key_string_length
  3    45 			      fixed bin (24) unal,	/* Is the length of the current key in bits. */
  3    46 	     2 pad	      bit (12) unal,
  3    47 	     2 flags	      aligned,
  3    48 	       3 is_at_beginning_of_index
  3    49 			      bit (1) unaligned,	/* Only the "next" key is defined. */
  3    50 	       3 is_at_end_of_index
  3    51 			      bit (1) unaligned,	/* Only the "previous" key is defined. */
  3    52 	       3 current_key_exists
  3    53 			      bit (1) unaligned,	/* If on, indicates that the "current" key is identified */
  3    54 						/* by the key_id_string.  If off, the "current" position */
  3    55 						/* is undefined, and the key_id_string identifies the */
  3    56 						/* previous or next key, depending on whether */
  3    57 						/* flags.is_at_end_of_index is off or on, respectively. */
  3    58 	       3 is_valid	      bit (1) unaligned,	/* If off, the index_manager_ was interrupted while */
  3    59 						/* setting the cursor position and the cursor is not */
  3    60 						/* to be trusted for relative position operations. */
  3    61 	       3 pad	      bit (32) unal;
  3    62 
  3    63 
  3    64      dcl	   index_cursor_ptr	      ptr;
  3    65 
  3    66      dcl	   INDEX_CURSOR_VERSION_3 fixed bin (17) init (3) internal static options (constant);
  3    67      dcl	   INDEX_CURSOR_TYPE      init (2) fixed bin (17) internal static options (constant);
  3    68 
  3    69 /* END INCLUDE FILE - dm_im_cursor.incl.pl1 */
      379 
      380 
  4     1 /* BEGIN INCLUDE FILE - dm_im_ci_header.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*
  4     5*          Each node (control interval) in the index has a header which
  4     6*     describes the contents of that node.  Although there are two different
  4     7*     kinds of headers, leaf and branch, they have a great deal in common, the
  4     8*     common_ci_header.  The common_ci_header states which slots are used by
  4     9*     the keys (leaf or branch) in the key_range substructure.  There is an
  4    10*     "upward pointer" to the node's parent branch key (parent_id_string).
  4    11*     There are pointers to the previous and next nodes (previous_id and
  4    12*     next_id) on the same level to facilitate rotation of keys, and sequential
  4    13*     searching.  There is also a count of how much space is in use by the keys.
  4    14*
  4    15**/
  4    16 
  4    17 /* HISTORY:
  4    18*
  4    19*Written by Lindsey Spratt, 03/29/82.
  4    20*Modified:
  4    21*10/25/84 by Lindsey L. Spratt:  Added a description and fixed the history
  4    22*            section format.
  4    23**/
  4    24 
  4    25 /* format: style2,ind3 */
  4    26      dcl	   1 common_ci_header     based (common_ci_header_ptr),
  4    27 	     2 flags	      unaligned,
  4    28 	       3 is_leaf	      bit (1) unaligned,	/* ON for leaf_ci, OFF for branch_ci. */
  4    29 	       3 pad	      bit (17) unaligned,	/* Must be zero. */
  4    30 	     2 key_tail_space_used_since_last_prefix_compaction
  4    31 			      fixed bin (18) unsigned unal,
  4    32 	     2 key_range	      unaligned,
  4    33 	       3 first	      fixed bin (18) unsigned,
  4    34 	       3 last	      fixed bin (18) unsigned,
  4    35 	     2 parent_id_string   bit (36) aligned,
  4    36 	     2 previous_id	      fixed bin (24) unsigned unaligned,
  4    37 	     2 next_id	      fixed bin (24) unsigned unaligned,
  4    38 	     2 pad	      bit (24) unaligned;
  4    39 
  4    40 
  4    41      dcl	   common_ci_header_ptr   ptr;
  4    42 
  4    43      dcl	   1 leaf_ci_header	      based (leaf_ci_header_ptr),
  4    44 	     2 common	      like common_ci_header;
  4    45 
  4    46      dcl	   leaf_ci_header_ptr     ptr;
  4    47 
  4    48      dcl	   1 branch_ci_header     based (branch_ci_header_ptr),
  4    49 	     2 common	      like common_ci_header,
  4    50 	     2 low_branch_id      fixed bin (24) unsigned unaligned,
  4    51 	     2 pad	      bit (12) unaligned;
  4    52 
  4    53      dcl	   branch_ci_header_ptr   ptr;
  4    54 
  4    55 
  4    56      dcl	   (
  4    57 	   DEFAULT_INITIAL_KEY_SLOT
  4    58 			      init (2),
  4    59 	   DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT
  4    60 			      init (1),
  4    61 	   LEAF_CI_HEADER_LENGTH_IN_BITS
  4    62 			      init (180),
  4    63 	   BRANCH_CI_HEADER_LENGTH_IN_BITS
  4    64 			      init (216)
  4    65 	   )		      internal static options (constant) fixed bin;
  4    66 
  4    67 /* END INCLUDE FILE - dm_im_ci_header.incl.pl1 */
      381 
      382 
  5     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*
  5     5*        Contains the declaration of an element identifier.  Element
  5     6*   identifiers consist of two parts, the id (number) of the control interval
  5     7*   in which the element resides, and the index into the slot table of
  5     8*   the element in the control interval.  The declaration of the element_id 
  5     9*   structure reflects this division of the element identifier.  The structure 
  5    10*   is based on the automatic bit string element_id_string because programs
  5    11*   generally pass bit strings (element_id_string) to each other, then 
  5    12*   interpret the bit string by overlaying the element_id structure ony if
  5    13*   it is necessary to access the parts of the id.  Basing element_id on
  5    14*   addr(element_id_string) instead of on a pointer removes the necessity
  5    15*   for always setting that pointer explicitly and guarantees that changes
  5    16*   made to the string or structure do not get inconsistent.
  5    17*
  5    18*   Changes made to element_id must also be made to datum_id, declared in 
  5    19*   dm_cm_datum.incl.pl1.
  5    20**/
  5    21 
  5    22 /* HISTORY:
  5    23*Written by Matthew Pierret, 04/01/82.
  5    24*Modified:
  5    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  5    26**/
  5    27 
  5    28 /* format: style2,ind3,ll79 */
  5    29 
  5    30      dcl	   element_id_string      bit (36) aligned;
  5    31 
  5    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  5    33 	     2 control_interval_id
  5    34 			      fixed bin (24) unal unsigned,
  5    35 	     2 index	      fixed bin (12) unal unsigned;
  5    36 
  5    37 
  5    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      383 
      384 
  6     1 /* BEGIN INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*     This include file contains declarations of all collection_manager_ 
  6     5*     entrypoints.
  6     6**/
  6     7 
  6     8 /* HISTORY:
  6     9*Written by Matthew Pierret 
  6    10*Modified:
  6    11*04/14/82 by Lindsey Spratt: Changed the control_interval_id parameter of the
  6    12*	  allocate_control_interval operation to be unaligned, as well as
  6    13*	  unsigned.
  6    14*06/17/82 by Matthew Pierret: Added the put_element_portion opertion and
  6    15*            removed the beginning_location parameter from the put_element
  6    16*            operation. Added the create_page_file_operation.
  6    17*08/09/82 by Matthew Pierret: Changed "fixed bin (17)"s to "bit (36) aligned"s
  6    18*            wherever collection_id was required.
  6    19*            Also changed the control_interval_id parameter of the 
  6    20*            allocate_control_interval operation back to be aligned. So there.
  6    21*10/20/82 by Matthew Pierret: Changed $create_page_file to $create_file,
  6    22*            added the argument file_create_info_ptr to $create_file.
  6    23*12/13/82 by Lindsey Spratt:  Corrected $free_control_interval to
  6    24*	  include the zero_on_free bit.
  6    25*12/17/82 by Matthew Pierret: Added cm_$get_id.
  6    26*01/07/83 by Matthew Pierret: Added cm_$put_element_buffered, 
  6    27*            cm_$allocate_element_buffered, cm_$free_element_buffered.
  6    28*04/27/83 by Matthew Pierret: Added cm_$put_unprotected_element,
  6    29*            cm_$put_unprotected_header.
  6    30*11/07/83 by Matthew Pierret: Added $get_element_portion_buffered,
  6    31*             $simple_get_buffered_element.
  6    32*02/08/84 by Matthew Pierret:  Changed $get_id to have only one bit(1)aligned
  6    33*            parameter for specifying absolute/relative nature of search.
  6    34*03/16/84 by Matthew Pierret:  Added cm_$get_control_interval_ptr,
  6    35*            $get_element_ptr, $get_element_portion_ptr, $simple_get_element_ptr
  6    36*04/03/84 by Matthew Pierret:  Added cm_$compact_control_interval.
  6    37*06/06/84 by Matthew Pierret:  Re-named free_element* to delete and
  6    38*            delete_from_ci_buffer.
  6    39*            Re-named *_buffered_ci to =_ci_buffer.
  6    40*            get entries.
  6    41*            modify entries.
  6    42*            Changed calling sequence of modify entries to have a ptr/length
  6    43*            instead of length/ptr parameter pair.
  6    44*03/11/85 by R. Michael Tague:  Added $postcommit_increments.
  6    45**/
  6    46 
  6    47 /* This include file contains declarations of collection_manager_ entrypoints */
  6    48 
  6    49 /* format: style2,ind3 */
  6    50      dcl	   collection_manager_$allocate_control_interval
  6    51 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
  6    52      dcl	   collection_manager_$compact_control_interval
  6    53 			      entry (bit (36) aligned, fixed bin (24) uns, fixed bin (35));
  6    54      dcl	   collection_manager_$create_collection
  6    55 			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  6    56      dcl	   collection_manager_$create_file
  6    57 			      entry (char (*), char (*), ptr, bit (36) aligned, fixed bin (35));
  6    58      dcl	   collection_manager_$destroy_collection
  6    59 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  6    60      dcl	   collection_manager_$free_control_interval
  6    61 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, bit (1) aligned,
  6    62 			      fixed bin (35));
  6    63 
  6    64      dcl	   collection_manager_$delete
  6    65 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  6    66 			      fixed bin (35));
  6    67      dcl	   collection_manager_$delete_from_ci_buffer
  6    68 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  6    69 			      fixed bin (35));
  6    70 
  6    71      dcl	   collection_manager_$get
  6    72 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  6    73 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  6    74      dcl	   collection_manager_$get_control_interval_ptr
  6    75 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, ptr,
  6    76 			      fixed bin (35));
  6    77      dcl	   collection_manager_$get_from_ci_buffer
  6    78 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  6    79 			      ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  6    80      dcl	   collection_manager_$get_by_ci_ptr
  6    81 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  6    82 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), ptr, fixed bin (35));
  6    83      dcl	   collection_manager_$get_header
  6    84 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (17), ptr, bit (1) aligned,
  6    85 			      ptr, fixed bin (35), fixed bin (35));
  6    86      dcl	   collection_manager_$get_id
  6    87 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17),
  6    88 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  6    89      dcl	   collection_manager_$get_portion
  6    90 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  6    91 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  6    92 			      fixed bin (35), fixed bin (35));
  6    93      dcl	   collection_manager_$get_portion_from_ci_buffer
  6    94 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  6    95 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  6    96 			      fixed bin (35));
  6    97      dcl	   collection_manager_$get_portion_by_ci_ptr
  6    98 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  6    99 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  6   100 			      fixed bin (35));
  6   101      dcl	   collection_manager_$modify
  6   102 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  6   103 			      fixed bin (35), fixed bin (35));
  6   104      dcl	   collection_manager_$modify_unprotected
  6   105 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  6   106 			      fixed bin (35), fixed bin (35));
  6   107      dcl	   collection_manager_$modify_in_ci_buffer
  6   108 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  6   109 			      fixed bin (35), fixed bin (35));
  6   110      dcl	   collection_manager_$modify_portion
  6   111 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35), ptr,
  6   112 			      fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  6   113      dcl	   collection_manager_$postcommit_increments
  6   114 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  6   115      dcl	   collection_manager_$put
  6   116 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  6   117 			      fixed bin (35), fixed bin (35));
  6   118      dcl	   collection_manager_$put_in_ci_buffer
  6   119 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  6   120 			      fixed bin (35), fixed bin (35));
  6   121      dcl	   collection_manager_$put_header
  6   122 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  6   123      dcl	   collection_manager_$put_unprotected_header
  6   124 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  6   125 
  6   126      dcl	   collection_manager_$replace_ci_buffer
  6   127 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  6   128 			      fixed bin (35));
  6   129      dcl	   collection_manager_$setup_ci_buffer
  6   130 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  6   131 			      fixed bin (35));
  6   132      dcl	   collection_manager_$simple_get_by_ci_ptr
  6   133 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  6   134 			      fixed bin (35));
  6   135      dcl	   collection_manager_$simple_get_from_ci_buffer
  6   136 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  6   137 			      fixed bin (35));
  6   138 
  6   139 /* END INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
      385 
      386 
  7     1 /* BEGIN INCLUDE FILE - dm_key_count_array.incl.pl1 */
  7     2 
  7     3 
  7     4 
  7     5 /****^  HISTORY COMMENTS:
  7     6*  1) change(87-01-15,Hergert), approve(87-04-01,MCR7632),
  7     7*     audit(87-02-09,Dupuis), install(87-04-02,MR12.1-1020):
  7     8*     Added the KEY_COUNT_OFFSET_IN_CHARACTERS. This is the offset from the
  7     9*     beginning of the structure to the element key_count_array.count in
  7    10*     characters. Using this it is possible to calculate the key_count_array_ptr
  7    11*     given the "addr (key_count_array.count (0))".
  7    12*                                                   END HISTORY COMMENTS */
  7    13 
  7    14 
  7    15 /* DESCRIPTION:
  7    16*
  7    17*          The key_count_array holds counts of the number of unique key values
  7    18*     in an index.  These values are used by the search optimization done by
  7    19*     MRDS.  count(0) is the number of keys in the index.  count(N) is the
  7    20*     number of keys in the index which have at least fields 1 through N
  7    21*     having the same value as another key in the index, i.e. count(N)
  7    22*     is the number of partial duplicates with number of partial
  7    23*     duplication fields equal to N.
  7    24*
  7    25**/
  7    26 
  7    27 /* HISTORY:
  7    28*
  7    29*Written by Lindsey Spratt, 11/09/82.
  7    30*Modified:
  7    31*10/27/84 by Lindsey L. Spratt:  Changed the version to char(8) aligned.
  7    32*	  Added a description, fixed the history section.
  7    33**/
  7    34 
  7    35 /* format: style2,ind3 */
  7    36      dcl	   1 key_count_array      aligned based (key_count_array_ptr),
  7    37 	     2 version	      char (8) aligned,
  7    38 	     2 number_of_counts   fixed bin (17) unal,
  7    39 	     2 pad	      bit (18) unal,
  7    40 	     2 count	      (0:kca_number_of_counts refer (key_count_array.number_of_counts)) fixed
  7    41 			      bin (35) aligned;
  7    42 
  7    43      dcl	   KEY_COUNT_ARRAY_VERSION_2
  7    44 			      init ("KeyCnt 2") char (8) aligned internal static options (constant);
  7    45      dcl     KEY_COUNT_OFFSET_IN_CHARACTERS
  7    46 			      init (12) fixed bin internal static options (constant);
  7    47 
  7    48      dcl	   key_count_array_ptr    ptr init (null);
  7    49      dcl	   kca_number_of_counts   fixed bin (17) init (0);
  7    50 
  7    51 
  7    52 /* END INCLUDE FILE - dm_key_count_array.incl.pl1 */
      387 
      388 
  8     1 /* BEGIN INCLUDE FILE dm_ci_lengths.incl.pl1 */
  8     2 
  8     3 /* DESCRIPTION:
  8     4*       This include file contains constants which are the length in bytes
  8     5*   of the addressable portion of a control interval.  The addressable portion
  8     6*   is that part of the control interval which callers of file_manager_
  8     7*   may access, specifically, everything between the end of the control
  8     8*   interval header (ci_header) and the control interval trailer (ci_trailer).
  8     9*   Control interval 0 is slightly different, as it also contains an 
  8    10*   unaddressable portion in which it maintains the file attributes.  For
  8    11*   control interval 0 the addressable portion is everything between the end
  8    12*   of the control interval header and the beginning of the file attributes.
  8    13**/
  8    14 
  8    15 /* HISTORY:
  8    16*Written by Matthew Pierret, 11/02/84.
  8    17*Modified:
  8    18**/
  8    19 
  8    20 /* format: style2,ind3 */
  8    21 
  8    22      dcl	   CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES
  8    23 			      fixed bin (17) init (4072) int static options (constant);
  8    24 
  8    25      dcl	   CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES
  8    26 			      fixed bin (17) init (3176) int static options (constant);
  8    27 
  8    28 
  8    29      dcl	   CI_ADDRESSABLE_LENGTH  fixed bin (17) init (4072) int static options (constant);
  8    30 
  8    31      dcl	   CI_0_ADDRESSABLE_LENGTH
  8    32 			      fixed bin (17) init (3176) int static options (constant);
  8    33 
  8    34 /* END INCLUDE FILE dm_ci_lengths.incl.pl1 */
      389 
      390    end im_update_key_counts;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/02/87  1304.9  im_update_key_counts.pl1          >spec>install>MR12.1-1020>im_update_key_counts.pl1
340          1    01/07/85  0858.5  dm_element_id.incl.pl1            >ldd>include>dm_element_id.incl.pl1
377          2    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
379          3    01/07/85  0858.9  dm_im_cursor.incl.pl1             >ldd>include>dm_im_cursor.incl.pl1
381          4    01/07/85  0858.8  dm_im_ci_header.incl.pl1          >ldd>include>dm_im_ci_header.incl.pl1
383          5    01/07/85  0858.5  dm_element_id.incl.pl1            >ldd>include>dm_element_id.incl.pl1
385          6    04/05/85  0924.4  dm_collmgr_entry_dcls.incl.pl1    >ldd>include>dm_collmgr_entry_dcls.incl.pl1
387          7    04/02/87  1300.6  dm_key_count_array.incl.pl1       >spec>install>MR12.1-1020>dm_key_count_array.incl.pl1
389          8    01/07/85  0900.7  dm_ci_lengths.incl.pl1            >ldd>include>dm_ci_lengths.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000002 constant        bit(36)                  initial dcl 2-7 set ref 142* 292* 305*
ALL_FIELDS                             constant        fixed bin(17,0)          initial dcl 112 ref 197 247
BITS_PER_BYTE                          constant        fixed bin(17,0)          initial dcl 113 ref 86 369
CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES
                                       constant        fixed bin(17,0)          initial dcl 8-22 ref 86 369
DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT
                                       constant        fixed bin(17,0)          initial dcl 4-56 ref 323
INDEX_CURSOR_TYPE               000033 constant        fixed bin(17,0)          initial dcl 3-67 set ref 142 142*
INDEX_CURSOR_VERSION_3                 constant        fixed bin(17,0)          initial dcl 3-66 ref 147
KEY_COUNT_ARRAY_VERSION_2       000000 constant        char(8)                  initial dcl 7-43 set ref 170*
LEAF_CI_HEADER_LENGTH_IN_BITS          constant        fixed bin(17,0)          initial dcl 4-56 ref 84 84
bin                                                    builtin function         dcl 104 ref 204 254 263
cleanup                         000122 stack reference condition                dcl 108 ref 153
collection_id             2            based           bit(36)                  level 2 dcl 3-29 set ref 325* 353* 369*
collection_manager_$get_from_ci_buffer
                                000026 constant        entry                    external dcl 6-77 ref 353
collection_manager_$setup_ci_buffer
                                000030 constant        entry                    external dcl 6-129 ref 369
collection_manager_$simple_get_from_ci_buffer
                                000032 constant        entry                    external dcl 6-135 ref 325
common                                 based           structure                level 2 unaligned dcl 4-43
common_ci_header                       based           structure                level 1 unaligned dcl 4-26
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "element_id" packed unsigned
                                                                                  unaligned dcl 5-32 in procedure
                                                                                  "im_update_key_counts" set ref 160 178* 179 184
                                                                                  187* 227* 228 233 235* 242
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "element_id" packed unsigned
                                                                                  unaligned dcl 1-32 in procedure "GET_CI_HEADER"
                                                                                  set ref 322*
count                     3            based           fixed bin(35,0)          array level 2 dcl 7-36 set ref 204* 204 254* 254
                                                                                  263* 263
count_idx                       000100 automatic       fixed bin(17,0)          dcl 77 set ref 203* 204 204* 253* 254 254*
current_key                            based           bit                      unaligned dcl 99 ref 270
current_key_ptr                 000102 automatic       pointer                  initial dcl 78 set ref 78* 163* 165 165* 197* 247*
                                                                                  270 270 270
current_key_string_length       000104 automatic       fixed bin(35,0)          initial dcl 79 set ref 79* 164* 165* 197 247 270 270
current_node_buffer_ptr         000106 automatic       pointer                  initial dcl 81 set ref 81* 149* 160* 165* 183* 184*
                                                                                  187* 196* 221* 232* 233* 235* 245*
data_format_util_$compare_string_to_string
                                000010 constant        entry                    external dcl 119 ref 197 247
dm_error_$bad_first_key_idx     000016 external static fixed bin(35,0)          dcl 128 set ref 333*
dm_error_$bad_last_key_idx      000020 external static fixed bin(35,0)          dcl 128 set ref 335*
dm_error_$bad_leaf_node         000022 external static fixed bin(35,0)          dcl 128 set ref 331*
dm_error_$wrong_cursor_type     000014 external static fixed bin(35,0)          dcl 128 set ref 142*
element_id                             based           structure                level 1 dcl 5-32 in procedure "im_update_key_counts"
element_id                             based           structure                level 1 dcl 1-32 in procedure "GET_CI_HEADER"
element_id_string               000211 automatic       bit(36)                  dcl 1-30 in procedure "GET_CI_HEADER" set ref 322
                                                                                  323 325*
element_id_string               000134 automatic       bit(36)                  dcl 5-30 in procedure "im_update_key_counts" set ref
                                                                                  150* 160 165* 174 174 175 178 179 184 187 188 196*
                                                                                  217* 223 223 224 227 228 233 235 237 242 245*
er_p_code                              parameter       fixed bin(35,0)          dcl 279 ref 277 281
error_table_$unimplemented_version
                                000024 external static fixed bin(35,0)          dcl 134 set ref 292* 305*
file_opening_id           1            based           bit(36)                  level 2 dcl 3-29 set ref 353* 369*
first                     1            based           fixed bin(18,0)          level 4 packed unsigned unaligned dcl 4-43 ref 175
                                                                                  237 333 335
flags                                  based           structure                level 2 packed unaligned dcl 4-26
gch_code                        000210 automatic       fixed bin(35,0)          initial dcl 319 set ref 319* 325* 328 328*
gch_p_control_interval_id              parameter       fixed bin(24,0)          unsigned unaligned dcl 315 ref 312 322
gch_p_leaf_ci_header_ptr               parameter       pointer                  dcl 317 set ref 312 325* 325 325 331 333 335 335
gch_p_node_buffer_ptr                  parameter       pointer                  dcl 314 set ref 312 325*
gk_code                         000220 automatic       fixed bin(35,0)          dcl 350 set ref 353* 356 356*
gk_p_key_id_string                     parameter       bit(36)                  dcl 346 set ref 343 353*
gk_p_leaf_key_ptr                      parameter       pointer                  dcl 347 set ref 343 353* 353*
gk_p_leaf_key_string_length            parameter       fixed bin(35,0)          dcl 348 set ref 343 353* 353*
gk_p_node_buffer_ptr                   parameter       pointer                  dcl 345 set ref 343 353*
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "element_id" packed unsigned
                                                                                  unaligned dcl 1-32 in procedure "GET_CI_HEADER"
                                                                                  set ref 323*
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "element_id" packed unsigned
                                                                                  unaligned dcl 5-32 in procedure
                                                                                  "im_update_key_counts" set ref 174* 174 175 188*
                                                                                  223* 223 224 237*
index_cursor                           based           structure                level 1 unaligned dcl 3-29
index_cursor_ptr                000130 automatic       pointer                  dcl 3-64 set ref 141* 142 142 147 325 353 353 369
                                                                                  369
is_leaf                                based           bit(1)                   level 3 packed unaligned dcl 4-26 ref 331
kca_number_of_counts            000140 automatic       fixed bin(17,0)          initial dcl 7-49 set ref 7-49*
key_count_array                        based           structure                level 1 dcl 7-36
key_count_array_ptr             000136 automatic       pointer                  initial dcl 7-48 set ref 169* 170 204 204 254 254
                                                                                  263 263 7-48*
key_range                 1            based           structure                level 3 packed unaligned dcl 4-43
last                      1(18)        based           fixed bin(18,0)          level 4 packed unsigned unaligned dcl 4-43 ref 188
                                                                                  224 335
leaf_ci_header                         based           structure                level 1 unaligned dcl 4-43 ref 325 325
leaf_ci_header_ptr              000132 automatic       pointer                  dcl 4-46 set ref 151* 156 159* 160* 175 178 191 224
                                                                                  227 240
local_main_ci_header_buffer     000110 automatic       bit                      dcl 84 set ref 159
local_node_buffer               000110 automatic       bit                      dcl 86 set ref 183 232
local_temp_ci_header_buffer     000110 automatic       bit                      dcl 84 set ref 186 234
myname                          000003 constant        varying char(32)         initial dcl 115 set ref 142* 292* 305*
next_first_inequal_field_id     000117 automatic       fixed bin(17,0)          initial dcl 92 set ref 92* 247* 253
next_id                   3(24)        based           fixed bin(24,0)          level 3 packed unsigned unaligned dcl 4-43 ref 227
null                                                   builtin function         dcl 104 ref 78 81 88 90 94 142 142 156 165 193 209
                                                                                  214 259 261 7-48 270 272 292 292 305 305
p_code                                 parameter       fixed bin(35,0)          dcl 73 set ref 53 139* 197* 200 200* 247* 250 250*
                                                                                  281*
p_current_key_id                       parameter       bit(36)                  dcl 68 ref 53 150 217
p_current_key_ptr                      parameter       pointer                  dcl 69 ref 53 163 270
p_current_key_string_length            parameter       fixed bin(35,0)          dcl 70 ref 53 164
p_expected_version                     parameter       char(8)                  dcl 302 in procedure "CHECK_VERSION_CHAR" set ref
                                                                                  299 305 305*
p_expected_version                     parameter       fixed bin(35,0)          dcl 289 in procedure "CHECK_VERSION" set ref 286 292
                                                                                  292*
p_field_table_ptr                      parameter       pointer                  dcl 65 set ref 53 197* 247*
p_index_cursor_ptr                     parameter       pointer                  dcl 63 ref 53 141
p_is_being_inserted                    parameter       bit(1)                   dcl 66 ref 53 204 254 263
p_key_count_array_ptr                  parameter       pointer                  dcl 72 ref 53 169
p_leaf_ci_header_ptr                   parameter       pointer                  dcl 67 ref 53 151
p_node_buffer_ptr                      parameter       pointer                  dcl 62 ref 53 149 221
p_received_version                     parameter       fixed bin(35,0)          dcl 288 in procedure "CHECK_VERSION" set ref 286 292
                                                                                  292*
p_received_version                     parameter       char(8)                  dcl 301 in procedure "CHECK_VERSION_CHAR" set ref
                                                                                  299 305 305*
p_structure_name                       parameter       char                     unaligned dcl 303 in procedure "CHECK_VERSION_CHAR"
                                                                                  set ref 299 305*
p_structure_name                       parameter       char                     unaligned dcl 290 in procedure "CHECK_VERSION" set
                                                                                  ref 286 292*
p_work_area_ptr                        parameter       pointer                  dcl 64 ref 53 140
previous_first_inequal_field_id 000116 automatic       fixed bin(17,0)          initial dcl 92 set ref 92* 197* 203 253
previous_id               3            based           fixed bin(24,0)          level 3 packed unsigned unaligned dcl 4-43 ref 178
snb_code                        000230 automatic       fixed bin(35,0)          initial dcl 367 set ref 367* 369* 372 372*
snb_p_buffer_ptr                       parameter       pointer                  dcl 365 set ref 361 369*
snb_p_control_interval_id              parameter       fixed bin(24,0)          unsigned dcl 363 set ref 361 369*
sub_err_                        000012 constant        entry                    external dcl 124 ref 142 292 305
temp_key                               based           bit                      unaligned dcl 98 ref 213 259 272
temp_key_ptr                    000110 automatic       pointer                  initial dcl 88 set ref 88* 196* 197* 209 213 214*
                                                                                  245* 247* 259 259 261* 272 272
temp_key_string_length          000112 automatic       fixed bin(35,0)          initial dcl 89 set ref 89* 196* 197 213 213 245* 247
                                                                                  259 259 272 272
temp_leaf_ci_header_ptr         000114 automatic       pointer                  initial dcl 90 set ref 90* 186* 187* 188 191* 193
                                                                                  234* 235* 237 240*
type                                   based           fixed bin(17,0)          level 2 packed unaligned dcl 3-29 set ref 142 142*
version                                based           char(8)                  level 2 in structure "key_count_array" dcl 7-36
                                                                                  in procedure "im_update_key_counts" set ref 170*
version                   0(18)        based           fixed bin(17,0)          level 2 in structure "index_cursor" packed unaligned
                                                                                  dcl 3-29 in procedure "im_update_key_counts" ref
                                                                                  147
work_area                              based           area(1024)               dcl 100 ref 213 259 270 272
work_area_ptr                   000120 automatic       pointer                  initial dcl 94 set ref 94* 140* 213 259 270 272 353*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 2-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 2-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 2-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 2-7
BRANCH_CI_HEADER_LENGTH_IN_BITS        internal static fixed bin(17,0)          initial dcl 4-56
CI_0_ADDRESSABLE_LENGTH                internal static fixed bin(17,0)          initial dcl 8-31
CI_ADDRESSABLE_LENGTH                  internal static fixed bin(17,0)          initial dcl 8-29
CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES
                                       internal static fixed bin(17,0)          initial dcl 8-25
DEFAULT_INITIAL_KEY_SLOT               internal static fixed bin(17,0)          initial dcl 4-56
KEY_COUNT_OFFSET_IN_CHARACTERS         internal static fixed bin(17,0)          initial dcl 7-45
branch_ci_header                       based           structure                level 1 unaligned dcl 4-48
branch_ci_header_ptr                   automatic       pointer                  dcl 4-53
collection_manager_$allocate_control_interval
                                000000 constant        entry                    external dcl 6-50
collection_manager_$compact_control_interval
                                000000 constant        entry                    external dcl 6-52
collection_manager_$create_collection
                                000000 constant        entry                    external dcl 6-54
collection_manager_$create_file 000000 constant        entry                    external dcl 6-56
collection_manager_$delete      000000 constant        entry                    external dcl 6-64
collection_manager_$delete_from_ci_buffer
                                000000 constant        entry                    external dcl 6-67
collection_manager_$destroy_collection
                                000000 constant        entry                    external dcl 6-58
collection_manager_$free_control_interval
                                000000 constant        entry                    external dcl 6-60
collection_manager_$get         000000 constant        entry                    external dcl 6-71
collection_manager_$get_by_ci_ptr
                                000000 constant        entry                    external dcl 6-80
collection_manager_$get_control_interval_ptr
                                000000 constant        entry                    external dcl 6-74
collection_manager_$get_header  000000 constant        entry                    external dcl 6-83
collection_manager_$get_id      000000 constant        entry                    external dcl 6-86
collection_manager_$get_portion 000000 constant        entry                    external dcl 6-89
collection_manager_$get_portion_by_ci_ptr
                                000000 constant        entry                    external dcl 6-97
collection_manager_$get_portion_from_ci_buffer
                                000000 constant        entry                    external dcl 6-93
collection_manager_$modify      000000 constant        entry                    external dcl 6-101
collection_manager_$modify_in_ci_buffer
                                000000 constant        entry                    external dcl 6-107
collection_manager_$modify_portion
                                000000 constant        entry                    external dcl 6-110
collection_manager_$modify_unprotected
                                000000 constant        entry                    external dcl 6-104
collection_manager_$postcommit_increments
                                000000 constant        entry                    external dcl 6-113
collection_manager_$put         000000 constant        entry                    external dcl 6-115
collection_manager_$put_header  000000 constant        entry                    external dcl 6-121
collection_manager_$put_in_ci_buffer
                                000000 constant        entry                    external dcl 6-118
collection_manager_$put_unprotected_header
                                000000 constant        entry                    external dcl 6-123
collection_manager_$replace_ci_buffer
                                000000 constant        entry                    external dcl 6-126
collection_manager_$simple_get_by_ci_ptr
                                000000 constant        entry                    external dcl 6-132
common_ci_header_ptr                   automatic       pointer                  dcl 4-41

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_VERSION                   001153 constant        entry                    internal dcl 286 ref 147
CHECK_VERSION_CHAR              001247 constant        entry                    internal dcl 299 ref 170
ERROR_RETURN                    001140 constant        entry                    internal dcl 277 ref 200 250 328 331 333 335 356 372
FINISH                          001101 constant        entry                    internal dcl 268 ref 153 264 280
GET_CI_HEADER                   001351 constant        entry                    internal dcl 312 ref 160 187 235
GET_KEY                         001464 constant        entry                    internal dcl 343 ref 165 196 245
MAIN_RETURN                     001073 constant        label                    dcl 264 ref 282
SETUP_NODE_BUFFER               001532 constant        entry                    internal dcl 361 ref 184 233
im_update_key_counts            000150 constant        entry                    external dcl 53

NAMES DECLARED BY CONTEXT OR IMPLICATION.
addr                                                   builtin function         ref 159 160 174 174 175 178 179 183 184 186 187 188
                                                                                  223 223 224 227 228 232 233 234 235 237 242 322
                                                                                  323
length                                                 builtin function         ref 325 325
max                                                    builtin function         ref 253
unspec                                                 builtin function         ref 325 325

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2076        2132    1672        2106
Length      2510    1672        34         341     204           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
im_update_key_counts                394 external procedure  is an external procedure.  
on unit on line 153                  64 on unit               
FINISH                               64 internal procedure  is called by several nonquick procedures.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure im_update_key_counts.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure im_update_key_counts.  
CHECK_VERSION_CHAR                      internal procedure  shares stack frame of external procedure im_update_key_counts.  
GET_CI_HEADER                           internal procedure  shares stack frame of external procedure im_update_key_counts.  
GET_KEY                                 internal procedure  shares stack frame of external procedure im_update_key_counts.  
SETUP_NODE_BUFFER                       internal procedure  shares stack frame of external procedure im_update_key_counts.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
im_update_key_counts     000100 count_idx                   im_update_key_counts
                         000102 current_key_ptr             im_update_key_counts
                         000104 current_key_string_length   im_update_key_counts
                         000106 current_node_buffer_ptr     im_update_key_counts
                         000110 local_temp_ci_header_buffer im_update_key_counts
                         000110 local_node_buffer           im_update_key_counts
                         000110 local_main_ci_header_buffer im_update_key_counts
                         000110 temp_key_ptr                im_update_key_counts
                         000112 temp_key_string_length      im_update_key_counts
                         000114 temp_leaf_ci_header_ptr     im_update_key_counts
                         000116 previous_first_inequal_field_id
                                                            im_update_key_counts
                         000117 next_first_inequal_field_id im_update_key_counts
                         000120 work_area_ptr               im_update_key_counts
                         000130 index_cursor_ptr            im_update_key_counts
                         000132 leaf_ci_header_ptr          im_update_key_counts
                         000134 element_id_string           im_update_key_counts
                         000136 key_count_array_ptr         im_update_key_counts
                         000140 kca_number_of_counts        im_update_key_counts
                         000210 gch_code                    GET_CI_HEADER
                         000211 element_id_string           GET_CI_HEADER
                         000220 gk_code                     GET_KEY
                         000230 snb_code                    SETUP_NODE_BUFFER

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac          alloc_auto_adj
mpfx2               enable_op           ext_entry           int_entry           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
collection_manager_$get_from_ci_buffer                      collection_manager_$setup_ci_buffer
collection_manager_$simple_get_from_ci_buffer               data_format_util_$compare_string_to_string
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bad_first_key_idx   dm_error_$bad_last_key_idx    dm_error_$bad_leaf_node       dm_error_$wrong_cursor_type
error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     53 000140        78 000155        79 000157        81 000160        84 000161        86 000177        88 000206
     89 000210        90 000211        92 000212        94 000215    7   48 000217    7   49 000220       139 000221
    140 000223       141 000226       142 000231       147 000307       149 000324       150 000330       151 000332
    153 000335       156 000357       159 000363       160 000365       163 000371       164 000375       165 000377
    169 000405       170 000411       174 000436       175 000442       178 000454       179 000456       183 000461
    184 000463       186 000466       187 000470       188 000502       190 000505       191 000506       193 000507
    196 000513       197 000515       200 000560       203 000571       204 000601       206 000622       209 000624
    213 000630       214 000635       217 000637       221 000642       223 000645       224 000651       227 000663
    228 000667       232 000672       233 000674       234 000677       235 000701       237 000713       239 000717
    240 000720       242 000721       245 000724       247 000726       250 000771       253 001002       254 001015
    256 001036       259 001040       261 001051       263 001053       264 001073       266 001077       268 001100
    270 001106       272 001125       274 001137       277 001140       280 001142       281 001146       282 001152
    286 001153       292 001164       297 001246       299 001247       305 001260       310 001350       312 001351
    319 001353       322 001354       323 001360       325 001362       328 001412       331 001416       333 001433
    335 001450       339 001463       343 001464       353 001466       356 001525       359 001531       361 001532
    367 001534       369 001535       372 001562       375 001566


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
