	COMPILATION LISTING OF SEGMENT ansi_tape_io_
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-03-10_1525.78_Fri_mst
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1989   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        6*        *                                                         *
        7*        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        8*        *                                                         *
        9*        *********************************************************** */
       10 
       11 /****^  HISTORY COMMENTS:
       12*  1) change(85-06-07,GWMay), approve(85-06-07,MECR0125),
       13*     audit(85-06-07,GDixon), install():
       14*     modified entry SETUP_NEW_FILE to call pfm_utils_$position_in_file to
       15*     position to the beginning of the headers where it had previously
       16*     positioned back one file.
       17*  2) change(85-10-24,GWMay), approve(85-10-24,MCR7256), audit(85-12-16,GDixon),
       18*     install(85-12-17,MR12.0-1001):
       19*     Formally install changes in MECR0125.  Added use of the maxlength and
       20*     substr functions and changed field sizes where possible to eliminate
       21*     stringsize errors.
       22*  3) change(87-08-17,GWMay), approve(87-09-09,MECR0006),
       23*     audit(87-09-04,Farley), install(87-09-09,MR12.1-1101):
       24*     Removed set density call that was moved within mtape_.
       25*  4) change(87-10-19,GWMay), approve(87-10-19,MCR7779), audit(87-11-02,Farley),
       26*     install(87-11-30,MR12.2-1006):
       27*     Formally install MECR0006.
       28*  5) change(88-02-03,GWMay), approve(88-02-03,MCR7837), audit(88-04-12,Farley),
       29*     install(88-04-19,MR12.2-1039):
       30*     Changed to process user specified labels correctly.
       31*     Changed to correctly set the RCP auth code in the header.
       32*  6) change(88-11-15,Farley), approve(88-11-16,MECR0004),
       33*     audit(88-11-15,Beattie), install(88-11-16,MR12.2-1216):
       34*     Changed to use the ANSI_L2_ID array for checking the ansi_hdr2 label_id,
       35*     in the decode_file_labels entry.  The check was using
       36*     "ANSI_L1_IS(ANSI_HDR2)", which was never allowing the "HDR2" code to
       37*     execute.
       38*  7) change(88-11-23,Farley), approve(88-12-14,MCR8031),
       39*     audit(89-05-15,Parisek), install(89-05-16,MR12.3-1045):
       40*     Official mr12.3 installation of previous change, MECR0004, for mr12.2.
       41*  8) change(00-01-26,Schroth), approve(00-01-26,MECR-Y2K):
       42*     Changed expiry date checking to use new pfm_utils_$label_unexpired to
       43*     verify if a file has expired.
       44*  9) change(00-03-10,Schroth), approve(00-03-10,MECR-MTAPE-LBLS):
       45*     Added code to decode_file_labels to properly process pre-mtape_
       46*     ANSI HDR2 labels.
       47*                                                   END HISTORY COMMENTS */
       48 
       49 ansi_tape_io_: procedure;
       50 
       51 /* format: style4 */
       52 
       53 /* *	This program is known as a tape Per-Format module and runs under
       54*   *	control of the mtape_ I/O module and is meant to process tape volumes
       55*   *	and files in ANSI standard format.
       56*   *
       57*   *	This Per-Format module uses the following PFM dependent option flags:
       58*   *
       59*   *	mtape_open_info.pfm_opt_sw (1) = "1"b = -generate
       60*   *	mtape_open_info.pfm_opt_sw (1) = "0"b = -no_generate
       61*   *	mtape_open_info.pfm_opt_sw (2) = "1"b = -buffer_offset
       62*   *	mtape_open_info.pfm_opt_sw (2) = "0"b = -no_buffer_offset
       63*   *
       64*   *	Modification History:
       65*   *
       66*   *	Created by J. A. Bush 11/01/82
       67*   *	Modified by J. A. Bush 11/10/83 for performance improvements
       68**/
       69 
       70 /*		ARGUMENT DATA		*/
       71 
       72 dcl  arg_mtdp ptr;					/* Pointer to the mtape data structure */
       73 dcl  arg_code fixed bin (35);				/* Return error code */
       74 dcl  arg_info_ptr ptr;				/* Pointer to Order data from iox_$control call */
       75 dcl  arg_io_call_infop ptr;				/* Pointer to io_call control info structure */
       76 dcl  arg_order_name char (*);				/* Name of Control order to be processed */
       77 dcl  arg_lr_ptr ptr;				/* Pointer to current label record structure */
       78 dcl  arg_labno fixed bin;				/* label record within label group */
       79 dcl  arg_type fixed bin;				/* 1 => BOF; 2 => EOV; 3 => EOF */
       80 dcl  arg_convert fixed bin;				/* Label record conversion indicator */
       81 
       82 /*		AUTOMATIC DATA		*/
       83 
       84 dcl  Schecked_labels bit (1) aligned;
       85 dcl  buf_ptr ptr;					/* Auto copy of users buffer pointer */
       86 dcl  buf_len fixed bin (21);				/* Auto copy of users lrec buffer */
       87 dcl  rec_len fixed bin (21);				/* Auto copy of logical record length */
       88 dcl  order_name char (32);				/* Auto copy of order name */
       89 dcl  info_ptr ptr;					/* Auto copy of order info pointer */
       90 dcl  install_id char (32);
       91 dcl  user_label_data char (76);			/* storage for user label data */
       92 dcl  auth_code char (3) aligned;
       93 dcl  today char (6);
       94 dcl  temp_fmt char (3);
       95 dcl  temp_mode char (6);
       96 dcl  (term, long_record, output) bit (1) aligned;
       97 dcl  (nvp, nlp, move_ptr) ptr;
       98 dcl  (i, desc_type, label_type, n_segs, uln, open_idx) fixed bin;
       99 dcl  (move_len, crl, bytes_remaining, bytes_processed) fixed bin (21);
      100 dcl  pic1 picture "9";
      101 dcl  pic2 picture "99";
      102 dcl  pic4 picture "9999";
      103 dcl  pic5 picture "99999";
      104 dcl  pic6 picture "999999";
      105 dcl  (code, fl_code) fixed bin (35);
      106 
      107 /*		CONSTANT DATA		*/
      108 
      109 dcl  myname char (32) int static options (constant) init ("ansi_tape_io_");
      110 dcl  LABEL_LENGTH fixed bin (21) int static options (constant) init (80); /* length of label records in bytes */
      111 dcl  MAX_ANSI_RECORD_SIZE fixed bin int static options (constant) init (99999);
      112 dcl  WRITING bit (1) aligned int static options (constant) init ("1"b);
      113 dcl  OPENING bit (1) aligned int static options (constant) init ("0"b);
      114 dcl  NON_MOD_FOUR fixed bin int static options (constant) init (1);
      115 dcl  ANSI_ASCII_PAD_CHAR char (1) int static options (constant) init ("^");
      116 dcl  ANSI_EBCDIC_PAD_CHAR char (1) int static options (constant) init ("_");
      117 dcl  RCW_LENGTH fixed bin int static options (constant) init (4); /* Length of an RCW */
      118 dcl  SCW_LENGTH fixed bin int static options (constant) init (5); /* Length of an SCW */
      119 dcl  (SEG_B_E init (0),				/* Record begins and ends in this segment */
      120      SEG_B_NE init (1),				/* Record begins but does not end in this segment */
      121      SEG_NB_NE init (2),				/* Record neither begins nor ends in this segment */
      122      SEG_NB_E init (3))				/* Record ends but does not begin in this segment */
      123 	fixed bin int static options (constant);
      124 dcl  DUMMY_LABEL char (76) int static options (constant) init /* dummy HDR1/EOF1 label, used for volume init */
      125 	("!!DUMMY FILE ID!!******00010001000100 00000 00000 000000MULTICS ANSI2       ");
      126 dcl  U_LABEL_ID (3) char (3) int static options (constant) init
      127 	("UHL", "UTL", "UTL");
      128 dcl  ANSI_FORMAT_CODES (0:7) char (3) int static options (constant) init
      129 	("   ", "U  ", "F  ", "D  ", "S  ", "FB ", "DB ", "SB ");
      130 dcl  LC char (26) int static options (constant) init
      131 	("abcdefghijklmnopqrstuvwxyz");
      132 dcl  UC char (26) int static options (constant) init
      133 	("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
      134 
      135 /*		EXTERNAL STATIC DATA	*/
      136 
      137 dcl  error_table_$end_of_info fixed bin (35) ext static;
      138 dcl  error_table_$eov_on_write fixed bin (35) ext static;
      139 dcl  error_table_$long_record fixed bin (35) ext static;
      140 dcl  error_table_$invalid_record_desc fixed bin (35) ext static;
      141 dcl  error_table_$bad_file fixed bin (35) ext static;
      142 dcl  error_table_$no_operation fixed bin (35) ext static;
      143 dcl  error_table_$no_file fixed bin (35) ext static;
      144 dcl  error_table_$no_next_volume fixed bin (35) ext static;
      145 dcl  error_table_$data_seq_error fixed bin (35) ext static;
      146 dcl  error_table_$invalid_file_set_format fixed bin (35) ext static;
      147 dcl  error_table_$invalid_label_format fixed bin (35) ext static;
      148 dcl  error_table_$unimplemented_version fixed bin (35) ext static;
      149 dcl  error_table_$uninitialized_volume fixed bin (35) ext static;
      150 
      151 /*		BUILTIN FUNCTIONS		*/
      152 
      153 dcl  (addr, binary, copy, divide, fixed, hbound, index, lbound, length,
      154      maxlength, mod, null, rel, rtrim, size, substr, translate, verify)
      155 	builtin;
      156 dcl  conversion condition;
      157 dcl  illegal_procedure condition;
      158 
      159 /*		EXTERNAL ENTRIES		*/
      160 
      161 dcl  system_info_$installation_id entry (char (*));
      162 dcl  get_group_id_ entry () returns (char (32));
      163 dcl  authenticate_ entry (char (*)) returns (char (3) aligned);
      164 dcl  ebcdic_to_ascii_ entry (char (*), char (*));
      165 dcl  ascii_to_ebcdic_ entry (char (*), char (*));
      166 
      167 /* 		BASED VARIABLES		*/
      168 
      169 dcl  based_area area based (mtape_data.areap);
      170 dcl  based_label_record char (LABEL_LENGTH) based (mtape_label_record.lab_ptr);
      171 dcl  based_lrec_data char (move_len) based;		/* to move data to/from users buffer */
      172 dcl  based_lrec_index (buf_len) char (1) based (mtape_data.arg_buf_ptr); /* to increment users buffer ptr */
      173 dcl  tblock char (mtape_data.length) unaligned based (mtape_data.cur_buf_ptr); /* block as char string */
      174 
      175 dcl  1 native_bo_contents based (mtape_data.cur_buf_ptr),	/* template for  native buffer offset */
      176        (2 block_size fixed dec (7, 0),			/* size of block in bytes (including buffer offset) */
      177        2 block_number fixed dec (7, 0)) unaligned;	/* block in current file (section), from 1 */
      178 
      179 dcl  1 db_record unaligned based (mtape_data.log_record_ptr), /* Template for D/DB formated records */
      180        2 rcw char (4),				/* record control word (length) */
      181        2 rdata char (move_len),			/* logical record data */
      182        2 nxt_lrec char (1);				/* to position to nxt record */
      183 
      184 dcl  1 sb_record unaligned based (mtape_data.log_record_ptr), /* Template for S/SB formated records */
      185        2 scw,					/* Segment control word */
      186          3 span_indicator char (1),			/* controls of segments in record */
      187          3 rec_len char (4),				/* length of logical record segment */
      188        2 rdata char (move_len),			/* logical record data */
      189        2 nxt_lrec char (1);				/* to position to nxt record */
      190 
      191 /* pfm_init - entry to initialize the Per-Format module, setting up file and volume
      192*   processing parameters and determining correctness of current volume */
      193 
      194 pfm_init: entry (arg_mtdp, arg_code);
      195 
      196 	call SETUP;				/* initialize our enviornment */
      197 	call CHECK_VERSION (mtdp, mtape_data_version_1, "mtape_data"); /* check version of this structure every time */
      198 
      199 /* When the pfm_init entry is called for the first time we must allocate a label record structure to
      200*   read tape labels into. We must also check the various structure versions to make sure
      201*   we know what the caller is talking about. */
      202 
      203 	if mtape_data.tlb = null then do;
      204 	     mcip = mtape_data.close_info_ptr;		/* set ptr to close into structure */
      205 	     call pfm_utils_$init_label_record (mtdp, null, null, mtape_data.tlb, LABEL_LENGTH);
      206 	     call CHECK_VERSION (mtape_data.tlb, mtape_lr_version_1, "mtape_label_record");
      207 	     call CHECK_VERSION (vs_ptr, mtape_vs_version_1, "mtape_vol_set");
      208 	     call CHECK_VERSION (maip, mtape_attach_info_version_1, "mtape_attach_info");
      209 	     call CHECK_VERSION (moip, mtape_open_info_version_1, "mtape_open_info");
      210 	     call CHECK_VERSION (mcip, mtape_close_info_version_1, "mtape_close_info");
      211 	     call CHECK_VERSION (mpfmip, mtape_pfm_info_version_1, "mtape_pfm_info");
      212 	     call mtape_$alloc (mtdp, MTAPE_ALLOC_FI, null, 0, fi_ptr); /* allocate dummy file_info structure */
      213 	     call CHECK_VERSION (fi_ptr, mtape_fi_version_1, "mtape_file_info"); /* and check its version */
      214 	     free mtape_file_info in (based_area);	/* we can free it now */
      215 
      216 /* initialize the pfm_info structure for this PFM */
      217 
      218 	     mtape_pfm_info.open_modes_allowed (1) = Sequential_input;
      219 	     mtape_pfm_info.open_modes_allowed (2) = Sequential_output;
      220 	     mtape_pfm_info.bof_prefix = "HDR";
      221 	     mtape_pfm_info.eov_prefix = "EOV";
      222 	     mtape_pfm_info.eof_prefix = "EOF";
      223 	     mtape_pfm_info.module_id = "ANSI";
      224 	     mtape_pfm_info.no_labels_ok = "0"b;
      225 	     mtape_pfm_info.multi_volumes_ok = "1"b;
      226 	     mtape_pfm_info.extended_error_recovery = "0"b;
      227 	end;
      228 	if mtape_vol_set.volume_type = Volume_ansi_tape then /* If an ansi tape.. */
      229 	     call CHECK_VOL_LABELS (mtape_vol_set.volume_check); /* check the volume labels */
      230 	else do;					/* Not an ansi tape, don't bother to read labels */
      231 	     if mtape_vol_set.volume_type = Volume_blank |
      232 		mtape_vol_set.volume_type = Volume_unreadable then
      233 		mtape_vol_set.volume_check = BLANK_VOLUME;
      234 	     else if mtape_vol_set.volume_type = Volume_unknown_format then
      235 		mtape_vol_set.volume_check = UNLABELED_VOLUME;
      236 	     else mtape_vol_set.volume_check = RECOG_FORMAT_VOLUME;
      237 	     mtape_data.lab_buf_len = LABEL_LENGTH;	/* set in case subsequent volumes are labeled */
      238 	end;
      239 
      240 pfm_init_return:					/* target of non-local gotos */
      241 	arg_code = code;
      242 	return;
      243 
      244 /* file_open - entry to do format specific processing in opening the file
      245*   or file set (i.e. read and write file labels) */
      246 
      247 file_open: entry (arg_mtdp, arg_code);
      248 
      249 	call SETUP;				/* initialize our enviornment */
      250 	call SET_OPEN_IDX;				/* determine what type of processing to do */
      251 	call pfm_utils_$file_search (mtdp, fi_ptr, vs_ptr, code); /* search for the file */
      252 	if code ^= 0 & open_idx ^= 1 then		/* if error and not creating file.. */
      253 	     go to open_return;			/* quit now */
      254 	go to open_action (open_idx);			/* do the appropriate thing */
      255 
      256 open_action (0):					/* open for input */
      257 	call CHECK_USER_LABELS (BOF_LABEL);		/* go see if user labels to be processed */
      258 	call SET_FILE_ATTRIBUTES;			/* complete file attributes from open desc */
      259 	go to open_return;
      260 
      261 open_action (1):					/* Open for output, creation */
      262 	if code = 0 |				/* if no error */
      263 	     code = error_table_$no_file |		/* or if could not find file */
      264 	     code = error_table_$uninitialized_volume then do; /* or if bad vol label */
      265 	     if NEED_TO_INIT_VOLUME () then do;		/* if volume requires initialization.. */
      266 		call INIT_VOL_LABELS;		/* initialize the volume labels */
      267 		if code ^= 0 then go to open_return;
      268 	     end;
      269 	     code = 0;				/* reset possible error code */
      270 	     call SETUP_NEW_FILE;			/* setup new file info structure */
      271 	     if code ^= 0 then go to open_return;
      272 	     call pfm_utils_$write_file_labels (mtdp, BOF_LABEL, code); /* go write the file header labels */
      273 	     if code = 0 then			/* if no error */
      274 		if mtape_vol_set.volume_end then	/* did we run out of tape? */
      275 		     call EOV_ON_WRITE (OPENING);	/* yes, do volume switch now */
      276 	end;
      277 	go to open_return;
      278 
      279 open_action (2):					/* open for output, extend existing file */
      280 	mtape_data.phy_block = mtape_file_info.block_count; /* preset block number */
      281 open_action (3):					/* open for output, modify existing file */
      282 	call pfm_utils_$truncate_file_set (mtdp);	/* get rid of EOF labels if extend | modify */
      283 	mtape_file_info.gen_version = mod (mtape_file_info.gen_version, 100) + 1; /* increment version */
      284 	go to open_return;
      285 
      286 open_action (4):					/* open for output, generate file */
      287 	call pfm_utils_$truncate_file_set (mtdp);	/* get rid of EOF labels */
      288 	mtape_file_info.generation = mod (mtape_file_info.generation, 10000) + 1; /* increment generation number */
      289 	call pfm_utils_$write_file_labels (mtdp, BOF_LABEL, code); /* go write the file header labels */
      290 	if code = 0 then				/* if no error */
      291 	     if mtape_vol_set.volume_end then		/* did we run out of tape? */
      292 		call EOV_ON_WRITE (OPENING);		/* yes, do volume switch now */
      293 open_return:
      294 	arg_code = code;				/* return error code */
      295 
      296 	return;
      297 
      298 /* file_close - entry to do format specific processing in closing the file
      299*   or file set (i.e. read and write file trailer labels) */
      300 
      301 file_close: entry (arg_mtdp, arg_code);
      302 
      303 	call SETUP;				/* initialize our enviornment */
      304 	mcip = mtape_data.close_info_ptr;		/* set up close info ptr too */
      305 
      306 	if mtape_open_info.open_mode = Sequential_input then /* input operation? */
      307 	     output = "0"b;				/* yes, reset output flag */
      308 	else output = "1"b;				/* true if sqo or sqio */
      309 	if output & mtape_data.error_lock ^= error_table_$no_next_volume then do; /* if writing tape */
      310 	     if mtape_data.error_lock = 0 then do;	/* flush out only if possible */
      311 		if mtape_data.processed > mtape_data.buffer_offset then /* if we have some unwritten data */
      312 		     call WRITE_BLOCK;		/* write a short block */
      313 		call mtape_$flush_buffers (mtdp, code); /* write out all queued buffers */
      314 		if code ^= 0 then			/* if some error writing data */
      315 		     if code = error_table_$eov_on_write then /* Is it end of tape? */
      316 			call EOV_ON_WRITE (WRITING);	/* Go close out volume and initiate volume switch */
      317 		if code ^= 0 then
      318 		     go to close_file_return;
      319 	     end;
      320 	     call pfm_utils_$write_file_labels (mtdp, EOF_LABEL, code); /* write out EOF labels */
      321 	     if code ^= 0 then			/* error writing labels.. */
      322 		go to close_file_return;
      323 	end;
      324 	else do;					/* input operation, must make sure tape is stoped */
      325 	     call mtape_$stop_tape (mtdp, code);
      326 	     if code ^= 0 then
      327 		go to close_file_return;
      328 	end;
      329 
      330 	Schecked_labels = "0"b;
      331 						/* USER trailers can only be returned when */
      332 						/* positioned after the file data */
      333 	if ^output & mtape_file_info.position_within_file = AT_EOF then do;
      334 	     call CHECK_USER_LABELS (EOF_LABEL);	/* go see if user labels to be processed */
      335 	     Schecked_labels = "1"b;
      336 	end;
      337 
      338 	if mtape_close_info.position ^= 0 then do;	/* if not leaving tape where it is.. */
      339 	     call pfm_utils_$position_in_file (mtdp, fi_ptr,
      340 		vs_ptr, mtape_close_info.position, code);
      341 	     if ^output & code = 0 & ^Schecked_labels &
      342 		mtape_file_info.position_within_file = AT_EOFH then
      343 		call CHECK_USER_LABELS (EOF_LABEL);
      344 	end;
      345 
      346 close_file_return:
      347 	arg_code = code;				/* copy return error code (if any) */
      348 	return;
      349 
      350 /* read - entry to read format specific logical records from the current file */
      351 
      352 read: entry (arg_mtdp, arg_code);
      353 
      354 	mtdp = arg_mtdp;				/* copy arguments */
      355 	buf_ptr = mtape_data.arg_buf_ptr;		/* If = null, return length of next record */
      356 	buf_len = mtape_data.arg_buf_len;
      357 	code, rec_len = 0;				/* initialize return record length */
      358 	long_record = "0"b;				/* init long record flag */
      359 	if mtape_data.remain <= 0 then		/* Do we need to read in a block? */
      360 	     call GET_NXT_RECORD;			/* yes, do it */
      361 	go to READ_TYPE (mtape_data.ad_file_format);	/* process depending on file format */
      362 
      363 READ_TYPE (1):					/* Process "U" formated records */
      364 	crl, move_len = mtape_data.remain;		/* user gets entire block */
      365 	move_ptr = mtape_data.log_record_ptr;		/* set pointer to move data from */
      366 	call MOVE_TO_USER;				/* move the data to the users buffer */
      367 	go to read_return;
      368 
      369 READ_TYPE (2):					/* Process "F/FB" formated records */
      370 	if mtape_data.record_size > mtape_data.remain then/* don't try to move more than we have */
      371 	     crl = mtape_data.remain;
      372 	else crl = mtape_data.record_size;
      373 	move_len = crl;
      374 	move_ptr = mtape_data.log_record_ptr;		/* set pointer to move data from */
      375 	call MOVE_TO_USER;				/* give the user his data */
      376 	go to read_return;
      377 
      378 READ_TYPE (3):					/* Process "D/DB" formated records */
      379 	if mtape_data.remain < RCW_LENGTH then		/* in case we have mod 4 padded block */
      380 	     call GET_NXT_RECORD;			/* go read next block */
      381 	do while (tape_blk (mtape_data.processed + 1) = mtape_data.padding_char);
      382 	     call GET_NXT_RECORD;			/* if rcw is pad, get next block */
      383 	end;
      384 	on conversion call INV_DESC;			/* if error converting rcw */
      385 	crl = binary (db_record.rcw, 21);		/* compute record length */
      386 	revert conversion;				/* revert conversion condition handling */
      387 	move_len = crl - RCW_LENGTH;
      388 	move_ptr = addr (db_record.rdata);		/* set pointer to move data from */
      389 	call MOVE_TO_USER;				/* give the user his data */
      390 	go to read_return;
      391 
      392 READ_TYPE (4):					/* Process "S/SB" formated records */
      393 	if mtape_data.remain < SCW_LENGTH then		/* in case we have mod 4 padded block */
      394 	     call GET_NXT_RECORD;			/* go read next block */
      395 	term = "0"b;				/* reset terminate condition */
      396 	on conversion call INV_DESC;			/* establish on unit for converting seg descriptors */
      397 	do n_segs = 1 by 1 while (^term);		/* 1 record may be made up of several segments and blocks */
      398 	     call CONVERT_DESC;			/* convert segment descriptor */
      399 	     if n_segs = 1 then			/* if first pass through */
      400 		do while (desc_type ^= SEG_B_E & desc_type ^= SEG_B_NE); /* make sure we get new record */
      401 		mtape_data.remain = mtape_data.remain - crl;
      402 		mtape_data.log_record_ptr = addr (sb_record.nxt_lrec);
      403 		if mtape_data.remain <= 0 then	/* Do we have to read in a new block? */
      404 		     call GET_NXT_RECORD;
      405 		call CONVERT_DESC;
      406 	     end;
      407 	     move_ptr = addr (sb_record.rdata);		/* set ptr to move data */
      408 	     call MOVE_TO_USER;			/* give the user his data */
      409 	     if desc_type = SEG_B_E | desc_type = SEG_NB_E then /* end of the record? */
      410 		term = "1"b;			/* yes, set terminate condition */
      411 	     else if mtape_data.remain <= 0 then	/* No, New segment in next block? */
      412 		call GET_NXT_RECORD;		/* yes, do it */
      413 	end;
      414 	revert conversion;
      415 
      416 read_return:
      417 	mtape_data.arg_rec_len = rec_len;		/* give the user the length of the record */
      418 	if code = 0 then				/* if no error but.. */
      419 	     if long_record then			/* we had a longer record than the users buffer */
      420 		code = error_table_$long_record;	/* tell him about it */
      421 	arg_code = code;				/* return error code */
      422 	return;
      423 
      424 /* write - entry to write format specific logical records into the current file */
      425 
      426 write: entry (arg_mtdp, arg_code);
      427 
      428 	mtdp = arg_mtdp;				/* Copy arguments */
      429 	buf_ptr = mtape_data.arg_buf_ptr;
      430 	buf_len = mtape_data.arg_buf_len;
      431 	code = 0;
      432 	if buf_ptr = null then do;			/* User wants to flush out buffers */
      433 	     if mtape_data.processed > mtape_data.buffer_offset then /* if we have some unwritten data */
      434 		call WRITE_BLOCK;			/* write a short block */
      435 	     call mtape_$flush_buffers (mtdp, code);	/* write out all queued buffers */
      436 	     if code ^= 0 then			/* if some error writing data */
      437 		if code = error_table_$eov_on_write then do; /* Is it end of tape? */
      438 		     call LOAD_PTRS;		/* load up structure pointers */
      439 		     call EOV_ON_WRITE (WRITING);	/* Go close out volume and initiate volume switch */
      440 		end;
      441 	     go to write_return;			/* return to user */
      442 	end;
      443 	go to WRITE_TYPE (mtape_data.ad_file_format);	/* process depending on file format */
      444 
      445 WRITE_TYPE (1):					/* Write "U" formated records */
      446 	call LONG_RECORD_CHECK (buf_len, "0"b);		/* check for long record */
      447 	move_len = buf_len;				/* writes entire block */
      448 	move_ptr = mtape_data.log_record_ptr;		/* set pointer to move data to */
      449 	call MOVE_TO_BUFFER (0, 0);			/* move the data to the tape buffer */
      450 	go to write_return;
      451 
      452 WRITE_TYPE (2):					/* Write "F/FB" formated records */
      453 	call LONG_RECORD_CHECK (buf_len, "1"b);		/* check for long record */
      454 	if mtape_data.record_size > mtape_data.remain then/* don't try to move more than we have */
      455 	     call WRITE_BLOCK;			/* write out the current block */
      456 	move_len = buf_len;
      457 	move_ptr = mtape_data.log_record_ptr;		/* set pointer to move data from */
      458 	call MOVE_TO_BUFFER (0, 1);			/* give the user his data */
      459 	go to write_return;
      460 
      461 WRITE_TYPE (3):					/* Write "D/DB" formated records */
      462 	call LONG_RECORD_CHECK (buf_len, "1"b);		/* check for long record */
      463 	if buf_len + RCW_LENGTH > mtape_data.remain then	/* if record won't fit in this block */
      464 	     call WRITE_BLOCK;			/* write out the current block */
      465 	move_len = buf_len;				/* set record length */
      466 	pic4 = move_len + RCW_LENGTH;			/* convert RCW to ASCII */
      467 	db_record.rcw = pic4;			/* set up RCW */
      468 	move_ptr = addr (db_record.rdata);		/* set pointer to move data from */
      469 	call MOVE_TO_BUFFER (RCW_LENGTH, RCW_LENGTH);	/* copy the users data  */
      470 	go to write_return;
      471 
      472 WRITE_TYPE (4):					/* Write "S/SB" formated records */
      473 	call LONG_RECORD_CHECK (buf_len, "1"b);		/* check for long record */
      474 	bytes_remaining = buf_len;			/* set user buffer extents */
      475 	bytes_processed = 0;
      476 	term = "0"b;				/* reset terminate condition */
      477 	do n_segs = 1 by 1 while (^term);		/* 1 record may be made up of several segments and blocks */
      478 	     if bytes_remaining <= mtape_data.remain - SCW_LENGTH then do; /* will record fit in this block? */
      479 		term = "1"b;			/* yes, set terminate condition */
      480 		if n_segs = 1 then			/* entire record fit in 1st block? */
      481 		     desc_type = SEG_B_E;		/* Yes, record begins and ends in this segment */
      482 		else desc_type = SEG_NB_E;		/* No, record ends but does not begin in this segment */
      483 		move_len = bytes_remaining;		/* move last part (or all) of record */
      484 	     end;
      485 	     else do;				/* No, record will not fit in current block */
      486 		if n_segs = 1 then			/* is this the first record segment? */
      487 		     desc_type = SEG_B_NE;		/* Yes, record begins but does not end in this segment */
      488 		else desc_type = SEG_NB_NE;		/* No, record neither begins nor ends in this segment */
      489 		move_len = mtape_data.remain - SCW_LENGTH; /* use rest of or entire block */
      490 		bytes_remaining = bytes_remaining - move_len; /* decrement remaining bytes to process */
      491 	     end;
      492 	     bytes_processed = bytes_processed + move_len;/* add up total moved so far */
      493 	     pic4 = move_len + SCW_LENGTH;		/* convert byte count for scw */
      494 	     move_ptr = addr (sb_record.rdata);		/* set ptr to move data */
      495 	     pic1 = desc_type;			/* convert descriptor */
      496 	     sb_record.scw.rec_len = pic4;		/* set record length */
      497 	     sb_record.scw.span_indicator = pic1;	/* and span indicator */
      498 	     call MOVE_TO_BUFFER (SCW_LENGTH, SCW_LENGTH + 1); /* copy the users data */
      499 	     buf_ptr = addr (based_lrec_index (bytes_processed + 1)); /* increment users buffer ptr */
      500 	end;
      501 
      502 write_return:
      503 	arg_code = code;				/* return error code */
      504 	return;
      505 
      506 /* order - entry to process format specific control orders not recognized by mtape_ */
      507 
      508 order: entry (arg_mtdp, arg_order_name, arg_info_ptr, arg_io_call_infop, arg_code);
      509 
      510 	call SETUP;				/* initialize our enviornment */
      511 	order_name = arg_order_name;
      512 	info_ptr = arg_info_ptr;
      513 
      514 	arg_code = error_table_$no_operation;		/* ANSI PFM has no local control operations */
      515 	return;
      516 
      517 /* decode_file_labels - entry to extract info contained in file labels, and fill in file_info structure */
      518 
      519 decode_file_labels: entry (arg_mtdp, arg_lr_ptr, arg_labno, arg_type, arg_code);
      520 
      521 	call SETUP;				/* initialize our enviornment */
      522 	lr_ptr = arg_lr_ptr;
      523 
      524 	on conversion begin;			/* set up handler for conversion errors */
      525 	     code = error_table_$invalid_label_format;	/* set appropriate error code */
      526 	     call mtape_$error (mtdp, code,
      527 		"^/Converting ANSI ^a^d label record to binary. Label contents:^/""^a""",
      528 		substr (based_label_record, 1, 3), arg_labno, based_label_record);
      529 	     go to dfl_return;
      530 	end;
      531 
      532 	ansi_hdr1P, ansi_hdr2P = mtape_label_record.lab_ptr; /* set up both template ptrs */
      533 	go to LTYPE (arg_type);			/* decode appropriate label type */
      534 
      535 LTYPE (1):					/* Beginning of file label */
      536 	if ansi_hdr1.label_id = ANSI_L1_ID (ANSI_HDR1) then do;
      537 						/* ANSI HDR1 label */
      538 	     if arg_labno ^= 1 then
      539 		call mtape_$error (mtdp, error_table_$invalid_label_format, "
      540 Additional ANSI HDR1 label found while looking for ANSI ^a^d label
      541 for file ^a.  Read continues using:
      542 ""^a""",
      543 		     substr (based_label_record, 1, 3), arg_labno,
      544 		     mtape_file_info.file_id,
      545 		     based_label_record);
      546 
      547 	     mtape_file_info.file_id = ansi_hdr1.file_id;
      548 	     mtape_file_info.file_set_id = ansi_hdr1.set_id;
      549 	     mtape_file_info.section = binary (ansi_hdr1.section, 17);
      550 	     mtape_file_info.seq_number = binary (ansi_hdr1.sequence, 17);
      551 	     mtape_file_info.generation = binary (ansi_hdr1.generation, 17);
      552 	     mtape_file_info.gen_version = binary (ansi_hdr1.version, 17);
      553 	     mtape_file_info.creation_date = ansi_hdr1.creation;
      554 	     mtape_file_info.expiration_date = ansi_hdr1.expiration;
      555 	     if ansi_hdr1.system = ANSI_SYS_CODE then	/* tape recorded by this module? */
      556 		mtape_file_info.native_file = "1"b;	/* yes, set flag */
      557 	end;
      558 	else if ansi_hdr2.label_id = ANSI_L2_ID (ANSI_HDR2) then do;
      559 
      560 	     if arg_labno ^= 2 then			/* ANSI HDR2 label */
      561 		call mtape_$error (mtdp, error_table_$invalid_label_format, "
      562 Additional ANSI HDR2 label found while looking for ANSI ^a^d label
      563 for file ^a.  Read continues using:
      564 ""^a""",
      565 		     substr (based_label_record, 1, 3), arg_labno,
      566 		     mtape_file_info.file_id, based_label_record);
      567 
      568 	     mtape_file_info.buffer_offset = binary (ansi_hdr2.buffer_offset, 17); /* Fill in rest of file info */
      569 	     if mtape_file_info.buffer_offset = 0 then	/* if not using buffer offsets.. */
      570 		mtape_file_info.native_file = "0"b;	/* revert this flag */
      571 	     mtape_file_info.block_size = binary (ansi_hdr2.blklen, 21);
      572 	     mtape_file_info.record_size = binary (ansi_hdr2.reclen, 21);
      573 	     temp_fmt = ansi_hdr2.format;		/* get first character of format */
      574 	     mtape_file_info.length_mode = NON_MOD_FOUR;	/* set special length mode as default */
      575 	     if mtape_vol_set.volume_check < NON_MULT_VOLUME then do; /* check Multics specific stuff */
      576 		mtape_file_info.hdw_mode = MTAPE_HWM_NINE; /* set nine mode, as default */
      577 		mtape_file_info.conversion = MTAPE_NO_CONVERSION; /* set no conversion as default */
      578 		if ansi_hdr2.system_use.blocked ^= " " then do;	/* this field moved with mtape_, allow old ones */
      579 		     if ansi_hdr2.system_use.blocked = "1" then	/* check blocking attribute */
      580 			temp_fmt = rtrim (temp_fmt) || "B";
      581 		     go to set_mode (binary (ansi_hdr2.system_use.mode, 17)); /* set HDW and conversion modes */
      582 		end;
      583 		else do;				/* handle the pre-mtape_ system_use blocking and format */
      584 		     if old_ansi_hdr2_system_use.blocked = "1" then	/* check blocking attribute */
      585 			temp_fmt = rtrim (temp_fmt) || "B";
      586 		     go to set_mode (binary (old_ansi_hdr2_system_use.mode, 17)); /* set HDW and conversion modes */
      587 		end;
      588 
      589 set_mode (3):					/* ASCII, binary mode */
      590 		mtape_file_info.hdw_mode = MTAPE_HWM_BIN;
      591 		go to set_mode_end;
      592 
      593 set_mode (2):					/* EBCDIC, nine track mode */
      594 		mtape_file_info.conversion = MTAPE_CV_EBCDIC; /* convert EBCDIC <==> ASCII */
      595 
      596 set_mode (1):					/* ASCII, nine track mode (default) */
      597 set_mode_end:
      598 	     end;
      599 	     mtape_file_info.file_code = temp_fmt;	/* set file code */
      600 	     do i = 0 to hbound (ANSI_FORMAT_CODES, 1);	/* set the file format */
      601 		if temp_fmt = ANSI_FORMAT_CODES (i) then/* found it */
      602 		     mtape_file_info.file_format = i;
      603 	     end;
      604 	end;
      605 	else if substr (based_label_record, 1,
      606 	     length (U_LABEL_ID (arg_type))) = U_LABEL_ID (arg_type) then /* user labels present */
      607 	     mtape_file_info.user_labels_present = "1"b;
      608 	return;
      609 
      610 LTYPE (2):					/* End of volume label */
      611 
      612 	if arg_labno = 1 then			/* if ANSI EOV1 label */
      613 	     mtape_file_info.block_count = binary (ansi_hdr1.blkcnt, 35); /* extract block count */
      614 	else if arg_labno = 2 then do;		/* if ANSI EOV2 label */
      615 	     if mtape_vol_set.volume_check < NON_MULT_VOLUME then do; /* check Multics specific stuff */
      616 		if mtape_vol_set.next_vs_ptr = null then do; /* if no VS structure */
      617 		     call mtape_$alloc (mtdp, MTAPE_ALLOC_VS, mtape_data.vs_tail, 0, nvp);
      618 		     mtape_data.vs_tail = nvp;
      619 		end;
      620 		else nvp = mtape_vol_set.next_vs_ptr;
      621 		if nvp -> mtape_vol_set.volume_name ^=
      622 		     ansi_hdr2.system_use.next_volname then
      623 		     nvp -> mtape_vol_set.volume_name = ansi_hdr2.system_use.next_volname;
      624 	     end;
      625 	end;
      626 	else if substr (based_label_record, 1,
      627 	     length (U_LABEL_ID (arg_type))) = U_LABEL_ID (arg_type) then do; /* user labels present */
      628 	     mtape_file_info.user_labels_present = "1"b;
      629 	     call CHECK_USER_LABELS (EOV_LABEL);
      630 	end;
      631 
      632 	return;
      633 
      634 LTYPE (3):					/* End of file label */
      635 						/* if ANSI EOF1 label */
      636 	if ansi_hdr1.label_id = ANSI_L1_ID (ANSI_EOF1) then do;
      637 	     if arg_labno ^= 1 then
      638 		call mtape_$error (mtdp, error_table_$invalid_label_format, "
      639 Additional ANSI EOF1 label found while looking for ANSI ^a^d label
      640 for file ^a.  Read continues using:
      641 ""^a""",
      642 		     substr (based_label_record, 1, 3), arg_labno,
      643 		     mtape_file_info.file_id, based_label_record);
      644 
      645 	     mtape_file_info.block_count = binary (ansi_hdr1.blkcnt, 35); /* extract block count */
      646 	     mtape_file_info.gen_version = binary (ansi_hdr1.version, 17); /* save in case modified | extended file */
      647 	end;
      648 	else if substr (based_label_record, 1,
      649 	     length (U_LABEL_ID (arg_type))) = U_LABEL_ID (arg_type) then /* user labels present */
      650 
      651 	     mtape_file_info.user_labels_present = "1"b;
      652 
      653 
      654 dfl_return:
      655 	arg_code = code;
      656 	return;
      657 
      658 /* encode_file_labels - entry to fill in file labels from info obtained from file_info structure */
      659 
      660 encode_file_labels: entry (arg_mtdp, arg_lr_ptr, arg_labno, arg_type, arg_convert, arg_code);
      661 
      662 	call SETUP;				/* initialize our enviornment */
      663 	lr_ptr = arg_lr_ptr;
      664 	based_label_record = "";			/* initialize to blanks first */
      665 	arg_convert = MTAPE_CV_UC_ASCII;		/* set conversion to uper case ascii */
      666 	if arg_labno = 1 then do;			/* init HDR1/EOV1/EOF1 label */
      667 	     if arg_type = EOV_LABEL then		/* if writing EOV sequence */
      668 		if mtape_vol_set.next_vs_ptr = null then do; /* and no next volume */
      669 		     call mtape_$user_query (mtdp, Q_NO_NEXT_VOLUME, code); /* ask user for a new one */
      670 		     if code ^= 0 then		/* if he didn't want to continue */
      671 			go to efl_return;		/* forget it */
      672 		end;
      673 	     ansi_hdr1P = mtape_label_record.lab_ptr;
      674 	     ansi_hdr1.label_id = ANSI_L1_ID (arg_type);	/* Now fill it in */
      675 						/* Use substr to move the uneven length string */
      676 	     ansi_hdr1.file_id = substr (mtape_file_info.file_id, 1,
      677 		maxlength (ansi_hdr1.file_id));
      678 	     ansi_hdr1.set_id = substr (mtape_file_info.file_set_id, 1,
      679 		maxlength (ansi_hdr1.set_id));
      680 	     pic4 = mtape_file_info.section;
      681 	     ansi_hdr1.section = pic4;
      682 	     pic4 = mtape_file_info.seq_number;
      683 	     ansi_hdr1.sequence = pic4;
      684 	     pic4 = mtape_file_info.generation;
      685 	     ansi_hdr1.generation = pic4;
      686 	     pic2 = mtape_file_info.gen_version;
      687 	     ansi_hdr1.version = pic2;
      688 	     ansi_hdr1.creation = mtape_file_info.creation_date;
      689 	     ansi_hdr1.expiration = mtape_file_info.expiration_date;
      690 	     ansi_hdr1.access = " ";			/* Always unlimited access */
      691 	     if arg_type > BOF_LABEL then do;		/* if EOV/EOF label */
      692 		pic6 = mtape_file_info.block_count;	/* fill in the block count */
      693 		ansi_hdr1.blkcnt = pic6;
      694 	     end;
      695 	     else ansi_hdr1.blkcnt = "000000";		/* used only for EOF/EOV1 records */
      696 	     ansi_hdr1.system = ANSI_SYS_CODE;
      697 	     return;
      698 	end;
      699 	else if arg_labno = 2 then do;		/* init HDR2/EOV2/EOF2 label */
      700 	     ansi_hdr2P = mtape_label_record.lab_ptr;
      701 	     ansi_hdr2.label_id = ANSI_L2_ID (arg_type);	/* Now fill it in */
      702 	     ansi_hdr2.format = substr (ANSI_FORMAT_CODES (mtape_file_info.file_format), 1, 1);
      703 	     pic5 = mtape_file_info.block_size;
      704 	     ansi_hdr2.blklen = pic5;
      705 	     if mtape_file_info.record_size <= MAX_ANSI_RECORD_SIZE then do; /* if it will fit */
      706 		pic5 = mtape_file_info.record_size;
      707 		ansi_hdr2.reclen = pic5;
      708 	     end;
      709 	     else ansi_hdr2.reclen = "00000";
      710 	     if substr (ANSI_FORMAT_CODES (mtape_file_info.file_format), 2, 1) ^= "" then
      711 		ansi_hdr2.system_use.blocked = "1";
      712 	     else ansi_hdr2.system_use.blocked = "0";
      713 	     if arg_type = EOV_LABEL then do;		/* if at EOV */
      714 		if mtape_vol_set.next_vs_ptr ^= null then /* and if we have another volume */
      715 		     ansi_hdr2.system_use.next_volname =
      716 			mtape_vol_set.next_vs_ptr -> mtape_vol_set.volume_name;
      717 		arg_convert = MTAPE_NO_CONVERSION;	/* don't convert volume id */
      718 	     end;
      719 	     if mtape_file_info.hdw_mode = MTAPE_HWM_BIN then /* if recording in binary mode */
      720 		ansi_hdr2.system_use.mode = "3";
      721 	     else if mtape_file_info.conversion = MTAPE_CV_EBCDIC then /* if recording EBCDIC data */
      722 		ansi_hdr2.system_use.mode = "2";
      723 	     else ansi_hdr2.system_use.mode = "1";	/* Standard ASCII NINE mode */
      724 	     pic2 = mtape_file_info.buffer_offset;
      725 	     ansi_hdr2.buffer_offset = pic2;
      726 	     return;
      727 	end;
      728 	else if mtape_open_info.label_entry_present then	/* if writing user labels */
      729 	     if arg_labno < 12 then do;		/* and not at max of 9 yet */
      730 		uln = arg_labno - 2;		/* user labels start at 1 */
      731 		user_label_data = "";
      732 		call mtape_open_info.user_label (mtape_data.iocb_ptr, user_label_data, uln, arg_type,
      733 		     mtape_file_info.section, code);	/* call the user label routine */
      734 		if code ^= 0 then			/* if error indicated from user routine */
      735 		     if code = error_table_$end_of_info then /* but it is normal termination */
      736 			go to efl_return;		/* return with end of info indication */
      737 		     else do;			/* some other error report it */
      738 			call mtape_$error (mtdp, code,
      739 			     "^/Calling the user label processing routine to process the ^a^d label record.",
      740 			     U_LABEL_ID (arg_type), uln);
      741 			code = error_table_$end_of_info; /* force user label termination */
      742 			go to efl_return;
      743 		     end;
      744 		pic1 = uln;			/* convert label number to ascii */
      745 		based_label_record = U_LABEL_ID (arg_type) || pic1 || user_label_data; /* form completed user label */
      746 		go to efl_return;
      747 	     end;
      748 	code = error_table_$end_of_info;		/* terminate label processing */
      749 
      750 efl_return:
      751 	arg_code = code;				/* copy error code */
      752 	return;
      753 
      754 /* CHECK_NEW_FILE_SECTION - internal procedure to check consistency of new file section */
      755 
      756 CHECK_NEW_FILE_SECTION: proc;
      757 
      758 dcl  per_file_overlay char (ov_len) based (addr (mtape_file_info.per_file_info));
      759 dcl  ov_len fixed bin;
      760 dcl  pp ptr;
      761 
      762 	code = 0;
      763 	fi_ptr = mtape_file_info.next_fi_ptr;		/* file info will be allocated if null */
      764 	call pfm_utils_$read_file_labels (mtdp, fi_ptr, vs_ptr, label_type, code); /* read new file sect. HDR labels */
      765 	if code ^= 0 then
      766 	     return;
      767 	if label_type ^= BOF_LABEL then do;		/* error if not header labels */
      768 	     code = error_table_$bad_file;
      769 	     call mtape_$error (mtdp, code,
      770 		"^/^[EOV^;EOF^] file label found where BOF label record expected", label_type);
      771 	     return;
      772 	end;
      773 	call SET_FILE_ATTRIBUTES;			/* set up missing pieces */
      774 	pp = mtape_file_info.prev_fi_ptr;		/* get prev file ptr */
      775 	ov_len = (binary (rel (addr (mtape_file_info.per_section_info))) -
      776 	     binary (rel (addr (mtape_file_info.per_file_info)))) * 4;
      777 	if mtape_file_info.record_size ^= pp -> mtape_file_info.record_size then /* if record sizes */
      778 	     if mtape_file_info.record_size = 0 then	/* are ^=, but new section = 0 */
      779 		pp -> mtape_file_info.record_size = 0;	/* make 1st section = 0 too */
      780 	if mtape_file_info.section ^= pp -> mtape_file_info.section + 1 |
      781 	     per_file_overlay ^= addr (pp -> mtape_file_info.per_file_info) -> per_file_overlay then do;
      782 	     code = error_table_$bad_file;		/* set an appropriate error code */
      783 	     call mtape_$error (mtdp, code,
      784 		"^/New file section for File ""^a"" on volume ""^a"" is inconsistent with previous section",
      785 		pp -> mtape_file_info.file_id, mtape_vol_set.volume_id);
      786 	end;
      787 	mtape_data.prev_block_no = 0;			/* clear out block counter */
      788 	call mtape_$set_mode (mtdp, "data", mtape_data.hdw_mode, null, code); /* set hardware mode */
      789 
      790      end CHECK_NEW_FILE_SECTION;
      791 
      792 /* CHECK_USER_LABELS - procedure to check if user labels and a user label entry exist */
      793 
      794 CHECK_USER_LABELS: proc (htype);
      795 
      796 dcl  htype fixed bin;
      797 dcl  flrp ptr;
      798 
      799 	if mtape_file_info.user_labels_present then	/* if file contains user labels */
      800 	     if mtape_open_info.label_entry_present then do; /* and user wants to see them */
      801 		if htype > BOF_LABEL then		/* trailer labels? */
      802 		     flrp = mtape_file_info.first_file_trail_ptr; /* yes, search trailer list */
      803 		else flrp = mtape_file_info.first_file_lab_ptr; /* search header list */
      804 		do lr_ptr = flrp repeat mtape_label_record.next_lab_ptr /* search up to 1st user label */
      805 		     while (substr (based_label_record, 1, 1) ^= "U");
      806 		end;
      807 		do lr_ptr = lr_ptr repeat mtape_label_record.next_lab_ptr
      808 		     while (lr_ptr ^= null);		/* send him all labels */
      809 		     user_label_data = substr (based_label_record, 5); /* copy user data */
      810 		     i = fixed (substr (based_label_record, 4, 1), 17); /* get label number */
      811 		     call mtape_open_info.user_label (mtape_data.iocb_ptr, /* call the user label routine */
      812 			user_label_data, i, htype, mtape_file_info.section, (0)); /* ignore error code */
      813 		end;
      814 	     end;
      815 
      816      end CHECK_USER_LABELS;
      817 
      818 /* CHECK_VERSION - internal procedure to check struture version numbers */
      819 
      820 CHECK_VERSION: proc (s_ptr, req_version, struc_name);
      821 
      822 dcl  s_ptr ptr;
      823 dcl  req_version char (8);
      824 dcl  struc_name char (32);
      825 
      826 dcl  1 version_check based (s_ptr) aligned,		/* generic structure to check verison number */
      827        2 version char (8);
      828 
      829 	if version_check.version ^= req_version then do;	/* they do not match */
      830 	     code = error_table_$unimplemented_version;	/* set error code */
      831 	     call mtape_$error (mtdp, code,
      832 		"^/^a: Expecting ""^a"" version for ^a structure. Version recorded in received structure is ""^a"".",
      833 		myname, req_version, struc_name, version_check.version);
      834 	     go to pfm_init_return;			/* take non-local goto and return to caller */
      835 	end;
      836 
      837      end CHECK_VERSION;
      838 
      839 /* CHECK_VOL_LABELS - internal procedure to read volume label(s) of a known ANSI volume */
      840 
      841 CHECK_VOL_LABELS: proc (ridx);
      842 
      843 dcl  ridx fixed bin;
      844 
      845 	call mtape_$order (mtdp, "rew", 0, null, code);	/* Rewind to load point */
      846 	if code ^= 0 then do;
      847 	     call mtape_$error (mtdp, code,
      848 		"While rewinding volume ^a prior to reading volume label(s)", mtape_vol_set.volume_id);
      849 	     return;
      850 	end;
      851 	nlp = mtape_vol_set.first_vl_ptr;		/* arm the label record ptr */
      852 	ansi_vol1P = mtape_data.tlb -> mtape_label_record.lab_ptr; /* get pointer to VOL1 structure */
      853 	term = "0"b;				/* get us through the first pass */
      854 	do i = 1 by 1 while (^term);			/* read up to HDR1 label */
      855 	     call mtape_$read_label (mtdp, mtape_data.tlb, code); /* read label record */
      856 	     if code ^= 0 then do;
      857 		call mtape_$error (mtdp, code,
      858 		     "Attempting to read ANSI volume label record from volume ^a.", mtape_vol_set.volume_id);
      859 		return;
      860 	     end;
      861 	     if ansi_vol1.label_id = ANSI_VOL1 then do;	/* if this is VOL1 label */
      862 		if ansi_vol1.owner_id.mult_id = MULTICS_ANSI_VERSION then /* only true if recorded by mtape_ */
      863 		     ridx = MTAPE_VOLUME;
      864 		else ridx = NON_MULT_VOLUME;		/* volume recorded by other vendor */
      865 	     end;
      866 	     else if ansi_vol1.label_id = ANSI_L1_ID (BOF_LABEL) then do; /* check if HDR1 label */
      867 		term = "1"b;			/* this is the place to stop reading labels */
      868 		mtape_vol_set.number_of_vol_labels = i - 1; /* set number of vol labels */
      869 		ansi_hdr1P = ansi_vol1P;		/* check expiration date of first file */
      870 		if ridx = NON_MULT_VOLUME then	/* check if recorded by tape_ansi_ */
      871 		     if substr (ansi_hdr1.system, 1, 12) = substr (ANSI_SYS_CODE, 1, 12) then
      872 			ridx = MULT_PRIOR_VOLUME;	/* yes, tape recorded by tape_ansi_ */
      873 		mtape_vol_set.first_file_unexpired = pfm_utils_$label_unexpired (ansi_hdr1.expiration);	/* check expiry date */
      874 	     end;
      875 	     if ^term then do;			/* link in this label  (if not HDR1) */
      876 		if nlp = null then			/* if no label record structure exists.. */
      877 		     call pfm_utils_$init_label_record (mtdp, mtape_vol_set.last_vl_ptr,
      878 			mtape_vol_set.first_vl_ptr, lr_ptr, LABEL_LENGTH);
      879 		else lr_ptr = nlp;			/* it does exist, use it */
      880 		based_label_record = mtape_data.tlb -> mtape_label_record.lab_ptr -> based_label_record;
      881 		nlp = mtape_label_record.next_lab_ptr;	/* update pointer for next label */
      882 	     end;
      883 	end;
      884 	call mtape_$order (mtdp, "bsr", 1, null, code);	/* backspace in front of HDR1 */
      885 	if code ^= 0 then
      886 	     call mtape_$error (mtdp, code,
      887 		"Attempting to backspace over ^a label record of volume ^a.",
      888 		ansi_vol1.label_id, mtape_vol_set.volume_id);
      889 
      890      end CHECK_VOL_LABELS;
      891 
      892 /* CONVERT_DESC - internal procedure to convert RDW for S/SB formated records */
      893 
      894 CONVERT_DESC: proc;
      895 
      896 	do while (sb_record.scw.span_indicator = mtape_data.padding_char);
      897 	     call GET_NXT_RECORD;			/* if scw is pad, get next block */
      898 	end;
      899 	desc_type = binary (sb_record.scw.span_indicator, 17); /* convert the span indicator */
      900 	crl = binary (sb_record.scw.rec_len, 21);	/* compute the record length */
      901 	move_len = crl - SCW_LENGTH;
      902 	if desc_type < SEG_B_E | desc_type > SEG_NB_E then/* invalid descriptor */
      903 	     call INV_DESC;
      904 
      905      end CONVERT_DESC;
      906 
      907 /* EOV_ON_WRITE - internal procedure to close out volume and initiate volume switch */
      908 
      909 EOV_ON_WRITE: proc (who_called);
      910 
      911 dcl  who_called bit (1) aligned;
      912 
      913 	call pfm_utils_$write_file_labels (mtdp, EOV_LABEL, code); /* yes, write out the EOV labels */
      914 	if code ^= 0 then return;			/* some problem with writing labels, give up */
      915 	mtape_vol_set.volume_end = "0"b;		/* reset volume end flag */
      916 	nvp = mtape_vol_set.next_vs_ptr;		/* copy pointer, in case its null */
      917 	call mtape_$volume_switch (mtdp, nvp, code);	/* do the magic */
      918 	if code ^= 0 then do;			/* could'nt do the switch */
      919 	     call mtape_$error (mtdp, code,
      920 		"Couldn't mount new volume at volume switch time");
      921 	     return;
      922 	end;
      923 	vs_ptr = mtape_data.vs_current;		/* point to new volume */
      924 	call INIT_VOL_LABELS;			/* init volume labels */
      925 	if code ^= 0 then return;
      926 	fi_ptr = null;				/* this will ensure we get file_info struct allocated */
      927 	call pfm_utils_$setup_file (mtdp, fi_ptr, "1"b);	/* set up new file section structure */
      928 	call pfm_utils_$write_file_labels (mtdp, BOF_LABEL, code); /* and write out the section header labels */
      929 	if code ^= 0 then return;			/* if errors.. */
      930 	mtape_data.prev_block_no = 0;			/* clear out block counter */
      931 	if who_called = WRITING then do;		/* if actually writing data */
      932 	     call mtape_$set_mode (mtdp, "data", mtape_data.hdw_mode, null, code); /* set hardware mode */
      933 	     if code ^= 0 then return;
      934 	     call mtape_$set_mode (mtdp, "length", mtape_data.length_mode, null, code); /* and special len mode */
      935 	     if code ^= 0 then return;
      936 	     if mtape_data.cur_buf_idx > lbound (mtape_data.buf_ptrs, 1) then do; /* if we have suspened bufs */
      937 		if mtape_data.native_file then do;	/* if writing with buffer offsets */
      938 		     do i = lbound (all_buf_ptrs, 1) to mtape_data.cur_buf_idx - 1; /* adjust block numbers */
      939 			all_buf_ptrs (i) -> native_bo_contents.block_number = i;
      940 		     end;
      941 		end;
      942 		call mtape_$flush_buffers (mtdp, code); /* flush out any suspended buffers */
      943 	     end;
      944 	end;
      945 
      946      end EOV_ON_WRITE;
      947 
      948 /* GET_NXT_RECORD - subroutine to position to next logical record, reading nxt tape block if necessary */
      949 
      950 GET_NXT_RECORD: proc;
      951 
      952 dcl  term bit (1) aligned;
      953 dcl  (block_no, i, j) fixed bin (21);
      954 
      955 	term = "0"b;
      956 	do while (^term);				/* in case we have to read 1 block of new file section */
      957 	     call mtape_$read_block (mtdp, code);	/* so read it in */
      958 	     if code ^= 0 then			/* if some error */
      959 		if code = error_table_$end_of_info then do; /* if EOF, read trailer */
      960 		     call LOAD_PTRS;		/* Load up structure pointers */
      961 		     call pfm_utils_$read_file_labels (mtdp, fi_ptr, vs_ptr, label_type, fl_code);
      962 		     if fl_code ^= 0 then do;		/* some problem reading labels, abort */
      963 			code = fl_code;
      964 			go to read_return;		/* Take non-local goto and return */
      965 		     end;
      966 		     if label_type = EOF_LABEL then	/* is this really end of the data file? */
      967 			go to read_return;		/* Take non-local goto and return */
      968 		     else if label_type = EOV_LABEL then do; /* No, volume switch has already been done */
      969 			call CHECK_NEW_FILE_SECTION;	/* go check out new file section labels */
      970 			if code ^= 0 then		/* some error */
      971 			     go to read_return;	/* Take non-local goto and return */
      972 		     end;
      973 		     else do;			/* if label_type = BOF, this is error */
      974 			code = error_table_$bad_file; /* set appropriate error code */
      975 			call mtape_$error (mtdp, code,
      976 			     "^/ANSI HDR1 file label found where EOF1 or EOV1 file label record expected");
      977 			go to read_return;		/* Take non-local goto and return */
      978 		     end;
      979 		end;
      980 		else go to read_return;		/* some other error, let user see what it is */
      981 	     else do;				/* successfully read the block */
      982 		term = "1"b;			/* set terminate condition */
      983 		if mtape_data.native_file then do;	/* tape written by this module? */
      984 		     on illegal_procedure call INV_DEC_DATA; /* if garbage catch it */
      985 		     mtape_data.cur_block.length = native_bo_contents.block_size;
      986 		     block_no = native_bo_contents.block_number; /* convert block number */
      987 		     revert illegal_procedure;
      988 		     if block_no ^= mtape_data.prev_block_no + 1 then do; /* check seq. */
      989 			call mtape_$stop_tape (mtdp, code);
      990 			code = error_table_$data_seq_error; /* set appropriate code */
      991 			call mtape_$error (mtdp, code,
      992 			     "Data block number was: ^d; S/B; ^d", block_no, mtape_data.prev_block_no + 1);
      993 			go to read_return;		/* Take non-local goto and return */
      994 		     end;
      995 		     mtape_data.prev_block_no = block_no; /* save current block number */
      996 		     mtape_data.remain = mtape_data.length - mtape_data.processed; /* reset, based on recorded len */
      997 		end;
      998 		if mtape_data.ad_file_format = 2 then do; /* if F/FB format, check padding */
      999 		     i = mod (mtape_data.remain, mtape_data.record_size);
     1000 		     if i ^= 0 then			/* if block not modulus record size */
     1001 			if verify (substr (tblock, mtape_data.length - i + 1, i), mtape_data.padding_char) = 0 then
     1002 			     mtape_data.length = mtape_data.length - i;
     1003 		     j = divide ((mtape_data.length - mtape_data.processed), mtape_data.record_size, 21);
     1004 		     do i = j to 1 by -1 while (verify (substr (tblock, mtape_data.processed +
     1005 			(i - 1) * mtape_data.record_size, mtape_data.record_size), mtape_data.padding_char) = 0);
     1006 			mtape_data.length = mtape_data.length - mtape_data.record_size; /* wipe record, if all pad */
     1007 		     end;
     1008 		     mtape_data.remain = mtape_data.length - mtape_data.processed; /* recompute remaining chars */
     1009 		end;
     1010 	     end;
     1011 	end;
     1012 
     1013      end GET_NXT_RECORD;
     1014 
     1015 /* INIT_VOL_LABELS - internal procedure to initialize and write the VOL1, UVL1 and dummy HDR1 and EOF1 label records */
     1016 
     1017 INIT_VOL_LABELS: proc;
     1018 
     1019 	if mtape_vol_set.first_file_unexpired then	/* if not expired */
     1020 	     if ^mtape_open_info.force then do;		/* and not ignoring expiration dates */
     1021 		call mtape_$user_query (mtdp, Q_UNEXPIRED_VOLUME, code); /* ask user */
     1022 		if code ^= 0 then return;		/* user does not want labels destroyed */
     1023 	     end;
     1024 
     1025 	call mtape_$order (mtdp, "den", 0, addr (mtape_attach_info.density), code); /* Rewind and set density */
     1026 	if code ^= 0 then do;
     1027 	     call mtape_$error (mtdp, code,
     1028 		"^/While rewinding and setting density to ^d BPI on volume ^a prior to volume initialization",
     1029 		mtape_attach_info.density, mtape_vol_set.volume_id);
     1030 	     return;
     1031 	end;
     1032 
     1033 	nlp = mtape_vol_set.first_vl_ptr;		/* arm the label record ptr */
     1034 	mtape_vol_set.volume_id = mtape_vol_set.volume_name;
     1035 
     1036 	auth_code = authenticate_ ((mtape_vol_set.volume_id));
     1037 	do i = 1 to 2;				/* do it for both the VOL1 and UVL1 labels */
     1038 	     if nlp = null then			/* if no label record structure exists.. */
     1039 		call pfm_utils_$init_label_record (mtdp, mtape_vol_set.last_vl_ptr,
     1040 		     mtape_vol_set.first_vl_ptr, lr_ptr, LABEL_LENGTH);
     1041 	     else lr_ptr = nlp;			/* it does exist, use it */
     1042 	     nlp = mtape_label_record.next_lab_ptr;	/* update pointer for next label */
     1043 	     if i = 1 then do;			/* init VOL1 label */
     1044 		ansi_vol1P = mtape_label_record.lab_ptr;
     1045 		ansi_vol1.label_id = ANSI_VOL1;	/* set label id */
     1046 		ansi_vol1.volume_id = substr (mtape_vol_set.volume_id, 1,
     1047 		     maxlength (ansi_vol1.volume_id));	/* set canonical volume name */
     1048 		ansi_vol1.access = " ";		/* set for unlimited access */
     1049 		ansi_vol1.owner_id.auth_code = auth_code; /* set authentication code for RCP */
     1050 		ansi_vol1.owner_id.mult_id = MULTICS_ANSI_VERSION; /* indicate recorded by mtape_ */
     1051 		ansi_vol1.label_version = LABEL_STANDARD_VERSION; /* set ANSI version */
     1052 	     end;
     1053 	     else do;				/* initialize UVL1 label */
     1054 		ansi_uvl1P = mtape_label_record.lab_ptr;/* set pointer */
     1055 		ansi_uvl1.label_id = ANSI_UVL1;	/* set label ID */
     1056 		ansi_uvl1.auth_code = auth_code;	/* set authentication code */
     1057 		ansi_uvl1.init_date = pfm_utils_$julian_date (""); /* set current date */
     1058 		call system_info_$installation_id (install_id); /* set installation name */
     1059 		ansi_uvl1.installation_id = install_id;
     1060 		ansi_uvl1.user_id = get_group_id_ ();	/* set user name */
     1061 	     end;
     1062 	     call mtape_$write_label (mtdp, lr_ptr, code);/* write it out */
     1063 	     if code ^= 0 then do;			/* if unrecoverable error */
     1064 		call mtape_$error (mtdp, code,
     1065 		     "Attempting to write ANSI ^[VOL1^;UVL1^] label record on volume ^a.",
     1066 		     i, mtape_vol_set.volume_id);
     1067 		return;
     1068 	     end;
     1069 	end;
     1070 	mtape_vol_set.number_of_vol_labels = 2;		/* set this constant */
     1071 	if mtape_vol_set.last_vl_ptr ^= lr_ptr then do;	/* in case there were more labels before */
     1072 	     mtape_vol_set.last_vl_ptr = lr_ptr;	/* truncate the chain */
     1073 	     mtape_label_record.next_lab_ptr = null;
     1074 	end;
     1075 
     1076 /* Now write the dummy HDR1 and EOF1 labels */
     1077 
     1078 	lr_ptr = mtape_data.tlb;
     1079 	based_label_record = ANSI_L1_ID (BOF_LABEL) || DUMMY_LABEL; /* start with HDR1 label */
     1080 	do i = 1 to 2;				/* write 2 labels */
     1081 	     call mtape_$write_label (mtdp, lr_ptr, code);/* write it out */
     1082 	     if code ^= 0 then do;			/* if unrecoverable error */
     1083 		call mtape_$error (mtdp, code,
     1084 		     "^/While initializing volume ^a with dummy ANSI ^[HDR1^;EOF1^] label record",
     1085 		     mtape_vol_set.volume_id, i);
     1086 		return;
     1087 	     end;
     1088 	     call mtape_$order (mtdp, "eof", 2, null, code); /* write 2 EOF marks */
     1089 	     if code ^= 0 then do;
     1090 		call mtape_$error (mtdp, code,
     1091 		     "^/While writing 2 EOFs following dummy ANSI ^[HDR1^;EOF1^] label record on volume ^a",
     1092 		     i, mtape_vol_set.volume_id);
     1093 		return;
     1094 	     end;
     1095 	     substr (based_label_record, 1, 4) = ANSI_L1_ID (EOF_LABEL); /* EOF1 for 2nd iteration */
     1096 	end;
     1097 	mtape_vol_set.volume_density = mtape_attach_info.density; /* reset volume parameters to */
     1098 	mtape_vol_set.volume_type = Volume_ansi_tape;	/* reflect that its an ANSI volume recorded at */
     1099 	mtape_vol_set.volume_check = MTAPE_VOLUME;	/* requested density by mtape_ */
     1100 
     1101 /* Position for writing first file */
     1102 
     1103 	call mtape_$order (mtdp, "rew", 0, null, code);	/* Rewind to load point */
     1104 	if code ^= 0 then do;
     1105 	     call mtape_$error (mtdp, code,
     1106 		"^/While rewinding volume ^a after volume initialization", mtape_vol_set.volume_id);
     1107 	     return;
     1108 	end;
     1109 	call mtape_$order (mtdp, "fsr", 2, null, code);	/* position to write over dummy HDR1 label */
     1110 	if code ^= 0 then
     1111 	     call mtape_$error (mtdp, code,
     1112 		"^/While positioning for writing first file label on volume ^a", mtape_vol_set.volume_id);
     1113 
     1114      end INIT_VOL_LABELS;
     1115 
     1116 /* INV_DEC_DATA - procedure to catch IPR faults which would result if block prefix block serial number
     1117*   and or block number were not in expected packed decimal format */
     1118 
     1119 INV_DEC_DATA: proc;
     1120 
     1121 dcl  blk_prefix_wds (2) fixed bin (35) based (mtape_data.cur_buf_ptr);
     1122 
     1123 	code = error_table_$invalid_file_set_format;
     1124 	call mtape_$error (mtdp, code,
     1125 	     "^/^a ^d block prefix words (^w ^w octal) from packed decimal to binary",
     1126 	     "Attempting to convert block #", mtape_data.phy_block, blk_prefix_wds (1),
     1127 	     blk_prefix_wds (2));
     1128 	go to read_return;				/* take non-local goto and return */
     1129 
     1130      end INV_DEC_DATA;
     1131 
     1132 /* INV_DESC - procedure to catch conversion error and report it */
     1133 
     1134 INV_DESC: proc;
     1135 
     1136 	call LOAD_PTRS;				/* Load structure pointers for exeception processing */
     1137 	code = error_table_$invalid_record_desc;	/* set appropriate error code */
     1138 	call mtape_$error (mtdp, code,
     1139 	     "^/^a ^a ^[R^;S^]CW at record ^d, block ^d, ^[of file section ^d ^;^s^]of file named ""^a"".",
     1140 	     "Converting ANSI", ANSI_FORMAT_CODES (mtape_file_info.file_format), (mtape_data.ad_file_format = 3),
     1141 	     mtape_data.log_record, mtape_data.phy_block, (mtape_file_info.section > 1),
     1142 	     mtape_file_info.section, mtape_file_info.file_id);
     1143 	go to read_return;				/* return to user with error */
     1144 
     1145      end INV_DESC;
     1146 
     1147 /* LOAD_PTRS - procedure to load structure pointers for exeception processing
     1148*   of time critical external entries (read and write) */
     1149 
     1150 LOAD_PTRS: proc;
     1151 
     1152 	vs_ptr = mtape_data.vs_current;		/* load up pertinent structure pointers */
     1153 	fi_ptr = mtape_data.fi_current;
     1154 	maip = mtape_data.attach_info_ptr;
     1155 	moip = mtape_data.open_info_ptr;
     1156 	mpfmip = mtape_data.pfm_info_ptr;
     1157 
     1158      end LOAD_PTRS;
     1159 
     1160 /* LONG_RECORD_CHECK - procedure to check if a requested write of a logical record will fit */
     1161 
     1162 LONG_RECORD_CHECK: proc (length, rec_blk_ck);
     1163 
     1164 dcl  length fixed bin (21);
     1165 dcl  rec_blk_ck bit (1) aligned;
     1166 
     1167 	if rec_blk_ck then do;			/* comparing against record length */
     1168 	     if length > mtape_data.record_size then	/* is it to big */
     1169 		code = error_table_$long_record;	/* yes, set code */
     1170 	end;
     1171 	else if length > mtape_data.block_size then	/* comparing against blk size, will it fit */
     1172 	     code = error_table_$long_record;		/* no, set code */
     1173 	if code ^= 0 then				/* if we have a long record.. */
     1174 	     go to write_return;			/* take non-local goto to write return exit */
     1175 
     1176      end LONG_RECORD_CHECK;
     1177 
     1178 /* MOVE_TO_BUFFER - subroutine to move user data to tape buffer on write,
     1179*   initiating a write of the buffer if full */
     1180 
     1181 MOVE_TO_BUFFER: proc (cwl, min_len);
     1182 
     1183 dcl  cwl fixed bin;					/* control word length */
     1184 dcl  min_len fixed bin;				/* minimum length of next record */
     1185 dcl  pad_chars fixed bin;
     1186 dcl  rcd_pad char (pad_chars) based (addr (tape_blk (mtape_data.processed + move_len + 1)));
     1187 
     1188 	if mtape_data.conversion = MTAPE_CV_EBCDIC then	/* if data recorded in ebcdic.. */
     1189 	     call ascii_to_ebcdic_ (buf_ptr -> based_lrec_data, move_ptr -> based_lrec_data);
     1190 	else move_ptr -> based_lrec_data = buf_ptr -> based_lrec_data; /* move data to tape buffer */
     1191 	if (mtape_data.ad_file_format = 1) | (mtape_data.ad_file_format = 2) then /* If "U" or "F" or "FB" format */
     1192 	     if move_len < mtape_data.record_size then do;/* and record is not fUll */
     1193 		pad_chars = mtape_data.record_size - move_len; /* pad record out with blanks */
     1194 		rcd_pad = copy (" ", pad_chars);
     1195 		if mtape_data.conversion = MTAPE_CV_EBCDIC then /* make them ebcdic blanks */
     1196 		     call ascii_to_ebcdic_ (rcd_pad, rcd_pad); /* if appropriate */
     1197 		move_len = mtape_data.record_size;	/* reflect on all data moved */
     1198 	     end;
     1199 	mtape_data.processed = mtape_data.processed + move_len + cwl; /* add up bytes processed */
     1200 	mtape_data.remain = mtape_data.block_size - mtape_data.processed; /* decrement remaining bytes */
     1201 	if ^mtape_data.file_blocked then		/* if not "FB", "DB", or "SB" format */
     1202 	     call WRITE_BLOCK;			/* write the block out now */
     1203 	else if mtape_data.remain < min_len then	/* if blocked but block full.. */
     1204 	     call WRITE_BLOCK;			/* write the block out now */
     1205 	else mtape_data.log_record_ptr = addr (tape_blk (mtape_data.processed + 1));
     1206 						/* Not blocked, set for next lrec */
     1207 
     1208      end MOVE_TO_BUFFER;
     1209 
     1210 /* MOVE_TO_USER - subroutine to move data from tape buffer to user buffer on read */
     1211 
     1212 MOVE_TO_USER: proc;
     1213 
     1214 	if buf_ptr = null then			/* if caller just wants length.. */
     1215 	     rec_len = rec_len + move_len;		/* thats it */
     1216 	else do;					/* this is a real read */
     1217 	     if ^long_record then do;			/* if we can still fit the data in */
     1218 		if buf_len - move_len < 0 then do;
     1219 		     long_record = "1"b;		/* we have more data than user can take */
     1220 		     move_len = buf_len;		/* move what we can */
     1221 		end;
     1222 		buf_len = buf_len - move_len;		/* and decrement length remaining in users buffer */
     1223 		if move_len > 0 then do;		/* if we have some data to move, move it */
     1224 		     if mtape_data.conversion = MTAPE_CV_EBCDIC then /* tape recorded in ebcdic */
     1225 			call ebcdic_to_ascii_ (move_ptr -> based_lrec_data, buf_ptr -> based_lrec_data);
     1226 		     else buf_ptr -> based_lrec_data = move_ptr -> based_lrec_data; /* move computed of bytes */
     1227 		     rec_len = rec_len + move_len;	/* tell user how long record is anyway */
     1228 		     buf_ptr = addr (based_lrec_index (rec_len + 1)); /* increment users buffer ptr */
     1229 		end;
     1230 	     end;
     1231 	end;
     1232 	mtape_data.processed = mtape_data.processed + crl;
     1233 	mtape_data.remain = mtape_data.cur_block.length - mtape_data.processed;
     1234 	if mtape_data.remain > 0 then
     1235 	     mtape_data.log_record_ptr = addr (tape_blk (mtape_data.processed + 1));
     1236 
     1237      end MOVE_TO_USER;
     1238 
     1239 /* NEED_TO_INIT_VOLUME - function to determine if a tape volume requires initializaton */
     1240 
     1241 NEED_TO_INIT_VOLUME: proc returns (bit (1) aligned);
     1242 
     1243 	if mtape_vol_set.volume_check > NON_MULT_VOLUME then /* if this is not an ANSI volume */
     1244 	     return ("1"b);
     1245 	if mtape_open_info.modify | mtape_open_info.extend then /* if modifying or extending */
     1246 	     return ("0"b);				/* existing file, do not init volume */
     1247 	if ^mtape_data.first_file then do;		/* if the first opening */
     1248 	     if mtape_open_info.seq_number = 1 then	/* or we want file number 1 */
     1249 		return ("1"b);
     1250 	     if mtape_open_info.next_file then		/* or next (first) file */
     1251 		return ("1"b);
     1252 	end;
     1253 	return ("0"b);
     1254 
     1255      end NEED_TO_INIT_VOLUME;
     1256 
     1257 /* SET_FILE_FORMAT - internal procedure to set file format in file info from open data */
     1258 
     1259 SET_FILE_FORMAT: proc;
     1260 
     1261 	temp_fmt = translate (mtape_open_info.file_format, UC, LC);
     1262 						/* file format in upper case */
     1263 	mtape_file_info.file_code = temp_fmt;		/* set file code */
     1264 	do i = 0 to hbound (ANSI_FORMAT_CODES, 1);	/* set the file format */
     1265 	     if temp_fmt = ANSI_FORMAT_CODES (i) then	/* found it */
     1266 		mtape_file_info.file_format = i;
     1267 	end;
     1268 
     1269      end SET_FILE_FORMAT;
     1270 
     1271 /* SET_OPEN_IDX - subroutine to determine what kind of opening this is */
     1272 
     1273 SET_OPEN_IDX: proc;
     1274 
     1275 	if mtape_open_info.open_mode = Sequential_input then do; /* input operation? */
     1276 	     output = "0"b;				/* yes, reset output flag */
     1277 	     open_idx = 0;				/* and set input open idx value */
     1278 	end;
     1279 	else do;					/* some type of output operation */
     1280 	     output = "1"b;				/* true if sqo or sqio */
     1281 	     if mtape_open_info.pfm_opt_sw (1) then	/* if generating a file */
     1282 		open_idx = 4;
     1283 	     else if mtape_open_info.modify then	/* if modifying an existing file */
     1284 		open_idx = 3;
     1285 	     else if mtape_open_info.extend then	/* if extending current file */
     1286 		open_idx = 2;
     1287 	     else open_idx = 1;			/* otherwise create new file */
     1288 	end;
     1289 
     1290      end SET_OPEN_IDX;
     1291 
     1292 /* SET_RECORD_SIZE - internal procedure to set record size either from defaults or as specified by the user */
     1293 
     1294 SET_RECORD_SIZE: proc;
     1295 
     1296 	if mtape_open_info.record_length = MTAPE_UNSPECIFIED then do; /* if no "-record" value specified by user */
     1297 	     if index (mtape_file_info.file_code, "S") ^= 0 then /* if Spanned format */
     1298 		mtape_file_info.record_size = mtape_open_info.default_span_rlen; /* set default */
     1299 	     else if index (mtape_file_info.file_code, "D") ^= 0 then /* if variable format */
     1300 		mtape_file_info.record_size = mtape_open_info.default_var_rlen; /* set default */
     1301 	     else mtape_file_info.record_size = mtape_open_info.default_fix_rlen; /* assume fixed or U format */
     1302 	end;
     1303 	else mtape_file_info.record_size = mtape_open_info.record_length; /* if user specified it */
     1304 
     1305      end SET_RECORD_SIZE;
     1306 
     1307 /* SET_RECORDING_MODE - internal procedure to set the recording mode in the file_info structure */
     1308 
     1309 SET_RECORDING_MODE: proc;
     1310 
     1311 	mtape_file_info.conversion = MTAPE_NO_CONVERSION; /* set no conversion as default */
     1312 	temp_mode = translate (mtape_open_info.recording_mode, UC, LC); /* mode to UC */
     1313 	if temp_mode = "ASCII" then			/* record in standard ascii mode */
     1314 	     mtape_file_info.hdw_mode = MTAPE_HWM_NINE;
     1315 	else if temp_mode = "EBCDIC" then do;		/* record in ebcdic mode */
     1316 	     mtape_file_info.hdw_mode = MTAPE_HWM_NINE;
     1317 	     mtape_file_info.conversion = MTAPE_CV_EBCDIC;/* set conversion for ASCII <==> EBCDIC */
     1318 	end;
     1319 	else mtape_file_info.hdw_mode = MTAPE_HWM_BIN;	/* Must be binary mode */
     1320      end SET_RECORDING_MODE;
     1321 
     1322 /* SETUP - internal procedure to set up enviornment for the external entries */
     1323 
     1324 SETUP: proc;
     1325 
     1326 	mtdp = arg_mtdp;				/* get pointers to pertinient data */
     1327 	vs_ptr = mtape_data.vs_current;
     1328 	fi_ptr = mtape_data.fi_current;
     1329 	maip = mtape_data.attach_info_ptr;
     1330 	moip = mtape_data.open_info_ptr;
     1331 	mpfmip = mtape_data.pfm_info_ptr;
     1332 	arg_code, code = 0;				/* and reset error codes */
     1333 
     1334      end SETUP;
     1335 
     1336 /* SETUP_NEW_FILE - procedure to create a file info structure and initialize it with open options */
     1337 
     1338 SETUP_NEW_FILE: proc;
     1339 
     1340 	if fi_ptr ^= null then			/* if replacing existing file */
     1341 	     if ^mtape_open_info.force then		/* and not ignoring expiration dates */
     1342 		if pfm_utils_$label_unexpired ((mtape_file_info.expiration_date)) then do;	/* if expiration date is in future */
     1343 		     call mtape_$user_query (mtdp, Q_UNEXPIRED_FILE, code); /* ask user what to do */
     1344 		     if code ^= 0 then return;	/* abort file opening on "no" answer */
     1345 		     if mtape_file_info.position_within_file ^= AT_BOFH then do;
     1346 			call pfm_utils_$position_in_file (mtdp, fi_ptr, vs_ptr, AT_BOFH, code);
     1347 			if code ^= 0 then return;
     1348 		     end;
     1349 		end;
     1350 	call pfm_utils_$setup_file (mtdp, fi_ptr, "0"b);	/* do the common stuff first */
     1351 	call SET_FILE_FORMAT;			/* set the file format in file info structure */
     1352 	call SET_RECORDING_MODE;			/* set the recording mode */
     1353 	if mtape_file_info.record_size = MTAPE_UNSPECIFIED then /* no record length */
     1354 	     call SET_RECORD_SIZE;			/* either use given or default */
     1355 	if mtape_open_info.pfm_opt_sw (2) then		/* if buffer offset specified */
     1356 	     mtape_file_info.buffer_offset = size (native_bo_contents) * 4; /* set the size */
     1357 	else do;
     1358 	     mtape_file_info.native_file = "0"b;	/* otherwise reset this flag */
     1359 	     mtape_file_info.buffer_offset = 0;		/* and set for no buffer offset */
     1360 	end;
     1361 	mtape_file_info.generation = 1;		/* set up as constants for now */
     1362 	mtape_file_info.gen_version = 0;
     1363 	mtape_file_info.creation_date = pfm_utils_$julian_date (""); /* set todays date */
     1364 	if mtape_open_info.expiration ^= "" then	/* if expiration specified.. */
     1365 	     mtape_file_info.expiration_date = pfm_utils_$julian_date ((mtape_open_info.expiration));
     1366 	else mtape_file_info.expiration_date = " 00000";	/* no expiration specified */
     1367 
     1368 SET_FILE_ATTRIBUTES: entry;				/* to set file attributes if not already set */
     1369 
     1370 	if mtape_file_info.file_format = MTAPE_UNSPECIFIED then /* if file format not specified */
     1371 	     call SET_FILE_FORMAT;
     1372 	mtape_file_info.length_mode = NON_MOD_FOUR;	/* set special length mode as default */
     1373 	if mtape_file_info.hdw_mode = MTAPE_UNSPECIFIED then /* recording mode not set */
     1374 	     call SET_RECORDING_MODE;			/* set it */
     1375 	if mtape_file_info.block_size = MTAPE_UNSPECIFIED then /* no block size */
     1376 	     mtape_file_info.block_size = mtape_open_info.block_length; /* use given */
     1377 	if mtape_file_info.record_size = MTAPE_UNSPECIFIED then /* no record length */
     1378 	     call SET_RECORD_SIZE;			/* either use given or default */
     1379 	if mtape_data.conversion = MTAPE_CV_EBCDIC then	/* if converting to ebcdic */
     1380 	     mtape_data.padding_char = ANSI_EBCDIC_PAD_CHAR; /* set EBCDIC pad char */
     1381 	else mtape_data.padding_char = ANSI_ASCII_PAD_CHAR; /* otherwise set ASCII pad char */
     1382 
     1383      end SETUP_NEW_FILE;
     1384 
     1385 /* WRITE_BLOCK - procedure to write out the current block when full */
     1386 
     1387 WRITE_BLOCK: proc;
     1388 
     1389 	if mtape_data.native_file then do;		/* tape written entirely by this module? */
     1390 	     native_bo_contents.block_size = mtape_data.processed; /* yes, store block size */
     1391 	     native_bo_contents.block_number = mtape_data.phy_block + 1; /* store block serial number */
     1392 	end;
     1393 	call mtape_$write_block (mtdp, code);
     1394 	if code ^= 0 then				/* some error */
     1395 	     if code = error_table_$eov_on_write then do; /* Is it end of tape? */
     1396 		call LOAD_PTRS;			/* Load up structure pointers */
     1397 		call EOV_ON_WRITE (WRITING);		/* Go close out volume and initiate volume switch */
     1398 		if code ^= 0 then
     1399 		     go to write_return;		/* If problem, take non-local goto and return */
     1400 	     end;
     1401 	     else go to write_return;			/* other error return to caller */
     1402 
     1403      end WRITE_BLOCK;
     1404 
  1     1 /* BEGIN INCLUDE FILE mtape_includes.incl.pl1. Created by J. A. Bush 07/29/83 */
  1     2 /* This include file contains all of the mtape_ include files necessary for a
  1     3*   Per-Format module to obtain the proper references */
  1     4 
  2     1 /* BEGIN INCLUDE FILE mtape_data.incl.pl1. Created by J. A. Bush 10/06/82  */
  2     2 /* format: style4 */
  2     3 
  2     4 dcl  mtdp ptr;
  2     5 
  2     6 dcl  mtape_data_version_1 char (8) int static options (constant) init ("mtdv0001");
  2     7 
  2     8 dcl  1 mtape_data aligned based (mtdp),
  2     9        2 version char (8),				/* Current structure version */
  2    10        2 areap ptr,					/* Pointer to an allocation area  */
  2    11        2 iocb_ptr ptr,				/* Pointer to our IO control block */
  2    12        2 atdp ptr,					/* Pointer to the attach description string  */
  2    13        2 opdp ptr,					/* Pointer to the open description string */
  2    14        2 cldp ptr,					/* Pointer to close description string */
  2    15        2 dtdp ptr,					/* Pointer to detach description string */
  2    16        2 cmtdp ptr,					/* If non-null, Ptr to allocated copy of mtape_data */
  2    17        2 vs_head ptr,				/* Pointer to the first volume_set structure  */
  2    18        2 vs_tail ptr,				/* Pointer to the last volume_set structure  */
  2    19        2 vs_current ptr,				/* Pointer to the current volume_set structure  */
  2    20        2 vs_mounted_tail ptr,				/* Pointer to MRM volume_set member */
  2    21        2 fi_head ptr,				/* Pointer to the first file_info structure  */
  2    22        2 fi_tail ptr,				/* Pointer to the last file_info structure  */
  2    23        2 fi_current ptr,				/* Pointer to the current file_info structure  */
  2    24        2 tape_infop ptr,				/* Pointer to rcp tape info structure */
  2    25        2 last_ur_status_ptr ptr,			/* If non-null, Ptr to last unrecoverable status */
  2    26        2 io_echan fixed bin (71),			/* Fast wait channel for I/O interrupts */
  2    27        2 mount_echan fixed bin (71),			/* Regular wait channel for mount requests */
  2    28        2 data_xfer_args,				/* Arguments for time critical (read/write) calls */
  2    29          3 arg_buf_ptr ptr,				/* Pointer to users buffer */
  2    30          3 arg_buf_len fixed bin (21),			/* Length of users buffer in bytes */
  2    31          3 arg_rec_len fixed bin (21),			/* Length of record read in bytes */
  2    32        2 error_lock fixed bin (35),			/* if ^= 0 = file locked error code */
  2    33        2 abs_ans char (3),				/* Query answer (yes or no) for abs user */
  2    34        2 user_type bit (1),				/* "1"b => interactive; "0"b => absentee */
  2    35        2 display_errors bit (1),			/* "1"b => display verbose error messages */
  2    36        2 force_end_of_volume bit (1),			/* "1"b => simulate EOV on next write */
  2    37        2 opd_len fixed bin (21),			/* Allocated length of open description */
  2    38        2 drives_in_use fixed bin,			/* Number of tape drives currently in use */
  2    39        2 data_buffers,				/* Info about data buffers */
  2    40          3 buf_ptrs (8) ptr,				/* Pointers to a subset of ioi buffers */
  2    41          3 blind_buf_ptrs (8) ptr,			/* Pointers to other subset of buffers */
  2    42          3 buf_len (8) fixed bin (21),			/* Length of buffers in 9 bit bytes */
  2    43          3 blind_buf_len (8) fixed bin (21),		/* Lengths of other subset of buffers */
  2    44          3 nbufs fixed bin,				/* Number of data buffers currently in use */
  2    45          3 buf_size fixed bin (21),			/* Allocated size of data buffers in bytes */
  2    46          3 bufs_per_subset fixed bin,			/* Number of buffers to write/read per I/O */
  2    47          3 cur_buf_idx fixed bin,			/* Index into subset of current buffer */
  2    48          3 run bit (1),				/* "1"b => wrt I/O queued thru tape_ioi_; "0"b => ^Queued */
  2    49        2 label_buffer,				/* Info about label record buffer */
  2    50          3 lab_bufp ptr,				/* Pointer to label I/O buffer */
  2    51          3 lab_buf_len fixed bin (21),			/* Length of label buffer in 9 bit bytes */
  2    52        2 tlb ptr,					/* Pointer to a temp label record structure */
  2    53        2 position,					/* Position on current volume */
  2    54          3 phy_file fixed bin,			/* physical file number */
  2    55          3 phy_block fixed bin,			/* physical block within physical file */
  2    56        2 current_file,				/* instantanious info about current file */
  2    57          3 cur_block,				/* info about current block */
  2    58 	 4 cur_buf_ptr ptr,				/* Pointer to the current data buffer */
  2    59 	 4 log_record_ptr ptr,			/* Pointer to current logical record */
  2    60 	 4 length fixed bin (21),			/* Length of current block in bytes */
  2    61 	 4 processed fixed bin (21),			/* Number of chars processed already */
  2    62 	 4 remain fixed bin (21),			/* Number of chars remaining to be processed */
  2    63 	 4 log_record fixed bin (21),			/* Log. record within the current block */
  2    64          3 char_size fixed bin,			/* Size in bits of the data chars of this file */
  2    65          3 padding_char char (1),			/* To pad blocks to mod 4 on binary writes */
  2    66          3 length_mode fixed bin,			/* 0 => W/R mod 4 blocks; 1 => W/R non-mod 4 blocks */
  2    67          3 hdw_mode fixed bin,			/* Hardware recording mode:
  2    68*						   1 = binary; 2 = nine track; 3 = BCD */
  2    69          3 conversion fixed bin,			/* File data conversion:
  2    70*						   0 = no conversion; 1 = ASCII<->EBCDIC; 2 = ASCII<->BCD */
  2    71          3 buffer_offset fixed bin,			/* Number of bytes prior to data */
  2    72          3 block_size fixed bin (21),			/* Maximum block size for this file */
  2    73          3 record_size fixed bin (21),			/* Maximum record size for this file */
  2    74          3 prev_block_no fixed bin (21),		/* Number of previous block read */
  2    75          3 ad_file_format fixed bin,			/* 1 = U; 2 = F; 3 = D or V; 4 = S or VS */
  2    76          3 file_blocked bit (1),			/* "1"b => file is blocked */
  2    77          3 native_file bit (1),			/* "1"b => current file written by mtape_ PFM */
  2    78          3 write_after_read bit (1),			/* "1"b => truncate file (and file_set) at this record */
  2    79          3 first_file bit (1),			/* "1"b => first file has been processed */
  2    80          3 tot_bytes_processed fixed bin (35),		/* total bytes in this file section */
  2    81          3 last_io fixed bin,				/* Last I/O operation (1 = read; 2 = write) */
  2    82          3 lrec_rrcx fixed bin,			/* current index of the lrec round robin counter */
  2    83          3 lrec_rrc,				/* history of last n logical records */
  2    84 	 4 block_no (0:7) fixed bin (35),		/* block (within file section) where lrec starts */
  2    85 	 4 block_len (0:7) fixed bin (35),		/* block len of current block */
  2    86 	 4 lrec_no (0:7) fixed bin (35),		/* logical record within currnt block */
  2    87 	 4 abs_byte (0:7) fixed bin (35),		/* byte (within file section) where lrec starts */
  2    88 	 4 byte_offset (0:7) fixed bin,		/* offset of 1st byte of lrec (within block) */
  2    89          3 blk_rrcx fixed bin,			/* index into blk_rrrc array of last block */
  2    90          3 blk_rrrc (0:7) fixed bin (35),		/* contains Lrec count of last n blocks */
  2    91          3 tot_lrec fixed bin (35),			/* Total logical records processed in current file */
  2    92        2 tioi_id bit (36),				/* Identifier used for calls to tape_ioi_ */
  2    93        2 attach_info_ptr ptr,				/* Pointer to attach option info */
  2    94        2 open_info_ptr ptr,				/* Pointer to open option info */
  2    95        2 close_info_ptr ptr,				/* Pointer to close option info */
  2    96        2 detach_info_ptr ptr,				/* Pointer to detach option info */
  2    97        2 pfm_info_ptr ptr,				/* Pointer to PFM info block */
  2    98        2 saved_pfm_info_ptr ptr,			/* Pointer to info for "change_module" control OP */
  2    99        2 pfm_name char (32),				/* Name of Per-Format module */
  2   100        2 pfm_required_entries like pfm_entries,		/* Required entry point declarations in PFM */
  2   101        2 pfm_work_area (32) fixed bin (35);		/* PFM work buffer */
  2   102 
  2   103 dcl  1 pfm_entries based aligned,			/* Entry declarations for PFM entries */
  2   104        2 pfm_init entry (ptr, fixed bin (35)),		/* PFM initialization entry */
  2   105        2 file_open entry (ptr, fixed bin (35)),		/* PFM file_open entry */
  2   106        2 file_close entry (ptr, fixed bin (35)),		/* PFM file_close entry */
  2   107        2 read entry (ptr, fixed bin (35)),		/* PFM read entry */
  2   108        2 write entry (ptr, fixed bin (35)),		/* PFM write entry */
  2   109        2 order entry (ptr, char (*), ptr, ptr, fixed bin (35)), /* PFM control order entry */
  2   110        2 decode_file_labels entry (ptr, ptr, fixed bin, fixed bin, fixed bin (35)),
  2   111        2 encode_file_labels entry (ptr, ptr, fixed bin, fixed bin, fixed bin, fixed bin (35));
  2   112 
  2   113 dcl  all_buf_ptrs (16) ptr based (addr (mtape_data.buf_ptrs));
  2   114 dcl  all_buf_lens (16) fixed bin (21) based (addr (mtape_data.buf_len));
  2   115 dcl  tape_blk (mtape_data.length) char (1) unaligned based (mtape_data.cur_buf_ptr); /* template for a tape block */
  2   116 
  2   117 /* END INCLUDE FILE mtape_data.incl.pl1 */
  1     5 
  1     6 
  3     1 /* BEGIN INCLUDE FILE mtape_vol_set.incl.pl1. Created by J. A. Bush 10/13/82 */
  3     2 /* The include file mtape_err_stats.incl.pl1 is referenced by this include file */
  3     3 /* format: style4 */
  3     4 
  3     5 dcl  vs_ptr ptr;
  3     6 
  3     7 dcl  mtape_vs_version_1 char (8) int static options (constant) init ("mtvsv001");
  3     8 
  3     9 dcl  1 mtape_vol_set aligned based (vs_ptr),
  3    10        2 version char (8),				/* Current version */
  3    11        2 prev_vs_ptr ptr,				/* Pointer to previous volume set entry */
  3    12        2 next_vs_ptr ptr,				/* Pointer to next volume set entry */
  3    13        2 mrm_vs_ptr ptr,				/* Pointer to Most Recently Mounted VS member */
  3    14        2 lrm_vs_ptr ptr,				/* Pointer to Least Recently Mounted VS member */
  3    15        2 first_vl_ptr ptr,				/* Pointer to the first volume label record structure */
  3    16        2 last_vl_ptr ptr,				/* Pointer to the last volume label record structure */
  3    17        2 volume_name char (32),			/* Name specified in the attach description */
  3    18        2 volume_id char (32),				/* Name as recorded in the volume label */
  3    19        2 mount_comment char (64),			/* Mount comment from attach description */
  3    20        2 demount_comment char (64),			/* Demount comment from detach description */
  3    21        2 device_name char (8),			/* Device volume is currently or last mounted on */
  3    22        2 rcp_id bit (36),				/* RCP activation for this volume */
  3    23        2 tioi_id bit (36),				/* tape_ioi_ activation for this volume */
  3    24        2 volume_index fixed bin,			/* Volume sequence number within volume set */
  3    25        2 volume_density fixed bin,			/* Actual volume density determined by RCP */
  3    26        2 volume_type fixed bin,			/* Use rcp_volume_formats.incl.pl1 for decode */
  3    27        2 volume_check fixed bin,			/* Refer to named constants below for values */
  3    28        2 number_of_vol_labels fixed bin,		/* # of volume label records on this volume */
  3    29        2 auth_required bit (1),			/* "1"b => Operator authentication was required */
  3    30        2 mounted bit (1),				/* "1"b => volume currently mounted */
  3    31        2 ever_mounted bit (1),			/* "1"b => volume has been mounted */
  3    32        2 volume_end bit (1),				/* "1"b => reached end of volume (EOT foil) on write */
  3    33        2 first_file_unexpired bit (1),			/* "1"b => first file of volume is unexpired */
  3    34        2 dev_att_retry bit (1),			/* "1"b => DEVICE ATTENTION recovery in progress */
  3    35        2 pwr_off_retry bit (1),			/* "1"b => POWER OFF recovery in progress */
  3    36        2 mounts fixed bin,				/* Number of times volume mounted during attachment */
  3    37        2 tot_error_stats like mtape_err_stats,		/* Summation of error statistics for all mounts */
  3    38        2 rel_error_stats like mtape_err_stats;		/* Summation of error statistics, this mount */
  3    39 
  3    40 /* Named constants applied to volume_check variable, when volume label read by PFMs pfm_init entry */
  3    41 
  3    42 dcl  (MTAPE_VOLUME init (1),				/* Volume recorded by mtape_ (desired type) */
  3    43      MULT_PRIOR_VOLUME init (2),			/* Volume recorded by prior Multics software
  3    44*						   (desired type) */
  3    45      NON_MULT_VOLUME init (3),			/* Volume recorded by other vendor (desired type) */
  3    46      BLANK_VOLUME init (4),				/* Volume is blank/unreadable */
  3    47      UNLABELED_VOLUME init (5),			/* Volume is unlabeled or has unrecognized label */
  3    48      RECOG_FORMAT_VOLUME init (6)			/* Volume has label of other recognized format */
  3    49      ) fixed bin int static options (constant);
  3    50 
  3    51 /* END INCLUDE FILE mtape_vol_set.incl.pl1 */
  1     7 
  1     8 
  4     1 /* BEGIN INCLUDE FILE mtape_label_record.incl.pl1. Created by J. A. Bush 10/13/82 */
  4     2 /* format: style4 */
  4     3 
  4     4 dcl  lr_ptr ptr;
  4     5 
  4     6 dcl  mtape_lr_version_1 char (8) int static options (constant) init ("mtlrv001");
  4     7 
  4     8 dcl  1 mtape_label_record aligned based (lr_ptr),
  4     9        2 version char (8),				/* Current version */
  4    10        2 prev_lab_ptr ptr,				/* Pointer to previous label record structure */
  4    11        2 next_lab_ptr ptr,				/* Pointer to next label record structure */
  4    12        2 lab_ptr ptr,				/* Pointer to the actual format specific label record */
  4    13        2 lab_length fixed bin,			/* Length in 9 bit bytes of the label record */
  4    14        2 mode fixed bin,				/* Hardware recording mode:
  4    15*						   1 = binary
  4    16*						   2 = nine
  4    17*						   3 = bcd */
  4    18        2 conversion fixed bin;			/* Character set conversion required:
  4    19*						   1 = no conversion
  4    20*						   2 = ASCII <==> EBCDIC (any case)
  4    21*						   3 = ASCII <==> BCD
  4    22*						   4 = ASCII ==> Upper case ASCII
  4    23*						   5 = ASCII ==> Upper case EBCDIC */
  4    24 
  4    25 /* END INCLUDE FILE mtape_label_record.incl.pl1 */
  1     9 
  1    10 
  5     1 /* BEGIN INCLUDE FILE mtape_err_stats.incl.pl1. Created by J. A. Bush 07/22/83. */
  5     2 /* format: style4 */
  5     3 
  5     4 dcl  es_ptr ptr;
  5     5 
  5     6 dcl  1 mtape_err_stats aligned based (es_ptr),		/* Error statistics block */
  5     7        2 read like err_entry,				/* For read operations */
  5     8        2 write like err_entry,			/* For write operations */
  5     9        2 orders like err_entry,			/* For non-data xfer operations */
  5    10        2 successful_retry (7) fixed bin (35);		/* retrys that succeeded after 1-7 trys */
  5    11 
  5    12 dcl  1 err_entry aligned based,
  5    13        2 errors fixed bin (35),
  5    14        2 operations fixed bin (35);
  5    15 
  5    16 /* END INCLUDE FILE mtape_err_stats.incl.pl1 */
  1    11 
  1    12 
  6     1 /* BEGIN INCLUDE FILE mtape_file_info.incl.pl1. Created by J. A. Bush 10/13/82 */
  6     2 /* format: style4 */
  6     3 
  6     4 dcl  fi_ptr ptr;
  6     5 
  6     6 dcl  mtape_fi_version_1 char (8) int static options (constant) init ("mtfiv001");
  6     7 
  6     8 dcl  1 mtape_file_info aligned based (fi_ptr),
  6     9        2 version char (8),				/* Current version */
  6    10        2 prev_fi_ptr ptr,				/* Pointer to the previous file info structure */
  6    11        2 next_fi_ptr ptr,				/* Pointer to the next file info structure */
  6    12        2 first_file_lab_ptr ptr,			/* Pointer to 1st label record struc. */
  6    13        2 last_file_lab_ptr ptr,			/* Pointer to last label record struc. */
  6    14        2 first_file_trail_ptr ptr,			/* Pointer to 1st trailer record struc. */
  6    15        2 last_file_trail_ptr ptr,			/* Pointer to last trailer record struc. */
  6    16        2 first_file_section_ptr ptr,			/* Pointer to file_info struct. of 1st file section */
  6    17        2 begin_vs_ptr ptr,				/* Pointer to 1st volume set struct. containing this file */
  6    18        2 end_vs_ptr ptr,				/* Pointer to last volume set struct. containing this file */
  6    19        2 position_within_file fixed bin,		/* 0 = In HDR; 1 = In data file; 2 = In trailer;
  6    20*						   3 = Not positioned within this file
  6    21*						   4 = At beginning of data file; 5 = At EOF */
  6    22        2 per_file_info,				/* Information pertaining to entire file */
  6    23          3 file_id char (32),				/* File identifier or name */
  6    24          3 file_set_id char (32),			/* Identifies the file set */
  6    25          3 creation_date char (6),			/* File creation date in form " yyddd" */
  6    26          3 expiration_date char (6),			/* File expiration date in form " yyddd" */
  6    27          3 file_code char (3),			/* Printable file code */
  6    28          3 file_format fixed bin,			/* Current file format:
  6    29*						   0 = unspecified; 1 = U; 2 = F; 3 = D or V;
  6    30*						   4 = S or VS; 5 = FB;
  6    31*						   6 = DB or VB; 7 = SB or VBS; */
  6    32          3 seq_number fixed bin,			/* File sequence number */
  6    33          3 generation fixed bin,			/* File generation number, if supported */
  6    34          3 gen_version fixed bin,			/* File generation version number, if supported */
  6    35          3 char_size fixed bin,			/* Size in bits of the data chars of this file */
  6    36          3 hdw_mode fixed bin,			/* Hardware mode: 1 = binary; 2 = nine; 3 = BCD */
  6    37          3 conversion fixed bin,			/* File data conversion:
  6    38*						   1 = no conversion; 2 = ASCII<->EBCDIC; 3 = ASCII<->BCD */
  6    39          3 buffer_offset fixed bin,			/* Number of bytes prior to data */
  6    40          3 length_mode fixed bin,			/* 0 => W/R mod 4 blocks; 1 => W/R non-mod 4 blocks */
  6    41          3 block_size fixed bin (21),			/* Maximum block size for this file */
  6    42          3 record_size fixed bin (21),			/* Maximum record size for this file */
  6    43          3 native_file bit (1),			/* "1"b => current file written by mtape_ PFM */
  6    44          3 user_labels_present bit (1),			/* "1"b => UHL<n>/UTL<n> are present */
  6    45          3 unlabeled_file bit (1),			/* "1"b => this is unlabeled file */
  6    46          3 pfm_opt_sw (5) bit (1),			/* PFM dependent */
  6    47          3 pfm_opt_value (5) fixed bin (35),		/* PFM dependent */
  6    48          3 pfm_opt_str (5) char (32),			/* PFM dependent */
  6    49        2 per_section_info,				/* Information pertaining only to this file section */
  6    50          3 section fixed bin,				/* File section number for multi-volume files */
  6    51          3 phy_file fixed bin,			/* Phy. file of HDR label GRP, on the current volume */
  6    52          3 first_file_on_volume bit (1),		/* "1"b => First file or file section on this volume */
  6    53          3 end_of_file_set bit (1),			/* "1"b => This is last file of file set */
  6    54          3 block_count fixed bin (35),			/* Number of blocks in this file section */
  6    55          3 read_errors fixed bin (35),			/* of errors encountered reading this file */
  6    56          3 write_errors fixed bin (35);			/* of errors encountered writing this file */
  6    57 
  6    58 /* END INCLUDE FILE mtape_file_info.incl.pl1 */
  1    13 
  1    14 
  7     1 /* BEGIN INCLUDE FILE mtape_attach_info.incl.pl1. Created by J. A. Bush 06/13/83 */
  7     2 /* format: style4 */
  7     3 
  7     4 dcl  maip ptr;
  7     5 
  7     6 dcl  mtape_attach_info_version_1 char (8) int static options (constant) init ("maiv0001");
  7     7 
  7     8 dcl  1 mtape_attach_info aligned based (maip),
  7     9        2 version char (8),				/* Current structure version */
  7    10        2 density fixed bin (35),			/* 200, 556, 800, 1600, 6250 BPI */
  7    11        2 tracks fixed bin (35),			/* Number of tracks, 7 or 9 */
  7    12        2 speed bit (36),				/* "000"b = any speed; "1xx"b = 75 IPS;
  7    13*						   "x1x"b = 125 IPS; "xx1"b = 200 IPS */
  7    14        2 ndrives fixed bin (35),			/* 0 = unspecified; 1 - 63 devices to be used */
  7    15        2 wait_time fixed bin (35),			/* time to wait in minutes for available device */
  7    16        2 pfm_prefix char (21),			/* if "-volume_type" was specified */
  7    17        2 default_pfm_prefix char (21),			/* if no "-vt" specified and blank volume */
  7    18        2 display bit (1),				/* Display attach description on user_output */
  7    19        2 labeled bit (1),				/* "1"b => labeled; "0"b => unlabeled volume set */
  7    20        2 wait bit (1),				/* "1"b => wait for available devices; "0"b => don't wait */
  7    21        2 system bit (1),				/* "1"b => User wants to be a "system" process */
  7    22        2 ring bit (1);				/* "1"b => write ring in; "0"b => no write ring */
  7    23 
  7    24 /* END INCLUDE FILE mtape_attach_info.incl.pl1 */
  1    15 
  1    16 
  8     1 /*  BEGIN INCLUDE FILE mtape_pfm_info.incl.pl1. Created by J. A. Bush 06/16/83 */
  8     2 /* format: style4 */
  8     3 
  8     4 dcl  mpfmip ptr;
  8     5 
  8     6 dcl  mtape_pfm_info_version_1 char (8) int static options (constant) init ("mpiv0001");
  8     7 
  8     8 dcl  1 mtape_pfm_info aligned based (mpfmip),		/* PFM information block */
  8     9        2 version char (8),				/* Current structure version */
  8    10        2 module_id char (21),				/* For identification of PFM. (e.g. ANSI, IBM, GCOS) */
  8    11        2 open_modes_allowed (3) fixed bin,		/* Allowable open modes for this PFM */
  8    12        2 bof_prefix char (3),				/* For identification of BOF labels */
  8    13        2 eov_prefix char (3),				/* For identification of EOV labels */
  8    14        2 eof_prefix char (3),				/* For identification of EOF labels */
  8    15        2 no_labels_ok bit (1),			/* "1"b => PFM processes unlabeled volumes */
  8    16        2 multi_volumes_ok bit (1),			/* "1"b => PFM processes multi-volume sets */
  8    17        2 extended_error_recovery bit (1),		/* "1"b => PFM will do error recovery after mtape_ gives up */
  8    18        2 pfm_open_options like pfm_options,		/* open options common to this PFM */
  8    19        2 pfm_close_options like pfm_options;		/* close options common to this PFM */
  8    20 
  8    21 dcl  1 pfm_options aligned based,			/* common to open and close pfm options */
  8    22        2 pfm_opt_flags (5),				/* identifies use of "pfm_opt_sw (1-5)" close flags */
  8    23          3 flag_name char (32),			/* name of flag */
  8    24          3 flag_ant_name char (32),			/* antonym name */
  8    25        2 pfm_opt_value_name (5) char (32),		/* identifies use of "pfm_opt_value (1-5)" */
  8    26        2 pfm_opt_str_name (5) char (32);		/* identifies use of "pfm_opt_str (1-5)" */
  8    27 
  8    28 /*  END INCLUDE FILE mtape_pfm_info.incl.pl1 */
  1    17 
  1    18 
  9     1 /* BEGIN INCLUDE FILE mtape_open_close_info.incl.pl1. Created by J. A. Bush 06/13/83 */
  9     2 /* format: style4 */
  9     3 
  9     4 dcl  moip ptr;					/* Pointer to mtape_open_info structure */
  9     5 dcl  mcip ptr;					/* Pointer to mtape_close_info structure */
  9     6 
  9     7 dcl  mtape_open_info_version_1 char (8) int static options (constant) init ("moiv0001");
  9     8 dcl  mtape_close_info_version_1 char (8) int static options (constant) init ("mciv0001");
  9     9 
  9    10 dcl  1 mtape_open_info aligned based (moip),
  9    11        2 version char (8),				/* Current structure version */
  9    12        2 cs_ptr ptr,				/* Pointer to arg processing control structure */
  9    13        2 cal_ptr ptr,				/* Pointer to arg processing ctl arg list */
  9    14        2 so_ptr ptr,				/* Pointer to last saved iox_ options */
  9    15        2 open_mode fixed bin,				/* iox_ opening mode */
  9    16        2 comment char (80),				/* Display on user_output after open */
  9    17        2 expiration char (24),			/* File expiration date */
  9    18        2 file_format char (3),			/* File format code */
  9    19        2 recording_mode char (6),			/* Ascii, ebcdic, or binary */
  9    20        2 file_name char (32),				/* Name of file to be recorded */
  9    21        2 replace_id char (32),			/* Name of file to replace */
  9    22        2 init_to_zero,				/* Enables clearing rest of structure */
  9    23          3 block_length fixed bin (35),			/* Block size in bytes */
  9    24          3 record_length fixed bin (35),		/* Record length specified by user */
  9    25          3 default_span_rlen fixed bin (35),		/* Default record length for spanned records */
  9    26          3 default_var_rlen fixed bin (35),		/* Default record length for variable records */
  9    27          3 default_fix_rlen fixed bin (35),		/* Default record length for fixed records */
  9    28          3 seq_number fixed bin (35),			/* File sequence number */
  9    29          3 append bit (1),				/* "1"b => append file to end of file set */
  9    30          3 create bit (1),				/* "1"b => create this file */
  9    31          3 display bit (1),				/* "1"b => display the open description */
  9    32          3 extend bit (1),				/* "1"b => extend the current file */
  9    33          3 force bit (1),				/* "1"b => disregard file expiration when creating */
  9    34          3 last_file bit (1),				/* "1"b => position to last file of file set */
  9    35          3 next_file bit (1),				/* "1"b => position to next file of file set */
  9    36          3 modify bit (1),				/* "1"b => modify the current file */
  9    37          3 label_entry_present bit (1),			/* "1"b => user label entry is valid */
  9    38          3 user_label entry (ptr, char (*), fixed bin, fixed bin, fixed bin, fixed bin (35)),
  9    39          3 pfm_args like pfm_arg_values;		/* see structure below */
  9    40 
  9    41 dcl  1 mtape_close_info aligned based (mcip),
  9    42        2 version char (8),				/* Current structure version */
  9    43        2 cs_ptr ptr,				/* Pointer to arg processing control structure */
  9    44        2 cal_ptr ptr,				/* Pointer to arg processing ctl arg list */
  9    45        2 so_ptr ptr,				/* Pointer to last saved iox_ options */
  9    46        2 comment char (80),				/* Display on user_output after open */
  9    47        2 init_to_zero,				/* Enables clearing rest of structure */
  9    48          3 display bit (1),				/* Display open description for user */
  9    49          3 position fixed bin,			/* For positioning on file closing:
  9    50*						   0 = Leave at current position;
  9    51*						   1 = Position to beginning of file;
  9    52*						   2 = Position to end of file;
  9    53*						   3 = Position to beginning of file section;
  9    54*						   4 = Position to end of file section */
  9    55          3 pfm_args like pfm_arg_values;		/* see structure below */
  9    56 
  9    57 dcl  1 pfm_arg_values aligned based,			/* Common to open and close_info */
  9    58        2 pfm_opt_sw (5) bit (1),			/* PFM dependent */
  9    59        2 pfm_opt_value (5) fixed bin (35),		/* PFM dependent */
  9    60        2 pfm_opt_str (5) char (32);			/* PFM dependent */
  9    61 
  9    62 /* END INCLUDE FILE mtape_open_close_info.incl.pl1 */
  1    19 
  1    20 
 10     1 /* BEGIN INCLUDE FILE mtape_constants.incl.pl1. Created by J. A. Bush 10/07/82 */
 10     2 /* format: style4 */
 10     3 
 10     4 /* This include file defines various named constants used throughout mtape_
 10     5*   and its associated Per-Format modules */
 10     6 
 10     7 /* Storage allocation constants, used to denote what type of storage to allocate */
 10     8 
 10     9 dcl  (MTAPE_ALLOC_VS init (1),			/* to allocate a volume_set structure */
 10    10      MTAPE_ALLOC_LR init (2),				/* to allocate a label record structure */
 10    11      MTAPE_ALLOC_FI init (3),				/* to allocate a file_info structure */
 10    12      MTAPE_ALLOC_STR init (4)				/* to allocate a character string, or undefined block */
 10    13      ) fixed bin int static options (constant);
 10    14 
 10    15 /* Volume density constants */
 10    16 
 10    17 dcl  MTAPE_VALID_DENSITIES (5) init (200, 556, 800, 1600, 6250)
 10    18 	fixed bin int static options (constant);
 10    19 
 10    20 /* Device speed constants */
 10    21 
 10    22 dcl  MTAPE_SPEED_VALUES (4) init (0, 75, 125, 200)	/* 0 is any speed device */
 10    23 	fixed bin int static options (constant);
 10    24 
 10    25 /* Hardware Mode constants */
 10    26 
 10    27 dcl  (MTAPE_HWM_BIN init (1),				/* For binary hardware mode */
 10    28      MTAPE_HWM_NINE init (2),				/* For nine hardware mode */
 10    29      MTAPE_HWM_BCD init (3)				/* For BCD hardware mode */
 10    30      ) fixed bin int static options (constant);
 10    31 
 10    32 /* Data conversion constants */
 10    33 
 10    34 dcl  (MTAPE_UNSPECIFIED init (0),			/* attribute not specified */
 10    35      MTAPE_NO_CONVERSION init (1),			/* No conversion on input or output */
 10    36      MTAPE_CV_EBCDIC init (2),			/* Convert to/from EBCDIC (from/to ASCII) */
 10    37      MTAPE_CV_BCD init (3),				/* Convert to/from BCD (from/to ASCII) */
 10    38      MTAPE_CV_UC_ASCII init (4),			/* Convert to Upper case ASCII (from any case ASCII) */
 10    39      MTAPE_CV_UC_EBCDIC init (5)			/* Convert to Upper case EBCDIC (from any case ASCII) */
 10    40      ) fixed bin int static options (constant);
 10    41 
 10    42 /* File positioning constants */
 10    43 
 10    44 dcl  (NOT_POSITIONED_IN_FILE init (0),			/* Not currently positioned within this file */
 10    45      AT_BOFH init (1),				/* Positioned at beginning of file hdr */
 10    46      AT_EOFH init (2),				/* Positioned at end of file hdr */
 10    47      AT_BOFD init (3),				/* Positioned at beginning of file data */
 10    48      AT_IFD init (4),				/* Positioned in file data, not beginning */
 10    49      AT_EOFD init (5),				/* Positioned prior to end of data file */
 10    50      AT_BOFT init (6),				/* Positioned at beginning of trailer label file */
 10    51      AT_EOFT init (7),				/* Positioned at end of trailer label file */
 10    52      AT_EOF init (8),				/* Positioned after trailer labels at EOF */
 10    53      FILES_PER_FILE_GRP init (3)			/* # of physical files per file (section) group */
 10    54      ) fixed bin int static options (constant);
 10    55 
 10    56 dcl  (BOF_LABEL init (1),				/* indicates beginning of file label */
 10    57      EOV_LABEL init (2),				/* indicates end of volume label */
 10    58      EOF_LABEL init (3)				/* indicates end of file label */
 10    59      ) fixed bin int static options (constant);
 10    60 
 10    61 /* user query constant codes */
 10    62 
 10    63 dcl  (Q_NO_NEXT_VOLUME init (1),
 10    64      Q_LABELED_VOLUME init (2),
 10    65      Q_UNEXPIRED_VOLUME init (3),
 10    66      Q_INCORRECT_VOLUME init (4),
 10    67      Q_UNEXPIRED_FILE init (5),
 10    68      Q_ABORT_FILE init (6)
 10    69      ) fixed bin int static options (constant);
 10    70 
 10    71 /* END INCLUDE FILE mtape_constants.incl.pl1 */
  1    21 
  1    22 
 11     1 /* BEGIN INCLUDE FILE mtape_dcls.incl.pl1. Created by J. A. Bush 04/20/83 */
 11     2 /* format: style4 */
 11     3 
 11     4 /****^  HISTORY COMMENTS:
 11     5*  1) change(00-01-26,Schroth), approve(00-01-26,MECR-Y2K):
 11     6*     Add declaration of pfm_utils_$label_unexpired for label date expiry checks
 11     7*                                                   END HISTORY COMMENTS */
 11     8 
 11     9 /* Usage: call mtape_$alloc (mtdp, type, link_tail, length, alloc_ptr); */
 11    10 dcl  mtape_$alloc entry (ptr, fixed bin, ptr, fixed bin (21), ptr);
 11    11 
 11    12 /* Usage: call mtape_$allocate_buffers (mtdp, block_size, code); */
 11    13 dcl  mtape_$allocate_buffers entry (ptr, fixed bin (21), fixed bin (35));
 11    14 
 11    15 /* Usage: call mtape_$demount (mtdp, code);
 11    16*dcl  mtape_$demount entry (ptr, fixed bin (35));
 11    17*
 11    18*/* Usage: call mtape_$error (mtdp, code, ioa_cntl_string, arguments); */
 11    19 dcl  mtape_$error entry options (variable);
 11    20 
 11    21 /* Usage: call mtape_$flush_buffers (mtdp, code); */
 11    22 dcl  mtape_$flush_buffers entry (ptr, fixed bin (35));
 11    23 
 11    24 /* Usage: call mtape_$mount (mtdp, code);
 11    25*dcl  mtape_$mount entry (ptr, fixed bin (35));
 11    26*/* Usage: call mtape_$order (mtdp, mnemonic, repeat_count, info_ptr, code); */
 11    27 dcl  mtape_$order entry (ptr, char (*), fixed bin, ptr, fixed bin (35));
 11    28 
 11    29 /* Usage: call mtape_$read_block (mtdp, code); */
 11    30 dcl  mtape_$read_block entry (ptr, fixed bin (35));
 11    31 
 11    32 /* Usage: call mtape_$read_label (mtdp, lr_ptr, code); */
 11    33 dcl  mtape_$read_label entry (ptr, ptr, fixed bin (35));
 11    34 
 11    35 /* Usage: call mtape_$set_mode (mtdp, mode, mode_index, mode_ptr, code); */
 11    36 dcl  mtape_$set_mode entry (ptr, char (*), fixed bin, ptr, fixed bin (35));
 11    37 
 11    38 /* Usage: call mtape_$stop_tape (mtdp, code); */
 11    39 dcl  mtape_$stop_tape entry (ptr, fixed bin (35));
 11    40 
 11    41 /* Usage: call mtape_$user_query (mtdp, query_code, code); */
 11    42 dcl  mtape_$user_query entry (ptr, fixed bin, fixed bin (35));
 11    43 
 11    44 /* Usage: call mtape_$volume_switch (mtdp, new_vs_ptr, code); */
 11    45 dcl  mtape_$volume_switch entry (ptr, ptr, fixed bin (35));
 11    46 
 11    47 /* Usage: call mtape_$write_block (mtdp, code); */
 11    48 dcl  mtape_$write_block entry (ptr, fixed bin (35));
 11    49 
 11    50 /* Usage: call mtape_$write_label (mtdp, lr_ptr, code); */
 11    51 dcl  mtape_$write_label entry (ptr, ptr, fixed bin (35));
 11    52 
 11    53 /* Usage: call pfm_utils_$file_search (mtdp, fi_ptr, vs_ptr, code); */
 11    54 dcl  pfm_utils_$file_search entry (ptr, ptr, ptr, fixed bin (35));
 11    55 
 11    56 /* Usage: call pfm_utils_$init_label_record (mtdp, link_tail, link_head, lr_ptr, length); */
 11    57 dcl  pfm_utils_$init_label_record entry (ptr, ptr, ptr, ptr, fixed bin (21));
 11    58 
 11    59 /* Usage: bool_unexpired = pfm_utils_$label_unexpired (label_date_string); */
 11    60 dcl  pfm_utils_$label_unexpired entry (char (*)) returns (bit (1) aligned);
 11    61 
 11    62 /* Usage: blk_yyddd = pfm_utils_$julian_date (date_time_string); */
 11    63 dcl  pfm_utils_$julian_date entry (char (*)) returns (char (6));
 11    64 
 11    65 /* Usage: call pfm_utils_$position_in_file (mtdp, fi_ptr, vs_ptr, position_constant, code); */
 11    66 dcl  pfm_utils_$position_in_file entry (ptr, ptr, ptr, fixed bin, fixed bin (35));
 11    67 
 11    68 /* Usage: call pfm_utils_$read_file_labels (mtdp, fi_ptr, vs_ptr, label_type, code); */
 11    69 dcl  pfm_utils_$read_file_labels entry (ptr, ptr, ptr, fixed bin, fixed bin (35));
 11    70 
 11    71 /* Usage: call pfm_utils_$setup_file (mtdp, fi_ptr, new_section); */
 11    72 dcl  pfm_utils_$setup_file entry (ptr, ptr, bit (1) aligned);
 11    73 
 11    74 /* Usage: call pfm_utils_$truncate_file_set (mtdp); */
 11    75 dcl  pfm_utils_$truncate_file_set entry (ptr);
 11    76 
 11    77 /* Usage: call pfm_utils_$write_file_labels (mtdp, label_type, code); */
 11    78 dcl  pfm_utils_$write_file_labels entry (ptr, fixed bin, fixed bin (35));
 11    79 
 11    80 /* END INCLUDE FILE mtape_dcls.incl.pl1 */
  1    23 
  1    24 
  1    25 /* END INCLUDE FILE mtape_includes.incl.pl1 */
     1405 
     1406 
 12     1 /* --------------- BEGIN include file rcp_volume_formats.incl.pl1 --------------- */
 12     2 
 12     3 
 12     4 
 12     5 /****^  HISTORY COMMENTS:
 12     6*  1) change(86-12-08,GWMay), approve(86-12-08,PBF7552),
 12     7*     audit(86-12-08,Martinson), install(86-12-17,MR12.0-1250):
 12     8*     added array entry 0 to the volume format types to indicate that the tape
 12     9*     volume was not authenticated by rcp.
 12    10*                                                   END HISTORY COMMENTS */
 12    11 
 12    12 
 12    13 /* General volume types */
 12    14 
 12    15 dcl (Volume_unauthenticated initial (0),
 12    16      Volume_blank initial (1),
 12    17      Volume_unknown_format initial (6),
 12    18      Volume_unreadable initial (7),
 12    19 
 12    20 /* Tape volume types */
 12    21 
 12    22      Volume_multics_tape initial (2),
 12    23      Volume_gcos_tape initial (3),
 12    24      Volume_ibm_tape initial (4),
 12    25      Volume_ansi_tape initial (5)) fixed bin static options (constant);
 12    26 
 12    27 /* Printable descriptions of volume types */
 12    28 
 12    29 dcl  Tape_volume_types (0:7) char (16) static options (constant) initial
 12    30     ("unauthenticated",
 12    31      "blank",
 12    32      "Multics",
 12    33      "GCOS",
 12    34      "IBM",
 12    35      "ANSI",
 12    36      "unrecognizable",
 12    37      "unreadable");
 12    38 
 12    39 /* ---------------- END include file rcp_volume_formats.incl.pl1 ---------------- */
     1407 
     1408 
 13     1 /*  BEGIN INCLUDE FILE:  ansi_vol1.incl.pl1                 */
 13     2 /*  Modified by J. A. Bush 11/06/82 for use by mtape_ */
 13     3 /*  format: style4 */
 13     4 
 13     5 dcl  ansi_vol1P ptr;				/* pointer on which ansi_vol1 is based */
 13     6 
 13     7 dcl  1 ansi_vol1 unaligned based (ansi_vol1P),		/* ANSI VOL1 label */
 13     8        2 label_id char (4),				/* "VOL1" */
 13     9        2 volume_id char (6),				/* volume identifier */
 13    10        2 access char (1),				/* " " if unlimited */
 13    11        2 reserved1 char (26),				/* blanks */
 13    12        2 owner_id,					/* Owner Identifier field (14 characters) */
 13    13          3 auth_code char (3),			/* Multics stores authenication code here */
 13    14          3 mult_id char (7),				/* inited with MULTICS_ANSI_VERSION */
 13    15          3 owner_id_pad char (4),			/* blanks */
 13    16        2 reserved2 char (28),				/* blanks */
 13    17        2 label_version char (1);			/* label standard version */
 13    18 
 13    19 dcl  ANSI_VOL1 char (4) int static options (constant) init ("VOL1");
 13    20 dcl  LABEL_STANDARD_VERSION char (1) int static options (constant) /* Label standard supported */
 13    21 	init ("3");				/* (currently to ANSI x3.27-1978) */
 13    22 dcl  MULTICS_ANSI_VERSION char (7) int static options (constant) /* current mtape_/ANSI version */
 13    23 	init ("MULT001");				/* goes in the owner_id2 field */
 13    24 
 13    25 /*  END INCLUDE FILE:  ansi_vol1.incl.pl1                   */
     1409 
 14     1 /* BEGIN INCLUDE FILE:  ansi_uvl1.incl.pl1 Created by J. A. Bush 11/07/82 */
 14     2 /* This include file defines the format of the ANSI user volume label record
 14     3*   (UVL1) used by the mtape_ ANSI Per-Format Module */
 14     4 
 14     5 /*  format: style4 */
 14     6 
 14     7 dcl  ansi_uvl1P ptr;				/* pointer on which ansi_uvl1 is based */
 14     8 
 14     9 dcl  1 ansi_uvl1 unaligned based (ansi_uvl1P),		/* ANSI UVL1 label */
 14    10        2 label_id char (4),				/* "UVL1" */
 14    11        2 auth_code char (3),				/* authentication code */
 14    12        2 init_date char (6),				/* Julian date volume initialized (" yyddd") */
 14    13        2 unused char (3),				/* Must be blanks */
 14    14        2 installation_id char (32),			/* Name of site volume initialized at */
 14    15        2 user_id char (32);				/* user id (person.project.tag) that initialized volume */
 14    16 
 14    17 dcl  ANSI_UVL1 char (4) int static options (constant) init ("UVL1");
 14    18 
 14    19 /*  END INCLUDE FILE:  ansi_uvl1.incl.pl1                   */
     1410 
     1411 
 15     1 /*  BEGIN INCLUDE FILE:  ansi_hdr1.incl.pl1                 */
 15     2 /*  Modified by J. A. Bush 11/07/82 for use by mtape_ */
 15     3 
 15     4 /* format: style4 */
 15     5 
 15     6 dcl  ansi_hdr1P ptr;				/* pointer on which ansi_hdr1 structure is based */
 15     7 
 15     8 dcl  1 ansi_hdr1 unaligned based (ansi_hdr1P),
 15     9        2 label_id char (4),				/* HDR1/EOF1/EOV1 */
 15    10        2 file_id char (17),				/* file identifier */
 15    11        2 set_id char (6),				/* file-set identifier */
 15    12        2 section char (4),				/* file section number */
 15    13        2 sequence char (4),				/* file sequence number (within file set) */
 15    14        2 generation char (4),				/* file generation number */
 15    15        2 version char (2),				/* generation version number */
 15    16        2 creation char (6),				/* file creation date - Julian form (" yyddd") */
 15    17        2 expiration char (6),				/* file expiration date - Julian form */
 15    18        2 access char (1),				/* file accessibility code */
 15    19        2 blkcnt char (6),				/* used by EOF1/EOV1, must be "000000" for HDR1 */
 15    20        2 system char (13),				/* system code = "MULTICS ANSI2" for mtape_ */
 15    21        2 reserved char (7);				/* must be spaces */
 15    22 
 15    23 
 15    24 dcl  ANSI_L1_ID (3) char (4) int static options (constant) init
 15    25 	("HDR1", "EOV1", "EOF1");
 15    26 dcl  (ANSI_HDR1 init (1),
 15    27      ANSI_EOV1 init (2),
 15    28      ANSI_EOF1 init (3)) fixed bin int static options (constant);
 15    29 dcl  ANSI_SYS_CODE char (13) int static options (constant) init ("MULTICS ANSI2");
 15    30 
 15    31 /*  END INCLUDE FILE:  ansi_hdr1.incl.pl1                   */
     1412 
     1413 
 16     1 /*  BEGIN INCLUDE FILE:  ansi_hdr2.incl.pl1                 */
 16     2 /*  Modified by J. A. Bush 11/07/82 for use by mtape_ */
 16     3 
 16     4 /* format: style4 */
 16     5 
 16     6 dcl  ansi_hdr2P ptr;				/* pointer on which ansi_hdr2 structure is based */
 16     7 
 16     8 dcl  1 ansi_hdr2 unaligned based (ansi_hdr2P),
 16     9        2 label_id char (4),				/* HDR2/EOF2/EOV2 */
 16    10        2 format char (1),				/* U, F, D, or S */
 16    11        2 blklen char (5),				/* maximum number of characters per block */
 16    12        2 reclen char (5),				/* maximum or actual record length - meaning varies with format */
 16    13        2 system_use,				/* 35 characters reserved for system-specific use */
 16    14          3 next_volname char (32),			/* next volume name - for trailer label */
 16    15          3 blocked char (1),				/* blocking attribute: 0 - no / 1 - yes */
 16    16          3 mode char (1),				/* data encoding mode */
 16    17 						/* 1 - ASCII, 9 mode */
 16    18 						/* 2 - EBCDIC, 9 mode */
 16    19 						/* 3 - binary */
 16    20          3 system_reserved char (1),			/* reserved for future use */
 16    21        2 buffer_offset char (2),			/* meaningful only if HDR1 system code ^= "" */
 16    22        2 reserved char (28);				/* spaces */
 16    23 
 16    24 /* Old HDR2 system use field, pre-secure-authentication */
 16    25 
 16    26 dcl  1 old_ansi_hdr2_system_use based (addr (ansi_hdr2.system_use)),
 16    27        2 canonical_next_volname char (6),		/* next volume name - for trailer label */
 16    28        2 blocked char (1),				/* blocking attribute: 0 - no / 1 - yes */
 16    29        2 mode char (1),				/* data encoding mode (same as above) */
 16    30        2 system_reserved char (27);			/* blanks */
 16    31 
 16    32 dcl  ANSI_L2_ID (3) char (4) int static options (constant) init
 16    33 	("HDR2", "EOV2", "EOF2");
 16    34 dcl  (ANSI_HDR2 init (1),
 16    35      ANSI_EOV2 init (2),
 16    36      ANSI_EOF2 init (3)) fixed bin int static options (constant);
 16    37 
 16    38 /*  END INCLUDE FILE:  ansi_hdr2.incl.pl1  */
     1414 
     1415 
 17     1 /* Begin include file ..... iox_modes.incl.pl1 */
 17     2 
 17     3 /* Written by C. D. Tavares, 03/17/75 */
 17     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
 17     5 
 17     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
 17     7     ("stream_input", "stream_output", "stream_input_output",
 17     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
 17     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
 17    10      "direct_input", "direct_output", "direct_update");
 17    11 
 17    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
 17    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
 17    14 
 17    15 dcl (Stream_input initial (1),
 17    16      Stream_output initial (2),
 17    17      Stream_input_output initial (3),
 17    18      Sequential_input initial (4),
 17    19      Sequential_output initial (5),
 17    20      Sequential_input_output initial (6),
 17    21      Sequential_update initial (7),
 17    22      Keyed_sequential_input initial (8),
 17    23      Keyed_sequential_output initial (9),
 17    24      Keyed_sequential_update initial (10),
 17    25      Direct_input initial (11),
 17    26      Direct_output initial (12),
 17    27      Direct_update initial (13)) fixed bin int static options (constant);
 17    28 
 17    29 /* End include file ..... iox_modes.incl.pl1 */
     1416 
     1417 
     1418      end ansi_tape_io_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/10/00  1525.0  ansi_tape_io_.pl1                 >udd>sm>ds>y2k>update>ansi_tape_io_.pl1
1405         1    02/16/84  1452.3  mtape_includes.incl.pl1           >ldd>incl>mtape_includes.incl.pl1
1-5          2    02/16/84  1452.3  mtape_data.incl.pl1               >ldd>incl>mtape_data.incl.pl1
1-7          3    02/16/84  1452.4  mtape_vol_set.incl.pl1            >ldd>incl>mtape_vol_set.incl.pl1
1-9          4    02/16/84  1452.3  mtape_label_record.incl.pl1       >ldd>incl>mtape_label_record.incl.pl1
1-11         5    02/16/84  1452.3  mtape_err_stats.incl.pl1          >ldd>incl>mtape_err_stats.incl.pl1
1-13         6    02/16/84  1452.3  mtape_file_info.incl.pl1          >ldd>incl>mtape_file_info.incl.pl1
1-15         7    02/16/84  1452.3  mtape_attach_info.incl.pl1        >ldd>incl>mtape_attach_info.incl.pl1
1-17         8    02/16/84  1452.4  mtape_pfm_info.incl.pl1           >ldd>incl>mtape_pfm_info.incl.pl1
1-19         9    06/11/85  1429.6  mtape_open_close_info.incl.pl1    >ldd>incl>mtape_open_close_info.incl.pl1
1-21        10    02/16/84  1452.3  mtape_constants.incl.pl1          >ldd>incl>mtape_constants.incl.pl1
1-23        11    01/27/00  1752.3  mtape_dcls.incl.pl1               >udd>sm>ds>y2k>update>mtape_dcls.incl.pl1
1407        12    12/17/86  1550.5  rcp_volume_formats.incl.pl1       >ldd>incl>rcp_volume_formats.incl.pl1
1409        13    10/06/83  1413.4  ansi_vol1.incl.pl1                >ldd>incl>ansi_vol1.incl.pl1
1410        14    10/06/83  1413.4  ansi_uvl1.incl.pl1                >ldd>incl>ansi_uvl1.incl.pl1
1412        15    10/06/83  1413.4  ansi_hdr1.incl.pl1                >ldd>incl>ansi_hdr1.incl.pl1
1414        16    10/06/83  1413.4  ansi_hdr2.incl.pl1                >ldd>incl>ansi_hdr2.incl.pl1
1416        17    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>incl>iox_modes.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ANSI_ASCII_PAD_CHAR                    constant        char(1)                  initial packed unaligned dcl 115 ref 1381
ANSI_EBCDIC_PAD_CHAR                   constant        char(1)                  initial packed unaligned dcl 116 ref 1379
ANSI_EOF1                              constant        fixed bin(17,0)          initial dcl 15-26 ref 634
ANSI_FORMAT_CODES               000100 constant        char(3)                  initial array packed unaligned dcl 128 set ref 600
                                                                                  601 702 710 1138* 1264 1265
ANSI_HDR1                              constant        fixed bin(17,0)          initial dcl 15-26 ref 535
ANSI_HDR2                              constant        fixed bin(17,0)          initial dcl 16-34 ref 558
ANSI_L1_ID                      000032 constant        char(4)                  initial array packed unaligned dcl 15-24 ref 535 634
                                                                                  674 866 1079 1095
ANSI_L2_ID                      000023 constant        char(4)                  initial array packed unaligned dcl 16-32 ref 558 701
ANSI_SYS_CODE                   000026 constant        char(13)                 initial packed unaligned dcl 15-29 ref 555 696 870
ANSI_UVL1                       000035 constant        char(4)                  initial packed unaligned dcl 14-17 ref 1055
ANSI_VOL1                       000040 constant        char(4)                  initial packed unaligned dcl 13-19 ref 861 1045
AT_BOFH                         000236 constant        fixed bin(17,0)          initial dcl 10-44 set ref 1345 1346*
AT_EOF                                 constant        fixed bin(17,0)          initial dcl 10-44 ref 333
AT_EOFH                                constant        fixed bin(17,0)          initial dcl 10-44 ref 341
BLANK_VOLUME                           constant        fixed bin(17,0)          initial dcl 3-42 ref 231
BOF_LABEL                       000236 constant        fixed bin(17,0)          initial dcl 10-56 set ref 256* 272* 289* 691 767 801
                                                                                  866 928* 1079
DUMMY_LABEL                     000111 constant        char(76)                 initial packed unaligned dcl 124 ref 1079
EOF_LABEL                       000234 constant        fixed bin(17,0)          initial dcl 10-56 set ref 320* 334* 341* 966 1095
EOV_LABEL                       000232 constant        fixed bin(17,0)          initial dcl 10-56 set ref 629* 667 713 913* 968
LABEL_LENGTH                    000134 constant        fixed bin(21,0)          initial dcl 110 set ref 170 205* 237 876* 1038*
LABEL_STANDARD_VERSION                 constant        char(1)                  initial packed unaligned dcl 13-20 ref 1051
LC                              000071 constant        char(26)                 initial packed unaligned dcl 130 ref 1261 1312
MAX_ANSI_RECORD_SIZE                   constant        fixed bin(17,0)          initial dcl 111 ref 705
MTAPE_ALLOC_FI                  000234 constant        fixed bin(17,0)          initial dcl 10-9 set ref 212*
MTAPE_ALLOC_VS                  000236 constant        fixed bin(17,0)          initial dcl 10-9 set ref 617*
MTAPE_CV_EBCDIC                        constant        fixed bin(17,0)          initial dcl 10-34 ref 593 721 1188 1195 1224 1317
                                                                                  1379
MTAPE_CV_UC_ASCII                      constant        fixed bin(17,0)          initial dcl 10-34 ref 665
MTAPE_HWM_BIN                          constant        fixed bin(17,0)          initial dcl 10-27 ref 589 719 1319
MTAPE_HWM_NINE                         constant        fixed bin(17,0)          initial dcl 10-27 ref 576 1313 1316
MTAPE_NO_CONVERSION                    constant        fixed bin(17,0)          initial dcl 10-34 ref 577 717 1311
MTAPE_UNSPECIFIED                      constant        fixed bin(17,0)          initial dcl 10-34 ref 1296 1353 1370 1373 1375 1377
MTAPE_VOLUME                           constant        fixed bin(17,0)          initial dcl 3-42 ref 862 1099
MULTICS_ANSI_VERSION            000036 constant        char(7)                  initial packed unaligned dcl 13-22 ref 862 1050
MULT_PRIOR_VOLUME                      constant        fixed bin(17,0)          initial dcl 3-42 ref 870
NON_MOD_FOUR                           constant        fixed bin(17,0)          initial dcl 114 ref 574 1372
NON_MULT_VOLUME                        constant        fixed bin(17,0)          initial dcl 3-42 ref 575 615 864 870 1243
OPENING                                constant        bit(1)                   initial dcl 113 set ref 273* 290*
Q_NO_NEXT_VOLUME                000236 constant        fixed bin(17,0)          initial dcl 10-63 set ref 669*
Q_UNEXPIRED_FILE                000227 constant        fixed bin(17,0)          initial dcl 10-63 set ref 1343*
Q_UNEXPIRED_VOLUME              000234 constant        fixed bin(17,0)          initial dcl 10-63 set ref 1021*
RCW_LENGTH                             constant        fixed bin(17,0)          initial dcl 117 set ref 378 387 463 466 469* 469*
RECOG_FORMAT_VOLUME                    constant        fixed bin(17,0)          initial dcl 3-42 ref 236
SCW_LENGTH                             constant        fixed bin(17,0)          initial dcl 118 set ref 392 478 489 493 498* 498 901
SEG_B_E                                constant        fixed bin(17,0)          initial dcl 119 ref 399 409 480 902
SEG_B_NE                               constant        fixed bin(17,0)          initial dcl 119 ref 399 486
SEG_NB_E                               constant        fixed bin(17,0)          initial dcl 119 ref 409 482 902
SEG_NB_NE                              constant        fixed bin(17,0)          initial dcl 119 ref 488
Schecked_labels                 000100 automatic       bit(1)                   dcl 84 set ref 330* 335* 341
Sequential_input                       constant        fixed bin(17,0)          initial dcl 17-15 ref 218 306 1275
Sequential_output                      constant        fixed bin(17,0)          initial dcl 17-15 ref 219
UC                              000062 constant        char(26)                 initial packed unaligned dcl 132 ref 1261 1312
UNLABELED_VOLUME                       constant        fixed bin(17,0)          initial dcl 3-42 ref 234
U_LABEL_ID                      000106 constant        char(3)                  initial array packed unaligned dcl 126 set ref 605
                                                                                  605 626 626 648 648 738* 745
Volume_ansi_tape                       constant        fixed bin(17,0)          initial dcl 12-15 ref 228 1098
Volume_blank                           constant        fixed bin(17,0)          initial dcl 12-15 ref 231
Volume_unknown_format                  constant        fixed bin(17,0)          initial dcl 12-15 ref 234
Volume_unreadable                      constant        fixed bin(17,0)          initial dcl 12-15 ref 231
WRITING                                constant        bit(1)                   initial dcl 112 set ref 314* 439* 931 1397*
access                    2(18)        based           char(1)                  level 2 in structure "ansi_vol1" packed packed
                                                                                  unaligned dcl 13-7 in procedure "ansi_tape_io_"
                                                                                  set ref 1048*
access                   15(09)        based           char(1)                  level 2 in structure "ansi_hdr1" packed packed
                                                                                  unaligned dcl 15-8 in procedure "ansi_tape_io_"
                                                                                  set ref 690*
ad_file_format          201            based           fixed bin(17,0)          level 3 dcl 2-8 ref 361 443 998 1138 1191 1191
addr                                                   builtin function         dcl 153 ref 388 402 407 468 494 499 584 586 775 775
                                                                                  780 780 938 939 1025 1025 1194 1195 1195 1205 1228
                                                                                  1234
all_buf_ptrs                           based           pointer                  array dcl 2-113 ref 938 939
ansi_hdr1                              based           structure                level 1 packed packed unaligned dcl 15-8
ansi_hdr1P                      000250 automatic       pointer                  dcl 15-6 set ref 532* 535 547 548 549 550 551 552
                                                                                  553 554 555 610 634 645 646 673* 674 676 676 678
                                                                                  678 681 683 685 687 688 689 690 693 695 696 869*
                                                                                  870 873
ansi_hdr2                              based           structure                level 1 packed packed unaligned dcl 16-8
ansi_hdr2P                      000252 automatic       pointer                  dcl 16-6 set ref 532* 558 568 571 572 573 578 579
                                                                                  581 584 586 621 621 700* 701 702 704 707 709 710
                                                                                  712 714 719 721 723 725
ansi_uvl1                              based           structure                level 1 packed packed unaligned dcl 14-9
ansi_uvl1P                      000246 automatic       pointer                  dcl 14-7 set ref 1054* 1055 1056 1057 1059 1060
ansi_vol1                              based           structure                level 1 packed packed unaligned dcl 13-7
ansi_vol1P                      000244 automatic       pointer                  dcl 13-5 set ref 852* 861 862 866 869 885 1044* 1045
                                                                                  1046 1046 1048 1049 1050 1051
areap                     2            based           pointer                  level 2 dcl 2-8 ref 214
arg_buf_len              50            based           fixed bin(21,0)          level 3 dcl 2-8 ref 356 430
arg_buf_ptr              46            based           pointer                  level 3 dcl 2-8 ref 355 429 499 1228
arg_code                               parameter       fixed bin(35,0)          dcl 73 set ref 194 240* 247 293* 301 346* 352 421*
                                                                                  426 502* 508 514* 519 654* 660 750* 1332*
arg_convert                            parameter       fixed bin(17,0)          dcl 80 set ref 660 665* 717*
arg_info_ptr                           parameter       pointer                  dcl 74 ref 508 512
arg_io_call_infop                      parameter       pointer                  dcl 75 ref 508
arg_labno                              parameter       fixed bin(17,0)          dcl 78 set ref 519 526* 538 538* 560 560* 610 614
                                                                                  637 637* 660 666 699 728 730
arg_lr_ptr                             parameter       pointer                  dcl 77 ref 519 522 660 663
arg_mtdp                               parameter       pointer                  dcl 72 ref 194 247 301 352 354 426 428 508 519 660
                                                                                  1326
arg_order_name                         parameter       char                     packed unaligned dcl 76 ref 508 511
arg_rec_len              51            based           fixed bin(21,0)          level 3 dcl 2-8 set ref 416*
arg_type                               parameter       fixed bin(17,0)          dcl 79 set ref 519 533 605 605 626 626 648 648 660
                                                                                  667 674 691 701 713 732* 738 745
ascii_to_ebcdic_                000052 constant        entry                    external dcl 165 ref 1188 1195
attach_info_ptr         274            based           pointer                  level 2 dcl 2-8 ref 1154 1329
auth_code                       000153 automatic       char(3)                  dcl 92 in procedure "ansi_tape_io_" set ref 1036*
                                                                                  1049 1056
auth_code                 1            based           char(3)                  level 2 in structure "ansi_uvl1" packed packed
                                                                                  unaligned dcl 14-9 in procedure "ansi_tape_io_"
                                                                                  set ref 1056*
auth_code                11(09)        based           char(3)                  level 3 in structure "ansi_vol1" packed packed
                                                                                  unaligned dcl 13-7 in procedure "ansi_tape_io_"
                                                                                  set ref 1049*
authenticate_                   000046 constant        entry                    external dcl 163 ref 1036
based_area                             based           area(1024)               dcl 169 ref 214
based_label_record                     based           char(80)                 packed unaligned dcl 170 set ref 526 526 526* 538
                                                                                  538 538* 560 560 560* 605 626 637 637 637* 648
                                                                                  664* 745* 804 809 810 880* 880 1079* 1095*
based_lrec_data                        based           char                     packed unaligned dcl 171 set ref 1188* 1188* 1190*
                                                                                  1190 1224* 1224* 1226* 1226
based_lrec_index                       based           char(1)                  array packed unaligned dcl 172 set ref 499 1228
binary                                                 builtin function         dcl 153 ref 385 549 550 551 552 568 571 572 581 586
                                                                                  610 645 646 775 775 899 900
blk_prefix_wds                         based           fixed bin(35,0)          array dcl 1121 set ref 1124* 1124*
blkcnt                   15(18)        based           char(6)                  level 2 packed packed unaligned dcl 15-8 set ref 610
                                                                                  645 693* 695*
blklen                    1(09)        based           char(5)                  level 2 packed packed unaligned dcl 16-8 set ref 571
                                                                                  704*
block_count             156            based           fixed bin(35,0)          level 3 dcl 6-8 set ref 279 610* 645* 692
block_length             66            based           fixed bin(35,0)          level 3 dcl 9-10 ref 1375
block_no                        000113 automatic       fixed bin(21,0)          dcl 953 set ref 986* 988 991* 995
block_number              1            based           fixed dec(7,0)           level 2 packed packed unaligned dcl 175 set ref 939*
                                                                                  986 1391*
block_size                             based           fixed dec(7,0)           level 2 in structure "native_bo_contents" packed
                                                                                  packed unaligned dcl 175 in procedure
                                                                                  "ansi_tape_io_" set ref 985 1390*
block_size               63            based           fixed bin(21,0)          level 3 in structure "mtape_file_info" dcl 6-8
                                                                                  in procedure "ansi_tape_io_" set ref 571* 703 1375
                                                                                  1375*
block_size              176            based           fixed bin(21,0)          level 3 in structure "mtape_data" dcl 2-8
                                                                                  in procedure "ansi_tape_io_" ref 1171 1200
blocked                   1(18)        based           char(1)                  level 2 in structure "old_ansi_hdr2_system_use"
                                                                                  packed packed unaligned dcl 16-26 in procedure
                                                                                  "ansi_tape_io_" ref 584
blocked                  13(27)        based           char(1)                  level 3 in structure "ansi_hdr2" packed packed
                                                                                  unaligned dcl 16-8 in procedure "ansi_tape_io_"
                                                                                  set ref 578 579 710* 712*
bof_prefix               13            based           char(3)                  level 2 dcl 8-8 set ref 220*
buf_len                         000104 automatic       fixed bin(21,0)          dcl 86 set ref 356* 430* 445* 447 452* 456 461* 463
                                                                                  465 472* 474 1218 1220 1222* 1222
buf_ptr                         000102 automatic       pointer                  dcl 85 set ref 355* 429* 432 499* 1188 1190 1214
                                                                                  1224 1226 1228*
buf_ptrs                 62            based           pointer                  array level 3 dcl 2-8 set ref 936 938 939
buffer_offset           175            based           fixed bin(17,0)          level 3 in structure "mtape_data" dcl 2-8
                                                                                  in procedure "ansi_tape_io_" ref 311 433
buffer_offset            14(18)        based           char(2)                  level 2 in structure "ansi_hdr2" packed packed
                                                                                  unaligned dcl 16-8 in procedure "ansi_tape_io_"
                                                                                  set ref 568 725*
buffer_offset            61            based           fixed bin(17,0)          level 3 in structure "mtape_file_info" dcl 6-8
                                                                                  in procedure "ansi_tape_io_" set ref 568* 569 724
                                                                                  1355* 1359*
bytes_processed                 000203 automatic       fixed bin(21,0)          dcl 99 set ref 475* 492* 492 499
bytes_remaining                 000202 automatic       fixed bin(21,0)          dcl 99 set ref 474* 478 483 490* 490
close_info_ptr          300            based           pointer                  level 2 dcl 2-8 ref 204 304
code                            000214 automatic       fixed bin(35,0)          dcl 105 set ref 240 251* 252 261 261 261 267 269*
                                                                                  271 272* 273 289* 290 293 313* 314 314 317 320*
                                                                                  321 325* 326 339* 341 346 357* 418 418* 421 431*
                                                                                  435* 436 436 502 525* 526* 654 669* 670 732* 734
                                                                                  734 738* 741* 748* 750 762* 764* 765 768* 769*
                                                                                  782* 783* 788* 830* 831* 845* 846 847* 855* 856
                                                                                  857* 884* 885 885* 913* 914 917* 918 919* 925 928*
                                                                                  929 932* 933 934* 935 942* 957* 958 958 963* 970
                                                                                  974* 975* 989* 990* 991* 1021* 1022 1025* 1026
                                                                                  1027* 1062* 1063 1064* 1081* 1082 1083* 1088* 1089
                                                                                  1090* 1103* 1104 1105* 1109* 1110 1110* 1123*
                                                                                  1124* 1137* 1138* 1168* 1171* 1173 1332* 1343*
                                                                                  1344 1346* 1347 1393* 1394 1394 1398
conversion              174            based           fixed bin(17,0)          level 3 in structure "mtape_data" dcl 2-8
                                                                                  in procedure "ansi_tape_io_" ref 1188 1195 1224
                                                                                  1379
conversion                      000216 stack reference condition                dcl 156 in procedure "ansi_tape_io_" ref 384 386 396
                                                                                  414 524
conversion               60            based           fixed bin(17,0)          level 3 in structure "mtape_file_info" dcl 6-8
                                                                                  in procedure "ansi_tape_io_" set ref 577* 593* 721
                                                                                  1311* 1317*
copy                                                   builtin function         dcl 153 ref 1194
creation                 12(09)        based           char(6)                  level 2 packed packed unaligned dcl 15-8 set ref 553
                                                                                  688*
creation_date            45            based           char(6)                  level 3 dcl 6-8 set ref 553* 688 1363*
crl                             000201 automatic       fixed bin(21,0)          dcl 99 set ref 363* 369* 372* 373 385* 387 401 900*
                                                                                  901 1232
cur_block               160            based           structure                level 3 dcl 2-8
cur_buf_idx             145            based           fixed bin(17,0)          level 3 dcl 2-8 ref 936 938
cur_buf_ptr             160            based           pointer                  level 4 dcl 2-8 ref 381 985 986 1000 1004 1124 1124
                                                                                  1194 1195 1195 1205 1234 1355 1390 1391
current_file            160            based           structure                level 2 dcl 2-8
cwl                                    parameter       fixed bin(17,0)          dcl 1183 ref 1181 1199
data_buffers             62            based           structure                level 2 dcl 2-8
data_xfer_args           46            based           structure                level 2 dcl 2-8
db_record                              based           structure                level 1 packed packed unaligned dcl 179
default_fix_rlen         72            based           fixed bin(35,0)          level 3 dcl 9-10 ref 1301
default_span_rlen        70            based           fixed bin(35,0)          level 3 dcl 9-10 ref 1297
default_var_rlen         71            based           fixed bin(35,0)          level 3 dcl 9-10 ref 1299
density                   2            based           fixed bin(35,0)          level 2 dcl 7-8 set ref 1025 1025 1027* 1097
desc_type                       000173 automatic       fixed bin(17,0)          dcl 98 set ref 399 399 409 409 480* 482* 486* 488*
                                                                                  495 899* 902 902
divide                                                 builtin function         dcl 153 ref 1003
ebcdic_to_ascii_                000050 constant        entry                    external dcl 164 ref 1224
eof_prefix               15            based           char(3)                  level 2 dcl 8-8 set ref 222*
eov_prefix               14            based           char(3)                  level 2 dcl 8-8 set ref 221*
err_entry                              based           structure                level 1 dcl 5-12
error_lock               52            based           fixed bin(35,0)          level 2 dcl 2-8 ref 309 310
error_table_$bad_file           000020 external static fixed bin(35,0)          dcl 141 ref 768 782 974
error_table_$data_seq_error     000030 external static fixed bin(35,0)          dcl 145 ref 990
error_table_$end_of_info        000010 external static fixed bin(35,0)          dcl 137 ref 734 741 748 958
error_table_$eov_on_write       000012 external static fixed bin(35,0)          dcl 138 ref 314 436 1394
error_table_$invalid_file_set_format
                                000032 external static fixed bin(35,0)          dcl 146 ref 1123
error_table_$invalid_label_format
                                000034 external static fixed bin(35,0)          dcl 147 set ref 525 538* 560* 637*
error_table_$invalid_record_desc
                                000016 external static fixed bin(35,0)          dcl 140 ref 1137
error_table_$long_record        000014 external static fixed bin(35,0)          dcl 139 ref 418 1168 1171
error_table_$no_file            000024 external static fixed bin(35,0)          dcl 143 ref 261
error_table_$no_next_volume     000026 external static fixed bin(35,0)          dcl 144 ref 309
error_table_$no_operation       000022 external static fixed bin(35,0)          dcl 142 ref 514
error_table_$unimplemented_version
                                000036 external static fixed bin(35,0)          dcl 148 ref 830
error_table_$uninitialized_volume
                                000040 external static fixed bin(35,0)          dcl 149 ref 261
expiration               35            based           char(24)                 level 2 in structure "mtape_open_info" dcl 9-10
                                                                                  in procedure "ansi_tape_io_" ref 1364 1364
expiration               13(27)        based           char(6)                  level 2 in structure "ansi_hdr1" packed packed
                                                                                  unaligned dcl 15-8 in procedure "ansi_tape_io_"
                                                                                  set ref 554 689* 873*
expiration_date          47            based           char(6)                  level 3 dcl 6-8 set ref 554* 689 1340 1364* 1366*
extend                   77            based           bit(1)                   level 3 dcl 9-10 ref 1245 1285
extended_error_recovery
                         20            based           bit(1)                   level 2 dcl 8-8 set ref 226*
fi_current               34            based           pointer                  level 2 dcl 2-8 ref 1153 1328
fi_ptr                          000232 automatic       pointer                  dcl 6-4 set ref 212* 213* 214 251* 279 283 283 288
                                                                                  288 333 339* 341 538 547 548 549 550 551 552 553
                                                                                  554 555 560 568 569 569 571 572 574 576 577 589
                                                                                  593 599 601 605 610 628 637 645 646 648 676 678
                                                                                  680 682 684 686 688 689 692 702 703 705 706 710
                                                                                  719 721 724 732 763* 763 764* 774 775 775 777 777
                                                                                  780 780 799 801 803 811 926* 927* 961* 1138 1138
                                                                                  1138 1138 1153* 1263 1265 1297 1297 1299 1299 1301
                                                                                  1303 1311 1313 1316 1317 1319 1328* 1340 1340 1345
                                                                                  1346* 1350* 1353 1355 1358 1359 1361 1362 1363
                                                                                  1364 1366 1370 1372 1373 1375 1375 1377
file_blocked            202            based           bit(1)                   level 3 dcl 2-8 ref 1201
file_code                51            based           char(3)                  level 3 dcl 6-8 set ref 599* 1263* 1297 1299
file_format              43            based           char(3)                  level 2 in structure "mtape_open_info" dcl 9-10
                                                                                  in procedure "ansi_tape_io_" ref 1261
file_format              52            based           fixed bin(17,0)          level 3 in structure "mtape_file_info" dcl 6-8
                                                                                  in procedure "ansi_tape_io_" set ref 601* 702 710
                                                                                  1138 1265* 1370
file_id                   1            based           char(17)                 level 2 in structure "ansi_hdr1" packed packed
                                                                                  unaligned dcl 15-8 in procedure "ansi_tape_io_"
                                                                                  set ref 547 676* 676
file_id                  25            based           char(32)                 level 3 in structure "mtape_file_info" dcl 6-8
                                                                                  in procedure "ansi_tape_io_" set ref 538* 547*
                                                                                  560* 637* 676 783* 1138*
file_set_id              35            based           char(32)                 level 3 dcl 6-8 set ref 548* 678
first_file              205            based           bit(1)                   level 3 dcl 2-8 ref 1247
first_file_lab_ptr        6            based           pointer                  level 2 dcl 6-8 ref 803
first_file_trail_ptr     12            based           pointer                  level 2 dcl 6-8 ref 801
first_file_unexpired    113            based           bit(1)                   level 2 dcl 3-9 set ref 873* 1019
first_vl_ptr             12            based           pointer                  level 2 dcl 3-9 set ref 851 876* 1033 1038*
fixed                                                  builtin function         dcl 153 ref 810
fl_code                         000215 automatic       fixed bin(35,0)          dcl 105 set ref 961* 962 963
flrp                            000264 automatic       pointer                  dcl 797 set ref 801* 803* 804
force                   100            based           bit(1)                   level 3 dcl 9-10 ref 1019 1340
format                    1            based           char(1)                  level 2 packed packed unaligned dcl 16-8 set ref 573
                                                                                  702*
gen_version              55            based           fixed bin(17,0)          level 3 dcl 6-8 set ref 283* 283 552* 646* 686 1362*
generation               54            based           fixed bin(17,0)          level 3 in structure "mtape_file_info" dcl 6-8
                                                                                  in procedure "ansi_tape_io_" set ref 288* 288 551*
                                                                                  684 1361*
generation               10(27)        based           char(4)                  level 2 in structure "ansi_hdr1" packed packed
                                                                                  unaligned dcl 15-8 in procedure "ansi_tape_io_"
                                                                                  set ref 551 685*
get_group_id_                   000044 constant        entry                    external dcl 162 ref 1060
hbound                                                 builtin function         dcl 153 ref 600 1264
hdw_mode                173            based           fixed bin(17,0)          level 3 in structure "mtape_data" dcl 2-8
                                                                                  in procedure "ansi_tape_io_" set ref 788* 932*
hdw_mode                 57            based           fixed bin(17,0)          level 3 in structure "mtape_file_info" dcl 6-8
                                                                                  in procedure "ansi_tape_io_" set ref 576* 589* 719
                                                                                  1313* 1316* 1319* 1373
htype                                  parameter       fixed bin(17,0)          dcl 796 set ref 794 801 811*
i                               000172 automatic       fixed bin(17,0)          dcl 98 in procedure "ansi_tape_io_" set ref 600* 601
                                                                                  601* 810* 811* 854* 868* 938* 939 939* 1037* 1043
                                                                                  1064* 1080* 1083* 1090* 1264* 1265 1265*
i                               000114 automatic       fixed bin(21,0)          dcl 953 in procedure "GET_NXT_RECORD" set ref 999*
                                                                                  1000 1000 1000 1000 1004* 1004*
illegal_procedure               000000 stack reference condition                dcl 157 ref 984 987
index                                                  builtin function         dcl 153 ref 1297 1299
info_ptr                        000116 automatic       pointer                  dcl 89 set ref 512*
init_date                 1(27)        based           char(6)                  level 2 packed packed unaligned dcl 14-9 set ref
                                                                                  1057*
init_to_zero             66            based           structure                level 2 in structure "mtape_open_info" dcl 9-10
                                                                                  in procedure "ansi_tape_io_"
init_to_zero             34            based           structure                level 2 in structure "mtape_close_info" dcl 9-41
                                                                                  in procedure "ansi_tape_io_"
install_id                      000120 automatic       char(32)                 packed unaligned dcl 90 set ref 1058* 1059
installation_id           4            based           char(32)                 level 2 packed packed unaligned dcl 14-9 set ref
                                                                                  1059*
iocb_ptr                  4            based           pointer                  level 2 dcl 2-8 set ref 732* 811*
j                               000115 automatic       fixed bin(21,0)          dcl 953 set ref 1003* 1004
lab_buf_len             152            based           fixed bin(21,0)          level 3 dcl 2-8 set ref 237*
lab_ptr                   6            based           pointer                  level 2 dcl 4-8 ref 526 526 526 532 538 538 538 560
                                                                                  560 560 605 626 637 637 637 648 664 673 700 745
                                                                                  804 809 810 852 880 880 1044 1054 1079 1095
label_buffer            150            based           structure                level 2 dcl 2-8
label_entry_present     104            based           bit(1)                   level 3 dcl 9-10 ref 728 799
label_id                               based           char(4)                  level 2 in structure "ansi_uvl1" packed packed
                                                                                  unaligned dcl 14-9 in procedure "ansi_tape_io_"
                                                                                  set ref 1055*
label_id                               based           char(4)                  level 2 in structure "ansi_hdr1" packed packed
                                                                                  unaligned dcl 15-8 in procedure "ansi_tape_io_"
                                                                                  set ref 535 634 674*
label_id                               based           char(4)                  level 2 in structure "ansi_vol1" packed packed
                                                                                  unaligned dcl 13-7 in procedure "ansi_tape_io_"
                                                                                  set ref 861 866 885* 1045*
label_id                               based           char(4)                  level 2 in structure "ansi_hdr2" packed packed
                                                                                  unaligned dcl 16-8 in procedure "ansi_tape_io_"
                                                                                  set ref 558 701*
label_type                      000174 automatic       fixed bin(17,0)          dcl 98 set ref 764* 767 769* 961* 966 968
label_version            23(27)        based           char(1)                  level 2 packed packed unaligned dcl 13-7 set ref
                                                                                  1051*
last_vl_ptr              14            based           pointer                  level 2 dcl 3-9 set ref 876* 1038* 1071 1072*
lbound                                                 builtin function         dcl 153 ref 936 938
length                  164            based           fixed bin(21,0)          level 4 in structure "mtape_data" dcl 2-8
                                                                                  in procedure "ansi_tape_io_" set ref 985* 996 1000
                                                                                  1000 1000* 1000 1003 1004 1006* 1006 1008 1233
length                                                 builtin function         dcl 153 in procedure "ansi_tape_io_" ref 605 626 648
length                                 parameter       fixed bin(21,0)          dcl 1164 in procedure "LONG_RECORD_CHECK" ref 1162
                                                                                  1168 1171
length_mode             172            based           fixed bin(17,0)          level 3 in structure "mtape_data" dcl 2-8
                                                                                  in procedure "ansi_tape_io_" set ref 934*
length_mode              62            based           fixed bin(17,0)          level 3 in structure "mtape_file_info" dcl 6-8
                                                                                  in procedure "ansi_tape_io_" set ref 574* 1372*
log_record              167            based           fixed bin(21,0)          level 4 dcl 2-8 set ref 1138*
log_record_ptr          162            based           pointer                  level 4 dcl 2-8 set ref 365 374 385 388 402* 402 407
                                                                                  448 457 467 468 494 496 497 896 899 900 1205*
                                                                                  1234*
long_record                     000161 automatic       bit(1)                   dcl 96 set ref 358* 418 1217 1219*
lr_ptr                          000230 automatic       pointer                  dcl 4-4 set ref 522* 526 526 526 532 538 538 538 560
                                                                                  560 560 605 626 637 637 637 648 663* 664 673 700
                                                                                  745 804* 804* 806 807* 807 807* 809 810* 813 876*
                                                                                  879* 880 881 1038* 1041* 1042 1044 1054 1062* 1071
                                                                                  1072 1073 1078* 1079 1081* 1095
maip                            000234 automatic       pointer                  dcl 7-4 set ref 208* 1025 1025 1027 1097 1154* 1329*
maxlength                                              builtin function         dcl 153 ref 676 678 1046
mcip                            000242 automatic       pointer                  dcl 9-5 set ref 204* 210* 304* 338 339
min_len                                parameter       fixed bin(17,0)          dcl 1184 ref 1181 1203
mod                                                    builtin function         dcl 153 ref 283 288 999
mode                      1(27)        based           char(1)                  level 2 in structure "old_ansi_hdr2_system_use"
                                                                                  packed packed unaligned dcl 16-26 in procedure
                                                                                  "ansi_tape_io_" ref 586
mode                     14            based           char(1)                  level 3 in structure "ansi_hdr2" packed packed
                                                                                  unaligned dcl 16-8 in procedure "ansi_tape_io_"
                                                                                  set ref 581 719* 721* 723*
modify                  103            based           bit(1)                   level 3 dcl 9-10 ref 1245 1283
module_id                 2            based           char(21)                 level 2 dcl 8-8 set ref 223*
moip                            000240 automatic       pointer                  dcl 9-4 set ref 209* 306 728 732 799 811 1019 1155*
                                                                                  1245 1245 1248 1250 1261 1275 1281 1283 1285 1296
                                                                                  1297 1299 1301 1303 1312 1330* 1340 1355 1364 1364
                                                                                  1375
move_len                        000200 automatic       fixed bin(21,0)          dcl 99 set ref 363* 373* 387* 388 402 407 447* 456*
                                                                                  465* 466 468 483* 489* 490 492 493 494 901* 1188
                                                                                  1188 1188 1188 1190 1190 1191 1193 1194 1195 1195
                                                                                  1197* 1199 1214 1218 1220* 1222 1223 1224 1224
                                                                                  1224 1224 1226 1226 1227
move_ptr                        000170 automatic       pointer                  dcl 97 set ref 365* 374* 388* 407* 448* 457* 468*
                                                                                  494* 1188 1190 1224 1226
mpfmip                          000236 automatic       pointer                  dcl 8-4 set ref 211* 218 219 220 221 222 223 224 225
                                                                                  226 1156* 1331*
mtape_$alloc                    000054 constant        entry                    external dcl 11-10 ref 212 617
mtape_$error                    000056 constant        entry                    external dcl 11-19 ref 526 538 560 637 738 769 783
                                                                                  831 847 857 885 919 975 991 1027 1064 1083 1090
                                                                                  1105 1110 1124 1138
mtape_$flush_buffers            000060 constant        entry                    external dcl 11-22 ref 313 435 942
mtape_$order                    000062 constant        entry                    external dcl 11-27 ref 845 884 1025 1088 1103 1109
mtape_$read_block               000064 constant        entry                    external dcl 11-30 ref 957
mtape_$read_label               000066 constant        entry                    external dcl 11-33 ref 855
mtape_$set_mode                 000070 constant        entry                    external dcl 11-36 ref 788 932 934
mtape_$stop_tape                000072 constant        entry                    external dcl 11-39 ref 325 989
mtape_$user_query               000074 constant        entry                    external dcl 11-42 ref 669 1021 1343
mtape_$volume_switch            000076 constant        entry                    external dcl 11-45 ref 917
mtape_$write_block              000100 constant        entry                    external dcl 11-48 ref 1393
mtape_$write_label              000102 constant        entry                    external dcl 11-51 ref 1062 1081
mtape_attach_info                      based           structure                level 1 dcl 7-8
mtape_attach_info_version_1     000050 constant        char(8)                  initial packed unaligned dcl 7-6 set ref 208*
mtape_close_info                       based           structure                level 1 dcl 9-41
mtape_close_info_version_1      000042 constant        char(8)                  initial packed unaligned dcl 9-8 set ref 210*
mtape_data                             based           structure                level 1 dcl 2-8
mtape_data_version_1            000060 constant        char(8)                  initial packed unaligned dcl 2-6 set ref 197*
mtape_err_stats                        based           structure                level 1 dcl 5-6
mtape_fi_version_1              000052 constant        char(8)                  initial packed unaligned dcl 6-6 set ref 213*
mtape_file_info                        based           structure                level 1 dcl 6-8 set ref 214
mtape_label_record                     based           structure                level 1 dcl 4-8
mtape_lr_version_1              000054 constant        char(8)                  initial packed unaligned dcl 4-6 set ref 206*
mtape_open_info                        based           structure                level 1 dcl 9-10
mtape_open_info_version_1       000044 constant        char(8)                  initial packed unaligned dcl 9-7 set ref 209*
mtape_pfm_info                         based           structure                level 1 dcl 8-8
mtape_pfm_info_version_1        000046 constant        char(8)                  initial packed unaligned dcl 8-6 set ref 211*
mtape_vol_set                          based           structure                level 1 dcl 3-9
mtape_vs_version_1              000056 constant        char(8)                  initial packed unaligned dcl 3-7 set ref 207*
mtdp                            000224 automatic       pointer                  dcl 2-4 set ref 197* 203 204 205* 205 206 212* 214
                                                                                  237 251* 272* 279 281* 286* 289* 304 309 310 311
                                                                                  311 313* 320* 325* 339* 354* 355 356 359 361 363
                                                                                  365 369 369 369 372 374 378 381 381 381 385 388
                                                                                  392 401 401 402 402 403 407 411 416 428* 429 430
                                                                                  433 433 435* 443 448 454 454 457 463 467 468 478
                                                                                  489 494 496 497 499 526* 538* 560* 617* 617 618
                                                                                  637* 669* 732 738* 764* 769* 783* 787 788* 788 811
                                                                                  831* 845* 847* 852 855* 855 857* 876* 880 884*
                                                                                  885* 896 896 899 900 913* 917* 919* 923 927* 928*
                                                                                  930 932* 932 934* 934 936 936 937 938 938 939 942*
                                                                                  957* 961* 975* 983 985 985 986 988 989* 991* 991
                                                                                  995 996 996 996 998 999 999 1000 1000 1000 1000
                                                                                  1000 1000 1003 1003 1003 1004 1004 1004 1004 1004
                                                                                  1004 1006 1006 1006 1008 1008 1008 1021* 1025*
                                                                                  1027* 1038* 1062* 1064* 1078 1081* 1083* 1088*
                                                                                  1090* 1103* 1105* 1109* 1110* 1124* 1124 1124 1124
                                                                                  1138* 1138 1138 1138 1152 1153 1154 1155 1156 1168
                                                                                  1171 1188 1191 1191 1191 1193 1194 1194 1195 1195
                                                                                  1195 1195 1195 1197 1199 1199 1200 1200 1200 1201
                                                                                  1203 1205 1205 1205 1224 1228 1232 1232 1233 1233
                                                                                  1233 1234 1234 1234 1234 1247 1326* 1327 1328 1329
                                                                                  1330 1331 1343* 1346* 1350* 1355 1379 1379 1381
                                                                                  1389 1390 1390 1391 1391 1393*
mult_id                  12            based           char(7)                  level 3 packed packed unaligned dcl 13-7 set ref 862
                                                                                  1050*
multi_volumes_ok         17            based           bit(1)                   level 2 dcl 8-8 set ref 225*
myname                          000135 constant        char(32)                 initial packed unaligned dcl 109 set ref 831*
n_segs                          000175 automatic       fixed bin(17,0)          dcl 98 set ref 397* 399* 477* 480 486*
native_bo_contents                     based           structure                level 1 packed packed unaligned dcl 175 set ref 1355
native_file             203            based           bit(1)                   level 3 in structure "mtape_data" dcl 2-8
                                                                                  in procedure "ansi_tape_io_" ref 937 983 1389
native_file              65            based           bit(1)                   level 3 in structure "mtape_file_info" dcl 6-8
                                                                                  in procedure "ansi_tape_io_" set ref 555* 569*
                                                                                  1358*
next_fi_ptr               4            based           pointer                  level 2 dcl 6-8 ref 763
next_file               102            based           bit(1)                   level 3 dcl 9-10 ref 1250
next_lab_ptr              4            based           pointer                  level 2 dcl 4-8 set ref 806 813 881 1042 1073*
next_volname              3(27)        based           char(32)                 level 3 packed packed unaligned dcl 16-8 set ref 621
                                                                                  621 714*
next_vs_ptr               4            based           pointer                  level 2 dcl 3-9 ref 616 620 667 714 714 916
nlp                             000166 automatic       pointer                  dcl 97 set ref 851* 876 879 881* 1033* 1038 1041
                                                                                  1042*
no_labels_ok             16            based           bit(1)                   level 2 dcl 8-8 set ref 224*
null                                                   builtin function         dcl 153 ref 203 205 205 205 205 212 212 432 616 667
                                                                                  714 788 788 807 845 845 876 884 884 926 932 932
                                                                                  934 934 1038 1073 1088 1088 1103 1103 1109 1109
                                                                                  1214 1340
number_of_vol_labels    106            based           fixed bin(17,0)          level 2 dcl 3-9 set ref 868* 1070*
nvp                             000164 automatic       pointer                  dcl 97 set ref 617* 618 620* 621 621 916* 917*
nxt_lrec                               based           char(1)                  level 2 packed packed unaligned dcl 184 set ref 402
old_ansi_hdr2_system_use               based           structure                level 1 packed packed unaligned dcl 16-26
open_idx                        000177 automatic       fixed bin(17,0)          dcl 98 set ref 252 254 1277* 1281* 1283* 1285* 1287*
open_info_ptr           276            based           pointer                  level 2 dcl 2-8 ref 1155 1330
open_mode                10            based           fixed bin(17,0)          level 2 dcl 9-10 ref 306 1275
open_modes_allowed       10            based           fixed bin(17,0)          array level 2 dcl 8-8 set ref 218* 219*
order_name                      000106 automatic       char(32)                 packed unaligned dcl 88 set ref 511*
output                          000162 automatic       bit(1)                   dcl 96 set ref 306* 308* 309 333 341 1276* 1280*
ov_len                          000106 automatic       fixed bin(17,0)          dcl 759 set ref 775* 780 780
owner_id                 11(09)        based           structure                level 2 packed packed unaligned dcl 13-7
pad_chars                       000342 automatic       fixed bin(17,0)          dcl 1185 set ref 1193* 1194 1194 1195 1195 1195 1195
padding_char            171            based           char(1)                  level 3 dcl 2-8 set ref 381 896 1000 1004 1379*
                                                                                  1381*
per_file_info            25            based           structure                level 2 dcl 6-8 set ref 775 780 780
per_file_overlay                       based           char                     packed unaligned dcl 758 ref 780 780
per_section_info        152            based           structure                level 2 dcl 6-8 set ref 775
pfm_arg_values                         based           structure                level 1 dcl 9-57
pfm_args                112            based           structure                level 3 dcl 9-10
pfm_entries                            based           structure                level 1 dcl 2-103
pfm_info_ptr            304            based           pointer                  level 2 dcl 2-8 ref 1156 1331
pfm_opt_sw              112            based           bit(1)                   array level 4 dcl 9-10 ref 1281 1355
pfm_options                            based           structure                level 1 dcl 8-21
pfm_utils_$file_search          000104 constant        entry                    external dcl 11-54 ref 251
pfm_utils_$init_label_record    000106 constant        entry                    external dcl 11-57 ref 205 876 1038
pfm_utils_$julian_date          000112 constant        entry                    external dcl 11-63 ref 1057 1363 1364
pfm_utils_$label_unexpired      000110 constant        entry                    external dcl 11-60 ref 873 1340
pfm_utils_$position_in_file     000114 constant        entry                    external dcl 11-66 ref 339 1346
pfm_utils_$read_file_labels     000116 constant        entry                    external dcl 11-69 ref 764 961
pfm_utils_$setup_file           000120 constant        entry                    external dcl 11-72 ref 927 1350
pfm_utils_$truncate_file_set    000122 constant        entry                    external dcl 11-75 ref 281 286
pfm_utils_$write_file_labels    000124 constant        entry                    external dcl 11-78 ref 272 289 320 913 928
phy_block               157            based           fixed bin(17,0)          level 3 dcl 2-8 set ref 279* 1124* 1138* 1391
pic1                            000204 automatic       picture(1)               packed unaligned dcl 100 set ref 495* 497 744* 745
pic2                            000205 automatic       picture(2)               packed unaligned dcl 101 set ref 686* 687 724* 725
pic4                            000206 automatic       picture(4)               packed unaligned dcl 102 set ref 466* 467 493* 496
                                                                                  680* 681 682* 683 684* 685
pic5                            000210 automatic       picture(5)               packed unaligned dcl 103 set ref 703* 704 706* 707
pic6                            000212 automatic       picture(6)               packed unaligned dcl 104 set ref 692* 693
position                 35            based           fixed bin(17,0)          level 3 in structure "mtape_close_info" dcl 9-41
                                                                                  in procedure "ansi_tape_io_" set ref 338 339*
position                156            based           structure                level 2 in structure "mtape_data" dcl 2-8
                                                                                  in procedure "ansi_tape_io_"
position_within_file     24            based           fixed bin(17,0)          level 2 dcl 6-8 ref 333 341 1345
pp                              000110 automatic       pointer                  dcl 760 set ref 774* 777 777 780 780 783
prev_block_no           200            based           fixed bin(21,0)          level 3 dcl 2-8 set ref 787* 930* 988 991 995*
prev_fi_ptr               2            based           pointer                  level 2 dcl 6-8 ref 774
processed               165            based           fixed bin(21,0)          level 4 dcl 2-8 set ref 311 381 433 996 1003 1004
                                                                                  1008 1194 1195 1195 1199* 1199 1200 1205 1232*
                                                                                  1232 1233 1234 1390
rcd_pad                                based           char                     packed unaligned dcl 1186 set ref 1194* 1195* 1195*
rcw                                    based           char(4)                  level 2 packed packed unaligned dcl 179 set ref 385
                                                                                  467*
rdata                     1(09)        based           char                     level 2 in structure "sb_record" packed packed
                                                                                  unaligned dcl 184 in procedure "ansi_tape_io_" set
                                                                                  ref 407 494
rdata                     1            based           char                     level 2 in structure "db_record" packed packed
                                                                                  unaligned dcl 179 in procedure "ansi_tape_io_" set
                                                                                  ref 388 468
rec_blk_ck                             parameter       bit(1)                   dcl 1165 ref 1162 1167
rec_len                         000105 automatic       fixed bin(21,0)          dcl 87 in procedure "ansi_tape_io_" set ref 357* 416
                                                                                  1214* 1214 1227* 1227 1228
rec_len                   0(09)        based           char(4)                  level 3 in structure "sb_record" packed packed
                                                                                  unaligned dcl 184 in procedure "ansi_tape_io_" set
                                                                                  ref 496* 900
reclen                    2(18)        based           char(5)                  level 2 packed packed unaligned dcl 16-8 set ref 572
                                                                                  707* 709*
record_length            67            based           fixed bin(35,0)          level 3 dcl 9-10 ref 1296 1303
record_size             177            based           fixed bin(21,0)          level 3 in structure "mtape_data" dcl 2-8
                                                                                  in procedure "ansi_tape_io_" ref 369 372 454 999
                                                                                  1003 1004 1004 1006 1168 1191 1193 1197
record_size              64            based           fixed bin(21,0)          level 3 in structure "mtape_file_info" dcl 6-8
                                                                                  in procedure "ansi_tape_io_" set ref 572* 705 706
                                                                                  777 777 777 777* 1297* 1299* 1301* 1303* 1353 1377
recording_mode           44            based           char(6)                  level 2 dcl 9-10 ref 1312
rel                                                    builtin function         dcl 153 ref 775 775
remain                  166            based           fixed bin(21,0)          level 4 dcl 2-8 set ref 359 363 369 369 378 392 401*
                                                                                  401 403 411 454 463 478 489 996* 999 1008* 1200*
                                                                                  1203 1233* 1234
req_version                            parameter       char(8)                  packed unaligned dcl 823 set ref 820 829 831*
ridx                                   parameter       fixed bin(17,0)          dcl 843 set ref 841 862* 864* 870 870*
rtrim                                                  builtin function         dcl 153 ref 579 584
s_ptr                                  parameter       pointer                  dcl 822 ref 820 829 831
sb_record                              based           structure                level 1 packed packed unaligned dcl 184
scw                                    based           structure                level 2 packed packed unaligned dcl 184
section                 152            based           fixed bin(17,0)          level 3 in structure "mtape_file_info" dcl 6-8
                                                                                  in procedure "ansi_tape_io_" set ref 549* 680 732*
                                                                                  780 780 811* 1138 1138*
section                   6(27)        based           char(4)                  level 2 in structure "ansi_hdr1" packed packed
                                                                                  unaligned dcl 15-8 in procedure "ansi_tape_io_"
                                                                                  set ref 549 681*
seq_number               53            based           fixed bin(17,0)          level 3 in structure "mtape_file_info" dcl 6-8
                                                                                  in procedure "ansi_tape_io_" set ref 550* 682
seq_number               73            based           fixed bin(35,0)          level 3 in structure "mtape_open_info" dcl 9-10
                                                                                  in procedure "ansi_tape_io_" ref 1248
sequence                  7(27)        based           char(4)                  level 2 packed packed unaligned dcl 15-8 set ref 550
                                                                                  683*
set_id                    5(09)        based           char(6)                  level 2 packed packed unaligned dcl 15-8 set ref 548
                                                                                  678* 678
size                                                   builtin function         dcl 153 ref 1355
span_indicator                         based           char(1)                  level 3 packed packed unaligned dcl 184 set ref 497*
                                                                                  896 899
struc_name                             parameter       char(32)                 packed unaligned dcl 824 set ref 820 831*
substr                                                 builtin function         dcl 153 set ref 526 526 538 538 560 560 605 626 637
                                                                                  637 648 676 678 702 710 804 809 810 870 870 1000
                                                                                  1004 1046 1095*
system                   17            based           char(13)                 level 2 packed packed unaligned dcl 15-8 set ref 555
                                                                                  696* 870
system_info_$installation_id    000042 constant        entry                    external dcl 161 ref 1058
system_use                3(27)        based           structure                level 2 packed packed unaligned dcl 16-8 set ref 584
                                                                                  586
tape_blk                               based           char(1)                  array packed unaligned dcl 2-115 set ref 381 1194
                                                                                  1195 1195 1205 1234
tblock                                 based           char                     packed unaligned dcl 173 ref 1000 1004
temp_fmt                        000154 automatic       char(3)                  packed unaligned dcl 94 set ref 573* 579* 579 584*
                                                                                  584 599 601 1261* 1263 1265
temp_mode                       000156 automatic       char(6)                  packed unaligned dcl 95 set ref 1312* 1313 1315
term                            000112 automatic       bit(1)                   dcl 952 in procedure "GET_NXT_RECORD" set ref 955*
                                                                                  956 982*
term                            000160 automatic       bit(1)                   dcl 96 in procedure "ansi_tape_io_" set ref 395* 397
                                                                                  409* 476* 477 479* 853* 854 867* 875
tlb                     154            based           pointer                  level 2 dcl 2-8 set ref 203 205* 206* 852 855* 880
                                                                                  1078
translate                                              builtin function         dcl 153 ref 1261 1312
uln                             000176 automatic       fixed bin(17,0)          dcl 98 set ref 730* 732* 738* 744
user_id                  14            based           char(32)                 level 2 packed packed unaligned dcl 14-9 set ref
                                                                                  1060*
user_label              106            based           entry variable           level 3 dcl 9-10 ref 732 811
user_label_data                 000130 automatic       char(76)                 packed unaligned dcl 91 set ref 731* 732* 745 809*
                                                                                  811*
user_labels_present      66            based           bit(1)                   level 3 dcl 6-8 set ref 605* 628* 648* 799
verify                                                 builtin function         dcl 153 ref 1000 1004
version                  11(27)        based           char(2)                  level 2 in structure "ansi_hdr1" packed packed
                                                                                  unaligned dcl 15-8 in procedure "ansi_tape_io_"
                                                                                  set ref 552 646 687*
version                                based           char(8)                  level 2 in structure "version_check" dcl 826
                                                                                  in procedure "CHECK_VERSION" set ref 829 831*
version_check                          based           structure                level 1 dcl 826
volume_check            105            based           fixed bin(17,0)          level 2 dcl 3-9 set ref 228* 231* 234* 236* 575 615
                                                                                  1099* 1243
volume_density          103            based           fixed bin(17,0)          level 2 dcl 3-9 set ref 1097*
volume_end              112            based           bit(1)                   level 2 dcl 3-9 set ref 273 290 915*
volume_id                 1            based           char(6)                  level 2 in structure "ansi_vol1" packed packed
                                                                                  unaligned dcl 13-7 in procedure "ansi_tape_io_"
                                                                                  set ref 1046* 1046
volume_id                26            based           char(32)                 level 2 in structure "mtape_vol_set" dcl 3-9
                                                                                  in procedure "ansi_tape_io_" set ref 783* 847*
                                                                                  857* 885* 1027* 1034* 1036 1046 1064* 1083* 1090*
                                                                                  1105* 1110*
volume_name              16            based           char(32)                 level 2 dcl 3-9 set ref 621 621* 714 1034
volume_type             104            based           fixed bin(17,0)          level 2 dcl 3-9 set ref 228 231 231 234 1098*
vs_current               24            based           pointer                  level 2 dcl 2-8 ref 923 1152 1327
vs_ptr                          000226 automatic       pointer                  dcl 3-5 set ref 207* 228 228 231 231 231 234 234 236
                                                                                  251* 273 290 339* 575 615 616 620 667 714 714 764*
                                                                                  783 847 851 857 868 873 876 876 885 915 916 923*
                                                                                  961* 1019 1027 1033 1034 1034 1036 1038 1038 1046
                                                                                  1064 1070 1071 1072 1083 1090 1097 1098 1099 1105
                                                                                  1110 1152* 1243 1327* 1346*
vs_tail                  22            based           pointer                  level 2 dcl 2-8 set ref 617* 618*
who_called                             parameter       bit(1)                   dcl 911 ref 909 931

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ANSI_EOF2                              internal static fixed bin(17,0)          initial dcl 16-34
ANSI_EOV1                              internal static fixed bin(17,0)          initial dcl 15-26
ANSI_EOV2                              internal static fixed bin(17,0)          initial dcl 16-34
AT_BOFD                                internal static fixed bin(17,0)          initial dcl 10-44
AT_BOFT                                internal static fixed bin(17,0)          initial dcl 10-44
AT_EOFD                                internal static fixed bin(17,0)          initial dcl 10-44
AT_EOFT                                internal static fixed bin(17,0)          initial dcl 10-44
AT_IFD                                 internal static fixed bin(17,0)          initial dcl 10-44
Direct_input                           internal static fixed bin(17,0)          initial dcl 17-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 17-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 17-15
FILES_PER_FILE_GRP                     internal static fixed bin(17,0)          initial dcl 10-44
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 17-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 17-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 17-15
MTAPE_ALLOC_LR                         internal static fixed bin(17,0)          initial dcl 10-9
MTAPE_ALLOC_STR                        internal static fixed bin(17,0)          initial dcl 10-9
MTAPE_CV_BCD                           internal static fixed bin(17,0)          initial dcl 10-34
MTAPE_CV_UC_EBCDIC                     internal static fixed bin(17,0)          initial dcl 10-34
MTAPE_HWM_BCD                          internal static fixed bin(17,0)          initial dcl 10-27
MTAPE_SPEED_VALUES                     internal static fixed bin(17,0)          initial array dcl 10-22
MTAPE_VALID_DENSITIES                  internal static fixed bin(17,0)          initial array dcl 10-17
NOT_POSITIONED_IN_FILE                 internal static fixed bin(17,0)          initial dcl 10-44
Q_ABORT_FILE                           internal static fixed bin(17,0)          initial dcl 10-63
Q_INCORRECT_VOLUME                     internal static fixed bin(17,0)          initial dcl 10-63
Q_LABELED_VOLUME                       internal static fixed bin(17,0)          initial dcl 10-63
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 17-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 17-15
Stream_input                           internal static fixed bin(17,0)          initial dcl 17-15
Stream_input_output                    internal static fixed bin(17,0)          initial dcl 17-15
Stream_output                          internal static fixed bin(17,0)          initial dcl 17-15
Tape_volume_types                      internal static char(16)                 initial array packed unaligned dcl 12-29
Volume_gcos_tape                       internal static fixed bin(17,0)          initial dcl 12-15
Volume_ibm_tape                        internal static fixed bin(17,0)          initial dcl 12-15
Volume_multics_tape                    internal static fixed bin(17,0)          initial dcl 12-15
Volume_unauthenticated                 internal static fixed bin(17,0)          initial dcl 12-15
all_buf_lens                           based           fixed bin(21,0)          array dcl 2-114
es_ptr                                 automatic       pointer                  dcl 5-4
iox_modes                              internal static char(24)                 initial array dcl 17-6
mtape_$allocate_buffers         000000 constant        entry                    external dcl 11-13
short_iox_modes                        internal static char(4)                  initial array dcl 17-12
today                                  automatic       char(6)                  packed unaligned dcl 93

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_NEW_FILE_SECTION          004613 constant        entry                    internal dcl 756 ref 969
CHECK_USER_LABELS               005050 constant        entry                    internal dcl 794 ref 256 334 341 629
CHECK_VERSION                   005176 constant        entry                    internal dcl 820 ref 197 206 207 208 209 210 211 213
CHECK_VOL_LABELS                005257 constant        entry                    internal dcl 841 ref 228
CONVERT_DESC                    005672 constant        entry                    internal dcl 894 ref 398 405
EOV_ON_WRITE                    005750 constant        entry                    internal dcl 909 ref 273 290 314 439 1397
GET_NXT_RECORD                  006250 constant        entry                    internal dcl 950 ref 359 378 382 392 403 411 897
INIT_VOL_LABELS                 006626 constant        entry                    internal dcl 1017 ref 266 924
INV_DEC_DATA                    007636 constant        entry                    internal dcl 1119 ref 984
INV_DESC                        007716 constant        entry                    internal dcl 1134 ref 384 396 902
LOAD_PTRS                       010043 constant        entry                    internal dcl 1150 ref 438 960 1136 1396
LONG_RECORD_CHECK               010072 constant        entry                    internal dcl 1162 ref 445 452 461 472
LTYPE                           000015 constant        label                    array(3) dcl 535 ref 533
MOVE_TO_BUFFER                  010121 constant        entry                    internal dcl 1181 ref 449 458 469 498
MOVE_TO_USER                    010266 constant        entry                    internal dcl 1212 ref 366 375 389 408
NEED_TO_INIT_VOLUME             010374 constant        entry                    internal dcl 1241 ref 265
READ_TYPE                       000005 constant        label                    array(4) dcl 363 ref 361
SETUP                           010625 constant        entry                    internal dcl 1324 ref 196 249 303 510 521 662
SETUP_NEW_FILE                  010654 constant        entry                    internal dcl 1338 ref 270
SET_FILE_ATTRIBUTES             011110 constant        entry                    internal dcl 1368 ref 258 773
SET_FILE_FORMAT                 010434 constant        entry                    internal dcl 1259 ref 1351 1370
SET_OPEN_IDX                    010467 constant        entry                    internal dcl 1273 ref 250
SET_RECORDING_MODE              010567 constant        entry                    internal dcl 1309 ref 1352 1373
SET_RECORD_SIZE                 010523 constant        entry                    internal dcl 1294 ref 1353 1377
WRITE_BLOCK                     011156 constant        entry                    internal dcl 1387 ref 311 433 454 463 1201 1203
WRITE_TYPE                      000011 constant        label                    array(4) dcl 445 ref 443
ansi_tape_io_                   001204 constant        entry                    external dcl 49
close_file_return               002041 constant        label                    dcl 346 ref 317 321 326
decode_file_labels              002731 constant        entry                    external dcl 519
dfl_return                      004052 constant        label                    dcl 654 ref 529
efl_return                      004610 constant        label                    dcl 750 ref 670 734 742 746
encode_file_labels              004063 constant        entry                    external dcl 660
file_close                      001654 constant        entry                    external dcl 301
file_open                       001450 constant        entry                    external dcl 247
open_action                     000000 constant        label                    array(0:4) dcl 256 ref 254
open_return                     001647 constant        label                    dcl 293 ref 252 259 267 271 277 284
order                           002670 constant        entry                    external dcl 508
pfm_init                        001216 constant        entry                    external dcl 194
pfm_init_return                 001443 constant        label                    dcl 240 ref 834
read                            002046 constant        entry                    external dcl 352
read_return                     002335 constant        label                    dcl 416 ref 367 376 390 958 964 966 970 977 993 1128
                                                                                  1143
set_mode                        000020 constant        label                    array(3) dcl 589 ref 581 586
set_mode_end                    003550 constant        label                    dcl 596 ref 591
write                           002353 constant        entry                    external dcl 426
write_return                    002660 constant        label                    dcl 502 ref 441 450 459 470 1173 1394 1398

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     12460       12606   11623       12470
Length     13514   11623       126         672     634           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ansi_tape_io_                      1048 external procedure  is an external procedure.  
on unit on line 384                  64 on unit               
on unit on line 396                  64 on unit               
on unit on line 524                 108 on unit               
CHECK_NEW_FILE_SECTION                  internal procedure  shares stack frame of internal procedure GET_NXT_RECORD.  
CHECK_USER_LABELS                       internal procedure  shares stack frame of external procedure ansi_tape_io_.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure ansi_tape_io_.  
CHECK_VOL_LABELS                        internal procedure  shares stack frame of external procedure ansi_tape_io_.  
CONVERT_DESC                            internal procedure  shares stack frame of external procedure ansi_tape_io_.  
EOV_ON_WRITE                            internal procedure  shares stack frame of external procedure ansi_tape_io_.  
GET_NXT_RECORD                      254 internal procedure  enables or reverts conditions.  
on unit on line 984                 126 on unit               
INIT_VOL_LABELS                         internal procedure  shares stack frame of external procedure ansi_tape_io_.  
INV_DEC_DATA                            internal procedure  shares stack frame of on unit on line 984.  
INV_DESC                            140 internal procedure  is called by several nonquick procedures.  
LOAD_PTRS                            64 internal procedure  is called by several nonquick procedures.  
LONG_RECORD_CHECK                       internal procedure  shares stack frame of external procedure ansi_tape_io_.  
MOVE_TO_BUFFER                          internal procedure  shares stack frame of external procedure ansi_tape_io_.  
MOVE_TO_USER                            internal procedure  shares stack frame of external procedure ansi_tape_io_.  
NEED_TO_INIT_VOLUME                     internal procedure  shares stack frame of external procedure ansi_tape_io_.  
SET_FILE_FORMAT                         internal procedure  shares stack frame of internal procedure SETUP_NEW_FILE.  
SET_OPEN_IDX                            internal procedure  shares stack frame of external procedure ansi_tape_io_.  
SET_RECORD_SIZE                         internal procedure  shares stack frame of internal procedure SETUP_NEW_FILE.  
SET_RECORDING_MODE                      internal procedure  shares stack frame of internal procedure SETUP_NEW_FILE.  
SETUP                                   internal procedure  shares stack frame of external procedure ansi_tape_io_.  
SETUP_NEW_FILE                      108 internal procedure  is called by several nonquick procedures.  
WRITE_BLOCK                             internal procedure  shares stack frame of external procedure ansi_tape_io_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
GET_NXT_RECORD           000106 ov_len                      CHECK_NEW_FILE_SECTION
                         000110 pp                          CHECK_NEW_FILE_SECTION
                         000112 term                        GET_NXT_RECORD
                         000113 block_no                    GET_NXT_RECORD
                         000114 i                           GET_NXT_RECORD
                         000115 j                           GET_NXT_RECORD
ansi_tape_io_            000100 Schecked_labels             ansi_tape_io_
                         000102 buf_ptr                     ansi_tape_io_
                         000104 buf_len                     ansi_tape_io_
                         000105 rec_len                     ansi_tape_io_
                         000106 order_name                  ansi_tape_io_
                         000116 info_ptr                    ansi_tape_io_
                         000120 install_id                  ansi_tape_io_
                         000130 user_label_data             ansi_tape_io_
                         000153 auth_code                   ansi_tape_io_
                         000154 temp_fmt                    ansi_tape_io_
                         000156 temp_mode                   ansi_tape_io_
                         000160 term                        ansi_tape_io_
                         000161 long_record                 ansi_tape_io_
                         000162 output                      ansi_tape_io_
                         000164 nvp                         ansi_tape_io_
                         000166 nlp                         ansi_tape_io_
                         000170 move_ptr                    ansi_tape_io_
                         000172 i                           ansi_tape_io_
                         000173 desc_type                   ansi_tape_io_
                         000174 label_type                  ansi_tape_io_
                         000175 n_segs                      ansi_tape_io_
                         000176 uln                         ansi_tape_io_
                         000177 open_idx                    ansi_tape_io_
                         000200 move_len                    ansi_tape_io_
                         000201 crl                         ansi_tape_io_
                         000202 bytes_remaining             ansi_tape_io_
                         000203 bytes_processed             ansi_tape_io_
                         000204 pic1                        ansi_tape_io_
                         000205 pic2                        ansi_tape_io_
                         000206 pic4                        ansi_tape_io_
                         000210 pic5                        ansi_tape_io_
                         000212 pic6                        ansi_tape_io_
                         000214 code                        ansi_tape_io_
                         000215 fl_code                     ansi_tape_io_
                         000224 mtdp                        ansi_tape_io_
                         000226 vs_ptr                      ansi_tape_io_
                         000230 lr_ptr                      ansi_tape_io_
                         000232 fi_ptr                      ansi_tape_io_
                         000234 maip                        ansi_tape_io_
                         000236 mpfmip                      ansi_tape_io_
                         000240 moip                        ansi_tape_io_
                         000242 mcip                        ansi_tape_io_
                         000244 ansi_vol1P                  ansi_tape_io_
                         000246 ansi_uvl1P                  ansi_tape_io_
                         000250 ansi_hdr1P                  ansi_tape_io_
                         000252 ansi_hdr2P                  ansi_tape_io_
                         000264 flrp                        CHECK_USER_LABELS
                         000342 pad_chars                   MOVE_TO_BUFFER

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              alloc_char_temp     call_ent_var_desc   call_ext_out_desc   call_ext_out
call_int_this       call_int_other      return_mac          tra_ext_1           mpfx2               mdfx1
enable_op           shorten_stack       ext_entry           ext_entry_desc      int_entry           verify_eis
any_to_any_truncate_op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ascii_to_ebcdic_              authenticate_                 ebcdic_to_ascii_              get_group_id_
mtape_$alloc                  mtape_$error                  mtape_$flush_buffers          mtape_$order
mtape_$read_block             mtape_$read_label             mtape_$set_mode               mtape_$stop_tape
mtape_$user_query             mtape_$volume_switch          mtape_$write_block            mtape_$write_label
pfm_utils_$file_search        pfm_utils_$init_label_record  pfm_utils_$julian_date        pfm_utils_$label_unexpired
pfm_utils_$position_in_file   pfm_utils_$read_file_labels   pfm_utils_$setup_file         pfm_utils_$truncate_file_set
pfm_utils_$write_file_labels  system_info_$installation_id

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_file         error_table_$data_seq_error   error_table_$end_of_info      error_table_$eov_on_write
error_table_$invalid_file_set_format                        error_table_$invalid_label_format
error_table_$invalid_record_desc                            error_table_$long_record      error_table_$no_file
error_table_$no_next_volume   error_table_$no_operation     error_table_$unimplemented_version
error_table_$uninitialized_volume




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     49 001203       194 001211       196 001226       197 001227       203 001234       204 001241       205 001243
    206 001265       207 001303       208 001310       209 001315       210 001322       211 001327       212 001334
    213 001356       214 001363       218 001365       219 001370       220 001372       221 001374       222 001376
    223 001400       224 001403       225 001404       226 001406       228 001407       231 001422       234 001431
    236 001436       237 001440       240 001443       242 001445       247 001446       249 001460       250 001461
    251 001462       252 001477       254 001504       256 001506       258 001510       259 001514       261 001515
    265 001524       266 001531       267 001532       269 001534       270 001535       271 001541       272 001543
    273 001556       277 001565       279 001566       281 001572       283 001601       284 001607       286 001610
    288 001617       289 001625       290 001640       293 001647       296 001651       301 001652       303 001664
    304 001665       306 001670       308 001676       309 001700       310 001707       311 001711       313 001715
    314 001726       317 001735       320 001737       321 001752       323 001754       325 001755       326 001766
    330 001770       333 001771       334 001777       335 002001       338 002003       339 002006       341 002025
    346 002041       348 002043       352 002044       354 002056       355 002062       356 002064       357 002066
    358 002070       359 002071       361 002077       363 002102       365 002105       366 002107       367 002110
    369 002111       372 002117       373 002120       374 002121       375 002123       376 002124       378 002125
    381 002134       382 002143       383 002147       384 002150       385 002172       386 002203       387 002204
    388 002207       389 002213       390 002214       392 002215       395 002224       396 002225       397 002247
    398 002254       399 002255       401 002264       402 002267       403 002275       405 002303       406 002304
    407 002305       408 002313       409 002314       411 002323       413 002332       414 002334       416 002335
    418 002340       421 002347       422 002350       426 002351       428 002363       429 002367       430 002371
    431 002373       432 002374       433 002400       435 002404       436 002415       438 002422       439 002426
    441 002430       443 002431       445 002433       447 002437       448 002441       449 002444       450 002450
    452 002451       454 002455       456 002462       457 002464       458 002467       459 002474       461 002475
    463 002501       465 002507       466 002511       467 002522       468 002527       469 002531       470 002533
    472 002534       474 002540       475 002542       476 002543       477 002544       478 002550       479 002555
    480 002557       482 002565       483 002567       484 002571       486 002572       488 002600       489 002602
    490 002605       492 002607       493 002611       494 002622       495 002627       496 002637       497 002642
    498 002645       499 002651       500 002656       502 002660       504 002662       508 002663       510 002706
    511 002707       512 002715       514 002720       515 002723       519 002724       521 002741       522 002742
    524 002746       525 002762       526 002765       529 003033       532 003036       533 003042       535 003045
    538 003054       547 003132       548 003137       549 003142       550 003154       551 003170       552 003204
    553 003220       554 003226       555 003232       557 003240       558 003241       560 003247       568 003325
    569 003341       571 003345       572 003360       573 003374       574 003401       575 003404       576 003410
    577 003412       578 003414       579 003422       581 003453       584 003466       586 003523       589 003541
    591 003544       593 003545       599 003550       600 003553       601 003557       603 003570       604 003572
    605 003573       608 003607       610 003610       614 003627       615 003631       616 003635       617 003641
    618 003662       619 003665       620 003666       621 003670       625 003701       626 003702       628 003712
    629 003715       632 003717       634 003720       637 003727       645 004005       646 004021       647 004035
    648 004036       654 004052       656 004054       660 004055       662 004073       663 004074       664 004100
    665 004104       666 004106       667 004111       669 004121       670 004134       673 004136       674 004141
    676 004147       678 004153       680 004156       681 004165       682 004170       683 004177       684 004202
    685 004211       686 004214       687 004224       688 004227       689 004232       690 004235       691 004240
    692 004244       693 004254       694 004257       695 004260       696 004263       697 004266       699 004267
    700 004271       701 004272       702 004277       703 004305       704 004315       705 004320       706 004324
    707 004334       708 004337       709 004340       710 004343       712 004354       713 004357       714 004362
    717 004373       719 004375       721 004405       723 004414       724 004417       725 004427       726 004432
    728 004433       730 004440       731 004442       732 004445       734 004501       738 004506       741 004546
    742 004551       744 004552       745 004562       746 004604       748 004605       750 004610       752 004612
    756 004613       762 004614       763 004616       764 004621       765 004640       767 004644       768 004647
    769 004652       771 004701       773 004702       774 004707       775 004713       777 004730       780 004740
    782 004751       783 004755       787 005010       788 005013       790 005047       794 005050       799 005052
    801 005060       803 005066       804 005070       806 005100       807 005103       809 005110       810 005115
    811 005132       813 005171       816 005175       820 005176       829 005200       830 005207       831 005212
    834 005255       837 005256       841 005257       845 005261       846 005316       847 005320       849 005351
    851 005352       852 005355       853 005361       854 005362       855 005366       856 005402       857 005404
    859 005435       861 005436       862 005445       864 005455       865 005460       866 005461       867 005464
    868 005466       869 005472       870 005473       873 005506       875 005526       876 005530       879 005555
    880 005557       881 005567       883 005572       884 005574       885 005632       890 005671       894 005672
    896 005673       897 005704       898 005710       899 005711       900 005721       901 005734       902 005737
    905 005747       909 005750       913 005752       914 005765       915 005770       916 005772       917 005774
    918 006007       919 006011       921 006035       923 006036       924 006041       925 006042       926 006045
    927 006047       928 006064       929 006077       930 006102       931 006104       932 006111       933 006145
    934 006150       935 006205       936 006210       937 006214       938 006216       939 006225       940 006233
    942 006235       946 006246       950 006247       955 006255       956 006256       957 006260       958 006272
    960 006303       961 006310       962 006330       963 006333       964 006334       966 006337       968 006345
    969 006351       970 006352       972 006360       974 006361       975 006364       977 006407       979 006412
    982 006413       983 006415       984 006420       985 006436       986 006444       987 006447       988 006450
    989 006454       990 006465       991 006471       993 006530       995 006533       996 006535       998 006540
    999 006543      1000 006547      1003 006563      1004 006567      1006 006612      1007 006614      1008 006617
   1011 006624      1013 006625      1017 006626      1019 006627      1021 006636      1022 006651      1025 006654
   1026 006712      1027 006714      1030 006751      1033 006752      1034 006755      1036 006761      1037 007001
   1038 007007      1041 007034      1042 007036      1043 007041      1044 007044      1045 007047      1046 007052
   1048 007056      1049 007061      1050 007064      1051 007067      1052 007072      1054 007073      1055 007076
   1056 007101      1057 007104      1058 007123      1059 007134      1060 007140      1062 007147      1063 007162
   1064 007164      1067 007221      1069 007222      1070 007224      1071 007227      1072 007233      1073 007235
   1078 007240      1079 007243      1080 007254      1081 007261      1082 007274      1083 007276      1086 007333
   1088 007334      1089 007372      1090 007374      1093 007431      1095 007432      1096 007441      1097 007443
   1098 007447      1099 007451      1103 007453      1104 007510      1105 007512      1107 007543      1109 007544
   1110 007602      1114 007635      1119 007636      1123 007637      1124 007644      1128 007712      1134 007715
   1136 007723      1137 007730      1138 007734      1143 010037      1150 010042      1152 010050      1153 010055
   1154 010060      1155 010063      1156 010066      1158 010071      1162 010072      1167 010074      1168 010077
   1170 010106      1171 010107      1173 010116      1176 010120      1181 010121      1188 010123      1190 010153
   1191 010161      1193 010172      1194 010175      1195 010204      1197 010236      1199 010241      1200 010246
   1201 010251      1203 010255      1205 010261      1208 010265      1212 010266      1214 010267      1217 010276
   1218 010300      1219 010303      1220 010305      1222 010307      1223 010311      1224 010313      1226 010343
   1227 010351      1228 010353      1232 010360      1233 010363      1234 010366      1237 010373      1241 010374
   1243 010376      1245 010405      1247 010414      1248 010417      1250 010425      1253 010432      1259 010434
   1261 010435      1263 010444      1264 010447      1265 010454      1267 010464      1269 010466      1273 010467
   1275 010470      1276 010474      1277 010475      1278 010476      1280 010477      1281 010501      1283 010506
   1285 010513      1287 010520      1290 010522      1294 010523      1296 010524      1297 010530      1299 010545
   1301 010561      1302 010563      1303 010564      1305 010566      1309 010567      1311 010570      1312 010574
   1313 010602      1315 010612      1316 010615      1317 010617      1318 010621      1319 010622      1320 010624
   1324 010625      1326 010626      1327 010632      1328 010634      1329 010637      1330 010642      1331 010645
   1332 010650      1334 010652      1338 010653      1340 010661      1343 010714      1344 010730      1345 010733
   1346 010737      1347 010756      1350 010761      1351 010777      1352 011000      1353 011001      1355 011006
   1358 011016      1359 011020      1361 011021      1362 011023      1363 011024      1364 011047      1366 011103
   1368 011106      1370 011115      1372 011122      1373 011126      1375 011131      1377 011140      1379 011143
   1381 011153      1383 011155      1387 011156      1389 011157      1390 011162      1391 011166      1393 011174
   1394 011205      1396 011212      1397 011216      1398 011220      1403 011222


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
