	COMPILATION LISTING OF SEGMENT format_pl1_stmt_type_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 02/21/85  0934.5 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 /* DESCRIPTION:
       11*
       12*   Produce a list of statements from a list of tokens.  The token type
       13*   assigned by format_pl1_lex_ is not based upon the context of the token.
       14*   For example, format_pl1_lex_ assigns "-" the token type minus.  This token
       15*   may be a prefix_minus token depending upon the context.  This procedure
       16*   uses contextual information to make sure the token type is correct.  The
       17*   steps are:
       18*
       19*   1) Find the end of condition prefix lists, if any.
       20*   2) Find the end of label prefix lists, if any, and fix up the token types.
       21*   3) Figure out the type of the next statement.
       22*   4) Find the end of the statement.
       23*   5) Fix up the token types in the statement.
       24*
       25*   Maintenance Instructions:
       26*
       27*   To add another token type:
       28*
       29*   1) If necesary, change fix_up_tokens to recognize the context in
       30*   which this token occurs and change an existing token type to the
       31*   new one.
       32*
       33*   To add another PL/I statement:
       34*
       35*   1) Add a statement type declaration to format_pl1_dcls.incl.pl1.
       36*   2) Add entries to the is_independent_statement, is macro_whitespace,
       37*   and is_macro_statement arrays in format_pl1_dcls.incl.pl1.
       38*   3) Change statement_type to recognize the new statement.  This
       39*   includes adding entries to the keyword, s_type, and
       40*   paren_not_allowed arrays.
       41*   4) If the statement does not end with a semicolon, change
       42*   find_end_of_statement.
       43*   5) If the statement requires certain token types be changed in order
       44*   to be formatted properly, change fix_up_tokens.
       45*
       46*   To add another macro:
       47*
       48*   1) Add a statement type declaration that starts with "percent_" to
       49*   format_pl1_dcls.incl.pl1.
       50*   2) Add entries to the is_independent_statement, is_macro_statement,
       51*   and is_macro_whitespace array in format_pl1_dcls.incl.pl1.
       52*   3) Change percent_statement_type to recognize the new macro.
       53*   4) If the macro does not end with a semicolon, change
       54*   find_end_of_statement.
       55*   5) If the macro requires certain token types be changed in order to
       56*   be formatted properly, change fix_up_tokens.
       57*
       58**/
       59 
       60 /* HISTORY:
       61*   Written by Paul Green, 11/05/77.
       62*
       63*   Modified:
       64*   12/10/78 by Monte Davidoff:  Removed from format_pl1_.
       65*   06/05/84 by R. Michael Tague:  To handle all legal pmac % statements.
       66*   02/12/85 by R. Michael Tague:  Changed test for the "Unknown statement
       67*               after macro" error message to use is_macro_statement instead
       68*               of comparing with percent_statment.  This should have been
       69*	     changed before.
       70**/
       71 
       72 /* format: style5,^indcomtxt */
       73 format_pl1_stmt_type_:
       74         procedure (P_temp_segs);
       75 
       76         declare P_temp_segs		(*) pointer;    /* (Input) array of temporary segment pointers */
       77 
       78 /* automatic */
       79 
       80         declare stmtx		fixed binary;   /* index into stmt */
       81 
       82 /* builtin */
       83 
       84         declare (divide, hbound, index, lbound, length, size, substr, unspec)
       85 				builtin;
       86 
  1     1 /* BEGIN INCLUDE FILE . . . format_pl1_dcls.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*   This include file contains common definitions used by the format_pl1
  1     5*   programs.  It defines tokens, statement types, mode types, etc.
  1     6**/
  1     7 
  1     8 /* HISTORY:
  1     9*Written by somebody, sometime.
  1    10*Modified:
  1    11*07/15/84 by R. Michael Tague:  Added the statement types:
  1    12*	  percent_abort_statement through percent_warn_statement.  Added
  1    13*            the condition is_macro_whitespace.  Added the modes: mode_indbegin,
  1    14*	  mode_indbeginend, mode_indthenbegin, mode_indthenbeginend,
  1    15*	  mode_indprocbody, mode_elsestmt, mode_equalind, and mode_linconind.
  1    16*	  Added style5.
  1    17**/
  1    18 
  1    19 /* format: style5 */
  1    20 
  1    21 /* automatic */
  1    22 
  1    23 declare temp_segs		  (4) pointer;
  1    24 
  1    25 /* based */
  1    26 
  1    27 /* format_pl1_ places the unit_stack and the declare_stack after the token array */
  1    28 
  1    29 declare 1 token		  (divide (sys_info$max_seg_size, 3, 19))
  1    30 			  aligned based (temp_segs (1)),
  1    31 	2 string_size	  fixed binary (21) unaligned,
  1    32 	2 pad		  bit (5) unaligned,
  1    33 	2 type		  fixed binary (8) unaligned,
  1    34 	2 string_ptr	  pointer unaligned,
  1    35 	2 trailer_index	  fixed binary (17);
  1    36 
  1    37 declare 1 trailer		  (divide (sys_info$max_seg_size, 2, 19))
  1    38 			  aligned based (temp_segs (2)),
  1    39 	2 string_size	  fixed binary (21) unaligned,
  1    40 	2 continued	  bit (1) unaligned,
  1    41 	2 pad		  bit (4) unaligned,
  1    42 	2 type		  fixed binary (8) unaligned,
  1    43 	2 string_ptr	  pointer unaligned;
  1    44 
  1    45 /* format_pl1_ places the item array and the levels array after the stmt array */
  1    46 
  1    47 declare 1 global_header	  aligned based,
  1    48 	2 source_ptr	  pointer,
  1    49 	2 source_length	  fixed binary (21),
  1    50 	2 n_tokens	  fixed binary (17),
  1    51 	2 n_trailers	  fixed binary (17),
  1    52 	2 n_stmts		  fixed binary (17),
  1    53 	2 output_length	  fixed binary (21),
  1    54 	2 max_severity	  fixed binary (35),
  1    55 	2 modes_ptr	  pointer,
  1    56 	2 modes_length	  fixed binary (21),
  1    57 	2 ca		  unaligned,
  1    58 	  3 check_comments	  bit (1),
  1    59 	  3 check_strings	  bit (1),
  1    60 	  3 force		  bit (1),
  1    61 	  3 long		  bit (1),
  1    62 	  3 record_style	  bit (1),
  1    63 	  3 require_style_comment
  1    64 			  bit (1),
  1    65 	2 flags		  unaligned,
  1    66 	  3 include_file	  bit (1),
  1    67 	  3 rdc_source	  bit (1),
  1    68 	  3 pad		  bit (28),
  1    69 	2 command_line_style  aligned like style,
  1    70 	2 prevailing_style	  aligned like style,
  1    71 	2 current_style	  aligned like style;
  1    72 
  1    73 declare 1 global		  aligned based (temp_segs (3)),
  1    74 	2 header		  aligned like global_header,
  1    75 	2 stmt		  (
  1    76 			  divide (sys_info$max_seg_size
  1    77 			  - size (global_header), 2, 19)),
  1    78 	  3 type		  fixed binary (8) unaligned,
  1    79 	  3 subtype	  fixed binary (8) unaligned,
  1    80 	  3 start		  fixed binary (17) unaligned,
  1    81 	  3 end		  fixed binary (17) unaligned,
  1    82 	  3 pad		  bit (18) unaligned;
  1    83 
  1    84 declare output_string	  char (4 * sys_info$max_seg_size)
  1    85 			  based (temp_segs (4));
  1    86 
  1    87 /* internal static */
  1    88 
  1    89 declare command		  char (10) internal static
  1    90 			  options (constant) initial ("format_pl1");
  1    91 
  1    92 /* token types */
  1    93 
  1    94 declare (
  1    95         no_token		  initial (0),
  1    96         invalid_char	  initial (1),
  1    97         identifier		  initial (2),
  1    98         keyword_token	  initial (3),
  1    99         isub		  initial (4),
  1   100         plus		  initial (5),
  1   101         minus		  initial (6),
  1   102         asterisk		  initial (7),
  1   103         slash		  initial (8),
  1   104         expon		  initial (9),
  1   105         not		  initial (10),
  1   106         and		  initial (11),
  1   107         or		  initial (12),
  1   108         cat		  initial (13),
  1   109         eq		  initial (14),
  1   110         ne		  initial (15),
  1   111         lt		  initial (16),
  1   112         gt		  initial (17),
  1   113         le		  initial (18),
  1   114         ge		  initial (19),
  1   115         ngt		  initial (20),
  1   116         nlt		  initial (21),
  1   117         prefix_plus		  initial (22),
  1   118         prefix_minus	  initial (23),
  1   119         assignment		  initial (24),
  1   120         colon		  initial (25),
  1   121         semi_colon		  initial (26),
  1   122         comma		  initial (27),
  1   123         period		  initial (28),
  1   124         arrow		  initial (29),
  1   125         left_parn		  initial (30),
  1   126         right_parn		  initial (31),
  1   127         percent		  initial (32),
  1   128         target_comma	  initial (33),
  1   129         comment_token	  initial (34),
  1   130         nl_vt_np_token	  initial (35),
  1   131         bit_string		  initial (36),
  1   132         char_string		  initial (37),
  1   133         fixed_bin		  initial (38),
  1   134         bin_integer		  initial (39),
  1   135         fixed_dec		  initial (40),
  1   136         dec_integer		  initial (41),
  1   137         float_bin		  initial (42),
  1   138         token_hole_1	  initial (43),
  1   139         float_dec		  initial (44),
  1   140         token_hole_2	  initial (45),
  1   141         i_fixed_bin		  initial (46),
  1   142         i_bin_integer	  initial (47),
  1   143         i_fixed_dec		  initial (48),
  1   144         i_dec_integer	  initial (49),
  1   145         i_float_bin		  initial (50),
  1   146         token_hole_3	  initial (51),
  1   147         i_float_dec		  initial (52),
  1   148         token_hole_4	  initial (53)
  1   149         )			  fixed binary (8) internal static
  1   150 			  options (constant);
  1   151 
  1   152 /* token class limits */
  1   153 
  1   154 declare (
  1   155         min_delimiter_token	  initial (5),
  1   156         max_delimiter_token	  initial (35),
  1   157         min_constant_token	  initial (36),
  1   158         max_constant_token	  initial (53),
  1   159         min_arithmetic_token	  initial (38),
  1   160         max_arithmetic_token	  initial (53)
  1   161         )			  fixed binary (8) internal static
  1   162 			  options (constant);
  1   163 
  1   164 /* arithmetic token type masks */
  1   165 
  1   166 declare (
  1   167         is_imaginary_constant	  initial ("1000"b),
  1   168         is_float_constant	  initial ("0100"b),
  1   169         is_decimal_constant	  initial ("0010"b),
  1   170         is_integral_constant	  initial ("0001"b)
  1   171         )			  bit (4) aligned internal static
  1   172 			  options (constant);
  1   173 
  1   174 /* lexical limits */
  1   175 
  1   176 declare (
  1   177         max_bit_string_constant initial (253),
  1   178         max_char_string_constant
  1   179 			  initial (254),
  1   180         max_identifier_length	  initial (256)
  1   181         )			  fixed binary internal static options (constant);
  1   182 
  1   183 /* statement types */
  1   184 
  1   185 declare (
  1   186         unknown_statement	  initial (0),
  1   187         allocate_statement	  initial (1),
  1   188         assignment_statement	  initial (2),
  1   189         begin_statement	  initial (3),
  1   190         call_statement	  initial (4),
  1   191         close_statement	  initial (5),
  1   192         declare_statement	  initial (6),
  1   193         lock_statement	  initial (7),
  1   194         delete_statement	  initial (8),
  1   195         display_statement	  initial (9),
  1   196         do_statement	  initial (10),
  1   197         else_clause		  initial (11),
  1   198         end_statement	  initial (12),
  1   199         entry_statement	  initial (13),
  1   200         exit_statement	  initial (14),
  1   201         format_statement	  initial (15),
  1   202         free_statement	  initial (16),
  1   203         get_statement	  initial (17),
  1   204         goto_statement	  initial (18),
  1   205         if_statement	  initial (19),
  1   206         locate_statement	  initial (20),
  1   207         null_statement	  initial (21),
  1   208         on_statement	  initial (22),
  1   209         open_statement	  initial (23),
  1   210         procedure_statement	  initial (24),
  1   211         put_statement	  initial (25),
  1   212         read_statement	  initial (26),
  1   213         return_statement	  initial (27),
  1   214         revert_statement	  initial (28),
  1   215         rewrite_statement	  initial (29),
  1   216         signal_statement	  initial (30),
  1   217         stop_statement	  initial (31),
  1   218         system_on_unit	  initial (32),
  1   219         unlock_statement	  initial (33),
  1   220         wait_statement	  initial (34),
  1   221         write_statement	  initial (35),
  1   222         default_statement	  initial (36),
  1   223         condition_prefix_list	  initial (37),
  1   224         label_prefix_list	  initial (38),
  1   225         percent_statement	  initial (39),
  1   226         percent_abort_statement initial (40),
  1   227         percent_default_statement
  1   228 			  initial (41),
  1   229         percent_else_statement  initial (42),
  1   230         percent_elseif_statement
  1   231 			  initial (43),
  1   232         percent_endif_statement initial (44),
  1   233         percent_error_statement initial (45),
  1   234         percent_if_statement	  initial (46),
  1   235         percent_include_statement
  1   236 			  initial (47),
  1   237         percent_page_statement  initial (48),
  1   238         percent_print_statement initial (49),
  1   239         percent_replace_statement
  1   240 			  initial (50),
  1   241         percent_set_statement	  initial (51),
  1   242         percent_skip_statement  initial (52),
  1   243         percent_warn_statement  initial (53)
  1   244         )			  fixed binary (8) internal static
  1   245 			  options (constant);
  1   246 
  1   247 declare is_independent_statement
  1   248 			  (0:53) bit (1) aligned internal static
  1   249 			  options (constant)
  1   250 			  initial ("0"b, (2) (1)"1"b, "0"b, (2) (1)"1"b,
  1   251 			  "0"b, (3) (1)"1"b, (4) (1)"0"b, "1"b, "0"b,
  1   252 			  (8) (1)"1"b, "0"b, (11) (1)"1"b, (18) (1)"0"b);
  1   253 
  1   254 declare is_macro_statement	  (0:53) bit (1) aligned internal static
  1   255 			  options (constant)
  1   256 			  initial ((39) (1)"0"b, (15) (1)"1"b);
  1   257 
  1   258 declare is_macro_whitespace	  (0:53) bit (1) aligned internal static
  1   259 			  options (constant)
  1   260 			  initial ((39) (1)"0"b, (3) (1)"1"b, (3) (1)"0"b,
  1   261 			  "1"b, "0"b, (7) (1)"1"b);
  1   262 
  1   263 /* statement subtypes */
  1   264 
  1   265 declare (
  1   266         subtype_none	  initial (0),
  1   267         subtype_noniterative_do initial (1)
  1   268         )			  fixed binary (8) internal static
  1   269 			  options (constant);
  1   270 
  1   271 /* style structures and constants */
  1   272 
  1   273 declare 1 style		  aligned based,
  1   274 	2 switches	  (26) bit (1) unaligned,
  1   275 	2 pad		  bit (10) unaligned,
  1   276 	2 values		  (10) fixed binary;
  1   277 
  1   278 /* named modes for format_pl1_ */
  1   279 
  1   280 declare (
  1   281         mode_on		  defined (global.current_style.switches (1)),
  1   282         mode_inddcls	  defined (global.current_style.switches (2)),
  1   283         mode_delnl		  defined (global.current_style.switches (3)),
  1   284         mode_insnl		  defined (global.current_style.switches (4)),
  1   285         mode_indattr	  defined (global.current_style.switches (5)),
  1   286         mode_linecom	  defined (global.current_style.switches (6)),
  1   287         mode_case		  defined (global.current_style.switches (7)),
  1   288         mode_ifthenstmt	  defined (global.current_style.switches (8)),
  1   289         mode_ifthendo	  defined (global.current_style.switches (9)),
  1   290         mode_ifthen		  defined (global.current_style.switches (10)),
  1   291         mode_indthenelse	  defined (global.current_style.switches (11)),
  1   292         mode_indnoniterdo	  defined (global.current_style.switches (12)),
  1   293         mode_indnoniterend	  defined (global.current_style.switches (13)),
  1   294         mode_indcomtxt	  defined (global.current_style.switches (14)),
  1   295         mode_thendo		  defined (global.current_style.switches (15)),
  1   296         mode_inditerdo	  defined (global.current_style.switches (16)),
  1   297         mode_indend		  defined (global.current_style.switches (17)),
  1   298         mode_indproc	  defined (global.current_style.switches (18)),
  1   299         mode_indcom		  defined (global.current_style.switches (19)),
  1   300         mode_indblkcom	  defined (global.current_style.switches (20)),
  1   301         mode_indbegin	  defined (global.current_style.switches (21)),
  1   302         mode_indbeginend	  defined (global.current_style.switches (22)),
  1   303         mode_indthenbegin	  defined (global.current_style.switches (23)),
  1   304         mode_indthenbeginend	  defined (global.current_style.switches (24)),
  1   305         mode_indprocbody	  defined (global.current_style.switches (25)),
  1   306         mode_elsestmt	  defined (global.current_style.switches (26))
  1   307         )			  bit (1);
  1   308 
  1   309 declare (
  1   310         mode_ind		  defined (global.current_style.values (1)),
  1   311         mode_ll		  defined (global.current_style.values (2)),
  1   312         mode_initcol	  defined (global.current_style.values (3)),
  1   313         mode_declareind	  defined (global.current_style.values (4)),
  1   314         mode_dclind		  defined (global.current_style.values (5)),
  1   315         mode_idind		  defined (global.current_style.values (6)),
  1   316         mode_struclvlind	  defined (global.current_style.values (7)),
  1   317         mode_comcol		  defined (global.current_style.values (8)),
  1   318         mode_equalind	  defined (global.current_style.values (9)),
  1   319         mode_lineconind	  defined (global.current_style.values (10))
  1   320         )			  fixed binary;
  1   321 
  1   322 /* mode names */
  1   323 
  1   324 declare switch_mode_names	  (26) char (15) internal static
  1   325 			  options (constant)
  1   326 			  initial ("on", "inddcls", "delnl", "insnl",
  1   327 			  "indattr", "linecom", "case", "ifthenstmt",
  1   328 			  "ifthendo", "ifthen", "indthenelse",
  1   329 			  "indnoniterdo", "indnoniterend", "indcomtxt",
  1   330 			  "thendo", "inditerdo", "indend", "indproc",
  1   331 			  "indcom", "indblkcom", "indbegin",
  1   332 			  "indbeginend", "indthenbegin",
  1   333 			  "indthenbeginend", "indprocbody", "elsestmt");
  1   334 
  1   335 declare switch_antonym_names	  (26) char (4) internal static
  1   336 			  options (constant)
  1   337 			  initial ("off", (5) (1)"", "tree", (19) (1)"");
  1   338 
  1   339 declare value_mode_names	  (10) char (12) internal static
  1   340 			  options (constant)
  1   341 			  initial ("ind", "ll", "initcol", "declareind",
  1   342 			  "dclind", "idind", "struclvlind", "comcol",
  1   343 			  "equalind", "lineconind");
  1   344 
  1   345 /* predefined styles */
  1   346 
  1   347 /* style1: on,inddcls,^delnl,^insnl,indattr,^linecom,case,^ifthenstmt,^ifthendo,^ifthen,^indthenelse,indnoniterdo,
  1   348*   ^indnoniterend,^indcomtxt,^thendo,inditerdo,^indend,^indproc,^indcom,indblkcom,indbegin,^indbeginend,indthenbegin,^indthenbeginend,indprocbody,elsestmt,ind5,ll122,initcol6,declareind8,
  1   349*   dclind8,idind23,struclvlind2,comcol61,equalind0,lineconind5
  1   350*   style2: style1,delnl,insnl
  1   351*   style3: style2,^inddcls,declareind10,dclind10,idind20
  1   352*   style4: style1,^inddcls,^indattr,linecom,ifthendo,^indnoniterdo,indcomtxt,^inditerdo,indproc,^indthenbegin,declareind9,dclind5
  1   353*   style5: style2,linecom,ifthen,^indnoniterdo,indnoniterend,indcomtxt,^indthenbegin,indthenbeginend,^indprocbody,^elsestmt,ind8,ll80,initcol0,idind24,comcol57,lineconind4
  1   354*
  1   355*
  1   356**/
  1   357 
  1   358 declare 1 styles		  (5) aligned internal static options (constant),
  1   359 	2 switches	  (26) bit (1) unaligned
  1   360 			  initial ("1"b, "1"b, "0"b, "0"b, "1"b, "0"b,
  1   361 			  "1"b, "0"b, "0"b, "0"b, "0"b, "1"b, "0"b, "0"b,
  1   362 			  "0"b, "1"b, "0"b, "0"b, "0"b, "1"b, "1"b, "0"b,
  1   363 			  "1"b, "0"b, "1"b, "1"b, /* style1 */
  1   364 			  "1"b, "1"b, "1"b, "1"b, "1"b, "0"b, "1"b, "0"b,
  1   365 			  "0"b, "0"b, "0"b, "1"b, "0"b, "0"b, "0"b, "1"b,
  1   366 			  "0"b, "0"b, "0"b, "1"b, "1"b, "0"b, "1"b, "0"b,
  1   367 			  "1"b, "1"b,	      /* style2 */
  1   368 			  "1"b, "0"b, "1"b, "1"b, "1"b, "0"b, "1"b, "0"b,
  1   369 			  "0"b, "0"b, "0"b, "1"b, "0"b, "0"b, "0"b, "1"b,
  1   370 			  "0"b, "0"b, "0"b, "1"b, "1"b, "0"b, "1"b, "0"b,
  1   371 			  "1"b, "1"b,	      /* style3 */
  1   372 			  "1"b, "0"b, "0"b, "0"b, "0"b, "1"b, "1"b, "0"b,
  1   373 			  "1"b, "0"b, "0"b, "0"b, "0"b, "1"b, "0"b, "0"b,
  1   374 			  "0"b, "1"b, "0"b, "1"b, "1"b, "0"b, "0"b, "0"b,
  1   375 			  "1"b, "1"b,	      /* style4 */
  1   376 			  "1"b, "1"b, "1"b, "1"b, "1"b, "1"b, "1"b, "0"b,
  1   377 			  "0"b, "1"b, "0"b, "0"b, "1"b, "1"b, "0"b, "1"b,
  1   378 			  "0"b, "0"b, "0"b, "1"b, "1"b, "0"b, "0"b, "1"b,
  1   379 			  "0"b, "0"b),	      /* style5 */
  1   380 	2 pad		  bit (10) unaligned initial ((5) (1)""b),
  1   381 	2 values		  (10) fixed binary
  1   382 			  initial (5, 122, 6, 8, 8, 23, 2, 61, 0, 5,
  1   383 					      /* style1 */
  1   384 			  5, 122, 6, 8, 8, 23, 2, 61, 0, 5,
  1   385 					      /* style2 */
  1   386 			  5, 122, 6, 10, 10, 20, 2, 61, 0, 5,
  1   387 					      /* style3 */
  1   388 			  5, 122, 6, 9, 5, 23, 2, 61, 0, 5,
  1   389 					      /* style4 */
  1   390 			  8, 80, 1, 8, 8, 24, 2, 57, 0, 4);
  1   391 					      /* style5 */
  1   392 
  1   393 /* control comment constants */
  1   394 
  1   395 declare control_comment_indicator
  1   396 			  char (7) internal static
  1   397 			  options (constant) initial ("format:");
  1   398 declare mode_separator	  char (1) internal static
  1   399 			  options (constant) initial (",");
  1   400 declare revert_mode		  char (6) internal static
  1   401 			  options (constant) initial ("revert");
  1   402 declare style_mode		  char (5) internal static
  1   403 			  options (constant) initial ("style");
  1   404 declare switch_mode_not_indicator
  1   405 			  char (1) internal static
  1   406 			  options (constant) initial ("^");
  1   407 
  1   408 /* if statement control comments */
  1   409 
  1   410 declare case_control_comment	  char (10) internal static
  1   411 			  options (constant) initial ("/* case */");
  1   412 declare tree_control_comment	  char (10) internal static
  1   413 			  options (constant) initial ("/* tree */");
  1   414 
  1   415 /* comment indicator constants */
  1   416 
  1   417 declare comment_indicator_extra_chars
  1   418 			  char (3) internal static
  1   419 			  options (constant) initial ((3)"*");
  1   420 declare comment_indicator_no_indcomtxt
  1   421 			  char (1) internal static
  1   422 			  options (constant) initial ("^");
  1   423 
  1   424 /* external static */
  1   425 
  1   426 declare sys_info$max_seg_size	  fixed binary (19) external static;
  1   427 
  1   428 /* entry */
  1   429 
  1   430 declare format_pl1_lex_	  entry ((*) pointer);
  1   431 declare format_pl1_stmt_type_	  entry ((*) pointer);
  1   432 declare format_pl1_		  entry ((*) pointer);
  1   433 declare format_pl1_modes_	  entry ((*) pointer, char (*), pointer, bit (1),
  1   434 			  bit (1));
  1   435 declare format_pl1_record_style_
  1   436 			  entry ((*) pointer, fixed binary (21),
  1   437 			  fixed binary);
  1   438 declare format_pl1_long_	  entry ((*) pointer, pointer);
  1   439 declare format_pl1_error_	  entry ((*) pointer, fixed binary (35), char (*),
  1   440 			  pointer);
  1   441 
  1   442 /* END INCLUDE FILE . . . format_pl1_dcls.incl.pl1 */
       87 
       88 
       89 /* program */
       90 
       91         temp_segs (*) = P_temp_segs (*);
       92         global.n_stmts = 0;
       93 
       94         unspec (stmt (1)) = ""b;		      /* build dummy first stmt */
       95         stmt (1).type = unknown_statement;
       96         stmt (1).subtype = subtype_none;
       97         stmt (1).start = 1;
       98         stmt (1).end = 1;
       99         stmtx = 1;
      100 
      101         begin;
      102 	      declare tokenx	        fixed binary;
      103 
      104 	      tokenx = 2;
      105 	      do while (tokenx <= global.n_tokens);
      106 		    call type_the_prefix_lists (tokenx);
      107 
      108 		    if tokenx <= global.n_tokens then
      109 			  call type_one_statement (tokenx);
      110 	      end;
      111         end;
      112 
      113         if stmtx >= hbound (stmt, 1) then
      114 	      call error (4, "Too many statements.", (stmt (stmtx).start));
      115 
      116         unspec (stmt (stmtx + 1)) = ""b;	      /* build dummy last stmt */
      117         stmt (stmtx + 1).type = unknown_statement;
      118         stmt (stmtx + 1).subtype = subtype_none;
      119         stmt (stmtx + 1).start = global.n_tokens + 1;
      120         stmt (stmtx + 1).end = global.n_tokens + 1;
      121 
      122 unrecoverable_error:
      123         global.n_stmts = stmtx;
      124 
      125         return;
      126 
      127 type_the_prefix_lists:
      128         procedure (tokenx);
      129 
      130         declare tokenx		fixed binary;   /* (Updated) current token */
      131 
      132         declare label		bit (1) aligned;
      133         declare labelx		fixed binary;
      134         declare prefix_start		fixed binary;
      135 
      136 /* condition prefix list */
      137 
      138         prefix_start = tokenx;
      139         do while (token (tokenx).type = left_parn);
      140 	      tokenx = tokenx + 1;
      141 
      142 	      if token (tokenx).type = identifier then
      143 		    tokenx = tokenx + 1;
      144 
      145 	      else if token (tokenx).type ^= percent then
      146 		    call error (3,
      147 		        "Missing identifier in condition prefix list.",
      148 		        tokenx);
      149 
      150 	      do while (token (tokenx).type = comma);
      151 		    tokenx = tokenx + 1;
      152 
      153 		    if token (tokenx).type = identifier then
      154 			  tokenx = tokenx + 1;
      155 
      156 		    else if token (tokenx).type ^= percent then
      157 			  call error (3,
      158 			      "Missing identifier in condition prefix list.",
      159 			      tokenx);
      160 	      end;
      161 
      162 	      if token (tokenx).type = right_parn then
      163 		    tokenx = tokenx + 1;
      164 
      165 	      else if token (tokenx).type ^= percent then
      166 		    call error (3,
      167 		        "Missing right parenthesis in condition prefix list.",
      168 		        tokenx);
      169 
      170 	      if token (tokenx).type = colon then
      171 		    tokenx = tokenx + 1;
      172 
      173 	      else if token (tokenx).type ^= percent then
      174 		    call error (3,
      175 		        "Missing colon after condition prefix list.",
      176 		        tokenx);
      177         end;
      178 
      179         if tokenx > prefix_start then
      180 	      call make_stmt (condition_prefix_list, subtype_none,
      181 		prefix_start, tokenx - 1);
      182 
      183 /* label prefix list */
      184 
      185         prefix_start = tokenx;
      186         label = "1"b;
      187         do while (token (tokenx).type = identifier & label);
      188 	      labelx = tokenx + 1;
      189 
      190 	      if token (labelx).type = left_parn then
      191 		    do;
      192 		    labelx = labelx + 1;
      193 
      194 		    if token (labelx).type = plus
      195 		        | token (labelx).type = minus then
      196 			  labelx = labelx + 1;
      197 
      198 		    if token (labelx).type = dec_integer
      199 		        |
      200 		        may_be_percent_replace_label_prefix (tokenx, labelx)
      201 		        then
      202 			  do;
      203 			  labelx = labelx + 1;
      204 
      205 			  if token (labelx).type = right_parn then
      206 				labelx = labelx + 1;
      207 			  else
      208 				label = "0"b;
      209 			  end;
      210 
      211 		    else
      212 			  label = "0"b;
      213 		    end;
      214 
      215 	      if token (labelx).type = colon & label then
      216 		    do tokenx = tokenx to labelx;
      217 			  if token (tokenx).type = plus then
      218 				token (tokenx).type = prefix_plus;
      219 
      220 			  else if token (tokenx).type = minus then
      221 				token (tokenx).type = prefix_minus;
      222 		    end;
      223 
      224 	      else
      225 		    label = "0"b;
      226         end;
      227 
      228         if tokenx > prefix_start then
      229 	      call make_stmt (label_prefix_list, subtype_none, prefix_start,
      230 		tokenx - 1);
      231 
      232         return;
      233 
      234 /* Label prefixes have the form "id ( [+|-] dec_integer ) :".  The %replace
      235*   macro introduces the possibility that the dec_integer may be an identifier
      236*   that is replaced by a dec_integer.  "id ( id ) :" can't always be formatted
      237*   as a label prefix since "else ( overflow ) :" is ambiguous.  This could be
      238*   an else clause with a condition prefix, rather than a label array named
      239*   "else" with a %replace identifier named "overflow".  This procedure allows
      240*   label prefixes of the form "id ( id ) :" unless the label array is "else"
      241*   and the subscript is a condition prefix list condition name.
      242**/
      243 may_be_percent_replace_label_prefix:
      244         procedure (label_token, subscript_token) returns (bit (1) aligned);
      245 
      246         declare label_token		fixed binary;   /* (Input) index of label name token */
      247         declare subscript_token	fixed binary;   /* (Input) index of subscript token */
      248 
      249         declare cnx			fixed binary;
      250         declare subscript_start_pos	fixed binary (21);
      251 
      252         declare label_string		char (token (label_token).string_size)
      253 				based (token (label_token).string_ptr);
      254         declare subscript_string	char (token (subscript_token)
      255 				.string_size)
      256 				based (token (subscript_token)
      257 				.string_ptr);
      258 
      259         declare condition_name	(17) char (16) internal static
      260 				options (constant)
      261 				initial ("conversion", "conv",
      262 				"fixedoverflow", "fofl", "overflow",
      263 				"ofl", "size", "stringrange", "strg",
      264 				"stringsize", "strz", "subscriptrange",
      265 				"subrg", "underflow", "ufl",
      266 				"zerodivide", "zdiv");
      267         declare disable_prefix	char (2) internal static
      268 				options (constant) initial ("no");
      269 
      270         if token (subscript_token).type ^= identifier then
      271 	      return ("0"b);
      272 
      273         if label_token + 2 ^= subscript_token | label_string ^= "else" then
      274 	      return ("1"b);
      275 
      276         if index (subscript_string, disable_prefix) = 1 then
      277 	      subscript_start_pos = length (disable_prefix) + 1;
      278         else
      279 	      subscript_start_pos = 1;
      280 
      281         do cnx = lbound (condition_name, 1) to hbound (condition_name, 1)
      282 	  while (condition_name (cnx)
      283 	  ^= substr (subscript_string, subscript_start_pos));
      284         end;
      285 
      286         return (cnx > hbound (condition_name, 1));
      287         end may_be_percent_replace_label_prefix;
      288 
      289         end type_the_prefix_lists;
      290 
      291 /* Get the type of one statement.
      292*
      293*   If the statement contains an embedded statement, e.g.  if, else or on, then
      294*   tokenx is left pointing to the first token of the embedded statement.
      295**/
      296 type_one_statement:
      297         procedure (tokenx);
      298 
      299         declare tokenx		fixed binary;   /* (Updated) index of current token, updated to first token of
      300*					         next statement */
      301 
      302         declare start		fixed binary;
      303         declare type		fixed binary (8);
      304 
      305         start = tokenx;
      306         type = statement_type (start);
      307         call find_end_of_statement (type, start, tokenx);
      308         call fix_up_tokens (type, start, tokenx);
      309 
      310         call make_stmt (type, statement_subtype (type, start, tokenx), start,
      311 	  tokenx);
      312 
      313         tokenx = tokenx + 1;
      314 
      315         return;
      316 
      317 statement_type:
      318         procedure (first_token) returns (fixed binary (8));
      319 
      320         declare first_token		fixed binary;   /* (Input) first token of statement */
      321 
      322         declare tokenx		fixed binary;
      323         declare keywordx		fixed binary;
      324 
      325         declare tokenx_token_string	char (token (tokenx).string_size)
      326 				based (token (tokenx).string_ptr);
      327 
      328         declare keyword		(34) char (12) aligned internal
      329 				static options (constant)
      330 				initial ("alloc", "allocate", "begin",
      331 				"call", "close", "dcl", "declare",
      332 				"default", "delete", "dft", "do",
      333 				"else", "end", "entry", "format",
      334 				"free", "get", "go", "goto", "if",
      335 				"locate", "on", "open", "proc",
      336 				"procedure", "put", "read", "return",
      337 				"revert", "rewrite", "signal", "stop",
      338 				"system", "write");
      339 
      340         declare s_type		(34) fixed binary (8) internal
      341 				static options (constant) initial (1,
      342 					      /* alloc */
      343 				1,	      /* allocate */
      344 				3,	      /* begin */
      345 				4,	      /* call */
      346 				5,	      /* close */
      347 				6,	      /* dcl */
      348 				6,	      /* declare */
      349 				36,	      /* default */
      350 				8,	      /* delete */
      351 				36,	      /* dft */
      352 				10,	      /* do */
      353 				11,	      /* else */
      354 				12,	      /* end */
      355 				13,	      /* entry */
      356 				15,	      /* format */
      357 				16,	      /* free */
      358 				17,	      /* get */
      359 				18,	      /* go */
      360 				18,	      /* goto */
      361 				19,	      /* if */
      362 				20,	      /* locate */
      363 				22,	      /* on */
      364 				23,	      /* open */
      365 				24,	      /* proc */
      366 				24,	      /* procedure */
      367 				25,	      /* put */
      368 				26,	      /* read */
      369 				27,	      /* return */
      370 				28,	      /* revert */
      371 				29,	      /* rewrite */
      372 				30,	      /* signal */
      373 				31,	      /* stop */
      374 				32,	      /* system */
      375 				35);	      /* write */
      376 
      377         declare paren_not_allowed	(34) bit (1) aligned internal
      378 				static options (constant)
      379 				initial ("1"b, "1"b, "1"b, "1"b, "1"b,
      380 				"0"b, "0"b, "0"b, "1"b, "0"b, "1"b,
      381 				"0"b, "1"b, "0"b, "0"b, "1"b, "1"b,
      382 				"1"b, "1"b, "0"b, "1"b, "1"b, "1"b,
      383 				"0"b, "0"b, "1"b, "1"b, "0"b, "1"b,
      384 				"1"b, "1"b, "1"b, "1"b, "1"b);
      385 
      386 /* Figure out what the next statement is. */
      387 
      388         tokenx = first_token;
      389 
      390         if token (tokenx).type = semi_colon then
      391 	      return (null_statement);
      392 
      393         if token (tokenx).type = percent then
      394 	      return (percent_statement_type (tokenx));
      395 
      396         if token (tokenx).type ^= identifier then
      397 	      do;
      398 	      if global.include_file & stmtx = 1 then
      399 		    call error (1,
      400 		        "Unknown statement at beginning of include file.",
      401 		        tokenx);
      402 
      403 	      else if is_macro_statement (stmt (stmtx).type) then
      404 		    call error (1, "Unknown statement after macro.", tokenx)
      405 		        ;
      406 
      407 	      else
      408 		    call error (3, "Unknown statement.", tokenx);
      409 
      410 	      return (unknown_statement);
      411 	      end;
      412 
      413 /* statement starts with an identifier */
      414 
      415         if token (tokenx + 1).type = assignment
      416 	  | token (tokenx + 1).type = arrow
      417 	  | token (tokenx + 1).type = period | token (tokenx + 1).type = comma
      418 	  then
      419 	      return (assignment_statement);
      420 
      421         do keywordx = lbound (keyword, 1) to hbound (keyword, 1)
      422 	  while (keyword (keywordx) ^= tokenx_token_string);
      423         end;
      424 
      425         if keywordx > hbound (keyword, 1) then
      426 	      return (assignment_statement);
      427 
      428         if token (tokenx + 1).type = left_parn then
      429 	      if paren_not_allowed (keywordx) then
      430 		    return (assignment_statement);
      431 	      else
      432 		    ;
      433 
      434         else
      435 	      return (s_type (keywordx));
      436 
      437 /* statement starts with "keyword (" */
      438 
      439         call skip_parens (tokenx);
      440 
      441         if token (tokenx).type = arrow | token (tokenx).type = period then
      442 	      return (assignment_statement);
      443 
      444         if token (tokenx).type = comma then
      445 	      if s_type (keywordx) = declare_statement then
      446 		    do;
      447 		    do while (token (tokenx).type ^= semi_colon
      448 		        & token (tokenx).type ^= assignment);
      449 			  if token (tokenx).type = left_parn then
      450 				call skip_parens (tokenx);
      451 			  else
      452 				tokenx = tokenx + 1;
      453 		    end;
      454 
      455 		    if token (tokenx).type = assignment then
      456 			  return (assignment_statement);
      457 		    else
      458 			  return (declare_statement);
      459 		    end;
      460 
      461 	      else
      462 		    return (assignment_statement);
      463 
      464         if token (tokenx).type = assignment then
      465 	      if s_type (keywordx) ^= if_statement then
      466 		    return (assignment_statement);
      467 	      else
      468 		    ;
      469 
      470         else
      471 	      return (s_type (keywordx));
      472 
      473 /* statement starts with "if ( ... ) =" */
      474 
      475         call find_then (first_token, tokenx);
      476 
      477         if token (tokenx).type = identifier then
      478 	      return (if_statement);
      479 
      480         return (assignment_statement);
      481 
      482 percent_statement_type:
      483         procedure (first_token) returns (fixed binary (8));
      484 
      485         declare first_token		fixed binary;   /* (Input) first token of statement */
      486         declare first_token_string	char (token (first_token).string_size)
      487 				based (token (first_token).string_ptr);
      488 
      489         if first_token_string = "%" then
      490 	      return (percent_statement);
      491         else if first_token_string = "%abort" then
      492 	      return (percent_abort_statement);
      493         else if first_token_string = "%default" then
      494 	      return (percent_default_statement);
      495         else if first_token_string = "%else" then
      496 	      return (percent_else_statement);
      497         else if first_token_string = "%elseif" then
      498 	      return (percent_elseif_statement);
      499         else if first_token_string = "%endif" then
      500 	      return (percent_endif_statement);
      501         else if first_token_string = "%error" then
      502 	      return (percent_error_statement);
      503         else if first_token_string = "%if" then
      504 	      return (percent_if_statement);
      505         else if first_token_string = "%include" then
      506 	      return (percent_include_statement);
      507         else if first_token_string = "%INCLUDE" then
      508 	      return (percent_include_statement);
      509         else if first_token_string = "%page" then
      510 	      return (percent_page_statement);
      511         else if first_token_string = "%print" then
      512 	      return (percent_print_statement);
      513         else if first_token_string = "%replace" then
      514 	      return (percent_replace_statement);
      515         else if first_token_string = "%set" then
      516 	      return (percent_set_statement);
      517         else if first_token_string = "%skip" then
      518 	      return (percent_skip_statement);
      519         else if first_token_string = "%warn" then
      520 	      return (percent_warn_statement);
      521         else
      522 	      do;
      523 	      call error (3, "Unknown macro.", first_token);
      524 	      return (percent_statement);
      525 	      end;
      526         end percent_statement_type;
      527 
      528         end statement_type;
      529 
      530 find_end_of_statement:
      531         procedure (stmt_type, first_token, last_token);
      532 
      533         declare stmt_type		fixed binary (8);
      534 					      /* (Input) type of the statement */
      535         declare first_token		fixed binary;   /* (Input) first token of the statement */
      536         declare last_token		fixed binary;   /* (Output) last token of the statement */
      537 
      538         declare last_token_string	char (token (last_token).string_size)
      539 				based (token (last_token).string_ptr);
      540 
      541         if stmt_type = on_statement then
      542 	      do;
      543 	      last_token = first_token + 1;
      544 
      545 	      call condition_name (last_token);
      546 	      do while (token (last_token).type = comma);
      547 		    last_token = last_token + 1;
      548 		    call condition_name (last_token);
      549 	      end;
      550 
      551 	      if token (last_token).type = identifier then
      552 		    if last_token_string = "snap" then
      553 			  if is_snap (last_token) then
      554 				last_token = last_token + 1;
      555 
      556 	      last_token = last_token - 1;
      557 	      end;
      558 
      559         else if stmt_type = if_statement then
      560 	      do;
      561 	      last_token = first_token;
      562 	      call find_then (first_token, last_token);
      563 
      564 	      if token (last_token).type ^= identifier
      565 		& token (last_token).type ^= percent then
      566 		    call error (3, "Missing ""then"" in if statement.",
      567 		        first_token);
      568 
      569 	      if token (last_token).type = percent
      570 		| token (last_token).type = no_token then
      571 		    last_token = last_token - 1;
      572 	      end;
      573 
      574         else if stmt_type = percent_if_statement
      575 	  | stmt_type = percent_elseif_statement then
      576 	      begin;
      577 	      declare found_percent_then      bit (1) aligned;
      578 
      579 	      do last_token = first_token + 1 by 1
      580 		while (^is_end_of_statement (token (last_token).type));
      581 	      end;
      582 
      583 	      if token (last_token).type = percent then
      584 		    found_percent_then = last_token_string = "%then";
      585 	      else
      586 		    found_percent_then = "0"b;
      587 
      588 	      if ^found_percent_then then
      589 		    do;
      590 		    call error (3,
      591 		        "Missing ""%then"" in %if or %elseif macro.",
      592 		        first_token);
      593 
      594 		    if token (last_token).type ^= semi_colon then
      595 			  last_token = last_token - 1;
      596 		    end;
      597 	      end;
      598 
      599         else if stmt_type = else_clause | stmt_type = percent_else_statement
      600 	  | stmt_type = percent_endif_statement then
      601 	      last_token = first_token;
      602 
      603         else
      604 	      do last_token = first_token by 1
      605 		while (token (last_token).type ^= semi_colon
      606 		& token (last_token + 1).type ^= percent
      607 		& token (last_token + 1).type ^= no_token);
      608 	      end;
      609 
      610         return;
      611 
      612 condition_name:
      613         procedure (tokenx);
      614 
      615         declare tokenx		fixed binary;   /* (Updated) current token position */
      616 
      617         if token (tokenx).type = identifier then
      618 	      do;
      619 	      tokenx = tokenx + 1;
      620 
      621 	      if token (tokenx).type = left_parn then
      622 		    begin;
      623 		    declare tx		      fixed binary;
      624 
      625 		    tx = tokenx;
      626 		    call skip_parens (tx);
      627 
      628 		    if token (tx).type ^= colon then
      629 			  tokenx = tx;
      630 		    end;
      631 	      end;
      632 
      633         else if token (last_token).type ^= percent then
      634 	      call error (3, "Missing identifier in condition name.", tokenx);
      635         end condition_name;
      636 
      637 is_snap:
      638         procedure (snap_token) returns (bit (1) aligned);
      639 
      640         declare snap_token		fixed binary;   /* (Input) token containing "snap" */
      641 
      642         declare tokenx		fixed binary;
      643 
      644         tokenx = snap_token + 1;
      645 
      646         if token (tokenx).type = identifier | token (tokenx).type = semi_colon
      647 	  then
      648 	      return ("1"b);
      649 
      650         if token (tokenx).type ^= left_parn then
      651 	      return ("0"b);
      652 
      653         call skip_parens (tokenx);
      654 
      655         return (token (tokenx).type = colon);
      656         end is_snap;
      657 
      658         end find_end_of_statement;
      659 
      660 fix_up_tokens:
      661         procedure (stmt_type, first_token, last_token);
      662 
      663         declare stmt_type		fixed binary (8);
      664 					      /* (Input) type of the current statement */
      665         declare first_token		fixed binary;   /* (Input) first token of the statement */
      666         declare last_token		fixed binary;   /* (Input) last token of the statement */
      667 
      668         declare tokenx		fixed binary;
      669         declare paren_depth		fixed binary;
      670         declare skip_assignment	bit (1) aligned;
      671 
      672         declare tokenx_token_string	char (token (tokenx).string_size)
      673 				based (token (tokenx).string_ptr);
      674 
      675         if stmt_type = if_statement then
      676 	      do;
      677 	      skip_assignment = "0"b;
      678 	      token (first_token).type = keyword_token;
      679 
      680 	      if token (last_token).type = identifier then
      681 		    token (last_token).type = keyword_token;
      682 	      end;
      683 
      684         else if stmt_type = assignment_statement then
      685 	      skip_assignment = "1"b;
      686 
      687         else if stmt_type = do_statement then
      688 	      do;
      689 	      tokenx = first_token + 1;
      690 
      691 	      if tokenx >= last_token then
      692 		    skip_assignment = "0"b;	      /* <noniterative do> */
      693 	      else
      694 		    do;
      695 		    skip_assignment = "1"b;
      696 
      697 		    if token (tokenx).type = identifier then
      698 			  if tokenx_token_string = "while"
      699 			      & token (tokenx + 1).type = left_parn then
      700 				do;
      701 				tokenx = tokenx + 1;
      702 				call skip_parens (tokenx);
      703 
      704 				if tokenx >= last_token then
      705 				        skip_assignment = "0"b;
      706 					      /* <do while> */
      707 				end;
      708 
      709 		    if skip_assignment	      /* <multiple do> */
      710 		        then
      711 			  do tokenx = tokenx + 1 to last_token - 1;
      712 				if token (tokenx).type = identifier then
      713 				        if tokenx_token_string = "while"
      714 					  | tokenx_token_string = "to"
      715 					  | tokenx_token_string = "by"
      716 					  | tokenx_token_string
      717 					  = "repeat" then
      718 					      if could_end_an_expression
      719 						(token (tokenx - 1)
      720 						.type) then
      721 						    token (tokenx)
      722 						        .type =
      723 						        keyword_token
      724 						        ;
      725 					      else
      726 						    ;
      727 				        else
      728 					      ;
      729 
      730 				else if token (tokenx).type = left_parn
      731 				    then
      732 				        do;
      733 				        call skip_parens (tokenx);
      734 				        tokenx = tokenx - 1;
      735 				        end;
      736 			  end;
      737 		    end;
      738 	      end;
      739 
      740         else if stmt_type = percent_replace_statement then
      741 	      do;
      742 	      tokenx = first_token + 2;
      743 	      if tokenx <= last_token then
      744 		    if token (tokenx).type = identifier then
      745 			  if tokenx_token_string = "by" then
      746 				token (tokenx).type = keyword_token;
      747 	      end;
      748 
      749         else if stmt_type = percent_set_statement
      750 	  | stmt_type = percent_default_statement then
      751 	      do;
      752 	      tokenx = first_token + 2;
      753 	      if tokenx <= last_token then
      754 		    if token (tokenx).type = identifier then
      755 			  if tokenx_token_string = "to" then
      756 				token (tokenx).type = keyword_token;
      757 	      end;
      758 
      759         else
      760 	      skip_assignment = "0"b;
      761 
      762         paren_depth = 0;
      763         do tokenx = first_token to last_token;
      764 	      if token (tokenx).type = left_parn then
      765 		    paren_depth = paren_depth + 1;
      766 
      767 	      else if token (tokenx).type = right_parn then
      768 		    paren_depth = paren_depth - 1;
      769 
      770 	      else if token (tokenx).type = assignment then
      771 		    if paren_depth = 0 & skip_assignment then
      772 			  skip_assignment = "0"b;
      773 		    else
      774 			  token (tokenx).type = eq;
      775 
      776 	      else if token (tokenx).type = comma
      777 		& stmt_type = assignment_statement & skip_assignment
      778 		& paren_depth = 0 then
      779 		    token (tokenx).type = target_comma;
      780 
      781 	      else if token (tokenx).type = percent
      782 		& length (tokenx_token_string) > length ("%") then
      783 		    token (tokenx).type = keyword_token;
      784 
      785 	      else if token (tokenx).type = plus | token (tokenx).type = minus
      786 		then
      787 		    if ^could_end_an_expression (token (tokenx - 1).type)
      788 		        then
      789 			  if token (tokenx).type = minus then
      790 				token (tokenx).type = prefix_minus;
      791 			  else
      792 				token (tokenx).type = prefix_plus;
      793         end;
      794         end fix_up_tokens;
      795 
      796 find_then:
      797         procedure (first_token, tokenx);
      798 
      799         declare first_token		fixed binary;   /* (Input) first token of the statement */
      800         declare tokenx		fixed binary;   /* (Updated) current token on input,
      801*					         then token or end of statement on output */
      802 
      803         declare tokenx_token_string	char (token (tokenx).string_size)
      804 				based (token (tokenx).string_ptr);
      805 
      806         do tokenx = tokenx + 1 by 1
      807 	  while (^is_end_of_statement (token (tokenx).type));
      808 	      if token (tokenx).type = identifier then
      809 		    if tokenx_token_string = "then" then
      810 			  if could_end_an_expression (token (tokenx - 1)
      811 			      .type) & first_token < tokenx - 1 then
      812 				return;
      813 			  else
      814 				;
      815 		    else
      816 			  ;
      817 
      818 	      else if token (tokenx).type = left_parn then
      819 		    do;
      820 		    call skip_parens (tokenx);
      821 		    tokenx = tokenx - 1;
      822 		    end;
      823         end;
      824         end find_then;
      825 
      826 skip_parens:
      827         procedure (tokenx);
      828 
      829         declare tokenx		fixed binary;   /* (Updated) on input, index of left_parn token,
      830*					         on output, index of end of statement token or token
      831*					         after matching right_parn, whichever comes first */
      832 
      833         declare paren_depth		fixed binary;
      834 
      835         paren_depth = 1;
      836         do tokenx = tokenx + 1 by 1
      837 	  while (paren_depth > 0 & ^is_end_of_statement (token (tokenx).type))
      838 	  ;
      839 	      if token (tokenx).type = left_parn then
      840 		    paren_depth = paren_depth + 1;
      841 
      842 	      else if token (tokenx).type = right_parn then
      843 		    paren_depth = paren_depth - 1;
      844         end;
      845         end skip_parens;
      846 
      847 could_end_an_expression:
      848         procedure (type) returns (bit (1) aligned);
      849 
      850         declare type		fixed binary (8) unaligned;
      851 					      /* (Input) token type which might end an expression */
      852 
      853         return (type = identifier | type = isub | type = right_parn
      854 	  | min_constant_token <= type & type <= max_constant_token);
      855         end could_end_an_expression;
      856 
      857 is_end_of_statement:
      858         procedure (type) returns (bit (1) aligned);
      859 
      860         declare type		fixed binary (8) unaligned;
      861 					      /* (Input) token type which might end a statement */
      862 
      863         return (type = semi_colon | type = percent | type = no_token);
      864         end is_end_of_statement;
      865 
      866 statement_subtype:
      867         procedure (stmt_type, first_token, last_token)
      868 	  returns (fixed binary (8));
      869 
      870         declare stmt_type		fixed binary (8);
      871 					      /* (Input) type of the statement */
      872         declare first_token		fixed binary;   /* (Input) first token of the statement */
      873         declare last_token		fixed binary;   /* (Input) last token of the statement */
      874 
      875         if stmt_type = do_statement then
      876 	      if token (last_token).type = semi_colon
      877 		& last_token = first_token + 1 then
      878 		    return (subtype_noniterative_do);
      879 
      880         return (subtype_none);
      881         end statement_subtype;
      882 
      883         end type_one_statement;
      884 
      885 /* Make a stmt entry. */
      886 
      887 make_stmt:
      888         procedure (type, subtype, start, end);
      889 
      890         declare type		fixed binary (8);
      891 					      /* (Input) statement type */
      892         declare subtype		fixed binary (8);
      893 					      /* (Input) statement subtype */
      894         declare start		fixed binary;   /* (Input) first token of statement */
      895         declare end			fixed binary;   /* (Input) last token of statement */
      896 
      897         if stmtx >= hbound (stmt, 1) then
      898 	      call error (4, "Too many statements.", start);
      899 
      900         stmtx = stmtx + 1;
      901         unspec (stmt (stmtx)) = ""b;
      902         stmt (stmtx).type = type;
      903         stmt (stmtx).subtype = subtype;
      904         stmt (stmtx).start = start;
      905         stmt (stmtx).end = end;
      906         end make_stmt;
      907 
      908 /* Print an error message. */
      909 
      910 error:
      911         procedure (severity, error_string, tokenx);
      912 
      913         declare severity		fixed binary (35);
      914 					      /* (Input) severity of the error */
      915         declare error_string		char (*);	      /* (Input) error message */
      916         declare tokenx		fixed binary;   /* (Input) token on which error occurred */
      917 
      918         call format_pl1_error_ (temp_segs (*), severity, error_string,
      919 	  (token (tokenx).string_ptr));
      920 
      921         if severity >= 4 then
      922 	      goto unrecoverable_error;
      923         end error;
      924 
      925         end format_pl1_stmt_type_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    02/21/85  0931.2  format_pl1_stmt_type_.pl1         >special_ldd>online>7051.pbf>format_pl1_stmt_type_.pl1
87           1    08/10/84  0958.4  format_pl1_dcls.incl.pl1          >ldd>include>format_pl1_dcls.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
P_temp_segs                            parameter       pointer                  array dcl 76 ref 73 91
arrow                                  constant        fixed bin(8,0)           initial dcl 1-94 ref 415 441
assignment                             constant        fixed bin(8,0)           initial dcl 1-94 ref 415 447 455 464 770
assignment_statement                   constant        fixed bin(8,0)           initial dcl 1-185 ref 415 425 428 441 455 461 464
                                                                                  480 684 776
cnx                             000134 automatic       fixed bin(17,0)          dcl 249 set ref 281* 281* 286
colon                                  constant        fixed bin(8,0)           initial dcl 1-94 ref 170 215 628 655
comma                                  constant        fixed bin(8,0)           initial dcl 1-94 ref 150 415 444 546 776
condition_name                  000252 constant        char(16)                 initial array unaligned dcl 259 ref 281 281 281 286
condition_prefix_list           000445 constant        fixed bin(8,0)           initial dcl 1-185 set ref 179*
dec_integer                            constant        fixed bin(8,0)           initial dcl 1-94 ref 198
declare_statement                      constant        fixed bin(8,0)           initial dcl 1-185 ref 444 457
disable_prefix                         constant        char(2)                  initial unaligned dcl 267 ref 276 276
divide                                                 builtin function         dcl 84 ref 113 897
do_statement                           constant        fixed bin(8,0)           initial dcl 1-185 ref 687 875
else_clause                            constant        fixed bin(8,0)           initial dcl 1-185 ref 599
end                      56            based           fixed bin(17,0)          array level 3 in structure "global" packed unaligned
                                                                                  dcl 1-73 in procedure "format_pl1_stmt_type_" set
                                                                                  ref 98* 120* 905*
end                                    parameter       fixed bin(17,0)          dcl 895 in procedure "make_stmt" ref 887 905
eq                                     constant        fixed bin(8,0)           initial dcl 1-94 ref 773
error_string                           parameter       char                     unaligned dcl 915 set ref 910 918*
first_token                            parameter       fixed bin(17,0)          dcl 535 in procedure "find_end_of_statement" set ref
                                                                                  530 543 561 562* 564* 579 590* 599 603
first_token                            parameter       fixed bin(17,0)          dcl 665 in procedure "fix_up_tokens" ref 660 678 689
                                                                                  742 752 763
first_token                            parameter       fixed bin(17,0)          dcl 799 in procedure "find_then" ref 796 808
first_token                            parameter       fixed bin(17,0)          dcl 872 in procedure "statement_subtype" ref 866 875
first_token                            parameter       fixed bin(17,0)          dcl 485 in procedure "percent_statement_type" set
                                                                                  ref 482 489 489 491 491 493 493 495 495 497 497
                                                                                  499 499 501 501 503 503 505 505 507 507 509 509
                                                                                  511 511 513 513 515 515 517 517 519 519 523*
first_token                            parameter       fixed bin(17,0)          dcl 320 in procedure "statement_type" set ref 317
                                                                                  388 475*
first_token_string                     based           char                     unaligned dcl 486 ref 489 491 493 495 497 499 501
                                                                                  503 505 507 509 511 513 515 517 519
flags                    13(06)        based           structure                level 3 packed unaligned dcl 1-73
format_pl1_error_               000012 constant        entry                    external dcl 1-439 ref 918
found_percent_then              000172 automatic       bit(1)                   dcl 577 set ref 583* 585* 588
global                                 based           structure                level 1 dcl 1-73
global_header                          based           structure                level 1 dcl 1-47 ref 113 897
hbound                                                 builtin function         dcl 84 ref 113 281 286 421 425 897
header                                 based           structure                level 2 dcl 1-73
identifier                             constant        fixed bin(8,0)           initial dcl 1-94 ref 142 153 187 270 396 477 551 564
                                                                                  617 646 680 697 712 743 753 808 853
if_statement                           constant        fixed bin(8,0)           initial dcl 1-185 ref 464 477 559 675
include_file             13(06)        based           bit(1)                   level 4 packed unaligned dcl 1-73 ref 398
index                                                  builtin function         dcl 84 ref 276
is_macro_statement              000356 constant        bit(1)                   initial array dcl 1-254 ref 403
isub                                   constant        fixed bin(8,0)           initial dcl 1-94 ref 853
keyword                         000104 constant        char(12)                 initial array dcl 328 ref 421 421 421 425
keyword_token                          constant        fixed bin(8,0)           initial dcl 1-94 ref 678 680 712 743 753 781
keywordx                        000155 automatic       fixed bin(17,0)          dcl 323 set ref 421* 421* 425 428 434 444 464 470
label                           000122 automatic       bit(1)                   dcl 132 set ref 186* 187 207* 211* 215 224*
label_prefix_list               000444 constant        fixed bin(8,0)           initial dcl 1-185 set ref 228*
label_string                           based           char                     unaligned dcl 252 ref 273
label_token                            parameter       fixed bin(17,0)          dcl 246 ref 243 273 273 273
labelx                          000123 automatic       fixed bin(17,0)          dcl 133 set ref 188* 190 192* 192 194 194 194* 194
                                                                                  198 198* 203* 203 205 205* 205 215 215
last_token                             parameter       fixed bin(17,0)          dcl 536 in procedure "find_end_of_statement" set ref
                                                                                  530 543* 545* 546 547* 547 548* 551 551 551 551*
                                                                                  551* 551 556* 556 561* 562* 564 564 569 569 569*
                                                                                  569 579* 579* 583 583 583 594 594* 594 599* 603*
                                                                                  603 603 603* 633
last_token                             parameter       fixed bin(17,0)          dcl 873 in procedure "statement_subtype" ref 866 875
                                                                                  875
last_token                             parameter       fixed bin(17,0)          dcl 666 in procedure "fix_up_tokens" ref 660 680 680
                                                                                  691 704 709 743 753 763
last_token_string                      based           char                     unaligned dcl 538 ref 551 583
lbound                                                 builtin function         dcl 84 ref 281 421
left_parn                              constant        fixed bin(8,0)           initial dcl 1-94 ref 139 190 428 449 621 650 697 730
                                                                                  764 818 839
length                                                 builtin function         dcl 84 ref 276 781 781
max_constant_token                     constant        fixed bin(8,0)           initial dcl 1-154 ref 853
min_constant_token                     constant        fixed bin(8,0)           initial dcl 1-154 ref 853
minus                                  constant        fixed bin(8,0)           initial dcl 1-94 ref 194 220 785 785
n_stmts                   5            based           fixed bin(17,0)          level 3 dcl 1-73 set ref 92* 122*
n_tokens                  3            based           fixed bin(17,0)          level 3 dcl 1-73 ref 105 108 119 120
no_token                               constant        fixed bin(8,0)           initial dcl 1-94 ref 569 603 863
null_statement                         constant        fixed bin(8,0)           initial dcl 1-185 ref 390
on_statement                           constant        fixed bin(8,0)           initial dcl 1-185 ref 541
paren_depth                     000223 automatic       fixed bin(17,0)          dcl 669 in procedure "fix_up_tokens" set ref 762*
                                                                                  764* 764 767* 767 770 776
paren_depth                     000244 automatic       fixed bin(17,0)          dcl 833 in procedure "skip_parens" set ref 835* 836
                                                                                  839* 839 842* 842
paren_not_allowed               000000 constant        bit(1)                   initial array dcl 377 ref 428
percent                                constant        fixed bin(8,0)           initial dcl 1-94 ref 145 156 165 173 393 564 569 583
                                                                                  603 633 781 863
percent_abort_statement                constant        fixed bin(8,0)           initial dcl 1-185 ref 491
percent_default_statement              constant        fixed bin(8,0)           initial dcl 1-185 ref 493 749
percent_else_statement                 constant        fixed bin(8,0)           initial dcl 1-185 ref 495 599
percent_elseif_statement               constant        fixed bin(8,0)           initial dcl 1-185 ref 497 574
percent_endif_statement                constant        fixed bin(8,0)           initial dcl 1-185 ref 499 599
percent_error_statement                constant        fixed bin(8,0)           initial dcl 1-185 ref 501
percent_if_statement                   constant        fixed bin(8,0)           initial dcl 1-185 ref 503 574
percent_include_statement              constant        fixed bin(8,0)           initial dcl 1-185 ref 505 507
percent_page_statement                 constant        fixed bin(8,0)           initial dcl 1-185 ref 509
percent_print_statement                constant        fixed bin(8,0)           initial dcl 1-185 ref 511
percent_replace_statement              constant        fixed bin(8,0)           initial dcl 1-185 ref 513 740
percent_set_statement                  constant        fixed bin(8,0)           initial dcl 1-185 ref 515 749
percent_skip_statement                 constant        fixed bin(8,0)           initial dcl 1-185 ref 517
percent_statement                      constant        fixed bin(8,0)           initial dcl 1-185 ref 489 524
percent_warn_statement                 constant        fixed bin(8,0)           initial dcl 1-185 ref 519
period                                 constant        fixed bin(8,0)           initial dcl 1-94 ref 415 441
plus                                   constant        fixed bin(8,0)           initial dcl 1-94 ref 194 217 785
prefix_minus                           constant        fixed bin(8,0)           initial dcl 1-94 ref 220 785
prefix_plus                            constant        fixed bin(8,0)           initial dcl 1-94 ref 217 791
prefix_start                    000124 automatic       fixed bin(17,0)          dcl 134 set ref 138* 179 179* 185* 228 228*
right_parn                             constant        fixed bin(8,0)           initial dcl 1-94 ref 162 205 767 842 853
s_type                          000042 constant        fixed bin(8,0)           initial array dcl 340 ref 434 444 464 470
semi_colon                             constant        fixed bin(8,0)           initial dcl 1-94 ref 390 447 594 603 646 863 875
severity                               parameter       fixed bin(35,0)          dcl 913 set ref 910 918* 921
size                                                   builtin function         dcl 84 ref 113 897
skip_assignment                 000224 automatic       bit(1)                   dcl 670 set ref 677* 684* 691* 695* 704* 709 759*
                                                                                  770 770* 776
snap_token                             parameter       fixed bin(17,0)          dcl 640 ref 637 644
start                    55(18)        based           fixed bin(17,0)          array level 3 in structure "global" packed unaligned
                                                                                  dcl 1-73 in procedure "format_pl1_stmt_type_" set
                                                                                  ref 97* 113 119* 904*
start                                  parameter       fixed bin(17,0)          dcl 894 in procedure "make_stmt" set ref 887 897*
                                                                                  904
start                           000144 automatic       fixed bin(17,0)          dcl 302 in procedure "type_one_statement" set ref
                                                                                  305* 306* 307* 308* 310* 310* 310*
stmt                     55            based           structure                array level 2 dcl 1-73 set ref 94* 113 116* 897 901*
stmt_type                              parameter       fixed bin(8,0)           dcl 663 in procedure "fix_up_tokens" ref 660 675 684
                                                                                  687 740 749 749 776
stmt_type                              parameter       fixed bin(8,0)           dcl 533 in procedure "find_end_of_statement" ref 530
                                                                                  541 559 574 574 599 599 599
stmt_type                              parameter       fixed bin(8,0)           dcl 870 in procedure "statement_subtype" ref 866 875
stmtx                           000100 automatic       fixed bin(17,0)          dcl 80 set ref 99* 113 113 116 117 118 119 120 122
                                                                                  398 403 897 900* 900 901 902 903 904 905
string_ptr                1            based           pointer                  array level 2 packed unaligned dcl 1-29 ref 273 276
                                                                                  281 421 489 491 493 495 497 499 501 503 505 507
                                                                                  509 511 513 515 517 519 551 583 697 712 712 712
                                                                                  712 743 753 781 808 918
string_size                            based           fixed bin(21,0)          array level 2 packed unaligned dcl 1-29 ref 273 276
                                                                                  281 421 489 491 493 495 497 499 501 503 505 507
                                                                                  509 511 513 515 517 519 551 583 697 712 712 712
                                                                                  712 743 753 781 808
style                                  based           structure                level 1 dcl 1-273
subscript_start_pos             000135 automatic       fixed bin(21,0)          dcl 250 set ref 276* 278* 281
subscript_string                       based           char                     unaligned dcl 254 ref 276 281
subscript_token                        parameter       fixed bin(17,0)          dcl 247 ref 243 270 273 276 276 281 281
substr                                                 builtin function         dcl 84 ref 281
subtype                                parameter       fixed bin(8,0)           dcl 892 in procedure "make_stmt" ref 887 903
subtype                  55(09)        based           fixed bin(8,0)           array level 3 in structure "global" packed unaligned
                                                                                  dcl 1-73 in procedure "format_pl1_stmt_type_" set
                                                                                  ref 96* 118* 903*
subtype_none                           constant        fixed bin(8,0)           initial dcl 1-265 set ref 96 118 179* 228* 880
subtype_noniterative_do                constant        fixed bin(8,0)           initial dcl 1-265 ref 875
sys_info$max_seg_size           000010 external static fixed bin(19,0)          dcl 1-426 ref 113 897
target_comma                           constant        fixed bin(8,0)           initial dcl 1-94 ref 776
temp_segs                       000102 automatic       pointer                  array dcl 1-23 set ref 91* 92 94 95 96 97 98 105 108
                                                                                  113 113 116 117 118 119 119 120 120 122 139 142
                                                                                  145 150 153 156 162 165 170 173 187 190 194 194
                                                                                  198 205 215 217 217 220 220 270 273 273 276 276
                                                                                  281 281 390 393 396 398 403 415 415 415 415 421
                                                                                  421 428 441 441 444 447 447 449 455 464 477 489
                                                                                  489 491 491 493 493 495 495 497 497 499 499 501
                                                                                  501 503 503 505 505 507 507 509 509 511 511 513
                                                                                  513 515 515 517 517 519 519 546 551 551 551 564
                                                                                  564 569 569 579 583 583 583 594 603 603 603 617
                                                                                  621 628 633 646 646 650 655 678 680 680 697 697
                                                                                  697 697 712 712 712 712 712 712 712 712 712 712
                                                                                  712 730 743 743 743 743 753 753 753 753 764 767
                                                                                  770 773 776 776 781 781 781 781 785 785 785 785
                                                                                  785 791 806 808 808 808 808 818 836 839 842 875
                                                                                  897 901 902 903 904 905 918* 918
token                                  based           structure                array level 1 dcl 1-29
tokenx                          000222 automatic       fixed bin(17,0)          dcl 668 in procedure "fix_up_tokens" set ref 689*
                                                                                  691 697 697 697 697 701* 701 702* 704 709* 709*
                                                                                  712 712 712 712 712 712 712 712 712 712 712 730
                                                                                  733* 734* 734* 742* 743 743 743 743 743 752* 753
                                                                                  753 753 753 753 763* 764 767 770 773 776 776 781
                                                                                  781 781 781 785 785 785 785 785 791*
tokenx                          000212 automatic       fixed bin(17,0)          dcl 642 in procedure "is_snap" set ref 644* 646 646
                                                                                  650 653* 655
tokenx                          000113 automatic       fixed bin(17,0)          dcl 102 in begin block on line 101 set ref 104* 105
                                                                                  106* 108 108*
tokenx                                 parameter       fixed bin(17,0)          dcl 130 in procedure "type_the_prefix_lists" set ref
                                                                                  127 138 139 140* 140 142 142* 142 145 145* 150
                                                                                  151* 151 153 153* 153 156 156* 162 162* 162 165
                                                                                  165* 170 170* 170 173 173* 179 179 185 187 188
                                                                                  198* 215* 215* 217 217 220 220* 228 228
tokenx                                 parameter       fixed bin(17,0)          dcl 829 in procedure "skip_parens" set ref 826 836*
                                                                                  836 836* 839 842*
tokenx                                 parameter       fixed bin(17,0)          dcl 615 in procedure "condition_name" set ref 612
                                                                                  617 619* 619 621 625 628* 633*
tokenx                                 parameter       fixed bin(17,0)          dcl 800 in procedure "find_then" set ref 796 806*
                                                                                  806 806* 808 808 808 808 808 818 820* 821* 821*
tokenx                                 parameter       fixed bin(17,0)          dcl 299 in procedure "type_one_statement" set ref
                                                                                  296 305 307* 308* 310* 310* 310* 313* 313
tokenx                          000154 automatic       fixed bin(17,0)          dcl 322 in procedure "statement_type" set ref 388*
                                                                                  390 393 393* 396 398* 403* 407* 415 415 415 415
                                                                                  421 421 428 439* 441 441 444 447 447 449 449* 451*
                                                                                  451 455 464 475* 477
tokenx                                 parameter       fixed bin(17,0)          dcl 916 in procedure "error" ref 910 918
tokenx_token_string                    based           char                     unaligned dcl 672 in procedure "fix_up_tokens" ref
                                                                                  697 712 712 712 712 743 753 781
tokenx_token_string                    based           char                     unaligned dcl 803 in procedure "find_then" ref 808
tokenx_token_string                    based           char                     unaligned dcl 325 in procedure "statement_type" ref
                                                                                  421
tx                              000202 automatic       fixed bin(17,0)          dcl 623 set ref 625* 626* 628 628
type                            000145 automatic       fixed bin(8,0)           dcl 303 in procedure "type_one_statement" set ref
                                                                                  306* 307* 308* 310* 310* 310*
type                      0(27)        based           fixed bin(8,0)           array level 2 in structure "token" packed unaligned
                                                                                  dcl 1-29 in procedure "format_pl1_stmt_type_" set
                                                                                  ref 139 142 145 150 153 156 162 165 170 173 187
                                                                                  190 194 194 198 205 215 217 217* 220 220* 270 390
                                                                                  393 396 415 415 415 415 428 441 441 444 447 447
                                                                                  449 455 464 477 546 551 564 564 569 569 579* 583
                                                                                  594 603 603 603 617 621 628 633 646 646 650 655
                                                                                  678* 680 680* 697 697 712 712* 712* 730 743 743*
                                                                                  753 753* 764 767 770 773* 776 776* 781 781* 785
                                                                                  785 785* 785 785* 791* 806* 808 808* 818 836* 839
                                                                                  842 875
type                                   parameter       fixed bin(8,0)           unaligned dcl 860 in procedure "is_end_of_statement"
                                                                                  ref 857 863 863 863
type                     55            based           fixed bin(8,0)           array level 3 in structure "global" packed unaligned
                                                                                  dcl 1-73 in procedure "format_pl1_stmt_type_" set
                                                                                  ref 95* 117* 403 902*
type                                   parameter       fixed bin(8,0)           dcl 890 in procedure "make_stmt" ref 887 902
type                                   parameter       fixed bin(8,0)           unaligned dcl 850 in procedure
                                                                                  "could_end_an_expression" ref 847 853 853 853 853
                                                                                  853
unknown_statement                      constant        fixed bin(8,0)           initial dcl 1-185 ref 95 117 410
unspec                                                 builtin function         dcl 84 set ref 94* 116* 901*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
allocate_statement                     internal static fixed bin(8,0)           initial dcl 1-185
and                                    internal static fixed bin(8,0)           initial dcl 1-94
asterisk                               internal static fixed bin(8,0)           initial dcl 1-94
begin_statement                        internal static fixed bin(8,0)           initial dcl 1-185
bin_integer                            internal static fixed bin(8,0)           initial dcl 1-94
bit_string                             internal static fixed bin(8,0)           initial dcl 1-94
call_statement                         internal static fixed bin(8,0)           initial dcl 1-185
case_control_comment                   internal static char(10)                 initial unaligned dcl 1-410
cat                                    internal static fixed bin(8,0)           initial dcl 1-94
char_string                            internal static fixed bin(8,0)           initial dcl 1-94
close_statement                        internal static fixed bin(8,0)           initial dcl 1-185
command                                internal static char(10)                 initial unaligned dcl 1-89
comment_indicator_extra_chars          internal static char(3)                  initial unaligned dcl 1-417
comment_indicator_no_indcomtxt         internal static char(1)                  initial unaligned dcl 1-420
comment_token                          internal static fixed bin(8,0)           initial dcl 1-94
control_comment_indicator              internal static char(7)                  initial unaligned dcl 1-395
default_statement                      internal static fixed bin(8,0)           initial dcl 1-185
delete_statement                       internal static fixed bin(8,0)           initial dcl 1-185
display_statement                      internal static fixed bin(8,0)           initial dcl 1-185
end_statement                          internal static fixed bin(8,0)           initial dcl 1-185
entry_statement                        internal static fixed bin(8,0)           initial dcl 1-185
exit_statement                         internal static fixed bin(8,0)           initial dcl 1-185
expon                                  internal static fixed bin(8,0)           initial dcl 1-94
fixed_bin                              internal static fixed bin(8,0)           initial dcl 1-94
fixed_dec                              internal static fixed bin(8,0)           initial dcl 1-94
float_bin                              internal static fixed bin(8,0)           initial dcl 1-94
float_dec                              internal static fixed bin(8,0)           initial dcl 1-94
format_pl1_                     000000 constant        entry                    external dcl 1-432
format_pl1_lex_                 000000 constant        entry                    external dcl 1-430
format_pl1_long_                000000 constant        entry                    external dcl 1-438
format_pl1_modes_               000000 constant        entry                    external dcl 1-433
format_pl1_record_style_        000000 constant        entry                    external dcl 1-435
format_pl1_stmt_type_           000000 constant        entry                    external dcl 1-431
format_statement                       internal static fixed bin(8,0)           initial dcl 1-185
free_statement                         internal static fixed bin(8,0)           initial dcl 1-185
ge                                     internal static fixed bin(8,0)           initial dcl 1-94
get_statement                          internal static fixed bin(8,0)           initial dcl 1-185
goto_statement                         internal static fixed bin(8,0)           initial dcl 1-185
gt                                     internal static fixed bin(8,0)           initial dcl 1-94
i_bin_integer                          internal static fixed bin(8,0)           initial dcl 1-94
i_dec_integer                          internal static fixed bin(8,0)           initial dcl 1-94
i_fixed_bin                            internal static fixed bin(8,0)           initial dcl 1-94
i_fixed_dec                            internal static fixed bin(8,0)           initial dcl 1-94
i_float_bin                            internal static fixed bin(8,0)           initial dcl 1-94
i_float_dec                            internal static fixed bin(8,0)           initial dcl 1-94
invalid_char                           internal static fixed bin(8,0)           initial dcl 1-94
is_decimal_constant                    internal static bit(4)                   initial dcl 1-166
is_float_constant                      internal static bit(4)                   initial dcl 1-166
is_imaginary_constant                  internal static bit(4)                   initial dcl 1-166
is_independent_statement               internal static bit(1)                   initial array dcl 1-247
is_integral_constant                   internal static bit(4)                   initial dcl 1-166
is_macro_whitespace                    internal static bit(1)                   initial array dcl 1-258
le                                     internal static fixed bin(8,0)           initial dcl 1-94
locate_statement                       internal static fixed bin(8,0)           initial dcl 1-185
lock_statement                         internal static fixed bin(8,0)           initial dcl 1-185
lt                                     internal static fixed bin(8,0)           initial dcl 1-94
max_arithmetic_token                   internal static fixed bin(8,0)           initial dcl 1-154
max_bit_string_constant                internal static fixed bin(17,0)          initial dcl 1-176
max_char_string_constant               internal static fixed bin(17,0)          initial dcl 1-176
max_delimiter_token                    internal static fixed bin(8,0)           initial dcl 1-154
max_identifier_length                  internal static fixed bin(17,0)          initial dcl 1-176
min_arithmetic_token                   internal static fixed bin(8,0)           initial dcl 1-154
min_delimiter_token                    internal static fixed bin(8,0)           initial dcl 1-154
mode_case                              defined         bit(1)                   unaligned dcl 1-280
mode_comcol                            defined         fixed bin(17,0)          dcl 1-309
mode_dclind                            defined         fixed bin(17,0)          dcl 1-309
mode_declareind                        defined         fixed bin(17,0)          dcl 1-309
mode_delnl                             defined         bit(1)                   unaligned dcl 1-280
mode_elsestmt                          defined         bit(1)                   unaligned dcl 1-280
mode_equalind                          defined         fixed bin(17,0)          dcl 1-309
mode_idind                             defined         fixed bin(17,0)          dcl 1-309
mode_ifthen                            defined         bit(1)                   unaligned dcl 1-280
mode_ifthendo                          defined         bit(1)                   unaligned dcl 1-280
mode_ifthenstmt                        defined         bit(1)                   unaligned dcl 1-280
mode_ind                               defined         fixed bin(17,0)          dcl 1-309
mode_indattr                           defined         bit(1)                   unaligned dcl 1-280
mode_indbegin                          defined         bit(1)                   unaligned dcl 1-280
mode_indbeginend                       defined         bit(1)                   unaligned dcl 1-280
mode_indblkcom                         defined         bit(1)                   unaligned dcl 1-280
mode_indcom                            defined         bit(1)                   unaligned dcl 1-280
mode_indcomtxt                         defined         bit(1)                   unaligned dcl 1-280
mode_inddcls                           defined         bit(1)                   unaligned dcl 1-280
mode_indend                            defined         bit(1)                   unaligned dcl 1-280
mode_inditerdo                         defined         bit(1)                   unaligned dcl 1-280
mode_indnoniterdo                      defined         bit(1)                   unaligned dcl 1-280
mode_indnoniterend                     defined         bit(1)                   unaligned dcl 1-280
mode_indproc                           defined         bit(1)                   unaligned dcl 1-280
mode_indprocbody                       defined         bit(1)                   unaligned dcl 1-280
mode_indthenbegin                      defined         bit(1)                   unaligned dcl 1-280
mode_indthenbeginend                   defined         bit(1)                   unaligned dcl 1-280
mode_indthenelse                       defined         bit(1)                   unaligned dcl 1-280
mode_initcol                           defined         fixed bin(17,0)          dcl 1-309
mode_insnl                             defined         bit(1)                   unaligned dcl 1-280
mode_linecom                           defined         bit(1)                   unaligned dcl 1-280
mode_lineconind                        defined         fixed bin(17,0)          dcl 1-309
mode_ll                                defined         fixed bin(17,0)          dcl 1-309
mode_on                                defined         bit(1)                   unaligned dcl 1-280
mode_separator                         internal static char(1)                  initial unaligned dcl 1-398
mode_struclvlind                       defined         fixed bin(17,0)          dcl 1-309
mode_thendo                            defined         bit(1)                   unaligned dcl 1-280
ne                                     internal static fixed bin(8,0)           initial dcl 1-94
ngt                                    internal static fixed bin(8,0)           initial dcl 1-94
nl_vt_np_token                         internal static fixed bin(8,0)           initial dcl 1-94
nlt                                    internal static fixed bin(8,0)           initial dcl 1-94
not                                    internal static fixed bin(8,0)           initial dcl 1-94
open_statement                         internal static fixed bin(8,0)           initial dcl 1-185
or                                     internal static fixed bin(8,0)           initial dcl 1-94
output_string                          based           char                     unaligned dcl 1-84
procedure_statement                    internal static fixed bin(8,0)           initial dcl 1-185
put_statement                          internal static fixed bin(8,0)           initial dcl 1-185
read_statement                         internal static fixed bin(8,0)           initial dcl 1-185
return_statement                       internal static fixed bin(8,0)           initial dcl 1-185
revert_mode                            internal static char(6)                  initial unaligned dcl 1-400
revert_statement                       internal static fixed bin(8,0)           initial dcl 1-185
rewrite_statement                      internal static fixed bin(8,0)           initial dcl 1-185
signal_statement                       internal static fixed bin(8,0)           initial dcl 1-185
slash                                  internal static fixed bin(8,0)           initial dcl 1-94
stop_statement                         internal static fixed bin(8,0)           initial dcl 1-185
style_mode                             internal static char(5)                  initial unaligned dcl 1-402
styles                                 internal static structure                array level 1 dcl 1-358
switch_antonym_names                   internal static char(4)                  initial array unaligned dcl 1-335
switch_mode_names                      internal static char(15)                 initial array unaligned dcl 1-324
switch_mode_not_indicator              internal static char(1)                  initial unaligned dcl 1-404
system_on_unit                         internal static fixed bin(8,0)           initial dcl 1-185
token_hole_1                           internal static fixed bin(8,0)           initial dcl 1-94
token_hole_2                           internal static fixed bin(8,0)           initial dcl 1-94
token_hole_3                           internal static fixed bin(8,0)           initial dcl 1-94
token_hole_4                           internal static fixed bin(8,0)           initial dcl 1-94
trailer                                based           structure                array level 1 dcl 1-37
tree_control_comment                   internal static char(10)                 initial unaligned dcl 1-412
unlock_statement                       internal static fixed bin(8,0)           initial dcl 1-185
value_mode_names                       internal static char(12)                 initial array unaligned dcl 1-339
wait_statement                         internal static fixed bin(8,0)           initial dcl 1-185
write_statement                        internal static fixed bin(8,0)           initial dcl 1-185

NAMES DECLARED BY EXPLICIT CONTEXT.
condition_name                  003173 constant        entry                    internal dcl 612 ref 545 548
could_end_an_expression         004230 constant        entry                    internal dcl 847 ref 712 785 808
error                           004425 constant        entry                    internal dcl 910 ref 113 145 156 165 173 398 403 407
                                                                                  523 564 590 633 897
find_end_of_statement           002607 constant        entry                    internal dcl 530 ref 307
find_then                       004031 constant        entry                    internal dcl 796 ref 475 562
fix_up_tokens                   003341 constant        entry                    internal dcl 660 ref 308
format_pl1_stmt_type_           000722 constant        entry                    external dcl 73
is_end_of_statement             004264 constant        entry                    internal dcl 857 ref 579 806 836
is_snap                         003275 constant        entry                    internal dcl 637 ref 551
make_stmt                       004336 constant        entry                    internal dcl 887 ref 179 228 310
may_be_percent_replace_label_prefix
                                001565 constant        entry                    internal dcl 243 ref 198
percent_statement_type          002362 constant        entry                    internal dcl 482 ref 393
skip_parens                     004150 constant        entry                    internal dcl 826 ref 439 449 626 653 702 733 820
statement_subtype               004307 constant        entry                    internal dcl 866 ref 310 310
statement_type                  002002 constant        entry                    internal dcl 317 ref 306
type_one_statement              001711 constant        entry                    internal dcl 296 ref 108
type_the_prefix_lists           001116 constant        entry                    internal dcl 127 ref 106
unrecoverable_error             001112 constant        label                    dcl 122 ref 921

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4730        4744    4657        4740
Length      5150    4657        14         170      51           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
format_pl1_stmt_type_               494 external procedure  is an external procedure.  
begin block on line 101                 begin block         shares stack frame of external procedure format_pl1_stmt_type_.  
type_the_prefix_lists                   internal procedure  shares stack frame of external procedure format_pl1_stmt_type_.  
may_be_percent_replace_label_prefix
                                        internal procedure  shares stack frame of external procedure format_pl1_stmt_type_.  
type_one_statement                      internal procedure  shares stack frame of external procedure format_pl1_stmt_type_.  
statement_type                          internal procedure  shares stack frame of external procedure format_pl1_stmt_type_.  
percent_statement_type                  internal procedure  shares stack frame of external procedure format_pl1_stmt_type_.  
find_end_of_statement                   internal procedure  shares stack frame of external procedure format_pl1_stmt_type_.  
begin block on line 574                 begin block         shares stack frame of external procedure format_pl1_stmt_type_.  
condition_name                          internal procedure  shares stack frame of external procedure format_pl1_stmt_type_.  
begin block on line 621                 begin block         shares stack frame of external procedure format_pl1_stmt_type_.  
is_snap                                 internal procedure  shares stack frame of external procedure format_pl1_stmt_type_.  
fix_up_tokens                           internal procedure  shares stack frame of external procedure format_pl1_stmt_type_.  
find_then                               internal procedure  shares stack frame of external procedure format_pl1_stmt_type_.  
skip_parens                             internal procedure  shares stack frame of external procedure format_pl1_stmt_type_.  
could_end_an_expression                 internal procedure  shares stack frame of external procedure format_pl1_stmt_type_.  
is_end_of_statement                     internal procedure  shares stack frame of external procedure format_pl1_stmt_type_.  
statement_subtype                       internal procedure  shares stack frame of external procedure format_pl1_stmt_type_.  
make_stmt                               internal procedure  shares stack frame of external procedure format_pl1_stmt_type_.  
error                                   internal procedure  shares stack frame of external procedure format_pl1_stmt_type_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
format_pl1_stmt_type_    000100 stmtx                       format_pl1_stmt_type_
                         000102 temp_segs                   format_pl1_stmt_type_
                         000113 tokenx                      begin block on line 101
                         000122 label                       type_the_prefix_lists
                         000123 labelx                      type_the_prefix_lists
                         000124 prefix_start                type_the_prefix_lists
                         000134 cnx                         may_be_percent_replace_label_prefix
                         000135 subscript_start_pos         may_be_percent_replace_label_prefix
                         000144 start                       type_one_statement
                         000145 type                        type_one_statement
                         000154 tokenx                      statement_type
                         000155 keywordx                    statement_type
                         000172 found_percent_then          begin block on line 574
                         000202 tx                          begin block on line 621
                         000212 tokenx                      is_snap
                         000222 tokenx                      fix_up_tokens
                         000223 paren_depth                 fix_up_tokens
                         000224 skip_assignment             fix_up_tokens
                         000244 paren_depth                 skip_parens

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              r_le_a              r_ge_a              call_ext_out_desc   return
bound_check_signal  ext_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
format_pl1_error_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     73 000717        91 000727        92 000775        94 000777        95 001002        96 001004        97 001006
     98 001010        99 001012       104 001014       105 001016       106 001022       108 001024       110 001032
    113 001033       116 001060       117 001067       118 001072       119 001100       120 001105       122 001112
    125 001115       127 001116       138 001120       139 001122       140 001133       142 001134       145 001147
    150 001176       151 001211       153 001212       156 001225       160 001254       162 001255       165 001261
    170 001310       173 001325       177 001354       179 001355       185 001364       186 001367       187 001371
    188 001405       190 001410       192 001416       194 001417       198 001433       203 001462       205 001463
    207 001475       209 001476       211 001477       215 001500       217 001524       220 001542       222 001550
    224 001553       226 001554       228 001555       232 001564       243 001565       270 001567       273 001602
    276 001624       278 001645       281 001647       284 001701       286 001703       296 001711       305 001713
    306 001715       307 001717       308 001732       310 001745       313 001777       315 002001       317 002002
    388 002004       390 002006       393 002022       396 002032       398 002034       403 002054       407 002073
    410 002106       415 002112       421 002135       423 002160       425 002162       428 002171       431 002211
    434 002212       439 002217       441 002221       444 002241       447 002247       449 002264       451 002271
    453 002272       455 002273       457 002301       461 002305       464 002311       467 002323       470 002324
    475 002331       477 002342       480 002356       482 002362       489 002364       491 002403       493 002412
    495 002421       497 002430       499 002437       501 002446       503 002455       505 002464       507 002473
    509 002502       511 002511       513 002520       515 002527       517 002536       519 002545       523 002554
    524 002603       530 002607       541 002611       543 002614       545 002617       546 002625       547 002641
    548 002642       549 002650       551 002651       556 002700       557 002703       559 002704       561 002706
    562 002710       564 002721       569 002762       572 003001       574 003002       579 003006       581 003033
    583 003036       585 003062       588 003063       590 003065       594 003112       574 003125       599 003126
    603 003137       608 003170       610 003172       612 003173       617 003175       619 003205       621 003206
    625 003215       626 003220       628 003222       631 003235       633 003236       635 003274       637 003275
    644 003277       646 003302       650 003320       653 003324       655 003326       660 003341       675 003343
    677 003346       678 003347       680 003355       682 003371       684 003372       687 003377       689 003401
    691 003404       695 003410       697 003412       701 003442       702 003443       704 003445       709 003452
    712 003465       727 003552       730 003553       733 003555       734 003557       736 003561       738 003563
    740 003564       742 003566       743 003571       747 003616       749 003617       752 003623       753 003626
    757 003653       759 003654       762 003655       763 003656       764 003667       767 003702       770 003707
    773 003717       776 003724       781 003743       785 003757       791 004022       793 004026       794 004030
    796 004031       806 004033       808 004055       815 004130       818 004131       820 004133       821 004141
    823 004144       824 004147       826 004150       835 004152       836 004154       839 004204       842 004221
    844 004225       845 004227       847 004230       853 004232       857 004264       863 004266       866 004307
    875 004311       880 004333       887 004336       897 004340       900 004374       901 004375       902 004404
    903 004411       904 004415       905 004420       906 004424       910 004425       918 004436       921 004472
    923 004476


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
