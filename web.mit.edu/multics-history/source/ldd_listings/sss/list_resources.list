	COMPILATION LISTING OF SEGMENT list_resources
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-17_1939.58_Mon_mdt
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(87-06-02,Rauschelbach), approve(87-07-07,MCR7728),
       15*     audit(87-07-08,Farley), install(87-07-15,MR12.1-1040):
       16*     A seperate error message was added for -awaiting_clear without a -type
       17*     argument instead of the same message as -acquisitions without -type.
       18*                                                   END HISTORY COMMENTS */
       19 
       20 
       21 /* format: indattr,inddcls,dclind5,idind30,struclvlind5,ifthenstmt,ifthendo,^inditerdo,^indnoniterend,case,^tree,^indproc,^indend,^delnl,^insnl,comcol81,indcom,linecom,^indcomtxt */
       22 
       23 list_resources: lr: procedure;
       24 
       25 	/*	This program is a command that may be called to list the resources that
       26*   *	have been assigned to or mounted by the calling process by RCP.
       27*   *	Created on 01/07/75 by Bill Silver.
       28*   *	Changed on 04/08/76 by Bill Silver for "-lv" option and to use temp
       29*   *		segments.
       30*   *	Changed on 05/24/78 by Michael R. Jordan for tape_drive/disk_drive
       31*   *		changes.
       32*   *	Changed on 10/31/78 by C. D. Tavares to add -acquisitions portion and
       33*   *		change -attachments to -mounts.
       34*   *	Changed on 11/18/78 by M. R. Jordan for -reservations and speed
       35*   *		qualifier for tapes.
       36*   *	Changed on 05/10/79 by CDT to add -awaiting_clear control arg.
       37*   *	Modified 831218 to call request_id_... BIM
       38*   *	Modified 831220 to correctly list console types... -E. A. Ranzenbach
       39*   *
       40*   * 	(-type | -tp)	This option specifies that all of the devices of
       41*   *			this type are to be listed.  It value argument
       42*   *			must be the name of the device type to be
       43*   *			listed.
       44*   *	(-dv  | -device)	Specifies that a specific device is to be
       45*   *			listed.  Its value argument must be the name of
       46*   *			the device.  RCP will list information about
       47*   *			only this one device.
       48*   *	(-lg  | -long)	This command option specifies that the user
       49*   *			wants all of the information known about the
       50*   *			assignment or mount.  This option argument
       51*   *			is not followed by a value argument.
       52*   *	(-lv  | -logical_volumes)
       53*   *			Specifies that only attached logical volumes are
       54*   *			to be listed.
       55*   *	(-resv | -reservations)
       56*   *			Specifies that only reservations are to be
       57*   *			listed.
       58*   *	(-asm | -assignments)
       59*   *			Specifies that only device assignments are to be
       60*   *			listed.
       61*   *	(-mts | -mounts)	Specifies that only mounts are to be listed.
       62*   *	(-atm | -attachments) 	 (as above, kept for compatibility.)
       63*   *	(-acq | -acquisitions)
       64*   *			Specifies that only owned resources are to be
       65*   *			listed.
       66*   *	(-user userid)	Specifies that user or project's acquisitions
       67*   *	(-awaiting_clear)	Specifies those resources awaiting manual
       68*   *			clearing.
       69*   */
       70 
       71 	/* 	AUTOMATIC  DATA		*/
       72 
       73 	dcl  alp			     pointer;			/* pointer to arg list */
       74 	dcl  arg_len		     fixed bin;			/* Length of an argument string. */
       75 	dcl  arg_ptr		     ptr;				/* Pointer to an argument string. */
       76 	dcl  argx			     fixed bin;			/* Number of the current argument. */
       77 	dcl  awaiting_clear		     bit (1) initial (""b);		/* ON if wants list of resources awaiting clear */
       78 	dcl  called_as_af		     bit (1) aligned;		/* O if called as active function */
       79 	dcl  cu_arg_ptr_entry	     entry (fixed bin, pointer, fixed bin, fixed bin (35), pointer) variable;
       80 	dcl  density_comment	     char (30) varying;		/* Used to print density capabilities. */
       81 	dcl  density_ptr		     ptr;				/* Pointer to density characteristics. */
       82 	dcl  device_name		     char (32);			/* Device name. */
       83 	dcl  resource_type		     char (32);			/* Device type. */
       84 	dcl  dtypex		     fixed bin;			/* Device type index. */
       85 	dcl  vtypex		     fixed bin;			/* Volume type index */
       86 	dcl  typex		     fixed bin;			/* scratch variable */
       87 	dcl  ecode		     fixed bin (35);		/* error_table_ code. */
       88 	dcl  (i, k)		     fixed bin;
       89 	dcl  is_volume		     bit (1) aligned;
       90 	dcl  list_index		     fixed bin;			/* 0 => all,  1 => type,  2 => device. */
       91 	dcl  listed_flag		     bit (1);			/* ON => something has been listed. */
       92 	dcl  long_flag		     bit (1);			/* ON => user wants all available information. */
       93 	dcl  num_args		     fixed bin;			/* Number of command arguments. */
       94 	dcl  num_listed		     fixed bin;			/* Number of entries actually listed. */
       95 	dcl  option		     char (32);			/* Command option string. */
       96 	dcl  option_code		     fixed bin;			/* 0 => none,  1 => string,  2 => binary. */
       97 	dcl  rcp_list_copied	     bit (1) initial (""b);		/* if on, don't recopy it */
       98 	dcl  request_control	     bit (36);			/* one bit for each control arg */
       99 	dcl  return_argp		     pointer;			/* points to af return arg */
      100 	dcl  return_argl		     fixed bin (21);		/* length of same */
      101 	dcl  seconds		     fixed bin;			/* Max IOI time-out intraval. */
      102 	dcl  seg_size		     fixed bin (19);		/* Size of temp segment. */
      103 	dcl  speed_comment		     char (30) varying;		/* Used to print speed capabilities. */
      104 	dcl  speed_ptr		     ptr;				/* Pointer to speed qualifier for tape drives. */
      105 	dcl  temp_seg_ptr		     ptr;				/* for temp segment namager. */
      106 	dcl  time_string		     char (24);			/* Used to list state time. */
      107 	dcl  user_id		     char (32);			/* for acquisition section */
      108 
      109 	/* 	BASED  DATA		*/
      110 
      111 	dcl  argument		     char (arg_len) based (arg_ptr);	/* Used to reference argument string. */
      112 
      113 	dcl  based_density		     bit (5) based (density_ptr) aligned;
      114 
      115 	dcl  based_speed		     bit (3) based (speed_ptr) aligned;
      116 
      117 	dcl  return_arg		     char (return_argl) varying based (return_argp);
      118 
      119 
      120 	/* 	INTERNAL STATIC DATA	*/
      121 
      122 	dcl  1 static_option_data	     (1:11) internal static options (constant),
      123 		2 brief_options	     char (16) initial		/* Brief form of command options. */
      124 				     ("-tp", "-dv", "-lg", "-asm", "-mts", "-lv", "-acq", "-user", "-atm",
      125 				     "-resv", "-awaiting_clear"),
      126 		2 long_options	     char (19) initial		/* Long  form of command options. */
      127 				     ("-type", "-device", "-long", "-assignments", "-mounts",
      128 				     "-logical_volumes", "-acquisitions", "-user", "-attachments",
      129 				     "-reservations", "-awaiting_clear"),
      130 		2 option_codes	     fixed bin initial
      131 				     (1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0),
      132 		2 af_usage_allowed	     bit (1) aligned initial
      133 				     ("1"b, "0"b, "0"b, "0"b, "0"b, "0"b, "1"b, "1"b, "0"b, "0"b, "1"b);
      134 
      135 	dcl  (Unset		     initial ("000000"b),
      136 	     Default		     initial ("111101"b),
      137 	     Assignments		     initial ("010000"b),
      138 	     Mounts		     initial ("001000"b),
      139 	     Logical_volumes	     initial ("000100"b),
      140 	     Acquisitions		     initial ("000010"b),
      141 	     Reservations		     initial ("000001"b)) bit (36) static options (constant);
      142 
      143 	dcl  operation_states	     (5) char (12)			/* Assignment and mounting states. */
      144 				     internal static init ("assigning", "assigning", "mounting", "mounting", "mounted");
      145 
      146 	dcl  density_names		     (5) char (5) varying		/* Used to print device density characteristics. */
      147 				     internal static init ("200 ", "556 ", "800 ", "1600 ", "6250 ");
      148 
      149 	dcl  console_model_names	     (3) char (4)			/* Operator's console model names. */
      150 				     internal static init ("EMC", "EMC", "LCC");
      151 	dcl  console_models		     (3) fixed bin (17) internal static init (6001, 6004, 6601);
      152 
      153 	dcl  speed_names		     (3) char (4)			/* Tape drive speed names. */
      154 				     internal static init ("75 ", "125 ", "200 ");
      155 
      156 	dcl  registry_dir		     char (168) static initial (">system_control_1>rcp");
      157 
      158 	/* 	EXTERNAL ENTRIES CALLED	*/
      159 
      160 	dcl  cleanup		     condition;			/* Used to release temp segment. */
      161 
      162 	dcl  (addr, after, before, clock, hbound, length, max, null, rtrim, substr, unspec) builtin;
      163 
      164 	dcl  (error_table_$badcall,
      165 	     error_table_$badopt,
      166 	     error_table_$inconsistent,
      167 	     error_table_$not_act_fnc,
      168 	     error_table_$odd_no_of_args,
      169 	     error_table_$resource_type_inappropriate,
      170 	     error_table_$wrong_no_of_args) fixed bin (35) external;
      171 
      172 	dcl  (com_err_, active_fnc_err_)   entry options (variable);
      173 	dcl  cu_$af_return_arg	     entry (fixed bin, pointer, fixed bin (21), fixed bin (35));
      174 	dcl  (cu_$arg_ptr_rel, cu_$af_arg_ptr_rel) entry (fixed bin, ptr, fixed bin, fixed bin (35), ptr);
      175 	dcl  cu_$arg_list_ptr	     ext entry (pointer);
      176 	dcl  date_time_		     entry (fixed bin (71), char (*));
      177 	dcl  ioa_			     entry options (variable);
      178 	dcl  hcs_$get_max_length_seg	     entry (ptr, fixed bin (19), fixed bin (35));
      179 	dcl  get_temp_segment_	     entry (char (*), ptr, fixed bin (35));
      180 	dcl  release_temp_segment_	     entry (char (*), ptr, fixed bin (35));
      181 	dcl  rcp_$copy_list		     entry (ptr, fixed bin (19), fixed bin (35));
      182 	dcl  resource_info_$get_rtypex     entry (char (*), char (*), fixed bin, bit (1) aligned, fixed bin (35));
      183 
  1     1 /*	Begin  include file ... rcp_list_info.incl.pl1
  1     2*   *
  1     3*   *	Created on 01/29/75 by Bill Silver.
  1     4*   *	Changed on 04/02/76 by Bill Silver to add lv entries.
  1     5*   *	Modified on 12/09/78 by Michael R. Jordan to add reservation information (version 3).
  1     6*   *	Modified 8/81 by M.R. Jordan to expand reservation information (version 4).
  1     7*   *	This include file defines arrays of entries that contain information
  1     8*   *	about the resources that a process has assigned and attached.
  1     9**/
  1    10 dcl  rli_ptr ptr;					/* Pointer to base of RCP list structure. */
  1    11 dcl  dassign_ptr ptr;				/* Pointer to a device assignment entry. */
  1    12 dcl  attach_ptr ptr;				/* Pointer to an attachment entry. */
  1    13 dcl  lv_ptr ptr;					/* Pointer to an lv entry. */
  1    14 dcl  device_resv_ptr ptr;				/* Pointer to a device reservation entry. */
  1    15 dcl  vol_resv_ptr ptr;				/* Pointer to a volume reservation entry. */
  1    16 
  1    17 dcl  rli_version_4 fixed bin internal static init (4);
  1    18 
  1    19 dcl 1 rli based (rli_ptr) aligned,			/* Base of RCP list structure. */
  1    20     2 head like rli_header,				/* header of structure. */
  1    21     2 dassigns (0 refer (rli.head.num_dassign))
  1    22      like dassign,					/* An array of device assignment entries. */
  1    23     2 attaches (0 refer (rli.head.num_attach))
  1    24      like attach,					/* An array of attachment entries. */
  1    25     2 lvs (0 refer (rli.head.num_lv))
  1    26      like lv,					/* An array of lv attachment entries. */
  1    27     2 device_resvs (0 refer (rli.head.num_device_resv))
  1    28      like device_resv,
  1    29     2 vol_resvs (0 refer (rli.head.num_vol_resv))
  1    30      like vol_resv,
  1    31     2 end bit (36);					/* Dummy used to reference end of structure. */
  1    32 
  1    33 dcl 1 rli_header based aligned,			/* Header of RCP list info structure. */
  1    34     2 version_num fixed bin,				/* Current version number.  Now = 1. */
  1    35     2 num_lv fixed bin,				/* Number of lv attachment entries. */
  1    36     2 num_dassign fixed bin,				/* Number of device assignment entries. */
  1    37     2 num_attach fixed bin,				/* Number of attachment entries. */
  1    38     2 num_device_resv fixed bin,			/* Number of devices reserved. */
  1    39     2 num_vol_resv fixed bin;				/* Number of volumes reserved. */
  1    40 
  1    41 dcl 1 dassign based (dassign_ptr) aligned,		/* Structure of a device assignment entry. */
  1    42     2 device_name char (8),				/* Device name. */
  1    43     2 dtypex fixed bin,				/* Device type index. */
  1    44     2 model fixed bin,				/* Device model number. */
  1    45     2 num_qualifiers fixed bin,			/* Number of device qualifiers. */
  1    46     2 qualifiers (4) fixed bin (35),			/* Device qualifiers. */
  1    47     2 state_time fixed bin (71),			/* Time assignment put into current state. */
  1    48     2 state fixed bin,				/* Current state of assignment. */
  1    49     2 level fixed bin,				/* Current validation level. */
  1    50     2 disposition bit (36),				/* Disposition of assignment. */
  1    51     2 flags,
  1    52      (3 attached bit (1)) unaligned,			/* ON => device is attached. */
  1    53     2 rcp_id bit (36),				/* RCP ID for this assignment. */
  1    54     2 usage_time fixed bin,				/* Number of minutes device may be assigned. */
  1    55     2 wait_time fixed bin;				/* Number of minutes user must wait for assignment. */
  1    56 
  1    57 dcl 1 attach based (attach_ptr) aligned,		/* Structure of an attachment entry. */
  1    58     2 device_name char (8),				/* Name of attached device. */
  1    59     2 volume_name char (32),				/* Name of attached volume. */
  1    60     2 dtypex fixed bin,				/* Device type index. */
  1    61     2 state_time fixed bin (71),			/* Time attachment put into current state. */
  1    62     2 state fixed bin,				/* Current state of this attachment. */
  1    63     2 level fixed bin,				/* Current validation level. */
  1    64     2 flags,					/* Info flags. */
  1    65      (3 priv bit (1),				/* ON => attached with privilege. */
  1    66       3 writing bit (1)) unal,			/* ON => attached for writing. */
  1    67     2 rcp_id bit (36),				/* RCP ID for this attachment. */
  1    68     2 workspace_max fixed bin (19),			/* Max size of IOI workspace buffer. */
  1    69     2 timeout_max fixed bin (52),			/* Max IOI time-out interval. */
  1    70     2 ioi_index fixed bin,				/* Index used to communicate with IOI. */
  1    71     2 usage_time fixed bin,				/* Number of minutes device may be attached. */
  1    72     2 wait_time fixed bin;				/* Number of minutes user must wait for attachment. */
  1    73 
  1    74 dcl 1 lv based (lv_ptr) aligned,			/* Structure of an LV entry. */
  1    75     2 volume_name char (32),				/* Logical volume name. */
  1    76     2 state_time fixed bin (71),			/* Time lv attached for process. */
  1    77     2 rcp_id bit (36);				/* RCP ID for this lv attachment. */
  1    78 
  1    79 dcl 1 device_resv based (device_resv_ptr) aligned,	/* Structure of a device reservation. */
  1    80     2 reservation_id fixed bin (71),
  1    81     2 reserved_by char (32),
  1    82     2 dtypex fixed bin,
  1    83     2 device_name char (8);
  1    84 
  1    85 dcl 1 vol_resv based (vol_resv_ptr) aligned,		/* Structure of a volume reservation. */
  1    86     2 reservation_id fixed bin (71),
  1    87     2 reserved_by char (32),
  1    88     2 vtypex fixed bin,
  1    89     2 volume_name char (32);
  1    90 
  1    91 /*	End of include file ... rcp_list_info.incl.pl1	*/
      184 
      185 
      186 	/* list_resources: */
      187 
      188 	temp_seg_ptr = null;
      189 	ecode,							/* Initialize. */
      190 	     list_index = 0;					/* 0 => all devices of all types. */
      191 	dtypex, vtypex, typex = 0;
      192 	request_control = Unset;
      193 	user_id = "";						/* default is myself */
      194 	resource_type = "";
      195 
      196 	long_flag = "0"b;						/* Default = minimum of information. */
      197 
      198 	call cu_$af_return_arg (num_args, return_argp, return_argl, ecode);	/* Get total number of arguments. */
      199 	if ecode = error_table_$not_act_fnc then do;
      200 		called_as_af = ""b;
      201 		cu_arg_ptr_entry = cu_$arg_ptr_rel;
      202 	     end;
      203 	else if ecode ^= 0 then do;
      204 		call active_fnc_err_ (ecode, "list_resources", "Obtaining argument information.");
      205 		if return_argp ^= null then return_arg = "";
      206 		return;
      207 	     end;
      208 	else do;
      209 		called_as_af = "1"b;
      210 		cu_arg_ptr_entry = cu_$af_arg_ptr_rel;
      211 	     end;
      212 
      213 	call cu_$arg_list_ptr (alp);
      214 
      215 	do argx = 1 to num_args;					/* Process each argument. */
      216 	     call PROCESS_ARG;					/* Most will be processed in pairs. */
      217 	     if ecode ^= 0 then return;				/* If error, abort */
      218 	end;
      219 
      220 	if request_control = Unset then request_control = Default;
      221 
      222 	if called_as_af then					/* was more than one option specified? */
      223 	     if after (request_control, "1"b) ^= ""b then do;
      224 		     call active_fnc_err_ (error_table_$inconsistent, "list_resources",
      225 			"More than one category of information requested in active function mode.");
      226 		     return_arg = "";
      227 		end;
      228 
      229 
      230 	/*  Now that we have valid arguments, get a work segment.  Then call RCP
      231*   to get the information about the resources associated with this process. */
      232 
      233 	on cleanup begin;						/* Cleanup handler for temp seg releasing. */
      234 		if temp_seg_ptr ^= null () then
      235 		     call release_temp_segment_ ("list_resources", temp_seg_ptr, ecode);
      236 	     end;
      237 
      238 	call GET_TEMP_SEG;						/* Get temporary working segment. */
      239 	if ecode ^= 0 then return;
      240 
      241 
      242 	/* Now process the requests. */
      243 
      244 	listed_flag = ""b;
      245 
      246 	/* List assignments. */
      247 
      248 	if (request_control & Assignments) ^= "0"b then do;
      249 		call COPY_RCP_LIST;
      250 
      251 		if (rli.head.num_dassign ^= 0)			/* if device assignments */
      252 		     | (request_control ^= Default) then do;		/* or not default case */
      253 			listed_flag = "1"b;				/* Something will be listed. */
      254 			call ioa_ ("Device Assignments");
      255 			call LIST_DASSIGN;				/* List all device assignments. */
      256 		     end;
      257 	     end;
      258 
      259 	/* List mounts. */
      260 
      261 	if (request_control & Mounts) ^= "0"b then do;
      262 		call COPY_RCP_LIST;
      263 
      264 		if (rli.head.num_attach ^= 0)				/* if device mounts */
      265 		     | (request_control ^= Default) then do;		/* or not default case */
      266 			listed_flag = "1"b;				/* Something will be listed. */
      267 			call ioa_ ("Mounts");
      268 			call LIST_MOUNTS;				/* List all device assignments. */
      269 		     end;
      270 	     end;
      271 
      272 	/* List logical volumes. */
      273 
      274 	if (request_control & Logical_volumes) ^= "0"b then do;
      275 		call COPY_RCP_LIST;
      276 
      277 		if (rli.head.num_lv ^= 0)				/* if logical volumes */
      278 		     | (request_control ^= Default) then do;		/* or not default case */
      279 			listed_flag = "1"b;				/* Something will be listed. */
      280 			call ioa_ ("Logical Volumes");
      281 			call LIST_LV;				/* List all device assignments. */
      282 		     end;
      283 	     end;
      284 
      285 
      286 	/* List reservations. */
      287 
      288 	if (request_control & Reservations) ^= "0"b then do;
      289 		call COPY_RCP_LIST;
      290 
      291 		if (rli.head.num_device_resv + rli.head.num_vol_resv ^= 0)	/* if reservations */
      292 		     | (request_control ^= Default) then do;		/* or not default case */
      293 			listed_flag = "1"b;				/* Something will be listed. */
      294 			call ioa_ ("Resource Reservations");
      295 			call LIST_RESERVATIONS;
      296 		     end;
      297 	     end;
      298 
      299 	/* List acquisitions. */
      300 
      301 	if (request_control & Acquisitions) ^= "0"b then do;
      302 
      303 		if request_control ^= Acquisitions then			/* other things too */
      304 		     call ioa_ ("Resource Acquisitions");
      305 		listed_flag = "1"b;					/* Something will be listed. */
      306 		call LIST_ACQUISITIONS;
      307 	     end;
      308 
      309 
      310 	if ^listed_flag then					/* Did we list anything? */
      311 	     call ioa_ ("list_resources: No resources selected.");		/* No. */
      312 
      313 RETURN:	if temp_seg_ptr ^= null then
      314 	     call release_temp_segment_ ("list_resources", temp_seg_ptr, ecode);
      315 	return;
      316 
      317 PROCESS_ARG: procedure;
      318 
      319 	/* This procedure is called to process one option argument.  Many of these
      320*   options have an accompanying value argument.  This value must be the next
      321*   argument.  In this case we will process the value argument too.  */
      322 
      323 	call cu_arg_ptr_entry (argx, arg_ptr, arg_len, ecode, alp);
      324 	if ecode ^= 0
      325 	then call crump (ecode, "while obtaining arguments.");
      326 
      327 	option = argument;						/* Save option argument. */
      328 	do i = 1 to hbound (long_options, 1);				/* Look for valid option name. */
      329 	     if (option = brief_options (i)) |				/* Is it this brief name? */
      330 		(option = long_options (i))				/* Or this long name? */
      331 	     then do;						/* Yes, one of them. */
      332 		     if called_as_af then
      333 			if ^af_usage_allowed (i) then do;
      334 				call active_fnc_err_ (error_table_$badcall, "list_resources",
      335 				     "^a not available in active function mode.", option);
      336 				return_arg = "";
      337 				return;
      338 			     end;
      339 
      340 		     call GET_VALUE (i);				/* Get value argument if any. */
      341 		     if ecode ^= 0					/* Check for errors. */
      342 		     then return;
      343 		     goto OPTION (i);				/* Go process this option. */
      344 		end;
      345 	end;
      346 
      347 	call crump (error_table_$badopt, option);			/* Option name not found. */
      348 	return;
      349 
      350 OPTION (1):							/* "-tp" or "-type" */
      351 	list_index = max (1, list_index);				/* 1 => list all devices of this type. */
      352 
      353 	dtypex, vtypex = 0;
      354 	call resource_info_$get_rtypex (argument, resource_type, typex, is_volume, ecode);
      355 	if ecode ^= 0 then
      356 	     call crump (ecode, argument);
      357 
      358 	if is_volume then vtypex = typex;
      359 	else dtypex = typex;
      360 	return;
      361 
      362 OPTION (2):							/* "-dv" or "-device" */
      363 	list_index = 2;						/* 2 => list only this one device. */
      364 	device_name = argument;					/* Get device name. */
      365 	return;
      366 OPTION (3):							/* "-lg" or "-long" */
      367 	long_flag = "1"b;						/* User wants all available information. */
      368 	return;
      369 OPTION (4):							/* "-asm" or "-assignments" */
      370 	request_control = request_control | Assignments;			/* User wants device assignments. */
      371 	return;
      372 OPTION (9):							/* "-atm" or "-attachments" */
      373 	call ioa_ ("list_resources:  Warning-- -mounts (-mts) should be used rather than -attachments (-atm).");
      374 OPTION (5):							/* "-mts" or "-mounts" */
      375 	request_control = request_control | Mounts;
      376 	return;
      377 OPTION (6):							/* "-lv" or "-logical_volumes" */
      378 	request_control = request_control | Logical_volumes;		/* User wants attached logical volumes. */
      379 	return;
      380 
      381 OPTION (7):							/* "-acq" or "-acquisitions" */
      382 	request_control = request_control | Acquisitions;
      383 	return;
      384 
      385 OPTION (8):							/* "-user" */
      386 	if awaiting_clear then
      387 	     call crump (error_table_$inconsistent, "-awaiting_clear and -user");
      388 
      389 	user_id = argument;
      390 	return;
      391 
      392 OPTION (10):							/* "-reservations" or "-resv" */
      393 	request_control = request_control | Reservations;
      394 	return;
      395 
      396 OPTION (11):							/* "-awaiting_clear" */
      397 	request_control = request_control | Acquisitions;
      398 	if user_id ^= "" then
      399 	     call crump (error_table_$inconsistent, "-awaiting_clear and -user.");
      400 
      401 	user_id = "*.*";
      402 	awaiting_clear = "1"b;
      403 	return;
      404 
      405      end PROCESS_ARG;
      406 
      407 GET_VALUE: procedure (option_num);
      408 
      409 	/* This procedure is called to get any value argument associated with this option.
      410*   Processing of the value argument depends upon the option code value associated
      411*   with this option.  The option code values are:
      412*   0.	This option argument has no accompanying value argument.
      413*   1.	This option argument has a string type value argument. */
      414 
      415 	dcl  option_num		     fixed bin;			/* Number that identifies this option. */
      416 
      417 	option_code = option_codes (option_num);			/* Get code value for this option. */
      418 
      419 	if option_code = 0						/* Is there an accompanying argument value? */
      420 	then return;						/* No, nothing else to do. */
      421 
      422 	/* Get accompanying argument value. */
      423 
      424 	if argx = num_args then					/* Is this the last argument? */
      425 	     call crump (error_table_$odd_no_of_args, "No value argument for " || option);
      426 
      427 	argx = argx + 1;						/* Get the next argument. */
      428 	call cu_arg_ptr_entry (argx, arg_ptr, arg_len, ecode, alp);
      429 	if ecode ^= 0 then
      430 	     call crump (ecode, "while obtaining arguments.");
      431 
      432 	if substr (argument, 1, 1) = "-" then				/* Is next argument a control option? */
      433 	     call crump (error_table_$wrong_no_of_args, "No value argument for " || option);
      434 
      435      end GET_VALUE;
      436 
      437 COPY_RCP_LIST: proc;
      438 
      439 	if rcp_list_copied then return;
      440 
      441 	rli.head.version_num = rli_version_4;				/* Tell RCP version we are working with. */
      442 	call rcp_$copy_list (rli_ptr, seg_size, ecode);
      443 	if ecode ^= 0 then
      444 	     call crump (ecode, "Error copying RCP list information.");
      445 
      446 	rcp_list_copied = "1"b;
      447 
      448 	return;
      449 
      450      end COPY_RCP_LIST;
      451 
      452 LIST_DASSIGN: procedure;
      453 
      454 	/* This procedure is called to list device assignments.  The device
      455*   assignments that will be listed depend upon the list_index variable.
      456*   We will list the assignments of all devices, all devices of a specified
      457*   type, or one specific device. */
      458 
      459 	num_listed = 0;
      460 	goto DASSIGN (list_index);					/* Decide which device assignments to list. */
      461 
      462 DASSIGN (0):							/* List all device assignments. */
      463 	if rli.head.num_dassign = 0					/* Any devices assigned? */
      464 	then do;							/* No. */
      465 		call ioa_ ("No devices assigned.");
      466 		return;
      467 	     end;
      468 	if long_flag						/* If in long mode tell how many. */
      469 	then if rli.head.num_dassign = 1
      470 	     then call ioa_ ("1 device assigned");
      471 	     else call ioa_ ("^d devices assigned", rli.head.num_dassign);
      472 	do i = 1 to rli.head.num_dassign;				/* Process each device assignment block. */
      473 	     dassign_ptr = addr (rli.dassigns (i));
      474 	     call LIST_DASSIGNMENT;					/* List each one. */
      475 	end;
      476 	return;
      477 
      478 DASSIGN (1):							/* All device assignments of specified type. */
      479 	if is_volume then
      480 	     call crump (error_table_$resource_type_inappropriate, rtrim (resource_type) || " is not a device type.");
      481 	do i = 1 to rli.head.num_dassign;				/* Look at each device assignment block. */
      482 	     dassign_ptr = addr (rli.dassigns (i));
      483 	     if dtypex = dassign.dtypex				/* Is this the device type specified? */
      484 	     then call LIST_DASSIGNMENT;				/* Yes, list this device assignment. */
      485 	end;
      486 	if num_listed = 0						/* Did we find any for this device type? */
      487 	then call ioa_ ("^5xNo ^a type devices assigned.", resource_type);
      488 	return;
      489 
      490 DASSIGN (2):							/* List specific device assignment. */
      491 	if is_volume then
      492 	     call crump (error_table_$resource_type_inappropriate, rtrim (resource_type) || " is not a device type.");
      493 	do i = 1 to rli.head.num_dassign;				/* Look through all device assignments. */
      494 	     dassign_ptr = addr (rli.dassigns (i));
      495 	     if device_name = dassign.device_name
      496 	     then do;						/* We found the device. */
      497 		     call LIST_DASSIGNMENT;				/* List its assignment info. */
      498 		     return;					/* No need to look further. */
      499 		end;
      500 	end;
      501 	call ioa_ ("^5xDevice ^a is not assigned", device_name);
      502 
      503      end LIST_DASSIGN;
      504 
      505 LIST_MOUNTS: procedure;
      506 
      507 	/* This procedure is called to list mounts.  The mounts that will be listed
      508*   depend upon the list_index variable.  We will list info on all devices, all
      509*   devices of a specified type, or one specific device.  */
      510 
      511 	num_listed = 0;
      512 	goto MOUNTS (list_index);					/* Decide which mounts to list. */
      513 
      514 MOUNTS (0):							/* List all mounts. */
      515 	if rli.head.num_attach = 0					/* Any mounts? */
      516 	then do;							/* No. */
      517 		call ioa_ ("No mounts.");
      518 		return;
      519 	     end;
      520 	if long_flag then						/* If in long mode tell how many. */
      521 	     call ioa_ ("^d mount^[s^;^]", rli.head.num_attach,
      522 		(rli.head.num_attach = 1));
      523 
      524 	do i = 1 to rli.head.num_attach;				/* Process each mount. */
      525 	     attach_ptr = addr (rli.attaches (i));
      526 	     call LIST_SINGLE_MOUNT;					/* List each one. */
      527 	end;
      528 	return;
      529 
      530 MOUNTS (1):							/* All mounts of specified type. */
      531 	if is_volume then
      532 	     call crump (error_table_$resource_type_inappropriate, rtrim (resource_type) || " is not a device type.");
      533 	do i = 1 to rli.head.num_attach;				/* Look at each mount block. */
      534 	     attach_ptr = addr (rli.attaches (i));
      535 	     if dtypex = attach.dtypex				/* Is this the device type specified? */
      536 	     then call LIST_SINGLE_MOUNT;
      537 	end;
      538 	if num_listed = 0						/* Did we find any for this device type? */
      539 	then call ioa_ ("^5xNo ^a type devices mounted.", resource_type);
      540 	return;
      541 
      542 MOUNTS (2):							/* List specific device mount. */
      543 	if is_volume then
      544 	     call crump (error_table_$resource_type_inappropriate, rtrim (resource_type) || " is not a device type.");
      545 	do i = 1 to rli.head.num_attach;				/* Look through all mounts. */
      546 	     attach_ptr = addr (rli.attaches (i));
      547 	     if device_name = dassign.device_name
      548 	     then do;						/* We found the device. */
      549 		     call LIST_SINGLE_MOUNT;				/* List its mount info. */
      550 		     return;
      551 		end;
      552 	end;
      553 	call ioa_ ("^5xDevice ^a is not mounted.", device_name);
      554 
      555      end LIST_MOUNTS;
      556 
      557 LIST_LV: procedure;
      558 
      559 	/* This procedure is called to list attached logical volumes.
      560*   All logical volumes attached for the calling process will be listed. */
      561 
      562 	if rli.head.num_lv = 0					/* Any logical volumes attached? */
      563 	then do;							/* No. */
      564 		call ioa_ ("No logical volumes");
      565 		return;
      566 	     end;
      567 
      568 	do i = 1 to rli.num_lv;					/* List all attached logical volumes. */
      569 	     lv_ptr = addr (rli.lvs (i));				/* Get pointer to lv info. */
      570 	     call ioa_ ("^5x^a", lv.volume_name);
      571 	     if long_flag						/* Does user want more info? */
      572 	     then do;						/* Yes. */
      573 		     call ioa_ ("^-State^-=  attached");
      574 		     call date_time_ (lv.state_time, time_string);
      575 		     call ioa_ ("^-Time^-=  ^a", time_string);
      576 		end;
      577 	end;
      578 
      579      end LIST_LV;
      580 
      581 LIST_RESERVATIONS: procedure;
      582 
      583 	/*   This procedure is called to list information about reservations.
      584*   The reservations that will be listed depend on the control arguments
      585*   specified by the caller. */
      586 
      587 	do i = 1 to rli.head.num_device_resv;				/* First look at the devices. */
      588 	     device_resv_ptr = addr (rli.device_resvs (i));
      589 	     if device_resv.reservation_id ^= 0 then			/* This one looks like a good one to list. */
      590 		call LIST_RESERVATION (device_resv.reservation_id);
      591 	end;
      592 
      593 
      594 	do i = 1 to rli.head.num_vol_resv;				/* Then make sure we haven't missed any volumes. */
      595 	     vol_resv_ptr = addr (rli.vol_resvs (i));
      596 	     if vol_resv.reservation_id ^= 0 then			/* List this one. */
      597 		call LIST_RESERVATION (vol_resv.reservation_id);
      598 	end;
      599 
      600 
      601 	return;
      602 
      603 
      604      end LIST_RESERVATIONS;
      605 
      606 LIST_DASSIGNMENT: procedure;
      607 
      608 	/* This procedure is called to list the assignment information for
      609*   one device.  If we are in long mode we will list all of the
      610*   device characteristics. */
      611 
      612 	num_listed = num_listed + 1;
      613 
      614 	if dassign.device_name ^= " "					/* Do we know device name? */
      615 	then call ioa_ ("^5xDevice ^a", dassign.device_name);
      616 	else call ioa_ ("^5xDevice not yet assigned");
      617 
      618 	if dassign.state = 0					/* State = 0 => free due to force unassign. */
      619 	then do;
      620 		call ioa_ ("^-State^-=  force unassigned");
      621 		return;
      622 	     end;
      623 
      624 	if ^long_flag						/* Does caller want all information? */
      625 	then return;						/* No. */
      626 
      627 	if dassign.state = 5					/* State = 5 => assignment completed. */
      628 	then call ioa_ ("^-State^-=  assigned");
      629 	else call ioa_ ("^-State^-=  assigning");
      630 	call date_time_ (dassign.state_time, time_string);
      631 	call ioa_ ("^-Time^-=  ^a", time_string);
      632 	if substr (dassign.disposition, 1, 1)				/* ON => retain,  OFF => unassign. */
      633 	then call ioa_ ("^-Disp^-=  retain");
      634 	else call ioa_ ("^-Disp^-=  unassign");
      635 
      636 	if dassign.flags.attached
      637 	then call ioa_ ("^-Device Mounted");
      638 
      639 	call ioa_ ("^-Level^-=  ^d", dassign.level);
      640 
      641 	if dassign.state ^= 5					/* Is device assignment completed? */
      642 	then return;						/* No, don't print device characteristics. */
      643 
      644 	call ioa_ ("^-Model^-=  ^d", dassign.model);
      645 
      646 	goto DTYPE (dassign.dtypex);					/* Process device type specific data. */
      647 
      648 DTYPE (1):							/* TAPE */
      649 	call ioa_ ("^-Tracks^-=  ^d", dassign.qualifiers (1));
      650 	density_ptr = addr (dassign.qualifiers (2));
      651 	density_comment = "";
      652 	do k = 1 to hbound (density_names, 1);				/* Check for each possible density. */
      653 	     if substr (based_density, k, 1)
      654 	     then density_comment = density_comment || density_names (k);
      655 	end;
      656 	call ioa_ ("^-Densities^-=  ^a", density_comment);
      657 	speed_ptr = addr (dassign.qualifiers (3));
      658 	speed_comment = "";
      659 	do k = 1 to hbound (speed_names, 1);				/* Check for each possible speed. */
      660 	     if substr (based_speed, k, 1)
      661 	     then speed_comment = speed_comment || speed_names (k);
      662 	end;
      663 	call ioa_ ("^-Speed^-=  ^a", speed_comment);
      664 	return;
      665 
      666 DTYPE (3):							/* CONSOLE */
      667 	do k = 1 to hbound (console_models, 1);
      668 	     if dassign.model = console_models (k) then do;
      669 		     call ioa_ ("^-Type^-=  ^a", console_model_names (k));
      670 		     return;
      671 		end;
      672 	end;
      673 
      674 	call crump (0, "Illegal console model number.");
      675 
      676 	return;
      677 
      678 DTYPE (4):							/* PRINTER */
      679 	call ioa_ ("^-Train^-=  ^d", dassign.qualifiers (1));
      680 	if dassign.qualifiers (2) = -1				/* -1 => line length not given on PRPH card. */
      681 	then call ioa_ ("^-Line Len^-=  not specified");
      682 	else call ioa_ ("^-Line Len^-=  ^d", dassign.qualifiers (2));
      683 	return;
      684 
      685 DTYPE (2):							/* DISK */
      686 DTYPE (5):							/* PUNCH */
      687 DTYPE (6):							/* READER */
      688 DTYPE (7):							/* SPECIAL */
      689 
      690      end LIST_DASSIGNMENT;
      691 
      692 LIST_SINGLE_MOUNT: procedure;
      693 
      694 	/* This procedure is called to list the information about one mount.
      695*   If we are in long mode we will list all available information. */
      696 
      697 	num_listed = num_listed + 1;
      698 
      699 	if attach.device_name ^= " "
      700 	then call ioa_ ("^5xDevice ^a", attach.device_name);
      701 	else call ioa_ ("^5xDevice not yet assigned");
      702 
      703 	if attach.volume_name ^= " "
      704 	then call ioa_ ("^-Volume^-=  ^a", attach.volume_name);
      705 
      706 	if attach.state = 0						/* State = 0 => free due to force unassignment. */
      707 	then do;
      708 		call ioa_ ("^-State^-=  force unassigned");
      709 		return;
      710 	     end;
      711 
      712 	if ^long_flag						/* Does user want all available info? */
      713 	then return;						/* No. */
      714 
      715 	call ioa_ ("^-State^-=  ^a", operation_states (attach.state));
      716 	call date_time_ (attach.state_time, time_string);
      717 	call ioa_ ("^-Time^-=  ^a", time_string);
      718 
      719 	if attach.flags.priv
      720 	then call ioa_ ("^-Attached with privilege");
      721 	if attach.flags.writing
      722 	then call ioa_ ("^-Attached for writing");
      723 
      724 	call ioa_ ("^-Level^-=  ^d", attach.level);
      725 	k = attach.workspace_max / 1024;
      726 	call ioa_ ("^-WS Max^-=  ^d K", k);
      727 	seconds = attach.timeout_max / 1000000;
      728 	call ioa_ ("^-TO Max^-=  ^d seconds", seconds);
      729 
      730      end LIST_SINGLE_MOUNT;
      731 
      732 LIST_RESERVATION: procedure (arg_rid);
      733 
      734 
      735 	dcl  arg_rid		     fixed bin (71);
      736 	dcl  request_id_		     entry (fixed bin (71)) returns (char (19));
      737 	dcl  header_printed		     bit (1);			/* Bit to tell whether we have printed resource class. */
      738 	dcl  k			     fixed bin;
      739 	dcl  rid			     fixed bin (71);		/* Reservation to list. */
      740 	dcl  rid_string		     char (32);			/* String representation of reservation id. */
      741 
      742 
      743 	rid = arg_rid;						/* copy reservation id */
      744 
      745 
      746 	rid_string = request_id_ (rid);
      747 	if long_flag then						/* Print full reservation id. */
      748 	     call ioa_ ("^/^2xReservation ^a (claimed)", rid_string);
      749 	else call ioa_ ("^/^2xReservation ^a (claimed)", substr (rid_string, 7, 6));
      750 
      751 
      752 	header_printed = "0"b;
      753 	do k = 1 to rli.head.num_device_resv;				/* Look at all device entries. */
      754 	     device_resv_ptr = addr (rli.device_resvs (k));
      755 	     if device_resv.reservation_id = rid then do;			/* Got one. */
      756 		     if ^header_printed then do;			/* Print header. */
      757 			     call ioa_ ("^5xDevices");
      758 			     header_printed = "1"b;
      759 			end;
      760 		     call ioa_ ("^-^a", device_resv.device_name);
      761 		     device_resv.reservation_id = 0;
      762 		end;
      763 	end;
      764 
      765 
      766 	header_printed = "0"b;
      767 	do k = 1 to rli.head.num_vol_resv;				/* Look at all vol entries. */
      768 	     vol_resv_ptr = addr (rli.vol_resvs (k));
      769 	     if vol_resv.reservation_id = rid then do;			/* Got one. */
      770 		     if ^header_printed then do;			/* Print header. */
      771 			     call ioa_ ("^5xVolumes");
      772 			     header_printed = "1"b;
      773 			end;
      774 		     call ioa_ ("^-^a", vol_resv.volume_name);
      775 		     vol_resv.reservation_id = 0;
      776 		end;
      777 	end;
      778 
      779 
      780 	return;
      781 
      782 
      783      end LIST_RESERVATION;
      784 
      785 LIST_ACQUISITIONS: proc;
      786 
      787 	dcl  sys_info$max_seg_size	     ext fixed bin (35) static;
      788 
      789 	dcl  define_area_		     ext entry (pointer, fixed bin (35)),
      790 	     release_area_		     ext entry (pointer),
      791 	     get_group_id_		     ext entry returns (char (32)),
      792 	     (rcp_$list_resources, rcp_admin_$list_resources, rcp_admin_$list_awaiting_clear)
      793 				     entry (char (*), char (*), char (*), pointer, fixed bin (35), pointer, fixed bin (35));
      794 
      795 	dcl  group_id		     char (32),
      796 	     uname		     char (32),
      797 	     pname		     char (32),
      798 	     n_resources		     fixed bin (35),
      799 	     priv_sw		     bit (1) aligned;
      800 
      801 	dcl  1 auto_area_info	     like area_info aligned automatic;
      802 
  2     1 /* BEGIN INCLUDE FILE area_info.incl.pl1  12/75 */
  2     2 
  2     3 dcl  area_info_version_1 fixed bin static init (1) options (constant);
  2     4 
  2     5 dcl  area_infop ptr;
  2     6 
  2     7 dcl 1 area_info aligned based (area_infop),
  2     8     2 version fixed bin,				/* version number for this structure is 1 */
  2     9     2 control aligned like area_control,		/* control bits for the area */
  2    10     2 owner char (32) unal,				/* creator of the area */
  2    11     2 n_components fixed bin,				/* number of components in the area (returned only) */
  2    12     2 size fixed bin (18),				/* size of the area in words */
  2    13     2 version_of_area fixed bin,			/* version of area (returned only) */
  2    14     2 areap ptr,					/* pointer to the area (first component on multisegment area) */
  2    15     2 allocated_blocks fixed bin,			/* number of blocks allocated */
  2    16     2 free_blocks fixed bin,				/* number of free blocks not in virgin */
  2    17     2 allocated_words fixed bin (30),			/* number of words allocated in the area */
  2    18     2 free_words fixed bin (30);			/* number of words free in area not in virgin */
  2    19 
  2    20 dcl 1 area_control aligned based,
  2    21     2 extend bit (1) unal,				/* says area is extensible */
  2    22     2 zero_on_alloc bit (1) unal,			/* says block gets zerod at allocation time */
  2    23     2 zero_on_free bit (1) unal,			/* says block gets zerod at free time */
  2    24     2 dont_free bit (1) unal,			/* debugging aid, turns off free requests */
  2    25     2 no_freeing bit (1) unal,			/* for allocation method without freeing */
  2    26     2 system bit (1) unal,				/* says area is managed by system */
  2    27     2 pad bit (30) unal;
  2    28 
  2    29 /* END INCLUDE FILE area_info.incl.pl1 */
      803 
  3     1 /* --------------- BEGIN include file resource_list.incl.pl1 --------------- */
  3     2 
  3     3 dcl 1 resource_list aligned based (resource_list_ptr),
  3     4     2 forward_ptr pointer initial (null),		/* points to next block, null if no next block */
  3     5     2 max_entries fixed bin,				/* number of elements in resource name array */
  3     6     2 n_resources fixed bin initial (0),		/* number of valid resource names in this block */
  3     7     2 resource_name (Max_entries refer (resource_list.max_entries)) char (32);
  3     8 						/* resource names */
  3     9 dcl  Max_entries fixed bin,
  3    10      resource_list_ptr pointer;
  3    11 
  3    12 /* ---------------- END include file resource_list.incl.pl1 ---------------- */
      804 
      805 
      806 	if resource_type = "" then
      807 	     if awaiting_clear
      808 	     then call crump (error_table_$wrong_no_of_args,
      809 		     "-type must be specified with -awaiting_clear.");
      810 	     else call crump (error_table_$wrong_no_of_args,
      811 		     "-type must be specified with -acquisitions.");
      812 
      813 	unspec (auto_area_info) = ""b;
      814 	auto_area_info.version = area_info_version_1;
      815 	auto_area_info.extend,
      816 	     auto_area_info.no_freeing = "1"b;
      817 	auto_area_info.owner = "list_resources";
      818 	auto_area_info.size = sys_info$max_seg_size;
      819 	auto_area_info.areap = temp_seg_ptr;
      820 
      821 	call define_area_ (addr (auto_area_info), ecode);
      822 	if ecode ^= 0 then
      823 	     call crump (ecode, "defining temporary area.");
      824 
      825 	on cleanup call release_area_ (temp_seg_ptr);			/* no real window exists here -- */
      826 								/* this is only necessary after call to ring 1
      827*						   may extend area to multi segments */
      828 
      829 	group_id = get_group_id_ ();
      830 	group_id = substr (group_id, 1, length (rtrim (group_id, " ")) - 2);	/* cut off tag */
      831 
      832 	if user_id = "" then user_id = group_id;
      833 	if user_id = group_id then priv_sw = ""b;
      834 	else do;
      835 		uname = before (user_id, ".");
      836 		pname = after (user_id, ".");
      837 		if (uname = "*") & (pname ^= "*") then priv_sw = ""b;
      838 		else priv_sw = "1"b;
      839 	     end;
      840 
      841 	if awaiting_clear then
      842 	     call rcp_admin_$list_awaiting_clear (resource_type, registry_dir,
      843 		user_id, temp_seg_ptr, n_resources, resource_list_ptr, ecode);
      844 	else if priv_sw then
      845 	     call rcp_admin_$list_resources (resource_type, registry_dir,
      846 		user_id, temp_seg_ptr, n_resources, resource_list_ptr, ecode);
      847 	else call rcp_$list_resources (resource_type, registry_dir,
      848 		user_id, temp_seg_ptr, n_resources, resource_list_ptr, ecode);
      849 
      850 	if ecode ^= 0 then
      851 	     call crump (ecode, "Resource type " || rtrim (resource_type)
      852 		|| " for " || user_id);
      853 
      854 	if called_as_af then return_arg = "";
      855 	else do;
      856 		call date_time_ (clock (), time_string);
      857 
      858 		call ioa_ ("^[No resources^2s^;^[1 resource^s^;^d resources^]^] of type ^a ^[awaiting manual clear.^;acquired by ^a^[.^; at ^a:^/^]^]",
      859 		     (n_resources = 0), (n_resources = 1), n_resources, resource_type,
      860 		     awaiting_clear, user_id, (n_resources = 0), time_string);
      861 	     end;
      862 
      863 	do resource_list_ptr = resource_list_ptr repeat (resource_list.forward_ptr)
      864 	     while (resource_list_ptr ^= null);
      865 
      866 	     do i = 1 to resource_list.n_resources;
      867 		if called_as_af then do;
      868 			return_arg = return_arg || rtrim (resource_list.resource_name (i));
      869 			return_arg = return_arg || " ";
      870 		     end;
      871 
      872 		else call ioa_ ("^a", resource_list.resource_name (i));
      873 	     end;
      874 	end;
      875 
      876 	if called_as_af then
      877 	     return_arg = rtrim (return_arg);
      878 
      879 	call release_area_ (temp_seg_ptr);
      880 
      881 	return;
      882 
      883      end LIST_ACQUISITIONS;
      884 
      885 GET_TEMP_SEG: procedure;
      886 
      887 	/* This procedure is called to get a temporary work segment for
      888*   the RLI structure. */
      889 
      890 	call get_temp_segment_ ("list_resources", temp_seg_ptr, ecode);
      891 	if ecode ^= 0 then
      892 	     call crump (ecode, "Error getting temporary segment");
      893 
      894 	call hcs_$get_max_length_seg (temp_seg_ptr, seg_size, ecode);
      895 	if ecode ^= 0 then
      896 	     call crump (ecode, "Error getting max seg length of temp segment");
      897 
      898 	rli_ptr = temp_seg_ptr;
      899 
      900      end GET_TEMP_SEG;
      901 
      902 crump: proc (ecode, reason);
      903 
      904 	dcl  ecode		     fixed bin (35) parameter,
      905 	     reason		     char (*) parameter;
      906 
      907 	dcl  com_err_entry		     entry variable options (variable);
      908 
      909 	if called_as_af then com_err_entry = active_fnc_err_;
      910 	else com_err_entry = com_err_;
      911 
      912 	call com_err_entry (ecode, "list_resources", "^a", reason);
      913 
      914 	if called_as_af then return_arg = "";
      915 	goto RETURN;
      916      end crump;
      917 
      918 test: entry (new_sysdir);
      919 
      920 	dcl  new_sysdir		     char (*) parameter;
      921 
      922 	if new_sysdir = "" then registry_dir = ">system_control_1>rcp";
      923 	else registry_dir = new_sysdir;
      924 	return;
      925 
      926      end list_resources;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/17/00  1939.5  list_resources.pl1                >udd>sm>ds>w>ml>list_resources.pl1
184          1    03/19/82  1747.0  rcp_list_info.incl.pl1            >ldd>incl>rcp_list_info.incl.pl1
803          2    06/11/76  1143.4  area_info.incl.pl1                >ldd>incl>area_info.incl.pl1
804          3    02/13/79  1815.0  resource_list.incl.pl1            >ldd>incl>resource_list.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Acquisitions                           constant        bit(36)                  initial packed unaligned dcl 135 ref 301 303 381 396
Assignments                            constant        bit(36)                  initial packed unaligned dcl 135 ref 248 369
Default                                constant        bit(36)                  initial packed unaligned dcl 135 ref 220 251 264 277
                                                                                  291
Logical_volumes                        constant        bit(36)                  initial packed unaligned dcl 135 ref 274 377
Mounts                                 constant        bit(36)                  initial packed unaligned dcl 135 ref 261 374
Reservations                           constant        bit(36)                  initial packed unaligned dcl 135 ref 288 392
Unset                                  constant        bit(36)                  initial packed unaligned dcl 135 ref 192 220
active_fnc_err_                 000124 constant        entry                    external dcl 172 ref 204 224 334 909
addr                                                   builtin function         dcl 162 ref 473 482 494 525 534 546 569 588 595 650
                                                                                  657 754 768 821 821
af_usage_allowed         12     000000 constant        bit(1)                   initial array level 2 dcl 122 ref 332
after                                                  builtin function         dcl 162 ref 222 836
alp                             000100 automatic       pointer                  dcl 73 set ref 213* 323* 428*
area_control                           based           structure                level 1 dcl 2-20
area_info                              based           structure                level 1 dcl 2-7
area_info_version_1                    constant        fixed bin(17,0)          initial dcl 2-3 ref 814
areap                    16     000132 automatic       pointer                  level 2 dcl 801 set ref 819*
arg_len                         000102 automatic       fixed bin(17,0)          dcl 74 set ref 323* 327 354 354 355 355 364 389 428*
                                                                                  432
arg_ptr                         000104 automatic       pointer                  dcl 75 set ref 323* 327 354 355 364 389 428* 432
arg_rid                                parameter       fixed bin(71,0)          dcl 735 ref 732 743
argument                               based           char                     packed unaligned dcl 111 set ref 327 354* 355* 364
                                                                                  389 432
argx                            000106 automatic       fixed bin(17,0)          dcl 76 set ref 215* 323* 424 427* 427 428*
attach                                 based           structure                level 1 dcl 1-57
attach_ptr                      000254 automatic       pointer                  dcl 1-12 set ref 525* 534* 535 546* 699 699 703 703
                                                                                  706 715 716 719 721 724 725 727
attached                 17            based           bit(1)                   level 3 packed packed unaligned dcl 1-41 ref 636
attaches                               based           structure                array level 2 dcl 1-19 set ref 525 534 546
auto_area_info                  000132 automatic       structure                level 1 dcl 801 set ref 813* 821 821
awaiting_clear                  000107 automatic       bit(1)                   initial packed unaligned dcl 77 set ref 77* 385 402*
                                                                                  806 841 858*
based_density                          based           bit(5)                   dcl 113 ref 653
based_speed                            based           bit(3)                   dcl 115 ref 660
before                                                 builtin function         dcl 162 ref 835
brief_options                   000000 constant        char(16)                 initial array level 2 packed packed unaligned
                                                                                  dcl 122 ref 329
called_as_af                    000110 automatic       bit(1)                   dcl 78 set ref 200* 209* 222 332 854 867 876 909 914
cleanup                         000242 stack reference condition                dcl 160 ref 233 825
clock                                                  builtin function         dcl 162 ref 856 856
com_err_                        000122 constant        entry                    external dcl 172 ref 910
com_err_entry                   000100 automatic       entry variable           dcl 907 set ref 909* 910* 912
console_model_names             000027 internal static char(4)                  initial array packed unaligned dcl 149 set ref 669*
console_models                  000224 constant        fixed bin(17,0)          initial array dcl 151 ref 666 668
control                   1     000132 automatic       structure                level 2 dcl 801
cu_$af_arg_ptr_rel              000132 constant        entry                    external dcl 174 ref 210
cu_$af_return_arg               000126 constant        entry                    external dcl 173 ref 198
cu_$arg_list_ptr                000134 constant        entry                    external dcl 175 ref 213
cu_$arg_ptr_rel                 000130 constant        entry                    external dcl 174 ref 201
cu_arg_ptr_entry                000112 automatic       entry variable           dcl 79 set ref 201* 210* 323 428
dassign                                based           structure                level 1 dcl 1-41
dassign_ptr                     000252 automatic       pointer                  dcl 1-11 set ref 473* 482* 483 494* 495 547 614 614
                                                                                  618 627 630 632 636 639 641 644 646 648 650 657
                                                                                  668 678 680 682
dassigns                  6            based           structure                array level 2 dcl 1-19 set ref 473 482 494
date_time_                      000136 constant        entry                    external dcl 176 ref 574 630 716 856
define_area_                    000160 constant        entry                    external dcl 789 ref 821
density_comment                 000116 automatic       varying char(30)         dcl 80 set ref 651* 653* 653 656*
density_names                   000227 constant        varying char(5)          initial array dcl 146 ref 652 653
density_ptr                     000130 automatic       pointer                  dcl 81 set ref 650* 653
device_name              13            based           char(8)                  level 2 in structure "device_resv" dcl 1-79
                                                                                  in procedure "lr" set ref 760*
device_name                            based           char(8)                  level 2 in structure "attach" dcl 1-57 in procedure
                                                                                  "lr" set ref 699 699*
device_name                     000132 automatic       char(32)                 packed unaligned dcl 82 in procedure "lr" set ref
                                                                                  364* 495 501* 547 553*
device_name                            based           char(8)                  level 2 in structure "dassign" dcl 1-41 in procedure
                                                                                  "lr" set ref 495 547 614 614*
device_resv                            based           structure                level 1 dcl 1-79
device_resv_ptr                 000260 automatic       pointer                  dcl 1-14 set ref 588* 589 589 754* 755 760 761
device_resvs                           based           structure                array level 2 dcl 1-19 set ref 588 754
disposition              16            based           bit(36)                  level 2 dcl 1-41 ref 632
dtypex                          000152 automatic       fixed bin(17,0)          dcl 84 in procedure "lr" set ref 191* 353* 359* 483
                                                                                  535
dtypex                   12            based           fixed bin(17,0)          level 2 in structure "attach" dcl 1-57 in procedure
                                                                                  "lr" ref 535
dtypex                    2            based           fixed bin(17,0)          level 2 in structure "dassign" dcl 1-41 in procedure
                                                                                  "lr" ref 483 646
ecode                                  parameter       fixed bin(35,0)          dcl 904 in procedure "crump" set ref 902 912*
ecode                           000155 automatic       fixed bin(35,0)          dcl 87 in procedure "lr" set ref 189* 198* 199 203
                                                                                  204* 217 234* 239 313* 323* 324 324* 341 354* 355
                                                                                  355* 428* 429 429* 442* 443 443* 821* 822 822*
                                                                                  841* 844* 847* 850 850* 890* 891 891* 894* 895
                                                                                  895*
error_table_$badcall            000104 external static fixed bin(35,0)          dcl 164 set ref 334*
error_table_$badopt             000106 external static fixed bin(35,0)          dcl 164 set ref 347*
error_table_$inconsistent       000110 external static fixed bin(35,0)          dcl 164 set ref 224* 385* 398*
error_table_$not_act_fnc        000112 external static fixed bin(35,0)          dcl 164 ref 199
error_table_$odd_no_of_args     000114 external static fixed bin(35,0)          dcl 164 set ref 424*
error_table_$resource_type_inappropriate
                                000116 external static fixed bin(35,0)          dcl 164 set ref 478* 490* 530* 542*
error_table_$wrong_no_of_args   000120 external static fixed bin(35,0)          dcl 164 set ref 432* 806* 810*
extend                    1     000132 automatic       bit(1)                   level 3 packed packed unaligned dcl 801 set ref 815*
flags                    17            based           structure                level 2 in structure "dassign" dcl 1-41 in procedure
                                                                                  "lr"
flags                    20            based           structure                level 2 in structure "attach" dcl 1-57 in procedure
                                                                                  "lr"
forward_ptr                            based           pointer                  initial level 2 dcl 3-3 ref 874
get_group_id_                   000164 constant        entry                    external dcl 789 ref 829
get_temp_segment_               000144 constant        entry                    external dcl 179 ref 890
group_id                        000100 automatic       char(32)                 packed unaligned dcl 795 set ref 829* 830* 830 830
                                                                                  832 833
hbound                                                 builtin function         dcl 162 ref 328 652 659 666
hcs_$get_max_length_seg         000142 constant        entry                    external dcl 178 ref 894
head                                   based           structure                level 2 dcl 1-19
header_printed                  000376 automatic       bit(1)                   packed unaligned dcl 737 set ref 752* 756 758* 766*
                                                                                  770 772*
i                               000156 automatic       fixed bin(17,0)          dcl 88 set ref 328* 329 329 332 340* 343* 472* 473*
                                                                                  481* 482* 493* 494* 524* 525* 533* 534* 545* 546*
                                                                                  568* 569* 587* 588* 594* 595* 866* 868 872*
ioa_                            000140 constant        entry                    external dcl 177 ref 254 267 280 294 303 310 372 465
                                                                                  468 471 486 501 517 520 538 553 564 570 573 575
                                                                                  614 616 620 627 629 631 632 634 636 639 644 648
                                                                                  656 663 669 678 680 682 699 701 703 708 715 717
                                                                                  719 721 724 726 728 747 749 757 760 771 774 858
                                                                                  872
is_volume                       000160 automatic       bit(1)                   dcl 89 set ref 354* 358 478 490 530 542
k                               000377 automatic       fixed bin(17,0)          dcl 738 in procedure "LIST_RESERVATION" set ref 753*
                                                                                  754* 767* 768*
k                               000157 automatic       fixed bin(17,0)          dcl 88 in procedure "lr" set ref 652* 653 653* 659*
                                                                                  660 660* 666* 668 669* 725* 726*
length                                                 builtin function         dcl 162 ref 830
level                    17            based           fixed bin(17,0)          level 2 in structure "attach" dcl 1-57 in procedure
                                                                                  "lr" set ref 724*
level                    15            based           fixed bin(17,0)          level 2 in structure "dassign" dcl 1-41 in procedure
                                                                                  "lr" set ref 639*
list_index                      000161 automatic       fixed bin(17,0)          dcl 90 set ref 189* 350* 350 362* 460 512
listed_flag                     000162 automatic       bit(1)                   packed unaligned dcl 91 set ref 244* 253* 266* 279*
                                                                                  293* 305* 310
long_flag                       000163 automatic       bit(1)                   packed unaligned dcl 92 set ref 196* 366* 468 520
                                                                                  571 624 712 747
long_options              4     000000 constant        char(19)                 initial array level 2 packed packed unaligned
                                                                                  dcl 122 ref 328 329
lv                                     based           structure                level 1 dcl 1-74
lv_ptr                          000256 automatic       pointer                  dcl 1-13 set ref 569* 570 574
lvs                                    based           structure                array level 2 dcl 1-19 set ref 569
max                                                    builtin function         dcl 162 ref 350
model                     3            based           fixed bin(17,0)          level 2 dcl 1-41 set ref 644* 668
n_resources               3            based           fixed bin(17,0)          initial level 2 in structure "resource_list" dcl 3-3
                                                                                  in procedure "LIST_ACQUISITIONS" ref 866
n_resources                     000130 automatic       fixed bin(35,0)          dcl 795 in procedure "LIST_ACQUISITIONS" set ref
                                                                                  841* 844* 847* 858 858 858* 858
new_sysdir                             parameter       char                     packed unaligned dcl 920 ref 918 922 923
no_freeing                1(04) 000132 automatic       bit(1)                   level 3 packed packed unaligned dcl 801 set ref 815*
null                                                   builtin function         dcl 162 ref 188 205 234 313 863
num_args                        000164 automatic       fixed bin(17,0)          dcl 93 set ref 198* 215 424
num_attach                3            based           fixed bin(17,0)          level 3 dcl 1-19 set ref 264 514 520* 520 524 533
                                                                                  545 569 588 595 754 768
num_dassign               2            based           fixed bin(17,0)          level 3 dcl 1-19 set ref 251 462 468 471* 472 481
                                                                                  493 525 534 546 569 588 595 754 768
num_device_resv           4            based           fixed bin(17,0)          level 3 dcl 1-19 ref 291 587 595 753 768
num_listed                      000165 automatic       fixed bin(17,0)          dcl 94 set ref 459* 486 511* 538 612* 612 697* 697
num_lv                    1            based           fixed bin(17,0)          level 3 dcl 1-19 ref 277 562 568 588 595 754 768
num_vol_resv              5            based           fixed bin(17,0)          level 3 dcl 1-19 ref 291 594 767
operation_states                000010 internal static char(12)                 initial array packed unaligned dcl 143 set ref 715*
option                          000166 automatic       char(32)                 packed unaligned dcl 95 set ref 327* 329 329 334*
                                                                                  347* 424 432
option_code                     000176 automatic       fixed bin(17,0)          dcl 96 set ref 417* 419
option_codes             11     000000 constant        fixed bin(17,0)          initial array level 2 dcl 122 ref 417
option_num                             parameter       fixed bin(17,0)          dcl 415 ref 407 417
owner                     2     000132 automatic       char(32)                 level 2 packed packed unaligned dcl 801 set ref 817*
pname                           000120 automatic       char(32)                 packed unaligned dcl 795 set ref 836* 837
priv                     20            based           bit(1)                   level 3 packed packed unaligned dcl 1-57 ref 719
priv_sw                         000131 automatic       bit(1)                   dcl 795 set ref 833* 837* 838* 844
qualifiers                5            based           fixed bin(35,0)          array level 2 dcl 1-41 set ref 648* 650 657 678* 680
                                                                                  682*
rcp_$copy_list                  000150 constant        entry                    external dcl 181 ref 442
rcp_$list_resources             000166 constant        entry                    external dcl 789 ref 847
rcp_admin_$list_awaiting_clear  000172 constant        entry                    external dcl 789 ref 841
rcp_admin_$list_resources       000170 constant        entry                    external dcl 789 ref 844
rcp_list_copied                 000177 automatic       bit(1)                   initial packed unaligned dcl 97 set ref 97* 439 446*
reason                                 parameter       char                     packed unaligned dcl 904 set ref 902 912*
registry_dir                    000032 internal static char(168)                initial packed unaligned dcl 156 set ref 841* 844*
                                                                                  847* 922* 923*
release_area_                   000162 constant        entry                    external dcl 789 ref 825 879
release_temp_segment_           000146 constant        entry                    external dcl 180 ref 234 313
request_control                 000200 automatic       bit(36)                  packed unaligned dcl 98 set ref 192* 220 220* 222
                                                                                  248 251 261 264 274 277 288 291 301 303 369* 369
                                                                                  374* 374 377* 377 381* 381 392* 392 396* 396
request_id_                     000154 constant        entry                    external dcl 736 ref 746
reservation_id                         based           fixed bin(71,0)          level 2 in structure "device_resv" dcl 1-79
                                                                                  in procedure "lr" set ref 589 589* 755 761*
reservation_id                         based           fixed bin(71,0)          level 2 in structure "vol_resv" dcl 1-85
                                                                                  in procedure "lr" set ref 596 596* 769 775*
resource_info_$get_rtypex       000152 constant        entry                    external dcl 182 ref 354
resource_list                          based           structure                level 1 dcl 3-3
resource_list_ptr               000156 automatic       pointer                  dcl 3-9 set ref 841* 844* 847* 863* 863 863* 866 868
                                                                                  872* 874
resource_name             4            based           char(32)                 array level 2 dcl 3-3 set ref 868 872*
resource_type                   000142 automatic       char(32)                 packed unaligned dcl 83 set ref 194* 354* 478 486*
                                                                                  490 530 538* 542 806 841* 844* 847* 850 858*
return_arg                             based           varying char             dcl 117 set ref 205* 226* 336* 854* 868* 868 869*
                                                                                  869 876* 876 914*
return_argl                     000204 automatic       fixed bin(21,0)          dcl 100 set ref 198* 205 226 336 854 868 869 876 914
return_argp                     000202 automatic       pointer                  dcl 99 set ref 198* 205 205 226 336 854 868 868 869
                                                                                  869 876 876 914
rid                             000400 automatic       fixed bin(71,0)          dcl 739 set ref 743* 746* 755 769
rid_string                      000402 automatic       char(32)                 packed unaligned dcl 740 set ref 746* 747* 749 749
rli                                    based           structure                level 1 dcl 1-19
rli_header                             based           structure                level 1 dcl 1-33
rli_ptr                         000250 automatic       pointer                  dcl 1-10 set ref 251 264 277 291 291 441 442* 462
                                                                                  468 471 472 473 481 482 493 494 514 520 520 524
                                                                                  525 533 534 545 546 562 568 569 587 588 594 595
                                                                                  753 754 767 768 898*
rli_version_4                          constant        fixed bin(17,0)          initial dcl 1-17 ref 441
rtrim                                                  builtin function         dcl 162 ref 478 490 530 542 830 850 868 876
seconds                         000205 automatic       fixed bin(17,0)          dcl 101 set ref 727* 728*
seg_size                        000206 automatic       fixed bin(19,0)          dcl 102 set ref 442* 894*
size                     13     000132 automatic       fixed bin(18,0)          level 2 dcl 801 set ref 818*
speed_comment                   000207 automatic       varying char(30)         dcl 103 set ref 658* 660* 660 663*
speed_names                     000221 constant        char(4)                  initial array packed unaligned dcl 153 ref 659 660
speed_ptr                       000220 automatic       pointer                  dcl 104 set ref 657* 660
state                    14            based           fixed bin(17,0)          level 2 in structure "dassign" dcl 1-41 in procedure
                                                                                  "lr" ref 618 627 641
state                    16            based           fixed bin(17,0)          level 2 in structure "attach" dcl 1-57 in procedure
                                                                                  "lr" ref 706 715
state_time               10            based           fixed bin(71,0)          level 2 in structure "lv" dcl 1-74 in procedure "lr"
                                                                                  set ref 574*
state_time               12            based           fixed bin(71,0)          level 2 in structure "dassign" dcl 1-41 in procedure
                                                                                  "lr" set ref 630*
state_time               14            based           fixed bin(71,0)          level 2 in structure "attach" dcl 1-57 in procedure
                                                                                  "lr" set ref 716*
static_option_data              000000 constant        structure                array level 1 unaligned dcl 122
substr                                                 builtin function         dcl 162 ref 432 632 653 660 749 749 830
sys_info$max_seg_size           000156 external static fixed bin(35,0)          dcl 787 ref 818
temp_seg_ptr                    000222 automatic       pointer                  dcl 105 set ref 188* 234 234* 313 313* 819 825* 841*
                                                                                  844* 847* 879* 890* 894* 898
time_string                     000224 automatic       char(24)                 packed unaligned dcl 106 set ref 574* 575* 630* 631*
                                                                                  716* 717* 856* 858*
timeout_max              24            based           fixed bin(52,0)          level 2 dcl 1-57 ref 727
typex                           000154 automatic       fixed bin(17,0)          dcl 86 set ref 191* 354* 358 359
uname                           000110 automatic       char(32)                 packed unaligned dcl 795 set ref 835* 837
unspec                                                 builtin function         dcl 162 set ref 813*
user_id                         000232 automatic       char(32)                 packed unaligned dcl 107 set ref 193* 389* 398 401*
                                                                                  832 832* 833 835 836 841* 844* 847* 850 858*
version                         000132 automatic       fixed bin(17,0)          level 2 dcl 801 set ref 814*
version_num                            based           fixed bin(17,0)          level 3 dcl 1-19 set ref 441*
vol_resv                               based           structure                level 1 dcl 1-85
vol_resv_ptr                    000262 automatic       pointer                  dcl 1-15 set ref 595* 596 596 768* 769 774 775
vol_resvs                              based           structure                array level 2 dcl 1-19 set ref 595 768
volume_name               2            based           char(32)                 level 2 in structure "attach" dcl 1-57 in procedure
                                                                                  "lr" set ref 703 703*
volume_name                            based           char(32)                 level 2 in structure "lv" dcl 1-74 in procedure "lr"
                                                                                  set ref 570*
volume_name              13            based           char(32)                 level 2 in structure "vol_resv" dcl 1-85
                                                                                  in procedure "lr" set ref 774*
vtypex                          000153 automatic       fixed bin(17,0)          dcl 85 set ref 191* 353* 358*
workspace_max            22            based           fixed bin(19,0)          level 2 dcl 1-57 ref 725
writing                  20(01)        based           bit(1)                   level 3 packed packed unaligned dcl 1-57 ref 721

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Max_entries                            automatic       fixed bin(17,0)          dcl 3-9
area_infop                             automatic       pointer                  dcl 2-5

NAMES DECLARED BY EXPLICIT CONTEXT.
COPY_RCP_LIST                   002615 constant        entry                    internal dcl 437 ref 249 262 275 289
DASSIGN                         000204 constant        label                    array(0:2) dcl 462 ref 460
DTYPE                           000212 constant        label                    array(7) dcl 648 ref 646
GET_TEMP_SEG                    006715 constant        entry                    internal dcl 885 ref 238
GET_VALUE                       002466 constant        entry                    internal dcl 407 ref 340
LIST_ACQUISITIONS               005706 constant        entry                    internal dcl 785 ref 306
LIST_DASSIGN                    002662 constant        entry                    internal dcl 452 ref 255
LIST_DASSIGNMENT                004117 constant        entry                    internal dcl 606 ref 474 483 497
LIST_LV                         003606 constant        entry                    internal dcl 557 ref 281
LIST_MOUNTS                     003224 constant        entry                    internal dcl 505 ref 268
LIST_RESERVATION                005365 constant        entry                    internal dcl 732 ref 589 596
LIST_RESERVATIONS               003763 constant        entry                    internal dcl 581 ref 295
LIST_SINGLE_MOUNT               005006 constant        entry                    internal dcl 692 ref 526 535 549
MOUNTS                          000207 constant        label                    array(0:2) dcl 514 ref 512
OPTION                          000171 constant        label                    array(11) dcl 350 ref 343
PROCESS_ARG                     002054 constant        entry                    internal dcl 317 ref 216
RETURN                          001760 constant        label                    dcl 313 ref 915
crump                           007026 constant        entry                    internal dcl 902 ref 324 347 355 385 398 424 429 432
                                                                                  443 478 490 530 542 674 806 810 822 850 891 895
list_resources                  001242 constant        entry                    external dcl 23
lr                              001232 constant        entry                    external dcl 23
test                            002017 constant        entry                    external dcl 918

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      7540        7734    7135        7550
Length     10304    7135       174         334     402          74

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
lr                                  706 external procedure  is an external procedure.  
on unit on line 233                  82 on unit               
PROCESS_ARG                             internal procedure  shares stack frame of external procedure lr.  
GET_VALUE                               internal procedure  shares stack frame of external procedure lr.  
COPY_RCP_LIST                           internal procedure  shares stack frame of external procedure lr.  
LIST_DASSIGN                            internal procedure  shares stack frame of external procedure lr.  
LIST_MOUNTS                             internal procedure  shares stack frame of external procedure lr.  
LIST_LV                                 internal procedure  shares stack frame of external procedure lr.  
LIST_RESERVATIONS                       internal procedure  shares stack frame of external procedure lr.  
LIST_DASSIGNMENT                        internal procedure  shares stack frame of external procedure lr.  
LIST_SINGLE_MOUNT                       internal procedure  shares stack frame of external procedure lr.  
LIST_RESERVATION                        internal procedure  shares stack frame of external procedure lr.  
LIST_ACQUISITIONS                   250 internal procedure  enables or reverts conditions.  
on unit on line 825                  68 on unit               
GET_TEMP_SEG                            internal procedure  shares stack frame of external procedure lr.  
crump                                94 internal procedure  is called during a stack extension.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 operation_states            lr
000027 console_model_names         lr
000032 registry_dir                lr

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
LIST_ACQUISITIONS        000100 group_id                    LIST_ACQUISITIONS
                         000110 uname                       LIST_ACQUISITIONS
                         000120 pname                       LIST_ACQUISITIONS
                         000130 n_resources                 LIST_ACQUISITIONS
                         000131 priv_sw                     LIST_ACQUISITIONS
                         000132 auto_area_info              LIST_ACQUISITIONS
                         000156 resource_list_ptr           LIST_ACQUISITIONS
crump                    000100 com_err_entry               crump
lr                       000100 alp                         lr
                         000102 arg_len                     lr
                         000104 arg_ptr                     lr
                         000106 argx                        lr
                         000107 awaiting_clear              lr
                         000110 called_as_af                lr
                         000112 cu_arg_ptr_entry            lr
                         000116 density_comment             lr
                         000130 density_ptr                 lr
                         000132 device_name                 lr
                         000142 resource_type               lr
                         000152 dtypex                      lr
                         000153 vtypex                      lr
                         000154 typex                       lr
                         000155 ecode                       lr
                         000156 i                           lr
                         000157 k                           lr
                         000160 is_volume                   lr
                         000161 list_index                  lr
                         000162 listed_flag                 lr
                         000163 long_flag                   lr
                         000164 num_args                    lr
                         000165 num_listed                  lr
                         000166 option                      lr
                         000176 option_code                 lr
                         000177 rcp_list_copied             lr
                         000200 request_control             lr
                         000202 return_argp                 lr
                         000204 return_argl                 lr
                         000205 seconds                     lr
                         000206 seg_size                    lr
                         000207 speed_comment               lr
                         000220 speed_ptr                   lr
                         000222 temp_seg_ptr                lr
                         000224 time_string                 lr
                         000232 user_id                     lr
                         000250 rli_ptr                     lr
                         000252 dassign_ptr                 lr
                         000254 attach_ptr                  lr
                         000256 lv_ptr                      lr
                         000260 device_resv_ptr             lr
                         000262 vol_resv_ptr                lr
                         000376 header_printed              LIST_RESERVATION
                         000377 k                           LIST_RESERVATION
                         000400 rid                         LIST_RESERVATION
                         000402 rid_string                  LIST_RESERVATION

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_char_temp     cat_realloc_chars   call_ent_var_desc   call_ent_var        call_ext_out_desc
call_ext_out        call_int_this_desc  call_int_this       call_int_other_desc return_mac          tra_ext_1
enable_op           shorten_stack       ext_entry           ext_entry_desc      int_entry           int_entry_desc
trunc_fx2           divide_fx1          divide_fx3          index_after_bs_1    clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
active_fnc_err_               com_err_                      cu_$af_arg_ptr_rel            cu_$af_return_arg
cu_$arg_list_ptr              cu_$arg_ptr_rel               date_time_                    define_area_
get_group_id_                 get_temp_segment_             hcs_$get_max_length_seg       ioa_
rcp_$copy_list                rcp_$list_resources           rcp_admin_$list_awaiting_clear
rcp_admin_$list_resources     release_area_                 release_temp_segment_         request_id_
resource_info_$get_rtypex

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badcall          error_table_$badopt           error_table_$inconsistent     error_table_$not_act_fnc
error_table_$odd_no_of_args   error_table_$resource_type_inappropriate                    error_table_$wrong_no_of_args
sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     77 001225        97 001226        23 001231       188 001250       189 001252       191 001254       192 001257
    193 001260       194 001263       196 001266       198 001267       199 001304       200 001310       201 001311
    202 001315       203 001316       204 001320       205 001351       206 001356       209 001357       210 001361
    213 001365       215 001373       216 001403       217 001404       218 001406       220 001410       222 001414
    224 001432       226 001464       233 001465       234 001501       236 001534       238 001535       239 001536
    244 001540       248 001541       249 001544       251 001545       253 001553       254 001555       255 001574
    261 001575       262 001600       264 001601       266 001607       267 001611       268 001624       274 001625
    275 001630       277 001631       279 001637       280 001641       281 001660       288 001661       289 001664
    291 001665       293 001674       294 001676       295 001712       301 001713       303 001716       305 001734
    306 001736       310 001742       313 001760       315 002013       918 002014       922 002033       923 002047
    924 002053       317 002054       323 002055       324 002073       327 002114       328 002121       329 002127
    332 002143       334 002147       336 002205       337 002206       340 002207       341 002211       343 002214
    345 002216       347 002220       348 002235       350 002236       353 002243       354 002245       355 002301
    358 002322       359 002330       360 002332       362 002333       364 002335       365 002342       366 002343
    368 002345       369 002346       371 002350       372 002351       374 002365       376 002367       377 002370
    379 002372       381 002373       383 002375       385 002376       389 002421       390 002426       392 002427
    394 002431       396 002432       398 002434       401 002460       402 002463       403 002465       407 002466
    417 002470       419 002474       424 002476       427 002524       428 002525       429 002543       432 002564
    435 002614       437 002615       439 002616       441 002621       442 002623       443 002636       446 002657
    448 002661       452 002662       459 002663       460 002664       462 002666       465 002671       466 002705
    468 002706       471 002732       472 002752       473 002763       474 002767       475 002770       476 002772
    478 002773       481 003041       482 003053       483 003057       485 003063       486 003065       488 003107
    490 003110       493 003156       494 003167       495 003173       497 003177       498 003200       500 003201
    501 003203       503 003223       505 003224       511 003225       512 003226       514 003230       517 003233
    518 003250       520 003251       524 003306       525 003317       526 003332       527 003333       528 003335
    530 003336       533 003404       534 003415       535 003430       537 003434       538 003436       540 003460
    542 003461       545 003527       546 003541       547 003554       549 003561       550 003562       552 003563
    553 003565       555 003605       557 003606       562 003607       564 003612       565 003631       568 003632
    569 003641       570 003662       571 003701       573 003703       574 003717       575 003735       577 003760
    579 003762       581 003763       587 003764       588 003775       589 004024       591 004034       594 004036
    595 004047       596 004104       598 004114       601 004116       606 004117       612 004120       614 004121
    616 004154       618 004170       620 004173       621 004207       624 004210       627 004213       629 004235
    630 004251       631 004267       632 004312       634 004333       636 004352       639 004374       641 004420
    644 004425       646 004450       648 004453       650 004476       651 004501       652 004502       653 004507
    655 004531       656 004533       657 004553       658 004556       659 004557       660 004565       662 004606
    663 004610       664 004633       666 004634       668 004641       669 004646       670 004671       672 004672
    674 004674       676 004714       678 004715       680 004740       682 004761       683 005004       685 005005
    692 005006       697 005007       699 005010       701 005043       703 005057       706 005107       708 005112
    709 005126       712 005127       715 005132       716 005157       717 005175       719 005220       721 005240
    724 005260       725 005304       726 005314       727 005334       728 005344       730 005364       732 005365
    743 005367       746 005371       747 005405       749 005430       752 005454       753 005455       754 005465
    755 005514       756 005517       757 005521       758 005537       760 005541       761 005561       763 005563
    766 005565       767 005566       768 005577       769 005634       770 005637       771 005641       772 005656
    774 005660       775 005700       777 005702       780 005704       785 005705       806 005713       810 005744
    813 005764       814 005767       815 005771       817 005775       818 006000       819 006003       821 006006
    822 006021       825 006044       829 006071       830 006100       832 006115       833 006125       835 006133
    836 006143       837 006161       838 006173       841 006175       844 006237       847 006300       850 006336
    854 006424       856 006432       858 006452       863 006535       866 006544       867 006556       868 006560
    869 006620       870 006627       872 006630       873 006654       874 006657       876 006663       879 006705
    881 006714       885 006715       890 006716       891 006745       894 006766       895 007001       898 007022
    900 007024       902 007025       909 007041       910 007051       912 007055       914 007112       915 007116


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
