	COMPILATION LISTING OF SEGMENT le_util_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 12/10/86  1255.4 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1986 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 /****^  HISTORY COMMENTS:
        8*  1) change(86-08-12,Elhard), approve(86-08-12,MCR7505),
        9*     audit(86-12-10,DGHowe), install(86-12-10,MR12.0-1241):
       10*     Originally written to provide utilities used by a number of le
       11*     subroutines.
       12*                                                   END HISTORY COMMENTS */
       13 
       14 /*  format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       15 
       16 le_util_:
       17   proc;
       18 
       19   /*** ****************************************************************/
       20   /***							*/
       21   /***	Name:	le_util_					*/
       22   /***	Function:	This is a set of utility routines used in a	*/
       23   /***		number of places within le_			*/
       24   /***							*/
       25   /*** ****************************************************************/
       26 
       27   /* constants */
       28 
       29   dcl true		bit (1) static options (constant) init ("1"b);
       30   dcl false		bit (1) static options (constant) init ("0"b);
       31   dcl Expanded_Absolute	bit (5) static options (constant)
       32 			init ("11110"b);
       33   dcl rel_chr		(0:10) char (1) static options (constant)
       34 			init ("t", "1", "2", "3", "l", "d", "s", "7",
       35 			"8", "i", "r");
       36 
       37   /* parameters */
       38 
       39   dcl a_user		char (*) parameter;
       40   dcl a_version		char (*) parameter;
       41   dcl a_relinfop		ptr parameter;
       42   dcl a_relindex		fixed bin parameter;
       43   dcl a_odd		bit (1) parameter;
       44   dcl a_skip		fixed bin parameter;
       45   dcl a_rel		char (*) parameter;
       46   dcl a_lebp		ptr parameter;
       47   dcl a_lecp		ptr parameter;
       48   dcl a_uid		aligned bit (36) parameter;
       49 
       50   /* procedures */
       51 
       52   dcl get_group_id_		entry () returns (char (32));
       53   dcl le_error_		entry options (variable);
       54 
       55   /* external */
       56 
       57   dcl le_data_$caller	external char (32) varying;
       58   dcl le_data_$version_suffix external char (64) varying;
       59   dcl le_et_$invalid_relinfo	external fixed bin (35);
       60 
       61   /* based */
       62 
       63   dcl 01 relinfo		aligned based (a_relinfop),
       64        02 decl_vers		fixed bin,
       65        02 n_bits		fixed bin,
       66        02 relbits		bit (0 refer (relinfo.n_bits)) aligned;
       67   dcl 01 leb		aligned based (a_lebp),
       68        02 header		aligned like le_binaries.header,
       69        02 binary		dim (0:0 refer (leb.n_binaries))
       70 			like le_binaries.binary;
       71   dcl 01 lec		aligned based (a_lecp),
       72        02 header		aligned like le_components.header,
       73        02 comp		dim (0 refer (lec.n_components)) like le_comp;
       74 
       75   /* automatic */
       76 
       77   dcl b			fixed bin automatic;
       78   dcl c			fixed bin automatic;
       79   dcl 01 exp_abs		aligned automatic,
       80        02 type		bit (5) unaligned,
       81        02 count		fixed bin (10) unsigned unaligned;
       82   dcl found		bit (1) automatic;
       83   dcl halfwords		fixed bin automatic;
       84   dcl 01 non_abs		aligned automatic,
       85        02 flag		bit (1) unaligned,
       86        02 type		fixed bin (4) unsigned unaligned;
       87 
       88   /* builtin */
       89 
       90   dcl divide		builtin;
       91   dcl mod			builtin;
       92   dcl null		builtin;
       93   dcl rtrim		builtin;
       94   dcl substr		builtin;
       95   dcl unspec		builtin;
       96 
       97   return;
       98 
       99 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      100 
      101 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      102 
      103 
      104 get_user_and_version:
      105   entry (a_user,			/** userid string	    (out)	*/
      106        a_version);			/** version string	    (out) */
      107 
      108   /*** ****************************************************************/
      109   /***							*/
      110   /***	Name:	le_util_$get_user_and_version			*/
      111   /***	Input:	none					*/
      112   /***	Function:	returns the userid and version strings to be	*/
      113   /***		included in the symbol section as part of the	*/
      114   /***		symbol header.				*/
      115   /***	Output:	user, version				*/
      116   /***							*/
      117   /*** ****************************************************************/
      118 
      119   a_user = get_group_id_ ();
      120   a_version = rtrim (le_data_$caller) || rtrim (le_data_$version_suffix);
      121 
      122   return;
      123 
      124 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      125 
      126 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      127 
      128 
      129 scan_relinfo:
      130   entry (a_relinfop,		/** reloc info pointer  (in )	*/
      131        a_relindex,			/** position in relinfo (i/o) */
      132        a_odd,			/** odd halfword flag   (i/o) */
      133        a_skip,			/** words to skip	    (out) */
      134        a_rel);			/** relinfo found	    (out) */
      135 
      136   /*** ****************************************************************/
      137   /***							*/
      138   /***	Name:	le_util_$scan_relinfo			*/
      139   /***	Input:	relinfop, relindex, odd			*/
      140   /***	Function:	scans a relinfo block starting at a particular	*/
      141   /***		point and returns the relocation information for	*/
      142   /***		the next word containing non-absolute relinfo, as	*/
      143   /***		well as the number of words to skip (ie. words	*/
      144   /***		with absolute relocation.)			*/
      145   /***	Output:	relindex, skip, rel				*/
      146   /***							*/
      147   /*** ****************************************************************/
      148 
      149   a_skip = 0;
      150   a_rel = "aa";
      151 
      152   /* handle adjustment for previous word containing part of an	*/
      153   /* absolute group.					*/
      154 
      155   if a_odd
      156     then halfwords = -1;
      157     else halfwords = 0;
      158   a_odd = false;
      159   found = false;
      160 
      161   /* scan for the next non-absolute halfword */
      162 
      163   do while ((a_relindex <= relinfo.n_bits) & ^found);
      164     if substr (relinfo.relbits, a_relindex, 1) = "0"b
      165       then do;
      166         halfwords = halfwords + 1;
      167         a_relindex = a_relindex + 1;
      168       end;
      169     else if substr (relinfo.relbits, a_relindex, 5) = Expanded_Absolute
      170       then do;
      171         unspec (exp_abs) = substr (relinfo.relbits, a_relindex, 15);
      172         a_relindex = a_relindex + 15;
      173         halfwords = halfwords + exp_abs.count;
      174       end;
      175     else found = true;
      176   end;
      177 
      178   /* calculate the number of words to skip */
      179 
      180   a_skip = divide (halfwords, 2, 18, 0);
      181 
      182   /* if we didn't run off the end, then we generate the relinfo for	*/
      183   /* non-absolute word.					*/
      184 
      185   if found
      186     then do;
      187       if mod (halfwords, 2) = 0
      188         then do;
      189 
      190 	/* non-absolute halfword was in the left halfword, so get	*/
      191 	/* the relinfo and insert it.				*/
      192 
      193 	unspec (non_abs) = substr (relinfo.relbits, a_relindex, 5);
      194 	if non_abs.type > 10
      195 	  then call le_error_ (LE_FATAL_ERROR, le_et_$invalid_relinfo,
      196 		  "^/Unknown relocation value (^d) found.", non_abs.type);
      197 	  else substr (a_rel, 1, 1) = rel_chr (non_abs.type);
      198 	a_relindex = a_relindex + 5;
      199         end;
      200 
      201       /* now process the right halfword */
      202 
      203       /* check for and absolute bit */
      204 
      205       if substr (relinfo.relbits, a_relindex, 1) = "0"b
      206         then a_relindex = a_relindex + 1;
      207 
      208       /* see if the right halfword is absolute but part of an	*/
      209       /* expanded absolute block, here we dont skip the block, just	*/
      210       /* set the odd flag to note next time that we have already	*/
      211       /* processed one bit of the expanded block.			*/
      212 
      213       else if substr (relinfo.relbits, a_relindex, 5) = Expanded_Absolute
      214         then a_odd = true;
      215       else do;
      216 
      217         /* the right halfword is not absolute */
      218 
      219         unspec (non_abs) = substr (relinfo.relbits, a_relindex, 5);
      220         if non_abs.type > 10
      221 	then call le_error_ (LE_FATAL_ERROR, le_et_$invalid_relinfo,
      222 		"^/Unknown relocation value (^d) found.", non_abs.type);
      223 	else substr (a_rel, 2, 1) = rel_chr (non_abs.type);
      224         a_relindex = a_relindex + 5;
      225       end;
      226     end;
      227 
      228   return;
      229 
      230 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      231 
      232 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      233 
      234 
      235 check_uid:
      236   entry (a_lecp,			/** components pointer  (in )	*/
      237        a_lebp,			/** binaries pointer    (in )	*/
      238        a_uid)			/** unique id	    (in ) */
      239        returns (bit (1));		/** duplicate flag	    (out) */
      240 
      241   /*** ****************************************************************/
      242   /***							*/
      243   /***	Name:	le_util_$check_uid				*/
      244   /***	Input:	lecp, lebp, uid				*/
      245   /***	Function:	compares a given uid (for a segment about to be	*/
      246   /***		overwritten) with the stored UIDs for the input	*/
      247   /***		components and already emitted output to insure	*/
      248   /***		that nothing is being destroyed.		*/
      249   /***	Output:	duplicate_flag				*/
      250   /***							*/
      251   /*** ****************************************************************/
      252 
      253   /* see if the file is the same as an input component */
      254 
      255   if a_lecp ^= null
      256     then
      257       do c = 1 to lec.n_components;
      258       if lec.comp (c).uid = a_uid
      259         then return (true);
      260     end;
      261 
      262   /* see if the file is the same as an output component */
      263 
      264   if a_lebp ^= null
      265     then
      266       do b = 1 to leb.n_binaries;
      267       if leb.binary (b).uid = a_uid
      268         then return (true);
      269     end;
      270 
      271   /* no match so return false */
      272 
      273   return (false);
      274 
      275 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      276 
      277 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      278 
      279 
  1     1 /****  START OF:	le_data.incl.pl1			 *  *  *  *  *  */
  1     2 
  1     3 /****^  HISTORY COMMENTS:
  1     4*  1) change(86-08-12,Elhard), approve(86-08-12,MCR7505),
  1     5*     audit(86-12-10,DGHowe), install(86-12-10,MR12.0-1241):
  1     6*     Originally written to define the structures used internally by le_.
  1     7*                                                   END HISTORY COMMENTS */
  1     8 
  1     9   /*** ****************************************************************/
  1    10   /***							*/
  1    11   /***	Name:	le_data					*/
  1    12   /***	Function:	This include file defines the data structures	*/
  1    13   /***		used internally by the linkage_editor subroutine.	*/
  1    14   /***							*/
  1    15   /*** ****************************************************************/
  1    16   
  1    17   /* error severity constants */
  1    18   
  1    19   dcl LE_WARNING		fixed bin static options (constant) init (1);
  1    20   dcl LE_ERROR		fixed bin static options (constant) init (2);
  1    21   dcl LE_FATAL_ERROR	fixed bin static options (constant) init (3);
  1    22   dcl LE_ABORT_ERROR	fixed bin static options (constant) init (4);
  1    23   
  1    24   /* section identifier constants */
  1    25   
  1    26   dcl Text		fixed bin (3) static options (constant)
  1    27 			init (0);
  1    28   dcl Linkage		fixed bin (3) static options (constant)
  1    29 			init (1);
  1    30   dcl Symbol		fixed bin (3) static options (constant)
  1    31 			init (2);
  1    32   dcl Definition		fixed bin (3) static options (constant)
  1    33 			init (3);
  1    34   dcl Static		fixed bin (3) static options (constant)
  1    35 			init (4);
  1    36   dcl System		fixed bin (3) static options (constant)
  1    37 			init (5);
  1    38   dcl Heap		fixed bin (3) static options (constant)
  1    39 			init (6);
  1    40   
  1    41   dcl section_nm		(0:6) char (16) static options (constant)
  1    42 			init ("text", "linkage", "symbol", "definition",
  1    43 			"static", "system", "heap");
  1    44   
  1    45   /* link type constants */
  1    46   
  1    47   dcl Self_Base		fixed bin (3) static options (constant)
  1    48 			init (1);
  1    49   dcl Refname_Base		fixed bin (3) static options (constant)
  1    50 			init (3);
  1    51   dcl Refname_Offsetname	fixed bin (3) static options (constant)
  1    52 			init (4);
  1    53   dcl Self_Offsetname	fixed bin (3) static options (constant)
  1    54 			init (5);
  1    55   
  1    56   /* backpatch type constants */
  1    57   
  1    58   dcl Patch_Link		fixed bin static options (constant) init (1);
  1    59   dcl Patch_Init		fixed bin static options (constant) init (2);
  1    60   dcl Patch_Symbol_Ref	fixed bin static options (constant) init (3);
  1    61   dcl Patch_Self_Init	fixed bin static options (constant) init (4);
  1    62   
  1    63   /*** ****************************************************************/
  1    64   /***							*/
  1    65   /***	Name:	le_components				*/
  1    66   /***	Function:	the component table is used to keep information	*/
  1    67   /***		about the input components being used and their	*/
  1    68   /***		disposition in output components.		*/
  1    69   /***							*/
  1    70   /*** ****************************************************************/
  1    71   
  1    72   dcl 01 le_components	aligned based,
  1    73        02 header		aligned,
  1    74         03 flags		aligned,
  1    75          04 separate_static	bit (1) unaligned,
  1    76          04 perprocess_static	bit (1) unaligned,
  1    77          04 mbz		bit (34) unaligned,
  1    78         03 n_components	fixed bin,
  1    79        02 comp		(0 refer (le_components.n_components))
  1    80 			like le_comp;
  1    81   
  1    82   /*** ****************************************************************/
  1    83   /***							*/
  1    84   /***	Name:	le_comp					*/
  1    85   /***	Function:	this is a single component table entry.		*/
  1    86   /***							*/
  1    87   /*** ****************************************************************/
  1    88   
  1    89   dcl 01 le_comp		aligned based,
  1    90        02 segp		ptr,
  1    91        02 bc		fixed bin (24),
  1    92        02 uid		bit (36) aligned,
  1    93        02 dtcm		fixed bin (71),
  1    94        02 name		char (32) varying,
  1    95        02 path		char (194) varying,
  1    96        02 compiler		char (8),
  1    97        02 target		fixed bin,
  1    98        02 flags		aligned,
  1    99         03 library		bit (1) unaligned,
  1   100         03 include		bit (1) unaligned,
  1   101         03 delete_table	bit (1) unaligned,
  1   102         03 separate_static	bit (1) unaligned,
  1   103         03 io_table		bit (1) unaligned,
  1   104         03 unique_path	bit (1) unaligned,
  1   105         03 mbz		bit (30) unaligned,
  1   106        02 tables		aligned,
  1   107         03 lesp		ptr,
  1   108         03 ledp		ptr,
  1   109         03 lelp		ptr,
  1   110        02 orig		aligned,
  1   111         03 textp		ptr,
  1   112         03 defnp		ptr,
  1   113         03 linkp		ptr,
  1   114         03 statp		ptr,
  1   115         03 symbp		ptr,
  1   116         03 rel_textp	ptr,
  1   117         03 rel_symbp	ptr,
  1   118         03 rel_linkp	ptr,
  1   119         03 textl		fixed bin (18) unsigned unaligned,
  1   120         03 defnl		fixed bin (18) unsigned unaligned,
  1   121         03 linkl		fixed bin (18) unsigned unaligned,
  1   122         03 statl		fixed bin (18) unsigned unaligned,
  1   123         03 symbl		fixed bin (18) unsigned unaligned,
  1   124         03 symbl_no_rel	fixed bin (18) unsigned unaligned,
  1   125         03 symbl_no_table	fixed bin (18) unsigned unaligned,
  1   126         03 n_symb_blocks	fixed bin (18) unsigned unaligned,
  1   127         03 text_boundary	fixed bin (9) unsigned unaligned,
  1   128         03 static_boundary	fixed bin (9) unsigned unaligned,
  1   129         03 next_comp	fixed bin (18) unsigned unaligned,
  1   130        02 new		aligned,
  1   131         03 rel_text		fixed bin (18) unsigned unaligned,
  1   132         03 rel_symb		fixed bin (18) unsigned unaligned,
  1   133         03 rel_stat		fixed bin (18) unsigned unaligned,
  1   134         03 text_pad		fixed bin (18) unsigned unaligned,
  1   135         03 static_pad	fixed bin (18) unsigned unaligned,
  1   136         03 symbol_pad	fixed bin (18) unsigned unaligned;
  1   137   
  1   138   /*** ****************************************************************/
  1   139   /***							*/
  1   140   /***	Name:	le_segnames				*/
  1   141   /***	Function:	the segname table is used for two purposes:	*/
  1   142   /***		 - to determine the target components of links	*/
  1   143   /***		   being resolved internally.			*/
  1   144   /***		 - to determine the segname definitions to be	*/
  1   145   /***		   emited for definitions being retained.	*/
  1   146   /***							*/
  1   147   /*** ****************************************************************/
  1   148   
  1   149   dcl 01 le_segnames	aligned based,
  1   150        02 header		aligned,
  1   151         03 n_segnames	fixed bin,
  1   152        02 segname		(segname_count refer (le_segnames.n_segnames)),
  1   153         03 str		char (32) varying,
  1   154         03 relp		fixed bin (18) unsigned unaligned,
  1   155         03 pad		bit (18) unaligned;
  1   156   dcl segname_count		fixed bin automatic;
  1   157   
  1   158   /*** ****************************************************************/
  1   159   /***							*/
  1   160   /***	Name:	le_definitions				*/
  1   161   /***	Function:	the definition table contains the definitions	*/
  1   162   /***		from the input components and is used to resolve	*/
  1   163   /***		link targets, and regenerate definition entries	*/
  1   164   /***							*/
  1   165   /*** ****************************************************************/
  1   166   
  1   167   dcl 01 le_definitions	aligned based,
  1   168        02 header		aligned,
  1   169         03 n_defs		fixed bin,
  1   170         03 pad		bit (36),
  1   171        02 def		(def_count refer (le_definitions.n_defs))
  1   172 			like le_definition;
  1   173   dcl def_count		fixed bin automatic;
  1   174   
  1   175   dcl 01 le_definition	aligned based,
  1   176        02 str		char (256) varying,
  1   177        02 type		fixed bin (18) unsigned unaligned,
  1   178        02 relp		fixed bin (18) unsigned unaligned,
  1   179        02 offset		fixed bin (18) unsigned unaligned,
  1   180        02 new_offset	fixed bin (18) unsigned unaligned,
  1   181        02 flags		aligned,
  1   182         03 force_retain	bit (1) unaligned,
  1   183         03 entrypoint	bit (1) unaligned,
  1   184         03 ignore		bit (1) unaligned,
  1   185         03 referenced	bit (1) unaligned,
  1   186         03 no_link		bit (1) unaligned,
  1   187         03 retain		bit (1) unaligned,
  1   188         03 delete		bit (1) unaligned,
  1   189         03 mbz		bit (29) unaligned;
  1   190   
  1   191   /*** ****************************************************************/
  1   192   /***							*/
  1   193   /***	Name:	le_options				*/
  1   194   /***	Function:	the option table contains definition retention	*/
  1   195   /***		information.  The input retentions options are	*/
  1   196   /***		ordered such that a linear search of the option	*/
  1   197   /***		table for the first matching starname will give	*/
  1   198   /***		the correct retention state.			*/
  1   199   /***							*/
  1   200   /*** ****************************************************************/
  1   201   
  1   202   dcl 01 le_options		aligned based,
  1   203        02 header		aligned,
  1   204         03 n_opts		fixed bin,
  1   205        02 opt		(0 refer (le_options.n_opts)),
  1   206         03 type		fixed bin (8) unaligned,
  1   207         03 used		bit (1) unaligned,
  1   208         03 inhibit_error	bit (1) unaligned,
  1   209         03 class		fixed bin (6) unaligned,
  1   210         03 order		fixed bin (17) unaligned,
  1   211         03 segname		char (32) unaligned,
  1   212         03 ep_name		char (256) unaligned;
  1   213   
  1   214   /*** ****************************************************************/
  1   215   /***							*/
  1   216   /***	Name:	le_links					*/
  1   217   /***	Function:	the link table contains information on all of the	*/
  1   218   /***		links in the input components. It is used to	*/
  1   219   /***		determine link targets, which library components	*/
  1   220   /***		will be included, and what init_info will be	*/
  1   221   /***		used, and where it will be placed.		*/
  1   222   /***							*/
  1   223   /*** ****************************************************************/
  1   224   
  1   225   dcl 01 le_links		aligned based,
  1   226        02 header		aligned,
  1   227         03 offset_adjustment	fixed bin (18),
  1   228         03 n_links		fixed bin,
  1   229        02 link		(link_count refer (le_links.n_links))
  1   230 			like le_link;
  1   231   dcl link_count		fixed bin automatic;
  1   232 
  1   233   dcl 01 le_link		aligned based,
  1   234        02 flags		unaligned,
  1   235         03 used		bit (1),
  1   236         03 mbx		bit (35),
  1   237        02 type		fixed bin (6) unsigned unaligned,
  1   238        02 class		fixed bin (6) unsigned unaligned,
  1   239        02 mod		bit (6) unaligned,
  1   240        02 exp		fixed bin (17) unaligned,
  1   241        02 target		fixed bin (18) unsigned unaligned,
  1   242        02 defx		fixed bin (18) unsigned unaligned,
  1   243        02 relp		fixed bin (18) unsigned unaligned,
  1   244        02 target_comp	fixed bin (18) unsigned unaligned,
  1   245        02 target_link	fixed bin (18) unsigned unaligned,
  1   246        02 extension		fixed bin (18) unsigned unaligned,
  1   247        02 initp		ptr unaligned,
  1   248        02 segnamep		ptr unaligned,
  1   249        02 offsetp		ptr unaligned;
  1   250   
  1   251   /*** ****************************************************************/
  1   252   /***							*/
  1   253   /***	Name:	le_binaries				*/
  1   254   /***	Function:	This table contains information about the output	*/
  1   255   /***		binaries.  It is primarily used for creation and	*/
  1   256   /***		backpatching of MSF output.			*/
  1   257   /***							*/
  1   258   /*** ****************************************************************/
  1   259   
  1   260   dcl 01 le_binaries	aligned based,
  1   261        02 header		aligned,
  1   262         03 n_binaries	fixed bin,
  1   263         03 pad		bit (36),
  1   264        02 binary		(0:0 refer (le_binaries.n_binaries)),
  1   265         03 segp		ptr,
  1   266         03 bc		fixed bin (24),
  1   267         03 uid		bit (36),
  1   268         03 aclc		fixed bin,
  1   269         03 aclp		ptr,
  1   270         03 textp		ptr,
  1   271         03 defnp		ptr,
  1   272         03 linkp		ptr,
  1   273         03 symbp		ptr,
  1   274         03 statp		ptr,
  1   275         03 textl		fixed bin (18) unsigned unaligned,
  1   276         03 defnl		fixed bin (18) unsigned unaligned,
  1   277         03 linkl		fixed bin (18) unsigned unaligned,
  1   278         03 symbl		fixed bin (18) unsigned unaligned,
  1   279         03 statl		fixed bin (18) unsigned unaligned,
  1   280         03 mbz2		bit (18) unaligned;
  1   281   
  1   282   /*** ****************************************************************/
  1   283   /***							*/
  1   284   /***	Name:	le_patches				*/
  1   285   /***	Function:	This table contains the list of backpatches to be	*/
  1   286   /***		performed when the rest of the object creation is	*/
  1   287   /***		complete. Since le_backpatch_ is the only routine	*/
  1   288   /***		concerned with this,  it is maintained completely	*/
  1   289   /***		internal to le_backpatch_.			*/
  1   290   /***							*/
  1   291   /*** ****************************************************************/
  1   292   
  1   293   dcl 01 le_patches		aligned based,
  1   294        02 header		aligned,
  1   295         03 n_patches	fixed bin,
  1   296        02 patch		(0 refer (le_patches.n_patches)) like le_patch;
  1   297        
  1   298   dcl 01 le_patch		aligned based,
  1   299        02 type		fixed bin,
  1   300        02 comp		fixed bin,
  1   301        02 relp		fixed bin (18) unsigned,
  1   302        02 target		fixed bin,
  1   303        02 index		fixed bin;
  1   304   
  1   305 /****  END OF:	le_data.incl.pl1			 *  *  *  *  *  */
      280 
      281 
      282   end le_util_;
      283 
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    12/10/86  1251.7  le_util_.pl1                      >special_ldd>install>MR12.0-1241>le_util_.pl1
280          1    12/10/86  1248.4  le_data.incl.pl1                  >special_ldd>install>MR12.0-1241>le_data.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Expanded_Absolute               000643 constant        bit(5)                   initial unaligned dcl 31 ref 169 213
LE_FATAL_ERROR                  000010 constant        fixed bin(17,0)          initial dcl 1-21 set ref 194* 220*
a_lebp                                 parameter       pointer                  dcl 46 ref 235 264 264 267
a_lecp                                 parameter       pointer                  dcl 47 ref 235 255 255 258
a_odd                                  parameter       bit(1)                   unaligned dcl 43 set ref 129 155 158* 213*
a_rel                                  parameter       char                     unaligned dcl 45 set ref 129 150* 197* 223*
a_relindex                             parameter       fixed bin(17,0)          dcl 42 set ref 129 163 164 167* 167 169 171 172* 172
                                                                                  193 198* 198 205 205* 205 213 219 224* 224
a_relinfop                             parameter       pointer                  dcl 41 ref 129 163 164 169 171 193 205 213 219
a_skip                                 parameter       fixed bin(17,0)          dcl 44 set ref 129 149* 180*
a_uid                                  parameter       bit(36)                  dcl 48 ref 235 258 267
a_user                                 parameter       char                     unaligned dcl 39 set ref 104 119*
a_version                              parameter       char                     unaligned dcl 40 set ref 104 120*
b                               000100 automatic       fixed bin(17,0)          dcl 77 set ref 264* 267*
binary                    2            based           structure                array level 2 in structure "leb" dcl 67 in procedure
                                                                                  "le_util_"
binary                    2            based           structure                array level 2 in structure "le_binaries" dcl 1-260
                                                                                  in procedure "le_util_"
c                               000101 automatic       fixed bin(17,0)          dcl 78 set ref 255* 258*
comp                      2            based           structure                array level 2 dcl 71
count                     0(05) 000102 automatic       fixed bin(10,0)          level 2 packed unsigned unaligned dcl 79 set ref 173
divide                                                 builtin function         dcl 90 ref 180
exp_abs                         000102 automatic       structure                level 1 dcl 79 set ref 171*
false                                  constant        bit(1)                   initial unaligned dcl 30 ref 158 159 273
found                           000103 automatic       bit(1)                   unaligned dcl 82 set ref 159* 163 175* 185
get_group_id_                   000010 constant        entry                    external dcl 52 ref 119
halfwords                       000104 automatic       fixed bin(17,0)          dcl 83 set ref 155* 157* 166* 166 173* 173 180 187
header                                 based           structure                level 2 in structure "leb" dcl 67 in procedure
                                                                                  "le_util_"
header                                 based           structure                level 2 in structure "le_binaries" dcl 1-260
                                                                                  in procedure "le_util_"
header                                 based           structure                level 2 in structure "lec" dcl 71 in procedure
                                                                                  "le_util_"
header                                 based           structure                level 2 in structure "le_components" dcl 1-72
                                                                                  in procedure "le_util_"
le_binaries                            based           structure                level 1 dcl 1-260
le_comp                                based           structure                level 1 dcl 1-89
le_components                          based           structure                level 1 dcl 1-72
le_data_$caller                 000014 external static varying char(32)         dcl 57 ref 120
le_data_$version_suffix         000016 external static varying char(64)         dcl 58 ref 120
le_definition                          based           structure                level 1 dcl 1-175
le_error_                       000012 constant        entry                    external dcl 53 ref 194 220
le_et_$invalid_relinfo          000020 external static fixed bin(35,0)          dcl 59 set ref 194* 220*
le_link                                based           structure                level 1 dcl 1-233
le_patch                               based           structure                level 1 dcl 1-298
leb                                    based           structure                level 1 dcl 67
lec                                    based           structure                level 1 dcl 71
mod                                                    builtin function         dcl 91 ref 187
n_binaries                             based           fixed bin(17,0)          level 3 dcl 67 ref 264
n_bits                    1            based           fixed bin(17,0)          level 2 dcl 63 ref 163 164 169 171 193 205 213 219
n_components              1            based           fixed bin(17,0)          level 3 dcl 71 ref 255
non_abs                         000105 automatic       structure                level 1 dcl 84 set ref 193* 219*
null                                                   builtin function         dcl 92 ref 255 264
rel_chr                         000000 constant        char(1)                  initial array unaligned dcl 33 ref 197 223
relbits                   2            based           bit                      level 2 dcl 63 ref 164 169 171 193 205 213 219
relinfo                                based           structure                level 1 dcl 63
rtrim                                                  builtin function         dcl 93 ref 120 120
substr                                                 builtin function         dcl 94 set ref 164 169 171 193 197* 205 213 219 223*
true                                   constant        bit(1)                   initial unaligned dcl 29 ref 175 213 258 267
type                      0(01) 000105 automatic       fixed bin(4,0)           level 2 packed unsigned unaligned dcl 84 set ref 194
                                                                                  194* 197 220 220* 223
uid                       5            based           bit(36)                  array level 3 in structure "lec" dcl 71 in procedure
                                                                                  "le_util_" ref 258
uid                       5            based           bit(36)                  array level 3 in structure "leb" dcl 67 in procedure
                                                                                  "le_util_" ref 267
unspec                                                 builtin function         dcl 95 set ref 171* 193* 219*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Definition                             internal static fixed bin(3,0)           initial dcl 1-32
Heap                                   internal static fixed bin(3,0)           initial dcl 1-38
LE_ABORT_ERROR                         internal static fixed bin(17,0)          initial dcl 1-22
LE_ERROR                               internal static fixed bin(17,0)          initial dcl 1-20
LE_WARNING                             internal static fixed bin(17,0)          initial dcl 1-19
Linkage                                internal static fixed bin(3,0)           initial dcl 1-28
Patch_Init                             internal static fixed bin(17,0)          initial dcl 1-59
Patch_Link                             internal static fixed bin(17,0)          initial dcl 1-58
Patch_Self_Init                        internal static fixed bin(17,0)          initial dcl 1-61
Patch_Symbol_Ref                       internal static fixed bin(17,0)          initial dcl 1-60
Refname_Base                           internal static fixed bin(3,0)           initial dcl 1-49
Refname_Offsetname                     internal static fixed bin(3,0)           initial dcl 1-51
Self_Base                              internal static fixed bin(3,0)           initial dcl 1-47
Self_Offsetname                        internal static fixed bin(3,0)           initial dcl 1-53
Static                                 internal static fixed bin(3,0)           initial dcl 1-34
Symbol                                 internal static fixed bin(3,0)           initial dcl 1-30
System                                 internal static fixed bin(3,0)           initial dcl 1-36
Text                                   internal static fixed bin(3,0)           initial dcl 1-26
def_count                              automatic       fixed bin(17,0)          dcl 1-173
le_definitions                         based           structure                level 1 dcl 1-167
le_links                               based           structure                level 1 dcl 1-225
le_options                             based           structure                level 1 dcl 1-202
le_patches                             based           structure                level 1 dcl 1-293
le_segnames                            based           structure                level 1 dcl 1-149
link_count                             automatic       fixed bin(17,0)          dcl 1-231
section_nm                             internal static char(16)                 initial array unaligned dcl 1-41
segname_count                          automatic       fixed bin(17,0)          dcl 1-156

NAMES DECLARED BY EXPLICIT CONTEXT.
check_uid                       000514 constant        entry                    external dcl 235
get_user_and_version            000062 constant        entry                    external dcl 104
le_util_                        000041 constant        entry                    external dcl 16
scan_relinfo                    000210 constant        entry                    external dcl 129

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       766        1010     646         776
Length      1214     646        22         170     117           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
le_util_                            120 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
le_util_                 000100 b                           le_util_
                         000101 c                           le_util_
                         000102 exp_abs                     le_util_
                         000103 found                       le_util_
                         000104 halfwords                   le_util_
                         000105 non_abs                     le_util_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        return_mac          mdfx1               signal_op
shorten_stack       ext_entry           ext_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_group_id_                 le_error_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
le_data_$caller               le_data_$version_suffix       le_et_$invalid_relinfo




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     16 000040        97 000050       104 000056       119 000104       120 000121       122 000173       129 000203
    149 000225       150 000227       155 000234       157 000244       158 000245       159 000250       163 000251
    164 000262       166 000266       167 000267       168 000270       169 000271       171 000275       172 000301
    173 000303       174 000307       175 000310       176 000312       180 000313       185 000316       187 000320
    193 000324       194 000331       197 000372       198 000377       205 000402       213 000413       219 000426
    220 000427       223 000470       224 000475       228 000500       235 000507       255 000522       258 000541
    260 000563       264 000565       267 000603       269 000625       273 000627


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
