	COMPILATION LISTING OF SEGMENT fm_status
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/04/85  0945.2 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 /* format: style4,ifthenstmt,^indproc,^indcomtxt */
        7 /*---------------*/
        8 
        9 fm_status: proc (A_dirname, A_entryname, A_file_status_ptr, A_code);
       10 
       11 /* DESCRIPTION:
       12*
       13*   This  subroutine  returns status information about a DM file that is
       14*   not returned by hcs_$status.  Information is returned  in  the  structure
       15*   declared in dm_file_status.incl.pl1.
       16**/
       17 
       18 /* HISTORY:
       19*
       20*Written by Steve Herbst, 08/13/84.
       21*Modified:
       22*11/07/84 by Steve Herbst: Changed in response to audit comments:
       23*	Removed cleanup windows, added ERROR_RETURN procedure, changed to
       24*	call fm_get_last_ci_num and use fm_attributes.ci_size_in_bits.
       25*11/27/84 by Steve Herbst: Changed further in response to audit comments:
       26*	Changed to report CLEAN_UP errors on normal termination, and call
       27*	sub_err_ with ACTION_CANT_RESTART.
       28*12/17/84 by Steve Herbst: Changed again in response to audit comments:
       29*	Fixed SUB_ERROR_CODE to return cond_info.status_code instead of
       30*	sub_error_info.retval, compute effective mode using validation
       31*	level instead of current ring, prevent CLEAN_UP from ever being
       32*	called twice.
       33*02/26/85 by Steve Herbst: Changed again in response to audit comments:
       34*	Changed CLEAN_UP proc, not its caller, to turn on cleanup_called_sw.
       35**/
       36 
       37 /* DECLARATIONS */
       38 
       39 /* Parameters */
       40 
       41 dcl  A_dirname char (*) parameter;
       42 dcl  A_entryname char (*) parameter;
       43 dcl  A_file_status_ptr ptr parameter;
       44 dcl  A_code fixed bin (35) parameter;
       45 
       46 
       47 /* Constants */
       48 
       49 dcl ME char (32) int static options (constant) init ("fm_status");
       50 dcl DONT_RETURN_CODE fixed bin int static options (constant) init (-1);
       51 
       52 /* Based */
       53 
       54 /* Static */
       55 
       56 /* Automatic */
       57 
       58 dcl 1 auto_ci_parts aligned,
       59    2 number_of_parts fixed bin init (1),
       60    2 pad fixed bin init (0),
       61    2 part (1) like ci_parts.part;
       62 
       63 dcl 1 cond_info aligned like condition_info;
       64 
       65 dcl 1 file_attributes_space aligned like file_attributes;
       66 
       67 dcl dirname char (168);
       68 dcl entryname char (32);
       69 dcl opening_id bit (36);
       70 dcl txn_id bit (36) aligned;
       71 dcl cleanup_called_sw bit (1) aligned;
       72 dcl callers_level fixed bin;
       73 dcl (begin_code, code) fixed bin (35);
       74 
       75 /* External */
       76 
       77 dcl dm_error_$bad_file_atrs_ver fixed bin (35) ext;
       78 dcl dm_error_$transaction_in_progress fixed bin (35) ext;
       79 dcl error_table_$null_info_ptr fixed bin (35) ext;
       80 dcl error_table_$unimplemented_version fixed bin (35) ext;
       81 
       82 /* Entries */
       83 
       84 dcl continue_to_signal_ entry (fixed bin (35));
       85 dcl cu_$level_get entry (fixed bin);
       86 dcl file_manager_$close entry (bit (36), fixed bin (35));
       87 dcl file_manager_$get_user_access_modes entry (char (*), char (*), char (32), fixed bin,
       88 	bit (36) aligned, bit (36) aligned, fixed bin (35));
       89 dcl file_manager_$open entry (char (*), char (*), bit (36), fixed bin (35));
       90 dcl find_condition_info_ entry (ptr, ptr, fixed bin (35));
       91 dcl fm_get_$internal_get entry (bit (36), fixed bin, ptr, fixed bin (35));
       92 dcl fm_get_last_ci_num entry (char (*), fixed bin, fixed bin (27));
       93 dcl get_group_id_ entry() returns(char(32));
       94 dcl pathname_ entry (char(*), char(*)) returns(char(168));
       95 dcl sub_err_ entry() options(variable);
       96 dcl transaction_manager_$begin_txn entry (fixed bin, bit (36) aligned, bit (36) aligned, fixed bin (35));
       97 dcl transaction_manager_$commit_txn entry (bit (36) aligned, fixed bin (35));
       98 
       99 /* Builtins */
      100 
      101 dcl (addr, null, unspec) builtin;
      102 
      103 /* Conditions */
      104 
      105 dcl (cleanup, sub_error_) condition;
      106 
      107 /* END OF DECLARATIONS */
      108 
      109 	dirname = A_dirname;
      110 	entryname = A_entryname;
      111 	dm_file_status_ptr = A_file_status_ptr;
      112 	A_code, begin_code = 0;
      113 	cleanup_called_sw = "0"b;
      114 
      115 	if dm_file_status_ptr = null then call ERROR_RETURN (error_table_$null_info_ptr);
      116 
      117 	if dm_file_status.version ^= DM_FILE_STATUS_VERSION_1 then
      118 	     call ERROR_RETURN (error_table_$unimplemented_version);
      119 
      120 /* Open the DM file */
      121 
      122 	opening_id = "0"b;
      123 	on cleanup call CLEAN_UP (code);
      124 
      125 	on sub_error_ begin;
      126 	     code = SUB_ERROR_CODE ();
      127 	     if code ^= DONT_RETURN_CODE then call ERROR_RETURN (code);
      128 					/* DONT_RETURN_CODE => want to continue signalling sub_error_ */
      129 	end;
      130 
      131 	call file_manager_$open (dirname, entryname, opening_id, code);
      132 	if opening_id = "0"b then call ERROR_RETURN (code);
      133 
      134 	revert sub_error_;
      135 
      136 /* Need a transaction to read the attributes in the file */
      137 
      138 	call transaction_manager_$begin_txn (TM_NORMAL_MODE, "0"b, txn_id, begin_code);
      139 	if txn_id = "0"b then call ERROR_RETURN (begin_code);
      140 
      141 /* Get file attributes */
      142 
      143 	unspec (file_attributes_space) = "0"b;
      144 	file_attributes_ptr = addr (file_attributes_space);
      145 
      146 	auto_ci_parts.part (1).local_ptr = file_attributes_ptr;
      147 	auto_ci_parts.part (1).offset_in_bytes = CI_0_ADDRESSABLE_LENGTH;
      148 	auto_ci_parts.part (1).length_in_bytes = CI_ADDRESSABLE_LENGTH - CI_0_ADDRESSABLE_LENGTH;
      149 
      150 	call fm_get_$internal_get (opening_id, 0, addr (auto_ci_parts), code);
      151 	if code ^= 0 then call ERROR_RETURN (code);
      152 
      153 	if file_attributes.version ^= FILE_ATTRIBUTES_VERSION_2 then
      154 						/* calls sub_err_ rather than just return a code since the
      155*						   bad version is in file_attributes, not dm_file_status */
      156 	     call sub_err_ (dm_error_$bad_file_atrs_ver, ME, ACTION_CANT_RESTART, null, 0,
      157 		"File attributes version was ^a, should have been ^a",
      158 		file_attributes.version, FILE_ATTRIBUTES_VERSION_2);
      159 
      160 	dm_file_status.fm_unique_id = file_attributes.unique_id;
      161 	dm_file_status.date_time_created = file_attributes.date_time_created;
      162 	dm_file_status.ring_brackets (1) = file_attributes.ring_brackets.write;
      163 	dm_file_status.ring_brackets (2) = file_attributes.ring_brackets.read;
      164 	unspec (dm_file_status.switches) = "0"b;
      165 	dm_file_status.protected_sw = file_attributes.protected;
      166 	dm_file_status.no_concurrency_sw = file_attributes.no_concurrency;
      167 	dm_file_status.no_rollback_sw = file_attributes.no_rollback;
      168 
      169 /* Get other info */
      170 
      171 	call cu_$level_get (callers_level);
      172 	call file_manager_$get_user_access_modes (dirname, entryname, get_group_id_ (), callers_level,
      173 	     dm_file_status.mode, "0"b, code);
      174 	if code ^= 0 then dm_file_status.mode = "0"b;
      175 
      176 	dm_file_status.ci_size = file_attributes.ci_size_in_bytes;
      177 
      178 	call fm_get_last_ci_num
      179 	     (pathname_ (dirname, entryname), (file_attributes.blocking_factor), dm_file_status.highest_ci);
      180 	
      181 RETURN:
      182 	if ^cleanup_called_sw then do;
      183 	     call CLEAN_UP (code);
      184 	     if code ^= 0 & A_code = 0 then call ERROR_RETURN (code);
      185 	end;
      186 	
      187 	return;
      188 
      189 CLEAN_UP: proc (P_cleanup_code);
      190 
      191 /* This procedure completes even if one of its calls returns an error.
      192*   The intent is to restore the environment and the file to their original
      193*   states as much as possible. It sets a parameter code instead of reporting
      194*   its own errors, to leave the choice up to the caller: an error is reported
      195*   at normal termination time, but not when "cleanup" is signalled. */
      196 
      197 dcl (P_cleanup_code, code) fixed bin (35);
      198 
      199 	code = 0;
      200 	cleanup_called_sw = "1"b;
      201 
      202 	if opening_id ^= "0"b then call file_manager_$close (opening_id, P_cleanup_code);
      203 	if txn_id ^= "0"b then
      204 	     if begin_code = dm_error_$transaction_in_progress then;
      205 						/* Can't commit or abort the user's previous transaction */
      206 	     else do;
      207 		call transaction_manager_$commit_txn (txn_id, code);  /* could have aborted instead; doesn't
      208*							    /* matter since no data has been changed */
      209 		if code ^= 0 & P_cleanup_code = 0 then P_cleanup_code = code;
      210 	     end;
      211 
      212 end CLEAN_UP;
      213 
      214 ERROR_RETURN: proc (P_code);
      215 
      216 dcl P_code fixed bin (35);
      217 
      218 	A_code = P_code;
      219 	go to RETURN;
      220 
      221 end ERROR_RETURN;
      222 
      223 SUB_ERROR_CODE: proc () returns (fixed bin (35));
      224 
      225 /* Returns the error code that sub_error_ was signalled with */
      226 
      227 dcl code fixed bin (35);
      228 
      229 	call find_condition_info_ (null, addr (cond_info), code);
      230 	if code ^= 0 then return (code);
      231 
      232 	if cond_info.info_ptr -> sub_error_info.default_restart then do;
      233 						/* should only happen when testing tm_per_process_init_ */
      234 	     call continue_to_signal_ (0);
      235 	     return (DONT_RETURN_CODE);
      236 	end;
      237 
      238 	else return (cond_info.info_ptr -> sub_error_info.status_code);
      239 
      240 end SUB_ERROR_CODE;
      241 
  1     1 /*  BEGIN INCLUDE FILE:  dm_ci_parts.incl.pl1  */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*
  1     5*        This include file contains the ci_parts structure.  This structure
  1     6*   is used across the file_manager_ interface to specify the parts of a
  1     7*   control interval to get or put.  If the number_of parts is equal to 0,
  1     8*   modules which take ci_parts interpret this case to mean to do everything
  1     9*   except the actual requested operation, i.e., lock the control interval
  1    10*   but don't get anything.  offset_in_bytes is the 0-originned offset in
  1    11*   bytes from the beginning of the addressable portion of the control interval.
  1    12*   An offset_in_bytes which is in the addressable portion is in error.
  1    13*   Likewise, if offset_in_bytes + length_in_bytes is outside of the addressable
  1    14*   portion, it is in error.
  1    15**/
  1    16 
  1    17 /* HISTORY:
  1    18*Written by Matthew Pierret, 01/28/82.
  1    19*  (01/28/82 Andre Bensoussan, Design.)
  1    20*Modified:
  1    21*11/07/84 by Matthew Pierret:  To add must_be_zero, initial attributes on
  1    22*            automatic storge.
  1    23**/
  1    24 
  1    25 /* format: style2,ind3 */
  1    26 
  1    27      dcl	   1 ci_parts	      aligned based (ci_parts_ptr),
  1    28 	     2 number_of_parts    fixed bin (17),
  1    29 	     2 must_be_zero	      fixed bin,
  1    30 	     2 part	      (cip_number_of_parts refer (ci_parts.number_of_parts)),
  1    31 	       3 offset_in_bytes  fixed bin (17),
  1    32 	       3 length_in_bytes  fixed bin (17),
  1    33 	       3 local_ptr	      ptr;
  1    34 
  1    35      dcl	   ci_parts_ptr	      ptr init (null ());
  1    36      dcl	   cip_number_of_parts    fixed bin (17) init (0);
  1    37 
  1    38 
  1    39 /*  BEGIN INCLUDE FILE:   dm_ci_parts.incl.pl1   */
      242 
      243 
  2     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  2     2 
  2     3 /* Structure for find_condition_info_.
  2     4*
  2     5*   Written 1-Mar-79 by M. N. Davidoff.
  2     6**/
  2     7 
  2     8 /* automatic */
  2     9 
  2    10      declare condition_info_ptr     pointer;
  2    11 
  2    12 /* based */
  2    13 
  2    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  2    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  2    16 	     2 version	      fixed binary,		/* Must be 1 */
  2    17 	     2 condition_name     char (32) varying,	/* name of condition */
  2    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  2    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  2    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  2    21 	     2 flags	      unaligned,
  2    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  2    23 	       3 pad1	      bit (35),
  2    24 	     2 pad2	      bit (36),
  2    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  2    26 	     2 pad3	      (4) bit (36);
  2    27 
  2    28 /* internal static */
  2    29 
  2    30      declare condition_info_version_1
  2    31 			      fixed binary internal static options (constant) initial (1);
  2    32 
  2    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
      244 
      245 
  3     1 /* BEGIN INCLUDE FILE condition_info_header.incl.pl1 BIM 1981 */
  3     2 /* format: style2 */
  3     3 
  3     4      declare condition_info_header_ptr
  3     5 			      pointer;
  3     6      declare 1 condition_info_header
  3     7 			      aligned based (condition_info_header_ptr),
  3     8 	     2 length	      fixed bin,		/* length in words of this structure */
  3     9 	     2 version	      fixed bin,		/* version number of this structure */
  3    10 	     2 action_flags	      aligned,		/* tell handler how to proceed */
  3    11 	       3 cant_restart     bit (1) unaligned,	/* caller doesn't ever want to be returned to */
  3    12 	       3 default_restart  bit (1) unaligned,	/* caller can be returned to with no further action */
  3    13 	       3 quiet_restart    bit (1) unaligned,	/* return, and print no message */
  3    14 	       3 support_signal   bit (1) unaligned,	/* treat this signal as if the signalling procedure had the support bit set */
  3    15 						/* if the signalling procedure had the support bit set, do the same for its caller */
  3    16 	       3 pad	      bit (32) unaligned,
  3    17 	     2 info_string	      char (256) varying,	/* may contain printable message */
  3    18 	     2 status_code	      fixed bin (35);	/* if^=0, code interpretable by com_err_ */
  3    19 
  3    20 /* END INCLUDE FILE condition_info_header.incl.pl1 */
      246 
      247 
  4     1 /* BEGIN INCLUDE FILE dm_ci_lengths.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*       This include file contains constants which are the length in bytes
  4     5*   of the addressable portion of a control interval.  The addressable portion
  4     6*   is that part of the control interval which callers of file_manager_
  4     7*   may access, specifically, everything between the end of the control
  4     8*   interval header (ci_header) and the control interval trailer (ci_trailer).
  4     9*   Control interval 0 is slightly different, as it also contains an 
  4    10*   unaddressable portion in which it maintains the file attributes.  For
  4    11*   control interval 0 the addressable portion is everything between the end
  4    12*   of the control interval header and the beginning of the file attributes.
  4    13**/
  4    14 
  4    15 /* HISTORY:
  4    16*Written by Matthew Pierret, 11/02/84.
  4    17*Modified:
  4    18**/
  4    19 
  4    20 /* format: style2,ind3 */
  4    21 
  4    22      dcl	   CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES
  4    23 			      fixed bin (17) init (4072) int static options (constant);
  4    24 
  4    25      dcl	   CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES
  4    26 			      fixed bin (17) init (3176) int static options (constant);
  4    27 
  4    28 
  4    29      dcl	   CI_ADDRESSABLE_LENGTH  fixed bin (17) init (4072) int static options (constant);
  4    30 
  4    31      dcl	   CI_0_ADDRESSABLE_LENGTH
  4    32 			      fixed bin (17) init (3176) int static options (constant);
  4    33 
  4    34 /* END INCLUDE FILE dm_ci_lengths.incl.pl1 */
      248 
      249 
  5     1 /* BEGIN INCLUDE FILE:  dm_file_status.incl.pl1 */
  5     2 
  5     3 /* format: style4,ifthenstmt,^indproc,^indcomtxt */
  5     4 
  5     5 /* DESCRIPTION:
  5     6*
  5     7*   This include file contains dm_file_status, the structure of information
  5     8*   returned by file_manager_$status. The caller should pass the addr of an
  5     9*   automatic copy as follows:
  5    10*
  5    11*	dcl auto_dm_file_status aligned like dm_file_status;
  5    12*	unspec (auto_dm_file_status) = "0"b;
  5    13*	auto_dm_file_status.version = DM_FILE_STATUS_VERSION_1;
  5    14*	call file_manager_$status (dirname, entryname,
  5    15*	     addr (auto_dm_file_status, code);
  5    16**/
  5    17 /* HISTORY:
  5    18*
  5    19*Written by Steve Herbst, 07/06/84.
  5    20*Modified:
  5    21*11/07/84 by Steve Herbst: Changed in response to audit comments:
  5    22*	Reformatted history section, made version aligned.
  5    23*12/12/84 by Steve Herbst: Changed further in response to audit comments:
  5    24*	Changed highest_ci from fixed(18) to fixed(27).
  5    25*12/17/84 by Steve Herbst: Changed again in response to audit comments:
  5    26*	Improved journalization comments.
  5    27**/
  5    28 
  5    29 
  5    30 dcl 1 dm_file_status aligned based (dm_file_status_ptr),
  5    31      2 version char (8),
  5    32      2 fm_unique_id bit (36) aligned,			/* file manager unique id */
  5    33      2 mode bit (36) aligned,				/* extended user's effective access to file */
  5    34      2 date_time_created fixed bin (71),
  5    35      2 ring_brackets (2) fixed bin (3),			/* extended ring brackets */
  5    36      2 switches,
  5    37       3 (protected_sw,
  5    38          no_concurrency_sw,
  5    39          no_rollback_sw) bit (1) unaligned,
  5    40       3 mbz bit (33) unaligned,
  5    41      2 highest_ci fixed bin (27),			/* number of highest control interval */
  5    42      2 ci_size fixed bin (18);			/* size in bytes (4/wd) of a control interval */
  5    43 
  5    44 dcl dm_file_status_ptr ptr;
  5    45 
  5    46 dcl DM_FILE_STATUS_VERSION_1 char (8) int static options (constant) init ("DMFLST01");
  5    47 
  5    48 /* END INCLUDE FILE:  dm_file_status.incl.pl1 */
      250 
      251 
  6     1 /* BEGIN INCULE FILE dm_fm_file_attributes.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*     
  6     5*     This include file contains the declaration of the file_attributes
  6     6*     structure.  An instance of this structure is stored in control interval 
  6     7*     zero of each DM file.  It describes the attributes of the file.
  6     8*
  6     9*     The structure is 896 bytes, or 224 words, long.
  6    10**/
  6    11 
  6    12 /* HISTORY:
  6    13*Written by Matthew Pierret, 06/15/84.
  6    14*   (Structure designed by Jeff Ives.) 
  6    15*Modified:
  6    16*11/06/84 by Matthew Pierret:  Changed mbz_rb1 from bit (28) to bit (30).
  6    17*            Removed the un-used version overlay and related constants.
  6    18**/
  6    19 
  6    20 /* format: style2,ind3 */
  6    21 
  6    22      dcl	   1 file_attributes      aligned based (file_attributes_ptr),
  6    23 	     2 version	      char (8) aligned,
  6    24 	     2 unique_id	      bit (36),
  6    25 	     2 ci_size_in_bytes   fixed bin (35),	/* control interval physical size, must be 4096	*/
  6    26 	     2 blocking_factor    fixed bin,		/* # of cis in each msf seg, must be 64 or 255	*/
  6    27 	     2 flags	      aligned,
  6    28 	       3 protected	      bit unal,		/* protected against inconsistency		*/
  6    29 	       3 no_concurrency   bit unal,		/* don't protect against concurrent access	*/
  6    30 	       3 no_rollback      bit unal,		/* don't protect against system failure		*/
  6    31 	       3 mbz_f1	      bit (33) unal,
  6    32 	     2 date_time_created  fixed bin (71),
  6    33 	     2 ring_brackets      aligned,
  6    34 	       3 write	      fixed bin (3) uns unal,
  6    35 	       3 read	      fixed bin (3) uns unal,
  6    36 	       3 mbz_rb1	      bit (30) bit unal,
  6    37 	     2 mbz_1	      fixed bin (35),	/* 10 words so far */
  6    38 	     2 mbz_2	      (9) fixed bin (71),	/* 28 words so far */
  6    39 	     2 time_last_dumped   fixed bin (71),	/* Not yet used */
  6    40 	     2 dump_file_path     char (168),		/* Not yet used */
  6    41 	     2 mbz_3	      (4) fixed bin (71),	/* 80 words so far */
  6    42 	     2 after_journal_path char (168),		/* Not yet used */
  6    43 	     2 mbz_4	      (50) fixed bin (71),	/* 222 words so far */
  6    44 	     2 mbz_5	      bit (54) unal,	/* 223.5 words so far */
  6    45 	     2 length_of_attributes
  6    46 			      fixed bin (17) unal;	/* 224 words total */
  6    47 
  6    48 
  6    49      dcl	   file_attributes_ptr    ptr init (null ());
  6    50 
  6    51      dcl	   FILE_ATTRIBUTES_VERSION_2
  6    52 			      init ("FilAtt02") char (8) aligned internal static options (constant);
  6    53 
  6    54 
  6    55 /* END INCLUDE FILE dm_fm_file_attributes.incl.pl1 */
      252 
      253 
  7     1 /*  START OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  7     2 
  7     3 /* HISTORY:
  7     4*
  7     5*Designed by Matthew C. Pierret, 01/26/82.
  7     6*Coded by Jeffrey D. Ives, 04/30/82.
  7     7*Modified:
  7     8*10/18/82 by Steve Herbst: Names changed.
  7     9*01/19/83 by Steve Herbst: Added (LOWEST HIGHEST)_MODE.
  7    10**/
  7    11 
  7    12 dcl (LOWEST_MODE init (1),
  7    13      HIGHEST_MODE init (8)) fixed bin int static options (constant);
  7    14 
  7    15      dcl	   TM_NORMAL_MODE	      fixed bin static options (constant) init (1);
  7    16      dcl	   TM_STATISTICAL_MODE   fixed bin static options (constant) init (2);
  7    17      dcl	   TM_READ_ONLY_MODE     fixed bin static options (constant) init (3);
  7    18      dcl	   TM_NEVER_WRITE_MODE   fixed bin static options (constant) init (4);
  7    19      dcl	   TM_TEST_NORMAL_MODE   fixed bin static options (constant) init (5);
  7    20      dcl	   TM_TEST_STATISTICAL_MODE fixed bin static options (constant) init (6);
  7    21      dcl	   TM_TEST_READ_ONLY_MODE fixed bin static options (constant) init (7);
  7    22      dcl	   TM_TEST_NEVER_WRITE_MODE fixed bin static options (constant) init (8);
  7    23 
  7    24 /*  END OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      254 
      255 
  8     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  8     2 /* format: style3 */
  8     3 
  8     4 /* These constants are to be used for the flags argument of sub_err_ */
  8     5 /* They are just "string (condition_info_header.action_flags)" */
  8     6 
  8     7 declare	(
  8     8 	ACTION_CAN_RESTART	init (""b),
  8     9 	ACTION_CANT_RESTART init ("1"b),
  8    10 	ACTION_DEFAULT_RESTART
  8    11 			init ("01"b),
  8    12 	ACTION_QUIET_RESTART
  8    13 			init ("001"b),
  8    14 	ACTION_SUPPORT_SIGNAL
  8    15 			init ("0001"b)
  8    16 	)		bit (36) aligned internal static options (constant);
  8    17 
  8    18 /* End include file */
      256 
      257 
  9     1 /* BEGIN INCLUDE FILE sub_error_info.incl.pl1 */
  9     2 /* format: style2 */
  9     3 
  9     4 /* The include file condition_info_header must be used with this file */
  9     5 
  9     6      declare sub_error_info_ptr     pointer;
  9     7      declare 1 sub_error_info	      aligned based (sub_error_info_ptr),
  9     8 	     2 header	      aligned like condition_info_header,
  9     9 	     2 retval	      fixed bin (35),	/* return value */
  9    10 	     2 name	      char (32),		/* module name */
  9    11 	     2 info_ptr	      ptr;
  9    12 
  9    13      declare sub_error_info_version_1
  9    14 			      internal static options (constant) fixed bin init (1);
  9    15 
  9    16 /* END INCLUDE FILE sub_error_info.incl.pl1 */
      258 
      259 
      260 end fm_status;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/04/85  0826.8  fm_status.pl1                     >spec>on>7192.pbf-04/04/85>fm_status.pl1
242          1    01/07/85  0900.8  dm_ci_parts.incl.pl1              >ldd>include>dm_ci_parts.incl.pl1
244          2    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
246          3    03/24/82  1347.2  condition_info_header.incl.pl1    >ldd>include>condition_info_header.incl.pl1
248          4    01/07/85  0900.7  dm_ci_lengths.incl.pl1            >ldd>include>dm_ci_lengths.incl.pl1
250          5    03/06/85  1031.1  dm_file_status.incl.pl1           >ldd>include>dm_file_status.incl.pl1
252          6    01/07/85  0901.0  dm_fm_file_attributes.incl.pl1    >ldd>include>dm_fm_file_attributes.incl.pl1
254          7    01/07/85  0900.0  dm_tm_modes.incl.pl1              >ldd>include>dm_tm_modes.incl.pl1
256          8    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
258          9    07/18/81  1100.0  sub_error_info.incl.pl1           >ldd>include>sub_error_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000014 constant        bit(36)                  initial dcl 8-7 set ref 153*
A_code                                 parameter       fixed bin(35,0)          dcl 44 set ref 9 112* 184 218*
A_dirname                              parameter       char                     unaligned dcl 41 ref 9 109
A_entryname                            parameter       char                     unaligned dcl 42 ref 9 110
A_file_status_ptr                      parameter       pointer                  dcl 43 ref 9 111
CI_0_ADDRESSABLE_LENGTH                constant        fixed bin(17,0)          initial dcl 4-31 ref 147 148
CI_ADDRESSABLE_LENGTH                  constant        fixed bin(17,0)          initial dcl 4-29 ref 148
DM_FILE_STATUS_VERSION_1        000002 constant        char(8)                  initial unaligned dcl 5-46 ref 117
DONT_RETURN_CODE                001041 constant        fixed bin(17,0)          initial dcl 50 ref 127 235
FILE_ATTRIBUTES_VERSION_2       000000 constant        char(8)                  initial dcl 6-51 set ref 153 153*
ME                              000004 constant        char(32)                 initial unaligned dcl 49 set ref 153*
P_cleanup_code                         parameter       fixed bin(35,0)          dcl 197 set ref 189 202* 209 209*
P_code                                 parameter       fixed bin(35,0)          dcl 216 ref 214 218
TM_NORMAL_MODE                  000033 constant        fixed bin(17,0)          initial dcl 7-15 set ref 138*
action_flags              2            based           structure                level 3 dcl 9-7
addr                                                   builtin function         dcl 101 ref 144 150 150 229 229
auto_ci_parts                   000100 automatic       structure                level 1 dcl 58 set ref 150 150
begin_code                      000566 automatic       fixed bin(35,0)          dcl 73 set ref 112* 138* 139* 203
blocking_factor           4            based           fixed bin(17,0)          level 2 dcl 6-22 ref 178
callers_level                   000565 automatic       fixed bin(17,0)          dcl 72 set ref 171* 172*
ci_parts                               based           structure                level 1 dcl 1-27
ci_parts_ptr                    000604 automatic       pointer                  initial dcl 1-35 set ref 1-35*
ci_size                  12            based           fixed bin(18,0)          level 2 dcl 5-30 set ref 176*
ci_size_in_bytes          3            based           fixed bin(35,0)          level 2 dcl 6-22 ref 176
cip_number_of_parts             000606 automatic       fixed bin(17,0)          initial dcl 1-36 set ref 1-36*
cleanup                         000570 stack reference condition                dcl 105 ref 123
cleanup_called_sw               000564 automatic       bit(1)                   dcl 71 set ref 113* 181 200*
code                            000567 automatic       fixed bin(35,0)          dcl 73 in procedure "fm_status" set ref 123* 126*
                                                                                  127 127* 131* 132* 150* 151 151* 172* 174 183* 184
                                                                                  184*
code                            000100 automatic       fixed bin(35,0)          dcl 197 in procedure "CLEAN_UP" set ref 199* 207*
                                                                                  209 209
code                            000106 automatic       fixed bin(35,0)          dcl 227 in procedure "SUB_ERROR_CODE" set ref 229*
                                                                                  230 230
cond_info                       000106 automatic       structure                level 1 dcl 63 set ref 229 229
condition_info                         based           structure                level 1 dcl 2-14
condition_info_header                  based           structure                level 1 dcl 3-6
continue_to_signal_             000020 constant        entry                    external dcl 84 ref 234
cu_$level_get                   000022 constant        entry                    external dcl 85 ref 171
date_time_created         6            based           fixed bin(71,0)          level 2 in structure "file_attributes" dcl 6-22
                                                                                  in procedure "fm_status" ref 161
date_time_created         4            based           fixed bin(71,0)          level 2 in structure "dm_file_status" dcl 5-30
                                                                                  in procedure "fm_status" set ref 161*
default_restart           2(01)        based           bit(1)                   level 4 packed unaligned dcl 9-7 ref 232
dirname                         000500 automatic       char(168)                unaligned dcl 67 set ref 109* 131* 172* 178* 178*
dm_error_$bad_file_atrs_ver     000010 external static fixed bin(35,0)          dcl 77 set ref 153*
dm_error_$transaction_in_progress
                                000012 external static fixed bin(35,0)          dcl 78 ref 203
dm_file_status                         based           structure                level 1 dcl 5-30
dm_file_status_ptr              000610 automatic       pointer                  dcl 5-44 set ref 111* 115 117 160 161 162 163 164
                                                                                  165 166 167 172 174 176 178
entryname                       000552 automatic       char(32)                 unaligned dcl 68 set ref 110* 131* 172* 178* 178*
error_table_$null_info_ptr      000014 external static fixed bin(35,0)          dcl 79 set ref 115*
error_table_$unimplemented_version
                                000016 external static fixed bin(35,0)          dcl 80 set ref 117*
file_attributes                        based           structure                level 1 dcl 6-22
file_attributes_ptr             000612 automatic       pointer                  initial dcl 6-49 set ref 144* 146 153 153 160 161
                                                                                  162 163 165 166 167 176 178 6-49*
file_attributes_space           000140 automatic       structure                level 1 dcl 65 set ref 143* 144
file_manager_$close             000024 constant        entry                    external dcl 86 ref 202
file_manager_$get_user_access_modes
                                000026 constant        entry                    external dcl 87 ref 172
file_manager_$open              000030 constant        entry                    external dcl 89 ref 131
find_condition_info_            000032 constant        entry                    external dcl 90 ref 229
flags                     5            based           structure                level 2 dcl 6-22
fm_get_$internal_get            000034 constant        entry                    external dcl 91 ref 150
fm_get_last_ci_num              000036 constant        entry                    external dcl 92 ref 178
fm_unique_id              2            based           bit(36)                  level 2 dcl 5-30 set ref 160*
get_group_id_                   000040 constant        entry                    external dcl 93 ref 172 172
header                                 based           structure                level 2 dcl 9-7
highest_ci               11            based           fixed bin(27,0)          level 2 dcl 5-30 set ref 178*
info_ptr                 14     000106 automatic       pointer                  level 2 dcl 63 set ref 232 238
length_in_bytes           3     000100 automatic       fixed bin(17,0)          array level 3 dcl 58 set ref 148*
local_ptr                 4     000100 automatic       pointer                  array level 3 dcl 58 set ref 146*
mode                      3            based           bit(36)                  level 2 dcl 5-30 set ref 172* 174*
no_concurrency            5(01)        based           bit(1)                   level 3 packed unaligned dcl 6-22 ref 166
no_concurrency_sw        10(01)        based           bit(1)                   level 3 packed unaligned dcl 5-30 set ref 166*
no_rollback               5(02)        based           bit(1)                   level 3 packed unaligned dcl 6-22 ref 167
no_rollback_sw           10(02)        based           bit(1)                   level 3 packed unaligned dcl 5-30 set ref 167*
null                                                   builtin function         dcl 101 ref 115 153 153 1-35 6-49 229 229
number_of_parts                 000100 automatic       fixed bin(17,0)          initial level 2 dcl 58 set ref 58*
offset_in_bytes           2     000100 automatic       fixed bin(17,0)          array level 3 dcl 58 set ref 147*
opening_id                      000562 automatic       bit(36)                  unaligned dcl 69 set ref 122* 131* 132 150* 202 202*
pad                       1     000100 automatic       fixed bin(17,0)          initial level 2 dcl 58 set ref 58*
part                      2     000100 automatic       structure                array level 2 in structure "auto_ci_parts" dcl 58
                                                                                  in procedure "fm_status"
part                      2            based           structure                array level 2 in structure "ci_parts" dcl 1-27
                                                                                  in procedure "fm_status"
pathname_                       000042 constant        entry                    external dcl 94 ref 178 178
protected                 5            based           bit(1)                   level 3 packed unaligned dcl 6-22 ref 165
protected_sw             10            based           bit(1)                   level 3 packed unaligned dcl 5-30 set ref 165*
read                     10(03)        based           fixed bin(3,0)           level 3 packed unsigned unaligned dcl 6-22 ref 163
ring_brackets            10            based           structure                level 2 in structure "file_attributes" dcl 6-22
                                                                                  in procedure "fm_status"
ring_brackets             6            based           fixed bin(3,0)           array level 2 in structure "dm_file_status" dcl 5-30
                                                                                  in procedure "fm_status" set ref 162* 163*
status_code             104            based           fixed bin(35,0)          level 3 dcl 9-7 ref 238
sub_err_                        000044 constant        entry                    external dcl 95 ref 153
sub_error_                      000576 stack reference condition                dcl 105 ref 125 134
sub_error_info                         based           structure                level 1 dcl 9-7
switches                 10            based           structure                level 2 dcl 5-30 set ref 164*
transaction_manager_$begin_txn  000046 constant        entry                    external dcl 96 ref 138
transaction_manager_$commit_txn 000050 constant        entry                    external dcl 97 ref 207
txn_id                          000563 automatic       bit(36)                  dcl 70 set ref 138* 139 203 207*
unique_id                 2            based           bit(36)                  level 2 dcl 6-22 ref 160
unspec                                                 builtin function         dcl 101 set ref 143* 164*
version                                based           char(8)                  level 2 in structure "file_attributes" dcl 6-22
                                                                                  in procedure "fm_status" set ref 153 153*
version                                based           char(8)                  level 2 in structure "dm_file_status" dcl 5-30
                                                                                  in procedure "fm_status" ref 117
write                    10            based           fixed bin(3,0)           level 3 packed unsigned unaligned dcl 6-22 ref 162

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 8-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 8-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 8-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 8-7
CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES
                                       internal static fixed bin(17,0)          initial dcl 4-22
CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES
                                       internal static fixed bin(17,0)          initial dcl 4-25
HIGHEST_MODE                           internal static fixed bin(17,0)          initial dcl 7-12
LOWEST_MODE                            internal static fixed bin(17,0)          initial dcl 7-12
TM_NEVER_WRITE_MODE                    internal static fixed bin(17,0)          initial dcl 7-18
TM_READ_ONLY_MODE                      internal static fixed bin(17,0)          initial dcl 7-17
TM_STATISTICAL_MODE                    internal static fixed bin(17,0)          initial dcl 7-16
TM_TEST_NEVER_WRITE_MODE               internal static fixed bin(17,0)          initial dcl 7-22
TM_TEST_NORMAL_MODE                    internal static fixed bin(17,0)          initial dcl 7-19
TM_TEST_READ_ONLY_MODE                 internal static fixed bin(17,0)          initial dcl 7-21
TM_TEST_STATISTICAL_MODE               internal static fixed bin(17,0)          initial dcl 7-20
condition_info_header_ptr              automatic       pointer                  dcl 3-4
condition_info_ptr                     automatic       pointer                  dcl 2-10
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 2-30
sub_error_info_ptr                     automatic       pointer                  dcl 9-6
sub_error_info_version_1               internal static fixed bin(17,0)          initial dcl 9-13

NAMES DECLARED BY EXPLICIT CONTEXT.
CLEAN_UP                        000673 constant        entry                    internal dcl 189 ref 123 183
ERROR_RETURN                    000750 constant        entry                    internal dcl 214 ref 115 117 127 132 139 151 184
RETURN                          000646 constant        label                    dcl 181 ref 219
SUB_ERROR_CODE                  000765 constant        entry                    internal dcl 223 ref 126
fm_status                       000065 constant        entry                    external dcl 9

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1336        1410    1042        1346
Length      2004    1042        52         360     273           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
fm_status                           502 external procedure  is an external procedure.  
on unit on line 123                  70 on unit               
on unit on line 125                  91 on unit               
CLEAN_UP                             72 internal procedure  is called by several nonquick procedures.  
ERROR_RETURN                         64 internal procedure  is called by several nonquick procedures.  
SUB_ERROR_CODE                          internal procedure  shares stack frame of on unit on line 125.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
CLEAN_UP                 000100 code                        CLEAN_UP
fm_status                000100 auto_ci_parts               fm_status
                         000106 cond_info                   fm_status
                         000140 file_attributes_space       fm_status
                         000500 dirname                     fm_status
                         000552 entryname                   fm_status
                         000562 opening_id                  fm_status
                         000563 txn_id                      fm_status
                         000564 cleanup_called_sw           fm_status
                         000565 callers_level               fm_status
                         000566 begin_code                  fm_status
                         000567 code                        fm_status
                         000604 ci_parts_ptr                fm_status
                         000606 cip_number_of_parts         fm_status
                         000610 dm_file_status_ptr          fm_status
                         000612 file_attributes_ptr         fm_status
on unit on line 125      000106 code                        SUB_ERROR_CODE

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return              tra_ext
enable              ext_entry_desc      int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
continue_to_signal_           cu_$level_get                 file_manager_$close
file_manager_$get_user_access_modes                         file_manager_$open            find_condition_info_
fm_get_$internal_get          fm_get_last_ci_num            get_group_id_                 pathname_
sub_err_                      transaction_manager_$begin_txn
transaction_manager_$commit_txn

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bad_file_atrs_ver   dm_error_$transaction_in_progress                           error_table_$null_info_ptr
error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      9 000060        58 000105    1   35 000110    1   36 000112    6   49 000113       109 000114       110 000122
    111 000127       112 000132       113 000134       115 000135       117 000147       122 000163       123 000164
    125 000211       126 000225       127 000234       129 000247       131 000250       132 000275       134 000305
    138 000306       139 000325       143 000335       144 000340       146 000342       147 000343       148 000345
    150 000347       151 000367       153 000377       160 000456       161 000462       162 000464       163 000467
    164 000473       165 000474       166 000500       167 000504       171 000510       172 000517       174 000571
    176 000575       178 000601       181 000646       183 000650       184 000656       187 000671       189 000672
    199 000700       200 000701       202 000704       203 000717       207 000727       209 000737       212 000746
    214 000747       218 000755       219 000762       223 000765       229 000767       230 001007       232 001014
    234 001021       235 001031       238 001035


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
