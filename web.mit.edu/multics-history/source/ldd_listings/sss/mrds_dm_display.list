	COMPILATION LISTING OF SEGMENT mrds_dm_display
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-18_1111.43_Tue_mdt
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 /* format: ^inddcls,^indattr,indnoniterend,^indnoniterdo,indend,tree,^case,insnl,comcol61,dclind5,declareind5,delnl */
        8 
        9 mrds_dm_display:
       10      proc (I_mrds_dm_display_info_ptr, O_err_msg, O_err_code);
       11 
       12 /* BEGIN DESCRIPTION
       13*
       14*   The purpose of this procedure is to display the db_model info.
       15*
       16*   The output is through the iocb_ptr supplied in mrds_dm_display_info.
       17*
       18*   END DESCRIPTION */
       19 
       20 
       21 /****^  HISTORY COMMENTS:
       22*  1) change(82-05-20,DWoodka), approve(), audit(), install():
       23*     written.
       24*  2) change(82-08-18,DWoodka), approve(), audit(), install():
       25*     modified to remove bit offset and bit length numbers from the display
       26*     and include the database type (page_file or vfile) for the DMS conversion.
       27*  3) change(83-02-14,Davids), approve(), audit(), install():
       28*     modified to use the new db_type_flags in the db_model structure instead
       29*     of the old numeric db_type.
       30*  4) change(83-02-28,Davids), approve(), audit(), install():
       31*     Modified to indicate that Rollback is on/off instead of before journalling
       32*     to keep it consistent with the rest of the user interface.
       33*  5) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
       34*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
       35*     modified to use crossreference file. display unreferenced objects.
       36*     display crossreferences.
       37*                                                   END HISTORY COMMENTS */
       38 
       39 
       40 /*      PARAMETERS     */
       41 
       42 dcl  I_mrds_dm_display_info_ptr ptr parameter;		/* Pointer to mrds_dm_display_info structure */
       43 dcl  O_err_code fixed bin (35) parameter;		/* Error code */
       44 dcl  O_err_msg char (*) parameter;			/* Text of error message */
       45 
       46 
       47 
       48 /*      INITIALIZATION     */
       49 
       50 	mrds_dm_display_info_ptr = I_mrds_dm_display_info_ptr;
       51 						/* Init parameters */
       52 	O_err_msg = "";
       53 	O_err_code = 0;
       54 
       55 	iocb_ptr = mrds_dm_display_info.output_iocb_ptr;	/* For faster reference */
       56 	temp_file_iocb_ptr, second_temp_file_iocb_ptr = null;
       57 						/* Used in tidy_up */
       58 	dbm_ptr = mrds_dm_display_info.dbm_ptr;
       59 
       60 	max_seg_size = sys_info$max_seg_size * 4;
       61 
       62 	temp_seg_ptrs (*), fm_ptr = null;
       63 	on cleanup call tidy_up;			/* Establish cleanup handler */
       64 
       65 	if mrds_dm_display_info.version ^= MRDS_DM_DISPLAY_INFO_VERSION_1
       66 	then call error (error_table_$unimplemented_version, "^/For mrds_dm_display_info.version");
       67 
       68 
       69 /*    print header    */
       70 
       71 	if mrds_dm_display_info.sw.header
       72 	then call print_header;
       73 
       74 /*    display cmdb format    */
       75 
       76 	if mrds_dm_display_info.sw.cmdb
       77 	then call mrds_dm_display_cmdb (mrds_dm_display_info_ptr, err_msg, code);
       78 
       79 /*    display domains    */
       80 
       81 	if mrds_dm_display_info.sw.domains
       82 	then call print_domain_info;
       83 
       84 /*    display attribute info    */
       85 
       86 	if mrds_dm_display_info.sw.attribute
       87 	then call print_attrib_info;
       88 
       89 /*   display relation info     */
       90 
       91 	if mrds_dm_display_info.sw.relation
       92 	then call print_rel_info;
       93 
       94 /*    display index info    */
       95 
       96 	if mrds_dm_display_info.sw.index
       97 	then call print_index_info;
       98 
       99 /*    display domain crossreference    */
      100 
      101 	if mrds_dm_display_info.sw.domain_xref
      102 	then call print_xref (DOMAIN_KEY_HEAD, 1);
      103 
      104 /*    display attribute crossreference    */
      105 
      106 	if mrds_dm_display_info.sw.attribute_xref
      107 	then call print_xref (ATTRIBUTE_KEY_HEAD, 2);
      108 
      109 /*    display complete crossreference    */
      110 
      111 	if mrds_dm_display_info.sw.all_xref
      112 	then call print_complete_xref;
      113 
      114 /*    display history info    */
      115 
      116 	if mrds_dm_display_info.sw.history
      117 	then call mrds_dm_display_history (mrds_dm_display_info_ptr, err_msg, code);
      118 
      119 	call tidy_up;
      120 
      121 exit:
      122 	return;
      123 
      124 
      125 
      126 print_rel_info:
      127      proc;
      128 
      129 dcl  pii_object  char (32);
      130 
      131 	if mrds_dm_display_info.sw.names_only
      132 	then call ioa_$ioa_switch (iocb_ptr, "^/RELATION NAMES:");
      133 	if rel_name_list_ptr = null
      134 	then call print_all_relations;
      135 	else do i = 1 to rel_name_list_ptr -> name_list.num_names;
      136 	     pii_object = (rel_name_list_ptr -> name_list.name (i));
      137 	     call print_object (pii_object);
      138 	     end;
      139 
      140 	call ioa_$ioa_switch (iocb_ptr, "");		/* add a line feed */
      141 
      142      end print_rel_info;
      143 
      144 
      145 
      146 
      147 print_all_relations:
      148      proc;					/* called by print_rel_info */
      149 
      150 dcl  par_object char (30);
      151 
      152 	if db_model.num_rels < 1
      153 	then do;
      154 	     call ioa_$ioa_switch (iocb_ptr, "^2/There are no relations defined for the database^/^a",
      155 		mrds_dm_display_info.db_path);
      156 	     return;
      157 	     end;
      158 	else do fi_ptr = ptr (dbm_ptr, db_model.file_ptr) repeat ptr (dbm_ptr, file_info.fwd_ptr)
      159 		while (rel (fi_ptr) ^= NULL_OFFSET);	/* loop through all relations (files) */
      160 
      161 	          par_object = file_info.file_name;
      162 	          call print_object (par_object);
      163 		end;
      164      end print_all_relations;
      165 
      166 
      167 
      168 print_object:
      169 	proc (po_object_of_print);
      170 
      171 dcl   po_object_of_print char (*) parameter;
      172 	
      173 		file_model_name = rtrim (po_object_of_print) || ".m";
      174 						/* get relation name */
      175 		call initiate_file_ (db_path, file_model_name, R_ACCESS, fm_ptr, (0), code);
      176 		if fm_ptr = null
      177 		then call error (mrds_error_$no_model_rel, "^/" || rtrim (rel_name_list_ptr -> name_list.name (i)));
      178 
      179 		ri_ptr = ptr (fm_ptr, file_model.rel_ptr);
      180 						/* relation info ptr */
      181 		if mrds_dm_display_info.sw.names_only
      182 		then call ioa_$ioa_switch (iocb_ptr, "^a", rel_info.name);
      183 						/* print relation name */
      184 		else if mrds_dm_display_info.sw.default
      185 		     then call print_rel_info_default;
      186 		     else if mrds_dm_display_info.sw.long
      187 			then call print_rel_info_long;
      188 			else call print_rel_info_brief;
      189 
      190 		call terminate_file_ (fm_ptr, 0, TERM_FILE_TERM, (0));
      191 
      192 	end print_object;
      193 
      194 
      195 print_rel_info_brief:
      196 print_rel_info_default:
      197      proc;					/* print relation info for default or brief switch */
      198 						/* called by print_rel_info or print_all_relations */
      199 
      200 
      201 	call ioa_$ioa_switch (iocb_ptr, "^2/RELATION: ^5x^32a", rel_info.name);
      202 	if rel_info.num_attr > 1
      203 	then plural = "S";
      204 	else plural = "";
      205 
      206 	printed_one_sw = "0"b;
      207 
      208 	do ai_ptr = ptr (fm_ptr, rel_info.attr_ptr) /* get attribute info */
      209 	     repeat ptr (fm_ptr, attr_info.fwd_thread) while (rel (ai_ptr) ^= NULL_OFFSET);
      210 
      211 	     if ^mrds_dm_display_info.sw.default
      212 	     then /* Brief form */
      213 		if ^printed_one_sw
      214 		then do;
      215 		     call ioa_$ioa_switch (iocb_ptr, "^/^3x^22a^a", "ATTRIBUTE" || plural || ":", attr_info.name);
      216 		     printed_one_sw = "1"b;
      217 		     end;
      218 		else call ioa_$ioa_switch (iocb_ptr, "^25x^a", attr_info.name);
      219 	     else do;				/* Default form */
      220 		if ^printed_one_sw
      221 		then do;
      222 		     call ioa_$ioa_switch (iocb_ptr, "^/^3x^a", "ATTRIBUTE" || plural || ":");
      223 		     printed_one_sw = "1"b;
      224 		     end;
      225 
      226 		if attr_info.key_attr
      227 		then type = "Key";
      228 		else type = "Data";
      229 
      230 		if attr_info.index_attr
      231 		then indx = "Index";
      232 		else indx = "";
      233 
      234 		untrimmed_dcl =
      235 		     mdbm_util_$display_descriptor (
      236 		     addr (pointer (dbm_ptr, attr_info.domain_ptr) -> domain_info.user_desc));
      237 		dcl_trimmed = mdbm_util_$trim_descriptor (untrimmed_dcl);
      238 
      239 		call ioa_$ioa_switch (iocb_ptr, "^6x^32a^2x^a^2x^a", attr_info.name, type, indx);
      240 		call ioa_$ioa_switch (iocb_ptr, "^10x^a", dcl_trimmed);
      241 
      242 		end;
      243 	     end;
      244      end print_rel_info_brief;
      245 
      246 
      247 print_rel_info_long:
      248      proc;					/* called by print_rel_info or print_all_relations */
      249 
      250 
      251 	rel_long.rel_name = rel_info.name;
      252 	rel_long.nattrs = rel_info.num_attr;
      253 
      254 	call iox_$put_chars (iocb_ptr, addr (rel_long), length (string (rel_long)), code);
      255 	if code ^= 0
      256 	then call error (code, "");
      257 
      258 
      259 	if rel_info.num_attr > 1
      260 	then plural = "S";
      261 	else plural = "";
      262 
      263 
      264 	call ioa_$ioa_switch_nnl (iocb_ptr, "^2/^3x^a:", "ATTRIBUTE" || plural);
      265 
      266 	do ai_ptr = ptr (fm_ptr, rel_info.attr_ptr) /* get attribute info */
      267 	     repeat ptr (fm_ptr, attr_info.fwd_thread) while (rel (ai_ptr) ^= NULL_OFFSET);
      268 
      269 	     if attr_info.key_attr
      270 	     then type = "Key";
      271 	     else type = "Data";
      272 
      273 	     if attr_info.index_attr
      274 	     then indx = "Index";
      275 	     else indx = "";
      276 
      277 	     call ioa_$ioa_switch (iocb_ptr, "^2/^6xName:^7x^a", attr_info.name);
      278 	     call ioa_$ioa_switch (iocb_ptr, "^6xType:^7x^a^2x^a", type, indx);
      279 
      280 	     di_ptr = pointer (dbm_ptr, attr_info.domain_ptr);
      281 
      282 	     call ioa_$ioa_switch (iocb_ptr, "^6xDomain_info:^/^12xname: ^a", domain_info.name);
      283 
      284 	     call ioa_$ioa_switch_nnl (iocb_ptr, "^12xdcl:  ^a",
      285 		mdbm_util_$display_descriptor (addr (domain_info.db_desc)));
      286 	     if domain_info.check_path_ptr ^= NULL_OFFSET
      287 	     then call ioa_$ioa_switch_nnl (iocb_ptr, "^/^15x-check_proc ^a",
      288 		     get_path_entry (domain_info.check_path_ptr, "$"));
      289 
      290 	     if domain_info.encd_path_ptr ^= NULL_OFFSET
      291 	     then call ioa_$ioa_switch_nnl (iocb_ptr, "^/^15x-encode_proc ^a",
      292 		     get_path_entry (domain_info.encd_path_ptr, "$"));
      293 
      294 	     if domain_info.decd_path_ptr ^= NULL_OFFSET
      295 	     then call ioa_$ioa_switch_nnl (iocb_ptr, "^/^15x-decode_proc ^a",
      296 		     get_path_entry (domain_info.decd_path_ptr, "$"));
      297 
      298 	     if domain_info.db_desc ^= domain_info.user_desc
      299 	     then /* It had a -decode_dcl */
      300 		call ioa_$ioa_switch_nnl (iocb_ptr, "^/^15x-decode_dcl ^/^15x^a",
      301 		     mdbm_util_$display_descriptor (addr (domain_info.user_desc)));
      302 	     call ioa_$ioa_switch (iocb_ptr, "");	/* add a line feed */
      303 
      304 	     end;
      305 
      306      end print_rel_info_long;
      307 
      308 
      309 
      310 print_domain_info:
      311      proc;
      312 	if db_model.domain_ptr = NULL_OFFSET
      313 	then do;
      314 	     call ioa_$ioa_switch (iocb_ptr, "^2/No domains exist for the database^/^a", mrds_dm_display_info.db_path);
      315 	     return;
      316 	     end;
      317 
      318 	if mrds_dm_display_info.sw.names_only
      319 	then call ioa_$ioa_switch (iocb_ptr, "^2/DOMAIN NAMES:");
      320 	else do;
      321 	     if db_model.num_domains > 1
      322 	     then plural = "S";
      323 	     else plural = "";
      324 	     call ioa_$ioa_switch (iocb_ptr, "^2/DOMAIN" || plural || ":");
      325 	     end;
      326 
      327 	if dom_name_list_ptr = null
      328 	then do;
      329 	     printed_one_sw = "0"b;
      330 	     do di_ptr = ptr (dbm_ptr, db_model.domain_ptr) /* loop through all domains */
      331 		repeat ptr (dbm_ptr, domain_info.fwd_thread) while (rel (di_ptr) ^= NULL_OFFSET);
      332 		if (mrds_dm_display_info.sw.unreferenced_domains & domain_info.unreferenced)
      333 		     | (^mrds_dm_display_info.sw.unreferenced_domains)
      334 		then do;
      335 		     if mrds_dm_display_info.sw.names_only
      336 		     then call ioa_$ioa_switch (iocb_ptr, "^a", domain_info.name);
      337 						/* print domain name */
      338 		     else call print_domain;
      339 		     printed_one_sw = "1"b;
      340 		     end;
      341 		end;
      342 	     if ^printed_one_sw
      343 	     then call ioa_$ioa_switch (iocb_ptr, "^2/No unreferenced domains exist for the database^/^a",
      344 		     mrds_dm_display_info.db_path);
      345 	     end;
      346 	else do i = 1 to dom_name_list_ptr -> name_list.num_names;
      347 		di_ptr = ptr (dbm_ptr, db_model.domain_ptr);
      348 
      349 		do while (domain_info.name ^= dom_name_list_ptr -> name_list.name (i));
      350 		     di_ptr = ptr (dbm_ptr, domain_info.fwd_thread);
      351 		     if rel (di_ptr) = NULL_OFFSET
      352 		     then call error (mrds_error_$no_model_dom,
      353 			     "^/" || rtrim (dom_name_list_ptr -> name_list.name (i)));
      354 		     end;
      355 
      356 
      357 		if mrds_dm_display_info.sw.names_only
      358 		then call ioa_$ioa_switch (iocb_ptr, "^a", domain_info.name);
      359 						/* print domain name */
      360 		else call print_domain;
      361 		end;
      362 
      363 	call ioa_$ioa_switch (iocb_ptr, "");		/* add a line feed */
      364 
      365      end print_domain_info;
      366 
      367 
      368 print_domain:
      369      proc;					/* called by print_domain_info */
      370 
      371 	long_desc_str = mdbm_util_$display_descriptor (addr (domain_info.db_desc));
      372 	if mrds_dm_display_info.sw.long
      373 	then do;
      374 	     desc_str = long_desc_str;
      375 	     call ioa_$ioa_switch_nnl (iocb_ptr, "^-^a^/^-^5x^a", domain_info.name, desc_str);
      376 	     end;
      377 	else do;
      378 	     desc_str = mdbm_util_$trim_descriptor (long_desc_str);
      379 	     call ioa_$ioa_switch_nnl (iocb_ptr, "^-^20a^1x^a", domain_info.name, desc_str);
      380 	     end;
      381 
      382 	if domain_info.check_path_ptr ^= NULL_OFFSET
      383 	then call ioa_$ioa_switch_nnl (iocb_ptr, "^/^15x-check_proc ^a",
      384 		get_path_entry (domain_info.check_path_ptr, "$"));
      385 
      386 	if domain_info.encd_path_ptr ^= NULL_OFFSET
      387 	then call ioa_$ioa_switch_nnl (iocb_ptr, "^/^15x-encode_proc ^a",
      388 		get_path_entry (domain_info.encd_path_ptr, "$"));
      389 
      390 	if domain_info.decd_path_ptr ^= NULL_OFFSET
      391 	then call ioa_$ioa_switch_nnl (iocb_ptr, "^/^15x-decode_proc ^a",
      392 		get_path_entry (domain_info.decd_path_ptr, "$"));
      393 
      394 	if domain_info.db_desc ^= domain_info.user_desc
      395 	then call ioa_$ioa_switch_nnl (iocb_ptr, "^/^15x-decode_dcl ^/^15x^a",
      396 		mdbm_util_$display_descriptor (addr (domain_info.user_desc)));
      397 
      398 	call ioa_$ioa_switch (iocb_ptr, "");		/* add a line feed */
      399      end print_domain;
      400 
      401 
      402 print_attrib_info:
      403      proc;
      404 
      405 	if ^mrds_dm_display_info.sw.header
      406 	then call build_db_attr_list;			/* if the attribute list is not already built */
      407 
      408           if (db_model.unreferenced_attribute_ptr = NULL_OFFSET & mrds_dm_display_info.unreferenced_attributes)
      409 	     then do;
      410 	     call ioa_$ioa_switch (iocb_ptr, "^2/No unreferenced attributes exist for the database^/^a", mrds_dm_display_info.db_path);
      411 	     return;
      412 	     end;
      413 	if mrds_dm_display_info.sw.names_only
      414 	then call ioa_$ioa_switch (iocb_ptr, "^2/ATTRIBUTE NAMES:");
      415 	else do;
      416 	     call ioa_$ioa_switch (iocb_ptr, "^/ATTRIBUTES:");
      417 	     call ioa_$ioa_switch_nnl (iocb_ptr, "^/^-^20a^1x^a^/", "NAME:", "DOMAIN:");
      418 	     end;
      419 
      420 	call iox_$position (temp_file_iocb_ptr, BOF, 0, code);
      421 	if code ^= 0
      422 	then call error (code, "Positioning temp file to BOF");
      423 
      424 	if attr_name_list_ptr = null
      425 	then if mrds_dm_display_info.sw.unreferenced_attributes
      426 	     then do ua_ptr = ptr (dbm_ptr, db_model.unreferenced_attribute_ptr)
      427 	          repeat ptr (dbm_ptr, unreferenced_attribute.fwd_thread) while (rel (ua_ptr) ^= NULL_OFFSET);
      428 
      429 	          if mrds_dm_display_info.sw.names_only
      430 		then call ioa_$ioa_switch (iocb_ptr, "^a", unreferenced_attribute.name);
      431 	          else do;
      432 		     di_ptr = ptr (dbm_ptr, unreferenced_attribute.domain_ptr);
      433 		     call ioa_$ioa_switch (iocb_ptr, "^-^20a^1x^a", unreferenced_attribute.name,
      434 			domain_info.name);
      435 		     end;
      436 		end;				/* do ua_ptr */
      437 	     
      438 	     else do;
      439 		seek_head_info.n = length (ATTRIBUTE_KEY_HEAD);
      440 		seek_head_info.search_key = ATTRIBUTE_KEY_HEAD;
      441 
      442 		call iox_$control (temp_file_iocb_ptr, "seek_head", addr (seek_head_info), code);
      443 		if code = error_table_$no_record
      444 		then code = error_table_$end_of_info;
      445 
      446 		do while (code = 0);
      447 
      448 		     call iox_$read_key (temp_file_iocb_ptr, key, (0), code);
      449 		     if code = 0
      450 		     then if substr (key, 1, length (ATTRIBUTE_KEY_HEAD)) = ATTRIBUTE_KEY_HEAD
      451 			then if mrds_dm_display_info.sw.names_only
      452 			     then do;
      453 				call ioa_$ioa_switch (iocb_ptr, "^a",
      454 				     substr (key, length (ATTRIBUTE_KEY_HEAD) + 1));
      455 				call iox_$position (temp_file_iocb_ptr, 0, 1, code);
      456 				end;
      457 			     else do;
      458 				call iox_$read_record (temp_file_iocb_ptr, temp_seg_ptr, 8, (0), code);
      459 
      460 				if (code = 0) | (code = error_table_$long_record)
      461 				then do;
      462 				     di_ptr = ptr (dbm_ptr, temp_seg_ptr -> crossref_info_record.offset);
      463 				     call ioa_$ioa_switch (iocb_ptr, "^-^20a^1x^a",
      464 					substr (key, length (ATTRIBUTE_KEY_HEAD) + 1),
      465 					di_ptr -> domain_info.name);
      466 				     code = 0;
      467 				     end;
      468 				else call error (code, "Reading attribute record from xref file for key: " || key);
      469 				end;
      470 			else code = error_table_$end_of_info;
      471 		     end;
      472 
      473 		if code ^= error_table_$end_of_info
      474 		then call error (code, "Getting attribute names from temp file");
      475 		end;
      476 
      477 	else do i = 1 to attr_name_list_ptr -> name_list.num_names;
      478 		key = ATTRIBUTE_KEY_HEAD || rtrim (attr_name_list_ptr -> name_list.name (i));
      479 		call iox_$seek_key (temp_file_iocb_ptr, key, (0), code);
      480 		if code ^= 0
      481 		then call error (mrds_error_$no_model_attr, "^/" || rtrim (attr_name_list_ptr -> name_list.name (i)));
      482 
      483 		if mrds_dm_display_info.sw.names_only
      484 		then call ioa_$ioa_switch (iocb_ptr, "^a", attr_name_list_ptr -> name_list.name (i));
      485 		else do;
      486 		     call iox_$read_record (temp_file_iocb_ptr, temp_seg_ptr, 8, (0), code);
      487 		     if (code = 0) | (code = error_table_$long_record)
      488 		     then do;
      489 			di_ptr = ptr (dbm_ptr, temp_seg_ptr -> crossref_info_record.offset);
      490 
      491 			call ioa_$ioa_switch (iocb_ptr, "^-^20a^1x^a", attr_name_list_ptr -> name_list.name (i),
      492 			     di_ptr -> domain_info.name);
      493 			code = 0;           /* in case the code was long_record */
      494 			end;
      495 		     else call error (code, "Reading attribute record from xref file for key: " || key);
      496 		     end;
      497 		end;
      498 
      499 	call ioa_$ioa_switch (iocb_ptr, "");	/* add a new_line */
      500 
      501 	return;
      502      end print_attrib_info;
      503 
      504 
      505 
      506 build_db_attr_list:
      507      proc;					/* called by print_header or print_attrib_info */
      508 
      509 	if temp_file_iocb_ptr ^= null
      510 	then return;
      511 
      512 	temp_file_iocb_ptr = mrds_dm_display_info.xref_iocb_ptr;
      513 	if temp_file_iocb_ptr = null
      514 	then do;
      515 	     call mu_db_xref$xref_build (mrds_dm_display_info.temp_dir_path, mrds_dm_display_info.db_path, dbm_ptr,
      516 		mrds_dm_display_info.xref_name, mrds_dm_display_info.xref_iocb_ptr, error_message, code);
      517 	     if code ^= 0
      518 	     then call error (code, error_message);
      519 
      520 	     end;
      521 
      522 	temp_file_iocb_ptr = mrds_dm_display_info.xref_iocb_ptr;
      523 	temp_file_attach_name = mrds_dm_display_info.xref_name;
      524 
      525 	call mu_temp_segments$get_temp_segment_path (mrds_dm_display_info.temp_dir_path, myname, temp_seg_ptr, code);
      526 	if code ^= 0
      527 	then call error (code, "Getting a temp segment in [pd].");
      528 
      529 	return;
      530      end build_db_attr_list;
      531 
      532 
      533 print_index_info:
      534      proc;
      535 
      536 	if mrds_dm_display_info.sw.names_only
      537 	then call ioa_$ioa_switch (iocb_ptr, "^/INDEXED RELATION NAMES:");
      538 
      539 	if index_name_list_ptr = null
      540 	then call print_all_indexes;
      541 	else do i = 1 to index_name_list_ptr -> name_list.num_names;
      542 
      543 		file_model_name = rtrim (index_name_list_ptr -> name_list.name (i)) || ".m";
      544 						/* get index name */
      545 		call initiate_file_ (db_path, file_model_name, R_ACCESS, fm_ptr, (0), code);
      546 		if fm_ptr = null
      547 		then call error (mrds_error_$no_model_rel, "^/" || rtrim (index_name_list_ptr -> name_list.name (i)));
      548 
      549 		ri_ptr = ptr (fm_ptr, file_model.rel_ptr);
      550 						/* relation info ptr */
      551 
      552 		if ^rel_info.indexed
      553 		then call ioa_$ioa_switch (iocb_ptr, "^/^3xThe relation ^a is not indexed^/", rel_info.name);
      554 
      555 		else do;				/* if the relation is indexed */
      556 
      557 		     if mrds_dm_display_info.sw.names_only
      558 		     then call ioa_$ioa_switch (iocb_ptr, "^a", index_name_list_ptr -> name_list.name (i));
      559 		     else do;
      560 			call ioa_$ioa_switch (iocb_ptr, "^2/INDEXED RELATION: ^8x^32a",
      561 			     index_name_list_ptr -> name_list.name (i));
      562 
      563 
      564 			call ioa_$ioa_switch (iocb_ptr, "^/^3x^a", "INDEXED ATTRIBUTES:");
      565 
      566 
      567 			do ai_ptr = ptr (fm_ptr, rel_info.attr_ptr) /* loop through attributes */
      568 			     repeat ptr (fm_ptr, attr_info.fwd_thread) while (rel (ai_ptr) ^= NULL_OFFSET);
      569 
      570 			     if attr_info.index_attr
      571 			     then call ioa_$ioa_switch (iocb_ptr, "^6x^a", attr_info.name);
      572 			     end;
      573 			end;
      574 		     end;
      575 
      576 		call terminate_file_ (fm_ptr, 0, TERM_FILE_TERM, (0));
      577 		end;
      578 
      579 	call ioa_$ioa_switch (iocb_ptr, "");		/* add line feed */
      580 
      581      end print_index_info;
      582 
      583 
      584 print_all_indexes:
      585      proc;					/* called by print_index_info */
      586 
      587 	if db_model.num_rels < 1
      588 	then do;
      589 	     call ioa_$ioa_switch (iocb_ptr, "^2/There are no relations defined for the database^/^a",
      590 		mrds_dm_display_info.db_path);
      591 	     return;
      592 	     end;
      593 	else do fi_ptr = ptr (dbm_ptr, db_model.file_ptr) repeat ptr (dbm_ptr, file_info.fwd_ptr)
      594 		while (rel (fi_ptr) ^= NULL_OFFSET);	/* loop through all relations (files) */
      595 
      596 		file_model_name = rtrim (file_info.file_name) || ".m";
      597 						/* get relation name */
      598 
      599 		call initiate_file_ (db_path, file_model_name, R_ACCESS, fm_ptr, (0), code);
      600 		if fm_ptr = null
      601 		then call error (code, "^/" || rtrim (db_path) || file_model_name);
      602 
      603 		ri_ptr = ptr (fm_ptr, file_model.rel_ptr);
      604 						/* relation info Ptr */
      605 
      606 		if rel_info.indexed
      607 		then do;
      608 
      609 		     if mrds_dm_display_info.sw.names_only
      610 		     then call ioa_$ioa_switch (iocb_ptr, "^a", rel_info.name);
      611 		     else do;
      612 			call ioa_$ioa_switch (iocb_ptr, "^2/INDEXED RELATION: ^8x^32a", rel_info.name);
      613 
      614 
      615 			call ioa_$ioa_switch (iocb_ptr, "^/^3x^a", "INDEXED ATTRIBUTES:");
      616 
      617 			do ai_ptr = ptr (fm_ptr, rel_info.attr_ptr) /* loop through attributes */
      618 			     repeat ptr (fm_ptr, attr_info.fwd_thread) while (rel (ai_ptr) ^= NULL_OFFSET);
      619 
      620 			     if attr_info.index_attr
      621 			     then call ioa_$ioa_switch (iocb_ptr, "^6x^a", attr_info.name);
      622 			     end;
      623 
      624 			end;
      625 
      626 		     end;
      627 
      628 		call terminate_file_ (fm_ptr, 0, TERM_FILE_TERM, (0));
      629 		end;
      630 
      631      end print_all_indexes;
      632 
      633 
      634 print_header:
      635      proc;
      636 
      637 
      638 	call build_db_attr_list;
      639 	call mu_db_xref$xref_statistics (temp_file_iocb_ptr, (0), total_attributes, (0), error_message, code);
      640 	if code ^= 0
      641 	then call error (code, error_message);
      642 
      643 	if db_model.db_type_flags.vfile_type
      644 	then call ioa_$ioa_switch (iocb_ptr, "DATA MODEL FOR VFILE DATA BASE  ^a", mrds_dm_display_info.db_path);
      645 						/* Database path */
      646 	else do;
      647 	     call ioa_$ioa_switch (iocb_ptr, "DATA MODEL FOR DMFILE DATA BASE  ^a", mrds_dm_display_info.db_path);
      648 						/* Database path */
      649 	     if db_model.db_type_flags.transactions_needed
      650 	     then do;
      651 		call ioa_$ioa_switch (iocb_ptr, "^-Database requires transactions");
      652 		call ioa_$ioa_switch (iocb_ptr, "^-   Rollback is    ^[on^;off^]", db_model.db_type_flags.rollback_on)
      653 		     ;
      654 		call ioa_$ioa_switch (iocb_ptr, "^-   Concurrency is ^[on^;off^]",
      655 		     db_model.db_type_flags.concurrency_on);
      656 		end;
      657 	     else call ioa_$ioa_switch (iocb_ptr, "^-Database does not require transactions");
      658 	     end;
      659 
      660 	if db_model.mdbm_secured
      661 	then call ioa_$ioa_switch (iocb_ptr, "Data base secured.");
      662 
      663 	header_1.version_num = db_model.version;
      664 
      665 	changer_ptr = pointer (dbm_ptr, db_model.changer_ptr);
      666 						/* last on list = creator */
      667 
      668 	do while (changer_ptr -> changer.next ^= NULL_OFFSET);
      669 	     changer_ptr = pointer (dbm_ptr, changer_ptr -> changer.next);
      670 	     end;
      671 
      672 	header_1.creator = changer_ptr -> changer.id;
      673 
      674 	call date_time_ ((changer_ptr -> changer.time), header_1.create_time);
      675 
      676 	call iox_$put_chars (iocb_ptr, addr (header_1), length (string (header_1)), code);
      677 	if code ^= 0
      678 	then call error (code, "");
      679 
      680 	if pointer (dbm_ptr, db_model.changer_ptr) -> changer.next ^= NULL_OFFSET
      681 	then do;					/* If db_model has been changed */
      682 	     header_2.changer = pointer (dbm_ptr, db_model.changer_ptr) -> changer.id;
      683 	     call date_time_ ((pointer (dbm_ptr, db_model.changer_ptr) -> changer.time), header_2.change_time);
      684 	     call iox_$put_chars (iocb_ptr, addr (header_2), length (string (header_2)), code);
      685 	     if code ^= 0
      686 	     then call error (code, "");
      687 
      688 	     end;
      689 
      690 	header_3.num_rels = db_model.num_rels;
      691 
      692 	header_3.num_attrs = total_attributes;		/*  count all attributes */
      693 
      694 	header_3.num_domains = db_model.num_domains;
      695 
      696 	call iox_$put_chars (iocb_ptr, addr (header_3), length (string (header_3)), code);
      697 	if code ^= 0
      698 	then call error (code, "");
      699 
      700 	call ioa_$ioa_switch (iocb_ptr, "");		/* Add a line feed */
      701 
      702      end print_header;
      703 
      704 
      705 
      706 print_xref:
      707      proc (px_key_head, px_type);
      708 
      709 dcl  px_key_head char (*) parameter;
      710 dcl  px_loop fixed bin;
      711 dcl  px_type fixed bin parameter;
      712 
      713 	call build_db_attr_list;
      714 
      715 	call iox_$position (temp_file_iocb_ptr, BOF, 0, code);
      716 	if code ^= 0
      717 	then call error (code, "Positioning temp file to BOF");
      718 
      719 	seek_head_info.n = length (px_key_head);
      720 	seek_head_info.search_key = px_key_head;
      721 
      722 	call iox_$control (temp_file_iocb_ptr, "seek_head", addr (seek_head_info), code);
      723 	if code ^= 0
      724 	then if code = error_table_$no_record
      725 	     then do;
      726 		call ioa_$ioa_switch (iocb_ptr, "^2/No ^[domains^;attributes^] exist for the database.", px_type = 1);
      727 		return;
      728 		end;
      729 	     else call error (code, "Seeking to first domain xref record");
      730 
      731 	printed_one_sw = "0"b;
      732 	call ioa_$ioa_switch (iocb_ptr, "^2/^[^20a^1x^;^s^]^20a^1x^[^20a^]^/", px_type = 1, "DOMAINS", "ATTRIBUTES",
      733 	     px_type = 2, "RELATIONS");
      734 
      735 	call iox_$read_key (temp_file_iocb_ptr, key, (0), code);
      736 	do while (code = 0);
      737 	     if substr (key, 1, length (px_key_head)) = px_key_head
      738 	     then do;
      739 		key = substr (key, length (px_key_head) + 1);
      740 		call iox_$read_record (temp_file_iocb_ptr, temp_seg_ptr, max_seg_size, (0), code);
      741 		if code = 0
      742 		then do;
      743 		     if temp_seg_ptr -> crossref_info_record.count ^= 0
      744 		     then do;
      745 			do px_loop = 1 to temp_seg_ptr -> crossref_info_record.count;
      746 			     call ioa_$ioa_switch (iocb_ptr, "^[^20a^;^20x^s^]^1x^a", px_loop = 1, key,
      747 				temp_seg_ptr -> crossref_info_record.object (px_loop));
      748 			     end;			/* do pdx_loop */
      749 
      750 			printed_one_sw = "1"b;
      751 			end;
      752 
      753 		     call iox_$read_key (temp_file_iocb_ptr, key, (0), code);
      754 		     end;
      755 		end;
      756 	     else code = error_table_$end_of_info;
      757 	     end;					/* do while code = 0 */
      758 
      759 	if code ^= error_table_$end_of_info
      760 	then call error (code, "Reading crossreference file.");
      761 
      762 	if ^printed_one_sw
      763 	then call ioa_$ioa_switch (iocb_ptr, "^2/No referenced ^[domains^;attributes^] exist for the database^/^a",
      764 		px_type = 1, mrds_dm_display_info.db_path);
      765 
      766 	return;
      767 
      768      end print_xref;
      769 
      770 print_complete_xref:
      771      proc;
      772 
      773 dcl  pcx_attribute_loop fixed bin;
      774 dcl  pcx_attribute_name char (32);
      775 dcl  pcx_domain_loop fixed bin;
      776 dcl  pcx_domain_name char (32);
      777 dcl  pcx_prev_attribute_name char (32);
      778 dcl  pcx_prev_domain_name char (32);
      779 
      780 	call build_db_attr_list;
      781 	call attach_second_iocb;
      782 
      783 	call iox_$position (temp_file_iocb_ptr, BOF, 0, code);
      784 	if code ^= 0
      785 	then call error (code, "Positioning temp file to BOF");
      786 
      787 	printed_one_sw = "0"b;
      788 	call ioa_$ioa_switch (iocb_ptr, "^2/^20a^x^20a^x^20a^/", "DOMAINS", "ATTRIBUTES", "RELATIONS");
      789 
      790 /* Position first iocb to first domain key */
      791 	seek_head_info.search_key = DOMAIN_KEY_HEAD;
      792 	seek_head_info.n = length (DOMAIN_KEY_HEAD);
      793 
      794 	call iox_$control (temp_file_iocb_ptr, "seek_head", addr (seek_head_info), code);
      795 	if code ^= 0
      796 	then if code = error_table_$no_record
      797 	     then do;
      798 		call ioa_$ioa_switch (iocb_ptr, "^2/No domains exist for the database.");
      799 		return;
      800 		end;
      801 	     else call error (code, "Seeking to first domain xref record");
      802 
      803 	call mu_temp_segments$get_temp_segment_path (mrds_dm_display_info.temp_dir_path, myname, temp_seg_ptrs (2),
      804 	     code);
      805 	if code ^= 0
      806 	then call error (code, "Cannot get temp segment in [pd].");
      807 
      808 	pcx_prev_domain_name, pcx_prev_attribute_name = "";
      809 
      810 /*
      811*   Produce the listing. This is done by reading the domain records from the
      812*   temp_file_iocb_ptr file. These records contain list of attributes the domains
      813*   are used in. Ignore unreferenced domains. Read the attribute record from the
      814*   second_temp_file_iocb_ptr file. These records contain list of relations the
      815*   attribute is used in. If no relations, display {Unreferenced} in the relation
      816*   column; otherwise display the domain, attribute and list of relations.
      817**/
      818 
      819 	call iox_$read_key (temp_file_iocb_ptr, key, (0), code);
      820 	do while (code = 0);
      821 	     if substr (key, 1, length (DOMAIN_KEY_HEAD)) ^= DOMAIN_KEY_HEAD
      822 	     then code = error_table_$end_of_info;
      823 	     else do;
      824 		call iox_$read_record (temp_file_iocb_ptr, temp_seg_ptr, max_seg_size, (0), code);
      825 		if code = 0
      826 		then do;
      827 		     pcx_domain_name = substr (key, length (DOMAIN_KEY_HEAD) + 1);
      828 
      829 /* ignore unreferenced domains by testing count of domain record. The first
      830*   reference of a domain record is the generated attribute with the same name,
      831*   so we skip that one. */
      832 		     do pcx_domain_loop = 1 to temp_seg_ptr -> crossref_info_record.count;
      833 
      834 /* make attribute record key. look for this record (has to be there according
      835*   to the rules of building the xref file). */
      836 			key = ATTRIBUTE_KEY_HEAD || temp_seg_ptr -> crossref_info_record.object (pcx_domain_loop);
      837 			call iox_$seek_key (second_temp_file_iocb_ptr, key, (0), code);
      838 			if code ^= 0
      839 			then if (code = error_table_$no_record) & (temp_seg_ptr -> crossref_info_record.count = 1)
      840 			     then do;		/* this is a generated attribute for a domain */
      841 				temp_seg_ptrs (2) -> crossref_info_record.count = 0;
      842 				pcx_attribute_name = pcx_domain_name;
      843 				end;
      844 			     else call error (code, "Searching crossreference for attribute list record: " || key);
      845 			else do;			/* read the attribute record into the second temp segment */
      846 			     call iox_$read_record (second_temp_file_iocb_ptr, temp_seg_ptrs (2), max_seg_size, (0),
      847 				code);
      848 			     if code ^= 0
      849 			     then call error (code, "Reading crossreference for attribute list record: " || key);
      850 
      851 			     pcx_attribute_name = temp_seg_ptr -> crossref_info_record.object (pcx_domain_loop);
      852 			     end;
      853 
      854 /* finally get to print something out. if the count of attribute record is zero,
      855*   then the attribute isn't used in any relations. */
      856 			if temp_seg_ptrs (2) -> crossref_info_record.count = 0
      857 			then do;
      858 			     call ioa_$ioa_switch (iocb_ptr, "^[^20x^s^;^20a^]^1x^[^20x^s^;^20a^]^1x{Unreferenced}", 
      859 				pcx_domain_name = pcx_prev_domain_name, pcx_domain_name,
      860 				pcx_attribute_name = pcx_prev_attribute_name, pcx_attribute_name);
      861 
      862 			     pcx_prev_domain_name = pcx_domain_name;
      863 			     pcx_prev_attribute_name = pcx_attribute_name;
      864 			     printed_one_sw = "1"b;
      865 			     end;
      866 
      867 /* otherwise, display the xref line doing previous line name suppressions */
      868 			else do pcx_attribute_loop = 1 to temp_seg_ptrs (2) -> crossref_info_record.count;
      869 				call ioa_$ioa_switch (iocb_ptr, "^[^20x^s^;^20a^]^1x^[^20x^s^;^20a^]^1x^20a",
      870 				     pcx_domain_name = pcx_prev_domain_name, pcx_domain_name,
      871 				     pcx_attribute_name = pcx_prev_attribute_name, pcx_attribute_name,
      872 				     temp_seg_ptrs (2) -> crossref_info_record.object (pcx_attribute_loop));
      873 
      874 				pcx_prev_domain_name = pcx_domain_name;
      875 				pcx_prev_attribute_name = pcx_attribute_name;
      876 				printed_one_sw = "1"b;
      877 
      878 				end;		/* do pcx_attribute_loop */
      879 			end;			/* do pcx_domain_loop */
      880 		     end;
      881 		end;
      882 
      883 /* the first file iocb should now be positioned to the next sequential record
      884*   as a byproduct of reading the domain record. try to read the current
      885*   record. */
      886 	     if code = 0
      887 	     then call iox_$read_key (temp_file_iocb_ptr, key, (0), code);
      888 
      889 	     end;					/* do while code = 0 */
      890 
      891 /* done reading all the domain records, or we encountered some kind of error
      892*   reading the crossreference file. */
      893 	if code ^= error_table_$end_of_info
      894 	then call error (code, "Reading crossreference file.");
      895 
      896 /* if we didn't print any lines, there must not have been any domains in the
      897*   crossreference file. */
      898 	if ^printed_one_sw
      899 	then call ioa_$ioa_switch (iocb_ptr, "^/No referenced domains exist for the database.");
      900 
      901 	return;
      902 
      903 /*
      904*   This internal subroutine attaches a second iocb to the same crossreference
      905*   file that was previously built. Note that it must be opened in -share mode
      906*   even though only the current process has the file opened.
      907**/
      908 
      909 attach_second_iocb:
      910      proc;
      911 
      912 dcl  asi_attach_desc char (256) varying;
      913 
      914 	asi_attach_desc = "vfile_ " || rtrim (mrds_dm_display_info.temp_dir_path);
      915 	asi_attach_desc = asi_attach_desc || ">";
      916 	asi_attach_desc = asi_attach_desc || temp_file_attach_name;
      917 	asi_attach_desc = asi_attach_desc || " -share";
      918 
      919 	call iox_$attach_name (unique_chars_ ("0"b), second_temp_file_iocb_ptr, (asi_attach_desc), null, code);
      920 	if code ^= 0
      921 	then call error (code, (asi_attach_desc));
      922 
      923 	call iox_$open (second_temp_file_iocb_ptr, Keyed_sequential_update, "0"b, code);
      924 	if code ^= 0
      925 	then call error (code, (asi_attach_desc));
      926 
      927 	return;
      928      end attach_second_iocb;
      929 
      930      end print_complete_xref;
      931 
      932 /*  * * * * * * * * * * * * * *      error     * * * * * * * * * * * * * *   */
      933 
      934 
      935 
      936 error:
      937      proc (err_code, err_message);			/* Error procedure  */
      938 
      939 dcl  err_code fixed bin (35);
      940 dcl  err_message char (*);
      941 
      942 
      943 	O_err_code = err_code;
      944 	O_err_msg = err_message;
      945 	call tidy_up;
      946 	goto exit;
      947 
      948      end error;
      949 
      950 
      951 
      952 
      953 
      954 /* * * * * * * * * * * * * * * *   tidy_up  * * * * * * * * * * * * * * *  */
      955 
      956 tidy_up:
      957      proc;
      958 
      959 	if second_temp_file_iocb_ptr ^= null
      960 	then do;
      961 	     call iox_$close (second_temp_file_iocb_ptr, (0));
      962 	     call iox_$detach_iocb (second_temp_file_iocb_ptr, (0));
      963 	     call iox_$destroy_iocb (second_temp_file_iocb_ptr, (0));
      964 	     second_temp_file_iocb_ptr = null;
      965 	     end;
      966 
      967 	if temp_seg_ptr ^= null
      968 	then call mu_temp_segments$free_all_temp_segments (myname, (0));
      969 
      970 	if fm_ptr ^= null
      971 	then call terminate_file_ (fm_ptr, 0, TERM_FILE_TERM, (0));
      972 
      973 	return;
      974      end tidy_up;
      975 
      976 /*    * * * * * * * *     get_path_entry      * * * * * * * * * *           */
      977 
      978 /* called by print_header, print_rel_info_long and print_domain */
      979 
      980 get_path_entry:
      981      procedure (path_ptr, separator) returns (char (256));
      982 
      983 dcl  path_ptr bit (18) unal parameter;			/* offset to struct in dbm_area */
      984 dcl  separator char (1) parameter;			/* either ">" or "$" */
      985 
      986 /* get the path - entry character string from the path_entry structure */
      987 
      988 	path_entry_ptr = pointer (dbm_ptr, path_ptr);
      989 
      990 	return (rtrim (path_entry.path) || separator || rtrim (path_entry.entry));
      991 
      992      end get_path_entry;
      993 
      994 
      995 /*    DECLARATIONS    */
      996 
      997 dcl  1 rel_long aligned,				/* Structure for relation -long */
      998        2 l1 char (19) unal init ("
      999 RELATION NAME:   "),
     1000        2 rel_name char (32) unal,
     1001        2 l2 char (23) unal init ("
     1002 Number attributes:	 "),
     1003        2 nattrs pic "zzzzzz9" unal;
     1004 
     1005 
     1006 
     1007 dcl  1 header_1,					/* Data base header info */
     1008        2 lf0 char (1) unal init ("
     1009 "),
     1010        2 l1 char (22) unal init ("Version:"),
     1011        2 version_num pic "zz9" unal,
     1012        2 lf1 char (1) unal init ("
     1013 "),
     1014        2 l2 char (21) unal init ("Created by: "),
     1015        2 creator char (32) unal,
     1016        2 lf2 char (1) unal init ("
     1017 "),
     1018        2 l3 char (21) unal init ("Created on: "),
     1019        2 create_time char (24) unal,
     1020        2 lf3 char (1) unal init ("
     1021 ");
     1022 
     1023 
     1024 dcl  1 header_2,					/*  second part of header */
     1025        2 l1 char (21) unal init ("Changed by: "),
     1026        2 changer char (32) unal,
     1027        2 lf1 char (1) unal init ("
     1028 "),
     1029        2 l2 char (21) unal init ("Changed on: "),
     1030        2 change_time char (24) unal,
     1031        2 lf2 char (1) unal init ("
     1032 ");
     1033 
     1034 dcl  1 header_3,					/* third part of header */
     1035        2 lf0 char (1) unal init ("
     1036 "),
     1037        2 l1 char (21) unal init ("Total Domains: "),
     1038        2 num_domains pic "zzz9" unal,
     1039        2 lf1 char (1) unal init ("
     1040 "),
     1041        2 l2 char (21) unal init ("Total Attributes: "),
     1042        2 num_attrs pic "zzz9" unal,
     1043        2 lf2 char (1) unal init ("
     1044 "),
     1045        2 l3 char (21) unal init ("Total Relations: "),
     1046        2 num_rels pic "zzz9" unal,
     1047        2 lf3 char (1) unal init ("
     1048 ");
     1049 dcl  1 seek_head_info,
     1050        2 relation_type fixed bin init (0),		/* head = search_key */
     1051        2 n fixed bin,
     1052        2 search_key char (256);
     1053 
     1054 dcl  addr builtin;
     1055 dcl  BOF int static options (constant) init (-1);
     1056 dcl  cleanup condition;
     1057 dcl  code fixed bin (35);
     1058 dcl  date_time_ entry (fixed bin (71), char (*));
     1059 dcl  dcl_trimmed char (80);
     1060 dcl  desc_str char (120) varying;
     1061 dcl  err_msg char (256);
     1062 dcl  error_message char (500);
     1063 dcl  error_table_$end_of_info fixed bin (35) ext static;
     1064 dcl  error_table_$long_record fixed bin(35) ext static;
     1065 dcl  error_table_$no_record fixed bin (35) ext static;
     1066 dcl  error_table_$unimplemented_version fixed bin (35) ext static;
     1067 dcl  file_model_name char (32);
     1068 dcl  fixed builtin;
     1069 dcl  i fixed bin;
     1070 dcl  indx char (5);
     1071 dcl  initiate_file_ entry (char (*), char (*), bit (*), ptr, fixed bin (24), fixed bin (35));
     1072 dcl  ioa_$ioa_switch entry () options (variable);
     1073 dcl  ioa_$ioa_switch_nnl entry () options (variable);
     1074 dcl  iocb_ptr ptr;
     1075 dcl  iox_$attach_name entry (char (*), ptr, char (*), ptr, fixed bin (35));
     1076 dcl  iox_$close entry (ptr, fixed bin (35));
     1077 dcl  iox_$control entry (ptr, char (*), ptr, fixed bin (35));
     1078 dcl  iox_$destroy_iocb entry (ptr, fixed bin (35));
     1079 dcl  iox_$detach_iocb entry (ptr, fixed bin (35));
     1080 dcl  iox_$open entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
     1081 dcl  iox_$position entry (ptr, fixed bin, fixed bin (21), fixed bin (35));
     1082 dcl  iox_$put_chars entry (ptr, ptr, fixed bin (21), fixed bin (35));
     1083 dcl  iox_$read_key entry (ptr, char (256) var, fixed bin (21), fixed bin (35));
     1084 dcl  iox_$read_record entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
     1085 dcl  iox_$seek_key entry (ptr, char (256) var, fixed bin (21), fixed bin (35));
     1086 dcl  key char (256) varying;
     1087 dcl  length builtin;
     1088 dcl  long_desc_str char (120) varying;
     1089 dcl  max_seg_size fixed bin (21);
     1090 dcl  mdbm_util_$display_descriptor entry (ptr) returns (char (120) varying);
     1091 dcl  mdbm_util_$trim_descriptor entry (char (120) varying) returns (char (*));
     1092 dcl  mrds_dm_display_cmdb entry (ptr, char (*), fixed bin (35));
     1093 dcl  mrds_dm_display_history entry (ptr, char (*), fixed bin (35));
     1094 dcl  mrds_error_$no_model_attr fixed bin (35) ext static;
     1095 dcl  mrds_error_$no_model_dom fixed bin (35) ext static;
     1096 dcl  mrds_error_$no_model_rel fixed bin (35) ext static;
     1097 dcl  mu_db_xref$xref_build entry (char (*), char (*), ptr, char (*), ptr, char (*), fixed bin (35));
     1098 dcl  mu_db_xref$xref_statistics entry (ptr, fixed bin, fixed bin, fixed bin, char (*), fixed bin (35));
     1099 dcl  mu_temp_segments$free_all_temp_segments entry (char (*), fixed bin (35));
     1100 dcl  mu_temp_segments$get_temp_segment_path entry (char (*), char (*), ptr, fixed bin (35));
     1101 dcl  myname char (32) int static options (constant) init ("mrds_dm_display");
     1102 dcl  null builtin;
     1103 dcl  NULL_OFFSET int static bit (18) unal init ((18)"1"b) options (constant);
     1104 dcl  plural char (1) varying;
     1105 dcl  pointer builtin;
     1106 dcl  printed_one_sw bit (1);
     1107 dcl  ptr builtin;
     1108 dcl  rel builtin;
     1109 dcl  rtrim builtin;
     1110 dcl  second_temp_file_iocb_ptr ptr;
     1111 dcl  string builtin;
     1112 dcl  substr builtin;
     1113 dcl  sys_info$max_seg_size fixed bin (35) ext static;
     1114 dcl  temp_file_attach_name char (32);
     1115 dcl  temp_file_iocb_ptr ptr;
     1116 dcl  temp_seg_ptr ptr based (addr (temp_seg_ptrs (1)));
     1117 dcl  temp_seg_ptrs (2) ptr;
     1118 dcl  terminate_file_ entry (ptr, fixed bin (24), bit (*), fixed bin (35));
     1119 dcl  total_attributes fixed bin;
     1120 dcl  type char (4);
     1121 dcl  unique_chars_ entry (bit (*)) returns (char (15));
     1122 dcl  untrimmed_dcl char (120) varying;
     1123 
     1124 
  1     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
     1125 
     1126 
  2     1 /* Begin include file ..... iox_modes.incl.pl1 */
  2     2 
  2     3 /* Written by C. D. Tavares, 03/17/75 */
  2     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
  2     5 
  2     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
  2     7     ("stream_input", "stream_output", "stream_input_output",
  2     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
  2     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
  2    10      "direct_input", "direct_output", "direct_update");
  2    11 
  2    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
  2    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
  2    14 
  2    15 dcl (Stream_input initial (1),
  2    16      Stream_output initial (2),
  2    17      Stream_input_output initial (3),
  2    18      Sequential_input initial (4),
  2    19      Sequential_output initial (5),
  2    20      Sequential_input_output initial (6),
  2    21      Sequential_update initial (7),
  2    22      Keyed_sequential_input initial (8),
  2    23      Keyed_sequential_output initial (9),
  2    24      Keyed_sequential_update initial (10),
  2    25      Direct_input initial (11),
  2    26      Direct_output initial (12),
  2    27      Direct_update initial (13)) fixed bin int static options (constant);
  2    28 
  2    29 /* End include file ..... iox_modes.incl.pl1 */
     1127 
     1128 
  3     1 /*  BEGIN INCLUDE  mrds_dm_display_info.incl.pl1       */
  3     2 
  3     3 
  3     4 
  3     5 /****^  HISTORY COMMENTS:
  3     6*  1) change(85-12-07,Spitzer), approve(85-12-07,MCR7311),
  3     7*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  3     8*     Add flag fields for unreferenced objects and crossrefs.
  3     9*                                                   END HISTORY COMMENTS */
  3    10 
  3    11 
  3    12 dcl 1 mrds_dm_display_info aligned based (mrds_dm_display_info_ptr),
  3    13     2 version fixed bin,
  3    14     2 output_iocb_ptr ptr,				/* Output iocb pointer */
  3    15     2 db_path char (168) unal,			/* Absolute pathname of the database */
  3    16     2 temp_dir_path char (168) unal,			/* Absolute pathname of temp dir */
  3    17     2 work_area_ptr ptr,				/* Pointer to freeing area */
  3    18     2 dbm_ptr ptr,					/* Pointer to the db_model of the database */
  3    19     2 sw,						/* Control switches */
  3    20       3 default bit (1) unal,				/* Neither -long or -brief */
  3    21       3 long bit (1) unal,				/* On = long mode */
  3    22       3 cmdb bit (1) unal,				/* On = cmdb type output */
  3    23       3 names_only bit (1) unal,			/* Only the name for either relation, attribute, domain, index
  3    24*						   name_list is pointer to by mrds_dm_display_info.name_list_ptr */
  3    25       3 domains bit (1) unal,				/* Domain info only */
  3    26       3 attribute bit (1) unal,			/* Attibute info only */
  3    27       3 relation bit (1) unal,			/* Relation info only */
  3    28       3 index bit (1) unal,				/* Index relation info only */
  3    29       3 history bit (1) unal,				/* On = list history */
  3    30       3 header bit (1) unal,				/* On = display header */
  3    31       3 unreferenced_domains bit (1) unal,		/* On = display only unreferenced domains */
  3    32       3 unreferenced_attributes bit (1) unal,		/* On = display only unreferenced attributes */
  3    33       3 domain_xref bit (1) unal,			/* On = display a domain crossreference */
  3    34       3 attribute_xref bit (1) unal,			/* On = display an attribute crossreference */
  3    35       3 all_xref bit (1) unal,			/* On = display a complete crossreference */
  3    36       3 mbz bit (21) unal,				/* Unnused  must be zeros */
  3    37 						/* The following  are pointer to name list like
  3    38*						   name_list  structure below */
  3    39 
  3    40     2 dom_name_list_ptr ptr,				/* Pointer to domain name list */
  3    41     2 attr_name_list_ptr ptr,				/* Pointer to attribute name list */
  3    42     2 rel_name_list_ptr ptr,				/* Pointer to relation name list */
  3    43     2 index_name_list_ptr ptr,			/* Pointer to index rel name list */
  3    44 
  3    45     2 xref_iocb_ptr ptr,				/* Pointer to database xref */
  3    46     2 xref_name char (32) unaligned;			/* Name of xref file created */
  3    47 
  3    48 dcl 1 name_list aligned based (name_list_ptr),		/* General name list */
  3    49     2 num_names fixed bin,				/* Number of names in list */
  3    50     2 name (num_names_alloc refer (name_list.num_names)) char (32);
  3    51 
  3    52 dcl  mrds_dm_display_info_ptr pointer;
  3    53 dcl  name_list_ptr pointer;
  3    54 dcl  MRDS_DM_DISPLAY_INFO_VERSION_1 int static options (constant) init (1);
  3    55 dcl  num_names_alloc fixed bin;
  3    56 
  3    57 /*  END INCLUDE  mrds_dm_display_info.incl.pl1       */
     1129 
     1130 
  4     1 /* BEGIN INCLUDE FILE mdbm_db_model.incl.pl1 -- jaw, 10/2/78 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(79-02-01,Gray), approve(), audit(), install():
  4     6*     modified to save space occupied by model
  4     7*  2) change(80-11-03,Gray), approve(), audit(), install():
  4     8*     to add mdbm_secured bit in db_model
  4     9*  3) change(82-04-09,Davids), approve(), audit(), install():
  4    10*     collapsed the following into an unused_offset array:
  4    11*       chng_before_path_ptr  chng_err_path_ptr  chng_after_path_ptr
  4    12*       copy_before_path_ptr  copy_err_path_ptr  copy_after_path_ptr
  4    13*       dsply_before_path_pt  dsply_err_path_pt  dsply_after_path_ptr
  4    14*       accs_before_path_ptr  accs_err_path_ptr  accs_after_path_ptr
  4    15*       unused_1
  4    16*     Also changed the name of unused_2 to restructuring_history_offset
  4    17*     and changed the comment on the changer structure to indicate
  4    18*     that it will contain on database creation information.
  4    19*  4) change(82-04-14,Davids), approve(), audit(), install():
  4    20*     used one of the unused_offsets to point to a message which indicates
  4    21*     why the db is inconsistent. The offset will be null when the db is created
  4    22*     and set the first time the message is used. this is so it will be
  4    23*     consistent with existing data bases. Also added the message structure.
  4    24*  5) change(82-04-28,Davids), approve(), audit(), install():
  4    25*     added the undo_request element to the message structure
  4    26*  6) change(82-05-04,Davids), approve(), audit(), install():
  4    27*     changed unused_offset (12) to last_restructruring_history_offset and
  4    28*     changed restructuring_history_offset to first_restructuring_history_offset
  4    29*  7) change(82-08-19,Davids), approve(), audit(), install():
  4    30*     changed the meaning of db_type from 1 => relational and 2 => CODASYL to
  4    31*     1 => vfile database and 2 => page_file database. Up to this point all
  4    32*     database types were equal to 1.
  4    33*  8) change(83-02-14,Davids), approve(), audit(), install():
  4    34*     changed db_type from a fixed bin unal to a substructure of 18 bit (1) unal
  4    35*     flags. This will allow information about transactions and dm_file
  4    36*     concurrency to be independent of the db_type, i.e. vfile or dm_file. The
  4    37*     change is compatable with all datamodels created by the released version
  4    38*     of mrds.
  4    39*  9) change(83-02-15,Davids), approve(), audit(), install():
  4    40*     added the rollback_on flag to the db_type_flags since it appears that you
  4    41*     can have a dmfile database that requires transactions but does not have any
  4    42*     journalizing. Also switched the order of the transactions_needed and
  4    43*     concurrency_on flags - this makes the change compatable with existing
  4    44*     dmfile databases except when displaying the model since concurrency_on and
  4    45*     rollback_on will be off in the model even though the dmfile relations had
  4    46*     them on during creation.
  4    47* 10) change(83-02-22,Kubicar), approve(), audit(), install():
  4    48*      Removed ctl_file_path_ptr.
  4    49* 11) change(85-11-08,Spitzer), approve(85-12-03,MCR7311),
  4    50*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  4    51*      used 1 unused offset for unreferenced attribute linked lists in db_model,
  4    52*      1 unused bit flag in domain_info to indicate an unreferenced domain, 1 bit
  4    53*      in the flag word for rmdb copying.
  4    54*                                                   END HISTORY COMMENTS */
  4    55 
  4    56 
  4    57 /* this include file contains the structures that go into the make up
  4    58*   of the "db_model" segment in the model for the database.
  4    59*   in addition there file_model.m segments, 1 for each database file(see mdbm_file_model.incl.pl1)
  4    60*
  4    61*   the db_model structure goes at the base of the segment, and contains items unique to
  4    62*   the whole databse. in addition, it has an area of size to fill the
  4    63*   rest of a segment, that holds the lists of files and domains in the database.
  4    64*   these lists are singly forward linked lists. all "pointers" in the database model
  4    65*   are maintained as offsets(bit (18)) from the base of the particular model segment
  4    66*   since actual pointers are process dependent on segment number.
  4    67*   the remaining structures are first a path_entry one to save pathnames in,
  4    68*   and the stack_item and constent structures, used to save a boolean
  4    69*   expression in polish form, with the stack represented by a linked list.
  4    70*   the final structure is one for identifying the status of version information */
  4    71 
  4    72      dcl	   1 db_model	      aligned based (dbm_ptr),/* base of db_model segment, allocated once per database */
  4    73 	     2 version	      unal fixed bin,	/* data base version, currently 4 */
  4    74 	     2 db_type_flags      unal,
  4    75 	       3 copy_good	      bit (1) unal,		/* "1"b => copy of the db_model is the valid copy */
  4    76 	       3 unused	      (13) bit (1) unal,
  4    77 	       3 rollback_on      bit (1) unal,		/* "1"b => before journaling is to be done */
  4    78 	       3 concurrency_on   bit (1) unal,		/* "1"b => dm_file concurrency is being used */
  4    79 	       3 transactions_needed bit (1) unal,	/* "1"b => transactions are needed to reference data */
  4    80 	       3 vfile_type	      bit (1) unal,		/* "1"b => vfile type relations, "0"b => dm_file type relations */
  4    81 	     2 uniq_sw_name	      char (32),		/* per database unique attach switch name for files */
  4    82 	     2 consistant	      bit (1) unal,		/* ON => correctly created/restructured database, ok to open */
  4    83 	     2 mdbm_secured	      bit (1) unal,		/* on => database has been secured */
  4    84 	     2 reserved	      bit (34) unal,	/* reserved for flags */
  4    85 	     2 blk_file_id_len    unal fixed bin,	/* no. bits required for blocked file id. */
  4    86 	     2 unblk_file_id_len  unal fixed bin,	/* number of file id bits, unblocked file */
  4    87 	     2 num_blk_files      unal fixed bin,	/* number of blocked files defined in db */
  4    88 	     2 num_unblk_files    unal fixed bin,	/* number of unblocked files defined in db */
  4    89 	     2 num_rels	      unal fixed bin,	/* number of relations defined in db. */
  4    90 	     2 num_domains	      unal fixed bin,	/* number of domains defined */
  4    91 	     2 num_dyn_links      unal fixed bin,	/* no. dynamic links defined */
  4    92 	     2 max_max_tuples     unal fixed bin (35),	/* maximum max_tuples across all files */
  4    93 	     2 pad_1	      unal fixed bin (35),	/* for future use */
  4    94 	     2 pad_2	      unal fixed bin (35),	/* for future use */
  4    95 	     2 version_ptr	      bit (18),		/* offset to version structure */
  4    96 	     2 file_ptr	      unal bit (18),	/* offset to first in threaded list of file_infos */
  4    97 	     2 domain_ptr	      unal bit (18),	/* offset to first in list of domain_infos */
  4    98 	     2 unreferenced_attribute_ptr unal bit (18),	/* offset to first in list of unreferenced attr_infos */
  4    99 	     2 unused_offsets     (11) unal bit (18),	/* extra offsets if needed */
  4   100 	     2 last_restructuring_history_offset unal bit (18), /* offset to last restructuring history entry */
  4   101 	     2 inconsistent_message_offset unal bit (18), /* offset to message indicating why db is inconsistent */
  4   102 	     2 first_restructuring_history_offset unal bit (18), /* offset to first restructuring history entry */
  4   103 	     2 changer_ptr	      unal bit (18),	/* offset to information about db creation */
  4   104 	     2 dbm_area	      area (sys_info$max_seg_size - fixed (rel (addr (db_model.dbm_area))) - 1);
  4   105 
  4   106      dcl	   dbm_ptr	      ptr;
  4   107 
  4   108 /* the files in the database each have a file_info containing
  4   109*   their name, the file_model for each file is found by initiating the
  4   110*   segment "file_name.m" (i.e. the file's name with suffix ".m")
  4   111*   the file_info list is a singly linked list in definition order */
  4   112 
  4   113      dcl	   1 file_info	      aligned based (fi_ptr), /* list of file names and numbers */
  4   114 	     2 file_name	      char (30),		/* name of file */
  4   115 	     2 file_id	      bit (36),		/* id number of file */
  4   116 	     2 fwd_ptr	      unal bit (18),	/* thread to next in list */
  4   117 	     2 unused	      unal bit (18);	/* for future expansion */
  4   118 
  4   119      dcl	   fi_ptr		      ptr;
  4   120 
  4   121 /* each domain used in the database will have a domain info saved in the db_model
  4   122*   segment. it describes the domain of the given name, and it's options.
  4   123*   the domain_info's form a singly linked list in definition order */
  4   124 
  4   125      dcl	   1 domain_info	      aligned based (di_ptr), /* one for each domain defined */
  4   126 	     2 name	      char (32),		/* name of domain */
  4   127 	     2 db_desc_is_ptr     bit (1) unal,		/* on if descriptor is pointer to real desc. */
  4   128 	     2 user_desc_is_ptr   bit (1) unal,		/* on if user desc is ptr */
  4   129 	     2 no_conversion      bit (1) unal,		/* if no conversion allowed */
  4   130 	     2 procedures_present bit (1) unal,		/* on => ids type procedures present */
  4   131 	     2 unreferenced	      bit (1) unal,		/* on => this domain is not used in any attribute */
  4   132 	     2 reserved	      bit (31) unal,
  4   133 	     2 db_desc	      bit (36),		/* desc. for item in db, or ptr to it */
  4   134 	     2 user_desc	      bit (36),		/* desc. for user-visible attr, or ptr */
  4   135 	     2 ave_len	      fixed bin (35),	/* average length of  varying string */
  4   136 	     2 nck_items	      unal fixed bin,	/* no. items in check stack */
  4   137 	     2 fwd_thread	      unal bit (18),	/* offset to next in list */
  4   138 	     2 check_path_ptr     unal bit (18),	/* integ. check proc. */
  4   139 	     2 ck_stack_ptr	      unal bit (18),	/* to check stack */
  4   140 	     2 encd_path_ptr      unal bit (18),	/* encode procedure */
  4   141 	     2 decd_path_ptr      unal bit (18),	/* decode procedure */
  4   142 	     2 str_before_path_ptr unal bit (18),	/* proc paths and entries */
  4   143 	     2 str_err_path_ptr   unal bit (18),
  4   144 	     2 str_after_path_ptr unal bit (18),
  4   145 	     2 get_before_path_ptr unal bit (18),
  4   146 	     2 get_err_path_ptr   unal bit (18),
  4   147 	     2 get_after_path_ptr unal bit (18),
  4   148 	     2 mod_before_path_ptr unal bit (18),
  4   149 	     2 mod_err_path_ptr   unal bit (18),
  4   150 	     2 mod_after_path_ptr unal bit (18),
  4   151 	     2 unused_1	      unal bit (18),	/* for future expansion */
  4   152 	     2 unused_2	      unal bit (18),
  4   153 	     2 changer_ptr	      unal bit (18);	/* pointer to change_id and chane_time structure */
  4   154 
  4   155      dcl	   di_ptr		      ptr;
  4   156 
  4   157 /* information necessary for attributes that are not used in any relation */
  4   158 
  4   159      dcl     1 unreferenced_attribute aligned based (ua_ptr),
  4   160 	     2 name char (32),			/* name of attribute */
  4   161 	     2 domain_ptr bit (18) unal,		/* to domain_info */
  4   162 	     2 fwd_thread bit (18) unal,		/* to next in list */
  4   163 	     2 unused (2) bit (18) unal;
  4   164 
  4   165      dcl     ua_ptr ptr;
  4   166 
  4   167 
  4   168 /* space saving pathname$entryname structure, to be allocated
  4   169*   only when a path$entry has to be saved, else only a bit(18)
  4   170*   offset takes up space in the main model structure */
  4   171 
  4   172      declare 1 path_entry	      based (path_entry_ptr),
  4   173 	     2 path	      char (168),		/* pathname portion of desired path$entry */
  4   174 	     2 entry	      char (32),		/* entryname portion of desired path$entry */
  4   175 	     2 reserved	      unal bit (36);	/* for future use */
  4   176 
  4   177      declare path_entry_ptr	      ptr;
  4   178 
  4   179 
  4   180 
  4   181 
  4   182 
  4   183 /* declarations for model of postfix stack holding the check option boolean expression
  4   184*   the following encoding values indicate the corresponding type of stack element
  4   185*
  4   186*   1  =
  4   187*   2  ^=
  4   188*   3  >
  4   189*   4  <
  4   190*   5  >=
  4   191*   6  <=
  4   192*
  4   193*   10  and
  4   194*   20  or
  4   195*   30  not
  4   196*
  4   197*   40  - (minus)
  4   198*
  4   199*   50  domain variable(same name as domain)
  4   200*
  4   201*   60  constant(number, bit string, or character string)
  4   202*
  4   203**/
  4   204 
  4   205 
  4   206      declare 1 stack_item	      based (stack_item_ptr), /* element of stack model list */
  4   207 	     2 next	      bit (18),		/* link to next in list */
  4   208 	     2 type	      fixed binary,		/* code for this element type */
  4   209 	     2 value_ptr	      bit (18);		/* pointer to variable holding value,
  4   210*						   if this is a constant element type */
  4   211 
  4   212      declare stack_item_ptr	      ptr;		/* pointer to a stack element */
  4   213 
  4   214 
  4   215 
  4   216      declare 1 constant	      based (constant_ptr),	/* variable size space for constant's value storage */
  4   217 	     2 length	      fixed bin (35),	/* length allocated to hold value */
  4   218 	     2 value	      bit (alloc_length refer (constant.length)) aligned; /* value for this constant */
  4   219 
  4   220      declare constant_ptr	      ptr;		/* pointer to constant's value space */
  4   221 
  4   222      declare alloc_length	      fixed binary (35) internal static; /* amount of space to allocate for constant's value */
  4   223 
  4   224 /* version structure, giving status of source for CMDB/RMDB,
  4   225*   status of model, and status of resultant */
  4   226 
  4   227 /* version number is in form MM.N.Y
  4   228*   where MM is the major version number, N is the minor version alteration,
  4   229*   and Y is the lastest modification to that alteration,
  4   230*   where M and N represent numbers 0-9, and Y is a letter */
  4   231 
  4   232      declare 1 version_status	      unal based (version_status_ptr),
  4   233 	     2 cmdb_rmdb,
  4   234 	       3 major	      fixed bin,
  4   235 	       3 minor	      fixed bin,
  4   236 	       3 modification     char (4),
  4   237 	     2 model,
  4   238 	       3 major	      fixed bin,
  4   239 	       3 minor	      fixed bin,
  4   240 	       3 modification     char (4),
  4   241 	     2 resultant,
  4   242 	       3 major	      fixed bin,
  4   243 	       3 minor	      fixed bin,
  4   244 	       3 modification     char (4);
  4   245 
  4   246      declare version_status_ptr     ptr;
  4   247 
  4   248 
  4   249 /* maintains information only about the db creation */
  4   250 
  4   251      declare 1 changer	      unal based (changer_ptr),
  4   252 	     2 id		      char (32),
  4   253 	     2 time	      fixed bin (71),
  4   254 	     2 next	      bit (18);		/* to next in the singly linked list */
  4   255 
  4   256      declare changer_ptr	      ptr;
  4   257 
  4   258 
  4   259      dcl	   01 message_str	      unal based (message_str_ptr), /* general purpose structure to hold messages */
  4   260 	     02 len	      fixed bin,		/* length of the message */
  4   261 	     02 text	      char (message_str_len refer (message_str.len)), /* actual message */
  4   262 	     02 name	      char (32),		/* name of thing that set the message */
  4   263 	     02 undo_request      char (100),		/* rmdb request that will undo the operation
  4   264*                                                               that caused the database to become inconsistent */
  4   265 	     02 mbz	      bit (36);		/* for possible extensions, like an offset to another message */
  4   266 
  4   267      dcl	   message_str_ptr	      ptr;		/* pointer to the message_str structure */
  4   268 
  4   269      dcl	   message_str_len	      fixed bin;		/* initail length of the text string in message_str */
  4   270 
  4   271 /* END INCLUDE FILE mdbm_db_model.incl.pl1 */
  4   272 
  4   273 
     1131 
     1132 
  5     1 /* BEGIN INCLUDE FILE mdbm_file_model.incl.pl1 -- jaw, 8/29/78 */
  5     2 
  5     3 
  5     4 /****^  HISTORY COMMENTS:
  5     5*  1) change(79-02-01,JGray), approve(), audit(), install():
  5     6*     modified to save space occupied by model
  5     7*  2) change(82-05-19,Davids), approve(), audit(), install():
  5     8*     renamed rel_info.nsec_inds to rel_info.unused_3 because it really wasn't
  5     9*     the number of secondary indices in the relation - it was always zero.
  5    10*  3) change(82-08-19,DWoodka), approve(), audit(), install():
  5    11*     changed rel_info.id and attr_info.index_id to bit (36) unaligned for the
  5    12*     DMS conversion.
  5    13*  4) change(82-09-20,MKubicar), approve(), audit(), install():
  5    14*     changed rel_info.id and attr_info.index_id to aligned; they are needed that
  5    15*     way for relmgr_ calls.  Also added rel_info.primary_key_index_id, needed
  5    16*     for relation manager changes.
  5    17*  5) change(85-12-02,Spitzer), approve(85-12-02,MCR7311),
  5    18*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  5    19*     used 2 reserved bits to indicate whether the copy of the <rel>.m and/or
  5    20*     <rel> files are good (for rmdb)
  5    21*                                                   END HISTORY COMMENTS */
  5    22 
  5    23 
  5    24 /* each file in the database will have a model segment with the name
  5    25*   file_name.m (i.e. the files name plus a suffix of ".m")
  5    26*   the file_model structure is allocated at the base of the segment for a given file.
  5    27*   it contains an area with which all other structures in this include file are allocated.
  5    28*   these structures contain the information about which relations, foreign keys,
  5    29*   and attributes are members of this file. all lists are singly linked lists in
  5    30*   definition order. pointers to these structures are obtained by using the "pointer"
  5    31*   builtin function with arguments of the segment base pointer, and the
  5    32*   offset (bit (18)) relative to that pointer that is actually stored in
  5    33*   the file model itself. this is because pointer segment numbers are
  5    34*   per process dependent. the major lists pointed to by the file_model structure
  5    35*   are the list of relations in this file(each with a contained attribute list),
  5    36*   and the list of foreign keys whose parent relation resides in this file
  5    37*   (along with a participating attribute sublist, and the child relation list,
  5    38*   if they are also in this file) */
  5    39 
  5    40 dcl 1 file_model aligned based (fm_ptr),		/* base of segment */
  5    41     2 temporary bit (1) unal,				/* on if file not part of db. */
  5    42     2 procedures_present bit (1) unal,			/* on => ids procedures present */
  5    43     2 file_model_copy_good bit (1) unaligned,		/* on => <rel>.m file is the good copy */
  5    44     2 relation_copy_good bit (1) unaligned,		/* on => <rel> file is the good copy */
  5    45     2 reserved bit (32) unal,				/* reserved for future flags */
  5    46     2 max_tuples fixed bin (35),			/* max no. of tuples in file */
  5    47     2 num_blocks fixed bin (35),			/* number of blocks in file */
  5    48     2 num_buckets fixed bin (35),			/* number of buckets in file */
  5    49     2 pad_1 fixed bin (35),				/* for future use */
  5    50     2 pad_2 fixed bin (35),
  5    51     2 ratd_len fixed bin (21),			/* length of above */
  5    52     2 mratd_len fixed bin (21),			/* length of above */
  5    53     2 uatd_len fixed bin (21),			/* char. length of update attach desc. */
  5    54     2 latd_len fixed bin (21),			/* char. len. of attach desc. */
  5    55     2 sratd_len fixed bin (21),			/* char. length of above attach desc. */
  5    56     2 suatd_len fixed bin (21),			/* char. length of attach desc. */
  5    57     2 file_type unal fixed bin,			/* 1 => unblocked, 2 => blocked */
  5    58     2 block_size unal fixed bin,			/* no. pages in block */
  5    59     2 block_factor unal fixed bin,			/* no. tuple slots per block */
  5    60     2 bucket_density unal fixed bin,			/* no. of bucket headers per block, neg. => blocks per header */
  5    61     2 tuple_id_len unal fixed bin,			/* no. bits needed for local tuple id */
  5    62     2 num_rels unal fixed bin,			/* number of relations in file */
  5    63     2 num_links unal fixed bin,			/* number of links in file */
  5    64     2 num_children unal fixed bin,			/* count of all child_link_infos in this file */
  5    65     2 default_rbs (3) unal fixed bin (8),		/* file ring brackets when not MDBM-secured */
  5    66     2 rel_ptr unal bit (18),				/* to first of list of rel_infos */
  5    67     2 link_ptr unal bit (18),				/* to first in list of parent link_infos */
  5    68     2 children_ptr unal bit (18),			/* to list of all child_link_infos in this file model */
  5    69     2 cno_array_ptr unal bit (18),			/* pointer to array of data component numbers */
  5    70     2 fi_ptr unal bit (18),				/* offset to file_info in db_model */
  5    71     2 suatd_ptr unal bit (18),			/* offset of scope_update attach desc. */
  5    72     2 sratd_ptr unal bit (18),			/* offset of scope_retrieve attach desc. */
  5    73     2 latd_ptr unal bit (18),				/* offset of load attach desc. */
  5    74     2 uatd_ptr unal bit (18),				/* offset of update attach description for file */
  5    75     2 mratd_ptr unal bit (18),			/* offset of moniter-retrieve attach desc. */
  5    76     2 ratd_ptr unal bit (18),				/* offset of retrieve attach desc. */
  5    77     2 open_eu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  5    78     2 open_eu_err_path_ptr unal bit (18),
  5    79     2 open_eu_after_path_ptr unal bit (18),
  5    80     2 open_er_before_path_ptr unal bit (18),
  5    81     2 open_er_err_path_ptr unal bit (18),
  5    82     2 open_er_after_path_ptr unal bit (18),
  5    83     2 open_neu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  5    84     2 open_neu_err_path_ptr unal bit (18),
  5    85     2 open_neu_after_path_ptr unal bit (18),
  5    86     2 open_ner_before_path_ptr unal bit (18),
  5    87     2 open_ner_err_path_ptr unal bit (18),
  5    88     2 open_ner_after_path_ptr unal bit (18),
  5    89     2 open_pu_before_path_ptr unal bit (18),
  5    90     2 open_pu_err_path_ptr unal bit (18),
  5    91     2 open_pu_after_path_ptr unal bit (18),
  5    92     2 open_pr_before_path_ptr unal bit (18),
  5    93     2 open_pr_err_path_ptr unal bit (18),
  5    94     2 open_pr_after_path_ptr unal bit (18),
  5    95     2 open_cu_before_path_ptr unal bit (18),
  5    96     2 open_cu_err_path_ptr unal bit (18),
  5    97     2 open_cu_after_path_ptr unal bit (18),
  5    98     2 open_cr_before_path_ptr unal bit (18),
  5    99     2 open_cr_err_path_ptr unal bit (18),
  5   100     2 open_cr_after_path_ptr unal bit (18),
  5   101     2 close_before_path_ptr unal bit (18),
  5   102     2 close_err_path_ptr unal bit (18),
  5   103     2 close_after_path_ptr unal bit (18),
  5   104     2 unused_1 unal bit (18),				/* for future expansion */
  5   105     2 unused_2 unal bit (18),
  5   106     2 changer_ptr unal bit (18),			/* pointer to changer_id, changer_time structure */
  5   107     2 fm_area area (sys_info$max_seg_size - fixed (rel (addr (file_model.fm_area))) - 1);
  5   108 dcl  fm_ptr ptr;
  5   109 dcl  atd char (atd_len) based (atd_ptr);		/* attach description for each file ready mode */
  5   110 dcl  atd_ptr ptr;
  5   111 dcl  atd_len fixed bin;
  5   112 dcl 1 comp_no_array unal based (cna_ptr),		/* ordered array of data comp. nos. */
  5   113     2 ncomponents fixed bin,
  5   114     2 comp_no (ncomp_init refer (comp_no_array.ncomponents)) fixed bin;
  5   115 dcl  cna_ptr ptr;
  5   116 dcl  ncomp_init fixed bin;
  5   117 
  5   118 /* a rel_info structure contains information describing a relation.
  5   119*   a relation may only occur in one file, thus there is one rel_info
  5   120*   per relation per database, each stored in the file_model area for
  5   121*   the file that contains it. the list of rel_info's in this file
  5   122*   form a singly linked list in definition order.
  5   123*   the rel_info itself points to a list of the attributes it contains,
  5   124*   and to any parent_link or child_link info's that involve it in a foreign key */
  5   125 
  5   126 dcl 1 rel_info aligned based (ri_ptr),
  5   127     2 name char (32),				/* relation name */
  5   128     2 id  bit (36) aligned,				/* relation id number */
  5   129     2 hashed bit (1) unal,				/* on if hashed */
  5   130     2 duplicates bit (1) unal,			/* on if allow dup. hash fields */
  5   131     2 via_link bit (1) unal,				/* on if to be stored by parent */
  5   132     2 system bit (1) unal,				/* on if dont care how stored */
  5   133     2 indexed bit (1) unal,				/* on if secondary index */
  5   134     2 mrds_update bit (1) unal,			/* on if updateable by MRDS */
  5   135     2 mrds_retrieve bit (1) unal,			/* on if retrievable by MRDS */
  5   136     2 virtual bit (1) unal,				/* if virtual relation, mapped on IDS records */
  5   137     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  5   138     2 reserved bit (27) unal,				/* for future flags */
  5   139     2 num_attr unal fixed bin,			/* number of attributes (all levels) defined */
  5   140     2 num_links_child unal fixed bin,			/* no. links in which child */
  5   141     2 num_links_par unal fixed bin,			/* no. links_in which parent */
  5   142     2 max_attr_index_id unal fixed bin,			/* max index id used by attr in this rel or PLI */
  5   143     2 num_key_attrs unal fixed bin,			/* number of attributes in primary key for this rel */
  5   144     2 nvar_atts unal fixed bin,			/* no. varying len. attributes */
  5   145     2 n36_thds unal fixed bin,			/* no. of 36-bit threads */
  5   146     2 n27_thds unal fixed bin,			/* no of 27-bit threads */
  5   147     2 n18_thds unal fixed bin,			/* no of 18-bit threads */
  5   148     2 unused_3 unal fixed bin,			/* element that was never used */
  5   149     2 max_data_len fixed bin (35),			/* max length of data portion of tuple */
  5   150     2 avg_data_len fixed bin (35),			/* average length of tuple data portion */
  5   151     2 max_key_len fixed bin (35),			/* max key length if not hashed */
  5   152     2 var_offset fixed bin (35),			/* position of first varying attr. */
  5   153     2 max_tuples fixed bin (35),			/* max no. tuples if blocked file */
  5   154     2 fwd_thread unal bit (18),			/* offsset to next rel. in file */
  5   155     2 attr_ptr unal bit (18),				/* to attr. info */
  5   156     2 primary_key_index_id bit (36) aligned,		/* index id of the relation's primary key */
  5   157     2 clink_ptr unal bit (18),			/* offset to child info of link determining location */
  5   158     2 map_ptr unal bit (18),				/* pointer to mapping info if virtual rel. */
  5   159     2 sec_ind_ptr unal bit (18),			/* ptr to list of sec. ind. infos, init. not used */
  5   160     2 locator_proc_path_ptr unal bit (18),		/* proc to determ. location */
  5   161     2 link_before_path_ptr unal bit (18),		/* op. proc. paths and entries */
  5   162     2 link_err_path_ptr unal bit (18),
  5   163     2 link_after_path_ptr unal bit (18),
  5   164     2 unlk_before_path_ptr unal bit (18),
  5   165     2 unlk_err_path_ptr unal bit (18),
  5   166     2 unlk_after_path_ptr unal bit (18),
  5   167     2 str_before_path_ptr unal bit (18),
  5   168     2 str_err_path_ptr unal bit (18),
  5   169     2 str_after_path_ptr unal bit (18),
  5   170     2 del_before_path_ptr unal bit (18),
  5   171     2 del_err_path_ptr unal bit (18),
  5   172     2 del_after_path_ptr unal bit (18),
  5   173     2 mod_before_path_ptr unal bit (18),
  5   174     2 mod_err_path_ptr unal bit (18),
  5   175     2 mod_after_path_ptr unal bit (18),
  5   176     2 find_before_path_ptr unal bit (18),
  5   177     2 find_err_path_ptr unal bit (18),
  5   178     2 find_after_path_ptr unal bit (18),
  5   179     2 retr_before_path_ptr unal bit (18),
  5   180     2 retr_err_path_ptr unal bit (18),
  5   181     2 retr_after_path_ptr unal bit (18),
  5   182     2 unused_1 unal bit (18),				/* for future expansion */
  5   183     2 unused_2 unal bit (18),
  5   184     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  5   185 dcl  ri_ptr ptr;
  5   186 
  5   187 /* a attr_info structure contains information about an attribute in a given relation.
  5   188*   since attributes may appear in more than one relation, each occurence of an attribute
  5   189*   means that an attr_info for it will be put in that relations sublist of attributes.
  5   190*   the list is singly linked in definition order. the attr_info describes
  5   191*   the data it represents, and how that data is used during a database search. */
  5   192 dcl 1 attr_info aligned based (ai_ptr),			/* info for a single attr. in attr. list */
  5   193     2 name char (32),				/* name of attribute */
  5   194     2 key_attr bit (1) unal,				/* on if part of primary or hash key */
  5   195     2 index_attr bit (1) unal,			/* on if a secondary index */
  5   196     2 link_attr bit (1) unal,				/* on if participates in link */
  5   197     2 reserved bit (33) unal,
  5   198     2 index_id bit (36) aligned,			/* id of index if index attr. */
  5   199     2 defn_order unal fixed bin,			/* relative posit. in which defined */
  5   200     2 key_order unal fixed bin,			/* relative posit. in key */
  5   201     2 bit_offset fixed bin (35),			/* position in tuple */
  5   202     2 bit_length fixed bin (35),			/* length if fixed */
  5   203     2 link_child_cnt fixed bin,			/* number of uses of attr in child rel of link */
  5   204     2 link_par_cnt fixed bin,				/* number of uses of attr in parent rel of link */
  5   205     2 domain_ptr unal bit (18),			/* to domain info */
  5   206     2 rslt_ptr unal bit (18),				/* ptr to info for "result" clause */
  5   207     2 fwd_thread unal bit (18),			/* to next in list */
  5   208     2 changer_ptr unal bit (18) ;			/* pointer to changer_id and changer_time */
  5   209 dcl  ai_ptr ptr;
  5   210 
  5   211 /* a parent_link_info structure is the carrier of foreign key definition info.
  5   212*   each time a foreign key definition indicates a relation as it's parent,
  5   213*   that relation will get a parent_link_info put in a list of associated parent_link_info's.
  5   214*   a relation can be parent and/or child in any number of foreign keys.
  5   215*   the parent_link_info structure describes the foreign key, and also points
  5   216*   to a list of the attributes that participate in this foreign key.
  5   217*   (this could be from 1 up to all attributes in the relation)
  5   218*   the attr_list structures are in a singly linked list in definition order
  5   219*   for this purpose. also pointed to is a list of child_link_info's
  5   220*   that describe the child relations in this foreign key. since foreign keys
  5   221*   may span files, not all related child_link_info's have to be in this file's
  5   222*   model area. */
  5   223 dcl 1 parent_link_info aligned based (pli_ptr),		/* gen'l link info, appears in each area spanned by link parent */
  5   224     2 name char (32),				/* name of link */
  5   225     2 singular bit (1) unal,				/* on if system owned link */
  5   226     2 temp bit (1) unal,				/* on if temp. order */
  5   227     2 first bit (1) unal,				/* insertion indicators */
  5   228     2 last bit (1) unal,
  5   229     2 next bit (1) unal,
  5   230     2 prior bit (1) unal,
  5   231     2 sort_rel_name bit (1) unal,			/* sort -- relation name */
  5   232     2 sort_keys bit (1) unal,				/* sort -- defined keys */
  5   233     2 dup_first bit (1) unal,				/* duplicates first */
  5   234     2 dup_last bit (1) unal,				/* duplicates last */
  5   235     2 indexed bit (1) unal,				/* locate parent via index */
  5   236     2 hashed bit (1) unal,				/* locate parent via hashed primary key */
  5   237     2 thread_36 bit (1) unal,				/* thread size indicators */
  5   238     2 thread_27 bit (1) unal,
  5   239     2 thread_18 bit (1) unal,
  5   240     2 clustered bit (1) unal,				/* ON => cluster option specified for this link */
  5   241     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  5   242     2 reserved bit (19) unal,				/* reserved for future flags */
  5   243     2 index_id aligned bit (8),			/* id of index if indexed */
  5   244     2 thread_index unal fixed bin,			/* index to threads in parent */
  5   245     2 nsel_attr unal fixed bin,			/* no. attr. determ. parent */
  5   246     2 n_children unal fixed bin,			/* no. children in link */
  5   247     2 child_fn char (30),				/* file name for first child in list */
  5   248     2 parent_ptr unal bit (18),			/* to parent relation info in file model */
  5   249     2 child_ptr unal bit (18),			/* to list of child info ptrs */
  5   250     2 sel_attr_ptr unal bit (18),			/* to first in list of attr. determ. parent */
  5   251     2 fwd_thread unal bit (18),			/* thread to next parent link info in file */
  5   252     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  5   253     2 sort_before_path_ptr unal bit (18),		/* proc. paths and entries */
  5   254     2 sort_err_path_ptr unal bit (18),
  5   255     2 sort_after_path_ptr unal bit (18),
  5   256     2 srch_before_path_ptr unal bit (18),
  5   257     2 srch_err_path_ptr unal bit (18),
  5   258     2 srch_after_path_ptr unal bit (18),
  5   259     2 link_before_path_ptr unal bit (18),
  5   260     2 link_err_path_ptr unal bit (18),
  5   261     2 link_after_path_ptr unal bit (18),
  5   262     2 unlk_before_path_ptr unal bit (18),
  5   263     2 unlk_err_path_ptr unal bit (18),
  5   264     2 unlk_after_path_ptr unal bit (18),
  5   265     2 unused_1 unal bit (18),				/* for future expansion */
  5   266     2 unused_2 unal bit (18),
  5   267     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  5   268 dcl  pli_ptr ptr;
  5   269 
  5   270 /* a child_link_info structure is the counter part of a parent_link_info
  5   271*   for foreign key child relations. each time a relation is defined to be
  5   272*   a child in a foreign key, it's list of child_link_infos will be added to.
  5   273*   this list is singly linked in foreign key definition order.
  5   274*   the child_link_info points to a list of participating attributes from the
  5   275*   child relation by means of a singly linked list of attr_list structures
  5   276*   in definition order. the number of attributes in the parent attr_list
  5   277*   and the child attr_list lists are the same with corresponding attr_list
  5   278*   attributes having the same domain. all child_link_infos in this file
  5   279*   are on a seperately linked list. this may not include all
  5   280*   child_link_infos for foreign keys whose parent relation resides in this file,
  5   281*   since foreign keys may span files, and the child_link_info will
  5   282*   reside in the file containing it's associated relation_info. */
  5   283 dcl 1 child_link_info aligned based (cli_ptr),		/* in same files as children */
  5   284     2 link_name char (32),				/* name of foreign key involving parent relation for this child */
  5   285     2 mandatory bit (1) unal,				/* on if membership mandatory */
  5   286     2 fixed bit (1) unal,				/* on if membership fixed */
  5   287     2 optional bit (1) unal,				/* on if membership optional */
  5   288     2 auto bit (1) unal,				/* on if insertion automatic */
  5   289     2 manual bit (1) unal,				/* on if insertion manual */
  5   290     2 struct_const bit (1) unal,			/* on if membership constrained by attr. comp. */
  5   291     2 range_sel bit (1) unal,				/* on if range type selection */
  5   292     2 key_dup_first bit (1) unal,			/* sort key flags */
  5   293     2 key_dup_last bit (1) unal,
  5   294     2 key_null bit (1) unal,				/* on if null allowed */
  5   295     2 sel_system bit (1) unal,			/* selection criteria flags */
  5   296     2 sel_current bit (1) unal,
  5   297     2 sel_key bit (1) unal,
  5   298     2 sel_proc bit (1) unal,
  5   299     2 no_null bit (1) unal,				/* if null key values not allowed */
  5   300     2 reserved bit (21) unal,
  5   301     2 thread_index unal fixed bin,			/* index to thread in tuple */
  5   302     2 chain_len unal fixed bin,			/* no. "then-thru's" in selction crit. */
  5   303     2 n_sort_keys unal fixed bin,			/* no. attr. in sort key */
  5   304     2 n_sel_items unal fixed bin,			/* no. items to sel for link sel. */
  5   305     2 n_dup_prevs unal fixed bin,			/* no. attr. for dup prev. */
  5   306     2 link_fwd_fn char (30),				/* file name for next child info in link */
  5   307     2 parent_fn char (30),				/* file name for parent info */
  5   308     2 parent_ptr unal bit (18),			/* offset to parent link info */
  5   309     2 link_fwd_thread unal bit (18),			/* offset for next child in link */
  5   310     2 rel_info_ptr unal bit (18),			/* to corresponding rel info */
  5   311     2 dup_prev_ptr unal bit (18),			/* list of attrs. for dup. prev. */
  5   312     2 sel_ptr unal bit (18),				/* list of attr. for link sel. */
  5   313     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  5   314     2 child_fwd_thread unal bit (18),			/* pointer to next in list of all child_link_infos in this file */
  5   315     2 sort_key_ptr unal bit (18),			/* list of sort keys */
  5   316     2 chain_ptr unal bit (18),			/* to "then thru" list */
  5   317     2 sel_proc_path_ptr unal bit (18),			/* link selection proc. */
  5   318     2 link_before_path_ptr unal bit (18),		/* proc. paths and entries */
  5   319     2 link_err_path_ptr unal bit (18),
  5   320     2 link_after_path_ptr unal bit (18),
  5   321     2 unlk_before_path_ptr unal bit (18),
  5   322     2 unlk_err_path_ptr unal bit (18),
  5   323     2 unlk_after_path_ptr unal bit (18),
  5   324     2 srch_before_path_ptr unal bit (18),
  5   325     2 srch_err_path_ptr unal bit (18),
  5   326     2 srch_after_path_ptr unal bit (18),
  5   327     2 unused_1 unal bit (18),				/* for future expansion */
  5   328     2 unused_2 unal bit (18) ;
  5   329 dcl  cli_ptr ptr;
  5   330 
  5   331 /* the attr_list structure is associated with the parent_link_info
  5   332*   and child_link_info structures to represent by means of a singly linked list
  5   333*   the participating attributes from relations in a foreign key.
  5   334*   the parent_link_info has a list for the parent relation,
  5   335*   and the child_link_info has a list for the child relation.
  5   336*   the participating attributes are a subset(not necessary proper) of
  5   337*   those attributes contained in a relation definition.
  5   338*   there are equal numbers of attr_list structures in the parent and
  5   339*   child lists of the same foreign key. the corresponding attributes in these
  5   340*   lists must have the same domain. */
  5   341 dcl 1 attr_list aligned based (al_ptr),			/* general attr. list */
  5   342     2 attr_fn char (30),				/* file name for attr. */
  5   343     2 attr_ptr unal bit (18),				/* to attr info block */
  5   344     2 fwd_thread unal bit (18);			/* to next in list */
  5   345 dcl  al_ptr ptr;
  5   346 dcl 1 sort_key aligned based (sk_ptr),			/* entry in sort key list */
  5   347     2 ascend bit (1) unal,				/* ascending order */
  5   348     2 descend bit (1) unal,				/* descending order */
  5   349     2 reserved bit (34) unal,
  5   350     2 attr_ptr unal bit (18),				/* to attr info */
  5   351     2 fwd_thread unal bit (18);			/* to next in list */
  5   352 dcl  sk_ptr ptr;
  5   353 dcl 1 dup_prev aligned based (dp_ptr),			/* dup. prevention list entry */
  5   354     2 attr_ptr unal bit (18),				/* to attr info */
  5   355     2 fwd_thread unal bit (18);			/* to next in list */
  5   356 dcl  dp_ptr ptr;
  5   357 dcl 1 select_chain aligned based (sc_ptr),		/* "then thru" list entry */
  5   358     2 link_fn char (30),				/* file name for thru link */
  5   359     2 link_ptr unal bit (18),				/* to parent link info */
  5   360     2 parent_attr_ptr unal bit (18),			/* to parent ident. attr. list */
  5   361     2 comp_proc_path_ptr unal bit (18),			/* comparison procedure */
  5   362     2 comp_attr_fn char (30),				/* file name for comparison attr. */
  5   363     2 comp_attr_ptr unal bit (18),			/* to comparison attr list */
  5   364     2 fwd_thread unal bit (18);			/* to next in chain */
  5   365 dcl  sc_ptr ptr;
  5   366 
  5   367 /* END INCLUDE FILE mdbm_file_model.incl.pl1 */
  5   368 
  5   369 
     1133 
     1134 
  6     1 /*  START OF:	rmdb_crossref_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6     2 
  6     3 /****^  HISTORY COMMENTS:
  6     4*  1) change(85-12-03,Spitzer), approve(85-12-03,MCR7311),
  6     5*     audit(86-09-15,Gilcrease), install(86-10-16,MR12.0-1187):
  6     6*     written.
  6     7*                                                   END HISTORY COMMENTS */
  6     8 
  6     9 /*DESCRIPTION
  6    10*  The following structures are the definition of the records with the keyed
  6    11*  vfile that is built during restructuring. This file serves as a crossreference
  6    12*  of unique attributes and domains used within the specified MRDS database. Each
  6    13*  object is a char (33); the first byte is set to an unprintable character so we
  6    14*  can use the index builtin to find a specific object.
  6    15**/
  6    16 
  6    17 dcl crossref_info_record_ptr ptr;
  6    18 dcl crossref_info_record_count fixed bin (21);
  6    19 dcl 1 crossref_info_record based (crossref_info_record_ptr),
  6    20      2 offset bit (18) unal,
  6    21      2 pad bit (18) unal,
  6    22      2 count fixed bin (21),
  6    23      2 entry (crossref_info_record_count refer (crossref_info_record.count)) unaligned,
  6    24       3 object_head char (1),
  6    25       3 object char (32);
  6    26 
  6    27 dcl crossref_info_record_objects char (33*crossref_info_record.count)
  6    28 			   based (addr (crossref_info_record.entry(1)));
  6    29 dcl OBJECT_HEAD char (1) int static options (constant) init (" ");
  6    30 
  6    31 dcl ATTRIBUTE_KEY_HEAD char (10) int static options (constant) init ("attribute:");
  6    32 dcl DOMAIN_KEY_HEAD char (7) int static options (constant) init ("domain:");
  6    33 dcl RELATION_KEY_HEAD char (9) int static options (constant) init ("relation:");
  6    34 
  6    35 /*DESCRIPTION
  6    36*  The following structures are used to contain sufficient crossreference
  6    37*  information for the delete_attribute and delete_domain requests. These
  6    38*  requests require a more complete view of a crossreference tree, associating
  6    39*  domains, attributes and relations in 2 directions.
  6    40**/
  6    41 
  6    42 dcl domain_list_ptr ptr;
  6    43 dcl domain_list_count fixed bin;
  6    44 dcl domain_list_names char (33*domain_list.count) based (addr (domain_list.name(1)));
  6    45 dcl 1 domain_list based (domain_list_ptr),
  6    46      2 count fixed bin,				/* number of domains in the list */
  6    47      2 name (domain_list_count refer (domain_list.count))
  6    48 	  char (33) unaligned,			/* name of this domain */
  6    49      2 attribute_list_ptr (domain_list_count refer (domain_list.count))
  6    50 		      ptr;			/* -> attribute_list structure */
  6    51 
  6    52 dcl attribute_list_ptr ptr;
  6    53 dcl attribute_list_count fixed bin;
  6    54 dcl attribute_list_names char (33*attribute_list.count) based (addr (attribute_list.name(1)));
  6    55 dcl 1 attribute_list based (attribute_list_ptr),
  6    56      2 count fixed bin,				/* number of attributes in the list */
  6    57      2 name (attribute_list_count refer (attribute_list.count))
  6    58 	  char (33) unaligned,			/* name of this attribute */
  6    59      2 domain_info_ptr (attribute_list_count refer (attribute_list.count))
  6    60 		   bit (18) unal,			/* offset in db_model of the domain_info structure for this attribute */
  6    61      2 attribute_ptr (attribute_list_count refer (attribute_list.count))
  6    62 		 ptr;				/* -> attribute structure */
  6    63 
  6    64 dcl relation_list_ptr ptr;
  6    65 dcl relation_list_count fixed bin;
  6    66 dcl relation_list_names char (33*relation_list.count) based (addr (relation_list.name (1)));
  6    67 dcl 1 relation_list based (relation_list_ptr),
  6    68      2 count fixed bin,				/* number of relations that are to be touched in this operation */
  6    69      2 name (relation_list_count refer (relation_list.count))
  6    70 	  char (33) unaligned,			/* name of this relation */
  6    71      2 relation_ptr (relation_list_count refer (relation_list.count))
  6    72 		ptr;				/* -> relation structure */
  6    73 
  6    74 dcl relation_ptr ptr;
  6    75 dcl relation_attribute_count fixed bin;
  6    76 dcl relation_attribute_names char (33*relation.attribute_count) based (addr (relation.attribute_names (1)));
  6    77 dcl 1 relation based (relation_ptr),
  6    78      2 name char (32),				/* name of the relation */
  6    79      2 file_model_ptr ptr,				/* -> relation.m segment */
  6    80      2 copy_file_model_ptr ptr,
  6    81      2 attribute_count fixed bin,			/* number of attributes defined for this relation */
  6    82      2 mbz fixed bin (35),
  6    83      2 attribute (relation_attribute_count refer (relation.attribute_count)),
  6    84       3 flags aligned,
  6    85         4 delete bit (1) unaligned,			/* ON: delete this attribute */
  6    86         4 new bit (1) unaligned,			/* ON: this attribute is added to the relation */
  6    87         4 part_of_key bit (1) unaligned,                    /* ON: this attribute is part of the primary key */
  6    88         4 to_be_deleted bit (1) unaligned,
  6    89         4 pad bit (32) unaligned,
  6    90       3 domain_info_ptr bit (18) aligned,		/* -> db_model domain_info structure */
  6    91       3 attribute_info_ptr ptr,			/* -> file_model attribute_info structure */
  6    92       3 value_ptr ptr,				/* if flags.new, this -> the value of the column to be stored */
  6    93 						/*   it must be of the correct data type as specified by the domain */
  6    94      2 attribute_names (relation_attribute_count refer (relation.attribute_count))
  6    95 		   char (33) unaligned;
  6    96 
  6    97 dcl attribute_ptr ptr;
  6    98 dcl attribute_count fixed bin;
  6    99 dcl 1 attribute based (attribute_ptr),
  6   100      2 count fixed bin,				/* number of relations this attribute is used in */
  6   101      2 relation_idx (attribute_count refer (attribute.count))
  6   102 		fixed bin;			/* index into list of relation names */
  6   103 
  6   104 /*  END OF:	rmdb_crossref_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1135 
     1136 
  7     1 /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
  7     2 /* format: style2,^inddcls,idind32 */
  7     3 
  7     4 declare 1 terminate_file_switches	based,
  7     5 	2 truncate		bit (1) unaligned,
  7     6 	2 set_bc			bit (1) unaligned,
  7     7 	2 terminate		bit (1) unaligned,
  7     8 	2 force_write		bit (1) unaligned,
  7     9 	2 delete			bit (1) unaligned;
  7    10 
  7    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
  7    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
  7    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
  7    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
  7    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
  7    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
  7    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
  7    18 
  7    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
     1137 
     1138 
     1139      end mrds_dm_display;
     1140 
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/00  1111.4  mrds_dm_display.pl1               >udd>sm>ds>w>ml>mrds_dm_display.pl1
1125         1    04/11/85  1552.6  access_mode_values.incl.pl1       >ldd>incl>access_mode_values.incl.pl1
1127         2    02/02/78  1329.7  iox_modes.incl.pl1                >ldd>incl>iox_modes.incl.pl1
1129         3    10/17/86  1504.5  mrds_dm_display_info.incl.pl1     >ldd>incl>mrds_dm_display_info.incl.pl1
1131         4    10/17/86  1504.3  mdbm_db_model.incl.pl1            >ldd>incl>mdbm_db_model.incl.pl1
1133         5    10/17/86  1504.5  mdbm_file_model.incl.pl1          >ldd>incl>mdbm_file_model.incl.pl1
1135         6    10/17/86  1504.6  rmdb_crossref_info.incl.pl1       >ldd>incl>rmdb_crossref_info.incl.pl1
1137         7    04/06/83  1339.4  terminate_file.incl.pl1           >ldd>incl>terminate_file.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ATTRIBUTE_KEY_HEAD              000004 constant        char(10)                 initial packed unaligned dcl 6-31 set ref 106* 439
                                                                                  440 449 449 453 453 463 463 478 836
BOF                             000017 constant        fixed bin(17,0)          initial dcl 1055 set ref 420* 715* 783*
DOMAIN_KEY_HEAD                 000002 constant        char(7)                  initial packed unaligned dcl 6-32 set ref 101* 791
                                                                                  792 821 821 827
I_mrds_dm_display_info_ptr             parameter       pointer                  dcl 42 ref 9 50
Keyed_sequential_update         000042 constant        fixed bin(17,0)          initial dcl 2-15 set ref 923*
MRDS_DM_DISPLAY_INFO_VERSION_1         constant        fixed bin(17,0)          initial dcl 3-54 ref 65
NULL_OFFSET                     012556 constant        bit(18)                  initial packed unaligned dcl 1103 ref 158 208 266
                                                                                  286 290 294 312 330 351 382 386 390 408 424 567
                                                                                  593 617 668 680
O_err_code                             parameter       fixed bin(35,0)          dcl 43 set ref 9 53* 943*
O_err_msg                              parameter       char                     packed unaligned dcl 44 set ref 9 52* 944*
R_ACCESS                        000072 constant        bit(3)                   initial packed unaligned dcl 1-11 set ref 175* 545*
                                                                                  599*
TERM_FILE_TERM                  000000 constant        bit(3)                   initial packed unaligned dcl 7-14 set ref 190* 576*
                                                                                  628* 970*
addr                                                   builtin function         dcl 1054 ref 234 234 254 254 284 284 298 298 371 371
                                                                                  394 394 442 442 458 462 486 489 525 676 676 684
                                                                                  684 696 696 722 722 740 743 745 746 794 794 824
                                                                                  832 836 838 851 967
ai_ptr                          001222 automatic       pointer                  dcl 5-209 set ref 208* 208* 215 218 226 230 234 234
                                                                                  239* 243 266* 266* 269 273 277 280* 304 567* 567*
                                                                                  570 570* 572 617* 617* 620 620* 622
all_xref                134(14)        based           bit(1)                   level 3 packed packed unaligned dcl 3-12 ref 111
asi_attach_desc                 001456 automatic       varying char(256)        dcl 912 set ref 914* 915* 915 916* 916 917* 917 919
                                                                                  920 924
attr_info                              based           structure                level 1 dcl 5-192
attr_name_list_ptr      140            based           pointer                  level 2 dcl 3-12 ref 424 477 478 480 483 491
attr_ptr                 24(18)        based           bit(18)                  level 2 packed packed unaligned dcl 5-126 ref 208
                                                                                  266 567 617
attribute               134(05)        based           bit(1)                   level 3 packed packed unaligned dcl 3-12 ref 86
attribute_xref          134(13)        based           bit(1)                   level 3 packed packed unaligned dcl 3-12 ref 106
change_time              22(27) 000165 automatic       char(24)                 level 2 packed packed unaligned dcl 1024 set ref
                                                                                  683*
changer                   5(09) 000165 automatic       char(32)                 level 2 in structure "header_2" packed packed
                                                                                  unaligned dcl 1024 in procedure "mrds_dm_display"
                                                                                  set ref 682*
changer                                based           structure                level 1 packed packed unaligned dcl 4-251
                                                                                  in procedure "mrds_dm_display"
changer_ptr                     001214 automatic       pointer                  dcl 4-256 in procedure "mrds_dm_display" set ref
                                                                                  665* 668 669* 669 672 674
changer_ptr              32(18)        based           bit(18)                  level 2 in structure "db_model" packed packed
                                                                                  unaligned dcl 4-72 in procedure "mrds_dm_display"
                                                                                  ref 665 680 682 683
check_path_ptr           15            based           bit(18)                  level 2 packed packed unaligned dcl 4-125 set ref
                                                                                  286 286* 286* 382 382* 382*
cleanup                         000344 stack reference condition                dcl 1056 ref 63
cmdb                    134(02)        based           bit(1)                   level 3 packed packed unaligned dcl 3-12 ref 76
code                            000352 automatic       fixed bin(35,0)          dcl 1057 set ref 76* 116* 175* 254* 255 255* 420*
                                                                                  421 421* 442* 443 443* 446 448* 449 455* 458* 460
                                                                                  460 466* 468* 470* 473 473* 479* 480 486* 487 487
                                                                                  493* 495* 515* 517 517* 525* 526 526* 545* 599*
                                                                                  600* 639* 640 640* 676* 677 677* 684* 685 685*
                                                                                  696* 697 697* 715* 716 716* 722* 723 723 729* 735*
                                                                                  736 740* 741 753* 756* 759 759* 783* 784 784* 794*
                                                                                  795 795 801* 803* 805 805* 819* 820 821* 824* 825
                                                                                  837* 838 838 844* 846* 848 848* 886 886* 893 893*
                                                                                  919* 920 920* 923* 924 924*
concurrency_on            0(33)        based           bit(1)                   level 3 packed packed unaligned dcl 4-72 set ref
                                                                                  654*
count                     1            based           fixed bin(21,0)          level 2 dcl 6-19 set ref 743 745 832 838 841* 856
                                                                                  868
create_time              31(18) 000125 automatic       char(24)                 level 2 packed packed unaligned dcl 1007 set ref
                                                                                  674*
creator                  14     000125 automatic       char(32)                 level 2 packed packed unaligned dcl 1007 set ref
                                                                                  672*
crossref_info_record                   based           structure                level 1 unaligned dcl 6-19
date_time_                      000010 constant        entry                    external dcl 1058 ref 674 683
db_desc                  11            based           bit(36)                  level 2 dcl 4-125 set ref 284 284 298 371 371 394
db_model                               based           structure                level 1 dcl 4-72
db_path                   4            based           char(168)                level 2 packed packed unaligned dcl 3-12 set ref
                                                                                  154* 175* 314* 342* 410* 515* 545* 589* 599* 600
                                                                                  643* 647* 762*
db_type_flags             0(18)        based           structure                level 2 packed packed unaligned dcl 4-72
dbm_ptr                         001202 automatic       pointer                  dcl 4-106 in procedure "mrds_dm_display" set ref 58*
                                                                                  152 158 158 163 234 234 280 312 321 330 330 341
                                                                                  347 347 350 408 424 424 432 436 462 489 515* 587
                                                                                  593 593 629 643 649 652 654 660 663 665 665 669
                                                                                  680 680 682 682 683 683 690 694 988
dbm_ptr                 132            based           pointer                  level 2 in structure "mrds_dm_display_info" dcl 3-12
                                                                                  in procedure "mrds_dm_display" ref 58
dcl_trimmed                     000353 automatic       char(80)                 packed unaligned dcl 1059 set ref 237* 240*
decd_path_ptr            16(18)        based           bit(18)                  level 2 packed packed unaligned dcl 4-125 set ref
                                                                                  294 294* 294* 390 390* 390*
default                 134            based           bit(1)                   level 3 packed packed unaligned dcl 3-12 ref 184 211
desc_str                        000377 automatic       varying char(120)        dcl 1060 set ref 374* 375* 378* 379*
di_ptr                          001206 automatic       pointer                  dcl 4-155 set ref 280* 282 284 284 286 286 286 290
                                                                                  290 290 294 294 294 298 298 298 298 330* 330* 332
                                                                                  335* 341 347* 349 350* 350 351 357 371 371 375 379
                                                                                  382 382 382 386 386 386 390 390 390 394 394 394
                                                                                  394 432* 433 462* 463 489* 491
dom_name_list_ptr       136            based           pointer                  level 2 dcl 3-12 ref 327 346 349 351
domain_info                            based           structure                level 1 dcl 4-125
domain_ptr               22(18)        based           bit(18)                  level 2 in structure "db_model" packed packed
                                                                                  unaligned dcl 4-72 in procedure "mrds_dm_display"
                                                                                  ref 312 330 347
domain_ptr               17            based           bit(18)                  level 2 in structure "attr_info" packed packed
                                                                                  unaligned dcl 5-192 in procedure "mrds_dm_display"
                                                                                  ref 234 234 280
domain_ptr               10            based           bit(18)                  level 2 in structure "unreferenced_attribute" packed
                                                                                  packed unaligned dcl 4-159 in procedure
                                                                                  "mrds_dm_display" ref 432
domain_xref             134(12)        based           bit(1)                   level 3 packed packed unaligned dcl 3-12 ref 101
domains                 134(04)        based           bit(1)                   level 3 packed packed unaligned dcl 3-12 ref 81
encd_path_ptr            16            based           bit(18)                  level 2 packed packed unaligned dcl 4-125 set ref
                                                                                  290 290* 290* 386 386* 386*
entry                    52            based           char(32)                 level 2 in structure "path_entry" packed packed
                                                                                  unaligned dcl 4-172 in procedure "mrds_dm_display"
                                                                                  ref 990
entry                     2            based           structure                array level 2 in structure "crossref_info_record"
                                                                                  packed packed unaligned dcl 6-19 in procedure
                                                                                  "mrds_dm_display"
err_code                               parameter       fixed bin(35,0)          dcl 939 ref 936 943
err_message                            parameter       char                     packed unaligned dcl 940 ref 936 944
err_msg                         000436 automatic       char(256)                packed unaligned dcl 1061 set ref 76* 116*
error_message                   000536 automatic       char(500)                packed unaligned dcl 1062 set ref 515* 517* 639*
                                                                                  640*
error_table_$end_of_info        000012 external static fixed bin(35,0)          dcl 1063 ref 443 470 473 756 759 821 893
error_table_$long_record        000014 external static fixed bin(35,0)          dcl 1064 ref 460 487
error_table_$no_record          000016 external static fixed bin(35,0)          dcl 1065 ref 443 723 795 838
error_table_$unimplemented_version
                                000020 external static fixed bin(35,0)          dcl 1066 set ref 65*
fi_ptr                          001204 automatic       pointer                  dcl 4-119 set ref 158* 158* 161* 163 593* 593* 596*
                                                                                  629
file_info                              based           structure                level 1 dcl 4-113
file_model                             based           structure                level 1 dcl 5-40
file_model_name                 000733 automatic       char(32)                 packed unaligned dcl 1067 set ref 173* 175* 543*
                                                                                  545* 596* 599* 600
file_name                              based           char(30)                 level 2 dcl 4-113 ref 161 596
file_ptr                 22            based           bit(18)                  level 2 packed packed unaligned dcl 4-72 ref 158 593
fm_ptr                          001216 automatic       pointer                  dcl 5-108 set ref 62* 175* 176 179 179 190* 208 243
                                                                                  266 304 545* 546 549 549 567 572 576* 599* 600 603
                                                                                  603 617 622 628* 970 970*
fwd_ptr                  11            based           bit(18)                  level 2 packed packed unaligned dcl 4-113 ref 163
                                                                                  629
fwd_thread               14(18)        based           bit(18)                  level 2 in structure "domain_info" packed packed
                                                                                  unaligned dcl 4-125 in procedure "mrds_dm_display"
                                                                                  ref 341 350
fwd_thread               10(18)        based           bit(18)                  level 2 in structure "unreferenced_attribute" packed
                                                                                  packed unaligned dcl 4-159 in procedure
                                                                                  "mrds_dm_display" ref 436
fwd_thread               20            based           bit(18)                  level 2 in structure "attr_info" packed packed
                                                                                  unaligned dcl 5-192 in procedure "mrds_dm_display"
                                                                                  ref 243 304 572 622
header                  134(09)        based           bit(1)                   level 3 packed packed unaligned dcl 3-12 ref 71 405
header_1                        000125 automatic       structure                level 1 packed packed unaligned dcl 1007 set ref 676
                                                                                  676 676 676
header_2                        000165 automatic       structure                level 1 packed packed unaligned dcl 1024 set ref 684
                                                                                  684 684 684
header_3                        000216 automatic       structure                level 1 packed packed unaligned dcl 1034 set ref 696
                                                                                  696 696 696
history                 134(08)        based           bit(1)                   level 3 packed packed unaligned dcl 3-12 ref 116
i                               000743 automatic       fixed bin(17,0)          dcl 1069 set ref 135* 136* 176 346* 349 351* 477*
                                                                                  478 480 483 491* 541* 543 546 557 560*
id                                     based           char(32)                 level 2 packed packed unaligned dcl 4-251 ref 672
                                                                                  682
index                   134(07)        based           bit(1)                   level 3 packed packed unaligned dcl 3-12 ref 96
index_attr               10(01)        based           bit(1)                   level 2 packed packed unaligned dcl 5-192 ref 230
                                                                                  273 570 620
index_name_list_ptr     144            based           pointer                  level 2 dcl 3-12 ref 539 541 543 546 557 560
indexed                  11(04)        based           bit(1)                   level 2 packed packed unaligned dcl 5-126 ref 552
                                                                                  606
indx                            000744 automatic       char(5)                  packed unaligned dcl 1070 set ref 230* 232* 239*
                                                                                  273* 275* 278*
initiate_file_                  000022 constant        entry                    external dcl 1071 ref 175 545 599
ioa_$ioa_switch                 000024 constant        entry                    external dcl 1072 ref 131 140 154 181 201 215 218
                                                                                  222 239 240 277 278 282 302 314 318 324 335 342
                                                                                  357 363 398 410 413 416 429 433 453 463 483 491
                                                                                  499 536 552 557 560 564 570 579 589 609 612 615
                                                                                  620 643 647 651 652 654 657 660 700 726 732 746
                                                                                  762 788 798 858 869 898
ioa_$ioa_switch_nnl             000026 constant        entry                    external dcl 1073 ref 264 284 286 290 294 298 375
                                                                                  379 382 386 390 394 417
iocb_ptr                        000746 automatic       pointer                  dcl 1074 set ref 55* 131* 140* 154* 181* 201* 215*
                                                                                  218* 222* 239* 240* 254* 264* 277* 278* 282* 284*
                                                                                  286* 290* 294* 298* 302* 314* 318* 324* 335* 342*
                                                                                  357* 363* 375* 379* 382* 386* 390* 394* 398* 410*
                                                                                  413* 416* 417* 429* 433* 453* 463* 483* 491* 499*
                                                                                  536* 552* 557* 560* 564* 570* 579* 589* 609* 612*
                                                                                  615* 620* 643* 647* 651* 652* 654* 657* 660* 676*
                                                                                  684* 696* 700* 726* 732* 746* 762* 788* 798* 858*
                                                                                  869* 898*
iox_$attach_name                000030 constant        entry                    external dcl 1075 ref 919
iox_$close                      000032 constant        entry                    external dcl 1076 ref 961
iox_$control                    000034 constant        entry                    external dcl 1077 ref 442 722 794
iox_$destroy_iocb               000036 constant        entry                    external dcl 1078 ref 963
iox_$detach_iocb                000040 constant        entry                    external dcl 1079 ref 962
iox_$open                       000042 constant        entry                    external dcl 1080 ref 923
iox_$position                   000044 constant        entry                    external dcl 1081 ref 420 455 715 783
iox_$put_chars                  000046 constant        entry                    external dcl 1082 ref 254 676 684 696
iox_$read_key                   000050 constant        entry                    external dcl 1083 ref 448 735 753 819 886
iox_$read_record                000052 constant        entry                    external dcl 1084 ref 458 486 740 824 846
iox_$seek_key                   000054 constant        entry                    external dcl 1085 ref 479 837
key                             000750 automatic       varying char(256)        dcl 1086 set ref 448* 449 453 453 463 463 468 478*
                                                                                  479* 495 735* 737 739* 739 746* 753* 819* 821 827
                                                                                  836* 837* 844 848 886*
key_attr                 10            based           bit(1)                   level 2 packed packed unaligned dcl 5-192 ref 226
                                                                                  269
l1                              000100 automatic       char(19)                 initial level 2 in structure "rel_long" packed
                                                                                  packed unaligned dcl 997 in procedure
                                                                                  "mrds_dm_display" set ref 997*
l1                        0(09) 000216 automatic       char(21)                 initial level 2 in structure "header_3" packed
                                                                                  packed unaligned dcl 1034 in procedure
                                                                                  "mrds_dm_display" set ref 1034*
l1                        0(09) 000125 automatic       char(22)                 initial level 2 in structure "header_1" packed
                                                                                  packed unaligned dcl 1007 in procedure
                                                                                  "mrds_dm_display" set ref 1007*
l1                              000165 automatic       char(21)                 initial level 2 in structure "header_2" packed
                                                                                  packed unaligned dcl 1024 in procedure
                                                                                  "mrds_dm_display" set ref 1024*
l2                        6(27) 000125 automatic       char(21)                 initial level 2 in structure "header_1" packed
                                                                                  packed unaligned dcl 1007 in procedure
                                                                                  "mrds_dm_display" set ref 1007*
l2                        6(27) 000216 automatic       char(21)                 initial level 2 in structure "header_3" packed
                                                                                  packed unaligned dcl 1034 in procedure
                                                                                  "mrds_dm_display" set ref 1034*
l2                       14(27) 000100 automatic       char(23)                 initial level 2 in structure "rel_long" packed
                                                                                  packed unaligned dcl 997 in procedure
                                                                                  "mrds_dm_display" set ref 997*
l2                       15(18) 000165 automatic       char(21)                 initial level 2 in structure "header_2" packed
                                                                                  packed unaligned dcl 1024 in procedure
                                                                                  "mrds_dm_display" set ref 1024*
l3                       24(09) 000125 automatic       char(21)                 initial level 2 in structure "header_1" packed
                                                                                  packed unaligned dcl 1007 in procedure
                                                                                  "mrds_dm_display" set ref 1007*
l3                       15(09) 000216 automatic       char(21)                 initial level 2 in structure "header_3" packed
                                                                                  packed unaligned dcl 1034 in procedure
                                                                                  "mrds_dm_display" set ref 1034*
length                                                 builtin function         dcl 1087 ref 254 254 439 449 453 453 463 463 676 676
                                                                                  684 684 696 696 719 737 739 792 821 827
lf0                             000125 automatic       char(1)                  initial level 2 in structure "header_1" packed
                                                                                  packed unaligned dcl 1007 in procedure
                                                                                  "mrds_dm_display" set ref 1007*
lf0                             000216 automatic       char(1)                  initial level 2 in structure "header_3" packed
                                                                                  packed unaligned dcl 1034 in procedure
                                                                                  "mrds_dm_display" set ref 1034*
lf1                       6(18) 000125 automatic       char(1)                  initial level 2 in structure "header_1" packed
                                                                                  packed unaligned dcl 1007 in procedure
                                                                                  "mrds_dm_display" set ref 1007*
lf1                       6(18) 000216 automatic       char(1)                  initial level 2 in structure "header_3" packed
                                                                                  packed unaligned dcl 1034 in procedure
                                                                                  "mrds_dm_display" set ref 1034*
lf1                      15(09) 000165 automatic       char(1)                  initial level 2 in structure "header_2" packed
                                                                                  packed unaligned dcl 1024 in procedure
                                                                                  "mrds_dm_display" set ref 1024*
lf2                      30(27) 000165 automatic       char(1)                  initial level 2 in structure "header_2" packed
                                                                                  packed unaligned dcl 1024 in procedure
                                                                                  "mrds_dm_display" set ref 1024*
lf2                      24     000125 automatic       char(1)                  initial level 2 in structure "header_1" packed
                                                                                  packed unaligned dcl 1007 in procedure
                                                                                  "mrds_dm_display" set ref 1007*
lf2                      15     000216 automatic       char(1)                  initial level 2 in structure "header_3" packed
                                                                                  packed unaligned dcl 1034 in procedure
                                                                                  "mrds_dm_display" set ref 1034*
lf3                      37(18) 000125 automatic       char(1)                  initial level 2 in structure "header_1" packed
                                                                                  packed unaligned dcl 1007 in procedure
                                                                                  "mrds_dm_display" set ref 1007*
lf3                      23(18) 000216 automatic       char(1)                  initial level 2 in structure "header_3" packed
                                                                                  packed unaligned dcl 1034 in procedure
                                                                                  "mrds_dm_display" set ref 1034*
long                    134(01)        based           bit(1)                   level 3 packed packed unaligned dcl 3-12 ref 186 372
long_desc_str                   001051 automatic       varying char(120)        dcl 1088 set ref 371* 374 378*
max_seg_size                    001110 automatic       fixed bin(21,0)          dcl 1089 set ref 60* 740* 824* 846*
mdbm_secured             11(01)        based           bit(1)                   level 2 packed packed unaligned dcl 4-72 ref 660
mdbm_util_$display_descriptor   000056 constant        entry                    external dcl 1090 ref 234 284 298 371 394
mdbm_util_$trim_descriptor      000060 constant        entry                    external dcl 1091 ref 237 378
mrds_dm_display_cmdb            000062 constant        entry                    external dcl 1092 ref 76
mrds_dm_display_history         000064 constant        entry                    external dcl 1093 ref 116
mrds_dm_display_info                   based           structure                level 1 dcl 3-12
mrds_dm_display_info_ptr        001200 automatic       pointer                  dcl 3-52 set ref 50* 55 58 65 71 76 76* 81 86 91 96
                                                                                  101 106 111 116 116* 131 133 135 136 154 175 176
                                                                                  181 184 186 211 314 318 327 332 332 335 342 346
                                                                                  349 351 357 372 405 408 410 413 424 424 429 449
                                                                                  477 478 480 483 483 491 512 515 515 515 515 522
                                                                                  523 525 536 539 541 543 545 546 557 557 560 589
                                                                                  599 600 609 643 647 762 803 914
mrds_error_$no_model_attr       000066 external static fixed bin(35,0)          dcl 1094 set ref 480*
mrds_error_$no_model_dom        000070 external static fixed bin(35,0)          dcl 1095 set ref 351*
mrds_error_$no_model_rel        000072 external static fixed bin(35,0)          dcl 1096 set ref 176* 546*
mu_db_xref$xref_build           000074 constant        entry                    external dcl 1097 ref 515
mu_db_xref$xref_statistics      000076 constant        entry                    external dcl 1098 ref 639
mu_temp_segments$free_all_temp_segments
                                000100 constant        entry                    external dcl 1099 ref 967
mu_temp_segments$get_temp_segment_path
                                000102 constant        entry                    external dcl 1100 ref 525 803
myname                          000007 constant        char(32)                 initial packed unaligned dcl 1101 set ref 525* 803*
                                                                                  967*
n                         1     000242 automatic       fixed bin(17,0)          level 2 dcl 1049 set ref 439* 719* 792*
name                                   based           char(32)                 level 2 in structure "attr_info" dcl 5-192
                                                                                  in procedure "mrds_dm_display" set ref 215* 218*
                                                                                  239* 277* 570* 620*
name                                   based           char(32)                 level 2 in structure "domain_info" dcl 4-125
                                                                                  in procedure "mrds_dm_display" set ref 282* 335*
                                                                                  349 357* 375* 379* 433* 463* 491*
name                                   based           char(32)                 level 2 in structure "unreferenced_attribute"
                                                                                  dcl 4-159 in procedure "mrds_dm_display" set ref
                                                                                  429* 433*
name                                   based           char(32)                 level 2 in structure "rel_info" dcl 5-126
                                                                                  in procedure "mrds_dm_display" set ref 181* 201*
                                                                                  251 552* 609* 612*
name                      1            based           char(32)                 array level 2 in structure "name_list" dcl 3-48
                                                                                  in procedure "mrds_dm_display" set ref 136 176 349
                                                                                  351 478 480 483* 491* 543 546 557* 560*
name_list                              based           structure                level 1 dcl 3-48
names_only              134(03)        based           bit(1)                   level 3 packed packed unaligned dcl 3-12 ref 131 181
                                                                                  318 335 357 413 429 449 483 536 557 609
nattrs                   22(18) 000100 automatic       picture(7)               level 2 packed packed unaligned dcl 997 set ref 252*
next                     12            based           bit(18)                  level 2 packed packed unaligned dcl 4-251 ref 668
                                                                                  669 680
null                                                   builtin function         dcl 1102 ref 56 62 133 176 327 424 509 513 539 546
                                                                                  600 919 919 959 964 967 970
num_attr                 12            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 5-126 ref 202
                                                                                  252 259
num_attrs                14     000216 automatic       picture(4)               level 2 packed packed unaligned dcl 1034 set ref
                                                                                  692*
num_domains              14(18)        based           fixed bin(17,0)          level 2 in structure "db_model" packed packed
                                                                                  unaligned dcl 4-72 in procedure "mrds_dm_display"
                                                                                  ref 321 694
num_domains               5(18) 000216 automatic       picture(4)               level 2 in structure "header_3" packed packed
                                                                                  unaligned dcl 1034 in procedure "mrds_dm_display"
                                                                                  set ref 694*
num_names                              based           fixed bin(17,0)          level 2 dcl 3-48 ref 135 346 477 541
num_rels                 22(18) 000216 automatic       picture(4)               level 2 in structure "header_3" packed packed
                                                                                  unaligned dcl 1034 in procedure "mrds_dm_display"
                                                                                  set ref 690*
num_rels                 14            based           fixed bin(17,0)          level 2 in structure "db_model" packed packed
                                                                                  unaligned dcl 4-72 in procedure "mrds_dm_display"
                                                                                  ref 152 587 690
object                    2(09)        based           char(32)                 array level 3 packed packed unaligned dcl 6-19 set
                                                                                  ref 746* 836 851 869*
offset                                 based           bit(18)                  level 2 packed packed unaligned dcl 6-19 ref 462 489
output_iocb_ptr           2            based           pointer                  level 2 dcl 3-12 ref 55
par_object                      001254 automatic       char(30)                 packed unaligned dcl 150 set ref 161* 162*
path                                   based           char(168)                level 2 packed packed unaligned dcl 4-172 ref 990
path_entry                             based           structure                level 1 packed packed unaligned dcl 4-172
path_entry_ptr                  001212 automatic       pointer                  dcl 4-177 set ref 988* 990 990
path_ptr                               parameter       bit(18)                  packed unaligned dcl 983 ref 980 988
pcx_attribute_loop              001404 automatic       fixed bin(17,0)          dcl 773 set ref 868* 869*
pcx_attribute_name              001405 automatic       char(32)                 packed unaligned dcl 774 set ref 842* 851* 858 858*
                                                                                  863 869 869* 875
pcx_domain_loop                 001415 automatic       fixed bin(17,0)          dcl 775 set ref 832* 836 851*
pcx_domain_name                 001416 automatic       char(32)                 packed unaligned dcl 776 set ref 827* 842 858 858*
                                                                                  862 869 869* 874
pcx_prev_attribute_name         001426 automatic       char(32)                 packed unaligned dcl 777 set ref 808* 858 863* 869
                                                                                  875*
pcx_prev_domain_name            001436 automatic       char(32)                 packed unaligned dcl 778 set ref 808* 858 862* 869
                                                                                  874*
pii_object                      001234 automatic       char(32)                 packed unaligned dcl 129 set ref 136* 137*
plural                          001112 automatic       varying char(1)          dcl 1104 set ref 202* 204* 215 222 259* 261* 264
                                                                                  321* 323* 324
po_object_of_print                     parameter       char                     packed unaligned dcl 171 ref 168 173
pointer                                                builtin function         dcl 1105 ref 234 234 280 665 669 680 682 683 988
printed_one_sw                  001114 automatic       bit(1)                   packed unaligned dcl 1106 set ref 206* 211 216* 220
                                                                                  223* 329* 339* 342 731* 750* 762 787* 864* 876*
                                                                                  898
ptr                                                    builtin function         dcl 1107 ref 158 163 179 208 243 266 304 330 341 347
                                                                                  350 424 432 436 462 489 549 567 572 593 603 617
                                                                                  622 629
px_key_head                            parameter       char                     packed unaligned dcl 709 ref 706 719 720 737 737 739
px_loop                         001374 automatic       fixed bin(17,0)          dcl 710 set ref 745* 746 746*
px_type                                parameter       fixed bin(17,0)          dcl 711 ref 706 726 732 732 762
rel                                                    builtin function         dcl 1108 ref 158 208 266 330 351 424 567 593 617
rel_info                               based           structure                level 1 dcl 5-126
rel_long                        000100 automatic       structure                level 1 dcl 997 set ref 254 254 254 254
rel_name                  4(27) 000100 automatic       char(32)                 level 2 packed packed unaligned dcl 997 set ref 251*
rel_name_list_ptr       142            based           pointer                  level 2 dcl 3-12 ref 133 135 136 176
rel_ptr                  20(27)        based           bit(18)                  level 2 packed packed unaligned dcl 5-40 ref 179 549
                                                                                  603
relation                134(06)        based           bit(1)                   level 3 packed packed unaligned dcl 3-12 ref 91
relation_type                   000242 automatic       fixed bin(17,0)          initial level 2 dcl 1049 set ref 1049*
ri_ptr                          001220 automatic       pointer                  dcl 5-185 set ref 179* 181 201 202 208 251 252 259
                                                                                  266 549* 552 552 567 603* 606 609 612 617
rollback_on               0(32)        based           bit(1)                   level 3 packed packed unaligned dcl 4-72 set ref
                                                                                  652*
rtrim                                                  builtin function         dcl 1109 ref 173 176 351 478 480 543 546 596 600 914
                                                                                  990 990
search_key                2     000242 automatic       char(256)                level 2 packed packed unaligned dcl 1049 set ref
                                                                                  440* 720* 791*
second_temp_file_iocb_ptr       001116 automatic       pointer                  dcl 1110 set ref 56* 837* 846* 919* 923* 959 961*
                                                                                  962* 963* 964*
seek_head_info                  000242 automatic       structure                level 1 unaligned dcl 1049 set ref 442 442 722 722
                                                                                  794 794
separator                              parameter       char(1)                  packed unaligned dcl 984 ref 980 990
string                                                 builtin function         dcl 1111 ref 254 254 676 676 684 684 696 696
substr                                                 builtin function         dcl 1112 ref 449 453 453 463 463 737 739 821 827
sw                      134            based           structure                level 2 dcl 3-12
sys_info$max_seg_size           000104 external static fixed bin(35,0)          dcl 1113 ref 60
temp_dir_path            56            based           char(168)                level 2 packed packed unaligned dcl 3-12 set ref
                                                                                  515* 525* 803* 914
temp_file_attach_name           001120 automatic       char(32)                 packed unaligned dcl 1114 set ref 523* 916
temp_file_iocb_ptr              001130 automatic       pointer                  dcl 1115 set ref 56* 420* 442* 448* 455* 458* 479*
                                                                                  486* 509 512* 513 522* 639* 715* 722* 735* 740*
                                                                                  753* 783* 794* 819* 824* 886*
temp_seg_ptr                           based           pointer                  dcl 1116 set ref 458* 462 486* 489 525* 740* 743 745
                                                                                  746 824* 832 836 838 851 967
temp_seg_ptrs                   001132 automatic       pointer                  array dcl 1117 set ref 62* 458 462 486 489 525 740
                                                                                  743 745 746 803* 824 832 836 838 841 846* 851 856
                                                                                  868 869 967
terminate_file_                 000106 constant        entry                    external dcl 1118 ref 190 576 628 970
time                     10            based           fixed bin(71,0)          level 2 packed packed unaligned dcl 4-251 ref 674
                                                                                  683
total_attributes                001136 automatic       fixed bin(17,0)          dcl 1119 set ref 639* 692
transactions_needed       0(34)        based           bit(1)                   level 3 packed packed unaligned dcl 4-72 ref 649
type                            001137 automatic       char(4)                  packed unaligned dcl 1120 set ref 226* 228* 239*
                                                                                  269* 271* 278*
ua_ptr                          001210 automatic       pointer                  dcl 4-165 set ref 424* 424* 429 432 433* 436
unique_chars_                   000110 constant        entry                    external dcl 1121 ref 919 919
unreferenced             10(04)        based           bit(1)                   level 2 packed packed unaligned dcl 4-125 ref 332
unreferenced_attribute                 based           structure                level 1 dcl 4-159
unreferenced_attribute_ptr
                         23            based           bit(18)                  level 2 packed packed unaligned dcl 4-72 ref 408 424
unreferenced_attributes
                        134(11)        based           bit(1)                   level 3 packed packed unaligned dcl 3-12 ref 408 424
unreferenced_domains    134(10)        based           bit(1)                   level 3 packed packed unaligned dcl 3-12 ref 332 332
untrimmed_dcl                   001140 automatic       varying char(120)        dcl 1122 set ref 234* 237*
user_desc                12            based           bit(36)                  level 2 dcl 4-125 set ref 234 234 298 298 298 394
                                                                                  394 394
version                                based           fixed bin(17,0)          level 2 in structure "mrds_dm_display_info" dcl 3-12
                                                                                  in procedure "mrds_dm_display" ref 65
version                                based           fixed bin(17,0)          level 2 in structure "db_model" packed packed
                                                                                  unaligned dcl 4-72 in procedure "mrds_dm_display"
                                                                                  ref 663
version_num               5(27) 000125 automatic       picture(3)               level 2 packed packed unaligned dcl 1007 set ref
                                                                                  663*
vfile_type                0(35)        based           bit(1)                   level 3 packed packed unaligned dcl 4-72 ref 643
xref_iocb_ptr           146            based           pointer                  level 2 dcl 3-12 set ref 512 515* 522
xref_name               150            based           char(32)                 level 2 packed packed unaligned dcl 3-12 set ref
                                                                                  515* 523

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-33
Direct_input                           internal static fixed bin(17,0)          initial dcl 2-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 2-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 2-15
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 2-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 2-15
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
OBJECT_HEAD                            internal static char(1)                  initial packed unaligned dcl 6-29
RELATION_KEY_HEAD                      internal static char(9)                  initial packed unaligned dcl 6-33
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RW_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-30
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
Sequential_input                       internal static fixed bin(17,0)          initial dcl 2-15
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 2-15
Sequential_output                      internal static fixed bin(17,0)          initial dcl 2-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 2-15
Stream_input                           internal static fixed bin(17,0)          initial dcl 2-15
Stream_input_output                    internal static fixed bin(17,0)          initial dcl 2-15
Stream_output                          internal static fixed bin(17,0)          initial dcl 2-15
TERM_FILE_BC                           internal static bit(2)                   initial packed unaligned dcl 7-12
TERM_FILE_DELETE                       internal static bit(5)                   initial packed unaligned dcl 7-17
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial packed unaligned dcl 7-16
TERM_FILE_TRUNC                        internal static bit(1)                   initial packed unaligned dcl 7-11
TERM_FILE_TRUNC_BC                     internal static bit(2)                   initial packed unaligned dcl 7-13
TERM_FILE_TRUNC_BC_TERM                internal static bit(3)                   initial packed unaligned dcl 7-15
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
al_ptr                                 automatic       pointer                  dcl 5-345
alloc_length                           internal static fixed bin(35,0)          dcl 4-222
atd                                    based           char                     packed unaligned dcl 5-109
atd_len                                automatic       fixed bin(17,0)          dcl 5-111
atd_ptr                                automatic       pointer                  dcl 5-110
attr_list                              based           structure                level 1 dcl 5-341
attribute                              based           structure                level 1 unaligned dcl 6-99
attribute_count                        automatic       fixed bin(17,0)          dcl 6-98
attribute_list                         based           structure                level 1 unaligned dcl 6-55
attribute_list_count                   automatic       fixed bin(17,0)          dcl 6-53
attribute_list_names                   based           char                     packed unaligned dcl 6-54
attribute_list_ptr                     automatic       pointer                  dcl 6-52
attribute_ptr                          automatic       pointer                  dcl 6-97
child_link_info                        based           structure                level 1 dcl 5-283
cli_ptr                                automatic       pointer                  dcl 5-329
cna_ptr                                automatic       pointer                  dcl 5-115
comp_no_array                          based           structure                level 1 packed packed unaligned dcl 5-112
constant                               based           structure                level 1 unaligned dcl 4-216
constant_ptr                           automatic       pointer                  dcl 4-220
crossref_info_record_count             automatic       fixed bin(21,0)          dcl 6-18
crossref_info_record_objects           based           char                     packed unaligned dcl 6-27
crossref_info_record_ptr               automatic       pointer                  dcl 6-17
domain_list                            based           structure                level 1 unaligned dcl 6-45
domain_list_count                      automatic       fixed bin(17,0)          dcl 6-43
domain_list_names                      based           char                     packed unaligned dcl 6-44
domain_list_ptr                        automatic       pointer                  dcl 6-42
dp_ptr                                 automatic       pointer                  dcl 5-356
dup_prev                               based           structure                level 1 dcl 5-353
fixed                                                  builtin function         dcl 1068
iox_modes                              internal static char(24)                 initial array dcl 2-6
message_str                            based           structure                level 1 packed packed unaligned dcl 4-259
message_str_len                        automatic       fixed bin(17,0)          dcl 4-269
message_str_ptr                        automatic       pointer                  dcl 4-267
name_list_ptr                          automatic       pointer                  dcl 3-53
ncomp_init                             automatic       fixed bin(17,0)          dcl 5-116
num_names_alloc                        automatic       fixed bin(17,0)          dcl 3-55
parent_link_info                       based           structure                level 1 dcl 5-223
pli_ptr                                automatic       pointer                  dcl 5-268
relation                               based           structure                level 1 unaligned dcl 6-77
relation_attribute_count               automatic       fixed bin(17,0)          dcl 6-75
relation_attribute_names               based           char                     packed unaligned dcl 6-76
relation_list                          based           structure                level 1 unaligned dcl 6-67
relation_list_count                    automatic       fixed bin(17,0)          dcl 6-65
relation_list_names                    based           char                     packed unaligned dcl 6-66
relation_list_ptr                      automatic       pointer                  dcl 6-64
relation_ptr                           automatic       pointer                  dcl 6-74
sc_ptr                                 automatic       pointer                  dcl 5-365
select_chain                           based           structure                level 1 dcl 5-357
short_iox_modes                        internal static char(4)                  initial array dcl 2-12
sk_ptr                                 automatic       pointer                  dcl 5-352
sort_key                               based           structure                level 1 dcl 5-346
stack_item                             based           structure                level 1 unaligned dcl 4-206
stack_item_ptr                         automatic       pointer                  dcl 4-212
terminate_file_switches                based           structure                level 1 packed packed unaligned dcl 7-4
version_status                         based           structure                level 1 packed packed unaligned dcl 4-232
version_status_ptr                     automatic       pointer                  dcl 4-246

NAMES DECLARED BY EXPLICIT CONTEXT.
attach_second_iocb              011747 constant        entry                    internal dcl 909 ref 781
build_db_attr_list              005757 constant        entry                    internal dcl 506 ref 405 638 713 780
error                           012220 constant        entry                    internal dcl 936 ref 65 176 255 351 421 468 473 480
                                                                                  495 517 526 546 600 640 677 685 697 716 729 759
                                                                                  784 801 805 844 848 893 920 924
exit                            001456 constant        label                    dcl 121 ref 946
get_path_entry                  012414 constant        entry                    internal dcl 980 ref 286 286 290 290 294 294 382 382
                                                                                  386 386 390 390
mrds_dm_display                 001114 constant        entry                    external dcl 9
print_all_indexes               006654 constant        entry                    internal dcl 584 ref 539
print_all_relations             001557 constant        entry                    internal dcl 147 ref 133
print_attrib_info               004501 constant        entry                    internal dcl 402 ref 86
print_complete_xref             010707 constant        entry                    internal dcl 770 ref 111
print_domain                    004060 constant        entry                    internal dcl 368 ref 338 360
print_domain_info               003403 constant        entry                    internal dcl 310 ref 81
print_header                    007316 constant        entry                    internal dcl 634 ref 71
print_index_info                006130 constant        entry                    internal dcl 533 ref 96
print_object                    001642 constant        entry                    internal dcl 168 ref 137 162
print_rel_info                  001457 constant        entry                    internal dcl 126 ref 91
print_rel_info_brief            002132 constant        entry                    internal dcl 195 ref 188
print_rel_info_default          002130 constant        entry                    internal dcl 195 ref 184
print_rel_info_long             002555 constant        entry                    internal dcl 247 ref 186
print_xref                      010152 constant        entry                    internal dcl 706 ref 101 106
tidy_up                         012261 constant        entry                    internal dcl 956 ref 63 119 945

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     13220       13332   12563       13230
Length     14016   12563       112         450     435           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_dm_display                    1867 external procedure  is an external procedure.  
on unit on line 63                   64 on unit               
print_rel_info                          internal procedure  shares stack frame of external procedure mrds_dm_display.  
print_all_relations                     internal procedure  shares stack frame of external procedure mrds_dm_display.  
print_object                            internal procedure  shares stack frame of external procedure mrds_dm_display.  
print_rel_info_default                  internal procedure  shares stack frame of external procedure mrds_dm_display.  
print_rel_info_long                     internal procedure  shares stack frame of external procedure mrds_dm_display.  
print_domain_info                       internal procedure  shares stack frame of external procedure mrds_dm_display.  
print_domain                            internal procedure  shares stack frame of external procedure mrds_dm_display.  
print_attrib_info                       internal procedure  shares stack frame of external procedure mrds_dm_display.  
build_db_attr_list                      internal procedure  shares stack frame of external procedure mrds_dm_display.  
print_index_info                        internal procedure  shares stack frame of external procedure mrds_dm_display.  
print_all_indexes                       internal procedure  shares stack frame of external procedure mrds_dm_display.  
print_header                            internal procedure  shares stack frame of external procedure mrds_dm_display.  
print_xref                              internal procedure  shares stack frame of external procedure mrds_dm_display.  
print_complete_xref                     internal procedure  shares stack frame of external procedure mrds_dm_display.  
attach_second_iocb                      internal procedure  shares stack frame of external procedure mrds_dm_display.  
error                                65 internal procedure  is called during a stack extension.  
tidy_up                             100 internal procedure  is called by several nonquick procedures.  
get_path_entry                          internal procedure  shares stack frame of external procedure mrds_dm_display.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mrds_dm_display          000100 rel_long                    mrds_dm_display
                         000125 header_1                    mrds_dm_display
                         000165 header_2                    mrds_dm_display
                         000216 header_3                    mrds_dm_display
                         000242 seek_head_info              mrds_dm_display
                         000352 code                        mrds_dm_display
                         000353 dcl_trimmed                 mrds_dm_display
                         000377 desc_str                    mrds_dm_display
                         000436 err_msg                     mrds_dm_display
                         000536 error_message               mrds_dm_display
                         000733 file_model_name             mrds_dm_display
                         000743 i                           mrds_dm_display
                         000744 indx                        mrds_dm_display
                         000746 iocb_ptr                    mrds_dm_display
                         000750 key                         mrds_dm_display
                         001051 long_desc_str               mrds_dm_display
                         001110 max_seg_size                mrds_dm_display
                         001112 plural                      mrds_dm_display
                         001114 printed_one_sw              mrds_dm_display
                         001116 second_temp_file_iocb_ptr   mrds_dm_display
                         001120 temp_file_attach_name       mrds_dm_display
                         001130 temp_file_iocb_ptr          mrds_dm_display
                         001132 temp_seg_ptrs               mrds_dm_display
                         001136 total_attributes            mrds_dm_display
                         001137 type                        mrds_dm_display
                         001140 untrimmed_dcl               mrds_dm_display
                         001200 mrds_dm_display_info_ptr    mrds_dm_display
                         001202 dbm_ptr                     mrds_dm_display
                         001204 fi_ptr                      mrds_dm_display
                         001206 di_ptr                      mrds_dm_display
                         001210 ua_ptr                      mrds_dm_display
                         001212 path_entry_ptr              mrds_dm_display
                         001214 changer_ptr                 mrds_dm_display
                         001216 fm_ptr                      mrds_dm_display
                         001220 ri_ptr                      mrds_dm_display
                         001222 ai_ptr                      mrds_dm_display
                         001234 pii_object                  print_rel_info
                         001254 par_object                  print_all_relations
                         001374 px_loop                     print_xref
                         001404 pcx_attribute_loop          print_complete_xref
                         001405 pcx_attribute_name          print_complete_xref
                         001415 pcx_domain_loop             print_complete_xref
                         001416 pcx_domain_name             print_complete_xref
                         001426 pcx_prev_attribute_name     print_complete_xref
                         001436 pcx_prev_domain_name        print_complete_xref
                         001456 asi_attach_desc             attach_second_iocb

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this_desc
call_int_this       call_int_other      return_mac          tra_ext_1           enable_op           shorten_stack
ext_entry_desc      int_entry           int_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
date_time_                    initiate_file_                ioa_$ioa_switch               ioa_$ioa_switch_nnl
iox_$attach_name              iox_$close                    iox_$control                  iox_$destroy_iocb
iox_$detach_iocb              iox_$open                     iox_$position                 iox_$put_chars
iox_$read_key                 iox_$read_record              iox_$seek_key                 mdbm_util_$display_descriptor
mdbm_util_$trim_descriptor    mrds_dm_display_cmdb          mrds_dm_display_history       mu_db_xref$xref_build
mu_db_xref$xref_statistics    mu_temp_segments$free_all_temp_segments
mu_temp_segments$get_temp_segment_path                      terminate_file_               unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$end_of_info      error_table_$long_record      error_table_$no_record
error_table_$unimplemented_version                          mrds_error_$no_model_attr     mrds_error_$no_model_dom
mrds_error_$no_model_rel      sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      9 001110       997 001127      1007 001135      1024 001156      1034 001170      1049 001211        50 001212
     52 001216        53 001222        55 001223        56 001225        58 001230        60 001232        62 001235
     63 001253        65 001275        71 001320        76 001325        81 001352        86 001357        91 001364
     96 001371       101 001376       106 001407       111 001420       116 001425       119 001452       121 001456
    126 001457       131 001460       133 001507       135 001516       136 001525       137 001534       138 001537
    140 001541       142 001556       147 001557       152 001560       154 001565       156 001612       158 001613
    161 001623       162 001627       163 001632       164 001641       168 001642       173 001653       175 001703
    176 001743       179 002024       181 002035       184 002065       186 002072       188 002077       190 002100
    192 002127       195 002130       201 002133       202 002157       204 002171       206 002172       208 002173
    211 002203       215 002211       216 002267       217 002272       218 002273       220 002317       222 002321
    223 002371       226 002374       228 002403       230 002405       232 002413       234 002416       237 002435
    239 002462       240 002522       243 002545       244 002554       247 002555       251 002556       252 002562
    254 002574       255 002615       259 002633       261 002645       264 002646       266 002710       269 002723
    271 002732       273 002734       275 002743       277 002746       278 002775       280 003025       282 003033
    284 003057       286 003121       290 003171       294 003241       298 003313       302 003356       304 003373
    306 003402       310 003403       312 003404       314 003411       315 003436       318 003437       321 003467
    323 003501       324 003502       325 003544       327 003545       329 003552       330 003553       332 003565
    335 003601       338 003630       339 003631       341 003633       342 003642       345 003671       346 003672
    347 003701       349 003707       350 003723       351 003730       354 004006       357 004010       360 004037
    361 004040       363 004042       365 004057       368 004060       371 004061       372 004075       374 004101
    375 004106       376 004141       378 004142       379 004173       382 004226       386 004276       390 004346
    394 004420       398 004463       399 004500       402 004501       405 004502       408 004507       410 004520
    411 004544       413 004545       416 004572       417 004615       420 004654       421 004672       424 004713
    429 004735       432 004765       433 004773       436 005024       439 005034       440 005036       442 005041
    443 005073       446 005101       448 005104       449 005122       453 005134       455 005170       456 005211
    458 005212       460 005234       462 005241       463 005246       466 005311       467 005313       468 005314
    469 005345       470 005347       471 005352       473 005353       475 005375       477 005376       478 005405
    479 005453       480 005472       483 005551       486 005607       487 005631       489 005636       491 005643
    493 005703       494 005704       495 005705       496 005736       497 005737       499 005741       501 005756
    506 005757       509 005760       512 005765       513 005770       515 005774       517 006034       522 006052
    523 006055       525 006061       526 006106       529 006127       533 006130       536 006131       539 006155
    541 006164       543 006173       545 006235       546 006274       549 006355       552 006366       557 006416
    560 006453       564 006504       567 006535       570 006547       572 006576       576 006605       577 006634
    579 006636       581 006653       584 006654       587 006655       589 006662       591 006707       593 006710
    596 006721       599 006750       600 007010       603 007067       606 007100       609 007103       612 007133
    615 007157       617 007210       620 007221       622 007250       628 007257       629 007306       631 007315
    634 007316       638 007317       639 007320       640 007355       643 007373       647 007424       649 007451
    651 007454       652 007474       654 007522       656 007550       657 007551       660 007571       663 007615
    665 007627       668 007635       669 007645       670 007650       672 007651       674 007654       676 007701
    677 007722       680 007740       682 007751       683 007754       684 010001       685 010022       690 010040
    692 010053       694 010062       696 010075       697 010116       700 010134       702 010151       706 010152
    713 010163       715 010164       716 010202       719 010223       720 010225       722 010232       723 010264
    726 010271       727 010321       729 010322       731 010341       732 010342       735 010431       736 010447
    737 010452       739 010461       740 010472       741 010512       743 010514       745 010517       746 010525
    748 010575       750 010577       753 010601       755 010617       756 010620       757 010623       759 010624
    762 010646       766 010706       770 010707       780 010710       781 010711       783 010712       784 010730
    787 010751       788 010752       791 011024       792 011027       794 011031       795 011063       798 011070
    799 011107       801 011110       803 011127       805 011155       808 011176       819 011204       820 011222
    821 011224       824 011235       825 011255       827 011257       832 011264       836 011275       837 011315
    838 011334       841 011345       842 011347       843 011352       844 011353       845 011405       846 011406
    848 011426       851 011461       856 011470       858 011473       862 011543       863 011546       864 011551
    865 011553       868 011554       869 011563       874 011645       875 011650       876 011653       878 011655
    879 011657       886 011661       889 011701       893 011702       898 011724       901 011746       909 011747
    914 011750       915 012003       916 012013       917 012025       919 012037       920 012120       923 012147
    924 012167       927 012215       936 012217       943 012233       944 012240       945 012250       946 012255
    956 012260       959 012266       961 012273       962 012304       963 012317       964 012332       967 012335
    970 012357       973 012413       980 012414       988 012416       990 012426


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
