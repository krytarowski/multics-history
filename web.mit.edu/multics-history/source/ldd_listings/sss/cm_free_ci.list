	COMPILATION LISTING OF SEGMENT cm_free_ci
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/04/85  0951.9 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /* DESCRIPTION:
        9*
       10*   This  module  frees  a control interval.  If the collection uses the
       11*   Unblocked CISM, the specified control interval is  returned  directly  to
       12*   the  page  file free pool, i.e., the allocation map is updated to reflect
       13*   that control interval's availability.  If the collection uses the Blocked
       14*   CISM, the map for the block in which the control interval belongs is made
       15*   available.  If the whole block is available,  then  all  of  the  control
       16*   intervals of the block are freed.
       17*
       18*   There are three entries into this module, described as follows:
       19*
       20*   cm_free_ci$cm_free_ci
       21*   This entry is the entry used by callers through the
       22*   collection_manager_ transfer vector.  It frees the control interval,
       23*   updates threads for the previous and next control intervals, and,
       24*   if the control interval is the first or last of the collection,
       25*   updates the collection's storage record to show a new first or last
       26*   control interval.
       27*
       28*   cm_free_ci$info
       29*   This entry is used by collection_manager_ modules.  It behaves
       30*   exactly as cm_free_ci$cm_free_ci, execpt that a pointer to the
       31*   cm_info structure is passed in.  This is because the calling
       32*   collection_manager_ module has already gotten the structure.
       33*
       34*   cm_free_ci$raw_return_prev_next
       35*   This entry is used by cm_destroy_collection.  It does not bother to
       36*   maintain the control interval threads or the storage record
       37*   information.  Instead it just blows away the specified control
       38*   interval.  The fact that this leaves the collection in an
       39*   inconsistent state is all right, as cm_destroy_collection is going
       40*   to free everything anyway.  This entry also returns the values of
       41*   the previous and next control intervals, as stored in the specified
       42*   control interval's header, to assist cm_destroy_collection in
       43*   following the control interval thread.
       44*
       45*   cm_free_ci$trace_thread_modifications_(on off)
       46*   These entries set a static switch, static_trace_thread_switch, to
       47*   on and off, respectively.  When the switch is on, debugging
       48*   information is printed whenever the control interval thread may have
       49*   been modified by freeing a control interval.
       50*
       51*
       52*   The zero-on-free capability is not currently supported.
       53*
       54**/
       55 
       56 /* HISTORY:
       57*
       58*Written by Matthew Pierret, 07/06/82.
       59*Modified:
       60*10/20/82 by Matthew Pierret:  Converted to use file_manager_.
       61*11/03/82 by Matthew Pierret:  Changed to use opening info for both the header
       62*            and specified collections; to use cm_file_header instead of
       63*            collmgr_header; to use BASIC_CI_LAYOUT_1 (datum header-less)
       64*12/10/82 by Lindsey Spratt:  Fixed to get the storage record from the header
       65*            collection.
       66*02/04/83 by Matthew Pierret: Upgraded to CM_INFO_VERSION_2. Changed to get
       67*            blocked storage record.
       68*02/09/83 by Lindsey Spratt:  Fixed to correctly re-thread the control
       69*            intervals.
       70*02/23/83 by Matthew Pierret: Changed to use file_reservation_map instead of
       71*            block_map_array.
       72*03/01/83 by Lindsey Spratt:  Fixed to use "next_control_interval" when
       73*            replacing the next_bci_header, rather than
       74*            "previous_control_interval".
       75*08/09/83 by Matthew Pierret: Removed the obsolete dm_data_$area_ptr.
       76*01/24/84 by Matthew Pierret: Added debugging entries for tracing
       77*            modifications to the control interval thread.
       78*05/21/84 by Matthew Pierret: Added RETURN and ERROR_RETURN procedures.
       79*            Renamed dm_cm_cism_info include file to dm_cism_info.  Changed to
       80*            use automatic code variable instead of p_code parameter.
       81*06/12/84 by Matthew Pierret: Re-named cm_put_element to cm_modify.
       82*07/24/84 by Matthew Pierret: Added raw_return_prev_next entry.  This entry
       83*            does a "raw" free, meaning that it does not update threads or
       84*            control information, just frees the ci. It also returns the values
       85*            of the prev and next ci from the ci's bci_header. This entry is
       86*            used by cm_destroy_collection.
       87*09/28/84 by Matthew Pierret: Removed initial attributes from flags. Changed
       88*            CHECK_VERSION_CHAR_4 to CHECK_CI_VERSION.  Added sub_err_ call for
       89*            case where an unsupported control interval storage method was
       90*            encountered.Added description of race entries.
       91*01/08/85 by Matthew Pierret: Corrected test of gsr_code in the subroutine
       92*            GET_STORAGE_RECORD_PTR to be for not-equal to 0 instead of equal.
       93**/
       94 
       95 /* format: style2,ind3 */
       96 /* format: indcomtxt,^indblkcom */
       97 
       98 cm_free_ci:
       99    proc (p_file_opening_id, p_collection_id, p_control_interval_number, p_zero_on_free, p_code);
      100 
      101 /* START OF DECLARATIONS */
      102 /* Parameter */
      103 
      104       dcl	    p_cm_info_ptr	       ptr parameter;
      105       dcl	    p_file_opening_id      bit (36) aligned parameter;
      106       dcl	    p_collection_id	       bit (36) aligned parameter;
      107       dcl	    p_control_interval_number
      108 			       fixed bin (24) uns parameter;
      109       dcl	    p_zero_on_free	       bit (1) aligned parameter;
      110 
      111       dcl	    p_previous_control_interval_number
      112 			       fixed bin (24) uns parameter;
      113       dcl	    p_next_control_interval_number
      114 			       fixed bin (24) uns parameter;
      115       dcl	    p_code	       fixed bin (35) parameter;
      116 
      117 /* Automatic */
      118 
      119       dcl	    code		       fixed bin (35);
      120       dcl	    control_interval_number
      121 			       fixed bin (24) uns;
      122       dcl	    hc_cm_info_ptr	       ptr init (null);
      123       dcl	    1 previous_bci_header  aligned like bci_header;
      124       dcl	    previous_control_interval
      125 			       fixed bin (24) unsigned;
      126       dcl	    1 next_bci_header      aligned like bci_header;
      127       dcl	    next_control_interval  fixed bin (24) unsigned;
      128 
      129       dcl	    1 automatic_bci_header aligned like bci_header;
      130       dcl	    1 automatic_cm_file_header
      131 			       aligned like cm_file_header;
      132       dcl	    map_idx	       fixed bin (17);
      133       dcl	    (collection_header_was_updated, return_prev_and_next_ci, this_is_raw_free)
      134 			       bit (1) aligned;
      135 
      136 /* Based */
      137 /* Builtin */
      138 
      139       dcl	    (addr, divide, length, null, size, substr, unspec)
      140 			       builtin;
      141 
      142 /* Constant */
      143 
      144       dcl	    myname	       init ("cm_free_ci") char (32) varying int static options (constant);
      145       dcl	    BITS_PER_WORD	       init (36) fixed bin (17) int static options (constant);
      146       dcl	    BYTES_PER_WORD	       init (4) fixed bin (17) int static options (constant);
      147       dcl	    NO_CONTROL_INTERVAL    init (0) fixed bin (24) unsigned int static options (constant);
      148       dcl	    OFFSET_OF_BCI_HEADER   init (0) fixed bin (21) internal static options (constant);
      149 
      150 /* Entry */
      151 
      152       dcl	    file_manager_$free     entry (bit (36) aligned, uns fixed bin (24), uns fixed bin (24), fixed bin (35));
      153       dcl	    file_manager_$simple_put
      154 			       entry (bit (36) aligned, fixed bin (27), fixed bin (21), ptr, fixed bin (21),
      155 			       fixed bin (35));
      156       dcl	    ioa_		       entry () options (variable);
      157       dcl	    sub_err_	       entry () options (variable);
      158 
      159 /* External */
      160 
      161       dcl	    dm_error_$ci_0_invalid_free
      162 			       ext fixed bin (35);
      163       dcl	    dm_error_$ci_not_in_collection
      164 			       ext fixed bin (35);
      165       dcl	    dm_error_$unimplemented_ci_version
      166 			       ext fixed bin (35);
      167       dcl	    dm_error_$unimplemented_cism
      168 			       ext fixed bin (35);
      169       dcl	    error_table_$unimplemented_version
      170 			       ext fixed bin (35);
      171 
      172 /* Static */
      173 
      174       dcl	    static_trace_thread_switch
      175 			       init ("0"b) bit (1) aligned internal static;
      176 
      177 /* END OF DECLARATIONS */
      178 
      179       this_is_raw_free, return_prev_and_next_ci = "0"b;
      180       code = 0;
      181 
      182       call cm_opening_info$get (p_file_opening_id, p_collection_id, cm_info_ptr, code);
      183       if code ^= 0
      184       then call ERROR_RETURN (code);
      185 
      186 
      187       go to JOIN;
      188 
      189 
      190 
      191 info:
      192    entry (p_cm_info_ptr, p_control_interval_number, p_zero_on_free, p_code);
      193 
      194       this_is_raw_free, return_prev_and_next_ci = "0"b;
      195       code = 0;
      196       cm_info_ptr = p_cm_info_ptr;
      197 
      198       go to JOIN;
      199 
      200 raw_return_prev_next:
      201    entry (p_cm_info_ptr, p_control_interval_number, p_zero_on_free, p_previous_control_interval_number,
      202         p_next_control_interval_number, p_code);
      203 
      204       this_is_raw_free, return_prev_and_next_ci = "1"b;
      205       code = 0;
      206       cm_info_ptr = p_cm_info_ptr;
      207 
      208       go to JOIN;
      209 
      210 JOIN:
      211       p_code = 0;
      212       collection_header_was_updated = "0"b;
      213 
      214       call CHECK_VERSION ("cm_info", cm_info.version, CM_INFO_VERSION_2);
      215 
      216       collection_header_ptr = cm_info.header_ptr;
      217 
      218       call CHECK_VERSION ("collection_header", collection_header.version, COLLECTION_HEADER_VERSION_2);
      219 
      220       control_interval_number = p_control_interval_number;
      221 
      222       if control_interval_number = 0
      223       then call ERROR_RETURN (dm_error_$ci_0_invalid_free);
      224 
      225    /*** The Header Collection will be accessed several times, so get
      226*        opening info for the Header Collection (pointed to by hc_cm_info_ptr) to
      227*        make these accesses more efficient. */
      228 
      229       call cm_opening_info$get (cm_info.file_oid, HEADER_COLLECTION_ID, hc_cm_info_ptr, code);
      230       if code ^= 0
      231       then call ERROR_RETURN (code);
      232 
      233    /*** Determine if this collection is in blocked or unblocked mode. */
      234 
      235       if collection_header.control_interval_storage_method = UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
      236       then
      237 UNBLOCKED:
      238          do;
      239 
      240          /*** This is an unblocked collection. */
      241 
      242 	  call cm_get_element (cm_info.file_oid, HEADER_COLLECTION_ID, CM_FILE_HEADER_ELEMENT_ID, (0),
      243 	       addr (automatic_cm_file_header), length (unspec (automatic_cm_file_header)), null, ("0"b),
      244 	       cm_file_header_ptr, (0), code);
      245 	  if code ^= 0
      246 	  then call ERROR_RETURN (code);
      247 
      248 	  call CHECK_VERSION ("cm_file_header", cm_file_header.version, CM_FILE_HEADER_VERSION_1);
      249 
      250 	  frmf_number_of_control_intervals = cm_file_header.number_of_control_intervals_per_block;
      251 	  frm_number_of_fragments = cm_file_header.number_of_blocks;
      252 
      253 UB_BEGIN_BLOCK:
      254 	  begin;
      255 	     dcl	   fragment_buffer	      (divide (frmf_number_of_control_intervals, BITS_PER_WORD * 2, 17, 0) + 1)
      256 				      fixed bin (71);
      257 	     dcl	   file_reservation_map_buffer
      258 				      (frm_number_of_fragments) fixed bin (71);
      259 
      260 	  /*** Get proper block of allocation map.  This requires getting the cm_file_header
      261*	       which contains a pointer to the array of allocation block maps, getting
      262*	       that array (file_reservation_map), searching that array until the proper block
      263*	       is found. */
      264 
      265 	     call cm_get_element (cm_info.file_oid, HEADER_COLLECTION_ID, cm_file_header.allocation_map_element_id, (0),
      266 		addr (file_reservation_map_buffer), length (unspec (file_reservation_map_buffer)), null, ("0"b),
      267 		file_reservation_map_ptr, (0), code);
      268 	     if code ^= 0
      269 	     then call ERROR_RETURN (code);
      270 
      271 FIND_APPROPRIATE_BLOCK_LOOP:
      272 	     do map_idx = 1 to frm_number_of_fragments
      273 		while (
      274 		^(file_reservation_map (map_idx).lowest_numbered_control_interval <= control_interval_number
      275 		& control_interval_number
      276 		< file_reservation_map (map_idx).lowest_numbered_control_interval + frmf_number_of_control_intervals))
      277 		;
      278 	     end FIND_APPROPRIATE_BLOCK_LOOP;
      279 
      280 	     if map_idx > frm_number_of_fragments
      281 	     then call ERROR_RETURN (dm_error_$ci_not_in_collection);
      282 
      283 	  /*** Get the file_reservation_map_fragment.  An exclusive get is used here to avoid being
      284*	       locked out later when trying to put back the updated file_reservation_map_fragment. */
      285 
      286 	     call cm_get_element$exclusive (cm_info.file_oid, HEADER_COLLECTION_ID,
      287 		file_reservation_map (map_idx).element_id, (0), addr (fragment_buffer),
      288 		length (unspec (fragment_buffer)), null, ("0"b), file_reservation_map_fragment_ptr, (0), code);
      289 	     if code ^= 0
      290 	     then call ERROR_RETURN (code);
      291 
      292 	     if substr (file_reservation_map_fragment,
      293 		control_interval_number - file_reservation_map (map_idx).lowest_numbered_control_interval + 1, 1)
      294 		= "0"b
      295 	     then call RETURN;			/* Already free */
      296 
      297 	     substr (file_reservation_map_fragment,
      298 		control_interval_number - file_reservation_map (map_idx).lowest_numbered_control_interval + 1, 1) =
      299 		"0"b;				/* Set to free */
      300 
      301 
      302 	     bci_header_ptr = addr (automatic_bci_header);
      303 
      304 	     call cm_get_bci_header$exclusive (cm_info.file_oid, control_interval_number, bci_header_ptr, code);
      305 	     if code ^= 0
      306 	     then call ERROR_RETURN (code);
      307 
      308 	     call CHECK_CI_VERSION (bci_header.layout_type);
      309 
      310 	     if bci_header.collection_id ^= cm_info.collection_id
      311 	     then call ERROR_RETURN (dm_error_$ci_not_in_collection);
      312 
      313 	     previous_control_interval = bci_header.previous_control_interval;
      314 	     next_control_interval = bci_header.next_control_interval;
      315 
      316 	     if ^this_is_raw_free
      317 	     then
      318 UPDATE_PREV_AND_NEXT_CI:
      319 	        do;
      320 
      321 	        /*** The first actual updating done in freeing a control interval is to update
      322*		   the threads of the previous and next control intervals. These control
      323*		   intervals are determined by looking in the bci_header of the control
      324*		   interval to be freed. In getting that control interval's bci_header, an
      325*		   exclusive lock is obtained since it will be needed when it is freed. */
      326 
      327 		 if previous_control_interval = NO_CONTROL_INTERVAL
      328 		 then
      329 		    do;
      330 		       unblocked_storage_record_ptr = GET_STORAGE_RECORD_PTR ();
      331 		       unblocked_storage_record.first_control_interval = next_control_interval;
      332 		       collection_header_was_updated = "1"b;
      333 		    end;
      334 		 else
      335 		    do;
      336 		       call cm_get_bci_header (cm_info.file_oid, previous_control_interval,
      337 			  addr (previous_bci_header), code);
      338 		       if code ^= 0
      339 		       then call ERROR_RETURN (code);
      340 
      341 		       call CHECK_CI_VERSION (bci_header.layout_type);
      342 
      343 		       previous_bci_header.next_control_interval = next_control_interval;
      344 		    end;
      345 
      346 		 if next_control_interval = NO_CONTROL_INTERVAL
      347 		 then
      348 		    do;
      349 		       unblocked_storage_record_ptr = GET_STORAGE_RECORD_PTR ();
      350 		       unblocked_storage_record.last_control_interval = previous_control_interval;
      351 		       collection_header_was_updated = "1"b;
      352 		    end;
      353 		 else
      354 		    do;
      355 		       call cm_get_bci_header (cm_info.file_oid, next_control_interval, addr (next_bci_header), code);
      356 		       if code ^= 0
      357 		       then call ERROR_RETURN (code);
      358 
      359 		       call CHECK_CI_VERSION (bci_header.layout_type);
      360 
      361 		       next_bci_header.previous_control_interval = previous_control_interval;
      362 		    end;
      363 
      364 	        /*** Dislay tracing information if desired. */
      365 
      366 		 if static_trace_thread_switch
      367 		 then call ioa_ ("Control interval ^d freed.", control_interval_number);
      368 
      369 	        /*** Modify previous and next control intervals' headers. */
      370 
      371 		 if previous_control_interval ^= 0
      372 		 then
      373 		    do;
      374 		       call file_manager_$simple_put (cm_info.file_oid, (previous_control_interval),
      375 			  OFFSET_OF_BCI_HEADER, addr (previous_bci_header),
      376 			  size (previous_bci_header) * BYTES_PER_WORD, code);
      377 		       if code ^= 0
      378 		       then call ERROR_RETURN (code);
      379 		       if static_trace_thread_switch
      380 		       then call ioa_ ("^8xControl interval ^d changed to have next of ^d.",
      381 			       previous_control_interval, previous_bci_header.next_control_interval);
      382 		    end;
      383 		 if next_control_interval ^= 0
      384 		 then
      385 		    do;
      386 		       call file_manager_$simple_put (cm_info.file_oid, (next_control_interval), OFFSET_OF_BCI_HEADER,
      387 			  addr (next_bci_header), size (next_bci_header) * BYTES_PER_WORD, code);
      388 		       if code ^= 0
      389 		       then call ERROR_RETURN (code);
      390 		       if static_trace_thread_switch
      391 		       then call ioa_ ("^8xControl interval ^d changed to have previous of ^d.",
      392 			       next_control_interval, next_bci_header.previous_control_interval);
      393 		    end;
      394 	        end UPDATE_PREV_AND_NEXT_CI;
      395 
      396 	  /*** Release disk address held by control interval. */
      397 
      398 	     call file_manager_$free (cm_info.file_oid, control_interval_number, 1, code);
      399 	     if code ^= 0
      400 	     then call ERROR_RETURN (code);
      401 
      402 	  /*** Write out the allocation map block. The window between releasing the disk
      403*	       address and writing back the updated map should be closed. */
      404 
      405 	     call cm_modify$info (hc_cm_info_ptr, file_reservation_map_fragment_ptr, -1,
      406 		file_reservation_map (map_idx).element_id, (0), code);
      407 	     if code ^= 0
      408 	     then call ERROR_RETURN (code);
      409 
      410 	     if file_reservation_map (map_idx).flags.no_control_intervals_are_available
      411 	     then
      412 	        do;
      413 		 file_reservation_map (map_idx).flags.no_control_intervals_are_available = "0"b;
      414 		 call cm_modify$info (hc_cm_info_ptr, file_reservation_map_ptr, -1,
      415 		      cm_file_header.allocation_map_element_id, (0), (0));
      416 	        end;
      417 
      418 	  /*** If the collection_header was updated, put it back. */
      419 
      420 	     if collection_header_was_updated
      421 	     then
      422 	        do;
      423 		 call cm_modify$info (hc_cm_info_ptr, unblocked_storage_record_ptr, -1,
      424 		      collection_header.storage_record_element_id, (0), code);
      425 		 if code ^= 0
      426 		 then call ERROR_RETURN (code);
      427 	        end;
      428 
      429 	  /*** Return the previous and next control interval numbers. */
      430 
      431 	     if return_prev_and_next_ci
      432 	     then
      433 	        do;
      434 		 p_previous_control_interval_number = previous_control_interval;
      435 		 p_next_control_interval_number = next_control_interval;
      436 	        end;
      437 	  end UB_BEGIN_BLOCK;
      438          end UNBLOCKED;
      439       else call sub_err_ (dm_error_$unimplemented_cism, myname, ACTION_CANT_RESTART, null, 0,
      440 	      "^/This routine does not implement control interval storage method ^d.",
      441 	      collection_header.control_interval_storage_method);
      442 
      443 
      444 /**** ***************************************************************************
      445*
      446*      The following code is to support the blocked control interval storage method.
      447*      This method is not yet supported and will not be supported in MR11.
      448*
      449*      else
      450*      BLOCKED:
      451*      do;
      452*      blocked_storage_record_ptr = GET_STORAGE_RECORD_PTR ();
      453*
      454*      camb_number_of_control_intervals = blocked_storage_record.number_of_control_intervals_per_block;
      455*      cam_number_of_blocks = blocked_storage_record.number_of_blocks;
      456*
      457*      begin;
      458*      dcl	   block_buffer	      (divide (camb_number_of_control_intervals, BITS_PER_WORD * 2, 17, 0) + 1)
      459*      fixed bin (71);
      460*      dcl	   cam_buffer	      (cam_number_of_blocks) fixed bin (71);
      461*
      462*      call
      463*      cm_get_element (cm_info.file_oid, HEADER_COLLECTION_ID,
      464*      blocked_storage_record.block_map_array_element_id, (0), addr (cam_buffer), length (unspec (cam_buffer)),
      465*      null, ("0"b), collection_allocation_map_ptr, (0), code);
      466*      if code ^= 0
      467*      then call ERROR_RETURN (code);
      468*
      469*      do map_idx = 1 to cam_number_of_blocks
      470*      while (
      471*      ^(collection_allocation_map (map_idx).lowest_numbered_control_interval <= control_interval_number
      472*      & control_interval_number
      473*      < collection_allocation_map (map_idx).lowest_numbered_control_interval + camb_number_of_control_intervals));
      474*      end;
      475*
      476*      if map_idx > cam_number_of_blocks
      477*      then call ERROR_RETURN (dm_error_$ci_not_in_collection);
      478*
      479*      call
      480*      cm_get_element$exclusive (cm_info.file_oid, HEADER_COLLECTION_ID,
      481*      collection_allocation_map (map_idx).element_id, (0), addr (block_buffer), length (unspec (block_buffer)), null,
      482*      ("0"b), collection_allocation_map_block_ptr, (0), code);
      483*      if code ^= 0
      484*      then call ERROR_RETURN (code);
      485*
      486*      if substr (collection_allocation_map_block,
      487*      control_interval_number - collection_allocation_map (map_idx).lowest_numbered_control_interval + 1, 1)
      488*      = "0"b
      489*      then call RETURN;
      490*
      491*      substr (collection_allocation_map_block,
      492*      control_interval_number - collection_allocation_map (map_idx).lowest_numbered_control_interval + 1, 1) =
      493*      "0"b;
      494*
      495*      call
      496*      cm_modify$info (hc_cm_info_ptr, collection_allocation_map_block_ptr, -1,
      497*      collection_allocation_map (map_idx).element_id, (0), code);
      498*      if code ^= 0
      499*      then
      500*      call ERROR_RETURN (code);
      501*
      502*      if collection_allocation_map (map_idx).flags.no_control_intervals_are_available
      503*      then
      504*      do;
      505*      collection_allocation_map (map_idx).flags.no_control_intervals_are_available = "0"b;
      506*      call
      507*      cm_modify$info (hc_cm_info_ptr, collection_allocation_map_ptr, -1,
      508*      blocked_storage_record.block_map_array_element_id, (0), (0));
      509*      if code ^= 0
      510*      then
      511*      call ERROR_RETURN (code);
      512*      end;
      513*
      514*      end;
      515*      end BLOCKED;
      516*
      517*      ************************************************************************ ****/
      518 
      519 MAIN_RETURN:
      520       return;
      521 
      522 
      523 trace_thread_modifications_on:
      524    entry ();
      525       static_trace_thread_switch = "1"b;
      526       return;
      527 
      528 trace_thread_modifications_off:
      529    entry ();
      530       static_trace_thread_switch = "0"b;
      531       return;
      532 
      533 RETURN:
      534    proc ();
      535 
      536       go to MAIN_RETURN;
      537 
      538    end RETURN;
      539 
      540 
      541 ERROR_RETURN:
      542    proc (er_p_code);
      543 
      544       dcl	    er_p_code	       fixed bin (35);
      545 
      546       p_code = er_p_code;
      547       call FINISH ();
      548       go to MAIN_RETURN;
      549 
      550    end ERROR_RETURN;
      551 
      552 
      553 FINISH:
      554    proc ();
      555 
      556    end FINISH;
      557 
      558 GET_STORAGE_RECORD_PTR:
      559    proc () returns (ptr);
      560 
      561       dcl	    gsr_p_storage_record_ptr
      562 			       ptr;
      563       dcl	    gsr_code	       fixed bin (35) init (0);
      564 
      565       if cm_info.storage_record_ptr = null
      566       then call cm_opening_info$get_storage_record (cm_info_ptr, gsr_code);
      567 
      568       if gsr_code ^= 0
      569       then call ERROR_RETURN (gsr_code);
      570 
      571       gsr_p_storage_record_ptr = cm_info.storage_record_ptr;
      572 
      573       return (gsr_p_storage_record_ptr);
      574 
      575    end GET_STORAGE_RECORD_PTR;
      576 
      577 CHECK_VERSION:
      578    proc (cv_p_structure_name, cv_p_given_version, cv_p_correct_version);
      579 
      580       dcl	    cv_p_structure_name    char (*);
      581       dcl	    cv_p_given_version     char (8) aligned;
      582       dcl	    cv_p_correct_version   char (8) aligned;
      583 
      584       if cv_p_given_version ^= cv_p_correct_version
      585       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      586 	      "^/Expected version ""^8a"" of ^a structure; received ""^8a"".", cv_p_correct_version,
      587 	      cv_p_structure_name, cv_p_given_version);
      588 
      589       return;
      590 
      591    end CHECK_VERSION;
      592 
      593 
      594 CHECK_CI_VERSION:
      595    proc (ccv_p_given_version);
      596 
      597       dcl	    ccv_p_given_version    char (4) aligned;
      598 
      599       if ccv_p_given_version ^= BASIC_CI_LAYOUT_1
      600       then call sub_err_ (dm_error_$unimplemented_ci_version, myname, ACTION_CANT_RESTART, null, 0,
      601 	      "^/Expected version ^a control interval; received ^a.", BASIC_CI_LAYOUT_1, ccv_p_given_version);
      602       else return;
      603 
      604    end CHECK_CI_VERSION;
      605 
  1     1 /* BEGIN INCLUDE FILE - dm_hdr_collection_id.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*
  1     5*        Contains the identifier of the Header Collection for a file
  1     6*   managed by the collection_manager_.  This is used by callers of 
  1     7*   collection_manager who wish to maintain their own file header or who wish
  1     8*   to maintain their own collection header information beyond the caller
  1     9*   collection header provided by colleciton_manager_$(get put)_header.
  1    10**/
  1    11 
  1    12 /* HISTORY:
  1    13*Written by Matthew Pierret, 09/24/84.
  1    14*Modified:
  1    15**/
  1    16 
  1    17 /* format: style2,ind3,ll79 */
  1    18 
  1    19      dcl	   HEADER_COLLECTION_ID   init ("000000000001"b3) bit (36)
  1    20 			      aligned internal static options (constant);
  1    21 
  1    22 /* END INCLUDE FILE - dm_hdr_collection_id.incl.pl1 */
      606 
      607 
  2     1 /* BEGIN INCLUDE FILE dm_cm_hdr_col_ids.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*   Contains element identifiers of some elements in the Header Collection.
  2     6*   HEADER_COLLECTION_HEADER_ELEMENT_ID is the identifier of the element in
  2     7*   which the collection_header for the Header Collection is stored (see
  2     8*   dm_cm_collection_header.incl.pl1).
  2     9*   CALLER_HEADER_ELEMENT_ID is the identifier of the element in which the
  2    10*   caller's file header is stored.
  2    11*   CM_FILE_HEADER_ELEMENT_ID is the identifier of the element in which the
  2    12*   cm_file_header structure is stored (see dm_cm_file_header.incl.pl1).
  2    13**/
  2    14 
  2    15 /* HISTORY:
  2    16*Written by Matthew Pierret, 09/24/84.
  2    17*Modified:
  2    18**/
  2    19 
  2    20 /* format: style2,ind3,ll79 */
  2    21      dcl	   (
  2    22 	   HEADER_COLLECTION_HEADER_ELEMENT_ID
  2    23 			      init ("000000000001"b3),
  2    24 	   CM_FILE_HEADER_ELEMENT_ID
  2    25 			      init ("000000000002"b3),
  2    26 	   CALLER_HEADER_ELEMENT_ID
  2    27 			      init ("000000000003"b3)
  2    28 	   )		      bit (36) aligned int static
  2    29 			      options (constant);
  2    30 
  2    31 /* END INCLUDE FILE  dm_cm_hdr_col_ids.incl.pl1 */
      608 
      609 
  3     1 /* BEGIN INCLUDE FILE - dm_cm_info.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*        The cm_info structure is used to hold per-process opening information
  3     5*   about a collection.  It is generally allocated in the process' DM free
  3     6*   area, as returned by the function get_dm_free_area_.  The opening_manager_
  3     7*   is used to provide access the cm_info structure, keeping it in a hash
  3     8*   table keyed on file opening id and collection id combined.
  3     9*        Currently cm_info is never freed until the process terminates.  Each
  3    10*   time a new transaction is started, detected when the current transaction
  3    11*   id of a process differs from cm_info.current_transaction_id, the information
  3    12*   in cm_info is refreshed.  Storage record information is only refreshed on
  3    13*   demand, as most modules do not need the information in the storage record.
  3    14*   Instead, cm_info.storage_record_ptr is set to null (), but 
  3    15*   cm_info.storage_record_buffer_ptr remains set to the previous value of
  3    16*   cm_info.storage_record_ptr.  When a refreshed copy of the storage record is
  3    17*   requested, it is placed at the location pointed to by
  3    18*   cm_info.storage_record_buffer_ptr, saving the expense of re-allocation.
  3    19**/
  3    20 
  3    21 /* HISTORY:
  3    22*Written by Matthew Pierret, 10/27/82. 
  3    23*Modified:
  3    24*01/25/83 by Matthew Pierret: Changed to version 2.  Added 
  3    25*            storage_record_buffer_ptr. This points to the storage_record.
  3    26*            When cm_info is refreshed, storage_record_ptr is set to null,
  3    27*            but storage_record_buffer_ptr continues to point at where the
  3    28*            storage_record was. When the storge_record is again requested,
  3    29*            it is put back in the same place rather than allocating a new
  3    30*            storage_record.
  3    31*09/24/84 by Matthew Pierret:  Re-wrote DESCRIPTION section. Removed the
  3    32*            init clause from the version component.
  3    33**/
  3    34 
  3    35 /* format: style2,ind3,ll79 */
  3    36 
  3    37      dcl	   1 cm_info	      aligned based (cm_info_ptr),
  3    38 	     2 version	      char (8),
  3    39 	     2 current_txn_id     bit (36) aligned init ("0"b),
  3    40 	     2 file_oid	      bit (36) aligned init ("0"b),
  3    41 	     2 collection_id      bit (36) aligned init ("0"b),
  3    42 	     2 header_ptr	      ptr init (null),
  3    43 	     2 storage_record_ptr ptr init (null),
  3    44 	     2 storage_record_buffer_ptr
  3    45 			      ptr init (null);
  3    46 
  3    47      dcl	   cm_info_ptr	      ptr init (null);
  3    48      dcl	   CM_INFO_VERSION_2      init ("cm_info2") char (8) aligned
  3    49 			      internal static options (constant);
  3    50 
  3    51 /* END INCLUDE FILE - dm_cm_info.incl.pl1 */
      610 
      611 
  4     1 /* BEGIN INCLUDE FILE - dm_cm_collection_header.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*       Associated with each collection is the following collection_header
  4     5*   structure stored as an element in the Header Collection of the file.
  4     6*   The identifier of this element is also the idenfifier of the collection.
  4     7*   Even the Header Collection has a collection_header stored in the Header
  4     8*   Collection itself in the element identified by the constant
  4     9*   HEADER_COLLECTION_HEADER_ELEMENT_ID declared in dm_cm_hdr_col_ids.incl.pl1.
  4    10*   The information in collection_header is expected to be stable information.
  4    11*   The structure elements are described as follows:
  4    12*   
  4    13*   version is a character string version equal to COLLECTION_HEADER_VERSION_2.
  4    14*   
  4    15*   flags.fixed_size_elements indicates, if on that all elements in the
  4    16*   collection are of a fixed length.
  4    17*   
  4    18*   flags.thread_elements indicates that elements in a collection are to be
  4    19*   threaded in a linked list.  This is currrently unupported.
  4    20*   
  4    21*   flags.thread_control_intervals indicates, if on, that control intervals in
  4    22*   a collection are to be threaded in a linked list.  This is only useful if
  4    23*   the control interval storage method is blocked.
  4    24*   
  4    25*   flags.must_be_zero1 is reserved for future use and must be "0"b.
  4    26*   
  4    27*   control_interval_storage_method is the method of storage management of
  4    28*   control intervals for this collection, either
  4    29*   BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD (not yet supported) or
  4    30*   UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD, declared in
  4    31*   dm_cism_info.incl.pl1.
  4    32*   
  4    33*   element_storage_method is the method of storage management of elements in
  4    34*   this collection, either BASIC_ELEMENT_STORAGE_METHOD or
  4    35*   ORDERED_ELEMENT_STORAGE_METHOD, declared in dm_esm_info.incl.pl1.
  4    36*   
  4    37*   maximum_element_size is the maximum size of an element in bits in this
  4    38*   collection.
  4    39*   
  4    40*   header_record_element_id is the identifier of an element containing a
  4    41*   caller-defined header for this collection.  If equal to "0"b, no
  4    42*   caller-defined header yet exists.  The put_header collection_manager_
  4    43*   operation stores such a header.
  4    44*   
  4    45*   storage_record_element_id is the identifier of the element containing the
  4    46*   storage_record for this collection.  The storage_record contains
  4    47*   information expected to be dynamic, such as the identifier of the last
  4    48*   control interval of the collection.  Its format is also dependent upon the
  4    49*   storage methods in effect for this collection.  storage_record structures
  4    50*   are declared in dm_cm_storage_record.incl.pl1.
  4    51*
  4    52**/
  4    53 
  4    54 /* HISTORY:
  4    55*Written by Matthew Pierret, 04/01/82.
  4    56*Modified:
  4    57*07/01/82 by Matthew Pierret: Changed to version A, added storage_record_area.
  4    58*10/29/82 by Matthew Pierret: Changed to version 2 ("col_hdr2"), separated
  4    59*            storage_record_area out, leaving storage_record_element_id behind.
  4    60*09/18/84 by Matthew Pierret: Added DESCRIPTION section.
  4    61**/
  4    62 
  4    63 /* format: style2,ind3,ll79 */
  4    64 
  4    65      dcl	   1 collection_header    aligned based (collection_header_ptr),
  4    66 	     2 version	      char (8),
  4    67 	     2 flags	      unaligned,
  4    68 	       3 fixed_size_elements
  4    69 			      bit (1),
  4    70 	       3 thread_elements  bit (1),
  4    71 	       3 thread_control_intervals
  4    72 			      bit (1),
  4    73 	       3 must_be_zero1    bit (15),
  4    74 	     2 control_interval_storage_method
  4    75 			      fixed bin (17) unal,
  4    76 	     2 element_storage_method
  4    77 			      fixed bin (17),
  4    78 	     2 maximum_element_size
  4    79 			      fixed bin (35),
  4    80 	     2 header_record_element_id
  4    81 			      bit (36) aligned,
  4    82 	     2 storage_record_element_id
  4    83 			      bit (36) aligned;
  4    84 
  4    85      dcl	   collection_header_ptr  ptr;
  4    86      dcl	   COLLECTION_HEADER_VERSION_2
  4    87 			      init ("col_hdr2") char (8) aligned
  4    88 			      int static options (constant);
  4    89 
  4    90 /* END INCLUDE FILE - dm_cm_collection_header.incl.pl1 */
      612 
      613 
  5     1 /* BEGIN INCLUDE FILE dm_cm_file_header.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*
  5     5*        This include file contains the cm_file_header and collection_id_table 
  5     6*   structure.  These structures are stored as elements in the Header Collection
  5     7*   of a file and contain per-file, as opposed to per-collection, information.
  5     8*   
  5     9*        The cm_file_header structure is always stored in the element whose
  5    10*   identifier is CM_FILE_HEADER_ELEMENT_ID, declared in 
  5    11*   dm_cm_hdr_col_ids.incl.pl1.  
  5    12*   
  5    13*        The collection_id_table is an array of identifiers of each collection 
  5    14*   in the file, excepting the Header Collection.  The identifier of a 
  5    15*   collection is the same as the identifier of the element which holds that
  5    16*   collection's collection_header, described in dm_cm_collection_header.incl.pl1.
  5    17*   The identifier of the element in which the collection_id_table is
  5    18*   stored is cm_file_header.collection_id_table_element_id.
  5    19*   
  5    20*      A file also has a reservation map for determining which controls 
  5    21*   intervals have been reserved by a collection.  It is divided into
  5    22*   several blocks, or fragments.  The file_reservation_map is actually an
  5    23*   array of element identifiers of the fragments of the map.  The 
  5    24*   file_reservation_map is stored in the element whose identifier is 
  5    25*   cm_file_header.allocation_map_element_id (quite a misnomer).  The number
  5    26*   of fragments of the map is cm_file_header.number_of_blocks.  The size
  5    27*   of each is fragment is cm_file_header.number_of_control_intervals_per_block
  5    28*   bits long, representing equally as many control intervals.  The
  5    29*   file_reservation_map is described in dm_cm_reservation_map.incl.pl1.
  5    30*   cm_file_header.highest_numbered_ci is the number of the control
  5    31*   interval in the file with the highest control interval number.  It is not 
  5    32*   yet used or maintained.
  5    33*
  5    34**/
  5    35 
  5    36 /* HISTORY:
  5    37*Written by Matthew Pierret, 03/23/82.
  5    38*Modified:
  5    39*04/08/82 by Matthew Pierret: Removed storage method constants.
  5    40*05/18/82 by Matthew Pierret: Made the array of collections an array of element
  5    41*            ids referring to collection_header's. Reduced buffer length to 120,
  5    42*            enough bytes to hold the collmgr_header with 25 collection header
  5    43*            element ids.
  5    44*06/03/82 by Matthew Pierret: Added collmgr_header_header.
  5    45*07/01/82 by Matthew Pierret: Removed collmgr_header_header. Changed to version A
  5    46*            made fixed length, split off array of collection_ids (also known as
  5    47*            element_ids of collection_headers).
  5    48*10/29/82 by Matthew Pierret: Changed from collmgr_header to cm_file_header.
  5    49*09/18/84 by Matthew Pierret: Added DESCRIPTION section. Moved constants to
  5    50*            dm_cm_hdr_col_ids.incl.pl1.  
  5    51**/
  5    52 
  5    53 /* format: style2,ind3,ll79 */
  5    54 
  5    55      dcl	   1 cm_file_header	      aligned based (cm_file_header_ptr),
  5    56 	     2 version	      char (8),
  5    57 	     2 highest_numbered_ci
  5    58 			      fixed bin (24) uns,
  5    59 	     2 number_of_collections
  5    60 			      fixed bin (17) unal,
  5    61 	     2 number_of_blocks   fixed bin (17) unal,
  5    62 	     2 number_of_control_intervals_per_block
  5    63 			      fixed bin (17),
  5    64 	     2 allocation_map_element_id
  5    65 			      bit (36) aligned,
  5    66 	     2 collection_id_table_element_id
  5    67 			      bit (36) aligned;
  5    68 
  5    69      dcl	   cm_file_header_ptr     ptr;
  5    70      dcl	   CM_FILE_HEADER_VERSION_1
  5    71 			      char (8) aligned init ("cm_fhdr1")
  5    72 			      int static options (constant);
  5    73 
  5    74 
  5    75      dcl	   collection_id_table    (cit_number_of_collections)
  5    76 			      bit (36) aligned
  5    77 			      based (collection_id_table_ptr);
  5    78 
  5    79      dcl	   collection_id_table_ptr
  5    80 			      ptr;
  5    81      dcl	   cit_number_of_collections
  5    82 			      fixed bin (17);
  5    83 
  5    84 
  5    85 
  5    86 /* ----------End include file dm_cm_file_header.incl.pl1---------- */
  5    87 
      614 
      615 
  6     1 /* BEGIN INCLUDE FILE dm_cm_storage_record.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*
  6     5*        A storage record is an extension to the collection_header structure.
  6     6*   It is expected to be more volatile than collection_header and has a 
  6     7*   different format depending on the control interval storage method in use
  6     8*   for the collection.  A storage record is stored as an element in the 
  6     9*   file's Header Collection with the element identifier 
  6    10*   collection_header.storage_record_element_id.
  6    11*   
  6    12*        The unblocked_storage_record contains the control interval numbers
  6    13*   of the first and last control intervals of a collection.  Unblocked
  6    14*   control intervals are chained together, so all control intervals can be 
  6    15*   found by starting at one end and following the chain forward or backward.
  6    16*   
  6    17*        The blocked_storage_record is not yet used, as the Blocked Control
  6    18*   Interval Storage Method is not yet implemented.
  6    19**/
  6    20 
  6    21 /* HISTORY:
  6    22*Written by Matthew Pierret, 09/24/84.
  6    23*Modified:
  6    24**/
  6    25 
  6    26 /* format: style2,ind3,ll79 */
  6    27 
  6    28      dcl	   1 unblocked_storage_record
  6    29 			      aligned
  6    30 			      based (unblocked_storage_record_ptr),
  6    31 	     2 first_control_interval
  6    32 			      fixed bin (24) uns,
  6    33 	     2 last_control_interval
  6    34 			      fixed bin (24) uns;
  6    35 
  6    36      dcl	   1 blocked_storage_record
  6    37 			      aligned based (blocked_storage_record_ptr),
  6    38 	     2 last_control_interval
  6    39 			      fixed bin (24) uns,
  6    40 	     2 number_of_blocks   fixed bin (17) unal,
  6    41 	     2 number_of_control_intervals_per_block
  6    42 			      fixed bin (17) unal,
  6    43 	     2 allocation_map_element_id
  6    44 			      bit (36) aligned;
  6    45 
  6    46      dcl	   unblocked_storage_record_ptr
  6    47 			      ptr init (null ());
  6    48      dcl	   blocked_storage_record_ptr
  6    49 			      ptr init (null ());
  6    50 
  6    51 /* END INCLUDE FILE dm_cm_storage_record.incl.pl1 */
      616 
      617 
  7     1 /* BEGIN INCLUDE FILE dm_cm_reservation_map.incl.pl1 */
  7     2 
  7     3 /* DESCRIPTION:
  7     4*
  7     5*        The collection_manager_'s file reservation map is used to keep track of
  7     6*   those control intervals which have been reserved by a collection so that
  7     7*   more than one collection in a file do not attempt to use the same control 
  7     8*   interval.  Logically the file reservation map is one long bit string
  7     9*   containing a bit for each control interval of the file.  If the bit for
  7    10*   a control interval is "1"b, that control interval has been reserved.
  7    11*   Actually the map is divided into several fragments represented by 
  7    12*   file_reservation_map_fragment structures, each a bit string of uniform
  7    13*   length and each stored as an element in the Header Collection.  Ideally,
  7    14*   each fragment is stored in a different control interval of the Header 
  7    15*   Collection for enhanced concurrent access to the map.
  7    16*   
  7    17*        To increase speed of reference and concurrent throughput the fragments
  7    18*   are not chained together, but are kept track of by the file_reservation_map
  7    19*   structure.  This structure is an array with each entry describing the
  7    20*   location of a fragment, the number of the control interval for which the
  7    21*   first bit in the fragment represents, and a flag which, if on, indicates 
  7    22*   that there are no unreserved control intervals in the fragment.  This flag
  7    23*   allows for skipping looking at fragments which are already full.
  7    24**/
  7    25 
  7    26 /* HISTORY:
  7    27*Written by Matthew Pierret, 2/23/83.
  7    28*Modified:
  7    29*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  7    30**/
  7    31 
  7    32 /* format: style2,ind3,ll79 */
  7    33 
  7    34      dcl	   1 file_reservation_map (frm_number_of_fragments) aligned
  7    35 			      based (file_reservation_map_ptr),
  7    36 	     2 flags	      unal,
  7    37 	       3 no_control_intervals_are_available
  7    38 			      bit (1) unal,
  7    39 	       3 must_be_zero     bit (11) unal,
  7    40 	     2 lowest_numbered_control_interval
  7    41 			      fixed bin (24) uns unal,
  7    42 	     2 element_id	      bit (36) aligned;
  7    43 
  7    44      dcl	   file_reservation_map_fragment
  7    45 			      aligned
  7    46 			      based (file_reservation_map_fragment_ptr)
  7    47 			      bit (frmf_number_of_control_intervals);
  7    48 
  7    49 
  7    50      dcl	   file_reservation_map_ptr
  7    51 			      ptr;
  7    52      dcl	   frm_number_of_fragments
  7    53 			      fixed bin (17);
  7    54 
  7    55      dcl	   file_reservation_map_fragment_ptr
  7    56 			      ptr;
  7    57      dcl	   frmf_number_of_control_intervals
  7    58 			      fixed bin (17);
  7    59 
  7    60 
  7    61 /* END INCLUDE FILE dm_cm_reservation_map.incl.pl1 */
      618 
      619 
  8     1 /* BEGIN INCLUDE FILE dm_cism_info.incl.pl1 */
  8     2 
  8     3 /* DESCRIPTION:
  8     4*
  8     5*     This include file contains the blocked_cism_info and unblocked_cism_info
  8     6*     structures, as well as constants relevant to control interval storage
  8     7*     management.  These structures and constants are used by several managers.
  8     8*     The structures each describe a method of control interval storage 
  8     9*     management.
  8    10**/
  8    11 
  8    12 /* HISTORY:
  8    13*
  8    14*Written 02/07/82 by Matthew Pierret.
  8    15*Modified:
  8    16*05/17/84 by Matthew Pierret:  Changed to align structure elements and add
  8    17*            a version string.
  8    18**/
  8    19 
  8    20 /* format: style2 */
  8    21 
  8    22      dcl	   1 blocked_cism_info    based (blocked_cism_info_ptr) aligned,
  8    23 	     2 version	      char (8) aligned init (CISM_INFO_VERSION_1),
  8    24 	     2 type	      fixed bin (17) init (BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD),
  8    25 	     2 number_of_control_intervals_per_block
  8    26 			      fixed bin (17);
  8    27 
  8    28      dcl	   1 unblocked_cism_info  based (unblocked_cism_info_ptr) aligned,
  8    29 	     2 version	      char (8) aligned init (CISM_INFO_VERSION_1),
  8    30 	     2 type	      fixed bin (17) init (UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD),
  8    31 	     2 must_be_zero	      fixed bin (17);
  8    32 
  8    33      dcl	   blocked_cism_info_ptr  ptr;
  8    34      dcl	   unblocked_cism_info_ptr
  8    35 			      ptr;
  8    36 
  8    37      dcl	   CISM_INFO_VERSION_1    init ("CISMinf1") char (8) aligned internal static options (constant);
  8    38      dcl	   BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
  8    39 			      fixed bin init (1) internal static options (constant);
  8    40      dcl	   UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
  8    41 			      fixed bin init (2) internal static options (constant);
  8    42 
  8    43 /* END INCLUDE FILE dm_cism_info.incl.pl1 ---------- */
      620 
      621 
  9     1 /* BEGIN INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
  9     2 
  9     3 /* DESCRIPTION:
  9     4*
  9     5*        The collection_manager_ manages the structure of the addressable
  9     6*   portion of a control interval.  The addressable portion is that portion of
  9     7*   a control interval which the file_manager_ will allow the
  9     8*   collection_manager_ to address.  In this description control interval will
  9     9*   be used to mean the addressable portion of a control interval.
  9    10*   
  9    11*        A control interval is divided into four parts: the header, the datum
  9    12*   position table (also known as the slot table or slots), un-used space and
  9    13*   used space.  The beginning of the header is at offset 0, and the end of the
  9    14*   used space is at the end of the control interval (curently offset 4072).
  9    15*   Pictoriarly, a control interval is structured as follows:
  9    16*   
  9    17*   ----------------------------------------------------------------------
  9    18*   |        || | | | | | ||               ||   | / / |       |/|   |    |
  9    19*   | Header || | slot  | || un-used space ||   |/ / /|       |/|   |    |
  9    20*   |        || | table | ||               ||   | / / |       |/|   |    |
  9    21*   |        || | | | | | ||               ||   |/ / /|       |/|   |    |
  9    22*   ----------------------------------------------------------------------
  9    23*                                           ^ ^    ^      ^    ^  ^   ^
  9    24*                                           | |    |      |    |  |   |
  9    25*                                           | |...........|.......|...|
  9    26*                        start of used space|      |           |      |
  9    27*                                                  |           |  each|
  9    28*                                          scattered free space|  is a used
  9    29*                                                                 datum
  9    30*   
  9    31*      The basic_control_interval structure describes the header
  9    32*   (basic_control_interval.header, bci_header) and the slots
  9    33*   (basic_control_interval.datum_position_table, datum_slot for one only).
  9    34*   Each datum_slot contains the offset (in bytes) and the length (in bits) of
  9    35*   a datum in the used space.  If the offset is equal to FREE_SLOT (declared
  9    36*   in dm_cm_basic_ci_const.incl.pl1), the slot is un-used.  The slot also
  9    37*   contains flags describing the type of datum (see dm_cm_datum.incl.pl1).
  9    38**/
  9    39 
  9    40 /* HISTORY:
  9    41*Written by Matthew Pierret, 02/07/82.
  9    42*Modified:
  9    43*03/25/82 by Matthew Pierret: Fixed alignment differences basic_control_interval
  9    44*            and its sub-structures.
  9    45*06/14/82 by Matthew Pierret: Removed common header and buffers. Changed
  9    46*            basic_ci_header to bci_header. Added previous_control_interval.
  9    47*07/12/82 by Matthew Pierret: Changed collection_id to be bit (36) aligned.
  9    48*10/29/82 by Matthew Pierret: Added flags to datum slots. 
  9    49*11/10/82 by Matthew Pierret: Removed continued_datum_is_present flag, as it
  9    50*            is not used.
  9    51*03/28/84 by Matthew Pierret: Added the constants BCI_HEADER_LENGTH_IN_BYTES
  9    52*            and DATUM_POSITION_TABLE_OFFSET_IN_BYTES.
  9    53**/
  9    54 
  9    55 /* format: style2 */
  9    56      dcl	   1 basic_control_interval
  9    57 			      aligned based (basic_control_interval_ptr),
  9    58 	     2 header	      like bci_header,
  9    59 	     2 datum_position_table
  9    60 			      (0 refer (basic_control_interval.number_of_datums)) like datum_slot;
  9    61 
  9    62 
  9    63      dcl	   1 bci_header	      aligned based (bci_header_ptr),
  9    64 	     2 layout_type	      char (4) aligned,
  9    65 	     2 collection_id      bit (36) aligned,
  9    66 	     2 next_control_interval
  9    67 			      fixed bin (24) uns unal,
  9    68 	     2 previous_control_interval
  9    69 			      fixed bin (24) uns unal,
  9    70 	     2 flags	      unal,
  9    71 	       3 continuation_datum_is_present
  9    72 			      bit (1) unal,
  9    73 	       3 free_slot_is_present
  9    74 			      bit (1) unal,
  9    75 	       3 must_be_zero     bit (4) unal,		/* reserved */
  9    76 	     2 scattered_free_space
  9    77 			      fixed bin (17) unal,
  9    78 	     2 start_of_used_space
  9    79 			      fixed bin (17) unal,
  9    80 	     2 number_of_datums   fixed bin (17) unal;
  9    81 
  9    82      dcl	   1 datum_slot	      aligned based (datum_slot_ptr),
  9    83 	     2 flags	      unal,
  9    84 	       3 special_format_datum
  9    85 			      bit (1) unal,		/* reserved */
  9    86 	       3 is_continued     bit (1) unal,
  9    87 	       3 is_continuation  bit (1) unal,
  9    88 	       3 mbz	      bit (1) unal,		/* reserved */
  9    89 	     2 offset_in_bytes    fixed bin (15) uns unal,
  9    90 	     2 length_in_bits     fixed bin (17) uns unal;
  9    91 
  9    92      dcl	   basic_control_interval_ptr
  9    93 			      ptr;
  9    94      dcl	   bci_header_ptr	      ptr;
  9    95      dcl	   datum_slot_ptr	      ptr;
  9    96 
  9    97      dcl	   BASIC_CI_LAYOUT_1      char (4) aligned init ("bci1") internal static options (constant);
  9    98 
  9    99 /* END INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
      622 
      623 
 10     1 /* BEGIN INCLUDE FILE dm_cm_entry_dcls.incl.pl1 */
 10     2 
 10     3 /* DESCRIPTION:
 10     4*
 10     5*   Contains entry declarations of internally available collection_manager_
 10     6*   entries.  Entries which are only available via the collection_manager_
 10     7*   transfer vector are not included here, but are declared instead in 
 10     8*   dm_collmgr_entry_dcls.incl.pl1.
 10     9**/
 10    10 
 10    11 /* HISTORY:
 10    12*Written by Mathew Pierret, 04/01/82.
 10    13*Modified:
 10    14*09/21/82 by Lindsey Spratt:  Added the cm_compact$replacement entry.
 10    15*10/29/82 by Matthew Pierret:  Added cm_find_free_slot, cm_determine_free_space,
 10    16*            cm_find_ci_to_alloc_datum, cm_recursive_put.
 10    17*            Added cm_get_element$info*, $header*.  The former is used when
 10    18*            the caller has a cm_info structure already; the latter is used to
 10    19*            get collection headers.
 10    20*            Added cm_opening_info$get. Removed cm_add_ci_(part thread).
 10    21*            Added cm_allocate_element$info.
 10    22*11/09/82 by Matthew Pierret:  Added argument to cm_allocate_ordered_element
 10    23*            calling sequence for returning free space.
 10    24*            Added cm_free_cn_datum("" $header).
 10    25*01/07/83 by Matthew Pierret:  Added:
 10    26*            cm_allocate_element$buffered("" _info);
 10    27*            cm_put_element$buffered("" _info);
 10    28*            cm_put_datum_in_place$buffered("" _continued);
 10    29*            cm_put_datum_in_pool$buffered("" _continued);
 10    30*            cm_compact$buffered.
 10    31*01/26/83 by Matthew Pierret: Replaced cm_get_header_and_slot with
 10    32*            cm_get_bci_header$slot and added cm_get_bci_header$slot_exclusive.
 10    33*            Added cm_opening_info$get_storage_record.
 10    34*            Added a bit(36)aligned argument to cm_recursive_put to hold the
 10    35*            id of the previous datum.
 10    36*02/02/83 by Matthew Pierret: Added fixed bin (17) argument to cm_find_free_slot
 10    37*            which is for the number of slots after allocation.
 10    38*02/07/83 by Matthew Pierret: Added cm_get_id$(id info info_return_slot
 10    39*            header header_return_slot).
 10    40*            Added cm_get_element_portion$(exclusive info info_exclusive).
 10    41*            Added cm_get_element$bypass_info.
 10    42*03/25/83 by Matthew Pierret: Added cm_free_element$info and
 10    43*            cm_free_opening_info.
 10    44*04/29/83 by Matthew Pierret: Added cm_put_element$unprotected_info
 10    45*08/04/83 by Matthew Pierret:  Added the entries $does_new_datum_fit and
 10    46*            $does_replacement_fit to cm_determine_free_space.  These entries
 10    47*            return flags indicating if a datum fits in the ci and the pool.
 10    48*            Added a bit(1)aligned parameter to cm_find_free_slot in which is
 10    49*            returned the new value of bci_header.free_slot_is_present.
 10    50*02/07/84 by Matthew Pierret:  Added cm_get_id$ptr.  Removed all cm_get_id
 10    51*            modules except cm_get_id$id.  Removed all cm_get_element$info*
 10    52*            entries.  Changed cm_get_element_$bypass_info to have the same
 10    53*            calling sequence as other cm_get_element entries.
 10    54*06/12/84 by Matthew Pierret:  Changed cm_put_element to cm_modify
 10    55*            and cm_allocate_element to cm_put.
 10    56*            Switched the element_length/element_ptr parameter pair to be
 10    57*            element_ptr/element_length in cm_modify and cm_put.
 10    58*07/24/84 by Matthew Pierret:  Added cm_free_ci$raw_return_prev_next.
 10    59*09/24/84 by Matthew Pierret:  Added trace_thread_modifications_(on off)
 10    60*            entries to cm_free_ci and cm_replace_buffered_ci, 
 10    61*            cm_allocate_ci$info_header, cm_opening_info$opening_table_ptr.
 10    62*            Removed cm_find_free_space. Commented out un-used entries.
 10    63*            Re-named allocate  entries to put entries, except for allocate_ci.
 10    64*            Re-named free element and free datum entries to use delete instead
 10    65*            of free, and cm_recursive_put to cm_recursive_modify.
 10    66*            Removed cm_get_element$bypass_info.
 10    67*02/27/85 by Matthew C. Pierret:  Re-added cm_compact$buffered_replacement now
 10    68*            that cm_modify$buffered uses it.
 10    69*03/07/85 by R. Michael Tague:  Added cm_postcommit_increment.
 10    70**/
 10    71 
 10    72 /* format: style2,ind3 */
 10    73 
 10    74 
 10    75      dcl	   cm_allocate_ci	      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
 10    76      dcl	   cm_allocate_ci$info    entry (ptr, fixed bin (24) unsigned, fixed bin (35));
 10    77      dcl	   cm_allocate_ci$info_header
 10    78 			      entry (ptr, fixed bin (24) unsigned, ptr, fixed bin (35));
 10    79 
 10    80 
 10    81      dcl	   cm_compact	      entry (bit (36) aligned, fixed bin (17), bit (36) aligned, ptr, fixed bin (35));
 10    82      dcl	   cm_compact$buffered    entry (ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
 10    83      dcl	   cm_compact$replacement entry (bit (36) aligned, fixed bin (17), bit (36) aligned, ptr, fixed bin (35));
 10    84      dcl	   cm_compact$buffered_replacement
 10    85 			      entry (ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
 10    86 
 10    87      dcl	   cm_delete_cn_datum     entry (ptr, bit (1) aligned, bit (36) aligned, fixed bin (35));
 10    88 
 10    89      dcl	   cm_delete_cn_datum$header
 10    90 			      entry (ptr, ptr, ptr, bit (1) aligned, bit (36) aligned, fixed bin (35));
 10    91 
 10    92      dcl	   cm_delete	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
 10    93 			      fixed bin (35));
 10    94      dcl	   cm_delete$info	      entry (ptr, bit (36) aligned, bit (1) aligned, fixed bin (35));
 10    95 
 10    96      dcl	   cm_determine_free_space$all
 10    97 			      entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35));
 10    98      dcl	   cm_determine_free_space$effective
 10    99 			      entry (ptr, fixed bin (35), bit (1) aligned, bit (1) aligned, fixed bin (35),
 10   100 			      fixed bin (35));
 10   101      dcl	   cm_determine_free_space$does_new_datum_fit
 10   102 			      entry (ptr, fixed bin (35), fixed bin (35), bit (1) aligned, bit (1) aligned,
 10   103 			      bit (1) aligned, bit (1) aligned, fixed bin (35));
 10   104 
 10   105 /**** Not yet used *********************************************************
 10   106*     dcl	   cm_determine_free_space$does_replacement_fit
 10   107*			      entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35), bit (1) aligned,
 10   108*			      bit (1) aligned, bit (1) aligned, bit (1) aligned, fixed bin (35)); 
 10   109*************************************************************************** */
 10   110 
 10   111      dcl	   cm_find_ci_to_alloc_datum
 10   112 			      entry (ptr, fixed bin (35), fixed bin (24) uns, bit (1) aligned, bit (1) aligned, ptr,
 10   113 			      fixed bin (24) uns, fixed bin (35));
 10   114 
 10   115      dcl	   cm_find_free_slot      entry (bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (17), fixed bin (17),
 10   116 			      bit (1) aligned, fixed bin (35));
 10   117 
 10   118      dcl	   cm_free_ci$info	      entry (ptr, fixed bin (24) uns, bit (1) aligned, fixed bin (35));
 10   119      dcl	   cm_free_ci$raw_return_prev_next
 10   120 			      entry (ptr, fixed bin (24) uns, bit (1) aligned, fixed bin (24) uns,
 10   121 			      fixed bin (24) uns, fixed bin (35));
 10   122      dcl	   cm_free_ci$trace_thread_modifications_on
 10   123 			      entry ();
 10   124      dcl	   cm_free_ci$trace_thread_modifications_off
 10   125 			      entry ();
 10   126 
 10   127 
 10   128      dcl	   cm_free_opening_info   entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
 10   129 
 10   130      dcl	   cm_get_bci_header      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
 10   131      dcl	   cm_get_bci_header$exclusive
 10   132 			      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
 10   133      dcl	   cm_get_bci_header$slot entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
 10   134 
 10   135 /**** Not yet used ********************************************************
 10   136*     dcl	   cm_get_bci_header$slot_exclusive
 10   137*			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
 10   138*************************************************************************** */
 10   139 
 10   140      dcl	   cm_get_element	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
 10   141 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
 10   142      dcl	   cm_get_element$exclusive
 10   143 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
 10   144 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
 10   145 
 10   146      dcl	   cm_get_element_portion entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
 10   147 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
 10   148 			      fixed bin (35), fixed bin (35));
 10   149 
 10   150 /**** Not yet used ********************************************************
 10   151*     dcl	   cm_get_element_portion$exclusive
 10   152*			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
 10   153*			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
 10   154*			      fixed bin (35), fixed bin (35));
 10   155*************************************************************************** */
 10   156 
 10   157      dcl	   cm_get_id$id	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin,
 10   158 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
 10   159      dcl	   cm_get_id$ptr	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin,
 10   160 			      bit (1) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
 10   161 
 10   162      dcl	   cm_modify	      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
 10   163 			      fixed bin (35), fixed bin (35));
 10   164      dcl	   cm_modify$buffered     entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
 10   165 			      fixed bin (35), fixed bin (35));
 10   166 
 10   167 /******* Not yet used *****************************************************
 10   168*     dcl	   cm_modify$buffered_info
 10   169*			      entry (ptr, ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35),
 10   170*			      fixed bin (35));
 10   171*****************************************************************************/
 10   172 
 10   173      dcl	   cm_modify$info	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
 10   174      dcl	   cm_modify$unprotected_info
 10   175 			      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
 10   176 
 10   177 
 10   178 /******* Not yet used *****************************************************
 10   179*     dcl	   cm_modify_portion entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35),
 10   180*			      fixed bin (35), ptr, bit (36) aligned, fixed bin (35), fixed bin (35));
 10   181*****************************************************************************/
 10   182 
 10   183 
 10   184      dcl	   cm_opening_info$get    entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
 10   185      dcl	   cm_opening_info$get_storage_record
 10   186 			      entry (ptr, fixed bin (35));
 10   187      dcl	   cm_opening_info$full_get
 10   188 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
 10   189      dcl	   cm_opening_info$opening_table_ptr
 10   190 			      entry () returns (ptr);
 10   191 
 10   192      dcl	   cm_postcommit_increment
 10   193 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
 10   194 
 10   195      dcl	   cm_put		      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
 10   196 			      fixed bin (35), fixed bin (35));
 10   197      dcl	   cm_put$buffered	      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
 10   198 			      fixed bin (35), fixed bin (35));
 10   199 
 10   200 /******* Not yet used *****************************************************
 10   201*     dcl	   cm_put$buffered_info
 10   202*			      entry (ptr, ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35),
 10   203*			      fixed bin (35));
 10   204*****************************************************************************/
 10   205 
 10   206      dcl	   cm_put$info	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
 10   207 
 10   208      dcl	   cm_put_basic_element   entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
 10   209 			      fixed bin (35));
 10   210 
 10   211      dcl	   cm_put_cn_datum	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, bit (36) aligned, fixed bin (35));
 10   212 
 10   213      dcl	   cm_put_datum_in_place  entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
 10   214 			      fixed bin (35));
 10   215      dcl	   cm_put_datum_in_place$buffered
 10   216 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
 10   217      dcl	   cm_put_datum_in_place$buffered_continued
 10   218 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (36) aligned,
 10   219 			      fixed bin (35));
 10   220      dcl	   cm_put_datum_in_place$continued
 10   221 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
 10   222 			      fixed bin (35), bit (36) aligned, fixed bin (35));
 10   223 
 10   224      dcl	   cm_put_datum_in_pool   entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
 10   225 			      fixed bin (35));
 10   226      dcl	   cm_put_datum_in_pool$buffered
 10   227 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
 10   228      dcl	   cm_put_datum_in_pool$buffered_continued
 10   229 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (36) aligned,
 10   230 			      fixed bin (35));
 10   231      dcl	   cm_put_datum_in_pool$continued
 10   232 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
 10   233 			      fixed bin (35), bit (36) aligned, fixed bin (35));
 10   234 
 10   235      dcl	   cm_put_ordered_element entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
 10   236 			      fixed bin (35));
 10   237      dcl	   cm_put_ordered_element$buffered
 10   238 			      entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
 10   239 			      fixed bin (35));
 10   240 
 10   241      dcl	   cm_put_overlength_tail entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35));
 10   242 
 10   243      dcl	   cm_recursive_modify    entry (ptr, bit (36) aligned, ptr, fixed bin (35), fixed bin (35), bit (36) aligned,
 10   244 			      fixed bin (35));
 10   245 
 10   246 
 10   247      dcl	   cm_replace_buffered_ci$trace_thread_modifications_on
 10   248 			      entry ();
 10   249      dcl	   cm_replace_buffered_ci$trace_thread_modifications_off
 10   250 			      entry ();
 10   251 
 10   252 /* END INCLUDE FILE dm_cm_entry_dcls.incl.pl1 */
      624 
      625 
 11     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
 11     2 /* format: style3 */
 11     3 
 11     4 /* These constants are to be used for the flags argument of sub_err_ */
 11     5 /* They are just "string (condition_info_header.action_flags)" */
 11     6 
 11     7 declare	(
 11     8 	ACTION_CAN_RESTART	init (""b),
 11     9 	ACTION_CANT_RESTART init ("1"b),
 11    10 	ACTION_DEFAULT_RESTART
 11    11 			init ("01"b),
 11    12 	ACTION_QUIET_RESTART
 11    13 			init ("001"b),
 11    14 	ACTION_SUPPORT_SIGNAL
 11    15 			init ("0001"b)
 11    16 	)		bit (36) aligned internal static options (constant);
 11    17 
 11    18 /* End include file */
      626 
      627 
      628    end cm_free_ci;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/04/85  0912.6  cm_free_ci.pl1                    >spec>on>7192.pbf-04/04/85>cm_free_ci.pl1
606          1    01/07/85  0858.8  dm_hdr_collection_id.incl.pl1     >ldd>include>dm_hdr_collection_id.incl.pl1
608          2    01/07/85  0858.4  dm_cm_hdr_col_ids.incl.pl1        >ldd>include>dm_cm_hdr_col_ids.incl.pl1
610          3    01/07/85  0858.4  dm_cm_info.incl.pl1               >ldd>include>dm_cm_info.incl.pl1
612          4    01/07/85  0858.2  dm_cm_collection_header.incl.pl1  >ldd>include>dm_cm_collection_header.incl.pl1
614          5    01/07/85  0858.3  dm_cm_file_header.incl.pl1        >ldd>include>dm_cm_file_header.incl.pl1
616          6    01/07/85  0858.4  dm_cm_storage_record.incl.pl1     >ldd>include>dm_cm_storage_record.incl.pl1
618          7    01/07/85  0858.4  dm_cm_reservation_map.incl.pl1    >ldd>include>dm_cm_reservation_map.incl.pl1
620          8    01/07/85  0858.0  dm_cism_info.incl.pl1             >ldd>include>dm_cism_info.incl.pl1
622          9    01/07/85  0858.0  dm_cm_basic_ci.incl.pl1           >ldd>include>dm_cm_basic_ci.incl.pl1
624         10    04/04/85  0819.0  dm_cm_entry_dcls.incl.pl1         >spec>on>7192.pbf-04/04/85>dm_cm_entry_dcls.incl.pl1
626         11    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000041 constant        bit(36)                  initial dcl 11-7 set ref 439* 584* 599*
BASIC_CI_LAYOUT_1               000000 constant        char(4)                  initial dcl 9-97 set ref 599 599*
BITS_PER_WORD                          constant        fixed bin(17,0)          initial dcl 145 ref 255
BYTES_PER_WORD                         constant        fixed bin(17,0)          initial dcl 146 ref 374 386
CM_FILE_HEADER_ELEMENT_ID       000046 constant        bit(36)                  initial dcl 2-21 set ref 242*
CM_FILE_HEADER_VERSION_1        000002 constant        char(8)                  initial dcl 5-70 set ref 248*
CM_INFO_VERSION_2               000006 constant        char(8)                  initial dcl 3-48 set ref 214*
COLLECTION_HEADER_VERSION_2     000004 constant        char(8)                  initial dcl 4-86 set ref 218*
HEADER_COLLECTION_ID            000050 constant        bit(36)                  initial dcl 1-19 set ref 229* 242* 265* 286*
NO_CONTROL_INTERVAL                    constant        fixed bin(24,0)          initial unsigned dcl 147 ref 327 346
OFFSET_OF_BCI_HEADER            000042 constant        fixed bin(21,0)          initial dcl 148 set ref 374* 386*
UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
                                       constant        fixed bin(17,0)          initial dcl 8-40 ref 235
addr                                                   builtin function         dcl 139 ref 242 242 265 265 286 286 302 336 336 355
                                                                                  355 374 374 386 386
allocation_map_element_id
                          5            based           bit(36)                  level 2 dcl 5-55 set ref 265* 414*
automatic_bci_header            000120 automatic       structure                level 1 dcl 129 set ref 302
automatic_cm_file_header        000125 automatic       structure                level 1 dcl 130 set ref 242 242 242 242
bci_header                             based           structure                level 1 dcl 9-63
bci_header_ptr                  000162 automatic       pointer                  dcl 9-94 set ref 302* 304* 308 310 313 314 341 359
blocked_storage_record_ptr      000150 automatic       pointer                  initial dcl 6-48 set ref 6-48*
ccv_p_given_version                    parameter       char(4)                  dcl 597 set ref 594 599 599*
cm_file_header                         based           structure                level 1 dcl 5-55
cm_file_header_ptr              000144 automatic       pointer                  dcl 5-69 set ref 242* 248 250 251 265 414
cm_get_bci_header               000034 constant        entry                    external dcl 10-130 ref 336 355
cm_get_bci_header$exclusive     000036 constant        entry                    external dcl 10-131 ref 304
cm_get_element                  000040 constant        entry                    external dcl 10-140 ref 242 265
cm_get_element$exclusive        000042 constant        entry                    external dcl 10-142 ref 286
cm_info                                based           structure                level 1 dcl 3-37
cm_info_ptr                     000140 automatic       pointer                  initial dcl 3-47 set ref 182* 196* 206* 214 216 229
                                                                                  242 3-47* 265 286 304 310 336 355 374 386 398 565
                                                                                  565* 571
cm_modify$info                  000044 constant        entry                    external dcl 10-173 ref 405 414 423
cm_opening_info$get             000046 constant        entry                    external dcl 10-184 ref 182 229
cm_opening_info$get_storage_record
                                000050 constant        entry                    external dcl 10-185 ref 565
code                            000100 automatic       fixed bin(35,0)          dcl 119 set ref 180* 182* 183 183* 195* 205* 229*
                                                                                  230 230* 242* 245 245* 265* 268 268* 286* 289 289*
                                                                                  304* 305 305* 336* 338 338* 355* 356 356* 374* 377
                                                                                  377* 386* 388 388* 398* 399 399* 405* 407 407*
                                                                                  423* 425 425*
collection_header                      based           structure                level 1 dcl 4-65
collection_header_ptr           000142 automatic       pointer                  dcl 4-85 set ref 216* 218 235 423 439
collection_header_was_updated   000135 automatic       bit(1)                   dcl 133 set ref 212* 332* 351* 420
collection_id             1            based           bit(36)                  level 2 in structure "bci_header" dcl 9-63
                                                                                  in procedure "cm_free_ci" ref 310
collection_id             4            based           bit(36)                  initial level 2 in structure "cm_info" dcl 3-37
                                                                                  in procedure "cm_free_ci" ref 310
control_interval_number         000101 automatic       fixed bin(24,0)          unsigned dcl 120 set ref 220* 222 271 271 292 297
                                                                                  304* 366* 398*
control_interval_storage_method
                          2(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 4-65 set ref 235 439*
cv_p_correct_version                   parameter       char(8)                  dcl 582 set ref 577 584 584*
cv_p_given_version                     parameter       char(8)                  dcl 581 set ref 577 584 584*
cv_p_structure_name                    parameter       char                     unaligned dcl 580 set ref 577 584*
datum_slot                             based           structure                level 1 dcl 9-82
divide                                                 builtin function         dcl 139 ref 255
dm_error_$ci_0_invalid_free     000022 external static fixed bin(35,0)          dcl 161 set ref 222*
dm_error_$ci_not_in_collection  000024 external static fixed bin(35,0)          dcl 163 set ref 280* 310*
dm_error_$unimplemented_ci_version
                                000026 external static fixed bin(35,0)          dcl 165 set ref 599*
dm_error_$unimplemented_cism    000030 external static fixed bin(35,0)          dcl 167 set ref 439*
element_id                1            based           bit(36)                  array level 2 dcl 7-34 set ref 286* 405*
er_p_code                              parameter       fixed bin(35,0)          dcl 544 ref 541 546
error_table_$unimplemented_version
                                000032 external static fixed bin(35,0)          dcl 169 set ref 584*
file_manager_$free              000012 constant        entry                    external dcl 152 ref 398
file_manager_$simple_put        000014 constant        entry                    external dcl 153 ref 374 386
file_oid                  3            based           bit(36)                  initial level 2 dcl 3-37 set ref 229* 242* 265* 286*
                                                                                  304* 336* 355* 374* 386* 398*
file_reservation_map                   based           structure                array level 1 dcl 7-34
file_reservation_map_buffer     000100 automatic       fixed bin(71,0)          array dcl 257 set ref 265 265 265 265
file_reservation_map_fragment          based           bit                      dcl 7-44 set ref 292 297*
file_reservation_map_fragment_ptr
                                000156 automatic       pointer                  dcl 7-55 set ref 286* 292 297 405*
file_reservation_map_ptr        000152 automatic       pointer                  dcl 7-50 set ref 265* 271 271 286 292 297 405 410
                                                                                  413 414*
first_control_interval                 based           fixed bin(24,0)          level 2 unsigned dcl 6-28 set ref 331*
flags                                  based           structure                array level 2 packed unaligned dcl 7-34
fragment_buffer                 000100 automatic       fixed bin(71,0)          array dcl 255 set ref 286 286 286 286
frm_number_of_fragments         000154 automatic       fixed bin(17,0)          dcl 7-52 set ref 251* 257 271 280
frmf_number_of_control_intervals
                                000160 automatic       fixed bin(17,0)          dcl 7-57 set ref 250* 255 271 292 297
gsr_code                        000130 automatic       fixed bin(35,0)          initial dcl 563 set ref 563* 565* 568 568*
gsr_p_storage_record_ptr        000126 automatic       pointer                  dcl 561 set ref 571* 573
hc_cm_info_ptr                  000102 automatic       pointer                  initial dcl 122 set ref 122* 229* 405* 414* 423*
header_ptr                6            based           pointer                  initial level 2 dcl 3-37 ref 216
ioa_                            000016 constant        entry                    external dcl 156 ref 366 379 390
last_control_interval
                          1            based           fixed bin(24,0)          level 2 unsigned dcl 6-28 set ref 350*
layout_type                            based           char(4)                  level 2 dcl 9-63 set ref 308* 341* 359*
length                                                 builtin function         dcl 139 ref 242 242 265 265 286 286
lowest_numbered_control_interval
                          0(12)        based           fixed bin(24,0)          array level 2 packed unsigned unaligned dcl 7-34 ref
                                                                                  271 271 292 297
map_idx                         000134 automatic       fixed bin(17,0)          dcl 132 set ref 271* 271 271* 280 286 292 297 405
                                                                                  410 413
myname                          000010 constant        varying char(32)         initial dcl 144 set ref 439* 584* 599*
next_bci_header                 000112 automatic       structure                level 1 dcl 126 set ref 355 355 386 386 386
next_control_interval
                          2            based           fixed bin(24,0)          level 2 in structure "bci_header" packed unsigned
                                                                                  unaligned dcl 9-63 in procedure "cm_free_ci" ref
                                                                                  314
next_control_interval
                          2     000104 automatic       fixed bin(24,0)          level 2 in structure "previous_bci_header" packed
                                                                                  unsigned unaligned dcl 123 in procedure
                                                                                  "cm_free_ci" set ref 343* 379*
next_control_interval           000117 automatic       fixed bin(24,0)          unsigned dcl 127 in procedure "cm_free_ci" set ref
                                                                                  314* 331 343 346 355* 383 386 390* 435
no_control_intervals_are_available     based           bit(1)                   array level 3 packed unaligned dcl 7-34 set ref 410
                                                                                  413*
null                                                   builtin function         dcl 139 ref 122 242 242 439 439 3-47 6-46 6-48 265
                                                                                  265 286 286 565 584 584 599 599
number_of_blocks          3(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 5-55 ref 251
number_of_control_intervals_per_block
                          4            based           fixed bin(17,0)          level 2 dcl 5-55 ref 250
p_cm_info_ptr                          parameter       pointer                  dcl 104 ref 191 196 200 206
p_code                                 parameter       fixed bin(35,0)          dcl 115 set ref 98 191 200 210* 546*
p_collection_id                        parameter       bit(36)                  dcl 106 set ref 98 182*
p_control_interval_number              parameter       fixed bin(24,0)          unsigned dcl 107 ref 98 191 200 220
p_file_opening_id                      parameter       bit(36)                  dcl 105 set ref 98 182*
p_next_control_interval_number         parameter       fixed bin(24,0)          unsigned dcl 113 set ref 200 435*
p_previous_control_interval_number     parameter       fixed bin(24,0)          unsigned dcl 111 set ref 200 434*
p_zero_on_free                         parameter       bit(1)                   dcl 109 ref 98 191 200
previous_bci_header             000104 automatic       structure                level 1 dcl 123 set ref 336 336 374 374 374
previous_control_interval
                          2(24)        based           fixed bin(24,0)          level 2 in structure "bci_header" packed unsigned
                                                                                  unaligned dcl 9-63 in procedure "cm_free_ci" ref
                                                                                  313
previous_control_interval
                          2(24) 000112 automatic       fixed bin(24,0)          level 2 in structure "next_bci_header" packed
                                                                                  unsigned unaligned dcl 126 in procedure
                                                                                  "cm_free_ci" set ref 361* 390*
previous_control_interval       000111 automatic       fixed bin(24,0)          unsigned dcl 124 in procedure "cm_free_ci" set ref
                                                                                  313* 327 336* 350 361 371 374 379* 434
return_prev_and_next_ci         000136 automatic       bit(1)                   dcl 133 set ref 179* 194* 204* 431
size                                                   builtin function         dcl 139 ref 374 386
static_trace_thread_switch      000010 internal static bit(1)                   initial dcl 174 set ref 366 379 390 525* 530*
storage_record_element_id
                          6            based           bit(36)                  level 2 dcl 4-65 set ref 423*
storage_record_ptr       10            based           pointer                  initial level 2 dcl 3-37 ref 565 571
sub_err_                        000020 constant        entry                    external dcl 157 ref 439 584 599
substr                                                 builtin function         dcl 139 set ref 292 297*
this_is_raw_free                000137 automatic       bit(1)                   dcl 133 set ref 179* 194* 204* 316
unblocked_storage_record               based           structure                level 1 dcl 6-28
unblocked_storage_record_ptr    000146 automatic       pointer                  initial dcl 6-46 set ref 6-46* 330* 331 349* 350
                                                                                  423*
unspec                                                 builtin function         dcl 139 ref 242 242 265 265 286 286
version                                based           char(8)                  level 2 in structure "cm_file_header" dcl 5-55
                                                                                  in procedure "cm_free_ci" set ref 248*
version                                based           char(8)                  level 2 in structure "cm_info" dcl 3-37 in procedure
                                                                                  "cm_free_ci" set ref 214*
version                                based           char(8)                  level 2 in structure "collection_header" dcl 4-65
                                                                                  in procedure "cm_free_ci" set ref 218*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 11-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 11-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 11-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 11-7
BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
                                       internal static fixed bin(17,0)          initial dcl 8-38
CALLER_HEADER_ELEMENT_ID               internal static bit(36)                  initial dcl 2-21
CISM_INFO_VERSION_1                    internal static char(8)                  initial dcl 8-37
HEADER_COLLECTION_HEADER_ELEMENT_ID    internal static bit(36)                  initial dcl 2-21
basic_control_interval                 based           structure                level 1 dcl 9-56
basic_control_interval_ptr             automatic       pointer                  dcl 9-92
blocked_cism_info                      based           structure                level 1 dcl 8-22
blocked_cism_info_ptr                  automatic       pointer                  dcl 8-33
blocked_storage_record                 based           structure                level 1 dcl 6-36
cit_number_of_collections              automatic       fixed bin(17,0)          dcl 5-81
cm_allocate_ci                  000000 constant        entry                    external dcl 10-75
cm_allocate_ci$info             000000 constant        entry                    external dcl 10-76
cm_allocate_ci$info_header      000000 constant        entry                    external dcl 10-77
cm_compact                      000000 constant        entry                    external dcl 10-81
cm_compact$buffered             000000 constant        entry                    external dcl 10-82
cm_compact$buffered_replacement 000000 constant        entry                    external dcl 10-84
cm_compact$replacement          000000 constant        entry                    external dcl 10-83
cm_delete                       000000 constant        entry                    external dcl 10-92
cm_delete$info                  000000 constant        entry                    external dcl 10-94
cm_delete_cn_datum              000000 constant        entry                    external dcl 10-87
cm_delete_cn_datum$header       000000 constant        entry                    external dcl 10-89
cm_determine_free_space$all     000000 constant        entry                    external dcl 10-96
cm_determine_free_space$does_new_datum_fit
                                000000 constant        entry                    external dcl 10-101
cm_determine_free_space$effective
                                000000 constant        entry                    external dcl 10-98
cm_find_ci_to_alloc_datum       000000 constant        entry                    external dcl 10-111
cm_find_free_slot               000000 constant        entry                    external dcl 10-115
cm_free_ci$info                 000000 constant        entry                    external dcl 10-118
cm_free_ci$raw_return_prev_next 000000 constant        entry                    external dcl 10-119
cm_free_ci$trace_thread_modifications_off
                                000000 constant        entry                    external dcl 10-124
cm_free_ci$trace_thread_modifications_on
                                000000 constant        entry                    external dcl 10-122
cm_free_opening_info            000000 constant        entry                    external dcl 10-128
cm_get_bci_header$slot          000000 constant        entry                    external dcl 10-133
cm_get_element_portion          000000 constant        entry                    external dcl 10-146
cm_get_id$id                    000000 constant        entry                    external dcl 10-157
cm_get_id$ptr                   000000 constant        entry                    external dcl 10-159
cm_modify                       000000 constant        entry                    external dcl 10-162
cm_modify$buffered              000000 constant        entry                    external dcl 10-164
cm_modify$unprotected_info      000000 constant        entry                    external dcl 10-174
cm_opening_info$full_get        000000 constant        entry                    external dcl 10-187
cm_opening_info$opening_table_ptr
                                000000 constant        entry                    external dcl 10-189
cm_postcommit_increment         000000 constant        entry                    external dcl 10-192
cm_put                          000000 constant        entry                    external dcl 10-195
cm_put$buffered                 000000 constant        entry                    external dcl 10-197
cm_put$info                     000000 constant        entry                    external dcl 10-206
cm_put_basic_element            000000 constant        entry                    external dcl 10-208
cm_put_cn_datum                 000000 constant        entry                    external dcl 10-211
cm_put_datum_in_place           000000 constant        entry                    external dcl 10-213
cm_put_datum_in_place$buffered  000000 constant        entry                    external dcl 10-215
cm_put_datum_in_place$buffered_continued
                                000000 constant        entry                    external dcl 10-217
cm_put_datum_in_place$continued 000000 constant        entry                    external dcl 10-220
cm_put_datum_in_pool            000000 constant        entry                    external dcl 10-224
cm_put_datum_in_pool$buffered   000000 constant        entry                    external dcl 10-226
cm_put_datum_in_pool$buffered_continued
                                000000 constant        entry                    external dcl 10-228
cm_put_datum_in_pool$continued  000000 constant        entry                    external dcl 10-231
cm_put_ordered_element          000000 constant        entry                    external dcl 10-235
cm_put_ordered_element$buffered 000000 constant        entry                    external dcl 10-237
cm_put_overlength_tail          000000 constant        entry                    external dcl 10-241
cm_recursive_modify             000000 constant        entry                    external dcl 10-243
cm_replace_buffered_ci$trace_thread_modifications_off
                                000000 constant        entry                    external dcl 10-249
cm_replace_buffered_ci$trace_thread_modifications_on
                                000000 constant        entry                    external dcl 10-247
collection_id_table                    based           bit(36)                  array dcl 5-75
collection_id_table_ptr                automatic       pointer                  dcl 5-79
datum_slot_ptr                         automatic       pointer                  dcl 9-95
unblocked_cism_info                    based           structure                level 1 dcl 8-28
unblocked_cism_info_ptr                automatic       pointer                  dcl 8-34

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_CI_VERSION                002265 constant        entry                    internal dcl 594 ref 308 341 359
CHECK_VERSION                   002163 constant        entry                    internal dcl 577 ref 214 218 248
ERROR_RETURN                    002102 constant        entry                    internal dcl 541 ref 183 222 230 245 268 280 289 305
                                                                                  310 338 356 377 388 399 407 425 568
FIND_APPROPRIATE_BLOCK_LOOP     000721 constant        label                    dcl 271
FINISH                          002117 constant        entry                    internal dcl 553 ref 547
GET_STORAGE_RECORD_PTR          002121 constant        entry                    internal dcl 558 ref 330 349
JOIN                            000361 constant        label                    dcl 210 ref 187 198 208
MAIN_RETURN                     002047 constant        label                    dcl 519 ref 536 548
RETURN                          002075 constant        entry                    internal dcl 533 ref 292
UB_BEGIN_BLOCK                  000612 constant        label                    dcl 253
UNBLOCKED                       000502 constant        label                    dcl 235
UPDATE_PREV_AND_NEXT_CI         001201 constant        label                    dcl 316
cm_free_ci                      000224 constant        entry                    external dcl 98
info                            000300 constant        entry                    external dcl 191
raw_return_prev_next            000333 constant        entry                    external dcl 200
trace_thread_modifications_off  002064 constant        entry                    external dcl 528
trace_thread_modifications_on   002051 constant        entry                    external dcl 523

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2644        2716    2351        2654
Length      3370    2351        52         436     272           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cm_free_ci                          276 external procedure  is an external procedure.  
begin block on line 253             212 begin block         uses auto adjustable storage.  
RETURN                                  internal procedure  shares stack frame of begin block on line 253.  
ERROR_RETURN                         70 internal procedure  is called by several nonquick procedures.  
FINISH                                  internal procedure  shares stack frame of internal procedure ERROR_RETURN.  
GET_STORAGE_RECORD_PTR                  internal procedure  shares stack frame of begin block on line 253.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure cm_free_ci.  
CHECK_CI_VERSION                        internal procedure  shares stack frame of begin block on line 253.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 static_trace_thread_switch  cm_free_ci

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
begin block on line 253  000100 fragment_buffer             begin block on line 253
                         000100 file_reservation_map_buffer begin block on line 253
                         000126 gsr_p_storage_record_ptr    GET_STORAGE_RECORD_PTR
                         000130 gsr_code                    GET_STORAGE_RECORD_PTR
cm_free_ci               000100 code                        cm_free_ci
                         000101 control_interval_number     cm_free_ci
                         000102 hc_cm_info_ptr              cm_free_ci
                         000104 previous_bci_header         cm_free_ci
                         000111 previous_control_interval   cm_free_ci
                         000112 next_bci_header             cm_free_ci
                         000117 next_control_interval       cm_free_ci
                         000120 automatic_bci_header        cm_free_ci
                         000125 automatic_cm_file_header    cm_free_ci
                         000134 map_idx                     cm_free_ci
                         000135 collection_header_was_updated
                                                            cm_free_ci
                         000136 return_prev_and_next_ci     cm_free_ci
                         000137 this_is_raw_free            cm_free_ci
                         000140 cm_info_ptr                 cm_free_ci
                         000142 collection_header_ptr       cm_free_ci
                         000144 cm_file_header_ptr          cm_free_ci
                         000146 unblocked_storage_record_ptr
                                                            cm_free_ci
                         000150 blocked_storage_record_ptr  cm_free_ci
                         000152 file_reservation_map_ptr    cm_free_ci
                         000154 frm_number_of_fragments     cm_free_ci
                         000156 file_reservation_map_fragment_ptr
                                                            cm_free_ci
                         000160 frmf_number_of_control_intervals
                                                            cm_free_ci
                         000162 bci_header_ptr              cm_free_ci

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
enter_begin         leave_begin         call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return              tra_ext             alloc_auto_adj      ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cm_get_bci_header             cm_get_bci_header$exclusive   cm_get_element                cm_get_element$exclusive
cm_modify$info                cm_opening_info$get           cm_opening_info$get_storage_record
file_manager_$free            file_manager_$simple_put      ioa_                          sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$ci_0_invalid_free   dm_error_$ci_not_in_collection
dm_error_$unimplemented_ci_version                          dm_error_$unimplemented_cism
error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    122 000210    3   47 000212    6   46 000213    6   48 000214        98 000217       179 000241       180 000243
    182 000244       183 000262       187 000272       191 000273       194 000315       195 000317       196 000320
    198 000324       200 000325       204 000350       205 000353       206 000354       208 000360       210 000361
    212 000362       214 000363       216 000404       218 000407       220 000434       222 000436       229 000446
    230 000464       235 000474       242 000502       245 000550       248 000560       250 000603       251 000606
    253 000612       255 000615       257 000630       265 000636       268 000707       271 000721       278 000746
    280 000750       286 000763       289 001040       292 001052       297 001071       302 001106       304 001110
    305 001126       308 001140       310 001147       313 001165       314 001174       316 001177       327 001201
    330 001203       331 001211       332 001214       333 001216       336 001217       338 001237       341 001251
    343 001260       346 001264       349 001266       350 001274       351 001300       352 001302       355 001303
    356 001323       359 001335       361 001344       366 001351       371 001373       374 001376       377 001426
    379 001440       383 001467       386 001472       388 001522       390 001534       398 001565       399 001606
    405 001620       407 001650       410 001662       413 001672       414 001674       420 001722       423 001725
    425 001752       431 001764       434 001767       435 001772       437 001774       438 001775       439 001776
    519 002047       523 002050       525 002057       526 002062       528 002063       530 002072       531 002074
    533 002075       536 002076       541 002101       546 002107       547 002113       548 002114       553 002117
    556 002120       558 002121       563 002123       565 002124       568 002143       571 002154       573 002160
    577 002163       584 002174       589 002264       594 002265       599 002267       602 002346       604 002347


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
