	COMPILATION LISTING OF SEGMENT probe_variable_mgr_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 11/11/88  1547.7 mst Fri
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(88-08-24,WAAnderson), approve(88-09-30,MCR7952),
       16*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
       17*     Added support for 'char', 'long' and 'double' data types.
       18*  2) change(88-09-07,WAAnderson), approve(88-09-30,MCR7952),
       19*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
       20*     Added format control comment to make the source more readable.
       21*                                                   END HISTORY COMMENTS */
       22 
       23 
       24 /* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       25 
       26 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       27 
       28 probe_variable_mgr_:
       29   proc;
       30 
       31   /* Here are the entry points for probe variables:
       32*    create_variable		to make one
       33*    find_variable		to search for one
       34*    list_variable		to list a single var
       35*    list_var_ptr		to list a var given ptr
       36*    list_all_variables	to list them all
       37*
       38*
       39*   INITIAL IMPLEMENTATION 20 Feb 80 by Jim Davis
       40*
       41*   "Plan to write one and throw it away."
       42*
       43*   We have a static pointer to the chain of the variables
       44*   We search linearly, placing new variables at the head, in the hope that they
       45*   are the most likely to be referenced.
       46*   Names may come in with a % in front
       47*
       48**/
       49   /* Add unaligned pointers 12/04/81 S. Herbst */
       50   /* Add external variables 04/26/82 S. Herbst */
       51   /* Replaced create_variable's P_external_sw / P_address_type & P_address_ptr for "dcl defined" 03/12/84 S.Herbst */
       52 
       53   dcl P_probe_info_ptr	ptr aligned parameter;
       54 				/* used by all */
       55   dcl P_variable_name	char (64) varying parameter;
       56   dcl P_variable_type	char (64) varying parameter;
       57   dcl P_unaligned_sw	bit (1) aligned parameter;
       58   dcl P_address_type	fixed bin;
       59   dcl P_address_ptr		ptr;
       60   dcl P_force_creation	bit (1) aligned parameter;
       61   dcl P_reference_node_ptr	ptr aligned parameter;
       62 				/* fill in during lookup */
       63   dcl P_var_info_ptr	ptr unal parameter;
       64   dcl P_code		fixed bin (35) parameter;
       65 
       66   dcl start_of_chain	ptr unal internal static init (null ());
       67 
       68   dcl normal_name		char (64) varying;
       69   dcl (seg_name, entry_point_name)
       70 			char (64);
       71   dcl var_ptr		ptr;
       72   dcl i			fixed bin;
       73 
       74   dcl 1 ref		aligned like reference_node based (refp);
       75   dcl refp		ptr;
       76 
       77   dcl (
       78       PROBE_VAR_INTEGER_TYPE	init (1), /* fixed bin short */
       79       PROBE_VAR_FLOAT_TYPE	init (3), /* float bin  short */
       80       PROBE_VAR_POINTER_TYPE	init (13),/* ITS ptr */
       81       PROBE_VAR_CHAR_TYPE	init (21),/* char */
       82       PROBE_VAR_LONG_TYPE	init (2), /* long */
       83       PROBE_VAR_DOUBLE_TYPE	init (4)	/* double */
       84       )			fixed bin static internal options (constant);
       85 
       86   dcl 1 name_to_type	(6) internal static options (constant),
       87        2 names		(5) char (32)
       88 			init ("fixed", "integer", "int", "comp-6",
       89 			"computational-6",
       90 			"float", "real", "real", "real", "real",
       91 			"pointer", "ptr", "ptr", "ptr", "ptr",
       92 			"double", "dbl", "dbl", "dbl", "dbl",
       93 			"char", "char", "char", "char", "char",
       94 			"long", "long", "long", "long", "long"),
       95        2 type		init (1, 3, 13, 4, 21, 2);
       96 
       97   dcl type_to_make		fixed bin;
       98 
       99   dcl (
      100       probe_et_$var_exists,		/* already is one */
      101       probe_et_$bad_dcl_type,
      102       probe_et_$no_vars,		/* there aren't any at all */
      103       probe_et_$var_doesnt_exist	/* specific one missing */
      104       )			fixed bin (35) external static;
      105 
      106   dcl get_external_variable_	entry (char (*), ptr, fixed bin (19), ptr,
      107 			fixed bin (35));
      108   dcl hcs_$make_ptr		entry (ptr, char (*), char (*), ptr,
      109 			fixed bin (35));
      110   dcl ioa_$ioa_switch	entry options (variable);
      111 
      112   dcl (index, length, null, pointer, substr)
      113 			builtin;
      114 
      115 MAIN_RETURN:
      116   return;
      117 
      118 create_variable:
      119   entry (P_probe_info_ptr, P_variable_name, P_variable_type, P_unaligned_sw,
      120        P_address_type, P_address_ptr, P_force_creation, P_var_info_ptr,
      121        P_code);
      122 
      123   probe_info_ptr = P_probe_info_ptr;
      124   P_code = 0;
      125 
      126   type_to_make = what_type_is ((P_variable_type));
      127   if type_to_make < 0 then do;
      128       P_code = probe_et_$bad_dcl_type;
      129       goto MAIN_RETURN;
      130     end;
      131 
      132   normal_name = normalize_name ((P_variable_name));
      133   probe_variable_ptr = find_var_info (normal_name);
      134 
      135   if probe_variable_ptr ^= null ()
      136     then
      137          if P_force_creation
      138 	 then call delete_current ();
      139 	 else do;
      140 	   P_code = probe_et_$var_exists;
      141 	   goto MAIN_RETURN;
      142 	 end;
      143 
      144   if P_address_type = ADDRESS_EXTERNAL_TYPE then do;
      145       i = index (normal_name, "$");
      146       if i ^= 0 then do;
      147 	seg_name = substr (normal_name, 1, i - 1);
      148 	if i < length (normal_name)
      149 	  then entry_point_name = substr (normal_name, i + 1);
      150 	  else entry_point_name = seg_name;
      151 	call hcs_$make_ptr (null, seg_name, entry_point_name, var_ptr,
      152 	     P_code);
      153 	if var_ptr = null
      154 	  then goto MAIN_RETURN;
      155 	if i = length (normal_name)
      156 	  then var_ptr = pointer (var_ptr, 0);
      157 				/* foo$ means base of segment foo */
      158         end;
      159         else do;
      160 	call get_external_variable_ ((normal_name), var_ptr, 0, null,
      161 	     P_code);
      162 	if P_code ^= 0
      163 	  then goto MAIN_RETURN;
      164         end;
      165     end;
      166 
      167   allocate probe_variable;
      168   probe_variable.name = normal_name;
      169   probe_variable.declared_type = P_variable_type;
      170   probe_variable.type = type_to_make;
      171   probe_variable.unaligned_sw = P_unaligned_sw;
      172 
      173   if P_address_type = ADDRESS_EXTERNAL_TYPE
      174     then probe_variable.address = var_ptr;
      175   else if P_address_type = ADDRESS_GIVEN_TYPE
      176     then probe_variable.address = P_address_ptr;
      177 
      178   else if probe_variable.type = PROBE_VAR_INTEGER_TYPE then do;
      179       allocate probe_variable_integer in (scratch_area);
      180       probe_variable_integer = 0b;
      181     end;
      182   else if probe_variable.type = PROBE_VAR_FLOAT_TYPE then do;
      183       allocate probe_variable_float in (scratch_area);
      184       probe_variable_float = 0.0;
      185     end;
      186   else if probe_variable.type = PROBE_VAR_DOUBLE_TYPE then do;
      187       allocate probe_variable_double in (scratch_area);
      188       probe_variable_double = 0.0;
      189     end;
      190   else if probe_variable.type = PROBE_VAR_LONG_TYPE then do;
      191       allocate probe_variable_long in (scratch_area);
      192       probe_variable_long = 0;
      193     end;
      194   else if probe_variable.type = PROBE_VAR_CHAR_TYPE then do;
      195       allocate probe_variable_char in (scratch_area);
      196       probe_variable_char = "";
      197     end;
      198   else if probe_variable.type = PROBE_VAR_POINTER_TYPE then do;
      199       if P_unaligned_sw
      200         then allocate probe_variable_pointer_unal in (scratch_area);
      201         else allocate probe_variable_pointer in (scratch_area);
      202       probe_variable_pointer = null ();
      203     end;
      204 
      205   probe_variable.next = start_of_chain;
      206   start_of_chain = probe_variable_ptr;
      207 
      208   P_var_info_ptr = probe_variable_ptr;
      209   goto MAIN_RETURN;
      210 
      211 find_variable:
      212   entry (P_probe_info_ptr, P_reference_node_ptr, P_code);
      213 
      214   probe_info_ptr = P_probe_info_ptr;
      215   P_code = 0;
      216   refp = P_reference_node_ptr;
      217 
      218   normal_name = normalize_name ((ref.name));
      219   probe_variable_ptr = find_var_info (normal_name);
      220   if probe_variable_ptr = null () then do;
      221       P_code = probe_et_$var_doesnt_exist;
      222       goto MAIN_RETURN;
      223     end;
      224 
      225   ref.symbol_ptr = null ();
      226   ref.address_ptr = probe_variable.address;
      227   ref.type = probe_variable.type;
      228   ref.descriptor = probe_variable.type * 2;
      229 
      230   if probe_variable.type = PROBE_VAR_INTEGER_TYPE
      231     then ref.precision = 35;
      232   else if probe_variable.type = PROBE_VAR_CHAR_TYPE
      233     then ref.precision = 1;
      234   else if probe_variable.type = PROBE_VAR_LONG_TYPE
      235     then ref.precision = 71;
      236   else if probe_variable.type = PROBE_VAR_DOUBLE_TYPE
      237     then ref.precision = 63;
      238   else if probe_variable.type = PROBE_VAR_FLOAT_TYPE
      239     then ref.precision = 27;
      240   else if probe_variable.type = PROBE_VAR_POINTER_TYPE
      241     then ref.precision = 0;		/* for completeness, tho useless */
      242 				/* else malfunction */
      243 
      244   ref.flags = "0"b;
      245   ref.flags.probe_variable = "1"b;
      246 
      247   ref.probe_var_info_ptr = probe_variable_ptr;
      248   goto MAIN_RETURN;
      249 
      250 list_variable:
      251   entry (P_probe_info_ptr, P_variable_name, P_code);
      252 
      253   probe_info_ptr = P_probe_info_ptr;
      254   P_code = 0;
      255 
      256   if start_of_chain = null () then do;
      257       P_code = probe_et_$no_vars;
      258       goto MAIN_RETURN;
      259     end;
      260 
      261   normal_name = normalize_name ((P_variable_name));
      262   probe_variable_ptr = find_var_info (normal_name);
      263   if probe_variable_ptr = null () then do;
      264       P_code = probe_et_$var_doesnt_exist;
      265       goto MAIN_RETURN;
      266     end;
      267   call list_current_var ();
      268   goto MAIN_RETURN;
      269 
      270 list_var_ptr:
      271   entry (P_probe_info_ptr, P_var_info_ptr, P_code);
      272 				/* used by symbol request */
      273 
      274   probe_info_ptr = P_probe_info_ptr;
      275   P_code = 0;
      276   probe_variable_ptr = P_var_info_ptr;
      277   call ioa_$ioa_switch (probe_info.output_switch,
      278        "probe variable ^a^[ unaligned^]",
      279        probe_variable.declared_type, probe_variable.unaligned_sw);
      280   goto MAIN_RETURN;
      281 
      282 
      283 list_all_variables:
      284   entry (P_probe_info_ptr, P_code);
      285 
      286   probe_info_ptr = P_probe_info_ptr;
      287 
      288   if start_of_chain = null () then do;
      289       P_code = probe_et_$no_vars;
      290       goto MAIN_RETURN;
      291     end;
      292 
      293   do probe_variable_ptr = start_of_chain repeat probe_variable.next
      294        while (probe_variable_ptr ^= null ());
      295     call list_current_var ();
      296   end;
      297   P_code = 0;
      298   goto MAIN_RETURN;
      299 
      300 
      301 list_current_var:
      302   proc;
      303 
      304   if probe_variable.type = PROBE_VAR_INTEGER_TYPE
      305     then call ioa_$ioa_switch (probe_info.output_switch, "^a^16t^a^32t^d",
      306 	    probe_variable.name, probe_variable.declared_type,
      307 	    probe_variable_integer);
      308   else if probe_variable.type = PROBE_VAR_FLOAT_TYPE
      309     then call ioa_$ioa_switch (probe_info.output_switch, "^a^16t^a^32t^f",
      310 	    probe_variable.name, probe_variable.declared_type,
      311 	    probe_variable_float);
      312   else if probe_variable.type = PROBE_VAR_POINTER_TYPE
      313     then call ioa_$ioa_switch (probe_info.output_switch,
      314 	    "^a^16t^a^[ unaligned^]^32t^p",
      315 	    probe_variable.name, probe_variable.declared_type,
      316 	    probe_variable.unaligned_sw,
      317 	    probe_variable_pointer);
      318 
      319   /* else malfunction */
      320   end list_current_var;
      321 
      322   /* INTERNAL PROCEDURES */
      323 
      324 normalize_name:
      325   proc (weird_name) returns (char (64) varying);
      326   dcl weird_name		char (*) parameter;
      327 
      328   if substr (weird_name, 1, 1) = "%"
      329     then return (substr (weird_name, 2));
      330     else return (weird_name);
      331   end normalize_name;
      332 
      333 
      334 find_var_info:
      335   proc (name_wanted) returns (ptr unal);
      336   dcl name_wanted		char (64) varying parameter;
      337   dcl p			ptr unal;
      338 
      339   do p = start_of_chain repeat p -> probe_variable.next while (p ^= null ());
      340     if p -> probe_variable.name = name_wanted
      341       then
      342 	 return (p);
      343   end;
      344   return (null ());
      345   end find_var_info;
      346 
      347 what_type_is:
      348   proc (type_desired) returns (fixed bin);
      349   dcl type_desired		char (*) parameter;
      350   dcl type_x		fixed bin;
      351   dcl name_x		fixed bin;
      352 
      353   dcl hbound		builtin;
      354 
      355   do type_x = 1 to hbound (name_to_type, 1);
      356     do name_x = 1 to hbound (name_to_type.names, 2);
      357       if name_to_type (type_x).names (name_x) = type_desired
      358         then
      359 	   return (name_to_type (type_x).type);
      360     end;
      361   end;
      362   return (-1);
      363   end what_type_is;
      364 
      365 
      366 
      367 delete_current:
      368   proc ();
      369 
      370   call unthread_current ();
      371   if probe_variable.type = PROBE_VAR_INTEGER_TYPE
      372     then free probe_variable_integer;
      373   else if probe_variable.type = PROBE_VAR_FLOAT_TYPE
      374     then free probe_variable_float;
      375   else if probe_variable.type = PROBE_VAR_POINTER_TYPE
      376     then free probe_variable_pointer;
      377 
      378   free probe_variable;
      379 
      380   end delete_current;
      381 
      382 unthread_current:
      383   proc ();
      384   dcl p			ptr unal;
      385 
      386   if start_of_chain = probe_variable_ptr
      387     then start_of_chain = probe_variable.next;
      388     else
      389       do p = start_of_chain repeat (p -> probe_variable.next)
      390 	 while (p ^= null ());
      391       if p -> probe_variable.next = probe_variable_ptr
      392         then do;
      393 	p -> probe_variable.next = probe_variable.next;
      394 	return;
      395         end;
      396     end;
      397 
      398   /* falling thru is impossible if variable is known */
      399   return;
      400   end unthread_current;
      401 
  1     1 /*	BEGIN INCLUDE FILE probe_info.incl.pl1		*/
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(88-10-24,WAAnderson), approve(88-10-24,MCR7952),
  1     7*     audit(88-10-24,RWaters), install(88-10-27,MR12.2-1194):
  1     8*     Added field 'retry_using_main' to add new C feature.
  1     9*                                                   END HISTORY COMMENTS */
  1    10 
  1    11 
  1    12 /* Created: 04/22/79 W. Olin Sibert, from subsystem_info	
  1    13*   Modified: 22 Sept 79 JRd to remove: 	default (ptr & (auto|based)) init (null ());
  1    14*   Added flags.setting_break 08/22/83 Steve Herbst
  1    15*   Added flags.executing_quit_request 01/15/85 Steve Herbst
  1    16**/
  1    17 
  1    18 dcl 1 probe_info aligned based (probe_info_ptr),		/* standard data for a probe invocation */
  1    19     2 probe_info_version fixed bin,			/* version of this structure */
  1    20 
  1    21     2 static_info_ptr pointer unaligned,		/* pointer to static information structure */
  1    22     2 modes_ptr pointer unaligned,			/* pointer to probe_modes structure */
  1    23 
  1    24     2 ptr_to_current_source ptr,			/* current_source is based on this */
  1    25     2 ptr_to_initial_source ptr,			/* initial_source is based on this */
  1    26     2 machine_cond_ptr pointer,			/* pointer to machine conditions, if we faulted to get here */
  1    27 
  1    28     2 token_info aligned,				/* information about token chain currently being processed */
  1    29       3 first_token pointer unaligned,			/* first token in chain */
  1    30       3 ct pointer unaligned, 			/* pointer to current token; updated in MANY places */
  1    31       3 end_token bit (18) aligned,			/* token type at which to stop scanning token chain */
  1    32       3 buffer_ptr pointer unaligned,			/* pointer to input buffer */
  1    33       3 buffer_lth fixed bin (21),			/* and length */
  1    34 
  1    35     2 random_info aligned,
  1    36       3 current_stack_frame pointer unaligned,		/* stack frame pointer for frame in which probe was invoked */
  1    37       3 input_type fixed bin, 			/* current input type */
  1    38       3 language_type fixed bin,			/* current language being processed */
  1    39       3 return_method fixed bin,			/* how we should return after exiting probe */
  1    40       3 entry_method fixed bin,			/* how we got here in the first place */
  1    41       3 pad1 (19) bit (36) aligned,
  1    42 
  1    43     2 break_info,					/* break info -- only interesting if we got here via a break */
  1    44       3 break_slot_ptr pointer,			/* pointer to break slot -- non-null IFF at a break */
  1    45       3 last_break_slot_ptr pointer unaligned,		/* pointer to previous break slot, not presently used */
  1    46       3 break_reset bit (1) aligned,			/* this break has been reset by somebody further on */
  1    47       3 real_break_return_loc pointer,			/* where to REALLY return to, modulo previous bit */
  1    48 
  1    49     2 probe_area_info,				/* information about various probe areas */
  1    50       3 break_segment_ptr pointer unaligned,		/* pointer to Personid.probe */
  1    51       3 break_area_ptr pointer unaligned,		/* pointer to area in break segment */
  1    52       3 scratch_area_ptr pointer unaligned,		/* pointer to probe scratch seg in process dir */
  1    53       3 probe_area_ptr pointer unaligned,		/* This area lasts as long as an invocation of probe. */
  1    54       3 work_area_ptr pointer unaligned,		/* This area lasts as long as the current request line */
  1    55       3 expression_area_ptr pointer unaligned,		/* This area lasts as long as the current command */
  1    56 
  1    57     2 flags aligned,				/* this, in particular, should be saved and restored correctly */
  1    58      (3 execute,					/* "1"b => execute requests, "0"b => just check syntax */
  1    59       3 in_listener,				/* ON => in probe listener loop */
  1    60       3 executing_request,				/* ON => executing a request */
  1    61       3 in_interpret_line,				/* executing in probe_listen_$interpret_line */
  1    62       3 setting_break,				/* executing "after" or "before": check syntax of "if" */
  1    63       3 executing_quit_request,			/* to prevent error looping during "quit" request */
  1    64       3 pad (30)) bit (1) unaligned,
  1    65 
  1    66     2 io_switches,					/* switches probe will do normal I/O on */
  1    67       3 input_switch pointer,
  1    68       3 output_switch pointer,
  1    69 
  1    70     2 error_info,					/* information about the last error saved for later printing */
  1    71       3 error_code fixed bin (35),
  1    72       3 error_message char (300) varying,
  1    73 
  1    74     2 listener_info,				/* internal use by probe listener */
  1    75       3 request_name character (32) varying,		/* primary name of the request being processed */
  1    76       3 abort_probe_label label variable,
  1    77       3 abort_line_label label variable,
  1    78       3 depth fixed binary,				/* count of active invocations of probe */
  1    79       3 previous pointer unaligned,			/* -> previous invocation's info */
  1    80       3 next pointer unaligned,
  1    81 
  1    82     2 end_of_probe_info pointer aligned,
  1    83     2 retry_using_main fixed bin aligned;
  1    84    
  1    85 
  1    86 dcl  probe_info_ptr pointer;
  1    87 
  1    88 dcl  probe_info_version fixed bin static options (constant) initial (1);
  1    89 
  1    90 dcl  probe_info_version_1 fixed bin static options (constant) initial (1);
  1    91 
  1    92 dcl  scratch_area area based (probe_info.scratch_area_ptr);
  1    93 dcl  probe_area area based (probe_info.probe_area_ptr);
  1    94 dcl  work_area area based (probe_info.work_area_ptr);
  1    95 dcl  expression_area area based (probe_info.expression_area_ptr);
  1    96 
  1    97 /*	END INCLUDE FILE probe_info.incl.pl1		*/
      402 
      403 
  2     1 /*	BEGIN INCLUDE FILE probe_references.incl.pl1	*/
  2     2 
  2     3 /****^  HISTORY COMMENTS:
  2     4*  1) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  2     5*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  2     6*     Added new field (c_symbol) for C-Probe support.
  2     7*  2) change(88-10-28,WAAnderson), approve(88-10-28,MCR7952),
  2     8*     audit(88-10-31,RWaters), install(88-11-11,MR12.2-1210):
  2     9*     Added new field (c_sub_c_ptr) for C-Probe_support.
  2    10*                                                   END HISTORY COMMENTS */
  2    11 
  2    12 /*	Split out of probe_tokens, 04/22/79 WOS 	*/
  2    13 /*       modified for probe variables Feb 19 80 JRD         */
  2    14 /*   Modified June 83 JMAthane to add "type_ptr" and "builtin" fields */
  2    15 
  2    16      dcl	   1 reference_node	      aligned based,	/* information about a reference */
  2    17 	     2 symbol_ptr	      pointer aligned,	/* to symbol table entry for reference */
  2    18 	     2 type_ptr	      pointer aligned,	/* to symbol table entry for type (null if none) */
  2    19 	     2 address_ptr	      pointer aligned,	/* to location of variable */
  2    20 	     2 base_addr	      pointer aligned,	/* pointer on which whole symbol is based */
  2    21 	     2 source_info_ptr    pointer aligned,	/* to symbol structure for reference */
  2    22 
  2    23 	     2 name	      char (256) unaligned varying, /* symbol name */
  2    24 
  2    25 	     2 type	      fixed bin (35),	/* data type */
  2    26 	     2 descriptor	      fixed bin (35),	/* type || packed */
  2    27 	     2 precision	      fixed bin (35),	/* scale and precision */
  2    28 	     2 flags,
  2    29 	       3 packed	      bit (1) unal,		/* data is in packed format */
  2    30 	       3 constant	      bit (1) unal,		/* data is really a constant */
  2    31 	       3 cross_section    bit (1) unal,		/* reference is an array cross-section */
  2    32 	       3 function	      bit (1) unal,		/* reference is function value */
  2    33 	       3 octal	      bit (1) unal,		/* indicates that this is the octal bif */
  2    34 	       3 star_extent      bit (1) unal,		/* reference is a star subscript for father */
  2    35 	       3 have_generation  bit (1) unal,		/* this reference has an explicitly specified generation */
  2    36 	       3 pseudo_var	      bit (1) unal,		/* it is ok to assign to it */
  2    37 	       3 probe_variable   bit (1) unal,
  2    38 	       3 path	      bit (1) unal,		/* it's a pathname/virtual entry */
  2    39 	       3 builtin	      bit (1) unal,		/* probe builtinvalue */
  2    40 	       3 c_ptr_to_char    bit (1)  unal,
  2    41                  3 c_sub_c_ptr      bit (1)  unal,
  2    42 	       3 pad2	      bit (23) unal,
  2    43 
  2    44 	     2 optional_info,			/* information which may or may not be present */
  2    45 	       3 argument_list    pointer unaligned,	/* pointer to reference_arg_list */
  2    46 	       3 subscript_ptr    pointer unaligned,	/* pointer to reference_subscripts */
  2    47 	       3 n_arguments      fixed bin,		/* number of arguments in argument list */
  2    48 	       3 n_subscripts     fixed bin,		/* number of subscripts present */
  2    49 
  2    50 	     2 constant_token_ptr pointer unaligned,	/* pointer to constant token if this is a constant */
  2    51 	     2 subscript_refs_ptr pointer unaligned,	/* pointer to array of subscript reference node pointers */
  2    52 	     2 invocation_level   fixed bin,		/* invocation level number ("[-17]") for this reference */
  2    53 	     2 probe_var_info_ptr ptr unal,		/* only if flags.probe_variable */
  2    54                2 c_symbol_ptr  ptr unal,
  2    55 	     2 pad1	      (9) pointer unaligned,
  2    56 	     2 end_of_reference_node pointer aligned;
  2    57 
  2    58 
  2    59      dcl	   1 reference_arg_list   aligned based,	/* argument list; based on reference.argument_list */
  2    60 	     2 number	      fixed bin,		/* number of arguments actually present */
  2    61 	     2 node	      (16) pointer aligned;	/* reference node pointers for each argument */
  2    62 
  2    63 
  2    64      dcl	   1 reference_subscripts aligned based,	/* subscript array; based on reference.subscript_ptr */
  2    65 	     2 number	      fixed bin,		/* number actually present */
  2    66 	     2 value	      (2, 16) fixed bin (24); /* values for lower and upper bound for each */
  2    67 
  2    68 
  2    69      dcl	   1 subscript_reference_ptrs aligned based,	/* array of pointers to subscript reference nodes */
  2    70 	     2 ptr	      (2, 16) pointer aligned;
  2    71 
  2    72 /*	END INCLUDE FILE probe_references.incl.pl1	*/
      404 
      405 
  3     1 /* BEGIN INCLUDE FILE ... probe_var_info.incl.pl 
  3     2*
  3     3*   describes a probe variable.  This str pointed to by the probe_var_info_ptr
  3     4*   of a reference node.
  3     5*   Jim Davis 19 Feb 80
  3     6**/
  3     7 
  3     8 
  3     9 /****^  HISTORY COMMENTS:
  3    10*  1) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  3    11*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  3    12*     Added info for new types used by C.
  3    13*                                                   END HISTORY COMMENTS */
  3    14 
  3    15 
  3    16 /* Added probe_variable.unaligned_sw and pointer_unal type 12/04/81 S. Herbst */
  3    17 /* Added address-type constants (ADDRESS_ALLOC_TYPE, etc.) 03/12/84 S. Herbst */
  3    18 
  3    19 dcl (ADDRESS_ALLOC_TYPE init (1),
  3    20      ADDRESS_EXTERNAL_TYPE init (2),
  3    21      ADDRESS_GIVEN_TYPE init (3)) fixed bin int static options (constant);
  3    22 
  3    23 dcl 1 probe_variable aligned based (probe_variable_ptr),
  3    24       2 next ptr unal,			         /* threaded */
  3    25       2 name char (64) varying,
  3    26       2 declared_type char (64) varying,	         /* what user TYPE */
  3    27       2 type fixed bin,			         /* Multics type */
  3    28       2 unaligned_sw bit (1) aligned,
  3    29       2 address ptr unal,			         /* to the data */
  3    30       2 pad (5) ptr unal;
  3    31 
  3    32 dcl probe_variable_integer fixed bin (35) based (probe_variable.address);
  3    33 dcl probe_variable_pointer pointer aligned based (probe_variable.address);
  3    34 dcl probe_variable_pointer_unal pointer unaligned based (probe_variable.address);
  3    35 dcl probe_variable_float float bin (27) based (probe_variable.address);
  3    36 dcl probe_variable_char  char(1) based (probe_variable.address);
  3    37 dcl probe_variable_double float bin (63) based (probe_variable.address);
  3    38 dcl probe_variable_long fixed bin(71) based (probe_variable.address);
  3    39 
  3    40 dcl probe_variable_ptr pointer unal;
  3    41 
  3    42 /* END INCLUDE FILE ... probe_var_info.incl.pl1 */
  3    43 
      406 
      407 
      408 
      409   end probe_variable_mgr_;
      410 
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/88  1545.0  probe_variable_mgr_.pl1           >spec>install>MR12.2-1210>probe_variable_mgr_.pl1
402          1    10/27/88  1339.2  probe_info.incl.pl1               >ldd>include>probe_info.incl.pl1
404          2    11/11/88  1543.8  probe_references.incl.pl1         >spec>install>MR12.2-1210>probe_references.incl.pl1
406          3    10/26/88  1255.5  probe_var_info.incl.pl1           >ldd>include>probe_var_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ADDRESS_EXTERNAL_TYPE                  constant        fixed bin(17,0)          initial dcl 3-19 ref 144 173
ADDRESS_GIVEN_TYPE                     constant        fixed bin(17,0)          initial dcl 3-19 ref 175
PROBE_VAR_CHAR_TYPE                    constant        fixed bin(17,0)          initial dcl 77 ref 194 232
PROBE_VAR_DOUBLE_TYPE                  constant        fixed bin(17,0)          initial dcl 77 ref 186 236
PROBE_VAR_FLOAT_TYPE                   constant        fixed bin(17,0)          initial dcl 77 ref 182 238 308 373
PROBE_VAR_INTEGER_TYPE                 constant        fixed bin(17,0)          initial dcl 77 ref 178 230 304 371
PROBE_VAR_LONG_TYPE                    constant        fixed bin(17,0)          initial dcl 77 ref 190 234
PROBE_VAR_POINTER_TYPE                 constant        fixed bin(17,0)          initial dcl 77 ref 198 240 312 375
P_address_ptr                          parameter       pointer                  dcl 59 ref 118 175
P_address_type                         parameter       fixed bin(17,0)          dcl 58 ref 118 144 173 175
P_code                                 parameter       fixed bin(35,0)          dcl 64 set ref 118 124* 128* 140* 151* 160* 162 211
                                                                                  215* 221* 250 254* 257* 264* 270 275* 283 289*
                                                                                  297*
P_force_creation                       parameter       bit(1)                   dcl 60 ref 118 135
P_probe_info_ptr                       parameter       pointer                  dcl 53 ref 118 123 211 214 250 253 270 274 283 286
P_reference_node_ptr                   parameter       pointer                  dcl 61 ref 211 216
P_unaligned_sw                         parameter       bit(1)                   dcl 57 ref 118 171 199
P_var_info_ptr                         parameter       pointer                  packed unaligned dcl 63 set ref 118 208* 270 276
P_variable_name                        parameter       varying char(64)         dcl 55 ref 118 132 250 261
P_variable_type                        parameter       varying char(64)         dcl 56 ref 118 126 169
address                  45            based           pointer                  level 2 packed packed unaligned dcl 3-23 set ref
                                                                                  173* 175* 179* 180 183* 184 187* 188 191* 192 195*
                                                                                  196 199* 201* 202 226 304 308 312 371 373 375
address_ptr               4            based           pointer                  level 2 dcl 74 set ref 226*
declared_type            22            based           varying char(64)         level 2 dcl 3-23 set ref 169* 277* 304* 308* 312*
descriptor              114            based           fixed bin(35,0)          level 2 dcl 74 set ref 228*
entry_point_name                000141 automatic       char(64)                 packed unaligned dcl 69 set ref 148* 150* 151*
flags                   116            based           structure                level 2 dcl 74 set ref 244*
get_external_variable_          000022 constant        entry                    external dcl 106 ref 160
hbound                                                 builtin function         dcl 353 ref 355 356
hcs_$make_ptr                   000024 constant        entry                    external dcl 108 ref 151
i                               000164 automatic       fixed bin(17,0)          dcl 72 set ref 145* 146 147 148 148 155
index                                                  builtin function         dcl 112 ref 145
io_switches              66            based           structure                level 2 dcl 1-18
ioa_$ioa_switch                 000026 constant        entry                    external dcl 110 ref 277 304 308 312
length                                                 builtin function         dcl 112 ref 148 155
name                      1            based           varying char(64)         level 2 in structure "probe_variable" dcl 3-23
                                                                                  in procedure "probe_variable_mgr_" set ref 168*
                                                                                  304* 308* 312* 340
name                     12            based           varying char(256)        level 2 in structure "ref" dcl 74 in procedure
                                                                                  "probe_variable_mgr_" ref 218
name_to_type                    000000 constant        structure                array level 1 unaligned dcl 86 ref 355
name_wanted                            parameter       varying char(64)         dcl 336 ref 334 340
name_x                          000101 automatic       fixed bin(17,0)          dcl 351 set ref 356* 357*
names                           000000 constant        char(32)                 initial array level 2 packed packed unaligned dcl 86
                                                                                  ref 356 357
next                                   based           pointer                  level 2 packed packed unaligned dcl 3-23 set ref
                                                                                  205* 296 343 386 391 393* 393 396
normal_name                     000100 automatic       varying char(64)         dcl 68 set ref 132* 133* 145 147 148 148 155 160 168
                                                                                  218* 219* 261* 262*
null                                                   builtin function         dcl 112 ref 135 151 151 153 160 160 202 220 225 256
                                                                                  263 288 293 339 344 388
output_switch            70            based           pointer                  level 3 dcl 1-18 set ref 277* 304* 308* 312*
p                               000234 automatic       pointer                  packed unaligned dcl 384 in procedure
                                                                                  "unthread_current" set ref 388* 388* 391 393* 396
p                               000216 automatic       pointer                  packed unaligned dcl 337 in procedure
                                                                                  "find_var_info" set ref 339* 339* 340 340* 343
pointer                                                builtin function         dcl 112 ref 155
precision               115            based           fixed bin(35,0)          level 2 dcl 74 set ref 230* 232* 234* 236* 238* 240*
probe_area_info          56            based           structure                level 2 dcl 1-18
probe_et_$bad_dcl_type          000014 external static fixed bin(35,0)          dcl 99 ref 128
probe_et_$no_vars               000016 external static fixed bin(35,0)          dcl 99 ref 257 289
probe_et_$var_doesnt_exist      000020 external static fixed bin(35,0)          dcl 99 ref 221 264
probe_et_$var_exists            000012 external static fixed bin(35,0)          dcl 99 ref 140
probe_info                             based           structure                level 1 dcl 1-18
probe_info_ptr                  000172 automatic       pointer                  dcl 1-86 set ref 123* 179 183 187 191 195 199 201
                                                                                  214* 253* 274* 277 286* 304 308 312
probe_var_info_ptr      126            based           pointer                  level 2 packed packed unaligned dcl 74 set ref 247*
probe_variable          116(08)        based           bit(1)                   level 3 in structure "ref" packed packed unaligned
                                                                                  dcl 74 in procedure "probe_variable_mgr_" set ref
                                                                                  245*
probe_variable                         based           structure                level 1 dcl 3-23 in procedure "probe_variable_mgr_"
                                                                                  set ref 167 378
probe_variable_char                    based           char(1)                  packed unaligned dcl 3-36 set ref 195 196*
probe_variable_double                  based           float bin(63)            dcl 3-37 set ref 187 188*
probe_variable_float                   based           float bin(27)            dcl 3-35 set ref 183 184* 308* 373
probe_variable_integer                 based           fixed bin(35,0)          dcl 3-32 set ref 179 180* 304* 371
probe_variable_long                    based           fixed bin(71,0)          dcl 3-38 set ref 191 192*
probe_variable_pointer                 based           pointer                  dcl 3-33 set ref 201 202* 312* 375
probe_variable_pointer_unal            based           pointer                  packed unaligned dcl 3-34 ref 199
probe_variable_ptr              000174 automatic       pointer                  packed unaligned dcl 3-40 set ref 133* 135 167* 168
                                                                                  169 170 171 173 175 178 179 180 182 183 184 186
                                                                                  187 188 190 191 192 194 195 196 198 199 201 202
                                                                                  205 206 208 219* 220 226 227 228 230 232 234 236
                                                                                  238 240 247 262* 263 276* 277 277 293* 293* 296
                                                                                  304 304 304 304 308 308 308 308 312 312 312 312
                                                                                  312 371 371 373 373 375 375 378 386 386 391 393
ref                                    based           structure                level 1 dcl 74
reference_node                         based           structure                level 1 dcl 2-16
refp                            000166 automatic       pointer                  dcl 75 set ref 216* 218 225 226 227 228 230 232 234
                                                                                  236 238 240 244 245 247
scratch_area                           based           area(1024)               dcl 1-92 ref 179 183 187 191 195 199 201
scratch_area_ptr         60            based           pointer                  level 3 packed packed unaligned dcl 1-18 ref 179 183
                                                                                  187 191 195 199 201
seg_name                        000121 automatic       char(64)                 packed unaligned dcl 69 set ref 147* 150 151*
start_of_chain                  000010 internal static pointer                  initial packed unaligned dcl 66 set ref 205 206* 256
                                                                                  288 293 339 386 386* 388
substr                                                 builtin function         dcl 112 ref 147 148 328 328
symbol_ptr                             based           pointer                  level 2 dcl 74 set ref 225*
type                    113            based           fixed bin(35,0)          level 2 in structure "ref" dcl 74 in procedure
                                                                                  "probe_variable_mgr_" set ref 227*
type                     43            based           fixed bin(17,0)          level 2 in structure "probe_variable" dcl 3-23
                                                                                  in procedure "probe_variable_mgr_" set ref 170*
                                                                                  178 182 186 190 194 198 227 228 230 232 234 236
                                                                                  238 240 304 308 312 371 373 375
type                     50     000000 constant        fixed bin(17,0)          initial array level 2 in structure "name_to_type"
                                                                                  dcl 86 in procedure "probe_variable_mgr_" ref 357
type_desired                           parameter       char                     packed unaligned dcl 349 ref 347 357
type_to_make                    000170 automatic       fixed bin(17,0)          dcl 97 set ref 126* 127 170
type_x                          000100 automatic       fixed bin(17,0)          dcl 350 set ref 355* 357 357*
unaligned_sw             44            based           bit(1)                   level 2 dcl 3-23 set ref 171* 277* 312*
var_ptr                         000162 automatic       pointer                  dcl 71 set ref 151* 153 155* 155 160* 173
weird_name                             parameter       char                     packed unaligned dcl 326 ref 324 328 328 330

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ADDRESS_ALLOC_TYPE                     internal static fixed bin(17,0)          initial dcl 3-19
expression_area                        based           area(1024)               dcl 1-95
probe_area                             based           area(1024)               dcl 1-93
probe_info_version                     internal static fixed bin(17,0)          initial dcl 1-88
probe_info_version_1                   internal static fixed bin(17,0)          initial dcl 1-90
reference_arg_list                     based           structure                level 1 dcl 2-59
reference_subscripts                   based           structure                level 1 dcl 2-64
subscript_reference_ptrs               based           structure                level 1 dcl 2-69
work_area                              based           area(1024)               dcl 1-94

NAMES DECLARED BY EXPLICIT CONTEXT.
MAIN_RETURN                     000447 constant        label                    dcl 115 ref 129 141 153 162 209 222 248 258 265 268
                                                                                  280 290 298
create_variable                 000457 constant        entry                    external dcl 118
delete_current                  002145 constant        entry                    internal dcl 367 ref 135
find_var_info                   002020 constant        entry                    internal dcl 334 ref 133 219 262
find_variable                   001173 constant        entry                    external dcl 211
list_all_variables              001543 constant        entry                    external dcl 283
list_current_var                001602 constant        entry                    internal dcl 301 ref 267 295
list_var_ptr                    001457 constant        entry                    external dcl 270
list_variable                   001366 constant        entry                    external dcl 250
normalize_name                  001754 constant        entry                    internal dcl 324 ref 132 218 261
probe_variable_mgr_             000442 constant        entry                    external dcl 28
unthread_current                002201 constant        entry                    internal dcl 382 ref 370
what_type_is                    002065 constant        entry                    internal dcl 347 ref 126

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2460        2510    2261        2470
Length      2766    2261        30         242     176           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
probe_variable_mgr_                 260 external procedure  is an external procedure.  
list_current_var                        internal procedure  shares stack frame of external procedure probe_variable_mgr_.  
normalize_name                       65 internal procedure  is called during a stack extension.  
find_var_info                           internal procedure  shares stack frame of external procedure probe_variable_mgr_.  
what_type_is                         68 internal procedure  is called during a stack extension.  
delete_current                          internal procedure  shares stack frame of external procedure probe_variable_mgr_.  
unthread_current                        internal procedure  shares stack frame of external procedure probe_variable_mgr_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 start_of_chain              probe_variable_mgr_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
probe_variable_mgr_      000100 normal_name                 probe_variable_mgr_
                         000121 seg_name                    probe_variable_mgr_
                         000141 entry_point_name            probe_variable_mgr_
                         000162 var_ptr                     probe_variable_mgr_
                         000164 i                           probe_variable_mgr_
                         000166 refp                        probe_variable_mgr_
                         000170 type_to_make                probe_variable_mgr_
                         000172 probe_info_ptr              probe_variable_mgr_
                         000174 probe_variable_ptr          probe_variable_mgr_
                         000216 p                           find_var_info
                         000234 p                           unthread_current
what_type_is             000100 type_x                      what_type_is
                         000101 name_x                      what_type_is

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_int_this_desc  return_mac          shorten_stack       ext_entry
int_entry_desc      op_alloc_           alloc_storage       op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_external_variable_        hcs_$make_ptr                 ioa_$ioa_switch

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
probe_et_$bad_dcl_type        probe_et_$no_vars             probe_et_$var_doesnt_exist    probe_et_$var_exists




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     28 000441       115 000447       118 000450       123 000471       124 000475       126 000476       127 000523
    128 000526       129 000531       132 000532       133 000560       135 000563       140 000574       141 000577
    144 000600       145 000604       146 000616       147 000617       148 000623       150 000635       151 000640
    153 000671       155 000675       158 000702       160 000703       162 000746       167 000751       168 000755
    169 000763       170 000772       171 000774       173 000777       175 001006       178 001014       179 001017
    180 001027       181 001031       182 001032       183 001034       184 001044       185 001047       186 001050
    187 001052       188 001062       189 001065       190 001066       191 001070       192 001100       193 001103
    194 001104       195 001106       196 001116       197 001122       198 001123       199 001125       201 001141
    202 001151       205 001154       206 001157       208 001161       209 001166       211 001167       214 001203
    215 001207       216 001210       218 001213       219 001237       220 001242       221 001245       222 001250
    225 001251       226 001253       227 001257       228 001261       230 001263       232 001272       234 001277
    236 001304       238 001311       240 001316       244 001321       245 001355       247 001357       248 001361
    250 001362       253 001376       254 001402       256 001403       257 001407       258 001411       261 001412
    262 001437       263 001442       264 001445       265 001450       267 001451       268 001452       270 001453
    274 001471       275 001475       276 001476       277 001505       280 001536       283 001537       286 001553
    288 001557       289 001563       290 001565       293 001566       295 001573       296 001574       297 001600
    298 001601       301 001602       304 001603       308 001647       312 001710       320 001752       324 001753
    328 001767       330 002007       334 002020       339 002022       340 002031       343 002051       344 002054
    347 002064       355 002100       356 002105       357 002113       360 002135       361 002137       362 002141
    367 002145       370 002146       371 002147       373 002161       375 002170       378 002176       380 002200
    382 002201       386 002202       388 002212       391 002217       393 002224       394 002227       396 002230
    399 002232


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
