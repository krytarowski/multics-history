	COMPILATION LISTING OF SEGMENT ta_file_io_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 11/30/87  1327.7 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(87-08-17,GWMay), approve(87-09-09,MECR0006),
       16*     audit(87-09-04,Farley), install(87-09-09,MR12.1-1101):
       17*     Changed to init the msf_fcp_ptr so that non-creation of an output file is
       18*     diagnosed.  Changed to always set the name of the output directory for
       19*     extractions.
       20*  2) change(87-10-19,GWMay), approve(87-10-19,MCR7779), audit(87-11-02,Farley),
       21*     install(87-11-30,MR12.2-1006):
       22*     Formally install MECR0006.
       23*                                                   END HISTORY COMMENTS */
       24 
       25 
       26 ta_file_io_: proc; return;
       27 
       28 /* This module does tape and file I/O for tape_archive.
       29*   Written 06/06/77 by C. D. Tavares
       30*   Modified 04/11/79 by CDT to handle unexpired file abort better and to
       31*   clean up garbage error message printed when processing table of contents.
       32*   Modified 10/24/80 by CDT to add tape_ibm_ capability.
       33*   Modified 12/05/80 by CDT to diagnose error_table_$short_record from
       34*   vfile_ as no_final_newline, not an error.
       35*   Last modified 83-03-25 by S. G. Harris for version 4.
       36*   Modified 6/83 by S. Krupp for conversion to mtape_.
       37*   Modified November 1984 by Greg Texada to make file names conform to both
       38*    IBM and ANSI standards.
       39*   Modified 12/84 by Keith Loepere to remove create_branch_info.
       40*   Modified 85-2-19 by C Spitzer. not to complain if cannot find a file on the tape when compacting.
       41**/
       42 
       43 
       44 /* AUTOMATIC */
       45 
       46 	dcl     attribute_file_name	 char (17) aligned,
       47 	        binary_mode		 bit (1) aligned,
       48 	        bit_count		 fixed bin (24),
       49 	        cancel_deletion	 bit (1) aligned,
       50 	        char_count		 fixed bin (21),
       51 	        compacting		 bit (1) aligned,
       52 	        dirname		 char (168),
       53 	        ename		 char (32),
       54 	        extracting		 bit (1) aligned,
       55 	        i			 fixed bin,
       56 	        input_opd		 char (520),
       57 	        j			 fixed bin,
       58 	        max_chars_in_seg	 fixed bin (21),
       59 	        msf_fcb_ptr		 pointer,
       60 	        n_chars_read	 fixed bin (21),
       61 	        n_words_read	 fixed bin (18),
       62 	        output_atd		 char (520),
       63 	        output_opd		 char (520),
       64 	        readin_ptr		 pointer,
       65 	        seg_ptr		 pointer,
       66 	        temp_file_no	 fixed bin;
       67 
       68 /* ENTRIES */
       69 
       70 	dcl     com_err_		 ext entry options (variable),
       71 	        hcs_$set_bc_seg	 ext entry (pointer, fixed bin (24), fixed bin (35)),
       72 	        hcs_$truncate_seg	 ext entry (pointer, fixed bin (18), fixed bin (35)),
       73 	        (ioa_, ioa_$rsnnl)	 ext entry options (variable),
       74 	        msf_manager_$close	 ext entry (pointer),
       75 	        msf_manager_$get_ptr	 ext entry (pointer, fixed bin, bit (1) aligned, pointer, fixed bin (24), fixed bin (35)),
       76 	        msf_manager_$open	 ext entry (char (*), char (*), pointer, fixed bin (35));
       77 
       78 	dcl     ta_filesys_util_$create_attribute_file ext entry (pointer, fixed bin, pointer, bit (1) aligned, fixed bin (35)),
       79 	        ta_filesys_util_$prepare_extraction ext entry (pointer, fixed bin, fixed bin (35)),
       80 	        ta_filesys_util_$replace_attributes ext entry (pointer, fixed bin, pointer, fixed bin (35));
       81 
       82 /* CONSTANTS */
       83 
       84 	dcl     Legal_name_chars_ansi	 char (128) static options (constant) initial
       85 				 ("//////////////////////////////////""//%&'()*+,-./0123456789:;<=>?/ABCDEFGHIJKLMNOPQRSTUVWXYZ////_/ABCDEFGHIJKLMNOPQRSTUVWXYZ/////"),
       86 	        Legal_name_chars_ibm	 char (128) static options (constant) initial
       87 				 ("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@""#$@@@@@@@@@@@0123456789@@@@@@@ABCDEFGHIJKLMNOPQRSTUVWXYZ@@@@@@ABCDEFGHIJKLMNOPQRSTUVWXYZ@@@@@"),
       88 	        Upper_case		 char (26) static options (constant) initial
       89 				 ("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
       90 	        Newline		 char (1) static options (constant) initial ("
       91 ");
       92 
       93 /* EXTERNAL STATIC */
       94 
       95 	dcl     (error_table_$end_of_info,
       96 	        error_table_$no_file,
       97 	        error_table_$short_record) ext fixed bin (35) static;
       98 
       99 	dcl     sys_info$max_seg_size	 fixed bin (35) external static;
      100 
      101 /* BASED */
      102 
      103 	dcl     1 tape_archive_io_info aligned based (tii_ptr),
  1     1 /* --------------- BEGIN include file tape_archive_io_info.incl.pl1 --------------- */
  1     2 
  1     3 /*
  1     4*dcl 1 tape_archive_io_info aligned,			/* level-1 line with storage class must be in outer program */
  1     5     2 tape_input_switch pointer,			/* IOX input switch pointer */
  1     6     2 input_opd_template char (520),			/* attach description template */
  1     7     2 tape_output_switch pointer,			/* IOX output switch pointer */
  1     8     2 output_opd_template char (520),			/* attach description template */
  1     9     2 file_input_switch pointer,			/* IOX switch */
  1    10     2 file_output_switch pointer,			/* IOX switch */
  1    11     2 temp_seg_ptrs aligned,				/* various free space pointers */
  1    12       3 attribute_seg_ptr pointer,			/* pointer to seg to hold attribute file from tape */
  1    13       3 buffer_ptr pointer,				/* seg for I/O buffer */
  1    14       3 temp_table_ptr pointer,			/* pointer to temp copy of online table */
  1    15     2 long_sw bit (1) aligned;			/* if on, call ioa_ to report major operations */
  1    16 
  1    17 dcl  based_temp_seg_ptrs (3) pointer based (addr (tape_archive_io_info.temp_seg_ptrs));
  1    18 
  1    19 /* ---------------- END include file tape_archive_io_info.incl.pl1 ---------------- */
      104 
      105 
      106 	dcl     based_segment	 (n_words_read) bit (36) aligned based (seg_ptr),
      107 	        buffer		 char (max_chars_in_seg) based (buffer_ptr);
      108 
      109 /* INCLUDE FILES */
      110 
  2     1 /* ---------- BEGIN include file tape_archive_table_dcl.incl.pl1 ---------- */
  2     2 
  2     3 /* Version 2 lengthened volume names from 6 to 32 characters */
  2     4 /* Version 3 introduced density field, workspace strategy for updates, */
  2     5 /* and the mount lock, which is less of a lock than a retain indicator. */
  2     6 /* Version 4 expanded density field to an array for independent volume set */
  2     7 /* densities and added uid fields for table deletion checking. */
  2     8 /* Modified 09/21/80 by C. D. Tavares for version 3 */
  2     9 /* Modified 12/9/81 by CDT to add highest_mount_type field */
  2    10 /* Last modified 83-03-16 by S. G. Harris (UNCA) for version 4. */
  2    11 /* Modified 09/16/83 by S. Krupp to add the TAPE_ARCHIVE_IO_MODULE
  2    12*   declaration for conversion to the mtape_ I/O module. */
  2    13 
  2    14 dcl 1 tape_archive_table aligned based (table_ptr),	/* online segment for tape_archive command */
  2    15     2 nonvolatile_part aligned,			/* temp table moving doesn't touch these */
  2    16       3 version_number fixed bin,			/* of table */
  2    17       3 magic_constant char (8),			/* "ta table" */
  2    18       3 compaction_warning_threshold float bin,		/* when to suggest compaction to user */
  2    19       3 auto_compaction_threshold float bin,		/* when to compact when user doesn't take hint */
  2    20       3 table_is_consistent bit (1) unaligned,		/* update in progress indicator */
  2    21       3 lock bit (36),				/* allows shared tape archives */
  2    22       3 lock_reason fixed bin,			/* reason seg already locked, for failure msg */
  2    23       3 locker_id char (32),				/* userid of locking process, for failure msg */
  2    24       3 io_module_name char (32),			/* tape_ansi_ or tape_ibm_ */
  2    25       3 recovery_info_offset bit (18) aligned,		/* holds address of workspace for table updates */
  2    26       3 perm_table_uid bit (36),			/* used to prevent table deletion */
  2    27       3 future_expansion (6) bit (36),			/* ... */
  2    28     2 volatile_part aligned,				/* these can get altered due to temp table moves */
  2    29       3 n_components fixed bin,			/* number valid (undeleted) components in archive */
  2    30       3 n_component_slots fixed bin,			/* number of used component slots in table */
  2    31       3 n_queued_requests fixed bin,			/* number requests to be performed next mount */
  2    32       3 n_request_slots fixed bin,			/* number of used request slots in table */
  2    33       3 next_mount_type fixed bin,			/* read only, write, or compact */
  2    34       3 date_time_tape_modified bit (36),		/* last time tape written on */
  2    35       3 date_time_last_compacted bit (36),		/* last time tape compacted */
  2    36       3 total_records fixed bin (35),			/* data out on tape, in Multics records */
  2    37       3 dead_records fixed bin (35),			/* records wasted (deletions, replacements) */
  2    38       3 incomplete_write_op_last bit (1),		/* ON if determined that user or sys crashed while writing tape */
  2    39       3 last_tape_file_no fixed bin,			/* number of last file existing on volume set */
  2    40       3 last_table_no fixed bin,			/* number of copies of online table on this volume set */
  2    41       3 mount_lock bit (36) aligned,			/* set to lock_id while volume set mounted */
  2    42       3 highest_mount_type fixed bin,			/* max of next_mount_type since retained */
  2    43       3 future_expansion (6) bit (36),			/* ... */
  2    44       3 tape_info aligned,
  2    45         4 density (2) fixed bin (17) unal,		/* post version 3 volume set densities */
  2    46         4 active_set fixed bin,			/* which of the two is most current */
  2    47         4 n_volumes_in_set (2) fixed bin,		/* how many reels comprise volume set */
  2    48         4 volume_set (2) aligned,
  2    49 	5 volume_id (8) char (168),			/* physical reel and slot info */
  2    50       3 component_table (0 refer (tape_archive_table.n_component_slots)) aligned like component,
  2    51       3 request_queue (0 refer (tape_archive_table.n_request_slots)) aligned like request;
  2    52 
  2    53 dcl 1 component aligned based (component_ptr),		/* format of one component entry */
  2    54     2 entry_status_descriptor like entry_status_descriptor aligned,
  2    55     2 previous_instance_backchain fixed bin,		/* index of file it replaced, if any */
  2    56     2 associated_request_index fixed bin,		/* if extract pending, index of request with dirpath */
  2    57     2 date_time_deleted bit (36) aligned,		/* if logically deleted, when. */
  2    58     2 future_expansion (5) bit (36) aligned;		/* ... */
  2    59 
  2    60 dcl 1 request aligned based (request_ptr),		/* format of a queued request */
  2    61     2 entry_status_descriptor like entry_status_descriptor aligned,
  2    62     2 directory_name char (168) unaligned,		/* in Multics file system */
  2    63     2 requested_ops unaligned,
  2    64       3 append bit (1) unaligned,			/* add to tape */
  2    65       3 replace bit (1) unaligned,			/* replace to tape */
  2    66       3 extract bit (1) unaligned,			/* extract from tape */
  2    67       3 delete bit (1) unaligned,			/* delete from tape or file system */
  2    68       3 force bit (1) unaligned,			/* forcibly do any of the above */
  2    69       3 single_name bit (1) unaligned,			/* append/extract with only given name */
  2    70       3 future_expansion bit (30) unaligned,
  2    71     2 existing_reference fixed bin,			/* index of component block, if exists (e.g. read) */
  2    72     2 future_expansion (4) bit (36) aligned;
  2    73 
  2    74 dcl 1 entry_status_descriptor aligned based,
  2    75     2 valid bit (1) unaligned,			/* an undeleted component or request if on */
  2    76     2 no_final_newline bit (1) unaligned,		/* ON if last char in file was not newline */
  2    77     2 safety_switch bit (1) unaligned,			/* reflects safety switch of file while online */
  2    78     2 pad bit (33) unaligned,
  2    79     2 file_info aligned,				/* main tape file for this entry */
  2    80       3 tape_file_name char (17),
  2    81       3 entry_name char (32) unaligned,			/* for Multics file system */
  2    82       3 date_time_archived bit (36),			/* when it was put on tape */
  2    83       3 recording_mode char (8) aligned,		/* "ascii", "binary", "ebcdic", etc. */
  2    84       3 date_time_branch_modified bit (36),		/* last modified while in file system */
  2    85       3 date_time_dumped bit (36),			/* by backup facility */
  2    86       3 bitcount_author char (32),			/* last person who modified it while online */
  2    87       3 file_length fixed bin (35),			/* in Multics pages */
  2    88       3 attribute_file_no fixed bin,			/* file number of attribute file on tape */
  2    89       3 n_tape_records fixed bin (35),			/* number of logical records on tape for this file */
  2    90     2 uid bit (36) aligned,				/* used to prevent table deletion */
  2    91     2 future_expansion bit (36) aligned;
  2    92 
  2    93 dcl 1 workspace based (workspace_ptr) aligned,		/* to prevent update inconsistencies */
  2    94     2 workspace_id char (8),				/* "wrkspace" */
  2    95     2 component_no fixed bin,
  2    96     2 request_no fixed bin,
  2    97     2 n_queued_requests fixed bin,
  2    98     2 dead_records fixed bin,
  2    99     2 total_records fixed bin,
  2   100     2 n_components fixed bin,
  2   101     2 n_request_slots fixed bin,
  2   102     2 next_mount_type fixed bin,
  2   103     2 future_expansion (70) fixed bin (35),
  2   104     2 tape_info_copy aligned like tape_archive_table.tape_info,
  2   105     2 future_expansion2 (16) fixed bin (35),
  2   106     2 component_copy like component aligned,
  2   107     2 future_expansion3 (16) fixed bin (35),
  2   108     2 request_copy like request aligned;
  2   109 
  2   110 dcl 1 based_tape_info based (tape_info_ptr) like tape_archive_table.tape_info aligned;
  2   111 
  2   112 dcl (table_ptr, component_ptr, request_ptr, workspace_ptr, tape_info_ptr) pointer;
  2   113 
  2   114 dcl ((None initial (0),				/* next scheduled processing flags */
  2   115      Delete initial (1),
  2   116      Read initial (2),
  2   117      Write initial (3),
  2   118      Compact initial (4),
  2   119 
  2   120      Examine initial (1),				/* current lock reason flags */
  2   121      Modify initial (2),
  2   122      Process_tape initial (3),
  2   123 
  2   124      Deletion initial (1),				/* pending_operation flags */
  2   125      Extraction initial (2),
  2   126      Replacement initial (3),
  2   127      Cancellation initial (4),
  2   128      Deletion_cancellation initial (5),
  2   129      Volume_alteration initial (6),
  2   130      Table_creation initial (7),
  2   131      Table_copy initial (8),
  2   132 
  2   133      Default_density initial (1600),
  2   134 
  2   135      tape_archive_version_4 initial (4)) fixed bin,
  2   136 
  2   137      TAPE_ARCHIVE_IO_MODULE char(6) init("mtape_"),
  2   138 
  2   139      Lock_reasons (0:3) char (24) initial
  2   140     ("no discernable reason", "table examination", "table modification", "tape processing"),
  2   141 
  2   142      Magic_constant char (8) initial ("ta table"),
  2   143      Magic_workspace_constant char (8) initial ("wrkspace")) static options (constant);
  2   144 
  2   145 /* ---------------- END include file tape_archive_table_dcl.incl.pl1 ---------------- */
      111 
      112 
  3     1 /* --------------- BEGIN include file tape_archive_attributes.incl.pl1 --------------- */
  3     2 
  3     3 dcl 1 ta_attributes aligned based (attribute_seg_ptr),
  3     4     2 version_no fixed bin,
  3     5     2 own_length_in_chars fixed bin (21),
  3     6     2 branch like status_branch aligned,
  3     7     2 safety_switch bit (1) aligned,
  3     8     2 entrypt_is_bounded bit (1) aligned,
  3     9     2 entrypt_bound bit (14) aligned,
  3    10     2 max_length fixed bin (19),
  3    11     2 future_expansion (22) bit (36) aligned,
  3    12     2 acl_count fixed bin,
  3    13     2 n_components fixed bin,
  3    14     2 names (binary (ta_attributes.nnames)) char (32) unaligned,
  3    15     2 acl_list (ta_attributes.acl_count) aligned,
  3    16       3 username char (32),
  3    17       3 modes bit (36),
  3    18       3 pad bit (72),
  3    19     2 component_bc (0:ta_attributes.n_components-1) fixed bin (24);
  3    20 
  4     1 /* --------------- BEGIN include file status_structures.incl.pl1 --------------- */
  4     2 
  4     3 /* Revised from existing include files 09/26/78 by C. D. Tavares */
  4     4 
  4     5 /* This include file contains branch and link structures returned by
  4     6*   hcs_$status_ and hcs_$status_long. */
  4     7 
  4     8 dcl 1 status_branch aligned based (status_ptr),
  4     9     2 short aligned,
  4    10       3 type fixed bin (2) unaligned unsigned,		/* seg, dir, or link */
  4    11       3 nnames fixed bin (16) unaligned unsigned,		/* number of names */
  4    12       3 names_relp bit (18) unaligned,			/* see entry_names dcl */
  4    13       3 dtcm bit (36) unaligned,			/* date/time contents last modified */
  4    14       3 dtu bit (36) unaligned,			/* date/time last used */
  4    15       3 mode bit (5) unaligned,			/* caller's effective access */
  4    16       3 raw_mode bit (5) unaligned,			/* caller's raw "rew" modes */
  4    17       3 pad1 bit (8) unaligned,
  4    18       3 records_used fixed bin (18) unaligned unsigned,	/* number of NONZERO pages used */
  4    19 
  4    20 /* Limit of information returned by hcs_$status_ */
  4    21 
  4    22     2 long aligned,
  4    23       3 dtd bit (36) unaligned,			/* date/time last dumped */
  4    24       3 dtem bit (36) unaligned,			/* date/time branch last modified */
  4    25       3 lvid bit (36) unaligned,			/* logical volume ID */
  4    26       3 current_length fixed bin (12) unaligned unsigned,	/* number of last page used */
  4    27       3 bit_count fixed bin (24) unaligned unsigned,	/* reported length in bits */
  4    28       3 pad2 bit (8) unaligned,
  4    29       3 copy_switch bit (1) unaligned,			/* copy switch */
  4    30       3 tpd_switch bit (1) unaligned,			/* transparent to paging device switch */
  4    31       3 mdir_switch bit (1) unaligned,			/* is a master dir */
  4    32       3 damaged_switch bit (1) unaligned,		/* salvager warned of possible damage */
  4    33       3 synchronized_switch bit (1) unaligned,		/* DM synchronized file */
  4    34       3 pad3 bit (5) unaligned,
  4    35       3 ring_brackets (0:2) fixed bin (6) unaligned unsigned, 
  4    36       3 uid bit (36) unaligned;			/* unique ID */
  4    37 
  4    38 dcl 1 status_link aligned based (status_ptr),
  4    39     2 type fixed bin (2) unaligned unsigned,		/* as above */
  4    40     2 nnames fixed bin (16) unaligned unsigned,
  4    41     2 names_relp bit (18) unaligned,
  4    42     2 dtem bit (36) unaligned,
  4    43     2 dtd bit (36) unaligned,
  4    44     2 pathname_length fixed bin (17) unaligned,		/* see pathname */
  4    45     2 pathname_relp bit (18) unaligned;			/* see pathname */
  4    46 
  4    47 dcl  status_entry_names (status_branch.nnames) character (32) aligned
  4    48 	based (pointer (status_area_ptr, status_branch.names_relp)),
  4    49 						/* array of names returned */
  4    50      status_pathname character (status_link.pathname_length) aligned
  4    51 	based (pointer (status_area_ptr, status_link.pathname_relp)),
  4    52 						/* link target path */
  4    53      status_area_ptr pointer,
  4    54      status_ptr pointer;
  4    55 
  4    56 dcl (Link initial (0),
  4    57      Segment initial (1),
  4    58      Directory initial (2)) fixed bin internal static options (constant);
  4    59 						/* values for type fields declared above */
  4    60 
  4    61 /* ---------------- END include file status_structures.incl.pl1 ---------------- */
  3    21 
  3    22 
  3    23 /* ---------------- END include file tape_archive_attributes.incl.pl1 ---------------- */
      113 
      114 
  5     1 /* Begin include file ..... iox_modes.incl.pl1 */
  5     2 
  5     3 /* Written by C. D. Tavares, 03/17/75 */
  5     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
  5     5 
  5     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
  5     7     ("stream_input", "stream_output", "stream_input_output",
  5     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
  5     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
  5    10      "direct_input", "direct_output", "direct_update");
  5    11 
  5    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
  5    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
  5    14 
  5    15 dcl (Stream_input initial (1),
  5    16      Stream_output initial (2),
  5    17      Stream_input_output initial (3),
  5    18      Sequential_input initial (4),
  5    19      Sequential_output initial (5),
  5    20      Sequential_input_output initial (6),
  5    21      Sequential_update initial (7),
  5    22      Keyed_sequential_input initial (8),
  5    23      Keyed_sequential_output initial (9),
  5    24      Keyed_sequential_update initial (10),
  5    25      Direct_input initial (11),
  5    26      Direct_output initial (12),
  5    27      Direct_update initial (13)) fixed bin int static options (constant);
  5    28 
  5    29 /* End include file ..... iox_modes.incl.pl1 */
      115 
      116 
  6     1 /* --------------- BEGIN include file iox_dcls.incl.pl1 --------------- */
  6     2 
  6     3 /* Written 05/04/78 by C. D. Tavares */
  6     4 /* Fixed declaration of iox_$find_iocb_n 05/07/80 by R. Holmstedt */
  6     5 /* Modified 5/83 by S. Krupp to add declarations for:  iox_$open_file,
  6     6*     iox_$close_file, iox_$detach and iox_$attach_loud entries. */
  6     7 
  6     8 dcl  iox_$attach_name entry (char (*), pointer, char (*), pointer, fixed bin (35)),
  6     9      iox_$attach_ptr entry (pointer, char (*), pointer, fixed bin (35)),
  6    10      iox_$close entry (pointer, fixed bin (35)),
  6    11      iox_$control entry (pointer, char (*), pointer, fixed bin (35)),
  6    12      iox_$delete_record entry (pointer, fixed bin (35)),
  6    13      iox_$destroy_iocb entry (pointer, fixed bin (35)),
  6    14      iox_$detach_iocb entry (pointer, fixed bin (35)),
  6    15      iox_$err_not_attached entry options (variable),
  6    16      iox_$err_not_closed entry options (variable),
  6    17      iox_$err_no_operation entry options (variable),
  6    18      iox_$err_not_open entry options (variable),
  6    19      iox_$find_iocb entry (char (*), pointer, fixed bin (35)),
  6    20      iox_$find_iocb_n entry (fixed bin, ptr, fixed bin(35)),
  6    21      iox_$get_chars entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  6    22      iox_$get_line entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  6    23      iox_$look_iocb entry (char (*), pointer, fixed bin (35)),
  6    24      iox_$modes entry (pointer, char (*), char (*), fixed bin (35)),
  6    25      iox_$move_attach entry (pointer, pointer, fixed bin (35)),
  6    26      iox_$open entry (pointer, fixed bin, bit (1) aligned, fixed bin (35)),
  6    27      iox_$position entry (pointer, fixed bin, fixed bin (21), fixed bin (35)),
  6    28      iox_$propagate entry (pointer),
  6    29      iox_$put_chars entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  6    30      iox_$read_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  6    31      iox_$read_length entry (pointer, fixed bin (21), fixed bin (35)),
  6    32      iox_$read_record entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  6    33      iox_$rewrite_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  6    34      iox_$seek_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  6    35      iox_$write_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  6    36      iox_$open_file entry(ptr, fixed bin, char(*), bit(1) aligned, fixed bin(35)),
  6    37      iox_$close_file entry(ptr, char(*), fixed bin(35)),
  6    38      iox_$detach entry(ptr, char(*), fixed bin(35)),
  6    39      iox_$attach_loud entry(ptr, char(*), ptr, fixed bin(35));
  6    40 
  6    41 dcl (iox_$user_output,
  6    42      iox_$user_input,
  6    43      iox_$user_io,
  6    44      iox_$error_output) external static pointer;
  6    45 
  6    46 /* ---------------- END include file iox_dcls.incl.pl1 ---------------- */
      117 
      118 
      119 
      120 /* BUILTINS */
      121 
      122 	dcl     (addr, binary, bit, clock, collate, divide, index, length, max,
      123 	        maxlength, mod, null, substr, translate, unspec) builtin;
      124 
      125 /* CONDITION */
      126 
      127 	dcl     cleanup		 condition;
      128 
      129 extract: entry (table_ptr, component_no, tii_ptr, code);
      130 
      131 /* PARAMETERS */
      132 
      133 	dcl     component_no	 fixed bin parameter,
      134 	        tii_ptr		 pointer parameter,
      135 	        code		 fixed bin (35) parameter;
      136 
      137 	compacting = (tape_archive_table.next_mount_type = Compact);
      138 	extracting = "1"b;
      139 	goto extract_compact_common;
      140 
      141 
      142 compact: entry (table_ptr, component_no, tii_ptr, code);
      143 
      144 	compacting = "1"b;
      145 	extracting = "0"b;
      146 
      147 extract_compact_common:
      148 	component_ptr = addr (component_table (component_no));
      149 
      150 	if extracting then do;			/* Don't copy it if it's going to be deleted */
      151 		request_ptr = addr (request_queue (component.associated_request_index));
      152 		if request.delete then compacting = "0"b;
      153 	     end;
      154 	else
      155 	     request_ptr = null;			/* Compact entry does not have any requests */
      156 
      157 	cancel_deletion = "0"b;
      158 	max_chars_in_seg = sys_info$max_seg_size * 4;
      159 	temp_file_no = tape_archive_table.last_tape_file_no;
      160 	msf_fcb_ptr = null;
      161 
      162 	dirname = "";
      163 	ename = component.entry_name;
      164 
      165 /* first, open the attribute file for this component */
      166 
      167 	attribute_file_name = make_filename ("ATTRIBUTEFILE", component.attribute_file_no);
      168 	call ioa_$rsnnl (input_opd_template, input_opd, 0,
      169 	     "binary", attribute_file_name, component.attribute_file_no);
      170 
      171 	if tape_archive_io_info.long_sw then
      172 	     call ioa_ ("Searching for ^a for^[ extraction^[-deletion^]^;^s^]^[ and^;^]^[ compaction^;^].",
      173 		component.entry_name, extracting, request.delete, (extracting & compacting), compacting);
      174 
      175 	on cleanup begin;
      176 		if msf_fcb_ptr ^= null
      177 		then call msf_manager_$close (msf_fcb_ptr);
      178 		call cleanerup ();
      179 	     end;
      180 
      181 	call iox_$open_file (tape_input_switch, Sequential_input, input_opd, ""b, code);
      182 	if code ^= 0
      183 	then if code = error_table_$no_file
      184 	     then do;
      185 		     call cleanerup;
      186 		     goto returner;
      187 		end;
      188 	     else call abort;
      189 
      190 	if compacting then do;			/* create a new attribute file on the new tape */
      191 		temp_file_no = temp_file_no + 1;
      192 		attribute_file_name = make_filename ("ATTRIBUTEFILE", temp_file_no);
      193 		call open_tape_output_file (attribute_file_name, temp_file_no, "binary");
      194 	     end;
      195 
      196 	call iox_$read_record (tape_input_switch, attribute_seg_ptr, max_chars_in_seg, n_chars_read, code);
      197 						/* The whole attributes file is one large record */
      198 	if code = error_table_$short_record then code = 0;
      199 	if code ^= 0 then call abort;
      200 
      201 	call close_switch (tape_input_switch);
      202 
      203 	if compacting then do;			/* copy the attribute file onto new tape */
      204 
      205 		call iox_$write_record (tape_output_switch, attribute_seg_ptr, n_chars_read, code);
      206 		if code ^= 0 then call abort;
      207 
      208 		call close_switch (tape_output_switch);
      209 	     end;
      210 
      211 /* Keep the attribute file aside for a moment and read in the segment */
      212 
      213 	call ioa_$rsnnl (input_opd_template, input_opd, 0,
      214 	     component.recording_mode, component.tape_file_name,
      215 	     component.attribute_file_no + 1);
      216 
      217 	call iox_$open_file (tape_input_switch, Sequential_input, input_opd, ""b, code);
      218 	if code ^= 0 then call abort;
      219 
      220 	if compacting then do;			/* create a new file on new tape to copy this into also */
      221 		temp_file_no = temp_file_no + 1;
      222 		component.tape_file_name = make_filename (substr (component.tape_file_name, 1, 13), temp_file_no);
      223 		call open_tape_output_file (component.tape_file_name, temp_file_no, component.recording_mode);
      224 	     end;
      225 
      226 	if extracting then do;			/* we may be just compacting;
      227*						   otherwise, check for namedups, noaccess, etc. */
      228 		dirname = request.directory_name;
      229 		call ta_filesys_util_$prepare_extraction (table_ptr, component.associated_request_index, code);
      230 		if code ^= 0 then call cant_extract;
      231 	     end;
      232 
      233 /* Now  we must figure out where and how to read in the file.  If we are truly
      234*   extracting,  we  should read the file right into place;  otherwise, we will
      235*   read  it  into a buffer just long enough to write it back out.  Also, if it
      236*   is  binary, we want to treat records a bit differently than if it is one of
      237*   the character mode.  */
      238 
      239 /* Note  that  at  any  time an error is noticed on extraction, the extracting
      240*   switch  will  be  turned  off  so  that  extraction  will  cease,  although
      241*   compaction may continue to take place.  */
      242 
      243 	if extracting then
      244 	     if component.recording_mode = "binary" then do; /* records represent segments and not lines */
      245 		     binary_mode = "1"b;
      246 		     msf_fcb_ptr = null;
      247 		     call msf_manager_$open (dirname, ename, msf_fcb_ptr, code);
      248 		     if msf_fcb_ptr = null then call cant_extract;
      249 		end;
      250 
      251 	     else do;				/* ascii or ebcdic mode */
      252 						/* open the target file right in place */
      253 		     binary_mode = ""b;
      254 		     call ioa_$rsnnl ("vfile_ ^a>^a ", output_atd, 0, dirname, ename);
      255 
      256 		     call iox_$attach_ptr (file_output_switch, output_atd, null, code);
      257 		     if code ^= 0 then call cant_extract;
      258 
      259 		     call iox_$open (file_output_switch, Stream_output, ""b, code);
      260 		     if code ^= 0 then call cant_extract;
      261 		end;
      262 
      263 /* Now read in the file itself.  If this is a binary file, we will read records and make segments out of each one.
      264*   If it is a character file, we will treat individual records as lines. */
      265 
      266 	if /* still */ extracting then
      267 	     if tape_archive_io_info.long_sw then
      268 		call ioa_ ("Reading ^a.", component.entry_name);
      269 
      270 	do j = 1 by 1 to component.n_tape_records while (extracting | compacting);
      271 
      272 	     if (extracting & binary_mode) then do;
      273 		     call msf_manager_$get_ptr (msf_fcb_ptr, j - 1, "1"b /* create */, seg_ptr, 0, code);
      274 						/* create an SSF or an MSF component to put the data into */
      275 		     if seg_ptr = null then do;
      276 			     call cant_extract;
      277 			     readin_ptr = buffer_ptr;
      278 			end;
      279 		     else readin_ptr = seg_ptr;
      280 		end;
      281 
      282 	     else readin_ptr = buffer_ptr;
      283 
      284 /* Read one record from the tape */
      285 
      286 	     if (extracting | compacting) then do;
      287 		     call iox_$read_record (tape_input_switch, readin_ptr, max_chars_in_seg, n_chars_read, code);
      288 		     if code = error_table_$short_record then code = 0;
      289 		     if code ^= 0 then call abort;
      290 		end;
      291 
      292 	     if compacting then do;
      293 		     call iox_$write_record (tape_output_switch, readin_ptr, n_chars_read, code);
      294 		     if code ^= 0 then call abort;
      295 		end;
      296 
      297 	     if extracting then do;
      298 		     if binary_mode then do;
      299 			     n_words_read = divide (n_chars_read + 3, 4, 18, 0);
      300 			     call hcs_$truncate_seg (seg_ptr, n_words_read, 0);
      301 
      302 			     i = mod (n_chars_read, 4);
      303 			     if i > 0 then substr (based_segment (n_words_read), i * 9 + 1) = ""b;
      304 
      305 			     call hcs_$set_bc_seg (seg_ptr, ta_attributes.component_bc (j - 1), code);
      306 			end;
      307 
      308 		     else do;			/* add a final newline and pump out the line */
      309 			     n_chars_read = n_chars_read + 1;
      310 			     substr (buffer, n_chars_read, 1) = Newline;
      311 
      312 /* Special hack: If the file had no final newline, don't add one */
      313 
      314 			     if j = component.n_tape_records then
      315 				if component.no_final_newline then n_chars_read = n_chars_read - 1;
      316 
      317 			     call iox_$put_chars (file_output_switch, buffer_ptr, n_chars_read, code);
      318 			     if code ^= 0 then call abort;
      319 			end;
      320 		end;
      321 	end;
      322 
      323 /* Everything's off the tape (and/or on the new tape);  clean up */
      324 
      325 	if (extracting & binary_mode)
      326 	then call msf_manager_$close (msf_fcb_ptr);
      327 
      328 	call cleanerup ();
      329 
      330 /* Now apply the attributes (ACL, names, etc.) to our newly extracted file. */
      331 
      332 	if extracting then do;
      333 		call ta_filesys_util_$replace_attributes (table_ptr, component.associated_request_index, attribute_seg_ptr, code);
      334 		if code ^= 0 then call abort;
      335 	     end;
      336 
      337 	if compacting then component.attribute_file_no = temp_file_no - 1; /* remember to reset the attribute file no. */
      338 	tape_archive_table.last_tape_file_no = temp_file_no;
      339 
      340 	if cancel_deletion then code = 1; else code = 0;	/* tell caller if deletion cancelled */
      341 	return;





      342 
      343 cant_extract: proc;
      344 
      345 /* This  internal procedure will print out whatever error caused extraction to
      346*   fail,  reset  the  extraction  flag,  and the RETURN so that compaction, if
      347*   being done, may continue to completion.  
      348*
      349*   Special handling is required if the component is to be deleted. If the
      350*   request is for an extraction only, then the deletion request can simply be
      351*   cancelled. If a compaction is also taking place, however, then it has
      352*   already been suppressed.  Now that the extraction has failed, an attempt
      353*   must be made to go back and recover this component for the compacted volume
      354*   set.
      355*
      356*   Since the request.delete flag is used by ta_table_mgr_ for dead record
      357*   management, it cannot be used to cancel the deletion. The caller must be
      358*   notified through a code indicating this special case. */
      359 
      360 	extracting = "0"b;
      361 	call com_err_ (code, "tape_archive", "^a>^a^/^5xExtraction^[-deletion^] request will be ignored.",
      362 	     dirname, ename, request.delete);
      363 	if request.delete then
      364 	     if output_opd_template ^= "" then do;	/* if compacting, try to recover component */
      365 		     cancel_deletion = "1"b;
      366 		     compacting = "1"b;
      367 		     call cleanerup ();
      368 		     if msf_fcb_ptr ^= null
      369 		     then call msf_manager_$close (msf_fcb_ptr);
      370 		     goto extract_compact_common;
      371 		end;
      372 	     else cancel_deletion = "1"b;		/* just extracting -- cancel deletion */
      373      end cant_extract;
      374 
      375 append: entry (table_ptr, request_no, tii_ptr, code);
      376 
      377 /* PARAMETER */
      378 
      379 	dcl     request_no		 fixed bin parameter;
      380 
      381 /* ENTRY */
      382 
      383 
      384 	request_ptr = addr (request_queue (request_no));
      385 	max_chars_in_seg = sys_info$max_seg_size * 4;
      386 	temp_file_no = tape_archive_table.last_tape_file_no;
      387 	msf_fcb_ptr = null;
      388 
      389 	dirname = request.directory_name;
      390 	ename = request.entry_name;
      391 
      392 /* Create  an attribute file for this file, which will contain the ACL, names,
      393*   etc.   for  replacement  purposes  when the time comes to recreate the file
      394*   online */
      395 
      396 	if request.recording_mode = "" then
      397 	     request.recording_mode = "binary";
      398 
      399 	binary_mode = (request.recording_mode = "binary");
      400 
      401 	call ta_filesys_util_$create_attribute_file (table_ptr, request_no,
      402 	     attribute_seg_ptr, binary_mode, code);
      403 	if code ^= 0 then return;
      404 
      405 /* Choose  the  proper  recording  mode  for this file, based on what the user
      406*   requested and what the data really is */
      407 
      408 	if binary_mode then /* seg is not legal ASCII */
      409 	     if request.recording_mode ^= "binary" then do;
      410 		     call com_err_ (0, "tape_archive",
      411 			"^a cannot be recorded in ^a mode;  using binary mode.",
      412 			ename, request.recording_mode);
      413 		     request.recording_mode = "binary";
      414 		end;
      415 
      416 /* End of fun and games, now comes the serious work of getting it out there */
      417 
      418 	request.date_time_archived = substr (bit (clock ()), 20, 36); /* standard file system time */
      419 	request.no_final_newline = ""b;
      420 
      421 	on cleanup begin;
      422 		if msf_fcb_ptr ^= null
      423 		then call msf_manager_$close (msf_fcb_ptr);
      424 		call cleanerup ();
      425 	     end;
      426 
      427 /* Put the attribute file out to tape first */
      428 
      429 	if tape_archive_io_info.long_sw then
      430 	     call ioa_ ("Appending ^a.", request.entry_name);
      431 
      432 	temp_file_no = temp_file_no + 1;
      433 	request.attribute_file_no = temp_file_no;
      434 	attribute_file_name = make_filename ("ATTRIBUTEFILE", temp_file_no);
      435 	call open_tape_output_file (attribute_file_name, temp_file_no, "binary");
      436 
      437 /* Write out the attribute file as one huge record */
      438 
      439 	call iox_$write_record (tape_output_switch, attribute_seg_ptr, ta_attributes.own_length_in_chars, code);
      440 	if code ^= 0 then call abort;
      441 
      442 	call close_switch (tape_output_switch);
      443 
      444 /* Now, down to the business of recording the file itself */
      445 
      446 	temp_file_no = temp_file_no + 1;
      447 	request.tape_file_name =
      448 	     make_filename (substr (ename, 1, 12), temp_file_no);
      449 	call open_tape_output_file (request.tape_file_name, temp_file_no, request.recording_mode);
      450 
      451 	if request.recording_mode = "binary" then do;
      452 		call msf_manager_$open (dirname, ename, msf_fcb_ptr, code);
      453 						/* Nice that msf_manager_ works on SSF's too! */
      454 		if code ^= 0 then call abort;
      455 
      456 		do i = 1 to max (ta_attributes.n_components, 1);
      457 		     call msf_manager_$get_ptr (msf_fcb_ptr, i - 1, ""b /* don't create */, seg_ptr, bit_count, code);
      458 		     if code ^= 0 then call abort;
      459 
      460 		     char_count = divide (bit_count, 9, 21, 0);
      461 
      462 		     call iox_$write_record (tape_output_switch, seg_ptr, char_count, code);
      463 		     if code ^= 0 then call abort;
      464 		end;
      465 
      466 		request.n_tape_records = i - 1;
      467 	     end;
      468 
      469 	else do;
      470 
      471 		call ioa_$rsnnl ("vfile_ ^a>^a", output_atd, 0, dirname, ename);
      472 
      473 		call iox_$attach_ptr (file_input_switch, output_atd, null, code);
      474 		if code ^= 0 then call abort;
      475 
      476 		call iox_$open (file_input_switch, Stream_input, ""b, code);
      477 		if code ^= 0 then call abort;
      478 
      479 		do i = 1 by 1 while (code ^= error_table_$end_of_info);
      480 
      481 		     call iox_$get_line (file_input_switch, buffer_ptr, max_chars_in_seg, n_chars_read, code);
      482 
      483 		     if code = 0 then /* strip newline */
      484 			n_chars_read = n_chars_read - 1;
      485 		     else if code = error_table_$short_record then do;
      486 			     if substr (buffer, n_chars_read, 1) = Newline then
      487 				call abort;	/* shouldn't! */
      488 			     request.no_final_newline = "1"b;
      489 			     code = 0;
      490 			end;
      491 		     else if code = error_table_$end_of_info then
      492 			request.n_tape_records = i - 1;
      493 		     else call abort;
      494 
      495 		     if code = 0 then do;
      496 			     call iox_$write_record (tape_output_switch, buffer_ptr, n_chars_read, code);
      497 			     if code ^= 0 then call abort;
      498 			end;
      499 		end;
      500 
      501 	     end;
      502 
      503 	call cleanerup ();
      504 	if msf_fcb_ptr ^= null
      505 	then call msf_manager_$close (msf_fcb_ptr);
      506 
      507 	tape_archive_table.last_tape_file_no = temp_file_no;
      508 	code = 0;
      509 	return;
      510 
      511 append_table: entry (table_ptr, tii_ptr, code);
      512 
      513 /* This entry writes the tape archive table out to tape. */
      514 
      515 /* AUTOMATIC */
      516 
      517 	dcl     tablefile_name	 char (17) aligned;
      518 
      519 	tape_archive_table.last_table_no = tape_archive_table.last_table_no + 1;
      520 	tablefile_name = make_filename ("ONLINE-TABLE-", tape_archive_table.last_table_no);
      521 
      522 	tape_archive_table.last_tape_file_no = tape_archive_table.last_tape_file_no + 1;
      523 						/* bump for file taken up by the table */
      524 	dirname = "";				/* for error messages */
      525 	ename = "tape copy of online table";
      526 	call open_tape_output_file (tablefile_name, tape_archive_table.last_tape_file_no, "binary");
      527 
      528 	char_count = divide (length (unspec (tape_archive_table)), 9, 21, 0);
      529 
      530 	call iox_$write_record (tape_output_switch, table_ptr, char_count, code);
      531 
      532 	call close_switch (tape_output_switch);
      533 
      534 	return;
      535 
      536 open_tape_output_file: proc (file_name, file_no, mode);
      537 
      538 	dcl     file_name		 char (17) aligned parameter,
      539 	        file_no		 fixed bin parameter,
      540 	        mode		 char (8) aligned parameter;
      541 
      542 	call ioa_$rsnnl (output_opd_template, output_opd, 0,
      543 	     mode, file_name, file_no);
      544 
      545 	call iox_$open_file (tape_output_switch, Sequential_output, output_opd, ""b, code);
      546 	if code ^= 0 then call abort;
      547 
      548 	return;
      549 
      550      end open_tape_output_file;





      551 
      552 make_filename: entry (table_ptr, arg_filename_part, arg_file_no) returns (char (17) aligned);
      553 
      554 	dcl     arg_filename_part	 char (13) parameter,
      555 	        arg_file_no		 fixed bin parameter;
      556 
      557 	return (make_filename (arg_filename_part, arg_file_no));



      558 
      559 make_filename: proc (filename_part, file_no) returns (char (17) aligned);
      560 
      561 	dcl     filename_part	 char (13) parameter,
      562 	        file_no		 fixed bin parameter;
      563 
      564 	dcl     complete_filename	 char (17) aligned,
      565 	        file_no_picture	 pic "9999";
      566 
      567 	file_no_picture = file_no;
      568 
      569 	if tape_archive_table.io_module_name = "tape_ansi_" then
      570 	     complete_filename = translate (filename_part, Legal_name_chars_ansi, collate ()) || file_no_picture;
      571 
      572 	else do;
      573 		if filename_part = "ONLINE-TABLE-" then
      574 		     complete_filename = "ONLINE#TABLE#" || file_no_picture;
      575 		else complete_filename = translate (filename_part, Legal_name_chars_ibm, collate ()) || file_no_picture;
      576 		if index (Upper_case || "@#$", substr (complete_filename, 1, 1)) > 0
      577 						/* ensure first character meets requirements of IBM*/
      578 		then complete_filename = "X" || substr (complete_filename, 1, maxlength (complete_filename) - 1);
      579 		substr (complete_filename, 9, 1) = ".";
      580 		if index (Upper_case, substr (complete_filename, 10, 1)) = 0 then
      581 		     substr (complete_filename, 10, 1) = "X";
      582 	     end;
      583 
      584 	return (complete_filename);
      585 
      586      end make_filename;





      587 
      588 close_switch: proc (switch_ptr);
      589 
      590 	dcl     switch_ptr		 pointer parameter;
      591 	dcl     code		 fixed bin (35);
      592 
      593 	call iox_$close (switch_ptr, code);
      594 
      595      end close_switch;





      596 
      597 cleanerup: proc;
      598 
      599 	dcl     temp_ptr		 pointer;
      600 
      601 	do temp_ptr = file_input_switch, file_output_switch;
      602 
      603 	     call iox_$close (temp_ptr, 0);
      604 	     call iox_$detach_iocb (temp_ptr, 0);
      605 	end;
      606 
      607 	do temp_ptr = tape_input_switch, tape_output_switch;
      608 	     call iox_$close (temp_ptr, 0);
      609 	end;
      610 
      611      end cleanerup;





      612 
      613 abort: proc options (non_quick);
      614 
      615 	call com_err_ (code, "tape_archive", "Unexpected error while processing ^[^s^;^a>^]^a", (dirname = ""), dirname, ename);
      616 	call cleanerup ();
      617 	goto returner;
      618      end abort;
      619 
      620 returner: return;
      621 
      622      end ta_file_io_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/30/87  1322.6  ta_file_io_.pl1                   >spec>install>1006>ta_file_io_.pl1
104          1    02/16/84  1452.4  tape_archive_io_info.incl.pl1     >ldd>include>tape_archive_io_info.incl.pl1
111          2    02/16/84  1452.4  tape_archive_table_dcl.incl.pl1   >ldd>include>tape_archive_table_dcl.incl.pl1
113          3    01/15/79  2202.8  tape_archive_attributes.incl.pl1  >ldd>include>tape_archive_attributes.incl.pl1
3-21         4    11/22/82  0955.7  status_structures.incl.pl1        >ldd>include>status_structures.incl.pl1
115          5    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
117          6    05/23/83  0916.6  iox_dcls.incl.pl1                 >ldd>include>iox_dcls.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Compact                                constant        fixed bin(17,0)          initial dcl 2-114 ref 137
Legal_name_chars_ansi           000047 constant        char(128)                initial unaligned dcl 84 ref 569
Legal_name_chars_ibm            000007 constant        char(128)                initial unaligned dcl 84 ref 575
Newline                         004726 constant        char(1)                  initial unaligned dcl 84 ref 310 486
Sequential_input                000135 constant        fixed bin(17,0)          initial dcl 5-15 set ref 181* 217*
Sequential_output               000136 constant        fixed bin(17,0)          initial dcl 5-15 set ref 545*
Stream_input                    000137 constant        fixed bin(17,0)          initial dcl 5-15 set ref 476*
Stream_output                   000140 constant        fixed bin(17,0)          initial dcl 5-15 set ref 259*
Upper_case                      000000 constant        char(26)                 initial unaligned dcl 84 ref 576 580
acl_count                46            based           fixed bin(17,0)          level 2 dcl 3-3 ref 305
addr                                                   builtin function         dcl 122 ref 147 151 384
arg_file_no                            parameter       fixed bin(17,0)          dcl 554 set ref 552 557*
arg_filename_part                      parameter       char(13)                 unaligned dcl 554 set ref 552 557*
associated_request_index
                         41            based           fixed bin(17,0)          level 2 dcl 2-53 set ref 151 229* 333*
attribute_file_name             000100 automatic       char(17)                 dcl 46 set ref 167* 168* 192* 193* 434* 435*
attribute_file_no        34            based           fixed bin(17,0)          level 4 in structure "component" dcl 2-53
                                                                                  in procedure "ta_file_io_" set ref 167* 168* 213
                                                                                  337*
attribute_file_no        34            based           fixed bin(17,0)          level 4 in structure "request" dcl 2-60 in procedure
                                                                                  "ta_file_io_" set ref 433*
attribute_seg_ptr       414            based           pointer                  level 3 dcl 103 set ref 196* 205* 305 305 305 333*
                                                                                  401* 439* 439 456
based_segment                          based           bit(36)                  array dcl 106 set ref 303*
binary                                                 builtin function         dcl 122 ref 305
binary_mode                     000105 automatic       bit(1)                   dcl 46 set ref 245* 253* 272 298 325 399* 401* 408
bit                                                    builtin function         dcl 122 ref 418
bit_count                       000106 automatic       fixed bin(24,0)          dcl 46 set ref 457* 460
branch                    2            based           structure                level 2 dcl 3-3
buffer                                 based           char                     unaligned dcl 106 set ref 310* 486
buffer_ptr              416            based           pointer                  level 3 dcl 103 set ref 277 282 310 317* 481* 486
                                                                                  496*
cancel_deletion                 000107 automatic       bit(1)                   dcl 46 set ref 157* 340 365* 372*
char_count                      000110 automatic       fixed bin(21,0)          dcl 46 set ref 460* 462* 528* 530*
cleanup                         001024 stack reference condition                dcl 127 ref 175 421
clock                                                  builtin function         dcl 122 ref 418
code                                   parameter       fixed bin(35,0)          dcl 133 in procedure "ta_file_io_" set ref 129 142
                                                                                  181* 182 182 196* 198 198* 199 205* 206 217* 218
                                                                                  229* 230 247* 256* 257 259* 260 273* 287* 288 288*
                                                                                  289 293* 294 305* 317* 318 333* 334 340* 340* 361*
                                                                                  375 401* 403 439* 440 452* 454 457* 458 462* 463
                                                                                  473* 474 476* 477 479 481* 483 485 489* 491 495
                                                                                  496* 497 508* 511 530* 545* 546 615*
code                            001104 automatic       fixed bin(35,0)          dcl 591 in procedure "close_switch" set ref 593*
collate                                                builtin function         dcl 122 ref 569 575
com_err_                        000010 constant        entry                    external dcl 70 ref 361 410 615
compacting                      000111 automatic       bit(1)                   dcl 46 set ref 137* 144* 152* 171 171* 190 203 220
                                                                                  270 286 292 337 366*
complete_filename               001070 automatic       char(17)                 dcl 564 set ref 569* 573* 575* 576 576* 576 576 579*
                                                                                  580 580* 584
component                              based           structure                level 1 dcl 2-53
component_bc                           based           fixed bin(24,0)          array level 2 dcl 3-3 set ref 305*
component_no                           parameter       fixed bin(17,0)          dcl 133 ref 129 142 147
component_ptr                   001020 automatic       pointer                  dcl 2-112 set ref 147* 151 163 167 168 171 213 213
                                                                                  213 222 222 222 223 223 229 243 266 270 314 314
                                                                                  333 337
component_table        1330            based           structure                array level 3 dcl 2-14 set ref 147
date_time_archived       16            based           bit(36)                  level 4 dcl 2-60 set ref 418*
delete                  112(03)        based           bit(1)                   level 3 packed unaligned dcl 2-60 set ref 152 171*
                                                                                  361* 363
directory_name           40            based           char(168)                level 2 packed unaligned dcl 2-60 ref 228 389
dirname                         000112 automatic       char(168)                unaligned dcl 46 set ref 162* 228* 247* 254* 361*
                                                                                  389* 452* 471* 524* 615 615*
divide                                                 builtin function         dcl 122 ref 299 460 528
ename                           000164 automatic       char(32)                 unaligned dcl 46 set ref 163* 247* 254* 361* 390*
                                                                                  410* 447 447 452* 471* 525* 615*
entry_name                6            based           char(32)                 level 4 in structure "component" packed unaligned
                                                                                  dcl 2-53 in procedure "ta_file_io_" set ref 163
                                                                                  171* 266*
entry_name                6            based           char(32)                 level 4 in structure "request" packed unaligned
                                                                                  dcl 2-60 in procedure "ta_file_io_" set ref 390
                                                                                  429*
entry_status_descriptor                based           structure                level 2 in structure "component" dcl 2-53
                                                                                  in procedure "ta_file_io_"
entry_status_descriptor                based           structure                level 1 dcl 2-74 in procedure "ta_file_io_"
entry_status_descriptor                based           structure                level 2 in structure "request" dcl 2-60 in procedure
                                                                                  "ta_file_io_"
error_table_$end_of_info        000036 external static fixed bin(35,0)          dcl 95 ref 479 491
error_table_$no_file            000040 external static fixed bin(35,0)          dcl 95 ref 182
error_table_$short_record       000042 external static fixed bin(35,0)          dcl 95 ref 198 288 485
extracting                      000174 automatic       bit(1)                   dcl 46 set ref 138* 145* 150 171* 171 226 243 266
                                                                                  270 272 286 297 325 332 360*
file_info                 1            based           structure                level 3 in structure "request" dcl 2-60 in procedure
                                                                                  "ta_file_io_"
file_info                 1            based           structure                level 3 in structure "component" dcl 2-53
                                                                                  in procedure "ta_file_io_"
file_input_switch       410            based           pointer                  level 2 dcl 103 set ref 473* 476* 481* 601
file_name                              parameter       char(17)                 dcl 538 set ref 536 542*
file_no                                parameter       fixed bin(17,0)          dcl 561 in procedure "make_filename" ref 559 567
file_no                                parameter       fixed bin(17,0)          dcl 538 in procedure "open_tape_output_file" set ref
                                                                                  536 542*
file_no_picture                 001075 automatic       picture(4)               unaligned dcl 564 set ref 567* 569 573 575
file_output_switch      412            based           pointer                  level 2 dcl 103 set ref 256* 259* 317* 601
filename_part                          parameter       char(13)                 unaligned dcl 561 ref 559 569 573 575
hcs_$set_bc_seg                 000012 constant        entry                    external dcl 70 ref 305
hcs_$truncate_seg               000014 constant        entry                    external dcl 70 ref 300
i                               000175 automatic       fixed bin(17,0)          dcl 46 set ref 302* 303 303 456* 457* 466 479* 491*
index                                                  builtin function         dcl 122 ref 576 580
input_opd                       000176 automatic       char(520)                unaligned dcl 46 set ref 168* 181* 213* 217*
input_opd_template        2            based           char(520)                level 2 dcl 103 set ref 168* 213*
io_module_name           20            based           char(32)                 level 3 dcl 2-14 ref 569
ioa_                            000016 constant        entry                    external dcl 70 ref 171 266 429
ioa_$rsnnl                      000020 constant        entry                    external dcl 70 ref 168 213 254 471 542
iox_$attach_ptr                 000046 constant        entry                    external dcl 6-8 ref 256 473
iox_$close                      000050 constant        entry                    external dcl 6-8 ref 593 603 608
iox_$detach_iocb                000052 constant        entry                    external dcl 6-8 ref 604
iox_$get_line                   000054 constant        entry                    external dcl 6-8 ref 481
iox_$open                       000056 constant        entry                    external dcl 6-8 ref 259 476
iox_$open_file                  000066 constant        entry                    external dcl 6-8 ref 181 217 545
iox_$put_chars                  000060 constant        entry                    external dcl 6-8 ref 317
iox_$read_record                000062 constant        entry                    external dcl 6-8 ref 196 287
iox_$write_record               000064 constant        entry                    external dcl 6-8 ref 205 293 439 462 496 530
j                               000400 automatic       fixed bin(17,0)          dcl 46 set ref 270* 273 305 314*
last_table_no            53            based           fixed bin(17,0)          level 3 dcl 2-14 set ref 519* 519 520*
last_tape_file_no        52            based           fixed bin(17,0)          level 3 dcl 2-14 set ref 159 338* 386 507* 522* 522
                                                                                  526*
length                                                 builtin function         dcl 122 ref 528
long_sw                 422            based           bit(1)                   level 2 dcl 103 ref 171 266 429
max                                                    builtin function         dcl 122 ref 456
max_chars_in_seg                000401 automatic       fixed bin(21,0)          dcl 46 set ref 158* 196* 287* 310 385* 481* 486
maxlength                                              builtin function         dcl 122 ref 576
mod                                                    builtin function         dcl 122 ref 302
mode                                   parameter       char(8)                  dcl 538 set ref 536 542*
msf_fcb_ptr                     000402 automatic       pointer                  dcl 46 set ref 160* 176 176* 246* 247* 248 273* 325*
                                                                                  368 368* 387* 422 422* 452* 457* 504 504*
msf_manager_$close              000022 constant        entry                    external dcl 70 ref 176 325 368 422 504
msf_manager_$get_ptr            000024 constant        entry                    external dcl 70 ref 273 457
msf_manager_$open               000026 constant        entry                    external dcl 70 ref 247 452
n_chars_read                    000404 automatic       fixed bin(21,0)          dcl 46 set ref 196* 205* 287* 293* 299 302 309* 309
                                                                                  310 314* 314 317* 481* 483* 483 486 496*
n_component_slots        41            based           fixed bin(17,0)          level 3 dcl 2-14 ref 151 384 528
n_components             47            based           fixed bin(17,0)          level 2 dcl 3-3 ref 456
n_request_slots          43            based           fixed bin(17,0)          level 3 dcl 2-14 ref 528
n_tape_records           35            based           fixed bin(35,0)          level 4 in structure "component" dcl 2-53
                                                                                  in procedure "ta_file_io_" ref 270 314
n_tape_records           35            based           fixed bin(35,0)          level 4 in structure "request" dcl 2-60 in procedure
                                                                                  "ta_file_io_" set ref 466* 491*
n_words_read                    000405 automatic       fixed bin(18,0)          dcl 46 set ref 299* 300* 303
next_mount_type          44            based           fixed bin(17,0)          level 3 dcl 2-14 ref 137
nnames                    2(02)        based           fixed bin(16,0)          level 4 packed unsigned unaligned dcl 3-3 ref 305
no_final_newline          0(01)        based           bit(1)                   level 3 in structure "component" packed unaligned
                                                                                  dcl 2-53 in procedure "ta_file_io_" ref 314
no_final_newline          0(01)        based           bit(1)                   level 3 in structure "request" packed unaligned
                                                                                  dcl 2-60 in procedure "ta_file_io_" set ref 419*
                                                                                  488*
nonvolatile_part                       based           structure                level 2 dcl 2-14
null                                                   builtin function         dcl 122 ref 154 160 176 246 248 256 256 275 368 387
                                                                                  422 473 473 504
output_atd                      000406 automatic       char(520)                unaligned dcl 46 set ref 254* 256* 471* 473*
output_opd                      000610 automatic       char(520)                unaligned dcl 46 set ref 542* 545*
output_opd_template     206            based           char(520)                level 2 dcl 103 set ref 363 542*
own_length_in_chars       1            based           fixed bin(21,0)          level 2 dcl 3-3 set ref 439*
readin_ptr                      001012 automatic       pointer                  dcl 46 set ref 277* 279* 282* 287* 293*
recording_mode           17            based           char(8)                  level 4 in structure "request" dcl 2-60 in procedure
                                                                                  "ta_file_io_" set ref 396 396* 399 408 410* 413*
                                                                                  449* 451
recording_mode           17            based           char(8)                  level 4 in structure "component" dcl 2-53
                                                                                  in procedure "ta_file_io_" set ref 213* 223* 243
request                                based           structure                level 1 dcl 2-60
request_no                             parameter       fixed bin(17,0)          dcl 379 set ref 375 384 401*
request_ptr                     001022 automatic       pointer                  dcl 2-112 set ref 151* 152 154* 171 228 361 363 384*
                                                                                  389 390 396 396 399 408 410 413 418 419 429 433
                                                                                  447 449 449 451 466 488 491
request_queue                          based           structure                array level 3 dcl 2-14 set ref 151 384
requested_ops           112            based           structure                level 2 packed unaligned dcl 2-60
seg_ptr                         001014 automatic       pointer                  dcl 46 set ref 273* 275 279 300* 303 305* 457* 462*
short                     2            based           structure                level 3 dcl 3-3
status_branch                          based           structure                level 1 dcl 4-8
substr                                                 builtin function         dcl 122 set ref 222 222 303* 310* 418 447 447 486
                                                                                  576 576 579* 580 580*
switch_ptr                             parameter       pointer                  dcl 590 set ref 588 593*
sys_info$max_seg_size           000044 external static fixed bin(35,0)          dcl 99 ref 158 385
ta_attributes                          based           structure                level 1 dcl 3-3
ta_filesys_util_$create_attribute_file
                                000030 constant        entry                    external dcl 78 ref 401
ta_filesys_util_$prepare_extraction
                                000032 constant        entry                    external dcl 78 ref 229
ta_filesys_util_$replace_attributes
                                000034 constant        entry                    external dcl 78 ref 333
table_ptr                              parameter       pointer                  dcl 2-112 set ref 129 137 142 147 151 159 229* 333*
                                                                                  338 375 384 386 401* 507 511 519 519 520 522 522
                                                                                  526 528 530* 552 569
tablefile_name                  001032 automatic       char(17)                 dcl 517 set ref 520* 526*
tape_archive_io_info                   based           structure                level 1 dcl 103
tape_archive_table                     based           structure                level 1 dcl 2-14 set ref 528
tape_file_name            1            based           char(17)                 level 4 in structure "component" dcl 2-53
                                                                                  in procedure "ta_file_io_" set ref 213* 222* 222
                                                                                  222 223*
tape_file_name            1            based           char(17)                 level 4 in structure "request" dcl 2-60 in procedure
                                                                                  "ta_file_io_" set ref 447* 449*
tape_info                64            based           structure                level 3 dcl 2-14
tape_input_switch                      based           pointer                  level 2 dcl 103 set ref 181* 196* 201* 217* 287* 607
tape_output_switch      204            based           pointer                  level 2 dcl 103 set ref 205* 208* 293* 439* 442*
                                                                                  462* 496* 530* 532* 545* 607
temp_file_no                    001016 automatic       fixed bin(17,0)          dcl 46 set ref 159* 191* 191 192* 193* 221* 221 222*
                                                                                  223* 337 338 386* 432* 432 433 434* 435* 446* 446
                                                                                  447* 449* 507
temp_ptr                        000100 automatic       pointer                  dcl 599 set ref 601* 603* 604* 607* 608*
temp_seg_ptrs           414            based           structure                level 2 dcl 103
tii_ptr                                parameter       pointer                  dcl 133 ref 129 142 168 171 181 196 196 201 205 205
                                                                                  208 213 217 256 259 266 277 282 287 293 305 305
                                                                                  305 310 317 317 333 363 375 401 429 439 439 439
                                                                                  442 456 462 473 476 481 481 486 496 496 511 530
                                                                                  532 542 545 601 601 607 607
translate                                              builtin function         dcl 122 ref 569 575
unspec                                                 builtin function         dcl 122 ref 528
volatile_part            40            based           structure                level 2 dcl 2-14

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Cancellation                           internal static fixed bin(17,0)          initial dcl 2-114
Default_density                        internal static fixed bin(17,0)          initial dcl 2-114
Delete                                 internal static fixed bin(17,0)          initial dcl 2-114
Deletion                               internal static fixed bin(17,0)          initial dcl 2-114
Deletion_cancellation                  internal static fixed bin(17,0)          initial dcl 2-114
Direct_input                           internal static fixed bin(17,0)          initial dcl 5-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 5-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 5-15
Directory                              internal static fixed bin(17,0)          initial dcl 4-56
Examine                                internal static fixed bin(17,0)          initial dcl 2-114
Extraction                             internal static fixed bin(17,0)          initial dcl 2-114
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 5-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 5-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 5-15
Link                                   internal static fixed bin(17,0)          initial dcl 4-56
Lock_reasons                           internal static char(24)                 initial array unaligned dcl 2-114
Magic_constant                         internal static char(8)                  initial unaligned dcl 2-114
Magic_workspace_constant               internal static char(8)                  initial unaligned dcl 2-114
Modify                                 internal static fixed bin(17,0)          initial dcl 2-114
None                                   internal static fixed bin(17,0)          initial dcl 2-114
Process_tape                           internal static fixed bin(17,0)          initial dcl 2-114
Read                                   internal static fixed bin(17,0)          initial dcl 2-114
Replacement                            internal static fixed bin(17,0)          initial dcl 2-114
Segment                                internal static fixed bin(17,0)          initial dcl 4-56
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 5-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 5-15
Stream_input_output                    internal static fixed bin(17,0)          initial dcl 5-15
TAPE_ARCHIVE_IO_MODULE                 internal static char(6)                  initial unaligned dcl 2-114
Table_copy                             internal static fixed bin(17,0)          initial dcl 2-114
Table_creation                         internal static fixed bin(17,0)          initial dcl 2-114
Volume_alteration                      internal static fixed bin(17,0)          initial dcl 2-114
Write                                  internal static fixed bin(17,0)          initial dcl 2-114
based_tape_info                        based           structure                level 1 dcl 2-110
based_temp_seg_ptrs                    based           pointer                  array dcl 1-17
iox_$attach_loud                000000 constant        entry                    external dcl 6-8
iox_$attach_name                000000 constant        entry                    external dcl 6-8
iox_$close_file                 000000 constant        entry                    external dcl 6-8
iox_$control                    000000 constant        entry                    external dcl 6-8
iox_$delete_record              000000 constant        entry                    external dcl 6-8
iox_$destroy_iocb               000000 constant        entry                    external dcl 6-8
iox_$detach                     000000 constant        entry                    external dcl 6-8
iox_$err_no_operation           000000 constant        entry                    external dcl 6-8
iox_$err_not_attached           000000 constant        entry                    external dcl 6-8
iox_$err_not_closed             000000 constant        entry                    external dcl 6-8
iox_$err_not_open               000000 constant        entry                    external dcl 6-8
iox_$error_output                      external static pointer                  dcl 6-41
iox_$find_iocb                  000000 constant        entry                    external dcl 6-8
iox_$find_iocb_n                000000 constant        entry                    external dcl 6-8
iox_$get_chars                  000000 constant        entry                    external dcl 6-8
iox_$look_iocb                  000000 constant        entry                    external dcl 6-8
iox_$modes                      000000 constant        entry                    external dcl 6-8
iox_$move_attach                000000 constant        entry                    external dcl 6-8
iox_$position                   000000 constant        entry                    external dcl 6-8
iox_$propagate                  000000 constant        entry                    external dcl 6-8
iox_$read_key                   000000 constant        entry                    external dcl 6-8
iox_$read_length                000000 constant        entry                    external dcl 6-8
iox_$rewrite_record             000000 constant        entry                    external dcl 6-8
iox_$seek_key                   000000 constant        entry                    external dcl 6-8
iox_$user_input                        external static pointer                  dcl 6-41
iox_$user_io                           external static pointer                  dcl 6-41
iox_$user_output                       external static pointer                  dcl 6-41
iox_modes                              internal static char(24)                 initial array dcl 5-6
short_iox_modes                        internal static char(4)                  initial array dcl 5-12
status_area_ptr                        automatic       pointer                  dcl 4-47
status_entry_names                     based           char(32)                 array dcl 4-47
status_link                            based           structure                level 1 dcl 4-38
status_pathname                        based           char                     dcl 4-47
status_ptr                             automatic       pointer                  dcl 4-47
tape_archive_version_4                 internal static fixed bin(17,0)          initial dcl 2-114
tape_info_ptr                          automatic       pointer                  dcl 2-112
workspace                              based           structure                level 1 dcl 2-93
workspace_ptr                          automatic       pointer                  dcl 2-112

NAMES DECLARED BY EXPLICIT CONTEXT.
abort                           004214 constant        entry                    internal dcl 613 ref 188 199 206 218 289 294 318 334
                                                                                  440 454 458 463 474 477 486 493 497 546
append                          002200 constant        entry                    external dcl 375
append_table                    003264 constant        entry                    external dcl 511
cant_extract                    003477 constant        entry                    internal dcl 343 ref 230 248 257 260 276
cleanerup                       004107 constant        entry                    internal dcl 597 ref 178 185 328 367 424 503 616
close_switch                    004072 constant        entry                    internal dcl 588 ref 201 208 442 532
compact                         000434 constant        entry                    external dcl 142
extract                         000404 constant        entry                    external dcl 129
extract_compact_common          000453 constant        label                    dcl 147 ref 139 370
make_filename                   003720 constant        entry                    internal dcl 559 in procedure "ta_file_io_" ref 167
                                                                                  192 222 434 447 520 557
make_filename                   003433 constant        entry                    external dcl 552
open_tape_output_file           003611 constant        entry                    internal dcl 536 ref 193 223 435 449 526
returner                        003470 constant        label                    dcl 620 ref 186 617
ta_file_io_                     000362 constant        entry                    external dcl 26

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5304        5374    4730        5314
Length      5764    4730        70         354     353           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ta_file_io_                         744 external procedure  is an external procedure.  
on unit on line 175                  68 on unit               
cant_extract                            internal procedure  shares stack frame of external procedure ta_file_io_.  
on unit on line 421                  68 on unit               
open_tape_output_file                   internal procedure  shares stack frame of external procedure ta_file_io_.  
make_filename                           internal procedure  shares stack frame of external procedure ta_file_io_.  
close_switch                            internal procedure  shares stack frame of external procedure ta_file_io_.  
cleanerup                            78 internal procedure  is called by several nonquick procedures.  
abort                               106 internal procedure  is declared options(non_quick).  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cleanerup                000100 temp_ptr                    cleanerup
ta_file_io_              000100 attribute_file_name         ta_file_io_
                         000105 binary_mode                 ta_file_io_
                         000106 bit_count                   ta_file_io_
                         000107 cancel_deletion             ta_file_io_
                         000110 char_count                  ta_file_io_
                         000111 compacting                  ta_file_io_
                         000112 dirname                     ta_file_io_
                         000164 ename                       ta_file_io_
                         000174 extracting                  ta_file_io_
                         000175 i                           ta_file_io_
                         000176 input_opd                   ta_file_io_
                         000400 j                           ta_file_io_
                         000401 max_chars_in_seg            ta_file_io_
                         000402 msf_fcb_ptr                 ta_file_io_
                         000404 n_chars_read                ta_file_io_
                         000405 n_words_read                ta_file_io_
                         000406 output_atd                  ta_file_io_
                         000610 output_opd                  ta_file_io_
                         001012 readin_ptr                  ta_file_io_
                         001014 seg_ptr                     ta_file_io_
                         001016 temp_file_no                ta_file_io_
                         001020 component_ptr               ta_file_io_
                         001022 request_ptr                 ta_file_io_
                         001032 tablefile_name              ta_file_io_
                         001070 complete_filename           make_filename
                         001075 file_no_picture             make_filename
                         001104 code                        close_switch

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return_mac          tra_ext_1           mdfx1               signal_op           enable_op           shorten_stack
ext_entry           int_entry           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      hcs_$set_bc_seg               hcs_$truncate_seg             ioa_
ioa_$rsnnl                    iox_$attach_ptr               iox_$close                    iox_$detach_iocb
iox_$get_line                 iox_$open                     iox_$open_file                iox_$put_chars
iox_$read_record              iox_$write_record             msf_manager_$close            msf_manager_$get_ptr
msf_manager_$open             ta_filesys_util_$create_attribute_file
ta_filesys_util_$prepare_extraction                         ta_filesys_util_$replace_attributes

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$end_of_info      error_table_$no_file          error_table_$short_record     sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     26 000361        26 000371       129 000377       137 000420       138 000427       139 000431       142 000432
    144 000450       145 000452       147 000453       150 000462       151 000465       152 000476       153 000502
    154 000503       157 000505       158 000506       159 000512       160 000514       162 000516       163 000521
    167 000524       168 000544       171 000607       175 000664       176 000700       178 000713       179 000720
    181 000721       182 000755       185 000762       186 000766       188 000767       190 000773       191 000776
    192 000777       193 001007       196 001013       198 001034       199 001041       201 001047       203 001056
    205 001061       206 001100       208 001106       213 001116       217 001162       218 001216       220 001224
    221 001227       222 001230       223 001251       226 001264       228 001267       229 001273       230 001310
    243 001313       245 001325       246 001327       247 001331       248 001356       249 001363       253 001364
    254 001365       256 001425       257 001455       259 001460       260 001501       266 001504       270 001535
    272 001553       273 001561       275 001607       276 001613       277 001614       278 001620       279 001621
    280 001623       282 001624       286 001630       287 001636       288 001656       289 001663       292 001671
    293 001674       294 001713       297 001721       298 001724       299 001727       300 001733       302 001747
    303 001753       305 001770       306 002023       309 002024       310 002025       314 002034       317 002045
    318 002062       321 002070       325 002072       328 002107       332 002113       333 002116       334 002137
    337 002145       338 002154       340 002161       340 002166       341 002167       375 002176       384 002214
    385 002230       386 002234       387 002236       389 002240       390 002243       396 002246       399 002257
    401 002266       403 002306       408 002317       410 002331       413 002373       418 002377       419 002407
    421 002411       422 002425       424 002440       425 002445       429 002446       432 002476       433 002477
    434 002502       435 002512       439 002516       440 002536       442 002544       446 002554       447 002555
    449 002573       451 002606       452 002615       454 002642       456 002650       457 002665       458 002712
    460 002720       462 002723       463 002742       464 002750       466 002752       467 002755       471 002756
    473 003015       474 003045       476 003053       477 003074       479 003102       481 003110       483 003130
    485 003135       486 003140       488 003154       489 003156       490 003157       491 003160       493 003167
    495 003173       496 003175       497 003214       499 003222       503 003224       504 003230       507 003243
    508 003250       509 003251       511 003260       519 003300       520 003304       522 003324       524 003330
    525 003333       526 003336       528 003352       530 003370       532 003407       534 003417       552 003426
    557 003441       620 003470       343 003477       360 003500       361 003501       363 003551       365 003563
    366 003565       367 003566       368 003572       370 003605       372 003606       373 003610       536 003611
    542 003613       545 003654       546 003711       548 003717       559 003720       567 003722       569 003732
    572 003760       573 003761       575 003775       576 004011       579 004046       580 004051       584 004064
    588 004072       593 004074       595 004105       597 004106       601 004114       603 004123       604 004135
    605 004147       607 004160       608 004167       609 004201       611 004212       613 004213       615 004221
    616 004273       617 004300


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
