	COMPILATION LISTING OF SEGMENT mrds_dsl_func_
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/01/88  1339.3 mst Mon
	    Options: optimize map

        1 /****^  ********************************************
        2*        *                                          *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988 *
        4*        *                                          *
        5*        ******************************************** */
        6 
        7 mrds_dsl_func_:
        8     proc ();
        9 
       10 /* NOTES:
       11*
       12*   This  procedure translates a function reference within a -where clause into
       13*   a  tabular representation easily processed by mrds_dsl_search.  An argument
       14*   list  and  entry  pointer are set up so that the function may be called via
       15*   cu_$gen_call.  Also, assign_ data is supplied to simplify conversions.
       16*
       17*
       18*
       19*   HISTORY:
       20*
       21*   77-06-01 J. A. Weeeldreyer: Initially written.
       22*
       23*   78-02-01  J.   A.   Weeldreyer:  Modified to properly handle expr.  without
       24*   variables.
       25*
       26*   79-02-01 J. A. Weeldreyer: Modified for MR7.0.
       27*
       28*   79-06-27 Al Kepner: Modified to use select_area.
       29*
       30*   80-02-01 Jim Gray : Modified to add area_ptr parameter.
       31*
       32*   80-09-24  Davids:  added  to the code that handles attributes a check to be
       33*   sure  that  the  user has read permission on the attribute, if not the code
       34*   dies  with  an  incorrect  access  error.   also removed declared but never
       35*   referenced variables that did not occur in an include file.
       36*
       37*   80-11-05  Jim Gray : Modified to "and" the mdbm_secured bit with the r_perm
       38*   bit in the attr_info, so that secure_mrds_db turns on this check.
       39*
       40*   81-05-06  Rickie  E.  Brinegar: Modified to use the modified rm_domain_info
       41*   structure.
       42*
       43*   81-06-01 Jim Gray : changed to use new resultant.
       44*
       45*
       46*   81-06-23 Jim Gray : added call to mrds_dsl_get_builtins to get builtin
       47*   scalar function definitions only on an as needed basis.
       48*
       49*   81-07-20 Jim Gray : fixed search loop for scalar function  names,
       50*   so that an unknown function name did not erference through a null
       51*   ptr.
       52*
       53*   83-09-13 R. Harvey : added knowledge of the range structure so that the
       54*   needed_bits could be set. Also removed a / operator from automatic storage
       55*   initialization.
       56*
       57*   84-09-20 Hergert: Made -compiled and .X. illegal tokens in functions.
       58*
       59*   84-11-01 John Hergert: added call to mu_print_error for error reporting.
       60*
       61**/
       62 
       63 /****^  HISTORY COMMENTS:
       64*  1) change(87-01-22,Hergert), approve(88-05-19,MCR7903),
       65*     audit(88-07-05,Dupuis), install(88-08-01,MR12.2-1073):
       66*     For new parser.
       67*                                                   END HISTORY COMMENTS */
       68 
       69 
       70 init:
       71     entry (psi_ptr,dbcb_ptr, fn_name, a_sfi_ptr, a_select_area_ptr, level, code);
       72 
       73 dcl     a_sfi_ptr		 ptr parameter;
       74 
       75         sfi_ptr = a_sfi_ptr;
       76         select_area_ptr = a_select_area_ptr;
       77         done = "0"b;
       78         do while (^done);
       79 	  if sfi_ptr = null ()
       80 	  then done = "1"b;
       81 	  else if fn_name = scalfn_info.name
       82 	       then done = "1"b;
       83 	       else sfi_ptr = scalfn_info.fwd_ptr;
       84         end;
       85 
       86         if sfi_ptr = null
       87         then					/* if didnt find it */
       88 	   call error (mrds_error_$undef_fun, LOUD, 0, WCF_TYPE,
       89 	        "Cannot find the function '" || fn_name || "'.");
       90 
       91         nsf_args_init = mrds_data_$max_sf_args;		/* all ok, alloc. fn. structure */
       92         allocate scalfn in (select_area);		/*  Allocations in select_area are never freed.  This area
       93*						   is reinitialized for each new selection expression. */
       94 
       95         scalfn.nargs = 0;				/* initialize */
       96         scalfn.arg_list_ptr = null;
       97         scalfn.entry_ptr = scalfn_info.entry_ptr;
       98 
       99         if level=1 then allocate sfptrs in (parser_work_area);
      100 
      101         sfn_ptrs (level) = sfn_ptr;
      102         sfi_ptrs (level) = sfi_ptr;
      103 
      104         return;
      105 
      106 build_attribute:
      107     entry (psi_ptr,dbcb_ptr, range_ptr, rel_index, ai_ptr, level, code);
      108 						/* tuple attribute */
      109 
      110 dcl     ai_ptr		 ptr;
      111 dcl     rel_index		 fixed bin;
      112 
      113         sfn_ptr = sfn_ptrs (level);
      114 
      115         if scalfn.nargs >= mrds_data_$max_sf_args
      116         then					/* check for overflow */
      117 	   call error (mrds_error_$max_sf_args, LOUD, 0, WCF_TYPE, "");
      118 
      119         rai_ptr = ai_ptr;
      120         if rm_attr_info.mdbm_secured & ^(rm_attr_info.read_perm)
      121 						/* if you don't have read access to an attribute */
      122         then call error (mdbm_error_$inc_attr_acc, LOUD, 0, AV_TYPE,
      123 	        "You must have read access to use an attribute in a function."
      124 	        );				/* it shouldn't be in a function */
      125         rdi_ptr = rm_attr_info.domain_ptr;
      126 
      127 /* Say this attribute is needed */
      128         range.tup_var (rel_index).needed_bits
      129 	   .attr (rm_attr_info.defn_order) = "1"b;
      130 
      131         li.encd_proc = "0"b;
      132         li.src_ptr,
      133 	   li.srcd_ptr,
      134 	   li.encdd_ptr = null;
      135 
      136         li.litd_ptr = addr (rm_domain_info.user_desc);
      137         li.encd_blen = 0;
      138         call mrds_dsl_make_literal$alloc (dbcb_ptr, addr (li), code);
      139         if code ^= 0 then call error (code, LOUD, 0, WCF_TYPE, "");
      140 
      141         scalfn.nargs = scalfn.nargs + 1;		/* add tuple attr. arg. */
      142         scalfn.arg.type (scalfn.nargs) = DATABASE;
      143         scalfn.arg.must_convert (scalfn.nargs) = "0"b;	/* for now */
      144         scalfn.arg.desc (scalfn.nargs) = li.litd_ptr -> bit36;
      145         scalfn.arg.loc_index (scalfn.nargs) = li.lit_offset;
      146         scalfn.arg.bit_length (scalfn.nargs) = li.lit_blen;
      147         scalfn.arg.ai_ptr (scalfn.nargs) = rai_ptr;
      148         scalfn.arg.ef_ptr (scalfn.nargs) = null;
      149         scalfn.arg.assn_ptr (scalfn.nargs) = li.lit_ptr;
      150 
      151         return;
      152 
      153 build_expr_func:
      154     entry (psi_ptr,dbcb_ptr, efd_ptr, expression, level, code);
      155 
      156 /* Procedure to fill in argument information, fiven the info in ef_data. */
      157 
      158 dcl     expression		 aligned bit (1);
      159 
      160         sfn_ptr = sfn_ptrs (level);
      161 
      162         if scalfn.nargs >= mrds_data_$max_sf_args
      163         then					/* check for overflow */
      164 	   call error (mrds_error_$max_sf_args, LOUD, 0, WCF_TYPE, "");
      165 
      166 
      167         scalfn.nargs = scalfn.nargs + 1;		/* add the argument */
      168 
      169         if expression
      170         then scalfn.arg.type (scalfn.nargs) = EXPR;
      171         else scalfn.arg.type (scalfn.nargs) = SCAL_FUN;
      172 
      173         scalfn.arg.must_convert (scalfn.nargs) = "0"b;
      174         scalfn.arg.desc (scalfn.nargs) = exp_fun_data.descriptor;
      175         scalfn.arg.loc_index (scalfn.nargs) = exp_fun_data.loc_index;
      176         scalfn.arg.bit_length (scalfn.nargs) = exp_fun_data.bit_length;
      177         scalfn.arg.assn_ptr (scalfn.nargs) = exp_fun_data.assn_ptr;
      178         scalfn.arg.ai_ptr (scalfn.nargs) = null;
      179         scalfn.arg.ef_ptr (scalfn.nargs) = exp_fun_data.ef_ptr;
      180 
      181 
      182         return;
      183 
      184 build_literal:
      185     entry (psi_ptr,dbcb_ptr, a_ptr, d_ptr, level, code);
      186 
      187 /* Procedure to add a literal argument to the function structure */
      188 
      189 dcl     (a_ptr, d_ptr)	 ptr;
      190 
      191         sfn_ptr = sfn_ptrs (level);
      192 
      193         if scalfn.nargs >= mrds_data_$max_sf_args
      194         then					/* check for overflow */
      195 	   call error (mrds_error_$max_sf_args, LOUD, 0, WCF_TYPE, "");
      196 
      197         scalfn.nargs = scalfn.nargs + 1;		/* add the literal arg. */
      198         scalfn.arg.type (scalfn.nargs) = LITERAL;
      199         scalfn.arg.must_convert (scalfn.nargs) = "0"b;
      200         scalfn.arg.desc (scalfn.nargs) = d_ptr -> bit36;
      201         scalfn.arg.ai_ptr (scalfn.nargs),
      202 	   scalfn.arg.ef_ptr (scalfn.nargs) = null;
      203         li.src_ptr = a_ptr;				/* get place to put it, and move it in */
      204         li.srcd_ptr,
      205 	   li.litd_ptr = d_ptr;
      206 
      207         li.encd_proc = "0"b;
      208         li.encdd_ptr = null;
      209 
      210         li.encd_blen = 0;
      211         call mrds_dsl_make_literal (dbcb_ptr, addr (li), code);
      212         if code ^= 0 then call error (code, LOUD, 0, WCF_TYPE, "");
      213         scalfn.arg.assn_ptr (scalfn.nargs) = li.lit_ptr;
      214 
      215         return;
      216 
      217 finish:
      218     entry (psi_ptr,dbcb_ptr, a_select_area_ptr, area_ptr, efd_ptr, level, code);
      219 
      220 
      221         select_area_ptr = a_select_area_ptr;
      222         wa_ptr = area_ptr;
      223         sfi_ptr = sfi_ptrs (level);
      224         sfn_ptr = sfn_ptrs (level);
      225         dbcb.possible_op = "0"b;			/* arith. oper. not possible here */
      226 
      227 /* At this point, the entire function arg list has been parsed.  We now finish the
      228*   argument list. */
      229 
      230         if scalfn_info.info_ent_ptr ^= null then do;	/* function accepts variable input */
      231 	  allocate arg_descs in (work_area);
      232 	  do i = 1 to arg_descs.ndescs;		/* fill in descriptors for info entry */
      233 	      arg_descs.desc (i) = scalfn.arg.desc (i);
      234 	  end;
      235 	  call cu_$ptr_call (scalfn_info.info_ent_ptr, ad_ptr,
      236 	       scalfn.rslt_desc);			/* get descriptor for result */
      237 	  if scalfn.rslt_desc = "0"b
      238 	  then call error (mrds_error_$unaccep_fn_args, LOUD, 4, WCF_TYPE,
      239 		  "Could not determine data type of function result.");
      240 	  ad_ptr = null;
      241 	  do i = 1 to scalfn.nargs;
      242 	      scalfn.arg.must_convert (i) = "0"b;	/* no need to convert in this case */
      243 	  end;
      244         end;					/* if function accepts variable input */
      245 
      246         else do;					/* if function accepts fixed args */
      247 	  if scalfn.nargs ^= scalfn_info.nargs
      248 	  then do;
      249 	      call ioa_$rsnnl (
      250 		 "^d argument^[ was^;s were^] supplied, ^d ^[was^;were^] expected.",
      251 		 err_msg, err_msg_len,
      252 		 scalfn.nargs, (scalfn.nargs = 1),
      253 		 scalfn_info.nargs, (scalfn_info.nargs = 1));
      254 	      call error (mrds_error_$unaccep_fn_args, LOUD, 4, WCF_TYPE,
      255 		 err_msg);
      256 	  end;
      257 	  scalfn.rslt_desc = scalfn_info.rslt_desc;	/* get descriptor of result */
      258 	  do i = 1 to scalfn.nargs;			/* check conversion requirements of each arg. */
      259 	      if scalfn_info.arg_desc (i) ^= scalfn.arg.desc (i) then do;
      260 						/* if needs conversion */
      261 		scalfn.arg.must_convert (i) = "1"b;	/* remember to convert */
      262 
      263 		li.encd_proc = "0"b;
      264 		li.src_ptr,			/* make space for converted value */
      265 		     li.srcd_ptr,
      266 		     li.encdd_ptr = null;
      267 
      268 
      269 		li.litd_ptr = addr (scalfn_info.arg_desc (i));
      270 		li.encd_blen = 0;
      271 		call mrds_dsl_make_literal$alloc (dbcb_ptr, addr (li),
      272 		     code);
      273 		if code ^= 0
      274 		then call error (code, LOUD, 4, WCF_TYPE, "");
      275 		scalfn.arg.arg_desc (i) = scalfn_info.arg_desc (i);
      276 						/* required descriptor */
      277 		scalfn.arg.arg_assn_ptr (i) = li.lit_ptr;
      278 	      end;				/* if conversion required */
      279 	      else scalfn.arg.must_convert (i) = "0"b;
      280 	  end;					/* loop through args */
      281         end;					/* if fixed args */
      282 
      283         li.encd_proc = "0"b;
      284         li.src_ptr,					/* save space for result */
      285 	   li.srcd_ptr,
      286 	   li.encdd_ptr = null;
      287 
      288         li.litd_ptr = addr (scalfn.rslt_desc);
      289         li.encd_blen = 0;
      290         call mrds_dsl_make_literal$alloc (dbcb_ptr, addr (li), code);
      291         if code ^= 0 then call error (code, LOUD, 4, WCF_TYPE, "");
      292         exp_fun_data.descriptor = scalfn.rslt_desc;	/* fill in result info */
      293         exp_fun_data.assn_ptr = li.lit_ptr;
      294         exp_fun_data.ef_ptr = sfn_ptr;
      295         exp_fun_data.loc_index = li.lit_offset;
      296         exp_fun_data.bit_length = li.lit_blen;
      297 
      298         nargs = scalfn.nargs + 1;			/* allocate and build arg list for calling function */
      299         num_ptrs = 2 * nargs;
      300         allocate arg_list in (select_area);		/* Allocations in select_area are never freed.  This area
      301*						   is reinitialized for each new selection expression. */
      302         scalfn.arg_list_ptr = al_ptr;
      303         arg_list.arg_count,				/* fill in arg list header */
      304 	   arg_list.desc_count = num_ptrs;
      305         arg_list.code = NORM;
      306         arg_list.pad = 0;
      307         do i = 1 to scalfn.nargs;			/* fill in arg and desc pointers for all input args */
      308 	  if scalfn.arg.must_convert (i) then do;	/* if separate arg pointers */
      309 	      arg_list.arg_des_ptr (i) =
      310 		 set_arg_ptr (scalfn.arg.arg_assn_ptr (i),
      311 		 (scalfn.arg.arg_desc (i)));
      312 	      arg_list.arg_des_ptr (i + nargs) =
      313 		 addr (scalfn.arg.arg_desc (i));
      314 	  end;
      315 	  else do;				/* no separate arg pointers */
      316 	      arg_list.arg_des_ptr (i) =
      317 		 set_arg_ptr (scalfn.arg.assn_ptr (i),
      318 		 (scalfn.arg.desc (i)));
      319 	      arg_list.arg_des_ptr (i + nargs) = addr (scalfn.arg.desc (i));
      320 	  end;
      321         end;					/* loop through input args */
      322         arg_list.arg_des_ptr (nargs) =
      323 	   set_arg_ptr (exp_fun_data.assn_ptr, (exp_fun_data.descriptor));
      324 						/* fill in info for result */
      325         arg_list.arg_des_ptr (2 * nargs) = addr (scalfn.rslt_desc);
      326 
      327         sfn_ptrs (level) = null;
      328         code = 0;					/* give caller good news */
      329         return;
      330 
      331 set_arg_ptr:
      332     proc (a_ptr, a_desc) returns (ptr);
      333 
      334 /* procedure to return a valid arg pointer given an internal pointer, i.e.
      335*   resolves the var. str. problem. */
      336 
      337 dcl     a_ptr		 ptr;
      338 dcl     r_ptr		 ptr;
      339 declare a_desc		 bit (36);
      340 
      341         if addr (a_desc) -> descriptor.type = 20
      342 	   | addr (a_desc) -> descriptor.type = 22
      343         then
      344 	   r_ptr = addrel (a_ptr, 1);
      345         else r_ptr = a_ptr;
      346         return (r_ptr);
      347 
      348     end set_arg_ptr;
      349 
      350 error:
      351     proc (cd, loud, stack_offset, error_type, message);
      352 
      353 dcl     cd		 fixed bin (35);		/* standard error code */
      354 dcl     loud		 bit (1) aligned;		/* OFF => dont print or signal error */
      355 dcl     stack_offset	 fixed bin;		/* offset from ls_top of where token is in lex stack */
      356 dcl     error_type		 char (*);
      357 dcl     message		 char (*);
      358 
      359         se_info_ptr = dbcb.se_info_ptr;
      360 
      361         code = cd;
      362 
      363         se_info.loud = loud;
      364         se_info.error_type = error_type;
      365         se_info.token_start = 0;
      366         se_info.stack_offset = stack_offset;		/* save this for semantics */
      367         se_info.error_msg = message;
      368         se_info.error_info_supplied = "1"b;		/* so no one else handles it */
      369 
      370         goto exit;
      371 
      372     end error;
      373 
  1     1 /* BEGIN mrds_dbcb.incl.pl1 -- jaw, 11/7/78 */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  1     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  1     8*     This entry is being made to cover the change made on 85-07-01 by Thanh
  1     9*     Nguyen. The scopes_changed flag was added to make checking for this
  1    10*     more efficient (mrds error list #137).
  1    11*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
  1    12*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
  1    13*     Add a bit called dont_check_txn_id to indicate whether or not we should
  1    14*     care if multiple txns use the same selection_expression. (mrds #156)
  1    15*  3) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  1    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  1    17*     Added parser_work_area_ptr and mrds_se_info_ptr for new parser.
  1    18*                                                   END HISTORY COMMENTS */
  1    19 
  1    20 
  1    21 /* WARNING
  1    22*          If the dbcb structure is changed then the mrds_data_
  1    23*          item saved_res_version MUST be incremented to invalidate all
  1    24*          existing saved resultants
  1    25**/
  1    26 
  1    27 /* HISTORY :
  1    28*
  1    29*   modified by Jim Gray - - 80-10-24, to add new_select_expr bit for
  1    30*   tid_list management
  1    31*
  1    32*   81-1-9 Jim Gray : added like reference for  ease  in  making  the
  1    33*   phony resultant in mu_database_index, without having the area dcl
  1    34*   included.
  1    35*
  1    36*   81-06-17 Roger Lackey :  added  last_store_rel_name  for  use  by
  1    37*   mrds_dsl_store
  1    38*
  1    39*   81-06-26 Roger Lackey : Added no_optimize and  print_search_order
  1    40*   switches
  1    41*
  1    42*   81-07-06 Jim Gray : added identifier for  the  current  selection
  1    43*   expression,  so  that relation statistics can be updated relative
  1    44*   to number of selection expressions seem. Also  removed  init  for
  1    45*   last_store_rel_name,   as   this   iw   now   properly   done  in
  1    46*   mrds_dsl_init_res.
  1    47*
  1    48*   81-07-17  Roger Lackey : added pred_ptr and unused_ptrs.
  1    49*
  1    50*   82-08-19  Mike Kubicar : added store_vector field.  This is needed
  1    51*   for the conversion to the relation manager.
  1    52*
  1    53*   82-08-23 Davids: added the relmgr_entries and access_costs
  1    54*   substructures so that the entries and costs can change
  1    55*   depending on the type of database that is opened.
  1    56*
  1    57*   82-09-09 Mike Kubicar : added modify_vector field.  This is needed
  1    58*   since modify uses a different vector type (general) than does store.
  1    59*
  1    60*   82-09-20 Davids: changed names of (store modify)_vector to
  1    61*   (store modify)_vector_ptr. Also (delete modify)_tuple_by_id to
  1    62*   (delete modify)_tuples_by_id. added the element cursor_storage_ptr
  1    63*   which should be inited to null and will be set by mu_cursor_manager_$get
  1    64*   during the first call.
  1    65*
  1    66*   82-09-21 Davids: renamed cursor_storage_ptr to cursor_ptrs_storage_ptr
  1    67*   since it deals with the pointers to the cursors and not the cursors
  1    68*   themelves and added the element cursor_storage_area_ptr which points
  1    69*   to the area where the cursors are kept.
  1    70*
  1    71*   82-09-22 Davids: renamed the transact_ctl_seg to transactions_needed.
  1    72*   the transact_ctl_seg always had a value of 0 and really didn't mean
  1    73*   anything.
  1    74*
  1    75*   82-09-22 Mike Kubicar : added create_relation, create_index and
  1    76*   destroy_relation_by_opening to relmgr_entries.  They are needed
  1    77*   by mrds_dsl_define_temp_rel.
  1    78*
  1    79*   82-09-24 Donna Woodka : added  put_tuple to  relmgr_entries. It
  1    80*   is needed by mu_store.
  1    81*
  1    82*   82-11-12 Davids: changed the declaration of the access_costs from fixed
  1    83*   bin to float bin since the values are not integers.
  1    84*
  1    85*   83-02-02 Davids: added the dbc_uid element. This will allow mrds to make
  1    86*   sure that the dbc_ptr still points to the correct segment. Element was 
  1    87*   added to the end of the structure to allow modules that don't use
  1    88*   the element to continue to reference the dbcb structure without recompiling.
  1    89*
  1    90*   83-02-25 Davids: added the concurrency_on and rollback_on elements. These
  1    91*   are needed so that temp rels can be created with the same file attributes
  1    92*   as the permanent relations.
  1    93*
  1    94*   83-05-02 Mike Kubicar : Deleted get_next_search_specification_ptr and
  1    95*   added the resultant_in_pdir bit.
  1    96*
  1    97*   83-05-18 Davids: reduced the number of reserved bits to 14 (from 15) and
  1    98*   added the res_already_made element.
  1    99*
  1   100*   83-05-24 Mike Kubicar : Updated the relation manager calling sequences.
  1   101*
  1   102*   83-08-03 Mike Kubicar : Added the element_id_list_segment_ptr and removed
  1   103*   one of the unused pointers.
  1   104*
  1   105*   83-09-20 Ron Harvey: Added relmgr_entries.get_population.
  1   106*
  1   107*   84-08-27 John Hergert:  Created compiled_se_info_ptr from unused_ptrs(2)
  1   108*   leaving unused_ptrs(1).
  1   109*
  1   110*   85-01-15 Thanh Nguyen:  Added the work_area_ptr and removed the last
  1   111*   unused_ptrs (1).
  1   112*
  1   113*   85-04-12 Thanh Nguyen:  Added user_started_transaction and 
  1   114*   non_shared_to_shared flags.  Also added se_transaction_id and some more
  1   115*   spare ptrs, entries and reserved storages for future enhancement, since
  1   116*   we changed the saved_res_version from rslt0001 to rslt0002.
  1   117*
  1   118*   85-07-01 Thanh Nguyen:  Added scopes_changed flag.  This flag is set by
  1   119*   common routine of mrds_dsl_set_scope, reset by mrds_dsl_optimize and 
  1   120*   mrds_dsl_gen_srch_prog when building of a new search_vars.
  1   121**/
  1   122 
  1   123 
  1   124 /* this structure is based on the {unique_name}.mrds.dbcb segment
  1   125*   that constitutes the non-secure portion of the resultant model that is
  1   126*   created during the opening of a database. it contains variables that
  1   127*   are used during the runtime access of the database, and an area
  1   128*   for evaluation of requests. it points to four other
  1   129*   segments in the resultant model, {unique_name}.mrds.rdbi, the secure
  1   130*   portion of the resultant(see mdbm_rm_db_info.incl.pl1),
  1   131*   {unique_name}.mrds.select, an area for selection expression evaluation,
  1   132*   {unique_name}.mrds.curdat, and {unique_name}.mrds.stadat, two segments
  1   133*   used in the elimination of duplicate tuples during a retrieve.
  1   134*   the dbcb area holds the structure in mdbm_scope_info.incl.pl1
  1   135*   that is used when the database is using the file scope mechanism
  1   136*   for concurrency control over file readying. the segment overlayed via
  1   137*   mrds_dbc.incl.pl1 structure is pointed to and also handles concurrency control,
  1   138*   across database openings. the pointer to this dbcb structure is kept in a table
  1   139*   which associates database indexes(returned from a call to dsl_$open), with particular
  1   140*   opening instances of resultant models. (see mu_database_index routine) */
  1   141 
  1   142      dcl	   1 dbcb		      aligned based (dbcb_ptr), /* DBCB -- non-secure portion */
  1   143 	     2 data	      like dbcb_data,
  1   144 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (dbcb.static_area))));
  1   145 
  1   146      dcl	   dbcb_ptr	      ptr;
  1   147 
  1   148      declare 1 dbcb_data	      based,		/* info part of dbcb, separated out so that
  1   149*						   like references can avoid getting the area declaration */
  1   150 	     2 rdbi_ptr	      ptr,		/* pointer to write protected mdbm_util_ info. */
  1   151 	     2 range_ptr	      ptr,		/*  ptr to range structure, or null */
  1   152 	     2 select_ptr	      ptr,		/* ptr to select list, or null */
  1   153 	     2 sv_ptr	      ptr,		/* pointer to search variables */
  1   154 	     2 so_ptr	      ptr,		/* pointer to search operators */
  1   155 	     2 ti_ptr	      ptr,		/* pointer to tuple info */
  1   156 	     2 lit_ptr	      ptr,		/* pointer to the literal area, or null */
  1   157 	     2 current_ptr	      ptr,		/* ptr to select list resulting from -current clause */
  1   158 	     2 ss_ptr	      ptr,		/* ptr to select sets block if not simple s.e. */
  1   159 	     2 retr_info_ptr      ptr,		/* ptr to retrieve info area */
  1   160 	     2 trel_info_ptr      ptr,		/* ptr to retrieve info area */
  1   161 	     2 sti_ptr	      ptr,		/* pointer to store info */
  1   162 	     2 dbc_ptr	      ptr,		/*  pointer to the data base control segment */
  1   163 	     2 sfi_ptr	      ptr,		/* points to head of scalar function list */
  1   164 	     2 scope_ptr	      ptr,		/* points to array of scope tuples */
  1   165 	     2 select_area_ptr    ptr,		/* ptr to area for current selection expression allocations */
  1   166 	     2 current_data_ptr   ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  1   167*						   for eliminating duplicate tuples. */
  1   168 	     2 static_data_ptr    ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  1   169*						   for eliminating duplicate tuples. */
  1   170 	     2 store_area_ptr     ptr,		/* temp storage area for dsl_$store */
  1   171 	     2 retrieve_area_ptr  ptr,		/* temp storage for dsl_$retrieve */
  1   172 	     2 modify_area_ptr    ptr,		/* temp storage area for dsl_$modify */
  1   173 	     2 delete_area_ptr    ptr,		/* temp storage area for dsl_$delete */
  1   174 	     2 def_temp_rel_area_ptr ptr,		/* temp storage area for dsl_$define_temp_rel */
  1   175 	     2 pred_ptr	      ptr,		/* Pointer to pred_array */
  1   176 	     2 store_vector_ptr   ptr,		/* Vector structure used during store operations */
  1   177 	     2 modify_vector_ptr  ptr,		/* Used during modifies */
  1   178 	     2 element_id_list_segment_ptr ptr,		/* Points to the segment used to hold element_id_list structures */
  1   179                2 compiled_se_info_ptr ptr,                  /* points to the segment containing all info on compiled sexs */
  1   180 	     2 work_area_ptr        ptr,		/* Work area for encode/decode value allocations in mu_retrieve */
  1   181 	     2 se_info_ptr          ptr,                  /* Points to se_info struct. Primarily for error reports */
  1   182 	     2 parser_work_area_ptr ptr,		/*  work area for parser */
  1   183 	     2 reserved_ptrs      (4) ptr,		/* Reserved for future use */
  1   184 	     2 another_flag	      bit (1) unal,		/* on if predicate was -another */
  1   185 	     2 current_flag	      bit (1) unal,		/* on if predicate was -current clause */
  1   186 	     2 dbc_incr	      bit (1) unal,		/* on if dbc open mode has been incremented for this user */
  1   187 	     2 delete_flag	      bit (1) unal,		/* On if search was called from mrds_dsl_sec_delete */
  1   188 	     2 dup_retain	      bit (1) unaligned,	/* On if dup tuples allowed for retrieval */
  1   189 	     2 prev_select	      bit (1) unal,		/* on if prev. select block processed in this s.e. */
  1   190 	     2 possible_op	      bit (1) unal,		/* on of arith op. allowed */
  1   191 	     2 sel_clause	      bit (1) unal,		/* on if currently in select clause */
  1   192 	     2 dsm_sw	      bit (1) unal,		/* on if data base was opened via data submodel */
  1   193 	     2 val_rtrv	      bit (1) unal,		/* if s.e. valid for retrieve */
  1   194 	     2 val_mod	      bit (1) unal,		/* for modify */
  1   195 	     2 val_del	      bit (1) unal,		/* for delete */
  1   196 	     2 val_dtr	      bit (1) unal,		/* for define temp rel */
  1   197 	     2 transactions_needed bit (1) unal,	/* On => transaction must be started or in progress does
  1   198*                                                                     not imply that the database is of type page_file */
  1   199 	     2 open_mode	      bit (3) unal,		/* 0=>unknown, 1=>r, 2=>u, 3=>er, 4=>eu, >4=>bad */
  1   200 	     2 new_select_expr    bit (1) unal,		/* on => starting a new tid list management period */
  1   201 	     2 no_optimize	      bit (1) unal,		/* On => no optimize */
  1   202 	     2 print_search_order bit (1) unal,		/*  On => print the search order */
  1   203 	     2 resultant_in_pdir  bit (1) unal,		/* On => Temp segments are in the process dir */
  1   204 	     2 res_already_made   bit (1) unal,           /* On => resultant has been made based on a saved copy */
  1   205 	     2 user_started_transaction bit (1) unal,     /* On => user already started his own transaction. */
  1   206 	     2 non_shared_to_shared bit (1) unal,         /* On => user changed the scope from non shared to shared
  1   207*						   inside a sequence of -another selection expression. */
  1   208 	     2 scopes_changed     bit (1) unal,           /* On => scopes had been changed by set_scopes or delete_scopes */
  1   209 	     2 dont_check_txn_id  bit (1) unal,           /* On => cpmd needs same selection exp across multiple txns */
  1   210 	     2 reserved	      bit (10) unal,	/* reserved for future use */
  1   211 	     2 nseq_sch	      fixed bin (35),	/* no. tuples located via sequential search */
  1   212 	     2 nind_sch	      fixed bin (35),	/* no. tuples located via index search */
  1   213 	     2 nhash_sch	      fixed bin (35),	/* no. tuples located via hash search */
  1   214 	     2 nlk_sch	      fixed bin (35),	/* no tuples located via link search */
  1   215 	     2 cur_lit_offset     fixed bin (35),	/* current bit offset in literal string */
  1   216 	     2 dbi	      fixed bin (35),	/* database index for this opening */
  1   217 	     2 last_s_e_id_num    fixed bin (35),	/* identifying number for last selection expression seen */
  1   218 	     2 se_transaction_id  bit (36) aligned,       /* transaction id from beginning of select expression */
  1   219 	     2 last_store_rel_name char (32),		/* Name of relation last used  for store */
  1   220 	     2 cursor_ptrs_storage_ptr ptr,		/* pointer to space where cursor ptrs are stored */
  1   221 	     2 cursor_storage_area_ptr ptr,		/* pointer to area where the cursors are kept */
  1   222 	     2 reserved_words     (10) fixed bin (35),	/* Reserved for future use */
  1   223 	     2 relmgr_entries,			/* relation manager entries */
  1   224 	       3 open	      entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  1   225 	       3 close	      entry (bit (36) aligned, fixed bin (35)),
  1   226 	       3 create_cursor    entry (bit (36) aligned, ptr, ptr, fixed bin (35)),
  1   227 	       3 destroy_cursor   entry (ptr, ptr, fixed bin (35)),
  1   228 	       3 set_scope	      entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35)),
  1   229 	       3 delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  1   230 	       3 modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35)),
  1   231 	       3 get_tuple_by_id  entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  1   232 	       3 get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)),
  1   233 	       3 get_tuple_id     entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  1   234 	       3 put_tuple	      entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  1   235 	       3 get_count	      entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  1   236 	       3 get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35)),
  1   237 	       3 get_population   entry (ptr, fixed bin (35), fixed bin (35)),
  1   238 	       3 create_relation  entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)),
  1   239 	       3 create_index     entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35)),
  1   240 	       3 destroy_relation_by_path entry (char (*), char (*), fixed bin (35)),
  1   241 	       3 reserved_entries (5) entry (),
  1   242 	     2 access_costs,			/* access costs for permute */
  1   243 	       3 total_primary_key_cost float bin,
  1   244 	       3 access_cost      float bin,
  1   245 	       3 access_overhead  float bin,
  1   246 	       3 us_access_cost   float bin,
  1   247 	       3 os_access_cost   float bin,
  1   248 	     2 dbc_uid	      bit (36) aligned,	/* uid of the segment containing the dbc structure */
  1   249 	     2 concurrency_on     bit (1) unal,		/* "1"b implies dmfile concurrency is being used */
  1   250 	     2 rollback_on	      bit (1) unal;		/* "1"b iomplies before journaling is to be done */
  1   251 
  1   252 /* END mrds_dbcb.incl.pl1 */
  1   253 
  1   254 
      374 
      375 
  2     1 /* BEGIN INCLUDE FILE  mrds_se_info.incl.pl1 
  2     2*
  2     3*   These contains information relating to the selection expression.
  2     4*
  2     5**/
  2     6 
  2     7 /****^  HISTORY COMMENTS:
  2     8*  1) change(85-08-05,Hergert), approve(88-06-28,MCR7903),
  2     9*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  2    10*     Created for for new parser.
  2    11*                                                   END HISTORY COMMENTS */
  2    12 
  2    13 dcl     1 se_info		 aligned based (se_info_ptr),
  2    14 	2 se_ptr		 ptr,			/* points to the beginning of the selection expression */
  2    15 	2 se_length	 fixed bin,		/* length of the selection expression */
  2    16 	2 se_cursor	 fixed bin,		/* current place in se */
  2    17 	2 flags,
  2    18 	  3 pso_seen	 bit,			/* -pso supplied in se */
  2    19 	  3 no_ot_seen	 bit,			/* -no_ot supplied in se */
  2    20           2 error_report,
  2    21 	  3 error_info_supplied bit aligned,              /* ON -> structure already filled in */
  2    22 	  3 loud             bit aligned,                	/* ON -> call mu_print_error */
  2    23             3 token_start      fixed bin,                   /* position in se where token starts */
  2    24             3 token_length     fixed bin,                   /* length of token in se */
  2    25 	  3 error_code       fixed bin(35),               /* system error code */
  2    26             3 stack_offset     fixed bin,                   /* how far down the token is in the lex stack */
  2    27             3 error_type       char(24),                    /* type of error. ie range, select where... */
  2    28 	  3 error_msg        char(256);         	/* message to explain problem */
  2    29 
  2    30 
  2    31 /* various types of errors. actually the string that is reported in the
  2    32*   error message. */
  2    33 dcl     RC_TYPE		 char (12) internal static
  2    34 			 options (constant) init ("Range Clause");
  2    35 dcl     SE_TYPE		 char (20) internal static
  2    36 			 options (constant)
  2    37 			 init ("Selection Expression");
  2    38 dcl     SC_TYPE		 char (13) internal static
  2    39 			 options (constant)
  2    40 			 init ("Select Clause");
  2    41 dcl     WC_TYPE		 char (12) internal static
  2    42 			 options (constant)
  2    43 			 init ("Where Clause");
  2    44 dcl     WCE_TYPE		 char (23) internal static
  2    45 			 options (constant)
  2    46 			 init ("Where Clause Expression");
  2    47 dcl     WCF_TYPE		 char (21) internal static
  2    48 			 options (constant)
  2    49 			 init ("Where Clause Function");
  2    50 dcl     AV_TYPE		 char (16) internal static
  2    51 			 options (constant)
  2    52 			 init ("Access Violation");
  2    53 dcl     IL_TYPE		 char (14) internal static
  2    54 			 options (constant)
  2    55 			 init ("Internal Logic");
  2    56 
  2    57 /* parser_work_area is used to hold all static data for an invocation
  2    58*   of the parser. parser_static_info holds ptrs to all of these relevant
  2    59*   data and also a ptr back to the area it is allocated in. 
  2    60*   parser_work_area.
  2    61**/
  2    62 
  2    63 dcl parser_work_area aligned area (sys_info$max_seg_size) based (parser_static_info.pwa_ptr);
  2    64 
  2    65 dcl psi_ptr ptr;
  2    66 dcl 1 parser_static_info aligned based (psi_ptr),
  2    67       2 pwa_ptr ptr,
  2    68       2 semantics, /* for mrds_dsl_semantics */
  2    69         3 static_data_ptr ptr,
  2    70       2 expr, /* for mrds_dsl_expr_ */
  2    71         3 data_stacks_ptr ptr,
  2    72       2 func, /* for mrds_dsl_func_ */
  2    73         3 sfptrs_ptr ptr,
  2    74       2 where_clause, /* for mrds_dsl_where_clause_ */
  2    75         3 ns_ptr ptr;
  2    76 
  2    77 
  2    78 /* END INCLUDE FILE  mrds_se_info.incl.pl1 */
      376 
      377 
  3     1 /* BEGIN INCLUDE FILE mrds_exp_fun_data.incl.pl1 -- jaw 5/20/77 */
  3     2 
  3     3 /* HISTORY:
  3     4*
  3     5*   81-06-01 Jim Gray : removed assn len and type entries,
  3     6*   now that mu_convert is being used.
  3     7*
  3     8**/
  3     9 
  3    10 
  3    11 dcl 1 exp_fun_data based (efd_ptr),			/* data for expression or function */
  3    12     2 var_index fixed bin,				/* index of assoc. tuple variable */
  3    13     2 loc_index fixed bin (18),			/* bit offset within literal pool for result */
  3    14     2 bit_length fixed bin (18),			/* bit length of expr. result */
  3    15     2 descriptor bit (36),				/* descriptor of expr. result */
  3    16     2 assn_ptr ptr,					/* pointer to storage location */
  3    17     2 ef_ptr ptr;					/* pointer to expression structure */
  3    18 
  3    19 dcl  efd_ptr ptr;
  3    20 
  3    21 /* END INCLUDE FILE mrds_exp_fun_data.incl.pl1 */
  3    22 
      378 
      379 
  4     1 /* BEGIN INCLUDE FILE mrds_expressions.incl.pl1 -- jaw 2/15/79 */
  4     2 
  4     3 /* HISTORY:
  4     4*
  4     5*   81-06-01 Jim Gray : removed assn len and type elements
  4     6*   since mu_covnert is now being used.
  4     7*
  4     8**/
  4     9 
  4    10 
  4    11 dcl 1 expr aligned based (expr_ptr),			/* internal representation of an expression,
  4    12*						   expression is stored in postfix polish form */
  4    13     2 nitems fixed bin,				/* no. items in expression */
  4    14     2 item (nexp_items_init refer (expr.nitems)),
  4    15       3 type fixed bin (3) unal,			/* 1 => data item
  4    16*						   2 => operator
  4    17*						   3 => scalar function */
  4    18       3 op_code fixed bin (3) unal,			/* 1 => add
  4    19*						   2 => subtract
  4    20*						   3 => multiply
  4    21*						   4 => divide */
  4    22       3 data_type fixed bin (2) unal,			/* 1 => literal
  4    23*						   2 => database */
  4    24       3 reserved bit (25) unal,
  4    25       3 desc bit (36),				/* data descriptor of data item or fun. result */
  4    26       3 loc_index fixed bin (18),			/* location index of data item or fun. result */
  4    27       3 bit_length fixed bin (18),			/* bit length of data item or fun. result */
  4    28       3 assn_ptr ptr,				/* pointer to item storage loc. */
  4    29       3 ai_ptr ptr,					/* to attr info if database item */
  4    30       3 fn_ptr ptr;					/* pointer to function structure if scalar function */
  4    31 
  4    32 dcl  expr_ptr ptr;
  4    33 dcl  nexp_items_init fixed bin;
  4    34 
  4    35 dcl 1 scalfn aligned based (sfn_ptr),			/* internal representation of a scalar function */
  4    36     2 entry_ptr ptr,				/* pointer to entry to be called */
  4    37     2 arg_list_ptr ptr,				/* pointer to arg list to be used for calling function */
  4    38     2 rslt_desc bit (36),				/* descriptor for result */
  4    39     2 nargs fixed bin,				/* number of input args */
  4    40     2 arg (nsf_args_init refer (scalfn.nargs)),		/* arg info */
  4    41       3 type fixed bin (3) unal,			/* 1 => literal
  4    42*						   2 => database
  4    43*						   3 => scalar function
  4    44*						   4 => expression */
  4    45       3 must_convert bit (1) unal,			/* on if arg must be converted to match requirements */
  4    46       3 reserved bit (31) unal,
  4    47       3 desc bit (36),				/* descriptor of data or result */
  4    48       3 loc_index fixed bin (18),			/* location index of data item or result */
  4    49       3 bit_length fixed bin (18),			/* bit length of data item or result */
  4    50       3 assn_ptr ptr,				/* pointer to item storage loc. */
  4    51       3 arg_desc bit (36),				/* descriptor for arg if must convert */
  4    52       3 arg_assn_ptr ptr,				/* assign_ ptr for arg in must convert */
  4    53       3 ai_ptr ptr,					/* to attr info if database item */
  4    54       3 ef_ptr ptr;					/* pointer to expression or function structure, or null */
  4    55 
  4    56 dcl  sfn_ptr ptr;
  4    57 dcl  nsf_args_init fixed bin;
  4    58 
  4    59 dcl ((DATA init (1)),
  4    60     (OPERATOR init (2)),
  4    61     (SCAL_FUN init (3)),
  4    62     (EXPR init (4)),
  4    63     (ADD init (1)),
  4    64     (SUBT init (2)),
  4    65     (MULT init (3)),
  4    66     (DIV init (4)),
  4    67     (LITERAL init (1)),
  4    68     (DATABASE init (2))) fixed bin int static options (constant);
  4    69 
  4    70 dcl  CFLTD59 bit (36) aligned int static options (constant)
  4    71      init ("100110000000000000000000000000111011"b);
  4    72 dcl  RFLTD59 bit (36) aligned int static options (constant)
  4    73      init ("100101000000000000000000000000111011"b);
  4    74 
  4    75 /* END INCLUDE FILE mrds_expressions.incl.pl1 */
  4    76 
      380 
      381 
  5     1 /* BEGIN mdbm_arg_list.incl.pl1 -- jaw 5/31/78 */
  5     2 /* the duplicate mrds_arg_list.incl.pl1 was eliminated by Jim Gray, Nov. 1979 */
  5     3 
  5     4 /* layout of argument list for IDS and DBM entries with options (variable) */
  5     5 
  5     6 dcl 1 arg_list based (al_ptr),
  5     7     2 arg_count fixed bin (17) unal,			/* 2 * no. of args. */
  5     8     2 code fixed bin (17) unal,			/* 4 => normal, 8 => special */
  5     9     2 desc_count fixed bin (17) unal,			/* 2 * no. of descriptors */
  5    10     2 pad fixed bin (17) unal,			/* must be 0 */
  5    11     2 arg_des_ptr (num_ptrs) ptr;			/* argument/descriptor pointer */
  5    12 
  5    13 dcl  al_ptr ptr;
  5    14 dcl  num_ptrs fixed bin;
  5    15 
  5    16 /* END mdbm_arg_list.incl.pl1  */
  5    17 
      382 
      383 
  6     1 /* BEGIN INCLUDE FILE mrds_scalfn_info.incl.pl1 -- jaw 5/3/77 */
  6     2 
  6     3 dcl 1 scalfn_info aligned based (sfi_ptr),		/* info for a scalar function */
  6     4     2 fwd_ptr ptr,					/* pointer to next function in list */
  6     5     2 name char (32),				/* primary name of function */
  6     6     2 info_ent_ptr ptr,				/* pointer to info entry for variable function, or null */
  6     7     2 entry_ptr ptr,				/* pointer to entry to be called */
  6     8     2 rslt_desc bit (36),				/* result descriptor for non_var. funct., or "0"b */
  6     9     2 nargs fixed bin,				/* no. of input args for non-var. funct. or 0 */
  6    10     2 arg_desc (nsfi_args_init refer (scalfn_info.nargs)) bit (36); /* descriptors for each input arg */
  6    11 
  6    12 dcl  sfi_ptr ptr;
  6    13 dcl  nsfi_args_init fixed bin;
  6    14 
  6    15 /* END INCLUDE FILE mrds_scalfn_info.incl.pl1 */
  6    16 
      384 
      385 
  7     1 /* BEGIN mrds_lit_info.incl.pl1 -- jaw, 2/13/79 */
  7     2 
  7     3 /* HISTORY:
  7     4*
  7     5*   81-05-06  Rickie  E.  Brinegar: The declaration encd_ptr ptr was changed to
  7     6*   encd_entry  entry  and encd_proc bit (1) and pad bit (35) were added.  This
  7     7*   was  done  inoder to permit make use of cu_$generate call and eliminate the
  7     8*   use of cv_ptr_ to generate entry pointers.
  7     9*
  7    10*   81-06-01 Jim Gray : removed assn_len and ass_len structure elements,
  7    11*   as these are not used, with the advent of mu_convert.
  7    12*
  7    13**/
  7    14 
  7    15 dcl 1 lit_info aligned based (lip),			/* info for make literal call */
  7    16     2 src_ptr ptr,					/* to literal source data */
  7    17     2 srcd_ptr ptr,					/* to literal source descr. */
  7    18     2 encd_entry entry,				/* to encode proc. entry */
  7    19     2 encd_proc bit (1) unal,				/* does an encode proc exist? */
  7    20     2 pad bit (35) unal,
  7    21     2 encdd_ptr ptr,				/* to descr. for input to encode proc */
  7    22     2 litd_ptr ptr,					/* to descr. to final liter. val. */
  7    23     2 lit_ptr ptr,					/* to final literal value */
  7    24     2 encd_blen fixed bin (35),			/* to bit length for encode proc input */
  7    25     2 lit_blen fixed bin (35),			/* to bit length for final literal */
  7    26     2 lit_offset fixed bin (35);			/* to offset for final literal in lit. pool */
  7    27 
  7    28 dcl  lip ptr;
  7    29 
  7    30 /* END mrds_lit_info.incl.pl1 */
  7    31 
      386 
      387 
  8     1 /*  BEGIN  mdbm_rm_attr_info.incl.pl1  --  jaw,  11/16/78  */
  8     2 
  8     3 /* WARNING
  8     4*          If the rm_attr_info structure is changed then the mrds_data_
  8     5*          item saved_res_version MUST be incremented to invalidate all
  8     6*          existing saved resultants
  8     7**/
  8     8 
  8     9 /*
  8    10*
  8    11*   Modified  by  Jim  Gray - - 80-11-05, to add mdbm_secured bit, so
  8    12*   that rm_rel_info does not have to be checked
  8    13*
  8    14*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
  8    15*   foreign keys.
  8    16*
  8    17*   82-08-19  D. Woodka : removed rm_attr_info.bit_offset for the DMS
  8    18*   conversion.
  8    19*
  8    20*   82-09-15 Davids: added the number_of_dups field.
  8    21*
  8    22*   82-09-20 Mike Kubicar : changed the index_id field to be bit (36)
  8    23*   aligned.  This is to conform with the new definition in the database
  8    24*   model.  Also removed the now useless field varying.
  8    25*
  8    26*   82-11-05 Davids: added the field model_defn_order and clarified the
  8    27*   comment for the field defn_order.
  8    28*
  8    29*   83-05-23 Mike Kubicar : changed number_of_dups to fixed bin (35) since
  8    30*   that's what relation manager returns.
  8    31*
  8    32**/
  8    33 
  8    34 
  8    35 /*
  8    36*   this   structure   is   allocated   in   the   static   area   of
  8    37*   mdbm_rm_db_info.incl.pl1  once for each attribute per relation in
  8    38*   a     readied     file.      it     in     turn     points     to
  8    39*   mdbm_rm_domain_info.incl.pl1  for  the  attributes  domain.   the
  8    40*   rm_attr_info  is  pointed  to  by mdbm_rm_rel_info.incl.pl1.  all
  8    41*   structures  are  in  the  rm_db_info  area.   the  attribute data
  8    42*   position  within  a  tuple as stored in the data file are kept in
  8    43*   this resultant model of the attribute.
  8    44* */
  8    45 
  8    46 dcl 1 rm_attr_info aligned based (rai_ptr),		/* resultant attr. info */
  8    47     2 name char (32),				/* from submodel */
  8    48     2 model_name char (32),				/* from model */
  8    49     2 key_attr bit (1) unal,				/* if key attribute */
  8    50     2 index_attr bit (1) unal,			/* if secondary index */
  8    51     2 read_perm bit (1) unal,				/* user has retr. permission */
  8    52     2 modify_perm bit (1) unal,			/* user has modify permission */
  8    53     2 mdbm_secured bit (1) unal,			/* on => database secured */
  8    54     2 reserved bit (30) unal,				/* for future use */
  8    55     2 index_id bit (36) aligned,			/* index id if index_attr */
  8    56     2 defn_order fixed bin,				/* relative order in which attr is defined in the view */
  8    57     2 key_order fixed bin,				/* relative order defined in prim. key */
  8    58     2 bit_length fixed bin (35),			/* length if fixed, max. len. if var. */
  8    59     2 domain_ptr ptr,				/* to domain info */
  8    60     2 number_of_dups fixed bin (35),                        /* if the attribute is indexed this will
  8    61*                                                               be the number of duplicate values, exact
  8    62*                                                               for a page_file database, an estimate for a vfile type */
  8    63     2 model_defn_order fixed bin;                           /* relative order in which attr is defined in the model */
  8    64 
  8    65 dcl  rai_ptr ptr int automatic init (null ());
  8    66 
  8    67 /* END mdbm_rm_attr_info.incl.pl1 */
  8    68 
  8    69 
      388 
      389 
  9     1 /* BEGIN mdbm_rm_domain_info.incl.pl1 -- jaw, 9/26/78 */
  9     2 
  9     3 /* WARNING
  9     4*          If the rm_domain_info structure is changed then the mrds_data_
  9     5*          item saved_res_version MUST be incremented to invalidate all
  9     6*          existing saved resultants
  9     7**/
  9     8 
  9     9 /* DESCRIPTION:
  9    10*
  9    11*   This  structure  is  allocated  in  the  mdbm_rm_db_info.incl.pl1
  9    12*   static  area,  once per attribute used in a relation in a readied
  9    13*   file. it is pointed to by the mdbm_rm_attr_info.incl.pl1, and may
  9    14*   point  to  mdbm_rm_ck_and_group.incl.pl1  if  a  "-check"  option
  9    15*   boolean expression was declared for this domain. it contains  the
  9    16*   descriptor  for  this domain data type, and other resultant model
  9    17*   information.
  9    18*
  9    19*
  9    20*   HISTORY:
  9    21*
  9    22*   81-05-06  Rickie  E.  Brinegar:  Modified  ck_proc,  encode_proc,
  9    23*   decode_proc to be entry variables instead of entry pointers. This
  9    24*   allows these programs to be written in languages other than pl1.
  9    25*
  9    26*   81-05-28 Jim Gray : removed unused procedure points,  and  unused
  9    27*   check  stack  structure  elements.  Also made the descriptors bit
  9    28*   (36) in this structure, rather than pointers to  the  descriptors
  9    29*   elsewhere.  Also  removed un-needed redundant assign_ parameters,
  9    30*   that are actually available in the descriptors.
  9    31*
  9    32*
  9    33**/
  9    34 
  9    35 dcl 1 rm_domain_info aligned based (rdi_ptr),		/* domain information */
  9    36     2 name char (32),				/* domain name */
  9    37     2 db_desc bit (36),				/*  to desc. for db. */
  9    38     2 user_desc bit (36),				/* desc for user visible data */
  9    39     2 user_bit_len fixed bin,				/* storage length of users data */
  9    40     2 ck_proc_entry entry variable,			/* to check proc. entry */
  9    41     2 encd_proc_entry entry variable,			/* to encode proc entry */
  9    42     2 decd_proc_entry entry variable,			/* to decode proc entry */
  9    43     2 ck_proc bit (1) unal,				/* Is there a check proc */
  9    44     2 encd_proc bit (1) unal,				/* Is there an encode proc */
  9    45     2 decd_proc bit (1) unal,				/* Is there a decode proc */
  9    46     2 pad bit (33) unal,
  9    47     2 next_domain_ptr ptr ;				/* to next domain, in list of all domains */
  9    48 						/* to check stack and groups */
  9    49 
  9    50 
  9    51 dcl  rdi_ptr ptr int automatic init (null ());
  9    52 
  9    53 /* END mdbm_rm_domain_info.incl.pl1 */
  9    54 
  9    55 
      390 
      391 
 10     1 /* BEGIN mrds_range.incl.pl1 -- jaw, 10/20/78 */
 10     2 
 10     3 /* Modified 83-04-22 by R. Harvey to add needed_bits */
 10     4 
 10     5 dcl 1 range aligned based (range_ptr),
 10     6     2 num_vars fixed bin,				/* number of tuple variables */
 10     7     2 tup_var (mrds_data_$max_tup_var refer (range.num_vars)), /* info for each tuple variable */
 10     8       3 name char (mrds_data_$max_id_len),		/* name of tuple variable */
 10     9       3 temp_rel bit (1) unal,			/* on if temporary relation */
 10    10       3 used bit (1) unal,				/* 1 => this tuple variable is referenced by
 10    11*						   a -select clause. */
 10    12       3 whole_tuple_selected bit (1) unal,		/* the whole tuple variable is referenced in the select clause */
 10    13       3 copy_for_current bit (1) unal,			/* -current requests attributes not previously retrieved */
 10    14       3 copied_for_current bit (1) unal,		/* tuple copied during previous -current */
 10    15       3 reserved bit (31) unal,			/* reserved for future use */
 10    16       3 rel_index fixed bin,				/* index to assoc. relation */
 10    17       3 stv_ptr ptr,				/* simple typed vector */
 10    18       3 idl_ptr ptr,				/* id_list ptr */
 10    19       3 needed_bits aligned,
 10    20         4 attr (mrds_data_$max_attributes) bit (1) unal,
 10    21       3 ri_ptr ptr;					/* pointer to rel info for assoc. relation */
 10    22 
 10    23 dcl  range_ptr ptr;
 10    24 
 10    25 /* END mrds_range.incl.pl1 */
 10    26 
      392 
      393 
 11     1 /* BEGIN INCLUDE FILE mrds_select_area.incl.pl1   (Kepner Multics)  05/29/79 1736.1 mst Tue */
 11     2 dcl 1 select_area_struct aligned based (select_area_struct_ptr), /* major structure in segment for current selection expression allocations */
 11     3     2 version fixed bin,
 11     4     2 dbcb_ptr ptr;					/* ptr ptr to dbcb */
 11     5 
 11     6 dcl  select_area_struct_ptr ptr int automatic init (null ());
 11     7 
 11     8 dcl  select_area area (sys_info$max_seg_size - size(model_seg)) based (select_area_ptr);
 11     9 
 11    10 dcl  select_area_ptr ptr int automatic init (null ());
 11    11 						/*   END INCLUDE FILE mrds_select_area.incl.pl1 */
 11    12 
      394 
      395 
 12     1 /* BEGIN INCLUDE FILE mdbm_seg_area.incl.pl1 - - Jim Gray 2/19/79 */
 12     2 
 12     3 /* these structures provide a standard for
 12     4*   1) using an entire segment as an area, managed by the area manager
 12     5*   2) a constant header, that has an offset to the major common structure in the area
 12     6*   the pointer to that structure is obtained via pointer(model_seg_ptr, model_seg.offset)
 12     7*   the model_area_ptr is obtained via pointer(model_seg_ptr, size(model_seg)) */
 12     8 
 12     9 declare 1 model_seg aligned based (model_seg_ptr),	/* segment header, not to be changed */
 12    10         2 struct_offset bit (18),			/* offset to major structure allocated in area */
 12    11         2 padding (3) fixed bin ;			/* to set up four word boundary */
 12    12 
 12    13 declare  model_seg_ptr ptr int automatic init (null ());
 12    14 
 12    15 
 12    16 declare  model_area area (sys_info$max_seg_size - size (model_seg)) based (model_area_ptr) ; /* segment area */
 12    17 
 12    18 declare  model_area_ptr ptr int automatic init (null ());
 12    19 
 12    20 dcl size builtin;
 12    21 
 12    22 /* END INCLUDE FILE mdbm_seg_area.incl.pl1 */
 12    23 
      396 
      397 
 13     1 /* BEGIN mdbm_descriptor.incl.pl1 -- jaw 5/31/78 */
 13     2 /* modified by Jim Gray - - Nov. 1979, to change type from fixed bin(5) to
 13     3*   unsigned fixed bin(6), so new packed decimal data types could be handled.
 13     4*   also the duplicate mrds_descriptor.incl.pl1 was eliminated. */
 13     5 
 13     6 dcl 1 descriptor based (desc_ptr),			/* map of Multics descriptor */
 13     7     2 version bit (1) unal,				/* DBM handles vers. 1 only */
 13     8     2 type unsigned fixed bin (6) unal,			/* data type */
 13     9     2 packed bit (1) unal,				/* on if data item is packed */
 13    10     2 number_dims bit (4) unal,			/* dimensions */
 13    11     2 size,					/* size for string data */
 13    12       3 scale bit (12) unal,				/* scale for num. data */
 13    13       3 precision bit (12) unal,			/* prec. for num. data */
 13    14     2 array_info (num_dims),
 13    15       3 lower_bound fixed bin (35),			/* lower bound of dimension */
 13    16       3 upper_bound fixed bin (35),			/* upper bound of dimension */
 13    17       3 multiplier fixed bin (35);			/*  element separation */
 13    18 
 13    19 dcl  desc_ptr ptr;
 13    20 dcl  num_dims fixed bin init (0) ;			/* more useful form of number_dims */
 13    21 
 13    22 /* END mdbm_descriptor.incl.pl1 */
 13    23 
 13    24 
      398 
      399 
      400 dcl     (
      401         nargs,					/* number of args in arg list */
      402         i						/* internal index */
      403         )			 fixed bin;		/* id of current token */
      404 
      405 dcl     (
      406         wa_ptr,					/* pointer to work area */
      407         ad_ptr,
      408         a_select_area_ptr
      409         )			 ptr;			/* pointer to list of descriptors for info entry */
      410 
      411 dcl     (
      412         code					/* Output:  status code */
      413         )			 fixed bin (35);		/* internal status code */
      414 
      415 dcl     fn_name		 char (*);		/* Input:  name of functions */
      416 
      417 dcl     1 arg_descs		 aligned based (ad_ptr),	/* list of descriptors for fn info entry */
      418 	2 ndescs		 fixed bin,
      419 	2 desc		 (scalfn.nargs refer (arg_descs.ndescs))
      420 			 bit (36);
      421 
      422 dcl     bit36		 bit (36) based;
      423 dcl     work_area		 area (sys_info$max_seg_size) based (wa_ptr);
      424 dcl     1 li		 aligned like lit_info;
      425 
      426 dcl     NORM		 fixed bin (17) int static init (4)
      427 			 options (constant);
      428 
      429 dcl     (
      430         mrds_data_$max_attributes,
      431         mrds_data_$max_expr_stack_size,
      432         mrds_data_$max_id_len,
      433         mrds_data_$max_sf_args,
      434         mrds_error_$max_sf_args,
      435         mrds_error_$undef_fun,
      436         mrds_error_$unaccep_fn_args,
      437         mdbm_error_$inc_attr_acc,
      438         sys_info$max_seg_size
      439         )			 fixed bin (35) ext;
      440 
      441 dcl     (null,
      442         addr,
      443         fixed,
      444         rel,
      445         addrel)		 builtin;
      446 
      447 dcl     cu_$ptr_call	 entry options (variable);
      448 dcl     mrds_dsl_make_literal	 entry (ptr, ptr, fixed bin (35));
      449 dcl     mrds_dsl_make_literal$alloc
      450 			 entry (ptr, ptr, fixed bin (35));
      451 declare done		 bit (1);			/* on => get out of loop */
      452 declare area_ptr		 ptr;
      453 dcl     err_msg		 char (256);
      454 dcl     err_msg_len		 fixed bin;
      455 dcl     level		 fixed bin;
      456 dcl     LOUD		 bit (1) aligned internal static
      457 			 options (constant) init ("1"b);
      458 dcl     se_info_ptr		 ptr;
      459 dcl     1 sfptrs aligned based(parser_static_info.sfptrs_ptr),
      460           2 stack (mrds_data_$max_expr_stack_size),
      461             3 sfn_ptrs ptr,
      462             3 sfi_ptrs ptr;
      463 dcl     ioa_$rsnnl		 entry () options (variable);
      464 exit:
      465     end mrds_dsl_func_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/01/88  1300.0  mrds_dsl_func_.pl1                >special_ldd>install>MR12.2-1073>mrds_dsl_func_.pl1
374          1    08/01/88  1300.0  mrds_dbcb.incl.pl1                >special_ldd>install>MR12.2-1073>mrds_dbcb.incl.pl1
376          2    08/01/88  1300.0  mrds_se_info.incl.pl1             >special_ldd>install>MR12.2-1073>mrds_se_info.incl.pl1
378          3    10/14/83  1608.9  mrds_exp_fun_data.incl.pl1        >ldd>include>mrds_exp_fun_data.incl.pl1
380          4    10/14/83  1608.9  mrds_expressions.incl.pl1         >ldd>include>mrds_expressions.incl.pl1
382          5    10/14/83  1609.0  mdbm_arg_list.incl.pl1            >ldd>include>mdbm_arg_list.incl.pl1
384          6    10/14/83  1608.5  mrds_scalfn_info.incl.pl1         >ldd>include>mrds_scalfn_info.incl.pl1
386          7    10/14/83  1609.1  mrds_lit_info.incl.pl1            >ldd>include>mrds_lit_info.incl.pl1
388          8    10/14/83  1609.1  mdbm_rm_attr_info.incl.pl1        >ldd>include>mdbm_rm_attr_info.incl.pl1
390          9    10/14/83  1609.1  mdbm_rm_domain_info.incl.pl1      >ldd>include>mdbm_rm_domain_info.incl.pl1
392         10    10/14/83  1609.1  mrds_range.incl.pl1               >ldd>include>mrds_range.incl.pl1
394         11    10/14/83  1608.6  mrds_select_area.incl.pl1         >ldd>include>mrds_select_area.incl.pl1
396         12    10/14/83  1608.6  mdbm_seg_area.incl.pl1            >ldd>include>mdbm_seg_area.incl.pl1
398         13    10/14/83  1608.6  mdbm_descriptor.incl.pl1          >ldd>include>mdbm_descriptor.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
AV_TYPE                         000000 constant        char(16)                 initial packed unaligned dcl 2-50 set ref 120*
DATABASE                               constant        fixed bin(17,0)          initial dcl 4-59 ref 142
EXPR                                   constant        fixed bin(17,0)          initial dcl 4-59 ref 169
LITERAL                                constant        fixed bin(17,0)          initial dcl 4-59 ref 198
LOUD                            000023 constant        bit(1)                   initial dcl 456 set ref 86* 115* 120* 139* 162* 193*
                                                                                  212* 237* 254* 273* 291*
NORM                                   constant        fixed bin(17,0)          initial dcl 426 ref 305
SCAL_FUN                               constant        fixed bin(17,0)          initial dcl 4-59 ref 171
WCF_TYPE                        000004 constant        char(21)                 initial packed unaligned dcl 2-47 set ref 86* 115*
                                                                                  139* 162* 193* 212* 237* 254* 273* 291*
a_desc                                 parameter       bit(36)                  packed unaligned dcl 339 set ref 331 341 341
a_ptr                                  parameter       pointer                  dcl 189 in procedure "mrds_dsl_func_" ref 184 203
a_ptr                                  parameter       pointer                  dcl 337 in procedure "set_arg_ptr" ref 331 341 345
a_select_area_ptr                      parameter       pointer                  dcl 405 ref 70 76 217 221
a_sfi_ptr                              parameter       pointer                  dcl 73 ref 70 75
ad_ptr                          000134 automatic       pointer                  dcl 405 set ref 231* 232 233 235* 240*
addr                                                   builtin function         dcl 441 ref 136 138 138 211 211 269 271 271 288 290
                                                                                  290 312 319 325 341 341
addrel                                                 builtin function         dcl 441 ref 341
ai_ptr                   20            based           pointer                  array level 3 in structure "scalfn" dcl 4-35
                                                                                  in procedure "mrds_dsl_func_" set ref 147* 178*
                                                                                  201*
ai_ptr                                 parameter       pointer                  dcl 110 in procedure "mrds_dsl_func_" ref 106 119
al_ptr                          000104 automatic       pointer                  dcl 5-13 set ref 300* 302 303 303 305 306 309 312
                                                                                  316 319 322 325
area_ptr                               parameter       pointer                  dcl 452 ref 217 222
arg                       6            based           structure                array level 2 dcl 4-35
arg_assn_ptr             16            based           pointer                  array level 3 dcl 4-35 set ref 277* 309*
arg_count                              based           fixed bin(17,0)          level 2 packed packed unaligned dcl 5-6 set ref 303*
arg_des_ptr               2            based           pointer                  array level 2 dcl 5-6 set ref 309* 312* 316* 319*
                                                                                  322* 325*
arg_desc                 14            based           bit(36)                  array level 3 in structure "scalfn" dcl 4-35
                                                                                  in procedure "mrds_dsl_func_" set ref 275* 309 312
arg_desc                 20            based           bit(36)                  array level 2 in structure "scalfn_info" dcl 6-3
                                                                                  in procedure "mrds_dsl_func_" set ref 259 269 275
arg_descs                              based           structure                level 1 dcl 417 set ref 231
arg_list                               based           structure                level 1 unaligned dcl 5-6 set ref 300
arg_list_ptr              2            based           pointer                  level 2 dcl 4-35 set ref 96* 302*
assn_ptr                  4            based           pointer                  level 2 in structure "exp_fun_data" dcl 3-11
                                                                                  in procedure "mrds_dsl_func_" set ref 177 293*
                                                                                  322*
assn_ptr                 12            based           pointer                  array level 3 in structure "scalfn" dcl 4-35
                                                                                  in procedure "mrds_dsl_func_" set ref 149* 177*
                                                                                  213* 316*
attr                                   based           bit(1)                   array level 4 packed packed unaligned dcl 10-5 set
                                                                                  ref 128*
bit36                                  based           bit(36)                  packed unaligned dcl 422 ref 144 200
bit_length               11            based           fixed bin(18,0)          array level 3 in structure "scalfn" dcl 4-35
                                                                                  in procedure "mrds_dsl_func_" set ref 146* 176*
bit_length                2            based           fixed bin(18,0)          level 2 in structure "exp_fun_data" dcl 3-11
                                                                                  in procedure "mrds_dsl_func_" set ref 176 296*
cd                                     parameter       fixed bin(35,0)          dcl 353 ref 350 361
code                      0(18)        based           fixed bin(17,0)          level 2 in structure "arg_list" packed packed
                                                                                  unaligned dcl 5-6 in procedure "mrds_dsl_func_"
                                                                                  set ref 305*
code                                   parameter       fixed bin(35,0)          dcl 411 in procedure "mrds_dsl_func_" set ref 70 106
                                                                                  138* 139 139* 153 184 211* 212 212* 217 271* 273
                                                                                  273* 290* 291 291* 328* 361*
cu_$ptr_call                    000030 constant        entry                    external dcl 447 ref 235
d_ptr                                  parameter       pointer                  dcl 189 ref 184 200 204
data                                   based           structure                level 2 dcl 1-142
dbcb                                   based           structure                level 1 dcl 1-142
dbcb_data                              based           structure                level 1 unaligned dcl 1-148
dbcb_ptr                               parameter       pointer                  dcl 1-146 set ref 70 106 138* 153 184 211* 217 225
                                                                                  271* 290* 359
defn_order               22            based           fixed bin(17,0)          level 2 dcl 8-46 ref 128
desc                      1            based           bit(36)                  array level 2 in structure "arg_descs" dcl 417
                                                                                  in procedure "mrds_dsl_func_" set ref 233*
desc                      7            based           bit(36)                  array level 3 in structure "scalfn" dcl 4-35
                                                                                  in procedure "mrds_dsl_func_" set ref 144* 174*
                                                                                  200* 233 259 316 319
desc_count                1            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 5-6 set ref 303*
descriptor                             based           structure                level 1 unaligned dcl 13-6 in procedure
                                                                                  "mrds_dsl_func_"
descriptor                3            based           bit(36)                  level 2 in structure "exp_fun_data" packed packed
                                                                                  unaligned dcl 3-11 in procedure "mrds_dsl_func_"
                                                                                  set ref 174 292* 322
domain_ptr               26            based           pointer                  level 2 dcl 8-46 ref 125
done                            000161 automatic       bit(1)                   packed unaligned dcl 451 set ref 77* 78 79* 81*
ef_ptr                    6            based           pointer                  level 2 in structure "exp_fun_data" dcl 3-11
                                                                                  in procedure "mrds_dsl_func_" set ref 179 294*
ef_ptr                   22            based           pointer                  array level 3 in structure "scalfn" dcl 4-35
                                                                                  in procedure "mrds_dsl_func_" set ref 148* 179*
                                                                                  201*
efd_ptr                                parameter       pointer                  dcl 3-19 ref 153 174 175 176 177 179 217 292 293 294
                                                                                  295 296 322 322
encd_blen                20     000136 automatic       fixed bin(35,0)          level 2 dcl 424 set ref 137* 210* 270* 289*
encd_proc                10     000136 automatic       bit(1)                   level 2 packed packed unaligned dcl 424 set ref 131*
                                                                                  207* 263* 283*
encdd_ptr                12     000136 automatic       pointer                  level 2 dcl 424 set ref 132* 208* 264* 284*
entry_ptr                              based           pointer                  level 2 in structure "scalfn" dcl 4-35 in procedure
                                                                                  "mrds_dsl_func_" set ref 97*
entry_ptr                14            based           pointer                  level 2 in structure "scalfn_info" dcl 6-3
                                                                                  in procedure "mrds_dsl_func_" ref 97
err_msg                         000162 automatic       char(256)                packed unaligned dcl 453 set ref 249* 254*
err_msg_len                     000262 automatic       fixed bin(17,0)          dcl 454 set ref 249*
error_info_supplied       6            based           bit(1)                   level 3 dcl 2-13 set ref 368*
error_msg                22            based           char(256)                level 3 dcl 2-13 set ref 367*
error_report              6            based           structure                level 2 dcl 2-13
error_type               14            based           char(24)                 level 3 in structure "se_info" dcl 2-13 in procedure
                                                                                  "mrds_dsl_func_" set ref 364*
error_type                             parameter       char                     packed unaligned dcl 356 in procedure "error" ref
                                                                                  350 364
exp_fun_data                           based           structure                level 1 unaligned dcl 3-11
expression                             parameter       bit(1)                   dcl 158 ref 153 169
fn_name                                parameter       char                     packed unaligned dcl 415 ref 70 81 86
func                      6            based           structure                level 2 dcl 2-66
fwd_ptr                                based           pointer                  level 2 dcl 6-3 ref 83
i                               000130 automatic       fixed bin(17,0)          dcl 400 set ref 232* 233 233* 241* 242* 258* 259 259
                                                                                  261 269 275 275 277 279* 307* 308 309 309 309 312
                                                                                  312 316 316 316 319 319*
info_ent_ptr             12            based           pointer                  level 2 dcl 6-3 set ref 230 235*
ioa_$rsnnl                      000036 constant        entry                    external dcl 463 ref 249
level                                  parameter       fixed bin(17,0)          dcl 455 ref 70 99 101 102 106 113 153 160 184 191
                                                                                  217 223 224 327
li                              000136 automatic       structure                level 1 dcl 424 set ref 138 138 211 211 271 271 290
                                                                                  290
lit_blen                 21     000136 automatic       fixed bin(35,0)          level 2 dcl 424 set ref 146 296
lit_info                               based           structure                level 1 dcl 7-15
lit_offset               22     000136 automatic       fixed bin(35,0)          level 2 dcl 424 set ref 145 295
lit_ptr                  16     000136 automatic       pointer                  level 2 dcl 424 set ref 149 213 277 293
litd_ptr                 14     000136 automatic       pointer                  level 2 dcl 424 set ref 136* 144 204* 269* 288*
loc_index                 1            based           fixed bin(18,0)          level 2 in structure "exp_fun_data" dcl 3-11
                                                                                  in procedure "mrds_dsl_func_" set ref 175 295*
loc_index                10            based           fixed bin(18,0)          array level 3 in structure "scalfn" dcl 4-35
                                                                                  in procedure "mrds_dsl_func_" set ref 145* 175*
loud                                   parameter       bit(1)                   dcl 354 in procedure "error" ref 350 363
loud                      7            based           bit(1)                   level 3 in structure "se_info" dcl 2-13 in procedure
                                                                                  "mrds_dsl_func_" set ref 363*
mdbm_error_$inc_attr_acc        000026 external static fixed bin(35,0)          dcl 429 set ref 120*
mdbm_secured             20(04)        based           bit(1)                   level 2 packed packed unaligned dcl 8-46 ref 120
message                                parameter       char                     packed unaligned dcl 357 ref 350 367
model_area_ptr                  000124 automatic       pointer                  initial dcl 12-18 set ref 12-18*
model_seg_ptr                   000122 automatic       pointer                  initial dcl 12-13 set ref 12-13*
mrds_data_$max_attributes       000010 external static fixed bin(35,0)          dcl 429 ref 128 128
mrds_data_$max_expr_stack_size  000012 external static fixed bin(35,0)          dcl 429 ref 99
mrds_data_$max_id_len           000014 external static fixed bin(35,0)          dcl 429 ref 128 128 128
mrds_data_$max_sf_args          000016 external static fixed bin(35,0)          dcl 429 ref 91 115 162 193
mrds_dsl_make_literal           000032 constant        entry                    external dcl 448 ref 211
mrds_dsl_make_literal$alloc     000034 constant        entry                    external dcl 449 ref 138 271 290
mrds_error_$max_sf_args         000020 external static fixed bin(35,0)          dcl 429 set ref 115* 162* 193*
mrds_error_$unaccep_fn_args     000024 external static fixed bin(35,0)          dcl 429 set ref 237* 254*
mrds_error_$undef_fun           000022 external static fixed bin(35,0)          dcl 429 set ref 86*
must_convert              6(04)        based           bit(1)                   array level 3 packed packed unaligned dcl 4-35 set
                                                                                  ref 143* 173* 199* 242* 261* 279* 308
name                      2            based           char(32)                 level 2 dcl 6-3 ref 81
nargs                           000127 automatic       fixed bin(17,0)          dcl 400 in procedure "mrds_dsl_func_" set ref 298*
                                                                                  299 312 319 322 325
nargs                     5            based           fixed bin(17,0)          level 2 in structure "scalfn" dcl 4-35 in procedure
                                                                                  "mrds_dsl_func_" set ref 92* 95* 115 141* 141 142
                                                                                  143 144 145 146 147 148 149 162 167* 167 169 171
                                                                                  173 174 175 176 177 178 179 193 197* 197 198 199
                                                                                  200 201 201 213 231 231 241 247 249* 249 258 298
                                                                                  307
nargs                    17            based           fixed bin(17,0)          level 2 in structure "scalfn_info" dcl 6-3
                                                                                  in procedure "mrds_dsl_func_" set ref 247 249* 249
ndescs                                 based           fixed bin(17,0)          level 2 dcl 417 set ref 231* 232
needed_bits                            based           structure                array level 3 dcl 10-5
nsf_args_init                   000102 automatic       fixed bin(17,0)          dcl 4-57 set ref 91* 92 92
null                                                   builtin function         dcl 441 ref 79 86 96 132 148 178 201 208 230 240 264
                                                                                  284 327 8-65 9-51 11-6 11-10 12-13 12-18
num_dims                        000126 automatic       fixed bin(17,0)          initial dcl 13-20 set ref 13-20*
num_ptrs                        000106 automatic       fixed bin(17,0)          dcl 5-14 set ref 299* 300 303
pad                       1(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 5-6 set ref 306*
parser_static_info                     based           structure                level 1 dcl 2-66
parser_work_area                       based           area                     dcl 2-63 ref 99
possible_op             106(06)        based           bit(1)                   level 3 packed packed unaligned dcl 1-142 set ref
                                                                                  225*
psi_ptr                                parameter       pointer                  dcl 2-65 ref 70 99 99 101 102 106 113 153 160 184
                                                                                  191 217 223 224 327
pwa_ptr                                based           pointer                  level 2 dcl 2-66 ref 99
r_ptr                           000310 automatic       pointer                  dcl 338 set ref 341* 345* 346
rai_ptr                         000112 automatic       pointer                  initial dcl 8-65 set ref 119* 120 120 125 128 147
                                                                                  8-65*
range                                  based           structure                level 1 dcl 10-5
range_ptr                              parameter       pointer                  dcl 10-23 ref 106 128
rdi_ptr                         000114 automatic       pointer                  initial dcl 9-51 set ref 125* 136 9-51*
read_perm                20(02)        based           bit(1)                   level 2 packed packed unaligned dcl 8-46 ref 120
rel_index                              parameter       fixed bin(17,0)          dcl 111 ref 106 128
rm_attr_info                           based           structure                level 1 dcl 8-46
rm_domain_info                         based           structure                level 1 dcl 9-35
rslt_desc                 4            based           bit(36)                  level 2 in structure "scalfn" dcl 4-35 in procedure
                                                                                  "mrds_dsl_func_" set ref 235* 237 257* 288 292 325
rslt_desc                16            based           bit(36)                  level 2 in structure "scalfn_info" dcl 6-3
                                                                                  in procedure "mrds_dsl_func_" ref 257
scalfn                                 based           structure                level 1 dcl 4-35 set ref 92
scalfn_info                            based           structure                level 1 dcl 6-3
se_info                                based           structure                level 1 dcl 2-13
se_info_ptr                     000264 automatic       pointer                  dcl 458 in procedure "mrds_dsl_func_" set ref 359*
                                                                                  363 364 365 366 367 368
se_info_ptr              72            based           pointer                  level 3 in structure "dbcb" dcl 1-142 in procedure
                                                                                  "mrds_dsl_func_" ref 359
select_area                            based           area                     dcl 11-8 ref 92 300
select_area_ptr                 000120 automatic       pointer                  initial dcl 11-10 set ref 76* 92 221* 300 11-10*
select_area_struct_ptr          000116 automatic       pointer                  initial dcl 11-6 set ref 11-6*
sfi_ptr                         000110 automatic       pointer                  dcl 6-12 set ref 75* 79 81 83* 83 86 97 102 223* 230
                                                                                  235 247 249 249 257 259 269 275
sfi_ptrs                  2            based           pointer                  array level 3 dcl 459 set ref 102* 223
sfn_ptr                         000100 automatic       pointer                  dcl 4-56 set ref 92* 95 96 97 101 113* 115 141 141
                                                                                  142 142 143 143 144 144 145 145 146 146 147 147
                                                                                  148 148 149 149 160* 162 167 167 169 169 171 171
                                                                                  173 173 174 174 175 175 176 176 177 177 178 178
                                                                                  179 179 191* 193 197 197 198 198 199 199 200 200
                                                                                  201 201 201 201 213 213 224* 231 231 233 235 237
                                                                                  241 242 247 249 249 257 258 259 261 275 277 279
                                                                                  288 292 294 298 302 307 308 309 309 312 316 316
                                                                                  319 325
sfn_ptrs                               based           pointer                  array level 3 dcl 459 set ref 101* 113 160 191 224
                                                                                  327*
sfptrs                                 based           structure                level 1 dcl 459 set ref 99
sfptrs_ptr                6            based           pointer                  level 3 dcl 2-66 set ref 99* 101 102 113 160 191 223
                                                                                  224 327
src_ptr                         000136 automatic       pointer                  level 2 dcl 424 set ref 132* 203* 264* 284*
srcd_ptr                  2     000136 automatic       pointer                  level 2 dcl 424 set ref 132* 204* 264* 284*
stack                                  based           structure                array level 2 dcl 459
stack_offset                           parameter       fixed bin(17,0)          dcl 355 in procedure "error" ref 350 366
stack_offset             13            based           fixed bin(17,0)          level 3 in structure "se_info" dcl 2-13 in procedure
                                                                                  "mrds_dsl_func_" set ref 366*
token_start              10            based           fixed bin(17,0)          level 3 dcl 2-13 set ref 365*
tup_var                   2            based           structure                array level 2 dcl 10-5
type                      0(01)        based           fixed bin(6,0)           level 2 in structure "descriptor" packed packed
                                                                                  unsigned unaligned dcl 13-6 in procedure
                                                                                  "mrds_dsl_func_" ref 341 341
type                      6            based           fixed bin(3,0)           array level 3 in structure "scalfn" packed packed
                                                                                  unaligned dcl 4-35 in procedure "mrds_dsl_func_"
                                                                                  set ref 142* 169* 171* 198*
user_desc                11            based           bit(36)                  level 2 dcl 9-35 set ref 136
wa_ptr                          000132 automatic       pointer                  dcl 405 set ref 222* 231
work_area                              based           area                     dcl 423 ref 231

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ADD                                    internal static fixed bin(17,0)          initial dcl 4-59
CFLTD59                                internal static bit(36)                  initial dcl 4-70
DATA                                   internal static fixed bin(17,0)          initial dcl 4-59
DIV                                    internal static fixed bin(17,0)          initial dcl 4-59
IL_TYPE                                internal static char(14)                 initial packed unaligned dcl 2-53
MULT                                   internal static fixed bin(17,0)          initial dcl 4-59
OPERATOR                               internal static fixed bin(17,0)          initial dcl 4-59
RC_TYPE                                internal static char(12)                 initial packed unaligned dcl 2-33
RFLTD59                                internal static bit(36)                  initial dcl 4-72
SC_TYPE                                internal static char(13)                 initial packed unaligned dcl 2-38
SE_TYPE                                internal static char(20)                 initial packed unaligned dcl 2-35
SUBT                                   internal static fixed bin(17,0)          initial dcl 4-59
WCE_TYPE                               internal static char(23)                 initial packed unaligned dcl 2-44
WC_TYPE                                internal static char(12)                 initial packed unaligned dcl 2-41
desc_ptr                               automatic       pointer                  dcl 13-19
expr                                   based           structure                level 1 dcl 4-11
expr_ptr                               automatic       pointer                  dcl 4-32
fixed                                                  builtin function         dcl 441
lip                                    automatic       pointer                  dcl 7-28
model_area                             based           area                     dcl 12-16
model_seg                              based           structure                level 1 dcl 12-9
nexp_items_init                        automatic       fixed bin(17,0)          dcl 4-33
nsfi_args_init                         automatic       fixed bin(17,0)          dcl 6-13
rel                                                    builtin function         dcl 441
select_area_struct                     based           structure                level 1 dcl 11-2
size                                                   builtin function         dcl 12-20
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 429

NAMES DECLARED BY EXPLICIT CONTEXT.
build_attribute                 000407 constant        entry                    external dcl 106
build_expr_func                 000732 constant        entry                    external dcl 153
build_literal                   001073 constant        entry                    external dcl 184
error                           002266 constant        entry                    internal dcl 350 ref 86 115 120 139 162 193 212 237
                                                                                  254 273 291
exit                            002235 constant        label                    dcl 464 ref 370
finish                          001277 constant        entry                    external dcl 217
init                            000150 constant        entry                    external dcl 70
mrds_dsl_func_                  000133 constant        entry                    external dcl 7
set_arg_ptr                     002236 constant        entry                    internal dcl 331 ref 309 316 322

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2570        2630    2350        2600
Length      3332    2350        40         466     220           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_dsl_func_                      292 external procedure  is an external procedure.  
set_arg_ptr                             internal procedure  shares stack frame of external procedure mrds_dsl_func_.  
error                                66 internal procedure  is called during a stack extension.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mrds_dsl_func_           000100 sfn_ptr                     mrds_dsl_func_
                         000102 nsf_args_init               mrds_dsl_func_
                         000104 al_ptr                      mrds_dsl_func_
                         000106 num_ptrs                    mrds_dsl_func_
                         000110 sfi_ptr                     mrds_dsl_func_
                         000112 rai_ptr                     mrds_dsl_func_
                         000114 rdi_ptr                     mrds_dsl_func_
                         000116 select_area_struct_ptr      mrds_dsl_func_
                         000120 select_area_ptr             mrds_dsl_func_
                         000122 model_seg_ptr               mrds_dsl_func_
                         000124 model_area_ptr              mrds_dsl_func_
                         000126 num_dims                    mrds_dsl_func_
                         000127 nargs                       mrds_dsl_func_
                         000130 i                           mrds_dsl_func_
                         000132 wa_ptr                      mrds_dsl_func_
                         000134 ad_ptr                      mrds_dsl_func_
                         000136 li                          mrds_dsl_func_
                         000161 done                        mrds_dsl_func_
                         000162 err_msg                     mrds_dsl_func_
                         000262 err_msg_len                 mrds_dsl_func_
                         000264 se_info_ptr                 mrds_dsl_func_
                         000310 r_ptr                       set_arg_ptr

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this_desc
return_mac          tra_ext_1           shorten_stack       ext_entry           ext_entry_desc      int_entry_desc
op_alloc_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cu_$ptr_call                  ioa_$rsnnl                    mrds_dsl_make_literal         mrds_dsl_make_literal$alloc

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
mdbm_error_$inc_attr_acc      mrds_data_$max_attributes     mrds_data_$max_expr_stack_size
mrds_data_$max_id_len         mrds_data_$max_sf_args        mrds_error_$max_sf_args       mrds_error_$unaccep_fn_args
mrds_error_$undef_fun




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 8   65 000120    9   51 000122   11    6 000123   11   10 000124   12   13 000125   12   18 000126   13   20 000127
      7 000132        70 000141        75 000173        76 000177        77 000202        78 000203        79 000206
     81 000215        83 000230        84 000232        86 000233        91 000320        92 000324        95 000335
     96 000336        97 000340        99 000343       101 000363       102 000373       104 000400       106 000401
    113 000422       115 000432       119 000467       120 000473       125 000536       128 000541       131 000611
    132 000613       136 000617       137 000621       138 000622       139 000636       141 000671       142 000673
    143 000701       144 000703       145 000710       146 000713       147 000715       148 000717       149 000721
    151 000723       153 000724       160 000747       162 000757       167 001014       169 001016       171 001031
    173 001037       174 001043       175 001047       176 001052       177 001054       178 001056       179 001060
    182 001064       184 001065       191 001106       193 001116       197 001153       198 001155       199 001163
    200 001165       201 001174       203 001177       204 001202       207 001206       208 001210       210 001212
    211 001213       212 001230       213 001263       215 001270       217 001271       221 001316       222 001321
    223 001325       224 001334       225 001336       230 001342       231 001347       232 001361       233 001367
    234 001374       235 001376       237 001420       240 001461       241 001463       242 001473       243 001477
    244 001501       247 001502       249 001505       254 001555       257 001610       258 001614       259 001623
    261 001633       263 001635       264 001637       269 001643       270 001645       271 001646       273 001664
    275 001720       277 001727       278 001731       279 001732       280 001734       283 001736       284 001740
    288 001744       289 001747       290 001750       291 001766       292 002022       293 002027       294 002031
    295 002034       296 002040       298 002042       299 002045       300 002047       302 002056       303 002060
    305 002067       306 002071       307 002073       308 002103       309 002111       312 002130       314 002141
    316 002142       319 002161       321 002172       322 002174       325 002215       327 002222       328 002233
    329 002234       464 002235       331 002236       341 002240       345 002257       346 002262       350 002265
    359 002306       361 002314       363 002317       364 002322       365 002327       366 002330       367 002332
    368 002337       370 002341


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
