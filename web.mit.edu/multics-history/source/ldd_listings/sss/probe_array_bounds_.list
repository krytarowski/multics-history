	COMPILATION LISTING OF SEGMENT probe_array_bounds_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 11/11/88  1547.2 mst Fri
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(88-09-07,WAAnderson), approve(88-09-30,MCR7952),
       16*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
       17*     Added format control comment to make the source more readable.
       18*                                                   END HISTORY COMMENTS */
       19 
       20 
       21 /* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       22 
       23 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       24 
       25 probe_array_bounds_:
       26   proc
       27        (P_probe_info_ptr, P_symbolp, P_reference, P_source_info, P_address,
       28        P_code) returns ((2, 16) fixed bin (24));
       29 
       30   /* given all the inputs abouta reference, return an array filled
       31*   with the upper and lower bounds of all its subscripts - so we
       32*   ca do subscriptrange checking and fill in star extents
       33*
       34*   Initially Coded by James R. Davis 22 Sept 78
       35*   Modified: JRD 31 Oct 78 to return FORTRAN arrays reversed
       36*   */
       37 
       38   dcl (
       39       P_probe_info_ptr	pointer,
       40       P_symbolp		ptr,	/* (input) to runtime_symbol node */
       41       P_address		ptr,	/* (input) for stu_, where symbols storage is */
       42       P_code		fixed bin (35)
       43       )			parameter;/* error code */
       44   dcl 1 P_reference		aligned like reference_node parameter;
       45 				/* (input) info about reference */
       46   dcl 1 P_source_info	aligned like source_info parameter;
       47 				/* (input) where declared; etc */
       48 
       49   dcl array_bounds		(2, 16) fixed bin (24);
       50 				/* what we fill in for caller */
       51   dcl (low, high)		fixed bin (35);
       52   dcl code		fixed bin (35);
       53   dcl dims		fixed bin;/* how many dims ref has */
       54   dcl reverse		bit (1);	/* set to reverse bounds */
       55   dcl father_ptr		ptr;	/* to the runtime_block containing the symbol */
       56   dcl level		fixed bin;/* nesting of this variable */
       57   dcl array_bounds_x	fixed bin;
       58 
       59   dcl probe_et_$bad_value	fixed bin (35) external static;
       60   dcl probe_et_$recorded_message
       61 			fixed bin (35) external static;
       62 
       63   dcl stu_$decode_runtime_value
       64 			entry (fixed bin (35), ptr, ptr, ptr, ptr, ptr,
       65 			fixed bin (35)) returns (fixed bin (35));
       66   dcl probe_error_$record	entry options (variable);
       67   dcl probe_error_$malfunction
       68 			entry options (variable);
       69 
       70   dcl (
       71       LOW			init (1),
       72       HIGH		init (2)
       73       )			fixed bin internal static options (constant);
       74 
       75   dcl (addrel, fixed, hbound) builtin;
       76 				/*  */
       77 
       78   probe_info_ptr = P_probe_info_ptr;
       79   P_code = 0;			/* until we find otherwise */
       80 
       81   dims = fixed (P_symbolp -> runtime_symbol.ndims, 6);
       82   if dims > hbound (array_bounds, 2)	/* PL/I  allows >15 dims, but we dont */
       83     then call probe_error_$malfunction ();
       84 
       85   /* get pointer to the runtime_block that symbol is part of, see if we are FORTRAN */
       86 
       87   level = fixed (P_symbolp -> runtime_symbol.level, 6, 0);
       88   if level <= 1
       89     then father_ptr = addrel (P_symbolp, P_symbolp -> runtime_symbol.father);
       90     else do;
       91       father_ptr = P_symbolp;		/* point at symbol node */
       92       do low = 1 to level;		/* trace back to the block */
       93         father_ptr = addrel (father_ptr, father_ptr -> runtime_symbol.father);
       94       end;
       95     end;
       96   reverse = father_ptr -> runtime_block.fortran;
       97 
       98   do array_bounds_x = 1 to dims;	/* reverse order for FORTRAN */
       99 
      100     low = P_symbolp -> runtime_symbol.bounds (array_bounds_x).lower;
      101     if low < 0 then do;
      102         low = stu_$decode_runtime_value (low,
      103 	   P_source_info.block_ptr, P_source_info.stack_ptr,
      104 	   (P_source_info.seg_info_ptr -> seg_info.linkage_ptr),
      105 	   P_source_info.block_ptr, P_address, code);
      106         if code ^= 0 then do;
      107 	  call probe_error_$record (probe_info_ptr, probe_et_$bad_value,
      108 	       P_reference.name);
      109 	  goto RECORDED_MESSAGE;
      110 	end;
      111       end;
      112 
      113     high = P_symbolp -> runtime_symbol.bounds (array_bounds_x).upper;
      114     if high < 0 then do;
      115         high = stu_$decode_runtime_value (high,
      116 	   P_source_info.block_ptr, P_source_info.stack_ptr,
      117 	   (P_source_info.seg_info_ptr -> seg_info.linkage_ptr),
      118 	   P_source_info.block_ptr, P_address, code);
      119         if code ^= 0 then do;
      120 	  call probe_error_$record (probe_info_ptr, probe_et_$bad_value,
      121 	       P_reference.name);
      122 	  goto RECORDED_MESSAGE;
      123 	end;
      124       end;
      125 
      126     if reverse then do;
      127         array_bounds (LOW, dims - array_bounds_x + 1) = low;
      128         array_bounds (HIGH, dims - array_bounds_x + 1) = high;
      129       end;
      130       else do;
      131         array_bounds (LOW, array_bounds_x) = low;
      132         array_bounds (HIGH, array_bounds_x) = high;
      133       end;
      134 
      135   end;
      136   return (array_bounds);
      137 
      138 
      139 RECORDED_MESSAGE:			/* error exit */
      140   P_code = probe_et_$recorded_message;
      141   array_bounds (*, *) = -1;		/* return useless dimensions */
      142   return (array_bounds);
      143 
      144   /*  */
      145 
  1     1 /*	BEGIN INCLUDE FILE probe_info.incl.pl1		*/
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(88-10-24,WAAnderson), approve(88-10-24,MCR7952),
  1     7*     audit(88-10-24,RWaters), install(88-10-27,MR12.2-1194):
  1     8*     Added field 'retry_using_main' to add new C feature.
  1     9*                                                   END HISTORY COMMENTS */
  1    10 
  1    11 
  1    12 /* Created: 04/22/79 W. Olin Sibert, from subsystem_info	
  1    13*   Modified: 22 Sept 79 JRd to remove: 	default (ptr & (auto|based)) init (null ());
  1    14*   Added flags.setting_break 08/22/83 Steve Herbst
  1    15*   Added flags.executing_quit_request 01/15/85 Steve Herbst
  1    16**/
  1    17 
  1    18 dcl 1 probe_info aligned based (probe_info_ptr),		/* standard data for a probe invocation */
  1    19     2 probe_info_version fixed bin,			/* version of this structure */
  1    20 
  1    21     2 static_info_ptr pointer unaligned,		/* pointer to static information structure */
  1    22     2 modes_ptr pointer unaligned,			/* pointer to probe_modes structure */
  1    23 
  1    24     2 ptr_to_current_source ptr,			/* current_source is based on this */
  1    25     2 ptr_to_initial_source ptr,			/* initial_source is based on this */
  1    26     2 machine_cond_ptr pointer,			/* pointer to machine conditions, if we faulted to get here */
  1    27 
  1    28     2 token_info aligned,				/* information about token chain currently being processed */
  1    29       3 first_token pointer unaligned,			/* first token in chain */
  1    30       3 ct pointer unaligned, 			/* pointer to current token; updated in MANY places */
  1    31       3 end_token bit (18) aligned,			/* token type at which to stop scanning token chain */
  1    32       3 buffer_ptr pointer unaligned,			/* pointer to input buffer */
  1    33       3 buffer_lth fixed bin (21),			/* and length */
  1    34 
  1    35     2 random_info aligned,
  1    36       3 current_stack_frame pointer unaligned,		/* stack frame pointer for frame in which probe was invoked */
  1    37       3 input_type fixed bin, 			/* current input type */
  1    38       3 language_type fixed bin,			/* current language being processed */
  1    39       3 return_method fixed bin,			/* how we should return after exiting probe */
  1    40       3 entry_method fixed bin,			/* how we got here in the first place */
  1    41       3 pad1 (19) bit (36) aligned,
  1    42 
  1    43     2 break_info,					/* break info -- only interesting if we got here via a break */
  1    44       3 break_slot_ptr pointer,			/* pointer to break slot -- non-null IFF at a break */
  1    45       3 last_break_slot_ptr pointer unaligned,		/* pointer to previous break slot, not presently used */
  1    46       3 break_reset bit (1) aligned,			/* this break has been reset by somebody further on */
  1    47       3 real_break_return_loc pointer,			/* where to REALLY return to, modulo previous bit */
  1    48 
  1    49     2 probe_area_info,				/* information about various probe areas */
  1    50       3 break_segment_ptr pointer unaligned,		/* pointer to Personid.probe */
  1    51       3 break_area_ptr pointer unaligned,		/* pointer to area in break segment */
  1    52       3 scratch_area_ptr pointer unaligned,		/* pointer to probe scratch seg in process dir */
  1    53       3 probe_area_ptr pointer unaligned,		/* This area lasts as long as an invocation of probe. */
  1    54       3 work_area_ptr pointer unaligned,		/* This area lasts as long as the current request line */
  1    55       3 expression_area_ptr pointer unaligned,		/* This area lasts as long as the current command */
  1    56 
  1    57     2 flags aligned,				/* this, in particular, should be saved and restored correctly */
  1    58      (3 execute,					/* "1"b => execute requests, "0"b => just check syntax */
  1    59       3 in_listener,				/* ON => in probe listener loop */
  1    60       3 executing_request,				/* ON => executing a request */
  1    61       3 in_interpret_line,				/* executing in probe_listen_$interpret_line */
  1    62       3 setting_break,				/* executing "after" or "before": check syntax of "if" */
  1    63       3 executing_quit_request,			/* to prevent error looping during "quit" request */
  1    64       3 pad (30)) bit (1) unaligned,
  1    65 
  1    66     2 io_switches,					/* switches probe will do normal I/O on */
  1    67       3 input_switch pointer,
  1    68       3 output_switch pointer,
  1    69 
  1    70     2 error_info,					/* information about the last error saved for later printing */
  1    71       3 error_code fixed bin (35),
  1    72       3 error_message char (300) varying,
  1    73 
  1    74     2 listener_info,				/* internal use by probe listener */
  1    75       3 request_name character (32) varying,		/* primary name of the request being processed */
  1    76       3 abort_probe_label label variable,
  1    77       3 abort_line_label label variable,
  1    78       3 depth fixed binary,				/* count of active invocations of probe */
  1    79       3 previous pointer unaligned,			/* -> previous invocation's info */
  1    80       3 next pointer unaligned,
  1    81 
  1    82     2 end_of_probe_info pointer aligned,
  1    83     2 retry_using_main fixed bin aligned;
  1    84    
  1    85 
  1    86 dcl  probe_info_ptr pointer;
  1    87 
  1    88 dcl  probe_info_version fixed bin static options (constant) initial (1);
  1    89 
  1    90 dcl  probe_info_version_1 fixed bin static options (constant) initial (1);
  1    91 
  1    92 dcl  scratch_area area based (probe_info.scratch_area_ptr);
  1    93 dcl  probe_area area based (probe_info.probe_area_ptr);
  1    94 dcl  work_area area based (probe_info.work_area_ptr);
  1    95 dcl  expression_area area based (probe_info.expression_area_ptr);
  1    96 
  1    97 /*	END INCLUDE FILE probe_info.incl.pl1		*/
      146 
      147 
      148   /* ;;;;;;; */
      149 
  2     1 /* BEGIN INCLUDE FILE ... probe_source_info.incl.pl1
  2     2*
  2     3*  James R. Davis 2 July 79 */
  2     4 
  2     5 dcl 1 source_info based aligned,
  2     6       2 stmnt_map_entry_index fixed bin,		/* index in stmnt map for this stmnt */
  2     7       2 instruction_ptr ptr,				/* to last instruction executed  */
  2     8       2 block_ptr ptr,				/* to runtime_block node */
  2     9       2 stack_ptr ptr,				/* to a stack frame */
  2    10       2 entry_ptr ptr,				/* to entry seq. for this proc */
  2    11       2 seg_info_ptr ptr;				/* to seg_info */
  2    12 
  2    13 dcl 1 current_source aligned like source_info based (probe_info.ptr_to_current_source);
  2    14 dcl 1 initial_source aligned like source_info based (probe_info.ptr_to_initial_source);
  2    15 
  2    16 /* END INCLUDE FILE ... probe_source_info.incl.pl1 */
      150 
      151 
      152   /* ;;;;;;; */
      153 
  3     1 /* BEGIN INCLUDE FILE ... probe_seg_info.incl.pl1
  3     2*
  3     3*   25 June 79 JRDavis
  3     4*
  3     5*   Modified  7 April 1983, TO - Add fields for character offset/line
  3     6*	correction per file.
  3     7**/
  3     8 
  3     9 dcl 1 seg_info based aligned,				/* place to remember information about object seg */
  3    10     2 language_type fixed bin,			/* language of source program */
  3    11     2 bits aligned,
  3    12       3 ignore_case bit (1) unal,
  3    13       3 bound_segment bit (1) unaligned,
  3    14       3 component bit (1) unaligned,
  3    15       3 pad bit (33) unal,
  3    16     2 names,					/* where to find it */
  3    17       3 directory_name character (168) unal,		/* what directory */
  3    18       3 entry_name character (32) unal,			/* what segment */
  3    19       3 segname character (32) unal,			/* procedure segname definition */
  3    20     2 identifier fixed bin (71),			/* time of object creation */
  3    21     2 pointers,					/* location of various parts of segment */
  3    22       3 symbol_header_ptr ptr unal,			/* to symbol section */
  3    23       3 original_source_ptr ptr unal,			/* to segment source map */
  3    24       3 statement_map_ptr ptr unal,			/* to segment statement map */
  3    25       3 break_info ptr unal,				/* for unbound segments, and start of chain for
  3    26*						   bound ones, -> break_map !obsolete, I think! */
  3    27       3 chain ptr unal,				/* to entry for next component if bound */
  3    28       3 linkage_ptr ptr unal,				/* to linkage section */
  3    29     2 bounds aligned,				/* structure of bounds information */
  3    30       3 text_bounds,
  3    31         4 start fixed bin (35),
  3    32         4 end fixed bin (35),
  3    33       3 symbol_bounds,
  3    34         4 start fixed bin (35),
  3    35         4 end fixed bin (35),
  3    36     2 map_size fixed bin,				/* size of statement map */
  3    37     2 error_code fixed bin (35),			/* errors encoutered while getting info, are recorded here */
  3    38     2 bound_create_time fixed bin (71),			/* time seg containing was bound or compiled. */
  3    39     2 bound_sym_header ptr unal,			/* to sym. section header for bound seg */
  3    40     2 pad (1) fixed bin (35),
  3    41 
  3    42     2 nfiles fixed bin,
  3    43     2 per_file (seg_info_nfiles refer (seg_info.nfiles)),
  3    44       3 file_pointers ptr unal,
  3    45       3 break_line (0:3) fixed bin (18) unsigned unaligned;
  3    46 
  3    47 dcl  seg_info_nfiles fixed bin;			/* for allocation purposes */
  3    48 
  3    49 
  3    50 /* END INCLUDE FILE ... probe_seg_info.incl.pl1 */
      154 
      155 
      156   /* ;;;;;;; */
      157 
  4     1 /*	BEGIN INCLUDE FILE ... runtime_symbol.incl.pl1 ... Modified 07/79 */
  4     2 
  4     3 dcl	1 runtime_symbol	aligned based,
  4     4 	2 flag		unal bit(1),	/* always "1"b for Version II */
  4     5 	2 use_digit	unal bit(1),	/* if "1"b and units are half words units are really digits */
  4     6 	2 array_units	unal bit(2),
  4     7 	2 units		unal bit(2),	/* addressing units */
  4     8 	2 type		unal bit(6),	/* data type */
  4     9 	2 level		unal bit(6),	/* structure level */
  4    10 	2 ndims		unal bit(6),	/* number of dimensions */
  4    11 	2 bits		unal,
  4    12 	  3 aligned	bit(1),
  4    13 	  3 packed	bit(1),
  4    14 	  3 simple	bit(1),
  4    15 	2 skip		unal bit(1),
  4    16 	2 scale		unal bit(8),	/* arithmetic scale factor */
  4    17 	2 name		unal bit(18),	/* rel ptr to acc name */
  4    18 	2 brother		unal bit(18),	/* rel ptr to brother entry */
  4    19 	2 father		unal bit(18),	/* rel ptr to father entry */
  4    20 	2 son		unal bit(18),	/* rel ptr to son entry */
  4    21 	2 address		unal,
  4    22 	  3 location	bit(18),		/* location in storage class */
  4    23 	  3 class		bit(4),		/* storage class */
  4    24 	  3 next		bit(14),		/* rel ptr to next of same class */
  4    25 	2 size		fixed bin(35),	/* encoded string|arith size */
  4    26 	2 offset		fixed bin(35),	/* encoded offset from address */
  4    27 	2 virtual_org	fixed bin(35),
  4    28 	2 bounds(1),
  4    29 	  3 lower		fixed bin(35),	/* encoded lower bound */
  4    30 	  3 upper		fixed bin(35),	/* encoded upper bound */
  4    31 	  3 multiplier	fixed bin(35);	/* encoded multiplier */
  4    32 
  4    33 dcl	1 runtime_bound	based,
  4    34 	2 lower		fixed bin(35),
  4    35 	2 upper		fixed bin(35),
  4    36 	2 multiplier	fixed bin(35);
  4    37 
  4    38 dcl	1 runtime_block	aligned based,
  4    39 	2 flag		unal bit(1),	/* always "1"b for Version II */
  4    40 	2 quick		unal bit(1),	/* "1"b if quick block */
  4    41 	2 fortran		unal bit(1),	/* "1"b if fortran program */
  4    42 	2 standard	unal bit(1),	/* "1"b if program has std obj segment */
  4    43 	2 owner_flag	unal bit(1),	/* "1"b if block has valid owner field */
  4    44 	2 skip		unal bit(1),
  4    45 	2 type		unal bit(6),	/* = 0 for a block node */
  4    46 	2 number		unal bit(6),	/* begin block number */
  4    47 	2 start		unal bit(18),	/* rel ptr to start of symbols */
  4    48 	2 name		unal bit(18),	/* rel ptr to name of proc */
  4    49 	2 brother		unal bit(18),	/* rel ptr to brother block */
  4    50 	2 father		unal bit(18),	/* rel ptr to father block */
  4    51 	2 son		unal bit(18),	/* rel ptr to son block */
  4    52 	2 map		unal,
  4    53 	  3 first		bit(18),		/* rel ptr to first word of map */
  4    54 	  3 last		bit(18),		/* rel ptr to last word of map */
  4    55 	2 entry_info	unal bit(18),	/* info about entry of quick block */
  4    56 	2 header		unal bit(18),	/* rel ptr to symbol header */
  4    57 	2 chain(4)	unal bit(18),	/* chain(i) is rel ptr to first symbol
  4    58*					   on start list with length >= 2**i */
  4    59 	2 token(0:5)	unal bit(18),	/* token(i) is rel ptr to first token
  4    60*					   on list with length >= 2 ** i */
  4    61 	2 owner		unal bit(18);	/* rel ptr to owner block */
  4    62 
  4    63 dcl	1 runtime_token	aligned based,
  4    64 	2 next		unal bit(18),	/* rel ptr to next token */
  4    65 	2 dcl		unal bit(18),	/* rel ptr to first dcl of this token */
  4    66 	2 name,				/* ACC */
  4    67 	  3 size		unal unsigned fixed bin (9), /* number of chars in token */
  4    68 	  3 string	unal char(n refer(runtime_token.size));
  4    69 
  4    70 dcl	1 encoded_value	aligned based,
  4    71 	2 flag		bit (2) unal,
  4    72 	2 code		bit (4) unal,
  4    73 	2 n1		bit (6) unal,
  4    74 	2 n2		bit (6) unal,
  4    75 	2 n3		bit (18) unal;
  4    76 
  4    77 /*	END INCLUDE FILE ... runtime_symbol.incl.pl1 */
      158 
      159 
      160   /* ;;;;;;; */
      161 
  5     1 /*	BEGIN INCLUDE FILE probe_tokens.incl.pl1	*/
  5     2 /*	Split up into probe_tokens and probe_references, 04/22/79 WOS */
  5     3 
  5     4 dcl 1 token_header aligned based,			/* header information common to all tokens */
  5     5     2 next pointer unaligned,				/* pointer to next token in chain */
  5     6     2 prev pointer unaligned,				/* same for previous token */
  5     7     2 type bit (18) aligned,
  5     8     2 buffer_ptr pointer unaligned,			/* pointer to beginning of input buffer */
  5     9     2 location fixed bin (17) unal,			/* offset in input buffer */
  5    10     2 length fixed bin (17) unal,
  5    11     2 flags aligned,
  5    12      (3 leading_whitespace,				/* there is whitespace before thios token */
  5    13       3 trailing_whitespace) bit (1) unaligned,		/* and same for after */
  5    14       3 pad1 bit (34) unaligned;
  5    15 
  5    16 dcl 1 token aligned based,				/* produced by scan_probe_input_ */
  5    17     2 header aligned like token_header;			/* that's all there is */
  5    18 
  5    19 dcl 1 identifier aligned based,			/* keyword or identifier token */
  5    20     2 header aligned like token_header,
  5    21     2 length fixed bin,				/* length of name */
  5    22     2 name pointer unaligned;				/* to string in buffer containing name */
  5    23 
  5    24 dcl 1 operator aligned based,				/* for punctuation */
  5    25     2 header aligned like token_header;			/* nothing but a header here */
  5    26 
  5    27 dcl 1 constant aligned based,				/* for strings pointers numbers etc */
  5    28     2 header aligned like token_header,
  5    29     2 encoded_precision aligned,			/* encoded precision kludge for assign_ */
  5    30       3 scale fixed bin (17) unaligned,			/* arithmetic scale */
  5    31       3 precision fixed bin (17) unaligned,		/* arithmetic precision or other size */
  5    32     2 scale_and_precision fixed bin (35),		/* An identical copy of the two values above */
  5    33     2 data_type fixed bin,				/* standard data type code + packed bit */
  5    34     2 data_ptr pointer unaligned;
  5    35 
  5    36 
  5    37 dcl (OPERATOR_TYPE init ("100"b),			/* types for above */
  5    38      NAME_TYPE init ("010"b),
  5    39      CONSTANT_TYPE init ("001"b)) bit (18) internal static options (constant);
  5    40 
  5    41 
  5    42 dcl  current_identifier_name				/* Overlays for looking at the current tokens */
  5    43      char (probe_info.ct -> identifier.length) based (probe_info.ct -> identifier.name);
  5    44 dcl 1 current_constant aligned like constant based (probe_info.ct);
  5    45 dcl 1 current_token aligned like token based (probe_info.ct);
  5    46 
  5    47 /*	END INCLUDE FILE probe_tokens.incl.pl1		*/
      162 
      163 
      164   /* ;;;;;;; */
      165 
  6     1 /*	BEGIN INCLUDE FILE probe_references.incl.pl1	*/
  6     2 
  6     3 /****^  HISTORY COMMENTS:
  6     4*  1) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  6     5*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  6     6*     Added new field (c_symbol) for C-Probe support.
  6     7*  2) change(88-10-28,WAAnderson), approve(88-10-28,MCR7952),
  6     8*     audit(88-10-31,RWaters), install(88-11-11,MR12.2-1210):
  6     9*     Added new field (c_sub_c_ptr) for C-Probe_support.
  6    10*                                                   END HISTORY COMMENTS */
  6    11 
  6    12 /*	Split out of probe_tokens, 04/22/79 WOS 	*/
  6    13 /*       modified for probe variables Feb 19 80 JRD         */
  6    14 /*   Modified June 83 JMAthane to add "type_ptr" and "builtin" fields */
  6    15 
  6    16      dcl	   1 reference_node	      aligned based,	/* information about a reference */
  6    17 	     2 symbol_ptr	      pointer aligned,	/* to symbol table entry for reference */
  6    18 	     2 type_ptr	      pointer aligned,	/* to symbol table entry for type (null if none) */
  6    19 	     2 address_ptr	      pointer aligned,	/* to location of variable */
  6    20 	     2 base_addr	      pointer aligned,	/* pointer on which whole symbol is based */
  6    21 	     2 source_info_ptr    pointer aligned,	/* to symbol structure for reference */
  6    22 
  6    23 	     2 name	      char (256) unaligned varying, /* symbol name */
  6    24 
  6    25 	     2 type	      fixed bin (35),	/* data type */
  6    26 	     2 descriptor	      fixed bin (35),	/* type || packed */
  6    27 	     2 precision	      fixed bin (35),	/* scale and precision */
  6    28 	     2 flags,
  6    29 	       3 packed	      bit (1) unal,		/* data is in packed format */
  6    30 	       3 constant	      bit (1) unal,		/* data is really a constant */
  6    31 	       3 cross_section    bit (1) unal,		/* reference is an array cross-section */
  6    32 	       3 function	      bit (1) unal,		/* reference is function value */
  6    33 	       3 octal	      bit (1) unal,		/* indicates that this is the octal bif */
  6    34 	       3 star_extent      bit (1) unal,		/* reference is a star subscript for father */
  6    35 	       3 have_generation  bit (1) unal,		/* this reference has an explicitly specified generation */
  6    36 	       3 pseudo_var	      bit (1) unal,		/* it is ok to assign to it */
  6    37 	       3 probe_variable   bit (1) unal,
  6    38 	       3 path	      bit (1) unal,		/* it's a pathname/virtual entry */
  6    39 	       3 builtin	      bit (1) unal,		/* probe builtinvalue */
  6    40 	       3 c_ptr_to_char    bit (1)  unal,
  6    41                  3 c_sub_c_ptr      bit (1)  unal,
  6    42 	       3 pad2	      bit (23) unal,
  6    43 
  6    44 	     2 optional_info,			/* information which may or may not be present */
  6    45 	       3 argument_list    pointer unaligned,	/* pointer to reference_arg_list */
  6    46 	       3 subscript_ptr    pointer unaligned,	/* pointer to reference_subscripts */
  6    47 	       3 n_arguments      fixed bin,		/* number of arguments in argument list */
  6    48 	       3 n_subscripts     fixed bin,		/* number of subscripts present */
  6    49 
  6    50 	     2 constant_token_ptr pointer unaligned,	/* pointer to constant token if this is a constant */
  6    51 	     2 subscript_refs_ptr pointer unaligned,	/* pointer to array of subscript reference node pointers */
  6    52 	     2 invocation_level   fixed bin,		/* invocation level number ("[-17]") for this reference */
  6    53 	     2 probe_var_info_ptr ptr unal,		/* only if flags.probe_variable */
  6    54                2 c_symbol_ptr  ptr unal,
  6    55 	     2 pad1	      (9) pointer unaligned,
  6    56 	     2 end_of_reference_node pointer aligned;
  6    57 
  6    58 
  6    59      dcl	   1 reference_arg_list   aligned based,	/* argument list; based on reference.argument_list */
  6    60 	     2 number	      fixed bin,		/* number of arguments actually present */
  6    61 	     2 node	      (16) pointer aligned;	/* reference node pointers for each argument */
  6    62 
  6    63 
  6    64      dcl	   1 reference_subscripts aligned based,	/* subscript array; based on reference.subscript_ptr */
  6    65 	     2 number	      fixed bin,		/* number actually present */
  6    66 	     2 value	      (2, 16) fixed bin (24); /* values for lower and upper bound for each */
  6    67 
  6    68 
  6    69      dcl	   1 subscript_reference_ptrs aligned based,	/* array of pointers to subscript reference nodes */
  6    70 	     2 ptr	      (2, 16) pointer aligned;
  6    71 
  6    72 /*	END INCLUDE FILE probe_references.incl.pl1	*/
      166 
      167 
      168   end;				/* probe_array_bounds_ external procedure */
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/11/88  1545.0  probe_array_bounds_.pl1           >spec>install>MR12.2-1210>probe_array_bounds_.pl1
146          1    10/27/88  1339.2  probe_info.incl.pl1               >ldd>include>probe_info.incl.pl1
150          2    11/26/79  1320.6  probe_source_info.incl.pl1        >ldd>include>probe_source_info.incl.pl1
154          3    11/02/83  1845.0  probe_seg_info.incl.pl1           >ldd>include>probe_seg_info.incl.pl1
158          4    11/26/79  1320.6  runtime_symbol.incl.pl1           >ldd>include>runtime_symbol.incl.pl1
162          5    11/26/79  1320.6  probe_tokens.incl.pl1             >ldd>include>probe_tokens.incl.pl1
166          6    11/11/88  1543.8  probe_references.incl.pl1         >spec>install>MR12.2-1210>probe_references.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
HIGH                                   constant        fixed bin(17,0)          initial dcl 70 ref 128 132
LOW                                    constant        fixed bin(17,0)          initial dcl 70 ref 127 131
P_address                              parameter       pointer                  dcl 38 set ref 25 102* 115*
P_code                                 parameter       fixed bin(35,0)          dcl 38 set ref 25 79* 139*
P_probe_info_ptr                       parameter       pointer                  dcl 38 ref 25 78
P_reference                            parameter       structure                level 1 dcl 44 set ref 25
P_source_info                          parameter       structure                level 1 dcl 46 set ref 25
P_symbolp                              parameter       pointer                  dcl 38 ref 25 81 87 88 88 91 100 113
addrel                                                 builtin function         dcl 75 ref 88 93
array_bounds                    000100 automatic       fixed bin(24,0)          array dcl 49 set ref 82 127* 128* 131* 132* 136 141*
                                                                                  142
array_bounds_x                  000151 automatic       fixed bin(17,0)          dcl 57 set ref 98* 100 113 127 128 131 132*
block_ptr                 4            parameter       pointer                  level 2 dcl 46 set ref 102* 102* 115* 115*
bounds                    7            based           structure                array level 2 dcl 4-3
code                            000142 automatic       fixed bin(35,0)          dcl 52 set ref 102* 106 115* 119
constant                               based           structure                level 1 dcl 5-27
dims                            000143 automatic       fixed bin(17,0)          dcl 53 set ref 81* 82 98 127 128
father                    2            based           bit(18)                  level 2 packed packed unaligned dcl 4-3 ref 88 93
father_ptr                      000146 automatic       pointer                  dcl 55 set ref 88* 91* 93* 93 93 96
fixed                                                  builtin function         dcl 75 ref 81 87
fortran                   0(02)        based           bit(1)                   level 2 packed packed unaligned dcl 4-38 ref 96
hbound                                                 builtin function         dcl 75 ref 82
high                            000141 automatic       fixed bin(35,0)          dcl 51 set ref 113* 114 115* 115* 128 132
level                     0(12)        based           bit(6)                   level 2 in structure "runtime_symbol" packed packed
                                                                                  unaligned dcl 4-3 in procedure
                                                                                  "probe_array_bounds_" ref 87
level                           000150 automatic       fixed bin(17,0)          dcl 56 in procedure "probe_array_bounds_" set ref
                                                                                  87* 88 92
linkage_ptr             103            based           pointer                  level 3 packed packed unaligned dcl 3-9 ref 102 115
low                             000140 automatic       fixed bin(35,0)          dcl 51 set ref 92* 100* 101 102* 102* 127 131
lower                     7            based           fixed bin(35,0)          array level 3 dcl 4-3 ref 100
name                     12            parameter       varying char(256)        level 2 dcl 44 set ref 107* 120*
ndims                     0(18)        based           bit(6)                   level 2 packed packed unaligned dcl 4-3 ref 81
pointers                 76            based           structure                level 2 dcl 3-9
probe_error_$malfunction        000020 constant        entry                    external dcl 67 ref 82
probe_error_$record             000016 constant        entry                    external dcl 66 ref 107 120
probe_et_$bad_value             000010 external static fixed bin(35,0)          dcl 59 set ref 107* 120*
probe_et_$recorded_message      000012 external static fixed bin(35,0)          dcl 60 ref 139
probe_info_ptr                  000152 automatic       pointer                  dcl 1-86 set ref 78* 107* 120*
reference_node                         based           structure                level 1 dcl 6-16
reverse                         000144 automatic       bit(1)                   packed unaligned dcl 54 set ref 96* 126
runtime_block                          based           structure                level 1 dcl 4-38
runtime_symbol                         based           structure                level 1 dcl 4-3
seg_info                               based           structure                level 1 dcl 3-9
seg_info_ptr             12            parameter       pointer                  level 2 dcl 46 ref 102 115
source_info                            based           structure                level 1 dcl 2-5
stack_ptr                 6            parameter       pointer                  level 2 dcl 46 set ref 102* 115*
stu_$decode_runtime_value       000014 constant        entry                    external dcl 63 ref 102 115
token                                  based           structure                level 1 dcl 5-16
token_header                           based           structure                level 1 dcl 5-4
upper                    10            based           fixed bin(35,0)          array level 3 dcl 4-3 ref 113

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
CONSTANT_TYPE                          internal static bit(18)                  initial packed unaligned dcl 5-37
NAME_TYPE                              internal static bit(18)                  initial packed unaligned dcl 5-37
OPERATOR_TYPE                          internal static bit(18)                  initial packed unaligned dcl 5-37
current_constant                       based           structure                level 1 dcl 5-44
current_identifier_name                based           char                     packed unaligned dcl 5-42
current_source                         based           structure                level 1 dcl 2-13
current_token                          based           structure                level 1 dcl 5-45
encoded_value                          based           structure                level 1 dcl 4-70
expression_area                        based           area(1024)               dcl 1-95
identifier                             based           structure                level 1 dcl 5-19
initial_source                         based           structure                level 1 dcl 2-14
operator                               based           structure                level 1 dcl 5-24
probe_area                             based           area(1024)               dcl 1-93
probe_info                             based           structure                level 1 dcl 1-18
probe_info_version                     internal static fixed bin(17,0)          initial dcl 1-88
probe_info_version_1                   internal static fixed bin(17,0)          initial dcl 1-90
reference_arg_list                     based           structure                level 1 dcl 6-59
reference_subscripts                   based           structure                level 1 dcl 6-64
runtime_bound                          based           structure                level 1 unaligned dcl 4-33
runtime_token                          based           structure                level 1 dcl 4-63
scratch_area                           based           area(1024)               dcl 1-92
seg_info_nfiles                        automatic       fixed bin(17,0)          dcl 3-47
subscript_reference_ptrs               based           structure                level 1 dcl 6-69
work_area                              based           area(1024)               dcl 1-94

NAMES DECLARED BY EXPLICIT CONTEXT.
RECORDED_MESSAGE                000425 constant        label                    dcl 139 set ref 109 122
probe_array_bounds_             000076 constant        entry                    external dcl 25

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       566         610     465         576
Length      1112     465        22         266     101           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
probe_array_bounds_                 166 external procedure  is an external procedure.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
probe_array_bounds_      000100 array_bounds                probe_array_bounds_
                         000140 low                         probe_array_bounds_
                         000141 high                        probe_array_bounds_
                         000142 code                        probe_array_bounds_
                         000143 dims                        probe_array_bounds_
                         000144 reverse                     probe_array_bounds_
                         000146 father_ptr                  probe_array_bounds_
                         000150 level                       probe_array_bounds_
                         000151 array_bounds_x              probe_array_bounds_
                         000152 probe_info_ptr              probe_array_bounds_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
probe_error_$malfunction      probe_error_$record           stu_$decode_runtime_value

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
probe_et_$bad_value           probe_et_$recorded_message




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     25 000070        78 000103        79 000107        81 000110        82 000115        87 000123        88 000131
     91 000142        92 000144        93 000153        94 000160        96 000165        98 000171       100 000201
    101 000210       102 000211       106 000242       107 000244       109 000267       113 000270       114 000276
    115 000277       119 000330       120 000332       122 000355       126 000356       127 000360       128 000372
    129 000377       131 000400       132 000405       135 000412       136 000414       139 000425       141 000431
    142 000454


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
