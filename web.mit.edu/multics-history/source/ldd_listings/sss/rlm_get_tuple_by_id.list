	COMPILATION LISTING OF SEGMENT rlm_get_tuple_by_id
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 03/05/85  0928.2 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 
        9 /* DESCRIPTION:
       10*
       11*          Gets a tuple or set of tuples identified by a tuple_id or an array
       12*     of tuple_ids (p_element_id_list_ptr).  The tuples returned consist of the
       13*     subset of attributes identified by the attribute id_list (p_id_list_ptr).
       14*     The tuples returned are actually simple_typed_vectors.  The relation and
       15*     record collection from which to get the tuples are identified in the
       16*     supplied relation_cursor.  If the cursor is not a relation_cursor (e.g.,
       17*     is an index_cursor), the call is in error.
       18*     
       19*          Three entries exist: rlm_get_tuple_by_id$single takes a single
       20*     tuple_id and returns a single simple_typed_vector_ptr;
       21*     rlm_get_tuple_by_id$list takes an array of tuple_ids and returns an array
       22*     of simple_typed_vector_ptrs in a typed_vector_list;
       23*     rlm_get_tuple_by_id$array takes an array of tuple_ids and returns a
       24*     typed_vector_array.
       25**/
       26 
       27 /* HISTORY:
       28*Written by Matthew Pierret 05/10/82.
       29*Modified:
       30*09/24/82 by Matthew Pierret:  Changed to check to see if the supplied cursor
       31*            contains the proper record collection id.  Made to use opening
       32*            information (relation_info) via rlm_opening_info$get.
       33*12/21/82 by Matthew Pierret:  Changed to convert dm_error_$record_not_found to 
       34*            dm_error_$no_tuple_id.
       35*01/18/83 by Matthew Pierret:  Changed to use relation_info version 2.
       36*03/01/83 by Matthew Pierret:  Changed to not use relation_info. Use instead
       37*            relation_opening_info.
       38*05/23/83 by Matthew Pierret:  Changed to use relation_cursor. Added 
       39*            ERROR_RETURN routine. Moved p_relation_cursor_ptr (formerly
       40*            p_record_cursor_ptr) to first in all calling sequences.
       41*            Changed calling sequences: moved p_id_list_ptr to immediately
       42*            before p_work_area_ptr. Changed the name of 
       43*            p_attribute_id_list_ptr to simply p_id_list_ptr.
       44*06/24/83 by Lindsey L. Spratt:  Changed to use version 2 of the
       45*            relation_cursor.
       46*04/13/84 by Lee Baldwin:  Changed calling sequences of record_manager_$get_record_by_id
       47*            and $get_records_by_id_list.
       48*05/29/84 by Matthew Pierret:  Changed to use RELATION_HEADER_VERSION_3.
       49*11/02/84 by Stanford S. Cox:  MAIN: Asgn. of tva_ptr to null.
       50*   	  FINISH: Added free of tva.  CV: Added unique var prefixes.
       51**/
       52 
       53 /* format: style2,ind3 */
       54 
       55 rlm_get_tuple_by_id:
       56    proc ();
       57 
       58       return;					/* Not a real entry */
       59 
       60 /* START OF DECLARATIONS */
       61 /* Parameter */
       62 
       63       dcl	    p_element_id_list_ptr  ptr;
       64       dcl	    p_tuple_id	       bit (36) aligned;
       65       dcl	    p_work_area_ptr	       ptr;
       66       dcl	    p_id_list_ptr	       ptr;
       67       dcl	    p_relation_cursor_ptr  ptr;
       68       dcl	    p_simple_typed_vector_ptr
       69 			       ptr;
       70       dcl	    p_typed_vector_list_ptr
       71 			       ptr;
       72       dcl	    p_typed_vector_array_ptr
       73 			       ptr;
       74       dcl	    p_code	       fixed bin (35);
       75 
       76 /* Automatic */
       77 
       78       dcl	    get_single_tuple       bit (1) aligned init ("0"b);
       79       dcl	    get_list_of_tuples     bit (1) aligned init ("0"b);
       80       dcl	    get_array_of_tuples    bit (1) aligned init ("0"b);
       81       dcl	    vector_idx	       fixed bin;
       82       dcl	    record_collection_cursor_ptr
       83 			       ptr init (null);
       84 
       85 /* Based */
       86 /* Builtin */
       87 
       88       dcl	    null		       builtin;
       89 
       90 /* Condition */
       91 
       92       dcl	    cleanup	       condition;
       93 
       94 /* Controlled */
       95 /* Constant */
       96 
       97       dcl	    myname	       init ("rlm_get_tuple_by_id") char (32) varying static options (constant);
       98 
       99 /* Entry */
      100 
      101       dcl	    rlm_opening_info$get   entry (bit (36) aligned, ptr, fixed bin (35));
      102       dcl	    sub_err_	       entry () options (variable);
      103 
      104 /* External */
      105 
      106       dcl	    (
      107 	    dm_error_$record_not_found,
      108 	    dm_error_$tuple_not_found_id
      109 	    )		       ext fixed bin (35);
      110       dcl	    error_table_$unimplemented_version
      111 			       ext fixed bin (35);
      112 
      113 /* END OF DECLARATIONS */
      114 
      115 single:
      116    entry (p_relation_cursor_ptr, p_tuple_id, p_id_list_ptr, p_work_area_ptr, p_simple_typed_vector_ptr, p_code);
      117 
      118       get_single_tuple = "1"b;
      119       goto JOIN;
      120 
      121 
      122 list:
      123    entry (p_relation_cursor_ptr, p_element_id_list_ptr, p_id_list_ptr, p_work_area_ptr, p_typed_vector_list_ptr, p_code);
      124 
      125       get_list_of_tuples = "1"b;
      126       goto JOIN;
      127 
      128 
      129 array:
      130    entry (p_relation_cursor_ptr, p_element_id_list_ptr, p_id_list_ptr, p_work_area_ptr, p_typed_vector_array_ptr, p_code);
      131 
      132       get_array_of_tuples = "1"b;
      133       goto JOIN;
      134 
      135 JOIN:
      136       p_code = 0;
      137       typed_vector_array_ptr = null ();
      138 
      139       relation_cursor_ptr = p_relation_cursor_ptr;
      140       call CHECK_VERSION ("relation_cursor", (relation_cursor.version), (RELATION_CURSOR_VERSION_2));
      141 
      142       call rlm_opening_info$get (relation_cursor.file_opening_id, relation_opening_info_ptr, p_code);
      143       if p_code ^= 0
      144       then return;
      145 
      146       call CHECK_VERSION ("relation_opening_info", (relation_opening_info.version), (RELATION_OPENING_INFO_VERSION_2));
      147 
      148       relation_header_ptr = relation_opening_info.relation_header_ptr;
      149       call CHECK_VERSION ("relation_header", relation_header.version, RELATION_HEADER_VERSION_3);
      150 
      151       on cleanup call FINISH ();
      152 
      153       record_collection_cursor_ptr = SET_RECORD_COLLECTION_CURSOR_PTR ();
      154 
      155 /* if relation_info.flags.protected then call lock_manager_$lock */
      156 
      157       if get_single_tuple
      158       then
      159          do;
      160 	  call record_manager_$get_record_by_id (p_tuple_id, p_id_list_ptr, p_work_area_ptr,
      161 	       record_collection_cursor_ptr, p_simple_typed_vector_ptr, p_code);
      162 	  if p_code ^= 0
      163 	  then if p_code = dm_error_$record_not_found
      164 	       then call ERROR_RETURN (dm_error_$tuple_not_found_id);
      165 	       else call ERROR_RETURN (p_code);
      166          end;
      167       else
      168          do;
      169 	  call record_manager_$get_records_by_id_list (p_element_id_list_ptr, p_id_list_ptr, p_work_area_ptr,
      170 	       record_collection_cursor_ptr, typed_vector_array_ptr, p_code);
      171 	  if p_code ^= 0
      172 	  then if p_code = dm_error_$record_not_found
      173 	       then call ERROR_RETURN (dm_error_$tuple_not_found_id);
      174 	       else call ERROR_RETURN (p_code);
      175 
      176 
      177 	  call CHECK_VERSION_FB ("typed_vector_array", (typed_vector_array.version), (TYPED_VECTOR_ARRAY_VERSION_2));
      178 
      179 	  if get_array_of_tuples
      180 	  then p_typed_vector_array_ptr = typed_vector_array_ptr;
      181 	  else
      182 	     do;
      183 	        typed_vector_list_ptr = p_typed_vector_list_ptr;
      184 	        call CHECK_VERSION_FB ("typed_vector_list", (typed_vector_list.version), (TYPED_VECTOR_LIST_VERSION_1));
      185 
      186 	        typed_vector_list.number_of_vectors =
      187 		   min (typed_vector_list.maximum_number_of_vectors, typed_vector_array.number_of_vectors);
      188 
      189 	        do vector_idx = 1 to typed_vector_list.number_of_vectors;
      190 		 typed_vector_list.vector_ptr (vector_idx) = typed_vector_array.vector_slot (vector_idx);
      191 	        end;
      192 
      193 	        p_typed_vector_list_ptr = typed_vector_list_ptr;
      194 	     end;
      195 
      196          end;
      197 
      198 RETURN:
      199       return;
      200 
      201 ERROR_RETURN:
      202    proc (er_code);
      203 
      204       dcl	    er_code	       fixed bin (35);
      205 
      206       p_code = er_code;
      207       goto RETURN;
      208 
      209    end ERROR_RETURN;
      210 
      211 FINISH:
      212    proc ();
      213 
      214       if typed_vector_array_ptr ^= null ()
      215       then free typed_vector_array;
      216       if record_collection_cursor_ptr ^= null & record_collection_cursor_ptr ^= relation_cursor.current.cursor_ptr
      217       then call record_manager_$destroy_cursor (record_collection_cursor_ptr, (0));
      218 
      219    end FINISH;
      220 
      221 CHECK_VERSION:
      222    proc (cv_p_structure_name, cv_p_received_version, cv_p_expected_version);
      223 
      224       dcl	    cv_p_received_version  char (8) aligned;
      225       dcl	    cv_p_expected_version  char (8) aligned;
      226       dcl	    cv_p_structure_name    char (*);
      227 
      228       if cv_p_received_version ^= cv_p_expected_version
      229       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      230 	      "^/Expected version ^8a of the ^a structure.
      231 Received version ^8a, instead.", cv_p_expected_version, cv_p_structure_name, cv_p_received_version);
      232 
      233    end CHECK_VERSION;
      234 
      235 
      236 CHECK_VERSION_FB:
      237    proc (cvf_p_structure_name, cvf_p_received_version, cvf_p_expected_version);
      238 
      239       dcl	    cvf_p_received_version fixed bin (35);
      240       dcl	    cvf_p_expected_version fixed bin (35);
      241       dcl	    cvf_p_structure_name   char (*);
      242 
      243       if cvf_p_received_version ^= cvf_p_expected_version
      244       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      245 	      "^/Expected version ^d of the ^a structure.
      246 Received version ^d, instead.", cvf_p_expected_version, cvf_p_structure_name, cvf_p_received_version);
      247 
      248    end CHECK_VERSION_FB;
      249 
      250 SET_RECORD_COLLECTION_CURSOR_PTR:
      251    proc () returns (ptr);
      252 
      253       dcl	    srccp_record_collection_cursor_ptr
      254 			       ptr init (null);
      255       dcl	    srccp_code	       fixed bin (35) init (0);
      256 
      257       if relation_cursor.flags.current_state_is_consistent
      258 	 & relation_cursor.current.collection_id = relation_header.record_collection_id
      259       then srccp_record_collection_cursor_ptr = relation_cursor.current.cursor_ptr;
      260       else
      261          do;
      262 	  call record_manager_$create_cursor (relation_cursor.file_opening_id, relation_header.record_collection_id,
      263 	       relation_cursor.work_area_ptr, srccp_record_collection_cursor_ptr, srccp_code);
      264 	  if srccp_code ^= 0
      265 	  then call ERROR_RETURN (srccp_code);
      266          end;
      267 
      268       return (srccp_record_collection_cursor_ptr);
      269 
      270    end SET_RECORD_COLLECTION_CURSOR_PTR;
      271 
  1     1 /* BEGIN INCLUDE FILE - dm_rlm_opening_info.incl.pl1 */
  1     2 
  1     3 /* Written by Matthew Pierret, 09/08/82. 
  1     4*Modified:
  1     5*01/18/83 by Matthew Pierret:  Changed version to be char (8). Added 
  1     6*            transaction_id.
  1     7*02/25/83 by Matthew Pierret:  Changed to relation_opening_info (from
  1     8*            relation_info).
  1     9*10/29/84 by Stanford S. Cox:  Changed to not init version.
  1    10**/
  1    11 
  1    12 
  1    13 /* format: style2,ind3 */
  1    14 
  1    15      dcl	   1 relation_opening_info
  1    16 			      aligned based (relation_opening_info_ptr),
  1    17 	     2 version	      char (8),
  1    18 	     2 per_process,
  1    19 	       3 current_transaction_id
  1    20 			      bit (36) aligned init ("0"b),
  1    21 	       3 current_rollback_count
  1    22 			      fixed bin (35) init (0),
  1    23 	       3 file_opening_id  bit (36) aligned init ("0"b),
  1    24 	       3 number_of_openings
  1    25 			      fixed bin (17) aligned init (0),
  1    26 	       3 lock_advice      aligned,
  1    27 	         4 this_process   bit (2) unaligned init ("0"b),
  1    28 	         4 other_processes
  1    29 			      bit (2) unaligned init ("0"b),
  1    30 	         4 mbz1	      bit (32) unaligned init ("0"b),
  1    31 	       3 record_cursor_ptr
  1    32 			      ptr init (null),
  1    33 	       3 index_cursor_array_ptr
  1    34 			      ptr init (null),
  1    35 	     2 relation_header_ptr
  1    36 			      ptr init (null),
  1    37 	     2 attribute_info_ptr ptr init (null),
  1    38 	     2 index_attribute_map_ptr
  1    39 			      ptr init (null);
  1    40 
  1    41      dcl	   relation_opening_info_ptr
  1    42 			      ptr;
  1    43      dcl	   RELATION_OPENING_INFO_VERSION_2
  1    44 			      init ("rlmopen2") char (8) aligned internal static options (constant);
  1    45 
  1    46 
  1    47 /* END INCLUDE FILE - dm_rlm_opening_info.incl.pl1 */
      272 
      273 
  2     1 /* BEGIN INCLUDE FILE - dm_rlm_header.incl.pl1 */
  2     2 
  2     3 /* HISTORY:
  2     4*Written by Matthew Pierret, 1982.
  2     5*Modified:
  2     6*02/25/83 by Matthew Pierret: Added attribute_info_element_id, 
  2     7*            header_info_update_count, RELATION_HEADER_VERSION_2.
  2     8*05/29/84 by Matthew Pierret: Added caller_header_element_id, 
  2     9*            RELATION_HEADER_VERSION_3.
  2    10*10/29/84 by Stanford S. Cox:  Changed to not init version.
  2    11**/
  2    12 
  2    13 /* format: style2,ind3 */
  2    14 
  2    15      dcl	   1 relation_header      aligned based (relation_header_ptr),
  2    16 	     2 version	      char (8),
  2    17 	     2 header_info_update_count
  2    18 			      fixed bin (35) aligned init (0),
  2    19 	     2 record_collection_id
  2    20 			      bit (36) aligned init ("0"b),
  2    21 	     2 cluster_index_id   bit (36) aligned init ("0"b),
  2    22 	     2 attribute_info_element_id
  2    23 			      bit (36) aligned init ("0"b),
  2    24 	     2 index_attribute_map_element_id
  2    25 			      bit (36) aligned init ("0"b),
  2    26 	     2 caller_header_element_id
  2    27 			      bit (36) aligned init ("0"b);
  2    28 
  2    29      dcl	   relation_header_ptr    ptr init (null);
  2    30      dcl	   RELATION_HEADER_VERSION_3
  2    31 			      init ("RelHdr 3") char (8) aligned internal static options (constant);
  2    32 
  2    33 /* END INCLUDE FILE - dm_rlm_header.incl.pl1 */
      274 
      275 
  3     1 /* BEGIN INCLUDE FILE dm_rlm_attribute_info.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION
  3     4*        
  3     5*   Relation attributes descriptor and name.  This info is kept in the header
  3     6*   collection of existing files, therefore this incl should not be changed.
  3     7**/
  3     8 
  3     9 /* HISTORY:
  3    10*Written by Matthew Pierret, 02/25/83.
  3    11*Modified:
  3    12*10/29/84 by Stanford S. Cox:  Changed to not init version.
  3    13*12/14/84 by Stanford S. Cox:  Backed out previous structure alignment changes
  3    14*   which were incompatible with existing DM files.        
  3    15**/
  3    16 
  3    17 /* format: style2,ind3 */
  3    18      dcl	   1 attribute_info	      aligned based (attribute_info_ptr),
  3    19 	     2 version	      char (8),
  3    20 	     2 number_of_attributes
  3    21 			      fixed bin (17) unal,
  3    22 	     2 maximum_attribute_name_length
  3    23 			      fixed bin (17) unal,
  3    24 	     2 attribute	      (ai_number_of_attributes refer (attribute_info.number_of_attributes)),
  3    25 	       3 descriptor	      bit (36) aligned,
  3    26 	       3 name	      char (ai_maximum_attribute_name_length
  3    27 			      refer (attribute_info.maximum_attribute_name_length)) varying;
  3    28 
  3    29      dcl	   attribute_info_ptr     ptr init (null);
  3    30      dcl	   ai_maximum_attribute_name_length
  3    31 			      fixed bin (17);
  3    32      dcl	   ai_number_of_attributes
  3    33 			      fixed bin (17);
  3    34      dcl	   ATTRIBUTE_INFO_VERSION_1
  3    35 			      init ("attrinf1") char (8) aligned internal static options (constant);
  3    36 
  3    37 /* END INCLUDE FILE dm_rlm_attribute_info.incl.pl1 */
  3    38 
      276 
      277 
  4     1 /* BEGIN INCLUDE FILE - dm_rlm_index_attr_map.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION
  4     4*        
  4     5*   Relation index components.  This info is kept in the header
  4     6*   collection of existing files, therefore this incl should not be changed.
  4     7**/
  4     8 
  4     9 /* HISTORY:
  4    10*Written by Matthew Pierret, 01/15/83.
  4    11*Modified:
  4    12*10/29/84 by Stanford S. Cox: Changed to not init version.
  4    13*12/14/84 by Stanford S. Cox:  Backed out previous structure alignment changes
  4    14*   which were incompatible with existing DM files.        
  4    15**/
  4    16 
  4    17 /* format: style2,ind3 */
  4    18      dcl	   1 index_attribute_map  aligned based (index_attribute_map_ptr),
  4    19 	     2 version	      char (8),
  4    20 	     2 number_of_indices  fixed bin (17) unal init (0),
  4    21 	     2 maximum_number_of_indices
  4    22 			      fixed bin (17) unal,
  4    23 	     2 maximum_number_of_attributes_per_index
  4    24 			      fixed bin (17) unal,
  4    25 	     2 mbz	      fixed bin (17) unal,
  4    26 	     2 index	      (iam_maximum_number_of_indices refer (index_attribute_map.maximum_number_of_indices)),
  4    27 	       3 collection_id    bit (36) aligned,
  4    28 	       3 style	      fixed bin (17) unal,
  4    29 	       3 number_of_duplication_fields
  4    30 			      fixed bin (17) unal,
  4    31 	       3 number_of_attributes
  4    32 			      fixed bin (17) unal,
  4    33 	       3 attribute_id     (iam_maximum_number_of_attributes_per_index
  4    34 			      refer (index_attribute_map.maximum_number_of_attributes_per_index)) fixed
  4    35 			      bin (17) unal;
  4    36 
  4    37      dcl	   index_attribute_map_ptr
  4    38 			      ptr init (null);
  4    39      dcl	   iam_maximum_number_of_indices
  4    40 			      fixed bin (17);
  4    41      dcl	   iam_maximum_number_of_attributes_per_index
  4    42 			      fixed bin (17);
  4    43      dcl	   INDEX_ATTRIBUTE_MAP_VERSION_2
  4    44 			      init ("idx_map2") char (8) aligned internal static options (constant);
  4    45      dcl	   INITIAL_NUMBER_OF_INDICES
  4    46 			      init (5) fixed bin (17);
  4    47      dcl	   UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY
  4    48 			      init (0) fixed bin (17);
  4    49 
  4    50 /* END INCLUDE FILE - dm_rlm_index_attr_map.incl.pl1 */
      278 
      279 
  5     1 /* ***********************************************************
  5     2*   *                                                         *
  5     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
  5     4*   *                                                         *
  5     5*   *********************************************************** */
  5     6 /* BEGIN INCLUDE FILE - vu_typed_vector.incl.pl1 */
  5     7 
  5     8 /* Written by Lindsey Spratt, 04/02/82.
  5     9*Modified:
  5    10*09/01/82 by Lindsey Spratt:  Changed value_ptr in simple_typed_vector to be
  5    11*	  unaligned.  Changed the type number of the simple_typed_vector to
  5    12*	  "3" from "1".  The OLD_SIMPLE_TYPED_VECTOR_TYPE is now an invalid
  5    13*	  type.
  5    14**/
  5    15 
  5    16 /* format: style2,ind3 */
  5    17      dcl	   1 simple_typed_vector  based (simple_typed_vector_ptr),
  5    18 	     2 type	      fixed bin (17) unal,
  5    19 	     2 number_of_dimensions
  5    20 			      fixed bin (17) unal,
  5    21 	     2 dimension	      (stv_number_of_dimensions refer (simple_typed_vector.number_of_dimensions)),
  5    22 	       3 value_ptr	      ptr unaligned;
  5    23 
  5    24      dcl	   1 general_typed_vector based (general_typed_vector_ptr),
  5    25 	     2 type	      fixed bin (17) unal,
  5    26 	     2 number_of_dimensions
  5    27 			      fixed bin (17) unal,
  5    28 	     2 dimension	      (gtv_number_of_dimensions refer (general_typed_vector.number_of_dimensions)),
  5    29 	       3 identifier	      fixed bin (17) unal,
  5    30 	       3 pad	      bit (18) unal,
  5    31 	       3 value_ptr	      ptr unal;
  5    32 
  5    33      dcl	   simple_typed_vector_ptr
  5    34 			      ptr;
  5    35      dcl	   stv_number_of_dimensions
  5    36 			      fixed bin (17);
  5    37 
  5    38      dcl	   general_typed_vector_ptr
  5    39 			      ptr;
  5    40      dcl	   gtv_number_of_dimensions
  5    41 			      fixed bin (17);
  5    42 
  5    43      dcl	   (
  5    44 	   OLD_SIMPLE_TYPED_VECTOR_TYPE
  5    45 			      init (1),		/* value_ptr was aligned. */
  5    46 	   GENERAL_TYPED_VECTOR_TYPE
  5    47 			      init (2),
  5    48 	   SIMPLE_TYPED_VECTOR_TYPE
  5    49 			      init (3)
  5    50 	   )		      fixed bin (17) internal static options (constant);
  5    51 
  5    52 /* END INCLUDE FILE - vu_typed_vector.incl.pl1 */
      280 
      281 
  6     1 /* ***********************************************************
  6     2*   *                                                         *
  6     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
  6     4*   *                                                         *
  6     5*   *********************************************************** */
  6     6 /* BEGIN INCLUDE FILE vu_typed_vector_array.incl.pl1 */
  6     7 
  6     8 /* Written by Lindsey Spratt, 03/04/82.
  6     9*Modified:
  6    10*06/23/82 by Lindsey Spratt: Changed to version 2.  The cv entry declarations
  6    11*	  were altered.  cv_to_typed now takes ptr to the descriptor, ptr to
  6    12*	  the print_vector value (char varying), ptr to the typed_vector
  6    13*	  value location, and a code. cv_to_print now takes ptr to the
  6    14*	  descriptor, ptr to the typed_vector value, the print_vector value
  6    15*	  (char(*) varying), the maximum allowed length for the print_vector
  6    16*	  value, a temp_seg to put the value in if its to big to fit into
  6    17*	  the print_vector, and a code.
  6    18**/
  6    19 
  6    20 /* format: style2,ind3 */
  6    21      dcl	   1 typed_vector_array   based (typed_vector_array_ptr) aligned,
  6    22 	     2 version	      fixed bin (35),
  6    23 	     2 number_of_dimensions
  6    24 			      fixed bin (17),
  6    25 	     2 number_of_vectors  fixed bin (17),
  6    26 	     2 number_of_vector_slots
  6    27 			      fixed bin (17),
  6    28 	     2 maximum_dimension_name_length
  6    29 			      fixed bin (17),
  6    30 	     2 dimension_table    (tva_number_of_dimensions refer (typed_vector_array.number_of_dimensions)),
  6    31 	       3 name	      char (tva_maximum_dimension_name_length
  6    32 			      refer (typed_vector_array.maximum_dimension_name_length)) varying,
  6    33 	       3 descriptor_ptr   ptr,		/* call cv_to_print (descriptor_ptr, typed_value_ptr, */
  6    34 						/* temp_seg_ptr, max_length_for_print_value, */
  6    35 						/* print_value, code) */
  6    36 	       3 cv_to_print      entry (ptr, ptr, ptr, fixed bin (35), char (*) varying, fixed bin (35)),
  6    37 						/* call cv_to_typed (descriptor_ptr, area_ptr, */
  6    38 						/* print_value_ptr, typed_value_ptr, code) */
  6    39 	       3 cv_to_typed      entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  6    40 	     2 vector_slot	      (tva_number_of_vector_slots refer (typed_vector_array.number_of_vector_slots))
  6    41 			      pointer;
  6    42 
  6    43      dcl	   typed_vector_array_ptr ptr;
  6    44      dcl	   tva_number_of_vector_slots
  6    45 			      fixed bin;
  6    46      dcl	   tva_number_of_dimensions
  6    47 			      fixed bin;
  6    48      dcl	   tva_maximum_dimension_name_length
  6    49 			      fixed bin;
  6    50      dcl	   TYPED_VECTOR_ARRAY_VERSION_2
  6    51 			      fixed bin (35) int static options (constant) init (2);
  6    52 
  6    53 /* END INCLUDE FILE vu_typed_vector_array.incl.pl1 */
      282 
      283 
  7     1 /*  BEGIN INCLUDE	dm_typed_vector_list.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  7     2 
  7     3 /* Written by R. Harvey, 09/24/82 
  7     4*Modified:
  7     5*09/27/82 by Matthew Pierret:  Changed "max" to "maximum", tvl_number_of_vectors
  7     6*            to tvl_maximum_number_of_vectors.
  7     7**/
  7     8 
  7     9 /* format: style2,ind3 */
  7    10      dcl	   1 typed_vector_list    aligned based (typed_vector_list_ptr),
  7    11 	     2 version	      fixed bin (17),
  7    12 	     2 maximum_number_of_vectors
  7    13 			      fixed bin (35),	/* vectors available */
  7    14 	     2 number_of_vectors  fixed bin (35),	/* number of vector_ptrs used */
  7    15 	     2 pad	      fixed bin (35),	/* (even word boundary) */
  7    16 	     2 vector_ptr	      (tvl_maximum_number_of_vectors refer (typed_vector_list.maximum_number_of_vectors)) ptr;
  7    17 
  7    18      dcl	   typed_vector_list_ptr  ptr;
  7    19      dcl	   TYPED_VECTOR_LIST_VERSION_1
  7    20 			      fixed bin (17) int static options (constant) init (1);
  7    21      dcl	   tvl_maximum_number_of_vectors  fixed bin (35);
  7    22 
  7    23 /*  END INCLUDE	dm_typed_vector_list.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      284 
      285 
  8     1 /* BEGIN INCLUDE FILE dm_rlm_cursor.incl.pl1 */
  8     2 
  8     3 /* HISTORY:
  8     4*
  8     5*Written by Matthew Pierret, 05/19/83. 
  8     6*Modified:
  8     7*06/24/83 by Lindsey L. Spratt:  Changed to version 2.  Added the current.flags
  8     8*            structure, to add the search_index_and_record_collection flag.
  8     9*            This flag is only meaningful when doing a relative search.  It is
  8    10*            used by rlm_general_search to know what state the
  8    11*            internal_search_specification was left in (suitable for searching
  8    12*            the index or suitable for searching the records).
  8    13*10/29/84 by Stanford S. Cox:  Changed to not init version.
  8    14*02/12/85 by S. Cox:  Chg and_group_idx to fb17, current.flags.mbz to bit35.
  8    15**/
  8    16 
  8    17 /* format: style2,ind3 */
  8    18      dcl	   1 relation_cursor      aligned based (relation_cursor_ptr),
  8    19 	     2 version	      char (8),		/* version of this structure */
  8    20 	     2 work_area_ptr      ptr init (null),	/* points to area in which cursor is allocated. */
  8    21 	     2 file_opening_id    bit (36) aligned init ("0"b),
  8    22 						/* opening id of file in which relation resides */
  8    23 	     2 flags	      aligned,
  8    24 	       3 current_state_is_consistent
  8    25 			      bit (1) unal init ("0"b),
  8    26 						/* On if all values in current are insynch */
  8    27 	       3 mbz	      bit (35) unal init ("0"b),
  8    28 						/* must be zero */
  8    29 	     2 current,				/* current position in search */
  8    30 	       3 and_group_idx    fixed bin (17) aligned init (0),
  8    31 						/* in relation_search_specification */
  8    32 	       3 flags	      aligned,
  8    33 	         4 search_index_and_record_collection
  8    34 			      bit (1) unal init ("0"b),
  8    35 	         4 mbz	      bit (35) unal init ("0"b),
  8    36 	       3 collection_id    bit (36) aligned init ("0"b),
  8    37 						/* that cursor is define over */
  8    38 	       3 specification_ptr
  8    39 			      ptr init (null),	/* points to index or record specification */
  8    40 	       3 cursor_ptr	      ptr init (null);	/* points to index or record cursor */
  8    41 
  8    42      dcl	   relation_cursor_ptr    ptr init (null);
  8    43      dcl	   RELATION_CURSOR_VERSION_2
  8    44 			      init ("relcrs02") char (8) aligned internal static options (constant);
  8    45 
  8    46 /* END INCLUDE FILE dm_rlm_cursor.incl.pl1 */
      286 
      287 
  9     1 /* BEGIN INCLUDE FILE dm_rcdmgr_entry_dcls.incl.pl1 */
  9     2 
  9     3 /* This include file contains declarations of record_manager_ entry points. */
  9     4 
  9     5 /* HISTORY:
  9     6*Written by Matthew Pierret 05/12/82.
  9     7*Modified:
  9     8*12/14/82 by Matthew Pierret: Changed $get_ids to $get_id.
  9     9*04/01/83 by Matthew Pierret: Added $get_records_and_ids and
  9    10*            $get_records_and_ids_by_interval.
  9    11*04/04/83 by Matthew Pierret: Added $destroy_collection and $destroy_cursor.
  9    12*05/24/83 by Matthew Pierret: Corrected mis-spelling of "manger" for
  9    13*            rcm_$destroy_cursor.
  9    14*06/06/83 by Matthew Pierret: Corrected rcm_$get_record_count_by_intervals -
  9    15*            added a ptr parameter. 
  9    16*06/13/83 by Matthew Pierret:  Changed rcm_$*_by_intervals to correctly be
  9    17*            rcm_$=_by_interval.
  9    18*04/12/84 by Lee Baldwin:  Renamed some of the entry points (see 
  9    19*            record_manager_.alm) and changed the declarations of
  9    20*            those that used to pass a typed_vector_type and a
  9    21*            typed_vector_array_version.
  9    22*04/26/84 by Lee Baldwin:  Changed the arg list of
  9    23*            $get_record_count_by_interval to not take a work_area_ptr.
  9    24**/
  9    25 
  9    26 /* format: style2,ind3 */
  9    27      dcl	   record_manager_$create_collection
  9    28 			      entry (bit (36) aligned, ptr, ptr, ptr, bit (36) aligned, fixed bin (35));
  9    29      dcl	   record_manager_$create_cursor
  9    30 			      entry (bit (36) aligned, bit (36) aligned, ptr, ptr, fixed bin (35));
  9    31      dcl	   record_manager_$destroy_collection
  9    32 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  9    33      dcl	   record_manager_$destroy_cursor
  9    34 			      entry (ptr, fixed bin (35));
  9    35 
  9    36      dcl	   record_manager_$get_record_by_id
  9    37 			      entry (bit (36) aligned, ptr, ptr, ptr, ptr, fixed bin (35));
  9    38      dcl	   record_manager_$get_records_by_id_list
  9    39 			      entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35));
  9    40      dcl	   record_manager_$get_records_by_spec
  9    41 			      entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35));
  9    42      dcl	   record_manager_$get_records_by_interval
  9    43 			      entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35), ptr, ptr, fixed bin (35));
  9    44      dcl	   record_manager_$get_records_and_ids_by_spec
  9    45 			      entry (ptr, ptr, ptr, ptr, ptr, ptr, fixed bin (35));
  9    46      dcl	   record_manager_$get_records_and_ids_by_interval
  9    47 			      entry (ptr, ptr, ptr, ptr, ptr, fixed bin (17), ptr, ptr, ptr, fixed bin (35));
  9    48      dcl	   record_manager_$get_record_ids_by_spec
  9    49                                     entry (ptr, ptr, ptr, ptr, fixed bin (35));
  9    50      dcl	   record_manager_$get_record_ids_by_interval
  9    51 			      entry (ptr, ptr, ptr, ptr, ptr, ptr, fixed bin (35));
  9    52      dcl	   record_manager_$get_record_count
  9    53 			      entry (ptr, ptr, fixed bin (35), fixed bin (35));
  9    54      dcl	   record_manager_$get_record_count_by_interval
  9    55 			      entry (ptr, ptr, ptr, ptr, fixed bin (35), fixed bin (35));
  9    56 
  9    57      dcl	   record_manager_$put_record_by_id
  9    58 			      entry (bit (36) aligned, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35));
  9    59 
  9    60      dcl	   record_manager_$put_records_by_id
  9    61 			      entry (bit (36) aligned, ptr, fixed bin (35), ptr, ptr, fixed bin (35));
  9    62 
  9    63      dcl	   record_manager_$delete_record_by_id
  9    64 			      entry (bit (36) aligned, ptr, fixed bin (35));
  9    65 
  9    66      dcl	   record_manager_$delete_records_by_id_list
  9    67 			      entry (ptr, ptr, fixed bin (35), fixed bin (35));
  9    68 
  9    69      dcl	   record_manager_$delete_records_by_spec
  9    70 			      entry (ptr, ptr, fixed bin (35), fixed bin (35));
  9    71 
  9    72      dcl	   record_manager_$modify_record_by_id
  9    73 			      entry (bit (36) aligned, ptr, ptr, fixed bin (35));
  9    74 
  9    75      dcl	   record_manager_$modify_records_by_id_list
  9    76 			      entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35));
  9    77 
  9    78      dcl	   record_manager_$modify_records_by_spec
  9    79 			      entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35));
  9    80 
  9    81 /* END INCLUDE FILE dm_rcdmgr_entry_dcls.incl.pl1 */
      288 
      289 
 10     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
 10     2 /* format: style3 */
 10     3 
 10     4 /* These constants are to be used for the flags argument of sub_err_ */
 10     5 /* They are just "string (condition_info_header.action_flags)" */
 10     6 
 10     7 declare	(
 10     8 	ACTION_CAN_RESTART	init (""b),
 10     9 	ACTION_CANT_RESTART init ("1"b),
 10    10 	ACTION_DEFAULT_RESTART
 10    11 			init ("01"b),
 10    12 	ACTION_QUIET_RESTART
 10    13 			init ("001"b),
 10    14 	ACTION_SUPPORT_SIGNAL
 10    15 			init ("0001"b)
 10    16 	)		bit (36) aligned internal static options (constant);
 10    17 
 10    18 /* End include file */
      290 
      291 
      292    end rlm_get_tuple_by_id;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/05/85  0836.8  rlm_get_tuple_by_id.pl1           >spec>on>7138.pbf>rlm_get_tuple_by_id.pl1
272          1    01/07/85  0859.6  dm_rlm_opening_info.incl.pl1      >ldd>include>dm_rlm_opening_info.incl.pl1
274          2    01/07/85  0859.4  dm_rlm_header.incl.pl1            >ldd>include>dm_rlm_header.incl.pl1
276          3    01/07/85  0901.7  dm_rlm_attribute_info.incl.pl1    >ldd>include>dm_rlm_attribute_info.incl.pl1
278          4    01/07/85  0901.7  dm_rlm_index_attr_map.incl.pl1    >ldd>include>dm_rlm_index_attr_map.incl.pl1
280          5    10/14/83  1609.1  vu_typed_vector.incl.pl1          >ldd>include>vu_typed_vector.incl.pl1
282          6    10/14/83  1609.1  vu_typed_vector_array.incl.pl1    >ldd>include>vu_typed_vector_array.incl.pl1
284          7    10/14/83  1609.1  dm_typed_vector_list.incl.pl1     >ldd>include>dm_typed_vector_list.incl.pl1
286          8    03/05/85  0800.2  dm_rlm_cursor.incl.pl1            >spec>on>7138.pbf>dm_rlm_cursor.incl.pl1
288          9    01/07/85  0859.3  dm_rcdmgr_entry_dcls.incl.pl1     >ldd>include>dm_rcdmgr_entry_dcls.incl.pl1
290         10    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000031 constant        bit(36)                  initial dcl 10-7 set ref 228* 243*
INITIAL_NUMBER_OF_INDICES       000124 automatic       fixed bin(17,0)          initial dcl 4-45 set ref 4-45*
RELATION_CURSOR_VERSION_2       000000 constant        char(8)                  initial dcl 8-43 ref 140
RELATION_HEADER_VERSION_3       000002 constant        char(8)                  initial dcl 2-30 set ref 149*
RELATION_OPENING_INFO_VERSION_2 000004 constant        char(8)                  initial dcl 1-43 ref 146
TYPED_VECTOR_ARRAY_VERSION_2           constant        fixed bin(35,0)          initial dcl 6-50 ref 177
TYPED_VECTOR_LIST_VERSION_1            constant        fixed bin(17,0)          initial dcl 7-19 ref 184
UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY
                                000125 automatic       fixed bin(17,0)          initial dcl 4-47 set ref 4-47*
attribute_info_ptr              000120 automatic       pointer                  initial dcl 3-29 set ref 3-29*
cleanup                         000106 stack reference condition                dcl 92 ref 151
collection_id            10            based           bit(36)                  initial level 3 dcl 8-18 ref 257
current                   6            based           structure                level 2 dcl 8-18
current_state_is_consistent
                          5            based           bit(1)                   initial level 3 packed unaligned dcl 8-18 ref 257
cursor_ptr               14            based           pointer                  initial level 3 dcl 8-18 ref 216 257
cv_p_expected_version                  parameter       char(8)                  dcl 225 set ref 221 228 228*
cv_p_received_version                  parameter       char(8)                  dcl 224 set ref 221 228 228*
cv_p_structure_name                    parameter       char                     unaligned dcl 226 set ref 221 228*
cvf_p_expected_version                 parameter       fixed bin(35,0)          dcl 240 set ref 236 243 243*
cvf_p_received_version                 parameter       fixed bin(35,0)          dcl 239 set ref 236 243 243*
cvf_p_structure_name                   parameter       char                     unaligned dcl 241 set ref 236 243*
dm_error_$record_not_found      000014 external static fixed bin(35,0)          dcl 106 ref 162 171
dm_error_$tuple_not_found_id    000016 external static fixed bin(35,0)          dcl 106 set ref 162* 171*
er_code                                parameter       fixed bin(35,0)          dcl 204 ref 201 206
error_table_$unimplemented_version
                                000020 external static fixed bin(35,0)          dcl 110 set ref 228* 243*
file_opening_id           4            based           bit(36)                  initial level 2 dcl 8-18 set ref 142* 262*
flags                     5            based           structure                level 2 dcl 8-18
get_array_of_tuples             000102 automatic       bit(1)                   initial dcl 80 set ref 80* 132* 179
get_list_of_tuples              000101 automatic       bit(1)                   initial dcl 79 set ref 79* 125*
get_single_tuple                000100 automatic       bit(1)                   initial dcl 78 set ref 78* 118* 157
index_attribute_map_ptr         000122 automatic       pointer                  initial dcl 4-37 set ref 4-37*
maximum_dimension_name_length
                          4            based           fixed bin(17,0)          level 2 dcl 6-21 ref 190 214
maximum_number_of_vectors
                          1            based           fixed bin(35,0)          level 2 dcl 7-10 ref 186
myname                          000006 constant        varying char(32)         initial dcl 97 set ref 228* 243*
null                                                   builtin function         dcl 88 ref 82 137 2-29 3-29 4-37 8-42 214 216 228
                                                                                  228 243 243 253
number_of_dimensions      1            based           fixed bin(17,0)          level 2 dcl 6-21 ref 190 214
number_of_vector_slots
                          3            based           fixed bin(17,0)          level 2 dcl 6-21 ref 214
number_of_vectors         2            based           fixed bin(17,0)          level 2 in structure "typed_vector_array" dcl 6-21
                                                                                  in procedure "rlm_get_tuple_by_id" ref 186
number_of_vectors         2            based           fixed bin(35,0)          level 2 in structure "typed_vector_list" dcl 7-10
                                                                                  in procedure "rlm_get_tuple_by_id" set ref 186*
                                                                                  189
p_code                                 parameter       fixed bin(35,0)          dcl 74 set ref 115 122 129 135* 142* 143 160* 162
                                                                                  162 165* 169* 171 171 174* 206*
p_element_id_list_ptr                  parameter       pointer                  dcl 63 set ref 122 129 169*
p_id_list_ptr                          parameter       pointer                  dcl 66 set ref 115 122 129 160* 169*
p_relation_cursor_ptr                  parameter       pointer                  dcl 67 ref 115 122 129 139
p_simple_typed_vector_ptr              parameter       pointer                  dcl 68 set ref 115 160*
p_tuple_id                             parameter       bit(36)                  dcl 64 set ref 115 160*
p_typed_vector_array_ptr               parameter       pointer                  dcl 72 set ref 129 179*
p_typed_vector_list_ptr                parameter       pointer                  dcl 70 set ref 122 183 193*
p_work_area_ptr                        parameter       pointer                  dcl 65 set ref 115 122 129 160* 169*
record_collection_cursor_ptr    000104 automatic       pointer                  initial dcl 82 set ref 82* 153* 160* 169* 216 216
                                                                                  216*
record_collection_id      3            based           bit(36)                  initial level 2 dcl 2-15 set ref 257 262*
record_manager_$create_cursor   000022 constant        entry                    external dcl 9-29 ref 262
record_manager_$destroy_cursor  000024 constant        entry                    external dcl 9-33 ref 216
record_manager_$get_record_by_id
                                000026 constant        entry                    external dcl 9-36 ref 160
record_manager_$get_records_by_id_list
                                000030 constant        entry                    external dcl 9-38 ref 169
relation_cursor                        based           structure                level 1 dcl 8-18
relation_cursor_ptr             000132 automatic       pointer                  initial dcl 8-42 set ref 139* 140 142 8-42* 216 257
                                                                                  257 257 262 262
relation_header                        based           structure                level 1 dcl 2-15
relation_header_ptr      14            based           pointer                  initial level 2 in structure "relation_opening_info"
                                                                                  dcl 1-15 in procedure "rlm_get_tuple_by_id" ref
                                                                                  148
relation_header_ptr             000116 automatic       pointer                  initial dcl 2-29 in procedure "rlm_get_tuple_by_id"
                                                                                  set ref 148* 149 2-29* 257 262
relation_opening_info                  based           structure                level 1 dcl 1-15
relation_opening_info_ptr       000114 automatic       pointer                  dcl 1-41 set ref 142* 146 148
rlm_opening_info$get            000010 constant        entry                    external dcl 101 ref 142
srccp_code                      000170 automatic       fixed bin(35,0)          initial dcl 255 set ref 255* 262* 264 264*
srccp_record_collection_cursor_ptr
                                000166 automatic       pointer                  initial dcl 253 set ref 253* 257* 262* 268
sub_err_                        000012 constant        entry                    external dcl 102 ref 228 243
typed_vector_array                     based           structure                level 1 dcl 6-21 ref 214
typed_vector_array_ptr          000126 automatic       pointer                  dcl 6-43 set ref 137* 169* 177 179 186 190 214 214
typed_vector_list                      based           structure                level 1 dcl 7-10
typed_vector_list_ptr           000130 automatic       pointer                  dcl 7-18 set ref 183* 184 186 186 189 190 193
vector_idx                      000103 automatic       fixed bin(17,0)          dcl 81 set ref 189* 190 190*
vector_ptr                4            based           pointer                  array level 2 dcl 7-10 set ref 190*
vector_slot                            based           pointer                  array level 2 dcl 6-21 ref 190
version                                based           fixed bin(35,0)          level 2 in structure "typed_vector_array" dcl 6-21
                                                                                  in procedure "rlm_get_tuple_by_id" ref 177
version                                based           char(8)                  level 2 in structure "relation_cursor" dcl 8-18
                                                                                  in procedure "rlm_get_tuple_by_id" ref 140
version                                based           fixed bin(17,0)          level 2 in structure "typed_vector_list" dcl 7-10
                                                                                  in procedure "rlm_get_tuple_by_id" ref 184
version                                based           char(8)                  level 2 in structure "relation_opening_info"
                                                                                  dcl 1-15 in procedure "rlm_get_tuple_by_id" ref
                                                                                  146
version                                based           char(8)                  level 2 in structure "relation_header" dcl 2-15
                                                                                  in procedure "rlm_get_tuple_by_id" set ref 149*
work_area_ptr             2            based           pointer                  initial level 2 dcl 8-18 set ref 262*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 10-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 10-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 10-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 10-7
ATTRIBUTE_INFO_VERSION_1               internal static char(8)                  initial dcl 3-34
GENERAL_TYPED_VECTOR_TYPE              internal static fixed bin(17,0)          initial dcl 5-43
INDEX_ATTRIBUTE_MAP_VERSION_2          internal static char(8)                  initial dcl 4-43
OLD_SIMPLE_TYPED_VECTOR_TYPE           internal static fixed bin(17,0)          initial dcl 5-43
SIMPLE_TYPED_VECTOR_TYPE               internal static fixed bin(17,0)          initial dcl 5-43
ai_maximum_attribute_name_length       automatic       fixed bin(17,0)          dcl 3-30
ai_number_of_attributes                automatic       fixed bin(17,0)          dcl 3-32
attribute_info                         based           structure                level 1 dcl 3-18
general_typed_vector                   based           structure                level 1 packed unaligned dcl 5-24
general_typed_vector_ptr               automatic       pointer                  dcl 5-38
gtv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 5-40
iam_maximum_number_of_attributes_per_index
                                       automatic       fixed bin(17,0)          dcl 4-41
iam_maximum_number_of_indices          automatic       fixed bin(17,0)          dcl 4-39
index_attribute_map                    based           structure                level 1 dcl 4-18
record_manager_$create_collection
                                000000 constant        entry                    external dcl 9-27
record_manager_$delete_record_by_id
                                000000 constant        entry                    external dcl 9-63
record_manager_$delete_records_by_id_list
                                000000 constant        entry                    external dcl 9-66
record_manager_$delete_records_by_spec
                                000000 constant        entry                    external dcl 9-69
record_manager_$destroy_collection
                                000000 constant        entry                    external dcl 9-31
record_manager_$get_record_count
                                000000 constant        entry                    external dcl 9-52
record_manager_$get_record_count_by_interval
                                000000 constant        entry                    external dcl 9-54
record_manager_$get_record_ids_by_interval
                                000000 constant        entry                    external dcl 9-50
record_manager_$get_record_ids_by_spec
                                000000 constant        entry                    external dcl 9-48
record_manager_$get_records_and_ids_by_interval
                                000000 constant        entry                    external dcl 9-46
record_manager_$get_records_and_ids_by_spec
                                000000 constant        entry                    external dcl 9-44
record_manager_$get_records_by_interval
                                000000 constant        entry                    external dcl 9-42
record_manager_$get_records_by_spec
                                000000 constant        entry                    external dcl 9-40
record_manager_$modify_record_by_id
                                000000 constant        entry                    external dcl 9-72
record_manager_$modify_records_by_id_list
                                000000 constant        entry                    external dcl 9-75
record_manager_$modify_records_by_spec
                                000000 constant        entry                    external dcl 9-78
record_manager_$put_record_by_id
                                000000 constant        entry                    external dcl 9-57
record_manager_$put_records_by_id
                                000000 constant        entry                    external dcl 9-60
simple_typed_vector                    based           structure                level 1 packed unaligned dcl 5-17
simple_typed_vector_ptr                automatic       pointer                  dcl 5-33
stv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 5-35
tva_maximum_dimension_name_length      automatic       fixed bin(17,0)          dcl 6-48
tva_number_of_dimensions               automatic       fixed bin(17,0)          dcl 6-46
tva_number_of_vector_slots             automatic       fixed bin(17,0)          dcl 6-44
tvl_maximum_number_of_vectors          automatic       fixed bin(35,0)          dcl 7-21

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_VERSION                   000701 constant        entry                    internal dcl 221 ref 140 146 149
CHECK_VERSION_FB                001003 constant        entry                    internal dcl 236 ref 177 184
ERROR_RETURN                    000614 constant        entry                    internal dcl 201 ref 162 165 171 174 264
FINISH                          000622 constant        entry                    internal dcl 211 ref 151
JOIN                            000240 constant        label                    dcl 135 set ref 119 126 133
RETURN                          000613 constant        label                    dcl 198 ref 207
SET_RECORD_COLLECTION_CURSOR_PTR
                                001077 constant        entry                    internal dcl 250 ref 153
array                           000227 constant        entry                    external dcl 129
list                            000214 constant        entry                    external dcl 122
rlm_get_tuple_by_id             000160 constant        entry                    external dcl 55
single                          000175 constant        entry                    external dcl 115

NAME DECLARED BY CONTEXT OR IMPLICATION.
min                                                    builtin function         ref 186

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1446        1500    1250        1456
Length      2120    1250        32         403     175           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rlm_get_tuple_by_id                 290 external procedure  is an external procedure.  
on unit on line 151                  78 on unit               
ERROR_RETURN                            internal procedure  shares stack frame of external procedure rlm_get_tuple_by_id.  
FINISH                                  internal procedure  shares stack frame of on unit on line 151.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure rlm_get_tuple_by_id.  
CHECK_VERSION_FB                        internal procedure  shares stack frame of external procedure rlm_get_tuple_by_id.  
SET_RECORD_COLLECTION_CURSOR_PTR
                                        internal procedure  shares stack frame of external procedure rlm_get_tuple_by_id.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rlm_get_tuple_by_id      000100 get_single_tuple            rlm_get_tuple_by_id
                         000101 get_list_of_tuples          rlm_get_tuple_by_id
                         000102 get_array_of_tuples         rlm_get_tuple_by_id
                         000103 vector_idx                  rlm_get_tuple_by_id
                         000104 record_collection_cursor_ptr
                                                            rlm_get_tuple_by_id
                         000114 relation_opening_info_ptr   rlm_get_tuple_by_id
                         000116 relation_header_ptr         rlm_get_tuple_by_id
                         000120 attribute_info_ptr          rlm_get_tuple_by_id
                         000122 index_attribute_map_ptr     rlm_get_tuple_by_id
                         000124 INITIAL_NUMBER_OF_INDICES   rlm_get_tuple_by_id
                         000125 UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY
                                                            rlm_get_tuple_by_id
                         000126 typed_vector_array_ptr      rlm_get_tuple_by_id
                         000130 typed_vector_list_ptr       rlm_get_tuple_by_id
                         000132 relation_cursor_ptr         rlm_get_tuple_by_id
                         000166 srccp_record_collection_cursor_ptr
                                                            SET_RECORD_COLLECTION_CURSOR_PTR
                         000170 srccp_code                  SET_RECORD_COLLECTION_CURSOR_PTR

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              enable              ext_entry           int_entry
free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
record_manager_$create_cursor record_manager_$destroy_cursor
record_manager_$get_record_by_id                            record_manager_$get_records_by_id_list
rlm_opening_info$get          sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$record_not_found    dm_error_$tuple_not_found_id  error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     78 000140        79 000141        80 000142        82 000143    2   29 000145    3   29 000146    4   37 000147
 4   45 000150    4   47 000152    8   42 000153        55 000157        58 000166       115 000167       118 000203
    119 000205       122 000206       125 000222       126 000224       129 000225       132 000235       133 000237
    135 000240       137 000242       139 000244       140 000247       142 000263       143 000300       146 000303
    148 000322       149 000325       151 000350       153 000366       157 000370       160 000372       162 000414
    165 000431       166 000437       169 000440       171 000462       174 000477       177 000505       179 000517
    183 000525       184 000531       186 000546       189 000555       190 000563       191 000606       193 000610
    198 000613       201 000614       206 000616       207 000621       211 000622       214 000623       216 000654
    219 000700       221 000701       228 000712       233 001002       236 001003       243 001014       248 001076
    250 001077       253 001101       255 001103       257 001104       262 001117       264 001137       268 001143


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
