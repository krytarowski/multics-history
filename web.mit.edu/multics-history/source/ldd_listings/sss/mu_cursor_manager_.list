	COMPILATION LISTING OF SEGMENT mu_cursor_manager_
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/01/88  1328.5 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 mu_cursor_manager_: proc;
        7 
        8 /*
        9*
       10*                      BEGIN_DESCRIPTION
       11*   This  routine  is used to manage the storage of cursors and their
       12*   pointers.   Each cursor is associated with a relation-opening-id,
       13*   a   collection-index   and  a  tuple-variable.  The  main   entry 
       14*   mu_cursor_manager_$mu_cursor_manager_ should never be called
       15*
       16********************************************************************************
       17********************************************************************************
       18*   Note that this entire module is now unnecessary with the advent of
       19*   relation cursors.  The management of cursors has become simple enough
       20*   that it can be handled in the same way that iocbs used to be handled.
       21*   The only reason this module still exists is to expedite the conversion
       22*   to relation cursors.  It will be deleted soon or significantly rewritten
       23*   and simplified.
       24********************************************************************************
       25********************************************************************************
       26*
       27*   The get entry  is  used to get the cursor associated with a given
       28*   <rel_opening_id-collection_index-tupe-variable>.   If  the cursor
       29*   has  not  yet been created a call to the relation_manager is made
       30*   to  create  it.   After creation it is stored in the storage area
       31*   for  future  reference.  The storage area will be either a simple
       32*   array overlaid on a temp segment and sorted by <r-c-t> or a keyed
       33*   sequential  file  with  keys  of <r-c-t>.  The first call to this
       34*   procedure  on  behalf  of  a  database  index  should have a null
       35*   storage pointer and a null area pointer input so that the storage
       36*   and area will be created. This entry will also cause the relation
       37*   to be opened if it is not already in the opened state.
       38*
       39*
       40*   The  destroy_all_no_free  entry destroys the storage used to hold
       41*   the  cursor  pointers,  and closes the relations that the cursors
       42*   were  associated  with.  The  temp seg area where the cursors are
       43*   stored is also deleted.
       44*
       45*
       46*   The entry destroy_and_free_on_opening_id is used to  destroy  the
       47*   storage   used   to   hold   the   cursor  pointers  for  cursors 
       48*   associated  with a given opening id. It also destroys the cursors
       49*   associated with the given opening id and closes the relation with
       50*   the given opening id.
       51*
       52*
       53*   The  cleanup_storage  entry  releases the temp segment area where
       54*   the  cursors are allocated and destroyes the storage used to hold
       55*   the  cursor  pointers.   It  assumes that the relations have been
       56*   closed by some other means
       57*
       58*   Known Bugs:
       59*
       60*   Other Problems:
       61*
       62*   History:
       63*      82-09-13 Davids: written
       64*    
       65*      82-09-24 Donna Woodka : changed declaration of mcm_collection_index
       66*      and cc_collection_id from fixed bin (35) to bit (36) aligned.
       67*
       68*      82-09-29 Davids: added the destroy_and_free_on_opening_id
       69*      entry and the move_chars internal proc. Changed the internal proc
       70*      add_cursor_to_array to use move_chars instead of the faulty
       71*      mu_mrl_. Also added the temp_space_begins element to the mcm_cursor_array
       72*      structure and changed the size of the array to be a constant instead
       73*      of a refers.
       74*
       75*      82-10-15 Davids: Modified the get entry to create an area to alloacte
       76*      the cursors in if the storage_ptr is null. Modified the 
       77*      destroy_all_no_free entry to have the area_ptr as a parameter and to
       78*      free the temp seg the area_ptr points to. Freeing is done via
       79*      release_temp_segment_ because that is how mu_define_area creates the
       80*      temp segment. All this makes the mcm_area_ptr an input/output
       81*      parameter.
       82*
       83*      82-10-18 Davids: Modified all entries to set the value of code to 0
       84*      as the first thing they do so if no error occurs the code returned
       85*      will be 0.
       86*
       87*      82-11-24 Davids: Modified call to move_chars in delete_cursors_from_array
       88*      to have the correct number of bytes to move.
       89*
       90*      82-12-03 Davids: Modified to delete the temp seg that the cursor ptrs are
       91*      stored in. This required storing a character representation of the dbi
       92*      in the cursor_array structure so that only the temp seg associated with 
       93*      the database being closed will be deleted.
       94*
       95*      83-01-03 Davids: Added the cleanup_storage entry. The relations will be
       96*      closed by running through the rm_rel_info structures and getting the
       97*      opening_id instead of calling the destroy_all_no_free entry. The
       98*      cleanup_storage entry was needed to neatly cleanup the storage used
       99*      by mu_cursor_manager.
      100*                      END_DESCRIPTION
      101*
      102*
      103*
      104*       Naming  convension:  becuase  of the number of internal
      105*       routines  and  the need for discriptive names variables
      106*       declared  in  all  routines  (including the main entry)
      107*       have  prefixes  that  are  the  initials of the routine
      108*       name.   Global  variables  can be identified since they
      109*       have  a  prefix  different  from  that derived from the
      110*       routine  name.  Variables with the same name except for
      111*       the  prefix  mean  the same thing.  Variables without a
      112*       prefix  are  external to the module, i.e.  entry names,
      113*       external  static,  builtins,  conditions,  etc.   These
      114*       variables  are declared in the main routine.  Variables
      115*       with  names  in  upper case (except for the prefix) are
      116*       internal static constants.
      117**/
      118 
      119 /* PARAMETERS */
      120 
      121 	dcl     mcm_dbi		 fixed bin (35);	/* (input) database index */
      122 	dcl     mcm_rmri_ptr	 ptr;		/* (input) pointer to the relation's rm_rel_info structure
      123*                                                                       which contains the rel_opening_id and from which
      124*                                                                       the path of the relation can be determined */
      125 	dcl     mcm_opening_id	 bit (36) aligned;	/* (input) opening id for the relation */
      126 	dcl     mcm_tuple_var_index	 fixed bin (35);	/* (input) tuple variable associated with the cursor */
      127 	dcl     mcm_collection_index	 bit (36) aligned;	/* (input) this was used before the conversion to
      128*						           relation cursors and is interm.  It is
      129*							 not currently used by this routine. */
      130 	dcl     mcm_relmgr_create_cursor entry;		/* (input) relation_manager entry for creating a cursor */
      131 	dcl     mcm_relmgr_open	 entry;		/* (input) relation_manager entry for opening a relation */
      132 	dcl     mcm_relmgr_close	 entry options (variable);
      133 						/* (input) relation_manager entry for closing a relation */
      134 	dcl     mcm_relmgr_destroy_cursor entry;	/* (input) relation_manager entry for destroying a cursor */
      135 	dcl     mcm_area_ptr	 ptr;		/* (input / output) ptr to area where
      136*                                                                                cursors are to be allocated */
      137 	dcl     mcm_storage_ptr	 ptr;		/* (input / output) pointer to storage where the mapping
      138*                                                                                between <r-c-t> and cursor_ptrs is kept */
      139 	dcl     mcm_cursor_ptr	 ptr;		/* (output) pointer to a cursor */
      140 	dcl     mcm_code		 fixed bin (35);	/* (output) standard error code */
      141 
      142 /* AUTOMATIC */
      143 
      144 	dcl     mcm_cursor_index	 fixed bin;	/* index in the cursor array of where the
      145*                                                               cursor is (and wher it should be stored) */
      146 	dcl     mcm_found		 bit (1);		/* "1"b ==> cursor was already in storage
      147*                                                                        and may just be returned
      148*                                                               "0"b ==> cursor not in storage and must be created */
      149 	dcl     mcm_key		 char (12);	/* key identifing the cursor */
      150 	dcl     mcm_unused1		 ptr;		/* unused output from vfile_search -
      151*                                                               we know the value will be null */
      152 	dcl     mcm_unused2		 bit (1);		/* unused output from vfile_search -
      153*                                                               we know the cursor won't be found */
      154 
      155 /* CONSTANTS */
      156 
      157 	dcl     mcm_ARRAY		 fixed bin init (1) internal static options (constant);
      158 						/* indicates that storage area is of type ARRAY */
      159 	dcl     mcm_CURSOR_ARRAY_ELEMENT_SIZE fixed bin init (24) internal static options (constant);
      160 						/* length in characters of a cursor element (key and pointer),
      161*                                                               key is 12 chars or and the ptr 8 but there is a 4 char
      162*                                                               (1 word) implicit pad to make the pointer
      163*                                                               start on an even word */
      164 	dcl     mcm_CURSOR_PTR_LENGTH	 fixed bin (21) init (8) internal static options (constant);
      165 						/* length of a cursor ptr ==> 2 words or 8 bytes */
      166 	dcl     mcm_MAX_NUM_FOR_ARRAY_STORAGE fixed bin init (1000) internal static options (constant);
      167 						/* maximum number of cursors that can be stored as an
      168*                                                               array before a keyed file becomes more efficient */
      169 	dcl     mcm_PROC_NAME	 char (18) init ("mu_cursor_manager_") internal static options (constant);
      170 	dcl     mcm_VFILE		 fixed bin init (2) internal static options (constant);
      171 						/* indicates that storage area is of type VFILE */
      172 
      173 /* BASED */
      174 
      175 	dcl     mcm_b36b		 bit (36) unaligned based; /* bit 36 overlay */
      176 	dcl     mcm_c4b		 char (4) based;	/* 4 character overlay */
      177 
      178 	dcl     01 mcm_cursor_array	 unaligned based,
      179 		02 version	 char (4),
      180 		02 num		 fixed bin,
      181 		02 dbi_char	 char (4),
      182 		02 mbz		 bit (36),
      183 		02 cursors	 (mcm_MAX_NUM_FOR_ARRAY_STORAGE),
      184 		  03 key		 char (12),
      185 		  03 cursor_ptr	 ptr aligned,
      186 		02 temp_space_begins bit (1) aligned;
      187 
      188 /* EXTERNAL STATIC */
      189 
      190 	dcl     error_table_$end_of_info fixed bin (35) ext static;
      191 	dcl     error_table_$no_record fixed bin (35) ext static;
      192 	dcl     mrds_error_$unknown_cursor_storage fixed bin (35) external static;
      193 	dcl     sys_info$max_seg_size	 fixed bin (35) ext static;
      194 
      195 /* ENTRIES */
      196 
      197 	dcl     delete_$path	 entry (char (*), char (*), bit (6), char (*), fixed bin (35));
      198 	dcl     expand_pathname_	 entry (char (*), char (*), char (*), fixed bin (35));
      199 	dcl     iox_$attach_name	 entry (char (*), ptr, char (*), ptr, fixed bin (35));
      200 	dcl     iox_$close		 entry (ptr, fixed bin (35));
      201 	dcl     iox_$control	 entry (ptr, char (*), ptr, fixed bin (35));
      202 	dcl     iox_$delete_record	 entry (ptr, fixed bin (35));
      203 	dcl     iox_$destroy_iocb	 entry (ptr, fixed bin (35));
      204 	dcl     iox_$detach_iocb	 entry (ptr, fixed bin (35));
      205 	dcl     iox_$open		 entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
      206 	dcl     iox_$position	 entry (ptr, fixed bin, fixed bin (21), fixed bin (35));
      207 	dcl     iox_$read_key	 entry (ptr, char (256) var, fixed bin (21), fixed bin (35));
      208 	dcl     iox_$read_record	 entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
      209 	dcl     iox_$seek_key	 entry (ptr, char (256) var, fixed bin (21), fixed bin (35));
      210 	dcl     iox_$write_record	 entry (ptr, ptr, fixed bin (21), fixed bin (35));
      211 	dcl     mrds_dsl_resultant_storage$get_opening_temp_dir
      212 				 entry (fixed bin (35), fixed bin (35)) returns (char (168));
      213 	dcl     mu_define_area	 entry (ptr, fixed bin (18), char (11), bit (1) aligned, bit (1) aligned, bit (1) aligned,
      214 				 bit (1) aligned, fixed bin (35));
      215 	dcl     mu_temp_segments$get_temp_segment entry (fixed bin (35), char (*), ptr, fixed bin (35));
      216 	dcl     mu_temp_segments$delete_all_temp_segments entry (char (*), fixed bin (35));
      217 	dcl     release_temp_segment_	 entry (char (*), ptr, fixed bin (35));
      218 	dcl     sub_err_		 entry options (variable);
      219 	dcl     unique_chars_	 entry (bit (*)) returns (char (15));
      220 
      221 /* BUILTINS */
      222 
      223 	dcl     addr		 builtin;
      224 	dcl     char		 builtin;
      225 	dcl     divide		 builtin;
      226 	dcl     fixed		 builtin;
      227 	dcl     ltrim		 builtin;
      228 	dcl     null		 builtin;
      229 	dcl     pointer		 builtin;
      230 	dcl     rel		 builtin;
      231 	dcl     rtrim		 builtin;
      232 	dcl     substr		 builtin;
      233 	dcl     unspec		 builtin;
      234 
      235 /* INCLUDES */
      236 
  1     1 /* BEGIN mdbm_rm_rel_info.incl.pl1 -- jaw, 11/16/78 */
  1     2 
  1     3 /* WARNING
  1     4*          If the rm_rel_info structure is changed then the mrds_data_
  1     5*          item saved_res_version MUST be incremented to invalidate all
  1     6*          existing saved resultants
  1     7**/
  1     8 
  1     9 /* HISTORY:
  1    10*
  1    11*   Modified by Jim Gray - - May 1980, to  include  model  number  of
  1    12*   attributes,   and   varying  attributes,  so  that  partial  view
  1    13*   submodels will have the  info  needed  to  properly  set  up  the
  1    14*   varying length array headers in the tuple structure.
  1    15*
  1    16*   Modified  by  Jim  Gray  -  -  80-11-06,  to  rename   r_perm   =
  1    17*   status_perm,     s_perm    =    append_tuple_perm,    d_perm    =
  1    18*   delete_tuple_perm, and make m_perm = unused_perm.
  1    19*
  1    20*   81-01-23 Jim Gray : added bit to indicate whether the last  model
  1    21*   view attribute was varying character or bit, since a partial view
  1    22*   submodel will not have this information in the resultant, and  it
  1    23*   is  needed for determining the new tuple length in mus_mod_ubtup,
  1    24*   since with exact length storage  of  varying  length  attributes,
  1    25*   each  tuple  can  be  a  different  length,  which is can only be
  1    26*   determined by examining the tuple itself.
  1    27*
  1    28*   81-01-29 Jim Gray : added curent  tuple  count,  to  provide  for
  1    29*   interface  to  allow  temp  rel  population  to  be known, and to
  1    30*   provide a more efficient means of finding an approx. current perm
  1    31*   relation population.
  1    32*
  1    33*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
  1    34*   blocked  files, foreign keys, and ids procedures. Also set number
  1    35*   of files per rel to a constant of 1.
  1    36*
  1    37*   81-05-28 Jim Gray : combined data  from  rm_file_info  into  this
  1    38*   structure so that only one structure per relation is needed.
  1    39*
  1    40*   81-07-02 Jim Gray : added total_key and dup_key vfile  statistics
  1    41*   counts.   Also  added  number  of  operations  count  since  last
  1    42*   statistics update, and a time  since  the  statistics  were  last
  1    43*   updated.
  1    44*
  1    45*   81-07-06 Jim Gray :  added  a  per  selection  expression  update
  1    46*   identifier so that small relations could be updated on a per S.E.
  1    47*   basis
  1    48*
  1    49*   82-04-21 R. Lackey : Added number_selected (ri_niocbs_init refer (rm_rel_info.niocbs)) fixed bin (35)
  1    50*   to end of structure   TR 12205 (Suggestion).
  1    51*   
  1    52*   82-08-19 D. Woodka :  Removed  rm_rel_info.max_data_len  field for
  1    53*   the DMS conversion. 
  1    54*
  1    55*   82-08-30 Davids: added the opening_id element and removed the iocb
  1    56*   array and the niocb element for DMS conversion. Also removed the
  1    57*   number_selected array (and ri_niocbs_init) since subsets are not
  1    58*   going to be used.
  1    59*
  1    60*   82-09-20 Mike Kubicar : changed rm_rel_info.rel_id to bit (36) aligned
  1    61*   so that it can be used with relation manager.  Also added
  1    62*   rm_rel_info.primary_key_index_id for relation manager.
  1    63*
  1    64*   82-09-22 Mike Kubicar : Removed the, now useless, fields var_attr_ptrs,
  1    65*   nvar_atts, model_nvar_atts.
  1    66*
  1    67*   82-09-24 Davids: Removed current_key_count and current_dup_key_count
  1    68*   since the duplicate key count for each secondary index is now being
  1    69*   kept in the attr_info structure and key_count was only needed to
  1    70*   help in calculating the average selectivity of each index which
  1    71*   can now be gotten directly from each index's dup key count. Also
  1    72*   removed the file_id element since it is no longer needed for
  1    73*   anything.
  1    74*
  1    75*   82-09-27 Mike Kubicar : removed file_id_len for the same reason file_id
  1    76*   was removed.
  1    77*
  1    78*   82-11-05 Mike Kubicar : added a pointer to an id_list structure to be
  1    79*   used when retrieving tuples from this relation.
  1    80*
  1    81*   83-04-06 Davids: Added the scope_flags_ptr which points to the scope_flags structure
  1    82*   for the relation. Note that this structure is part of the resultant NOT
  1    83*   part of the db.control structure. The scopes are duplicated in the resultant
  1    84*   to reduce contention for the db.control structure. Note also that the pointer
  1    85*   will always point to a scope_flags structure even if no scopes have been
  1    86*   set on the relation, the structure is allocated when the db is opened.
  1    87**/
  1    88 
  1    89 
  1    90 /* DESCRIPTION:
  1    91*
  1    92*   This structure is allocated in the area part of the structure  in
  1    93*   mdbm_rm_db_info.incl.pl1  as  part of the resultant model created
  1    94*   at open  time  for  a  database.  There  will  be  one  of  these
  1    95*   rm_rel_info   structures  for  each  relation  appearing  in  the
  1    96*   database view (there may be less than the total in  the  database
  1    97*   for  a  submodel  openings).  There  will  also  be  one for each
  1    98*   temporary relation currently defined for that opening.
  1    99*
  1   100*   The structure in mdbm_rm_rel_array.incl.pl1 contains pointers  to
  1   101*   all  rm_rel_info  structures  allocated. It is used for searching
  1   102*   for the appropriate  structure.  This  array  is  pointed  to  by
  1   103*   rm_db_info. There are two arrays, one for perm rels, one for temp
  1   104*   rels.
  1   105*
  1   106*   The      rm_rel_info      structure      points      to       the
  1   107*   mdbm_rm_attr_info.incl.pl1  structures,  one  for  each attribute
  1   108*   appearing in this view of the relation. Each  of  these  in  turn
  1   109*   point  to a mdbm_rm_domain_info.incl.pl1 structure for the domain
  1   110*   info for each attr.
  1   111*
  1   112*   Most of the other information here deals with  specifics  of  the
  1   113*   relation's  logical  definition,  such as key and secondary index
  1   114*   attribute inidicators, security permissions, and  tuple  physical
  1   115*   construction details.
  1   116*
  1   117**/
  1   118 
  1   119      dcl	   1 rm_rel_info	      aligned based (rmri_ptr), /* relation information */
  1   120 	     2 name	      char (32),		/* from submodel */
  1   121 	     2 model_name	      char (30),		/* from model */
  1   122 	     2 rel_id	      bit (36) aligned,	/* unique id. */
  1   123 	     2 retrieve	      bit (1) unal,		/* operations allowed by this view */
  1   124 	     2 modify	      bit (1) unal,
  1   125 	     2 delete	      bit (1) unal,
  1   126 	     2 store	      bit (1) unal,
  1   127 	     2 total_key	      bit (1) unal,		/* on if view includes full primary key */
  1   128 	     2 indexed	      bit (1) unal,		/* on if exists sec. index */
  1   129 	     2 mdbm_secured	      bit (1) unal,		/* on if mdbm must check security */
  1   130 	     2 status_perm	      bit (1) unal,		/* if user has status. perm. */
  1   131 	     2 append_tuple_perm  bit (1) unal,		/* if user has store perm. */
  1   132 	     2 delete_tuple_perm  bit (1) unal,		/* if user has del. perm. */
  1   133 	     2 unused_perm	      bit (1) unal,		/* for future use. */
  1   134 	     2 last_model_attr_char_var bit (1) unal,	/* on => last model varying attr is char */
  1   135 	     2 reserved	      bit (24) unal,	/* for future use */
  1   136 	     2 num_attr	      fixed bin,		/* total no. of attr. in rel. */
  1   137 	     2 model_num_attr     fixed bin,		/* total attrs in model relation */
  1   138 	     2 nkey_attr	      fixed bin,		/* no. of key attr. */
  1   139 	     2 model_nkey_attr    fixed bin,		/* total number of keys in model */
  1   140 	     2 primary_key_index_id bit (36) aligned,     /* Index id of relation's primary key */
  1   141 	     2 nsec_inds	      fixed bin,		/* no. sec. indexes */
  1   142 	     2 max_key_len	      fixed bin (35),	/* max length (chars) of primary key */
  1   143 	     2 current_tuple_population fixed bin (35),	/* last known total  tuple count for this relation */
  1   144 	     2 last_statistics_update_count fixed bin,	/* number of operations's, since this rels stats were updated */
  1   145 	     2 last_statistics_update_time fixed bin (71),/* last time this rels stats were updated */
  1   146 	     2 last_statistics_update_s_e_ref_num fixed bin (35), /* last select expr ID that updated this rels stats */
  1   147 	     2 ready_mode	      fixed bin,		/* 1 => r, 2 => mr, 3 => u, 4 => l, 5 => sr, 6 => su */
  1   148 	     2 file_type	      fixed bin,		/* 1 => unblocked, 2 => blocked, 3 => temporary */
  1   149 	     2 tuple_id_len	      fixed bin,		/* no. bits in local tuple id */
  1   150 	     2 opening_id	      bit (36) aligned,	/* relation manager opening is */
  1   151 	     2 key_attr_ptrs      (nkey_attr_init refer (rm_rel_info.nkey_attr)) ptr, /* ptrs to key attr. */
  1   152 	     2 attr_ptrs	      (natts_init refer (rm_rel_info.num_attr)) ptr, /* ptrs to all attr. */
  1   153 	     2 id_list_ptr        ptr,		/* Id list for retrieves from the relation */
  1   154                2 scope_flags_ptr    ptr;                    /* pointer to the scope_flags structure for the rel */
  1   155 
  1   156      dcl	   rmri_ptr	      ptr;
  1   157      dcl	   (nkey_attr_init,
  1   158 	   natts_init,
  1   159 	   nvar_atts_init)	      fixed bin;
  1   160 
  1   161 /* END mdbm_rm_rel_info.incl.pl1 */
  1   162 
  1   163 
      237 
      238 
  2     1 /* BEGIN mdbm_rm_db_info.incl.pl1 -- jaw, 11/7/78 */
  2     2 
  2     3 
  2     4 
  2     5 /****^  HISTORY COMMENTS:
  2     6*  1) change(86-08-13,Hergert),, approve(88-06-28,MCR7903),
  2     7*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  2     8*     Removed change of 84-11-02. i.e. replaced even_word_pad.
  2     9*                                                   END HISTORY COMMENTS */
  2    10 
  2    11 
  2    12 /* WARNING
  2    13*          If the rm_db_info structure is changed then the mrds_data_
  2    14*          item saved_res_version MUST be incremented to invalidate all
  2    15*          existing saved resultants
  2    16**/
  2    17 
  2    18 /*  DESCRIPTION:  This  structure   is   based   on   a   segment
  2    19*   {unique_name}.mrds.rdbi that represents the secure portion of the
  2    20*   resultant model that is created partially at database open  time,
  2    21*   (the rm_file_array, and rm_rel_array) and partially at ready_file
  2    22*   time,    (the    rm_file_info,     rm_rel_info,     rm_attr_info,
  2    23*   rm_domain_info, rm_plink_info and rm_clink_info). it's purpose is
  2    24*   to  provide  an  efficient  means  of  accessing  database  model
  2    25*   information, as seen from the possibly submodel view of the user,
  2    26*   and his current state of "files readied". it is the  secure  part
  2    27*   because  it  contains  the  model  information  which needs to be
  2    28*   protected  from  general  knowledge,  and   this   segment   will
  2    29*   eventually  be  capable  of  being in a lower ring. the structure
  2    30*   itself points to four arrays that are  allocated  in  it's  area,
  2    31*   that  in  turn point to the other structures mentions above, also
  2    32*   allocated in  the  rm_db_info.static_area.  the  arrays  are  the
  2    33*   rm_file_array,  and  rm_rel_array. their are a pair for temporary
  2    34*   relations,  initially  empty,  and  a  pair  for   normal   model
  2    35*   files/relations.  the  normal  rm_file_array  is initialized to a
  2    36*   list of all known file names, the rm_rel_array only gets relation
  2    37*   names   as   files  are  readied.  the  rm_file_array  points  to
  2    38*   rm_file_infos for each file (see mdbm_rm_file_info.incl.pl1)  and
  2    39*   the   rm_rel_array   points  to  rm_rel_info  for  each  relation
  2    40*   "readied". (see mdbm_rm_rel_info.incl.pl1). (the  arrays  are  in
  2    41*   mdbm_rm_file_array.incl.pl1  and mdbm_rm_rel_array.incl.pl1). the
  2    42*   file infos point to contained rel infos, the rel infos  point  to
  2    43*   contained  attr  infos,  and  those in turn to domain infos. (see
  2    44*   mdbm_rm_attr_info.incl.pl1   and    mdbm_rm_domain_info.incl.pl1)
  2    45*   foreign     keys    are    represented    by    the    structures
  2    46*   mdbm_rm_plink_info.incl.pl1, and mdbm_rm_clink_info.incl.pl1. the
  2    47*   pathnames  of the model and submodel, if any, are also maintained
  2    48*   in rm_db_info. the pointer to this rm_db_info segment is obtained
  2    49*   from  the  dbcb  segment tructure(see mrds_dbcb.incl.pl1) see the
  2    50*   individual include files for  further  organization  information,
  2    51*   and particular data structures.
  2    52*
  2    53*   HISTORY:
  2    54*
  2    55*   80-02-01 Jim Gray : Modified to put area on even  word  boundary,
  2    56*   so that define_area_ could be used to make it an extensible area
  2    57*
  2    58*   81-1-9 Jim  Gray  :  added  like  reference  to  make  the  phony
  2    59*   resultant in mu_database_index easier to keep, since no reference
  2    60*   to the area is needed.
  2    61*
  2    62*   81-1-12 Jim Gray : added version of submodel used in  opening  to
  2    63*   resultant.
  2    64*
  2    65*   81-05-13 Rickie E. Brinegar: added the administrator bit  to  the
  2    66*   structure.
  2    67*
  2    68*   81-05-28 Jim Gray : removed pointers to file_arrays,  since  they
  2    69*   are  now  combined  into  the rel_array. Removed the control file
  2    70*   info which was unused. Added pointer  to  head  of  domain  list,
  2    71*   which is to be used to insure only one copy of each domain info.
  2    72*
  2    73*   83-05-19 Davids: Added the  saved_res_version element.
  2    74*
  2    75*   84-11-02 Thanh Nguyen:   Replaced  the  even_word_pad   by   the 
  2    76*   ref_name_proc_ptr  to point  to list  of reference  name of  the
  2    77*   check, encode, or decode proc.
  2    78*
  2    79*   CAUTION: The structure entries from db_version to sm_path  should
  2    80*   not  be moved or have their declarations changed because they are
  2    81*   used in the handling of old version database openings.
  2    82*
  2    83*
  2    84**/
  2    85 
  2    86      dcl	   1 rm_db_info	      aligned based (rdbi_ptr), /* data base info, located at base of res. dm. seg. */
  2    87 	     2 data	      like rm_db_info_data,
  2    88 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (rm_db_info.static_area))));
  2    89 
  2    90      dcl	   rdbi_ptr	      ptr;
  2    91 
  2    92      declare 1 rm_db_info_data      based,		/* separate declaration of info, so others can use
  2    93*						   like reference to it without getting the area as well */
  2    94 	     2 db_version	      fixed bin,		/* version no. of db */
  2    95 	     2 sm_version	      fixed bin unal,	/* version of submodel used unal, 0 if model opening */
  2    96 	     2 val_level	      fixed bin unal,	/* validation level for this db. */
  2    97 	     2 db_path	      char (168),		/* abs. path of db. */
  2    98 	     2 sm_path	      char (168),		/* path of submodel or model */
  2    99 	     2 mdbm_secured	      bit (1) unal,		/* ON => database is secured */
  2   100 	     2 administrator      bit (1) unal,		/* ON => user is an administrator */
  2   101 	     2 pad	      bit (34) unal,	/* for future use */
  2   102 	     2 saved_res_version  char (8),		/* version of the saved resultant in the 
  2   103*                                                               dbcb and rdbi segments in the db dir */
  2   104 	     2 domain_list_ptr    ptr,		/* pointer to head of list of domain_info's */
  2   105 	     2 ra_ptr	      ptr,		/* pointer to rel. array */
  2   106 	     2 tra_ptr	      ptr,		/* to rel array for temp rels */
  2   107 	     2 even_word_pad      fixed bin (71) aligned; /* padding to put area on even word boundary */
  2   108 
  2   109 /* END mdbm_rm_db_info.incl.pl1 */
  2   110 
  2   111 
      239 
      240 
  3     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  3     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  3     3*      version number to IOX2. */
  3     4 /* format: style2 */
  3     5 
  3     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  3     7 	     2 version	      character (4) aligned,	/* IOX2 */
  3     8 	     2 name	      char (32),		/* I/O name of this block. */
  3     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  3    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  3    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  3    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  3    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  3    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
  3    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  3    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  3    17 						/* open(p,mode,not_used,s) */
  3    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  3    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  3    20 						/* get_line(p,bufptr,buflen,actlen,s) */
  3    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  3    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
  3    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  3    24 						/* put_chars(p,bufptr,buflen,s) */
  3    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  3    26 						/* modes(p,newmode,oldmode,s) */
  3    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  3    28 						/* position(p,u1,u2,s) */
  3    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  3    30 						/* control(p,order,infptr,s) */
  3    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  3    32 						/* read_record(p,bufptr,buflen,actlen,s) */
  3    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  3    34 						/* write_record(p,bufptr,buflen,s) */
  3    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  3    36 						/* rewrite_record(p,bufptr,buflen,s) */
  3    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  3    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  3    39 						/* seek_key(p,key,len,s) */
  3    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  3    41 						/* read_key(p,key,len,s) */
  3    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
  3    43 						/* read_length(p,len,s) */
  3    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  3    45 						/* open_file(p,mode,desc,not_used,s) */
  3    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  3    47 						/* close_file(p,desc,s) */
  3    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
  3    49 						/* detach(p,desc,s) */
  3    50 
  3    51      declare iox_$iocb_version_sentinel
  3    52 			      character (4) aligned external static;
  3    53 
  3    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
      241 
      242 
      243 get: entry (mcm_dbi, mcm_rmri_ptr, mcm_tuple_var_index, mcm_collection_index,
      244 	mcm_relmgr_create_cursor, mcm_relmgr_open, mcm_storage_ptr,
      245 	mcm_area_ptr, mcm_cursor_ptr, mcm_code);
      246 
      247 
      248 
      249 
      250 
      251 	mcm_code = 0;
      252 
      253 	if mcm_rmri_ptr -> rm_rel_info.opening_id = "0"b
      254 	then call open_relation (mcm_relmgr_open, mcm_rmri_ptr);
      255 
      256 	if mcm_storage_ptr = null ()
      257 	then do;
      258 		call build_storage (mcm_dbi, mcm_ARRAY, mcm_storage_ptr);
      259 		call mu_define_area (mcm_area_ptr, (sys_info$max_seg_size), "cursor_area",
      260 		     "1"b, "0"b, "0"b, "0"b, mcm_code);
      261 		if mcm_code ^= 0
      262 		then call error_exit (mcm_code, "Could not get a temp seg for cursor storage.");
      263 	     end;
      264 
      265 	mcm_key = addr (mcm_rmri_ptr -> rm_rel_info.opening_id) -> mcm_c4b ||
      266 	     addr (mcm_tuple_var_index) -> mcm_c4b;
      267 
      268 	if storage_type (mcm_storage_ptr) = mcm_ARRAY
      269 	then do;
      270 		call array_search (mcm_key, mcm_storage_ptr, mcm_cursor_index, mcm_found);
      271 		if ^mcm_found
      272 		then do;
      273 			call create_cursor (mcm_rmri_ptr -> rm_rel_info.opening_id, mcm_collection_index,
      274 			     mcm_relmgr_create_cursor, mcm_area_ptr, mcm_cursor_ptr);
      275 			if mcm_storage_ptr -> mcm_cursor_array.num = mcm_MAX_NUM_FOR_ARRAY_STORAGE
      276 			then do;
      277 				call convert_array_to_vfile (mcm_storage_ptr);
      278 				call vfile_search (mcm_key, mcm_storage_ptr, mcm_unused1, mcm_unused2);
      279 				call add_cursor_to_vfile (mcm_storage_ptr, mcm_cursor_ptr);
      280 			     end;
      281 			else call add_cursor_to_array (mcm_storage_ptr, mcm_key, mcm_cursor_ptr, mcm_cursor_index);
      282 		     end;
      283 		else mcm_cursor_ptr = mcm_storage_ptr -> mcm_cursor_array.cursors (mcm_cursor_index).cursor_ptr;
      284 	     end;
      285 	else do;
      286 		call vfile_search (mcm_key, mcm_storage_ptr, mcm_cursor_ptr, mcm_found);
      287 		if ^mcm_found
      288 		then do;
      289 			call create_cursor (mcm_rmri_ptr -> rm_rel_info.opening_id, mcm_collection_index,
      290 			     mcm_relmgr_create_cursor, mcm_area_ptr, mcm_cursor_ptr);
      291 			call add_cursor_to_vfile (mcm_storage_ptr, mcm_cursor_ptr);
      292 		     end;
      293 	     end;
      294 
      295 
      296 
      297 
      298 
      299 	goto exit;
      300 
      301 destroy_all_no_free: entry (mcm_storage_ptr, mcm_area_ptr, mcm_relmgr_close, mcm_code);
      302 
      303 
      304 
      305 
      306 
      307 	mcm_code = 0;
      308 
      309 	if storage_type (mcm_storage_ptr) = mcm_ARRAY
      310 	then call close_rels_from_array (mcm_storage_ptr, mcm_relmgr_close);
      311 	else call close_rels_from_vfile (mcm_storage_ptr, mcm_relmgr_close);
      312 
      313 	call destroy_storage (mcm_storage_ptr);
      314 
      315 /* mu_define_area uses get_temp_segment_ to get the temp seg the area is based on */
      316 
      317 	call release_temp_segment_ ("cursor_area", mcm_area_ptr, mcm_code);
      318 	if mcm_code ^= 0
      319 	then call error_exit (mcm_code, "Could not release the temp seg used to store the cursors.");
      320 
      321 	goto exit;
      322 
      323 
      324 
      325 
      326 
      327 
      328 
      329 
      330 
      331 
      332 
      333 
      334 
      335 destroy_and_free_on_opening_id: entry (mcm_opening_id, mcm_area_ptr, mcm_storage_ptr,
      336 	mcm_relmgr_destroy_cursor, mcm_relmgr_close, mcm_code);
      337 
      338 
      339 
      340 
      341 
      342 	mcm_code = 0;
      343 
      344 	if storage_type (mcm_storage_ptr) = mcm_ARRAY
      345 	then call delete_cursors_from_array (mcm_opening_id, mcm_area_ptr, mcm_storage_ptr, mcm_relmgr_destroy_cursor);
      346 	else call delete_cursors_from_vfile (mcm_opening_id, mcm_area_ptr, mcm_storage_ptr, mcm_relmgr_destroy_cursor);
      347 
      348 	call mcm_relmgr_close (mcm_opening_id, mcm_code);
      349 	if mcm_code ^= 0
      350 	then call error_exit (mcm_code, "Could not close the open relation");
      351 
      352 	goto exit;
      353 
      354 cleanup_storage: entry (mcm_storage_ptr, mcm_area_ptr, mcm_code);
      355 
      356 
      357 
      358 
      359 
      360 	mcm_code = 0;
      361 
      362 	call destroy_storage (mcm_storage_ptr);
      363 
      364 /* mu_define_area uses get_temp_segment_ to get the temp seg the area is based on */
      365 
      366 	call release_temp_segment_ ("cursor_area", mcm_area_ptr, mcm_code);
      367 	if mcm_code ^= 0
      368 	then call error_exit (mcm_code, "Could not release the temp seg used to store the cursors.");
      369 
      370 	goto exit;
      371 
      372 exit:
      373 	return;
      374 
      375 open_relation: proc (or_relmgr_open, or_rmri_ptr);
      376 
      377 /*
      378*   This  procedure  calls  the  relation  manager  entry to open the
      379*   relation.   it determines the path to the relation by obtaining a
      380*   pointer  to  the rm_db_info structure which has as an element the
      381*   database  path,  this  coupled  with the relation's name from the
      382*   rm_rel_info  structure  gives  the  path.   The  pointer  to  the
      383*   rm_db_info  structure  is  obtained by forming a pointer based on
      384*   the  seg_no  of  the or_rmri_ptr pointer and a 0 bit offset, i.e.
      385*   the  rm_rel_info structure is allocated in the static area set up
      386*   in the rm_db_info structure.
      387**/
      388 
      389 /* PARAMETERS */
      390 
      391 	dcl     or_relmgr_open	 entry options (variable);
      392 						/* (input) relation_manager entry used to open the realtion */
      393 	dcl     or_rmri_ptr		 ptr;		/* (input) pointer to the relation's rm_rel_info structure */
      394 
      395 /* AUTOMATIC */
      396 
      397 	dcl     or_code		 fixed bin (35);	/* standard error code */
      398 	dcl     or_rdbi_ptr		 ptr;		/* pointer to the database's rm_db_info structure */
      399 
      400 
      401 
      402 
      403 
      404 	or_rdbi_ptr = pointer (or_rmri_ptr, 0);
      405 
      406 	call or_relmgr_open (or_rdbi_ptr -> rm_db_info.db_path,
      407 	     or_rmri_ptr -> rm_rel_info.model_name,
      408 	     or_rmri_ptr -> rm_rel_info.opening_id,
      409 	     or_code);
      410 	if or_code ^= 0
      411 	then call error_exit (or_code, "Could not open the relation " || or_rmri_ptr -> rm_rel_info.name);
      412 
      413 	return;
      414 
      415      end /* open_relation */;
      416 
      417 build_storage: proc (bs_dbi, bs_storage_type, bs_storage_ptr);
      418 
      419 /* 
      420*   This  procedure  goes out and gets the space that will be used to
      421*   store the cursor pointers.  If the cursors are to be stored in an
      422*   array  a  temp  segment  is  obtained  other wise a keyed file is
      423*   attached  and  opened.   The location of the storage (temp seg or
      424*   keyed  file)  will be in the opening temp dir.  If a temp segment
      425*   is  used  than  this  routine  will also initialize the number of
      426*   cursors to 0 and the version of the structure.  No initialization
      427*   is needed for the keyed file.
      428**/
      429 
      430 /* GLOBALS
      431*
      432*   mcm_ARRAY		indicates a storage type of array
      433*   mcm_PROC_NAME    	procedure's name
      434*   mcm_dbi		data base index
      435*   mcm_cursor_array	          structure containing the array of cursors to be overlaid on the temp_seg
      436**/
      437 
      438 /* PARAMETERS */
      439 
      440 	dcl     bs_dbi		 fixed bin (35);	/* (input) database index - used for array storage only */
      441 	dcl     bs_storage_type	 fixed bin;	/* (input) indicates whether a temp_seg or
      442*                                                                        keyed file is to be built */
      443 	dcl     bs_storage_ptr	 ptr;		/* (output) either a ptr to the temp_seg or the file's iocb */
      444 
      445 /* AUTOMATIC */
      446 
      447 	dcl     bs_code		 fixed bin (35);	/* standard error code */
      448 	dcl     bs_dbi_char		 char (4);	/* character representation of the database index */
      449 	dcl     bs_temp_dir		 char (168);	/* path of the opening temp dir, dir
      450*                                                               that will contain the storage area */
      451 
      452 /* CONSTANTS */
      453 
      454 	dcl     bs_KSQU		 fixed bin init (10) internal static options (constant);
      455 						/* indicates an iox opening mode of keyed-sequential-update */
      456 
      457 	if bs_storage_type = mcm_ARRAY
      458 	then do;
      459 		bs_dbi_char = ltrim (char (bs_dbi));
      460 		call mu_temp_segments$get_temp_segment (mcm_dbi, mcm_PROC_NAME || bs_dbi_char, bs_storage_ptr, bs_code);
      461 		if bs_code ^= 0
      462 		then call error_exit (bs_code, "Could not get a temp_segment for cursor array storage");
      463 		bs_storage_ptr -> mcm_cursor_array.num = 0;
      464 		bs_storage_ptr -> mcm_cursor_array.version = "ARAY";
      465 		bs_storage_ptr -> mcm_cursor_array.dbi_char = bs_dbi_char;
      466 		bs_storage_ptr -> mcm_cursor_array.mbz = "0"b;
      467 	     end;
      468 	else do;
      469 		bs_temp_dir = mrds_dsl_resultant_storage$get_opening_temp_dir (mcm_dbi, bs_code);
      470 		if bs_code ^= 0
      471 		then call error_exit (bs_code, "Could not get the opening temp dir");
      472 		call iox_$attach_name (ltrim (char (mcm_dbi)) || ".mcm." || unique_chars_ ("0"b), bs_storage_ptr,
      473 		     "vfile_ " || rtrim (bs_temp_dir) || ">" || ltrim (char (mcm_dbi)) ||
      474 		     ".mcm." || unique_chars_ ("0"b),
      475 		     null (), bs_code);
      476 		if bs_code ^= 0
      477 		then call error_exit (bs_code, "Could not attach a temp file for cursor storage");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 TERS */
      571 
      572 	dcl     st_storage_ptr	 ptr;		/* (input) either a ptr to the temp_seg or the file's iocb */
      573 
      574 /* AUTOMATIC */
      575 
      576 	dcl     st_return_type	 fixed bin;	/* indicats the type of storage that storage_ptr points to */
      577 
      578 /* BASED */
      579 
      580 	dcl     st_c4b		 char (4) based;	/* 4 character overlay for the version element */
      581 
      582 
      583 
      584 
      585 
      586 	if st_storage_ptr -> st_c4b = "IOX2"
      587 	then st_return_type = mcm_VFILE;
      588 	else
      589 	     if st_storage_ptr -> st_c4b = "ARAY"
      590 	then st_return_type = mcm_ARRAY;
      591 	else call error_exit (mrds_error_$unknown_cursor_storage, "A cursor storage pointer is bad.");
      592 
      593 	return (st_return_type);
      594 
      595      end /* storage_type */;
      596 
      597 array_search: proc (as_key, as_storage_ptr, as_index, as_found);
      598 
      599 /*
      600*   This  procedure  performs  a binary search on the cursor array to
      601*   locate  a  given  cursor  or  determine where it should be placed
      602*   after it is gotten from the relation_manager.  The case of a zero
      603*   length  array  is special cased because the search algorithm will
      604*   not  return the correct index in which to put the new element for
      605*   this condition.
      606**/
      607 
      608 /* GLOBALS
      609*
      610*   mcm_cursor_array          	structure containing the array of cursors to be overlaid on the temp_seg
      611**/
      612 
      613 /* PARAMETERS */
      614 
      615 	dcl     as_key		 char (12);	/* (input) the key identifing which cursor is wanted */
      616 	dcl     as_storage_ptr	 ptr;		/* (input) ptr to the temp_seg containing the cursor array */
      617 	dcl     as_index		 fixed bin;	/* (output) index in the array of the requested cursor or
      618*                                                                        index of where it should placed. */
      619 	dcl     as_found		 bit (1);		/* (output) "1"b ==> cursor was found,
      620*                                                                        "0"b ==> it needs to be gotten */
      621 
      622 /* AUTOMATIC */
      623 
      624 	dcl     as_higher_index	 fixed bin;	/* highest element of the binary search */
      625 	dcl     as_key_larger	 bit (1) aligned;	/* "1"b => if as_key > key at as_middle_index */
      626 	dcl     as_lower_index	 fixed bin;	/* lower index of the binary search */
      627 	dcl     as_middle_index	 fixed bin;	/* middle element of the search */
      628 
      629 
      630 
      631 
      632 
      633 	as_found = "0"b;
      634 	as_index = 0;
      635 
      636 	if as_storage_ptr -> mcm_cursor_array.num = 0
      637 	then as_index = 1;
      638 	else do;
      639 		as_lower_index = 1;
      640 		as_higher_index = as_storage_ptr -> mcm_cursor_array.num;
      641 		do while (^as_found & as_lower_index <= as_higher_index);
      642 		     as_middle_index = divide ((as_higher_index + as_lower_index), 2, 35, 0);
      643 		     if as_key > as_storage_ptr -> mcm_cursor_array.cursors (as_middle_index).key
      644 		     then do;
      645 			     as_lower_index = as_middle_index + 1;
      646 			     as_key_larger = "1"b;
      647 			end;
      648 		     else
      649 			if as_key = as_storage_ptr -> mcm_cursor_array.cursors (as_middle_index).key
      650 		     then as_found = "1"b;
      651 		     else do;
      652 			     as_higher_index = as_middle_index - 1;
      653 			     as_key_larger = "0"b;
      654 			end;
      655 		end;
      656 		as_index = as_middle_index;
      657 		if as_key_larger & ^as_found
      658 		then as_index = as_index + 1;
      659 	     end;
      660 
      661 	return;
      662 
      663      end /* array_search */;
      664 
      665 vfile_search: proc (vs_key, vs_storage_ptr, vs_cursor_ptr, vs_found);
      666 
      667 /*
      668*   This  procedure  searches  the  keyed file for the key associated
      669*   with the requested cursor.  If the key is not found it leaves the
      670*   vfile  in  a  state  where  cursor  record  can be added with the
      671*   correct key.
      672**/
      673 
      674 /* GLOBALS
      675*
      676*   error_table_$no_record     error returned if seek_key cannot find the key
      677*   mcm_CURSOR_PTR_LENGTH	length of a cursor_ptr in bytes
      678**/
      679 
      680 /* PARAMETERS */
      681 
      682 	dcl     vs_key		 char (12);	/* (input) key identifing which cursor is wanted */
      683 	dcl     vs_storage_ptr	 ptr;		/* (input) points to the iocb for the
      684*                                                                       file containing the cursors */
      685 	dcl     vs_cursor_ptr	 ptr;		/* (output) null if the key wasn't found or a cursor_ptr */
      686 	dcl     vs_found		 bit (1);		/* (output) "1"b => the key was found,
      687*                                                                        "0"b => the key was not found */
      688 
      689 /* AUTOMATIC */
      690 
      691 	dcl     vs_code		 fixed bin (35);	/* standard error code */
      692 	dcl     vs_unused1		 fixed bin (21);	/* unused output parameter from iox_ calls */
      693 	dcl     vs_vfile_key	 char (256) varying;/* type of key used by vfile */
      694 
      695 
      696 
      697 
      698 
      699 	vs_found = "0"b;
      700 	vs_cursor_ptr = null ();
      701 
      702 	vs_vfile_key = vs_key;
      703 
      704 	call iox_$seek_key (vs_storage_ptr, vs_vfile_key, vs_unused1, vs_code);
      705 	if vs_code ^= 0
      706 	then do;
      707 		if vs_code ^= error_table_$no_record
      708 		then call error_exit (vs_code, "Error while adding key to vfile.");
      709 	     end;
      710 	else do;
      711 		vs_found = "1"b;
      712 		call iox_$read_record (vs_storage_ptr, addr (vs_cursor_ptr), mcm_CURSOR_PTR_LENGTH,
      713 		     vs_unused1, vs_code);
      714 		if vs_code ^= 0
      715 		then call error_exit (vs_code, "Unable to read a cursor record.");
      716 	     end;
      717 
      718 	return;
      719 
      720      end /* vfile_search */;
      721 
      722 add_cursor_to_array: proc (acta_storage_ptr, acta_key, acta_cursor_ptr, acta_index);
      723 
      724 /*
      725*   This routine adds a <key cursor_ptr> element to the cursor array.
      726**/
      727 
      728 /* GLOBALS
      729*
      730*   mcm_CURSOR_ARRAY_ELEMENT_SIZE   number of bits used for a cursor element (key and pointer)
      731*   mcm_cursor_array                structure containing the array of cursors to be overlaid on the temp_seg
      732*
      733*/* PARAMETERS */
      734 
      735 	dcl     acta_storage_ptr	 ptr;		/* (input) pointer to the cursor array structure */
      736 	dcl     acta_key		 char (12);	/* (input) the cursor_ptr's key */
      737 	dcl     acta_cursor_ptr	 ptr;		/* (input) the cursor pointer */
      738 	dcl     acta_index		 fixed bin;	/* (input) index where the cursor should be placed */
      739 
      740 /* AUTOMATIC */
      741 
      742 	dcl     acta_move_length	 fixed bin (21);	/* number of chars that need to be moved */
      743 
      744 
      745 
      746 
      747 	if acta_storage_ptr -> mcm_cursor_array.num >= acta_index
      748 	then do;
      749 		acta_storage_ptr -> mcm_cursor_array.num = acta_storage_ptr -> mcm_cursor_array.num + 1;
      750 		acta_move_length = mcm_CURSOR_ARRAY_ELEMENT_SIZE *
      751 		     (acta_storage_ptr -> mcm_cursor_array.num - acta_index);
      752 		call move_chars (addr (acta_storage_ptr -> mcm_cursor_array.cursors (acta_index)), acta_move_length,
      753 		     addr (acta_storage_ptr -> mcm_cursor_array.cursors (acta_index + 1)),
      754 		     addr (acta_storage_ptr -> mcm_cursor_array.temp_space_begins));
      755 	     end;
      756 	else acta_storage_ptr -> mcm_cursor_array.num = acta_storage_ptr -> mcm_cursor_array.num + 1;
      757 
      758 	acta_storage_ptr -> mcm_cursor_array.cursors (acta_index).key = acta_key;
      759 	acta_storage_ptr -> mcm_cursor_array.cursors (acta_index).cursor_ptr = acta_cursor_ptr;
      760 
      761 	return;
      762 
      763      end /* add_cursor_to_array */;
      764 
      765 move_chars: proc (mc_source_ptr, mc_length, mc_target_ptr, mc_temp_space_ptr);
      766 
      767 /*
      768*   This routine shifts a string  of  mc_length  characters  starting
      769*   from  mc_source_ptr  to  a  point starting with mc_target_ptr. It
      770*   does this by copying the string into a temp area and then copying
      771*   it back, this way there are no problems with  source  and  target
      772*   strings overlaping.
      773**/
      774 
      775 /* GLOBALS
      776*
      777*   mcm_cursor_array		structure containing the array of cursors, or in this
      778*			case the string of chars to eb shifted
      779**/
      780 
      781 /* PARAMETERS */
      782 
      783 	dcl     mc_source_ptr	 ptr;		/* (input) location of the first character to be moved */
      784 	dcl     mc_length		 fixed bin (21);	/* (input) number of characters to be moved */
      785 	dcl     mc_target_ptr	 ptr;		/* (input) location of the first character after the move */
      786 	dcl     mc_temp_space_ptr	 ptr;		/* (input) location ofthe first character of the temp space */
      787 
      788 /* BASED */
      789 
      790 	dcl     mc_chars		 char (mc_length) based unaligned;
      791 
      792 
      793 
      794 
      795 	mc_temp_space_ptr -> mc_chars = mc_source_ptr -> mc_chars;
      796 	mc_target_ptr -> mc_chars = mc_temp_space_ptr -> mc_chars;
      797 
      798 	return;
      799 
      800      end /* move_chars */;
      801 
      802 add_cursor_to_vfile: proc (actv_storage_ptr, actv_cursor_ptr);
      803 
      804 /*
      805*   This  procedure  adds  the  cursor_ptr  record  to the keyed file
      806*   storage  structure.   The  position in the keyed file has already
      807*   been set up by the vfile_search procedure.
      808**/
      809 
      810 /* GLOBALS
      811*
      812*   mcm_CURSOR_PTR_LENGTH	length of a cursor_ptr in bytes
      813**/
      814 
      815 /* PARAMETERS */
      816 
      817 	dcl     actv_storage_ptr	 ptr;		/* (input) pointer to the keyed file's iocb */
      818 	dcl     actv_cursor_ptr	 ptr;		/* (input) pointer to the cursor - the record to be written */
      819 
      820 /* AUTOMATIC */
      821 
      822 	dcl     actv_code		 fixed bin (35);	/* standard error code */
      823 
      824 
      825 
      826 
      827 
      828 	call iox_$write_record (actv_storage_ptr, addr (actv_cursor_ptr), mcm_CURSOR_PTR_LENGTH, actv_code);
      829 	if actv_code ^= 0
      830 	then call error_exit (actv_code, "Error while loading key into vfile.");
      831 
      832 	return;
      833 
      834      end /* add_cursor_to_vfile */;
      835 
      836 convert_array_to_vfile: proc (catv_storage_ptr);
      837 
      838 /*
      839*   This procedure converts from a array storage type to a keyed file
      840*   storage  type.   It first builds the keyed file storage space and
      841*   then copies each element from the cursor array and writes it into
      842*   the    keyed    file.     The    procedures    vfile_search   and
      843*   add_cursor_to_vfile  are  used to eliminate code duplication that
      844*   would  otherwise  be  required.   When  all the cursors have been
      845*   moved the storage space associated with the array is destroyed.
      846**/
      847 
      848 /* GLOBALS
      849*
      850*   mcm_cursor_array           structure containing the array of cursors to be overlaid on the temp_seg
      851*   mcm_PROC_NAME	          procedure's name
      852*   mcm_VFILE		indicates a storage type of keyed file
      853**/
      854 
      855 /* PARAMETERS */
      856 
      857 	dcl     catv_storage_ptr	 ptr;		/* (input/output) input => ptr to the array storage */
      858 						/*                output => ptr to the keyed file's iocb */
      859 
      860 /* AUTOMATIC */
      861 
      862 	dcl     catv_array_storage_ptr ptr;		/* pointer to array storage */
      863 	dcl     catv_i		 fixed bin;	/* loop index */
      864 	dcl     catv_unused1	 ptr;		/* unused output from vfile_search -
      865*                                                               we know the value will be null */
      866 	dcl     catv_unused2	 bit (1);		/* unused output from vfile_search -
      867*                                                               we know the cursor won't be found */
      868 	dcl     catv_vfile_storage_ptr ptr;		/* pointer to keyed file's iocb */
      869 
      870 	catv_array_storage_ptr = catv_storage_ptr;
      871 
      872 	call build_storage (0, mcm_VFILE, catv_vfile_storage_ptr);
      873 
      874 	do catv_i = 1 to catv_array_storage_ptr -> mcm_cursor_array.num;
      875 	     call vfile_search (catv_array_storage_ptr -> mcm_cursor_array.cursors (catv_i).key,
      876 		catv_vfile_storage_ptr, catv_unused1, catv_unused2);
      877 	     call add_cursor_to_vfile (catv_vfile_storage_ptr,
      878 		catv_array_storage_ptr -> mcm_cursor_array.cursors (catv_i).cursor_ptr);
      879 	end;
      880 
      881 	catv_storage_ptr = catv_vfile_storage_ptr;
      882 
      883 	call destroy_storage (catv_array_storage_ptr);
      884 
      885 	return;
      886 
      887      end /* convert_array_to_vfile */;
      888 
      889 create_cursor: proc (cc_rel_opening_id, cc_collection_id, cc_relmgr_create_cursor, cc_area_ptr, cc_cursor_ptr);
      890 
      891 /*
      892*   This procedure calls the relation_manager to get a cursor.
      893**/
      894 
      895 /* PARAMETERS */
      896 
      897 	dcl     cc_rel_opening_id	 bit (36) aligned;	/* (input) relation manager opening id for the relation */
      898 	dcl     cc_collection_id	 bit (36) aligned;	/* (input) collection id of the collection to
      899*                                                                       be associated with the cursor */
      900 	dcl     cc_relmgr_create_cursor entry options (variable);
      901 						/* (input) entry used to get the cursor */
      902 	dcl     cc_area_ptr		 ptr;		/* (input) pointer to area where cursor is to be allocated */
      903 	dcl     cc_cursor_ptr	 ptr;		/* (output) pointer to the cursor */
      904 
      905 /* AUTOMATIC */
      906 
      907 	dcl     cc_code		 fixed bin (35);	/* standard error code */
      908 
      909 
      910 
      911 
      912 
      913 	call cc_relmgr_create_cursor (cc_rel_opening_id,
      914 	     cc_area_ptr, cc_cursor_ptr, cc_code);
      915 	if cc_code ^= 0
      916 	then call error_exit (cc_code, "Could not obtain a cursor.");
      917 
      918 	return;
      919 
      920      end /* create_cursor */;
      921 
      922 close_rels_from_array: proc (crfa_storage_ptr, crfa_relmgr_close);
      923 
      924 /*
      925*   This  procedure closes the relations that are associated with the
      926*   cursors whose pointers are in the cursor array.
      927**/
      928 
      929 /* GLOBALS 
      930*
      931*   mcm_cursor_array		structure containing the array of cursors
      932*   mcm_b36b                   b36 overlay
      933**/
      934 
      935 /* PARAMETERS */
      936 
      937 	dcl     crfa_storage_ptr	 ptr;		/* (input) pointer to the array storage */
      938 	dcl     crfa_relmgr_close	 entry options (variable); /* (input) entry used to close a relation */
      939 
      940 /* AUTOMATIC */
      941 
      942 	dcl     crfa_close_code	 fixed bin (35);	/* last non-zero error code returned from crfa_relmgr_close */
      943 	dcl     crfa_code		 fixed bin (35);	/* standard error code */
      944 	dcl     crfa_i		 fixed bin;	/* loop index */
      945 	dcl     crfa_last_opening_id	 bit (36);	/* opening id of the last relation closed */
      946 	dcl     crfa_opening_id	 bit (36);	/* opening id of the relation to be closed next */
      947 
      948 
      949 
      950 
      951 
      952 
      953 	crfa_last_opening_id = "0"b;
      954 	crfa_close_code = 0;
      955 	do crfa_i = 1 to crfa_storage_ptr -> mcm_cursor_array.num;
      956 	     crfa_opening_id = addr (crfa_storage_ptr -> mcm_cursor_array.cursors (crfa_i).key) -> mcm_b36b;
      957 	     if crfa_last_opening_id ^= crfa_opening_id
      958 	     then do;
      959 		     call crfa_relmgr_close (crfa_opening_id, crfa_code);
      960 		     if crfa_code ^= 0
      961 		     then crfa_close_code = crfa_code;
      962 		     crfa_last_opening_id = crfa_opening_id;
      963 		end;
      964 	end;
      965 
      966 	if crfa_close_code ^= 0
      967 	then call error_exit (crfa_close_code, "Error while closing relations, not all relations have been closed.");
      968 
      969 	return;
      970 
      971      end /* close_rels_from_array */;
      972 
      973 close_rels_from_vfile: proc (crfv_storage_ptr, crfv_relmgr_close);
      974 
      975 /*
      976*   This  procedure closes the relations that are associated with the
      977*   cursors whose pointers are in the vfile.
      978**/
      979 
      980 /* GLOBALS
      981*
      982*   mcm_cursor_array
      983*   mcm_b36
      984**/
      985 
      986 /* PARAMETERS */
      987 
      988 	dcl     crfv_storage_ptr	 ptr;		/* (input) points to the iocb for
      989*                                                                       the file containing the cursors */
      990 	dcl     crfv_relmgr_close	 entry options (variable);
      991 						/* (input) entry used to close the relations */
      992 
      993 /* AUTOMATIC */
      994 
      995 	dcl     crfv_close_code	 fixed bin (35);	/* last non-zero error code returned from crfv_relmgr_close */
      996 	dcl     crfv_code		 fixed bin (35);	/* standard error code */
      997 	dcl     crfv_last_opening_id	 bit (36);	/* opening id of last relation closed */
      998 	dcl     crfv_key		 char (256) varying;/* cursor_key returned from the vfile */
      999 	dcl     crfv_unused1	 fixed bin (21);	/* unused output from the call to iox_$read_key */
     1000 	dcl     crfv_opening_id	 bit (36);	/* opening id of the next relation to be closed */
     1001 
     1002 /* CONSTANTS */
     1003 
     1004 	dcl     crfv_BOF		 fixed bin init (-1) internal static options (constant);
     1005 						/* indicates that the file is to be
     1006*                                                               positioned to the first record */
     1007 	dcl     crfv_SKIP_RECORD	 fixed bin init (0) internal static options (constant);
     1008 
     1009 /* indicates that the file is to be
     1010*						   positioned down 1 record */
     1011 
     1012 	call iox_$position (crfv_storage_ptr, crfv_BOF, 0, crfv_code);
     1013 	if crfv_code ^= 0
     1014 	then call error_exit (crfv_code, "Could not position to begining of key tree when destroying cursor pointers.");
     1015 
     1016 	call iox_$read_key (crfv_storage_ptr, crfv_key, crfv_unused1, crfv_code);
     1017 	if crfv_code ^= 0 & crfv_code ^= error_table_$end_of_info
     1018 	then call error_exit (crfv_code, "Could not read key from key tree.");
     1019 
     1020 	crfv_last_opening_id = "0"b;
     1021 	crfv_close_code = 0;
     1022 
     1023 	do while (crfv_code = 0);
     1024 	     crfv_opening_id = addr (crfv_key) -> mcm_b36b;
     1025 	     if crfv_last_opening_id ^= crfv_opening_id
     1026 	     then do;
     1027 		     call crfv_relmgr_close (crfv_opening_id, crfv_code);
     1028 		     if crfv_code ^= 0
     1029 		     then crfv_close_code = crfv_code;
     1030 		     crfv_last_opening_id = crfv_opening_id;
     1031 		end;
     1032 	     call iox_$position (crfv_storage_ptr, crfv_SKIP_RECORD, 1, crfv_code);
     1033 	     if crfv_code ^= 0 & crfv_code ^= error_table_$end_of_info
     1034 	     then call error_exit (crfv_code, "Could not position to next record while closing relations.");
     1035 
     1036 	     call iox_$read_key (crfv_storage_ptr, crfv_key, crfv_unused1, crfv_code);
     1037 	     if crfv_code ^= 0 & crfv_code ^= error_table_$end_of_info
     1038 	     then call error_exit (crfv_code, "Could not read key from key tree.");
     1039 	end;
     1040 
     1041 	if crfv_close_code ^= 0
     1042 	then call error_exit (crfv_close_code, "Error while closing relations, not all relations have been closed.");
     1043 	return;
     1044 
     1045      end /* close_rels_from_vfile */;
     1046 
     1047 delete_cursors_from_array: proc (dcfa_opening_id, dcfa_area_ptr, dcfa_storage_ptr, dcfa_relmgr_destroy_cursor);
     1048 
     1049 /*
     1050*   This procedure destroys all  cursors  assocaiated  with  a  given
     1051*   opening id and removes the cursor_ptrs from the array.
     1052**/
     1053 
     1054 /* GLOBAL
     1055*
     1056*   mcm_c4b		     4 character overlay
     1057*   mcm_cursor_array		     structure containing the array of cursors
     1058*   mcm_CURSOR_ARRAY_ELEMENT_SIZE   number of bits used for cursor element (key and pointer)
     1059**/
     1060 
     1061 /* PARAMETERS */
     1062 
     1063 	dcl     dcfa_opening_id	 bit (36) aligned;	/* (input) opening id of cursors to be deleted */
     1064 	dcl     dcfa_area_ptr	 ptr;		/* (input) pointer to area where the
     1065*                                                                       cursors have been allocated */
     1066 	dcl     dcfa_storage_ptr	 ptr;		/* (input) pointer to cursor ptr storage structure */
     1067 	dcl     dcfa_relmgr_destroy_cursor entry options (variable);
     1068 						/* (input) relation manager entry to destroy a cursor */
     1069 
     1070 /* AUTOMATIC */
     1071 
     1072 	dcl     dcfa_code		 fixed bin (35);	/* error code */
     1073 	dcl     dcfa_cursor_index_1	 fixed bin;	/* index into the array of the first
     1074*                                                               cursor with the opening id */
     1075 	dcl     dcfa_cursor_index_2	 fixed bin;	/* index into the array of the last
     1076*                                                               cursor with the opening id */
     1077 	dcl     dcfa_key		 char (12);	/* key containing only the opening id, so that
     1078*                                                               a search will find the first key with that opening id. */
     1079 	dcl     dcfa_num_cursors_being_deleted fixed bin; /* number of cursors being deleted from the array */
     1080 	dcl     dcfa_unused1	 bit (1);		/* output from array_search, we know the key won't be found */
     1081 
     1082 	unspec (dcfa_key) = "0"b;
     1083 	substr (dcfa_key, 1, 4) = addr (dcfa_opening_id) -> mcm_c4b;
     1084 	call array_search (dcfa_key, dcfa_storage_ptr, dcfa_cursor_index_1, dcfa_unused1);
     1085 	dcfa_cursor_index_2 = dcfa_cursor_index_1;
     1086 	do while ((addr (dcfa_storage_ptr -> mcm_cursor_array.cursors (dcfa_cursor_index_2).key) -> mcm_c4b =
     1087 	     addr (dcfa_opening_id) -> mcm_c4b)
     1088 	     & (dcfa_cursor_index_2 <= dcfa_storage_ptr -> mcm_cursor_array.num));
     1089 	     call dcfa_relmgr_destroy_cursor (
     1090 		dcfa_storage_ptr -> mcm_cursor_array.cursors (dcfa_cursor_index_2).cursor_ptr,
     1091 		dcfa_area_ptr, dcfa_code);
     1092 	     if dcfa_code ^= 0
     1093 	     then call error_exit (dcfa_code, "Could not destroy a cursor.");
     1094 	     dcfa_cursor_index_2 = dcfa_cursor_index_2 + 1;
     1095 	end;
     1096 	dcfa_num_cursors_being_deleted = dcfa_cursor_index_2 - dcfa_cursor_index_1;
     1097 	call move_chars (addr (dcfa_storage_ptr -> mcm_cursor_array.cursors (dcfa_cursor_index_2)),
     1098 	     (dcfa_storage_ptr -> mcm_cursor_array.num - dcfa_cursor_index_2 + 1) * mcm_CURSOR_ARRAY_ELEMENT_SIZE,
     1099 	     addr (dcfa_storage_ptr -> mcm_cursor_array.cursors (dcfa_cursor_index_1)),
     1100 	     addr (dcfa_storage_ptr -> mcm_cursor_array.temp_space_begins));
     1101 	dcfa_storage_ptr -> mcm_cursor_array.num =
     1102 	     dcfa_storage_ptr -> mcm_cursor_array.num - dcfa_num_cursors_being_deleted;
     1103 
     1104 	return;
     1105 
     1106      end /* delete_cursors_from_array */;
     1107 
     1108 delete_cursors_from_vfile: proc (dcfv_opening_id, dcfv_area_ptr, dcfv_storage_ptr, dcfv_relmgr_destroy_cursor);
     1109 
     1110 /*
     1111*   This procedure destroys all cursors associated with a given
     1112*   opening id and removes the cursors from the vfile.
     1113**/
     1114 
     1115 /* GLOBAL 
     1116*
     1117*   mcm_c4b		4 character overlay
     1118*   mcm_CURSOR_PTR_LENGTH	length of a cursor_ptr ==> 2 words or 8 bytes
     1119**/
     1120 
     1121 /* PARAMETERS */
     1122 
     1123 	dcl     dcfv_opening_id	 bit (36) aligned;	/* (input) opening id of cursors to be deleted */
     1124 	dcl     dcfv_area_ptr	 ptr;		/* (input) pointer to area where the
     1125*                                                                       cursors have been allocated */
     1126 	dcl     dcfv_storage_ptr	 ptr;		/* (input) pointer to cursor ptr storage
     1127*                                                                       structure, an iocb in this case */
     1128 	dcl     dcfv_relmgr_destroy_cursor entry options (variable);
     1129 						/* (input) relation manager entry to destroy a cursor */
     1130 
     1131 /* AUTOMATIC */
     1132 
     1133 	dcl     dcfv_code		 fixed bin (35);	/* standard error code */
     1134 	dcl     dcfv_stored_cursor_ptr ptr;		/* cursor pointer that was stored in the vfile */
     1135 	dcl     dcfv_stored_key	 char (256) varying;/* key that was stored in the vfile */
     1136 	dcl     dcfv_unused1	 fixed bin (21);	/* unused output from iox_$read_key and read_record */
     1137 	dcl     01 dcfv_seek_head_info,		/* structure to control vfile seek_head operation */
     1138 		02 relation_type	 fixed bin init (1),/* will seek first key with a head >= given key */
     1139 		02 n		 fixed bin init (4),/* key head is 45 characters long */
     1140 		02 key		 char (256);	/* key head character string */
     1141 
     1142 	dcfv_seek_head_info.key = addr (dcfv_opening_id) -> mcm_c4b;
     1143 	call iox_$control (dcfv_storage_ptr, "seek_key", addr (dcfv_seek_head_info), dcfv_code);
     1144 	do while (dcfv_code = 0);
     1145 	     call iox_$read_key (dcfv_storage_ptr, dcfv_stored_key, dcfv_unused1, dcfv_code);
     1146 	     if dcfv_code = 0
     1147 	     then do;
     1148 		     if addr (dcfv_stored_key) -> mcm_c4b = addr (dcfv_opening_id) -> mcm_c4b
     1149 		     then do;
     1150 
     1151 			     call iox_$read_record (dcfv_storage_ptr, addr (dcfv_stored_cursor_ptr),
     1152 				mcm_CURSOR_PTR_LENGTH, dcfv_unused1, dcfv_code);
     1153 			     if dcfv_code = 0
     1154 			     then do;
     1155 				     call dcfv_relmgr_destroy_cursor (
     1156 					dcfv_stored_cursor_ptr,
     1157 					dcfv_area_ptr, dcfv_code);
     1158 				     if dcfv_code = 0
     1159 				     then call iox_$delete_record (dcfv_storage_ptr, dcfv_code);
     1160 				end;
     1161 			end;
     1162 		end;
     1163 	end;
     1164 
     1165      end /* delete_cursors_from_vfile */;
     1166 
     1167 error_exit: proc (ee_code, ee_message);
     1168 
     1169 /*
     1170*   This  procedure  is  used  in  case an error occurs.  It sets the
     1171*   value  of  the  error code to be returned to the caller and calls
     1172*   sub_err_ to report more completely to the user.  It also performs
     1173*   a non-local goto to return to the caller of mu_cursor_manager_ so
     1174*   this procedure itself never returns to its caller.
     1175**/
     1176 
     1177 /* GLOBALS
     1178*
     1179*   mcm_code		standard error code to be returned to the caller of mu_cursor_manager_
     1180*   mcm_PROC_NAME              procedure's name
     1181*
     1182*/* PARAMETERS */
     1183 
     1184 	dcl     ee_code		 fixed bin (35);	/* (input) standard error code */
     1185 	dcl     ee_message		 char (*);	/* (input) message of what went
     1186*                                                                       wrong to be sent to the user */
     1187 
     1188 
     1189 
     1190 
     1191 
     1192 	mcm_code = ee_code;
     1193 	call sub_err_ (mcm_code, mcm_PROC_NAME, "c", null (), 0, ee_message);
     1194 
     1195 	goto exit;
     1196 
     1197      end /* error_exit */;
     1198 
     1199      end /* mu_cursor_manager_ */;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/01/88  1315.0  mu_cursor_manager_.pl1            >special_ldd>install>MR12.2-1073>mu_cursor_manager_.pl1
237          1    10/14/83  1609.1  mdbm_rm_rel_info.incl.pl1         >ldd>include>mdbm_rm_rel_info.incl.pl1
239          2    08/01/88  1310.7  mdbm_rm_db_info.incl.pl1          >special_ldd>install>MR12.2-1073>mdbm_rm_db_info.incl.pl1
241          3    05/20/83  1846.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
acta_cursor_ptr                        parameter       pointer                  dcl 737 ref 722 759
acta_index                             parameter       fixed bin(17,0)          dcl 738 ref 722 747 750 752 752 752 752 758 759
acta_key                               parameter       char(12)                 packed unaligned dcl 736 ref 722 758
acta_move_length                000524 automatic       fixed bin(21,0)          dcl 742 set ref 750* 752*
acta_storage_ptr                       parameter       pointer                  dcl 735 ref 722 747 749 749 750 752 752 752 752 752
                                                                                  752 756 756 758 759
actv_code                       000542 automatic       fixed bin(35,0)          dcl 822 set ref 828* 829 829*
actv_cursor_ptr                        parameter       pointer                  dcl 818 set ref 802 828 828
actv_storage_ptr                       parameter       pointer                  dcl 817 set ref 802 828*
addr                                                   builtin function         dcl 223 ref 265 265 712 712 752 752 752 752 752 752
                                                                                  828 828 956 1024 1083 1086 1086 1097 1097 1097
                                                                                  1097 1097 1097 1142 1143 1143 1148 1148 1151 1151
as_found                               parameter       bit(1)                   packed unaligned dcl 619 set ref 597 633* 641 648*
                                                                                  657
as_higher_index                 000400 automatic       fixed bin(17,0)          dcl 624 set ref 640* 641 642 652*
as_index                               parameter       fixed bin(17,0)          dcl 617 set ref 597 634* 636* 656* 657* 657
as_key                                 parameter       char(12)                 packed unaligned dcl 615 ref 597 643 648
as_key_larger                   000401 automatic       bit(1)                   dcl 625 set ref 646* 653* 657
as_lower_index                  000402 automatic       fixed bin(17,0)          dcl 626 set ref 639* 641 642 645*
as_middle_index                 000403 automatic       fixed bin(17,0)          dcl 627 set ref 642* 643 645 648 652 656
as_storage_ptr                         parameter       pointer                  dcl 616 ref 597 636 640 643 648
attach_descrip_ptr       14            based           pointer                  level 2 dcl 3-6 ref 528
bs_KSQU                         000057 constant        fixed bin(17,0)          initial dcl 454 set ref 479*
bs_code                         000142 automatic       fixed bin(35,0)          dcl 447 set ref 460* 461 461* 469* 470 470* 472* 476
                                                                                  476* 479* 480 480*
bs_dbi                                 parameter       fixed bin(35,0)          dcl 440 ref 417 459
bs_dbi_char                     000143 automatic       char(4)                  packed unaligned dcl 448 set ref 459* 460 465
bs_storage_ptr                         parameter       pointer                  dcl 443 set ref 417 460* 463 464 465 466 472* 479*
bs_storage_type                        parameter       fixed bin(17,0)          dcl 441 ref 417 457
bs_temp_dir                     000144 automatic       char(168)                packed unaligned dcl 449 set ref 469* 472
catv_array_storage_ptr          000552 automatic       pointer                  dcl 862 set ref 870* 874 875 877 883*
catv_i                          000554 automatic       fixed bin(17,0)          dcl 863 set ref 874* 875 877*
catv_storage_ptr                       parameter       pointer                  dcl 857 set ref 836 870 881*
catv_unused1                    000556 automatic       pointer                  dcl 864 set ref 875*
catv_unused2                    000560 automatic       bit(1)                   packed unaligned dcl 866 set ref 875*
catv_vfile_storage_ptr          000562 automatic       pointer                  dcl 868 set ref 872* 875* 877* 881
cc_area_ptr                            parameter       pointer                  dcl 902 set ref 889 913*
cc_code                         000614 automatic       fixed bin(35,0)          dcl 907 set ref 913* 915 915*
cc_collection_id                       parameter       bit(36)                  dcl 898 ref 889
cc_cursor_ptr                          parameter       pointer                  dcl 903 set ref 889 913*
cc_rel_opening_id                      parameter       bit(36)                  dcl 897 set ref 889 913*
cc_relmgr_create_cursor                parameter       entry variable           dcl 900 ref 889 913
char                                                   builtin function         dcl 224 ref 459 472 472
crfa_close_code                 000624 automatic       fixed bin(35,0)          dcl 942 set ref 954* 960* 966 966*
crfa_code                       000625 automatic       fixed bin(35,0)          dcl 943 set ref 959* 960 960
crfa_i                          000626 automatic       fixed bin(17,0)          dcl 944 set ref 955* 956*
crfa_last_opening_id            000627 automatic       bit(36)                  packed unaligned dcl 945 set ref 953* 957 962*
crfa_opening_id                 000630 automatic       bit(36)                  packed unaligned dcl 946 set ref 956* 957 959* 962
crfa_relmgr_close                      parameter       entry variable           dcl 938 ref 922 959
crfa_storage_ptr                       parameter       pointer                  dcl 937 ref 922 955 956
crfv_BOF                        000000 constant        fixed bin(17,0)          initial dcl 1004 set ref 1012*
crfv_SKIP_RECORD                000056 constant        fixed bin(17,0)          initial dcl 1007 set ref 1032*
crfv_close_code                 000662 automatic       fixed bin(35,0)          dcl 995 set ref 1021* 1028* 1041 1041*
crfv_code                       000663 automatic       fixed bin(35,0)          dcl 996 set ref 1012* 1013 1013* 1016* 1017 1017
                                                                                  1017* 1023 1027* 1028 1028 1032* 1033 1033 1033*
                                                                                  1036* 1037 1037 1037*
crfv_key                        000665 automatic       varying char(256)        dcl 998 set ref 1016* 1024 1036*
crfv_last_opening_id            000664 automatic       bit(36)                  packed unaligned dcl 997 set ref 1020* 1025 1030*
crfv_opening_id                 000767 automatic       bit(36)                  packed unaligned dcl 1000 set ref 1024* 1025 1027*
                                                                                  1030
crfv_relmgr_close                      parameter       entry variable           dcl 990 ref 973 1027
crfv_storage_ptr                       parameter       pointer                  dcl 988 set ref 973 1012* 1016* 1032* 1036*
crfv_unused1                    000766 automatic       fixed bin(21,0)          dcl 999 set ref 1016* 1036*
cursor_ptr               10            based           pointer                  array level 3 dcl 178 set ref 283 759* 877* 1089*
cursors                   4            based           structure                array level 2 unaligned dcl 178 set ref 752 752 752
                                                                                  752 1097 1097 1097 1097
data                                   based           structure                level 2 dcl 2-86
db_path                   2            based           char(168)                level 3 dcl 2-86 set ref 406*
dbi_char                  1(18)        based           char(4)                  level 2 packed packed unaligned dcl 178 set ref 465*
                                                                                  522
dcfa_area_ptr                          parameter       pointer                  dcl 1064 set ref 1047 1089*
dcfa_code                       000776 automatic       fixed bin(35,0)          dcl 1072 set ref 1089* 1092 1092*
dcfa_cursor_index_1             000777 automatic       fixed bin(17,0)          dcl 1073 set ref 1084* 1085 1096 1097 1097
dcfa_cursor_index_2             001000 automatic       fixed bin(17,0)          dcl 1075 set ref 1085* 1086 1086 1089 1094* 1094
                                                                                  1096 1097 1097 1097
dcfa_key                        001001 automatic       char(12)                 packed unaligned dcl 1077 set ref 1082* 1083* 1084*
dcfa_num_cursors_being_deleted  001004 automatic       fixed bin(17,0)          dcl 1079 set ref 1096* 1101
dcfa_opening_id                        parameter       bit(36)                  dcl 1063 set ref 1047 1083 1086
dcfa_relmgr_destroy_cursor             parameter       entry variable           dcl 1067 ref 1047 1089
dcfa_storage_ptr                       parameter       pointer                  dcl 1066 set ref 1047 1084* 1086 1086 1089 1097 1097
                                                                                  1097 1097 1097 1097 1097 1101 1101
dcfa_unused1                    001005 automatic       bit(1)                   packed unaligned dcl 1080 set ref 1084*
dcfv_area_ptr                          parameter       pointer                  dcl 1124 set ref 1108 1155*
dcfv_code                       001014 automatic       fixed bin(35,0)          dcl 1133 set ref 1143* 1144 1145* 1146 1151* 1153
                                                                                  1155* 1158 1158*
dcfv_opening_id                        parameter       bit(36)                  dcl 1123 set ref 1108 1142 1148
dcfv_relmgr_destroy_cursor             parameter       entry variable           dcl 1128 ref 1108 1155
dcfv_seek_head_info             001122 automatic       structure                level 1 unaligned dcl 1137 set ref 1143 1143
dcfv_storage_ptr                       parameter       pointer                  dcl 1126 set ref 1108 1143* 1145* 1151* 1158*
dcfv_stored_cursor_ptr          001016 automatic       pointer                  dcl 1134 set ref 1151 1151 1155*
dcfv_stored_key                 001020 automatic       varying char(256)        dcl 1135 set ref 1145* 1148
dcfv_unused1                    001121 automatic       fixed bin(21,0)          dcl 1136 set ref 1145* 1151*
delete_$path                    000020 constant        entry                    external dcl 197 ref 541
divide                                                 builtin function         dcl 225 ref 642
ds_c168b                               based           char(168)                packed unaligned dcl 518 ref 528
ds_code                         000224 automatic       fixed bin(35,0)          dcl 510 set ref 522* 524 524* 529* 530 530* 532* 533
                                                                                  533* 535* 536 536* 538* 539 539* 541* 542 542*
ds_dir                          000225 automatic       char(168)                packed unaligned dcl 511 set ref 529* 541*
ds_entry                        000277 automatic       char(32)                 packed unaligned dcl 513 set ref 529* 541*
ds_path                         000307 automatic       char(168)                packed unaligned dcl 514 set ref 528* 529*
ds_storage_ptr                         parameter       pointer                  dcl 505 set ref 488 520* 522 528 532* 535* 538* 546*
ee_code                                parameter       fixed bin(35,0)          dcl 1184 ref 1167 1192
ee_message                             parameter       char                     packed unaligned dcl 1185 set ref 1167 1193*
error_table_$end_of_info        000010 external static fixed bin(35,0)          dcl 190 ref 1017 1033 1037
error_table_$no_record          000012 external static fixed bin(35,0)          dcl 191 ref 707
expand_pathname_                000022 constant        entry                    external dcl 198 ref 529
iocb                                   based           structure                level 1 dcl 3-6
iox_$attach_name                000024 constant        entry                    external dcl 199 ref 472
iox_$close                      000026 constant        entry                    external dcl 200 ref 532
iox_$control                    000030 constant        entry                    external dcl 201 ref 1143
iox_$delete_record              000032 constant        entry                    external dcl 202 ref 1158
iox_$destroy_iocb               000034 constant        entry                    external dcl 203 ref 538
iox_$detach_iocb                000036 constant        entry                    external dcl 204 ref 535
iox_$open                       000040 constant        entry                    external dcl 205 ref 479
iox_$position                   000042 constant        entry                    external dcl 206 ref 1012 1032
iox_$read_key                   000044 constant        entry                    external dcl 207 ref 1016 1036 1145
iox_$read_record                000046 constant        entry                    external dcl 208 ref 712 1151
iox_$seek_key                   000050 constant        entry                    external dcl 209 ref 704
iox_$write_record               000052 constant        entry                    external dcl 210 ref 828
key                       2     001122 automatic       char(256)                level 2 in structure "dcfv_seek_head_info" packed
                                                                                  packed unaligned dcl 1137 in procedure
                                                                                  "delete_cursors_from_vfile" set ref 1142*
key                       4            based           char(12)                 array level 3 in structure "mcm_cursor_array" packed
                                                                                  packed unaligned dcl 178 in procedure
                                                                                  "mu_cursor_manager_" set ref 643 648 758* 875* 956
                                                                                  1086
ltrim                                                  builtin function         dcl 227 ref 459 472 472
mbz                       2(18)        based           bit(36)                  level 2 packed packed unaligned dcl 178 set ref 466*
mc_chars                               based           char                     packed unaligned dcl 790 set ref 795* 795 796* 796
mc_length                              parameter       fixed bin(21,0)          dcl 784 ref 765 795 795 796 796
mc_source_ptr                          parameter       pointer                  dcl 783 ref 765 795
mc_target_ptr                          parameter       pointer                  dcl 785 ref 765 796
mc_temp_space_ptr                      parameter       pointer                  dcl 786 ref 765 795 796
mcm_ARRAY                       000070 constant        fixed bin(17,0)          initial dcl 157 set ref 258* 268 309 344 457 520 588
mcm_CURSOR_ARRAY_ELEMENT_SIZE          constant        fixed bin(17,0)          initial dcl 159 ref 750 1097
mcm_CURSOR_PTR_LENGTH           000060 constant        fixed bin(21,0)          initial dcl 164 set ref 712* 828* 1151*
mcm_MAX_NUM_FOR_ARRAY_STORAGE          constant        fixed bin(17,0)          initial dcl 166 ref 178 275
mcm_PROC_NAME                   000001 constant        char(18)                 initial packed unaligned dcl 169 set ref 460 522
                                                                                  541* 1193*
mcm_VFILE                              constant        fixed bin(17,0)          initial dcl 170 set ref 586 872*
mcm_area_ptr                           parameter       pointer                  dcl 135 set ref 243 259* 273* 289* 301 317* 335 344*
                                                                                  346* 354 366*
mcm_b36b                               based           bit(36)                  packed unaligned dcl 175 ref 956 1024
mcm_c4b                                based           char(4)                  packed unaligned dcl 176 ref 265 265 1083 1086 1086
                                                                                  1142 1148 1148
mcm_code                               parameter       fixed bin(35,0)          dcl 140 set ref 243 251* 259* 261 261* 301 307* 317*
                                                                                  318 318* 335 342* 348* 349 349* 354 360* 366* 367
                                                                                  367* 1192* 1193*
mcm_collection_index                   parameter       bit(36)                  dcl 127 set ref 243 273* 289*
mcm_cursor_array                       based           structure                level 1 unaligned dcl 178
mcm_cursor_index                000100 automatic       fixed bin(17,0)          dcl 144 set ref 270* 281* 283
mcm_cursor_ptr                         parameter       pointer                  dcl 139 set ref 243 273* 279* 281* 283* 286* 289*
                                                                                  291*
mcm_dbi                                parameter       fixed bin(35,0)          dcl 121 set ref 243 258* 460* 469* 472 472
mcm_found                       000101 automatic       bit(1)                   packed unaligned dcl 146 set ref 270* 271 286* 287
mcm_key                         000102 automatic       char(12)                 packed unaligned dcl 149 set ref 265* 270* 278* 281*
                                                                                  286*
mcm_opening_id                         parameter       bit(36)                  dcl 125 set ref 335 344* 346* 348*
mcm_relmgr_close                       parameter       entry variable           dcl 132 set ref 301 309* 311* 335 348
mcm_relmgr_create_cursor               parameter       entry variable           dcl 130 set ref 243 273* 289*
mcm_relmgr_destroy_cursor              parameter       entry variable           dcl 134 set ref 335 344* 346*
mcm_relmgr_open                        parameter       entry variable           dcl 131 set ref 243 253*
mcm_rmri_ptr                           parameter       pointer                  dcl 122 set ref 243 253 253* 265 273 289
mcm_storage_ptr                        parameter       pointer                  dcl 137 set ref 243 256 258* 268* 270* 275 277* 278*
                                                                                  279* 281* 283 286* 291* 301 309* 309* 311* 313*
                                                                                  335 344* 344* 346* 354 362*
mcm_tuple_var_index                    parameter       fixed bin(35,0)          dcl 126 set ref 243 265
mcm_unused1                     000106 automatic       pointer                  dcl 150 set ref 278*
mcm_unused2                     000110 automatic       bit(1)                   packed unaligned dcl 152 set ref 278*
model_name               10            based           char(30)                 level 2 dcl 1-119 set ref 406*
mrds_dsl_resultant_storage$get_opening_temp_dir
                                000054 constant        entry                    external dcl 211 ref 469
mrds_error_$unknown_cursor_storage
                                000014 external static fixed bin(35,0)          dcl 192 set ref 591*
mu_define_area                  000056 constant        entry                    external dcl 213 ref 259
mu_temp_segments$delete_all_temp_segments
                                000062 constant        entry                    external dcl 216 ref 522
mu_temp_segments$get_temp_segment
                                000060 constant        entry                    external dcl 215 ref 460
n                         1     001122 automatic       fixed bin(17,0)          initial level 2 dcl 1137 set ref 1137*
name                                   based           char(32)                 level 2 dcl 1-119 ref 410
null                                                   builtin function         dcl 228 ref 256 472 472 546 700 1193 1193
num                       1            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 178 set ref 275
                                                                                  463* 636 640 747 749* 749 750 756* 756 874 955
                                                                                  1086 1097 1101* 1101
opening_id               42            based           bit(36)                  level 2 dcl 1-119 set ref 253 265 273* 289* 406*
or_code                         000130 automatic       fixed bin(35,0)          dcl 397 set ref 406* 410 410*
or_rdbi_ptr                     000132 automatic       pointer                  dcl 398 set ref 404* 406
or_relmgr_open                         parameter       entry variable           dcl 391 ref 375 406
or_rmri_ptr                            parameter       pointer                  dcl 393 ref 375 404 406 406 410
pointer                                                builtin function         dcl 229 ref 404
relation_type                   001122 automatic       fixed bin(17,0)          initial level 2 dcl 1137 set ref 1137*
release_temp_segment_           000064 constant        entry                    external dcl 217 ref 317 366
rm_db_info                             based           structure                level 1 dcl 2-86
rm_db_info_data                        based           structure                level 1 unaligned dcl 2-92
rm_rel_info                            based           structure                level 1 dcl 1-119
rtrim                                                  builtin function         dcl 231 ref 472
st_c4b                                 based           char(4)                  packed unaligned dcl 580 ref 586 588
st_return_type                  000370 automatic       fixed bin(17,0)          dcl 576 set ref 586* 588* 593
st_storage_ptr                         parameter       pointer                  dcl 572 ref 552 586 588
sub_err_                        000066 constant        entry                    external dcl 218 ref 1193
substr                                                 builtin function         dcl 232 set ref 528 1083*
sys_info$max_seg_size           000016 external static fixed bin(35,0)          dcl 193 ref 259
temp_space_begins     13564            based           bit(1)                   level 2 dcl 178 set ref 752 752 1097 1097
unique_chars_                   000070 constant        entry                    external dcl 219 ref 472 472
unspec                                                 builtin function         dcl 233 set ref 1082*
version                                based           char(4)                  level 2 packed packed unaligned dcl 178 set ref 464*
vs_code                         000412 automatic       fixed bin(35,0)          dcl 691 set ref 704* 705 707 707* 712* 714 714*
vs_cursor_ptr                          parameter       pointer                  dcl 685 set ref 665 700* 712 712
vs_found                               parameter       bit(1)                   packed unaligned dcl 686 set ref 665 699* 711*
vs_key                                 parameter       char(12)                 packed unaligned dcl 682 ref 665 702
vs_storage_ptr                         parameter       pointer                  dcl 683 set ref 665 704* 712*
vs_unused1                      000413 automatic       fixed bin(21,0)          dcl 692 set ref 704* 712*
vs_vfile_key                    000414 automatic       varying char(256)        dcl 693 set ref 702* 704*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
fixed                                                  builtin function         dcl 226
iox_$iocb_version_sentinel             external static char(4)                  dcl 3-51
natts_init                             automatic       fixed bin(17,0)          dcl 1-157
nkey_attr_init                         automatic       fixed bin(17,0)          dcl 1-157
nvar_atts_init                         automatic       fixed bin(17,0)          dcl 1-157
rdbi_ptr                               automatic       pointer                  dcl 2-90
rel                                                    builtin function         dcl 230
rmri_ptr                               automatic       pointer                  dcl 1-156

NAMES DECLARED BY EXPLICIT CONTEXT.
add_cursor_to_array             002775 constant        entry                    internal dcl 722 ref 281
add_cursor_to_vfile             003072 constant        entry                    internal dcl 802 ref 279 291 877
array_search                    002560 constant        entry                    internal dcl 597 ref 270 1084
build_storage                   001576 constant        entry                    internal dcl 417 ref 258 872
cleanup_storage                 001430 constant        entry                    external dcl 354
close_rels_from_array           003245 constant        entry                    internal dcl 922 ref 309
close_rels_from_vfile           003330 constant        entry                    internal dcl 973 ref 311
convert_array_to_vfile          003124 constant        entry                    internal dcl 836 ref 277
create_cursor                   003206 constant        entry                    internal dcl 889 ref 273 289
delete_cursors_from_array       003542 constant        entry                    internal dcl 1047 ref 344
delete_cursors_from_vfile       003675 constant        entry                    internal dcl 1108 ref 346
destroy_all_no_free             001142 constant        entry                    external dcl 301
destroy_and_free_on_opening_id  001300 constant        entry                    external dcl 335
destroy_storage                 002236 constant        entry                    internal dcl 488 ref 313 362 883
error_exit                      004047 constant        entry                    internal dcl 1167 ref 261 318 349 367 410 461 470
                                                                                  476 480 524 530 533 536 539 542 591 707 714 829
                                                                                  915 966 1013 1017 1033 1037 1041 1092
exit                            001522 constant        label                    dcl 372 ref 299 321 352 370 1195
get                             000553 constant        entry                    external dcl 243
move_chars                      003052 constant        entry                    internal dcl 765 ref 752 1097
mu_cursor_manager_              000535 constant        entry                    external dcl 6
open_relation                   001523 constant        entry                    internal dcl 375 ref 253
storage_type                    002512 constant        entry                    internal dcl 552 ref 268 309 344 520
vfile_search                    002667 constant        entry                    internal dcl 665 ref 278 286 875

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5074        5166    4505        5104
Length      5516    4505        72         314     367           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mu_cursor_manager_                 1144 external procedure  is an external procedure.  
open_relation                           internal procedure  shares stack frame of external procedure mu_cursor_manager_.  
build_storage                           internal procedure  shares stack frame of external procedure mu_cursor_manager_.  
destroy_storage                         internal procedure  shares stack frame of external procedure mu_cursor_manager_.  
storage_type                            internal procedure  shares stack frame of external procedure mu_cursor_manager_.  
array_search                            internal procedure  shares stack frame of external procedure mu_cursor_manager_.  
vfile_search                            internal procedure  shares stack frame of external procedure mu_cursor_manager_.  
add_cursor_to_array                     internal procedure  shares stack frame of external procedure mu_cursor_manager_.  
move_chars                              internal procedure  shares stack frame of external procedure mu_cursor_manager_.  
add_cursor_to_vfile                     internal procedure  shares stack frame of external procedure mu_cursor_manager_.  
convert_array_to_vfile                  internal procedure  shares stack frame of external procedure mu_cursor_manager_.  
create_cursor                           internal procedure  shares stack frame of external procedure mu_cursor_manager_.  
close_rels_from_array                   internal procedure  shares stack frame of external procedure mu_cursor_manager_.  
close_rels_from_vfile                   internal procedure  shares stack frame of external procedure mu_cursor_manager_.  
delete_cursors_from_array               internal procedure  shares stack frame of external procedure mu_cursor_manager_.  
delete_cursors_from_vfile               internal procedure  shares stack frame of external procedure mu_cursor_manager_.  
error_exit                              internal procedure  shares stack frame of external procedure mu_cursor_manager_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mu_cursor_manager_       000100 mcm_cursor_index            mu_cursor_manager_
                         000101 mcm_found                   mu_cursor_manager_
                         000102 mcm_key                     mu_cursor_manager_
                         000106 mcm_unused1                 mu_cursor_manager_
                         000110 mcm_unused2                 mu_cursor_manager_
                         000130 or_code                     open_relation
                         000132 or_rdbi_ptr                 open_relation
                         000142 bs_code                     build_storage
                         000143 bs_dbi_char                 build_storage
                         000144 bs_temp_dir                 build_storage
                         000224 ds_code                     destroy_storage
                         000225 ds_dir                      destroy_storage
                         000277 ds_entry                    destroy_storage
                         000307 ds_path                     destroy_storage
                         000370 st_return_type              storage_type
                         000400 as_higher_index             array_search
                         000401 as_key_larger               array_search
                         000402 as_lower_index              array_search
                         000403 as_middle_index             array_search
                         000412 vs_code                     vfile_search
                         000413 vs_unused1                  vfile_search
                         000414 vs_vfile_key                vfile_search
                         000524 acta_move_length            add_cursor_to_array
                         000542 actv_code                   add_cursor_to_vfile
                         000552 catv_array_storage_ptr      convert_array_to_vfile
                         000554 catv_i                      convert_array_to_vfile
                         000556 catv_unused1                convert_array_to_vfile
                         000560 catv_unused2                convert_array_to_vfile
                         000562 catv_vfile_storage_ptr      convert_array_to_vfile
                         000614 cc_code                     create_cursor
                         000624 crfa_close_code             close_rels_from_array
                         000625 crfa_code                   close_rels_from_array
                         000626 crfa_i                      close_rels_from_array
                         000627 crfa_last_opening_id        close_rels_from_array
                         000630 crfa_opening_id             close_rels_from_array
                         000662 crfv_close_code             close_rels_from_vfile
                         000663 crfv_code                   close_rels_from_vfile
                         000664 crfv_last_opening_id        close_rels_from_vfile
                         000665 crfv_key                    close_rels_from_vfile
                         000766 crfv_unused1                close_rels_from_vfile
                         000767 crfv_opening_id             close_rels_from_vfile
                         000776 dcfa_code                   delete_cursors_from_array
                         000777 dcfa_cursor_index_1         delete_cursors_from_array
                         001000 dcfa_cursor_index_2         delete_cursors_from_array
                         001001 dcfa_key                    delete_cursors_from_array
                         001004 dcfa_num_cursors_being_deleted
                                                            delete_cursors_from_array
                         001005 dcfa_unused1                delete_cursors_from_array
                         001014 dcfv_code                   delete_cursors_from_vfile
                         001016 dcfv_stored_cursor_ptr      delete_cursors_from_vfile
                         001020 dcfv_stored_key             delete_cursors_from_vfile
                         001121 dcfv_unused1                delete_cursors_from_vfile
                         001122 dcfv_seek_head_info         delete_cursors_from_vfile

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ent_var_desc   call_ext_out_desc   call_ext_out        return_mac
shorten_stack       ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
delete_$path                  expand_pathname_              iox_$attach_name              iox_$close
iox_$control                  iox_$delete_record            iox_$destroy_iocb             iox_$detach_iocb
iox_$open                     iox_$position                 iox_$read_key                 iox_$read_record
iox_$seek_key                 iox_$write_record             mrds_dsl_resultant_storage$get_opening_temp_dir
mu_define_area                mu_temp_segments$delete_all_temp_segments
mu_temp_segments$get_temp_segment                           release_temp_segment_         sub_err_
unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$end_of_info      error_table_$no_record        mrds_error_$unknown_cursor_storage
sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      6 000534       243 000542       251 000567       253 000570       256 000605       258 000611       259 000624
    261 000665       265 000706       268 000717       270 000732       271 000746       273 000751       275 000772
    277 001000       278 001006       279 001022       280 001033       281 001034       282 001051       283 001052
    284 001061       286 001062       287 001077       289 001102       291 001123       299 001134       301 001135
    307 001160       309 001161       311 001205       313 001215       317 001223       318 001250       321 001271
    335 001272       342 001316       344 001317       346 001350       348 001365       349 001402       352 001423
    354 001424       360 001444       362 001445       366 001453       367 001500       370 001521       372 001522
    375 001523       404 001525       406 001530       410 001557       413 001575       417 001576       457 001600
    459 001603       460 001630       461 001664       463 001674       464 001701       465 001703       466 001707
    467 001712       469 001713       470 001727       472 001737       476 002174       479 002205       480 002225
    484 002235       488 002236       520 002240       522 002253       524 002301       526 002311       528 002312
    529 002321       530 002345       532 002355       533 002367       535 002377       536 002411       538 002421
    539 002433       541 002443       542 002476       546 002506       548 002511       552 002512       586 002514
    588 002527       591 002534       593 002554       597 002560       633 002562       634 002566       636 002567
    639 002600       640 002602       641 002604       642 002620       643 002623       645 002636       646 002641
    647 002643       648 002644       652 002652       653 002655       655 002656       656 002657       657 002661
    661 002666       665 002667       699 002671       700 002675       702 002677       704 002705       705 002722
    707 002724       709 002735       711 002736       712 002743       714 002764       718 002774       722 002775
    747 002777       749 003006       750 003011       752 003016       755 003030       756 003031       758 003034
    759 003046       761 003051       765 003052       795 003054       796 003064       798 003071       802 003072
    828 003074       829 003113       832 003123       836 003124       870 003126       872 003131       874 003134
    875 003145       877 003163       879 003176       881 003200       883 003203       885 003205       889 003206
    913 003210       915 003234       918 003244       922 003245       953 003247       954 003250       955 003251
    956 003263       957 003271       959 003273       960 003310       962 003313       964 003315       966 003317
    969 003327       973 003330      1012 003332      1013 003350      1016 003360      1017 003376      1020 003411
   1021 003412      1023 003413      1024 003416      1025 003420      1027 003422      1028 003437      1030 003442
   1032 003444      1033 003464      1036 003477      1037 003515      1039 003530      1041 003531      1043 003541
   1047 003542      1082 003544      1083 003547      1084 003551      1085 003566      1086 003570      1089 003607
   1092 003627      1094 003637      1095 003640      1096 003641      1097 003644      1101 003664      1104 003674
   1108 003675      1137 003677      1142 003703      1143 003707      1144 003737      1145 003742      1146 003760
   1148 003762      1151 003766      1153 004007      1155 004011      1158 004031      1163 004045      1165 004046
   1167 004047      1192 004060      1193 004063      1195 004126


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
