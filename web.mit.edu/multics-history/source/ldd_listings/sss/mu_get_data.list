	COMPILATION LISTING OF SEGMENT mu_get_data
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/18/85  1044.8 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 mu_get_data: get_data: proc (a_rmri_ptr, a_area_ptr, a_simple_typed_vector_ptr, a_ml_ptr, code);
       19 
       20 /* NOTES:
       21*
       22*   This procedure moves  attribute  values  from  a  tuple  to  user
       23*   arguments.  Any  required conversions are performed, and decoding
       24*   takes place if specified.  The  $item  entry  performs  the  same
       25*   function for a single (possibly mis-aligned) attribute value.
       26*
       27*
       28*   HISTORY:
       29*
       30*   78-11-01 J. A. Weeldreyer: Initially written.
       31*
       32*   79-07-11 Al Kepner: Modified to change  the  length  field  of  a
       33*   varying char attribute from a bit length to a char length.
       34*
       35*   80-02-01 Jim Gray  :  Modified  to  make  use  of  an  extensible
       36*   non-freeing area.
       37*
       38*
       39*   80-05-08  Davids:  modified  assignments  of  tuple_num_atts  and
       40*   tuple_nvar_atts  to  take  values from rm_rel_info.model_num_attr
       41*   and  model_nvar_atts   rather   than   rm_rel_info.num_attr   and
       42*   nvar_atts.  This  was  to  fix  a problem with submodels were the
       43*   submodel view did not contain a varying string attribute and  the
       44*   model did.
       45*
       46*   80-08-12 Davids: length of attributes  for  moves  not  requiring
       47*   conversion          are         now         calculated         by
       48*   mu_data_length$get_data_bit_length. this fixes a bug caused  when
       49*   decoded declaration and data mode declaration are not the same.
       50*
       51*   81-05-06 Rickie E. Brinegar: Modified  to  use  cu_$generate_call
       52*   and the changed resultant model.
       53*
       54*   81-06-01 Jim Gray : changed to use new resultant structure.
       55*
       56*   81-10-17 Davids: added calls to add_bit_offset_ to calculate  the
       57*   value   of  item_ptr  in  mu_get_data  because  the  old  way  of
       58*   overlaying a bit array and taking the addr  of  some  element  in
       59*   that  array  ran into a pl1 bug when the offset was large and the
       60*   compiler had all the prefixes set.
       61*
       62*   82-08-20 D. Woodka : removed references to rm_attr_info.bit_offset
       63*   and rm_rel_info.max_data_len for DMS conversion
       64*
       65*   82-09-03 Mike Kubicar : Converted to use simple_typed_vectors.
       66*
       67*   83-04-07 Davids: Deleted declaration to unused variable fb35u.
       68*
       69*   84-07-19 Hergert: Initialized icode to 0 in get_item just in case
       70*   users decode proc doesnt handle code properly.
       71*
       72*   84-09-05 Thanh Nguyen: Added code to check for needing of data type
       73*   conversion, in case of the user descriptor (if the decode_declare present)
       74*   is different with the actual target user data type. (TR # 16198)
       75*
       76*   85-01-15 Thanh Nguyen: Modified code to call mrds_space_allocate function
       77*   to allocate value_for_db or value_for_user instead of using the standard
       78*   PL/I allocate, so we would not have the overflow of area (in case of the
       79*   caller is mu_retrieve).  Added mrds_space_allocate.incl.pl1.
       80**/
       81 
       82 
       83 	area_ptr = a_area_ptr;
       84 	rmri_ptr = a_rmri_ptr;			/* move into local storage */
       85 	simple_typed_vector_ptr = a_simple_typed_vector_ptr;
       86 	ml_ptr = a_ml_ptr;
       87 
       88 	do i = 1 to move_list.nitems;			/* loop for each value to be moved */
       89 
       90 	     raip = rm_rel_info.attr_ptrs (move_list.item.attr_index (i));
       91 
       92 	     item_ptr = simple_typed_vector.dimension (raip ->
       93 		rm_attr_info.defn_order).value_ptr;
       94 
       95 	     call get_item (raip, item_ptr,		/* call proc. to do the work */
       96 		move_list.item.user_ptr (i), move_list.item.user_desc_ptr (i));
       97 
       98 	end;					/* attr. value loop */
       99 
      100 	code = 0;
      101 
      102 exit:
      103 	return;
      104 
      105 item: get_data_item: entry
      106 	(a_raip, b_area_ptr, a_item_ptr, a_targ_ptr, a_desc_ptr, code);
      107 
      108 /* Entry to pass only one item back to the user.  THis item may be mis-aligned. */
      109 
      110 	dcl     (a_raip,
      111 	        b_area_ptr,
      112 	        a_item_ptr,
      113 	        a_desc_ptr,
      114 	        a_targ_ptr)		 ptr;
      115 
      116 
      117 	area_ptr = b_area_ptr;
      118 	call get_item (a_raip, a_item_ptr, a_targ_ptr, a_desc_ptr);
      119 
      120 	code = 0;
      121 
      122 	return;
      123 
      124 get_item: proc (aip, ip, target_data_ptr, target_desc_ptr);
      125 
      126 /* Procedure to process a single value */
      127 
      128 	dcl     (aip,
      129 	        ip,
      130 	        target_data_ptr,
      131 	        target_desc_ptr)	 ptr;
      132 						/* just make sure code = 0 in case user's decode proc doesn't handle code properly. */
      133 	icode = 0;
      134 	rai_ptr = aip;				/* attribute info */
      135 	rdi_ptr = rm_attr_info.domain_ptr;		/* domain info */
      136 
      137 	if ^rm_domain_info.decd_proc then do;		/* if no decoding */
      138 
      139 		if target_desc_ptr -> bit36 = rm_domain_info.db_desc &
      140 		     target_desc_ptr -> bit36 = rm_domain_info.user_desc
      141 						/* if no conversion */
      142 		then do;
      143 			len = mu_data_length$get_data_bit_length ((rm_domain_info.user_desc));
      144 			target_data_ptr -> target_str = ip -> src_str;
      145 		     end;
      146 
      147 		else do;				/* if must convert */
      148 			call align_item;		/* move into temp & set db_val_ptr */
      149 
      150 			call mu_convert (db_val_ptr,	/* convert from db data type */
      151 			     addr (rm_domain_info.db_desc),
      152 			     target_data_ptr,	/* to data type that user wants */
      153 			     target_desc_ptr,
      154 			     icode);
      155 			if icode ^= 0 then call error (icode);
      156 		     end;				/* if must convert */
      157 
      158 	     end;					/* if no decoding */
      159 
      160 	else do;					/* if must decode */
      161 
      162 		call align_item;			/* move into temp & set db_val_ptr */
      163 
      164 		if rm_domain_info.user_bit_len > 2376 then do; /* if wont fit into work space */
      165 			user_val_ptr = mrds_space_allocate (area_ptr, (rm_domain_info.user_bit_len + 35) / 36);
      166 			if user_val_ptr = null then
      167 			     call error (error_table_$noalloc);
      168 			ub_alloc = "1"b;
      169 		     end;
      170 		else user_val_ptr = addr (wksp2);	/* if will fit */
      171 
      172 		value_for_user = "0"b;		/* clear out space */
      173 
      174 		decode_list.uv_ptr = user_val_ptr;	/* user val is output from decode */
      175 		user_descriptor = rm_domain_info.user_desc; /* move descriptor into local storage */
      176 		decode_list.ud_ptr = addr (user_descriptor);
      177 
      178 		if decode_list.ud_ptr -> descriptor.type = VAR_CHAR /* varying strings are strange */
      179 		     | decode_list.ud_ptr -> descriptor.type = VAR_BIT then
      180 		     decode_list.uv_ptr = addr (decode_list.uv_ptr -> varying.string); /* point to string, not length */
      181 
      182 		decode_list.dbv_ptr = db_val_ptr;	/* db value is input to decode */
      183 		db_descriptor = rm_domain_info.db_desc; /* move into local storage */
      184 		decode_list.dbd_ptr = addr (db_descriptor); /* and get into arg list */
      185 
      186 		if decode_list.dbd_ptr -> descriptor.type = VAR_CHAR /* more strange strings */
      187 		     | decode_list.dbd_ptr -> descriptor.type = VAR_BIT then
      188 		     decode_list.dbv_ptr = addr (decode_list.dbv_ptr -> varying.string);
      189 
      190 		decode_list.code_ptr = addr (icode);	/* return code */
      191 		decode_list.coded_ptr = addr (FB35_DESC);
      192 
      193 /* 81-05-06 Rickie E. Brinegar: Start changed code ************************* */
      194 
      195 		call cu_$generate_call /* call decode_proc(value_for_user, value_for_db, icode) */
      196 		     (rm_domain_info.decd_proc_entry, addr (decode_list));
      197 
      198 /* 81-05-06 Rickie E. Brinegar: End changed code *************************** */
      199 
      200 		if icode ^= 0 then call error (icode);
      201 
      202 		if target_desc_ptr -> bit36 = rm_domain_info.user_desc /* if no conversion required */
      203 		then do;
      204 			len = mu_data_length$get_data_bit_length ((rm_domain_info.user_desc));
      205 			target_data_ptr -> target_str = user_val_ptr -> src_str;
      206 		     end;
      207 
      208 		else do;
      209 			call mu_convert (user_val_ptr,/* convert decoded output as appropriate */
      210 			     addr (rm_domain_info.user_desc),
      211 			     target_data_ptr,
      212 			     target_desc_ptr,
      213 			     icode);
      214 			if icode ^= 0 then call error (icode);
      215 		     end;				/* convertion required */
      216 
      217 	     end;					/* if needed to decode */
      218 
      219 align_item: proc;
      220 
      221 /* Procedure to move source item to a properly aligned position */
      222 
      223 	dcl     src_str		 bit (len) based (ip);
      224 
      225 	if rm_attr_info.bit_length > 2376 then do;	/* if wont fit in work space */
      226 		db_val_ptr = mrds_space_allocate (area_ptr, (rm_attr_info.bit_length + 35) / 36);
      227 		if db_val_ptr = null then call error (error_table_$noalloc);
      228 		db_alloc = "1"b;
      229 	     end;
      230 	else db_val_ptr = addr (wksp1);		/* if will fit */
      231 	value_for_db = "0"b;			/* clear out space */
      232 
      233 	len = rm_attr_info.bit_length;
      234 
      235 	value_for_db = src_str;
      236 
      237      end align_item;
      238 
      239      end get_item;
      240 
  1     1 /* BEGINNING OF:  mrds_space_allocate.incl.pl1   * * * * * * * * * * * * * * */
  1     2 
  1     3 /* HISTORY:
  1     4*
  1     5*   Created by:  Thanh Nguyen      01/15/85
  1     6*
  1     7* */
  1     8 
  1     9 
  1    10 mrds_space_allocate:   proc (mrds_area_ptr, requested_word_size) returns (ptr);
  1    11 
  1    12 /* This function "allocates" the requested space in the temporary segment, if
  1    13*   the segment is "mrds area".  The space of allocation will not be free.  If 
  1    14*   the area is full, this function returns a null pointer.  And the user has to
  1    15*   call mrds_area_initialize to reset the temporary segment back to the 
  1    16*   beginning.  So, we never have the overflow on the area and the CPU 
  1    17*   processing time for this allocation is low.  If the segment is not a
  1    18*   "mrds area", this function does a standard PL/I allocate.
  1    19* */
  1    20 
  1    21           dcl     mrds_area_ptr           ptr;       /* ptr to the temporary segment. (INPUT) */
  1    22           dcl     requested_word_size     fixed bin (35); /* number of words to be allocated. (INPUT) */
  1    23 
  1    24           dcl     actual_allocated_size   fixed bin (35); /* number of words to be allocated, rounded up to a 0 + mod 2 quantity. */
  1    25 	dcl     MRDS_AREA               char (8) init ("MRDSAREA");
  1    26           dcl     (mod, null, ptr)        builtin;
  1    27 
  1    28           dcl     1 mrds_area             based (mrds_area_ptr),
  1    29 		2 area_id             char (8),
  1    30 		2 offset_to_free_word fixed bin (35), /* offset to the next free word in temp seg.  */
  1    31 		2 length_free_space   fixed bin (35); /* length of remaining free space in temp seg.*/
  1    32 
  1    33 	dcl     p_work_area             area (sys_info$max_seg_size) based (mrds_area_ptr);
  1    34 	dcl     alloc_value_ptr         ptr;
  1    35 	dcl     alloc_value             (actual_allocated_size) bit (36) based (alloc_value_ptr);
  1    36 
  1    37 
  1    38 	/* round up to even word boundary. */
  1    39 	actual_allocated_size = requested_word_size + mod (requested_word_size, 2);
  1    40 	if mrds_area_ptr = null then return (null);
  1    41 	else if mrds_area.area_id ^= MRDS_AREA then do;
  1    42 	     /* must be a standard PL/I area. */
  1    43 	     allocate alloc_value set (alloc_value_ptr) in (p_work_area);
  1    44 	     return (alloc_value_ptr);
  1    45 	end;
  1    46 	else if actual_allocated_size <= length_free_space then do;
  1    47 	     /* get pointer to next free word of area.  */
  1    48 	     alloc_value_ptr = ptr (mrds_area_ptr, mrds_area.offset_to_free_word);
  1    49 	     /* increase offset of remaining free space */
  1    50 	     mrds_area.offset_to_free_word = mrds_area.offset_to_free_word + actual_allocated_size;
  1    51 	     /* decrease length of remaining free space */
  1    52 	     mrds_area.length_free_space = mrds_area.length_free_space - actual_allocated_size;
  1    53 	     return (alloc_value_ptr);
  1    54 	end;
  1    55 	else return (null);
  1    56 
  1    57 
  1    58 end mrds_space_allocate;
  1    59 
  1    60 /* END OF:     mrds_space_allocate.incl.pl1  * * * * * * * * * * * * * * * * */
      241 
      242 
      243 error: proc (cd);
      244 
      245 /* Error procedure */
      246 
      247 	dcl     cd		 fixed bin (35);
      248 
      249 	code = cd;
      250 	go to exit;
      251 
      252      end error;
      253 
  2     1 /* BEGIN mdbm_rm_rel_info.incl.pl1 -- jaw, 11/16/78 */
  2     2 
  2     3 /* WARNING
  2     4*          If the rm_rel_info structure is changed then the mrds_data_
  2     5*          item saved_res_version MUST be incremented to invalidate all
  2     6*          existing saved resultants
  2     7**/
  2     8 
  2     9 /* HISTORY:
  2    10*
  2    11*   Modified by Jim Gray - - May 1980, to  include  model  number  of
  2    12*   attributes,   and   varying  attributes,  so  that  partial  view
  2    13*   submodels will have the  info  needed  to  properly  set  up  the
  2    14*   varying length array headers in the tuple structure.
  2    15*
  2    16*   Modified  by  Jim  Gray  -  -  80-11-06,  to  rename   r_perm   =
  2    17*   status_perm,     s_perm    =    append_tuple_perm,    d_perm    =
  2    18*   delete_tuple_perm, and make m_perm = unused_perm.
  2    19*
  2    20*   81-01-23 Jim Gray : added bit to indicate whether the last  model
  2    21*   view attribute was varying character or bit, since a partial view
  2    22*   submodel will not have this information in the resultant, and  it
  2    23*   is  needed for determining the new tuple length in mus_mod_ubtup,
  2    24*   since with exact length storage  of  varying  length  attributes,
  2    25*   each  tuple  can  be  a  different  length,  which is can only be
  2    26*   determined by examining the tuple itself.
  2    27*
  2    28*   81-01-29 Jim Gray : added curent  tuple  count,  to  provide  for
  2    29*   interface  to  allow  temp  rel  population  to  be known, and to
  2    30*   provide a more efficient means of finding an approx. current perm
  2    31*   relation population.
  2    32*
  2    33*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
  2    34*   blocked  files, foreign keys, and ids procedures. Also set number
  2    35*   of files per rel to a constant of 1.
  2    36*
  2    37*   81-05-28 Jim Gray : combined data  from  rm_file_info  into  this
  2    38*   structure so that only one structure per relation is needed.
  2    39*
  2    40*   81-07-02 Jim Gray : added total_key and dup_key vfile  statistics
  2    41*   counts.   Also  added  number  of  operations  count  since  last
  2    42*   statistics update, and a time  since  the  statistics  were  last
  2    43*   updated.
  2    44*
  2    45*   81-07-06 Jim Gray :  added  a  per  selection  expression  update
  2    46*   identifier so that small relations could be updated on a per S.E.
  2    47*   basis
  2    48*
  2    49*   82-04-21 R. Lackey : Added number_selected (ri_niocbs_init refer (rm_rel_info.niocbs)) fixed bin (35)
  2    50*   to end of structure   TR 12205 (Suggestion).
  2    51*   
  2    52*   82-08-19 D. Woodka :  Removed  rm_rel_info.max_data_len  field for
  2    53*   the DMS conversion. 
  2    54*
  2    55*   82-08-30 Davids: added the opening_id element and removed the iocb
  2    56*   array and the niocb element for DMS conversion. Also removed the
  2    57*   number_selected array (and ri_niocbs_init) since subsets are not
  2    58*   going to be used.
  2    59*
  2    60*   82-09-20 Mike Kubicar : changed rm_rel_info.rel_id to bit (36) aligned
  2    61*   so that it can be used with relation manager.  Also added
  2    62*   rm_rel_info.primary_key_index_id for relation manager.
  2    63*
  2    64*   82-09-22 Mike Kubicar : Removed the, now useless, fields var_attr_ptrs,
  2    65*   nvar_atts, model_nvar_atts.
  2    66*
  2    67*   82-09-24 Davids: Removed current_key_count and current_dup_key_count
  2    68*   since the duplicate key count for each secondary index is now being
  2    69*   kept in the attr_info structure and key_count was only needed to
  2    70*   help in calculating the average selectivity of each index which
  2    71*   can now be gotten directly from each index's dup key count. Also
  2    72*   removed the file_id element since it is no longer needed for
  2    73*   anything.
  2    74*
  2    75*   82-09-27 Mike Kubicar : removed file_id_len for the same reason file_id
  2    76*   was removed.
  2    77*
  2    78*   82-11-05 Mike Kubicar : added a pointer to an id_list structure to be
  2    79*   used when retrieving tuples from this relation.
  2    80*
  2    81*   83-04-06 Davids: Added the scope_flags_ptr which points to the scope_flags structure
  2    82*   for the relation. Note that this structure is part of the resultant NOT
  2    83*   part of the db.control structure. The scopes are duplicated in the resultant
  2    84*   to reduce contention for the db.control structure. Note also that the pointer
  2    85*   will always point to a scope_flags structure even if no scopes have been
  2    86*   set on the relation, the structure is allocated when the db is opened.
  2    87**/
  2    88 
  2    89 
  2    90 /* DESCRIPTION:
  2    91*
  2    92*   This structure is allocated in the area part of the structure  in
  2    93*   mdbm_rm_db_info.incl.pl1  as  part of the resultant model created
  2    94*   at open  time  for  a  database.  There  will  be  one  of  these
  2    95*   rm_rel_info   structures  for  each  relation  appearing  in  the
  2    96*   database view (there may be less than the total in  the  database
  2    97*   for  a  submodel  openings).  There  will  also  be  one for each
  2    98*   temporary relation currently defined for that opening.
  2    99*
  2   100*   The structure in mdbm_rm_rel_array.incl.pl1 contains pointers  to
  2   101*   all  rm_rel_info  structures  allocated. It is used for searching
  2   102*   for the appropriate  structure.  This  array  is  pointed  to  by
  2   103*   rm_db_info. There are two arrays, one for perm rels, one for temp
  2   104*   rels.
  2   105*
  2   106*   The      rm_rel_info      structure      points      to       the
  2   107*   mdbm_rm_attr_info.incl.pl1  structures,  one  for  each attribute
  2   108*   appearing in this view of the relation. Each  of  these  in  turn
  2   109*   point  to a mdbm_rm_domain_info.incl.pl1 structure for the domain
  2   110*   info for each attr.
  2   111*
  2   112*   Most of the other information here deals with  specifics  of  the
  2   113*   relation's  logical  definition,  such as key and secondary index
  2   114*   attribute inidicators, security permissions, and  tuple  physical
  2   115*   construction details.
  2   116*
  2   117**/
  2   118 
  2   119      dcl	   1 rm_rel_info	      aligned based (rmri_ptr), /* relation information */
  2   120 	     2 name	      char (32),		/* from submodel */
  2   121 	     2 model_name	      char (30),		/* from model */
  2   122 	     2 rel_id	      bit (36) aligned,	/* unique id. */
  2   123 	     2 retrieve	      bit (1) unal,		/* operations allowed by this view */
  2   124 	     2 modify	      bit (1) unal,
  2   125 	     2 delete	      bit (1) unal,
  2   126 	     2 store	      bit (1) unal,
  2   127 	     2 total_key	      bit (1) unal,		/* on if view includes full primary key */
  2   128 	     2 indexed	      bit (1) unal,		/* on if exists sec. index */
  2   129 	     2 mdbm_secured	      bit (1) unal,		/* on if mdbm must check security */
  2   130 	     2 status_perm	      bit (1) unal,		/* if user has status. perm. */
  2   131 	     2 append_tuple_perm  bit (1) unal,		/* if user has store perm. */
  2   132 	     2 delete_tuple_perm  bit (1) unal,		/* if user has del. perm. */
  2   133 	     2 unused_perm	      bit (1) unal,		/* for future use. */
  2   134 	     2 last_model_attr_char_var bit (1) unal,	/* on => last model varying attr is char */
  2   135 	     2 reserved	      bit (24) unal,	/* for future use */
  2   136 	     2 num_attr	      fixed bin,		/* total no. of attr. in rel. */
  2   137 	     2 model_num_attr     fixed bin,		/* total attrs in model relation */
  2   138 	     2 nkey_attr	      fixed bin,		/* no. of key attr. */
  2   139 	     2 model_nkey_attr    fixed bin,		/* total number of keys in model */
  2   140 	     2 primary_key_index_id bit (36) aligned,     /* Index id of relation's primary key */
  2   141 	     2 nsec_inds	      fixed bin,		/* no. sec. indexes */
  2   142 	     2 max_key_len	      fixed bin (35),	/* max length (chars) of primary key */
  2   143 	     2 current_tuple_population fixed bin (35),	/* last known total  tuple count for this relation */
  2   144 	     2 last_statistics_update_count fixed bin,	/* number of operations's, since this rels stats were updated */
  2   145 	     2 last_statistics_update_time fixed bin (71),/* last time this rels stats were updated */
  2   146 	     2 last_statistics_update_s_e_ref_num fixed bin (35), /* last select expr ID that updated this rels stats */
  2   147 	     2 ready_mode	      fixed bin,		/* 1 => r, 2 => mr, 3 => u, 4 => l, 5 => sr, 6 => su */
  2   148 	     2 file_type	      fixed bin,		/* 1 => unblocked, 2 => blocked, 3 => temporary */
  2   149 	     2 tuple_id_len	      fixed bin,		/* no. bits in local tuple id */
  2   150 	     2 opening_id	      bit (36) aligned,	/* relation manager opening is */
  2   151 	     2 key_attr_ptrs      (nkey_attr_init refer (rm_rel_info.nkey_attr)) ptr, /* ptrs to key attr. */
  2   152 	     2 attr_ptrs	      (natts_init refer (rm_rel_info.num_attr)) ptr, /* ptrs to all attr. */
  2   153 	     2 id_list_ptr        ptr,		/* Id list for retrieves from the relation */
  2   154                2 scope_flags_ptr    ptr;                    /* pointer to the scope_flags structure for the rel */
  2   155 
  2   156      dcl	   rmri_ptr	      ptr;
  2   157      dcl	   (nkey_attr_init,
  2   158 	   natts_init,
  2   159 	   nvar_atts_init)	      fixed bin;
  2   160 
  2   161 /* END mdbm_rm_rel_info.incl.pl1 */
  2   162 
  2   163 
      254 
      255 
  3     1 /* BEGIN mdbm_rm_domain_info.incl.pl1 -- jaw, 9/26/78 */
  3     2 
  3     3 /* WARNING
  3     4*          If the rm_domain_info structure is changed then the mrds_data_
  3     5*          item saved_res_version MUST be incremented to invalidate all
  3     6*          existing saved resultants
  3     7**/
  3     8 
  3     9 /* DESCRIPTION:
  3    10*
  3    11*   This  structure  is  allocated  in  the  mdbm_rm_db_info.incl.pl1
  3    12*   static  area,  once per attribute used in a relation in a readied
  3    13*   file. it is pointed to by the mdbm_rm_attr_info.incl.pl1, and may
  3    14*   point  to  mdbm_rm_ck_and_group.incl.pl1  if  a  "-check"  option
  3    15*   boolean expression was declared for this domain. it contains  the
  3    16*   descriptor  for  this domain data type, and other resultant model
  3    17*   information.
  3    18*
  3    19*
  3    20*   HISTORY:
  3    21*
  3    22*   81-05-06  Rickie  E.  Brinegar:  Modified  ck_proc,  encode_proc,
  3    23*   decode_proc to be entry variables instead of entry pointers. This
  3    24*   allows these programs to be written in languages other than pl1.
  3    25*
  3    26*   81-05-28 Jim Gray : removed unused procedure points,  and  unused
  3    27*   check  stack  structure  elements.  Also made the descriptors bit
  3    28*   (36) in this structure, rather than pointers to  the  descriptors
  3    29*   elsewhere.  Also  removed un-needed redundant assign_ parameters,
  3    30*   that are actually available in the descriptors.
  3    31*
  3    32*
  3    33**/
  3    34 
  3    35 dcl 1 rm_domain_info aligned based (rdi_ptr),		/* domain information */
  3    36     2 name char (32),				/* domain name */
  3    37     2 db_desc bit (36),				/*  to desc. for db. */
  3    38     2 user_desc bit (36),				/* desc for user visible data */
  3    39     2 user_bit_len fixed bin,				/* storage length of users data */
  3    40     2 ck_proc_entry entry variable,			/* to check proc. entry */
  3    41     2 encd_proc_entry entry variable,			/* to encode proc entry */
  3    42     2 decd_proc_entry entry variable,			/* to decode proc entry */
  3    43     2 ck_proc bit (1) unal,				/* Is there a check proc */
  3    44     2 encd_proc bit (1) unal,				/* Is there an encode proc */
  3    45     2 decd_proc bit (1) unal,				/* Is there a decode proc */
  3    46     2 pad bit (33) unal,
  3    47     2 next_domain_ptr ptr ;				/* to next domain, in list of all domains */
  3    48 						/* to check stack and groups */
  3    49 
  3    50 
  3    51 dcl  rdi_ptr ptr int automatic init (null ());
  3    52 
  3    53 /* END mdbm_rm_domain_info.incl.pl1 */
  3    54 
  3    55 
      256 
      257 
  4     1 /*  BEGIN  mdbm_rm_attr_info.incl.pl1  --  jaw,  11/16/78  */
  4     2 
  4     3 /* WARNING
  4     4*          If the rm_attr_info structure is changed then the mrds_data_
  4     5*          item saved_res_version MUST be incremented to invalidate all
  4     6*          existing saved resultants
  4     7**/
  4     8 
  4     9 /*
  4    10*
  4    11*   Modified  by  Jim  Gray - - 80-11-05, to add mdbm_secured bit, so
  4    12*   that rm_rel_info does not have to be checked
  4    13*
  4    14*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
  4    15*   foreign keys.
  4    16*
  4    17*   82-08-19  D. Woodka : removed rm_attr_info.bit_offset for the DMS
  4    18*   conversion.
  4    19*
  4    20*   82-09-15 Davids: added the number_of_dups field.
  4    21*
  4    22*   82-09-20 Mike Kubicar : changed the index_id field to be bit (36)
  4    23*   aligned.  This is to conform with the new definition in the database
  4    24*   model.  Also removed the now useless field varying.
  4    25*
  4    26*   82-11-05 Davids: added the field model_defn_order and clarified the
  4    27*   comment for the field defn_order.
  4    28*
  4    29*   83-05-23 Mike Kubicar : changed number_of_dups to fixed bin (35) since
  4    30*   that's what relation manager returns.
  4    31*
  4    32**/
  4    33 
  4    34 
  4    35 /*
  4    36*   this   structure   is   allocated   in   the   static   area   of
  4    37*   mdbm_rm_db_info.incl.pl1  once for each attribute per relation in
  4    38*   a     readied     file.      it     in     turn     points     to
  4    39*   mdbm_rm_domain_info.incl.pl1  for  the  attributes  domain.   the
  4    40*   rm_attr_info  is  pointed  to  by mdbm_rm_rel_info.incl.pl1.  all
  4    41*   structures  are  in  the  rm_db_info  area.   the  attribute data
  4    42*   position  within  a  tuple as stored in the data file are kept in
  4    43*   this resultant model of the attribute.
  4    44* */
  4    45 
  4    46 dcl 1 rm_attr_info aligned based (rai_ptr),		/* resultant attr. info */
  4    47     2 name char (32),				/* from submodel */
  4    48     2 model_name char (32),				/* from model */
  4    49     2 key_attr bit (1) unal,				/* if key attribute */
  4    50     2 index_attr bit (1) unal,			/* if secondary index */
  4    51     2 read_perm bit (1) unal,				/* user has retr. permission */
  4    52     2 modify_perm bit (1) unal,			/* user has modify permission */
  4    53     2 mdbm_secured bit (1) unal,			/* on => database secured */
  4    54     2 reserved bit (30) unal,				/* for future use */
  4    55     2 index_id bit (36) aligned,			/* index id if index_attr */
  4    56     2 defn_order fixed bin,				/* relative order in which attr is defined in the view */
  4    57     2 key_order fixed bin,				/* relative order defined in prim. key */
  4    58     2 bit_length fixed bin (35),			/* length if fixed, max. len. if var. */
  4    59     2 domain_ptr ptr,				/* to domain info */
  4    60     2 number_of_dups fixed bin (35),                        /* if the attribute is indexed this will
  4    61*                                                               be the number of duplicate values, exact
  4    62*                                                               for a page_file database, an estimate for a vfile type */
  4    63     2 model_defn_order fixed bin;                           /* relative order in which attr is defined in the model */
  4    64 
  4    65 dcl  rai_ptr ptr int automatic init (null ());
  4    66 
  4    67 /* END mdbm_rm_attr_info.incl.pl1 */
  4    68 
  4    69 
      258 
      259 
  5     1 /* BEGIN mdbm_move_list.incl.pl1 -- jaw, 7/13/78 */
  5     2 
  5     3 /* HISTORY:
  5     4*
  5     5*   81-06-01 Jim Gray : removed assn type and len elements,
  5     6*   now that mu_convert is used.
  5     7*
  5     8**/
  5     9 
  5    10 
  5    11 dcl 1 move_list aligned based (ml_ptr),			/* info for moving data in and out of tuple */
  5    12     2 nitems fixed bin,				/* number of items */
  5    13     2 item (ml_nitems_init refer (move_list.nitems)),
  5    14       3 attr_index fixed bin,				/* index to attr info in rel_info */
  5    15       3 user_ptr ptr,				/* pointer to user data value */
  5    16       3 user_desc_ptr ptr;				/* pointer to descriptor for user */
  5    17 
  5    18 dcl  ml_ptr ptr;
  5    19 dcl  ml_nitems_init fixed bin;
  5    20 
  5    21 /* END mdbm_move_list.incl.pl1 */
  5    22 
      260 
      261 
  6     1 /* ***********************************************************
  6     2*   *                                                         *
  6     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
  6     4*   *                                                         *
  6     5*   *********************************************************** */
  6     6 /* BEGIN INCLUDE FILE - vu_typed_vector.incl.pl1 */
  6     7 
  6     8 /* Written by Lindsey Spratt, 04/02/82.
  6     9*Modified:
  6    10*09/01/82 by Lindsey Spratt:  Changed value_ptr in simple_typed_vector to be
  6    11*	  unaligned.  Changed the type number of the simple_typed_vector to
  6    12*	  "3" from "1".  The OLD_SIMPLE_TYPED_VECTOR_TYPE is now an invalid
  6    13*	  type.
  6    14**/
  6    15 
  6    16 /* format: style2,ind3 */
  6    17      dcl	   1 simple_typed_vector  based (simple_typed_vector_ptr),
  6    18 	     2 type	      fixed bin (17) unal,
  6    19 	     2 number_of_dimensions
  6    20 			      fixed bin (17) unal,
  6    21 	     2 dimension	      (stv_number_of_dimensions refer (simple_typed_vector.number_of_dimensions)),
  6    22 	       3 value_ptr	      ptr unaligned;
  6    23 
  6    24      dcl	   1 general_typed_vector based (general_typed_vector_ptr),
  6    25 	     2 type	      fixed bin (17) unal,
  6    26 	     2 number_of_dimensions
  6    27 			      fixed bin (17) unal,
  6    28 	     2 dimension	      (gtv_number_of_dimensions refer (general_typed_vector.number_of_dimensions)),
  6    29 	       3 identifier	      fixed bin (17) unal,
  6    30 	       3 pad	      bit (18) unal,
  6    31 	       3 value_ptr	      ptr unal;
  6    32 
  6    33      dcl	   simple_typed_vector_ptr
  6    34 			      ptr;
  6    35      dcl	   stv_number_of_dimensions
  6    36 			      fixed bin (17);
  6    37 
  6    38      dcl	   general_typed_vector_ptr
  6    39 			      ptr;
  6    40      dcl	   gtv_number_of_dimensions
  6    41 			      fixed bin (17);
  6    42 
  6    43      dcl	   (
  6    44 	   OLD_SIMPLE_TYPED_VECTOR_TYPE
  6    45 			      init (1),		/* value_ptr was aligned. */
  6    46 	   GENERAL_TYPED_VECTOR_TYPE
  6    47 			      init (2),
  6    48 	   SIMPLE_TYPED_VECTOR_TYPE
  6    49 			      init (3)
  6    50 	   )		      fixed bin (17) internal static options (constant);
  6    51 
  6    52 /* END INCLUDE FILE - vu_typed_vector.incl.pl1 */
      262 
      263 
      264 	dcl /* input parameters */
      265 	        a_rmri_ptr		 ptr,
      266 	        a_area_ptr		 ptr,
      267 	        a_simple_typed_vector_ptr ptr,		/* points to tuple structure */
      268 	        a_ml_ptr		 ptr;		/* points to move_list structure for user's output */
      269 
      270 	dcl     (raip,				/* temp attr info pointer */
      271 	        item_ptr,				/* pointer to value */
      272 	        db_val_ptr,				/* pointer to converted value, ready for tuple */
      273 	        user_val_ptr)	 ptr;		/* pointer to converted value, prior to encoding */
      274 
      275 	dcl     (wksp1,				/* work spaces to minimize allocations */
      276 	        wksp2)		 (33) fixed bin (71);
      277 
      278 	dcl     (db_alloc,				/* to remember allocations */
      279 	        ub_alloc)		 bit (1) aligned;
      280 
      281 	dcl     target_str		 bit (len) based;
      282 	dcl     src_str		 bit (len) based;
      283 	dcl     len		 fixed bin;	/* length of value */
      284 	dcl     i			 fixed bin;	/* internal indexes */
      285 
      286 	dcl     (code,				/* Output: status code */
      287 	        icode)		 fixed bin (35);	/* internal status code */
      288 	dcl     db_descriptor	 bit (36) aligned;	/* describes the way db wants data */
      289 	dcl     user_descriptor	 bit (36) aligned;	/* describes the way user proc wants data */
      290 
      291 	dcl     work_area		 area (sys_info$max_seg_size) based (area_ptr); /* working area */
      292 	dcl     value_for_db	 bit (rm_attr_info.bit_length) based (db_val_ptr); /* converted value, ready for tuple */
      293 	dcl     value_for_user	 bit (rm_domain_info.user_bit_len) based (user_val_ptr); /* converted val., ready for encoding */
      294 	dcl     bit36		 bit (36) based;	/* templates */
      295 
      296 	dcl     1 varying		 based unaligned,	/* description of varying string */
      297 		2 length		 fixed bin (35),	/* length word */
      298 		2 string		 char (0);	/* string starts here */
      299 
      300 	dcl     1 descriptor	 aligned based,
      301 	        ( 2 flag		 bit (1),
      302 		2 type		 fixed bin (6) unsigned, /* data type */
      303 		2 packed		 bit (1),		/* ON = unaligned */
      304 		2 number_dims	 fixed bin (4) unsigned, /* non-zero for arrays */
      305 		2 size		 fixed bin (24) unsigned) unaligned, /* size of data */
      306 		2 array_info	 (0 refer (descriptor.number_dims)),
      307 		  3 lower_bound	 fixed bin (35),
      308 		  3 upper_bound	 fixed bin (35),
      309 		  3 multiplier	 fixed bin (35);
      310 
      311 	dcl     1 decode_list	 aligned,		/* arg list for decode proc. */
      312 		2 nargs		 fixed bin (17) unal init (6),
      313 		2 code		 fixed bin (17) unal init (4),
      314 		2 ndescs		 fixed bin (17) unal init (6),
      315 		2 pad		 fixed bin (17) unal init (0),
      316 		2 dbv_ptr		 ptr,
      317 		2 uv_ptr		 ptr,
      318 		2 code_ptr	 ptr,
      319 		2 dbd_ptr		 ptr,
      320 		2 ud_ptr		 ptr,
      321 		2 coded_ptr	 ptr;
      322 
      323 	dcl     FB35_DESC		 bit (36) aligned int static options (constant)
      324 				 init ("100000100000000000000000000000100011"b);
      325 	dcl     VAR_BIT		 fixed bin (5) int static options (constant) init (20);
      326 	dcl     VAR_CHAR		 fixed bin (5) int static options (constant) init (22);
      327 
      328 	dcl     sys_info$max_seg_size	 ext fixed bin (35);
      329 	dcl     error_table_$noalloc	 fixed bin (35) ext static;
      330 	dcl     (addr,
      331 	        null)		 builtin;
      332 
      333 
      334 	dcl     mu_convert		 entry (ptr, ptr, ptr, ptr, fixed bin (35));
      335 	dcl     mu_data_length$get_data_bit_length entry (bit (36)) returns (fixed bin (35));
      336 
      337 /* 81-05-06 Rickie E. Brinegar: Start changed code ************************* */
      338 
      339 	dcl     cu_$generate_call	 entry (entry, ptr);
      340 
      341 /* 81-05-06 Rickie E. Brinegar: End changed code *************************** */
      342 
      343 	declare area_ptr		 ptr;
      344      end mu_get_data;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/85  0908.2  mu_get_data.pl1                   >special_ldd>online>mrds.pbf-04/18/85>mu_get_data.pl1
241          1    02/20/85  1610.1  mrds_space_allocate.incl.pl1      >ldd>include>mrds_space_allocate.incl.pl1
254          2    10/14/83  1609.1  mdbm_rm_rel_info.incl.pl1         >ldd>include>mdbm_rm_rel_info.incl.pl1
256          3    10/14/83  1609.1  mdbm_rm_domain_info.incl.pl1      >ldd>include>mdbm_rm_domain_info.incl.pl1
258          4    10/14/83  1609.1  mdbm_rm_attr_info.incl.pl1        >ldd>include>mdbm_rm_attr_info.incl.pl1
260          5    10/14/83  1608.9  mdbm_move_list.incl.pl1           >ldd>include>mdbm_move_list.incl.pl1
262          6    10/14/83  1609.1  vu_typed_vector.incl.pl1          >ldd>include>vu_typed_vector.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
FB35_DESC                       000000 constant        bit(36)                  initial dcl 323 set ref 191
MRDS_AREA                       000406 automatic       char(8)                  initial unaligned dcl 1-25 set ref 1-25* 1-41
VAR_BIT                                constant        fixed bin(5,0)           initial dcl 325 ref 178 186
VAR_CHAR                               constant        fixed bin(5,0)           initial dcl 326 ref 178 186
a_area_ptr                             parameter       pointer                  dcl 264 ref 18 18 83
a_desc_ptr                             parameter       pointer                  dcl 110 set ref 105 105 118*
a_item_ptr                             parameter       pointer                  dcl 110 set ref 105 105 118*
a_ml_ptr                               parameter       pointer                  dcl 264 ref 18 18 86
a_raip                                 parameter       pointer                  dcl 110 set ref 105 105 118*
a_rmri_ptr                             parameter       pointer                  dcl 264 ref 18 18 84
a_simple_typed_vector_ptr              parameter       pointer                  dcl 264 ref 18 18 85
a_targ_ptr                             parameter       pointer                  dcl 110 set ref 105 105 118*
actual_allocated_size           000404 automatic       fixed bin(35,0)          dcl 1-24 set ref 1-39* 1-43 1-46 1-50 1-52
addr                                                   builtin function         dcl 330 ref 150 150 170 176 178 184 186 190 191 195
                                                                                  195 209 209 230
aip                                    parameter       pointer                  dcl 128 ref 124 134
alloc_value                            based           bit(36)                  array unaligned dcl 1-35 ref 1-43
alloc_value_ptr                 000410 automatic       pointer                  dcl 1-34 set ref 1-43* 1-44 1-48* 1-53
area_id                                based           char(8)                  level 2 packed unaligned dcl 1-28 ref 1-41
area_ptr                        000354 automatic       pointer                  dcl 343 set ref 83* 117* 165* 226*
attr_index                2            based           fixed bin(17,0)          array level 3 dcl 5-11 ref 90
attr_ptrs                              based           pointer                  array level 2 dcl 2-119 ref 90
b_area_ptr                             parameter       pointer                  dcl 110 ref 105 105 117
bit36                                  based           bit(36)                  unaligned dcl 294 ref 139 139 202
bit_length               24            based           fixed bin(35,0)          level 2 dcl 4-46 ref 225 226 231 233 235
cd                                     parameter       fixed bin(35,0)          dcl 247 ref 243 249
code                                   parameter       fixed bin(35,0)          dcl 286 in procedure "get_data" set ref 18 18 100*
                                                                                  105 105 120* 249*
code                      0(18) 000336 automatic       fixed bin(17,0)          initial level 2 in structure "decode_list" packed
                                                                                  unaligned dcl 311 in procedure "get_data" set ref
                                                                                  311*
code_ptr                  6     000336 automatic       pointer                  level 2 dcl 311 set ref 190*
coded_ptr                14     000336 automatic       pointer                  level 2 dcl 311 set ref 191*
cu_$generate_call               000016 constant        entry                    external dcl 339 ref 195
db_alloc                        000326 automatic       bit(1)                   dcl 278 set ref 228*
db_desc                  10            based           bit(36)                  level 2 dcl 3-35 set ref 139 150 150 183
db_descriptor                   000333 automatic       bit(36)                  dcl 288 set ref 183* 184
db_val_ptr                      000116 automatic       pointer                  dcl 270 set ref 150* 182 226* 227 230* 231 235
dbd_ptr                  10     000336 automatic       pointer                  level 2 dcl 311 set ref 184* 186 186
dbv_ptr                   2     000336 automatic       pointer                  level 2 dcl 311 set ref 182* 186* 186
decd_proc                30(02)        based           bit(1)                   level 2 packed unaligned dcl 3-35 ref 137
decd_proc_entry          24            based           entry variable           level 2 dcl 3-35 set ref 195*
decode_list                     000336 automatic       structure                level 1 dcl 311 set ref 195 195
defn_order               22            based           fixed bin(17,0)          level 2 dcl 4-46 ref 92
descriptor                             based           structure                level 1 dcl 300
dimension                 1            based           structure                array level 2 packed unaligned dcl 6-17
domain_ptr               26            based           pointer                  level 2 dcl 4-46 ref 135
error_table_$noalloc            000010 external static fixed bin(35,0)          dcl 329 set ref 166* 227*
i                               000331 automatic       fixed bin(17,0)          dcl 284 set ref 88* 90 95 95*
icode                           000332 automatic       fixed bin(35,0)          dcl 286 set ref 133* 150* 155 155* 190 200 200* 209*
                                                                                  214 214*
ip                                     parameter       pointer                  dcl 128 ref 124 144 235
item                      2            based           structure                array level 2 dcl 5-11
item_ptr                        000114 automatic       pointer                  dcl 270 set ref 92* 95*
len                             000330 automatic       fixed bin(17,0)          dcl 283 set ref 143* 144 144 204* 205 205 233* 235
length_free_space         3            based           fixed bin(35,0)          level 2 dcl 1-28 set ref 1-46 1-52* 1-52
ml_ptr                          000106 automatic       pointer                  dcl 5-18 set ref 86* 88 90 95 95
mod                                                    builtin function         dcl 1-26 ref 1-39
move_list                              based           structure                level 1 dcl 5-11
mrds_area                              based           structure                level 1 unaligned dcl 1-28
mrds_area_ptr                          parameter       pointer                  dcl 1-21 ref 1-10 1-40 1-41 1-43 1-46 1-48 1-48 1-50
                                                                                  1-50 1-52 1-52
mu_convert                      000012 constant        entry                    external dcl 334 ref 150 209
mu_data_length$get_data_bit_length
                                000014 constant        entry                    external dcl 335 ref 143 204
nargs                           000336 automatic       fixed bin(17,0)          initial level 2 packed unaligned dcl 311 set ref
                                                                                  311*
ndescs                    1     000336 automatic       fixed bin(17,0)          initial level 2 packed unaligned dcl 311 set ref
                                                                                  311*
nitems                                 based           fixed bin(17,0)          level 2 dcl 5-11 ref 88
nkey_attr                24            based           fixed bin(17,0)          level 2 dcl 2-119 ref 90
null                                                   builtin function         dcl 330 in procedure "get_data" ref 3-51 4-65 166
                                                                                  227
null                                                   builtin function         dcl 1-26 in procedure "mrds_space_allocate" ref 1-40
                                                                                  1-40 1-55
offset_to_free_word       2            based           fixed bin(35,0)          level 2 dcl 1-28 set ref 1-48 1-50* 1-50
p_work_area                            based           area                     dcl 1-33 ref 1-43
pad                       1(18) 000336 automatic       fixed bin(17,0)          initial level 2 packed unaligned dcl 311 set ref
                                                                                  311*
ptr                                                    builtin function         dcl 1-26 ref 1-48
rai_ptr                         000104 automatic       pointer                  initial dcl 4-65 set ref 4-65* 134* 135 225 226 231
                                                                                  233 235
raip                            000112 automatic       pointer                  dcl 270 set ref 90* 92 95*
rdi_ptr                         000102 automatic       pointer                  initial dcl 3-51 set ref 3-51* 135* 137 139 139 143
                                                                                  150 150 164 165 172 175 183 195 202 204 209 209
requested_word_size                    parameter       fixed bin(35,0)          dcl 1-22 ref 1-10 1-39 1-39
rm_attr_info                           based           structure                level 1 dcl 4-46
rm_domain_info                         based           structure                level 1 dcl 3-35
rm_rel_info                            based           structure                level 1 dcl 2-119
rmri_ptr                        000100 automatic       pointer                  dcl 2-156 set ref 84* 90
simple_typed_vector                    based           structure                level 1 packed unaligned dcl 6-17
simple_typed_vector_ptr         000110 automatic       pointer                  dcl 6-33 set ref 85* 92
src_str                                based           bit                      unaligned dcl 223 in procedure "align_item" ref 235
src_str                                based           bit                      unaligned dcl 282 in procedure "get_data" ref 144
                                                                                  205
string                    1            based           char                     level 2 packed unaligned dcl 296 set ref 178 186
target_data_ptr                        parameter       pointer                  dcl 128 set ref 124 144 150* 205 209*
target_desc_ptr                        parameter       pointer                  dcl 128 set ref 124 139 139 150* 202 209*
target_str                             based           bit                      unaligned dcl 281 set ref 144* 205*
type                      0(01)        based           fixed bin(6,0)           level 2 packed unsigned unaligned dcl 300 ref 178
                                                                                  178 186 186
ub_alloc                        000327 automatic       bit(1)                   dcl 278 set ref 168*
ud_ptr                   12     000336 automatic       pointer                  level 2 dcl 311 set ref 176* 178 178
user_bit_len             12            based           fixed bin(17,0)          level 2 dcl 3-35 ref 164 165 172
user_desc                11            based           bit(36)                  level 2 dcl 3-35 set ref 139 143 175 202 204 209 209
user_desc_ptr             6            based           pointer                  array level 3 dcl 5-11 set ref 95*
user_descriptor                 000334 automatic       bit(36)                  dcl 289 set ref 175* 176
user_ptr                  4            based           pointer                  array level 3 dcl 5-11 set ref 95*
user_val_ptr                    000120 automatic       pointer                  dcl 270 set ref 165* 166 170* 172 174 205 209*
uv_ptr                    4     000336 automatic       pointer                  level 2 dcl 311 set ref 174* 178* 178
value_for_db                           based           bit                      unaligned dcl 292 set ref 231* 235*
value_for_user                         based           bit                      unaligned dcl 293 set ref 172*
value_ptr                 1            based           pointer                  array level 3 packed unaligned dcl 6-17 ref 92
varying                                based           structure                level 1 packed unaligned dcl 296
wksp1                           000122 automatic       fixed bin(71,0)          array dcl 275 set ref 230
wksp2                           000224 automatic       fixed bin(71,0)          array dcl 275 set ref 170

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
GENERAL_TYPED_VECTOR_TYPE              internal static fixed bin(17,0)          initial dcl 6-43
OLD_SIMPLE_TYPED_VECTOR_TYPE           internal static fixed bin(17,0)          initial dcl 6-43
SIMPLE_TYPED_VECTOR_TYPE               internal static fixed bin(17,0)          initial dcl 6-43
general_typed_vector                   based           structure                level 1 packed unaligned dcl 6-24
general_typed_vector_ptr               automatic       pointer                  dcl 6-38
gtv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 6-40
ml_nitems_init                         automatic       fixed bin(17,0)          dcl 5-19
natts_init                             automatic       fixed bin(17,0)          dcl 2-157
nkey_attr_init                         automatic       fixed bin(17,0)          dcl 2-157
nvar_atts_init                         automatic       fixed bin(17,0)          dcl 2-157
stv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 6-35
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 328
work_area                              based           area                     dcl 291

NAMES DECLARED BY EXPLICIT CONTEXT.
align_item                      000543 constant        entry                    internal dcl 219 ref 148 162
error                           000713 constant        entry                    internal dcl 243 ref 155 166 200 214 227
exit                            000146 constant        label                    dcl 102 ref 250
get_data                        000031 constant        entry                    external dcl 18
get_data_item                   000155 constant        entry                    external dcl 105
get_item                        000224 constant        entry                    internal dcl 124 ref 95 118
item                            000171 constant        entry                    external dcl 105
mrds_space_allocate             000622 constant        entry                    internal dcl 1-10 ref 165 226
mu_get_data                     000045 constant        entry                    external dcl 18

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1060        1100     746        1070
Length      1410     746        20         273     111           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
get_data                            318 external procedure  is an external procedure.  
get_item                                internal procedure  shares stack frame of external procedure get_data.  
align_item                              internal procedure  shares stack frame of external procedure get_data.  
mrds_space_allocate                     internal procedure  shares stack frame of external procedure get_data.  
error                                   internal procedure  shares stack frame of external procedure get_data.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
get_data                 000100 rmri_ptr                    get_data
                         000102 rdi_ptr                     get_data
                         000104 rai_ptr                     get_data
                         000106 ml_ptr                      get_data
                         000110 simple_typed_vector_ptr     get_data
                         000112 raip                        get_data
                         000114 item_ptr                    get_data
                         000116 db_val_ptr                  get_data
                         000120 user_val_ptr                get_data
                         000122 wksp1                       get_data
                         000224 wksp2                       get_data
                         000326 db_alloc                    get_data
                         000327 ub_alloc                    get_data
                         000330 len                         get_data
                         000331 i                           get_data
                         000332 icode                       get_data
                         000333 db_descriptor               get_data
                         000334 user_descriptor             get_data
                         000336 decode_list                 get_data
                         000354 area_ptr                    get_data
                         000404 actual_allocated_size       mrds_space_allocate
                         000406 MRDS_AREA                   mrds_space_allocate
                         000410 alloc_value_ptr             mrds_space_allocate

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return              mod_fx1             ext_entry           trunc_fx2           divide_fx1
divide_fx3          alloc_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cu_$generate_call             mu_convert                    mu_data_length$get_data_bit_length

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$noalloc




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 3   51 000007    4   65 000011       311 000012        18 000024        83 000056        84 000062        85 000065
     86 000070        88 000073        90 000103        92 000120        95 000127        98 000143       100 000145
    102 000146       105 000147       117 000202       118 000206       120 000222       122 000223       124 000224
    133 000226       134 000227       135 000232       137 000234       139 000237       143 000251       144 000266
    145 000276       148 000277       150 000300       155 000323       158 000327       162 000330       164 000331
    165 000335       166 000346       168 000361       169 000363       170 000364       172 000366       174 000374
    175 000375       176 000377       178 000401       182 000414       183 000416       184 000420       186 000422
    190 000435       191 000437       195 000441       200 000454       202 000460       204 000470       205 000505
    206 000514       209 000515       214 000536       239 000542       219 000543       225 000544       226 000550
    227 000563       228 000576       229 000600       230 000601       231 000603       233 000611       235 000613
    237 000621    1   10 000622    1   25 000624    1   39 000626    1   40 000636    1   41 000645    1   43 000653
 1   44 000662    1   46 000665    1   48 000670    1   50 000674    1   52 000700    1   53 000706    1   55 000710
    243 000713       249 000715       250 000717


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
