	COMPILATION LISTING OF SEGMENT alm_cross_reference_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/17/88  1010.2 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /* This routine writes the cross reference table into the listing for ALM.
       14*   The data is accumulated by table_ in a list structure addressable through
       15*   the global (varcom) cell symbol_tree_rel.  This module merely formats
       16*   the information and calls prlst_ for each line.
       17*
       18*   First written on 07/23/72 at 20:41:52 by R F Mabee.
       19*   Modified on 11/22/72 at 22:39:54 by R F Mabee. 
       20*   Modified to change tree_recurse subprocedure from recursive to iterative one
       21*	  on 02/10/76 by Eugene E Wiatrowski		*/
       22 
       23 alm_cross_reference_: procedure;
       24 
       25  declare	com_err_ entry options(variable);
       26 
       27  declare	1 word based aligned,
       28 	  2 left bit (18) unaligned,
       29 	  2 right bit (18) unaligned;
       30 
       31  declare	eb_data_$lavptr external static pointer;
       32 
       33  declare	cv_bin_$dec external entry (fixed binary, char (*)),
       34 	cv_bin_$oct external entry (fixed binary, char (*)),
       35 	prlst_ external entry (char (*));
       36 
       37 
       38  declare	(pointer, addr, substr, char, fixed, bit, length, convert) builtin;
       39 
       40 
  1     1 /* Begin include file alm_xref_nodes.incl.pl1.
  1     2*   This file defines the structures of the two nodes which make up the symbol tree
  1     3*   maintained by ALM (table_) for use in generating the cross-reference.
  1     4*   First written on 07/23/72 at 14:54:03 by R F Mabee.
  1     5*   Last modified on 07/27/72 at 08:48:06 by R F Mabee. */
  1     6 
  1     7  declare	1 symbol_tree_node based aligned,		/* Binary name tree, sorted alphabetically. */
  1     8 	  2 high_sublist fixed binary,		/* Relative pointer to symbol_tree_node.name_rel. */
  1     9 	  2 low_sublist fixed binary,
  1    10 	  2 line_list_forward_rel bit (18) unaligned,	/* Thread of line number nodes. */
  1    11 	  2 line_list_backward_rel bit (18) unaligned,	/* They are doubly threaded. */
  1    12 	/* Above prefix must occupy three words, as pointers all point at next item. */
  1    13 	  2 name_rel bit (18) unaligned,		/* Relative pointer to ACC symbol name. */
  1    14 	  2 next_rel bit (18) unaligned,		/* Hash bucket thread. */
  1    15 	  2 flags bit (18) unaligned,		/* Used by table_. */
  1    16 	  2 value bit (18) unaligned,		/* Value associated with symbol. */
  1    17 	  2 location_counter bit (18) unaligned, /* Relative pointer to l.c. bead. */
  1    18 	  2 filler bit (18) unaligned,	/* Probably used, not needed for xref. */
  1    19 	  2 origin bit (18) unaligned,	/* Origin for a location counter node. */
  1    20 	  2 padding bit (18) unaligned;	/* So PL/I does right thing with above. */
  1    21 	/* The format of the rest of the node depends on what kind of symbol it is,
  1    22*	    which is why the line list is put before the visible part of the node. */
  1    23 
  1    24  declare	1 line_node based aligned,			/* Sorted list of referencing line numbers. */
  1    25 	  2 forward_rel bit (18) unaligned,		/* Thread of line_nodes. */
  1    26 	  2 backward_rel bit (18) unaligned,		/* Doubly threaded. */
  1    27 	  2 line_no fixed binary;			/* Combined line number and relative address of file name node. */
  1    28 
  1    29 /* End of include file alm_xref_nodes.incl.pl1. */
       41 
       42 
  2     1 /* Begin include file alm_include_file_info.incl.pl1.
  2     2*   Created on 06/16/72 at 00:18:27 by R F Mabee.
  2     3*   Modified 4/13/77 by Noel I. Morris
  2     4*
  2     5*   This structure is used for the nodes of a linked list describing the source and
  2     6*include files processed by the assembler.  Its primary purpose is to save this
  2     7*information from pass one to pass two to save searching for the include files again.
  2     8*Enough information is saved to create the standard object segment source file map.
  2     9*The list nodes are also temporarily threaded (by the stack_back_pointer item) to form
  2    10*a stack of suspended input files for nested include file use.		*/
  2    11 
  2    12 
  2    13  
  2    14 
  2    15 /****^  HISTORY COMMENTS:
  2    16*  1) change(87-04-28,JRGray), approve(87-07-03,MCR7689),
  2    17*     audit(87-07-09,RWaters), install(87-11-02,MR12.2-1001):
  2    18*     Modified to track more info, (fix for alm 19).
  2    19*                                                   END HISTORY COMMENTS */
  2    20 
  2    21 
  2    22 declare	1 source_info aligned based,
  2    23 	  2 first_word fixed bin (71),	/* Forces even alignment. */
  2    24 
  2    25 	/*  Threading items. */
  2    26 
  2    27 	  2 names_list_pointer pointer,	/* List of file nodes, oldest first. */
  2    28 	  2 stack_back_pointer pointer,	/* Push-down list for nested files, newest first. */
  2    29 
  2    30 	/*  File info passed for pass two. */
  2    31 
  2    32 	  2 source_pointer pointer,		/* Base of include file. */
  2    33 	  2 source_length fixed bin (26),	/* Character count. */
  2    34 	  2 search_name char (32),		/* File name called for (with ".incl.alm"). */
  2    35 
  2    36 	/*  Source map information. */
  2    37 
  2    38 	  2 source_number fixed bin (26),	/* Main source 0, first include 1 ... */
  2    39 	  2 uid bit (36),			/* From segment branch. */
  2    40 	  2 dtm fixed bin (71),		/* Watch for alignment. */
  2    41 	  2 pathname char (256),		/* Actual pathname. */
  2    42 	  2 source_map_offset fixed bin (26),	/* Used only in alm_source_map_. */
  2    43 	  2 source_map_length fixed bin (26),	/* Ditto. Saves stuff from pre-counting for later use. */
  2    44 
  2    45 	/*  The rest of this node stores position in this file when another
  2    46*	    level of include file is invoked. */
  2    47 
  2    48 	  2 curr_char_no fixed bin (26),	/* eb_data_$curr_char_no. */
  2    49 	  2 line_begin_offset fixed bin (26),	/* begin_line. */
  2    50 	  2 line_number fixed bin (26),		/* binlin. */
  2    51 	  2 savep ptr unal,				/* saved source pointer */
  2    52 	  2 savel fixed bin (24),			/* saved source length */
  2    53 
  2    54 	  2 last_word fixed bin (26);		/* Need [fixed (rel (last), 18) -
  2    55*					   fixed (rel (first), 18))] words. */
  2    56 
  2    57 
  2    58 /* End of include file alm_include_file_info.incl.pl1. */
       43 
       44 
  3     1 /* Begin include file alm_list_beads.incl.pl1. */
  3     2 /* Created 19 November 1970, R H Campbell. */
  3     3 /* Modified 25 November 1970, R H Campbell. */
  3     4 /* Added entry_bead_ptr to external_definition_bead for new object segment format, 30 April 1972, R F Mabee. */
  3     5 /* Last modified on 04/30/72 at 23:40:00 by R F Mabee. */
  3     6 
  3     7  declare	1 acc based aligned,				/* ACC format string for symbol name. */
  3     8  	  2 lg bit (9) unaligned,				/* The length. */
  3     9  	  2 cs character (31) unaligned;			/* The string. */
  3    10 
  3    11  declare	1 call_out_bead based aligned,			/* Mastermode callout link list bead. */
  3    12  	  2 (kind, next) bit (18) unaligned,			/* Kind of bead (3), rel ptr to next bead. */
  3    13  	  2 (expression, modifier) bit (18) unaligned,		/* Rel ptr to expression bead, modifier. */
  3    14  	  2 (type_pair, transfer_vector_no) bit (18) unaligned,	/* Rel ptr to type pair bead, ? */
  3    15  	  2 (call_pc, crh) bit (18) unaligned,			/* Location of call, ? */
  3    16  	  2 (clh, inhibit) bit (18) unaligned;			/* ? inhibit bit. */
  3    17 
  3    18  declare	1 entry_bead based aligned,				/* Entry interlude link list bead. */
  3    19  	  2 (kind, next) bit (18) unaligned,			/* Kind of bead (2), rel ptr to next bead. */
  3    20  	  2 (link_no, transfer_vector_no) bit (18) unaligned,	/* ? */
  3    21  	  2 (transfer_vector, inhibit) bit (18) unaligned;	/* Rel ptr to transfer vector bead, inhibit bit. */
  3    22 
  3    23  declare	1 expression_bead based aligned,			/* Expression list bead. */
  3    24  	  2 (location, next) bit (18) unaligned,		/* Location of output expression word, rel ptr to next bead. */
  3    25  	  2 (type_pair, expression) bit (18) unaligned,		/* Rel ptr to type pair bead, expression value. */
  3    26  	  2 (clh, location_counter) bit (18) unaligned;		/* ? */
  3    27 
  3    28  declare	1 external_definition_bead based aligned,		/* External definition list bead. */
  3    29  	  2 (name, next) bit (18) unaligned,			/* Rel ptr to name list bead, rel ptr to next bead. */
  3    30  	  2 (location, class) bit (18) unaligned,		/* ? */
  3    31  	  2 (trap, location_counter) bit (18) unaligned,		/* Rel ptr to trap list bead, ? */
  3    32 	  2 entry_bead_ptr bit (18) unaligned;			/* Non-zero if defines entry. */
  3    33 
  3    34  declare	1 link_bead based aligned,				/* Element of link list. */
  3    35  	  2 (kind, next) bit (18) unaligned,			/* Kind of bead (1), rel ptr to next bead. */
  3    36  	  2 (expression, modifier) bit (18) unaligned;		/* Rel ptr to expression bead, modifier field. */
  3    37 
  3    38  declare	1 literal_bead based aligned,				/* Literal list bead. */
  3    39  	  2 (location, next) bit (18) unaligned,		/* "Load address" of literal, rel ptr to next bead. */
  3    40  	  2 (location_counters, size) bit (18) unaligned,		/* Rel ptr to location counter rel ptrs, size in words. */
  3    41  	  2 words (10),					/* The literal. */
  3    42 	    3 (left, right) bit (18) unaligned;			/* Separate relocatable halves. */
  3    43 
  3    44  declare	1 location_counter_bead based aligned,			/* Symbol table bucket list bead for location counter name. */
  3    45  	  2 (symbol, next) bit (18) unaligned,			/* Rel ptr to symbol name, rel ptr to next bead. */
  3    46  	  2 (flags, value) bit (18) unaligned,			/* Symbol flags, current value. */
  3    47  	  2 (left_join, right_join) bit (18) unaligned,		/* Rel ptrs to joined location counter beads. */
  3    48  	  2 (origin, max_value) bit (18) unaligned,		/* Lowest value, highest value. */
  3    49  	  2 (mod_value, section) bit (18) unaligned;		/* Indicator for rounding origin, section in which it occurs. */
  3    50 
  3    51  declare	1 location_counters (10) based aligned,			/* Location counter rel ptrs for relocatable literals. */
  3    52  	  2 (left, right) bit (18) unaligned;			/* One for each half word. */
  3    53 
  3    54  declare	1 name_bead based aligned,				/* Name list bead. */
  3    55  	  2 (name, next) bit (18) unaligned,			/* Rel ptr to name, rel ptr to next bead. */
  3    56  	  2 (section, location) bit (18) unaligned;		/* ? */
  3    57 
  3    58  declare	1 statement_bead based aligned,			/* "Collation tape" list bead. */
  3    59  	  2 (value, next) bit (18) unaligned,			/* Value of current location counter, rel ptr to next bead. */
  3    60  	  2 flags bit (36),					/* Flags for this statement. */
  3    61  	  2 location_counter bit (18);			/* Rel ptr to active location counter bead. */
  3    62 
  3    63  declare	1 symbol_bead based aligned,				/* Symbol table hashcode bucket list bead. */
  3    64  	  2 (symbol, next) bit (18) unaligned,			/* Rel ptr to symbol name, rel ptr to next bead. */
  3    65  	  2 (flags, value) bit (18) unaligned,			/* Symbol flags, symbol value. */
  3    66  	  2 location_counter bit (18);			/* Rel ptr to related location counter bead. */
  3    67 
  3    68  declare	1 transfer_vector_bead based aligned,			/* Transfer vector list bead. */
  3    69  	  2 (clh, next) bit (18) unaligned,			/* ?, rel ptr to next bead. */
  3    70  	  2 (transfer_vector_no, location) bit (18) unaligned,	/* ? */
  3    71  	  2 (location_counter, inhibit) bit (18) unaligned;	/* ? inhibit bit. */
  3    72 
  3    73  declare	1 trap_bead based aligned,				/* Trap list bead. */
  3    74  	  2 (location, next) bit (18) unaligned,		/* Location of output trap word, rel ptr to next bead. */
  3    75  	  2 (call, argument) bit (18) unaligned;		/* Rel ptr to call link bead, rel ptr to argument link bead. */
  3    76 
  3    77  declare	1 type_pair_bead based aligned,			/* Type pair list bead. */
  3    78  	  2 (location, next) bit (18) unaligned,		/* Location of output type pair words, rel ptr to next bead. */
  3    79  	  2 (type, trap) bit (18) unaligned,			/* Type of link, rel ptr to trap list bead. */
  3    80  	  2 (segment, symbol) bit (18) unaligned;		/* Rel ptrs to name list beads for segment, symbol. */
  3    81 
  3    82 /* End of include file alm_list_beads.incl.pl1. */
       45 
       46 
  4     1 /* Begin include file varcom.incl.pl1. */
  4     2 /* RHG added new variables 9/7/70. */
  4     3 /* RFM added new cells for new object segment format and first-reference trap, 27 March 1972. */
  4     4 /* RFM added include file stuff, then cross referencer stuff, 23 July 1972. */
  4     5 /* Last modified on 07/23/72 at 04:19:25 by R F Mabee. */
  4     6   
  4     7  declare	1 eb_data_$varcom external aligned,
  4     8 	  2 (brk(2),	nbrk(2),	sym(8),	dsym(8),old_locsym,	pc,	spc,	tpc,
  4     9 	   pclst,		p2pcl,	old_ndpcls,	tvorg,	tvcnt,	tvlth,	litorg,
  4    10 	   litc,		deforg,	defc,	defcnt,	stkc,	lnkc,	lnkno,
  4    11 	   litlst,	old_ndltls, lnklst,	old_ndlkls,	explst,	blklst,	namlst,
  4    12 	   trplst,	xdflst,	tvlst,	begin_line, tpass1,	tpass2,	tpostp,
  4    13 	   tinhib,	tmmode,	txonly,	tmm2,	txo2,	tprot,	tcall,
  4    14 	   tmvdef,	tpulnk,	tfatal,	calrho,	lreter,	passwd,	binlin,
  4    15 	   nboxes,   box(0:210),   myfil,	mynam,	myblk,	mylnk,	tpost1 ) fixed bin (26) ,
  4    16 	  2 source_printed bit(1) aligned,
  4    17 	  2 (ndpcls,	ndltls,	ndlkls,	ndtvls) ptr,
  4    18 	  2 (basno,	value,	admod,	b29,	iaddr,	symlnk ) fixed bin (26),
  4    19 	  2 (itxtmod, ilnkmod, entrieslc, include_file_list, include_index,
  4    20 	     first_ref_trap_proc_linkno, first_ref_trap_arg_linkno,
  4    21 	     text_section_length) fixed binary (26),
  4    22 	  2 (include_info_stack, include_name_list_base, include_name_list_top) pointer,
  4    23 	  2 symbol_tree_rel fixed binary (26);
  4    24 
  4    25 /* End of the include file varcom.incl.pl1. */
       47 
       48 
  5     1 
  5     2 
  5     3 
  5     4 	/*	include file for CONCOM */
  5     5 
  5     6 declare 1 eb_data_$concom ext aligned,
  5     7         2 (ap,	ab,	bp,	bb,	lp,	lb,	sp,	sb,
  5     8 		clunk,	clint,	clext,	clbas,	clstk,	clndx,	clmlc,	fdef,
  5     9 		fmul,	fphs,	fset,	frel,	fabs,	fbol,	fcom,	find,
  5    10 		flocrf,	fequrf,	fbolrf,	fsetrf,	fbasrf,	fsegrf,	fstkrf,	fndxrf,
  5    11 		fmlcrf,	onesev,	twosev,	thrsev,	forsev,	fivsev,	sixsev,	allsev,
  5    12 		symbas(8),mir,	mri,	mdu,	mdl,	mx0,	mx1,	mpc,	
  5    13 		mpci,	mfi,	mits,	mitb,	ixtern,	intern,	iassgn,	iserch,
  5    14 		ixvrvl,	ixvrvp,	invrvl,	invrvp,	ibvrvl,	ibvrvp,	iaccvl,	iacivl,
  5    15 		mcmpq,	mcmpx0,	mldaq,	mldq,	mldx0,	mnopdu,	mstcd,	mtra,
  5    16 		mtnc,	mtnz,	meabsp,	meapap,	meapbp,	meaplp,	meapsp,	mstpap,
  5    17 		mstpbp,	mstplp,	mstpsp,	i1542,	i642,	i3333,	i66,	ibb,
  5    18 		ibsp,	nullf,	smxer(2),	sentry(2),sretrn(2),	dzero(2) ) fixed bin (26) aligned ;
  5    19   
  5    20 	/* end of the include file for CONCOM */
       49 
       50 
       51 
       52 /* Main procedure, print heading and recurse over tree. */
       53 
       54 	if symbol_tree_rel = 0 then return;
       55 	call prlst_ ("               MULTICS ASSEMBLY CROSS REFERENCE LISTING
       56 
       57    Value        Symbol                   Source file   Line number
       58 ");
       59 	call tree_recurse ((symbol_tree_rel));
       60 	return;
       61 
       62 tree_recurse: procedure (tree_rel);		/*  walks the cross-reference tree. */
       63 
       64  declare	(tree_rel,subtree_rel,stack_offset)	 fixed binary (17);
       65 
       66  declare	tree_ptr 		pointer;
       67 
       68 declare	returning		bit(1) aligned;
       69 
       70 declare	stack(1000)	fixed bin;
       71 
       72 	stack_offset = 0;
       73 	returning = "0"b;
       74 
       75 	do while(tree_rel > 0);
       76 	   tree_ptr = pointer(eb_data_$lavptr,tree_rel);
       77 	   subtree_rel = tree_ptr -> symbol_tree_node.low_sublist;
       78 
       79 	   if subtree_rel > 0 & ^ returning
       80 	      then do;
       81 		 /* push on stack */
       82 		 if stack_offset < hbound(stack,1)
       83 		    then do;
       84 			stack_offset = stack_offset + 1;
       85 			stack(stack_offset) = tree_rel;
       86 			end;
       87 		    else do;
       88 			call com_err_(0,"alm","cross-reference tree too big to display");
       89 			return;
       90 			end;
       91 		 end;
       92 	      else do;
       93 		 call do_symbol(tree_ptr);
       94 		 subtree_rel = tree_ptr -> symbol_tree_node.high_sublist;
       95 		 if subtree_rel = 0
       96 		    then do;
       97 			/* pop the stack */
       98 			if stack_offset > 0
       99 			   then do;
      100 				subtree_rel = stack(stack_offset);
      101 				stack_offset = stack_offset - 1;
      102 				end;
      103 			returning = "1"b;
      104 			end;
      105 		    else returning = "0"b;
      106 		 end;
      107 	   tree_rel = subtree_rel;
      108 	end;
      109 
      110 	end;
      111 
      112 do_symbol: procedure (tree_ptr);		/* Put out name, value, and referencing line numbers for one symbol. */
      113  declare	tree_ptr pointer;
      114 
      115  declare	line_rel bit (18), line_ptr pointer,
      116 	name_ptr pointer, name_len fixed binary,
      117 	line_no fixed binary, file_no fixed binary, last_file_no fixed binary,
      118 	value fixed binary, buf_len fixed binary, buf_len_two fixed binary,
      119 	buffer char (140) varying, numbuf char (12);
      120 
      121  declare	1 acc based aligned,
      122 	  2 len bit (9) unaligned,
      123 	  2 str char (32) unaligned;
      124 
      125 
      126 	line_rel = tree_ptr -> symbol_tree_node.line_list_forward_rel;
      127 	if line_rel = "0"b then return;
      128 
      129 	if substr (tree_ptr -> symbol_tree_node.flags, 1, 3) = "110"b
      130 	then value = fixed (tree_ptr -> symbol_tree_node.origin, 18);	/* Location counter node - print origin. */
      131 	else value = fixed (tree_ptr -> symbol_tree_node.value, 18);
      132 	if substr (tree_ptr -> symbol_tree_node.flags, 1, 3) = "001"b
      133 	   then if tree_ptr -> symbol_tree_node.location_counter ^= "0"b then do;
      134 		name_ptr = pointer (eb_data_$lavptr, tree_ptr -> symbol_tree_node.location_counter);
      135 		value = value + fixed (name_ptr -> location_counter_bead.origin, 18);
      136 		end;
      137 
      138 	if substr (tree_ptr -> symbol_tree_node.flags, 1, 3) = "010"b
      139 	then numbuf = "";	/* No useful value in external symbol node. */
      140 	else if substr (tree_ptr -> symbol_tree_node.flags, 1, 3) = "000"b
      141 	then numbuf = "";	/* Or in undefined symbol node. */
      142 	else call cv_bin_$oct (value, numbuf);
      143 	buffer = numbuf || (4)" ";
      144 
      145 	name_ptr = pointer (eb_data_$lavptr, tree_ptr -> symbol_tree_node.name_rel);
      146 	name_len = fixed (name_ptr -> acc.len, 9);
      147 	if name_len < 24 then buf_len = 41;		/* Adjust beginning of next field to 6-character boundary. */
      148 	else buf_len = 23 + name_len - mod (name_len, 6);
      149 	buffer = buffer || substr (name_ptr -> acc.str, 1, name_len);
      150 	buffer = char (buffer, buf_len);
      151 
      152 	last_file_no = 0;
      153 
      154 line_loop:	line_ptr = pointer (eb_data_$lavptr, line_rel);
      155 		line_no = line_ptr -> line_node.line_no;
      156 		file_no = convert (file_no, addr (line_no) -> word.left);
      157 		line_no = convert (line_no, addr (line_no) -> word.right);
      158 
      159 		line_rel = line_ptr -> line_node.forward_rel;
      160 
      161 		if file_no ^= last_file_no then do;
      162 			name_ptr = pointer (eb_data_$lavptr, file_no);
      163 			name_len = index (name_ptr -> source_info.search_name, " ") - 1;
      164 			if name_len <= 0 then name_len = length (name_ptr -> source_info.search_name);
      165 
      166 		/* Strip off .alm, .incl suffixes if present. */
      167 
      168 			if name_len > 4
      169 			   then if substr (name_ptr -> source_info.search_name, name_len - 3, 4) = ".alm"
      170 			   	 then name_len = name_len - 4;
      171 			if name_len > 5
      172 			   then if substr (name_ptr -> source_info.search_name, name_len - 4, 5) = ".incl"
      173 				 then name_len = name_len - 5;
      174 
      175 			if length (buffer) > buf_len then do;
      176 				call prlst_ ((buffer));
      177 				buffer = char ("", buf_len);
      178 				end;
      179 			if name_len < 12 then buf_len_two = buf_len + 12;	/* Adjust position to 6-character boundary. */
      180 			else buf_len_two = buf_len + 6 + name_len - mod (name_len, 6);
      181 
      182 			buffer = buffer || substr (name_ptr -> source_info.search_name, 1, name_len) || ":";
      183 			buffer = char (buffer, buf_len_two);
      184 			last_file_no = file_no;
      185 			end;
      186 
      187 		else if length (buffer) >= 120
      188 		        then if line_rel ^= "0"b then do;	/* Avoid single entry on last line. */
      189 			call prlst_ ((buffer));
      190 			buffer = char ("", buf_len_two);
      191 			end;
      192 
      193 		call cv_bin_$dec (line_no, numbuf);
      194 		buffer = buffer || substr (numbuf, 8, 5);
      195 		if line_rel ^= "0"b then do;
      196 			buffer = buffer || ",";
      197 			goto line_loop;
      198 			end;
      199 	/* End of line_loop. */
      200 	call prlst_ (buffer || ".");
      201 	end;
      202 end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/17/88  0938.2  alm_cross_reference_.pl1          >spec>install>1170>alm_cross_reference_.pl1
41           1    05/06/74  1740.3  alm_xref_nodes.incl.pl1           >ldd>include>alm_xref_nodes.incl.pl1
43           2    11/02/87  1305.6  alm_include_file_info.incl.pl1    >ldd>include>alm_include_file_info.incl.pl1
45           3    01/12/79  1050.3  alm_list_beads.incl.pl1           >ldd>include>alm_list_beads.incl.pl1
47           4    10/21/74  1242.9  varcom.incl.pl1                   >ldd>include>varcom.incl.pl1
49           5    10/21/74  1243.0  concom.incl.pl1                   >ldd>include>concom.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
acc                                    based           structure                level 1 dcl 121
addr                                                   builtin function         dcl 38 ref 156 157
buf_len                         002105 automatic       fixed bin(17,0)          dcl 115 set ref 147* 148* 150 175 177 179 180
buf_len_two                     002106 automatic       fixed bin(17,0)          dcl 115 set ref 179* 180* 183 190
buffer                          002107 automatic       varying char(140)        dcl 115 set ref 143* 149* 149 150* 150 175 176 177*
                                                                                  182* 182 183* 183 187 189 190* 194* 194 196* 196
                                                                                  200
char                                                   builtin function         dcl 38 ref 150 177 183 190
com_err_                        000010 constant        entry                    external dcl 25 ref 88
convert                                                builtin function         dcl 38 ref 156 157
cv_bin_$dec                     000014 constant        entry                    external dcl 33 ref 193
cv_bin_$oct                     000016 constant        entry                    external dcl 33 ref 142
eb_data_$lavptr                 000012 external static pointer                  dcl 31 ref 76 134 145 154 162
eb_data_$varcom                 000022 external static structure                level 1 dcl 4-7
file_no                         002102 automatic       fixed bin(17,0)          dcl 115 set ref 156* 156 161 162 184
fixed                                                  builtin function         dcl 38 ref 129 131 135 146
flags                     4            based           bit(18)                  level 2 packed packed unaligned dcl 1-7 ref 129 132
                                                                                  138 140
forward_rel                            based           bit(18)                  level 2 packed packed unaligned dcl 1-24 ref 159
high_sublist                           based           fixed bin(17,0)          level 2 dcl 1-7 ref 94
last_file_no                    002103 automatic       fixed bin(17,0)          dcl 115 set ref 152* 161 184*
left                                   based           bit(18)                  level 2 packed packed unaligned dcl 27 ref 156
len                                    based           bit(9)                   level 2 packed packed unaligned dcl 121 ref 146
length                                                 builtin function         dcl 38 ref 164 175 187
line_list_forward_rel
                          2            based           bit(18)                  level 2 packed packed unaligned dcl 1-7 ref 126
line_no                         002101 automatic       fixed bin(17,0)          dcl 115 in procedure "do_symbol" set ref 155* 156
                                                                                  157* 157 157 193*
line_no                   1            based           fixed bin(17,0)          level 2 in structure "line_node" dcl 1-24
                                                                                  in procedure "alm_cross_reference_" ref 155
line_node                              based           structure                level 1 dcl 1-24
line_ptr                        002074 automatic       pointer                  dcl 115 set ref 154* 155 159
line_rel                        002072 automatic       bit(18)                  packed unaligned dcl 115 set ref 126* 127 154 159*
                                                                                  187 195
location_counter          5            based           bit(18)                  level 2 packed packed unaligned dcl 1-7 ref 132 134
location_counter_bead                  based           structure                level 1 dcl 3-44
low_sublist               1            based           fixed bin(17,0)          level 2 dcl 1-7 ref 77
name_len                        002100 automatic       fixed bin(17,0)          dcl 115 set ref 146* 147 148 148 149 163* 164 164*
                                                                                  168 168 168* 168 171 171 171* 171 179 180 180 182
name_ptr                        002076 automatic       pointer                  dcl 115 set ref 134* 135 145* 146 149 162* 163 164
                                                                                  168 171 182
name_rel                  3            based           bit(18)                  level 2 packed packed unaligned dcl 1-7 ref 145
numbuf                          002153 automatic       char(12)                 packed unaligned dcl 115 set ref 138* 140* 142* 143
                                                                                  193* 194
origin                    6            based           bit(18)                  level 2 in structure "symbol_tree_node" packed
                                                                                  packed unaligned dcl 1-7 in procedure
                                                                                  "alm_cross_reference_" ref 129
origin                    3            based           bit(18)                  level 2 in structure "location_counter_bead" packed
                                                                                  packed unaligned dcl 3-44 in procedure
                                                                                  "alm_cross_reference_" ref 135
pointer                                                builtin function         dcl 38 ref 76 134 145 154 162
prlst_                          000020 constant        entry                    external dcl 33 ref 55 176 189 200
returning                       000112 automatic       bit(1)                   dcl 68 set ref 73* 79 103* 105*
right                     0(18)        based           bit(18)                  level 2 packed packed unaligned dcl 27 ref 157
search_name              11            based           char(32)                 level 2 dcl 2-22 ref 163 164 168 171 182
source_info                            based           structure                level 1 dcl 2-22
stack                           000113 automatic       fixed bin(17,0)          array dcl 70 set ref 82 85* 100
stack_offset                    000107 automatic       fixed bin(17,0)          dcl 64 set ref 72* 82 84* 84 85 98 100 101* 101
str                       0(09)        based           char(32)                 level 2 packed packed unaligned dcl 121 ref 149
substr                                                 builtin function         dcl 38 ref 129 132 138 140 149 168 171 182 194
subtree_rel                     000106 automatic       fixed bin(17,0)          dcl 64 set ref 77* 79 94* 95 100* 107
symbol_tree_node                       based           structure                level 1 dcl 1-7
symbol_tree_rel         470     000022 external static fixed bin(26,0)          level 2 dcl 4-7 ref 54 59
tree_ptr                        000110 automatic       pointer                  dcl 66 in procedure "tree_recurse" set ref 76* 77
                                                                                  93* 94
tree_ptr                               parameter       pointer                  dcl 113 in procedure "do_symbol" ref 112 126 129 129
                                                                                  131 132 132 134 138 140 145
tree_rel                               parameter       fixed bin(17,0)          dcl 64 set ref 62 75 76 85 107*
value                     4(18)        based           bit(18)                  level 2 in structure "symbol_tree_node" packed
                                                                                  packed unaligned dcl 1-7 in procedure
                                                                                  "alm_cross_reference_" ref 131
value                           002104 automatic       fixed bin(17,0)          dcl 115 in procedure "do_symbol" set ref 129* 131*
                                                                                  135* 135 142*
word                                   based           structure                level 1 dcl 27

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
acc                                    based           structure                level 1 dcl 3-7
bit                                                    builtin function         dcl 38
call_out_bead                          based           structure                level 1 dcl 3-11
eb_data_$concom                        external static structure                level 1 dcl 5-6
entry_bead                             based           structure                level 1 dcl 3-18
expression_bead                        based           structure                level 1 dcl 3-23
external_definition_bead               based           structure                level 1 dcl 3-28
link_bead                              based           structure                level 1 dcl 3-34
literal_bead                           based           structure                level 1 dcl 3-38
location_counters                      based           structure                array level 1 dcl 3-51
name_bead                              based           structure                level 1 dcl 3-54
statement_bead                         based           structure                level 1 dcl 3-58
symbol_bead                            based           structure                level 1 dcl 3-63
transfer_vector_bead                   based           structure                level 1 dcl 3-68
trap_bead                              based           structure                level 1 dcl 3-73
type_pair_bead                         based           structure                level 1 dcl 3-77

NAMES DECLARED BY EXPLICIT CONTEXT.
alm_cross_reference_            000071 constant        entry                    external dcl 23
do_symbol                       000231 constant        entry                    internal dcl 112 ref 93
line_loop                       000427 constant        label                    dcl 154 ref 197
tree_recurse                    000123 constant        entry                    internal dcl 62 ref 59

NAMES DECLARED BY CONTEXT OR IMPLICATION.
hbound                                                 builtin function         ref 82
index                                                  builtin function         ref 163
mod                                                    builtin function         ref 148 180

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1114        1140    1022        1124
Length      1420    1022        24         243      71           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
alm_cross_reference_               1214 external procedure  is an external procedure.  
tree_recurse                            internal procedure  shares stack frame of external procedure alm_cross_reference_.  
do_symbol                               internal procedure  shares stack frame of external procedure alm_cross_reference_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
alm_cross_reference_     000106 subtree_rel                 tree_recurse
                         000107 stack_offset                tree_recurse
                         000110 tree_ptr                    tree_recurse
                         000112 returning                   tree_recurse
                         000113 stack                       tree_recurse
                         002072 line_rel                    do_symbol
                         002074 line_ptr                    do_symbol
                         002076 name_ptr                    do_symbol
                         002100 name_len                    do_symbol
                         002101 line_no                     do_symbol
                         002102 file_no                     do_symbol
                         002103 last_file_no                do_symbol
                         002104 value                       do_symbol
                         002105 buf_len                     do_symbol
                         002106 buf_len_two                 do_symbol
                         002107 buffer                      do_symbol
                         002153 numbuf                      do_symbol

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   return_mac          mdfx1               shorten_stack
ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cv_bin_$dec                   cv_bin_$oct                   prlst_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
eb_data_$lavptr               eb_data_$varcom




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     23 000070        54 000076        55 000101        59 000114        60 000122        62 000123        72 000125
     73 000126        75 000127        76 000133        77 000140        79 000142        82 000145        84 000150
     85 000151        86 000154        88 000155        89 000203        91 000204        93 000205        94 000207
     95 000211        98 000212       100 000214       101 000216       103 000220       104 000222       105 000223
    107 000224       108 000227       110 000230       112 000231       126 000233       127 000240       129 000242
    131 000253       132 000256       134 000265       135 000272       138 000275       140 000304       142 000312
    143 000327       145 000343       146 000356       147 000361       148 000366       149 000375       150 000410
    152 000425       154 000427       155 000435       156 000437       157 000442       159 000445       161 000450
    162 000453       163 000457       164 000467       168 000472       171 000502       175 000513       176 000516
    177 000535       178 000552       179 000553       180 000562       182 000572       183 000627       184 000645
    185 000650       187 000651       189 000656       190 000675       191 000712       193 000713       194 000730
    195 000742       196 000744       197 000753       200 000754       201 001003


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
