	COMPILATION LISTING OF SEGMENT tssi_
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 07/12/88  1434.9 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 
       15 
       16 /****^  HISTORY COMMENTS:
       17*  1) change(88-07-06,TLNguyen), approve(88-07-06,MCR7932),
       18*     audit(88-07-08,Parisek), install(88-07-12,MR12.2-1055):
       19*     Fix bug which prevents a null pointer condition raised when calling
       20*     msf_manager_$get_ptr
       21*                                                   END HISTORY COMMENTS */
       22 
       23 
       24 
       25 /*  The translator storage system interface module (tssi_) gets pointers
       26*    to segments needed by translators, relieving them of the burden of
       27*    taking care of acls.  It has several entry points, sometimes in
       28*    pairs - one for strictly Single Segment Files, and another for Multi Segment
       29*    Files.
       30*
       31*    Based on ti_, written by V. Voydock.
       32*
       33*    Coded by Dan Bricklin April 1972
       34*    Recoded to use new ACL primitives and also better methods by M.J. Grady May 1973
       35*    Modified by E Stone April 1974 to call new msf_manager_ entries $acl_add and $acl_delete
       36*    to fix bug in clean_up_file entry and to cleanup code
       37*    Modified by Richard Lamson January 6, 1982 for better interface with initial ACLs
       38*
       39**/
       40 
       41 
       42 tssi_:	proc;
       43 
       44 
       45 dcl
       46 	dirname char(*),
       47 	ename char(*),
       48 	segp ptr,
       49 	aclinfop ptr,
       50 	code fixed bin(35),
       51 	xcode fixed bin(35),
       52 	(addr, null, substr) builtin,
       53 	hcs_$make_seg ext entry(char(*), char(*), char(*), fixed bin(5), ptr, fixed bin(35)),
       54 	hcs_$list_acl entry (char(*), char(*), ptr, ptr, ptr, fixed bin, fixed bin(35)),
       55 	hcs_$replace_acl entry (char(*), char(*), ptr, fixed bin, bit(1), fixed bin(35)),
       56 	term_$nomakeunknown ext entry(ptr, fixed bin(35)),
       57 	error_table_$seg_unknown fixed bin(35) ext,
       58 	error_table_$nolinkag fixed bin(35) ext,
       59 	type fixed bin,
       60 	seg fixed bin static init (1),
       61 	file fixed bin static init (2),
       62 	cleanup condition,
       63 
       64 	1 info_bead based(aclinfop) aligned,
       65 	   2 dirname char(168),
       66 	   2 ename char(32),
       67 	   2 made_seg bit(1),
       68 	   2 mode bit(3),
       69 
       70 	free_area area based(areap),
       71 	areap ptr static init(null),
       72 
       73 
       74 	1 working_acl aligned,
       75 	   2 process_group_id char(32) aligned,
       76 	   2 mode bit(3) unaligned,
       77 	   2 mbz1 bit(33) unaligned,
       78 	   2 mbz2 bit(36),
       79 	   2 err_code fixed bin(35),
       80 
       81 	1 del_acl aligned,
       82 	  2 process_group_id char(32) aligned,
       83 	  2 err_code fixed bin(35),
       84 
       85 	hcs_$delete_acl_entries entry(char(*), char(*), ptr, fixed bin, fixed bin(35)),
       86 	hcs_$add_acl_entries entry(char(*), char(*), ptr, fixed bin, fixed bin(35)),
       87 	hcs_$truncate_seg ext entry(ptr, fixed bin(19), fixed bin(35)),
       88 	bc fixed bin(24),
       89 	msf_manager_$open entry(char(*), char(*), ptr, fixed bin(35)),
       90 	msf_manager_$get_ptr entry(ptr, fixed bin, bit(1), ptr, fixed bin(24), fixed bin(35)),
       91 	msf_manager_$adjust entry(ptr, fixed bin, fixed bin(24), bit(3), fixed bin(35)),
       92 	msf_manager_$close entry(ptr),
       93 	msf_manager_$acl_add entry(ptr, ptr, fixed bin, fixed bin(35)),
       94 	msf_manager_$acl_delete entry(ptr, ptr, fixed bin, fixed bin(35)),
       95 	fcbp ptr,
       96 	bit_count fixed bin(24),
       97 	mode bit(36) aligned,
       98 	hcs_$set_bc_seg ext entry(ptr, fixed bin(24), fixed bin(35)),
       99 	dir char(168),
      100 	enm char(32),
      101 	hcs_$terminate_noname ext entry(ptr, fixed bin(35)),
      102 	component fixed bin,
      103 	get_group_id_ ext entry returns(char(32) aligned),
      104 	get_group_id_$tag_star ext entry returns(char(32) aligned),
      105 	get_system_free_area_ ext entry returns(ptr);
      106 
      107 
      108 /*  The get_segment entry returns a pointer to segment dirname>ename.  The
      109*     segment will have "rw" access to the current user.  If an old acl had to be
      110*     changed to do this, aclinfop is set pointing to information for reseting
      111*     the acl. */
      112 
      113 
      114 get_segment:
      115 	entry(dirname, ename, segp, aclinfop, code);
      116 
      117 
      118 	segp, aclinfop = null;			/* initialize ptrs to show no allocation done */
      119 
      120 	if areap = null then areap = get_system_free_area_();
      121 
      122 	dir = dirname;				/* copy path name arguments */
      123 	enm = ename;
      124 
      125 	call hcs_$make_seg(dir,enm,"",01100b,segp,code); /* try to make seg */
      126 	if segp = null then return;			/* bad error */
      127 
      128 	on cleanup call free_acl_info;
      129 
      130 	allocate info_bead in(free_area) set(aclinfop);	/* grab some storage */
      131 
      132 	aclinfop->info_bead.dirname = dir;		/* save the pathnames */
      133 	aclinfop->info_bead.ename = enm;
      134 
      135 	if code = 0 then do;			/* we made the seg save some info */
      136 	     info_bead.made_seg = "1"b;
      137 	     info_bead.mode = "110"b;			/* save mode */
      138 
      139 	end;
      140 	else do;					/* we did not make it */
      141 	     info_bead.made_seg = "0"b;
      142 	     info_bead.mode = "0"b;
      143 
      144 	     call term_$nomakeunknown(segp,code);	/*term it, but save segno */
      145 
      146 	     if code ^= 0 then do;
      147 		if code ^= error_table_$seg_unknown then
      148 		if code ^= error_table_$nolinkag then return;
      149 		code = 0;
      150 	     end;
      151 
      152 	end;
      153 	call add_acl;					/* add Person.project.tag to acl of segment */
      154 	if code ^= 0 then return;
      155 
      156 	if ^info_bead.made_seg then call hcs_$truncate_seg(segp,0,code);
      157 	return;					/* all done now */
      158 
      159 
      160 /*  The get_file entry returns a pointer to component 0 of file dirname>ename.  The
      161*    file will have "rw" access to the current user.  If an old acl had to be changed
      162*    to set the access to "rw", then aclinfop will be left pointing to information
      163*    needed to reset the acl.  */
      164 
      165 
      166 get_file:
      167 	entry(dirname, ename, segp, aclinfop, fcbp, code);
      168 
      169 	segp, aclinfop, fcbp = null;				/* init ptrs to indicate that we haven't allocated	*/
      170           code = 0;
      171 
      172 	if areap = null then areap = get_system_free_area_();	/* grab area */
      173 
      174 	dir = dirname;					/* copy path name arguments */
      175 	enm = ename;
      176 
      177 	on cleanup begin;					/* in case returned around, want to clean up */
      178 	     call free_acl_info;
      179 	     call free_fcb;
      180 	end;
      181 
      182 	call msf_manager_$open(dir, enm, fcbp, code);
      183 	if fcbp = null then return;                                 /* return the code value indicating the reason for opening failure */
      184 
      185 	call msf_manager_$get_ptr(fcbp, 0, "1"b, segp, bc, xcode);
      186 	if segp=null then do;
      187 	   call free_fcb;
      188 	   code = xcode;
      189 	   return;
      190 	   end;
      191 
      192 	allocate info_bead in (free_area) set (aclinfop);		/* save ptr to acl, acl_count, and set user ptr */
      193 
      194 	aclinfop->info_bead.dirname = dir;			/* save the pathnames */
      195 	aclinfop->info_bead.ename = enm;
      196 
      197 	if code ^= 0 then do;				/* we made the seg so.. */
      198 	     info_bead.made_seg = "1"b;
      199 	     info_bead.mode = "101"b;				/* put on by msf_manager_ */
      200 	end;
      201 	else do;						/* was there so do other things */
      202 	     info_bead.made_seg = "0"b;
      203 	     info_bead.mode = "0"b;
      204 	     call msf_manager_$adjust(fcbp,0,0,"110"b,code);	/* truncate seg to 0 */
      205 	end;
      206 
      207 	call add_acl;					/* add rw for P.P.tag to segment */
      208 
      209 	return;						/* that's it */
      210 
      211 
      212 /* The following two internal procedures are used through out tssi_ to free allocated storage. */
      213 
      214 
      215 free_acl_info:
      216 	proc;
      217 
      218 
      219 
      220 	if aclinfop^=null then				/* if aclinfop was set, then free the bead */
      221 	free aclinfop->info_bead in (free_area);
      222 
      223 	end free_acl_info;
      224 
      225 
      226 
      227 free_fcb:
      228 	proc;
      229 
      230 
      231 	if fcbp^=null then					/* if a fcb was allocated, then free it */
      232 	call msf_manager_$close(fcbp);
      233 
      234 
      235 	end free_fcb;
      236 
      237 
      238 /*  The finish_segment entry is used to set the bitcount on the segment after the translator
      239*    is finished with it.  It also resets the acl, if an old one exists.  If one did not,
      240*    then if mode="110"b then the acl is changed to "re", else it is left "rw".  It also terminates
      241*    the segment.  */
      242 
      243 
      244 finish_segment:
      245 	entry(segp, bit_count, mode, aclinfop, code);
      246 
      247 	call hcs_$set_bc_seg(segp, bit_count, code);		/* set the bitcount to the value given 	*/
      248 	if code^=0 then return;				/* if error, then give up */
      249 
      250 	type = seg;					/* finishing up a segment, rather than a file */
      251 
      252 	call delete_acl (code);				/* remove the acl entry for Person.Project.tag */
      253 	if code ^= 0 then return;
      254 
      255 	call adjust_mode;					/* make sure requested mode is on the segment */
      256 
      257 	call free_acl_info;
      258 
      259 	call hcs_$terminate_noname(segp,code);
      260 
      261 	return;						/* finished */
      262 
      263 
      264 /*  The finish_file entry is used to set the length of the file when the translator is finished
      265*    with it.  It also resets acls like the "finish_segment" entry, and terminates the file.  */
      266 
      267 
      268 finish_file:
      269 	entry(fcbp, component, bit_count, mode, aclinfop, code);
      270 
      271 	call msf_manager_$adjust(fcbp, component, bit_count, "101"b, code);/* set the bitcount and terminate */
      272 	if code ^= 0 then return;				/* set bitcount before changing acl so we know
      273*							  it will work*/
      274 
      275 	type = file;					/* flag to indicate a file is being finished */
      276 
      277 	call delete_acl (code);				/* remove acl for Person.Project.tag */
      278 	if code ^= 0 then return;
      279 
      280 	call adjust_mode;					/* make sure requested mode is on the file */
      281 
      282 	call free_acl_info;					/* free info structure */
      283 
      284 	call free_fcb;					/* free the fcb */
      285 
      286 	return;						/* finished */
      287 
      288 
      289 /*  The clean_up entry is called by the user in the event of him having to abnormally abort his work, and
      290*    just frees the storage allocated for acls, if present. */
      291 
      292 
      293 clean_up_segment:
      294 	entry(aclinfop);
      295 
      296 	if aclinfop = null then return;
      297 
      298 	type = seg;					/* finishing up a segment, rather than a file */
      299 
      300 	call delete_acl (xcode);				/* remove acl entry for P.P.t */
      301 
      302 	call free_acl_info;
      303 
      304 	return;						/* that's it */
      305 
      306 
      307 clean_up_file:
      308 	entry(fcbp, aclinfop);
      309 
      310 
      311 	if aclinfop ^= null then do;
      312 
      313 	     type = file;					/* flag to indicate a file is finished */
      314 
      315 	     call delete_acl (xcode);				/* delete acl for P.P.tag */
      316 
      317 	     call free_acl_info;
      318 
      319 	end;
      320 
      321 	call free_fcb;
      322 
      323 	return;
      324 
      325 
      326 /* The internal procedure add_acl is used to add the entry Person.Project.tag  rw for the get entries */
      327 
      328 add_acl:
      329      proc;
      330 
      331 	working_acl.process_group_id = get_group_id_();	/* set up acl for Person.Project.tag */
      332 	working_acl.mode = "101"b;
      333 	working_acl.mbz1, working_acl.mbz2 = "0"b;
      334 
      335 	call hcs_$add_acl_entries(dir,enm,addr(working_acl),1,code); /* do it */
      336 
      337 
      338      end add_acl;
      339 
      340 
      341 
      342 
      343 
      344 
      345 /* The internal procedure delete_acl is used to remove the entry on the segment or msf for
      346*   Person.Project.tag */
      347 
      348 delete_acl:
      349 	proc (error);
      350 
      351 dcl	error fixed bin (35);
      352 
      353 
      354 
      355 	dir = aclinfop->info_bead.dirname;			/* copy dirname */
      356 	enm = aclinfop->info_bead.ename;			/* copy ename also */
      357 
      358 	del_acl.process_group_id = get_group_id_();		/* get Person.Project.tag to del it */
      359 
      360 	if type = seg then call hcs_$delete_acl_entries(dir,enm,addr(del_acl),1,error);
      361  	else call msf_manager_$acl_delete(fcbp,addr(del_acl),1,error);
      362 
      363 
      364      end delete_acl;
      365 
      366 /* The internal procedure adjust_mode puts the requested mode on the the acl if the segment or msf
      367*   was made by tssi_. */
      368 
      369 adjust_mode:
      370      proc;
      371 
      372 
      373 
      374 	if info_bead.made_seg then do;
      375 	     working_acl.mode = substr (mode, 1, 3);		/* copy mode */
      376 	     if info_bead.mode ^= working_acl.mode then do;	/* if different mode set it */
      377 
      378 		working_acl.process_group_id = get_group_id_$tag_star();
      379 		working_acl.mbz1, working_acl.mbz2 = "0"b;
      380 
      381 		if type = seg
      382 		then call hcs_$add_acl_entries(dir,enm,addr(working_acl),1,code);
      383  		else call msf_manager_$acl_add(fcbp,addr(working_acl),1,code);
      384 
      385 	     end;
      386 
      387 	if working_acl.mode & E_ACCESS then call fix_inacl_entries;
      388 
      389 	end;
      390 
      391 fix_inacl_entries:
      392 	procedure;
      393 
      394 
      395 
      396 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      397 	/*									*/
      398 	/* POLICY:								*/
      399 	/*	If the user is trying to put "re" on a new segment, then for each ACL entry	*/
      400 	/*	which was derived from the IACL (which should be all that's on the entry by	*/
      401 	/*	now), if the access is non-null, then if it already contains "e", we assume	*/
      402 	/*	the user knows what she's doing;  otherwise, the corresponding user receives	*/
      403 	/*	"re" permission to the new segment.					*/
      404 	/*									*/
      405 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      406 
      407 
      408 
      409 	acl_ptr = null ();
      410 	on cleanup begin;
      411 	     if acl_ptr ^= null then free segment_acl;
      412 	end;
      413 
      414 	call hcs_$list_acl (dir, enm, get_system_free_area_ (), acl_ptr, null (), acl_count, xcode);
      415 	if xcode ^= 0 then return;			/* Can't fix initial acl? Too bad. */
      416 	do i = 1 to acl_count;
      417 	     if segment_acl (i).modes ^= N_ACCESS
      418 	     then if (segment_acl (i).modes & E_ACCESS) = ""b
      419 		then segment_acl (i).modes = RE_ACCESS;
      420 	end;
      421 	call hcs_$replace_acl (dir, enm, acl_ptr, acl_count, "1"b, xcode);
      422 	free segment_acl;
      423 	return;
      424 
      425 declare 1 segment_acl (acl_count) aligned based (acl_ptr),
      426 	2 access_name	    char (32),
      427 	2 modes		    bit (36),
      428 	2 xmodes		    bit (36),
      429 	2 status_code	    fixed binary (35);
      430 
      431 declare	acl_ptr pointer;
      432 declare  (acl_count, i) fixed binary;
      433 
      434 
      435 	end fix_inacl_entries;
      436 
  1     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      437 
      438 
      439      end adjust_mode;
      440 
      441 	end tssi_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/12/88  1434.9  tssi_.pl1                         >spec>install>1055>tssi_.pl1
437          1    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
E_ACCESS                               constant        bit(3)                   initial packed unaligned dcl 1-11 ref 387 417
N_ACCESS                               constant        bit(3)                   initial packed unaligned dcl 1-11 ref 417
RE_ACCESS                              constant        bit(3)                   initial packed unaligned dcl 1-11 ref 417
acl_count                       000102 automatic       fixed bin(17,0)          dcl 432 set ref 411 414* 416 421* 422
acl_ptr                         000100 automatic       pointer                  dcl 431 set ref 409* 411 411 414* 417 417 417 421*
                                                                                  422
aclinfop                               parameter       pointer                  dcl 45 set ref 114 118* 130* 132 133 136 137 141 142
                                                                                  156 166 169* 192* 194 195 198 199 202 203 220 220
                                                                                  244 268 293 296 307 311 355 356 374 376
addr                                                   builtin function         dcl 45 ref 335 335 360 360 361 361 381 381 383 383
areap                           000010 internal static pointer                  initial dcl 45 set ref 120 120* 130 172 172* 192 220
bc                              000134 automatic       fixed bin(24,0)          dcl 45 set ref 185*
bit_count                              parameter       fixed bin(24,0)          dcl 45 set ref 244 247* 268 271*
cleanup                         000102 stack reference condition                dcl 45 ref 128 177 410
code                                   parameter       fixed bin(35,0)          dcl 45 set ref 114 125* 135 144* 146 147 147 149*
                                                                                  154 156* 166 170* 182* 188* 197 204* 244 247* 248
                                                                                  252* 253 259* 268 271* 272 277* 278 335* 381* 383*
component                              parameter       fixed bin(17,0)          dcl 45 set ref 268 271*
del_acl                         000123 automatic       structure                level 1 dcl 45 set ref 360 360 361 361
dir                             000135 automatic       char(168)                packed unaligned dcl 45 set ref 122* 125* 132 174*
                                                                                  182* 194 335* 355* 360* 381* 414* 421*
dirname                                parameter       char                     packed unaligned dcl 45 in procedure "tssi_" ref 114
                                                                                  122 166 174
dirname                                based           char(168)                level 2 in structure "info_bead" dcl 45 in procedure
                                                                                  "tssi_" set ref 132* 194* 355
ename                    52            based           char(32)                 level 2 in structure "info_bead" dcl 45 in procedure
                                                                                  "tssi_" set ref 133* 195* 356
ename                                  parameter       char                     packed unaligned dcl 45 in procedure "tssi_" ref 114
                                                                                  123 166 175
enm                             000207 automatic       char(32)                 packed unaligned dcl 45 set ref 123* 125* 133 175*
                                                                                  182* 195 335* 356* 360* 381* 414* 421*
error                                  parameter       fixed bin(35,0)          dcl 351 set ref 348 360* 361*
error_table_$nolinkag           000024 external static fixed bin(35,0)          dcl 45 ref 147
error_table_$seg_unknown        000022 external static fixed bin(35,0)          dcl 45 ref 147
fcbp                                   parameter       pointer                  dcl 45 set ref 166 169* 182* 183 185* 204* 231 231*
                                                                                  268 271* 307 361* 383*
file                                   constant        fixed bin(17,0)          initial dcl 45 ref 275 313
free_area                              based           area(1024)               dcl 45 ref 130 192 220
get_group_id_                   000054 constant        entry                    external dcl 45 ref 331 358
get_group_id_$tag_star          000056 constant        entry                    external dcl 45 ref 378
get_system_free_area_           000060 constant        entry                    external dcl 45 ref 120 172 414 414
hcs_$add_acl_entries            000030 constant        entry                    external dcl 45 ref 335 381
hcs_$delete_acl_entries         000026 constant        entry                    external dcl 45 ref 360
hcs_$list_acl                   000014 constant        entry                    external dcl 45 ref 414
hcs_$make_seg                   000012 constant        entry                    external dcl 45 ref 125
hcs_$replace_acl                000016 constant        entry                    external dcl 45 ref 421
hcs_$set_bc_seg                 000050 constant        entry                    external dcl 45 ref 247
hcs_$terminate_noname           000052 constant        entry                    external dcl 45 ref 259
hcs_$truncate_seg               000032 constant        entry                    external dcl 45 ref 156
i                               000103 automatic       fixed bin(17,0)          dcl 432 set ref 416* 417 417 417*
info_bead                              based           structure                level 1 dcl 45 set ref 130 192 220
made_seg                 62            based           bit(1)                   level 2 dcl 45 set ref 136* 141* 156 198* 202* 374
mbz1                     10(03) 000110 automatic       bit(33)                  level 2 packed packed unaligned dcl 45 set ref 333*
                                                                                  379*
mbz2                     11     000110 automatic       bit(36)                  level 2 dcl 45 set ref 333* 379*
mode                                   parameter       bit(36)                  dcl 45 in procedure "tssi_" ref 244 268 375
mode                     63            based           bit(3)                   level 2 in structure "info_bead" dcl 45 in procedure
                                                                                  "tssi_" set ref 137* 142* 199* 203* 376
mode                     10     000110 automatic       bit(3)                   level 2 in structure "working_acl" packed packed
                                                                                  unaligned dcl 45 in procedure "tssi_" set ref 332*
                                                                                  375* 376 387
modes                    10            based           bit(36)                  array level 2 dcl 425 set ref 417 417 417*
msf_manager_$acl_add            000044 constant        entry                    external dcl 45 ref 383
msf_manager_$acl_delete         000046 constant        entry                    external dcl 45 ref 361
msf_manager_$adjust             000040 constant        entry                    external dcl 45 ref 204 271
msf_manager_$close              000042 constant        entry                    external dcl 45 ref 231
msf_manager_$get_ptr            000036 constant        entry                    external dcl 45 ref 185
msf_manager_$open               000034 constant        entry                    external dcl 45 ref 182
null                                                   builtin function         dcl 45 ref 118 120 126 169 172 183 186 220 231 296
                                                                                  311 409 411 414 414
process_group_id                000110 automatic       char(32)                 level 2 in structure "working_acl" dcl 45
                                                                                  in procedure "tssi_" set ref 331* 378*
process_group_id                000123 automatic       char(32)                 level 2 in structure "del_acl" dcl 45 in procedure
                                                                                  "tssi_" set ref 358*
seg                                    constant        fixed bin(17,0)          initial dcl 45 ref 250 298 360 381
segment_acl                            based           structure                array level 1 dcl 425 set ref 411 422
segp                                   parameter       pointer                  dcl 45 set ref 114 118* 125* 126 144* 156* 166 169*
                                                                                  185* 186 244 247* 259*
substr                                                 builtin function         dcl 45 ref 375
term_$nomakeunknown             000020 constant        entry                    external dcl 45 ref 144
type                            000101 automatic       fixed bin(17,0)          dcl 45 set ref 250* 275* 298* 313* 360 381
working_acl                     000110 automatic       structure                level 1 dcl 45 set ref 335 335 381 381 383 383
xcode                           000100 automatic       fixed bin(35,0)          dcl 45 set ref 185* 188 300* 315* 414* 415 421*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-33
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RW_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
R_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-30
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36

NAMES DECLARED BY EXPLICIT CONTEXT.
add_acl                         001075 constant        entry                    internal dcl 328 ref 153 207
adjust_mode                     001260 constant        entry                    internal dcl 369 ref 255 280
clean_up_file                   001002 constant        entry                    external dcl 307
clean_up_segment                000751 constant        entry                    external dcl 293
delete_acl                      001152 constant        entry                    internal dcl 348 ref 252 277 300 315
finish_file                     000656 constant        entry                    external dcl 268
finish_segment                  000562 constant        entry                    external dcl 244
fix_inacl_entries               001403 constant        entry                    internal dcl 391 ref 387
free_acl_info                   001036 constant        entry                    internal dcl 215 ref 128 178 257 282 302 317
free_fcb                        001054 constant        entry                    internal dcl 227 ref 179 187 284 321
get_file                        000300 constant        entry                    external dcl 166
get_segment                     000034 constant        entry                    external dcl 114
tssi_                           000021 constant        entry                    external dcl 42

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2164        2246    1610        2174
Length      2514    1610        62         231     354           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
tssi_                               300 external procedure  is an external procedure.  
on unit on line 128                  64 on unit               
on unit on line 177                  64 on unit               
free_acl_info                        64 internal procedure  is called by several nonquick procedures.  
free_fcb                             68 internal procedure  is called by several nonquick procedures.  
add_acl                                 internal procedure  shares stack frame of external procedure tssi_.  
delete_acl                              internal procedure  shares stack frame of external procedure tssi_.  
adjust_mode                             internal procedure  shares stack frame of external procedure tssi_.  
fix_inacl_entries                   114 internal procedure  enables or reverts conditions.  
on unit on line 410                  64 on unit               

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 areap                       tssi_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
fix_inacl_entries        000100 acl_ptr                     fix_inacl_entries
                         000102 acl_count                   fix_inacl_entries
                         000103 i                           fix_inacl_entries
tssi_                    000100 xcode                       tssi_
                         000101 type                        tssi_
                         000110 working_acl                 tssi_
                         000123 del_acl                     tssi_
                         000134 bc                          tssi_
                         000135 dir                         tssi_
                         000207 enm                         tssi_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac          enable_op
ext_entry           ext_entry_desc      int_entry           op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_group_id_                 get_group_id_$tag_star        get_system_free_area_         hcs_$add_acl_entries
hcs_$delete_acl_entries       hcs_$list_acl                 hcs_$make_seg                 hcs_$replace_acl
hcs_$set_bc_seg               hcs_$terminate_noname         hcs_$truncate_seg             msf_manager_$acl_add
msf_manager_$acl_delete       msf_manager_$adjust           msf_manager_$close            msf_manager_$get_ptr
msf_manager_$open             term_$nomakeunknown

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$nolinkag         error_table_$seg_unknown




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     42 000020       114 000026       118 000063       120 000066       122 000100       123 000106       125 000113
    126 000152       128 000156       130 000200       132 000206       133 000211       135 000214       136 000216
    137 000220       139 000222       141 000223       142 000224       144 000225       146 000236       147 000240
    149 000245       153 000246       154 000247       156 000251       157 000271       166 000272       169 000331
    170 000335       172 000336       174 000351       175 000357       177 000364       178 000400       179 000405
    180 000412       182 000413       183 000440       185 000444       186 000470       187 000474       188 000500
    189 000502       192 000503       194 000511       195 000514       197 000517       198 000521       199 000523
    200 000525       202 000526       203 000527       204 000530       207 000553       209 000554       244 000555
    247 000602       248 000615       250 000617       252 000621       253 000627       255 000631       257 000632
    259 000636       261 000647       268 000650       271 000676       272 000720       275 000722       277 000724
    278 000732       280 000734       282 000735       284 000741       286 000745       293 000746       296 000761
    298 000765       300 000767       302 000771       304 000775       307 000776       311 001014       313 001020
    315 001022       317 001024       321 001030       323 001034       215 001035       220 001043       223 001052
    227 001053       231 001061       235 001074       328 001075       331 001076       332 001105       333 001111
    335 001114       338 001151       348 001152       355 001154       356 001161       358 001164       360 001173
    361 001235       364 001257       369 001260       374 001261       375 001265       376 001271       378 001275
    379 001304       381 001307       383 001350       387 001371       439 001401       391 001402       409 001410
    410 001412       411 001426       412 001437       414 001440       415 001511       416 001514       417 001523
    420 001534       421 001536       422 001576       423 001602


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
