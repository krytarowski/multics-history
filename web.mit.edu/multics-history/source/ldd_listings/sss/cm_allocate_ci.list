	COMPILATION LISTING OF SEGMENT cm_allocate_ci
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phx. Az., Sys-M 
	Compiled on: 04/02/87  1311.7 mst Thu
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 /* DESCRIPTION:
        8*
        9*         This module implements collection_manager_$allocate_control_interval.
       10*
       11*         This  routine  allocates  a  control  interval  in a page file using
       12*     either the Unblocked or Blocked Control Interval Storage Method.
       13*
       14*          Currently only the Unblocked CISM is supported. Allocating a control
       15*     interval requires finding a free control interval in the allocation map,
       16*     assigning a disk address to a new control interval, initializing that
       17*     control interval, updating the map, updating the collection_header to show
       18*     that the new control interval is the last control interval of the
       19*     collection, and updating the former last control interval's header to
       20*     thread it with the new one. Non-harmful inconsistencies can develop if a
       21*     failure occurs in the middle of this routine, but they are not rolled back
       22*     because future allocations will fix the inconsistency. 
       23*          One non-pasive inconsistency can arise if every step is completed
       24*     except for threading the previous control interval.
       25*
       26*     **** This module should be changed to not abort if a deadlock ****
       27*     occurs while attempting to access a file_reservation_map fragment.
       28*     It was set up to skip a fragment if a deadlock or timeout occured,
       29*     but assumed that dm_error_$lock_deadlock and dm_error_$lock_timeout
       30*     would be returned.  Actually, deadlocks are signalled, and file_manager_
       31*    wwaits for a very long time.  This module really needs an interface to
       32*     file_manager_ which does not wait at all.  That is the only way in which 
       33*     it would be practical to implement the skipping of fragments which are
       34*     already locked.
       35**/
       36 
       37 /* HISTORY:
       38*
       39*Written by Matthew Pierret, 07/21/82.
       40*Modified:
       41*09/27/82 by Matthew Pierret:  Fixed bug that accidentally set first_control_interval
       42*            equal to last_control_interval.
       43*10/20/82 by Matthew Pierret:  Converted to use file_manager_.  Removed attempts
       44*            to explicitly assign disk addresses to control intervals - this is
       45*            done automatically by fm_$put.
       46*11/23/82 by Lindsey Spratt:  Fixed to set the storage_record_ptr to null in
       47*	  the finish procedure if the storage_record is freed.  Added
       48*	  putting of the storage_record back into the header collection when
       49*	  modified.  Also, added setting of the first_control_interval.
       50*01/03/83 by Lindsey Spratt:  Fixed to call cm_get_info$full_get using
       51*	  cm_info.file_oid and cm_info.collection_id instead of
       52*	  p_file_opening_id and p_collection_id.  Added the info_header
       53*	  entry point.  This entry takes a pointer to an (empty) bci_header
       54*	  and fills in the bci_header for its caller.
       55*	  cm_allocate_overlength_tail needs this.
       56*02/01/83 by Matthew Pierret: Upgraded to support CM_INFO_VERSION_2.
       57*            Changed to report internal inconsistencies via sub_err_.
       58*            Changed to use cm_get_bci_header. Removed allocate_control_interval
       59*            label.
       60*02/23/83 by Matthew Pierret: Changed to use file_reservation_map instead of
       61*            block_map_array.
       62*03/31/83 by Lindsey L. Spratt:  Fixed to initialize the new
       63*            file_reservation_map.element_id to "0"b.
       64*03/31/83 by Lindsey L.  Spratt:  Added distinct setup of the CI which holds
       65*            the new allocation map fragment.  This CI is in the header
       66*            collection, but is not threaded into any list of CI's (e.g., those
       67*            in the header collection).
       68*04/01/83 by Lindsey L. Spratt:  Fixed to set the lowest_ci_number of the new
       69*            map fragment to 1 greater than the ci number of the ci which
       70*	  contains the new map fragment.  The new map fragment CI being the
       71*	  CI which immediately follows the last CI of the previous map
       72*	  fragment.
       73*	  Fixed to fully initialize the fragment_bci_header.  Fixed to set
       74*	  the cm_file_header.number_of_blocks when extending the
       75*            file_reservation_map.  Fixed to leave space in the map_buffer for
       76*            the extension (by 1).  Changed to use the ERROR_RETURN procedure.
       77*04/03/83 by Lindsey L. Spratt:  Fixed to replace the file_reservation_map in
       78*            the file after extending it.
       79*04/29/83 by Matthew Pierret:  Changed to check for
       80*            dm_error_$long_return_element in addition to $long_element, as the
       81*            "get" modules now return the former and the "put" modules return
       82*            the latter.
       83*            Changed to check to see if this is the first control interval of a
       84*            collection (storage_record.first_control_interval is 0), and to not
       85*            attempt to thread the non-existent previous ci in this case.
       86*08/09/83 by Matthew Pierret:  Removed uses of the obsolete dm_data_$area_ptr.
       87*01/24/84 by Matthew Pierret:  Added debugging entriesto trace control interval
       88*            thread modificaitons.
       89*05/21/84 by Matthew Pierret:  Renamed include file dm_cm_cism_info to 
       90*            dm_cism_info.
       91*06/12/84 by Matthew Pierret:  Renamed cm_allocate_element to cm_put,
       92*            cm_put_element to cm_modify.
       93*10/09/84 by Matthew Pierret:  Changed file_manager_$get declaration to take
       94*            a fixed bin (27) control interval number.  Changed ERROR_RETURN
       95*            to accept as input an error code, and changed the module to use
       96*            a local code variable instead of the p_code parameter.
       97*            Changed value of myname to from "cm_allocate_control_interval".
       98*            Added a call to sub_err_ if the CISM is not supported.
       99*            Removed the FINISH procedure - the work it did was unnecessary
      100*            and wrong. Re-hashed the technology for determining
      101*            inconsistencies.
      102**/
      103 
      104 
      105 /****^  HISTORY COMMENTS:
      106*  1) change(87-01-15,Hergert), approve(87-04-01,MCR7632),
      107*     audit(87-02-02,Dupuis), install(87-04-02,MR12.1-1020):
      108*     For TR phx20754, changed initialization of bci_header.start_of_used_space
      109*     to be just CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES. It was CIALIB -1
      110*     which caused assumptions of the free space available being on a word
      111*     boundary to be wrong. This caused alignment problems with internal data
      112*     structures depending on this word alignment.
      113*                                                   END HISTORY COMMENTS */
      114 
      115 
      116 
      117 /* format: style2,^indnoniterdo,^indprocbody,ind3,ll79 */
      118 cm_allocate_ci:
      119    proc (p_file_opening_id, p_collection_id, p_control_interval_number, p_code)
      120         ;
      121 
      122 /* START OF DECLARATIONS */
      123 
      124 /* Parameter */
      125 
      126    dcl	 p_file_opening_id	    bit (36) aligned parameter;
      127    dcl	 p_collection_id	    bit (36) aligned parameter;
      128    dcl	 p_control_interval_number
      129 			    fixed bin (24) unsigned parameter;
      130    dcl	 p_bci_header_ptr	    ptr parameter;
      131    dcl	 p_cm_info_ptr	    ptr parameter;
      132    dcl	 p_code		    fixed bin (35) parameter;
      133 
      134 /* Automatic */
      135 
      136    dcl	 1 automatic_bci_header aligned like bci_header;
      137    dcl	 1 fragment_bci_header  aligned like bci_header;
      138    dcl	 automatic_ci_parts_buffer
      139 			    (6) fixed bin (71);	/* Max of 1 part */
      140    dcl	 1 automatic_cm_file_header
      141 			    aligned like cm_file_header;
      142    dcl	 map_idx		    fixed bin (17);
      143    dcl	 code		    fixed bin (35);
      144    dcl	 control_interval_number
      145 			    fixed bin (27);
      146    dcl	 free_control_interval_idx
      147 			    fixed bin (17);
      148    dcl	 number_of_fragments_with_vacancies
      149 			    fixed bin (17);
      150    dcl	 1 previous_bci_header  aligned like bci_header;
      151    dcl	 previous_control_interval_number
      152 			    fixed bin (27);
      153 
      154    dcl	 allocated	    bit (1) aligned;
      155    dcl	 replace_map	    bit (1) aligned;
      156 
      157 /* Based */
      158 /* Builtin */
      159 
      160    dcl	 (addr, divide, string, index, length, null, size, substr, unspec)
      161 			    builtin;
      162 
      163 /* Constant */
      164 
      165    dcl	 myname		    init ("cm_allocate_ci") char (32) varying
      166 			    int static options (constant);
      167    dcl	 BYTES_PER_WORD	    init (4) fixed bin (17) int static
      168 			    options (constant);
      169    dcl	 BITS_PER_WORD	    init (36) fixed bin (17) int static
      170 			    options (constant);
      171    dcl	 (
      172 	 ATTEMPTING_TO_GET	    init ("1"b),
      173 	 ATTEMPTING_TO_PUT	    init ("0"b)
      174 	 )		    bit (1) aligned int static
      175 			    options (constant);
      176 
      177 /* Entry */
      178 
      179    dcl	 sub_err_		    entry () options (variable);
      180    dcl	 file_manager_$put	    entry (bit (36) aligned, fixed bin (27), ptr,
      181 			    fixed bin (35));
      182    dcl	 ioa_		    entry () options (variable);
      183 
      184 /* Static */
      185 
      186    dcl	 static_trace_thread_switch
      187 			    init ("0"b) bit (1) aligned internal static;
      188 
      189 /* External */
      190 
      191    dcl	 (
      192 	 dm_error_$long_element,
      193 	 dm_error_$long_return_element,
      194 	 dm_error_$ci_not_allocated,
      195 	 dm_error_$no_element,
      196 	 dm_error_$misformatted_ci,
      197 	 dm_error_$ci_not_in_collection,
      198 	 dm_error_$unimplemented_cism,
      199 	 error_table_$unimplemented_version
      200 	 )		    ext fixed bin (35);
      201 
      202 /* END OF DECLARATIONS */
      203 
      204 /* format: ^indblkcom,indcomtxt */
      205 
      206    p_code, code = 0;
      207    call cm_opening_info$full_get (p_file_opening_id, p_collection_id,
      208         cm_info_ptr, code);
      209    if code ^= 0
      210    then call ERROR_RETURN (code);
      211    bci_header_ptr = addr (automatic_bci_header);
      212 
      213    go to JOIN;
      214 
      215 
      216 info:
      217    entry (p_cm_info_ptr, p_control_interval_number, p_code);
      218 
      219    p_code, code = 0;
      220    cm_info_ptr = p_cm_info_ptr;
      221    bci_header_ptr = addr (automatic_bci_header);
      222 
      223    go to JOIN;
      224 
      225 info_header:
      226    entry (p_cm_info_ptr, p_control_interval_number, p_bci_header_ptr, p_code);
      227 
      228    p_code, code = 0;
      229    cm_info_ptr = p_cm_info_ptr;
      230    bci_header_ptr = p_bci_header_ptr;
      231 
      232    go to JOIN;
      233 
      234 
      235 JOIN:
      236    call CHECK_VERSION ("cm_info", cm_info.version, CM_INFO_VERSION_2);
      237    collection_header_ptr = cm_info.header_ptr;
      238    call CHECK_VERSION ("collection_header", collection_header.version,
      239         COLLECTION_HEADER_VERSION_2);
      240 
      241    p_control_interval_number = 0;
      242 
      243    blocked_storage_record_ptr, unblocked_storage_record_ptr = null;
      244    if cm_info.storage_record_ptr = null
      245    then
      246       do;
      247       call cm_opening_info$get_storage_record (cm_info_ptr, code);
      248       if code ^= 0
      249       then call ERROR_RETURN (code);
      250    end;
      251 
      252 /**** Setup the ci_parts structure for later use in writing bci_header */
      253 
      254    automatic_ci_parts_buffer = 0;
      255    ci_parts_ptr = addr (automatic_ci_parts_buffer);
      256    ci_parts.number_of_parts = 1;
      257    ci_parts.part (1).offset_in_bytes = 0;
      258    ci_parts.part (1).length_in_bytes = size (bci_header) * BYTES_PER_WORD;
      259 
      260 
      261    if collection_header.control_interval_storage_method
      262         ^= UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
      263    then call sub_err_ (dm_error_$unimplemented_cism, myname,
      264 	   ACTION_CANT_RESTART, null, 0,
      265 	   "^/This operation only supports control interval storage method ^d;^/received method ^d."
      266 	   , UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD,
      267 	   collection_header.control_interval_storage_method);
      268    else
      269 UNBLOCKED:
      270       do;
      271       unblocked_storage_record_ptr = cm_info.storage_record_ptr;
      272 
      273    /*** Get the header of the last control interval of the collection exclusively.
      274*        If an exclusive lock cannot be obtained on this control interval, the
      275*        allocation cannot take place, as it must be threaded to the new control
      276*        interval. */
      277 
      278       previous_control_interval_number =
      279 	 unblocked_storage_record.last_control_interval;
      280 
      281       if previous_control_interval_number ^= 0
      282 	 | cm_info.collection_id = HEADER_COLLECTION_ID
      283       then
      284          do;
      285          call cm_get_bci_header (cm_info.file_oid,
      286 	    (previous_control_interval_number), addr (previous_bci_header),
      287 	    code);
      288          if code ^= 0
      289          then call ERROR_RETURN (code);
      290       end;
      291 
      292    /*** Get the allocation map by getting cm_file_header, file_reservation_map and
      293*        then a suitable fragment of the reservation map. */
      294 
      295       call cm_get_element (cm_info.file_oid, HEADER_COLLECTION_ID,
      296 	 CM_FILE_HEADER_ELEMENT_ID, 0, addr (automatic_cm_file_header),
      297 	 length (unspec (automatic_cm_file_header)), null, ("0"b),
      298 	 cm_file_header_ptr, (0), code);
      299       if code ^= 0
      300       then call GET_ERROR_RETURN (code, "cm_file_header",
      301 	      CM_FILE_HEADER_ELEMENT_ID,
      302 	      length (unspec (automatic_cm_file_header)));
      303 
      304       call CHECK_VERSION ("cm_file_header", cm_file_header.version,
      305 	 CM_FILE_HEADER_VERSION_1);
      306 
      307    /*** Before proceeding, initialize the header of the new control interval
      308*        (bci_header), and set up buffers for the file_reservation_map and for one
      309*        fragment. Note that the buffer for file_reservation_map is slightly
      310*        larger than is needed; this is in case the array needs to be extended
      311*        (i.e., there are no available control intervals).
      312*   */
      313 
      314       unspec (bci_header) = "0"b;
      315       bci_header.layout_type = BASIC_CI_LAYOUT_1;
      316       bci_header.collection_id = cm_info.collection_id;
      317       bci_header.start_of_used_space =
      318 	 CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES;
      319       bci_header.previous_control_interval =
      320 	 unblocked_storage_record.last_control_interval;
      321 
      322 
      323       frmf_number_of_control_intervals =
      324 	 cm_file_header.number_of_control_intervals_per_block;
      325       frm_number_of_fragments = cm_file_header.number_of_blocks;
      326 
      327 BEGIN_BLOCK:
      328       begin;
      329          dcl     fragment_buffer	(
      330 				divide (
      331 				frmf_number_of_control_intervals,
      332 				BITS_PER_WORD * 2, 17, 0) + 1)
      333 				fixed bin (71);
      334          dcl     map_buffer		(frm_number_of_fragments + 1) fixed
      335 				bin (71);
      336 
      337       /*** Get file_reservation_map, which contains the element ids of the fragments of
      338*	 the reservation map. The array also contains a flag associated with each
      339*	 entry (no_control_intervals_are_available) which tells if the fragment is
      340*	 full. If the file_reservation_map cannot be gotten, the allocation cannot continue
      341*      */
      342 
      343          call cm_get_element (cm_info.file_oid, HEADER_COLLECTION_ID,
      344 	    cm_file_header.allocation_map_element_id, 0, addr (map_buffer),
      345 	    length (unspec (map_buffer)), null, ("0"b),
      346 	    file_reservation_map_ptr, (0), code);
      347          if code ^= 0
      348          then call GET_ERROR_RETURN (code, "file reservation map",
      349 	         cm_file_header.allocation_map_element_id,
      350 	         length (unspec (map_buffer)));
      351 
      352          allocated, replace_map = "0"b;
      353          number_of_fragments_with_vacancies = 0;
      354 
      355 TRY_EACH_ALLOCATION_FRAGMENT_LOOP:
      356          do map_idx = 1 to frm_number_of_fragments while (^allocated);
      357 
      358 	  if ^file_reservation_map (map_idx).flags
      359 	       .no_control_intervals_are_available
      360 	  then
      361 TRY_THIS_ALLOCATION_FRAGMENT:
      362 	     do;
      363 	     number_of_fragments_with_vacancies =
      364 		number_of_fragments_with_vacancies + 1;
      365 
      366 	  /*** Get this fragment. If unavailable because of locking conflict,
      367*	       try the next fragment. If unavailable for any other reason, it can be assumed
      368*	       the problem is not local to the fragment, so give up the allocation.
      369*	  */
      370 
      371 	     call cm_get_element (cm_info.file_oid, HEADER_COLLECTION_ID,
      372 		file_reservation_map (map_idx).element_id, 0,
      373 		addr (fragment_buffer), length (unspec (fragment_buffer)),
      374 		null, "0"b, file_reservation_map_fragment_ptr, (0), code);
      375 	     if code ^= 0
      376 	     then call FILE_MAP_ERROR_RETURN (code, map_idx,
      377 		     file_reservation_map (map_idx).element_id,
      378 		     length (unspec (fragment_buffer)));
      379 	     else
      380 	        do;
      381 
      382 	        free_control_interval_idx =
      383 		   index (file_reservation_map_fragment, "0"b);
      384 
      385 	        if free_control_interval_idx = 0
      386 	        then
      387 		 do;
      388 		 number_of_fragments_with_vacancies =
      389 		      number_of_fragments_with_vacancies - 1;
      390 		 file_reservation_map (map_idx).flags
      391 		      .no_control_intervals_are_available = "1"b;
      392 		 replace_map = "1"b;
      393 	        end;
      394 	        else
      395 TRY_THIS_CI:
      396 		 do;
      397 
      398 		 control_interval_number =
      399 		      file_reservation_map (map_idx)
      400 		      .lowest_numbered_control_interval
      401 		      + free_control_interval_idx - 1;
      402 		 substr (file_reservation_map_fragment,
      403 		      free_control_interval_idx, 1) = "1"b;
      404 
      405 	        /*** Try to assign a disk address to the new control interval by writing into
      406*		   it.  If a locking conflict exists, someone else is trying to allocate
      407*		   into this fragment, so give up on the entire fragment. */
      408 
      409 		 ci_parts.part (1).local_ptr = bci_header_ptr;
      410 
      411 		 call file_manager_$put (cm_info.file_oid,
      412 		      control_interval_number, ci_parts_ptr, code);
      413 		 if code ^= 0
      414 		 then call ERROR_RETURN (code);
      415 
      416 	        /*** Put the updated file_reservation_map_fragment. If unsuccessful due to locking conflict,
      417*		   try another fragment. Otherwise it is assumed that the same error will occur
      418*		   no matter what fragment is tried.  */
      419 
      420 		 call cm_modify (cm_info.file_oid, HEADER_COLLECTION_ID,
      421 		      file_reservation_map_fragment_ptr, -1,
      422 		      file_reservation_map (map_idx).element_id, (0), code)
      423 		      ;
      424 		 if code ^= 0
      425 		 then call MODIFY_ERROR_RETURN (code,
      426 			 "file reservation map fragment",
      427 			 file_reservation_map (map_idx).element_id);
      428 		 else
      429 		    do;
      430 
      431 		 /*** Put the updated collection_header. If unsuccessful, return. The collection
      432*		      will be inconsistent in a non-harmful way, only causing the loss of a
      433*		      control interval, but no data. */
      434 
      435 		    if unblocked_storage_record.first_control_interval = 0
      436 		         & cm_info.collection_id ^= HEADER_COLLECTION_ID
      437 		    then unblocked_storage_record.first_control_interval =
      438 			    control_interval_number;
      439 
      440 		    unblocked_storage_record.last_control_interval =
      441 		         control_interval_number;
      442 
      443 		    call cm_modify (cm_info.file_oid, HEADER_COLLECTION_ID,
      444 		         cm_info.storage_record_ptr, -1,
      445 		         collection_header.storage_record_element_id, (0),
      446 		         code);
      447 		    if code ^= 0
      448 		    then call MODIFY_ERROR_RETURN (code, "storage record",
      449 			    collection_header.storage_record_element_id);
      450 
      451 		    call cm_modify (cm_info.file_oid, HEADER_COLLECTION_ID,
      452 		         collection_header_ptr, -1, cm_info.collection_id,
      453 		         (0), code);
      454 		    if code ^= 0
      455 		    then call MODIFY_ERROR_RETURN (code,
      456 			    "collection header", cm_info.collection_id);
      457 
      458 
      459 		    if previous_control_interval_number ^= 0
      460 		         | cm_info.collection_id = HEADER_COLLECTION_ID
      461 		    then
      462 		       do;
      463 
      464 		    /*** Thread in the previous control interval.  This control interval has already
      465*		         been locked exclusively, so a non-zero error code indicates a fatal problem.
      466*		         If such is the case, the colleciton is left inconsistent, since the
      467*		         collection_header thinks that the last control interval is one that is not
      468*		         addressable. */
      469 
      470 		       previous_bci_header.next_control_interval =
      471 			  control_interval_number;
      472 		       ci_parts.part (1).local_ptr =
      473 			  addr (previous_bci_header);
      474 
      475 		       call file_manager_$put (cm_info.file_oid,
      476 			  previous_control_interval_number, ci_parts_ptr,
      477 			  code);
      478 		       if code ^= 0
      479 		       then call ERROR_RETURN (code);
      480 		    end;
      481 
      482 		    allocated = "1"b;
      483 
      484 		 end;
      485 
      486 	        end TRY_THIS_CI;
      487 	     end;
      488 	  end TRY_THIS_ALLOCATION_FRAGMENT;
      489          end TRY_EACH_ALLOCATION_FRAGMENT_LOOP;
      490 
      491          if number_of_fragments_with_vacancies > 0
      492          then
      493 	  do;
      494 
      495 	  if replace_map
      496 	  then call cm_modify (cm_info.file_oid, HEADER_COLLECTION_ID,
      497 		  file_reservation_map_ptr, -1,
      498 		  cm_file_header.allocation_map_element_id, (0), (0));
      499          end;
      500          else
      501 EXTEND_MAP_AND_ALLOCATE_IN_NEW_FRAGMENT:
      502 	  do;
      503 
      504          /*** This do-group does almost the identical thing as TRY_THIS_ALLOCATION_FRAGMENT,
      505*	    with a few exceptions: Since this is the last attempt, an error at any point
      506*	    aborts the allocation; the file_reservation_map is extended one entry and
      507*	    put back; the control_interval_number is determined by figuring out
      508*	    the highest possible control interval number + 1; and the file_reservation_map_fragment
      509*	    is allocated instead of put because it does not exist yet. */
      510 
      511 	  frm_number_of_fragments = frm_number_of_fragments + 1;
      512 	  cm_file_header.number_of_blocks = frm_number_of_fragments;
      513 	  map_idx = frm_number_of_fragments;
      514 	  control_interval_number =
      515 	       file_reservation_map (map_idx - 1)
      516 	       .lowest_numbered_control_interval
      517 	       + frmf_number_of_control_intervals;
      518 	  file_reservation_map (map_idx).lowest_numbered_control_interval =
      519 	       control_interval_number + 1;
      520 	  string (file_reservation_map (map_idx).flags) = "0"b;
      521 	  addr (file_reservation_map (map_idx).element_id)
      522 	       -> element_id.control_interval_id = control_interval_number;
      523 	  addr (file_reservation_map (map_idx).element_id)
      524 	       -> element_id.index = 0;
      525 	  file_reservation_map_fragment = "0"b;
      526 	  substr (file_reservation_map_fragment, 1, 1) = "1"b;
      527 	  control_interval_number = control_interval_number + 1;
      528 
      529          /*** Assign a disk address for the new control interval by writing into the new
      530*	    control interval.  Put the bci_header initialized earlier. */
      531 
      532 	  ci_parts.part (1).local_ptr = bci_header_ptr;
      533 
      534 	  call file_manager_$put (cm_info.file_oid, control_interval_number,
      535 	       ci_parts_ptr, code);
      536 	  if code ^= 0
      537 	  then call ERROR_RETURN (code);
      538 
      539          /*** Set up the CI for the new fragment. */
      540 
      541 	  unspec (fragment_bci_header) = "0"b;
      542 	  fragment_bci_header.layout_type = BASIC_CI_LAYOUT_1;
      543 	  fragment_bci_header.collection_id = HEADER_COLLECTION_ID;
      544 	  fragment_bci_header.start_of_used_space =
      545 	       CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES;
      546 
      547 	  ci_parts.part (1).local_ptr = addr (fragment_bci_header);
      548 	  call file_manager_$put (cm_info.file_oid,
      549 	       (addr (file_reservation_map (map_idx).element_id)
      550 	       -> element_id.control_interval_id), ci_parts_ptr, code);
      551 	  if code ^= 0
      552 	  then call ERROR_RETURN (code);
      553 
      554          /*** Allocate a new file_reservation_map_fragment. */
      555 
      556 	  call cm_put (cm_info.file_oid, HEADER_COLLECTION_ID,
      557 	       file_reservation_map_fragment_ptr,
      558 	       (frmf_number_of_control_intervals),
      559 	       file_reservation_map (map_idx).element_id, (0), code);
      560 	  if code ^= 0
      561 	  then call ERROR_RETURN (code);
      562 
      563          /*** Put the updated cm_file_header. */
      564 
      565 	  call cm_modify (cm_info.file_oid, HEADER_COLLECTION_ID,
      566 	       cm_file_header_ptr, -1, CM_FILE_HEADER_ELEMENT_ID, (0), code);
      567 	  if code ^= 0
      568 	  then call ERROR_RETURN (code);
      569 
      570          /*** Put the revised file_reservation_map. */
      571 
      572 	  call cm_modify (cm_info.file_oid, HEADER_COLLECTION_ID,
      573 	       file_reservation_map_ptr,
      574 	       length (unspec (file_reservation_map)),
      575 	       cm_file_header.allocation_map_element_id, (0), code);
      576 	  if code ^= 0
      577 	  then call ERROR_RETURN (code);
      578 
      579          /*** Put updated collection_header. */
      580 
      581 	  unblocked_storage_record.last_control_interval =
      582 	       control_interval_number;
      583 
      584 	  if unblocked_storage_record.first_control_interval = 0
      585 	       & cm_info.collection_id ^= HEADER_COLLECTION_ID
      586 	  then unblocked_storage_record.first_control_interval =
      587 		  control_interval_number;
      588 
      589 	  call cm_modify (cm_info.file_oid, HEADER_COLLECTION_ID,
      590 	       cm_info.storage_record_ptr, -1,
      591 	       collection_header.storage_record_element_id, (0), code);
      592 	  if code ^= 0
      593 	  then call MODIFY_ERROR_RETURN (code, "storage record",
      594 		  collection_header.storage_record_element_id);
      595 
      596 	  call cm_modify (cm_info.file_oid, HEADER_COLLECTION_ID,
      597 	       cm_info.header_ptr, -1, cm_info.collection_id, (0), code);
      598 	  if code ^= 0
      599 	  then call MODIFY_ERROR_RETURN (code, "collection header",
      600 		  cm_info.collection_id);
      601 
      602 	  if previous_control_interval_number ^= 0
      603 	       | cm_info.collection_id = HEADER_COLLECTION_ID
      604 	  then
      605 	     do;
      606 
      607 	  /*** Thread in the previous control interval.  This control interval has
      608*	       already been locked exclusively, so a non-zero error code indicates a
      609*	       fatal problem. */
      610 
      611 	     previous_bci_header.next_control_interval =
      612 		control_interval_number;
      613 	     ci_parts.part (1).local_ptr = addr (previous_bci_header);
      614 
      615 	     call file_manager_$put (cm_info.file_oid,
      616 		previous_control_interval_number, ci_parts_ptr, code);
      617 	     if code ^= 0
      618 	     then call ERROR_RETURN (code);
      619 	  end;
      620 
      621          end EXTEND_MAP_AND_ALLOCATE_IN_NEW_FRAGMENT;
      622       end BEGIN_BLOCK;
      623    end UNBLOCKED;
      624 
      625    if static_trace_thread_switch
      626    then call ioa_ (
      627 	   "Control interval ^d allocated with previous of ^d.^/^8xControl interval ^d changed to have next of ^d."
      628 	   , control_interval_number, bci_header.previous_control_interval,
      629 	   previous_bci_header.next_control_interval);
      630 
      631    p_control_interval_number = control_interval_number;
      632 
      633 MAIN_RETURN:
      634    return;
      635 
      636 
      637 trace_thread_modifications_on:
      638    entry ();
      639 
      640    static_trace_thread_switch = "1"b;
      641    call cm_free_ci$trace_thread_modifications_on ();
      642    call cm_replace_buffered_ci$trace_thread_modifications_on ();
      643    return;
      644 
      645 trace_thread_modifications_off:
      646    entry ();
      647 
      648    static_trace_thread_switch = "0"b;
      649    call cm_free_ci$trace_thread_modifications_off ();
      650    call cm_replace_buffered_ci$trace_thread_modifications_off ();
      651    return;
      652 
      653 
      654 ERROR_RETURN:
      655    proc (er_p_code);
      656 
      657    dcl	 er_p_code	    fixed bin (35);
      658 
      659    p_code = er_p_code;
      660    go to MAIN_RETURN;
      661 
      662    end ERROR_RETURN;
      663 
      664 
      665 CHECK_VERSION:
      666    proc (cv_p_structure_name, cv_p_given_version, cv_p_correct_version);
      667 
      668    dcl	 cv_p_structure_name    char (*);
      669    dcl	 cv_p_given_version	    char (8) aligned;
      670    dcl	 cv_p_correct_version   char (8) aligned;
      671 
      672    if cv_p_given_version ^= cv_p_correct_version
      673    then call sub_err_ (error_table_$unimplemented_version, myname,
      674 	   ACTION_CANT_RESTART, null, 0,
      675 	   "^/Expected version ^8a of ^a structure; received ^8a.",
      676 	   cv_p_correct_version, cv_p_structure_name, cv_p_given_version);
      677    else return;
      678 
      679    end CHECK_VERSION;
      680 
      681 GET_ERROR_RETURN:
      682    proc (ger_p_code, ger_p_element_name, ger_p_element_id,
      683         ger_p_expected_length);
      684 
      685    dcl	 ger_p_code	    fixed bin (35);
      686    dcl	 ger_p_element_name	    char (*);
      687    dcl	 ger_p_element_id	    bit (36) aligned;
      688    dcl	 ger_p_expected_length  fixed bin (35);
      689 
      690    if ger_p_code = dm_error_$long_return_element
      691    then call sub_err_ (ger_p_code, myname, ACTION_CANT_RESTART, null, 0,
      692 	   "The ^a at CI ^d, slot ^d, is longer than the ^d bits expected.",
      693 	   ger_p_element_name,
      694 	   addr (ger_p_element_id) -> element_id.control_interval_id,
      695 	   addr (ger_p_element_id) -> element_id.index,
      696 	   ger_p_expected_length);
      697    else if ger_p_code = dm_error_$no_element
      698    then call sub_err_ (ger_p_code, myname, ACTION_CANT_RESTART, null, 0,
      699 	   "^/The ^a expected at CI ^d, slot ^d, is not there.",
      700 	   ger_p_element_name,
      701 	   addr (ger_p_element_id) -> element_id.control_interval_id,
      702 	   addr (ger_p_element_id) -> element_id.index);
      703    else if ger_p_code = dm_error_$ci_not_allocated
      704 	   | ger_p_code = dm_error_$ci_not_in_collection
      705 	   | ger_p_code = dm_error_$misformatted_ci
      706    then call sub_err_ (ger_p_code, myname, ACTION_CANT_RESTART, null, 0,
      707 	   "^/CI ^d is expected to have the ^a at slot ^d.",
      708 	   addr (ger_p_element_id) -> element_id.control_interval_id,
      709 	   ger_p_element_name, addr (ger_p_element_id) -> element_id.index);
      710    else call ERROR_RETURN (ger_p_code);
      711 
      712    end GET_ERROR_RETURN;
      713 
      714 MODIFY_ERROR_RETURN:
      715    proc (mer_p_code, mer_p_element_name, mer_p_element_id);
      716 
      717    dcl	 mer_p_code	    fixed bin (35);
      718    dcl	 mer_p_element_name	    char (*);
      719    dcl	 mer_p_element_id	    bit (36) aligned;
      720 
      721    if mer_p_code = dm_error_$long_element
      722    then call sub_err_ (mer_p_code, myname, ACTION_CANT_RESTART, null, 0,
      723 	   "The ^a at CI ^d, slot ^d, did not fit, even though it did not change in size."
      724 	   , mer_p_element_name,
      725 	   addr (mer_p_element_id) -> element_id.control_interval_id,
      726 	   addr (mer_p_element_id) -> element_id.index);
      727    else if mer_p_code = dm_error_$no_element
      728    then call sub_err_ (mer_p_code, myname, ACTION_CANT_RESTART, null, 0,
      729 	   "^/The ^a expected at CI ^d, slot ^d, is not there.",
      730 	   mer_p_element_name,
      731 	   addr (mer_p_element_id) -> element_id.control_interval_id,
      732 	   addr (mer_p_element_id) -> element_id.index);
      733    else if mer_p_code = dm_error_$ci_not_allocated
      734 	   | mer_p_code = dm_error_$ci_not_in_collection
      735 	   | mer_p_code = dm_error_$misformatted_ci
      736    then call sub_err_ (mer_p_code, myname, ACTION_CANT_RESTART, null, 0,
      737 	   "^/CI ^d is expected to have the ^a at slot ^d.",
      738 	   addr (mer_p_element_id) -> element_id.control_interval_id,
      739 	   mer_p_element_name, addr (mer_p_element_id) -> element_id.index);
      740    else call ERROR_RETURN (mer_p_code);
      741 
      742    end MODIFY_ERROR_RETURN;
      743 
      744 
      745 FILE_MAP_ERROR_RETURN:
      746    proc (fmer_p_code, fmer_p_fragment_number, fmer_p_element_id,
      747         fmer_p_expected_length);
      748 
      749    dcl	 fmer_p_code	    fixed bin (35);
      750    dcl	 fmer_p_fragment_number fixed bin (17);
      751    dcl	 fmer_p_element_id	    bit (36) aligned;
      752    dcl	 fmer_p_expected_length fixed bin (35);
      753 
      754    if fmer_p_code = dm_error_$long_return_element
      755    then call sub_err_ (fmer_p_code, myname, ACTION_CANT_RESTART, null, 0,
      756 	   "File reservation map fragment ^d at CI ^d, slot ^d, is longer than^/the ^d bits expected."
      757 	   , fmer_p_fragment_number,
      758 	   addr (fmer_p_element_id) -> element_id.control_interval_id,
      759 	   addr (fmer_p_element_id) -> element_id.index,
      760 	   fmer_p_expected_length);
      761    else if fmer_p_code = dm_error_$no_element
      762    then call sub_err_ (fmer_p_code, myname, ACTION_CANT_RESTART, null, 0,
      763 	   "^/File reservation map fragment ^d is not at the expected location, CI ^d, slot ^d."
      764 	   , fmer_p_fragment_number,
      765 	   addr (fmer_p_element_id) -> element_id.control_interval_id,
      766 	   addr (fmer_p_element_id) -> element_id.index);
      767    else if fmer_p_code = dm_error_$ci_not_allocated
      768 	   | fmer_p_code = dm_error_$ci_not_in_collection
      769 	   | fmer_p_code = dm_error_$misformatted_ci
      770    then call sub_err_ (fmer_p_code, myname, ACTION_CANT_RESTART, null, 0,
      771 	   "^/CI ^d is expected to have file reservation map fragment ^d at slot ^d."
      772 	   , addr (fmer_p_element_id) -> element_id.control_interval_id,
      773 	   fmer_p_fragment_number,
      774 	   addr (fmer_p_element_id) -> element_id.index);
      775    else call ERROR_RETURN (fmer_p_code);
      776 
      777    end FILE_MAP_ERROR_RETURN;
      778 
  1     1 /* BEGIN INCLUDE FILE - dm_hdr_collection_id.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*
  1     5*        Contains the identifier of the Header Collection for a file
  1     6*   managed by the collection_manager_.  This is used by callers of 
  1     7*   collection_manager who wish to maintain their own file header or who wish
  1     8*   to maintain their own collection header information beyond the caller
  1     9*   collection header provided by colleciton_manager_$(get put)_header.
  1    10**/
  1    11 
  1    12 /* HISTORY:
  1    13*Written by Matthew Pierret, 09/24/84.
  1    14*Modified:
  1    15**/
  1    16 
  1    17 /* format: style2,ind3,ll79 */
  1    18 
  1    19      dcl	   HEADER_COLLECTION_ID   init ("000000000001"b3) bit (36)
  1    20 			      aligned internal static options (constant);
  1    21 
  1    22 /* END INCLUDE FILE - dm_hdr_collection_id.incl.pl1 */
      779 
      780 
  2     1 /* BEGIN INCLUDE FILE dm_cm_hdr_col_ids.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*   Contains element identifiers of some elements in the Header Collection.
  2     6*   HEADER_COLLECTION_HEADER_ELEMENT_ID is the identifier of the element in
  2     7*   which the collection_header for the Header Collection is stored (see
  2     8*   dm_cm_collection_header.incl.pl1).
  2     9*   CALLER_HEADER_ELEMENT_ID is the identifier of the element in which the
  2    10*   caller's file header is stored.
  2    11*   CM_FILE_HEADER_ELEMENT_ID is the identifier of the element in which the
  2    12*   cm_file_header structure is stored (see dm_cm_file_header.incl.pl1).
  2    13**/
  2    14 
  2    15 /* HISTORY:
  2    16*Written by Matthew Pierret, 09/24/84.
  2    17*Modified:
  2    18**/
  2    19 
  2    20 /* format: style2,ind3,ll79 */
  2    21      dcl	   (
  2    22 	   HEADER_COLLECTION_HEADER_ELEMENT_ID
  2    23 			      init ("000000000001"b3),
  2    24 	   CM_FILE_HEADER_ELEMENT_ID
  2    25 			      init ("000000000002"b3),
  2    26 	   CALLER_HEADER_ELEMENT_ID
  2    27 			      init ("000000000003"b3)
  2    28 	   )		      bit (36) aligned int static
  2    29 			      options (constant);
  2    30 
  2    31 /* END INCLUDE FILE  dm_cm_hdr_col_ids.incl.pl1 */
      781 
      782 
  3     1 /* BEGIN INCLUDE FILE - dm_cm_info.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*        The cm_info structure is used to hold per-process opening information
  3     5*   about a collection.  It is generally allocated in the process' DM free
  3     6*   area, as returned by the function get_dm_free_area_.  The opening_manager_
  3     7*   is used to provide access the cm_info structure, keeping it in a hash
  3     8*   table keyed on file opening id and collection id combined.
  3     9*        Currently cm_info is never freed until the process terminates.  Each
  3    10*   time a new transaction is started, detected when the current transaction
  3    11*   id of a process differs from cm_info.current_transaction_id, the information
  3    12*   in cm_info is refreshed.  Storage record information is only refreshed on
  3    13*   demand, as most modules do not need the information in the storage record.
  3    14*   Instead, cm_info.storage_record_ptr is set to null (), but 
  3    15*   cm_info.storage_record_buffer_ptr remains set to the previous value of
  3    16*   cm_info.storage_record_ptr.  When a refreshed copy of the storage record is
  3    17*   requested, it is placed at the location pointed to by
  3    18*   cm_info.storage_record_buffer_ptr, saving the expense of re-allocation.
  3    19**/
  3    20 
  3    21 /* HISTORY:
  3    22*Written by Matthew Pierret, 10/27/82. 
  3    23*Modified:
  3    24*01/25/83 by Matthew Pierret: Changed to version 2.  Added 
  3    25*            storage_record_buffer_ptr. This points to the storage_record.
  3    26*            When cm_info is refreshed, storage_record_ptr is set to null,
  3    27*            but storage_record_buffer_ptr continues to point at where the
  3    28*            storage_record was. When the storge_record is again requested,
  3    29*            it is put back in the same place rather than allocating a new
  3    30*            storage_record.
  3    31*09/24/84 by Matthew Pierret:  Re-wrote DESCRIPTION section. Removed the
  3    32*            init clause from the version component.
  3    33**/
  3    34 
  3    35 /* format: style2,ind3,ll79 */
  3    36 
  3    37      dcl	   1 cm_info	      aligned based (cm_info_ptr),
  3    38 	     2 version	      char (8),
  3    39 	     2 current_txn_id     bit (36) aligned init ("0"b),
  3    40 	     2 file_oid	      bit (36) aligned init ("0"b),
  3    41 	     2 collection_id      bit (36) aligned init ("0"b),
  3    42 	     2 header_ptr	      ptr init (null),
  3    43 	     2 storage_record_ptr ptr init (null),
  3    44 	     2 storage_record_buffer_ptr
  3    45 			      ptr init (null);
  3    46 
  3    47      dcl	   cm_info_ptr	      ptr init (null);
  3    48      dcl	   CM_INFO_VERSION_2      init ("cm_info2") char (8) aligned
  3    49 			      internal static options (constant);
  3    50 
  3    51 /* END INCLUDE FILE - dm_cm_info.incl.pl1 */
      783 
      784 
  4     1 /* BEGIN INCLUDE FILE dm_cm_file_header.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*
  4     5*        This include file contains the cm_file_header and collection_id_table 
  4     6*   structure.  These structures are stored as elements in the Header Collection
  4     7*   of a file and contain per-file, as opposed to per-collection, information.
  4     8*   
  4     9*        The cm_file_header structure is always stored in the element whose
  4    10*   identifier is CM_FILE_HEADER_ELEMENT_ID, declared in 
  4    11*   dm_cm_hdr_col_ids.incl.pl1.  
  4    12*   
  4    13*        The collection_id_table is an array of identifiers of each collection 
  4    14*   in the file, excepting the Header Collection.  The identifier of a 
  4    15*   collection is the same as the identifier of the element which holds that
  4    16*   collection's collection_header, described in dm_cm_collection_header.incl.pl1.
  4    17*   The identifier of the element in which the collection_id_table is
  4    18*   stored is cm_file_header.collection_id_table_element_id.
  4    19*   
  4    20*      A file also has a reservation map for determining which controls 
  4    21*   intervals have been reserved by a collection.  It is divided into
  4    22*   several blocks, or fragments.  The file_reservation_map is actually an
  4    23*   array of element identifiers of the fragments of the map.  The 
  4    24*   file_reservation_map is stored in the element whose identifier is 
  4    25*   cm_file_header.allocation_map_element_id (quite a misnomer).  The number
  4    26*   of fragments of the map is cm_file_header.number_of_blocks.  The size
  4    27*   of each is fragment is cm_file_header.number_of_control_intervals_per_block
  4    28*   bits long, representing equally as many control intervals.  The
  4    29*   file_reservation_map is described in dm_cm_reservation_map.incl.pl1.
  4    30*   cm_file_header.highest_numbered_ci is the number of the control
  4    31*   interval in the file with the highest control interval number.  It is not 
  4    32*   yet used or maintained.
  4    33*
  4    34**/
  4    35 
  4    36 /* HISTORY:
  4    37*Written by Matthew Pierret, 03/23/82.
  4    38*Modified:
  4    39*04/08/82 by Matthew Pierret: Removed storage method constants.
  4    40*05/18/82 by Matthew Pierret: Made the array of collections an array of element
  4    41*            ids referring to collection_header's. Reduced buffer length to 120,
  4    42*            enough bytes to hold the collmgr_header with 25 collection header
  4    43*            element ids.
  4    44*06/03/82 by Matthew Pierret: Added collmgr_header_header.
  4    45*07/01/82 by Matthew Pierret: Removed collmgr_header_header. Changed to version A
  4    46*            made fixed length, split off array of collection_ids (also known as
  4    47*            element_ids of collection_headers).
  4    48*10/29/82 by Matthew Pierret: Changed from collmgr_header to cm_file_header.
  4    49*09/18/84 by Matthew Pierret: Added DESCRIPTION section. Moved constants to
  4    50*            dm_cm_hdr_col_ids.incl.pl1.  
  4    51**/
  4    52 
  4    53 /* format: style2,ind3,ll79 */
  4    54 
  4    55      dcl	   1 cm_file_header	      aligned based (cm_file_header_ptr),
  4    56 	     2 version	      char (8),
  4    57 	     2 highest_numbered_ci
  4    58 			      fixed bin (24) uns,
  4    59 	     2 number_of_collections
  4    60 			      fixed bin (17) unal,
  4    61 	     2 number_of_blocks   fixed bin (17) unal,
  4    62 	     2 number_of_control_intervals_per_block
  4    63 			      fixed bin (17),
  4    64 	     2 allocation_map_element_id
  4    65 			      bit (36) aligned,
  4    66 	     2 collection_id_table_element_id
  4    67 			      bit (36) aligned;
  4    68 
  4    69      dcl	   cm_file_header_ptr     ptr;
  4    70      dcl	   CM_FILE_HEADER_VERSION_1
  4    71 			      char (8) aligned init ("cm_fhdr1")
  4    72 			      int static options (constant);
  4    73 
  4    74 
  4    75      dcl	   collection_id_table    (cit_number_of_collections)
  4    76 			      bit (36) aligned
  4    77 			      based (collection_id_table_ptr);
  4    78 
  4    79      dcl	   collection_id_table_ptr
  4    80 			      ptr;
  4    81      dcl	   cit_number_of_collections
  4    82 			      fixed bin (17);
  4    83 
  4    84 
  4    85 
  4    86 /* ----------End include file dm_cm_file_header.incl.pl1---------- */
  4    87 
      785 
      786 
  5     1 /* BEGIN INCLUDE FILE - dm_cm_collection_header.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*       Associated with each collection is the following collection_header
  5     5*   structure stored as an element in the Header Collection of the file.
  5     6*   The identifier of this element is also the idenfifier of the collection.
  5     7*   Even the Header Collection has a collection_header stored in the Header
  5     8*   Collection itself in the element identified by the constant
  5     9*   HEADER_COLLECTION_HEADER_ELEMENT_ID declared in dm_cm_hdr_col_ids.incl.pl1.
  5    10*   The information in collection_header is expected to be stable information.
  5    11*   The structure elements are described as follows:
  5    12*   
  5    13*   version is a character string version equal to COLLECTION_HEADER_VERSION_2.
  5    14*   
  5    15*   flags.fixed_size_elements indicates, if on that all elements in the
  5    16*   collection are of a fixed length.
  5    17*   
  5    18*   flags.thread_elements indicates that elements in a collection are to be
  5    19*   threaded in a linked list.  This is currrently unupported.
  5    20*   
  5    21*   flags.thread_control_intervals indicates, if on, that control intervals in
  5    22*   a collection are to be threaded in a linked list.  This is only useful if
  5    23*   the control interval storage method is blocked.
  5    24*   
  5    25*   flags.must_be_zero1 is reserved for future use and must be "0"b.
  5    26*   
  5    27*   control_interval_storage_method is the method of storage management of
  5    28*   control intervals for this collection, either
  5    29*   BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD (not yet supported) or
  5    30*   UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD, declared in
  5    31*   dm_cism_info.incl.pl1.
  5    32*   
  5    33*   element_storage_method is the method of storage management of elements in
  5    34*   this collection, either BASIC_ELEMENT_STORAGE_METHOD or
  5    35*   ORDERED_ELEMENT_STORAGE_METHOD, declared in dm_esm_info.incl.pl1.
  5    36*   
  5    37*   maximum_element_size is the maximum size of an element in bits in this
  5    38*   collection.
  5    39*   
  5    40*   header_record_element_id is the identifier of an element containing a
  5    41*   caller-defined header for this collection.  If equal to "0"b, no
  5    42*   caller-defined header yet exists.  The put_header collection_manager_
  5    43*   operation stores such a header.
  5    44*   
  5    45*   storage_record_element_id is the identifier of the element containing the
  5    46*   storage_record for this collection.  The storage_record contains
  5    47*   information expected to be dynamic, such as the identifier of the last
  5    48*   control interval of the collection.  Its format is also dependent upon the
  5    49*   storage methods in effect for this collection.  storage_record structures
  5    50*   are declared in dm_cm_storage_record.incl.pl1.
  5    51*
  5    52**/
  5    53 
  5    54 /* HISTORY:
  5    55*Written by Matthew Pierret, 04/01/82.
  5    56*Modified:
  5    57*07/01/82 by Matthew Pierret: Changed to version A, added storage_record_area.
  5    58*10/29/82 by Matthew Pierret: Changed to version 2 ("col_hdr2"), separated
  5    59*            storage_record_area out, leaving storage_record_element_id behind.
  5    60*09/18/84 by Matthew Pierret: Added DESCRIPTION section.
  5    61**/
  5    62 
  5    63 /* format: style2,ind3,ll79 */
  5    64 
  5    65      dcl	   1 collection_header    aligned based (collection_header_ptr),
  5    66 	     2 version	      char (8),
  5    67 	     2 flags	      unaligned,
  5    68 	       3 fixed_size_elements
  5    69 			      bit (1),
  5    70 	       3 thread_elements  bit (1),
  5    71 	       3 thread_control_intervals
  5    72 			      bit (1),
  5    73 	       3 must_be_zero1    bit (15),
  5    74 	     2 control_interval_storage_method
  5    75 			      fixed bin (17) unal,
  5    76 	     2 element_storage_method
  5    77 			      fixed bin (17),
  5    78 	     2 maximum_element_size
  5    79 			      fixed bin (35),
  5    80 	     2 header_record_element_id
  5    81 			      bit (36) aligned,
  5    82 	     2 storage_record_element_id
  5    83 			      bit (36) aligned;
  5    84 
  5    85      dcl	   collection_header_ptr  ptr;
  5    86      dcl	   COLLECTION_HEADER_VERSION_2
  5    87 			      init ("col_hdr2") char (8) aligned
  5    88 			      int static options (constant);
  5    89 
  5    90 /* END INCLUDE FILE - dm_cm_collection_header.incl.pl1 */
      787 
      788 
  6     1 /* BEGIN INCLUDE FILE dm_cm_storage_record.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*
  6     5*        A storage record is an extension to the collection_header structure.
  6     6*   It is expected to be more volatile than collection_header and has a 
  6     7*   different format depending on the control interval storage method in use
  6     8*   for the collection.  A storage record is stored as an element in the 
  6     9*   file's Header Collection with the element identifier 
  6    10*   collection_header.storage_record_element_id.
  6    11*   
  6    12*        The unblocked_storage_record contains the control interval numbers
  6    13*   of the first and last control intervals of a collection.  Unblocked
  6    14*   control intervals are chained together, so all control intervals can be 
  6    15*   found by starting at one end and following the chain forward or backward.
  6    16*   
  6    17*        The blocked_storage_record is not yet used, as the Blocked Control
  6    18*   Interval Storage Method is not yet implemented.
  6    19**/
  6    20 
  6    21 /* HISTORY:
  6    22*Written by Matthew Pierret, 09/24/84.
  6    23*Modified:
  6    24**/
  6    25 
  6    26 /* format: style2,ind3,ll79 */
  6    27 
  6    28      dcl	   1 unblocked_storage_record
  6    29 			      aligned
  6    30 			      based (unblocked_storage_record_ptr),
  6    31 	     2 first_control_interval
  6    32 			      fixed bin (24) uns,
  6    33 	     2 last_control_interval
  6    34 			      fixed bin (24) uns;
  6    35 
  6    36      dcl	   1 blocked_storage_record
  6    37 			      aligned based (blocked_storage_record_ptr),
  6    38 	     2 last_control_interval
  6    39 			      fixed bin (24) uns,
  6    40 	     2 number_of_blocks   fixed bin (17) unal,
  6    41 	     2 number_of_control_intervals_per_block
  6    42 			      fixed bin (17) unal,
  6    43 	     2 allocation_map_element_id
  6    44 			      bit (36) aligned;
  6    45 
  6    46      dcl	   unblocked_storage_record_ptr
  6    47 			      ptr init (null ());
  6    48      dcl	   blocked_storage_record_ptr
  6    49 			      ptr init (null ());
  6    50 
  6    51 /* END INCLUDE FILE dm_cm_storage_record.incl.pl1 */
      789 
      790 
  7     1 /* BEGIN INCLUDE FILE dm_cm_reservation_map.incl.pl1 */
  7     2 
  7     3 /* DESCRIPTION:
  7     4*
  7     5*        The collection_manager_'s file reservation map is used to keep track of
  7     6*   those control intervals which have been reserved by a collection so that
  7     7*   more than one collection in a file do not attempt to use the same control 
  7     8*   interval.  Logically the file reservation map is one long bit string
  7     9*   containing a bit for each control interval of the file.  If the bit for
  7    10*   a control interval is "1"b, that control interval has been reserved.
  7    11*   Actually the map is divided into several fragments represented by 
  7    12*   file_reservation_map_fragment structures, each a bit string of uniform
  7    13*   length and each stored as an element in the Header Collection.  Ideally,
  7    14*   each fragment is stored in a different control interval of the Header 
  7    15*   Collection for enhanced concurrent access to the map.
  7    16*   
  7    17*        To increase speed of reference and concurrent throughput the fragments
  7    18*   are not chained together, but are kept track of by the file_reservation_map
  7    19*   structure.  This structure is an array with each entry describing the
  7    20*   location of a fragment, the number of the control interval for which the
  7    21*   first bit in the fragment represents, and a flag which, if on, indicates 
  7    22*   that there are no unreserved control intervals in the fragment.  This flag
  7    23*   allows for skipping looking at fragments which are already full.
  7    24**/
  7    25 
  7    26 /* HISTORY:
  7    27*Written by Matthew Pierret, 2/23/83.
  7    28*Modified:
  7    29*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  7    30**/
  7    31 
  7    32 /* format: style2,ind3,ll79 */
  7    33 
  7    34      dcl	   1 file_reservation_map (frm_number_of_fragments) aligned
  7    35 			      based (file_reservation_map_ptr),
  7    36 	     2 flags	      unal,
  7    37 	       3 no_control_intervals_are_available
  7    38 			      bit (1) unal,
  7    39 	       3 must_be_zero     bit (11) unal,
  7    40 	     2 lowest_numbered_control_interval
  7    41 			      fixed bin (24) uns unal,
  7    42 	     2 element_id	      bit (36) aligned;
  7    43 
  7    44      dcl	   file_reservation_map_fragment
  7    45 			      aligned
  7    46 			      based (file_reservation_map_fragment_ptr)
  7    47 			      bit (frmf_number_of_control_intervals);
  7    48 
  7    49 
  7    50      dcl	   file_reservation_map_ptr
  7    51 			      ptr;
  7    52      dcl	   frm_number_of_fragments
  7    53 			      fixed bin (17);
  7    54 
  7    55      dcl	   file_reservation_map_fragment_ptr
  7    56 			      ptr;
  7    57      dcl	   frmf_number_of_control_intervals
  7    58 			      fixed bin (17);
  7    59 
  7    60 
  7    61 /* END INCLUDE FILE dm_cm_reservation_map.incl.pl1 */
      791 
      792 
  8     1 /* BEGIN INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
  8     2 
  8     3 /* DESCRIPTION:
  8     4*
  8     5*        The collection_manager_ manages the structure of the addressable
  8     6*   portion of a control interval.  The addressable portion is that portion of
  8     7*   a control interval which the file_manager_ will allow the
  8     8*   collection_manager_ to address.  In this description control interval will
  8     9*   be used to mean the addressable portion of a control interval.
  8    10*   
  8    11*        A control interval is divided into four parts: the header, the datum
  8    12*   position table (also known as the slot table or slots), un-used space and
  8    13*   used space.  The beginning of the header is at offset 0, and the end of the
  8    14*   used space is at the end of the control interval (curently offset 4072).
  8    15*   Pictoriarly, a control interval is structured as follows:
  8    16*   
  8    17*   ----------------------------------------------------------------------
  8    18*   |        || | | | | | ||               ||   | / / |       |/|   |    |
  8    19*   | Header || | slot  | || un-used space ||   |/ / /|       |/|   |    |
  8    20*   |        || | table | ||               ||   | / / |       |/|   |    |
  8    21*   |        || | | | | | ||               ||   |/ / /|       |/|   |    |
  8    22*   ----------------------------------------------------------------------
  8    23*                                           ^ ^    ^      ^    ^  ^   ^
  8    24*                                           | |    |      |    |  |   |
  8    25*                                           | |...........|.......|...|
  8    26*                        start of used space|      |           |      |
  8    27*                                                  |           |  each|
  8    28*                                          scattered free space|  is a used
  8    29*                                                                 datum
  8    30*   
  8    31*      The basic_control_interval structure describes the header
  8    32*   (basic_control_interval.header, bci_header) and the slots
  8    33*   (basic_control_interval.datum_position_table, datum_slot for one only).
  8    34*   Each datum_slot contains the offset (in bytes) and the length (in bits) of
  8    35*   a datum in the used space.  If the offset is equal to FREE_SLOT (declared
  8    36*   in dm_cm_basic_ci_const.incl.pl1), the slot is un-used.  The slot also
  8    37*   contains flags describing the type of datum (see dm_cm_datum.incl.pl1).
  8    38**/
  8    39 
  8    40 /* HISTORY:
  8    41*Written by Matthew Pierret, 02/07/82.
  8    42*Modified:
  8    43*03/25/82 by Matthew Pierret: Fixed alignment differences basic_control_interval
  8    44*            and its sub-structures.
  8    45*06/14/82 by Matthew Pierret: Removed common header and buffers. Changed
  8    46*            basic_ci_header to bci_header. Added previous_control_interval.
  8    47*07/12/82 by Matthew Pierret: Changed collection_id to be bit (36) aligned.
  8    48*10/29/82 by Matthew Pierret: Added flags to datum slots. 
  8    49*11/10/82 by Matthew Pierret: Removed continued_datum_is_present flag, as it
  8    50*            is not used.
  8    51*03/28/84 by Matthew Pierret: Added the constants BCI_HEADER_LENGTH_IN_BYTES
  8    52*            and DATUM_POSITION_TABLE_OFFSET_IN_BYTES.
  8    53**/
  8    54 
  8    55 /* format: style2 */
  8    56      dcl	   1 basic_control_interval
  8    57 			      aligned based (basic_control_interval_ptr),
  8    58 	     2 header	      like bci_header,
  8    59 	     2 datum_position_table
  8    60 			      (0 refer (basic_control_interval.number_of_datums)) like datum_slot;
  8    61 
  8    62 
  8    63      dcl	   1 bci_header	      aligned based (bci_header_ptr),
  8    64 	     2 layout_type	      char (4) aligned,
  8    65 	     2 collection_id      bit (36) aligned,
  8    66 	     2 next_control_interval
  8    67 			      fixed bin (24) uns unal,
  8    68 	     2 previous_control_interval
  8    69 			      fixed bin (24) uns unal,
  8    70 	     2 flags	      unal,
  8    71 	       3 continuation_datum_is_present
  8    72 			      bit (1) unal,
  8    73 	       3 free_slot_is_present
  8    74 			      bit (1) unal,
  8    75 	       3 must_be_zero     bit (4) unal,		/* reserved */
  8    76 	     2 scattered_free_space
  8    77 			      fixed bin (17) unal,
  8    78 	     2 start_of_used_space
  8    79 			      fixed bin (17) unal,
  8    80 	     2 number_of_datums   fixed bin (17) unal;
  8    81 
  8    82      dcl	   1 datum_slot	      aligned based (datum_slot_ptr),
  8    83 	     2 flags	      unal,
  8    84 	       3 special_format_datum
  8    85 			      bit (1) unal,		/* reserved */
  8    86 	       3 is_continued     bit (1) unal,
  8    87 	       3 is_continuation  bit (1) unal,
  8    88 	       3 mbz	      bit (1) unal,		/* reserved */
  8    89 	     2 offset_in_bytes    fixed bin (15) uns unal,
  8    90 	     2 length_in_bits     fixed bin (17) uns unal;
  8    91 
  8    92      dcl	   basic_control_interval_ptr
  8    93 			      ptr;
  8    94      dcl	   bci_header_ptr	      ptr;
  8    95      dcl	   datum_slot_ptr	      ptr;
  8    96 
  8    97      dcl	   BASIC_CI_LAYOUT_1      char (4) aligned init ("bci1") internal static options (constant);
  8    98 
  8    99 /* END INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
      793 
      794 
  9     1 /* BEGIN INCLUDE FILE dm_cism_info.incl.pl1 */
  9     2 
  9     3 /* DESCRIPTION:
  9     4*
  9     5*     This include file contains the blocked_cism_info and unblocked_cism_info
  9     6*     structures, as well as constants relevant to control interval storage
  9     7*     management.  These structures and constants are used by several managers.
  9     8*     The structures each describe a method of control interval storage 
  9     9*     management.
  9    10**/
  9    11 
  9    12 /* HISTORY:
  9    13*
  9    14*Written 02/07/82 by Matthew Pierret.
  9    15*Modified:
  9    16*05/17/84 by Matthew Pierret:  Changed to align structure elements and add
  9    17*            a version string.
  9    18**/
  9    19 
  9    20 /* format: style2 */
  9    21 
  9    22      dcl	   1 blocked_cism_info    based (blocked_cism_info_ptr) aligned,
  9    23 	     2 version	      char (8) aligned init (CISM_INFO_VERSION_1),
  9    24 	     2 type	      fixed bin (17) init (BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD),
  9    25 	     2 number_of_control_intervals_per_block
  9    26 			      fixed bin (17);
  9    27 
  9    28      dcl	   1 unblocked_cism_info  based (unblocked_cism_info_ptr) aligned,
  9    29 	     2 version	      char (8) aligned init (CISM_INFO_VERSION_1),
  9    30 	     2 type	      fixed bin (17) init (UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD),
  9    31 	     2 must_be_zero	      fixed bin (17);
  9    32 
  9    33      dcl	   blocked_cism_info_ptr  ptr;
  9    34      dcl	   unblocked_cism_info_ptr
  9    35 			      ptr;
  9    36 
  9    37      dcl	   CISM_INFO_VERSION_1    init ("CISMinf1") char (8) aligned internal static options (constant);
  9    38      dcl	   BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
  9    39 			      fixed bin init (1) internal static options (constant);
  9    40      dcl	   UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
  9    41 			      fixed bin init (2) internal static options (constant);
  9    42 
  9    43 /* END INCLUDE FILE dm_cism_info.incl.pl1 ---------- */
      795 
      796 
 10     1 /* BEGIN INCLUDE FILE:  dm_ci_header.incl.pl1 */
 10     2 
 10     3 /* DESCRIPTION:
 10     4*
 10     5*        This include file contains various structures which make up the
 10     6*   header and trailer of a control interval.
 10     7*   
 10     8*   ****  NOTE:  The include file dm_ci.incl.pl1 is heavily dependent ****
 10     9*   ****  on this include file.  When changing this include file,     ****
 10    10*   ****  check dm_ci.incl.pl1 to see if it is affected.              ****
 10    11**/
 10    12 
 10    13 /* HISTORY:
 10    14*Written by Jeffrey D. Ives, 03/02/82.
 10    15*  (Design by Andre Bensoussan and Jeffrey D. Ives)
 10    16*Modified:
 10    17*11/02/84 by Matthew Pierret:  Re-organized so that dm_ci.incl.pl1 and
 10    18*            dm_ci_header.incl.pl1 do not duplicate structures or constants.
 10    19**/
 10    20 
 10    21 /* format: style2,ind3 */
 10    22 
 10    23 /* ci_header is the first four words of a control interval. Its contents
 10    24*   are used to verify that a control interval is in an expected format,
 10    25*   to identify the control interval and the file to which the control
 10    26*   interval belongs, and to maintain information for the synchronization
 10    27*   of disk I/O between DM file control intervals and associated before
 10    28*   journal control intervals.  The first two words are the time stamp for
 10    29*   synchronization; the latter two identify the control interval. */
 10    30 
 10    31      dcl	   ci_header_ptr	      ptr;
 10    32      dcl	   1 ci_header	      aligned based (ci_header_ptr),
 10    33 	     2 stamp	      like ci_stamp,
 10    34 	     2 id		      like ci_id;
 10    35 
 10    36 /* ci_trailer is the last two words of a control interval and must match
 10    37*   the first two words (ci_header.stamp). */
 10    38 
 10    39      dcl	   ci_trailer_ptr	      ptr;
 10    40      dcl	   1 ci_trailer	      like ci_header.stamp aligned based (ci_trailer_ptr);
 10    41 
 10    42 
 10    43 /* ci_stamp is a two-word date/time modified stamp, consisting of:
 10    44*     version: a 9-bit version string for the structure
 10    45*     bj_idx:  before journal index for I/O synchronization
 10    46*     time_modified:  Multics clock time of last modification */
 10    47 
 10    48      dcl	   1 ci_stamp	      aligned based,
 10    49 	     3 version	      bit (9) unal,
 10    50 	     3 bj_idx	      fixed bin (9) uns unal,
 10    51 	     3 time_modified      fixed bin (53) unal;
 10    52 
 10    53      dcl	   CI_HEADER_STAMP_VERSION_1
 10    54 			      bit (9) aligned static options (constant) init ("641"b3);
 10    55 
 10    56 /* ci_id is a two-word identification of the control interval, which
 10    57*   rarely changes and consists of:
 10    58*     uid:   DM file unique identifier
 10    59*     size_code:  the control interval size in bytes, in an encoded
 10    60*                 form (see ci_size_code below).
 10    61*     num:   the control interval number.  0 is the number of the first
 10    62*            control interval of a file. */
 10    63 
 10    64      dcl	   1 ci_id	      aligned based,
 10    65 	     3 uid	      bit (36),
 10    66 	     3 size_code	      bit (9) unal,
 10    67 	     3 num	      fixed bin (27) uns unal;
 10    68 
 10    69 /* ci_size_code is the structure which defines the content of ci_id.size_code.
 10    70*   The size in bytes of a control interval is equal to 
 10    71*   (2 ** ci_size_code.exponent * (64 + 8 * ci_size_code.addon)).  */
 10    72 
 10    73      dcl	   1 ci_size_code	      aligned based,
 10    74 	     2 exponent	      fixed bin (6) uns unal,
 10    75 	     2 addon	      fixed bin (3) uns unal;
 10    76 
 10    77 /* ci_header_chunks is a structure which can be used to update the
 10    78*   ci_stamp or ci_id in one memory cycle. */
 10    79 
 10    80      dcl	   1 ci_header_chunks     aligned based (ci_header_ptr),
 10    81 	     2 stamp	      fixed bin (71),
 10    82 	     2 id		      fixed bin (71);
 10    83 
 10    84 /* ci_trailer_chunk is a structure which can e used to update the
 10    85*   ci_trailer in one memory cycle. */
 10    86 
 10    87      dcl	   1 ci_trailer_chunk     aligned based,
 10    88 	     2 stamp	      fixed bin (71);
 10    89 
 10    90 
 10    91 /*  END INCLUDE FILE:  dm_ci_header.incl.pl1  */
      797 
      798 
 11     1 /*  BEGIN INCLUDE FILE:  dm_ci_parts.incl.pl1  */
 11     2 
 11     3 /* DESCRIPTION:
 11     4*
 11     5*        This include file contains the ci_parts structure.  This structure
 11     6*   is used across the file_manager_ interface to specify the parts of a
 11     7*   control interval to get or put.  If the number_of parts is equal to 0,
 11     8*   modules which take ci_parts interpret this case to mean to do everything
 11     9*   except the actual requested operation, i.e., lock the control interval
 11    10*   but don't get anything.  offset_in_bytes is the 0-originned offset in
 11    11*   bytes from the beginning of the addressable portion of the control interval.
 11    12*   An offset_in_bytes which is in the addressable portion is in error.
 11    13*   Likewise, if offset_in_bytes + length_in_bytes is outside of the addressable
 11    14*   portion, it is in error.
 11    15**/
 11    16 
 11    17 /* HISTORY:
 11    18*Written by Matthew Pierret, 01/28/82.
 11    19*  (01/28/82 Andre Bensoussan, Design.)
 11    20*Modified:
 11    21*11/07/84 by Matthew Pierret:  To add must_be_zero, initial attributes on
 11    22*            automatic storge.
 11    23**/
 11    24 
 11    25 /* format: style2,ind3 */
 11    26 
 11    27      dcl	   1 ci_parts	      aligned based (ci_parts_ptr),
 11    28 	     2 number_of_parts    fixed bin (17),
 11    29 	     2 must_be_zero	      fixed bin,
 11    30 	     2 part	      (cip_number_of_parts refer (ci_parts.number_of_parts)),
 11    31 	       3 offset_in_bytes  fixed bin (17),
 11    32 	       3 length_in_bytes  fixed bin (17),
 11    33 	       3 local_ptr	      ptr;
 11    34 
 11    35      dcl	   ci_parts_ptr	      ptr init (null ());
 11    36      dcl	   cip_number_of_parts    fixed bin (17) init (0);
 11    37 
 11    38 
 11    39 /*  BEGIN INCLUDE FILE:   dm_ci_parts.incl.pl1   */
      799 
      800 
 12     1 /* BEGIN INCLUDE FILE dm_ci_lengths.incl.pl1 */
 12     2 
 12     3 /* DESCRIPTION:
 12     4*       This include file contains constants which are the length in bytes
 12     5*   of the addressable portion of a control interval.  The addressable portion
 12     6*   is that part of the control interval which callers of file_manager_
 12     7*   may access, specifically, everything between the end of the control
 12     8*   interval header (ci_header) and the control interval trailer (ci_trailer).
 12     9*   Control interval 0 is slightly different, as it also contains an 
 12    10*   unaddressable portion in which it maintains the file attributes.  For
 12    11*   control interval 0 the addressable portion is everything between the end
 12    12*   of the control interval header and the beginning of the file attributes.
 12    13**/
 12    14 
 12    15 /* HISTORY:
 12    16*Written by Matthew Pierret, 11/02/84.
 12    17*Modified:
 12    18**/
 12    19 
 12    20 /* format: style2,ind3 */
 12    21 
 12    22      dcl	   CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES
 12    23 			      fixed bin (17) init (4072) int static options (constant);
 12    24 
 12    25      dcl	   CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES
 12    26 			      fixed bin (17) init (3176) int static options (constant);
 12    27 
 12    28 
 12    29      dcl	   CI_ADDRESSABLE_LENGTH  fixed bin (17) init (4072) int static options (constant);
 12    30 
 12    31      dcl	   CI_0_ADDRESSABLE_LENGTH
 12    32 			      fixed bin (17) init (3176) int static options (constant);
 12    33 
 12    34 /* END INCLUDE FILE dm_ci_lengths.incl.pl1 */
      801 
      802 
 13     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
 13     2 
 13     3 /* DESCRIPTION:
 13     4*
 13     5*        Contains the declaration of an element identifier.  Element
 13     6*   identifiers consist of two parts, the id (number) of the control interval
 13     7*   in which the element resides, and the index into the slot table of
 13     8*   the element in the control interval.  The declaration of the element_id 
 13     9*   structure reflects this division of the element identifier.  The structure 
 13    10*   is based on the automatic bit string element_id_string because programs
 13    11*   generally pass bit strings (element_id_string) to each other, then 
 13    12*   interpret the bit string by overlaying the element_id structure ony if
 13    13*   it is necessary to access the parts of the id.  Basing element_id on
 13    14*   addr(element_id_string) instead of on a pointer removes the necessity
 13    15*   for always setting that pointer explicitly and guarantees that changes
 13    16*   made to the string or structure do not get inconsistent.
 13    17*
 13    18*   Changes made to element_id must also be made to datum_id, declared in 
 13    19*   dm_cm_datum.incl.pl1.
 13    20**/
 13    21 
 13    22 /* HISTORY:
 13    23*Written by Matthew Pierret, 04/01/82.
 13    24*Modified:
 13    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
 13    26**/
 13    27 
 13    28 /* format: style2,ind3,ll79 */
 13    29 
 13    30      dcl	   element_id_string      bit (36) aligned;
 13    31 
 13    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
 13    33 	     2 control_interval_id
 13    34 			      fixed bin (24) unal unsigned,
 13    35 	     2 index	      fixed bin (12) unal unsigned;
 13    36 
 13    37 
 13    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      803 
      804 
 14     1 /* BEGIN INCLUDE FILE dm_cm_entry_dcls.incl.pl1 */
 14     2 
 14     3 /* DESCRIPTION:
 14     4*
 14     5*   Contains entry declarations of internally available collection_manager_
 14     6*   entries.  Entries which are only available via the collection_manager_
 14     7*   transfer vector are not included here, but are declared instead in 
 14     8*   dm_collmgr_entry_dcls.incl.pl1.
 14     9**/
 14    10 
 14    11 /* HISTORY:
 14    12*Written by Mathew Pierret, 04/01/82.
 14    13*Modified:
 14    14*09/21/82 by Lindsey Spratt:  Added the cm_compact$replacement entry.
 14    15*10/29/82 by Matthew Pierret:  Added cm_find_free_slot, cm_determine_free_space,
 14    16*            cm_find_ci_to_alloc_datum, cm_recursive_put.
 14    17*            Added cm_get_element$info*, $header*.  The former is used when
 14    18*            the caller has a cm_info structure already; the latter is used to
 14    19*            get collection headers.
 14    20*            Added cm_opening_info$get. Removed cm_add_ci_(part thread).
 14    21*            Added cm_allocate_element$info.
 14    22*11/09/82 by Matthew Pierret:  Added argument to cm_allocate_ordered_element
 14    23*            calling sequence for returning free space.
 14    24*            Added cm_free_cn_datum("" $header).
 14    25*01/07/83 by Matthew Pierret:  Added:
 14    26*            cm_allocate_element$buffered("" _info);
 14    27*            cm_put_element$buffered("" _info);
 14    28*            cm_put_datum_in_place$buffered("" _continued);
 14    29*            cm_put_datum_in_pool$buffered("" _continued);
 14    30*            cm_compact$buffered.
 14    31*01/26/83 by Matthew Pierret: Replaced cm_get_header_and_slot with
 14    32*            cm_get_bci_header$slot and added cm_get_bci_header$slot_exclusive.
 14    33*            Added cm_opening_info$get_storage_record.
 14    34*            Added a bit(36)aligned argument to cm_recursive_put to hold the
 14    35*            id of the previous datum.
 14    36*02/02/83 by Matthew Pierret: Added fixed bin (17) argument to cm_find_free_slot
 14    37*            which is for the number of slots after allocation.
 14    38*02/07/83 by Matthew Pierret: Added cm_get_id$(id info info_return_slot
 14    39*            header header_return_slot).
 14    40*            Added cm_get_element_portion$(exclusive info info_exclusive).
 14    41*            Added cm_get_element$bypass_info.
 14    42*03/25/83 by Matthew Pierret: Added cm_free_element$info and
 14    43*            cm_free_opening_info.
 14    44*04/29/83 by Matthew Pierret: Added cm_put_element$unprotected_info
 14    45*08/04/83 by Matthew Pierret:  Added the entries $does_new_datum_fit and
 14    46*            $does_replacement_fit to cm_determine_free_space.  These entries
 14    47*            return flags indicating if a datum fits in the ci and the pool.
 14    48*            Added a bit(1)aligned parameter to cm_find_free_slot in which is
 14    49*            returned the new value of bci_header.free_slot_is_present.
 14    50*02/07/84 by Matthew Pierret:  Added cm_get_id$ptr.  Removed all cm_get_id
 14    51*            modules except cm_get_id$id.  Removed all cm_get_element$info*
 14    52*            entries.  Changed cm_get_element_$bypass_info to have the same
 14    53*            calling sequence as other cm_get_element entries.
 14    54*06/12/84 by Matthew Pierret:  Changed cm_put_element to cm_modify
 14    55*            and cm_allocate_element to cm_put.
 14    56*            Switched the element_length/element_ptr parameter pair to be
 14    57*            element_ptr/element_length in cm_modify and cm_put.
 14    58*07/24/84 by Matthew Pierret:  Added cm_free_ci$raw_return_prev_next.
 14    59*09/24/84 by Matthew Pierret:  Added trace_thread_modifications_(on off)
 14    60*            entries to cm_free_ci and cm_replace_buffered_ci, 
 14    61*            cm_allocate_ci$info_header, cm_opening_info$opening_table_ptr.
 14    62*            Removed cm_find_free_space. Commented out un-used entries.
 14    63*            Re-named allocate  entries to put entries, except for allocate_ci.
 14    64*            Re-named free element and free datum entries to use delete instead
 14    65*            of free, and cm_recursive_put to cm_recursive_modify.
 14    66*            Removed cm_get_element$bypass_info.
 14    67*02/27/85 by Matthew C. Pierret:  Re-added cm_compact$buffered_replacement now
 14    68*            that cm_modify$buffered uses it.
 14    69*03/07/85 by R. Michael Tague:  Added cm_postcommit_increment.
 14    70**/
 14    71 
 14    72 /* format: style2,ind3 */
 14    73 
 14    74 
 14    75      dcl	   cm_allocate_ci	      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
 14    76      dcl	   cm_allocate_ci$info    entry (ptr, fixed bin (24) unsigned, fixed bin (35));
 14    77      dcl	   cm_allocate_ci$info_header
 14    78 			      entry (ptr, fixed bin (24) unsigned, ptr, fixed bin (35));
 14    79 
 14    80 
 14    81      dcl	   cm_compact	      entry (bit (36) aligned, fixed bin (17), bit (36) aligned, ptr, fixed bin (35));
 14    82      dcl	   cm_compact$buffered    entry (ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
 14    83      dcl	   cm_compact$replacement entry (bit (36) aligned, fixed bin (17), bit (36) aligned, ptr, fixed bin (35));
 14    84      dcl	   cm_compact$buffered_replacement
 14    85 			      entry (ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
 14    86 
 14    87      dcl	   cm_delete_cn_datum     entry (ptr, bit (1) aligned, bit (36) aligned, fixed bin (35));
 14    88 
 14    89      dcl	   cm_delete_cn_datum$header
 14    90 			      entry (ptr, ptr, ptr, bit (1) aligned, bit (36) aligned, fixed bin (35));
 14    91 
 14    92      dcl	   cm_delete	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
 14    93 			      fixed bin (35));
 14    94      dcl	   cm_delete$info	      entry (ptr, bit (36) aligned, bit (1) aligned, fixed bin (35));
 14    95 
 14    96      dcl	   cm_determine_free_space$all
 14    97 			      entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35));
 14    98      dcl	   cm_determine_free_space$effective
 14    99 			      entry (ptr, fixed bin (35), bit (1) aligned, bit (1) aligned, fixed bin (35),
 14   100 			      fixed bin (35));
 14   101      dcl	   cm_determine_free_space$does_new_datum_fit
 14   102 			      entry (ptr, fixed bin (35), fixed bin (35), bit (1) aligned, bit (1) aligned,
 14   103 			      bit (1) aligned, bit (1) aligned, fixed bin (35));
 14   104 
 14   105 /**** Not yet used *********************************************************
 14   106*     dcl	   cm_determine_free_space$does_replacement_fit
 14   107*			      entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35), bit (1) aligned,
 14   108*			      bit (1) aligned, bit (1) aligned, bit (1) aligned, fixed bin (35)); 
 14   109*************************************************************************** */
 14   110 
 14   111      dcl	   cm_find_ci_to_alloc_datum
 14   112 			      entry (ptr, fixed bin (35), fixed bin (24) uns, bit (1) aligned, bit (1) aligned, ptr,
 14   113 			      fixed bin (24) uns, fixed bin (35));
 14   114 
 14   115      dcl	   cm_find_free_slot      entry (bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (17), fixed bin (17),
 14   116 			      bit (1) aligned, fixed bin (35));
 14   117 
 14   118      dcl	   cm_free_ci$info	      entry (ptr, fixed bin (24) uns, bit (1) aligned, fixed bin (35));
 14   119      dcl	   cm_free_ci$raw_return_prev_next
 14   120 			      entry (ptr, fixed bin (24) uns, bit (1) aligned, fixed bin (24) uns,
 14   121 			      fixed bin (24) uns, fixed bin (35));
 14   122      dcl	   cm_free_ci$trace_thread_modifications_on
 14   123 			      entry ();
 14   124      dcl	   cm_free_ci$trace_thread_modifications_off
 14   125 			      entry ();
 14   126 
 14   127 
 14   128      dcl	   cm_free_opening_info   entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
 14   129 
 14   130      dcl	   cm_get_bci_header      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
 14   131      dcl	   cm_get_bci_header$exclusive
 14   132 			      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
 14   133      dcl	   cm_get_bci_header$slot entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
 14   134 
 14   135 /**** Not yet used ********************************************************
 14   136*     dcl	   cm_get_bci_header$slot_exclusive
 14   137*			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
 14   138*************************************************************************** */
 14   139 
 14   140      dcl	   cm_get_element	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
 14   141 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
 14   142      dcl	   cm_get_element$exclusive
 14   143 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
 14   144 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
 14   145 
 14   146      dcl	   cm_get_element_portion entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
 14   147 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
 14   148 			      fixed bin (35), fixed bin (35));
 14   149 
 14   150 /**** Not yet used ********************************************************
 14   151*     dcl	   cm_get_element_portion$exclusive
 14   152*			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
 14   153*			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
 14   154*			      fixed bin (35), fixed bin (35));
 14   155*************************************************************************** */
 14   156 
 14   157      dcl	   cm_get_id$id	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin,
 14   158 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
 14   159      dcl	   cm_get_id$ptr	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin,
 14   160 			      bit (1) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
 14   161 
 14   162      dcl	   cm_modify	      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
 14   163 			      fixed bin (35), fixed bin (35));
 14   164      dcl	   cm_modify$buffered     entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
 14   165 			      fixed bin (35), fixed bin (35));
 14   166 
 14   167 /******* Not yet used *****************************************************
 14   168*     dcl	   cm_modify$buffered_info
 14   169*			      entry (ptr, ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35),
 14   170*			      fixed bin (35));
 14   171*****************************************************************************/
 14   172 
 14   173      dcl	   cm_modify$info	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
 14   174      dcl	   cm_modify$unprotected_info
 14   175 			      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
 14   176 
 14   177 
 14   178 /******* Not yet used *****************************************************
 14   179*     dcl	   cm_modify_portion entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35),
 14   180*			      fixed bin (35), ptr, bit (36) aligned, fixed bin (35), fixed bin (35));
 14   181*****************************************************************************/
 14   182 
 14   183 
 14   184      dcl	   cm_opening_info$get    entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
 14   185      dcl	   cm_opening_info$get_storage_record
 14   186 			      entry (ptr, fixed bin (35));
 14   187      dcl	   cm_opening_info$full_get
 14   188 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
 14   189      dcl	   cm_opening_info$opening_table_ptr
 14   190 			      entry () returns (ptr);
 14   191 
 14   192      dcl	   cm_postcommit_increment
 14   193 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
 14   194 
 14   195      dcl	   cm_put		      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
 14   196 			      fixed bin (35), fixed bin (35));
 14   197      dcl	   cm_put$buffered	      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
 14   198 			      fixed bin (35), fixed bin (35));
 14   199 
 14   200 /******* Not yet used *****************************************************
 14   201*     dcl	   cm_put$buffered_info
 14   202*			      entry (ptr, ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35),
 14   203*			      fixed bin (35));
 14   204*****************************************************************************/
 14   205 
 14   206      dcl	   cm_put$info	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
 14   207 
 14   208      dcl	   cm_put_basic_element   entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
 14   209 			      fixed bin (35));
 14   210 
 14   211      dcl	   cm_put_cn_datum	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, bit (36) aligned, fixed bin (35));
 14   212 
 14   213      dcl	   cm_put_datum_in_place  entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
 14   214 			      fixed bin (35));
 14   215      dcl	   cm_put_datum_in_place$buffered
 14   216 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
 14   217      dcl	   cm_put_datum_in_place$buffered_continued
 14   218 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (36) aligned,
 14   219 			      fixed bin (35));
 14   220      dcl	   cm_put_datum_in_place$continued
 14   221 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
 14   222 			      fixed bin (35), bit (36) aligned, fixed bin (35));
 14   223 
 14   224      dcl	   cm_put_datum_in_pool   entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
 14   225 			      fixed bin (35));
 14   226      dcl	   cm_put_datum_in_pool$buffered
 14   227 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
 14   228      dcl	   cm_put_datum_in_pool$buffered_continued
 14   229 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (36) aligned,
 14   230 			      fixed bin (35));
 14   231      dcl	   cm_put_datum_in_pool$continued
 14   232 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
 14   233 			      fixed bin (35), bit (36) aligned, fixed bin (35));
 14   234 
 14   235      dcl	   cm_put_ordered_element entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
 14   236 			      fixed bin (35));
 14   237      dcl	   cm_put_ordered_element$buffered
 14   238 			      entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
 14   239 			      fixed bin (35));
 14   240 
 14   241      dcl	   cm_put_overlength_tail entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35));
 14   242 
 14   243      dcl	   cm_recursive_modify    entry (ptr, bit (36) aligned, ptr, fixed bin (35), fixed bin (35), bit (36) aligned,
 14   244 			      fixed bin (35));
 14   245 
 14   246 
 14   247      dcl	   cm_replace_buffered_ci$trace_thread_modifications_on
 14   248 			      entry ();
 14   249      dcl	   cm_replace_buffered_ci$trace_thread_modifications_off
 14   250 			      entry ();
 14   251 
 14   252 /* END INCLUDE FILE dm_cm_entry_dcls.incl.pl1 */
      805 
      806 
 15     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
 15     2 /* format: style3 */
 15     3 
 15     4 /* These constants are to be used for the flags argument of sub_err_ */
 15     5 /* They are just "string (condition_info_header.action_flags)" */
 15     6 
 15     7 declare	(
 15     8 	ACTION_CAN_RESTART	init (""b),
 15     9 	ACTION_CANT_RESTART init ("1"b),
 15    10 	ACTION_DEFAULT_RESTART
 15    11 			init ("01"b),
 15    12 	ACTION_QUIET_RESTART
 15    13 			init ("001"b),
 15    14 	ACTION_SUPPORT_SIGNAL
 15    15 			init ("0001"b)
 15    16 	)		bit (36) aligned internal static options (constant);
 15    17 
 15    18 /* End include file */
      807 
      808    end cm_allocate_ci;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/02/87  1300.0  cm_allocate_ci.pl1                >spec>install>MR12.1-1020>cm_allocate_ci.pl1
779          1    01/07/85  0858.8  dm_hdr_collection_id.incl.pl1     >ldd>include>dm_hdr_collection_id.incl.pl1
781          2    01/07/85  0858.4  dm_cm_hdr_col_ids.incl.pl1        >ldd>include>dm_cm_hdr_col_ids.incl.pl1
783          3    01/07/85  0858.4  dm_cm_info.incl.pl1               >ldd>include>dm_cm_info.incl.pl1
785          4    01/07/85  0858.3  dm_cm_file_header.incl.pl1        >ldd>include>dm_cm_file_header.incl.pl1
787          5    01/07/85  0858.2  dm_cm_collection_header.incl.pl1  >ldd>include>dm_cm_collection_header.incl.pl1
789          6    01/07/85  0858.4  dm_cm_storage_record.incl.pl1     >ldd>include>dm_cm_storage_record.incl.pl1
791          7    01/07/85  0858.4  dm_cm_reservation_map.incl.pl1    >ldd>include>dm_cm_reservation_map.incl.pl1
793          8    01/07/85  0858.0  dm_cm_basic_ci.incl.pl1           >ldd>include>dm_cm_basic_ci.incl.pl1
795          9    01/07/85  0858.0  dm_cism_info.incl.pl1             >ldd>include>dm_cism_info.incl.pl1
797         10    01/07/85  0900.5  dm_ci_header.incl.pl1             >ldd>include>dm_ci_header.incl.pl1
799         11    01/07/85  0900.8  dm_ci_parts.incl.pl1              >ldd>include>dm_ci_parts.incl.pl1
801         12    01/07/85  0900.7  dm_ci_lengths.incl.pl1            >ldd>include>dm_ci_lengths.incl.pl1
803         13    01/07/85  0858.5  dm_element_id.incl.pl1            >ldd>include>dm_element_id.incl.pl1
805         14    04/05/85  0924.3  dm_cm_entry_dcls.incl.pl1         >ldd>include>dm_cm_entry_dcls.incl.pl1
807         15    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000035 constant        bit(36)                  initial dcl 15-7 set ref 261* 672* 690* 697* 703*
                                                                                  721* 727* 733* 754* 761* 767*
BASIC_CI_LAYOUT_1               000000 constant        char(4)                  initial dcl 8-97 ref 315 542
BITS_PER_WORD                          constant        fixed bin(17,0)          initial dcl 169 ref 329
BYTES_PER_WORD                         constant        fixed bin(17,0)          initial dcl 167 ref 258
CM_FILE_HEADER_ELEMENT_ID       000055 constant        bit(36)                  initial dcl 2-21 set ref 295* 299* 565*
CM_FILE_HEADER_VERSION_1        000004 constant        char(8)                  initial dcl 4-70 set ref 304*
CM_INFO_VERSION_2               000006 constant        char(8)                  initial dcl 3-48 set ref 235*
COLLECTION_HEADER_VERSION_2     000002 constant        char(8)                  initial dcl 5-86 set ref 238*
CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES
                                       constant        fixed bin(17,0)          initial dcl 12-22 ref 317 544
HEADER_COLLECTION_ID            000056 constant        bit(36)                  initial dcl 1-19 set ref 281 295* 343* 371* 420* 435
                                                                                  443* 451* 459 495* 543 556* 565* 572* 584 589*
                                                                                  596* 602
UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
                                000055 constant        fixed bin(17,0)          initial dcl 9-40 set ref 261 261*
addr                                                   builtin function         dcl 160 ref 211 221 255 285 285 295 295 343 343 371
                                                                                  371 472 521 523 547 548 613 690 690 697 697 703
                                                                                  703 721 721 727 727 733 733 754 754 761 761 767
                                                                                  767
allocated                       000150 automatic       bit(1)                   dcl 154 set ref 352* 355 482*
allocation_map_element_id
                          5            based           bit(36)                  level 2 dcl 4-55 set ref 343* 347* 495* 572*
automatic_bci_header            000100 automatic       structure                level 1 dcl 136 set ref 211 221
automatic_ci_parts_buffer       000112 automatic       fixed bin(71,0)          array dcl 138 set ref 254* 255
automatic_cm_file_header        000126 automatic       structure                level 1 dcl 140 set ref 295 295 295 295 299 299
bci_header                             based           structure                level 1 dcl 8-63 set ref 258 314*
bci_header_ptr                  000174 automatic       pointer                  dcl 8-94 set ref 211* 221* 230* 258 314 315 316 317
                                                                                  319 409 532 625
blocked_storage_record_ptr      000162 automatic       pointer                  initial dcl 6-48 set ref 243* 6-48*
ci_header                              based           structure                level 1 dcl 10-32
ci_id                                  based           structure                level 1 dcl 10-64
ci_parts                               based           structure                level 1 dcl 11-27
ci_parts_ptr                    000176 automatic       pointer                  initial dcl 11-35 set ref 255* 256 257 258 11-35*
                                                                                  409 411* 472 475* 532 534* 547 548* 613 615*
ci_stamp                               based           structure                level 1 dcl 10-48
cip_number_of_parts             000200 automatic       fixed bin(17,0)          initial dcl 11-36 set ref 11-36*
cm_file_header                         based           structure                level 1 dcl 4-55
cm_file_header_ptr              000154 automatic       pointer                  dcl 4-69 set ref 295* 304 323 325 343 347 495 512
                                                                                  565* 572
cm_free_ci$trace_thread_modifications_off
                                000042 constant        entry                    external dcl 14-124 ref 649
cm_free_ci$trace_thread_modifications_on
                                000040 constant        entry                    external dcl 14-122 ref 641
cm_get_bci_header               000044 constant        entry                    external dcl 14-130 ref 285
cm_get_element                  000046 constant        entry                    external dcl 14-140 ref 295 343 371
cm_info                                based           structure                level 1 dcl 3-37
cm_info_ptr                     000152 automatic       pointer                  initial dcl 3-47 set ref 207* 220* 229* 235 237 244
                                                                                  247* 271 281 285 295 316 3-47* 343 371 411 420 435
                                                                                  443 443 451 451 454 459 475 495 534 548 556 565
                                                                                  572 584 589 589 596 596 596 598 602 615
cm_modify                       000050 constant        entry                    external dcl 14-162 ref 420 443 451 495 565 572 589
                                                                                  596
cm_opening_info$full_get        000054 constant        entry                    external dcl 14-187 ref 207
cm_opening_info$get_storage_record
                                000052 constant        entry                    external dcl 14-185 ref 247
cm_put                          000056 constant        entry                    external dcl 14-195 ref 556
cm_replace_buffered_ci$trace_thread_modifications_off
                                000062 constant        entry                    external dcl 14-249 ref 650
cm_replace_buffered_ci$trace_thread_modifications_on
                                000060 constant        entry                    external dcl 14-247 ref 642
code                            000136 automatic       fixed bin(35,0)          dcl 143 set ref 206* 207* 209 209* 219* 228* 247*
                                                                                  248 248* 285* 288 288* 295* 299 299* 343* 347 347*
                                                                                  371* 375 375* 411* 413 413* 420* 424 424* 443* 447
                                                                                  447* 451* 454 454* 475* 478 478* 534* 536 536*
                                                                                  548* 551 551* 556* 560 560* 565* 567 567* 572* 576
                                                                                  576* 589* 592 592* 596* 598 598* 615* 617 617*
collection_header                      based           structure                level 1 dcl 5-65
collection_header_ptr           000156 automatic       pointer                  dcl 5-85 set ref 237* 238 261 261 443 447 451* 589
                                                                                  592
collection_id             4            based           bit(36)                  initial level 2 in structure "cm_info" dcl 3-37
                                                                                  in procedure "cm_allocate_ci" set ref 281 316 435
                                                                                  451* 454* 459 584 596* 598* 602
collection_id             1            based           bit(36)                  level 2 in structure "bci_header" dcl 8-63
                                                                                  in procedure "cm_allocate_ci" set ref 316*
collection_id             1     000105 automatic       bit(36)                  level 2 in structure "fragment_bci_header" dcl 137
                                                                                  in procedure "cm_allocate_ci" set ref 543*
control_interval_id                    based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 13-32 set ref
                                                                                  521* 548 690* 697* 703* 721* 727* 733* 754* 761*
                                                                                  767*
control_interval_number         000137 automatic       fixed bin(27,0)          dcl 144 set ref 398* 411* 435 440 470 514* 518 521
                                                                                  527* 527 534* 581 584 611 625* 631
control_interval_storage_method
                          2(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 5-65 set ref 261 261*
cv_p_correct_version                   parameter       char(8)                  dcl 670 set ref 665 672 672*
cv_p_given_version                     parameter       char(8)                  dcl 669 set ref 665 672 672*
cv_p_structure_name                    parameter       char                     unaligned dcl 668 set ref 665 672*
datum_slot                             based           structure                level 1 dcl 8-82
divide                                                 builtin function         dcl 160 ref 329
dm_error_$ci_not_allocated      000024 external static fixed bin(35,0)          dcl 191 ref 703 733 767
dm_error_$ci_not_in_collection  000032 external static fixed bin(35,0)          dcl 191 ref 703 733 767
dm_error_$long_element          000020 external static fixed bin(35,0)          dcl 191 ref 721
dm_error_$long_return_element   000022 external static fixed bin(35,0)          dcl 191 ref 690 754
dm_error_$misformatted_ci       000030 external static fixed bin(35,0)          dcl 191 ref 703 733 767
dm_error_$no_element            000026 external static fixed bin(35,0)          dcl 191 ref 697 727 761
dm_error_$unimplemented_cism    000034 external static fixed bin(35,0)          dcl 191 set ref 261*
element_id                             based           structure                level 1 dcl 13-32 in procedure "cm_allocate_ci"
element_id                1            based           bit(36)                  array level 2 in structure "file_reservation_map"
                                                                                  dcl 7-34 in procedure "cm_allocate_ci" set ref
                                                                                  371* 375* 420* 424* 521 523 548 556*
er_p_code                              parameter       fixed bin(35,0)          dcl 657 ref 654 659
error_table_$unimplemented_version
                                000036 external static fixed bin(35,0)          dcl 191 set ref 672*
file_manager_$put               000014 constant        entry                    external dcl 180 ref 411 475 534 548 615
file_oid                  3            based           bit(36)                  initial level 2 dcl 3-37 set ref 285* 295* 343* 371*
                                                                                  411* 420* 443* 451* 475* 495* 534* 548* 556* 565*
                                                                                  572* 589* 596* 615*
file_reservation_map                   based           structure                array level 1 dcl 7-34 set ref 572 572
file_reservation_map_fragment          based           bit                      dcl 7-44 set ref 382 402* 525* 526*
file_reservation_map_fragment_ptr
                                000170 automatic       pointer                  dcl 7-55 set ref 371* 382 402 420* 525 526 556*
file_reservation_map_ptr        000164 automatic       pointer                  dcl 7-50 set ref 343* 358 371 375 390 398 420 424
                                                                                  495* 514 518 520 521 523 548 556 572* 572 572
first_control_interval                 based           fixed bin(24,0)          level 2 unsigned dcl 6-28 set ref 435 435* 584 584*
flags                                  based           structure                array level 2 packed unaligned dcl 7-34 set ref 520*
fmer_p_code                            parameter       fixed bin(35,0)          dcl 749 set ref 745 754 754* 761 761* 767 767 767
                                                                                  767* 775*
fmer_p_element_id                      parameter       bit(36)                  dcl 751 set ref 745 754 754 761 761 767 767
fmer_p_expected_length                 parameter       fixed bin(35,0)          dcl 752 set ref 745 754*
fmer_p_fragment_number                 parameter       fixed bin(17,0)          dcl 750 set ref 745 754* 761* 767*
fragment_bci_header             000105 automatic       structure                level 1 dcl 137 set ref 541* 547
fragment_buffer                 000100 automatic       fixed bin(71,0)          array dcl 329 set ref 371 371 371 371 375 375
free_control_interval_idx       000140 automatic       fixed bin(17,0)          dcl 146 set ref 382* 385 398 402
frm_number_of_fragments         000166 automatic       fixed bin(17,0)          dcl 7-52 set ref 325* 334 355 511* 511 512 513 572
                                                                                  572
frmf_number_of_control_intervals
                                000172 automatic       fixed bin(17,0)          dcl 7-57 set ref 323* 329 382 402 514 525 526 556
ger_p_code                             parameter       fixed bin(35,0)          dcl 685 set ref 681 690 690* 697 697* 703 703 703
                                                                                  703* 710*
ger_p_element_id                       parameter       bit(36)                  dcl 687 set ref 681 690 690 697 697 703 703
ger_p_element_name                     parameter       char                     unaligned dcl 686 set ref 681 690* 697* 703*
ger_p_expected_length                  parameter       fixed bin(35,0)          dcl 688 set ref 681 690*
header_ptr                6            based           pointer                  initial level 2 dcl 3-37 set ref 237 596*
index                                                  builtin function         dcl 160 in procedure "cm_allocate_ci" ref 382
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "element_id" packed unsigned
                                                                                  unaligned dcl 13-32 in procedure "cm_allocate_ci"
                                                                                  set ref 523* 690* 697* 703* 721* 727* 733* 754*
                                                                                  761* 767*
ioa_                            000016 constant        entry                    external dcl 182 ref 625
last_control_interval
                          1            based           fixed bin(24,0)          level 2 unsigned dcl 6-28 set ref 278 319 440* 581*
layout_type                     000105 automatic       char(4)                  level 2 in structure "fragment_bci_header" dcl 137
                                                                                  in procedure "cm_allocate_ci" set ref 542*
layout_type                            based           char(4)                  level 2 in structure "bci_header" dcl 8-63
                                                                                  in procedure "cm_allocate_ci" set ref 315*
length                                                 builtin function         dcl 160 ref 295 295 299 299 343 343 347 347 371 371
                                                                                  375 375 572 572
length_in_bytes           3            based           fixed bin(17,0)          array level 3 dcl 11-27 set ref 258*
local_ptr                 4            based           pointer                  array level 3 dcl 11-27 set ref 409* 472* 532* 547*
                                                                                  613*
lowest_numbered_control_interval
                          0(12)        based           fixed bin(24,0)          array level 2 packed unsigned unaligned dcl 7-34 set
                                                                                  ref 398 514 518*
map_buffer                      000100 automatic       fixed bin(71,0)          array dcl 334 set ref 343 343 343 343 347 347
map_idx                         000135 automatic       fixed bin(17,0)          dcl 142 set ref 355* 358 371 375* 375 390 398 420
                                                                                  424* 513* 514 518 520 521 523 548 556
mer_p_code                             parameter       fixed bin(35,0)          dcl 717 set ref 714 721 721* 727 727* 733 733 733
                                                                                  733* 740*
mer_p_element_id                       parameter       bit(36)                  dcl 719 set ref 714 721 721 727 727 733 733
mer_p_element_name                     parameter       char                     unaligned dcl 718 set ref 714 721* 727* 733*
myname                          000010 constant        varying char(32)         initial dcl 165 set ref 261* 672* 690* 697* 703*
                                                                                  721* 727* 733* 754* 761* 767*
next_control_interval
                          2     000142 automatic       fixed bin(24,0)          level 2 packed unsigned unaligned dcl 150 set ref
                                                                                  470* 611* 625*
no_control_intervals_are_available     based           bit(1)                   array level 3 packed unaligned dcl 7-34 set ref 358
                                                                                  390*
null                                                   builtin function         dcl 160 ref 243 244 261 261 295 295 3-47 6-46 6-48
                                                                                  11-35 343 343 371 371 672 672 690 690 697 697 703
                                                                                  703 721 721 727 727 733 733 754 754 761 761 767
                                                                                  767
number_of_blocks          3(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 4-55 set ref 325 512*
number_of_control_intervals_per_block
                          4            based           fixed bin(17,0)          level 2 dcl 4-55 ref 323
number_of_fragments_with_vacancies
                                000141 automatic       fixed bin(17,0)          dcl 148 set ref 353* 363* 363 388* 388 491
number_of_parts                        based           fixed bin(17,0)          level 2 dcl 11-27 set ref 256*
offset_in_bytes           2            based           fixed bin(17,0)          array level 3 dcl 11-27 set ref 257*
p_bci_header_ptr                       parameter       pointer                  dcl 130 ref 225 230
p_cm_info_ptr                          parameter       pointer                  dcl 131 ref 216 220 225 229
p_code                                 parameter       fixed bin(35,0)          dcl 132 set ref 118 206* 216 219* 225 228* 659*
p_collection_id                        parameter       bit(36)                  dcl 127 set ref 118 207*
p_control_interval_number              parameter       fixed bin(24,0)          unsigned dcl 128 set ref 118 216 225 241* 631*
p_file_opening_id                      parameter       bit(36)                  dcl 126 set ref 118 207*
part                      2            based           structure                array level 2 dcl 11-27
previous_bci_header             000142 automatic       structure                level 1 dcl 150 set ref 285 285 472 613
previous_control_interval
                          2(24)        based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 8-63 set ref
                                                                                  319* 625*
previous_control_interval_number
                                000147 automatic       fixed bin(27,0)          dcl 151 set ref 278* 281 285 459 475* 602 615*
replace_map                     000151 automatic       bit(1)                   dcl 155 set ref 352* 392* 495
size                                                   builtin function         dcl 160 ref 258
stamp                                  based           structure                level 2 dcl 10-32
start_of_used_space       4            based           fixed bin(17,0)          level 2 in structure "bci_header" packed unaligned
                                                                                  dcl 8-63 in procedure "cm_allocate_ci" set ref
                                                                                  317*
start_of_used_space       4     000105 automatic       fixed bin(17,0)          level 2 in structure "fragment_bci_header" packed
                                                                                  unaligned dcl 137 in procedure "cm_allocate_ci"
                                                                                  set ref 544*
static_trace_thread_switch      000010 internal static bit(1)                   initial dcl 186 set ref 625 640* 648*
storage_record_element_id
                          6            based           bit(36)                  level 2 dcl 5-65 set ref 443* 447* 589* 592*
storage_record_ptr       10            based           pointer                  initial level 2 dcl 3-37 set ref 244 271 443* 589*
string                                                 builtin function         dcl 160 set ref 520*
sub_err_                        000012 constant        entry                    external dcl 179 ref 261 672 690 697 703 721 727 733
                                                                                  754 761 767
substr                                                 builtin function         dcl 160 set ref 402* 526*
unblocked_storage_record               based           structure                level 1 dcl 6-28
unblocked_storage_record_ptr    000160 automatic       pointer                  initial dcl 6-46 set ref 243* 271* 278 319 6-46* 435
                                                                                  435 440 581 584 584
unspec                                                 builtin function         dcl 160 set ref 295 295 299 299 314* 343 343 347 347
                                                                                  371 371 375 375 541* 572 572
version                                based           char(8)                  level 2 in structure "collection_header" dcl 5-65
                                                                                  in procedure "cm_allocate_ci" set ref 238*
version                                based           char(8)                  level 2 in structure "cm_file_header" dcl 4-55
                                                                                  in procedure "cm_allocate_ci" set ref 304*
version                                based           char(8)                  level 2 in structure "cm_info" dcl 3-37 in procedure
                                                                                  "cm_allocate_ci" set ref 235*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 15-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 15-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 15-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 15-7
ATTEMPTING_TO_GET                      internal static bit(1)                   initial dcl 171
ATTEMPTING_TO_PUT                      internal static bit(1)                   initial dcl 171
BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
                                       internal static fixed bin(17,0)          initial dcl 9-38
CALLER_HEADER_ELEMENT_ID               internal static bit(36)                  initial dcl 2-21
CISM_INFO_VERSION_1                    internal static char(8)                  initial dcl 9-37
CI_0_ADDRESSABLE_LENGTH                internal static fixed bin(17,0)          initial dcl 12-31
CI_ADDRESSABLE_LENGTH                  internal static fixed bin(17,0)          initial dcl 12-29
CI_HEADER_STAMP_VERSION_1              internal static bit(9)                   initial dcl 10-53
CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES
                                       internal static fixed bin(17,0)          initial dcl 12-25
HEADER_COLLECTION_HEADER_ELEMENT_ID    internal static bit(36)                  initial dcl 2-21
basic_control_interval                 based           structure                level 1 dcl 8-56
basic_control_interval_ptr             automatic       pointer                  dcl 8-92
blocked_cism_info                      based           structure                level 1 dcl 9-22
blocked_cism_info_ptr                  automatic       pointer                  dcl 9-33
blocked_storage_record                 based           structure                level 1 dcl 6-36
ci_header_chunks                       based           structure                level 1 dcl 10-80
ci_header_ptr                          automatic       pointer                  dcl 10-31
ci_size_code                           based           structure                level 1 dcl 10-73
ci_trailer                             based           structure                level 1 dcl 10-40
ci_trailer_chunk                       based           structure                level 1 dcl 10-87
ci_trailer_ptr                         automatic       pointer                  dcl 10-39
cit_number_of_collections              automatic       fixed bin(17,0)          dcl 4-81
cm_allocate_ci                  000000 constant        entry                    external dcl 14-75
cm_allocate_ci$info             000000 constant        entry                    external dcl 14-76
cm_allocate_ci$info_header      000000 constant        entry                    external dcl 14-77
cm_compact                      000000 constant        entry                    external dcl 14-81
cm_compact$buffered             000000 constant        entry                    external dcl 14-82
cm_compact$buffered_replacement 000000 constant        entry                    external dcl 14-84
cm_compact$replacement          000000 constant        entry                    external dcl 14-83
cm_delete                       000000 constant        entry                    external dcl 14-92
cm_delete$info                  000000 constant        entry                    external dcl 14-94
cm_delete_cn_datum              000000 constant        entry                    external dcl 14-87
cm_delete_cn_datum$header       000000 constant        entry                    external dcl 14-89
cm_determine_free_space$all     000000 constant        entry                    external dcl 14-96
cm_determine_free_space$does_new_datum_fit
                                000000 constant        entry                    external dcl 14-101
cm_determine_free_space$effective
                                000000 constant        entry                    external dcl 14-98
cm_find_ci_to_alloc_datum       000000 constant        entry                    external dcl 14-111
cm_find_free_slot               000000 constant        entry                    external dcl 14-115
cm_free_ci$info                 000000 constant        entry                    external dcl 14-118
cm_free_ci$raw_return_prev_next 000000 constant        entry                    external dcl 14-119
cm_free_opening_info            000000 constant        entry                    external dcl 14-128
cm_get_bci_header$exclusive     000000 constant        entry                    external dcl 14-131
cm_get_bci_header$slot          000000 constant        entry                    external dcl 14-133
cm_get_element$exclusive        000000 constant        entry                    external dcl 14-142
cm_get_element_portion          000000 constant        entry                    external dcl 14-146
cm_get_id$id                    000000 constant        entry                    external dcl 14-157
cm_get_id$ptr                   000000 constant        entry                    external dcl 14-159
cm_modify$buffered              000000 constant        entry                    external dcl 14-164
cm_modify$info                  000000 constant        entry                    external dcl 14-173
cm_modify$unprotected_info      000000 constant        entry                    external dcl 14-174
cm_opening_info$get             000000 constant        entry                    external dcl 14-184
cm_opening_info$opening_table_ptr
                                000000 constant        entry                    external dcl 14-189
cm_postcommit_increment         000000 constant        entry                    external dcl 14-192
cm_put$buffered                 000000 constant        entry                    external dcl 14-197
cm_put$info                     000000 constant        entry                    external dcl 14-206
cm_put_basic_element            000000 constant        entry                    external dcl 14-208
cm_put_cn_datum                 000000 constant        entry                    external dcl 14-211
cm_put_datum_in_place           000000 constant        entry                    external dcl 14-213
cm_put_datum_in_place$buffered  000000 constant        entry                    external dcl 14-215
cm_put_datum_in_place$buffered_continued
                                000000 constant        entry                    external dcl 14-217
cm_put_datum_in_place$continued 000000 constant        entry                    external dcl 14-220
cm_put_datum_in_pool            000000 constant        entry                    external dcl 14-224
cm_put_datum_in_pool$buffered   000000 constant        entry                    external dcl 14-226
cm_put_datum_in_pool$buffered_continued
                                000000 constant        entry                    external dcl 14-228
cm_put_datum_in_pool$continued  000000 constant        entry                    external dcl 14-231
cm_put_ordered_element          000000 constant        entry                    external dcl 14-235
cm_put_ordered_element$buffered 000000 constant        entry                    external dcl 14-237
cm_put_overlength_tail          000000 constant        entry                    external dcl 14-241
cm_recursive_modify             000000 constant        entry                    external dcl 14-243
collection_id_table                    based           bit(36)                  array dcl 4-75
collection_id_table_ptr                automatic       pointer                  dcl 4-79
datum_slot_ptr                         automatic       pointer                  dcl 8-95
element_id_string                      automatic       bit(36)                  dcl 13-30
unblocked_cism_info                    based           structure                level 1 dcl 9-28
unblocked_cism_info_ptr                automatic       pointer                  dcl 9-34

NAMES DECLARED BY EXPLICIT CONTEXT.
BEGIN_BLOCK                     001215 constant        label                    dcl 327
CHECK_VERSION                   003045 constant        entry                    internal dcl 665 ref 235 238 304
ERROR_RETURN                    003031 constant        entry                    internal dcl 654 ref 209 248 288 413 478 536 551 560
                                                                                  567 576 617 710 740 775
EXTEND_MAP_AND_ALLOCATE_IN_NEW_FRAGMENT
                                002144 constant        label                    dcl 500
FILE_MAP_ERROR_RETURN           003723 constant        entry                    internal dcl 745 ref 375
GET_ERROR_RETURN                003152 constant        entry                    internal dcl 681 ref 299 347
JOIN                            000564 constant        label                    dcl 235 ref 213 223 232
MAIN_RETURN                     002760 constant        label                    dcl 633 ref 660
MODIFY_ERROR_RETURN             003437 constant        entry                    internal dcl 714 ref 424 447 454 592 598
TRY_EACH_ALLOCATION_FRAGMENT_LOOP
                                001355 constant        label                    dcl 355
TRY_THIS_ALLOCATION_FRAGMENT    001375 constant        label                    dcl 358
TRY_THIS_CI                     001517 constant        label                    dcl 394
UNBLOCKED                       000777 constant        label                    dcl 268
cm_allocate_ci                  000434 constant        entry                    external dcl 118
info                            000506 constant        entry                    external dcl 216
info_header                     000537 constant        entry                    external dcl 225
trace_thread_modifications_off  003006 constant        entry                    external dcl 645
trace_thread_modifications_on   002762 constant        entry                    external dcl 637

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4542        4626    4203        4552
Length      5402    4203        64         537     336           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cm_allocate_ci                      290 external procedure  is an external procedure.  
begin block on line 327             272 begin block         uses auto adjustable storage.  
ERROR_RETURN                         64 internal procedure  is called by several nonquick procedures.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure cm_allocate_ci.  
GET_ERROR_RETURN                    126 internal procedure  is called by several nonquick procedures.  
MODIFY_ERROR_RETURN                     internal procedure  shares stack frame of begin block on line 327.  
FILE_MAP_ERROR_RETURN                   internal procedure  shares stack frame of begin block on line 327.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 static_trace_thread_switch  cm_allocate_ci

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
begin block on line 327  000100 map_buffer                  begin block on line 327
                         000100 fragment_buffer             begin block on line 327
cm_allocate_ci           000100 automatic_bci_header        cm_allocate_ci
                         000105 fragment_bci_header         cm_allocate_ci
                         000112 automatic_ci_parts_buffer   cm_allocate_ci
                         000126 automatic_cm_file_header    cm_allocate_ci
                         000135 map_idx                     cm_allocate_ci
                         000136 code                        cm_allocate_ci
                         000137 control_interval_number     cm_allocate_ci
                         000140 free_control_interval_idx   cm_allocate_ci
                         000141 number_of_fragments_with_vacancies
                                                            cm_allocate_ci
                         000142 previous_bci_header         cm_allocate_ci
                         000147 previous_control_interval_number
                                                            cm_allocate_ci
                         000150 allocated                   cm_allocate_ci
                         000151 replace_map                 cm_allocate_ci
                         000152 cm_info_ptr                 cm_allocate_ci
                         000154 cm_file_header_ptr          cm_allocate_ci
                         000156 collection_header_ptr       cm_allocate_ci
                         000160 unblocked_storage_record_ptr
                                                            cm_allocate_ci
                         000162 blocked_storage_record_ptr  cm_allocate_ci
                         000164 file_reservation_map_ptr    cm_allocate_ci
                         000166 frm_number_of_fragments     cm_allocate_ci
                         000170 file_reservation_map_fragment_ptr
                                                            cm_allocate_ci
                         000172 frmf_number_of_control_intervals
                                                            cm_allocate_ci
                         000174 bci_header_ptr              cm_allocate_ci
                         000176 ci_parts_ptr                cm_allocate_ci
                         000200 cip_number_of_parts         cm_allocate_ci

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
enter_begin_block   leave_begin_block   call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this
call_int_other_desc call_int_other      return_mac          tra_ext_1           alloc_auto_adj      ext_entry
int_entry           int_entry_desc      index_bs_1_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cm_free_ci$trace_thread_modifications_off                   cm_free_ci$trace_thread_modifications_on
cm_get_bci_header             cm_get_element                cm_modify                     cm_opening_info$full_get
cm_opening_info$get_storage_record                          cm_put
cm_replace_buffered_ci$trace_thread_modifications_off       cm_replace_buffered_ci$trace_thread_modifications_on
file_manager_$put             ioa_                          sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$ci_not_allocated    dm_error_$ci_not_in_collection                              dm_error_$long_element
dm_error_$long_return_element dm_error_$misformatted_ci     dm_error_$no_element          dm_error_$unimplemented_cism
error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 3   47 000417    6   46 000421    6   48 000422   11   35 000423   11   36 000424       118 000427       206 000447
    207 000451       209 000467       211 000477       213 000501       216 000502       219 000521       220 000523
    221 000527       223 000531       225 000532       228 000552       229 000554       230 000560       232 000563
    235 000564       237 000605       238 000610       241 000635       243 000636       244 000641       247 000646
    248 000657       254 000667       255 000703       256 000705       257 000707       258 000710       261 000713
    271 000777       278 001002       281 001004       285 001011       288 001032       295 001042       299 001110
    304 001143       314 001166       315 001172       316 001174       317 001177       319 001201       323 001206
    325 001211       327 001215       329 001220       334 001233       343 001242       347 001314       352 001351
    353 001354       355 001355       358 001370       363 001375       371 001376       375 001451       382 001477
    385 001504       388 001505       390 001507       392 001514       393 001516       398 001517       402 001527
    409 001534       411 001537       413 001555       420 001567       424 001622       435 001656       440 001666
    443 001671       447 001721       451 001751       454 002001       459 002033       470 002042       472 002045
    475 002050       478 002066       482 002100       489 002103       491 002106       495 002110       499 002143
    511 002144       512 002145       513 002150       514 002151       518 002160       520 002167       521 002171
    523 002175       525 002200       526 002207       527 002211       532 002212       534 002215       536 002234
    541 002246       542 002252       543 002254       544 002256       547 002260       548 002263       551 002310
    556 002322       560 002355       565 002367       567 002417       572 002431       576 002464       581 002476
    584 002502       589 002512       592 002542       596 002572       598 002622       602 002654       611 002663
    613 002666       615 002671       617 002707       622 002721       625 002722       631 002756       633 002760
    637 002761       640 002770       641 002773       642 002777       643 003004       645 003005       648 003014
    649 003016       650 003022       651 003027       654 003030       659 003036       660 003042       665 003045
    672 003056       677 003147       679 003150       681 003151       690 003165       697 003255       703 003340
    710 003427       712 003436       714 003437       721 003450       727 003537       733 003623       740 003713
    742 003722       745 003723       754 003725       761 004016       767 004102       775 004172       777 004201


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
