	COMPILATION LISTING OF SEGMENT contents
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-05-05_1831.04_Fri_mdt
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 /* format: ^inddcls,^indattr,indnoniterend,^indnoniterdo,indend,tree,^case,insnl,comcol61,dclind5,declareind5,delnl */
       11 
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(86-01-03,Spitzer), approve(86-01-03,MCR7321),
       15*     audit(86-01-06,Blair), install(86-01-07,MR12.0-1005):
       16*     Add -from/-to and -match/-exclude control arguments.
       17*  2) change(86-12-01,GWMay), approve(86-12-01,MCR7575),
       18*     audit(86-12-04,Lippard), install(86-12-09,MR12.0-1238):
       19*     added -newline,-nl,-no_newline,-nnl and -requote_line, -rql control
       20*     arguments.
       21*                                                   END HISTORY COMMENTS */
       22 
       23 
       24 contents:
       25      proc () options (variable);
       26 
       27 /* active function to return contents of seg as big string. */
       28 /* rewritten to accept archive components pathnames 1/29/82 LAB */
       29 
       30 /* Argument processing */
       31 	call cu_$af_return_arg (arg_count, return_ptr, return_len, code);
       32 	if code = error_table_$not_act_fnc
       33 	then do;
       34 	     af_sw = "0"b;
       35 	     complain = com_err_;
       36 	     end;
       37 	else do;
       38 	     af_sw = "1"b;
       39 	     complain = active_fnc_err_;
       40 	     end;
       41 
       42 	path = "";
       43 
       44 	have_selection_args = "0"b;
       45 	loop = 1;
       46 	to_line, from_line = UNUSED;
       47 	Schange_NL_to_SP = "1"b;
       48 	Schange_NL_to_QUOTE = "0"b;
       49 
       50 	from_stringp, to_stringp, seg_ptr, match_listp, exclude_listp, system_free_area_ptr = null ();
       51 	on cleanup call cleaner;
       52 
       53 	do while (loop <= arg_count);
       54 	     call cu_$arg_ptr (loop, arg_ptr, arg_len, (0));
       55 	     if /* case */ index (arg, "-") = 1
       56 	     then if arg = "-newline" | arg = "-nl"
       57 		then do;
       58 		     Schange_NL_to_SP = "0"b;
       59 		     Schange_NL_to_QUOTE = "0"b;
       60 		     end;
       61 
       62 		else if arg = "-no_newline" | arg = "-nnl"
       63 		then do;
       64 		     Schange_NL_to_SP = "1"b;
       65 		     Schange_NL_to_QUOTE = "0"b;
       66 		     end;
       67 
       68 		else if arg = "-requote_line" | arg = "-rql"
       69 		then do;
       70 		     Schange_NL_to_SP = "0"b;
       71 		     Schange_NL_to_QUOTE = "1"b;
       72 		     end;
       73 
       74 		else if arg = "-fm" | arg = "-from"
       75 		then if from_line ^= UNUSED | from_stringp ^= null
       76 		     then do;
       77 inconsistent:
       78 			call complain (error_table_$inconsistent, myname, "Only one line range is allowed. ^a", arg);
       79 			goto return_to_caller;
       80 			end;
       81 		     else call get_next_arg ("-from", from_line, from_stringp, from_stringl, from_is_regexp);
       82 		else if arg = "-to"
       83 		then if to_line ^= UNUSED | to_stringp ^= null
       84 		     then goto inconsistent;
       85 		     else call get_next_arg ("-to", to_line, to_stringp, to_stringl, to_is_regexp);
       86 		else if arg = "-match"
       87 		then do;
       88 		     call get_char_arg ("-match", char_arg_ptr, char_arg_len);
       89 		     call add_to_match_exclude_list ("1"b, char_arg_ptr, char_arg_len);
       90 		     end;
       91 		else if arg = "-ex" | arg = "-exclude"
       92 		then do;
       93 		     call get_char_arg ("-exclude", char_arg_ptr, char_arg_len);
       94 		     call add_to_match_exclude_list ("0"b, char_arg_ptr, char_arg_len);
       95 		     end;
       96 		else do;
       97 		     call complain (error_table_$badopt, myname, "^a", arg);
       98 		     goto return_to_caller;
       99 		     end;
      100 	     else if path = ""
      101 	     then path = arg;
      102 	     else do;
      103 		call complain (0, myname, "Pathname already supplied. ^a", arg);
      104 		goto return_to_caller;
      105 		end;
      106 	     loop = loop + 1;
      107 	     end;					/* do while */
      108 
      109 	if path = ""
      110 	then do;
      111 	     if af_sw
      112 	     then call active_fnc_err_$suppress_name (0, myname, "Usage:  [contents path {-control_args}]");
      113 	     else call com_err_$suppress_name (0, myname, "Usage:  contents path {-control_args}");
      114 	     goto return_to_caller;
      115 	     end;
      116 
      117 /* convert to pathname and/or component name */
      118 
      119 	call cu_$arg_ptr (1, arg_ptr, arg_len, 0);
      120 	call expand_pathname_$component (path, dn, en, comp_nm, code);
      121 	if code ^= 0
      122 	then do;
      123 	     call complain (code, myname, "^a", path);
      124 	     return;
      125 	     end;
      126 
      127 /* initiate seg */
      128 
      129 	call initiate_file_$component (dn, en, comp_nm, R_ACCESS, seg_ptr, bit_count, code);
      130 	if seg_ptr = null
      131 	then do;
      132 	     call complain (code, myname, "^a", pathname_$component (dn, en, comp_nm));
      133 	     return;
      134 	     end;
      135 
      136 	seg_len = divide ((bit_count + 8), 9, 21, 0);
      137 	if Schange_NL_to_SP
      138 	then seg_len = length (rtrim (seg, NL));	/* strip trailing newlines */
      139 
      140 	if have_selection_args
      141 	then call process_selection;
      142 	else call return_entire_segment;
      143 
      144 return_to_caller:
      145 	call cleaner;
      146 	return;
      147 
      148 return_entire_segment:
      149      proc;
      150 
      151 	seg_next_line_ptr = seg_ptr;
      152 	seg_next_line_len = seg_len;
      153 	seg_pos = 0;
      154 	if Schange_NL_to_QUOTE | Schange_NL_to_SP
      155 	then do;
      156 	     do while (seg_pos < seg_len);
      157 		move_len = index (seg_next_line, NL) - length (NL);
      158 
      159 		if move_len < 0
      160 		then /* takes care of segs with no NL at the end */
      161 		     move_len = seg_len - seg_pos;
      162 
      163 		if Schange_NL_to_QUOTE
      164 		then call put_next_line (requote_string_ (substr (seg_next_line, 1, move_len)));
      165 		else /* Schange_NL_to_SP */
      166 		     call put_next_line (substr (seg_next_line, 1, move_len));
      167 
      168 		seg_pos = seg_pos + move_len + length (NL);
      169 		seg_next_line_ptr = addcharno (seg_ptr, seg_pos);
      170 		end;
      171 	     end;
      172 	else call put_next_line ((seg));
      173 
      174 	if ^af_sw
      175 	then call iox_$put_chars (iox_$user_output, addr (NL), 1, 0);
      176 
      177 	return;
      178      end return_entire_segment;
      179 
      180 process_selection:
      181      proc;
      182 
      183 dcl  found_a_match bit (1) aligned;
      184 dcl  found_start bit (1) aligned;
      185 dcl  line char (linel) based (linep);
      186 dcl  linecount fixed bin (21);
      187 dcl  linel fixed bin (21);
      188 dcl  linep ptr;
      189 dcl  nlpos fixed bin (21);
      190 dcl  printed_something bit (1) aligned;
      191 dcl  regexp_string char (regexp_stringl) based (regexp_stringp);
      192 dcl  regexp_stringl fixed bin (21);
      193 dcl  regexp_stringp ptr;
      194 dcl  rest_of_segment char (rest_of_segmentl) based (rest_of_segmentp);
      195 dcl  rest_of_segmentl fixed bin (21);
      196 dcl  rest_of_segmentp ptr;
      197 
      198 	linecount = 0;
      199 	printed_something = "0"b;
      200 	rest_of_segmentp = seg_ptr;
      201 	rest_of_segmentl = seg_len;
      202 
      203 	if (from_stringp = null) & (from_line = UNUSED)
      204 	then found_start = "1"b;			/* -from not specified, start from the beginning */
      205 	else found_start = "0"b;
      206 
      207 	if af_sw
      208 	then return_arg = "";
      209 
      210 	do while (rest_of_segmentl > 0);
      211 	     linep = rest_of_segmentp;
      212 	     nlpos = index (rest_of_segment, NL);
      213 	     if nlpos = 0
      214 	     then do;
      215 		linel = rest_of_segmentl;
      216 		nlpos = rest_of_segmentl + 1;
      217 		end;
      218 	     else if Schange_NL_to_SP | Schange_NL_to_QUOTE
      219 		then linel = nlpos - 1;
      220 		else linel = nlpos;
      221 
      222 	     linecount = linecount + 1;
      223 
      224 	     if linel = 0
      225 	     then goto skip_line;			/* blank line */
      226 
      227 /* Test to see if "-to NUMBER" or "-from NUMBER" was given. */
      228 	     if from_line ^= UNUSED
      229 	     then if linecount < from_line
      230 		then goto skip_line;		/* not to the starting place yet */
      231 	     if to_line ^= UNUSED
      232 	     then if linecount > to_line
      233 		then goto selection_done;		/* done with the entire segment */
      234 
      235 /* Test to see if "-from STRING" was given. STRING may be a regular expression. */
      236 	     if from_stringp ^= null
      237 	     then if ^found_start
      238 		then if from_is_regexp
      239 		     then if search (from_stringp, from_stringl, linep, linel)
      240 			then do;
      241 			     found_start = "1"b;
      242 			     goto test_match_excludes;
      243 			     end;
      244 			else goto skip_line;
      245 		     else goto skip_line;
      246 
      247 /* Test to see if "-to STRING" was given. STRING may be a regular expression. */
      248 	     if to_stringp ^= null
      249 	     then if to_is_regexp
      250 		then if search (to_stringp, to_stringl, linep, linel)
      251 		     then nlpos = rest_of_segmentl;	/* process this line, then stop */
      252 		     else ;			/* keep on truckin' */
      253 
      254 /* Look at match and exclude strings now. Do the match strings first */
      255 
      256 test_match_excludes:
      257 	     if match_listp ^= null
      258 	     then do;
      259 		found_a_match = "0"b;
      260 		do loop = 1 to match_list.count while (^found_a_match);
      261 		     if match_list.regexp (loop)
      262 		     then found_a_match =
      263 			     search (match_list.stringp (loop), match_list.stringlen (loop), linep, linel);
      264 		     else do;
      265 			regexp_stringp = match_list.stringp (loop);
      266 			regexp_stringl = match_list.stringlen (loop);
      267 			found_a_match = (index (line, regexp_string) ^= 0);
      268 			end;
      269 		     end;				/* do loop */
      270 		if ^found_a_match
      271 		then goto skip_line;		/* no match strings were found */
      272 		end;
      273 
      274 	     if exclude_listp ^= null
      275 	     then do;
      276 		found_a_match = "0"b;
      277 		do loop = 1 to exclude_list.count while (^found_a_match);
      278 		     if exclude_list.regexp (loop)
      279 		     then found_a_match =
      280 			     search (exclude_list.stringp (loop), exclude_list.stringlen (loop), linep, linel);
      281 		     else do;
      282 			regexp_stringp = exclude_list.stringp (loop);
      283 			regexp_stringl = exclude_list.stringlen (loop);
      284 			found_a_match = (index (line, regexp_string) ^= 0);
      285 			end;
      286 		     end;				/* do loop */
      287 		if found_a_match
      288 		then goto skip_line;		/* at least 1 exclude string matched */
      289 		end;
      290 
      291 	     if Schange_NL_to_QUOTE
      292 	     then call put_next_line (requote_string_ ((line)));
      293 	     else call put_next_line (line);
      294 
      295 	     printed_something = "1"b;
      296 
      297 skip_line:
      298 	     rest_of_segmentl = rest_of_segmentl - nlpos;
      299 	     rest_of_segmentp = addcharno (rest_of_segmentp, nlpos);
      300 	     end;					/* do while */
      301 
      302 selection_done:
      303 	if printed_something
      304 	then if ^af_sw
      305 	     then call iox_$put_chars (iox_$user_output, addr (NL), 1, (0));
      306 	     else ;				/* do nothing */
      307 	else if from_line ^= UNUSED & linecount > from_line
      308 	     then call complain (0, myname, "Line ^d not found.", from_line);
      309 	     else if from_stringp ^= null
      310 		then call complain (0, myname, "^[/^a/^;^a^] not matched.", from_is_regexp, from_string);
      311 		else call complain (0, myname, "No lines selected.");
      312 
      313 	return;
      314 
      315      end process_selection;
      316 
      317 
      318 put_next_line:
      319      proc (next_line);
      320 
      321 dcl  next_line char (*);
      322 
      323 /* If we get here, the line is eligible to be printed/returned */
      324 
      325 	if af_sw
      326 	then do;
      327 
      328 	     if length (return_arg) + length (next_line) + 1 > return_len
      329 	     then do;
      330 		call complain (0, myname, "Return string of ^d characters is too long.",
      331 		     length (return_arg) + length (next_line) + 1);
      332 		return;
      333 		end;
      334 
      335 	     else do;
      336 		if Schange_NL_to_SP | Schange_NL_to_QUOTE
      337 		then if return_arg ^= ""
      338 		     then return_arg = return_arg || SP;
      339 
      340 		return_arg = return_arg || next_line;
      341 		end;
      342 	     end;
      343 	else do;
      344 	     call iox_$put_chars (iox_$user_output, addr (next_line), length (next_line), (0));
      345 
      346 	     if Schange_NL_to_QUOTE | Schange_NL_to_SP
      347 	     then call iox_$put_chars (iox_$user_output, addr (SPACE), 1, (0));
      348 	     end;
      349 
      350 	return;
      351      end put_next_line;
      352 
      353 check_for_regexp:
      354      proc (l, p, regexp);
      355 
      356 dcl  l fixed bin (21) parameter;
      357 dcl  p ptr parameter;
      358 dcl  regexp bit (1) parameter;
      359 dcl  string char (l) based (p);
      360 
      361 	if l > 2
      362 	then if (substr (string, 1, 1) = "/") & (substr (string, l, 1) = "/")
      363 	     then do;
      364 		p = addcharno (p, 1);
      365 		l = l - 2;
      366 		regexp = "1"b;
      367 		end;
      368 	     else regexp = "0"b;
      369 	else regexp = "0"b;
      370 
      371 	return;
      372      end check_for_regexp;
      373 
      374 search:
      375      proc (regexpp, regexpl, stringp, stringl) returns (bit (1) aligned);
      376 
      377 dcl  error_table_$nomatch fixed bin (35) ext static;
      378 dcl  regexp char (regexpl) based (regexpp);
      379 dcl  regexpl fixed bin (21) parameter;
      380 dcl  regexpp ptr parameter;
      381 dcl  stringl fixed bin (21) parameter;
      382 dcl  stringp ptr parameter;
      383 
      384 	call search_file_$silent (regexpp, 1, regexpl, stringp, 1, stringl, (0), (0), code);
      385 	if code = 0
      386 	then return ("1"b);
      387 	else if code = error_table_$nomatch
      388 	     then ;				/* not found */
      389 	     else if code ^= 0
      390 		then do;
      391 		     if code = 2
      392 		     then call complain (0, myname, "Illegal regexp: /^a/", regexp);
      393 		     else call complain (code, myname, "Searching for /^a/", regexp);
      394 		     goto return_to_caller;
      395 		     end;
      396 
      397 	return ("0"b);
      398      end search;
      399 
      400 cleaner:
      401      proc;
      402 
      403 	if seg_ptr ^= null
      404 	then call terminate_file_ (seg_ptr, 0, TERM_FILE_TERM, 0);
      405 	if match_listp ^= null
      406 	then free match_list in (system_free_area);
      407 	if exclude_listp ^= null
      408 	then free exclude_list in (system_free_area);
      409 
      410 	return;
      411      end cleaner;
      412 
      413 get_next_arg:
      414      proc (previous_control_arg, number, p, l, regexp);
      415 
      416 dcl  arg char (argl) based (argp);
      417 dcl  argl fixed bin (21);
      418 dcl  argp ptr;
      419 dcl  ent bit (1) aligned;
      420 dcl  l fixed bin (21) parameter;
      421 dcl  number fixed bin (21) parameter;
      422 dcl  p ptr parameter;
      423 dcl  previous_control_arg char (*) parameter;
      424 dcl  regexp bit (1) parameter;
      425 
      426 	ent = "1"b;
      427 	goto next_arg_common;
      428 
      429 get_char_arg:
      430      entry (previous_control_arg, p, l);
      431 
      432 	ent = "0"b;
      433 	goto next_arg_common;
      434 
      435 next_arg_common:
      436 	if loop = arg_count
      437 	then do;
      438 	     call complain (error_table_$noarg, myname, "Following ^a.", previous_control_arg);
      439 	     goto return_to_caller;
      440 	     end;
      441 
      442 	loop = loop + 1;
      443 	call cu_$arg_ptr (loop, argp, argl, (0));
      444 	if index (arg, "-") = 1
      445 	then do;
      446 	     call complain (0, myname, "Missing argument following ^a.", previous_control_arg);
      447 	     goto return_to_caller;
      448 	     end;
      449 
      450 	if ent
      451 	then do;
      452 	     number = cv_dec_check_ (arg, code);
      453 	     if code = 0
      454 	     then do;
      455 		p = null;
      456 		l = argl;
      457 		end;
      458 	     else do;
      459 		p = argp;
      460 		l = argl;
      461 		call check_for_regexp (l, p, regexp);
      462 		if regexp
      463 		then number = UNUSED;
      464 		else do;
      465 		     call complain (0, myname, "Non-numeric argument ""^a"" following ^a.", arg, previous_control_arg)
      466 			;
      467 		     goto return_to_caller;
      468 		     end;
      469 		end;
      470 	     end;
      471 	else do;
      472 	     number = UNUSED;
      473 	     p = argp;
      474 	     l = argl;
      475 	     end;
      476 
      477 	have_selection_args = "1"b;
      478 	return;
      479      end get_next_arg;
      480 
      481 add_to_match_exclude_list:
      482      proc (type, argp, argl);
      483 
      484 dcl  arg char (argl) based (argp);
      485 dcl  argl fixed bin (21) parameter;
      486 dcl  argp ptr parameter;
      487 dcl  i fixed bin;
      488 dcl  listp ptr;
      489 dcl  type bit (1) aligned parameter;
      490 
      491 	if system_free_area_ptr = null
      492 	then system_free_area_ptr = get_system_free_area_ ();
      493 	if type
      494 	then do;
      495 	     if match_listp = null
      496 	     then do;
      497 		match_count = arg_count - loop + 1;
      498 		allocate match_list in (system_free_area) set (match_listp);
      499 		match_list.count = 0;
      500 		end;
      501 	     listp = match_listp;
      502 	     end;
      503 	else do;
      504 	     if exclude_listp = null
      505 	     then do;
      506 		exclude_count = arg_count - loop + 1;
      507 		allocate exclude_list in (system_free_area) set (exclude_listp);
      508 		exclude_list.count = 0;
      509 		end;
      510 	     listp = exclude_listp;
      511 	     end;
      512 
      513 	i, listp -> match_list.count = listp -> match_list.count + 1;
      514 	if argl > 1
      515 	then if (substr (arg, 1, 1) = "/") & (substr (arg, argl, 1) = "/")
      516 	     then do;
      517 		listp -> match_list.flags.regexp (i) = "1"b;
      518 		listp -> match_list.stringlen (i) = argl - 2;
      519 		listp -> match_list.stringp (i) = addcharno (argp, 1);
      520 		end;
      521 	     else do;
      522 have_match_exclude_string:
      523 		listp -> match_list.flags.regexp (i) = "0"b;
      524 		listp -> match_list.stringlen (i) = argl;
      525 		listp -> match_list.stringp (i) = argp;
      526 		end;
      527 	else goto have_match_exclude_string;
      528 
      529 	return;
      530      end add_to_match_exclude_list;
      531 
  1     1 /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
  1     2 /* format: style2,^inddcls,idind32 */
  1     3 
  1     4 declare 1 terminate_file_switches	based,
  1     5 	2 truncate		bit (1) unaligned,
  1     6 	2 set_bc			bit (1) unaligned,
  1     7 	2 terminate		bit (1) unaligned,
  1     8 	2 force_write		bit (1) unaligned,
  1     9 	2 delete			bit (1) unaligned;
  1    10 
  1    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
  1    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
  1    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
  1    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
  1    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
  1    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
  1    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
  1    18 
  1    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
      532 
  2     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  2     2*
  2     3*   Values for the "access mode" argument so often used in hardcore
  2     4*   James R. Davis 26 Jan 81  MCR 4844
  2     5*   Added constants for SM access 4/28/82 Jay Pattin
  2     6*   Added text strings 03/19/85 Chris Jones
  2     7**/
  2     8 
  2     9 
  2    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  2    11 dcl	(
  2    12 	N_ACCESS		   init ("000"b),
  2    13 	R_ACCESS		   init ("100"b),
  2    14 	E_ACCESS		   init ("010"b),
  2    15 	W_ACCESS		   init ("001"b),
  2    16 	RE_ACCESS		   init ("110"b),
  2    17 	REW_ACCESS	   init ("111"b),
  2    18 	RW_ACCESS		   init ("101"b),
  2    19 	S_ACCESS		   init ("100"b),
  2    20 	M_ACCESS		   init ("010"b),
  2    21 	A_ACCESS		   init ("001"b),
  2    22 	SA_ACCESS		   init ("101"b),
  2    23 	SM_ACCESS		   init ("110"b),
  2    24 	SMA_ACCESS	   init ("111"b)
  2    25 	)		   bit (3) internal static options (constant);
  2    26 
  2    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  2    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  2    29 
  2    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  2    31 			   static options (constant);
  2    32 
  2    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  2    34 			   static options (constant);
  2    35 
  2    36 dcl	(
  2    37 	N_ACCESS_BIN	   init (00000b),
  2    38 	R_ACCESS_BIN	   init (01000b),
  2    39 	E_ACCESS_BIN	   init (00100b),
  2    40 	W_ACCESS_BIN	   init (00010b),
  2    41 	RW_ACCESS_BIN	   init (01010b),
  2    42 	RE_ACCESS_BIN	   init (01100b),
  2    43 	REW_ACCESS_BIN	   init (01110b),
  2    44 	S_ACCESS_BIN	   init (01000b),
  2    45 	M_ACCESS_BIN	   init (00010b),
  2    46 	A_ACCESS_BIN	   init (00001b),
  2    47 	SA_ACCESS_BIN	   init (01001b),
  2    48 	SM_ACCESS_BIN	   init (01010b),
  2    49 	SMA_ACCESS_BIN	   init (01011b)
  2    50 	)		   fixed bin (5) internal static options (constant);
  2    51 
  2    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      533 
      534 
      535 dcl  1 exclude_list based (exclude_listp),
      536        2 count fixed bin,
      537        2 string (exclude_count refer (exclude_list.count)),
      538          3 flags aligned,
      539 	 4 regexp bit (1) unaligned,			/* ON = string is a regexp */
      540 	 4 pad bit (35),
      541          3 stringlen fixed bin (21),			/* length of string */
      542          3 stringp ptr;				/* pointer to string. If regexp, string is without slashes */
      543 
      544 dcl  1 match_list based (match_listp),
      545        2 count fixed bin,
      546        2 string (match_count refer (match_list.count)),
      547          3 flags aligned,
      548 	 4 regexp bit (1) unaligned,			/* ON = string is a regexp */
      549 	 4 pad bit (35),
      550          3 stringlen fixed bin (21),			/* length of string */
      551          3 stringp ptr;				/* pointer to string. If regexp, string is without slashes */
      552 
      553 dcl  Schange_NL_to_QUOTE bit (1) aligned;
      554 dcl  Schange_NL_to_SP bit (1) aligned;
      555 dcl  (addcharno, addr, divide, index, length, null, rtrim, substr) builtin;
      556 dcl  active_fnc_err_ entry options (variable);
      557 dcl  active_fnc_err_$suppress_name entry options (variable);
      558 dcl  af_sw bit (1);
      559 dcl  arg char (arg_len) based (arg_ptr);
      560 dcl  arg_count fixed bin;
      561 dcl  arg_len fixed bin (21);
      562 dcl  arg_ptr ptr;
      563 dcl  bit_count fixed bin (24);
      564 dcl  char_arg_len fixed bin (21);
      565 dcl  char_arg_ptr ptr;
      566 dcl  cleanup condition;
      567 dcl  code fixed bin (35);
      568 dcl  com_err_ entry () options (variable);
      569 dcl  com_err_$suppress_name entry () options (variable);
      570 dcl  comp_nm char (32);
      571 dcl  complain entry variable options (variable);
      572 dcl  cu_$af_return_arg entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
      573 dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
      574 dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
      575 dcl  dn char (168);
      576 dcl  en char (32);
      577 dcl  error_table_$badopt fixed bin (35) ext static;
      578 dcl  error_table_$inconsistent fixed bin (35) ext static;
      579 dcl  error_table_$noarg fixed bin (35) ext static;
      580 dcl  error_table_$not_act_fnc fixed bin (35) ext;
      581 dcl  exclude_count fixed bin (21);
      582 dcl  exclude_listp ptr;
      583 dcl  expand_pathname_$component entry (char (*), char (*), char (*), char (*), fixed bin (35));
      584 dcl  from_is_regexp bit (1);
      585 dcl  from_line fixed bin (21);
      586 dcl  from_string char (from_stringl) based (from_stringp);
      587 dcl  from_stringl fixed bin (21);
      588 dcl  from_stringp ptr;
      589 dcl  get_system_free_area_ entry () returns (ptr);
      590 dcl  have_selection_args bit (1) aligned;
      591 dcl  initiate_file_$component entry (char (*), char (*), char (*), bit (*), ptr, fixed bin (24), fixed bin (35));
      592 dcl  iox_$put_chars entry (ptr, ptr, fixed bin (21), fixed bin (35));
      593 dcl  iox_$user_output ptr external;
      594 dcl  loop fixed bin;
      595 dcl  match_count fixed bin (21);
      596 dcl  match_listp ptr;
      597 dcl  move_len fixed bin (21);
      598 dcl  myname char (32) int static options (constant) init ("contents");
      599 dcl  NL char (1) static options (constant) init ("
      600 ");
      601 dcl  path char (168);
      602 dcl  pathname_$component entry (char (*), char (*), char (*)) returns (char (194));
      603 dcl  requote_string_ entry (char (*)) returns (char (*));
      604 dcl  return_arg char (return_len) varying based (return_ptr);
      605 dcl  return_len fixed bin (21);
      606 dcl  return_ptr ptr;
      607 dcl  search_file_$silent
      608 	entry (ptr, fixed bin (21), fixed bin (21), ptr, fixed bin (21), fixed bin (21), fixed bin (21), fixed bin (21),
      609 	fixed bin (35));
      610 dcl  seg char (seg_len) based (seg_ptr) aligned;
      611 dcl  seg_len fixed bin (21);
      612 dcl  seg_next_line char (seg_next_line_len) based (seg_next_line_ptr) aligned;
      613 dcl  seg_next_line_len fixed bin (21);
      614 dcl  seg_next_line_ptr ptr;
      615 dcl  seg_pos fixed bin (21);
      616 dcl  seg_ptr ptr;
      617 dcl  SP char (1) static options (constant) init (" ");
      618 dcl  SPACE char (1) int static options (constant) init (" ");
      619 dcl  system_free_area area based (system_free_area_ptr);
      620 dcl  system_free_area_ptr ptr;
      621 dcl  terminate_file_ entry (ptr, fixed bin (24), bit (*), fixed bin (35));
      622 dcl  to_is_regexp bit (1);
      623 dcl  to_line fixed bin (21);
      624 dcl  to_stringl fixed bin (21);
      625 dcl  to_stringp ptr;
      626 dcl  UNUSED fixed bin int static options (constant) init (-1);
      627 
      628      end contents;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/05/00  1831.0  contents.pl1                      >udd>sm>ds>w>ml>contents.pl1
532          1    04/06/83  1339.4  terminate_file.incl.pl1           >ldd>incl>terminate_file.incl.pl1
533          2    04/11/85  1552.6  access_mode_values.incl.pl1       >ldd>incl>access_mode_values.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
NL                              000001 constant        char(1)                  initial packed unaligned dcl 599 set ref 137 157 157
                                                                                  168 174 174 212 302 302
R_ACCESS                        000054 constant        bit(3)                   initial packed unaligned dcl 2-11 set ref 129*
SP                              000000 constant        char(1)                  initial packed unaligned dcl 617 ref 336
SPACE                           000000 constant        char(1)                  initial packed unaligned dcl 618 set ref 346 346
Schange_NL_to_QUOTE             000100 automatic       bit(1)                   dcl 553 set ref 48* 59* 65* 71* 154 163 218 291 336
                                                                                  346
Schange_NL_to_SP                000101 automatic       bit(1)                   dcl 554 set ref 47* 58* 64* 70* 137 154 218 336 346
TERM_FILE_TERM                  000012 constant        bit(3)                   initial packed unaligned dcl 1-14 set ref 403*
UNUSED                          003572 constant        fixed bin(17,0)          initial dcl 626 ref 46 74 82 203 228 231 307 462 472
active_fnc_err_                 000010 constant        entry                    external dcl 556 ref 39
active_fnc_err_$suppress_name   000012 constant        entry                    external dcl 557 ref 111
addcharno                                              builtin function         dcl 555 ref 169 299 364 519
addr                                                   builtin function         dcl 555 ref 174 174 302 302 344 344 346 346
af_sw                           000102 automatic       bit(1)                   packed unaligned dcl 558 set ref 34* 38* 111 174 207
                                                                                  302 325
arg                                    based           char                     packed unaligned dcl 416 in procedure "get_next_arg"
                                                                                  set ref 444 452* 465*
arg                                    based           char                     packed unaligned dcl 559 in procedure "contents" set
                                                                                  ref 55 55 55 62 62 68 68 74 74 77* 82 86 91 91 97*
                                                                                  100 103*
arg                                    based           char                     packed unaligned dcl 484 in procedure
                                                                                  "add_to_match_exclude_list" ref 514 514
arg_count                       000103 automatic       fixed bin(17,0)          dcl 560 set ref 31* 53 435 497 506
arg_len                         000104 automatic       fixed bin(21,0)          dcl 561 set ref 54* 55 55 55 62 62 68 68 74 74 77 77
                                                                                  82 86 91 91 97 97 100 103 103 119*
arg_ptr                         000106 automatic       pointer                  dcl 562 set ref 54* 55 55 55 62 62 68 68 74 74 77 82
                                                                                  86 91 91 97 100 103 119*
argl                            000420 automatic       fixed bin(21,0)          dcl 417 in procedure "get_next_arg" set ref 443* 444
                                                                                  452 452 456 460 465 465 474
argl                                   parameter       fixed bin(21,0)          dcl 485 in procedure "add_to_match_exclude_list" ref
                                                                                  481 514 514 514 514 518 524
argp                            000422 automatic       pointer                  dcl 418 in procedure "get_next_arg" set ref 443* 444
                                                                                  452 459 465 473
argp                                   parameter       pointer                  dcl 486 in procedure "add_to_match_exclude_list" ref
                                                                                  481 514 514 519 525
bit_count                       000110 automatic       fixed bin(24,0)          dcl 563 set ref 129* 136
char_arg_len                    000111 automatic       fixed bin(21,0)          dcl 564 set ref 88* 89* 93* 94*
char_arg_ptr                    000112 automatic       pointer                  dcl 565 set ref 88* 89* 93* 94*
cleanup                         000114 stack reference condition                dcl 566 ref 51
code                            000122 automatic       fixed bin(35,0)          dcl 567 set ref 31* 32 120* 121 123* 129* 132* 384*
                                                                                  385 387 389 391 393* 452* 453
com_err_                        000014 constant        entry                    external dcl 568 ref 35
com_err_$suppress_name          000016 constant        entry                    external dcl 569 ref 113
comp_nm                         000123 automatic       char(32)                 packed unaligned dcl 570 set ref 120* 129* 132* 132*
complain                        000134 automatic       entry variable           dcl 571 set ref 35* 39* 77 97 103 123 132 307 309
                                                                                  311 330 391 393 438 446 465
count                                  based           fixed bin(17,0)          level 2 in structure "exclude_list" dcl 535
                                                                                  in procedure "contents" set ref 277 407 507* 508*
count                                  based           fixed bin(17,0)          level 2 in structure "match_list" dcl 544
                                                                                  in procedure "contents" set ref 260 405 498* 499*
                                                                                  513 513*
cu_$af_return_arg               000020 constant        entry                    external dcl 572 ref 31
cu_$arg_ptr                     000022 constant        entry                    external dcl 573 ref 54 119 443
cv_dec_check_                   000024 constant        entry                    external dcl 574 ref 452
divide                                                 builtin function         dcl 555 ref 136
dn                              000140 automatic       char(168)                packed unaligned dcl 575 set ref 120* 129* 132* 132*
en                              000212 automatic       char(32)                 packed unaligned dcl 576 set ref 120* 129* 132* 132*
ent                             000424 automatic       bit(1)                   dcl 419 set ref 426* 432* 450
error_table_$badopt             000026 external static fixed bin(35,0)          dcl 577 set ref 97*
error_table_$inconsistent       000030 external static fixed bin(35,0)          dcl 578 set ref 77*
error_table_$noarg              000032 external static fixed bin(35,0)          dcl 579 set ref 438*
error_table_$nomatch            000060 external static fixed bin(35,0)          dcl 377 ref 387
error_table_$not_act_fnc        000034 external static fixed bin(35,0)          dcl 580 ref 32
exclude_count                   000222 automatic       fixed bin(21,0)          dcl 581 set ref 506* 507 507
exclude_list                           based           structure                level 1 unaligned dcl 535 set ref 407 507
exclude_listp                   000224 automatic       pointer                  dcl 582 set ref 50* 274 277 278 278 278 282 283 407
                                                                                  407 504 507* 508 510
expand_pathname_$component      000036 constant        entry                    external dcl 583 ref 120
flags                     2            based           structure                array level 3 in structure "exclude_list" dcl 535
                                                                                  in procedure "contents"
flags                     2            based           structure                array level 3 in structure "match_list" dcl 544
                                                                                  in procedure "contents"
found_a_match                   000354 automatic       bit(1)                   dcl 183 set ref 259* 260 261* 267* 270 276* 277 278*
                                                                                  284* 287
found_start                     000355 automatic       bit(1)                   dcl 184 set ref 203* 205* 236 241*
from_is_regexp                  000226 automatic       bit(1)                   packed unaligned dcl 584 set ref 81* 236 309*
from_line                       000227 automatic       fixed bin(21,0)          dcl 585 set ref 46* 74 81* 203 228 228 307 307 307*
from_string                            based           char                     packed unaligned dcl 586 set ref 309*
from_stringl                    000230 automatic       fixed bin(21,0)          dcl 587 set ref 81* 236* 309 309
from_stringp                    000232 automatic       pointer                  dcl 588 set ref 50* 74 81* 203 236 236* 309 309
get_system_free_area_           000040 constant        entry                    external dcl 589 ref 491
have_selection_args             000234 automatic       bit(1)                   dcl 590 set ref 44* 140 477*
i                               000440 automatic       fixed bin(17,0)          dcl 487 set ref 513* 517 518 519 522 524 525
index                                                  builtin function         dcl 555 ref 55 157 212 267 284 444
initiate_file_$component        000042 constant        entry                    external dcl 591 ref 129
iox_$put_chars                  000044 constant        entry                    external dcl 592 ref 174 302 344 346
iox_$user_output                000046 external static pointer                  dcl 593 set ref 174* 302* 344* 346*
l                                      parameter       fixed bin(21,0)          dcl 420 in procedure "get_next_arg" set ref 413 429
                                                                                  456* 460* 461* 474*
l                                      parameter       fixed bin(21,0)          dcl 356 in procedure "check_for_regexp" set ref 353
                                                                                  361 361 361 361 365* 365
length                                                 builtin function         dcl 555 ref 137 157 168 328 328 330 330 344 344
line                                   based           char                     packed unaligned dcl 185 set ref 267 284 291 293*
linecount                       000356 automatic       fixed bin(21,0)          dcl 186 set ref 198* 222* 222 228 231 307
linel                           000357 automatic       fixed bin(21,0)          dcl 187 set ref 215* 218* 220* 224 236* 248* 261*
                                                                                  267 278* 284 291 293 293
linep                           000360 automatic       pointer                  dcl 188 set ref 211* 236* 248* 261* 267 278* 284 291
                                                                                  293
listp                           000442 automatic       pointer                  dcl 488 set ref 501* 510* 513 513 517 518 519 522
                                                                                  524 525
loop                            000235 automatic       fixed bin(17,0)          dcl 594 set ref 45* 53 54* 106* 106 260* 261 261 261
                                                                                  265 266* 277* 278 278 278 282 283* 435 442* 442
                                                                                  443* 497 506
match_count                     000236 automatic       fixed bin(21,0)          dcl 595 set ref 497* 498 498
match_list                             based           structure                level 1 unaligned dcl 544 set ref 405 498
match_listp                     000240 automatic       pointer                  dcl 596 set ref 50* 256 260 261 261 261 265 266 405
                                                                                  405 495 498* 499 501
move_len                        000242 automatic       fixed bin(21,0)          dcl 597 set ref 157* 159 159* 163 163 165 165 168
myname                          000002 constant        char(32)                 initial packed unaligned dcl 598 set ref 77* 97*
                                                                                  103* 111* 113* 123* 132* 307* 309* 311* 330* 391*
                                                                                  393* 438* 446* 465*
next_line                              parameter       char                     packed unaligned dcl 321 set ref 318 328 330 340 344
                                                                                  344 344 344
nlpos                           000362 automatic       fixed bin(21,0)          dcl 189 set ref 212* 213 216* 218 220 248* 297 299
null                                                   builtin function         dcl 555 ref 50 74 82 130 203 236 248 256 274 309 403
                                                                                  405 407 455 491 495 504
number                                 parameter       fixed bin(21,0)          dcl 421 set ref 413 452* 462* 472*
p                                      parameter       pointer                  dcl 422 in procedure "get_next_arg" set ref 413 429
                                                                                  455* 459* 461* 473*
p                                      parameter       pointer                  dcl 357 in procedure "check_for_regexp" set ref 353
                                                                                  361 361 364* 364
path                            000243 automatic       char(168)                packed unaligned dcl 601 set ref 42* 100 100* 109
                                                                                  120* 123*
pathname_$component             000050 constant        entry                    external dcl 602 ref 132 132
previous_control_arg                   parameter       char                     packed unaligned dcl 423 set ref 413 429 438* 446*
                                                                                  465*
printed_something               000363 automatic       bit(1)                   dcl 190 set ref 199* 295* 302
regexp                                 parameter       bit(1)                   packed unaligned dcl 424 in procedure "get_next_arg"
                                                                                  set ref 413 461* 462
regexp                    2            based           bit(1)                   array level 4 in structure "match_list" packed
                                                                                  packed unaligned dcl 544 in procedure "contents"
                                                                                  set ref 261 517* 522*
regexp                                 based           char                     packed unaligned dcl 378 in procedure "search" set
                                                                                  ref 391* 393*
regexp                                 parameter       bit(1)                   packed unaligned dcl 358 in procedure
                                                                                  "check_for_regexp" set ref 353 366* 368* 369*
regexp                    2            based           bit(1)                   array level 4 in structure "exclude_list" packed
                                                                                  packed unaligned dcl 535 in procedure "contents"
                                                                                  ref 278
regexp_string                          based           char                     packed unaligned dcl 191 ref 267 284
regexp_stringl                  000364 automatic       fixed bin(21,0)          dcl 192 set ref 266* 267 283* 284
regexp_stringp                  000366 automatic       pointer                  dcl 193 set ref 265* 267 282* 284
regexpl                                parameter       fixed bin(21,0)          dcl 379 set ref 374 384* 391 391 393 393
regexpp                                parameter       pointer                  dcl 380 set ref 374 384* 391 393
requote_string_                 000052 constant        entry                    external dcl 603 ref 163 291
rest_of_segment                        based           char                     packed unaligned dcl 194 ref 212
rest_of_segmentl                000370 automatic       fixed bin(21,0)          dcl 195 set ref 201* 210 212 215 216 248 297* 297
rest_of_segmentp                000372 automatic       pointer                  dcl 196 set ref 200* 211 212 299* 299
return_arg                             based           varying char             dcl 604 set ref 207* 328 330 336 336* 336 340* 340
return_len                      000315 automatic       fixed bin(21,0)          dcl 605 set ref 31* 207 328 336 340
return_ptr                      000316 automatic       pointer                  dcl 606 set ref 31* 207 328 330 336 336 336 340 340
rtrim                                                  builtin function         dcl 555 ref 137
search_file_$silent             000054 constant        entry                    external dcl 607 ref 384
seg                                    based           char                     dcl 610 ref 137 172
seg_len                         000320 automatic       fixed bin(21,0)          dcl 611 set ref 136* 137* 137 152 156 159 172 201
seg_next_line                          based           char                     dcl 612 ref 157 163 163 165 165
seg_next_line_len               000321 automatic       fixed bin(21,0)          dcl 613 set ref 152* 157 163 163 165 165
seg_next_line_ptr               000322 automatic       pointer                  dcl 614 set ref 151* 157 163 163 165 165 169*
seg_pos                         000324 automatic       fixed bin(21,0)          dcl 615 set ref 153* 156 159 168* 168 169
seg_ptr                         000326 automatic       pointer                  dcl 616 set ref 50* 129* 130 137 151 169 172 200 403
                                                                                  403*
string                                 based           char                     packed unaligned dcl 359 in procedure
                                                                                  "check_for_regexp" ref 361 361
string                    2            based           structure                array level 2 in structure "exclude_list" unaligned
                                                                                  dcl 535 in procedure "contents"
string                    2            based           structure                array level 2 in structure "match_list" unaligned
                                                                                  dcl 544 in procedure "contents"
stringl                                parameter       fixed bin(21,0)          dcl 381 set ref 374 384*
stringlen                 4            based           fixed bin(21,0)          array level 3 in structure "exclude_list" dcl 535
                                                                                  in procedure "contents" set ref 278* 283
stringlen                 4            based           fixed bin(21,0)          array level 3 in structure "match_list" dcl 544
                                                                                  in procedure "contents" set ref 261* 266 518* 524*
stringp                                parameter       pointer                  dcl 382 in procedure "search" set ref 374 384*
stringp                   6            based           pointer                  array level 3 in structure "exclude_list" dcl 535
                                                                                  in procedure "contents" set ref 278* 282
stringp                   6            based           pointer                  array level 3 in structure "match_list" dcl 544
                                                                                  in procedure "contents" set ref 261* 265 519* 525*
substr                                                 builtin function         dcl 555 ref 163 163 165 165 361 361 514 514
system_free_area                       based           area(1024)               dcl 619 ref 405 407 498 507
system_free_area_ptr            000330 automatic       pointer                  dcl 620 set ref 50* 405 407 491 491* 498 507
terminate_file_                 000056 constant        entry                    external dcl 621 ref 403
to_is_regexp                    000332 automatic       bit(1)                   packed unaligned dcl 622 set ref 85* 248
to_line                         000333 automatic       fixed bin(21,0)          dcl 623 set ref 46* 82 85* 231 231
to_stringl                      000334 automatic       fixed bin(21,0)          dcl 624 set ref 85* 248*
to_stringp                      000336 automatic       pointer                  dcl 625 set ref 50* 82 85* 248 248*
type                                   parameter       bit(1)                   dcl 489 ref 481 493

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 2-33
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 2-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 2-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 2-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
RW_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 2-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 2-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 2-30
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 2-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 2-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 2-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
TERM_FILE_BC                           internal static bit(2)                   initial packed unaligned dcl 1-12
TERM_FILE_DELETE                       internal static bit(5)                   initial packed unaligned dcl 1-17
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial packed unaligned dcl 1-16
TERM_FILE_TRUNC                        internal static bit(1)                   initial packed unaligned dcl 1-11
TERM_FILE_TRUNC_BC                     internal static bit(2)                   initial packed unaligned dcl 1-13
TERM_FILE_TRUNC_BC_TERM                internal static bit(3)                   initial packed unaligned dcl 1-15
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 2-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
terminate_file_switches                based           structure                level 1 packed packed unaligned dcl 1-4

NAMES DECLARED BY EXPLICIT CONTEXT.
add_to_match_exclude_list       003252 constant        entry                    internal dcl 481 ref 89 94
check_for_regexp                002412 constant        entry                    internal dcl 353 ref 461
cleaner                         002634 constant        entry                    internal dcl 400 ref 51 144
contents                        000247 constant        entry                    external dcl 24
get_char_arg                    002742 constant        entry                    internal dcl 429 ref 88 93
get_next_arg                    002721 constant        entry                    internal dcl 413 ref 81 85
have_match_exclude_string       003403 constant        label                    dcl 522 ref 514
inconsistent                    000475 constant        label                    dcl 77 ref 82
next_arg_common                 002762 constant        label                    dcl 435 ref 427 433
process_selection               001444 constant        entry                    internal dcl 180 ref 140
put_next_line                   002223 constant        entry                    internal dcl 318 ref 163 165 172 291 293
return_entire_segment           001255 constant        entry                    internal dcl 148 ref 142
return_to_caller                001250 constant        label                    dcl 144 ref 79 98 104 114 394 439 447 467
search                          002455 constant        entry                    internal dcl 374 ref 236 248 261 278
selection_done                  002041 constant        label                    dcl 302 ref 231
skip_line                       002032 constant        label                    dcl 297 ref 224 228 236 236 270 287
test_match_excludes             001601 constant        label                    dcl 256 ref 242

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4064        4146    3574        4074
Length      4414    3574        62         232     267           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
contents                            629 external procedure  is an external procedure.  
on unit on line 51                   64 on unit               
return_entire_segment                   internal procedure  shares stack frame of external procedure contents.  
process_selection                       internal procedure  shares stack frame of external procedure contents.  
put_next_line                       102 internal procedure  is called during a stack extension.  
check_for_regexp                        internal procedure  shares stack frame of external procedure contents.  
search                                  internal procedure  shares stack frame of external procedure contents.  
cleaner                              84 internal procedure  is called by several nonquick procedures.  
get_next_arg                            internal procedure  shares stack frame of external procedure contents.  
add_to_match_exclude_list               internal procedure  shares stack frame of external procedure contents.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
contents                 000100 Schange_NL_to_QUOTE         contents
                         000101 Schange_NL_to_SP            contents
                         000102 af_sw                       contents
                         000103 arg_count                   contents
                         000104 arg_len                     contents
                         000106 arg_ptr                     contents
                         000110 bit_count                   contents
                         000111 char_arg_len                contents
                         000112 char_arg_ptr                contents
                         000122 code                        contents
                         000123 comp_nm                     contents
                         000134 complain                    contents
                         000140 dn                          contents
                         000212 en                          contents
                         000222 exclude_count               contents
                         000224 exclude_listp               contents
                         000226 from_is_regexp              contents
                         000227 from_line                   contents
                         000230 from_stringl                contents
                         000232 from_stringp                contents
                         000234 have_selection_args         contents
                         000235 loop                        contents
                         000236 match_count                 contents
                         000240 match_listp                 contents
                         000242 move_len                    contents
                         000243 path                        contents
                         000315 return_len                  contents
                         000316 return_ptr                  contents
                         000320 seg_len                     contents
                         000321 seg_next_line_len           contents
                         000322 seg_next_line_ptr           contents
                         000324 seg_pos                     contents
                         000326 seg_ptr                     contents
                         000330 system_free_area_ptr        contents
                         000332 to_is_regexp                contents
                         000333 to_line                     contents
                         000334 to_stringl                  contents
                         000336 to_stringp                  contents
                         000354 found_a_match               process_selection
                         000355 found_start                 process_selection
                         000356 linecount                   process_selection
                         000357 linel                       process_selection
                         000360 linep                       process_selection
                         000362 nlpos                       process_selection
                         000363 printed_something           process_selection
                         000364 regexp_stringl              process_selection
                         000366 regexp_stringp              process_selection
                         000370 rest_of_segmentl            process_selection
                         000372 rest_of_segmentp            process_selection
                         000420 argl                        get_next_arg
                         000422 argp                        get_next_arg
                         000424 ent                         get_next_arg
                         000440 i                           add_to_match_exclude_list
                         000442 listp                       add_to_match_exclude_list

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             alloc_char_temp     call_ent_var_desc   call_ext_out_desc   call_ext_out        call_int_this_desc
call_int_this       call_int_other      return_mac          enable_op           shorten_stack       ext_entry
int_entry           int_entry_desc      set_chars_eis       index_chars_eis     op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
active_fnc_err_               active_fnc_err_$suppress_name com_err_                      com_err_$suppress_name
cu_$af_return_arg             cu_$arg_ptr                   cv_dec_check_                 expand_pathname_$component
get_system_free_area_         initiate_file_$component      iox_$put_chars                pathname_$component
requote_string_               search_file_$silent           terminate_file_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$inconsistent     error_table_$noarg            error_table_$nomatch
error_table_$not_act_fnc      iox_$user_output




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     24 000246        31 000254        32 000270        34 000274        35 000275        36 000301        38 000302
     39 000304        42 000310        44 000313        45 000314        46 000316        47 000321        48 000323
     50 000324        51 000333        53 000355        54 000361        55 000377        58 000423        59 000424
     60 000425        62 000426        64 000436        65 000440        66 000441        68 000442        70 000452
     71 000453        72 000455        74 000456        77 000475        79 000530        81 000531        82 000537
     85 000552        86 000560        88 000564        89 000571        90 000575        91 000576        93 000606
     94 000613        95 000617        97 000620        98 000652        99 000653       100 000654       103 000664
    104 000717       106 000720       107 000721       109 000722       111 000726       113 000756       114 001003
    119 001004       120 001024       121 001053       123 001055       124 001103       129 001104       130 001144
    132 001150       133 001222       136 001223       137 001227       140 001243       142 001247       144 001250
    146 001254       148 001255       151 001256       152 001260       153 001262       154 001263       156 001267
    157 001273       159 001305       163 001311       165 001347       168 001366       169 001373       170 001376
    171 001377       172 001400       174 001416       177 001443       180 001444       198 001445       199 001446
    200 001447       201 001451       203 001453       205 001465       207 001466       210 001471       211 001474
    212 001476       213 001507       215 001510       216 001512       217 001514       218 001515       220 001524
    222 001525       224 001526       228 001530       231 001535       236 001542       241 001560       242 001562
    248 001563       256 001601       259 001605       260 001606       261 001620       265 001645       266 001647
    267 001651       269 001661       270 001663       274 001666       276 001672       277 001673       278 001706
    282 001733       283 001735       284 001737       286 001747       287 001751       291 001754       293 002014
    295 002030       297 002032       299 002034       300 002040       302 002041       306 002067       307 002070
    309 002131       311 002175       313 002221       318 002222       325 002236       328 002241       330 002246
    332 002301       336 002302       340 002323       342 002340       344 002341       346 002362       350 002411
    353 002412       361 002414       364 002431       365 002434       366 002436       367 002442       368 002443
    369 002450       371 002454       374 002455       384 002457       385 002514       387 002522       389 002526
    391 002530       393 002573       394 002627       397 002630       400 002633       403 002641       405 002674
    407 002706       410 002720       413 002721       426 002737       427 002741       429 002742       432 002760
    433 002761       435 002762       438 002765       439 003022       442 003023       443 003024       444 003042
    446 003056       447 003110       450 003111       452 003113       453 003141       455 003143       456 003145
    457 003147       459 003150       460 003152       461 003154       462 003166       465 003177       467 003237
    470 003240       472 003241       473 003244       474 003245       477 003247       478 003251       481 003252
    491 003254       493 003267       495 003273       497 003277       498 003303       499 003314       501 003315
    502 003317       504 003320       506 003324       507 003330       508 003341       510 003342       513 003344
    514 003350       517 003366       518 003373       519 003377       520 003402       522 003403       524 003410
    525 003413       529 003416


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
