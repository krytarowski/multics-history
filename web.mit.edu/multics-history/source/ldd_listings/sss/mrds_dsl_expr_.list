	COMPILATION LISTING OF SEGMENT mrds_dsl_expr_
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/01/88  1333.1 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 mrds_dsl_expr_:
       13     proc ();
       14 
       15 
       16 /*
       17*   BEGIN_DESCRIPTION
       18*   This  procedure  translates  a  where-clause  arithmetic  expression into a
       19*   postfix  polish  form which can be easily evaluated within mrds_dsl_search.
       20*   END_DESCRIPTION
       21*
       22*
       23*
       24*   HISTORY:
       25*
       26*   77-05-01 J. A. Weeldreyer: Initially written.
       27*
       28*   78-02-01  J.   A.   Weeldreyer:  Modified to properly handle expr.  without
       29*   variables.
       30*
       31*   79-02-01 J. A. Weeldreyer: Modified for MR7.0.
       32*
       33*   79-05-04   Al   Kepner:   Modified   to   add   set_type_and_len   proc  to
       34*   condense_data_stack.
       35*
       36*   79-06-01 Al Kepner: Modified to use select_area.
       37*
       38*   79-09-01  NSDavids:  Modified  to correctly build a character or bit string
       39*   literal  as  opposed to treating it like a number which was returned from a
       40*   function call.  Also to handle the case were the result of an expression is
       41*   a literal type.
       42*
       43*   79-12-01 Jim Gray : Modified to change complex data type determination from
       44*   internal  to a call to mu_data_class$complex_data_class so that the new packed
       45*   decimal data types get included.
       46*
       47*   80-02-01 Jim Gray : Modified to add area_ptr parameter.
       48*
       49*   80-09-24  Davids:  added  to the code that handles attributes a check to be
       50*   sure  that  the  user has read permission on the attribute, if not the code
       51*   dies  with  an  incorrect  access  error.   also removed declared but never
       52*   referenced variables including the include file mdbm_arg_list.  Modified by
       53*   Jim Gray - - 80-11-05, to "and" the mdbm_secured bit with the r_perm bit in
       54*   the rm_attr_info so that secure_mrds_db turns on this check.
       55*
       56*   81-05-06  Rickie  E.   Brinegar:  Modified  to  make  use  of  the modified
       57*   rm_domain_info stucture.
       58*
       59*   81-06-01 Jim Gray : modified to use new resultant strucuture.
       60*   Also took out unused assign_ parameters.
       61*
       62*   81-09-21 Davids: enclosed several expr.item (i) = data_stack  (j)
       63*   assignments  with  unspecs  because  pl1 has a bug which causes a
       64*   subscriptrange  condition  to  occur  when  the   dimensions   of
       65*   data_stack and item are not the same.
       66*
       67*   81-09-22 Davids: another subscriptrange condition caused  by  the
       68*   pl1 bug.
       69*
       70*   81-11-04  Davids:  corrected  a  problem  that  would   cause   a
       71*   subscriptrange  condition  to  occur when an expression had extra
       72*   parens, i.e. ((1 + 2)). The fix was to check  for  the  condition
       73*   nops = 0 when the token is a ")", i.e. token_proc (8).
       74*
       75*   83-02-28 Davids: explicitly declared variables that were declared by
       76*   context of implication and removed declarations to variables that
       77*   were never referenced.
       78*
       79*   83-09-13 R. Harvey: added knowledge of the range structure so that the
       80*   needed bits could be set for the attributes. Also removed / operators
       81*   to improve speed.
       82*
       83*   84-09-20 Hergert: Made -compiled and .X. illegal tokens. Also fixed typo
       84*   where label token_proc(4) was spelled troken_proc(4). If -where showed up
       85*   in an expression.....
       86*
       87*   84-11-01 John Hergert: added call to mu_print_error for error reporting.
       88**/
       89 
       90 
       91 /****^  HISTORY COMMENTS:
       92*  1) change(88-06-27,Hergert), approve(88-07-11,MCR7903),
       93*     audit(88-07-14,Dupuis), install(88-08-01,MR12.2-1073):
       94*     Reworked for new parser.
       95*                                                   END HISTORY COMMENTS */
       96 
       97 init:
       98     entry (psi_ptr,level);
       99 
      100         if level=1 then do;
      101 	   allocate data_stacks in (parser_work_area);
      102 	   data_stacks.stack_top (*) = 0;
      103         end;
      104         else nstk_items = 0;
      105 
      106         return;
      107 
      108 build_function:
      109     entry (psi_ptr,dbcb_ptr, efd_ptr, level, code);
      110 
      111         if nstk_items >= mrds_data_$max_expr_stack_size
      112         then
      113 						/* make sure we dont overflow */
      114 	   call error (mrds_error_$expr_stack_ovfl, LOUD, 0, WCE_TYPE,
      115 	        "Too many items have been specified in an expression.");
      116 
      117         nstk_items = nstk_items + 1;			/* add function to data stack */
      118         data_stack.type (nstk_items) = SCAL_FUN;
      119         data_stack.op_code (nstk_items), data_stack.data_type (nstk_items) =
      120 	   0;
      121         data_stack.desc (nstk_items) = exp_fun_data.descriptor;
      122         data_stack.loc_index (nstk_items) = exp_fun_data.loc_index;
      123         data_stack.bit_length (nstk_items) = exp_fun_data.bit_length;
      124         data_stack.assn_ptr (nstk_items) = exp_fun_data.assn_ptr;
      125         data_stack.ai_ptr (nstk_items) = null;
      126         data_stack.fn_ptr (nstk_items) = exp_fun_data.ef_ptr;
      127 
      128         code = 0;
      129         return;
      130 
      131 build_attribute:
      132     entry (psi_ptr,dbcb_ptr, range_ptr, rel_index, ai_ptr, level, code);
      133 
      134 dcl     ai_ptr		 ptr;
      135 dcl     rel_index		 fixed bin;
      136 
      137 
      138         if nstk_items >= mrds_data_$max_expr_stack_size
      139         then
      140 						/* check for overflow */
      141 	   call error (mrds_error_$expr_stack_ovfl, LOUD, 0, WCE_TYPE,
      142 	        "Too many items have been specified in an expression.");
      143 
      144         rai_ptr = ai_ptr;				/* save space to move attr. value */
      145         if rm_attr_info.mdbm_secured & ^(rm_attr_info.read_perm)
      146 						/* if you don't have read access to an attribute */
      147         then call error (mdbm_error_$inc_attr_acc, LOUD, 0, AV_TYPE,
      148 	        "You must have read access to use an attribute in an expression."
      149 	        );				/* it shouldn't be in an expression */
      150         rdi_ptr = rm_attr_info.domain_ptr;
      151 
      152 /* Say this attribute is needed */
      153 
      154         range.tup_var (rel_index).needed_bits.attr (rm_attr_info.defn_order) =
      155 	   "1"b;
      156 
      157         li.encd_proc = "0"b;
      158         li.src_ptr, li.srcd_ptr, li.encdd_ptr = null;
      159 
      160         li.litd_ptr = addr (rm_domain_info.user_desc);
      161         li.encd_blen = 0;
      162         call mrds_dsl_make_literal$alloc (dbcb_ptr, addr (li), code);
      163         if code ^= 0
      164         then
      165 	   call error (code, LOUD, 0, WCE_TYPE, "");
      166 
      167         nstk_items = nstk_items + 1;			/* add tuple attr. to data stack */
      168         data_stack.type (nstk_items) = DATA;
      169         data_stack.op_code (nstk_items) = 0;
      170         data_stack.data_type (nstk_items) = DATABASE;
      171         data_stack.desc (nstk_items) = li.litd_ptr -> bit36;
      172         data_stack.loc_index (nstk_items) = li.lit_offset;
      173         data_stack.bit_length (nstk_items) = li.lit_blen;
      174         data_stack.assn_ptr (nstk_items) = li.lit_ptr;	/* we dont know this now */
      175         data_stack.ai_ptr (nstk_items) = ai_ptr;
      176         data_stack.fn_ptr (nstk_items) = null;
      177 
      178         code = 0;
      179         return;
      180 
      181 build_literal:
      182     entry (psi_ptr,dbcb_ptr, a_ptr, d_ptr, char_sw, level, code);
      183 
      184 /* Procedure to build a literal expr. item and add it to the data stack. */
      185 
      186 dcl     (a_ptr, d_ptr)	 ptr;
      187 dcl     lit_char		 char (lit_len) based (a_ptr);
      188 dcl     lit_char_var	 char (lit_len) var based (a_ptr);
      189 dcl     lit_len		 fixed bin;
      190 
      191         if nstk_items >= mrds_data_$max_expr_stack_size	/* check for overflow */
      192         then call error (mrds_error_$expr_stack_ovfl, LOUD, 0, WCE_TYPE,
      193 	        "Too many items have been specified in a en expression.");
      194 
      195         nstk_items = nstk_items + 1;			/* add literal to data stack */
      196 
      197         lit_len = fixed (string (d_ptr -> descriptor.size));
      198         if ^char_sw then do;
      199 	  if d_ptr -> descriptor.type = CHAR_VAR_TYPE
      200 	  then
      201 	       if index (lit_char_var, "i") ^= 0
      202 	       then				/* check if could be complex */
      203 		  desc_ptr = addr (CFLTD59);
      204 	       else desc_ptr = addr (RFLTD59);
      205 
      206 	  else if d_ptr -> descriptor.type = CHAR_TYPE
      207 	       then
      208 		  if index (lit_char, "i") ^= 0
      209 		  then
      210 		       desc_ptr = addr (CFLTD59);
      211 		  else desc_ptr = addr (RFLTD59);
      212 
      213 	       else if mu_data_class$complex_data_class (d_ptr)
      214 		  then
      215 		       desc_ptr = addr (CFLTD59);
      216 		  else desc_ptr = addr (RFLTD59);
      217         end;
      218 
      219         data_stack.type (nstk_items) = DATA;
      220         data_stack.op_code (nstk_items) = 0;
      221         data_stack.data_type (nstk_items) = LITERAL;
      222         data_stack.ai_ptr (nstk_items), data_stack.fn_ptr (nstk_items) = null;
      223 
      224         if char_sw then do;
      225 	  data_stack.desc (nstk_items) = d_ptr -> bit36;
      226 	  li.litd_ptr = d_ptr;
      227         end;
      228         else do;
      229 	  data_stack.desc (nstk_items) = desc_ptr -> bit36;
      230 	  li.litd_ptr = desc_ptr;
      231         end;
      232 
      233         li.src_ptr = a_ptr;				/* make the literal */
      234         li.srcd_ptr = d_ptr;
      235         li.encd_proc = "0"b;
      236         li.encdd_ptr = null;
      237         li.encd_blen = 0;
      238 
      239         call mrds_dsl_make_literal (dbcb_ptr, addr (li), code);
      240         if code ^= 0
      241         then
      242 	   call error (code, LOUD, 0, WCE_TYPE, "");
      243 
      244         data_stack.loc_index (nstk_items) = li.lit_offset;
      245         data_stack.bit_length (nstk_items) = li.lit_blen;
      246         data_stack.assn_ptr (nstk_items) = li.lit_ptr;
      247 
      248         code = 0;
      249         return;
      250 
      251 condense_stack:
      252     entry (psi_ptr,dbcb_ptr, a_select_area_ptr, operator, level, code);
      253 
      254 /* Procedure to combine the top 2 data_stack items, and the parameter operator
      255*   into one sub_expression.  Space to hold the result is allocated in
      256*   the literal pool. */
      257 
      258 dcl     (i, j, k)		 fixed bin;
      259 dcl     operator		 char (1) aligned;
      260 
      261         select_area_ptr = a_select_area_ptr;
      262         if data_stack.type (nstk_items - 1) ^= EXPR	/* two data items */
      263 	   & data_stack.type (nstk_items) ^= EXPR then do;/* build new sub-expr */
      264 
      265 	  nexp_items_init = mrds_data_$max_expr_items;	/* may grow to max */
      266 	  allocate expr in (select_area);		/* Allocations in select_area are never freed.  This area
      267*						   is reinitialized at the beginning of each new selection expression. */
      268 	  expr.nitems = 3;				/* just starting */
      269 	  unspec (expr.item (1)) = unspec (data_stack (nstk_items - 1));
      270 	  unspec (expr.item (2)) = unspec (data_stack (nstk_items));
      271 	  data_stack.type (nstk_items - 1) = EXPR;
      272 	  data_stack.ai_ptr (nstk_items) = null;
      273 	  data_stack.fn_ptr (nstk_items - 1) = expr_ptr;	/* reuse first data_stack item for new sub-expr */
      274 	  data_stack.desc (nstk_items - 1) =
      275 	       resolve_descs (data_stack.desc (nstk_items - 1),
      276 	       data_stack.desc (nstk_items));
      277 	  nstk_items = nstk_items - 1;		/* reduce data stack */
      278         end;					/* building new sub_expr */
      279 
      280         else if data_stack.type (nstk_items - 1) = EXPR	/* if both are sub-exprs */
      281 	        & data_stack.type (nstk_items) = EXPR then do;
      282 						/* combine both into one */
      283 	       expr_ptr = data_stack.fn_ptr (nstk_items - 1);
      284 						/* the first one will survive */
      285 	       i = expr.nitems;			/* no. items in first */
      286 	       expr_ptr1 = data_stack.fn_ptr (nstk_items);
      287 	       j = expr_ptr1 -> expr.nitems;		/* no. items in second */
      288 	       if i + j + 1 > mrds_data_$max_expr_items
      289 	       then				/* check for overflow */
      290 		  call error (mrds_error_$max_expr_items, LOUD, 0,
      291 		       WCE_TYPE,
      292 		       "Too many items have been specified in an expression."
      293 		       );
      294 
      295 	       expr.nitems = i + j + 1;		/* set count for combined expr */
      296 	       do k = i + 1 to i + j;			/* append second expr. to first */
      297 		 unspec (expr.item (k)) =
      298 		      unspec (expr_ptr1 -> expr.item (k - i));
      299 
      300 	       end;
      301 
      302 
      303 	       data_stack.desc (nstk_items - 1) =
      304 		  resolve_descs (data_stack.desc (nstk_items - 1),
      305 		  data_stack.desc (nstk_items));
      306 	       nstk_items = nstk_items - 1;		/* reduce stack size */
      307 	   end;					/* condensing two sub-exprs */
      308 
      309 	   else do;				/* adding data item to sub-expr */
      310 
      311 	       if data_stack.type (nstk_items) = EXPR then do;
      312 		 i = nstk_items;			/* i -> sub_expr */
      313 		 j = nstk_items - 1;		/* j -> data item */
      314 	       end;
      315 	       else do;
      316 		 i = nstk_items - 1;		/* ditto */
      317 		 j = nstk_items;
      318 	       end;
      319 
      320 	       expr_ptr = data_stack.fn_ptr (i);	/* look at sub-expr */
      321 	       if expr.nitems + 2 > mrds_data_$max_expr_items
      322 	       then				/* check for overflow */
      323 		  call error (mrds_error_$max_expr_items, LOUD, 0,
      324 		       WCE_TYPE,
      325 		       "Too many item have been specified in an expression."
      326 		       )
      327 		       ;
      328 
      329 	       expr.nitems = expr.nitems + 2;		/* update count */
      330 	       if i < j
      331 	       then				/* if expr is first operand */
      332 		  unspec (expr.item (expr.nitems - 1)) =
      333 		       unspec (data_stack (j));
      334 						/* CHANGE 81-09-21 append data item */
      335 	       else do;				/* if data item is first */
      336 		 do k = expr.nitems - 2 to 1 by -1;
      337 		     expr.item (k + 1) = expr.item (k); /* move each item up one slot */
      338 		 end;
      339 		 unspec (expr.item (1)) = unspec (data_stack (j));
      340 						/* CHANGE 81-09-21 move data item into first slot */
      341 	       end;				/* if data item first */
      342 
      343 	       data_stack.desc (i) =
      344 		  resolve_descs (data_stack.desc (i), data_stack.desc (j));
      345 
      346 	       if i = nstk_items
      347 	       then				/* if sub-expr last item in stack */
      348 		  data_stack (nstk_items - 1) = data_stack (nstk_items);
      349 						/* move it down one */
      350 	       nstk_items = nstk_items - 1;
      351 
      352 	   end;					/* appending data item to sub-expr */
      353 
      354         li.encd_proc = "0"b;
      355         li.src_ptr,					/* reserve space for result */
      356 	   li.srcd_ptr, li.encdd_ptr = null;
      357 
      358         li.litd_ptr = addr (data_stack.desc (nstk_items));
      359         li.encd_blen = 0;
      360         call mrds_dsl_make_literal$alloc (dbcb_ptr, addr (li), code);
      361         if code ^= 0
      362         then
      363 	   call error (code, LOUD, 0, WCE_TYPE, "");
      364         data_stack.loc_index (nstk_items) = li.lit_offset;
      365         data_stack.bit_length (nstk_items) = li.lit_blen;
      366         data_stack.assn_ptr (nstk_items) = li.lit_ptr;
      367 
      368         expr.item.type (expr.nitems) = OPERATOR;		/* now add operator to expr */
      369         expr.item.op_code (expr.nitems) = index (OPERATOR_LIST, operator);
      370 
      371         expr.item.desc (expr.nitems) = data_stack.desc (nstk_items);
      372         expr.item.loc_index (expr.nitems) = data_stack.loc_index (nstk_items);
      373         expr.item.bit_length (expr.nitems) =
      374 	   data_stack.bit_length (nstk_items);
      375         expr.item.assn_ptr (expr.nitems) = data_stack.assn_ptr (nstk_items);
      376         expr.item.data_type (expr.nitems) = 0;
      377         expr.item.ai_ptr (expr.nitems), expr.item.fn_ptr (expr.nitems) = null;
      378 
      379         code = 0;
      380         return;
      381 
      382 finish:
      383     entry (psi_ptr,efd_ptr, a_select_area_ptr, level);
      384 
      385 
      386         if nstk_items = 1
      387         then					/* special case of single function in expr */
      388 	   if data_stack.type (1) = SCAL_FUN then do;
      389 	       nexp_items_init = 1;
      390 	       allocate expr in (a_select_area_ptr -> select_area);
      391 	       expr.nitems = 1;
      392 	       unspec (expr.item (1)) = unspec (data_stack (1));
      393 	       data_stack.fn_ptr (1) = expr_ptr;
      394 	   end;
      395 
      396         exp_fun_data.loc_index = data_stack.loc_index (1);	/* fill in result info for caller */
      397         exp_fun_data.bit_length = data_stack.bit_length (1);
      398         exp_fun_data.descriptor = data_stack.desc (1);
      399         exp_fun_data.assn_ptr = data_stack.assn_ptr (1);
      400         exp_fun_data.ef_ptr = data_stack.fn_ptr (1);
      401 
      402         return;
      403 
      404 resolve_descs:
      405     proc (d1, d2) returns (bit (36) aligned);
      406 
      407 /* Procedure to determine whether to use complex or real float dec (59). */
      408 
      409 dcl     (d1, d2, rslt)	 bit (36) aligned;
      410 
      411         if mu_data_class$complex_data_class (addr (d1))
      412 	   | mu_data_class$complex_data_class (addr (d2))
      413         then
      414 	   rslt = CFLTD59;				/* if either input is complex */
      415         else rslt = RFLTD59;				/* if not */
      416         return (rslt);
      417 
      418     end resolve_descs;
      419 
      420 error:
      421     proc (cd, loud, stack_offset, error_type, message);
      422 
      423 dcl     cd		 fixed bin (35);		/* standard error code */
      424 dcl     loud		 bit (1) aligned;		/* OFF => dont print or signal error */
      425 dcl     stack_offset	 fixed bin;		/* offset from ls_top of where token is in lex stack */
      426 dcl     error_type		 char (*);
      427 dcl     message		 char (*);
      428 
      429         se_info_ptr = dbcb.se_info_ptr;
      430 
      431         code = cd;
      432 
      433         se_info.loud = loud;
      434         se_info.error_type = error_type;
      435         se_info.token_start = 0;
      436         se_info.stack_offset = stack_offset;		/* save this for semantics */
      437         se_info.error_msg = message;
      438         se_info.error_info_supplied = "1"b;		/* so no one else handles it */
      439 
      440         goto exit;
      441 
      442     end error;
      443 
  1     1 /* BEGIN mrds_dbcb.incl.pl1 -- jaw, 11/7/78 */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  1     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  1     8*     This entry is being made to cover the change made on 85-07-01 by Thanh
  1     9*     Nguyen. The scopes_changed flag was added to make checking for this
  1    10*     more efficient (mrds error list #137).
  1    11*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
  1    12*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
  1    13*     Add a bit called dont_check_txn_id to indicate whether or not we should
  1    14*     care if multiple txns use the same selection_expression. (mrds #156)
  1    15*  3) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  1    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  1    17*     Added parser_work_area_ptr and mrds_se_info_ptr for new parser.
  1    18*                                                   END HISTORY COMMENTS */
  1    19 
  1    20 
  1    21 /* WARNING
  1    22*          If the dbcb structure is changed then the mrds_data_
  1    23*          item saved_res_version MUST be incremented to invalidate all
  1    24*          existing saved resultants
  1    25**/
  1    26 
  1    27 /* HISTORY :
  1    28*
  1    29*   modified by Jim Gray - - 80-10-24, to add new_select_expr bit for
  1    30*   tid_list management
  1    31*
  1    32*   81-1-9 Jim Gray : added like reference for  ease  in  making  the
  1    33*   phony resultant in mu_database_index, without having the area dcl
  1    34*   included.
  1    35*
  1    36*   81-06-17 Roger Lackey :  added  last_store_rel_name  for  use  by
  1    37*   mrds_dsl_store
  1    38*
  1    39*   81-06-26 Roger Lackey : Added no_optimize and  print_search_order
  1    40*   switches
  1    41*
  1    42*   81-07-06 Jim Gray : added identifier for  the  current  selection
  1    43*   expression,  so  that relation statistics can be updated relative
  1    44*   to number of selection expressions seem. Also  removed  init  for
  1    45*   last_store_rel_name,   as   this   iw   now   properly   done  in
  1    46*   mrds_dsl_init_res.
  1    47*
  1    48*   81-07-17  Roger Lackey : added pred_ptr and unused_ptrs.
  1    49*
  1    50*   82-08-19  Mike Kubicar : added store_vector field.  This is needed
  1    51*   for the conversion to the relation manager.
  1    52*
  1    53*   82-08-23 Davids: added the relmgr_entries and access_costs
  1    54*   substructures so that the entries and costs can change
  1    55*   depending on the type of database that is opened.
  1    56*
  1    57*   82-09-09 Mike Kubicar : added modify_vector field.  This is needed
  1    58*   since modify uses a different vector type (general) than does store.
  1    59*
  1    60*   82-09-20 Davids: changed names of (store modify)_vector to
  1    61*   (store modify)_vector_ptr. Also (delete modify)_tuple_by_id to
  1    62*   (delete modify)_tuples_by_id. added the element cursor_storage_ptr
  1    63*   which should be inited to null and will be set by mu_cursor_manager_$get
  1    64*   during the first call.
  1    65*
  1    66*   82-09-21 Davids: renamed cursor_storage_ptr to cursor_ptrs_storage_ptr
  1    67*   since it deals with the pointers to the cursors and not the cursors
  1    68*   themelves and added the element cursor_storage_area_ptr which points
  1    69*   to the area where the cursors are kept.
  1    70*
  1    71*   82-09-22 Davids: renamed the transact_ctl_seg to transactions_needed.
  1    72*   the transact_ctl_seg always had a value of 0 and really didn't mean
  1    73*   anything.
  1    74*
  1    75*   82-09-22 Mike Kubicar : added create_relation, create_index and
  1    76*   destroy_relation_by_opening to relmgr_entries.  They are needed
  1    77*   by mrds_dsl_define_temp_rel.
  1    78*
  1    79*   82-09-24 Donna Woodka : added  put_tuple to  relmgr_entries. It
  1    80*   is needed by mu_store.
  1    81*
  1    82*   82-11-12 Davids: changed the declaration of the access_costs from fixed
  1    83*   bin to float bin since the values are not integers.
  1    84*
  1    85*   83-02-02 Davids: added the dbc_uid element. This will allow mrds to make
  1    86*   sure that the dbc_ptr still points to the correct segment. Element was 
  1    87*   added to the end of the structure to allow modules that don't use
  1    88*   the element to continue to reference the dbcb structure without recompiling.
  1    89*
  1    90*   83-02-25 Davids: added the concurrency_on and rollback_on elements. These
  1    91*   are needed so that temp rels can be created with the same file attributes
  1    92*   as the permanent relations.
  1    93*
  1    94*   83-05-02 Mike Kubicar : Deleted get_next_search_specification_ptr and
  1    95*   added the resultant_in_pdir bit.
  1    96*
  1    97*   83-05-18 Davids: reduced the number of reserved bits to 14 (from 15) and
  1    98*   added the res_already_made element.
  1    99*
  1   100*   83-05-24 Mike Kubicar : Updated the relation manager calling sequences.
  1   101*
  1   102*   83-08-03 Mike Kubicar : Added the element_id_list_segment_ptr and removed
  1   103*   one of the unused pointers.
  1   104*
  1   105*   83-09-20 Ron Harvey: Added relmgr_entries.get_population.
  1   106*
  1   107*   84-08-27 John Hergert:  Created compiled_se_info_ptr from unused_ptrs(2)
  1   108*   leaving unused_ptrs(1).
  1   109*
  1   110*   85-01-15 Thanh Nguyen:  Added the work_area_ptr and removed the last
  1   111*   unused_ptrs (1).
  1   112*
  1   113*   85-04-12 Thanh Nguyen:  Added user_started_transaction and 
  1   114*   non_shared_to_shared flags.  Also added se_transaction_id and some more
  1   115*   spare ptrs, entries and reserved storages for future enhancement, since
  1   116*   we changed the saved_res_version from rslt0001 to rslt0002.
  1   117*
  1   118*   85-07-01 Thanh Nguyen:  Added scopes_changed flag.  This flag is set by
  1   119*   common routine of mrds_dsl_set_scope, reset by mrds_dsl_optimize and 
  1   120*   mrds_dsl_gen_srch_prog when building of a new search_vars.
  1   121**/
  1   122 
  1   123 
  1   124 /* this structure is based on the {unique_name}.mrds.dbcb segment
  1   125*   that constitutes the non-secure portion of the resultant model that is
  1   126*   created during the opening of a database. it contains variables that
  1   127*   are used during the runtime access of the database, and an area
  1   128*   for evaluation of requests. it points to four other
  1   129*   segments in the resultant model, {unique_name}.mrds.rdbi, the secure
  1   130*   portion of the resultant(see mdbm_rm_db_info.incl.pl1),
  1   131*   {unique_name}.mrds.select, an area for selection expression evaluation,
  1   132*   {unique_name}.mrds.curdat, and {unique_name}.mrds.stadat, two segments
  1   133*   used in the elimination of duplicate tuples during a retrieve.
  1   134*   the dbcb area holds the structure in mdbm_scope_info.incl.pl1
  1   135*   that is used when the database is using the file scope mechanism
  1   136*   for concurrency control over file readying. the segment overlayed via
  1   137*   mrds_dbc.incl.pl1 structure is pointed to and also handles concurrency control,
  1   138*   across database openings. the pointer to this dbcb structure is kept in a table
  1   139*   which associates database indexes(returned from a call to dsl_$open), with particular
  1   140*   opening instances of resultant models. (see mu_database_index routine) */
  1   141 
  1   142      dcl	   1 dbcb		      aligned based (dbcb_ptr), /* DBCB -- non-secure portion */
  1   143 	     2 data	      like dbcb_data,
  1   144 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (dbcb.static_area))));
  1   145 
  1   146      dcl	   dbcb_ptr	      ptr;
  1   147 
  1   148      declare 1 dbcb_data	      based,		/* info part of dbcb, separated out so that
  1   149*						   like references can avoid getting the area declaration */
  1   150 	     2 rdbi_ptr	      ptr,		/* pointer to write protected mdbm_util_ info. */
  1   151 	     2 range_ptr	      ptr,		/*  ptr to range structure, or null */
  1   152 	     2 select_ptr	      ptr,		/* ptr to select list, or null */
  1   153 	     2 sv_ptr	      ptr,		/* pointer to search variables */
  1   154 	     2 so_ptr	      ptr,		/* pointer to search operators */
  1   155 	     2 ti_ptr	      ptr,		/* pointer to tuple info */
  1   156 	     2 lit_ptr	      ptr,		/* pointer to the literal area, or null */
  1   157 	     2 current_ptr	      ptr,		/* ptr to select list resulting from -current clause */
  1   158 	     2 ss_ptr	      ptr,		/* ptr to select sets block if not simple s.e. */
  1   159 	     2 retr_info_ptr      ptr,		/* ptr to retrieve info area */
  1   160 	     2 trel_info_ptr      ptr,		/* ptr to retrieve info area */
  1   161 	     2 sti_ptr	      ptr,		/* pointer to store info */
  1   162 	     2 dbc_ptr	      ptr,		/*  pointer to the data base control segment */
  1   163 	     2 sfi_ptr	      ptr,		/* points to head of scalar function list */
  1   164 	     2 scope_ptr	      ptr,		/* points to array of scope tuples */
  1   165 	     2 select_area_ptr    ptr,		/* ptr to area for current selection expression allocations */
  1   166 	     2 current_data_ptr   ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  1   167*						   for eliminating duplicate tuples. */
  1   168 	     2 static_data_ptr    ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  1   169*						   for eliminating duplicate tuples. */
  1   170 	     2 store_area_ptr     ptr,		/* temp storage area for dsl_$store */
  1   171 	     2 retrieve_area_ptr  ptr,		/* temp storage for dsl_$retrieve */
  1   172 	     2 modify_area_ptr    ptr,		/* temp storage area for dsl_$modify */
  1   173 	     2 delete_area_ptr    ptr,		/* temp storage area for dsl_$delete */
  1   174 	     2 def_temp_rel_area_ptr ptr,		/* temp storage area for dsl_$define_temp_rel */
  1   175 	     2 pred_ptr	      ptr,		/* Pointer to pred_array */
  1   176 	     2 store_vector_ptr   ptr,		/* Vector structure used during store operations */
  1   177 	     2 modify_vector_ptr  ptr,		/* Used during modifies */
  1   178 	     2 element_id_list_segment_ptr ptr,		/* Points to the segment used to hold element_id_list structures */
  1   179                2 compiled_se_info_ptr ptr,                  /* points to the segment containing all info on compiled sexs */
  1   180 	     2 work_area_ptr        ptr,		/* Work area for encode/decode value allocations in mu_retrieve */
  1   181 	     2 se_info_ptr          ptr,                  /* Points to se_info struct. Primarily for error reports */
  1   182 	     2 parser_work_area_ptr ptr,		/*  work area for parser */
  1   183 	     2 reserved_ptrs      (4) ptr,		/* Reserved for future use */
  1   184 	     2 another_flag	      bit (1) unal,		/* on if predicate was -another */
  1   185 	     2 current_flag	      bit (1) unal,		/* on if predicate was -current clause */
  1   186 	     2 dbc_incr	      bit (1) unal,		/* on if dbc open mode has been incremented for this user */
  1   187 	     2 delete_flag	      bit (1) unal,		/* On if search was called from mrds_dsl_sec_delete */
  1   188 	     2 dup_retain	      bit (1) unaligned,	/* On if dup tuples allowed for retrieval */
  1   189 	     2 prev_select	      bit (1) unal,		/* on if prev. select block processed in this s.e. */
  1   190 	     2 possible_op	      bit (1) unal,		/* on of arith op. allowed */
  1   191 	     2 sel_clause	      bit (1) unal,		/* on if currently in select clause */
  1   192 	     2 dsm_sw	      bit (1) unal,		/* on if data base was opened via data submodel */
  1   193 	     2 val_rtrv	      bit (1) unal,		/* if s.e. valid for retrieve */
  1   194 	     2 val_mod	      bit (1) unal,		/* for modify */
  1   195 	     2 val_del	      bit (1) unal,		/* for delete */
  1   196 	     2 val_dtr	      bit (1) unal,		/* for define temp rel */
  1   197 	     2 transactions_needed bit (1) unal,	/* On => transaction must be started or in progress does
  1   198*                                                                     not imply that the database is of type page_file */
  1   199 	     2 open_mode	      bit (3) unal,		/* 0=>unknown, 1=>r, 2=>u, 3=>er, 4=>eu, >4=>bad */
  1   200 	     2 new_select_expr    bit (1) unal,		/* on => starting a new tid list management period */
  1   201 	     2 no_optimize	      bit (1) unal,		/* On => no optimize */
  1   202 	     2 print_search_order bit (1) unal,		/*  On => print the search order */
  1   203 	     2 resultant_in_pdir  bit (1) unal,		/* On => Temp segments are in the process dir */
  1   204 	     2 res_already_made   bit (1) unal,           /* On => resultant has been made based on a saved copy */
  1   205 	     2 user_started_transaction bit (1) unal,     /* On => user already started his own transaction. */
  1   206 	     2 non_shared_to_shared bit (1) unal,         /* On => user changed the scope from non shared to shared
  1   207*						   inside a sequence of -another selection expression. */
  1   208 	     2 scopes_changed     bit (1) unal,           /* On => scopes had been changed by set_scopes or delete_scopes */
  1   209 	     2 dont_check_txn_id  bit (1) unal,           /* On => cpmd needs same selection exp across multiple txns */
  1   210 	     2 reserved	      bit (10) unal,	/* reserved for future use */
  1   211 	     2 nseq_sch	      fixed bin (35),	/* no. tuples located via sequential search */
  1   212 	     2 nind_sch	      fixed bin (35),	/* no. tuples located via index search */
  1   213 	     2 nhash_sch	      fixed bin (35),	/* no. tuples located via hash search */
  1   214 	     2 nlk_sch	      fixed bin (35),	/* no tuples located via link search */
  1   215 	     2 cur_lit_offset     fixed bin (35),	/* current bit offset in literal string */
  1   216 	     2 dbi	      fixed bin (35),	/* database index for this opening */
  1   217 	     2 last_s_e_id_num    fixed bin (35),	/* identifying number for last selection expression seen */
  1   218 	     2 se_transaction_id  bit (36) aligned,       /* transaction id from beginning of select expression */
  1   219 	     2 last_store_rel_name char (32),		/* Name of relation last used  for store */
  1   220 	     2 cursor_ptrs_storage_ptr ptr,		/* pointer to space where cursor ptrs are stored */
  1   221 	     2 cursor_storage_area_ptr ptr,		/* pointer to area where the cursors are kept */
  1   222 	     2 reserved_words     (10) fixed bin (35),	/* Reserved for future use */
  1   223 	     2 relmgr_entries,			/* relation manager entries */
  1   224 	       3 open	      entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  1   225 	       3 close	      entry (bit (36) aligned, fixed bin (35)),
  1   226 	       3 create_cursor    entry (bit (36) aligned, ptr, ptr, fixed bin (35)),
  1   227 	       3 destroy_cursor   entry (ptr, ptr, fixed bin (35)),
  1   228 	       3 set_scope	      entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35)),
  1   229 	       3 delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  1   230 	       3 modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35)),
  1   231 	       3 get_tuple_by_id  entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  1   232 	       3 get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)),
  1   233 	       3 get_tuple_id     entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  1   234 	       3 put_tuple	      entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  1   235 	       3 get_count	      entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  1   236 	       3 get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35)),
  1   237 	       3 get_population   entry (ptr, fixed bin (35), fixed bin (35)),
  1   238 	       3 create_relation  entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)),
  1   239 	       3 create_index     entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35)),
  1   240 	       3 destroy_relation_by_path entry (char (*), char (*), fixed bin (35)),
  1   241 	       3 reserved_entries (5) entry (),
  1   242 	     2 access_costs,			/* access costs for permute */
  1   243 	       3 total_primary_key_cost float bin,
  1   244 	       3 access_cost      float bin,
  1   245 	       3 access_overhead  float bin,
  1   246 	       3 us_access_cost   float bin,
  1   247 	       3 os_access_cost   float bin,
  1   248 	     2 dbc_uid	      bit (36) aligned,	/* uid of the segment containing the dbc structure */
  1   249 	     2 concurrency_on     bit (1) unal,		/* "1"b implies dmfile concurrency is being used */
  1   250 	     2 rollback_on	      bit (1) unal;		/* "1"b iomplies before journaling is to be done */
  1   251 
  1   252 /* END mrds_dbcb.incl.pl1 */
  1   253 
  1   254 
      444 
      445 
  2     1 /* BEGIN INCLUDE FILE  mrds_se_info.incl.pl1 
  2     2*
  2     3*   These contains information relating to the selection expression.
  2     4*
  2     5**/
  2     6 
  2     7 /****^  HISTORY COMMENTS:
  2     8*  1) change(85-08-05,Hergert), approve(88-06-28,MCR7903),
  2     9*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  2    10*     Created for for new parser.
  2    11*                                                   END HISTORY COMMENTS */
  2    12 
  2    13 dcl     1 se_info		 aligned based (se_info_ptr),
  2    14 	2 se_ptr		 ptr,			/* points to the beginning of the selection expression */
  2    15 	2 se_length	 fixed bin,		/* length of the selection expression */
  2    16 	2 se_cursor	 fixed bin,		/* current place in se */
  2    17 	2 flags,
  2    18 	  3 pso_seen	 bit,			/* -pso supplied in se */
  2    19 	  3 no_ot_seen	 bit,			/* -no_ot supplied in se */
  2    20           2 error_report,
  2    21 	  3 error_info_supplied bit aligned,              /* ON -> structure already filled in */
  2    22 	  3 loud             bit aligned,                	/* ON -> call mu_print_error */
  2    23             3 token_start      fixed bin,                   /* position in se where token starts */
  2    24             3 token_length     fixed bin,                   /* length of token in se */
  2    25 	  3 error_code       fixed bin(35),               /* system error code */
  2    26             3 stack_offset     fixed bin,                   /* how far down the token is in the lex stack */
  2    27             3 error_type       char(24),                    /* type of error. ie range, select where... */
  2    28 	  3 error_msg        char(256);         	/* message to explain problem */
  2    29 
  2    30 
  2    31 /* various types of errors. actually the string that is reported in the
  2    32*   error message. */
  2    33 dcl     RC_TYPE		 char (12) internal static
  2    34 			 options (constant) init ("Range Clause");
  2    35 dcl     SE_TYPE		 char (20) internal static
  2    36 			 options (constant)
  2    37 			 init ("Selection Expression");
  2    38 dcl     SC_TYPE		 char (13) internal static
  2    39 			 options (constant)
  2    40 			 init ("Select Clause");
  2    41 dcl     WC_TYPE		 char (12) internal static
  2    42 			 options (constant)
  2    43 			 init ("Where Clause");
  2    44 dcl     WCE_TYPE		 char (23) internal static
  2    45 			 options (constant)
  2    46 			 init ("Where Clause Expression");
  2    47 dcl     WCF_TYPE		 char (21) internal static
  2    48 			 options (constant)
  2    49 			 init ("Where Clause Function");
  2    50 dcl     AV_TYPE		 char (16) internal static
  2    51 			 options (constant)
  2    52 			 init ("Access Violation");
  2    53 dcl     IL_TYPE		 char (14) internal static
  2    54 			 options (constant)
  2    55 			 init ("Internal Logic");
  2    56 
  2    57 /* parser_work_area is used to hold all static data for an invocation
  2    58*   of the parser. parser_static_info holds ptrs to all of these relevant
  2    59*   data and also a ptr back to the area it is allocated in. 
  2    60*   parser_work_area.
  2    61**/
  2    62 
  2    63 dcl parser_work_area aligned area (sys_info$max_seg_size) based (parser_static_info.pwa_ptr);
  2    64 
  2    65 dcl psi_ptr ptr;
  2    66 dcl 1 parser_static_info aligned based (psi_ptr),
  2    67       2 pwa_ptr ptr,
  2    68       2 semantics, /* for mrds_dsl_semantics */
  2    69         3 static_data_ptr ptr,
  2    70       2 expr, /* for mrds_dsl_expr_ */
  2    71         3 data_stacks_ptr ptr,
  2    72       2 func, /* for mrds_dsl_func_ */
  2    73         3 sfptrs_ptr ptr,
  2    74       2 where_clause, /* for mrds_dsl_where_clause_ */
  2    75         3 ns_ptr ptr;
  2    76 
  2    77 
  2    78 /* END INCLUDE FILE  mrds_se_info.incl.pl1 */
      446 
      447 
  3     1 /* BEGIN INCLUDE FILE mrds_exp_fun_data.incl.pl1 -- jaw 5/20/77 */
  3     2 
  3     3 /* HISTORY:
  3     4*
  3     5*   81-06-01 Jim Gray : removed assn len and type entries,
  3     6*   now that mu_convert is being used.
  3     7*
  3     8**/
  3     9 
  3    10 
  3    11 dcl 1 exp_fun_data based (efd_ptr),			/* data for expression or function */
  3    12     2 var_index fixed bin,				/* index of assoc. tuple variable */
  3    13     2 loc_index fixed bin (18),			/* bit offset within literal pool for result */
  3    14     2 bit_length fixed bin (18),			/* bit length of expr. result */
  3    15     2 descriptor bit (36),				/* descriptor of expr. result */
  3    16     2 assn_ptr ptr,					/* pointer to storage location */
  3    17     2 ef_ptr ptr;					/* pointer to expression structure */
  3    18 
  3    19 dcl  efd_ptr ptr;
  3    20 
  3    21 /* END INCLUDE FILE mrds_exp_fun_data.incl.pl1 */
  3    22 
      448 
      449 
  4     1 /* BEGIN INCLUDE FILE mrds_expressions.incl.pl1 -- jaw 2/15/79 */
  4     2 
  4     3 /* HISTORY:
  4     4*
  4     5*   81-06-01 Jim Gray : removed assn len and type elements
  4     6*   since mu_covnert is now being used.
  4     7*
  4     8**/
  4     9 
  4    10 
  4    11 dcl 1 expr aligned based (expr_ptr),			/* internal representation of an expression,
  4    12*						   expression is stored in postfix polish form */
  4    13     2 nitems fixed bin,				/* no. items in expression */
  4    14     2 item (nexp_items_init refer (expr.nitems)),
  4    15       3 type fixed bin (3) unal,			/* 1 => data item
  4    16*						   2 => operator
  4    17*						   3 => scalar function */
  4    18       3 op_code fixed bin (3) unal,			/* 1 => add
  4    19*						   2 => subtract
  4    20*						   3 => multiply
  4    21*						   4 => divide */
  4    22       3 data_type fixed bin (2) unal,			/* 1 => literal
  4    23*						   2 => database */
  4    24       3 reserved bit (25) unal,
  4    25       3 desc bit (36),				/* data descriptor of data item or fun. result */
  4    26       3 loc_index fixed bin (18),			/* location index of data item or fun. result */
  4    27       3 bit_length fixed bin (18),			/* bit length of data item or fun. result */
  4    28       3 assn_ptr ptr,				/* pointer to item storage loc. */
  4    29       3 ai_ptr ptr,					/* to attr info if database item */
  4    30       3 fn_ptr ptr;					/* pointer to function structure if scalar function */
  4    31 
  4    32 dcl  expr_ptr ptr;
  4    33 dcl  nexp_items_init fixed bin;
  4    34 
  4    35 dcl 1 scalfn aligned based (sfn_ptr),			/* internal representation of a scalar function */
  4    36     2 entry_ptr ptr,				/* pointer to entry to be called */
  4    37     2 arg_list_ptr ptr,				/* pointer to arg list to be used for calling function */
  4    38     2 rslt_desc bit (36),				/* descriptor for result */
  4    39     2 nargs fixed bin,				/* number of input args */
  4    40     2 arg (nsf_args_init refer (scalfn.nargs)),		/* arg info */
  4    41       3 type fixed bin (3) unal,			/* 1 => literal
  4    42*						   2 => database
  4    43*						   3 => scalar function
  4    44*						   4 => expression */
  4    45       3 must_convert bit (1) unal,			/* on if arg must be converted to match requirements */
  4    46       3 reserved bit (31) unal,
  4    47       3 desc bit (36),				/* descriptor of data or result */
  4    48       3 loc_index fixed bin (18),			/* location index of data item or result */
  4    49       3 bit_length fixed bin (18),			/* bit length of data item or result */
  4    50       3 assn_ptr ptr,				/* pointer to item storage loc. */
  4    51       3 arg_desc bit (36),				/* descriptor for arg if must convert */
  4    52       3 arg_assn_ptr ptr,				/* assign_ ptr for arg in must convert */
  4    53       3 ai_ptr ptr,					/* to attr info if database item */
  4    54       3 ef_ptr ptr;					/* pointer to expression or function structure, or null */
  4    55 
  4    56 dcl  sfn_ptr ptr;
  4    57 dcl  nsf_args_init fixed bin;
  4    58 
  4    59 dcl ((DATA init (1)),
  4    60     (OPERATOR init (2)),
  4    61     (SCAL_FUN init (3)),
  4    62     (EXPR init (4)),
  4    63     (ADD init (1)),
  4    64     (SUBT init (2)),
  4    65     (MULT init (3)),
  4    66     (DIV init (4)),
  4    67     (LITERAL init (1)),
  4    68     (DATABASE init (2))) fixed bin int static options (constant);
  4    69 
  4    70 dcl  CFLTD59 bit (36) aligned int static options (constant)
  4    71      init ("100110000000000000000000000000111011"b);
  4    72 dcl  RFLTD59 bit (36) aligned int static options (constant)
  4    73      init ("100101000000000000000000000000111011"b);
  4    74 
  4    75 /* END INCLUDE FILE mrds_expressions.incl.pl1 */
  4    76 
      450 
      451 
  5     1 /* BEGIN mdbm_descriptor.incl.pl1 -- jaw 5/31/78 */
  5     2 /* modified by Jim Gray - - Nov. 1979, to change type from fixed bin(5) to
  5     3*   unsigned fixed bin(6), so new packed decimal data types could be handled.
  5     4*   also the duplicate mrds_descriptor.incl.pl1 was eliminated. */
  5     5 
  5     6 dcl 1 descriptor based (desc_ptr),			/* map of Multics descriptor */
  5     7     2 version bit (1) unal,				/* DBM handles vers. 1 only */
  5     8     2 type unsigned fixed bin (6) unal,			/* data type */
  5     9     2 packed bit (1) unal,				/* on if data item is packed */
  5    10     2 number_dims bit (4) unal,			/* dimensions */
  5    11     2 size,					/* size for string data */
  5    12       3 scale bit (12) unal,				/* scale for num. data */
  5    13       3 precision bit (12) unal,			/* prec. for num. data */
  5    14     2 array_info (num_dims),
  5    15       3 lower_bound fixed bin (35),			/* lower bound of dimension */
  5    16       3 upper_bound fixed bin (35),			/* upper bound of dimension */
  5    17       3 multiplier fixed bin (35);			/*  element separation */
  5    18 
  5    19 dcl  desc_ptr ptr;
  5    20 dcl  num_dims fixed bin init (0) ;			/* more useful form of number_dims */
  5    21 
  5    22 /* END mdbm_descriptor.incl.pl1 */
  5    23 
  5    24 
      452 
      453 
  6     1 /* BEGIN mrds_lit_info.incl.pl1 -- jaw, 2/13/79 */
  6     2 
  6     3 /* HISTORY:
  6     4*
  6     5*   81-05-06  Rickie  E.  Brinegar: The declaration encd_ptr ptr was changed to
  6     6*   encd_entry  entry  and encd_proc bit (1) and pad bit (35) were added.  This
  6     7*   was  done  inoder to permit make use of cu_$generate call and eliminate the
  6     8*   use of cv_ptr_ to generate entry pointers.
  6     9*
  6    10*   81-06-01 Jim Gray : removed assn_len and ass_len structure elements,
  6    11*   as these are not used, with the advent of mu_convert.
  6    12*
  6    13**/
  6    14 
  6    15 dcl 1 lit_info aligned based (lip),			/* info for make literal call */
  6    16     2 src_ptr ptr,					/* to literal source data */
  6    17     2 srcd_ptr ptr,					/* to literal source descr. */
  6    18     2 encd_entry entry,				/* to encode proc. entry */
  6    19     2 encd_proc bit (1) unal,				/* does an encode proc exist? */
  6    20     2 pad bit (35) unal,
  6    21     2 encdd_ptr ptr,				/* to descr. for input to encode proc */
  6    22     2 litd_ptr ptr,					/* to descr. to final liter. val. */
  6    23     2 lit_ptr ptr,					/* to final literal value */
  6    24     2 encd_blen fixed bin (35),			/* to bit length for encode proc input */
  6    25     2 lit_blen fixed bin (35),			/* to bit length for final literal */
  6    26     2 lit_offset fixed bin (35);			/* to offset for final literal in lit. pool */
  6    27 
  6    28 dcl  lip ptr;
  6    29 
  6    30 /* END mrds_lit_info.incl.pl1 */
  6    31 
      454 
      455 
  7     1 /*  BEGIN  mdbm_rm_attr_info.incl.pl1  --  jaw,  11/16/78  */
  7     2 
  7     3 /* WARNING
  7     4*          If the rm_attr_info structure is changed then the mrds_data_
  7     5*          item saved_res_version MUST be incremented to invalidate all
  7     6*          existing saved resultants
  7     7**/
  7     8 
  7     9 /*
  7    10*
  7    11*   Modified  by  Jim  Gray - - 80-11-05, to add mdbm_secured bit, so
  7    12*   that rm_rel_info does not have to be checked
  7    13*
  7    14*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
  7    15*   foreign keys.
  7    16*
  7    17*   82-08-19  D. Woodka : removed rm_attr_info.bit_offset for the DMS
  7    18*   conversion.
  7    19*
  7    20*   82-09-15 Davids: added the number_of_dups field.
  7    21*
  7    22*   82-09-20 Mike Kubicar : changed the index_id field to be bit (36)
  7    23*   aligned.  This is to conform with the new definition in the database
  7    24*   model.  Also removed the now useless field varying.
  7    25*
  7    26*   82-11-05 Davids: added the field model_defn_order and clarified the
  7    27*   comment for the field defn_order.
  7    28*
  7    29*   83-05-23 Mike Kubicar : changed number_of_dups to fixed bin (35) since
  7    30*   that's what relation manager returns.
  7    31*
  7    32**/
  7    33 
  7    34 
  7    35 /*
  7    36*   this   structure   is   allocated   in   the   static   area   of
  7    37*   mdbm_rm_db_info.incl.pl1  once for each attribute per relation in
  7    38*   a     readied     file.      it     in     turn     points     to
  7    39*   mdbm_rm_domain_info.incl.pl1  for  the  attributes  domain.   the
  7    40*   rm_attr_info  is  pointed  to  by mdbm_rm_rel_info.incl.pl1.  all
  7    41*   structures  are  in  the  rm_db_info  area.   the  attribute data
  7    42*   position  within  a  tuple as stored in the data file are kept in
  7    43*   this resultant model of the attribute.
  7    44* */
  7    45 
  7    46 dcl 1 rm_attr_info aligned based (rai_ptr),		/* resultant attr. info */
  7    47     2 name char (32),				/* from submodel */
  7    48     2 model_name char (32),				/* from model */
  7    49     2 key_attr bit (1) unal,				/* if key attribute */
  7    50     2 index_attr bit (1) unal,			/* if secondary index */
  7    51     2 read_perm bit (1) unal,				/* user has retr. permission */
  7    52     2 modify_perm bit (1) unal,			/* user has modify permission */
  7    53     2 mdbm_secured bit (1) unal,			/* on => database secured */
  7    54     2 reserved bit (30) unal,				/* for future use */
  7    55     2 index_id bit (36) aligned,			/* index id if index_attr */
  7    56     2 defn_order fixed bin,				/* relative order in which attr is defined in the view */
  7    57     2 key_order fixed bin,				/* relative order defined in prim. key */
  7    58     2 bit_length fixed bin (35),			/* length if fixed, max. len. if var. */
  7    59     2 domain_ptr ptr,				/* to domain info */
  7    60     2 number_of_dups fixed bin (35),                        /* if the attribute is indexed this will
  7    61*                                                               be the number of duplicate values, exact
  7    62*                                                               for a page_file database, an estimate for a vfile type */
  7    63     2 model_defn_order fixed bin;                           /* relative order in which attr is defined in the model */
  7    64 
  7    65 dcl  rai_ptr ptr int automatic init (null ());
  7    66 
  7    67 /* END mdbm_rm_attr_info.incl.pl1 */
  7    68 
  7    69 
      456 
      457 
  8     1 /* BEGIN mdbm_rm_domain_info.incl.pl1 -- jaw, 9/26/78 */
  8     2 
  8     3 /* WARNING
  8     4*          If the rm_domain_info structure is changed then the mrds_data_
  8     5*          item saved_res_version MUST be incremented to invalidate all
  8     6*          existing saved resultants
  8     7**/
  8     8 
  8     9 /* DESCRIPTION:
  8    10*
  8    11*   This  structure  is  allocated  in  the  mdbm_rm_db_info.incl.pl1
  8    12*   static  area,  once per attribute used in a relation in a readied
  8    13*   file. it is pointed to by the mdbm_rm_attr_info.incl.pl1, and may
  8    14*   point  to  mdbm_rm_ck_and_group.incl.pl1  if  a  "-check"  option
  8    15*   boolean expression was declared for this domain. it contains  the
  8    16*   descriptor  for  this domain data type, and other resultant model
  8    17*   information.
  8    18*
  8    19*
  8    20*   HISTORY:
  8    21*
  8    22*   81-05-06  Rickie  E.  Brinegar:  Modified  ck_proc,  encode_proc,
  8    23*   decode_proc to be entry variables instead of entry pointers. This
  8    24*   allows these programs to be written in languages other than pl1.
  8    25*
  8    26*   81-05-28 Jim Gray : removed unused procedure points,  and  unused
  8    27*   check  stack  structure  elements.  Also made the descriptors bit
  8    28*   (36) in this structure, rather than pointers to  the  descriptors
  8    29*   elsewhere.  Also  removed un-needed redundant assign_ parameters,
  8    30*   that are actually available in the descriptors.
  8    31*
  8    32*
  8    33**/
  8    34 
  8    35 dcl 1 rm_domain_info aligned based (rdi_ptr),		/* domain information */
  8    36     2 name char (32),				/* domain name */
  8    37     2 db_desc bit (36),				/*  to desc. for db. */
  8    38     2 user_desc bit (36),				/* desc for user visible data */
  8    39     2 user_bit_len fixed bin,				/* storage length of users data */
  8    40     2 ck_proc_entry entry variable,			/* to check proc. entry */
  8    41     2 encd_proc_entry entry variable,			/* to encode proc entry */
  8    42     2 decd_proc_entry entry variable,			/* to decode proc entry */
  8    43     2 ck_proc bit (1) unal,				/* Is there a check proc */
  8    44     2 encd_proc bit (1) unal,				/* Is there an encode proc */
  8    45     2 decd_proc bit (1) unal,				/* Is there a decode proc */
  8    46     2 pad bit (33) unal,
  8    47     2 next_domain_ptr ptr ;				/* to next domain, in list of all domains */
  8    48 						/* to check stack and groups */
  8    49 
  8    50 
  8    51 dcl  rdi_ptr ptr int automatic init (null ());
  8    52 
  8    53 /* END mdbm_rm_domain_info.incl.pl1 */
  8    54 
  8    55 
      458 
      459 
  9     1 /* BEGIN mrds_range.incl.pl1 -- jaw, 10/20/78 */
  9     2 
  9     3 /* Modified 83-04-22 by R. Harvey to add needed_bits */
  9     4 
  9     5 dcl 1 range aligned based (range_ptr),
  9     6     2 num_vars fixed bin,				/* number of tuple variables */
  9     7     2 tup_var (mrds_data_$max_tup_var refer (range.num_vars)), /* info for each tuple variable */
  9     8       3 name char (mrds_data_$max_id_len),		/* name of tuple variable */
  9     9       3 temp_rel bit (1) unal,			/* on if temporary relation */
  9    10       3 used bit (1) unal,				/* 1 => this tuple variable is referenced by
  9    11*						   a -select clause. */
  9    12       3 whole_tuple_selected bit (1) unal,		/* the whole tuple variable is referenced in the select clause */
  9    13       3 copy_for_current bit (1) unal,			/* -current requests attributes not previously retrieved */
  9    14       3 copied_for_current bit (1) unal,		/* tuple copied during previous -current */
  9    15       3 reserved bit (31) unal,			/* reserved for future use */
  9    16       3 rel_index fixed bin,				/* index to assoc. relation */
  9    17       3 stv_ptr ptr,				/* simple typed vector */
  9    18       3 idl_ptr ptr,				/* id_list ptr */
  9    19       3 needed_bits aligned,
  9    20         4 attr (mrds_data_$max_attributes) bit (1) unal,
  9    21       3 ri_ptr ptr;					/* pointer to rel info for assoc. relation */
  9    22 
  9    23 dcl  range_ptr ptr;
  9    24 
  9    25 /* END mrds_range.incl.pl1 */
  9    26 
      460 
      461 
 10     1 /* BEGIN INCLUDE FILE mdbm_seg_area.incl.pl1 - - Jim Gray 2/19/79 */
 10     2 
 10     3 /* these structures provide a standard for
 10     4*   1) using an entire segment as an area, managed by the area manager
 10     5*   2) a constant header, that has an offset to the major common structure in the area
 10     6*   the pointer to that structure is obtained via pointer(model_seg_ptr, model_seg.offset)
 10     7*   the model_area_ptr is obtained via pointer(model_seg_ptr, size(model_seg)) */
 10     8 
 10     9 declare 1 model_seg aligned based (model_seg_ptr),	/* segment header, not to be changed */
 10    10         2 struct_offset bit (18),			/* offset to major structure allocated in area */
 10    11         2 padding (3) fixed bin ;			/* to set up four word boundary */
 10    12 
 10    13 declare  model_seg_ptr ptr int automatic init (null ());
 10    14 
 10    15 
 10    16 declare  model_area area (sys_info$max_seg_size - size (model_seg)) based (model_area_ptr) ; /* segment area */
 10    17 
 10    18 declare  model_area_ptr ptr int automatic init (null ());
 10    19 
 10    20 dcl size builtin;
 10    21 
 10    22 /* END INCLUDE FILE mdbm_seg_area.incl.pl1 */
 10    23 
      462 
      463 
 11     1 /* BEGIN INCLUDE FILE mrds_select_area.incl.pl1   (Kepner Multics)  05/29/79 1736.1 mst Tue */
 11     2 dcl 1 select_area_struct aligned based (select_area_struct_ptr), /* major structure in segment for current selection expression allocations */
 11     3     2 version fixed bin,
 11     4     2 dbcb_ptr ptr;					/* ptr ptr to dbcb */
 11     5 
 11     6 dcl  select_area_struct_ptr ptr int automatic init (null ());
 11     7 
 11     8 dcl  select_area area (sys_info$max_seg_size - size(model_seg)) based (select_area_ptr);
 11     9 
 11    10 dcl  select_area_ptr ptr int automatic init (null ());
 11    11 						/*   END INCLUDE FILE mrds_select_area.incl.pl1 */
 11    12 
      464 
      465 
      466 dcl     expr_ptr1		 ptr;			/* another pointer to expr */
      467 
      468 dcl     code		 fixed bin (35);
      469 dcl     bit36		 bit (36) based;
      470 dcl     1 li		 aligned like lit_info;
      471 
      472 dcl     nstk_items		 fixed bin
      473 			 based (addr (data_stacks.stack_top (level)));
      474 						/* current number of items in data stack */
      475 dcl     level		 fixed bin (17);
      476 dcl     1 data_stack	 (mrds_data_$max_expr_stack_size) aligned like expr.item
      477 			 based (addr (data_stacks.stack (level, 1)));
      478 
      479 dcl     1 data_stacks	 (mrds_data_$max_nested_expr)
      480 			 aligned based (parser_static_info.data_stacks_ptr),
      481 	2 stack_top	 fixed bin,
      482 	2 stack		 (mrds_data_$max_expr_stack_size)
      483 			 aligned like expr.item;
      484 
      485 dcl     CHAR_VAR_TYPE	 fixed bin (5) int static options (constant)
      486 			 init (22);
      487 dcl     CHAR_TYPE		 fixed bin (5) int static options (constant)
      488 			 init (21);
      489 
      490 
      491 
      492 dcl     (
      493         mrds_data_$max_attributes,
      494         mrds_data_$max_id_len,
      495         mrds_data_$max_expr_stack_size,
      496         mrds_data_$max_expr_items,
      497         mrds_data_$max_nested_expr,
      498         mrds_error_$expr_stack_ovfl,
      499         mrds_error_$max_expr_items,
      500         mdbm_error_$inc_attr_acc,
      501         sys_info$max_seg_size
      502         )			 fixed bin (35) ext;
      503 
      504 dcl     (null, addr, fixed, string, index, unspec, rel)
      505 			 builtin;
      506 
      507 dcl     mrds_dsl_make_literal	 entry (ptr, ptr, fixed bin (35));
      508 dcl     mrds_dsl_make_literal$alloc
      509 			 entry (ptr, ptr, fixed bin (35));
      510 dcl     mu_data_class$complex_data_class
      511 			 entry (ptr) returns (bit (1) aligned);
      512 						/* returns true if
      513*						   descriptor pointed to = complex numeric */
      514 dcl     char_sw		 bit (1) aligned;
      515 dcl     LOUD		 bit (1) aligned internal static
      516 			 options (constant) init ("1"b);
      517 dcl     OPERATOR_LIST	 char (4) aligned internal static
      518 			 options (constant) init ("+-*/");
      519 dcl     se_info_ptr		 ptr;
      520 dcl     a_select_area_ptr      ptr;
      521 exit:
      522     end mrds_dsl_expr_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/01/88  1300.0  mrds_dsl_expr_.pl1                >special_ldd>install>MR12.2-1073>mrds_dsl_expr_.pl1
444          1    08/01/88  1300.0  mrds_dbcb.incl.pl1                >special_ldd>install>MR12.2-1073>mrds_dbcb.incl.pl1
446          2    08/01/88  1300.0  mrds_se_info.incl.pl1             >special_ldd>install>MR12.2-1073>mrds_se_info.incl.pl1
448          3    10/14/83  1608.9  mrds_exp_fun_data.incl.pl1        >ldd>include>mrds_exp_fun_data.incl.pl1
450          4    10/14/83  1608.9  mrds_expressions.incl.pl1         >ldd>include>mrds_expressions.incl.pl1
452          5    10/14/83  1608.6  mdbm_descriptor.incl.pl1          >ldd>include>mdbm_descriptor.incl.pl1
454          6    10/14/83  1609.1  mrds_lit_info.incl.pl1            >ldd>include>mrds_lit_info.incl.pl1
456          7    10/14/83  1609.1  mdbm_rm_attr_info.incl.pl1        >ldd>include>mdbm_rm_attr_info.incl.pl1
458          8    10/14/83  1609.1  mdbm_rm_domain_info.incl.pl1      >ldd>include>mdbm_rm_domain_info.incl.pl1
460          9    10/14/83  1609.1  mrds_range.incl.pl1               >ldd>include>mrds_range.incl.pl1
462         10    10/14/83  1608.6  mdbm_seg_area.incl.pl1            >ldd>include>mdbm_seg_area.incl.pl1
464         11    10/14/83  1608.6  mrds_select_area.incl.pl1         >ldd>include>mrds_select_area.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
AV_TYPE                         000003 constant        char(16)                 initial packed unaligned dcl 2-50 set ref 145*
CFLTD59                         000002 constant        bit(36)                  initial dcl 4-70 set ref 199 206 213 411
CHAR_TYPE                              constant        fixed bin(5,0)           initial dcl 487 ref 206
CHAR_VAR_TYPE                          constant        fixed bin(5,0)           initial dcl 485 ref 199
DATA                                   constant        fixed bin(17,0)          initial dcl 4-59 ref 168 219
DATABASE                               constant        fixed bin(17,0)          initial dcl 4-59 ref 170
EXPR                                   constant        fixed bin(17,0)          initial dcl 4-59 ref 262 262 271 280 280 311
LITERAL                                constant        fixed bin(17,0)          initial dcl 4-59 ref 221
LOUD                            000021 constant        bit(1)                   initial dcl 515 set ref 111* 138* 145* 163* 191*
                                                                                  240* 288* 321* 361*
OPERATOR                               constant        fixed bin(17,0)          initial dcl 4-59 ref 368
OPERATOR_LIST                   000000 constant        char(4)                  initial dcl 517 ref 369
RFLTD59                         000001 constant        bit(36)                  initial dcl 4-72 set ref 204 211 216 415
SCAL_FUN                               constant        fixed bin(17,0)          initial dcl 4-59 ref 118 386
WCE_TYPE                        000007 constant        char(23)                 initial packed unaligned dcl 2-44 set ref 111* 138*
                                                                                  163* 191* 240* 288* 321* 361*
a_ptr                                  parameter       pointer                  dcl 186 ref 181 199 206 233
a_select_area_ptr                      parameter       pointer                  dcl 520 ref 251 261 382 390
addr                                                   builtin function         dcl 504 ref 104 111 117 117 118 118 119 119 119 119
                                                                                  121 121 122 122 123 123 124 124 125 125 126 126
                                                                                  138 160 162 162 167 167 168 168 169 169 170 170
                                                                                  171 171 172 172 173 173 174 174 175 175 176 176
                                                                                  191 195 195 199 204 206 211 213 216 219 219 220
                                                                                  220 221 221 222 222 222 222 225 225 229 229 239
                                                                                  239 244 244 245 245 246 246 262 262 262 262 269
                                                                                  269 270 270 271 271 272 272 273 273 274 274 274
                                                                                  274 274 274 277 277 280 280 280 280 283 283 286
                                                                                  286 303 303 303 303 303 303 306 306 311 311 312
                                                                                  313 316 317 320 330 339 343 343 343 346 346 346
                                                                                  346 346 350 350 358 358 358 360 360 364 364 365
                                                                                  365 366 366 371 371 372 372 373 373 375 375 386
                                                                                  386 392 393 396 397 398 399 400 411 411 411 411
ai_ptr                    6            based           pointer                  array level 2 in structure "data_stack" dcl 476
                                                                                  in procedure "mrds_dsl_expr_" set ref 125* 175*
                                                                                  222* 272*
ai_ptr                                 parameter       pointer                  dcl 134 in procedure "mrds_dsl_expr_" ref 131 144
                                                                                  175
ai_ptr                   10            based           pointer                  array level 3 in structure "expr" dcl 4-11
                                                                                  in procedure "mrds_dsl_expr_" set ref 377*
assn_ptr                  6            based           pointer                  array level 3 in structure "expr" dcl 4-11
                                                                                  in procedure "mrds_dsl_expr_" set ref 375*
assn_ptr                  4            based           pointer                  array level 2 in structure "data_stack" dcl 476
                                                                                  in procedure "mrds_dsl_expr_" set ref 124* 174*
                                                                                  246* 366* 375 399
assn_ptr                  4            based           pointer                  level 2 in structure "exp_fun_data" dcl 3-11
                                                                                  in procedure "mrds_dsl_expr_" set ref 124 399*
attr                                   based           bit(1)                   array level 4 packed packed unaligned dcl 9-5 set
                                                                                  ref 154*
bit36                                  based           bit(36)                  packed unaligned dcl 469 ref 171 225 229
bit_length                2            based           fixed bin(18,0)          level 2 in structure "exp_fun_data" dcl 3-11
                                                                                  in procedure "mrds_dsl_expr_" set ref 123 397*
bit_length                3            based           fixed bin(18,0)          array level 2 in structure "data_stack" dcl 476
                                                                                  in procedure "mrds_dsl_expr_" set ref 123* 173*
                                                                                  245* 365* 373 397
bit_length                5            based           fixed bin(18,0)          array level 3 in structure "expr" dcl 4-11
                                                                                  in procedure "mrds_dsl_expr_" set ref 373*
cd                                     parameter       fixed bin(35,0)          dcl 423 ref 420 431
char_sw                                parameter       bit(1)                   dcl 514 ref 181 198 224
code                                   parameter       fixed bin(35,0)          dcl 468 set ref 108 128* 131 162* 163 163* 178* 181
                                                                                  239* 240 240* 248* 251 360* 361 361* 379* 431*
d1                                     parameter       bit(36)                  dcl 409 set ref 404 411 411
d2                                     parameter       bit(36)                  dcl 409 set ref 404 411 411
d_ptr                                  parameter       pointer                  dcl 186 set ref 181 197 199 206 213* 225 226 234
data                                   based           structure                level 2 dcl 1-142
data_stack                             based           structure                array level 1 dcl 476 set ref 269 270 330 339 346*
                                                                                  346 392
data_stacks                            based           structure                array level 1 dcl 479 set ref 101
data_stacks_ptr           4            based           pointer                  level 3 dcl 2-66 set ref 101* 102 104 111 117 117
                                                                                  118 118 119 119 119 119 121 121 122 122 123 123
                                                                                  124 124 125 125 126 126 138 167 167 168 168 169
                                                                                  169 170 170 171 171 172 172 173 173 174 174 175
                                                                                  175 176 176 191 195 195 219 219 220 220 221 221
                                                                                  222 222 222 222 225 225 229 229 244 244 245 245
                                                                                  246 246 262 262 262 262 269 269 270 270 271 271
                                                                                  272 272 273 273 274 274 274 274 274 274 277 277
                                                                                  280 280 280 280 283 283 286 286 303 303 303 303
                                                                                  303 303 306 306 311 311 312 313 316 317 320 330
                                                                                  339 343 343 343 346 346 346 346 346 350 350 358
                                                                                  358 364 364 365 365 366 366 371 371 372 372 373
                                                                                  373 375 375 386 386 392 393 396 397 398 399 400
data_type                 2(08)        based           fixed bin(2,0)           array level 3 in structure "expr" packed packed
                                                                                  unaligned dcl 4-11 in procedure "mrds_dsl_expr_"
                                                                                  set ref 376*
data_type                 0(08)        based           fixed bin(2,0)           array level 2 in structure "data_stack" packed
                                                                                  packed unaligned dcl 476 in procedure
                                                                                  "mrds_dsl_expr_" set ref 119* 170* 221*
dbcb                                   based           structure                level 1 dcl 1-142
dbcb_data                              based           structure                level 1 unaligned dcl 1-148
dbcb_ptr                               parameter       pointer                  dcl 1-146 set ref 108 131 162* 181 239* 251 360* 429
defn_order               22            based           fixed bin(17,0)          level 2 dcl 7-46 ref 154
desc                      1            based           bit(36)                  array level 2 in structure "data_stack" dcl 476
                                                                                  in procedure "mrds_dsl_expr_" set ref 121* 171*
                                                                                  225* 229* 274* 274* 274* 303* 303* 303* 343* 343*
                                                                                  343* 358 371 398
desc                      3            based           bit(36)                  array level 3 in structure "expr" dcl 4-11
                                                                                  in procedure "mrds_dsl_expr_" set ref 371*
desc_ptr                        000110 automatic       pointer                  dcl 5-19 set ref 199* 204* 206* 211* 213* 216* 229
                                                                                  230
descriptor                             based           structure                level 1 unaligned dcl 5-6 in procedure
                                                                                  "mrds_dsl_expr_"
descriptor                3            based           bit(36)                  level 2 in structure "exp_fun_data" packed packed
                                                                                  unaligned dcl 3-11 in procedure "mrds_dsl_expr_"
                                                                                  set ref 121 398*
domain_ptr               26            based           pointer                  level 2 dcl 7-46 ref 150
ef_ptr                    6            based           pointer                  level 2 dcl 3-11 set ref 126 400*
efd_ptr                                parameter       pointer                  dcl 3-19 ref 108 121 122 123 124 126 382 396 397 398
                                                                                  399 400
encd_blen                20     000132 automatic       fixed bin(35,0)          level 2 dcl 470 set ref 161* 237* 359*
encd_proc                10     000132 automatic       bit(1)                   level 2 packed packed unaligned dcl 470 set ref 157*
                                                                                  235* 354*
encdd_ptr                12     000132 automatic       pointer                  level 2 dcl 470 set ref 158* 236* 355*
error_info_supplied       6            based           bit(1)                   level 3 dcl 2-13 set ref 438*
error_msg                22            based           char(256)                level 3 dcl 2-13 set ref 437*
error_report              6            based           structure                level 2 dcl 2-13
error_type                             parameter       char                     packed unaligned dcl 426 in procedure "error" ref
                                                                                  420 434
error_type               14            based           char(24)                 level 3 in structure "se_info" dcl 2-13 in procedure
                                                                                  "mrds_dsl_expr_" set ref 434*
exp_fun_data                           based           structure                level 1 unaligned dcl 3-11
expr                      4            based           structure                level 2 in structure "parser_static_info" dcl 2-66
                                                                                  in procedure "mrds_dsl_expr_"
expr                                   based           structure                level 1 dcl 4-11 in procedure "mrds_dsl_expr_" set
                                                                                  ref 266 390
expr_ptr                        000104 automatic       pointer                  dcl 4-32 set ref 266* 268 269 270 273 283* 285 295
                                                                                  297 320* 321 329 329 330 330 336 337 337 339 368
                                                                                  368 369 369 371 371 372 372 373 373 375 375 376
                                                                                  376 377 377 377 377 390* 391 392 393
expr_ptr1                       000130 automatic       pointer                  dcl 466 set ref 286* 287 297
fixed                                                  builtin function         dcl 504 ref 197
fn_ptr                   10            based           pointer                  array level 2 in structure "data_stack" dcl 476
                                                                                  in procedure "mrds_dsl_expr_" set ref 126* 176*
                                                                                  222* 273* 283 286 320 393* 400
fn_ptr                   12            based           pointer                  array level 3 in structure "expr" dcl 4-11
                                                                                  in procedure "mrds_dsl_expr_" set ref 377*
i                               000101 automatic       fixed bin(17,0)          dcl 258 set ref 285* 288 295 296 296 297 312* 316*
                                                                                  320 330 343 343 346
index                                                  builtin function         dcl 504 ref 199 206 369
item                      2            based           structure                array level 2 dcl 4-11 set ref 269* 270* 297* 297
                                                                                  330* 337* 337 339* 392*
j                               000102 automatic       fixed bin(17,0)          dcl 258 set ref 287* 288 295 296 313* 317* 330 330
                                                                                  339 343
k                               000103 automatic       fixed bin(17,0)          dcl 258 set ref 296* 297 297* 336* 337 337*
level                                  parameter       fixed bin(17,0)          dcl 475 ref 97 100 104 108 111 117 117 118 118 119
                                                                                  119 119 119 121 121 122 122 123 123 124 124 125
                                                                                  125 126 126 131 138 167 167 168 168 169 169 170
                                                                                  170 171 171 172 172 173 173 174 174 175 175 176
                                                                                  176 181 191 195 195 219 219 220 220 221 221 222
                                                                                  222 222 222 225 225 229 229 244 244 245 245 246
                                                                                  246 251 262 262 262 262 269 269 270 270 271 271
                                                                                  272 272 273 273 274 274 274 274 274 274 277 277
                                                                                  280 280 280 280 283 283 286 286 303 303 303 303
                                                                                  303 303 306 306 311 311 312 313 316 317 320 330
                                                                                  339 343 343 343 346 346 346 346 346 350 350 358
                                                                                  358 364 364 365 365 366 366 371 371 372 372 373
                                                                                  373 375 375 382 386 386 392 393 396 397 398 399
                                                                                  400
li                              000132 automatic       structure                level 1 dcl 470 set ref 162 162 239 239 360 360
lit_blen                 21     000132 automatic       fixed bin(35,0)          level 2 dcl 470 set ref 173 245 365
lit_char                               based           char                     packed unaligned dcl 187 ref 206
lit_char_var                           based           varying char             dcl 188 ref 199
lit_info                               based           structure                level 1 dcl 6-15
lit_len                         000100 automatic       fixed bin(17,0)          dcl 189 set ref 197* 206
lit_offset               22     000132 automatic       fixed bin(35,0)          level 2 dcl 470 set ref 172 244 364
lit_ptr                  16     000132 automatic       pointer                  level 2 dcl 470 set ref 174 246 366
litd_ptr                 14     000132 automatic       pointer                  level 2 dcl 470 set ref 160* 171 226* 230* 358*
loc_index                 4            based           fixed bin(18,0)          array level 3 in structure "expr" dcl 4-11
                                                                                  in procedure "mrds_dsl_expr_" set ref 372*
loc_index                 1            based           fixed bin(18,0)          level 2 in structure "exp_fun_data" dcl 3-11
                                                                                  in procedure "mrds_dsl_expr_" set ref 122 396*
loc_index                 2            based           fixed bin(18,0)          array level 2 in structure "data_stack" dcl 476
                                                                                  in procedure "mrds_dsl_expr_" set ref 122* 172*
                                                                                  244* 364* 372 396
loud                                   parameter       bit(1)                   dcl 424 in procedure "error" ref 420 433
loud                      7            based           bit(1)                   level 3 in structure "se_info" dcl 2-13 in procedure
                                                                                  "mrds_dsl_expr_" set ref 433*
mdbm_error_$inc_attr_acc        000026 external static fixed bin(35,0)          dcl 492 set ref 145*
mdbm_secured             20(04)        based           bit(1)                   level 2 packed packed unaligned dcl 7-46 ref 145
message                                parameter       char                     packed unaligned dcl 427 ref 420 437
model_area_ptr                  000122 automatic       pointer                  initial dcl 10-18 set ref 10-18*
model_seg_ptr                   000120 automatic       pointer                  initial dcl 10-13 set ref 10-13*
mrds_data_$max_attributes       000010 external static fixed bin(35,0)          dcl 492 ref 154 154
mrds_data_$max_expr_items       000016 external static fixed bin(35,0)          dcl 492 ref 265 288 321
mrds_data_$max_expr_stack_size  000014 external static fixed bin(35,0)          dcl 492 ref 101 102 102 104 104 111 111 111 117 117
                                                                                  117 117 118 118 118 118 119 119 119 119 119 119
                                                                                  119 119 121 121 121 121 122 122 122 122 123 123
                                                                                  123 123 124 124 124 124 125 125 125 125 126 126
                                                                                  126 126 138 138 138 167 167 167 167 168 168 168
                                                                                  168 169 169 169 169 170 170 170 170 171 171 171
                                                                                  171 172 172 172 172 173 173 173 173 174 174 174
                                                                                  174 175 175 175 175 176 176 176 176 191 191 191
                                                                                  195 195 195 195 219 219 219 219 220 220 220 220
                                                                                  221 221 221 221 222 222 222 222 222 222 222 222
                                                                                  225 225 225 225 229 229 229 229 244 244 244 244
                                                                                  245 245 245 245 246 246 246 246 262 262 262 262
                                                                                  262 262 262 262 269 269 269 269 270 270 270 270
                                                                                  271 271 271 271 272 272 272 272 273 273 273 273
                                                                                  274 274 274 274 274 274 274 274 274 274 274 274
                                                                                  277 277 277 277 280 280 280 280 280 280 280 280
                                                                                  283 283 283 283 286 286 286 286 303 303 303 303
                                                                                  303 303 303 303 303 303 303 303 306 306 306 306
                                                                                  311 311 311 311 312 312 313 313 316 316 317 317
                                                                                  320 320 330 330 339 339 343 343 343 343 343 343
                                                                                  346 346 346 346 346 346 346 346 346 346 350 350
                                                                                  350 350 358 358 358 358 364 364 364 364 365 365
                                                                                  365 365 366 366 366 366 371 371 371 371 372 372
                                                                                  372 372 373 373 373 373 375 375 375 375 386 386
                                                                                  386 386 392 392 393 393 396 396 397 397 398 398
                                                                                  399 399 400 400
mrds_data_$max_id_len           000012 external static fixed bin(35,0)          dcl 492 ref 154 154 154
mrds_data_$max_nested_expr      000020 external static fixed bin(35,0)          dcl 492 ref 101 102
mrds_dsl_make_literal           000030 constant        entry                    external dcl 507 ref 239
mrds_dsl_make_literal$alloc     000032 constant        entry                    external dcl 508 ref 162 360
mrds_error_$expr_stack_ovfl     000022 external static fixed bin(35,0)          dcl 492 set ref 111* 138* 191*
mrds_error_$max_expr_items      000024 external static fixed bin(35,0)          dcl 492 set ref 288* 321*
mu_data_class$complex_data_class
                                000034 constant        entry                    external dcl 510 ref 213 411 411
needed_bits                            based           structure                array level 3 dcl 9-5
nexp_items_init                 000106 automatic       fixed bin(17,0)          dcl 4-33 set ref 265* 266 266 389* 390 390
nitems                                 based           fixed bin(17,0)          level 2 dcl 4-11 set ref 266* 268* 285 287 295* 321
                                                                                  329* 329 330 336 368 369 371 372 373 375 376 377
                                                                                  377 390* 391*
nstk_items                             based           fixed bin(17,0)          dcl 472 set ref 104* 111 117* 117 118 119 119 121
                                                                                  122 123 124 125 126 138 167* 167 168 169 170 171
                                                                                  172 173 174 175 176 191 195* 195 219 220 221 222
                                                                                  222 225 229 244 245 246 262 262 269 270 271 272
                                                                                  273 274 274 274 277* 277 280 280 283 286 303 303
                                                                                  303 306* 306 311 312 313 316 317 346 346 346 350*
                                                                                  350 358 364 365 366 371 372 373 375 386
null                                                   builtin function         dcl 504 ref 125 158 176 222 236 272 355 377 7-65
                                                                                  8-51 10-13 10-18 11-6 11-10
num_dims                        000112 automatic       fixed bin(17,0)          initial dcl 5-20 set ref 5-20*
op_code                   2(04)        based           fixed bin(3,0)           array level 3 in structure "expr" packed packed
                                                                                  unaligned dcl 4-11 in procedure "mrds_dsl_expr_"
                                                                                  set ref 369*
op_code                   0(04)        based           fixed bin(3,0)           array level 2 in structure "data_stack" packed
                                                                                  packed unaligned dcl 476 in procedure
                                                                                  "mrds_dsl_expr_" set ref 119* 169* 220*
operator                               parameter       char(1)                  dcl 259 ref 251 369
parser_static_info                     based           structure                level 1 dcl 2-66
parser_work_area                       based           area                     dcl 2-63 ref 101
psi_ptr                                parameter       pointer                  dcl 2-65 ref 97 101 101 102 104 108 111 117 117 118
                                                                                  118 119 119 119 119 121 121 122 122 123 123 124
                                                                                  124 125 125 126 126 131 138 167 167 168 168 169
                                                                                  169 170 170 171 171 172 172 173 173 174 174 175
                                                                                  175 176 176 181 191 195 195 219 219 220 220 221
                                                                                  221 222 222 222 222 225 225 229 229 244 244 245
                                                                                  245 246 246 251 262 262 262 262 269 269 270 270
                                                                                  271 271 272 272 273 273 274 274 274 274 274 274
                                                                                  277 277 280 280 280 280 283 283 286 286 303 303
                                                                                  303 303 303 303 306 306 311 311 312 313 316 317
                                                                                  320 330 339 343 343 343 346 346 346 346 346 350
                                                                                  350 358 358 364 364 365 365 366 366 371 371 372
                                                                                  372 373 373 375 375 382 386 386 392 393 396 397
                                                                                  398 399 400
pwa_ptr                                based           pointer                  level 2 dcl 2-66 ref 101
rai_ptr                         000114 automatic       pointer                  initial dcl 7-65 set ref 144* 145 145 150 154 7-65*
range                                  based           structure                level 1 dcl 9-5
range_ptr                              parameter       pointer                  dcl 9-23 ref 131 154
rdi_ptr                         000116 automatic       pointer                  initial dcl 8-51 set ref 150* 160 8-51*
read_perm                20(02)        based           bit(1)                   level 2 packed packed unaligned dcl 7-46 ref 145
rel_index                              parameter       fixed bin(17,0)          dcl 135 ref 131 154
rm_attr_info                           based           structure                level 1 dcl 7-46
rm_domain_info                         based           structure                level 1 dcl 8-35
rslt                            000176 automatic       bit(36)                  dcl 409 set ref 411* 415* 416
se_info                                based           structure                level 1 dcl 2-13
se_info_ptr                     000156 automatic       pointer                  dcl 519 in procedure "mrds_dsl_expr_" set ref 429*
                                                                                  433 434 435 436 437 438
se_info_ptr              72            based           pointer                  level 3 in structure "dbcb" dcl 1-142 in procedure
                                                                                  "mrds_dsl_expr_" ref 429
select_area                            based           area                     dcl 11-8 ref 266 390
select_area_ptr                 000126 automatic       pointer                  initial dcl 11-10 set ref 261* 266 11-10*
select_area_struct_ptr          000124 automatic       pointer                  initial dcl 11-6 set ref 11-6*
size                      0(12)        based           structure                level 2 packed packed unaligned dcl 5-6 ref 197
src_ptr                         000132 automatic       pointer                  level 2 dcl 470 set ref 158* 233* 355*
srcd_ptr                  2     000132 automatic       pointer                  level 2 dcl 470 set ref 158* 234* 355*
stack                     2            based           structure                array level 2 dcl 479 set ref 118 119 119 121 122
                                                                                  123 124 125 126 168 169 170 171 172 173 174 175
                                                                                  176 219 220 221 222 222 225 229 244 245 246 262
                                                                                  262 269 270 271 272 273 274 274 274 280 280 283
                                                                                  286 303 303 303 311 320 330 339 343 343 343 346
                                                                                  346 358 364 365 366 371 372 373 375 386 392 393
                                                                                  396 397 398 399 400
stack_offset             13            based           fixed bin(17,0)          level 3 in structure "se_info" dcl 2-13 in procedure
                                                                                  "mrds_dsl_expr_" set ref 436*
stack_offset                           parameter       fixed bin(17,0)          dcl 425 in procedure "error" ref 420 436
stack_top                              based           fixed bin(17,0)          array level 2 dcl 479 set ref 102* 104 111 117 117
                                                                                  118 119 119 121 122 123 124 125 126 138 167 167
                                                                                  168 169 170 171 172 173 174 175 176 191 195 195
                                                                                  219 220 221 222 222 225 229 244 245 246 262 262
                                                                                  269 270 271 272 273 274 274 274 277 277 280 280
                                                                                  283 286 303 303 303 306 306 311 312 313 316 317
                                                                                  346 346 346 350 350 358 364 365 366 371 372 373
                                                                                  375 386
string                                                 builtin function         dcl 504 ref 197
token_start              10            based           fixed bin(17,0)          level 3 dcl 2-13 set ref 435*
tup_var                   2            based           structure                array level 2 dcl 9-5
type                      2            based           fixed bin(3,0)           array level 3 in structure "expr" packed packed
                                                                                  unaligned dcl 4-11 in procedure "mrds_dsl_expr_"
                                                                                  set ref 368*
type                                   based           fixed bin(3,0)           array level 2 in structure "data_stack" packed
                                                                                  packed unaligned dcl 476 in procedure
                                                                                  "mrds_dsl_expr_" set ref 118* 168* 219* 262 262
                                                                                  271* 280 280 311 386
type                      0(01)        based           fixed bin(6,0)           level 2 in structure "descriptor" packed packed
                                                                                  unsigned unaligned dcl 5-6 in procedure
                                                                                  "mrds_dsl_expr_" ref 199 206
unspec                                                 builtin function         dcl 504 set ref 269* 269 270* 270 297* 297 330* 330
                                                                                  339* 339 392* 392
user_desc                11            based           bit(36)                  level 2 dcl 8-35 set ref 160

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ADD                                    internal static fixed bin(17,0)          initial dcl 4-59
DIV                                    internal static fixed bin(17,0)          initial dcl 4-59
IL_TYPE                                internal static char(14)                 initial packed unaligned dcl 2-53
MULT                                   internal static fixed bin(17,0)          initial dcl 4-59
RC_TYPE                                internal static char(12)                 initial packed unaligned dcl 2-33
SC_TYPE                                internal static char(13)                 initial packed unaligned dcl 2-38
SE_TYPE                                internal static char(20)                 initial packed unaligned dcl 2-35
SUBT                                   internal static fixed bin(17,0)          initial dcl 4-59
WCF_TYPE                               internal static char(21)                 initial packed unaligned dcl 2-47
WC_TYPE                                internal static char(12)                 initial packed unaligned dcl 2-41
lip                                    automatic       pointer                  dcl 6-28
model_area                             based           area                     dcl 10-16
model_seg                              based           structure                level 1 dcl 10-9
nsf_args_init                          automatic       fixed bin(17,0)          dcl 4-57
rel                                                    builtin function         dcl 504
scalfn                                 based           structure                level 1 dcl 4-35
select_area_struct                     based           structure                level 1 dcl 11-2
sfn_ptr                                automatic       pointer                  dcl 4-56
size                                                   builtin function         dcl 10-20
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 492

NAMES DECLARED BY EXPLICIT CONTEXT.
build_attribute                 000471 constant        entry                    external dcl 131
build_function                  000264 constant        entry                    external dcl 108
build_literal                   001076 constant        entry                    external dcl 181
condense_stack                  001545 constant        entry                    external dcl 251
error                           003047 constant        entry                    internal dcl 420 ref 111 138 145 163 191 240 288 321
                                                                                  361
exit                            002776 constant        label                    dcl 521 ref 440
finish                          002630 constant        entry                    external dcl 382
init                            000155 constant        entry                    external dcl 97
mrds_dsl_expr_                  000142 constant        entry                    external dcl 12
resolve_descs                   002777 constant        entry                    internal dcl 404 ref 274 303 343

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3344        3402    3121        3354
Length      4066    3121        36         447     222           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_dsl_expr_                      227 external procedure  is an external procedure.  
resolve_descs                           internal procedure  shares stack frame of external procedure mrds_dsl_expr_.  
error                                   internal procedure  shares stack frame of external procedure mrds_dsl_expr_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mrds_dsl_expr_           000100 lit_len                     mrds_dsl_expr_
                         000101 i                           mrds_dsl_expr_
                         000102 j                           mrds_dsl_expr_
                         000103 k                           mrds_dsl_expr_
                         000104 expr_ptr                    mrds_dsl_expr_
                         000106 nexp_items_init             mrds_dsl_expr_
                         000110 desc_ptr                    mrds_dsl_expr_
                         000112 num_dims                    mrds_dsl_expr_
                         000114 rai_ptr                     mrds_dsl_expr_
                         000116 rdi_ptr                     mrds_dsl_expr_
                         000120 model_seg_ptr               mrds_dsl_expr_
                         000122 model_area_ptr              mrds_dsl_expr_
                         000124 select_area_struct_ptr      mrds_dsl_expr_
                         000126 select_area_ptr             mrds_dsl_expr_
                         000130 expr_ptr1                   mrds_dsl_expr_
                         000132 li                          mrds_dsl_expr_
                         000156 se_info_ptr                 mrds_dsl_expr_
                         000176 rslt                        resolve_descs

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return_mac          ext_entry           op_alloc_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
mrds_dsl_make_literal         mrds_dsl_make_literal$alloc   mu_data_class$complex_data_class

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
mdbm_error_$inc_attr_acc      mrds_data_$max_attributes     mrds_data_$max_expr_items
mrds_data_$max_expr_stack_size                              mrds_data_$max_id_len         mrds_data_$max_nested_expr
mrds_error_$expr_stack_ovfl   mrds_error_$max_expr_items




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 5   20 000127    7   65 000130    8   51 000132   10   13 000133   10   18 000134   11    6 000135   11   10 000136
     12 000141        97 000150       100 000166       101 000171       102 000212       103 000236       104 000237
    106 000256       108 000257       111 000301       117 000356       118 000374       119 000411       121 000421
    122 000425       123 000430       124 000432       125 000434       126 000446       128 000461       129 000462
    131 000463       138 000504       144 000561       145 000565       150 000630       154 000633       157 000703
    158 000705       160 000711       161 000713       162 000714       163 000730       167 000763       168 001001
    169 001016       170 001022       171 001026       172 001033       173 001036       174 001040       175 001042
    176 001054       178 001066       179 001067       181 001070       191 001111       195 001166       197 001204
    198 001212       199 001215       204 001242       206 001245       211 001266       213 001271       216 001307
    219 001311       220 001337       221 001343       222 001347       224 001361       225 001366       226 001403
    227 001404       229 001405       230 001420       233 001421       234 001425       235 001430       236 001432
    237 001434       239 001435       240 001451       244 001504       245 001531       246 001533       248 001535
    249 001536       251 001537       261 001560       262 001564       265 001624       266 001626       268 001637
    269 001641       270 001667       271 001675       272 001703       273 001706       274 001716       277 001740
    278 001746       280 001747       283 001755       285 001757       286 001761       287 001763       288 001765
    295 002025       296 002031       297 002043       300 002057       303 002061       306 002116       307 002124
    311 002125       312 002130       313 002133       314 002135       316 002136       317 002142       320 002144
    321 002150       329 002210       330 002212       336 002251       337 002257       338 002267       339 002272
    341 002321       343 002322       346 002361       350 002403       354 002405       355 002407       358 002413
    359 002437       360 002440       361 002455       364 002510       365 002535       366 002537       368 002541
    369 002550       371 002570       372 002602       373 002605       375 002607       376 002612       377 002616
    379 002621       380 002622       382 002623       386 002643       389 002672       390 002674       391 002707
    392 002711       393 002733       394 002734       396 002735       397 002757       398 002761       399 002763
    400 002765       402 002775       521 002776       404 002777       411 003001       415 003042       416 003044
    420 003047       429 003065       431 003072       433 003075       434 003100       435 003105       436 003106
    437 003110       438 003115       440 003117


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
