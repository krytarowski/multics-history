	COMPILATION LISTING OF SEGMENT merge_ascii
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 07/12/88  1435.0 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 
       15 
       16 /****^  HISTORY COMMENTS:
       17*  1) change(88-07-06,TLNguyen), approve(88-07-06,MCR7925),
       18*     audit(88-07-08,Parisek), install(88-07-12,MR12.2-1055):
       19*     Fix bug which prevents printing out an error message when lacking path
       20*     argument for -output_file (-of) control argument.
       21*                                                   END HISTORY COMMENTS */
       22 
       23 
       24 
       25 merge_ascii: ma: proc;
       26 	default (fixed&^precision&^constant) precision (21); /* DEFAULT 4*256K CHARS */
       27 	default (constant&real&^decimal) binary;
       28 
       29 /* Coded by RE Mullen, Fall '75  */
       30 /* Recoded by RE Mullen, Spring '77 */
       31 /* Added code for archive :: convention THVV 1980 */
       32 /* Jay Pattin 11/10/80 made compare_ascii take -output_file */
       33 /* Jay Pattin 6/30/82 added -extend, -truncate to cpa, cleaned up a little */
       34 /* Jay Pattin 11/2/82 prevent -of file from being original in cpa. see TR13883 */
       35 
  1     1 /* BEGIN INCLUDE FILE ... merge_ascii_info.incl.pl1 ... REM Winter '77 */
  1     2 /* Modified for archive component convention THVV 1980 */
  1     3 /* Added output_iocb_ptr for cpa -output_file */
  1     4 
  1     5 dcl  ma_info_ptr ptr;
  1     6 
  1     7 /* programs modifiying variables are supplied im most comments */
  1     8 /* ma_info.control.*** modified by ma unless otherwise noted */
  1     9 /* ma_info.per_text(output).*** usually set by ma_edit_ instead */
  1    10 /* ma=merge_ascii ma_=merge_ascii_ mar_=ma_resynch_ maa_=ma_analyze_ mae_=ma_edit_ */
  1    11 
  1    12 dcl 1 ma_info aligned based (ma_info_ptr),
  1    13     2 control aligned,				/* stuff controling program action */
  1    14       3 minlines fixed bin,				/* ma: resynch block must have >= minlines */
  1    15       3 minchars fixed bin,				/* ma: resynch block must have >= minchars */
  1    16       3 lo fixed bin,				/* ma: lowest seg_index to resynch */
  1    17       3 hi fixed bin,				/* ma: highest seg_index to resynch */
  1    18       3 eof bit (1),				/* set by mar_ and ma_.skip_same for ma_ */
  1    19       3 synchlen fixed bin,				/* mar_: chars between resynch start and next diff */
  1    20       3 synchlines fixed bin,				/* mar_: lines between resynch start and next diff */
  1    21       3 have_orig bit (1),				/* "1"b if original provided */
  1    22       3 have_output bit (1),				/* ma_: "1"b if merge and have got path */
  1    23       3 have_edit bit (1),				/* if any "-edit" segs */
  1    24       3 convergence_ok bit (1) aligned,			/* "1"b => ok to pick up identical changes */
  1    25       3 brief_mode bit (1) aligned,			/* UNUSED */
  1    26       3 total_differences fixed bin,			/* ma_: number of time synch lost */
  1    27       3 total_lines_differing fixed bin,		/* ma_: summed over all diff in all texts */
  1    28       3 totals_only bit (1),				/* ma: dont print differences */
  1    29       3 print_heading bit (1),			/* ma: print heading before start */
  1    30       3 no_line_numbers bit (1),			/* ma: dont print linnos with diffs */
  1    31       3 print_new_lines bit (1),			/* ma: dont print context or old with diff */
  1    32       3 no_totals bit (1),				/* ma: dont print totals line when done */
  1    33       3 abort_label label,				/* goto abort label to bust out */
  1    34       3 op_dirname char (168),			/* info about desired output seg */
  1    35       3 op_ename char (32),
  1    36       3 op_ptr ptr,
  1    37       3 output_iocb_ptr ptr,
  1    38     2 per_text_info (8) aligned,			/* 1=output_temp, 2=orig, 3+=updates */
  1    39       3 tptr ptr,					/* ma: base of each text */
  1    40       3 tchars fixed bin,				/* ma: chars in each text */
  1    41       3 tlines fixed bin,				/* UNUSED */
  1    42       3 cp ptr,					/* ma_: ->current position, next char to process */
  1    43       3 len fixed bin,				/* ma_: chars remaining to process */
  1    44       3 line fixed bin,				/* ma_: line number cp points at */
  1    45       3 difflen fixed bin,				/* mar_: chars between synchs */
  1    46       3 difflines fixed bin,				/* mar_: lines between synchs */
  1    47       3 same_as fixed bin,				/* mar_: seg_index of lowest seg with identical diff */
  1    48       3 textid char (1) aligned,			/* ma: char to identify text in display */
  1    49       3 edit bit (1) aligned,				/* ma: not take automatically */
  1    50       3 pad_t (3) fixed bin,				/* make 16 wds for indexing speed */
  1    51     2 text_id (8) aligned,				/* names of the stff */
  1    52       3 dirname char (168),
  1    53       3 ename char (32),
  1    54       3 component char (32);
  1    55 
  1    56 dcl  ma_text_ids char (8) init ("mabcdefg")int static options (constant);
  1    57 dcl  MA_TEXT_IDS char (8) init ("MABCDEFG")int static options (constant);
  1    58 dcl  ma_max_texts fixed bin int static options (constant) init (8);
  1    59 
  1    60 /* END INCLUDE FILE ... merge_ascii_info.incl.pl1 */
       36 
       37 
       38 dcl  merge_ascii_ entry (ptr);
       39 dcl  hcs_$truncate_seg entry (ptr, fixed bin, fixed bin (35));
       40 dcl  hcs_$delentry_seg entry (ptr, fixed bin (35));
       41 dcl  hcs_$set_bc_seg entry (ptr, fixed bin, fixed bin (35));
       42 dcl  hcs_$make_seg entry (char (*), char (*), char (*),
       43      fixed bin, ptr, fixed bin (35));
       44 dcl (ioa_$ioa_switch, com_err_, com_err_$suppress_name) entry options (variable);
       45 dcl  iox_$user_output ptr external;
       46 dcl  iox_$attach_name entry (char(*), ptr, char(*), ptr, fixed bin(35)),
       47      iox_$open entry (ptr, fixed bin, bit(1) aligned, fixed bin(35)),
       48      iox_$close entry (ptr, fixed bin(35)),
       49      iox_$detach_iocb entry (ptr, fixed bin(35));
       50 dcl  hcs_$initiate_count entry (char (*), char (*), char (*),
       51      fixed bin (24), fixed bin (2), ptr, fixed bin (35));
       52 dcl  get_equal_name_$component entry (char (*), char (*), char (*), char (*), char (32), char (32), fixed bin (35));
       53 dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
       54 dcl  hcs_$terminate_noname entry (ptr, fixed bin (35));
       55 dcl  expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35));
       56 dcl  expand_pathname_$component entry (char (*), char (*), char (*), char (*), fixed bin (35));
       57 dcl  archive_$get_component entry (ptr, fixed bin (24), char (*), ptr, fixed bin (24), fixed bin (35));
       58 dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
       59 dcl  cu_$arg_count entry (fixed bin, fixed bin (35));
       60 dcl  unique_chars_ entry (bit(*)) returns(char(15));
       61 dcl (error_table_$noarg,
       62      error_table_$inconsistent,
       63      error_table_$segknown,
       64      error_table_$zero_length_seg,
       65      error_table_$badopt,
       66      error_table_$rqover,
       67      error_table_$noentry) ext fixed bin (35);
       68 
       69 dcl  cleanup condition;
       70 dcl  record_quota_overflow condition;
       71 
       72 dcl (me, operation) char (16) aligned;
       73 
       74 dcl (addr, baseno, divide, index, null, rtrim, substr, unspec) builtin;
       75 
       76 dcl (i, j, k) fixed bin;
       77 dcl  nargs fixed bin;
       78 dcl  of_arg fixed bin;
       79 dcl  al fixed bin;
       80 dcl  ap ptr;
       81 dcl  attach_desc char (256);
       82 dcl  arg char (al) based (ap);
       83 dcl  dn char (168);
       84 dcl  en char (32);
       85 dcl  ct char (32);
       86 dcl  first_name char (32);
       87 dcl  first_cpt char (32);
       88 
       89 dcl  code fixed bin (35);
       90 
       91 dcl (edit_bit, have_tc_or_ex, extend, no_header, orig_bit, out_bit) bit (1);
       92 dcl (MA, CPA) bit (1) init (""b);
       93 dcl (first_is_orig, old_mins_ok, saw_minlines, saw_minchars) bit (1) init (""b); /* CPA compatibility switches */
       94 dcl  (iocb_ptr, p) ptr;
       95 dcl (bit_count, cpt_bc) fixed bin (24);
       96 dcl  sx fixed bin;
       97 dcl  expected char (32);
       98 dcl 1 mai aligned like ma_info;
       99 
      100 dcl  ch char (999) based;
      101 						/* ENDCL */
      102 
      103 	me = "merge_ascii";
      104 	MA = "1"b;
      105 	call cu_$arg_count (nargs, code);
      106 	if code ^= 0 | nargs = 0 then do;
      107 	     call com_err_$suppress_name (code, me, "Usage:  merge_ascii paths {-control_args}");
      108 	     return;
      109 	end;
      110 	go to common;
      111 
      112 
      113 compare_ascii: cpa: entry;
      114 	me = "compare_ascii";
      115 	CPA = "1"b;
      116 
      117 	call cu_$arg_count (nargs, code);
      118 	if code ^= 0 | nargs = 0 then do;		/* tell usage of cpa */
      119 	     call com_err_$suppress_name (code, me, "Usage:  compare_ascii paths {-control_args}");
      120 	     return;
      121 	end;
      122 						/* for cpa nums are minchars..minlines, if -minchars..minlines not given */
      123 						/* for cpa first path is orig unless -orig or -no_orig given somewhere */
      124 	of_arg = 0;
      125 	first_is_orig = "1"b;
      126 	old_mins_ok, extend = "1"b;
      127 	have_tc_or_ex = "0"b;
      128 
      129 	do i = 1 to nargs;
      130 	     call cu_$arg_ptr (i, ap, al, code);
      131 	     if arg = "-orig" | arg = "-original" | arg = "-no_orig" | arg = "-no_original" then do;
      132 		if ^first_is_orig then do;
      133 		     call com_err_ (0, me, "Either -original or -no_original can be specified once.");
      134 		     return;
      135 		end;
      136 		first_is_orig = ""b;
      137 	     end;
      138 	     else if arg = "-minlines" | arg = "-minchars" then do;
      139 		old_mins_ok = ""b;
      140 	     end;
      141 	end;
      142 
      143 common:
      144 	unspec (mai) = ""b;
      145 	mai.op_ptr = null ();
      146 	mai.op_dirname, mai.op_ename = "";
      147 	do i = 1 to ma_max_texts;
      148 	     mai.textid (i) = substr (MA_TEXT_IDS, i, 1);	/* print id's in uppercase */
      149 	     mai.tptr (i), mai.cp (i) = null ();
      150 	end;
      151 	mai.output_iocb_ptr = iox_$user_output;
      152 	iocb_ptr = null ();
      153 	on cleanup call ma_cleanup_handler;
      154 	mai.abort_label = ABORT;
      155 	mai.minlines = 2;
      156 	mai.minchars = 25;
      157 	first_name = "";
      158 	no_header = ""b;
      159 
      160 	i = 0;
      161 	mai.lo = 3; mai.hi = 2;			/* seg1 is output, seg2 is orig, segs3+ are updates */
      162 	do while (i < nargs);
      163 	     i = i + 1;
      164 	     out_bit, orig_bit, edit_bit = ""b;		/* dont know what it is, yet */
      165 
      166 	     call cu_$arg_ptr (i, ap, al, code);
      167 	     if ^CPA then goto COMMON_ARGS;
      168 	     if arg = "-totals" | arg = "-total" | arg = "-tt" then mai.totals_only = "1"b;
      169 	     else if arg = "-no_totals" | arg = "-no_total" | arg = "-ntt" then mai.no_totals = "1"b;
      170 	     else if arg = "-extend" then have_tc_or_ex, extend = "1"b;
      171 	     else if arg = "-truncate" | arg = "-tc" then do;
      172 		extend = "0"b;
      173 		have_tc_or_ex = "1"b;
      174 	     end;
      175 	     else if arg = "-header" | arg = "-he" then do;
      176 		mai.print_heading = "1"b;
      177 		no_header = "0"b;
      178 	     end;
      179 	     else if arg = "-no_header" | arg = "-nhe" then no_header = "1"b;
      180 	     else if arg = "-no_numbers" | arg = "-no_number" | arg = "-nnb" then mai.no_line_numbers = "1"b;
      181 	     else if arg = "-print_new_lines" | arg = "-pnl" then mai.print_new_lines = "1"b;
      182 	     else if arg = "-no_output_file" | arg = "-nof" then mai.output_iocb_ptr = iox_$user_output;
      183 	     else if arg = "-no_orig" | arg = "-no_original" then;
      184 						/* if CPA then we've already noticed this arg */
      185 	     else 
      186 COMMON_ARGS:	if arg = "-minlines" | arg = "-minchars" then do;
      187 		expected = substr (arg, 2);		/* note what we expect */
      188 		i = i + 1;
      189 		call cu_$arg_ptr (i, ap, al, code);
      190 		if code ^= 0 then do;
      191 NOARG:		     call com_err_ (code, me, "^a", expected);	/* tell whats missing */
      192 		     go to ABORT;
      193 		end;
      194 		k = cv_dec_check_ (arg, code);
      195 		if code ^= 0 then do;
      196 BADNUM:		     call com_err_ (0, me, "Invalid ^a value: ""^a""", expected, arg);
      197 		     go to ABORT;
      198 		end;
      199 		if k <= 0 then go to BADNUM;
      200 		if expected = "minlines" then mai.minlines = k;
      201 		else mai.minchars = k;
      202 	     end;
      203 	     else if index (arg, "-") = 1 then do;	/* -something path */
      204 		if MA & (arg = "-old_original" | arg = "-old_orig") then do;
      205 		     mai.convergence_ok = "1"b;
      206 		     go to ORIG;
      207 		end;
      208 		else if arg = "-original" | arg = "-orig" then do;
      209 ORIG:
      210 		     expected = "original";
      211 		     if mai.have_orig then go to ONLYONE;
      212 		     mai.have_orig, orig_bit = "1"b;
      213 		end;
      214 		else if arg = "-output_file" | arg = "-of" then do;
      215 		     expected = "output";
      216 		     if mai.have_output then do;
      217 ONLYONE:
      218 			call com_err_ (0, me, "Only one ^a segment can be specified.", expected);
      219 			go to ABORT;
      220 		     end;
      221 
      222 		     of_arg = i + 1;                    /* prepare to get the path argument for -output_file control argument */
      223 		     if of_arg > nargs then do;
      224 			call com_err_ (0, me, "Missing path argument for ^a control argument.", arg);
      225 			goto ABORT;
      226 		     end;
      227 
      228 		     mai.have_output, out_bit = "1"b;
      229 		end;
      230 		else if MA & arg = "-edit" then do;
      231 		     expected = "edit";
      232 		     mai.have_edit, edit_bit = "1"b;
      233 		end;
      234 		else do;				/* -crap */
      235 BAD_ARG:		     call com_err_ (error_table_$badopt, me, "^a", arg);
      236 		     go to ABORT;
      237 		end;
      238 		i = i + 1;
      239 		if ^(CPA & out_bit) then do;		/* Don't process cpa output path until end. */
      240 		     call cu_$arg_ptr (i, ap, al, code);
      241 		     if code ^= 0 then go to NOARG;	/* should have been path */
      242 		     call PROCESS_PATH;
      243 		end;
      244 	     end;
      245 	     else if ^old_mins_ok then call PROCESS_PATH; /* must be vanilla path */
      246 	     else do;				/* a vanilla path or a vanilla number */
      247 		k = cv_dec_check_ (arg, code);
      248 		if code ^= 0 then call PROCESS_PATH;
      249 		else do;				/* a number */
      250 		     if ^saw_minchars then do;
      251 			saw_minchars = "1"b;
      252 			mai.minchars = k;
      253 			expected = "minchars";
      254 		     end;
      255 		     else if ^saw_minlines then do;
      256 			saw_minlines = "1"b;
      257 			mai.minlines = k;
      258 			expected = "minlines";
      259 		     end;
      260 		     else go to BAD_ARG;
      261 		     if k <= 0 then go to BADNUM;
      262 		end;
      263 	     end;
      264 	end;					/* end arg loop */
      265 
      266 /* GLOBAL ARG CHECKS */
      267 
      268 	if mai.lo ^< mai.hi then do;			/* (orig&no_upd) | (no_orig&one_upd) is dumb */
      269 	     call com_err_ (0, me, "Not enough texts supplied.");
      270 	     go to ABORT;
      271 	end;
      272 
      273 	if have_tc_or_ex & ^mai.have_output then do;
      274 	     call com_err_ (error_table_$inconsistent, me, "-extend and -truncate may only be used with -output_file.");
      275 	     return;
      276 	end;
      277 
      278 	if CPA & mai.have_output then do;                 /* my name is compare_ascii and -output_file (-of) is specified */
      279 	     out_bit = "1"b;
      280 
      281 	     call cu_$arg_ptr (of_arg, ap, al, code);     /* get path argument for -output_file (-of) control argument */
      282 	     if code ^= 0 then do;
      283 		call com_err_ (code, me);
      284 		goto ABORT;
      285 	     end;
      286 
      287 	     if index (arg, "-") = 1 then do;              /* the first character of arg value is a hyphen. */
      288                                                              /* example: cpa path1 path2 -of */
      289 		call com_err_ (error_table_$noarg, me, "^/Missing path argument for -output_file (-of) control argument.  Found ^a", arg);
      290 		goto ABORT;
      291 	     end;
      292 
      293 	     call PROCESS_PATH;
      294 	     if ^no_header then mai.print_heading = "1"b;
      295 	     if extend then attach_desc = rtrim (attach_desc) || " -extend";
      296 	     call iox_$attach_name (unique_chars_ ("0"b) || ".cpa", iocb_ptr, attach_desc, null (), code);
      297 	     call iox_$open (iocb_ptr, 2, "0"b, code);
      298 	     if code ^= 0 then do;
      299 		call com_err_ (code, me, "Attaching ^a.", arg);
      300 		goto ABORT;
      301 	     end;
      302 	     mai.output_iocb_ptr = iocb_ptr;
      303 	     mai.have_output = "0"b;		/* so merge_ascii_ knows this is a compare */
      304 	end;
      305 
      306 	if MA & ^mai.have_output then do;
      307 	     code = error_table_$noarg;
      308 	     expected = "output_file";
      309 	     go to NOARG;
      310 	end;
      311 
      312 	if mai.print_new_lines & ^mai.have_orig then do;
      313 	     call com_err_ (0, me, "An original must be supplied to use print_new_lines feature");
      314 	     go to ABORT;
      315 	end;
      316 
      317 	do i = mai.lo to mai.hi;
      318 	     if mai.have_output then if mai.op_ptr ^= null () then
      319 		if baseno (mai.op_ptr) = baseno (mai.tptr (i)) then do; /* Output must not be same as input */
      320 		     dn = mai.op_dirname;
      321 		     en = mai.op_ename;
      322 		     ct = "";
      323 		     go to SAMESEG;
      324 		end;
      325 	     do j = i + 1 to mai.hi;			/* No two inputs must be same */
      326 		if mai.tptr (i) = mai.tptr (j) then do;
      327 		     dn = mai.dirname (j);
      328 		     en = mai.ename (j);
      329 		     ct = mai.component (j);
      330 SAMESEG:		     call com_err_ (0, me, "^a^[>^]^a^[::^a^;^s^] is the same segment as ^a^[>^]^a^[::^a^;^s^]",
      331 			dn, (dn ^= ">"), en, (ct ^= ""), ct,
      332 			mai.dirname (i), (mai.dirname (i) ^= ">"), mai.ename (i), (mai.component (i) ^= ""), mai.component (i));
      333 		     go to ABORT;
      334 		end;
      335 	     end;
      336 	end;
      337 
      338 /* START WORK */
      339 
      340 	if mai.print_heading then do;
      341 	     do i = mai.lo to mai.hi;
      342 		if mai.tptr (i) ^= null () then do;
      343 		     call ioa_$ioa_switch (mai.output_iocb_ptr, "^a ^a^[>^]^a^[::^a^;^s^] (^[original^;new^])",
      344 			mai.textid (i), mai.dirname (i), (mai.dirname (i) ^= ">"), mai.ename (i),
      345 			(mai.component (i) ^= ""), mai.component (i), (i = 2));
      346 		end;
      347 	     end;
      348 	end;
      349 
      350 	call merge_ascii_ (addr (mai));
      351 
      352 /* if merge then copy to target segment */
      353 	if mai.have_output then do;			/* now must move output to target */
      354 	     if mai.op_ptr = null () then do;		/* output seg not exist yet */
      355 		call hcs_$make_seg ((mai.op_dirname), (mai.op_ename), "", 01011b, mai.op_ptr, code);
      356 		if mai.op_ptr = null then goto OP_ERR;	/* can't create it! */
      357 	     end;
      358 	     else do;				/* output seg already exists */
      359 		call hcs_$truncate_seg (mai.op_ptr, 0, code); /* check access & save paging */
      360 		if code ^= 0 then go to OP_ERR;	/* access bad, vanished? */
      361 	     end;
      362 	     on record_quota_overflow begin;		/* now target exists, prepare to copy */
      363 		code = error_table_$rqover;
      364 		go to OP_ERR;
      365 	     end;
      366 	     substr (mai.op_ptr -> ch, 1, mai.tchars (1)) = substr (mai.tptr (1) -> ch, 1, mai.tchars (1));
      367 	     call hcs_$set_bc_seg (mai.op_ptr, 9*mai.tchars (1), code); /* finally done */
      368 	     if code ^= 0 then do;			/* unlikely .. */
      369 OP_ERR:		call hcs_$set_bc_seg (mai.tptr (1), 9*mai.tchars (1), 0); /* come here if trouble with output seg */
      370 		call com_err_ (code, me,
      371 		     "^a^[>^]^a", mai.op_dirname, (mai.op_dirname ^= ">"), mai.op_ename);
      372 		call com_err_ (0, me, "Merged output is in ^a>^a",
      373 		     mai.dirname (1), mai.ename (1));
      374 	     end;
      375 	     else do;				/* successful copy, delete temp */
      376 		call hcs_$delentry_seg (mai.tptr (1), code);
      377 		if code ^= 0 then call com_err_ (code, me, "Could not delete ^a>^a", mai.dirname (1), mai.ename (1));
      378 	     end;
      379 	end;
      380 						/* make soothing noise */
      381 	if ^mai.no_totals then do;
      382 	     if CPA then operation = "Comparison"; else operation = "Merge";
      383 	     if CPA & mai.total_differences = 0 then call ioa_$ioa_switch (mai.output_iocb_ptr, "Segments are identical.");
      384 	     else call ioa_$ioa_switch (mai.output_iocb_ptr, "^a finished: ^d difference^[s^], ^d line^[s^].",
      385 		operation,
      386 		mai.total_differences, (mai.total_differences ^= 1),
      387 		mai.total_lines_differing, (mai.total_lines_differing ^= 1));
      388 	end;
      389 	call ma_cleanup_handler;			/* clean up address space etc */
      390 	return;
      391 
      392 ABORT:						/* come here for failure exit */
      393 	if mai.tptr (1) ^= null ()
      394 	then call hcs_$delentry_seg (mai.tptr (1), code);
      395 	call ma_cleanup_handler;			/* failure leave address space clean */
      396 	return;
      397 
      398 /* ------------------------------------------------------------ */
      399 
      400 
      401 ma_cleanup_handler: proc;				/* IP to cleanup */
      402 	     do i = 2 to ma_max_texts;
      403 		if mai.tptr (i) ^= null () then
      404 		     call hcs_$terminate_noname (mai.tptr (i), code);
      405 	     end;
      406 	     if mai.op_ptr ^= null () then
      407 		call hcs_$terminate_noname (mai.op_ptr, 0);
      408 
      409 	     if iocb_ptr ^= null () then do;
      410 		call iox_$close (iocb_ptr, code);
      411 		call iox_$detach_iocb (iocb_ptr, code);
      412 	     end;
      413 
      414 	end ma_cleanup_handler;
      415 
      416 PROCESS_PATH: proc;					/* IP to deal with pathname, switches already set */
      417 
      418 dcl cpt_ptr ptr;
      419 dcl cpt char (32);
      420 dcl (sname, scpt) char (32);				/* results of equal processing */
      421 
      422 	     cpt = "";				/* can't have output in archive */
      423 	     if out_bit then call expand_pathname_ (arg, dn, en, code);
      424 	     else call expand_pathname_$component (arg, dn, en, cpt, code);
      425 	     if code ^= 0 then do;
      426 ARG_ERR:
      427 		call com_err_ (code, me, "^a", arg);
      428 		go to ABORT;
      429 	     end;
      430 
      431 	     if first_name = "" then do;
      432 		first_name = en;			/* first_name is template for equal conv */
      433 		first_cpt = cpt;
      434 		if first_is_orig then do;		/* if f_i_o then first path is orig */
      435 		     mai.have_orig, orig_bit = "1"b;	/* so simulate preceding "-orig" arg */
      436 		     expected = "original";
      437 		end;
      438 	     end;
      439 	     else do;				/* all but first ename get equal conv */
      440 		call get_equal_name_$component (first_name, first_cpt, en, cpt, sname, scpt, code);
      441 		if code ^= 0 then do;
      442 		     call com_err_ (code, me, "^a^[::^a^;^s^] ^a^[::^a^;^s^]",
      443 			first_name, (first_cpt ^= ""), first_cpt, en, (cpt ^= ""), cpt);
      444 		     go to ABORT;
      445 		end;
      446 		en = sname;			/* replace by expanded name */
      447 		cpt = scpt;
      448 	     end;
      449 
      450 	     if out_bit then do;
      451 		if CPA then do;
      452 		     attach_desc = "vfile_ " || rtrim (dn) || ">" || en;
      453 		     return;
      454 		end;
      455 		
      456 		else do				/* attempt to initiate real output segment now */
      457 						/* if it does not exist we will create it later */
      458 						/* if is does exist we will compare the pointer to input segments */
      459 		     mai.op_dirname = dn;
      460 		     mai.op_ename = en;
      461 		     call hcs_$initiate_count ((mai.op_dirname), (mai.op_ename), "", 0, 0, mai.op_ptr, code);
      462 		     if code ^= 0 then
      463 			if code ^= error_table_$noentry then
      464 			if code ^= error_table_$segknown then do;
      465 				call com_err_ (code, me, "^a^[>^]^a", dn, (dn ^= ">"), en);
      466 				go to ABORT;
      467 			end;
      468 		     sx = 1;
      469 						/* also create temporary seg for output */
      470 		     dn = "[pd]";
      471 		     en = "ma_temp." || rtrim (mai.op_ename);
      472 		     call hcs_$make_seg ("", en, "", 01011b, p, code);
      473 		     if p = null () then do;
      474 PATH_ERR:			call com_err_ (code, me, "^a^[>^]^a", dn, (dn ^= ">"), en);
      475 			go to ABORT;
      476 		     end;
      477 		     mai.tptr (1) = p;
      478 		end;
      479 	     end;					/* out_bit processing done */
      480 	     else do;				/* name of input seg */
      481 		if orig_bit then sx, mai.lo = 2;		/* note seg_index for later */
      482 		else do;				/* some updated version */
      483 		     mai.hi = mai.hi + 1;
      484 		     if mai.hi > ma_max_texts then do;
      485 			call com_err_ (0, me, "Only six versions and one original can be merged or compared.");
      486 			go to ABORT;
      487 		     end;
      488 		     sx = mai.hi;
      489 		end;
      490 		p = null ();
      491 		call hcs_$initiate_count (dn, en, "", bit_count, 0, p, code);
      492 		if p = null () then go to PATH_ERR;
      493 		mai.tptr (sx) = p;			/* set ptr now */
      494 		if bit_count = 0 then do;
      495 		     code = error_table_$zero_length_seg;
      496 		     go to PATH_ERR;
      497 		end;
      498 		mai.tchars (sx) = divide (bit_count+8, 9, 17, 0);
      499 		if edit_bit then mai.edit (sx) = "1"b;
      500 		mai.len (sx) = mai.tchars (sx);
      501 		if cpt ^= "" then do;		/* read archive? */
      502 		     call archive_$get_component (p, bit_count, cpt, cpt_ptr, cpt_bc, code);
      503 		     if code ^= 0 then do;
      504 			call com_err_ (code, me, "^a^[>^]^a::^a", dn, (dn ^= ">"), en, cpt);
      505 			go to ABORT;
      506 		     end;
      507 		     p, mai.tptr (sx) = cpt_ptr;		/* set ptr to archive element */
      508 		     mai.tchars (sx), mai.len (sx) = divide (cpt_bc+8, 9, 17, 0);
      509 		end;
      510 	     end;
      511 	     mai.cp (sx) = mai.tptr (sx);			/* fill in info structure */
      512 	     mai.line (sx) = 1;
      513 	     mai.dirname (sx) = dn;
      514 	     mai.ename (sx) = en;
      515 	     mai.component (sx) = cpt;
      516 
      517 	end PROCESS_PATH;
      518 
      519      end merge_ascii;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/12/88  1435.0  merge_ascii.pl1                   >spec>install>1055>merge_ascii.pl1
36           1    09/28/82  1437.6  merge_ascii_info.incl.pl1         >ldd>include>merge_ascii_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CPA                             000356 automatic       bit(1)                   initial packed unaligned dcl 92 set ref 92* 115* 167
                                                                                  239 278 382 383 451
MA                              000355 automatic       bit(1)                   initial packed unaligned dcl 92 set ref 92* 104* 204
                                                                                  230 306
MA_TEXT_IDS                     000000 constant        char(8)                  initial packed unaligned dcl 1-57 ref 148
abort_label              24     000404 automatic       label variable           level 3 dcl 98 set ref 154*
addr                                                   builtin function         dcl 74 ref 350 350
al                              000131 automatic       fixed bin(21,0)          dcl 79 set ref 130* 131 131 131 131 138 138 166* 168
                                                                                  168 168 169 169 169 170 171 171 175 175 179 179
                                                                                  180 180 180 181 181 182 182 183 183 185 185 187
                                                                                  189* 194 194 196 196 203 204 204 208 208 214 214
                                                                                  224 224 230 235 235 240* 247 247 281* 287 289 289
                                                                                  299 299 423 423 424 424 426 426
ap                              000132 automatic       pointer                  dcl 80 set ref 130* 131 131 131 131 138 138 166* 168
                                                                                  168 168 169 169 169 170 171 171 175 175 179 179
                                                                                  180 180 180 181 181 182 182 183 183 185 185 187
                                                                                  189* 194 196 203 204 204 208 208 214 214 224 230
                                                                                  235 240* 247 281* 287 289 299 423 424 426
archive_$get_component          000056 constant        entry                    external dcl 57 ref 502
arg                                    based           char                     packed unaligned dcl 82 set ref 131 131 131 131 138
                                                                                  138 168 168 168 169 169 169 170 171 171 175 175
                                                                                  179 179 180 180 180 181 181 182 182 183 183 185
                                                                                  185 187 194* 196* 203 204 204 208 208 214 214 224*
                                                                                  230 235* 247* 287 289* 299* 423* 424* 426*
attach_desc                     000134 automatic       char(256)                packed unaligned dcl 81 set ref 295* 295 296* 452*
baseno                                                 builtin function         dcl 74 ref 318 318
bit_count                       000370 automatic       fixed bin(24,0)          dcl 95 set ref 491* 494 498 502*
ch                                     based           char(999)                packed unaligned dcl 100 set ref 366* 366
cleanup                         000100 stack reference condition                dcl 69 ref 153
code                            000346 automatic       fixed bin(35,0)          dcl 89 set ref 105* 106 107* 117* 118 119* 130* 166*
                                                                                  189* 190 191* 194* 195 240* 241 247* 248 281* 282
                                                                                  283* 296* 297* 298 299* 307* 355* 359* 360 363*
                                                                                  367* 368 370* 376* 377 377* 392* 403* 410* 411*
                                                                                  423* 424* 425 426* 440* 441 442* 461* 462 462 462
                                                                                  465* 472* 474* 491* 495* 502* 503 504*
com_err_                        000024 constant        entry                    external dcl 44 ref 133 191 196 217 224 235 269 274
                                                                                  283 289 299 313 330 370 372 377 426 442 465 474
                                                                                  485 504
com_err_$suppress_name          000026 constant        entry                    external dcl 44 ref 107 119
component               400     000404 automatic       char(32)                 array level 3 dcl 98 set ref 329 330 330* 343 343*
                                                                                  515*
control                         000404 automatic       structure                level 2 dcl 98
convergence_ok           12     000404 automatic       bit(1)                   level 3 dcl 98 set ref 205*
cp                      122     000404 automatic       pointer                  array level 3 dcl 98 set ref 149* 511*
cpt                             001660 automatic       char(32)                 packed unaligned dcl 419 set ref 422* 424* 433 440*
                                                                                  442 442* 447* 501 502* 504* 515
cpt_bc                          000371 automatic       fixed bin(24,0)          dcl 95 set ref 502* 508
cpt_ptr                         001656 automatic       pointer                  dcl 418 set ref 502* 507
ct                              000316 automatic       char(32)                 packed unaligned dcl 85 set ref 322* 329* 330 330*
cu_$arg_count                   000062 constant        entry                    external dcl 59 ref 105 117
cu_$arg_ptr                     000060 constant        entry                    external dcl 58 ref 130 166 189 240 281
cv_dec_check_                   000046 constant        entry                    external dcl 53 ref 194 247
dirname                 316     000404 automatic       char(168)                array level 3 dcl 98 set ref 327 330* 330 343* 343
                                                                                  372* 377* 513*
divide                                                 builtin function         dcl 74 ref 498 508
dn                              000234 automatic       char(168)                packed unaligned dcl 83 set ref 320* 327* 330* 330
                                                                                  423* 424* 452 456 465* 465 470* 474* 474 491* 504*
                                                                                  504 513
edit                    132     000404 automatic       bit(1)                   array level 3 dcl 98 set ref 499*
edit_bit                        000347 automatic       bit(1)                   packed unaligned dcl 91 set ref 164* 232* 499
en                              000306 automatic       char(32)                 packed unaligned dcl 84 set ref 321* 328* 330* 423*
                                                                                  424* 432 440* 442* 446* 452 460 465* 471* 472*
                                                                                  474* 491* 504* 514
ename                   370     000404 automatic       char(32)                 array level 3 dcl 98 set ref 328 330* 343* 372* 377*
                                                                                  514*
error_table_$badopt             000076 external static fixed bin(35,0)          dcl 61 set ref 235*
error_table_$inconsistent       000070 external static fixed bin(35,0)          dcl 61 set ref 274*
error_table_$noarg              000066 external static fixed bin(35,0)          dcl 61 set ref 289* 307
error_table_$noentry            000102 external static fixed bin(35,0)          dcl 61 ref 462
error_table_$rqover             000100 external static fixed bin(35,0)          dcl 61 ref 363
error_table_$segknown           000072 external static fixed bin(35,0)          dcl 61 ref 462
error_table_$zero_length_seg    000074 external static fixed bin(35,0)          dcl 61 ref 495
expand_pathname_                000052 constant        entry                    external dcl 55 ref 423
expand_pathname_$component      000054 constant        entry                    external dcl 56 ref 424
expected                        000373 automatic       char(32)                 packed unaligned dcl 97 set ref 187* 191* 196* 200
                                                                                  209* 215* 217* 231* 253* 258* 308* 436*
extend                          000351 automatic       bit(1)                   packed unaligned dcl 91 set ref 126* 170* 172* 295
first_cpt                       000336 automatic       char(32)                 packed unaligned dcl 87 set ref 433* 440* 442 442*
first_is_orig                   000357 automatic       bit(1)                   initial packed unaligned dcl 93 set ref 93* 125* 132
                                                                                  136* 434
first_name                      000326 automatic       char(32)                 packed unaligned dcl 86 set ref 157* 431 432* 440*
                                                                                  442*
get_equal_name_$component       000044 constant        entry                    external dcl 52 ref 440
have_edit                11     000404 automatic       bit(1)                   level 3 dcl 98 set ref 232*
have_orig                 7     000404 automatic       bit(1)                   level 3 dcl 98 set ref 211 212* 312 435*
have_output              10     000404 automatic       bit(1)                   level 3 dcl 98 set ref 216 228* 273 278 303* 306 318
                                                                                  353
have_tc_or_ex                   000350 automatic       bit(1)                   packed unaligned dcl 91 set ref 127* 170* 173* 273
hcs_$delentry_seg               000014 constant        entry                    external dcl 40 ref 376 392
hcs_$initiate_count             000042 constant        entry                    external dcl 50 ref 461 491
hcs_$make_seg                   000020 constant        entry                    external dcl 42 ref 355 472
hcs_$set_bc_seg                 000016 constant        entry                    external dcl 41 ref 367 369
hcs_$terminate_noname           000050 constant        entry                    external dcl 54 ref 403 406
hcs_$truncate_seg               000012 constant        entry                    external dcl 39 ref 359
hi                        3     000404 automatic       fixed bin(21,0)          level 3 dcl 98 set ref 161* 268 317 325 341 483* 483
                                                                                  484 488
i                               000124 automatic       fixed bin(21,0)          dcl 76 set ref 129* 130* 147* 148 148 149 149* 160*
                                                                                  162 163* 163 166* 188* 188 189* 222 238* 238 240*
                                                                                  317* 318 325 326 330 330 330 330 330* 341* 342 343
                                                                                  343 343 343 343 343 343* 402* 403 403*
index                                                  builtin function         dcl 74 ref 203 287
ioa_$ioa_switch                 000022 constant        entry                    external dcl 44 ref 343 383 384
iocb_ptr                        000364 automatic       pointer                  dcl 94 set ref 152* 296* 297* 302 409 410* 411*
iox_$attach_name                000032 constant        entry                    external dcl 46 ref 296
iox_$close                      000036 constant        entry                    external dcl 46 ref 410
iox_$detach_iocb                000040 constant        entry                    external dcl 46 ref 411
iox_$open                       000034 constant        entry                    external dcl 46 ref 297
iox_$user_output                000030 external static pointer                  dcl 45 ref 151 182
j                               000125 automatic       fixed bin(21,0)          dcl 76 set ref 325* 326 327 328 329*
k                               000126 automatic       fixed bin(21,0)          dcl 76 set ref 194* 199 200 201 247* 252 257 261
len                     124     000404 automatic       fixed bin(21,0)          array level 3 dcl 98 set ref 500* 508*
line                    125     000404 automatic       fixed bin(21,0)          array level 3 dcl 98 set ref 512*
lo                        2     000404 automatic       fixed bin(21,0)          level 3 dcl 98 set ref 161* 268 317 341 481*
ma_info                                based           structure                level 1 dcl 1-12
ma_max_texts                           constant        fixed bin(21,0)          initial dcl 1-58 ref 147 402 484
mai                             000404 automatic       structure                level 1 dcl 98 set ref 143* 350 350
me                              000114 automatic       char(16)                 dcl 72 set ref 103* 107* 114* 119* 133* 191* 196*
                                                                                  217* 224* 235* 269* 274* 283* 289* 299* 313* 330*
                                                                                  370* 372* 377* 426* 442* 465* 474* 485* 504*
merge_ascii_                    000010 constant        entry                    external dcl 38 ref 350
minchars                  1     000404 automatic       fixed bin(21,0)          level 3 dcl 98 set ref 156* 201* 252*
minlines                        000404 automatic       fixed bin(21,0)          level 3 dcl 98 set ref 155* 200* 257*
nargs                           000127 automatic       fixed bin(21,0)          dcl 77 set ref 105* 106 117* 118 129 162 223
no_header                       000352 automatic       bit(1)                   packed unaligned dcl 91 set ref 158* 177* 179* 294
no_line_numbers          20     000404 automatic       bit(1)                   level 3 dcl 98 set ref 180*
no_totals                22     000404 automatic       bit(1)                   level 3 dcl 98 set ref 169* 381
null                                                   builtin function         dcl 74 ref 145 149 152 296 296 318 342 354 356 392
                                                                                  403 406 409 473 490 492
of_arg                          000130 automatic       fixed bin(21,0)          dcl 78 set ref 124* 222* 223 281*
old_mins_ok                     000360 automatic       bit(1)                   initial packed unaligned dcl 93 set ref 93* 126*
                                                                                  139* 245
op_dirname               30     000404 automatic       char(168)                level 3 dcl 98 set ref 146* 320 355 370* 370 456*
                                                                                  461
op_ename                102     000404 automatic       char(32)                 level 3 dcl 98 set ref 146* 321 355 370* 460* 461
                                                                                  471
op_ptr                  112     000404 automatic       pointer                  level 3 dcl 98 set ref 145* 318 318 354 355* 356
                                                                                  359* 366 367* 406 406* 461*
operation                       000120 automatic       char(16)                 dcl 72 set ref 382* 382* 384*
orig_bit                        000353 automatic       bit(1)                   packed unaligned dcl 91 set ref 164* 212* 435* 481
out_bit                         000354 automatic       bit(1)                   packed unaligned dcl 91 set ref 164* 228* 239 279*
                                                                                  423 450
output_iocb_ptr         114     000404 automatic       pointer                  level 3 dcl 98 set ref 151* 182* 302* 343* 383* 384*
p                               000366 automatic       pointer                  dcl 94 set ref 472* 473 477 490* 491* 492 493 502*
                                                                                  507*
per_text_info           116     000404 automatic       structure                array level 2 dcl 98
print_heading            17     000404 automatic       bit(1)                   level 3 dcl 98 set ref 176* 294* 340
print_new_lines          21     000404 automatic       bit(1)                   level 3 dcl 98 set ref 181* 312
record_quota_overflow           000106 stack reference condition                dcl 70 ref 362
rtrim                                                  builtin function         dcl 74 ref 295 452 471
saw_minchars                    000362 automatic       bit(1)                   initial packed unaligned dcl 93 set ref 93* 250 251*
saw_minlines                    000361 automatic       bit(1)                   initial packed unaligned dcl 93 set ref 93* 255 256*
scpt                            001700 automatic       char(32)                 packed unaligned dcl 420 set ref 440* 447
sname                           001670 automatic       char(32)                 packed unaligned dcl 420 set ref 440* 446
substr                                                 builtin function         dcl 74 set ref 148 187 366* 366
sx                              000372 automatic       fixed bin(21,0)          dcl 96 set ref 468* 481* 488* 493 498 499 500 500
                                                                                  507 508 508 511 511 512 513 514 515
tchars                  120     000404 automatic       fixed bin(21,0)          array level 3 dcl 98 set ref 366 366 367 369 498*
                                                                                  500 508*
text_id                 316     000404 automatic       structure                array level 2 dcl 98
textid                  131     000404 automatic       char(1)                  array level 3 dcl 98 set ref 148* 343*
total_differences        14     000404 automatic       fixed bin(21,0)          level 3 dcl 98 set ref 383 384* 384
total_lines_differing
                         15     000404 automatic       fixed bin(21,0)          level 3 dcl 98 set ref 384* 384
totals_only              16     000404 automatic       bit(1)                   level 3 dcl 98 set ref 168*
tptr                    116     000404 automatic       pointer                  array level 3 dcl 98 set ref 149* 318 326 326 342
                                                                                  366 369* 376* 392 392* 403 403* 477* 493* 507* 511
unique_chars_                   000064 constant        entry                    external dcl 60 ref 296
unspec                                                 builtin function         dcl 74 set ref 143*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ma_info_ptr                            automatic       pointer                  dcl 1-5
ma_text_ids                            internal static char(8)                  initial packed unaligned dcl 1-56

NAMES DECLARED BY EXPLICIT CONTEXT.
ABORT                           003665 constant        label                    dcl 392 ref 154 192 197 219 225 236 270 284 290 300
                                                                                  314 333 428 444 466 475 486 505
ARG_ERR                         004114 constant        label                    dcl 426
BADNUM                          001532 constant        label                    dcl 196 ref 199 261
BAD_ARG                         002014 constant        label                    dcl 235 ref 255
COMMON_ARGS                     001415 constant        label                    dcl 185 ref 167
NOARG                           001453 constant        label                    dcl 191 ref 241 309
ONLYONE                         001677 constant        label                    dcl 217 ref 211
OP_ERR                          003346 constant        label                    dcl 369 ref 356 360 364
ORIG                            001651 constant        label                    dcl 209 ref 206
PATH_ERR                        004631 constant        label                    dcl 474 ref 492 496
PROCESS_PATH                    004020 constant        entry                    internal dcl 416 ref 242 245 248 293
SAMESEG                         002723 constant        label                    dcl 330 ref 323
common                          001065 constant        label                    dcl 143 ref 110
compare_ascii                   000670 constant        entry                    external dcl 113
cpa                             000660 constant        entry                    external dcl 113
ma                              000571 constant        entry                    external dcl 25
ma_cleanup_handler              003710 constant        entry                    internal dcl 401 ref 153 389 395
merge_ascii                     000601 constant        entry                    external dcl 25

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5622        5726    5216        5632
Length      6220    5216       104         256     404           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ma                                 1298 external procedure  is an external procedure.  
on unit on line 153                  64 on unit               
on unit on line 362                  64 on unit               
ma_cleanup_handler                   72 internal procedure  is called by several nonquick procedures.  
PROCESS_PATH                            internal procedure  shares stack frame of external procedure ma.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
ma                       000114 me                          ma
                         000120 operation                   ma
                         000124 i                           ma
                         000125 j                           ma
                         000126 k                           ma
                         000127 nargs                       ma
                         000130 of_arg                      ma
                         000131 al                          ma
                         000132 ap                          ma
                         000134 attach_desc                 ma
                         000234 dn                          ma
                         000306 en                          ma
                         000316 ct                          ma
                         000326 first_name                  ma
                         000336 first_cpt                   ma
                         000346 code                        ma
                         000347 edit_bit                    ma
                         000350 have_tc_or_ex               ma
                         000351 extend                      ma
                         000352 no_header                   ma
                         000353 orig_bit                    ma
                         000354 out_bit                     ma
                         000355 MA                          ma
                         000356 CPA                         ma
                         000357 first_is_orig               ma
                         000360 old_mins_ok                 ma
                         000361 saw_minlines                ma
                         000362 saw_minchars                ma
                         000364 iocb_ptr                    ma
                         000366 p                           ma
                         000370 bit_count                   ma
                         000371 cpt_bc                      ma
                         000372 sx                          ma
                         000373 expected                    ma
                         000404 mai                         ma
                         001656 cpt_ptr                     PROCESS_PATH
                         001660 cpt                         PROCESS_PATH
                         001670 sname                       PROCESS_PATH
                         001700 scpt                        PROCESS_PATH

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out
call_int_this       call_int_other      return_mac          tra_ext_1           enable_op           shorten_stack
ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
archive_$get_component        com_err_                      com_err_$suppress_name        cu_$arg_count
cu_$arg_ptr                   cv_dec_check_                 expand_pathname_              expand_pathname_$component
get_equal_name_$component     hcs_$delentry_seg             hcs_$initiate_count           hcs_$make_seg
hcs_$set_bc_seg               hcs_$terminate_noname         hcs_$truncate_seg             ioa_$ioa_switch
iox_$attach_name              iox_$close                    iox_$detach_iocb              iox_$open
merge_ascii_                  unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$inconsistent     error_table_$noarg            error_table_$noentry
error_table_$rqover           error_table_$segknown         error_table_$zero_length_seg  iox_$user_output




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     92 000560        93 000562        25 000570       103 000607       104 000612       105 000614       106 000625
    107 000631       108 000655       110 000656       113 000657       114 000676       115 000701       117 000703
    118 000714       119 000720       120 000744       124 000745       125 000746       126 000750       127 000752
    129 000753       130 000761       131 000776       132 001020       133 001022       134 001047       136 001050
    137 001051       138 001052       139 001062       141 001063       143 001065       145 001070       146 001072
    147 001100       148 001107       149 001116       150 001121       151 001123       152 001127       153 001131
    154 001153       155 001156       156 001160       157 001162       158 001165       160 001166       161 001167
    161 001171       162 001173       163 001177       164 001200       166 001203       167 001220       168 001222
    169 001243       170 001262       171 001272       172 001302       173 001303       174 001305       175 001306
    176 001316       177 001320       178 001321       179 001322       180 001335       181 001354       182 001367
    183 001404       185 001415       187 001427       188 001433       189 001434       190 001451       191 001453
    192 001502       194 001503       195 001530       196 001532       197 001575       199 001576       200 001600
    201 001606       202 001607       203 001610       204 001622       205 001635       206 001637       208 001640
    209 001651       211 001654       212 001656       213 001661       214 001662       215 001672       216 001675
    217 001677       219 001730       222 001731       223 001734       224 001736       225 001772       228 001773
    229 001776       230 001777       231 002005       232 002010       233 002013       235 002014       236 002046
    238 002047       239 002050       240 002054       241 002071       242 002073       244 002074       245 002075
    247 002101       248 002126       250 002132       251 002134       252 002136       253 002140       254 002143
    255 002144       256 002146       257 002150       258 002152       261 002155       264 002156       268 002157
    269 002162       270 002207       273 002210       274 002214       275 002240       278 002241       279 002245
    281 002247       282 002264       283 002266       284 002303       287 002304       289 002320       290 002353
    293 002354       294 002355       295 002361       296 002411       297 002471       298 002512       299 002514
    300 002550       302 002551       303 002553       306 002554       307 002560       308 002563       309 002566
    312 002567       313 002573       314 002620       317 002621       318 002631       320 002650       321 002653
    322 002656       323 002661       325 002662       326 002673       327 002705       328 002713       329 002717
    330 002723       333 003043       335 003044       336 003046       340 003050       341 003052       342 003061
    343 003067       347 003165       350 003167       353 003200       354 003202       355 003206       356 003253
    357 003257       359 003260       360 003274       362 003276       363 003312       364 003315       366 003320
    367 003326       368 003344       369 003346       370 003365       372 003434       374 003471       376 003472
    377 003503       381 003544       382 003546       382 003554       383 003557       384 003606       389 003660
    390 003664       392 003665       395 003702       396 003706       401 003707       402 003715       403 003726
    405 003746       406 003751       409 003767       410 003774       411 004005       414 004017       416 004020
    422 004021       423 004024       424 004057       425 004112       426 004114       428 004146       431 004147
    432 004153       433 004156       434 004161       435 004163       436 004166       438 004171       440 004172
    441 004226       442 004230       444 004312       446 004313       447 004316       450 004321       451 004323
    452 004325       453 004374       456 004376       460 004401       461 004404       462 004455       465 004464
    466 004532       468 004533       470 004535       471 004540       472 004566       473 004625       474 004631
    475 004700       477 004701       479 004703       481 004704       483 004712       484 004713       485 004716
    486 004743       488 004744       490 004745       491 004747       492 005011       493 005015       494 005021
    495 005024       496 005027       498 005030       499 005034       500 005040       501 005041       502 005045
    503 005100       504 005102       505 005153       507 005154       508 005161       511 005167       512 005173
    513 005176       514 005204       515 005210       517 005214


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
