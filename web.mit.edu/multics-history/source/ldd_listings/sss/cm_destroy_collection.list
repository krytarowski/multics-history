	COMPILATION LISTING OF SEGMENT cm_destroy_collection
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/04/85  0951.5 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /* DESCRIPTION:
        9*
       10*         This  routine  destroys  a collection in a DM file.  Currently, only
       11*     collections which employ the Unblocked Control  Interval  Storage  Method
       12*     can  be  destroyed.  Each control interval of the collection is freed, as
       13*     well  as  all  associated  header   information,   which   includes   the
       14*     collection_header,    the   storage_record   and   the   entry   in   the
       15*     collection_id_table.
       16*
       17*          In the future (post MR11) when creation of Blocked collections is
       18*     supported, this module will also support the deletion of Blocked
       19*     collections.  Deleting Blocked collections requires following an
       20*     allocation map, rather than a control interval thread.
       21**/
       22 
       23 /* HISTORY:
       24*Written by Matthew Pierret, 03/21/83.
       25*Modified:
       26*02/07/84 by Matthew Pierret:  Changed to use cm_get_element instead of
       27*            cm_get_element$info.  The latter entry is now obsolete.
       28*05/21/84 by Matthew Pierret:  Renamed include file dm_cm_cism_info to
       29*            dm_cism_info.  Added er_p_code parameter to ERROR_RETURN.
       30*            Changed to use local variable code instead of parameter p_code.
       31*06/12/84 by Matthew Pierret:  Re-named cm_put_element to cm_modify.
       32*07/24/84 by Matthew Pierret:  Changed to use cm_free_ci$raw_return_prev_next
       33*            instead of using cm_free_ci$info then relying on it to have updated
       34*            unblocked_storage_record.first_control_interval.  The new entry
       35*            frees the control itnerval without bothering to update headers
       36*            and re-thread threads, and returns the value of the next ci id.
       37*09/26/84 by Matthew Pierret: Added comment indicating that Blocked collections
       38*            are not supported but will be in the future.
       39**/
       40 
       41 /* format: style2,ind3 */
       42 
       43 cm_destroy_collection:
       44    proc (p_file_opening_id, p_collection_id, p_code);
       45 
       46 
       47 /* START OF DECLARATIONS */
       48 /* Parameter */
       49 
       50       dcl	    p_file_opening_id      bit (36) aligned parameter;
       51       dcl	    p_collection_id	       bit (36) aligned parameter;
       52       dcl	    p_code	       fixed bin (35) parameter;
       53 
       54 /* Automatic */
       55 
       56       dcl	    1 local_cm_file_header aligned like cm_file_header;
       57       dcl	    hc_cm_info_ptr	       ptr init (null);
       58       dcl	    is_unblocked	       bit (1) aligned init ("1"b);
       59       dcl	    (header_record_element_id, collection_header_element_id, collection_id, file_opening_id,
       60 	    storage_record_element_id)
       61 			       bit (36) aligned init ("0"b);
       62       dcl	    ci_count	       fixed bin (24);
       63       dcl	    collection_idx	       fixed bin;
       64       dcl	    code		       fixed bin (35);
       65       dcl	    collection_id_table_length
       66 			       fixed bin (35) init (0);
       67       dcl	    (current_ci_id, first_ci_id, last_ci_id, next_ci_id)
       68 			       fixed bin (24) unsigned;
       69 
       70 /* Based */
       71 
       72       dcl	    dm_work_area	       area (sys_info$max_seg_size) based (dm_work_area_ptr);
       73       dcl	    collection_id_table_buffer
       74 			       aligned bit (collection_id_table_length) based (collection_id_table_ptr);
       75 
       76 /* Builtin */
       77 
       78       dcl	    (addr, ceil, divide, length, null, unspec)
       79 			       builtin;
       80 
       81 /* Condition */
       82 
       83       dcl	    cleanup	       condition;
       84 
       85 /* Constant */
       86 
       87       dcl	    myname	       init ("cm_destroy_collection") char (32) varying internal static options (constant);
       88       dcl	    (
       89 	    BITS_PER_WORD	       init (36),
       90 	    DEFAULT_POSITION       init (0)
       91 	    )		       fixed bin internal static options (constant);
       92       dcl	    LIMIT_TO_STOP_INFINITE_LOOPING
       93 			       init (1e6) fixed bin (35) internal static options (constant);
       94       dcl	    DONT_ZERO_ON_FREE      init ("0"b) bit (1) aligned internal static options (constant);
       95 
       96 /* Entry */
       97 
       98       dcl	    sub_err_	       entry () options (variable);
       99       dcl	    get_dm_free_area_      entry () returns (ptr);
      100 
      101 /* External */
      102 
      103       dcl	    (
      104 	    error_table_$unimplemented_version,
      105 	    sys_info$max_seg_size,
      106 	    dm_error_$programming_error,
      107 	    dm_error_$unimplemented_cism
      108 	    )		       fixed bin (35) ext;
      109 
      110 /* Static */
      111 
      112       dcl	    dm_work_area_ptr       ptr init (null) internal static;
      113 
      114 /* END OF DECLARATIONS */
      115 
      116 /* format: ^indblkcom,indcomtxt */
      117 
      118       p_code, code = 0;
      119 
      120       file_opening_id = p_file_opening_id;
      121       collection_id = p_collection_id;
      122 
      123       collection_id_table_ptr = null;
      124 
      125    /*** Get opening info for the header collection (hc_cm_info_ptr). ***/
      126 
      127       call cm_opening_info$full_get (file_opening_id, HEADER_COLLECTION_ID, hc_cm_info_ptr, code);
      128       if code ^= 0
      129       then call ERROR_RETURN (code);
      130 
      131    /*** Get the opening info (cm_info) for this collection. ***/
      132 
      133       call cm_opening_info$full_get (file_opening_id, collection_id, cm_info_ptr, code);
      134       if code ^= 0
      135       then call ERROR_RETURN (code);
      136 
      137       call CHECK_VERSION (cm_info.version, CM_INFO_VERSION_2, "cm_info");
      138 
      139       collection_header_ptr = cm_info.header_ptr;
      140       call CHECK_VERSION (collection_header.version, COLLECTION_HEADER_VERSION_2, "collection_header");
      141 
      142       if collection_header.control_interval_storage_method ^= UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
      143       then call sub_err_ (dm_error_$unimplemented_cism, myname, ACTION_CANT_RESTART, null, 0,
      144 	      "^/This operation only supports control interval storage method ^d;^/^10xreceived method ^d.",
      145 	      UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD, collection_header.control_interval_storage_method);
      146 						/* In the future (post MR11) deletion of */
      147 						/* Blocked collections will be supported. */
      148       else
      149          do;
      150 
      151          /*** This is an Unblocked collection. Set up the unblocked_storage_record,
      152*	    and  get the ids of the first and last control intervals of the collection. ***/
      153 
      154 	  unblocked_storage_record_ptr = cm_info.storage_record_ptr;
      155 
      156 	  first_ci_id = unblocked_storage_record.first_control_interval;
      157 	  last_ci_id = unblocked_storage_record.last_control_interval;
      158 
      159          end;
      160 
      161    /*** Save the element ids of elements related to this element which are
      162*        stored in the Header Collection. ***/
      163 
      164       collection_header_element_id = collection_id;
      165       header_record_element_id = collection_header.header_record_element_id;
      166       storage_record_element_id = collection_header.storage_record_element_id;
      167 
      168 /**** Prepare to begin destruction. ***/
      169 
      170       collection_id_table_ptr = null;
      171       if dm_work_area_ptr = null
      172       then dm_work_area_ptr = get_dm_free_area_ ();
      173       on cleanup call FINISH ();
      174 
      175 /**** Free all of the control intervals in the collection. ***/
      176 
      177       current_ci_id = first_ci_id;
      178 
      179       do ci_count = 1 to LIMIT_TO_STOP_INFINITE_LOOPING while (current_ci_id > 0);
      180 
      181          call cm_free_ci$raw_return_prev_next (cm_info_ptr, current_ci_id, "1"b, (0), next_ci_id, code);
      182          if code ^= 0
      183          then call ERROR_RETURN (code);
      184 
      185          current_ci_id = next_ci_id;
      186       end;
      187 
      188 /**** Free the opening info for his collection. ***/
      189 
      190       call cm_free_opening_info (file_opening_id, collection_id, code);
      191       if code ^= 0
      192       then call ERROR_RETURN (code);
      193       cm_info_ptr = null;
      194 
      195 /**** Remove the collection_id from the collection_id_table. ***/
      196 
      197    /*** Get the cm_file_header, to find the location of the collection_id_table. ***/
      198 
      199       call cm_get_element (file_opening_id, HEADER_COLLECTION_ID, CM_FILE_HEADER_ELEMENT_ID, DEFAULT_POSITION,
      200 	 addr (local_cm_file_header), length (unspec (local_cm_file_header)), null, ("0"b), cm_file_header_ptr, (0),
      201 	 code);
      202       if code ^= 0
      203       then call ERROR_RETURN (code);
      204       call CHECK_VERSION (cm_file_header.version, CM_FILE_HEADER_VERSION_1, "cm_file_header");
      205 
      206    /*** Get the collection_id_table. ***/
      207 
      208       cit_number_of_collections = cm_file_header.number_of_collections;
      209 
      210       call cm_get_element (file_opening_id, HEADER_COLLECTION_ID, cm_file_header.collection_id_table_element_id,
      211 	 DEFAULT_POSITION, null, (0), dm_work_area_ptr, ("1"b), collection_id_table_ptr, collection_id_table_length,
      212 	 code);
      213       if code ^= 0
      214       then call ERROR_RETURN (code);
      215 
      216       if ceil (divide (collection_id_table_length, BITS_PER_WORD, 35, 18)) ^= cit_number_of_collections
      217       then call sub_err_ (dm_error_$programming_error, myname, ACTION_CAN_RESTART, null, 0,
      218 	      "^/The actual size of the collection_id_table, ^d entries, differs from the^/number of collections, ^d.",
      219 	      ceil (divide (collection_id_table_length, BITS_PER_WORD, 35, 18)), cit_number_of_collections);
      220 
      221    /*** Find the entry in the collection_id_table which holds this collection_id. ***/
      222 
      223       do collection_idx = 1 to cit_number_of_collections while (collection_id_table (collection_idx) ^= collection_id);
      224       end;
      225 
      226       if collection_idx <= cit_number_of_collections
      227       then
      228          do;
      229 
      230          /*** The collection id is in collection_id_table (collection_idx). Remove it,
      231*	    recover the entry and replace the collection_id_table in the file. ***/
      232 
      233 	  if collection_idx ^= cit_number_of_collections
      234 	  then collection_id_table (collection_idx) = collection_id_table (cit_number_of_collections);
      235 	  cit_number_of_collections = cit_number_of_collections - 1;
      236 
      237 	  call cm_modify$info (hc_cm_info_ptr, collection_id_table_ptr, length (unspec (collection_id_table)),
      238 	       cm_file_header.collection_id_table_element_id, (0), code);
      239 	  if code ^= 0
      240 	  then call ERROR_RETURN (code);
      241 
      242 	  cm_file_header.number_of_collections = cit_number_of_collections;
      243 
      244 	  call cm_modify$info (hc_cm_info_ptr, cm_file_header_ptr, length (unspec (cm_file_header)),
      245 	       CM_FILE_HEADER_ELEMENT_ID, (0), code);
      246 	  if code ^= 0
      247 	  then call ERROR_RETURN (code);
      248 
      249          end;
      250 
      251 /**** Free all per-collection header information in the file: the collection_header,
      252*      storage_record and caller header. ***/
      253 
      254       call cm_delete$info (hc_cm_info_ptr, collection_header_element_id, DONT_ZERO_ON_FREE, code);
      255       if code ^= 0
      256       then call ERROR_RETURN (code);
      257 
      258       call cm_delete$info (hc_cm_info_ptr, storage_record_element_id, DONT_ZERO_ON_FREE, code);
      259       if code ^= 0
      260       then call ERROR_RETURN (code);
      261 
      262       call cm_delete$info (hc_cm_info_ptr, header_record_element_id, DONT_ZERO_ON_FREE, code);
      263       if code ^= 0
      264       then call ERROR_RETURN (code);
      265 
      266 /**** Finished ****/
      267 
      268       call FINISH ();
      269 MAIN_RETURN:
      270       return;					/* Effective end of cm_destroy_collection */
      271 
      272 ERROR_RETURN:
      273    proc (er_p_code);
      274 
      275       dcl	    er_p_code	       fixed bin (35);
      276 
      277       p_code = er_p_code;
      278       call FINISH ();
      279       goto MAIN_RETURN;
      280 
      281    end ERROR_RETURN;
      282 
      283 
      284 
      285 FINISH:
      286    proc ();
      287 
      288       if collection_id_table_ptr ^= null
      289       then free collection_id_table_buffer in (dm_work_area);
      290 
      291    end FINISH;
      292 
      293 CHECK_VERSION:
      294    proc (cv_p_received_version, cv_p_expected_version, cv_p_structure_name);
      295       dcl	    cv_p_received_version  char (8) aligned;
      296       dcl	    cv_p_expected_version  char (8) aligned;
      297       dcl	    cv_p_structure_name    char (*);
      298 
      299       if cv_p_received_version ^= cv_p_expected_version
      300       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      301 	      "^/Expected version ^8a of the ^a structure.
      302 Received version ^8a instead.", cv_p_expected_version, cv_p_structure_name, cv_p_received_version);
      303 
      304    end CHECK_VERSION;
      305 
  1     1 /* BEGIN INCLUDE FILE - dm_hdr_collection_id.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*
  1     5*        Contains the identifier of the Header Collection for a file
  1     6*   managed by the collection_manager_.  This is used by callers of 
  1     7*   collection_manager who wish to maintain their own file header or who wish
  1     8*   to maintain their own collection header information beyond the caller
  1     9*   collection header provided by colleciton_manager_$(get put)_header.
  1    10**/
  1    11 
  1    12 /* HISTORY:
  1    13*Written by Matthew Pierret, 09/24/84.
  1    14*Modified:
  1    15**/
  1    16 
  1    17 /* format: style2,ind3,ll79 */
  1    18 
  1    19      dcl	   HEADER_COLLECTION_ID   init ("000000000001"b3) bit (36)
  1    20 			      aligned internal static options (constant);
  1    21 
  1    22 /* END INCLUDE FILE - dm_hdr_collection_id.incl.pl1 */
      306 
      307 
  2     1 /* BEGIN INCLUDE FILE dm_cm_hdr_col_ids.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*   Contains element identifiers of some elements in the Header Collection.
  2     6*   HEADER_COLLECTION_HEADER_ELEMENT_ID is the identifier of the element in
  2     7*   which the collection_header for the Header Collection is stored (see
  2     8*   dm_cm_collection_header.incl.pl1).
  2     9*   CALLER_HEADER_ELEMENT_ID is the identifier of the element in which the
  2    10*   caller's file header is stored.
  2    11*   CM_FILE_HEADER_ELEMENT_ID is the identifier of the element in which the
  2    12*   cm_file_header structure is stored (see dm_cm_file_header.incl.pl1).
  2    13**/
  2    14 
  2    15 /* HISTORY:
  2    16*Written by Matthew Pierret, 09/24/84.
  2    17*Modified:
  2    18**/
  2    19 
  2    20 /* format: style2,ind3,ll79 */
  2    21      dcl	   (
  2    22 	   HEADER_COLLECTION_HEADER_ELEMENT_ID
  2    23 			      init ("000000000001"b3),
  2    24 	   CM_FILE_HEADER_ELEMENT_ID
  2    25 			      init ("000000000002"b3),
  2    26 	   CALLER_HEADER_ELEMENT_ID
  2    27 			      init ("000000000003"b3)
  2    28 	   )		      bit (36) aligned int static
  2    29 			      options (constant);
  2    30 
  2    31 /* END INCLUDE FILE  dm_cm_hdr_col_ids.incl.pl1 */
      308 
      309 
  3     1 /* BEGIN INCLUDE FILE - dm_cm_info.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*        The cm_info structure is used to hold per-process opening information
  3     5*   about a collection.  It is generally allocated in the process' DM free
  3     6*   area, as returned by the function get_dm_free_area_.  The opening_manager_
  3     7*   is used to provide access the cm_info structure, keeping it in a hash
  3     8*   table keyed on file opening id and collection id combined.
  3     9*        Currently cm_info is never freed until the process terminates.  Each
  3    10*   time a new transaction is started, detected when the current transaction
  3    11*   id of a process differs from cm_info.current_transaction_id, the information
  3    12*   in cm_info is refreshed.  Storage record information is only refreshed on
  3    13*   demand, as most modules do not need the information in the storage record.
  3    14*   Instead, cm_info.storage_record_ptr is set to null (), but 
  3    15*   cm_info.storage_record_buffer_ptr remains set to the previous value of
  3    16*   cm_info.storage_record_ptr.  When a refreshed copy of the storage record is
  3    17*   requested, it is placed at the location pointed to by
  3    18*   cm_info.storage_record_buffer_ptr, saving the expense of re-allocation.
  3    19**/
  3    20 
  3    21 /* HISTORY:
  3    22*Written by Matthew Pierret, 10/27/82. 
  3    23*Modified:
  3    24*01/25/83 by Matthew Pierret: Changed to version 2.  Added 
  3    25*            storage_record_buffer_ptr. This points to the storage_record.
  3    26*            When cm_info is refreshed, storage_record_ptr is set to null,
  3    27*            but storage_record_buffer_ptr continues to point at where the
  3    28*            storage_record was. When the storge_record is again requested,
  3    29*            it is put back in the same place rather than allocating a new
  3    30*            storage_record.
  3    31*09/24/84 by Matthew Pierret:  Re-wrote DESCRIPTION section. Removed the
  3    32*            init clause from the version component.
  3    33**/
  3    34 
  3    35 /* format: style2,ind3,ll79 */
  3    36 
  3    37      dcl	   1 cm_info	      aligned based (cm_info_ptr),
  3    38 	     2 version	      char (8),
  3    39 	     2 current_txn_id     bit (36) aligned init ("0"b),
  3    40 	     2 file_oid	      bit (36) aligned init ("0"b),
  3    41 	     2 collection_id      bit (36) aligned init ("0"b),
  3    42 	     2 header_ptr	      ptr init (null),
  3    43 	     2 storage_record_ptr ptr init (null),
  3    44 	     2 storage_record_buffer_ptr
  3    45 			      ptr init (null);
  3    46 
  3    47      dcl	   cm_info_ptr	      ptr init (null);
  3    48      dcl	   CM_INFO_VERSION_2      init ("cm_info2") char (8) aligned
  3    49 			      internal static options (constant);
  3    50 
  3    51 /* END INCLUDE FILE - dm_cm_info.incl.pl1 */
      310 
      311 
  4     1 /* BEGIN INCLUDE FILE - dm_cm_collection_header.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*       Associated with each collection is the following collection_header
  4     5*   structure stored as an element in the Header Collection of the file.
  4     6*   The identifier of this element is also the idenfifier of the collection.
  4     7*   Even the Header Collection has a collection_header stored in the Header
  4     8*   Collection itself in the element identified by the constant
  4     9*   HEADER_COLLECTION_HEADER_ELEMENT_ID declared in dm_cm_hdr_col_ids.incl.pl1.
  4    10*   The information in collection_header is expected to be stable information.
  4    11*   The structure elements are described as follows:
  4    12*   
  4    13*   version is a character string version equal to COLLECTION_HEADER_VERSION_2.
  4    14*   
  4    15*   flags.fixed_size_elements indicates, if on that all elements in the
  4    16*   collection are of a fixed length.
  4    17*   
  4    18*   flags.thread_elements indicates that elements in a collection are to be
  4    19*   threaded in a linked list.  This is currrently unupported.
  4    20*   
  4    21*   flags.thread_control_intervals indicates, if on, that control intervals in
  4    22*   a collection are to be threaded in a linked list.  This is only useful if
  4    23*   the control interval storage method is blocked.
  4    24*   
  4    25*   flags.must_be_zero1 is reserved for future use and must be "0"b.
  4    26*   
  4    27*   control_interval_storage_method is the method of storage management of
  4    28*   control intervals for this collection, either
  4    29*   BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD (not yet supported) or
  4    30*   UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD, declared in
  4    31*   dm_cism_info.incl.pl1.
  4    32*   
  4    33*   element_storage_method is the method of storage management of elements in
  4    34*   this collection, either BASIC_ELEMENT_STORAGE_METHOD or
  4    35*   ORDERED_ELEMENT_STORAGE_METHOD, declared in dm_esm_info.incl.pl1.
  4    36*   
  4    37*   maximum_element_size is the maximum size of an element in bits in this
  4    38*   collection.
  4    39*   
  4    40*   header_record_element_id is the identifier of an element containing a
  4    41*   caller-defined header for this collection.  If equal to "0"b, no
  4    42*   caller-defined header yet exists.  The put_header collection_manager_
  4    43*   operation stores such a header.
  4    44*   
  4    45*   storage_record_element_id is the identifier of the element containing the
  4    46*   storage_record for this collection.  The storage_record contains
  4    47*   information expected to be dynamic, such as the identifier of the last
  4    48*   control interval of the collection.  Its format is also dependent upon the
  4    49*   storage methods in effect for this collection.  storage_record structures
  4    50*   are declared in dm_cm_storage_record.incl.pl1.
  4    51*
  4    52**/
  4    53 
  4    54 /* HISTORY:
  4    55*Written by Matthew Pierret, 04/01/82.
  4    56*Modified:
  4    57*07/01/82 by Matthew Pierret: Changed to version A, added storage_record_area.
  4    58*10/29/82 by Matthew Pierret: Changed to version 2 ("col_hdr2"), separated
  4    59*            storage_record_area out, leaving storage_record_element_id behind.
  4    60*09/18/84 by Matthew Pierret: Added DESCRIPTION section.
  4    61**/
  4    62 
  4    63 /* format: style2,ind3,ll79 */
  4    64 
  4    65      dcl	   1 collection_header    aligned based (collection_header_ptr),
  4    66 	     2 version	      char (8),
  4    67 	     2 flags	      unaligned,
  4    68 	       3 fixed_size_elements
  4    69 			      bit (1),
  4    70 	       3 thread_elements  bit (1),
  4    71 	       3 thread_control_intervals
  4    72 			      bit (1),
  4    73 	       3 must_be_zero1    bit (15),
  4    74 	     2 control_interval_storage_method
  4    75 			      fixed bin (17) unal,
  4    76 	     2 element_storage_method
  4    77 			      fixed bin (17),
  4    78 	     2 maximum_element_size
  4    79 			      fixed bin (35),
  4    80 	     2 header_record_element_id
  4    81 			      bit (36) aligned,
  4    82 	     2 storage_record_element_id
  4    83 			      bit (36) aligned;
  4    84 
  4    85      dcl	   collection_header_ptr  ptr;
  4    86      dcl	   COLLECTION_HEADER_VERSION_2
  4    87 			      init ("col_hdr2") char (8) aligned
  4    88 			      int static options (constant);
  4    89 
  4    90 /* END INCLUDE FILE - dm_cm_collection_header.incl.pl1 */
      312 
      313 
  5     1 /* BEGIN INCLUDE FILE dm_cm_file_header.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*
  5     5*        This include file contains the cm_file_header and collection_id_table 
  5     6*   structure.  These structures are stored as elements in the Header Collection
  5     7*   of a file and contain per-file, as opposed to per-collection, information.
  5     8*   
  5     9*        The cm_file_header structure is always stored in the element whose
  5    10*   identifier is CM_FILE_HEADER_ELEMENT_ID, declared in 
  5    11*   dm_cm_hdr_col_ids.incl.pl1.  
  5    12*   
  5    13*        The collection_id_table is an array of identifiers of each collection 
  5    14*   in the file, excepting the Header Collection.  The identifier of a 
  5    15*   collection is the same as the identifier of the element which holds that
  5    16*   collection's collection_header, described in dm_cm_collection_header.incl.pl1.
  5    17*   The identifier of the element in which the collection_id_table is
  5    18*   stored is cm_file_header.collection_id_table_element_id.
  5    19*   
  5    20*      A file also has a reservation map for determining which controls 
  5    21*   intervals have been reserved by a collection.  It is divided into
  5    22*   several blocks, or fragments.  The file_reservation_map is actually an
  5    23*   array of element identifiers of the fragments of the map.  The 
  5    24*   file_reservation_map is stored in the element whose identifier is 
  5    25*   cm_file_header.allocation_map_element_id (quite a misnomer).  The number
  5    26*   of fragments of the map is cm_file_header.number_of_blocks.  The size
  5    27*   of each is fragment is cm_file_header.number_of_control_intervals_per_block
  5    28*   bits long, representing equally as many control intervals.  The
  5    29*   file_reservation_map is described in dm_cm_reservation_map.incl.pl1.
  5    30*   cm_file_header.highest_numbered_ci is the number of the control
  5    31*   interval in the file with the highest control interval number.  It is not 
  5    32*   yet used or maintained.
  5    33*
  5    34**/
  5    35 
  5    36 /* HISTORY:
  5    37*Written by Matthew Pierret, 03/23/82.
  5    38*Modified:
  5    39*04/08/82 by Matthew Pierret: Removed storage method constants.
  5    40*05/18/82 by Matthew Pierret: Made the array of collections an array of element
  5    41*            ids referring to collection_header's. Reduced buffer length to 120,
  5    42*            enough bytes to hold the collmgr_header with 25 collection header
  5    43*            element ids.
  5    44*06/03/82 by Matthew Pierret: Added collmgr_header_header.
  5    45*07/01/82 by Matthew Pierret: Removed collmgr_header_header. Changed to version A
  5    46*            made fixed length, split off array of collection_ids (also known as
  5    47*            element_ids of collection_headers).
  5    48*10/29/82 by Matthew Pierret: Changed from collmgr_header to cm_file_header.
  5    49*09/18/84 by Matthew Pierret: Added DESCRIPTION section. Moved constants to
  5    50*            dm_cm_hdr_col_ids.incl.pl1.  
  5    51**/
  5    52 
  5    53 /* format: style2,ind3,ll79 */
  5    54 
  5    55      dcl	   1 cm_file_header	      aligned based (cm_file_header_ptr),
  5    56 	     2 version	      char (8),
  5    57 	     2 highest_numbered_ci
  5    58 			      fixed bin (24) uns,
  5    59 	     2 number_of_collections
  5    60 			      fixed bin (17) unal,
  5    61 	     2 number_of_blocks   fixed bin (17) unal,
  5    62 	     2 number_of_control_intervals_per_block
  5    63 			      fixed bin (17),
  5    64 	     2 allocation_map_element_id
  5    65 			      bit (36) aligned,
  5    66 	     2 collection_id_table_element_id
  5    67 			      bit (36) aligned;
  5    68 
  5    69      dcl	   cm_file_header_ptr     ptr;
  5    70      dcl	   CM_FILE_HEADER_VERSION_1
  5    71 			      char (8) aligned init ("cm_fhdr1")
  5    72 			      int static options (constant);
  5    73 
  5    74 
  5    75      dcl	   collection_id_table    (cit_number_of_collections)
  5    76 			      bit (36) aligned
  5    77 			      based (collection_id_table_ptr);
  5    78 
  5    79      dcl	   collection_id_table_ptr
  5    80 			      ptr;
  5    81      dcl	   cit_number_of_collections
  5    82 			      fixed bin (17);
  5    83 
  5    84 
  5    85 
  5    86 /* ----------End include file dm_cm_file_header.incl.pl1---------- */
  5    87 
      314 
      315 
  6     1 /* BEGIN INCLUDE FILE dm_cm_storage_record.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*
  6     5*        A storage record is an extension to the collection_header structure.
  6     6*   It is expected to be more volatile than collection_header and has a 
  6     7*   different format depending on the control interval storage method in use
  6     8*   for the collection.  A storage record is stored as an element in the 
  6     9*   file's Header Collection with the element identifier 
  6    10*   collection_header.storage_record_element_id.
  6    11*   
  6    12*        The unblocked_storage_record contains the control interval numbers
  6    13*   of the first and last control intervals of a collection.  Unblocked
  6    14*   control intervals are chained together, so all control intervals can be 
  6    15*   found by starting at one end and following the chain forward or backward.
  6    16*   
  6    17*        The blocked_storage_record is not yet used, as the Blocked Control
  6    18*   Interval Storage Method is not yet implemented.
  6    19**/
  6    20 
  6    21 /* HISTORY:
  6    22*Written by Matthew Pierret, 09/24/84.
  6    23*Modified:
  6    24**/
  6    25 
  6    26 /* format: style2,ind3,ll79 */
  6    27 
  6    28      dcl	   1 unblocked_storage_record
  6    29 			      aligned
  6    30 			      based (unblocked_storage_record_ptr),
  6    31 	     2 first_control_interval
  6    32 			      fixed bin (24) uns,
  6    33 	     2 last_control_interval
  6    34 			      fixed bin (24) uns;
  6    35 
  6    36      dcl	   1 blocked_storage_record
  6    37 			      aligned based (blocked_storage_record_ptr),
  6    38 	     2 last_control_interval
  6    39 			      fixed bin (24) uns,
  6    40 	     2 number_of_blocks   fixed bin (17) unal,
  6    41 	     2 number_of_control_intervals_per_block
  6    42 			      fixed bin (17) unal,
  6    43 	     2 allocation_map_element_id
  6    44 			      bit (36) aligned;
  6    45 
  6    46      dcl	   unblocked_storage_record_ptr
  6    47 			      ptr init (null ());
  6    48      dcl	   blocked_storage_record_ptr
  6    49 			      ptr init (null ());
  6    50 
  6    51 /* END INCLUDE FILE dm_cm_storage_record.incl.pl1 */
      316 
      317 
  7     1 /* BEGIN INCLUDE FILE dm_cism_info.incl.pl1 */
  7     2 
  7     3 /* DESCRIPTION:
  7     4*
  7     5*     This include file contains the blocked_cism_info and unblocked_cism_info
  7     6*     structures, as well as constants relevant to control interval storage
  7     7*     management.  These structures and constants are used by several managers.
  7     8*     The structures each describe a method of control interval storage 
  7     9*     management.
  7    10**/
  7    11 
  7    12 /* HISTORY:
  7    13*
  7    14*Written 02/07/82 by Matthew Pierret.
  7    15*Modified:
  7    16*05/17/84 by Matthew Pierret:  Changed to align structure elements and add
  7    17*            a version string.
  7    18**/
  7    19 
  7    20 /* format: style2 */
  7    21 
  7    22      dcl	   1 blocked_cism_info    based (blocked_cism_info_ptr) aligned,
  7    23 	     2 version	      char (8) aligned init (CISM_INFO_VERSION_1),
  7    24 	     2 type	      fixed bin (17) init (BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD),
  7    25 	     2 number_of_control_intervals_per_block
  7    26 			      fixed bin (17);
  7    27 
  7    28      dcl	   1 unblocked_cism_info  based (unblocked_cism_info_ptr) aligned,
  7    29 	     2 version	      char (8) aligned init (CISM_INFO_VERSION_1),
  7    30 	     2 type	      fixed bin (17) init (UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD),
  7    31 	     2 must_be_zero	      fixed bin (17);
  7    32 
  7    33      dcl	   blocked_cism_info_ptr  ptr;
  7    34      dcl	   unblocked_cism_info_ptr
  7    35 			      ptr;
  7    36 
  7    37      dcl	   CISM_INFO_VERSION_1    init ("CISMinf1") char (8) aligned internal static options (constant);
  7    38      dcl	   BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
  7    39 			      fixed bin init (1) internal static options (constant);
  7    40      dcl	   UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
  7    41 			      fixed bin init (2) internal static options (constant);
  7    42 
  7    43 /* END INCLUDE FILE dm_cism_info.incl.pl1 ---------- */
      318 
      319 
  8     1 /* BEGIN INCLUDE FILE dm_cm_entry_dcls.incl.pl1 */
  8     2 
  8     3 /* DESCRIPTION:
  8     4*
  8     5*   Contains entry declarations of internally available collection_manager_
  8     6*   entries.  Entries which are only available via the collection_manager_
  8     7*   transfer vector are not included here, but are declared instead in 
  8     8*   dm_collmgr_entry_dcls.incl.pl1.
  8     9**/
  8    10 
  8    11 /* HISTORY:
  8    12*Written by Mathew Pierret, 04/01/82.
  8    13*Modified:
  8    14*09/21/82 by Lindsey Spratt:  Added the cm_compact$replacement entry.
  8    15*10/29/82 by Matthew Pierret:  Added cm_find_free_slot, cm_determine_free_space,
  8    16*            cm_find_ci_to_alloc_datum, cm_recursive_put.
  8    17*            Added cm_get_element$info*, $header*.  The former is used when
  8    18*            the caller has a cm_info structure already; the latter is used to
  8    19*            get collection headers.
  8    20*            Added cm_opening_info$get. Removed cm_add_ci_(part thread).
  8    21*            Added cm_allocate_element$info.
  8    22*11/09/82 by Matthew Pierret:  Added argument to cm_allocate_ordered_element
  8    23*            calling sequence for returning free space.
  8    24*            Added cm_free_cn_datum("" $header).
  8    25*01/07/83 by Matthew Pierret:  Added:
  8    26*            cm_allocate_element$buffered("" _info);
  8    27*            cm_put_element$buffered("" _info);
  8    28*            cm_put_datum_in_place$buffered("" _continued);
  8    29*            cm_put_datum_in_pool$buffered("" _continued);
  8    30*            cm_compact$buffered.
  8    31*01/26/83 by Matthew Pierret: Replaced cm_get_header_and_slot with
  8    32*            cm_get_bci_header$slot and added cm_get_bci_header$slot_exclusive.
  8    33*            Added cm_opening_info$get_storage_record.
  8    34*            Added a bit(36)aligned argument to cm_recursive_put to hold the
  8    35*            id of the previous datum.
  8    36*02/02/83 by Matthew Pierret: Added fixed bin (17) argument to cm_find_free_slot
  8    37*            which is for the number of slots after allocation.
  8    38*02/07/83 by Matthew Pierret: Added cm_get_id$(id info info_return_slot
  8    39*            header header_return_slot).
  8    40*            Added cm_get_element_portion$(exclusive info info_exclusive).
  8    41*            Added cm_get_element$bypass_info.
  8    42*03/25/83 by Matthew Pierret: Added cm_free_element$info and
  8    43*            cm_free_opening_info.
  8    44*04/29/83 by Matthew Pierret: Added cm_put_element$unprotected_info
  8    45*08/04/83 by Matthew Pierret:  Added the entries $does_new_datum_fit and
  8    46*            $does_replacement_fit to cm_determine_free_space.  These entries
  8    47*            return flags indicating if a datum fits in the ci and the pool.
  8    48*            Added a bit(1)aligned parameter to cm_find_free_slot in which is
  8    49*            returned the new value of bci_header.free_slot_is_present.
  8    50*02/07/84 by Matthew Pierret:  Added cm_get_id$ptr.  Removed all cm_get_id
  8    51*            modules except cm_get_id$id.  Removed all cm_get_element$info*
  8    52*            entries.  Changed cm_get_element_$bypass_info to have the same
  8    53*            calling sequence as other cm_get_element entries.
  8    54*06/12/84 by Matthew Pierret:  Changed cm_put_element to cm_modify
  8    55*            and cm_allocate_element to cm_put.
  8    56*            Switched the element_length/element_ptr parameter pair to be
  8    57*            element_ptr/element_length in cm_modify and cm_put.
  8    58*07/24/84 by Matthew Pierret:  Added cm_free_ci$raw_return_prev_next.
  8    59*09/24/84 by Matthew Pierret:  Added trace_thread_modifications_(on off)
  8    60*            entries to cm_free_ci and cm_replace_buffered_ci, 
  8    61*            cm_allocate_ci$info_header, cm_opening_info$opening_table_ptr.
  8    62*            Removed cm_find_free_space. Commented out un-used entries.
  8    63*            Re-named allocate  entries to put entries, except for allocate_ci.
  8    64*            Re-named free element and free datum entries to use delete instead
  8    65*            of free, and cm_recursive_put to cm_recursive_modify.
  8    66*            Removed cm_get_element$bypass_info.
  8    67*02/27/85 by Matthew C. Pierret:  Re-added cm_compact$buffered_replacement now
  8    68*            that cm_modify$buffered uses it.
  8    69*03/07/85 by R. Michael Tague:  Added cm_postcommit_increment.
  8    70**/
  8    71 
  8    72 /* format: style2,ind3 */
  8    73 
  8    74 
  8    75      dcl	   cm_allocate_ci	      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
  8    76      dcl	   cm_allocate_ci$info    entry (ptr, fixed bin (24) unsigned, fixed bin (35));
  8    77      dcl	   cm_allocate_ci$info_header
  8    78 			      entry (ptr, fixed bin (24) unsigned, ptr, fixed bin (35));
  8    79 
  8    80 
  8    81      dcl	   cm_compact	      entry (bit (36) aligned, fixed bin (17), bit (36) aligned, ptr, fixed bin (35));
  8    82      dcl	   cm_compact$buffered    entry (ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
  8    83      dcl	   cm_compact$replacement entry (bit (36) aligned, fixed bin (17), bit (36) aligned, ptr, fixed bin (35));
  8    84      dcl	   cm_compact$buffered_replacement
  8    85 			      entry (ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
  8    86 
  8    87      dcl	   cm_delete_cn_datum     entry (ptr, bit (1) aligned, bit (36) aligned, fixed bin (35));
  8    88 
  8    89      dcl	   cm_delete_cn_datum$header
  8    90 			      entry (ptr, ptr, ptr, bit (1) aligned, bit (36) aligned, fixed bin (35));
  8    91 
  8    92      dcl	   cm_delete	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  8    93 			      fixed bin (35));
  8    94      dcl	   cm_delete$info	      entry (ptr, bit (36) aligned, bit (1) aligned, fixed bin (35));
  8    95 
  8    96      dcl	   cm_determine_free_space$all
  8    97 			      entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35));
  8    98      dcl	   cm_determine_free_space$effective
  8    99 			      entry (ptr, fixed bin (35), bit (1) aligned, bit (1) aligned, fixed bin (35),
  8   100 			      fixed bin (35));
  8   101      dcl	   cm_determine_free_space$does_new_datum_fit
  8   102 			      entry (ptr, fixed bin (35), fixed bin (35), bit (1) aligned, bit (1) aligned,
  8   103 			      bit (1) aligned, bit (1) aligned, fixed bin (35));
  8   104 
  8   105 /**** Not yet used *********************************************************
  8   106*     dcl	   cm_determine_free_space$does_replacement_fit
  8   107*			      entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35), bit (1) aligned,
  8   108*			      bit (1) aligned, bit (1) aligned, bit (1) aligned, fixed bin (35)); 
  8   109*************************************************************************** */
  8   110 
  8   111      dcl	   cm_find_ci_to_alloc_datum
  8   112 			      entry (ptr, fixed bin (35), fixed bin (24) uns, bit (1) aligned, bit (1) aligned, ptr,
  8   113 			      fixed bin (24) uns, fixed bin (35));
  8   114 
  8   115      dcl	   cm_find_free_slot      entry (bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (17), fixed bin (17),
  8   116 			      bit (1) aligned, fixed bin (35));
  8   117 
  8   118      dcl	   cm_free_ci$info	      entry (ptr, fixed bin (24) uns, bit (1) aligned, fixed bin (35));
  8   119      dcl	   cm_free_ci$raw_return_prev_next
  8   120 			      entry (ptr, fixed bin (24) uns, bit (1) aligned, fixed bin (24) uns,
  8   121 			      fixed bin (24) uns, fixed bin (35));
  8   122      dcl	   cm_free_ci$trace_thread_modifications_on
  8   123 			      entry ();
  8   124      dcl	   cm_free_ci$trace_thread_modifications_off
  8   125 			      entry ();
  8   126 
  8   127 
  8   128      dcl	   cm_free_opening_info   entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  8   129 
  8   130      dcl	   cm_get_bci_header      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
  8   131      dcl	   cm_get_bci_header$exclusive
  8   132 			      entry (bit (36) aligned, uns fixed bin (24), ptr, fixed bin (35));
  8   133      dcl	   cm_get_bci_header$slot entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  8   134 
  8   135 /**** Not yet used ********************************************************
  8   136*     dcl	   cm_get_bci_header$slot_exclusive
  8   137*			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  8   138*************************************************************************** */
  8   139 
  8   140      dcl	   cm_get_element	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  8   141 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  8   142      dcl	   cm_get_element$exclusive
  8   143 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  8   144 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  8   145 
  8   146      dcl	   cm_get_element_portion entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  8   147 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  8   148 			      fixed bin (35), fixed bin (35));
  8   149 
  8   150 /**** Not yet used ********************************************************
  8   151*     dcl	   cm_get_element_portion$exclusive
  8   152*			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  8   153*			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  8   154*			      fixed bin (35), fixed bin (35));
  8   155*************************************************************************** */
  8   156 
  8   157      dcl	   cm_get_id$id	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin,
  8   158 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  8   159      dcl	   cm_get_id$ptr	      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin,
  8   160 			      bit (1) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  8   161 
  8   162      dcl	   cm_modify	      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  8   163 			      fixed bin (35), fixed bin (35));
  8   164      dcl	   cm_modify$buffered     entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  8   165 			      fixed bin (35), fixed bin (35));
  8   166 
  8   167 /******* Not yet used *****************************************************
  8   168*     dcl	   cm_modify$buffered_info
  8   169*			      entry (ptr, ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35),
  8   170*			      fixed bin (35));
  8   171*****************************************************************************/
  8   172 
  8   173      dcl	   cm_modify$info	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  8   174      dcl	   cm_modify$unprotected_info
  8   175 			      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  8   176 
  8   177 
  8   178 /******* Not yet used *****************************************************
  8   179*     dcl	   cm_modify_portion entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35),
  8   180*			      fixed bin (35), ptr, bit (36) aligned, fixed bin (35), fixed bin (35));
  8   181*****************************************************************************/
  8   182 
  8   183 
  8   184      dcl	   cm_opening_info$get    entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  8   185      dcl	   cm_opening_info$get_storage_record
  8   186 			      entry (ptr, fixed bin (35));
  8   187      dcl	   cm_opening_info$full_get
  8   188 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  8   189      dcl	   cm_opening_info$opening_table_ptr
  8   190 			      entry () returns (ptr);
  8   191 
  8   192      dcl	   cm_postcommit_increment
  8   193 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  8   194 
  8   195      dcl	   cm_put		      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  8   196 			      fixed bin (35), fixed bin (35));
  8   197      dcl	   cm_put$buffered	      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  8   198 			      fixed bin (35), fixed bin (35));
  8   199 
  8   200 /******* Not yet used *****************************************************
  8   201*     dcl	   cm_put$buffered_info
  8   202*			      entry (ptr, ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35),
  8   203*			      fixed bin (35));
  8   204*****************************************************************************/
  8   205 
  8   206      dcl	   cm_put$info	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  8   207 
  8   208      dcl	   cm_put_basic_element   entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  8   209 			      fixed bin (35));
  8   210 
  8   211      dcl	   cm_put_cn_datum	      entry (ptr, ptr, fixed bin (35), bit (36) aligned, bit (36) aligned, fixed bin (35));
  8   212 
  8   213      dcl	   cm_put_datum_in_place  entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  8   214 			      fixed bin (35));
  8   215      dcl	   cm_put_datum_in_place$buffered
  8   216 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
  8   217      dcl	   cm_put_datum_in_place$buffered_continued
  8   218 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (36) aligned,
  8   219 			      fixed bin (35));
  8   220      dcl	   cm_put_datum_in_place$continued
  8   221 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  8   222 			      fixed bin (35), bit (36) aligned, fixed bin (35));
  8   223 
  8   224      dcl	   cm_put_datum_in_pool   entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  8   225 			      fixed bin (35));
  8   226      dcl	   cm_put_datum_in_pool$buffered
  8   227 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35));
  8   228      dcl	   cm_put_datum_in_pool$buffered_continued
  8   229 			      entry (ptr, ptr, fixed bin (35), ptr, fixed bin (35), bit (36) aligned,
  8   230 			      fixed bin (35));
  8   231      dcl	   cm_put_datum_in_pool$continued
  8   232 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), ptr, ptr,
  8   233 			      fixed bin (35), bit (36) aligned, fixed bin (35));
  8   234 
  8   235      dcl	   cm_put_ordered_element entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  8   236 			      fixed bin (35));
  8   237      dcl	   cm_put_ordered_element$buffered
  8   238 			      entry (ptr, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35),
  8   239 			      fixed bin (35));
  8   240 
  8   241      dcl	   cm_put_overlength_tail entry (ptr, ptr, fixed bin (35), bit (36) aligned, fixed bin (35));
  8   242 
  8   243      dcl	   cm_recursive_modify    entry (ptr, bit (36) aligned, ptr, fixed bin (35), fixed bin (35), bit (36) aligned,
  8   244 			      fixed bin (35));
  8   245 
  8   246 
  8   247      dcl	   cm_replace_buffered_ci$trace_thread_modifications_on
  8   248 			      entry ();
  8   249      dcl	   cm_replace_buffered_ci$trace_thread_modifications_off
  8   250 			      entry ();
  8   251 
  8   252 /* END INCLUDE FILE dm_cm_entry_dcls.incl.pl1 */
      320 
      321 
  9     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  9     2 /* format: style3 */
  9     3 
  9     4 /* These constants are to be used for the flags argument of sub_err_ */
  9     5 /* They are just "string (condition_info_header.action_flags)" */
  9     6 
  9     7 declare	(
  9     8 	ACTION_CAN_RESTART	init (""b),
  9     9 	ACTION_CANT_RESTART init ("1"b),
  9    10 	ACTION_DEFAULT_RESTART
  9    11 			init ("01"b),
  9    12 	ACTION_QUIET_RESTART
  9    13 			init ("001"b),
  9    14 	ACTION_SUPPORT_SIGNAL
  9    15 			init ("0001"b)
  9    16 	)		bit (36) aligned internal static options (constant);
  9    17 
  9    18 /* End include file */
      322 
      323    end cm_destroy_collection;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/04/85  0912.5  cm_destroy_collection.pl1         >spec>on>7192.pbf-04/04/85>cm_destroy_collection.pl1
306          1    01/07/85  0858.8  dm_hdr_collection_id.incl.pl1     >ldd>include>dm_hdr_collection_id.incl.pl1
308          2    01/07/85  0858.4  dm_cm_hdr_col_ids.incl.pl1        >ldd>include>dm_cm_hdr_col_ids.incl.pl1
310          3    01/07/85  0858.4  dm_cm_info.incl.pl1               >ldd>include>dm_cm_info.incl.pl1
312          4    01/07/85  0858.2  dm_cm_collection_header.incl.pl1  >ldd>include>dm_cm_collection_header.incl.pl1
314          5    01/07/85  0858.3  dm_cm_file_header.incl.pl1        >ldd>include>dm_cm_file_header.incl.pl1
316          6    01/07/85  0858.4  dm_cm_storage_record.incl.pl1     >ldd>include>dm_cm_storage_record.incl.pl1
318          7    01/07/85  0858.0  dm_cism_info.incl.pl1             >ldd>include>dm_cism_info.incl.pl1
320          8    04/04/85  0819.0  dm_cm_entry_dcls.incl.pl1         >spec>on>7192.pbf-04/04/85>dm_cm_entry_dcls.incl.pl1
322          9    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000025 constant        bit(36)                  initial dcl 9-7 set ref 142* 299*
ACTION_CAN_RESTART              000036 constant        bit(36)                  initial dcl 9-7 set ref 216*
BITS_PER_WORD                   001372 constant        fixed bin(17,0)          initial dcl 88 ref 216 216 216
CM_FILE_HEADER_ELEMENT_ID       000041 constant        bit(36)                  initial dcl 2-21 set ref 199* 244*
CM_FILE_HEADER_VERSION_1        000000 constant        char(8)                  initial dcl 5-70 set ref 204*
CM_INFO_VERSION_2               000004 constant        char(8)                  initial dcl 3-48 set ref 137*
COLLECTION_HEADER_VERSION_2     000002 constant        char(8)                  initial dcl 4-86 set ref 140*
DEFAULT_POSITION                000036 constant        fixed bin(17,0)          initial dcl 88 set ref 199* 210*
DONT_ZERO_ON_FREE               000036 constant        bit(1)                   initial dcl 94 set ref 254* 258* 262*
HEADER_COLLECTION_ID            000042 constant        bit(36)                  initial dcl 1-19 set ref 127* 199* 210*
LIMIT_TO_STOP_INFINITE_LOOPING  000006 constant        fixed bin(35,0)          initial dcl 92 ref 179
UNBLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
                                000041 constant        fixed bin(17,0)          initial dcl 7-40 set ref 142 142*
addr                                                   builtin function         dcl 78 ref 199 199
blocked_storage_record_ptr      000152 automatic       pointer                  initial dcl 6-48 set ref 6-48*
ceil                                                   builtin function         dcl 78 ref 216 216 216
ci_count                        000120 automatic       fixed bin(24,0)          dcl 62 set ref 179*
cit_number_of_collections       000146 automatic       fixed bin(17,0)          dcl 5-81 set ref 208* 216 216* 223 226 233 233 235*
                                                                                  235 237 237 242
cleanup                         000130 stack reference condition                dcl 83 ref 173
cm_delete$info                  000024 constant        entry                    external dcl 8-94 ref 254 258 262
cm_file_header                         based           structure                level 1 dcl 5-55 set ref 244 244
cm_file_header_ptr              000142 automatic       pointer                  dcl 5-69 set ref 199* 204 208 210 237 242 244* 244
                                                                                  244
cm_free_ci$raw_return_prev_next 000026 constant        entry                    external dcl 8-119 ref 181
cm_free_opening_info            000030 constant        entry                    external dcl 8-128 ref 190
cm_get_element                  000032 constant        entry                    external dcl 8-140 ref 199 210
cm_info                                based           structure                level 1 dcl 3-37
cm_info_ptr                     000136 automatic       pointer                  initial dcl 3-47 set ref 133* 137 139 154 181* 193*
                                                                                  3-47*
cm_modify$info                  000034 constant        entry                    external dcl 8-173 ref 237 244
cm_opening_info$full_get        000036 constant        entry                    external dcl 8-187 ref 127 133
code                            000122 automatic       fixed bin(35,0)          dcl 64 set ref 118* 127* 128 128* 133* 134 134* 181*
                                                                                  182 182* 190* 191 191* 199* 202 202* 210* 213 213*
                                                                                  237* 239 239* 244* 246 246* 254* 255 255* 258* 259
                                                                                  259* 262* 263 263*
collection_header                      based           structure                level 1 dcl 4-65
collection_header_element_id    000114 automatic       bit(36)                  initial dcl 59 set ref 59* 164* 254*
collection_header_ptr           000140 automatic       pointer                  dcl 4-85 set ref 139* 140 142 142 165 166
collection_id                   000115 automatic       bit(36)                  initial dcl 59 set ref 59* 121* 133* 164 190* 223
collection_id_table                    based           bit(36)                  array dcl 5-75 set ref 223 233* 233 237 237
collection_id_table_buffer             based           bit                      dcl 73 ref 288
collection_id_table_element_id
                          6            based           bit(36)                  level 2 dcl 5-55 set ref 210* 237*
collection_id_table_length      000123 automatic       fixed bin(35,0)          initial dcl 65 set ref 65* 210* 216 216 216 288 288
collection_id_table_ptr         000144 automatic       pointer                  dcl 5-79 set ref 123* 170* 210* 223 233 233 237* 237
                                                                                  237 288 288
collection_idx                  000121 automatic       fixed bin(17,0)          dcl 63 set ref 223* 223* 226 233 233
control_interval_storage_method
                          2(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 4-65 set ref 142 142*
current_ci_id                   000124 automatic       fixed bin(24,0)          unsigned dcl 67 set ref 177* 179 181* 185*
cv_p_expected_version                  parameter       char(8)                  dcl 296 set ref 293 299 299*
cv_p_received_version                  parameter       char(8)                  dcl 295 set ref 293 299 299*
cv_p_structure_name                    parameter       char                     unaligned dcl 297 set ref 293 299*
divide                                                 builtin function         dcl 78 ref 216 216 216
dm_error_$programming_error     000020 external static fixed bin(35,0)          dcl 103 set ref 216*
dm_error_$unimplemented_cism    000022 external static fixed bin(35,0)          dcl 103 set ref 142*
dm_work_area                           based           area                     dcl 72 ref 288
dm_work_area_ptr                000010 internal static pointer                  initial dcl 112 set ref 171 171* 210* 288
er_p_code                              parameter       fixed bin(35,0)          dcl 275 ref 272 277
error_table_$unimplemented_version
                                000016 external static fixed bin(35,0)          dcl 103 set ref 299*
file_opening_id                 000116 automatic       bit(36)                  initial dcl 59 set ref 59* 120* 127* 133* 190* 199*
                                                                                  210*
first_ci_id                     000125 automatic       fixed bin(24,0)          unsigned dcl 67 set ref 156* 177
first_control_interval                 based           fixed bin(24,0)          level 2 unsigned dcl 6-28 ref 156
get_dm_free_area_               000014 constant        entry                    external dcl 99 ref 171
hc_cm_info_ptr                  000110 automatic       pointer                  initial dcl 57 set ref 57* 127* 237* 244* 254* 258*
                                                                                  262*
header_ptr                6            based           pointer                  initial level 2 dcl 3-37 ref 139
header_record_element_id
                          5            based           bit(36)                  level 2 in structure "collection_header" dcl 4-65
                                                                                  in procedure "cm_destroy_collection" ref 165
header_record_element_id        000113 automatic       bit(36)                  initial dcl 59 in procedure "cm_destroy_collection"
                                                                                  set ref 59* 165* 262*
is_unblocked                    000112 automatic       bit(1)                   initial dcl 58 set ref 58*
last_ci_id                      000126 automatic       fixed bin(24,0)          unsigned dcl 67 set ref 157*
last_control_interval
                          1            based           fixed bin(24,0)          level 2 unsigned dcl 6-28 ref 157
length                                                 builtin function         dcl 78 ref 199 199 237 237 244 244
local_cm_file_header            000100 automatic       structure                level 1 dcl 56 set ref 199 199 199 199
myname                          000007 constant        varying char(32)         initial dcl 87 set ref 142* 216* 299*
next_ci_id                      000127 automatic       fixed bin(24,0)          unsigned dcl 67 set ref 181* 185
null                                                   builtin function         dcl 78 ref 57 123 142 142 170 171 193 199 199 210
                                                                                  210 216 216 3-47 6-46 6-48 288 299 299
number_of_collections
                          3            based           fixed bin(17,0)          level 2 packed unaligned dcl 5-55 set ref 208 242*
p_code                                 parameter       fixed bin(35,0)          dcl 52 set ref 43 118* 277*
p_collection_id                        parameter       bit(36)                  dcl 51 ref 43 121
p_file_opening_id                      parameter       bit(36)                  dcl 50 ref 43 120
storage_record_element_id
                          6            based           bit(36)                  level 2 in structure "collection_header" dcl 4-65
                                                                                  in procedure "cm_destroy_collection" ref 166
storage_record_element_id       000117 automatic       bit(36)                  initial dcl 59 in procedure "cm_destroy_collection"
                                                                                  set ref 59* 166* 258*
storage_record_ptr       10            based           pointer                  initial level 2 dcl 3-37 ref 154
sub_err_                        000012 constant        entry                    external dcl 98 ref 142 216 299
unblocked_storage_record               based           structure                level 1 dcl 6-28
unblocked_storage_record_ptr    000150 automatic       pointer                  initial dcl 6-46 set ref 154* 156 157 6-46*
unspec                                                 builtin function         dcl 78 ref 199 199 237 237 244 244
version                                based           char(8)                  level 2 in structure "collection_header" dcl 4-65
                                                                                  in procedure "cm_destroy_collection" set ref 140*
version                                based           char(8)                  level 2 in structure "cm_info" dcl 3-37 in procedure
                                                                                  "cm_destroy_collection" set ref 137*
version                                based           char(8)                  level 2 in structure "cm_file_header" dcl 5-55
                                                                                  in procedure "cm_destroy_collection" set ref 204*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 9-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 9-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 9-7
BLOCKED_CONTROL_INTERVAL_STORAGE_METHOD
                                       internal static fixed bin(17,0)          initial dcl 7-38
CALLER_HEADER_ELEMENT_ID               internal static bit(36)                  initial dcl 2-21
CISM_INFO_VERSION_1                    internal static char(8)                  initial dcl 7-37
HEADER_COLLECTION_HEADER_ELEMENT_ID    internal static bit(36)                  initial dcl 2-21
blocked_cism_info                      based           structure                level 1 dcl 7-22
blocked_cism_info_ptr                  automatic       pointer                  dcl 7-33
blocked_storage_record                 based           structure                level 1 dcl 6-36
cm_allocate_ci                  000000 constant        entry                    external dcl 8-75
cm_allocate_ci$info             000000 constant        entry                    external dcl 8-76
cm_allocate_ci$info_header      000000 constant        entry                    external dcl 8-77
cm_compact                      000000 constant        entry                    external dcl 8-81
cm_compact$buffered             000000 constant        entry                    external dcl 8-82
cm_compact$buffered_replacement 000000 constant        entry                    external dcl 8-84
cm_compact$replacement          000000 constant        entry                    external dcl 8-83
cm_delete                       000000 constant        entry                    external dcl 8-92
cm_delete_cn_datum              000000 constant        entry                    external dcl 8-87
cm_delete_cn_datum$header       000000 constant        entry                    external dcl 8-89
cm_determine_free_space$all     000000 constant        entry                    external dcl 8-96
cm_determine_free_space$does_new_datum_fit
                                000000 constant        entry                    external dcl 8-101
cm_determine_free_space$effective
                                000000 constant        entry                    external dcl 8-98
cm_find_ci_to_alloc_datum       000000 constant        entry                    external dcl 8-111
cm_find_free_slot               000000 constant        entry                    external dcl 8-115
cm_free_ci$info                 000000 constant        entry                    external dcl 8-118
cm_free_ci$trace_thread_modifications_off
                                000000 constant        entry                    external dcl 8-124
cm_free_ci$trace_thread_modifications_on
                                000000 constant        entry                    external dcl 8-122
cm_get_bci_header               000000 constant        entry                    external dcl 8-130
cm_get_bci_header$exclusive     000000 constant        entry                    external dcl 8-131
cm_get_bci_header$slot          000000 constant        entry                    external dcl 8-133
cm_get_element$exclusive        000000 constant        entry                    external dcl 8-142
cm_get_element_portion          000000 constant        entry                    external dcl 8-146
cm_get_id$id                    000000 constant        entry                    external dcl 8-157
cm_get_id$ptr                   000000 constant        entry                    external dcl 8-159
cm_modify                       000000 constant        entry                    external dcl 8-162
cm_modify$buffered              000000 constant        entry                    external dcl 8-164
cm_modify$unprotected_info      000000 constant        entry                    external dcl 8-174
cm_opening_info$get             000000 constant        entry                    external dcl 8-184
cm_opening_info$get_storage_record
                                000000 constant        entry                    external dcl 8-185
cm_opening_info$opening_table_ptr
                                000000 constant        entry                    external dcl 8-189
cm_postcommit_increment         000000 constant        entry                    external dcl 8-192
cm_put                          000000 constant        entry                    external dcl 8-195
cm_put$buffered                 000000 constant        entry                    external dcl 8-197
cm_put$info                     000000 constant        entry                    external dcl 8-206
cm_put_basic_element            000000 constant        entry                    external dcl 8-208
cm_put_cn_datum                 000000 constant        entry                    external dcl 8-211
cm_put_datum_in_place           000000 constant        entry                    external dcl 8-213
cm_put_datum_in_place$buffered  000000 constant        entry                    external dcl 8-215
cm_put_datum_in_place$buffered_continued
                                000000 constant        entry                    external dcl 8-217
cm_put_datum_in_place$continued 000000 constant        entry                    external dcl 8-220
cm_put_datum_in_pool            000000 constant        entry                    external dcl 8-224
cm_put_datum_in_pool$buffered   000000 constant        entry                    external dcl 8-226
cm_put_datum_in_pool$buffered_continued
                                000000 constant        entry                    external dcl 8-228
cm_put_datum_in_pool$continued  000000 constant        entry                    external dcl 8-231
cm_put_ordered_element          000000 constant        entry                    external dcl 8-235
cm_put_ordered_element$buffered 000000 constant        entry                    external dcl 8-237
cm_put_overlength_tail          000000 constant        entry                    external dcl 8-241
cm_recursive_modify             000000 constant        entry                    external dcl 8-243
cm_replace_buffered_ci$trace_thread_modifications_off
                                000000 constant        entry                    external dcl 8-249
cm_replace_buffered_ci$trace_thread_modifications_on
                                000000 constant        entry                    external dcl 8-247
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 103
unblocked_cism_info                    based           structure                level 1 dcl 7-28
unblocked_cism_info_ptr                automatic       pointer                  dcl 7-34

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_VERSION                   001263 constant        entry                    internal dcl 293 ref 137 140 204
ERROR_RETURN                    001230 constant        entry                    internal dcl 272 ref 128 134 182 191 202 213 239 246
                                                                                  255 259 263
FINISH                          001243 constant        entry                    internal dcl 285 ref 173 268 278
MAIN_RETURN                     001227 constant        label                    dcl 269 ref 279
cm_destroy_collection           000173 constant        entry                    external dcl 43

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1600        1640    1373        1610
Length      2242    1373        40         366     204           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cm_destroy_collection               308 external procedure  is an external procedure.  
on unit on line 173                  64 on unit               
ERROR_RETURN                            internal procedure  shares stack frame of external procedure cm_destroy_collection.  
FINISH                               64 internal procedure  is called by several nonquick procedures.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure cm_destroy_collection.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 dm_work_area_ptr            cm_destroy_collection

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cm_destroy_collection    000100 local_cm_file_header        cm_destroy_collection
                         000110 hc_cm_info_ptr              cm_destroy_collection
                         000112 is_unblocked                cm_destroy_collection
                         000113 header_record_element_id    cm_destroy_collection
                         000114 collection_header_element_id
                                                            cm_destroy_collection
                         000115 collection_id               cm_destroy_collection
                         000116 file_opening_id             cm_destroy_collection
                         000117 storage_record_element_id   cm_destroy_collection
                         000120 ci_count                    cm_destroy_collection
                         000121 collection_idx              cm_destroy_collection
                         000122 code                        cm_destroy_collection
                         000123 collection_id_table_length  cm_destroy_collection
                         000124 current_ci_id               cm_destroy_collection
                         000125 first_ci_id                 cm_destroy_collection
                         000126 last_ci_id                  cm_destroy_collection
                         000127 next_ci_id                  cm_destroy_collection
                         000136 cm_info_ptr                 cm_destroy_collection
                         000140 collection_header_ptr       cm_destroy_collection
                         000142 cm_file_header_ptr          cm_destroy_collection
                         000144 collection_id_table_ptr     cm_destroy_collection
                         000146 cit_number_of_collections   cm_destroy_collection
                         000150 unblocked_storage_record_ptr
                                                            cm_destroy_collection
                         000152 blocked_storage_record_ptr  cm_destroy_collection

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return              enable
ext_entry           int_entry           ceil_fx1            divide_fx1          free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cm_delete$info                cm_free_ci$raw_return_prev_next                             cm_free_opening_info
cm_get_element                cm_modify$info                cm_opening_info$full_get      get_dm_free_area_
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$programming_error   dm_error_$unimplemented_cism  error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     43 000167        57 000200        58 000202        59 000204        65 000211    3   47 000212    6   46 000214
 6   48 000215       118 000216       120 000221       121 000223       123 000225       127 000227       128 000243
    133 000247       134 000264       137 000270       139 000311       140 000314       142 000341       154 000425
    156 000430       157 000432       164 000434       165 000436       166 000441       170 000443       171 000445
    173 000457       177 000501       179 000503       181 000515       182 000541       185 000545       186 000547
    190 000551       191 000564       193 000570       199 000572       202 000636       204 000642       208 000665
    210 000671       213 000731       216 000735       223 001024       224 001037       226 001041       233 001043
    235 001050       237 001052       239 001100       242 001104       244 001110       246 001134       254 001140
    255 001155       258 001161       259 001176       262 001202       263 001217       268 001223       269 001227
    272 001230       277 001232       278 001235       279 001241       285 001242       288 001250       291 001262
    293 001263       299 001274       304 001364


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
