	COMPILATION LISTING OF SEGMENT assign_storage
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 12/01/87  1555.1 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 
       15 /****^  HISTORY COMMENTS:
       16*  1) change(87-06-26,Huen), approve(87-06-26,MCR7712), audit(87-12-01,RWaters),
       17*     install(87-12-01,MR12.2-1005):
       18*     Fix bug2174
       19*                                                   END HISTORY COMMENTS */
       20 
       21 
       22 /* This procedure is called to assign storage to all blocks
       23*
       24*   Revised Version: 15 April 1971 by BLW
       25*	Modified: 22 January 1973 by BLW for controlled storage
       26*	Modified:	18 April 1975 by RHS for options(constant)
       27*	Modified:	5 June 1975 by EEW for separate_static
       28*	Modified:	19 June 1975 by RAB for listing label arrays
       29*	Modified:	24 November 1975 by RAB to fix 1439
       30*	Modified:	31 March 1976 by RAB to fix 1481,
       31*		introduced by fix of 1439
       32*	Modified:	21 October 1976 by RAB to improve conversion of static
       33*		to constant
       34*	Modified:	5 April 1978 by RAB to detect infinite loop while finding level of quick block
       35*	Modified: 23 April 1979 by PCK to implement 4-bit decimal.
       36*          Modified: 18 June 1987 by RW to fix 2174 by checking segment size when
       37*		static storage is allocated.
       38**/
       39 
       40 assign_storage: proc(pt) ;
       41 
       42 dcl	pt ptr;		/* points at a block node */
       43 
       44 dcl	(cg_static_$cur_block,cg_static_$format_list,cg_static_$temporary_list,
       45 	cg_static_$stat_base,cg_static_$text_base,cg_static_$link_base,cg_static_$constant_list,
       46 	cg_static_$label_list,cg_static_$last_label) ptr ext,
       47 	(cg_static_$separate_static,cg_static_$generate_symtab,cg_static_$table_option) bit(1) ext,
       48 	(cg_static_$text_pos,cg_static_$stat_pos,cg_static_$link_pos,
       49 	 cg_static_$cur_level,cg_static_$max_stack_size, cg_static_$max_program_size) fixed bin(17) ext;
       50 
       51 dcl	(block_pt,blk_pt,sym_pt,ref_pt,bp,p,q,q1,static_base,pos_pt) ptr,
       52 	(auto_ctr,loc,cfo,c,r,t,n,units,a_units,datum_size,bit_length,increment) fixed bin(17),
       53 	err_no fixed bin,
       54 	(not_set,no_runtime_symbol) bit(1) aligned,
       55 	cptr(3) ptr based,
       56 	static_pos fixed bin(17) based,
       57 	error entry(fixed bin,ptr,ptr),
       58 	cg_error entry(fixed bin,fixed bin),
       59 	assign_storage entry(ptr),
       60 	initialize_int_static entry(ptr,ptr),
       61 	create_list entry(fixed bin) returns(ptr);
       62 
       63 dcl	(addrel,divide,fixed,max,mod,null) builtin;
       64 
       65 dcl	fo_mult(0:5) fixed bin(17,1) int static init(0,1,4.5,9,18,0),
       66 	bits_per_char fixed bin int static init(9),
       67 	param_array fixed bin int static init(64);
       68 
       69 dcl	fix_bin fixed bin based,
       70 	buffer(datum_size) fixed bin based;
       71 
  1     1 /* BEGIN INCLUDE FILE ... pl1_tree_areas.incl.pl1 */
  1     2 
  1     3 /* format: style3 */
  1     4 dcl	tree_area		area based (pl1_stat_$tree_area_ptr);
  1     5 dcl	xeq_tree_area	area based (pl1_stat_$xeq_tree_area_ptr);
  1     6 
  1     7 dcl	pl1_stat_$tree_area_ptr
  1     8 			ptr ext static,
  1     9 	pl1_stat_$xeq_tree_area_ptr
  1    10 			ptr ext static;
  1    11 
  1    12 /* END INCLUDE FILE ... op_codes.incl.pl1 */
       72 
  2     1 /* BEGIN INCLUDE FILE ... nodes.incl.pl1 */
  2     2 
  2     3 /* Modified: 26 Dec 1979 by PCK to implement by name assignment */
  2     4 
  2     5 dcl (	block_node		initial("000000001"b),
  2     6 	statement_node		initial("000000010"b),
  2     7 	operator_node		initial("000000011"b),
  2     8 	reference_node		initial("000000100"b),
  2     9 	token_node		initial("000000101"b),
  2    10 	symbol_node		initial("000000110"b),
  2    11 	context_node		initial("000000111"b),
  2    12 	array_node		initial("000001000"b),
  2    13 	bound_node		initial("000001001"b),
  2    14 	format_value_node		initial("000001010"b),
  2    15 	list_node			initial("000001011"b),
  2    16 	default_node		initial("000001100"b),
  2    17 	machine_state_node		initial("000001101"b),
  2    18 	source_node		initial("000001110"b),
  2    19 	label_node		initial("000001111"b),
  2    20 	cross_reference_node	initial("000010000"b),
  2    21 	sf_par_node		initial("000010001"b),
  2    22 	temporary_node		initial("000010010"b),
  2    23 	label_array_element_node	initial("000010011"b),
  2    24 	by_name_agg_node		initial("000010100"b))
  2    25 				bit(9) internal static aligned options(constant);
  2    26 
  2    27 dcl	1 node			based aligned,
  2    28 	2 type			unal bit(9),
  2    29 	2 source_id		unal structure,
  2    30 	  3 file_number		bit(8),
  2    31 	  3 line_number		bit(14),
  2    32 	  3 statement_number	bit(5);
  2    33 
  2    34 /* END INCLUDE FILE ... nodes.incl.pl1 */
       73 
  3     1 /* BEGIN INCLUDE FILE ... block.incl.pl1 */
  3     2 /* Modified 22 Ocober 1980 by M. N. Davidoff to increase max block.number to 511 */
  3     3 /* format: style3,idind30 */
  3     4 
  3     5 declare	1 block			aligned based,
  3     6 	  2 node_type		bit (9) unaligned,
  3     7 	  2 source_id		structure unaligned,
  3     8 	    3 file_number		bit (8),
  3     9 	    3 line_number		bit (14),
  3    10 	    3 statement_number	bit (5),
  3    11 	  2 father		ptr unaligned,
  3    12 	  2 brother		ptr unaligned,
  3    13 	  2 son			ptr unaligned,
  3    14 	  2 declaration		ptr unaligned,
  3    15 	  2 end_declaration		ptr unaligned,
  3    16 	  2 default		ptr unaligned,
  3    17 	  2 end_default		ptr unaligned,
  3    18 	  2 context		ptr unaligned,
  3    19 	  2 prologue		ptr unaligned,
  3    20 	  2 end_prologue		ptr unaligned,
  3    21 	  2 main			ptr unaligned,
  3    22 	  2 end_main		ptr unaligned,
  3    23 	  2 return_values		ptr unaligned,
  3    24 	  2 return_count		ptr unaligned,
  3    25 	  2 plio_ps		ptr unaligned,
  3    26 	  2 plio_fa		ptr unaligned,
  3    27 	  2 plio_ffsb		ptr unaligned,
  3    28 	  2 plio_ssl		ptr unaligned,
  3    29 	  2 plio_fab2		ptr unaligned,
  3    30 	  2 block_type		bit (9) unaligned,
  3    31 	  2 prefix		bit (12) unaligned,
  3    32 	  2 like_attribute		bit (1) unaligned,
  3    33 	  2 no_stack		bit (1) unaligned,
  3    34 	  2 get_data		bit (1) unaligned,
  3    35 	  2 flush_at_call		bit (1) unaligned,
  3    36 	  2 processed		bit (1) unaligned,
  3    37 	  2 text_displayed		bit (1) unaligned,
  3    38 	  2 number		fixed bin (9) unsigned unaligned,
  3    39 	  2 free_temps		dimension (3) ptr,	/* these fields are used by the code generator */
  3    40 	  2 temp_list		ptr,
  3    41 	  2 entry_list		ptr,
  3    42 	  2 o_and_s		ptr,
  3    43 	  2 why_nonquick		aligned,
  3    44 	    3 auto_adjustable_storage bit (1) unaligned,
  3    45 	    3 returns_star_extents	bit (1) unaligned,
  3    46 	    3 stack_extended_by_args	bit (1) unaligned,
  3    47 	    3 invoked_by_format	bit (1) unaligned,
  3    48 	    3 format_statement	bit (1) unaligned,
  3    49 	    3 io_statements		bit (1) unaligned,
  3    50 	    3 assigned_to_entry_var	bit (1) unaligned,
  3    51 	    3 condition_statements	bit (1) unaligned,
  3    52 	    3 no_owner		bit (1) unaligned,
  3    53 	    3 recursive_call	bit (1) unaligned,
  3    54 	    3 options_non_quick	bit (1) unaligned,
  3    55 	    3 options_variable	bit (1) unaligned,
  3    56 	    3 never_referenced	bit (1) unaligned,
  3    57 	    3 pad_nonquick		bit (5) unaligned,
  3    58 	  2 prologue_flag		bit (1) unaligned,
  3    59 	  2 options_main		bit (1) unaligned,
  3    60 	  2 pad			bit (16) unaligned,
  3    61 	  2 number_of_entries	fixed bin (17),
  3    62 	  2 level			fixed bin (17),
  3    63 	  2 last_auto_loc		fixed bin (17),
  3    64 	  2 symbol_block		fixed bin (17),
  3    65 	  2 entry_info		fixed bin (18),
  3    66 	  2 enter			structure unaligned,
  3    67 	    3 start		fixed bin (17),
  3    68 	    3 end			fixed bin (17),
  3    69 	  2 leave			structure unaligned,
  3    70 	    3 start		fixed bin (17),
  3    71 	    3 end			fixed bin (17),
  3    72 	  2 owner			ptr;
  3    73 
  3    74 declare	max_block_number		fixed bin internal static options (constant) initial (511);
  3    75 
  3    76 /* END INCLUDE FILE ... block.incl.pl1 */
       74 
  4     1 /* ***********************************************************
  4     2*   *                                                         *
  4     3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
  4     4*   *                                                         *
  4     5*   *********************************************************** */
  4     6 /* BEGIN INCLUDE FILE ... statement.incl.pl1 */
  4     7 /* Internal interface of the PL/I compiler */
  4     8 
  4     9 dcl	1 statement		based aligned,
  4    10 	2 node_type		bit(9) unaligned,
  4    11 	2 source_id		structure unaligned,
  4    12 	  3 file_number		bit(8),
  4    13 	  3 line_number		bit(14),
  4    14 	  3 statement_number	bit(5),
  4    15 	2 next			ptr unaligned,
  4    16 	2 back			ptr unaligned,
  4    17 	2 root			ptr unaligned,
  4    18 	2 labels			ptr unaligned,
  4    19 	2 reference_list		ptr unaligned,
  4    20 	2 state_list		ptr unaligned,
  4    21 	2 reference_count		fixed(17) unaligned,
  4    22 	2 ref_count_copy		fixed(17) unaligned,
  4    23 	2 object			structure unaligned,
  4    24 	  3 start			fixed(17),
  4    25 	  3 finish		fixed(17),
  4    26 	2 source			structure unaligned,
  4    27 	  3 segment		fixed(11),
  4    28 	  3 start			fixed(23),
  4    29 	  3 length		fixed(11),
  4    30 	2 prefix			bit(12) unaligned,
  4    31 	2 optimized		bit(1) unaligned,
  4    32 	2 free_temps		bit(1) unaligned,
  4    33 	2 LHS_in_RHS		bit(1) unaligned,
  4    34 	2 statement_type		bit(9) unaligned,
  4    35 	2 bits			structure unaligned,
  4    36 	  3 processed		bit(1) unaligned,
  4    37 	  3 put_in_profile		bit(1) unaligned,
  4    38 	  3 generated		bit(1) unaligned,
  4    39 	  3 snap			bit(1) unaligned,
  4    40 	  3 system		bit(1) unaligned,
  4    41 	  3 irreducible		bit(1) unaligned,
  4    42 	  3 checked		bit(1) unaligned,
  4    43 	  3 save_temps		bit(1) unaligned,
  4    44 	  3 suppress_warnings	bit(1) unaligned,
  4    45 	  3 force_nonquick		bit(1) unaligned,
  4    46 	  3 expanded_by_name	bit(1) unaligned,
  4    47 	  3 begins_loop		bit(1) unaligned,
  4    48 	  3 pad			bit(24) unaligned;
  4    49 
  4    50 /* END INCLUDE FILE ... statement.incl.pl1 */
       75 
  5     1 /* BEGIN INCLUDE FILE ... symbol.incl.pl1 */
  5     2 
  5     3 dcl	1 symbol			based aligned,
  5     4 	2 node_type		bit(9) unal,
  5     5 	2 source_id		structure unal,
  5     6 	  3 file_number		bit(8),
  5     7 	  3 line_number		bit(14),
  5     8 	  3 statement_number	bit(5),
  5     9 	2 location		fixed(18) unal unsigned,
  5    10 	2 allocated		bit(1) unal,
  5    11 	2 dcl_type		bit(3) unal,
  5    12 	2 reserved		bit(6) unal,
  5    13 	2 pix			unal,
  5    14 	  3 pic_fixed		bit(1) unal,
  5    15 	  3 pic_float		bit(1) unal,
  5    16 	  3 pic_char		bit(1) unal,
  5    17 	  3 pic_scale		fixed(7) unal,
  5    18 	  3 pic_size		fixed(7) unal,
  5    19 	2 level			fixed(8) unal,
  5    20 	2 boundary		fixed(3) unal,
  5    21 	2 size_units		fixed(3) unal,
  5    22 	2 scale			fixed(7) unal,
  5    23 	2 runtime			bit(18) unal,
  5    24 	2 runtime_offset		bit(18) unal,
  5    25 	2 block_node		ptr unal,
  5    26 	2 token			ptr unal,
  5    27 	2 next			ptr unal,
  5    28 	2 multi_use		ptr unal,
  5    29 	2 cross_references		ptr unal,
  5    30 	2 initial			ptr unal,
  5    31 	2 array			ptr unal,
  5    32 	2 descriptor		ptr unal,
  5    33 	2 equivalence		ptr unal,
  5    34 	2 reference		ptr unal,
  5    35 	2 general			ptr unal,
  5    36 	2 father			ptr unal,
  5    37 	2 brother			ptr unal,
  5    38 	2 son			ptr unal,
  5    39 	2 word_size		ptr unal,
  5    40 	2 bit_size		ptr unal,
  5    41 	2 dcl_size		ptr unal,
  5    42 	2 symtab_size		ptr unal,
  5    43 	2 c_word_size		fixed(24),
  5    44 	2 c_bit_size		fixed(24),
  5    45 	2 c_dcl_size		fixed(24),
  5    46 
  5    47 	2 attributes		structure aligned,
  5    48 	  3 data_type		structure unal,
  5    49 	    4 structure		bit(1) ,
  5    50 	    4 fixed		bit(1),
  5    51 	    4 float		bit(1),
  5    52 	    4 bit			bit(1),
  5    53 	    4 char		bit(1),
  5    54 	    4 ptr			bit(1),
  5    55 	    4 offset		bit(1),
  5    56 	    4 area		bit(1),
  5    57 	    4 label		bit(1),
  5    58 	    4 entry		bit(1),
  5    59 	    4 file		bit(1),
  5    60 	    4 arg_descriptor	bit(1),
  5    61 	    4 storage_block		bit(1),
  5    62 	    4 explicit_packed	bit(1), /* options(packed) */
  5    63 	    4 condition		bit(1),
  5    64 	    4 format		bit(1),
  5    65 	    4 builtin		bit(1),
  5    66 	    4 generic		bit(1),
  5    67 	    4 picture		bit(1),
  5    68 
  5    69 	  3 misc_attributes		structure unal,
  5    70 	    4 dimensioned		bit(1),
  5    71 	    4 initialed		bit(1),
  5    72 	    4 aligned		bit(1),
  5    73 	    4 unaligned		bit(1),
  5    74 	    4 signed		bit(1),
  5    75 	    4 unsigned		bit(1),
  5    76 	    4 precision		bit(1),
  5    77 	    4 varying		bit(1),
  5    78 	    4 local		bit(1),
  5    79 	    4 decimal		bit(1),
  5    80 	    4 binary		bit(1),
  5    81 	    4 real		bit(1),
  5    82 	    4 complex		bit(1),
  5    83 	    4 variable		bit(1),
  5    84 	    4 reducible		bit(1),
  5    85 	    4 irreducible		bit(1),
  5    86 	    4 returns		bit(1),
  5    87 	    4 position		bit(1),
  5    88 	    4 internal		bit(1),
  5    89 	    4 external		bit(1),
  5    90 	    4 like		bit(1),
  5    91 	    4 member		bit(1),
  5    92 	    4 non_varying		bit(1),
  5    93 	    4 options		bit(1),
  5    94 	    4 variable_arg_list 	bit(1),		/* options(variable) */
  5    95 	    4 alloc_in_text		bit(1),		/* options(constant) */
  5    96 
  5    97 	  3 storage_class		structure unal,
  5    98 	    4 auto		bit(1),
  5    99 	    4 based		bit(1),
  5   100 	    4 static		bit(1),
  5   101 	    4 controlled		bit(1),
  5   102 	    4 defined		bit(1),
  5   103 	    4 parameter		bit(1),
  5   104 	    4 param_desc		bit(1),
  5   105 	    4 constant		bit(1),
  5   106 	    4 temporary		bit(1),
  5   107 	    4 return_value		bit(1),
  5   108 
  5   109 	  3 file_attributes		structure unal,
  5   110 	    4 print		bit(1),
  5   111 	    4 input		bit(1),
  5   112 	    4 output		bit(1),
  5   113 	    4 update		bit(1),
  5   114 	    4 stream		bit(1),
  5   115 	    4 reserved_1		bit(1),
  5   116 	    4 record		bit(1),
  5   117 	    4 sequential		bit(1),
  5   118 	    4 direct		bit(1),
  5   119 	    4 interactive		bit(1),		/* env(interactive) */
  5   120 	    4 reserved_2		bit(1),
  5   121 	    4 reserved_3		bit(1),
  5   122 	    4 stringvalue		bit(1),		/* env(stringvalue) */
  5   123 	    4 keyed		bit(1),
  5   124 	    4 reserved_4		bit(1),
  5   125 	    4 environment		bit(1),
  5   126 
  5   127 	  3 compiler_developed	structure unal,
  5   128 	    4 aliasable		bit(1),
  5   129 	    4 packed		bit(1),
  5   130 	    4 passed_as_arg		bit(1),
  5   131 	    4 allocate		bit(1),
  5   132 	    4 set			bit(1),
  5   133 	    4 exp_extents		bit(1),
  5   134 	    4 refer_extents		bit(1),
  5   135 	    4 star_extents		bit(1),
  5   136 	    4 isub		bit(1),
  5   137 	    4 put_in_symtab		bit(1),
  5   138 	    4 contiguous		bit(1),
  5   139 	    4 put_data		bit(1),
  5   140 	    4 overlayed		bit(1),
  5   141 	    4 error		bit(1),
  5   142 	    4 symtab_processed	bit(1),
  5   143 	    4 overlayed_by_builtin	bit(1),
  5   144 	    4 defaulted		bit(1),
  5   145 	    4 connected		bit(1);
  5   146 
  5   147 /* END INCLUDE FILE ... symbol.incl.pl1 */
       76 
  6     1 dcl	1 label			based aligned,
  6     2 	2 node_type		bit(9) unaligned,
  6     3 	2 source_id		structure unaligned,
  6     4 	  3 file_number		bit(8),
  6     5 	  3 line_number		bit(14),
  6     6 	  3 statement_number	bit(5),
  6     7 	2 location		fixed(17) unaligned,
  6     8 	2 allocated		bit(1) unaligned,
  6     9 	2 dcl_type		bit(3) unaligned,
  6    10 	2 reserved		bit(29) unaligned,
  6    11 	2 array			bit(1) unaligned,
  6    12 	2 used_as_format		bit(1) unaligned,
  6    13 	2 used_in_goto		bit(1) unaligned,
  6    14 	2 symbol_table		bit(18) unaligned,
  6    15 	2 low_bound		fixed(17) unaligned,
  6    16 	2 high_bound		fixed(17) unaligned,
  6    17 	2 block_node		ptr unaligned,
  6    18 	2 token			ptr unaligned,
  6    19 	2 next			ptr unaligned,
  6    20 	2 multi_use		ptr unaligned,
  6    21 	2 cross_reference		ptr unaligned,
  6    22 	2 statement		ptr unaligned;
       77 
  7     1 dcl	1 array			based aligned,
  7     2 	2 node_type		bit(9) unaligned,
  7     3 	2 reserved		bit(34) unaligned,
  7     4 	2 number_of_dimensions	fixed(7) unaligned,
  7     5 	2 own_number_of_dimensions	fixed(7) unaligned,
  7     6 	2 element_boundary		fixed(3) unaligned,
  7     7 	2 size_units		fixed(3) unaligned,
  7     8 	2 offset_units		fixed(3) unaligned,
  7     9 	2 interleaved		bit(1) unaligned,
  7    10 	2 c_element_size		fixed(24),
  7    11 	2 c_element_size_bits	fixed(24),
  7    12 	2 c_virtual_origin		fixed(24),
  7    13 	2 element_size		ptr unaligned,
  7    14 	2 element_size_bits		ptr unaligned,
  7    15 	2 virtual_origin		ptr unaligned,
  7    16 	2 symtab_virtual_origin	ptr unaligned,
  7    17 	2 symtab_element_size	ptr unaligned,
  7    18 	2 bounds			ptr unaligned,
  7    19 	2 element_descriptor	ptr unaligned;
  7    20 
  7    21 dcl	1 bound			based aligned,
  7    22 	2 node_type		bit(9),
  7    23 	2 c_lower			fixed(24),
  7    24 	2 c_upper			fixed(24),
  7    25 	2 c_multiplier		fixed(24),
  7    26 	2 c_desc_multiplier		fixed(24),
  7    27 	2 lower			ptr unaligned,
  7    28 	2 upper			ptr unaligned,
  7    29 	2 multiplier		ptr unaligned,
  7    30 	2 desc_multiplier		ptr unaligned,
  7    31 	2 symtab_lower		ptr unaligned,
  7    32 	2 symtab_upper		ptr unaligned,
  7    33 	2 symtab_multiplier		ptr unaligned,
  7    34 	2 next			ptr unaligned;
       78 
  8     1 /* BEGIN INCLUDE FILE ... reference.incl.pl1 */
  8     2 
  8     3 dcl	1 reference		based aligned,
  8     4 	2 node_type		bit(9) unaligned,
  8     5 	2 array_ref		bit(1) unaligned,
  8     6 	2 varying_ref		bit(1) unaligned,
  8     7 	2 shared			bit(1) unaligned,
  8     8 	2 put_data_sw		bit(1) unaligned,
  8     9 	2 processed		bit(1) unaligned,
  8    10 	2 units			fixed(3) unaligned,
  8    11 	2 ref_count		fixed(17) unaligned,
  8    12 	2 c_offset		fixed(24),
  8    13 	2 c_length		fixed(24),
  8    14 	2 symbol			ptr unaligned,
  8    15 	2 qualifier		ptr unaligned,
  8    16 	2 offset			ptr unaligned,
  8    17 	2 length			ptr unaligned,
  8    18 	2 subscript_list		ptr unaligned,
  8    19 						/* these fields are used by the 645 code generator */
  8    20 	2 address			structure unaligned,
  8    21 	  3 base			bit(3),
  8    22 	  3 offset		bit(15),
  8    23 	  3 op			bit(9),
  8    24 	  3 no_address		bit(1),
  8    25 	  3 inhibit		bit(1),
  8    26 	  3 ext_base		bit(1),
  8    27 	  3 tag			bit(6),
  8    28 	2 info			structure unaligned,
  8    29 	  3 address_in		structure,
  8    30 	    4 b			dimension(0:7) bit(1),
  8    31 	    4 storage		bit(1),
  8    32 	  3 value_in		structure,
  8    33 	    4 a			bit(1),
  8    34 	    4 q			bit(1),
  8    35 	    4 aq			bit(1),
  8    36 	    4 string_aq		bit(1),
  8    37 	    4 complex_aq		bit(1),
  8    38 	    4 decimal_aq		bit(1),
  8    39 	    4 b			dimension(0:7) bit(1),
  8    40 	    4 storage		bit(1),
  8    41 	    4 indicators		bit(1),
  8    42 	    4 x			dimension(0:7) bit(1),
  8    43 	  3 other			structure,
  8    44 	    4 big_offset		bit(1),
  8    45 	    4 big_length		bit(1),
  8    46 	    4 modword_in_offset	bit(1),
  8    47 	2 data_type		fixed(5) unaligned,
  8    48 	2 bits			structure unaligned,
  8    49 	  3 padded_ref		bit(1),
  8    50 	  3 aligned_ref		bit(1),
  8    51 	  3 long_ref		bit(1),
  8    52 	  3 forward_ref		bit(1),
  8    53 	  3 ic_ref		bit(1),
  8    54 	  3 temp_ref		bit(1),
  8    55 	  3 defined_ref		bit(1),
  8    56 	  3 evaluated		bit(1),
  8    57 	  3 allocate		bit(1),
  8    58 	  3 allocated		bit(1),
  8    59 	  3 aliasable		bit(1),
  8    60 	  3 even			bit(1),
  8    61 	  3 perm_address		bit(1),
  8    62 	  3 aggregate		bit(1),
  8    63 	  3 hit_zero		bit(1),
  8    64 	  3 dont_save		bit(1),
  8    65 	  3 fo_in_qual		bit(1),
  8    66 	  3 hard_to_load		bit(1),
  8    67 	2 relocation		bit(12) unaligned,
  8    68 	2 more_bits		structure unaligned,
  8    69 	  3 substr		bit(1),
  8    70 	  3 padded_for_store_ref	bit(1),
  8    71 	  3 aligned_for_store_ref	bit(1),
  8    72 	  3 mbz			bit(15),
  8    73 	2 store_ins		bit(18) unaligned;
  8    74 
  8    75 /* END INCLUDE FILE ... reference.incl.pl1 */
       79 
  9     1 /* BEGIN INCLUDE FILE ... list.incl.pl1 */
  9     2 
  9     3 /* Modified 26 June 81 by EBush to add max_list_elements */
  9     4 
  9     5 
  9     6 dcl	1 list		based aligned,
  9     7 	2 node_type	bit(9) unaligned,
  9     8 	2 reserved	bit(12) unaligned,
  9     9 	2 number		fixed(14) unaligned,
  9    10 	2 element		dimension(n refer(list.number)) ptr unaligned;
  9    11 
  9    12 dcl       max_list_elements   fixed bin(17) internal static options (constant)
  9    13 	                    init(16383);
  9    14 
  9    15 /* END INCLUDE FILE ... list.incl.pl1 */
       80 
 10     1 dcl (	root_block		initial("000000001"b),
 10     2 	external_procedure		initial("000000010"b),
 10     3 	internal_procedure		initial("000000011"b),
 10     4 	begin_block		initial("000000100"b),
 10     5 	on_unit			initial("000000101"b))  internal static bit(9) aligned options(constant);
       81 
 11     1 /* BEGIN INCLUDE FILE ... boundary.incl.pl1 */
 11     2 
 11     3 /* Modified: 26 Apr 1979 by PCK to implement 4-bit decimal */
 11     4 
 11     5 dcl (	bit_		init(1),
 11     6 	digit_		init(2),
 11     7 	character_	init(3),
 11     8 	half_		init(4),
 11     9 	word_		init(5),
 11    10 	mod2_		init(6),
 11    11 	mod4_		init(7)) fixed bin(3) int static options(constant);
 11    12 
 11    13 /* END INCLUDE FILE ... boundary.incl.pl1 */
       82 
 12     1 /* BEGIN INCLUDE FILE ... system.incl.pl1 */
 12     2 
 12     3 /* Modified: 25 Apr 1979 by PCK to implemnt 4-bit decimal */
 12     4 
 12     5 dcl (	max_p_flt_bin_1			initial(27),
 12     6 	max_p_flt_bin_2			initial(63),
 12     7 	max_p_fix_bin_1			initial(35),
 12     8 	max_p_fix_bin_2			initial(71),
 12     9 
 12    10 	max_p_dec				initial(59),
 12    11 	max_p_bin_or_dec			initial (71),	/* max (max_p_fix_bin_2, max_p_dec) */
 12    12 
 12    13 	min_scale				initial(-128),
 12    14 	max_scale				initial(+127),
 12    15 	max_bit_string			initial(9437184),
 12    16 	max_char_string			initial(1048576),
 12    17 	max_area_size			initial(262144),
 12    18 	min_area_size			initial(28),
 12    19 
 12    20 	max_bit_string_constant		initial (253),	/* max length of bit literals */
 12    21 	max_char_string_constant		initial (254),	/* max length of character literals */
 12    22 	max_identifier_length		initial (256),
 12    23 	max_number_of_dimensions		initial (127),
 12    24 
 12    25 	max_length_precision		initial(24),
 12    26 	max_offset_precision		initial(24),	/* 18 bits for word offset + 6 bits for bit offset */
 12    27 
 12    28 	max_words_per_variable		initial (262144),
 12    29 
 12    30 	bits_per_word			initial(36),
 12    31 	bits_per_double			initial(72),
 12    32 	packed_digits_per_character		initial(2),
 12    33 	characters_per_half			initial(2),
 12    34 	characters_per_word			initial(4),
 12    35 	characters_per_double		initial(8),
 12    36 
 12    37 	bits_per_character			initial(9),
 12    38 	bits_per_half			initial(18),
 12    39 	bits_per_decimal_digit		initial(9),
 12    40 	bits_per_binary_exponent		initial(8),
 12    41 	bits_per_packed_ptr			initial(36),
 12    42 	words_per_packed_pointer		initial(1),
 12    43 
 12    44 	words_per_fix_bin_1			initial(1),
 12    45 	words_per_fix_bin_2			initial(2),
 12    46 	words_per_flt_bin_1			initial(1),
 12    47 	words_per_flt_bin_2			initial(2),
 12    48 	words_per_varying_string_header	initial(1),
 12    49 	words_per_offset			initial(1),
 12    50 	words_per_pointer			initial(2),
 12    51 	words_per_label_var			initial(4),
 12    52 	words_per_entry_var			initial(4),
 12    53 	words_per_file_var			initial(4),
 12    54 	words_per_format			initial(4),
 12    55 	words_per_condition_var		initial(6),
 12    56 
 12    57 	max_index_register_value		initial(262143),
 12    58 	max_signed_index_register_value	initial(131071),
 12    59 
 12    60 	max_signed_xreg_precision		initial(17),
 12    61 	max_uns_xreg_precision		initial(18),
 12    62 
 12    63 	default_area_size			initial(1024),
 12    64 	default_flt_bin_p			initial(27),
 12    65 	default_fix_bin_p			initial(17),
 12    66 	default_flt_dec_p			initial(10),
 12    67           default_fix_dec_p   		initial(7)) fixed bin(31) internal static options(constant);
 12    68 
 12    69 dcl	bits_per_digit			initial(4.5)  fixed bin(31,1) internal static options(constant);
 12    70 
 12    71 dcl (	integer_type		initial("010000000000000000000100000001100000"b),
 12    72 	dec_integer_type		initial("010000000000000000000100000010100000"b),
 12    73 	pointer_type		initial("000001000000000000000100000000000000"b),
 12    74 	real_type			initial("001000000000000000000100000001100000"b),
 12    75 	complex_type		initial("001000000000000000000100000001010000"b),
 12    76 	builtin_type		initial("000000000000000010000000000000000000"b),
 12    77 	storage_block_type		initial("000000000000100000000000000000000000"b),
 12    78 	arg_desc_type		initial("000000000001000000000000000000000000"b),
 12    79 	local_label_var_type	initial("000000001000000000000100000100001000"b),
 12    80 	entry_var_type		initial("000000000100000000000000000000001000"b),
 12    81 	bit_type			initial("000100000000000000000000000000000000"b),
 12    82 	char_type			initial("000010000000000000000000000000000000"b)) bit(36) aligned int static
 12    83 									options(constant);
 12    84 
 12    85 /* END INCLUDE FILE ... system.incl.pl1 */
       83 
 13     1 /* BEGIN INCLUDE FILE ... declare_type.incl.pl1 */
 13     2 
 13     3 /* Modified: 25 Apr 1979 by PCK to implement 4-bit decimal */
 13     4 
 13     5 dcl  (	by_declare	initial("001"b),
 13     6 	by_explicit_context initial("010"b),
 13     7 	by_context	initial("011"b),
 13     8 	by_implication	initial("100"b),
 13     9 	by_compiler	initial("101"b)) int static bit(3) aligned options(constant);
 13    10 
 13    11 /* END INCLUDE FILE ... declare_type.incl.pl1 */
       84 
       85 
       86 	block_pt, blk_pt = pt;
       87 
       88 	if cg_static_$separate_static
       89 	then do;
       90 	     static_base = cg_static_$stat_base;
       91 	     pos_pt = addr(cg_static_$stat_pos);
       92 	     end;
       93 	else do;
       94 	     static_base = cg_static_$link_base;
       95 	     pos_pt = addr(cg_static_$link_pos);
       96 	     end;
       97 
       98 again:	if block_pt = null then return;
       99 	cg_static_$cur_block = block_pt;
      100 
      101 	no_runtime_symbol = ^ (cg_static_$table_option | cg_static_$generate_symtab);
      102 
      103 	if block_pt -> block.no_stack
      104 	then do;
      105 
      106 	     /* get ptr to block owning this quick block */
      107 
      108 	     do while(blk_pt -> block.no_stack);
      109 		if blk_pt -> block.owner = null then blk_pt = blk_pt -> block.father;
      110 		else blk_pt = blk_pt -> block.owner;
      111 		end;
      112 
      113 	     /* the level of a quick block is that of the block in which
      114*	        its storage is being allocated;  the level of that block,
      115*	        if not previously set, is that of its parent + 1.
      116*	        (Iterate, if necessary.) */
      117 
      118 	     increment = 0;
      119 	     bp = blk_pt;
      120 	     do while(bp -> block.level = 0);
      121 		bp -> block.last_auto_loc = max(param_array,bp -> block.last_auto_loc);
      122 		increment = increment + 1;
      123 		bp = bp -> block.father;
      124 
      125 		do while(bp -> block.no_stack);
      126 		     if bp = block_pt	/* without this test, the compiler could loop if this were true */
      127 		     then do;
      128 
      129 			/* we have a loop in owner-father chain, so block_pt is unreachable */
      130 
      131 			call error(267,null,(bp -> block.main -> statement.labels -> element(2)));
      132 			bp -> block.why_nonquick.never_referenced = "1"b;
      133 			bp -> block.no_stack = "0"b;
      134 			blk_pt = block_pt;
      135 			go to again;
      136 			end;
      137 
      138 		     if bp -> block.owner = null
      139 			then bp = bp -> block.father;
      140 			else bp = bp -> block.owner;
      141 		     end;
      142 
      143 		end;
      144 
      145 	     cg_static_$cur_level = bp -> block.level + increment;
      146 
      147 	     /* assign space for no_stack block in the ancestor block,
      148*	        reserving space for entry & return info if needed */
      149 
      150 	     auto_ctr = blk_pt -> block.last_auto_loc;
      151 	     if block_pt -> block.block_type ^= begin_block
      152 	     then do;
      153 		auto_ctr = auto_ctr + mod(auto_ctr,2);	/* make even */
      154 		block_pt -> block.entry_info = auto_ctr;
      155 		auto_ctr = auto_ctr + 6;
      156 
      157 		if auto_ctr > cg_static_$max_stack_size
      158 		then call cg_error(308,cg_static_$max_stack_size);
      159 		end;
      160 
      161 	     end;
      162 	else do;
      163 	     cg_static_$cur_level = blk_pt -> block.father -> block.level + 1;
      164 	     auto_ctr = max(param_array,blk_pt -> block.last_auto_loc);
      165 	     end;
      166 
      167 	block_pt -> block.level = cg_static_$cur_level;
      168 
      169 	sym_pt = block_pt -> block.declaration;
      170 
      171 	do while(sym_pt ^= null);
      172 
      173 	     if sym_pt -> node.type = label_node
      174 	     then do;
      175 
      176 		if sym_pt -> label.array
      177 		then do;
      178 		     sym_pt -> label.location = cg_static_$text_pos;
      179 		     cg_static_$text_pos = cg_static_$text_pos + (sym_pt -> label.high_bound -
      180 		      sym_pt -> label.low_bound + 1);
      181 		     sym_pt -> label.allocated = "1"b;
      182 
      183 		     p = create_list(2);
      184 		     p -> list.element(2) = sym_pt;
      185 		     if cg_static_$last_label ^= null
      186 			then cg_static_$last_label -> list.element(1) = p;
      187 			else cg_static_$label_list = p;
      188 		     cg_static_$last_label = p;
      189 		     end;
      190 
      191 		goto loop;
      192 		end;
      193 
      194 	     /* if we have a format, put it on a list for later processing */
      195 
      196 	     if sym_pt -> symbol.format & sym_pt -> symbol.constant
      197 	     then do;
      198 		p = create_list(2);
      199 		p -> list.element(2) = sym_pt;
      200 		p -> list.element(1) = cg_static_$format_list;
      201 		cg_static_$format_list = p;
      202 		goto loop;
      203 		end;
      204 
      205 	     if sym_pt -> symbol.varying then goto no;
      206 
      207 	     if sym_pt -> symbol.packed then goto contig;
      208 
      209 	     if ^ sym_pt -> symbol.bit
      210 	     then if ^ sym_pt -> symbol.char
      211 		then goto no;
      212 
      213 	     /* The following section sets the contiguous bit ON if a reference
      214*	        to the datum never overlaps a word boundary;  the algorithm is
      215*	        due to Jim Gimpel and is described in MSPM BN.9.01 */
      216 
      217 contig:	     if sym_pt -> symbol.dcl_size ^= null then goto no;
      218 
      219 	     q = sym_pt -> symbol.array;
      220 	     if q = null then bit_length = sym_pt -> symbol.c_bit_size;
      221 	     else bit_length = q -> array.c_element_size_bits;
      222 
      223 	     if bit_length = 0 then goto no;
      224 
      225 	     if bit_length = 1 then goto yes;
      226 
      227 	     if sym_pt -> symbol.char
      228 	     then if bit_length = bits_per_char
      229 		then goto yes;
      230 
      231 	     ref_pt = sym_pt -> symbol.reference;
      232 	     units = ref_pt -> reference.units;
      233 
      234 	     if ref_pt -> reference.offset ^= null
      235 	     then if units < word_ then goto no;
      236 
      237 	     cfo = mod(ref_pt -> reference.c_offset * fo_mult(units),bits_per_word);
      238 
      239 	     if q = null
      240 	     then if cfo + bit_length <= bits_per_word
      241 		then goto yes; else goto no;
      242 
      243 	     if q -> virtual_origin ^= null then goto no;
      244 
      245 	     a_units = q -> array.offset_units;
      246 	     n = mod(q -> c_virtual_origin * fo_mult(a_units),bits_per_word);
      247 
      248 	     c = cfo - n;
      249 	     r = 36;
      250 	     q = q -> array.bounds;
      251 
      252 	     do while(q ^= null);
      253 		n = q -> c_multiplier;
      254 		if n = 0 then goto no;
      255 
      256 		n = mod(n * fo_mult(a_units),bits_per_word);
      257 gcd:		t = mod(n,r);
      258 
      259 		if t ^= 0
      260 		then do;
      261 		     n = r;
      262 		     r = t;
      263 		     goto gcd;
      264 		     end;
      265 
      266 		q = q -> bound.next;
      267 		end;
      268 
      269 	     if bit_length + mod(c,r) <= r then  
      270 yes:	     sym_pt -> symbol.contiguous = "1"b;
      271 
      272 no:	     if ^ sym_pt -> symbol.allocate & no_runtime_symbol then goto loop;
      273 	     if sym_pt -> symbol.father ^= null then goto loop;
      274 
      275 	     cg_static_$generate_symtab = cg_static_$generate_symtab | sym_pt -> symbol.put_in_symtab;
      276 
      277 	     /* have a symbol that has to be allocated, check for referenced
      278*	        but not set */
      279 
      280 	     not_set = "0"b;
      281 	     if ^ sym_pt -> symbol.allocate then goto disp;
      282 	     if block_pt -> block.get_data then goto disp;
      283 	     if sym_pt -> symbol.dcl_type = by_compiler then goto disp;
      284 	     if sym_pt -> symbol.aliasable then goto disp;
      285 	     if sym_pt -> symbol.area then goto disp;
      286 
      287 	     /* following eliminates error 307 for
      288*		dcl a based(p);
      289*	        where "p" is never references in program */
      290 
      291 	     if (sym_pt -> symbol.ptr | sym_pt -> symbol.offset)
      292 	     then if sym_pt -> symbol.put_in_symtab
      293 		then goto disp;
      294 
      295 	     not_set = ^ (sym_pt -> symbol.set | sym_pt -> symbol.passed_as_arg);
      296 
      297 	     /* the only storage classes we handle are auto and int static */
      298 
      299 disp:	     if sym_pt -> symbol.auto
      300 	     then do;
      301 		if ^ sym_pt -> symbol.structure & not_set
      302 		then call error(307,null,sym_pt);
      303 
      304 		call assign_datum(sym_pt,auto_ctr);
      305 
      306 		if auto_ctr > cg_static_$max_stack_size
      307 		then call cg_error(308,cg_static_$max_stack_size);
      308 
      309                     if cg_static_$text_pos > cg_static_$max_program_size
      310                     then call cg_error(311,cg_static_$max_stack_size);
      311 
      312 		goto fl;
      313 		end;
      314 
      315 	     if sym_pt->symbol.controlled & ^sym_pt->symbol.arg_descriptor
      316 	     then do;
      317 		if sym_pt->symbol.internal
      318 		then do;
      319 		     sym_pt->symbol.allocated = "1"b;
      320 		     if not_set & ^sym_pt->symbol.structure & sym_pt->symbol.initial = null
      321 			then call error(307,null,sym_pt);
      322 		     loc = pos_pt -> static_pos;
      323 		     loc = loc + mod(loc,2);
      324 		     pos_pt -> static_pos = loc + 6;
      325 		     sym_pt->symbol.location = loc;
      326 		     q = addrel(static_base,loc);
      327 		     q->cptr(1) = null;
      328 		     q->cptr(2) = null;
      329 		     q->cptr(3) = null;
      330 		     end;
      331 
      332 flc:		q = sym_pt->symbol.descriptor->reference.symbol;
      333 		if q->symbol.controlled
      334 		then do;
      335 			if sym_pt->symbol.external
      336 			then do;
      337 				q->symbol.external = "1"b;
      338 				q->symbol.internal = "0"b;
      339 			     end;
      340 			else do;
      341 				q->symbol.location = loc + 2;
      342 				q->symbol.allocated = "1"b;
      343 			     end;
      344 		     end;
      345 		go to fl;
      346 		end;
      347 
      348 	     if sym_pt -> symbol.file
      349 	     then if sym_pt -> symbol.constant
      350 		then if sym_pt -> symbol.internal
      351 		     then goto int_stat;
      352 
      353 	     if sym_pt -> symbol.static
      354 	     then do;
      355 
      356 		if ^ sym_pt -> symbol.internal then goto fl;
      357 
      358 int_stat:		datum_size = sym_pt -> symbol.c_word_size;
      359 
      360 		if not_set | sym_pt -> symbol.alloc_in_text
      361 		then do;
      362 
      363 		     if ^ sym_pt -> symbol.structure & sym_pt -> symbol.initial = null
      364 		     then do;
      365 			if sym_pt -> symbol.alloc_in_text
      366 			then do;
      367 			     call error(482,null,sym_pt);
      368 			     sym_pt->alloc_in_text = "0"b;
      369 			     goto int_stat;
      370 			     end;
      371 
      372 		          else call error(307,null,sym_pt);
      373 
      374 		          sym_pt -> symbol.allocated = "1"b;
      375 		          goto fl;
      376 		          end;
      377 
      378 		     if sym_pt -> symbol.son ^= null then goto tx;
      379 
      380 		     /* turn into a constant */
      381 
      382 		     sym_pt -> symbol.multi_use = cg_static_$constant_list;
      383 		     cg_static_$constant_list = sym_pt;
      384 
      385 		     if datum_size > 1
      386 		     then do;
      387 			allocate buffer in(tree_area) set(q);
      388 			goto ci;
      389 			end;
      390 
      391 		     n = 0;
      392 		     call initialize_int_static(sym_pt,addr(n));
      393 
      394 		     p = sym_pt -> symbol.multi_use;
      395 		     do while(p ^= null);
      396 			q = p -> symbol.initial;
      397 
      398 			if datum_size <= p -> symbol.c_word_size
      399 			then if q -> fix_bin = n
      400 			     then do;
      401 				if p -> symbol.equivalence = null
      402 				     then sym_pt -> symbol.equivalence = p;
      403 				     else sym_pt -> symbol.equivalence = p -> symbol.equivalence;
      404 
      405 				if p -> symbol.allocated
      406 				then do;
      407 				     sym_pt -> symbol.location = p -> symbol.location;
      408 				     sym_pt -> symbol.allocated = "1"b;
      409 				     end;
      410 				else if no_runtime_symbol
      411 				     then sym_pt -> symbol.allocate = "0"b;
      412 				     else sym_pt->symbol.equivalence -> symbol.allocate = "1"b;
      413 
      414 				goto si;
      415 				end;
      416 
      417 			p = p -> symbol.multi_use;
      418 			end;
      419 
      420 		     /* there was no existing constant with this value as a prefix */
      421 
      422 		     allocate fix_bin in(tree_area) set(q);
      423 		     q -> fix_bin = n;
      424 
      425 		     goto si;
      426 
      427 		     /* assign to text section */
      428 
      429 tx:		     loc = cg_static_$text_pos;
      430 		     if sym_pt -> symbol.boundary = mod2_ | datum_size = 2
      431 		     then loc = loc + mod(loc,2);
      432 
      433 		     cg_static_$text_pos = loc + datum_size;
      434 
      435 		     sym_pt -> symbol.location = loc;
      436 		     sym_pt -> symbol.allocated = "1"b;
      437 
      438 		     q = addrel(cg_static_$text_base,loc);
      439 
      440 ci:		     call initialize_int_static(sym_pt,q);
      441 
      442 si:		     sym_pt -> symbol.initial = q;
      443 		     sym_pt -> symbol.constant = "1"b;
      444 		     sym_pt -> symbol.static = "0"b;
      445 
      446 		     goto fl;
      447 		     end;
      448 
      449 		call assign_datum(sym_pt,pos_pt->static_pos);
      450 
      451 		if sym_pt -> symbol.initial ^= null | sym_pt -> symbol.area
      452 		then call initialize_int_static(sym_pt,addrel(static_base,loc));
      453 
      454 fl:		q = sym_pt -> symbol.son;
      455 		if q ^= null then call fill_loc(q);
      456 
      457 		end;
      458 
      459 loop:	     sym_pt = sym_pt -> symbol.next;
      460 	     end;
      461 
      462 	/* finished with user storage, now do temps */
      463 
      464 	if block_pt -> block.block_type ^= root_block then goto done;
      465 
      466 	sym_pt = cg_static_$temporary_list;
      467 	do while(sym_pt ^= null);
      468 
      469 	     if sym_pt -> symbol.allocate
      470 	     then call assign_datum(sym_pt,auto_ctr);
      471 
      472 	     sym_pt = sym_pt -> symbol.next;
      473 	     end;
      474 
      475 done:	blk_pt -> block.last_auto_loc = auto_ctr;
      476 
      477 	p = block_pt -> block.son;
      478 	if p ^= null then call assign_storage(p);
      479 
      480 	blk_pt, block_pt = block_pt -> block.brother;
      481 	goto again;
      482 
      483 assign_datum:  proc(s,ctr);
      484 
      485 dcl	     s ptr,
      486 	     ctr fixed bin(17);
      487 
      488 dcl	     (amt,k) fixed bin(17),
      489 	     my_s ptr;
      490 
      491 	     my_s = s;
      492 
      493 	     amt = my_s -> symbol.c_word_size;
      494 	     if my_s -> symbol.boundary = mod2_ | amt = 2
      495 	     then ctr = ctr + mod(ctr,2);
      496 
      497 	     loc = ctr;
      498 	     ctr = ctr + amt;
      499 
      500 	     my_s -> symbol.location = loc;
      501 	     my_s -> symbol.allocated = "1"b;
      502 
      503 	     end;
      504 
      505 fill_loc:	     proc(s);
      506 
      507 dcl	     s ptr;
      508 
      509 dcl	     (p,q,p1) ptr;
      510 
      511 	     p = s;
      512 repeat:	     if p = null then return;
      513 
      514 	     p -> symbol.location = loc;
      515 	     p -> symbol.allocated = "1"b;
      516 
      517 	     /* if father is external, set son external also */
      518 
      519 	     if p -> symbol.father -> symbol.external
      520 	     then do;
      521 		p -> symbol.internal = "0"b;
      522 		p -> symbol.external = "1"b;
      523 		goto do_son;
      524 		end;
      525 
      526 	     if p -> symbol.cross_references = null then goto l1;
      527 	     if cg_static_$generate_symtab then goto l1;
      528 	     if p -> symbol.aliasable then goto l1;
      529 	     if p -> symbol.dcl_type = by_compiler then goto l1;
      530 	     if p -> symbol.set then goto l1;
      531 	     if p -> symbol.passed_as_arg then goto l1;
      532 	     if p -> symbol.structure then goto l1;
      533 
      534 	     if p -> symbol.auto
      535 	     then do;
      536 		call error(307,null,p);
      537 		goto l1;
      538 		end;
      539 
      540 	     if (p->symbol.static|p->symbol.controlled) & p->symbol.internal
      541 	     then if p -> symbol.initial = null
      542 		then call error(307,null,p);
      543 
      544 	     /* check for switch into text segment */
      545 
      546 l1:	     if p -> symbol.father -> symbol.constant
      547 	     then do;
      548 		p -> symbol.constant = "1"b;
      549 		p -> symbol.static, p -> symbol.auto = "0"b;
      550 		p1 = cg_static_$text_base;
      551 		end;
      552 	     else p1 = static_base;
      553 
      554 	     p1 = addrel(p1,loc);
      555 
      556 	     if p -> symbol.static | p -> symbol.constant
      557 	     then if p -> symbol.initial ^= null | p -> symbol.area
      558 		then call initialize_int_static(p,p1);
      559 
      560 	     if p -> symbol.constant then p -> symbol.initial = p1;
      561 
      562 do_son:	     q = p -> symbol.son;
      563 	     if q ^= null then call fill_loc(q);
      564 
      565 	     p = p -> symbol.brother;
      566 	     goto repeat;
      567 	     end;
      568 
      569 	end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    12/01/87  1555.1  assign_storage.pl1                >spec>install>MR12.2-1005>assign_storage.pl1
72           1    07/21/80  1546.3  pl1_tree_areas.incl.pl1           >ldd>include>pl1_tree_areas.incl.pl1
73           2    07/21/80  1546.3  nodes.incl.pl1                    >ldd>include>nodes.incl.pl1
74           3    08/13/81  2043.5  block.incl.pl1                    >ldd>include>block.incl.pl1
75           4    04/07/83  1635.0  statement.incl.pl1                >ldd>include>statement.incl.pl1
76           5    12/07/83  1701.7  symbol.incl.pl1                   >ldd>include>symbol.incl.pl1
77           6    05/06/74  1742.1  label.incl.pl1                    >ldd>include>label.incl.pl1
78           7    05/06/74  1741.6  array.incl.pl1                    >ldd>include>array.incl.pl1
79           8    07/21/80  1546.3  reference.incl.pl1                >ldd>include>reference.incl.pl1
80           9    08/13/81  2211.5  list.incl.pl1                     >ldd>include>list.incl.pl1
81          10    05/03/76  1320.8  block_types.incl.pl1              >ldd>include>block_types.incl.pl1
82          11    10/25/79  1645.8  boundary.incl.pl1                 >ldd>include>boundary.incl.pl1
83          12    12/07/83  1701.7  system.incl.pl1                   >ldd>include>system.incl.pl1
84          13    10/25/79  1645.8  declare_type.incl.pl1             >ldd>include>declare_type.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_units                         000132 automatic       fixed bin(17,0)          dcl 51 set ref 245* 246 256
addrel                                                 builtin function         dcl 63 ref 326 438 451 451 554
aliasable                32(35)        based           bit(1)                   level 4 packed unaligned dcl 5-3 ref 284 528
alloc_in_text            32(08)        based           bit(1)                   level 4 packed unaligned dcl 5-3 set ref 360 365
                                                                                  368*
allocate                 33(02)        based           bit(1)                   level 4 packed unaligned dcl 5-3 set ref 272 281
                                                                                  410* 412* 469
allocated                 1(18)        based           bit(1)                   level 2 in structure "label" packed unaligned
                                                                                  dcl 6-1 in procedure "assign_storage" set ref 181*
allocated                 1(18)        based           bit(1)                   level 2 in structure "symbol" packed unaligned
                                                                                  dcl 5-3 in procedure "assign_storage" set ref 319*
                                                                                  342* 374* 405 408* 436* 501* 515*
amt                             000146 automatic       fixed bin(17,0)          dcl 488 set ref 493* 494 498
area                     31(07)        based           bit(1)                   level 4 packed unaligned dcl 5-3 ref 285 451 556
arg_descriptor           31(11)        based           bit(1)                   level 4 packed unaligned dcl 5-3 ref 315
array                                  based           structure                level 1 dcl 7-1 in procedure "assign_storage"
array                    12            based           pointer                  level 2 in structure "symbol" packed unaligned
                                                                                  dcl 5-3 in procedure "assign_storage" ref 219
array                     2(15)        based           bit(1)                   level 2 in structure "label" packed unaligned
                                                                                  dcl 6-1 in procedure "assign_storage" ref 176
assign_storage                  000060 constant        entry                    external dcl 51 ref 478
attributes               31            based           structure                level 2 dcl 5-3
auto                     32(09)        based           bit(1)                   level 4 packed unaligned dcl 5-3 set ref 299 534
                                                                                  549*
auto_ctr                        000122 automatic       fixed bin(17,0)          dcl 51 set ref 150* 153* 153 153 154 155* 155 157
                                                                                  164* 304* 306 469* 475
begin_block                            constant        bit(9)                   initial dcl 10-1 ref 151
bit                      31(03)        based           bit(1)                   level 4 packed unaligned dcl 5-3 ref 209
bit_length                      000134 automatic       fixed bin(17,0)          dcl 51 set ref 220* 221* 223 225 227 239 269
bits_per_char                          constant        fixed bin(17,0)          initial dcl 65 ref 227
bits_per_word                   002036 constant        fixed bin(31,0)          initial dcl 12-5 ref 237 239 246 256
blk_pt                          000102 automatic       pointer                  dcl 51 set ref 86* 108 109 109* 109 110* 110 119
                                                                                  134* 150 163 164 475 480*
block                                  based           structure                level 1 dcl 3-5
block_pt                        000100 automatic       pointer                  dcl 51 set ref 86* 98 99 103 126 134 151 154 167 169
                                                                                  282 464 477 480 480*
block_type               24            based           bit(9)                   level 2 packed unaligned dcl 3-5 ref 151 464
bound                                  based           structure                level 1 dcl 7-21
boundary                  2(20)        based           fixed bin(3,0)           level 2 packed unaligned dcl 5-3 ref 430 494
bounds                   12            based           pointer                  level 2 packed unaligned dcl 7-1 ref 250
bp                              000110 automatic       pointer                  dcl 51 set ref 119* 120 121 121 123* 123 125 126 131
                                                                                  132 133 138 138* 138 140* 140 145
brother                   2            based           pointer                  level 2 in structure "block" packed unaligned
                                                                                  dcl 3-5 in procedure "assign_storage" ref 480
brother                  20            based           pointer                  level 2 in structure "symbol" packed unaligned
                                                                                  dcl 5-3 in procedure "assign_storage" ref 565
buffer                                 based           fixed bin(17,0)          array dcl 69 ref 387
by_compiler                            constant        bit(3)                   initial dcl 13-5 ref 283 529
c                               000125 automatic       fixed bin(17,0)          dcl 51 set ref 248* 269
c_bit_size               27            based           fixed bin(24,0)          level 2 dcl 5-3 ref 220
c_element_size_bits       3            based           fixed bin(24,0)          level 2 dcl 7-1 ref 221
c_multiplier              3            based           fixed bin(24,0)          level 2 dcl 7-21 ref 253
c_offset                  1            based           fixed bin(24,0)          level 2 dcl 8-3 ref 237
c_virtual_origin          4            based           fixed bin(24,0)          level 2 dcl 7-1 ref 246
c_word_size              26            based           fixed bin(24,0)          level 2 dcl 5-3 ref 358 398 493
cfo                             000124 automatic       fixed bin(17,0)          dcl 51 set ref 237* 239 248
cg_error                        000056 constant        entry                    external dcl 51 ref 157 306 309
cg_static_$constant_list        000024 external static pointer                  dcl 44 set ref 382 383*
cg_static_$cur_block            000010 external static pointer                  dcl 44 set ref 99*
cg_static_$cur_level            000046 external static fixed bin(17,0)          dcl 44 set ref 145* 163* 167
cg_static_$format_list          000012 external static pointer                  dcl 44 set ref 200 201*
cg_static_$generate_symtab      000034 external static bit(1)                   unaligned dcl 44 set ref 101 275* 275 527
cg_static_$label_list           000026 external static pointer                  dcl 44 set ref 187*
cg_static_$last_label           000030 external static pointer                  dcl 44 set ref 185 185 188*
cg_static_$link_base            000022 external static pointer                  dcl 44 ref 94
cg_static_$link_pos             000044 external static fixed bin(17,0)          dcl 44 set ref 95
cg_static_$max_program_size     000052 external static fixed bin(17,0)          dcl 44 ref 309
cg_static_$max_stack_size       000050 external static fixed bin(17,0)          dcl 44 set ref 157 157* 306 306* 309*
cg_static_$separate_static      000032 external static bit(1)                   unaligned dcl 44 ref 88
cg_static_$stat_base            000016 external static pointer                  dcl 44 ref 90
cg_static_$stat_pos             000042 external static fixed bin(17,0)          dcl 44 set ref 91
cg_static_$table_option         000036 external static bit(1)                   unaligned dcl 44 ref 101
cg_static_$temporary_list       000014 external static pointer                  dcl 44 ref 466
cg_static_$text_base            000020 external static pointer                  dcl 44 ref 438 550
cg_static_$text_pos             000040 external static fixed bin(17,0)          dcl 44 set ref 178 179* 179 309 429 433*
char                     31(04)        based           bit(1)                   level 4 packed unaligned dcl 5-3 ref 209 227
compiler_developed       32(35)        based           structure                level 3 packed unaligned dcl 5-3
constant                 32(16)        based           bit(1)                   level 4 packed unaligned dcl 5-3 set ref 196 348
                                                                                  443* 546 548* 556 560
contiguous               33(09)        based           bit(1)                   level 4 packed unaligned dcl 5-3 set ref 269*
controlled               32(12)        based           bit(1)                   level 4 packed unaligned dcl 5-3 ref 315 333 540
cptr                                   based           pointer                  array dcl 51 set ref 327* 328* 329*
create_list                     000064 constant        entry                    external dcl 51 ref 183 198
cross_references         10            based           pointer                  level 2 packed unaligned dcl 5-3 ref 526
ctr                                    parameter       fixed bin(17,0)          dcl 485 set ref 483 494* 494 494 497 498* 498
data_type                31            based           structure                level 3 packed unaligned dcl 5-3
datum_size                      000133 automatic       fixed bin(17,0)          dcl 51 set ref 358* 385 387 398 430 433
dcl_size                 24            based           pointer                  level 2 packed unaligned dcl 5-3 ref 217
dcl_type                  1(19)        based           bit(3)                   level 2 packed unaligned dcl 5-3 ref 283 529
declaration               4            based           pointer                  level 2 packed unaligned dcl 3-5 ref 169
descriptor               13            based           pointer                  level 2 packed unaligned dcl 5-3 ref 332
element                   1            based           pointer                  array level 2 packed unaligned dcl 9-6 set ref 131
                                                                                  184* 185* 199* 200*
entry_info               50            based           fixed bin(18,0)          level 2 dcl 3-5 set ref 154*
equivalence              14            based           pointer                  level 2 packed unaligned dcl 5-3 set ref 401 401*
                                                                                  403* 403 412
error                           000054 constant        entry                    external dcl 51 ref 131 301 320 367 372 536 540
external                 32(02)        based           bit(1)                   level 4 packed unaligned dcl 5-3 set ref 335 337*
                                                                                  519 522*
father                    1            based           pointer                  level 2 in structure "block" packed unaligned
                                                                                  dcl 3-5 in procedure "assign_storage" ref 109 123
                                                                                  138 163
father                   17            based           pointer                  level 2 in structure "symbol" packed unaligned
                                                                                  dcl 5-3 in procedure "assign_storage" ref 273 519
                                                                                  546
file                     31(10)        based           bit(1)                   level 4 packed unaligned dcl 5-3 ref 348
fix_bin                                based           fixed bin(17,0)          dcl 69 set ref 398 422 423*
fo_mult                         000000 constant        fixed bin(17,1)          initial array dcl 65 ref 237 246 256
format                   31(15)        based           bit(1)                   level 4 packed unaligned dcl 5-3 ref 196
get_data                 24(23)        based           bit(1)                   level 2 packed unaligned dcl 3-5 ref 282
high_bound                3(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 6-1 ref 179
increment                       000135 automatic       fixed bin(17,0)          dcl 51 set ref 118* 122* 122 145
initial                  11            based           pointer                  level 2 packed unaligned dcl 5-3 set ref 320 363 396
                                                                                  442* 451 540 556 560*
initialize_int_static           000062 constant        entry                    external dcl 51 ref 392 440 451 556
internal                 32(01)        based           bit(1)                   level 4 packed unaligned dcl 5-3 set ref 317 338*
                                                                                  348 356 521* 540
label                                  based           structure                level 1 dcl 6-1
label_node                             constant        bit(9)                   initial dcl 2-5 ref 173
labels                    4            based           pointer                  level 2 packed unaligned dcl 4-9 ref 131
last_auto_loc            46            based           fixed bin(17,0)          level 2 dcl 3-5 set ref 121* 121 150 164 475*
level                    45            based           fixed bin(17,0)          level 2 dcl 3-5 set ref 120 145 163 167*
list                                   based           structure                level 1 dcl 9-6
loc                             000123 automatic       fixed bin(17,0)          dcl 51 set ref 322* 323* 323 323 324 325 326 341
                                                                                  429* 430* 430 430 433 435 438 451 451 497* 500 514
                                                                                  554
location                  1            based           fixed bin(18,0)          level 2 in structure "symbol" packed unsigned
                                                                                  unaligned dcl 5-3 in procedure "assign_storage"
                                                                                  set ref 325* 341* 407* 407 435* 500* 514*
location                  1            based           fixed bin(17,0)          level 2 in structure "label" packed unaligned
                                                                                  dcl 6-1 in procedure "assign_storage" set ref 178*
low_bound                 3            based           fixed bin(17,0)          level 2 packed unaligned dcl 6-1 ref 179
main                     13            based           pointer                  level 2 packed unaligned dcl 3-5 ref 131
max                                                    builtin function         dcl 63 ref 121 164
misc_attributes          31(19)        based           structure                level 3 packed unaligned dcl 5-3
mod                                                    builtin function         dcl 63 ref 153 237 246 256 257 269 323 430 494
mod2_                                  constant        fixed bin(3,0)           initial dcl 11-5 ref 430 494
multi_use                 7            based           pointer                  level 2 packed unaligned dcl 5-3 set ref 382* 394
                                                                                  417
my_s                            000150 automatic       pointer                  dcl 488 set ref 491* 493 494 500 501
n                               000130 automatic       fixed bin(17,0)          dcl 51 set ref 246* 248 253* 254 256* 256 257 261*
                                                                                  391* 392 392 398 423
never_referenced         42(12)        based           bit(1)                   level 3 packed unaligned dcl 3-5 set ref 132*
next                     14            based           pointer                  level 2 in structure "bound" packed unaligned
                                                                                  dcl 7-21 in procedure "assign_storage" ref 266
next                      6            based           pointer                  level 2 in structure "symbol" packed unaligned
                                                                                  dcl 5-3 in procedure "assign_storage" ref 459 472
no_runtime_symbol               000137 automatic       bit(1)                   dcl 51 set ref 101* 272 410
no_stack                 24(22)        based           bit(1)                   level 2 packed unaligned dcl 3-5 set ref 103 108 125
                                                                                  133*
node                                   based           structure                level 1 dcl 2-27
not_set                         000136 automatic       bit(1)                   dcl 51 set ref 280* 295* 301 320 360
null                                                   builtin function         dcl 63 ref 98 109 131 131 138 171 185 217 220 234
                                                                                  239 243 252 273 301 301 320 320 320 327 328 329
                                                                                  363 367 367 372 372 378 395 401 451 455 467 478
                                                                                  512 526 536 536 540 540 540 556 563
offset                    5            based           pointer                  level 2 in structure "reference" packed unaligned
                                                                                  dcl 8-3 in procedure "assign_storage" ref 234
offset                   31(06)        based           bit(1)                   level 4 in structure "symbol" packed unaligned
                                                                                  dcl 5-3 in procedure "assign_storage" ref 291
offset_units              1(31)        based           fixed bin(3,0)           level 2 packed unaligned dcl 7-1 ref 245
owner                    54            based           pointer                  level 2 dcl 3-5 ref 109 110 138 140
p                               000100 automatic       pointer                  dcl 509 in procedure "fill_loc" set ref 511* 512 514
                                                                                  515 519 521 522 526 528 529 530 531 532 534 536*
                                                                                  540 540 540 540 540* 546 548 549 549 556 556 556
                                                                                  556 556* 560 560 562 565* 565
p                               000112 automatic       pointer                  dcl 51 in procedure "assign_storage" set ref 183*
                                                                                  184 185 187 188 198* 199 200 201 394* 395 396 398
                                                                                  401 401 403 405 407 417* 417 477* 478 478*
p1                              000104 automatic       pointer                  dcl 509 set ref 550* 552* 554* 554 556* 560
packed                   33            based           bit(1)                   level 4 packed unaligned dcl 5-3 ref 207
param_array                            constant        fixed bin(17,0)          initial dcl 65 ref 121 164
passed_as_arg            33(01)        based           bit(1)                   level 4 packed unaligned dcl 5-3 ref 295 531
pl1_stat_$tree_area_ptr         000066 external static pointer                  dcl 1-7 ref 387 422
pos_pt                          000120 automatic       pointer                  dcl 51 set ref 91* 95* 322 324 449
pt                                     parameter       pointer                  dcl 42 ref 40 86
ptr                      31(05)        based           bit(1)                   level 4 packed unaligned dcl 5-3 ref 291
put_in_symtab            33(08)        based           bit(1)                   level 4 packed unaligned dcl 5-3 ref 275 291
q                               000102 automatic       pointer                  dcl 509 in procedure "fill_loc" set ref 562* 563
                                                                                  563*
q                               000114 automatic       pointer                  dcl 51 in procedure "assign_storage" set ref 219*
                                                                                  220 221 239 243 245 246 250* 250 252 253 266* 266
                                                                                  326* 327 328 329 332* 333 337 338 341 342 387*
                                                                                  396* 398 422* 423 438* 440* 442 454* 455 455*
r                               000126 automatic       fixed bin(17,0)          dcl 51 set ref 249* 257 261 262* 269 269
ref_pt                          000106 automatic       pointer                  dcl 51 set ref 231* 232 234 237
reference                15            based           pointer                  level 2 in structure "symbol" packed unaligned
                                                                                  dcl 5-3 in procedure "assign_storage" ref 231
reference                              based           structure                level 1 dcl 8-3 in procedure "assign_storage"
root_block                             constant        bit(9)                   initial dcl 10-1 ref 464
s                                      parameter       pointer                  dcl 507 in procedure "fill_loc" ref 505 511
s                                      parameter       pointer                  dcl 485 in procedure "assign_datum" ref 483 491
set                      33(03)        based           bit(1)                   level 4 packed unaligned dcl 5-3 ref 295 530
son                       3            based           pointer                  level 2 in structure "block" packed unaligned
                                                                                  dcl 3-5 in procedure "assign_storage" ref 477
son                      21            based           pointer                  level 2 in structure "symbol" packed unaligned
                                                                                  dcl 5-3 in procedure "assign_storage" ref 378 454
                                                                                  562
statement                              based           structure                level 1 dcl 4-9
static                   32(11)        based           bit(1)                   level 4 packed unaligned dcl 5-3 set ref 353 444*
                                                                                  540 549* 556
static_base                     000116 automatic       pointer                  dcl 51 set ref 90* 94* 326 451 451 552
static_pos                             based           fixed bin(17,0)          dcl 51 set ref 322 324* 449*
storage_class            32(09)        based           structure                level 3 packed unaligned dcl 5-3
structure                31            based           bit(1)                   level 4 packed unaligned dcl 5-3 ref 301 320 363 532
sym_pt                          000104 automatic       pointer                  dcl 51 set ref 169* 171 173 176 178 179 179 181 184
                                                                                  196 196 199 205 207 209 209 217 219 220 227 231
                                                                                  269 272 273 275 281 283 284 285 291 291 291 295
                                                                                  295 299 301 301* 304* 315 315 317 319 320 320 320*
                                                                                  325 332 335 348 348 348 353 356 358 360 363 363
                                                                                  365 367* 368 372* 374 378 382 383 392* 394 401 403
                                                                                  407 408 410 412 430 435 436 440* 442 443 444 449*
                                                                                  451 451 451* 454 459* 459 466* 467 469 469* 472*
                                                                                  472
symbol                                 based           structure                level 1 dcl 5-3 in procedure "assign_storage"
symbol                    3            based           pointer                  level 2 in structure "reference" packed unaligned
                                                                                  dcl 8-3 in procedure "assign_storage" ref 332
t                               000127 automatic       fixed bin(17,0)          dcl 51 set ref 257* 259 262
tree_area                              based           area(1024)               dcl 1-4 ref 387 422
type                                   based           bit(9)                   level 2 packed unaligned dcl 2-27 ref 173
units                     0(14)        based           fixed bin(3,0)           level 2 in structure "reference" packed unaligned
                                                                                  dcl 8-3 in procedure "assign_storage" ref 232
units                           000131 automatic       fixed bin(17,0)          dcl 51 in procedure "assign_storage" set ref 232*
                                                                                  234 237
varying                  31(26)        based           bit(1)                   level 4 packed unaligned dcl 5-3 ref 205
virtual_origin            7            based           pointer                  level 2 packed unaligned dcl 7-1 ref 243
why_nonquick             42            based           structure                level 2 dcl 3-5
word_                                  constant        fixed bin(3,0)           initial dcl 11-5 ref 234

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
arg_desc_type                          internal static bit(36)                  initial dcl 12-71
array_node                             internal static bit(9)                   initial dcl 2-5
bit_                                   internal static fixed bin(3,0)           initial dcl 11-5
bit_type                               internal static bit(36)                  initial dcl 12-71
bits_per_binary_exponent               internal static fixed bin(31,0)          initial dcl 12-5
bits_per_character                     internal static fixed bin(31,0)          initial dcl 12-5
bits_per_decimal_digit                 internal static fixed bin(31,0)          initial dcl 12-5
bits_per_digit                         internal static fixed bin(31,1)          initial dcl 12-69
bits_per_double                        internal static fixed bin(31,0)          initial dcl 12-5
bits_per_half                          internal static fixed bin(31,0)          initial dcl 12-5
bits_per_packed_ptr                    internal static fixed bin(31,0)          initial dcl 12-5
block_node                             internal static bit(9)                   initial dcl 2-5
bound_node                             internal static bit(9)                   initial dcl 2-5
builtin_type                           internal static bit(36)                  initial dcl 12-71
by_context                             internal static bit(3)                   initial dcl 13-5
by_declare                             internal static bit(3)                   initial dcl 13-5
by_explicit_context                    internal static bit(3)                   initial dcl 13-5
by_implication                         internal static bit(3)                   initial dcl 13-5
by_name_agg_node                       internal static bit(9)                   initial dcl 2-5
char_type                              internal static bit(36)                  initial dcl 12-71
character_                             internal static fixed bin(3,0)           initial dcl 11-5
characters_per_double                  internal static fixed bin(31,0)          initial dcl 12-5
characters_per_half                    internal static fixed bin(31,0)          initial dcl 12-5
characters_per_word                    internal static fixed bin(31,0)          initial dcl 12-5
complex_type                           internal static bit(36)                  initial dcl 12-71
context_node                           internal static bit(9)                   initial dcl 2-5
cross_reference_node                   internal static bit(9)                   initial dcl 2-5
dec_integer_type                       internal static bit(36)                  initial dcl 12-71
default_area_size                      internal static fixed bin(31,0)          initial dcl 12-5
default_fix_bin_p                      internal static fixed bin(31,0)          initial dcl 12-5
default_fix_dec_p                      internal static fixed bin(31,0)          initial dcl 12-5
default_flt_bin_p                      internal static fixed bin(31,0)          initial dcl 12-5
default_flt_dec_p                      internal static fixed bin(31,0)          initial dcl 12-5
default_node                           internal static bit(9)                   initial dcl 2-5
digit_                                 internal static fixed bin(3,0)           initial dcl 11-5
divide                                                 builtin function         dcl 63
entry_var_type                         internal static bit(36)                  initial dcl 12-71
err_no                                 automatic       fixed bin(17,0)          dcl 51
external_procedure                     internal static bit(9)                   initial dcl 10-1
fixed                                                  builtin function         dcl 63
format_value_node                      internal static bit(9)                   initial dcl 2-5
half_                                  internal static fixed bin(3,0)           initial dcl 11-5
integer_type                           internal static bit(36)                  initial dcl 12-71
internal_procedure                     internal static bit(9)                   initial dcl 10-1
k                                      automatic       fixed bin(17,0)          dcl 488
label_array_element_node               internal static bit(9)                   initial dcl 2-5
list_node                              internal static bit(9)                   initial dcl 2-5
local_label_var_type                   internal static bit(36)                  initial dcl 12-71
machine_state_node                     internal static bit(9)                   initial dcl 2-5
max_area_size                          internal static fixed bin(31,0)          initial dcl 12-5
max_bit_string                         internal static fixed bin(31,0)          initial dcl 12-5
max_bit_string_constant                internal static fixed bin(31,0)          initial dcl 12-5
max_block_number                       internal static fixed bin(17,0)          initial dcl 3-74
max_char_string                        internal static fixed bin(31,0)          initial dcl 12-5
max_char_string_constant               internal static fixed bin(31,0)          initial dcl 12-5
max_identifier_length                  internal static fixed bin(31,0)          initial dcl 12-5
max_index_register_value               internal static fixed bin(31,0)          initial dcl 12-5
max_length_precision                   internal static fixed bin(31,0)          initial dcl 12-5
max_list_elements                      internal static fixed bin(17,0)          initial dcl 9-12
max_number_of_dimensions               internal static fixed bin(31,0)          initial dcl 12-5
max_offset_precision                   internal static fixed bin(31,0)          initial dcl 12-5
max_p_bin_or_dec                       internal static fixed bin(31,0)          initial dcl 12-5
max_p_dec                              internal static fixed bin(31,0)          initial dcl 12-5
max_p_fix_bin_1                        internal static fixed bin(31,0)          initial dcl 12-5
max_p_fix_bin_2                        internal static fixed bin(31,0)          initial dcl 12-5
max_p_flt_bin_1                        internal static fixed bin(31,0)          initial dcl 12-5
max_p_flt_bin_2                        internal static fixed bin(31,0)          initial dcl 12-5
max_scale                              internal static fixed bin(31,0)          initial dcl 12-5
max_signed_index_register_value        internal static fixed bin(31,0)          initial dcl 12-5
max_signed_xreg_precision              internal static fixed bin(31,0)          initial dcl 12-5
max_uns_xreg_precision                 internal static fixed bin(31,0)          initial dcl 12-5
max_words_per_variable                 internal static fixed bin(31,0)          initial dcl 12-5
min_area_size                          internal static fixed bin(31,0)          initial dcl 12-5
min_scale                              internal static fixed bin(31,0)          initial dcl 12-5
mod4_                                  internal static fixed bin(3,0)           initial dcl 11-5
on_unit                                internal static bit(9)                   initial dcl 10-1
operator_node                          internal static bit(9)                   initial dcl 2-5
packed_digits_per_character            internal static fixed bin(31,0)          initial dcl 12-5
pl1_stat_$xeq_tree_area_ptr            external static pointer                  dcl 1-7
pointer_type                           internal static bit(36)                  initial dcl 12-71
q1                                     automatic       pointer                  dcl 51
real_type                              internal static bit(36)                  initial dcl 12-71
reference_node                         internal static bit(9)                   initial dcl 2-5
sf_par_node                            internal static bit(9)                   initial dcl 2-5
source_node                            internal static bit(9)                   initial dcl 2-5
statement_node                         internal static bit(9)                   initial dcl 2-5
storage_block_type                     internal static bit(36)                  initial dcl 12-71
symbol_node                            internal static bit(9)                   initial dcl 2-5
temporary_node                         internal static bit(9)                   initial dcl 2-5
token_node                             internal static bit(9)                   initial dcl 2-5
words_per_condition_var                internal static fixed bin(31,0)          initial dcl 12-5
words_per_entry_var                    internal static fixed bin(31,0)          initial dcl 12-5
words_per_file_var                     internal static fixed bin(31,0)          initial dcl 12-5
words_per_fix_bin_1                    internal static fixed bin(31,0)          initial dcl 12-5
words_per_fix_bin_2                    internal static fixed bin(31,0)          initial dcl 12-5
words_per_flt_bin_1                    internal static fixed bin(31,0)          initial dcl 12-5
words_per_flt_bin_2                    internal static fixed bin(31,0)          initial dcl 12-5
words_per_format                       internal static fixed bin(31,0)          initial dcl 12-5
words_per_label_var                    internal static fixed bin(31,0)          initial dcl 12-5
words_per_offset                       internal static fixed bin(31,0)          initial dcl 12-5
words_per_packed_pointer               internal static fixed bin(31,0)          initial dcl 12-5
words_per_pointer                      internal static fixed bin(31,0)          initial dcl 12-5
words_per_varying_string_header        internal static fixed bin(31,0)          initial dcl 12-5
xeq_tree_area                          based           area(1024)               dcl 1-5

NAMES DECLARED BY EXPLICIT CONTEXT.
again                           000044 constant        label                    dcl 98 ref 135 481
assign_datum                    001520 constant        entry                    internal dcl 483 ref 304 449 469
assign_storage                  000015 constant        entry                    external dcl 40
ci                              001344 constant        label                    dcl 440 ref 388
contig                          000411 constant        label                    dcl 217 ref 207
disp                            000655 constant        label                    dcl 299 ref 281 282 283 284 285 291
do_son                          001777 constant        label                    dcl 562 ref 523
done                            001472 constant        label                    dcl 475 ref 464
fill_loc                        001560 constant        entry                    internal dcl 505 ref 455 563
fl                              001421 constant        label                    dcl 454 ref 312 345 356 375 446
flc                             001027 constant        label                    dcl 332
gcd                             000545 constant        label                    dcl 257 ref 263
int_stat                        001073 constant        label                    dcl 358 ref 348 369
l1                              001715 constant        label                    dcl 546 ref 526 527 528 529 530 531 532 537
loop                            001436 constant        label                    dcl 459 ref 191 202 272 273
no                              000574 constant        label                    dcl 272 ref 205 209 217 223 234 241 243 254
repeat                          001571 constant        label                    dcl 512 ref 566
si                              001355 constant        label                    dcl 442 ref 414 425
tx                              001310 constant        label                    dcl 429 ref 378
yes                             000571 constant        label                    dcl 269 ref 225 227 239

NAME DECLARED BY CONTEXT OR IMPLICATION.
addr                                                   builtin function         ref 91 95 392 392

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2332        2422    2040        2342
Length      3100    2040        70         442     271           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
assign_storage                      120 external procedure  is an external procedure.  
assign_datum                            internal procedure  shares stack frame of external procedure assign_storage.  
fill_loc                             82 internal procedure  calls itself recursively.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
assign_storage           000100 block_pt                    assign_storage
                         000102 blk_pt                      assign_storage
                         000104 sym_pt                      assign_storage
                         000106 ref_pt                      assign_storage
                         000110 bp                          assign_storage
                         000112 p                           assign_storage
                         000114 q                           assign_storage
                         000116 static_base                 assign_storage
                         000120 pos_pt                      assign_storage
                         000122 auto_ctr                    assign_storage
                         000123 loc                         assign_storage
                         000124 cfo                         assign_storage
                         000125 c                           assign_storage
                         000126 r                           assign_storage
                         000127 t                           assign_storage
                         000130 n                           assign_storage
                         000131 units                       assign_storage
                         000132 a_units                     assign_storage
                         000133 datum_size                  assign_storage
                         000134 bit_length                  assign_storage
                         000135 increment                   assign_storage
                         000136 not_set                     assign_storage
                         000137 no_runtime_symbol           assign_storage
                         000146 amt                         assign_datum
                         000150 my_s                        assign_datum
fill_loc                 000100 p                           fill_loc
                         000102 q                           fill_loc
                         000104 p1                          fill_loc

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        call_int_this       call_int_other      mdfx1               ext_entry           int_entry
trunc_fx1           scaled_mod_fx1      scaled_mod_fx3      op_alloc_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
assign_storage                cg_error                      create_list                   error
initialize_int_static

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
cg_static_$constant_list      cg_static_$cur_block          cg_static_$cur_level          cg_static_$format_list
cg_static_$generate_symtab    cg_static_$label_list         cg_static_$last_label         cg_static_$link_base
cg_static_$link_pos           cg_static_$max_program_size   cg_static_$max_stack_size     cg_static_$separate_static
cg_static_$stat_base          cg_static_$stat_pos           cg_static_$table_option       cg_static_$temporary_list
cg_static_$text_base          cg_static_$text_pos           pl1_stat_$tree_area_ptr




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     40 000012        86 000022        88 000027        90 000031        91 000034        92 000036        94 000037
     95 000042        98 000044        99 000050       101 000053       103 000057       108 000062       109 000066
    110 000075       111 000077       118 000100       119 000101       120 000102       121 000105       122 000112
    123 000113       125 000115       126 000122       131 000126       132 000151       133 000154       134 000156
    135 000160       138 000161       140 000170       141 000172       143 000173       145 000174       150 000177
    151 000202       153 000207       154 000213       155 000215       157 000217       161 000234       163 000235
    164 000242       167 000250       169 000254       171 000256       173 000262       176 000266       178 000272
    179 000276       181 000307       183 000311       184 000323       185 000326       187 000337       188 000340
    191 000341       196 000342       198 000351       199 000364       200 000367       201 000373       202 000374
    205 000375       207 000400       209 000403       217 000411       219 000414       220 000416       221 000425
    223 000427       225 000430       227 000432       231 000437       232 000441       234 000445       237 000453
    239 000465       241 000475       243 000476       245 000501       246 000505       248 000515       249 000520
    250 000522       252 000524       253 000530       254 000533       256 000534       257 000545       259 000551
    261 000552       262 000554       263 000556       266 000557       267 000562       269 000563       272 000574
    273 000602       275 000605       280 000612       281 000613       282 000616       283 000622       284 000627
    285 000632       291 000635       295 000643       299 000655       301 000660       304 000703       306 000705
    309 000723       312 000741       315 000742       317 000750       319 000753       320 000755       322 001003
    323 001005       324 001010       325 001013       326 001017       327 001023       328 001025       329 001026
    332 001027       333 001032       335 001035       337 001040       338 001042       339 001044       341 001045
    342 001051       345 001053       348 001054       353 001065       356 001070       358 001073       360 001076
    363 001105       365 001113       367 001115       368 001134       369 001137       372 001140       374 001157
    375 001162       378 001163       382 001166       383 001172       385 001173       387 001176       388 001205
    391 001206       392 001207       394 001221       395 001224       396 001230       398 001233       401 001242
    403 001250       405 001252       407 001255       408 001257       409 001261       410 001262       412 001267
    414 001272       417 001273       418 001275       422 001276       423 001305       425 001307       429 001310
    430 001313       433 001327       435 001332       436 001335       438 001337       440 001344       442 001355
    443 001360       444 001362       446 001364       449 001365       451 001375       454 001421       455 001424
    459 001436       460 001441       464 001442       466 001447       467 001453       469 001460       472 001466
    473 001471       475 001472       477 001475       478 001500       480 001513       481 001517       483 001520
    491 001522       493 001525       494 001527       497 001544       498 001547       500 001551       501 001554
    503 001556       505 001557       511 001565       512 001571       514 001575       515 001602       519 001604
    521 001610       522 001612       523 001614       526 001615       527 001620       528 001623       529 001626
    530 001633       531 001636       532 001641       534 001644       536 001647       537 001665       540 001666
    546 001715       548 001722       549 001725       550 001731       551 001735       552 001736       554 001741
    556 001746       560 001771       562 001777       563 002002       565 002015       566 002020


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
