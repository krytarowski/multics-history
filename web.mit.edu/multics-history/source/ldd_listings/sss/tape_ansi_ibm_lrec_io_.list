	COMPILATION LISTING OF SEGMENT tape_ansi_ibm_lrec_io_
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/04/82  1707.1 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 /*                                                        */
       11 /*   *    *    *    *    *    *    *    *    *    *    *    *    *    */
       12 /*                                                                    */
       13 /*  0) Created:                                                       */
       14 /*  1) Modified: 06/29/79 by Rick Riley                               */
       15 /*               (to allow reading writing ibm tapes in binary mode   */
       16 /*  2) Modified: 4/82 by J. A. Bush for block sizes > 8192 bytes      */
       17 /* ****************************************************************** */
       18 
       19 
       20 tape_ansi_ibm_lrec_io_: procedure;
       21 	return;
       22 
       23 /* parameters */
       24 
       25 	dcl     peel		 fixed bin,
       26 	        hold		 char (4) varying;
       27 	dcl     iocbP		 ptr,		/* pointer to iocb */
       28 	        ubP		 ptr,		/* pointer to user buffer */
       29 	        buf_len		 fixed bin (21),	/* length of user buffer */
       30 	        rec_len		 fixed bin (21),	/* number of characters transmitted */
       31 	        code		 fixed bin (35);
       32 
  1     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  1     2 /* format: style2 */
  1     3 
  1     4      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  1     5 	     2 version	      character (4) aligned,
  1     6 	     2 name	      char (32),		/* I/O name of this block. */
  1     7 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  1     8 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  1     9 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  1    10 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  1    11 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  1    12 	     2 reserved	      bit (72),		/* Reserved for future use. */
  1    13 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  1    14 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  1    15 						/* open(p,mode,not_used,s) */
  1    16 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  1    17 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  1    18 						/* get_line(p,bufptr,buflen,actlen,s) */
  1    19 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  1    20 						/* get_chars(p,bufptr,buflen,actlen,s) */
  1    21 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  1    22 						/* put_chars(p,bufptr,buflen,s) */
  1    23 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  1    24 						/* modes(p,newmode,oldmode,s) */
  1    25 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  1    26 						/* position(p,u1,u2,s) */
  1    27 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  1    28 						/* control(p,order,infptr,s) */
  1    29 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  1    30 						/* read_record(p,bufptr,buflen,actlen,s) */
  1    31 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  1    32 						/* write_record(p,bufptr,buflen,s) */
  1    33 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  1    34 						/* rewrite_record(p,bufptr,buflen,s) */
  1    35 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  1    36 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  1    37 						/* seek_key(p,key,len,s) */
  1    38 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  1    39 						/* read_key(p,key,len,s) */
  1    40 	     2 read_length	      entry (ptr, fixed (21), fixed (35));
  1    41 						/* read_length(p,len,s) */
  1    42 
  1    43      declare iox_$iocb_version_sentinel
  1    44 			      character (4) aligned external static;
  1    45 
  1    46 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
       33 
       34 
  2     1 /*  BEGIN INCLUDE FILE:  tape_ansi_cseg.incl.pl1            */
  2     2 /*						*/
  2     3 /*  1) Modified: 12/01/75 by Ross E. Klinger  --  to allow  */
  2     4 /*     for allocation of the attach and open descriptions   */
  2     5 /*     within the cseg structure.			*/
  2     6 /*  2) Modified for resource management.			*/
  2     7 /*  3) Modified 9/79 by R.J.C. Kissel to handle the new tseg.	*/
  2     8 /*  4) Modified 4/82 by J.A. Bush for block sizes > 8192 bytes	*/
  2     9 
  2    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind9 */
  2    11 dcl      cP		  ptr;			/* pointer on which cseg structure is based */
  2    12 dcl      cseg_tseg_version_2	  fixed bin internal static options (constant) init (2);
  2    13 
  2    14 dcl      1 cseg		  based (cP),		/* control structure */
  2    15 	 2 file_set_lock	  bit (1) aligned,		/* "1"b if file set in use */
  2    16 	 2 invalid	  bit (1) aligned,		/* invalid cseg - delete at detach time bit */
  2    17 	 2 standard	  fixed bin,		/* label standard */
  2    18 						/* 1 - ANSI standard */
  2    19 						/* 2 - IBM/OS-VS */
  2    20 						/* 3 - IBM/DOS-VM */
  2    21 	 2 attach_description,			/* iox_ attach description */
  2    22 	   3 length	  fixed bin (17),		/* actual length of string */
  2    23 	   3 string	  char (256),		/* maximum is 256 characters */
  2    24 	 2 open_description,			/* iox_ open description */
  2    25 	   3 length	  fixed bin (17),		/* actual length of string */
  2    26 	   3 string	  char (32),		/* maximum is 32 */
  2    27 	 2 module		  char (12) varying,	/* IO module name */
  2    28 	 2 ndrives	  fixed bin,		/* maximum number of drives to be used */
  2    29 	 2 nactive	  fixed bin,		/* number of drives actually in use */
  2    30 	 2 write_ring	  bit (1) aligned,		/* volumes mounted with write rings */
  2    31 	 2 protect	  bit (1) aligned,		/* volumes have rings, but are hardware protected */
  2    32 	 2 density	  fixed bin,		/* file set recording density */
  2    33 						/* 2 - 800 bpi NRZI */
  2    34 						/* 3 - 1600 bpi PE  */
  2    35 	 2 vcN		  fixed bin,		/* number of links in volume chain */
  2    36 	 2 fcP		  ptr,			/* file chain pointer */
  2    37 	 2 flP		  ptr,			/* pointer to file link of current file */
  2    38 	 2 hdw_status,				/* hardware status structure */
  2    39 	   3 bits		  bit (72) aligned,		/* IOM status */
  2    40 	   3 no_minor	  fixed bin,		/* number of minor status codes */
  2    41 	   3 major	  fixed bin (35),		/* major status */
  2    42 	   3 minor	  (10) fixed bin (35),	/* minor status */
  2    43 	 2 lbl_buf	  char (80),		/* label I/O buffer */
  2    44 	 2 open_mode	  fixed bin,		/* opening mode */
  2    45 						/* 4 - sequential_input */
  2    46 						/* 5 - sequential_output */
  2    47 	 2 close_rewind	  bit (1) aligned,		/* rewind volume at next close */
  2    48 	 2 force		  bit (1) aligned,		/* force file overwrite switch */
  2    49 	 2 user_labels	  bit (1) aligned,		/* process user labels switch */
  2    50 	 2 no_labels	  bit (1) aligned,		/* "1"b if volume has no labels */
  2    51 	 2 output_mode	  fixed bin,		/* 0 - input */
  2    52 						/* 1 - extend */
  2    53 						/* 2 - modify */
  2    54 						/* 3 - write */
  2    55 						/* 4 - create */
  2    56 	 2 replace_id	  char (17),		/* replace file identifier */
  2    57 	 2 retain		  fixed bin,		/* 0 - default to rcp_ defaults */
  2    58 						/* 1 - unassign drives and volumes */
  2    59 						/* 2 - retain drives, unassign volumes */
  2    60 						/* 3 - unassign drives, retain volumes */
  2    61 						/* 4 - retain drives and volumes */
  2    62 	 2 lrec,					/* logical record IO control data */
  2    63 	   3 bufP		  ptr,			/* pointer to current processing buffer */
  2    64 	   3 nc_buf	  fixed bin,		/* number of characters in buffer */
  2    65 	   3 offset	  fixed bin,		/* current processing offset within buffer */
  2    66 	   3 saveP	  ptr,			/* pointer to current D/V format RCW/RDW */
  2    67 	   3 file_lock	  bit (1) aligned,		/* "1"b if file in use */
  2    68 	   3 blkcnt	  fixed bin (35),		/* physical block count */
  2    69 	   3 reccnt	  fixed bin (35),		/* logical record count (not presently used) */
  2    70 	   3 code		  fixed bin (35),		/* lrec_io_ non-restartable error code */
  2    71 	 2 read_length,				/* read_length control data */
  2    72 	   3 rlP		  ptr,			/* pointer to read_length segment */
  2    73 	   3 rlN		  fixed bin (21),		/* number of characters in segment */
  2    74 	 2 user_label_routine (6) variable entry (char (80), bit (1)),
  2    75 						/* 1 - read UHL */
  2    76 						/* 2 - write UHL */
  2    77 						/* 3 - read UTL */
  2    78 						/* 4 - write UTL */
  2    79 						/* 5 - read UVL */
  2    80 						/* 6 - write UVL */
  2    81 						/* THE FOLLOWING IS NEEDED ONLY WHILE TAPEIO_ / TDCM IS THE IO PROCEDURE */
  2    82 	 2 syncP		  ptr,			/* pointer to synchronous IO buffer */
  2    83 	 2 mode		  fixed bin,		/* 0 = binary -- 1 = 9 mode */
  2    84 	 2 soft_status,				/* software status structure */
  2    85 	   3 nbuf		  fixed bin,		/* number of suspended buffers */
  2    86 	   3 buf		  (2),
  2    87 	     4 bufP	  ptr,			/* pointer to buffer */
  2    88 	     4 count	  fixed bin,		/* buffer character count */
  2    89 	 2 (
  2    90 	 free_list,
  2    91 	 busy_list,
  2    92 	 chain		  (3),
  2    93 	 bufct		  (3)
  2    94 	 )		  fixed bin,		/* buffer management variables */
  2    95 	 2 wait_switch	  (1:63) bit (1) unaligned,	/* per-drive event wait switches */
  2    96 	 2 buf_size	  fixed bin,		/* size of each tseg buffer in chars (bytes) */
  2    97 	 2 tseg		  aligned,
  2    98 	   3 version_num	  fixed bin,
  2    99 	   3 areap	  ptr,			/* pointer to DSM area */
  2   100 	   3 ev_chan	  fixed bin (71),		/* event channel number */
  2   101 	   3 write_sw	  fixed bin (1),		/* 0 = read, 1 = write */
  2   102 	   3 sync		  fixed bin (1),		/* non-zero for synchronous i/o */
  2   103 	   3 get_size	  fixed bin (1),		/* ON for record sizes to be returned */
  2   104 	   3 ws_segno	  bit (18),		/* rcp_ kluge */
  2   105 	   3 drive_name	  char (32),
  2   106 	   3 tracks	  fixed bin,
  2   107 	   3 density	  bit (36),
  2   108 	   3 speed	  bit (36),		/* bits are 75, 125, 200 ips respectively */
  2   109 	   3 pad99 bit (36),			/* see tseg.incl.pl1 */
  2   110 	   3 buffer_offset	  fixed bin (12),		/* offset of first buffer to be processed */
  2   111 	   3 buffer_count	  fixed bin (12),		/* number of buffers to be processed */
  2   112 	   3 completion_status
  2   113 			  fixed bin (2),		/* 0 = no pending i/o or no status */
  2   114 						/* 1 = normal termination of i/o */
  2   115 						/* 2 = non-zero major status from previous i/o */
  2   116 	   3 hardware_status  bit (36) aligned,		/* major and sub-status */
  2   117 	   3 error_buffer	  fixed bin (12),		/* buffer in which i/o error occurred */
  2   118 	   3 command_count	  fixed bin (12),		/* number of non-data commands to execute */
  2   119 	   3 command_queue	  (10) fixed bin (6) aligned, /* non-data-transfer commands */
  2   120 	   3 bufferptr	  (12) fixed bin (18) aligned,/* relative ptrs to buffers */
  2   121 	   3 buffer_size	  (12) fixed bin (18) aligned,/* size of buffer */
  2   122 	   3 mode		  (12) fixed bin (2) aligned, /* 0 = bin, 1 = bcd, 2 = 9 track */
  2   123 	   3 buffer	  (4) char (cseg.buf_size) aligned,
  2   124 						/* data buffers */
  2   125 						/*  END OF TAPEIO_ / TDCM DATA */
  2   126 	 2 vl		  (63),			/* volume chain link */
  2   127 	   3 position,				/* volume position */
  2   128 	     4 fflX	  fixed bin unal,		/* index of first file link on volume */
  2   129 	     4 cflX	  fixed bin unal,		/* index of current file link */
  2   130 	     4 pos	  fixed bin unal,		/* intra-file position code */
  2   131 						/*  0 = in HDR group                          */
  2   132 						/*  1 - in data / passed HDR TM               */
  2   133 						/*  2 = in EOx group / passed data TM         */
  2   134 	     4 lflX	  fixed bin unal,		/* index of last file link on volume */
  2   135 	   3 vol_data,
  2   136 	     4 volname	  char (32),		/* volume name */
  2   137 	     4 canonical_volname
  2   138 			  char (6),		/* volume name as appears on label */
  2   139 	     4 comment	  char (64) varying,	/* mount comment */
  2   140 	     4 auth_code	  char (3) aligned,		/* authentication code for this volume */
  2   141 	     4 rcp_id	  fixed bin (6),		/* TDCM DUMMY - CHANGE TO BIT (36) ALIGNED */
  2   142 	     4 event_chan	  fixed bin (71),		/* rcp_ attach event channel */
  2   143 	     4 tape_drive	  char (32),		/* name of tape drive */
  2   144 	     4 ws_segno	  bit (18),		/* segno of IOI workspace (per drive) */
  2   145 	     4 write_VOL1	  fixed bin,		/* 0 - correct VOL1 label */
  2   146 						/* 1 - blank tape */
  2   147 						/* 2 - can't read 1st block */
  2   148 						/* 3 - 1st block not VOL1 label */
  2   149 						/* 4 - valid VOL1 label but wrong volume ID (Obsolete) */
  2   150 						/* 5 - correct VOL1 label, but wrong density */
  2   151 						/* 6 - invalid file-set format (Obsolete) */
  2   152 						/* -1 - correct VOL1 label of an earlier format */
  2   153 						/* (no authentication code) */
  2   154 	     4 ioi_index	  fixed bin,		/* ioi_ index for IO */
  2   155 	   3 reg_data,				/* registration data */
  2   156 	     4 tracks	  fixed bin unal,		/* number of tracks */
  2   157 	     4 density	  fixed bin unal,		/* density code */
  2   158 	     4 label_type	  fixed bin unal,		/* volume format */
  2   159 	     4 usage_count	  fixed bin unal,		/* number of attachment to this volume */
  2   160 	     4 read_errors	  fixed bin unal,		/* number of read errors */
  2   161 	     4 write_errors	  fixed bin unal,		/* number of write errors */
  2   162 	 2 chain_area	  area;			/* file chain allocation area */
  2   163 
  2   164 /*  END INCLUDE FILE:  tape_ansi_cseg.incl.pl1              */
       35 
       36 
  3     1 /*  BEGIN INCLUDE FILE:  tape_ansi_fd.incl.pl1              */
  3     2 
  3     3 dcl 1 fd aligned based (cseg.fcP),			/* first file chain link */
  3     4     2 backP ptr init (null),				/* no previous links (ever) */
  3     5     2 nextP ptr init (null),				/* pointer to next link; null if only */
  3     6     2 flX fixed bin init (0),				/* link index is 0 */
  3     7     2 vlX fixed bin init (0),				/* start file chain on 1st volume */
  3     8 						/* in conjunction with eov, below, which */
  3     9     2 dummy_HDR2 bit (1),				/* "1"b if file has dummy_HDR2 label */
  3    10     2 eox fixed bin init (2),				/* 2 forces volume switch on first real file link */
  3    11 
  3    12     2 hdr1,					/* HDR1 data */
  3    13       3 file_id char (17),				/* file identifier */
  3    14       3 set_id char (32),				/* reel id of 1st volume of multi-volume set */
  3    15       3 canonical_set_id char (6),			/* in canonical format */
  3    16       3 dummy_section fixed bin,
  3    17       3 sequence fixed bin,				/* file sequence number (inter-file) */
  3    18       3 dummy_generation fixed bin,
  3    19       3 dummy_version fixed bin,
  3    20       3 creation char (5),				/* holds today's date in Julian form */
  3    21       3 expiration char (5),				/* Julian expiration date */
  3    22       3 access char (1),
  3    23       3 dummy_blkcnt fixed bin (35),
  3    24       3 system char (13),				/* holds system code for labels */
  3    25 
  3    26     2 hdr2,					/* HDR2 data */
  3    27       3 format fixed bin,				/* logical record format code */
  3    28 						/* 1 - U format                               */
  3    29 						/* 2 - F format                               */
  3    30 						/* 3 - D format (ANSI) / V format (IBM)       */
  3    31 						/* 4 - S format (ANSI) / V spanned (IBM)      */
  3    32       3 blklen fixed bin,				/* actual/maximum physical block length */
  3    33       3 reclen fixed bin (21),			/* actual/maximum logical record length */
  3    34       3 dummy_next_volname char (32),
  3    35       3 canonical_dummy_next_volname char (6),
  3    36       3 blocked bit (1),				/* "0"b - unblocked / "1"b - blocked */
  3    37       3 mode fixed bin,				/* file data recording mode */
  3    38 						/* 1 - ASCII, 9 mode  */
  3    39 						/* 2 - EBCDIC, 9mode  */
  3    40 						/* 3 - binary           */
  3    41       3 bo fixed bin,				/* ANSI buffer offset: # of chars preceding each block */
  3    42       3 cc char (1);				/* IBM HDR2 control characters code */
  3    43 
  3    44 /*  END INCLUDE FILE:  tape_ansi_fd.incl.pl1                */
       37 
       38 
  4     1 /*  BEGIN INCLUDE FILE:  tape_ansi_fl.incl.pl1              */
  4     2 
  4     3 dcl 1 fl aligned based (cseg.flP),			/* file chain link */
  4     4     2 backP ptr init (null),				/* pointer to previous link in chain, or null if 1st */
  4     5     2 nextP ptr init (null),				/* pointer to next link in chain, or null if last */
  4     6     2 flX fixed bin init (0),				/* index of this link within file chain */
  4     7     2 vlX fixed bin init (0),				/* volume link index */
  4     8 
  4     9     2 HDR2 bit (1) init ("0"b),			/* "1"b if file has HDR2 label */
  4    10     2 eox fixed bin init (0),				/* 0 - trailer labels not yet processed */
  4    11 						/* 1 - trailer labels are EOF */
  4    12 						/* 2 - trailer labels are EOV */
  4    13 
  4    14     2 hdr1,					/* HDR1 data */
  4    15       3 file_id char (17),				/* file identifier */
  4    16       3 set_id char (32),				/* reel id of 1st volume of multi-volume set */
  4    17       3 canonical_set_id char (6) unaligned,		/* reel id in canonical format */
  4    18       3 section fixed bin,				/* file section number (intra-file) */
  4    19       3 sequence fixed bin,				/* file sequence number (inter-file) */
  4    20       3 generation fixed bin,				/* file generation number */
  4    21       3 version fixed bin,				/* generation version number */
  4    22       3 creation char (5),				/* Julian creation date "yyddd" */
  4    23       3 expiration char (5),				/* Julian expiration date */
  4    24       3 access char (1),				/* file accessability code */
  4    25       3 blkcnt fixed bin (35),			/* number of data blocks - in EOx1 */
  4    26       3 system char (13),				/* system/IO module code */
  4    27 
  4    28     2 hdr2,					/* HDR2 data */
  4    29       3 format fixed bin init (0),			/* logical record format code */
  4    30 						/* 1 - U format                               */
  4    31 						/* 2 - F format                               */
  4    32 						/* 3 - D format (ANSI) / V format (IBM)       */
  4    33 						/* 4 - S format (ANSI) / V spanned (IBM)      */
  4    34       3 blklen fixed bin init (0),			/* actual/maximum physical block length */
  4    35       3 reclen fixed bin (21) init (0),			/* actual/maximum logical record length */
  4    36       3 next_volname char (32) init ("") unaligned,	/* volume name of next volume */
  4    37       3 canonical_next_volname char (6) init ("") unal,	/* in canonical format */
  4    38       3 blocked bit (1) init ("0"b),			/* "0"b - unblocked / "1"b - blocked */
  4    39       3 mode fixed bin init (0),			/* file data recording mode */
  4    40 						/* 1 - ASCII, 9 mode  */
  4    41 						/* 2 - EBCDIC, 9mode  */
  4    42 						/* 3 - binary           */
  4    43       3 bo fixed bin init (0),			/* ANSI buffer offset: # of chars preceding each block */
  4    44       3 cc char (1) init (" ");			/* IBM HDR2 control characters code */
  4    45 
  4    46 /*  END INCLUDE FILE:  tape_ansi_fl.incl.pl1                */
       39 
       40 
       41 
       42 /* based storage */
       43 	dcl     1 BDW		 based (cseg.lrec.bufP), /* block descriptor word */
       44 		2 length		 fixed bin (17) unaligned, /* block length */
       45 		2 pad		 bit (18) unaligned;/* pad */
       46 	dcl     buf		 char (cseg.buf_size) aligned based (cseg.lrec.bufP), /* one physical block */
       47 	        data		 char (move) unaligned based, /* overlay for data move */
       48 	        rpad		 char (1) based (addr (erp (fd.mode))); /* ASCII , BINARY, or EBCDIC space */
       49 	dcl     1 SDW		 based (dwP),	/* segment descriptor word */
       50 		2 length		 fixed bin (17) unaligned, /* length of segment */
       51 		2 code		 fixed bin (8) unaligned, /* control code */
       52 		2 pad		 bit (9) unaligned;
       53 	dcl     1 RDW		 based (dwP),	/* V-format rdw */
       54 		2 length		 fixed bin (17) unaligned, /* record length */
       55 		2 pad		 bit (18) unaligned;/* pad */
       56 	dcl     ub		 char (buf_len) unaligned based (ubP); /* user buffer overlay */
       57 
       58 /* error codes */
       59 
       60 	dcl
       61 	        (error_table_$tape_error,
       62 	        error_table_$eof_record,
       63 	        error_table_$eov_on_write,
       64 	        error_table_$file_busy,
       65 	        error_table_$fatal_error,
       66 	        error_table_$invalid_record_desc,
       67 	        error_table_$long_record)
       68 				 fixed bin (35) external static;
       69 
       70 /* builtin functions */
       71 	dcl     (addr, copy, mod, null, substr, unspec) builtin;
       72 
       73 /* conditions */
       74 	dcl     cleanup		 condition;
       75 
       76 /* automatic storage */
       77 	dcl     i			 fixed bin,	/* temporary storage */
       78 	        csw		 bit (1) init ("0"b), /* indicates close or write_record entry */
       79 	        total		 fixed bin (21) initial (0), /* total number of characters moved in this request */
       80 	        move		 fixed bin initial (0), /* number of characters moved per segment/record */
       81 	        left		 fixed bin (21),	/* number of characters remaining to be moved */
       82 	        long_record		 bit (1) initial ("0"b), /* long record switch */
       83 	        parity_error	 bit (1) initial ("0"b), /* parity error switch */
       84 	        req_off		 fixed bin,	/* number of buffer characters processed by this request */
       85 	        remain		 fixed bin,	/* number of unprocessed characters in buffer */
       86 	        ecode		 fixed bin (35) init (0), /* temporary error code */
       87 	        data_len		 fixed bin initial (0), /* number of characters in varying length record */
       88 	        first_span		 bit (1) initial ("1"b); /* first segment of spanned request switch */
       89 
       90 /* pointers */
       91 	dcl     dwP		 ptr,		/* pointer to RDW - SDW */
       92 	        fromP		 ptr,		/* pointer to buffer for data move */
       93 	        toP		 ptr;		/* pointer to user buffer for data move */
       94 
       95 
       96 /* static storage */
       97 
       98 
       99 	dcl     1 sdw		 internal static aligned, /* SDW data */
      100 		2 complete	 fixed bin (8) initial (0), /* complete code */
      101 		2 initial		 fixed bin (8) initial (1), /* initial code */
      102 		2 medial		 fixed bin (8) initial (3), /* medial code */
      103 		2 final		 fixed bin (8) initial (2); /* final code */
      104 
      105 	dcl     erp		 (3) bit (9) internal static initial ("000100000"b, "001000000"b, "000100000"b); /* ASCII EBCDIC BINARY record pad */
      106 
      107 	dcl     ebcdic		 fixed bin internal static init (2);
      108 	dcl     binary		 fixed bin internal static init (3);
      109 
      110 	dcl     DOS		 fixed bin initial (3) internal static;
      111 
      112 /* external procedures */
      113 
      114 
      115 	dcl     ascii_to_ebcdic_	 ext entry (char (*), char (*)),
      116 	        ebcdic_to_ascii_	 ext entry (char (*), char (*)),
      117 	        tape_ansi_file_cntl_$data_eof ext entry (ptr, fixed bin (35)),
      118 	        tape_ansi_file_cntl_$data_eot ext entry (ptr, fixed bin (35)),
      119 	        tape_ansi_file_cntl_$position_for_output ext entry (ptr, fixed bin (35)),
      120 	        tape_ansi_nl_file_cntl_$data_eof ext entry (ptr, fixed bin (35)),
      121 	        tape_ansi_nl_file_cntl_$data_eot ext entry (ptr, fixed bin (35)),
      122 	        tape_ansi_tape_io_$close ext entry (ptr, fixed bin (35)),
      123 	        tape_ansi_tape_io_$get_buffer ext entry (ptr, ptr, fixed bin (35)),
      124 	        tape_ansi_tape_io_$read ext entry (ptr, ptr, fixed bin, fixed bin (35)),
      125 	        tape_ansi_tape_io_$release_buffer ext entry (ptr, ptr, fixed bin (35)),
      126 	        tape_ansi_tape_io_$write ext entry (ptr, ptr, fixed bin, fixed bin (35));
      127 
      128 read_record: entry (iocbP, ubP, buf_len, rec_len, code);	/* read_record entry point */
      129 
      130 	cP = iocbP -> iocb.actual_iocb_ptr -> iocb.attach_data_ptr; /* get pointer to cseg */
      131 
      132 	if cseg.file_lock then do;
      133 		rec_len = 0;
      134 		code = error_table_$file_busy;
      135 		return;
      136 	     end;
      137 	else do;
      138 		on cleanup begin;
      139 			cseg.file_lock = "0"b;
      140 			cseg.code = error_table_$fatal_error;
      141 		     end;
      142 		cseg.file_lock = "1"b;
      143 	     end;
      144 
      145 
      146 	if cseg.code ^= 0 then do;			/* was there a non-restartable error? */
      147 		code = cseg.code;			/* set return code */
      148 		cseg.file_lock = "0"b;
      149 		return;
      150 	     end;
      151 
      152 	if cseg.rlN ^= -1 then do;			/* data record is in read length segment */
      153 		if buf_len >= cseg.rlN then do;	/* user wants as much as (or more than) we have */
      154 			code = 0;
      155 			move = cseg.rlN;		/* give only as much as we have */
      156 		     end;
      157 		else do;				/* user wants less than we have */
      158 			code = error_table_$long_record;
      159 			move = buf_len;		/* give what s(he) wants */
      160 		     end;
      161 		ubP -> data = cseg.rlP -> data;	/* move to user */
      162 		rec_len = move;			/* indicate amount moved */
      163 		cseg.rlN = -1;			/* read length buffer is now empty */
      164 		cseg.lrec.reccnt = cseg.lrec.reccnt + 1;
      165 		cseg.file_lock = "0"b;
      166 		return;
      167 	     end;
      168 
      169 	go to r_format (fd.format);			/* transfer to begin processing */
      170 
      171 r_format (1): call get_record;			/* U format - get a logical record */
      172 	move = remain;				/* user gets all, even pad chars (if any) */
      173 	if buf_len < move then do;			/* buffer < record */
      174 		long_record = "1"b;
      175 		move = buf_len;			/* move as much as can fit */
      176 	     end;
      177 	req_off = remain;				/* this request processes the entire block */
      178 	call move_to_user;				/* move data to user's buffer */
      179 	call read_release;				/* release the record */
      180 	go to r_count;				/* return to caller */
      181 
      182 r_format (2): call get_record;			/* get 1 record */
      183 	if fd.reclen > remain then move = remain;	/* don't try to move more than we have */
      184 	else move = fd.reclen;			/* move only up to 1 record's worth */
      185 	if buf_len < move then do;			/* buffer < record */
      186 		long_record = "1"b;
      187 		move = buf_len;			/* move only what can fit */
      188 	     end;
      189 	req_off = fd.reclen;			/* process one record */
      190 	call move_to_user;				/* move data to user's buffer */
      191 	call read_release;				/* release the record */
      192 	go to r_count;				/* return to caller */
      193 
      194 r_format (3): call get_record;			/* V format - get a logical record */
      195 	dwP = addr (substr (buf, cseg.offset + 1));	/* get pointer to rdw */
      196 	if fd.mode ^= binary then /* if not already binary then make it  */
      197 	     substr (unspec (RDW.length), 1, 10) = "00"b || substr (unspec (RDW.length), 2, 8);
      198 						/* shift byte right to form valid binary value reading 9 mode */
      199 	data_len = RDW.length - 4;			/* subtract rdw length to get data length */
      200 	if data_len > remain - 4 then go to inv_desc;	/* block bigger than block size? */
      201 	move = data_len;				/* move up to 1 record */
      202 	if buf_len < move then do;			/* buffer < record */
      203 		long_record = "1"b;
      204 		move = buf_len;			/* move only what can fit */
      205 	     end;
      206 	cseg.offset = cseg.offset + 4;		/* the rdw has been processed */
      207 	req_off = data_len;				/* process one logical record */
      208 	call move_to_user;				/* move data to user's buffer */
      209 	call read_release;				/* release the record */
      210 	go to r_count;				/* return to caller */
      211 
      212 r_format (4): call get_record;			/* VBS format - get a logical record */
      213 	left = buf_len;				/* save request for decrementing */
      214 r_sw_check: call process_sw;				/* process the SDW - get type and data length */
      215 	if left >= data_len then move = data_len;	/* give user the entire segment..... */
      216 	else do;					/* user doesn't want all the data */
      217 		long_record = "1"b;			/* buffer < record */
      218 		move = left;			/* move only as much as can fit */
      219 	     end;
      220 	call move_to_user;				/* move the data to the user's buffer */
      221 	left = left - move;				/* keep track of remainder of request */
      222 	if SDW.code = sdw.complete | SDW.code = sdw.final then do; /* segment is last (or only) of record */
      223 		call read_release;			/* release it */
      224 		go to r_count;			/* and we're done */
      225 	     end;
      226 	else call read_release;			/* release the record and continue */
      227 	if left ^= 0 then do;			/* user wants more, and more segments are available */
      228 		call get_record;			/* get the next segment */
      229 		go to r_sw_check;			/* transfer to process the SDW/SDW, etc. ..... */
      230 	     end;
      231 	call skip_segments;				/* request satisfied, but more segments remain - skip them */
      232 	long_record = "1"b;				/* buffer < record */
      233 	go to r_count;				/* return to caller */
      234 
      235 inv_desc: ecode = error_table_$invalid_record_desc;	/* set error code */
      236 	go to r_exit;
      237 
      238 r_count:	cseg.lrec.reccnt = cseg.lrec.reccnt + 1;
      239 
      240 r_exit:	if parity_error then code = error_table_$tape_error;
      241 	else code = ecode;
      242 	cseg.code = code;
      243 	if code = 0 then if long_record then code = error_table_$long_record;
      244 	rec_len = total;				/* return total number of characters moved */
      245 	cseg.file_lock = "0"b;
      246 	return;					/* and return to the caller */
      247 
      248 get_record: procedure;				/* internal procedure to get 1 logical record */
      249 	if cseg.lrec.bufP = null then do;		/* get a block if inactive buffer */
      250 restart:		call tape_ansi_tape_io_$read (cP, cseg.lrec.bufP, cseg.nc_buf, ecode); /* get 1 physical block */
      251 		if ecode ^= 0 then do;		/* was there an error or EOF? */
      252 			if ecode = error_table_$eof_record then do; /* EOF detected */
      253 				if cseg.no_labels then call tape_ansi_nl_file_cntl_$data_eof (iocbP, ecode);
      254 				else call tape_ansi_file_cntl_$data_eof (iocbP, ecode);
      255 				if ecode = 0 then go to restart; /* switched to new file section */
      256 				else go to r_exit;	/* no next volume or error */
      257 			     end;
      258 			else do;			/* parity or fatal error */
      259 				if ecode = error_table_$tape_error then parity_error = "1"b; /* process the block */
      260 				else go to r_exit;	/* fatal error - terminate processing */
      261 			     end;
      262 		     end;
      263 		cseg.blkcnt = cseg.blkcnt + 1;	/* keep track of physical blocks read */
      264 		if cseg.nc_buf > fd.blklen then cseg.nc_buf = fd.blklen; /* use only as much as wanted */
      265 		if fd.format > 2 then do;		/* check BDW against block size if V,VB,VS,VBS format */
      266 			if fd.mode ^= binary then
      267 			     substr (unspec (BDW.length), 1, 10) = "00"b || substr (unspec (BDW.length), 2, 8);
      268 						/* shift to get valid binary value when reading in 9 mode */
      269 			if BDW.length > cseg.nc_buf then go to inv_desc; /* block is too short */
      270 			cseg.nc_buf = BDW.length;	/* use all in block */
      271 			cseg.offset = 4;		/* BDW has been processed */
      272 		     end;
      273 		else cseg.offset = 0;		/* U, F, or FB format */
      274 	     end;
      275 	remain = cseg.nc_buf - cseg.offset;		/* get number of characters to be processed */
      276 	return;					/* exit */
      277      end get_record;
      278 
      279 process_sw: procedure;				/* internal procedure to process SDW's */
      280 	dwP = addr (substr (buf, cseg.offset + 1));	/* get pointer to SDW */
      281 	if fd.mode ^= binary then /* if not already binary then  */
      282 	     substr (unspec (SDW.length), 1, 10) = "00"b || substr (unspec (SDW.length), 2, 8);
      283 						/* shift byte right valid binary reading 9 mode */
      284 	if cseg.standard = DOS then substr (unspec (SDW.length), 3, 1) = "0"b; /* zero the bit if DOS */
      285 	data_len = SDW.length - 4;			/* get length of data */
      286 	if data_len > remain - 4 then go to inv_desc;
      287 	if SDW.code < 0 then go to inv_desc;		/* error if type < 0 */
      288 	if SDW.code > 3 then go to inv_desc;		/* error if type > 3 */
      289 	cseg.offset = cseg.offset + 4;		/* SDW has been processed */
      290 	req_off = data_len;				/* the entire segment will be processed */
      291 	return;					/* exit */
      292      end process_sw;
      293 
      294 skip_segments: procedure;				/* internal procedure to skip to beginning of spanned record */
      295 s_get:	call get_record;				/* get a segment */
      296 	call process_sw;				/* process its SDW */
      297 	if SDW.code = sdw.final then do;		/* is this the final segment? */
      298 		call read_release;			/* release it */
      299 		return;				/* and exit */
      300 	     end;
      301 	call read_release;				/* release the segment */
      302 	go to s_get;				/* get the next segment */
      303      end skip_segments;
      304 
      305 move_to_user: procedure;				/* internal procedure to move data to user's buffer */
      306 	if move = 0 then return;
      307 	fromP = addr (substr (buf, cseg.offset + 1));	/* set pointer to data to be moved */
      308 	toP = addr (substr (ub, total + 1));		/* set pointer to user buffer */
      309 	if fd.mode = ebcdic then call ebcdic_to_ascii_ (fromP -> data, toP -> data);
      310 	else toP -> data = fromP -> data;
      311 	total = total + move;			/* sum each move */
      312 	return;					/* exit */
      313      end move_to_user;
      314 
      315 read_release: procedure;				/* internal procedure to release a record and/or block */
      316 	cseg.offset = cseg.offset + req_off;		/* the request has been processed */
      317 	remain = cseg.nc_buf - cseg.offset;		/* get number of characters not yet processed */
      318 	if remain < 4 then do;			/* if so, the block may have been exhausted */
      319 		if fd.format = 2 then if fd.reclen <= remain then return; /* another record? */
      320 		call tape_ansi_tape_io_$release_buffer (cP, cseg.lrec.bufP, 0); /* block exhausted  */
      321 	     end;
      322 	return;					/* exit */
      323      end read_release;
      324 
      325 write_record: entry (iocbP, ubP, buf_len, code);		/* write_record entry point */
      326 
      327 	cP = iocbP -> iocb.actual_iocb_ptr -> iocb.attach_data_ptr; /* get pointer to cseg */
      328 
      329 	if cseg.file_lock then do;
      330 		code = error_table_$file_busy;
      331 		return;
      332 	     end;
      333 	else do;
      334 		on cleanup begin;
      335 			cseg.file_lock = "0"b;
      336 			cseg.code = error_table_$fatal_error;
      337 		     end;
      338 		cseg.file_lock = "1"b;
      339 	     end;
      340 
      341 	if cseg.code ^= 0 then do;			/* was there a non-restartable error? */
      342 		code = cseg.code;			/* set return code */
      343 		cseg.file_lock = "0"b;
      344 		return;
      345 	     end;
      346 
      347 	if ^cseg.no_labels then do;			/* only for labeled volumes */
      348 		if vl (fl.vlX).pos ^= 1 then do;	/* not positioned for output */
      349 			call tape_ansi_file_cntl_$position_for_output (iocbP, ecode);
      350 			if ecode ^= 0 then go to w_exit; /* error */
      351 		     end;
      352 	     end;
      353 
      354 	go to w_format (fd.format);			/* transfer to begin processing */
      355 
      356 
      357 
      358 w_format (1): if buf_len > fd.blklen then go to w_long;	/* U format - check buf_len */
      359 	call get_buf;				/* get a buffer */
      360 	move = buf_len;				/* move the requested amount of data */
      361 	req_off = buf_len;				/* number of characters to be processed */
      362 	call move_to_buf;				/* move the data to the write buffer */
      363 	call write_buf;				/* write one block */
      364 	go to w_count;				/* return to caller */
      365 
      366 w_format (2): if buf_len > fd.reclen then go to w_long;	/* F format - check buf_len validity */
      367 	call get_buf;				/* get a buffer */
      368 	move = buf_len;				/* transfer the request as stated */
      369 	remain = fd.reclen - buf_len;			/* get difference between buf_len and reclen for padding */
      370 	if remain ^= 0 then substr (buf, cseg.offset + buf_len + 1, remain) = copy (rpad, remain); /* pad the record */
      371 	req_off = fd.reclen;			/* process one logical record */
      372 	call move_to_buf;				/* move the data to the write buffer */
      373 	if ^fd.blocked then call write_buf;		/* unblocked: write 1 record per block */
      374 	else if cseg.offset = fd.blklen then call write_buf; /* blocked: write if block full */
      375 	go to w_count;				/* return to caller */
      376 
      377 w_format (3): data_len = buf_len + 4;			/* V format - data length = buf_len + RDW length */
      378 	if data_len > fd.reclen then go to w_long;	/* check data_len validity */
      379 	call get_buf;				/* get a buffer */
      380 	if fd.blocked then if data_len > fd.blklen - cseg.offset then do; /* record won't fit in this block */
      381 		     call write_buf;		/* write the current buffer contents */
      382 		     call get_buf;			/* get another write buffer */
      383 		end;				/* request validity has been verified, so just continue */
      384 	dwP = addr (substr (buf, cseg.offset + 1));	/* locate rdw position */
      385 	cseg.saveP = dwP;				/* save the RDW location for pad incrementing */
      386 	RDW.length = data_len;			/* store the record length */
      387 	if fd.mode ^= binary then /* if not already binary */
      388 	     substr (unspec (RDW.length), 2, 9) = substr (unspec (RDW.length), 3, 8) || "0"b;
      389 						/* shift high order byte to allow writing in 9 mode */
      390 	RDW.pad = "0"b;				/* zero the pad field */
      391 	cseg.offset = cseg.offset + 4;		/* the rdw has been processed */
      392 	req_off = buf_len;				/* process buf_len characters */
      393 	move = buf_len;				/* move buf_len characters */
      394 	call move_to_buf;				/* move the data to the write buffer */
      395 	if ^fd.blocked then call write_buf;		/* unblocked: write 1 record per block */
      396 	else if fd.blklen - cseg.offset < 4 then call write_buf; /* write block if even null record can't fit */
      397 	go to w_count;				/* return to caller */
      398 
      399 w_format (4): if buf_len > fd.reclen then go to w_long;	/* VBS format - check buf_len validity */
      400 	call get_buf;				/* get a buffer */
      401 	peel = 0;					/* initialize character count */
      402 	left = buf_len;				/* save request for decrementing */
      403 	remain = fd.blklen - cseg.offset;		/* get number of characters left in block */
      404 	dwP = addr (substr (buf, cseg.offset + 1));
      405 w_fit_check:
      406 	cseg.saveP = dwP;				/* save SDW location for pad incrementing */
      407 	if left + 4 <= remain then do;		/* will entire request fit in remainder of block? */
      408 		if left + 4 > remain - 5 then do;	/* Will request be last segment of block? */
      409 			i = 4 - (remain - (left + 4));/* get nbr of chars in last word of block */
      410 			if i = 0 then move = left;	/*  0 in last work: write all this segment */
      411 			else if i = 4 then move = left; /* last word full: write all this segment */
      412 
      413 /* this segment wont be word aligned; have to back track to previous segment
      414*   and see how many characters have to be peeled off to make last segment of block word aligned */
      415 
      416 			else do;
      417 				peel = mod (cseg.offset, 4);
      418 				if peel ^= 0 then do;
      419 					hold = substr (buf, cseg.offset - peel + 1, peel); /* save the unaligned characters */
      420 					if SDW.code = sdw.initial then ;
      421 					else SDW.code = sdw.medial;
      422 					SDW.length = SDW.length - peel; /* rewrite length - peeled chars in descriptor word */
      423 					SDW.code = sdw.medial;
      424 					substr (unspec (SDW.length), 2, 9) = substr (unspec (SDW.length), 3, 8) || "0"b;
      425 					cseg.offset = cseg.offset - peel; /* update count to reflect peeled characters */
      426 					total = total - peel; /* adjust for characters peeled also */
      427 				     end;
      428 				go to w_now;	/* segment is word aligned; write out buffer */
      429 			     end;
      430 		     end;
      431 		else move = left;			/* not last segment of block - move all */
      432 	     end;
      433 	else move = remain - 4;			/* entire request won't fit - move what will */
      434 	left = left - move;				/* decrement data to be moved count */
      435 	if first_span then do;			/* first segment of the record */
      436 		first_span = "0"b;			/* one time only */
      437 		if left = 0 then SDW.code = sdw.complete; /* whole record in one segment */
      438 		else SDW.code = sdw.initial;		/* only part of record fits */
      439 	     end;
      440 	else do;					/* not first segment of record */
      441 		if left = 0 then SDW.code = sdw.final;	/* last segment of record */
      442 		else SDW.code = sdw.medial;		/* still more to come */
      443 	     end;
      444 	data_len = move + peel + 4;			/* compute segment length */
      445 	if peel > 0 then peel = 0;
      446 	SDW.length = data_len;			/* store segment length */
      447 	if fd.mode ^= binary then /* if not binary move right to binary from 9 mode */
      448 	     substr (unspec (SDW.length), 2, 9) = substr (unspec (SDW.length), 3, 8) || "0"b;
      449 	if cseg.standard = DOS then if data_len = 4 then substr (unspec (SDW.length), 2, 1) = "1"b;
      450 	SDW.pad = "0"b;				/* zero pad field */
      451 	cseg.offset = cseg.offset + 4;		/* SDW has been processed */
      452 	req_off = move;				/* process the data move */
      453 	call move_to_buf;				/* move data to write buffer */
      454 	remain = remain - data_len;			/* get number of characters left after request */
      455 	if ^fd.blocked then go to w_now;		/* ^blocked: write each segment */
      456 	if remain < 5 then do;			/*  another segment can't fit in the block? */
      457 w_now:		call write_buf;			/* write the block */
      458 		call get_buf;			/* get another buffer */
      459 		remain = fd.blklen - cseg.offset;	/* initialize number of remaining characters */
      460 	     end;
      461 	dwP = addr (substr (buf, cseg.offset + 1));	/* locate current SDW position */
      462 	if peel ^= 0 then do;			/* pick up chars had to peel off */
      463 		substr (buf, cseg.offset + 5, peel) = substr (hold, 1, peel); /* move chars into buffer */
      464 		cseg.offset = cseg.offset + peel;
      465 		total = total + peel;
      466 		remain = fd.blklen - cseg.offset;
      467 	     end;
      468 	if left ^= 0 then go to w_fit_check;		/* if more segments need be written, continue processing */
      469 	go to w_exit;				/* .... or return to caller */
      470 
      471 
      472 w_long:	code = error_table_$long_record;		/* set return code */
      473 	go to w_exit1;				/* csw can't be "1"b, shouldn't lock logical I/O */
      474 
      475 w_count:	cseg.lrec.reccnt = cseg.lrec.reccnt + 1;
      476 
      477 w_exit:	code = ecode;				/* set return code */
      478 	cseg.code = code;
      479 	if csw then go to c_exit;			/* if close entry, go to close exit */
      480 w_exit1:	cseg.file_lock = "0"b;			/* unlock the file */
      481 	return;					/* return to caller */
      482 
      483 get_buf: procedure;					/* internal procedure to get a write buffer for data transfer */
      484 	if cseg.lrec.bufP = null then do;		/* get a buffer if necessary */
      485 		call tape_ansi_tape_io_$get_buffer (cP, cseg.lrec.bufP, 0); /* get the buffer */
      486 		if fd.format > 2 then cseg.offset = 4;	/* set offset for BDW */
      487 		else cseg.offset = 0;		/* initialize buffer offset */
      488 	     end;
      489 	return;					/* exit */
      490      end get_buf;
      491 
      492 
      493 move_to_buf: procedure;				/* internal procedure to move data from user's buffer */
      494 	if move = 0 then go to move_nothing;		/* return if no data to be moved */
      495 	fromP = addr (substr (ub, total + 1));		/* set pointer to data to be moved */
      496 	toP = addr (substr (buf, cseg.offset + 1));	/* set pointer to buffer */
      497 	if fd.mode = ebcdic then call ascii_to_ebcdic_ (fromP -> data, toP -> data);
      498 	else toP -> data = fromP -> data;		/* move as is */
      499 	total = total + move;			/* sum each move */
      500 move_nothing: cseg.offset = cseg.offset + req_off;	/* the request has been processed (char offset) */
      501 	return;					/* return to caller */
      502      end move_to_buf;
      503 
      504 write_buf: procedure;				/* internal procedure to write one physical block */
      505 	if cseg.offset < 20 then if fd.format ^= 2 then do; /* pad to 20 bytes if not F format */
      506 		     remain = 20 - cseg.offset;	/* get pad requirement */
      507 		     go to w_pad;			/* pad the block */
      508 		end;
      509 	remain = 4 - mod (cseg.offset, 4);		/* block length must be integral multiple of 4 */
      510 	if remain ^= 4 then do;			/* not multiple - pad to word boundry */
      511 w_pad:		substr (buf, cseg.offset + 1, remain) = copy (rpad, remain); /* pad with blanks */
      512 		cseg.offset = cseg.offset + remain;	/* increment to reflect padding */
      513 	     end;
      514 	else remain = 0;				/* multiple - indicate no padding performed */
      515 	if fd.format > 2 then do;			/* should a BDW be included? */
      516 		BDW.length = cseg.offset;		/* store the block length */
      517 		if fd.mode ^= binary then
      518 		     substr (unspec (BDW.length), 2, 9) = substr (unspec (BDW.length), 3, 8) || "0"b;
      519 						/* shift high order byte to allow writing in 9 mode */
      520 		BDW.pad = "0"b;			/* zero the pad field */
      521 		if remain ^= 0 then do;		/* the block was padded: the last rdw must be incremented */
      522 			dwP = cseg.saveP;		/* get the pointer to the last RDW used */
      523 			if fd.mode ^= binary then
      524 			     substr (unspec (RDW.length), 1, 10) = "00"b || substr (unspec (RDW.length), 2, 8); /* pack */
      525 			if cseg.standard = DOS then substr (unspec (RDW.length), 3, 1) = "0"b; /* DOS 0 length seg bit */
      526 			RDW.length = RDW.length + remain; /* increment to reflect added pad characters */
      527 			if fd.mode ^= binary then
      528 			     substr (unspec (RDW.length), 2, 9) = substr (unspec (RDW.length), 3, 8) || "0"b; /* unpack */
      529 		     end;
      530 	     end;
      531 	call tape_ansi_tape_io_$write (cP, cseg.lrec.bufP, cseg.offset, ecode); /* write the block */
      532 	if ecode = 0 then cseg.blkcnt = cseg.blkcnt + 1;	/* OK: up block count */
      533 	else if ecode = error_table_$eov_on_write then do;/* EOT detected */
      534 		cseg.blkcnt = cseg.blkcnt + 1;	/* block was written */
      535 		if csw then return;			/* ignore EOT if closing */
      536 		else do;
      537 			if cseg.no_labels then call tape_ansi_nl_file_cntl_$data_eot (iocbP, ecode);
      538 			else call tape_ansi_file_cntl_$data_eot (iocbP, ecode); /* switch to next volume */
      539 			if ecode ^= 0 then do;	/* terminate if switching failed */
      540 				if fd.format = 4 & left ^= 0 then go to w_exit; /* VS/VBS record only partially written */
      541 				else do;		/* not VS/VBS format, or VS/VBS record completely written */
      542 					cseg.code = ecode; /* inhibit further iox_$write_record calls */
      543 					code = 0; /* but this call is ok */
      544 					cseg.lrec.reccnt = cseg.lrec.reccnt + 1; /* so increment record count */
      545 					go to w_exit1; /* and return to caller */
      546 				     end;
      547 			     end;
      548 		     end;
      549 	     end;
      550 	else do;					/* IO error (occurred on previous block) */
      551 		cseg.blkcnt = cseg.blkcnt - cseg.soft_status.nbuf + 1; /* decrement block count */
      552 		cseg.lrec.reccnt = -cseg.lrec.reccnt;	/* make record count unreliable */
      553 		go to w_exit;			/* terminate processing */
      554 	     end;
      555 	return;					/* return to caller */
      556      end write_buf;
      557 
      558 close: entry (acP, code);				/* close entry to synchronize and terminate io */
      559 	dcl     acP		 ptr;		/* pointer to control segment */
      560 
      561 	cP = acP;					/* set pointer to control segment */
      562 	csw = "1"b;				/* indicate close entry in case write error */
      563 	if cseg.open_mode = 4 then do;		/* opened for input */
      564 		if cseg.lrec.bufP ^= null then go to close2; /* release an active buffer */
      565 		go to c_exit;			/* synchronize and finish up io */
      566 	     end;
      567 	else do;					/* file was opened for output */
      568 		if cseg.lrec.bufP = null then go to c_exit; /* no active buffer - synchronize and close */
      569 		if cseg.offset = 0 then go to close2;	/* active empty buffer - release, synch., and close */
      570 		if fd.format > 2 then if cseg.offset = 4 then go to close2; /* active buffer has only a BDW */
      571 		call write_buf;			/* active buffer with data - write the buffer */
      572 		go to c_exit;			/* synchronize and close io */
      573 	     end;
      574 close2:	call tape_ansi_tape_io_$release_buffer (cP, cseg.lrec.bufP, 0); /* release the buffer */
      575 c_exit:	call tape_ansi_tape_io_$close (cP, code);	/* terminate the tape_ansi_tape_io_ set up */
      576 	return;					/* exit */
      577 
      578 
      579      end tape_ansi_ibm_lrec_io_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/04/82  1606.0  tape_ansi_ibm_lrec_io_.pl1        >dumps>old>recomp>tape_ansi_ibm_lrec_io_.pl1
33           1    07/28/81  1333.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
35           2    06/10/82  1045.3  tape_ansi_cseg.incl.pl1           >ldd>include>tape_ansi_cseg.incl.pl1
37           3    11/20/79  2015.6  tape_ansi_fd.incl.pl1             >ldd>include>tape_ansi_fd.incl.pl1
39           4    11/20/79  2015.6  tape_ansi_fl.incl.pl1             >ldd>include>tape_ansi_fl.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BDW                                    based           structure                level 1 packed unaligned dcl 43
DOS                                    constant        fixed bin(17,0)          initial dcl 110 ref 284 449 525
RDW                                    based           structure                level 1 packed unaligned dcl 53
SDW                                    based           structure                level 1 packed unaligned dcl 49
acP                                    parameter       pointer                  dcl 559 ref 558 561
actual_iocb_ptr          12            based           pointer                  level 2 dcl 1-4 ref 130 327
addr                                                   builtin function         dcl 71 ref 195 280 307 308 370 384 404 461 495 496
                                                                                  511
ascii_to_ebcdic_                000030 constant        entry                    external dcl 115 ref 497
attach_data_ptr          16            based           pointer                  level 2 dcl 1-4 ref 130 327
binary                                 constant        fixed bin(17,0)          initial dcl 108 ref 196 266 281 387 447 517 523 527
blkcnt                  221            based           fixed bin(35,0)          level 3 dcl 2-14 set ref 263* 263 532* 532 534* 534
                                                                                  551* 551
blklen                   46            based           fixed bin(17,0)          level 3 dcl 3-3 ref 264 264 358 374 380 396 403 459
                                                                                  466
blocked                  62            based           bit(1)                   level 3 dcl 3-3 ref 373 380 395 455
buf                                    based           char                     dcl 46 set ref 195 280 307 370* 384 404 419 461 463*
                                                                                  496 511*
bufP                    212            based           pointer                  level 3 dcl 2-14 set ref 195 249 250* 266 266 269
                                                                                  270 280 307 320* 370 384 404 419 461 463 484 485*
                                                                                  496 511 516 517 517 520 531* 564 568 574*
buf_len                                parameter       fixed bin(21,0)          dcl 27 ref 128 153 159 173 175 185 187 202 204 213
                                                                                  308 325 358 360 361 366 368 369 370 377 392 393
                                                                                  399 402 495
buf_size                310            based           fixed bin(17,0)          level 2 dcl 2-14 ref 195 280 307 348 370 384 404 419
                                                                                  461 463 496 511
cP                              000104 automatic       pointer                  dcl 2-11 set ref 130* 132 139 140 142 146 147 148
                                                                                  152 153 155 161 163 164 164 165 169 183 184 189
                                                                                  195 195 195 196 206 206 238 238 242 245 249 250*
                                                                                  250 250 253 263 263 264 264 264 264 265 266 266
                                                                                  266 269 269 270 270 271 273 275 275 280 280 280
                                                                                  281 284 289 289 307 307 307 309 316 316 317 317
                                                                                  319 319 320* 320 327* 329 335 336 338 341 342 343
                                                                                  347 348 348 348 354 358 366 369 370 370 370 370
                                                                                  371 373 374 374 378 380 380 380 384 384 384 385
                                                                                  387 391 391 395 396 396 399 403 403 404 404 404
                                                                                  405 417 419 419 419 425 425 447 449 451 451 455
                                                                                  459 459 461 461 461 463 463 463 464 464 466 466
                                                                                  475 475 478 480 484 485* 485 486 486 487 496 496
                                                                                  496 497 500 500 505 505 506 509 511 511 511 511
                                                                                  512 512 515 516 516 517 517 517 520 522 523 525
                                                                                  527 531* 531 531 532 532 534 534 537 540 542 544
                                                                                  544 551 551 551 552 552 561* 563 564 568 569 570
                                                                                  570 574* 574 575*
cleanup                         000106 stack reference condition                dcl 74 ref 138 334
code                                   parameter       fixed bin(35,0)          dcl 27 in procedure "tape_ansi_ibm_lrec_io_" set ref
                                                                                  128 134* 147* 154* 158* 240* 241* 242 243 243* 325
                                                                                  330* 342* 472* 477* 478 543* 558 575*
code                    223            based           fixed bin(35,0)          level 3 in structure "cseg" dcl 2-14 in procedure
                                                                                  "tape_ansi_ibm_lrec_io_" set ref 140* 146 147 242*
                                                                                  336* 341 342 478* 542*
code                      0(18)        based           fixed bin(8,0)           level 2 in structure "SDW" packed unaligned dcl 49
                                                                                  in procedure "tape_ansi_ibm_lrec_io_" set ref 222
                                                                                  222 287 288 297 420 421* 423* 437* 438* 441* 442*
complete                        000000 constant        fixed bin(8,0)           initial level 2 dcl 99 ref 222 437
copy                                                   builtin function         dcl 71 ref 370 511
cseg                                   based           structure                level 1 unaligned dcl 2-14
csw                             000115 automatic       bit(1)                   initial unaligned dcl 77 set ref 77* 479 535 562*
data                                   based           char                     unaligned dcl 46 set ref 161* 161 309* 309* 310* 310
                                                                                  497* 497* 498* 498
data_len                        000126 automatic       fixed bin(17,0)          initial dcl 77 set ref 77* 199* 200 201 207 215 215
                                                                                  285* 286 290 377* 378 380 386 444* 446 449 454
dwP                             000130 automatic       pointer                  dcl 91 set ref 195* 196 196 199 222 222 280* 281 281
                                                                                  284 285 287 288 297 384* 385 386 387 387 390 404*
                                                                                  405 420 421 422 422 423 424 424 437 438 441 442
                                                                                  446 447 447 449 450 461* 522* 523 523 525 526 526
                                                                                  527 527
ebcdic                                 constant        fixed bin(17,0)          initial dcl 107 ref 309 497
ebcdic_to_ascii_                000032 constant        entry                    external dcl 115 ref 309
ecode                           000125 automatic       fixed bin(35,0)          initial dcl 77 set ref 77* 235* 241 250* 251 252
                                                                                  253* 254* 255 259 349* 350 477 531* 532 533 537*
                                                                                  538* 539 542
erp                             000010 internal static bit(9)                   initial array unaligned dcl 105 set ref 370 511
error_table_$eof_record         000014 external static fixed bin(35,0)          dcl 60 ref 252
error_table_$eov_on_write       000016 external static fixed bin(35,0)          dcl 60 ref 533
error_table_$fatal_error        000022 external static fixed bin(35,0)          dcl 60 ref 140 336
error_table_$file_busy          000020 external static fixed bin(35,0)          dcl 60 ref 134 330
error_table_$invalid_record_desc
                                000024 external static fixed bin(35,0)          dcl 60 ref 235
error_table_$long_record        000026 external static fixed bin(35,0)          dcl 60 ref 158 243 472
error_table_$tape_error         000012 external static fixed bin(35,0)          dcl 60 ref 240 259
fcP                     130            based           pointer                  level 2 dcl 2-14 ref 169 183 184 189 196 264 264 265
                                                                                  266 281 309 319 319 354 358 366 369 370 371 373
                                                                                  374 378 380 380 387 395 396 399 403 447 455 459
                                                                                  466 486 497 505 511 515 517 523 527 540 570
fd                                     based           structure                level 1 dcl 3-3
file_lock               220            based           bit(1)                   level 3 dcl 2-14 set ref 132 139* 142* 148* 165*
                                                                                  245* 329 335* 338* 343* 480*
final                     3     000000 constant        fixed bin(8,0)           initial level 2 dcl 99 ref 222 297 441
first_span                      000127 automatic       bit(1)                   initial unaligned dcl 77 set ref 77* 435 436*
fl                                     based           structure                level 1 dcl 4-3
flP                     132            based           pointer                  level 2 dcl 2-14 ref 348
format                   45            based           fixed bin(17,0)          level 3 dcl 3-3 ref 169 265 319 354 486 505 515 540
                                                                                  570
fromP                           000132 automatic       pointer                  dcl 91 set ref 307* 309 310 495* 497 498
hdr2                     45            based           structure                level 2 dcl 3-3
hold                            000102 automatic       varying char(4)          dcl 25 set ref 419* 463
i                               000114 automatic       fixed bin(17,0)          dcl 77 set ref 409* 410 411
initial                   1     000000 constant        fixed bin(8,0)           initial level 2 dcl 99 ref 420 438
iocb                                   based           structure                level 1 dcl 1-4
iocbP                                  parameter       pointer                  dcl 27 set ref 128 130 253* 254* 325 327 349* 537*
                                                                                  538*
left                            000120 automatic       fixed bin(21,0)          dcl 77 set ref 213* 215 218 221* 221 227 402* 407
                                                                                  408 409 410 411 431 434* 434 437 441 468 540
length                                 based           fixed bin(17,0)          level 2 in structure "RDW" packed unaligned dcl 53
                                                                                  in procedure "tape_ansi_ibm_lrec_io_" set ref 196
                                                                                  196 199 386* 387 387 523 523 525 526* 526 527 527
length                                 based           fixed bin(17,0)          level 2 in structure "SDW" packed unaligned dcl 49
                                                                                  in procedure "tape_ansi_ibm_lrec_io_" set ref 281
                                                                                  281 284 285 422* 422 424 424 446* 447 447 449
length                                 based           fixed bin(17,0)          level 2 in structure "BDW" packed unaligned dcl 43
                                                                                  in procedure "tape_ansi_ibm_lrec_io_" set ref 266
                                                                                  266 269 270 516* 517 517
long_record                     000121 automatic       bit(1)                   initial unaligned dcl 77 set ref 77* 174* 186* 203*
                                                                                  217* 232* 243
lrec                    212            based           structure                level 2 unaligned dcl 2-14
medial                    2     000000 constant        fixed bin(8,0)           initial level 2 dcl 99 ref 421 423 442
mod                                                    builtin function         dcl 71 ref 417 509
mode                     63            based           fixed bin(17,0)          level 3 dcl 3-3 ref 196 266 281 309 370 387 447 497
                                                                                  511 517 523 527
move                            000117 automatic       fixed bin(17,0)          initial dcl 77 set ref 77* 155* 159* 161 161 162
                                                                                  172* 173 175* 183* 184* 185 187* 201* 202 204*
                                                                                  215* 218* 221 306 309 309 309 309 310 310 311 360*
                                                                                  368* 393* 410* 411* 431* 433* 434 444 452 494 497
                                                                                  497 497 497 498 498 499
nbuf                    264            based           fixed bin(17,0)          level 3 dcl 2-14 ref 551
nc_buf                  214            based           fixed bin(17,0)          level 3 dcl 2-14 set ref 250* 264 264* 269 270* 275
                                                                                  317
no_labels               202            based           bit(1)                   level 2 dcl 2-14 ref 253 347 537
null                                                   builtin function         dcl 71 ref 249 484 564 568
offset                  215            based           fixed bin(17,0)          level 3 dcl 2-14 set ref 195 206* 206 271* 273* 275
                                                                                  280 289* 289 307 316* 316 317 370 374 380 384 391*
                                                                                  391 396 403 404 417 419 425* 425 451* 451 459 461
                                                                                  463 464* 464 466 486* 487* 496 500* 500 505 506
                                                                                  509 511 512* 512 516 531* 569 570
open_mode               176            based           fixed bin(17,0)          level 2 dcl 2-14 ref 563
pad                       0(27)        based           bit(9)                   level 2 in structure "SDW" packed unaligned dcl 49
                                                                                  in procedure "tape_ansi_ibm_lrec_io_" set ref 450*
pad                       0(18)        based           bit(18)                  level 2 in structure "BDW" packed unaligned dcl 43
                                                                                  in procedure "tape_ansi_ibm_lrec_io_" set ref 520*
pad                       0(18)        based           bit(18)                  level 2 in structure "RDW" packed unaligned dcl 53
                                                                                  in procedure "tape_ansi_ibm_lrec_io_" set ref 390*
parity_error                    000122 automatic       bit(1)                   initial unaligned dcl 77 set ref 77* 240 259*
peel                            000100 automatic       fixed bin(17,0)          dcl 25 set ref 401* 417* 418 419 419 422 425 426 444
                                                                                  445 445* 462 463 463 464 465
pos                                    based           fixed bin(17,0)          array level 4 packed unaligned dcl 2-14 ref 348
position                               based           structure                array level 3 packed unaligned dcl 2-14
read_length             224            based           structure                level 2 unaligned dcl 2-14
rec_len                                parameter       fixed bin(21,0)          dcl 27 set ref 128 133* 162* 244*
reccnt                  222            based           fixed bin(35,0)          level 3 dcl 2-14 set ref 164* 164 238* 238 475* 475
                                                                                  544* 544 552* 552
reclen                   47            based           fixed bin(21,0)          level 3 dcl 3-3 ref 183 184 189 319 366 369 371 378
                                                                                  399
remain                          000124 automatic       fixed bin(17,0)          dcl 77 set ref 172 177 183 183 200 275* 286 317* 318
                                                                                  319 369* 370 370 370 403* 407 408 409 433 454* 454
                                                                                  456 459* 466* 506* 509* 510 511 511 512 514* 521
                                                                                  526
req_off                         000123 automatic       fixed bin(17,0)          dcl 77 set ref 177* 189* 207* 290* 316 361* 371*
                                                                                  392* 452* 500
rlN                     226            based           fixed bin(21,0)          level 3 dcl 2-14 set ref 152 153 155 163*
rlP                     224            based           pointer                  level 3 dcl 2-14 ref 161
rpad                                   based           char(1)                  unaligned dcl 46 ref 370 511
saveP                   216            based           pointer                  level 3 dcl 2-14 set ref 385* 405* 522
sdw                             000000 constant        structure                level 1 dcl 99
soft_status             264            based           structure                level 2 unaligned dcl 2-14
standard                  2            based           fixed bin(17,0)          level 2 dcl 2-14 ref 284 449 525
substr                                                 builtin function         dcl 71 set ref 195 196* 196 266* 266 280 281* 281
                                                                                  284* 307 308 370* 384 387* 387 404 419 424* 424
                                                                                  447* 447 449* 461 463* 463 495 496 511* 517* 517
                                                                                  523* 523 525* 527* 527
tape_ansi_file_cntl_$data_eof   000034 constant        entry                    external dcl 115 ref 254
tape_ansi_file_cntl_$data_eot   000036 constant        entry                    external dcl 115 ref 538
tape_ansi_file_cntl_$position_for_output
                                000040 constant        entry                    external dcl 115 ref 349
tape_ansi_nl_file_cntl_$data_eof
                                000042 constant        entry                    external dcl 115 ref 253
tape_ansi_nl_file_cntl_$data_eot
                                000044 constant        entry                    external dcl 115 ref 537
tape_ansi_tape_io_$close        000046 constant        entry                    external dcl 115 ref 575
tape_ansi_tape_io_$get_buffer   000050 constant        entry                    external dcl 115 ref 485
tape_ansi_tape_io_$read         000052 constant        entry                    external dcl 115 ref 250
tape_ansi_tape_io_$release_buffer
                                000054 constant        entry                    external dcl 115 ref 320 574
tape_ansi_tape_io_$write        000056 constant        entry                    external dcl 115 ref 531
toP                             000134 automatic       pointer                  dcl 91 set ref 308* 309 310 496* 497 498
total                           000116 automatic       fixed bin(21,0)          initial dcl 77 set ref 77* 244 308 311* 311 426* 426
                                                                                  465* 465 495 499* 499
ub                                     based           char                     unaligned dcl 56 set ref 308 495
ubP                                    parameter       pointer                  dcl 27 ref 128 161 308 325 495
unspec                                                 builtin function         dcl 71 ref 196 196 266 266 281 281 284 387 387 424
                                                                                  424 447 447 449 517 517 523 523 525 527 527
vl                                     based           structure                array level 2 unaligned dcl 2-14
vlX                       5            based           fixed bin(17,0)          initial level 2 dcl 4-3 ref 348

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
cseg_tseg_version_2                    internal static fixed bin(17,0)          initial dcl 2-12
iox_$iocb_version_sentinel             external static char(4)                  dcl 1-43

NAMES DECLARED BY EXPLICIT CONTEXT.
c_exit                          001430 constant        label                    dcl 575 ref 479 565 568 572
close                           001346 constant        entry                    external dcl 558
close2                          001414 constant        label                    dcl 574 ref 564 569 570
get_buf                         002021 constant        entry                    internal dcl 483 ref 359 367 379 382 400 458
get_record                      001442 constant        entry                    internal dcl 248 ref 171 182 194 212 228 295
inv_desc                        000366 constant        label                    dcl 235 ref 200 269 286 287 288
move_nothing                    002132 constant        label                    dcl 500 ref 494
move_to_buf                     002055 constant        entry                    internal dcl 493 ref 362 372 394 453
move_to_user                    001704 constant        entry                    internal dcl 305 ref 178 190 208 220
process_sw                      001604 constant        entry                    internal dcl 279 ref 214 296
r_count                         000372 constant        label                    dcl 238 ref 180 192 210 224 233
r_exit                          000377 constant        label                    dcl 240 ref 236 256 259
r_format                        000004 constant        label                    array(4) dcl 171 ref 169
r_sw_check                      000324 constant        label                    dcl 214 ref 229
read_record                     000055 constant        entry                    external dcl 128
read_release                    001763 constant        entry                    internal dcl 315 ref 179 191 209 223 226 298 301
restart                         001450 constant        label                    dcl 250 ref 255
s_get                           001666 constant        label                    dcl 295 ref 302
skip_segments                   001665 constant        entry                    internal dcl 294 ref 231
tape_ansi_ibm_lrec_io_          000041 constant        entry                    external dcl 20
w_count                         001324 constant        label                    dcl 475 ref 364 375 397
w_exit                          001331 constant        label                    dcl 477 ref 350 469 540 553
w_exit1                         001337 constant        label                    dcl 480 ref 473 545
w_fit_check                     000772 constant        label                    dcl 405 ref 468
w_format                        000010 constant        label                    array(4) dcl 358 ref 354
w_long                          001320 constant        label                    dcl 472 ref 358 366 378 399
w_now                           001265 constant        label                    dcl 457 ref 428 455
w_pad                           002164 constant        label                    dcl 511 ref 507
write_buf                       002136 constant        entry                    internal dcl 504 ref 363 373 374 381 395 396 457 571
write_record                    000433 constant        entry                    external dcl 325

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2740        3020    2445        2750
Length      3322    2445        60         266     273           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
tape_ansi_ibm_lrec_io_              226 external procedure  is an external procedure.  
on unit on line 138                  64 on unit               
get_record                              internal procedure  shares stack frame of external procedure tape_ansi_ibm_lrec_io_.  
process_sw                              internal procedure  shares stack frame of external procedure tape_ansi_ibm_lrec_io_.  
skip_segments                           internal procedure  shares stack frame of external procedure tape_ansi_ibm_lrec_io_.  
move_to_user                            internal procedure  shares stack frame of external procedure tape_ansi_ibm_lrec_io_.  
read_release                            internal procedure  shares stack frame of external procedure tape_ansi_ibm_lrec_io_.  
on unit on line 334                  64 on unit               
get_buf                                 internal procedure  shares stack frame of external procedure tape_ansi_ibm_lrec_io_.  
move_to_buf                             internal procedure  shares stack frame of external procedure tape_ansi_ibm_lrec_io_.  
write_buf                               internal procedure  shares stack frame of external procedure tape_ansi_ibm_lrec_io_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 erp                         tape_ansi_ibm_lrec_io_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
tape_ansi_ibm_lrec_io_   000100 peel                        tape_ansi_ibm_lrec_io_
                         000102 hold                        tape_ansi_ibm_lrec_io_
                         000104 cP                          tape_ansi_ibm_lrec_io_
                         000114 i                           tape_ansi_ibm_lrec_io_
                         000115 csw                         tape_ansi_ibm_lrec_io_
                         000116 total                       tape_ansi_ibm_lrec_io_
                         000117 move                        tape_ansi_ibm_lrec_io_
                         000120 left                        tape_ansi_ibm_lrec_io_
                         000121 long_record                 tape_ansi_ibm_lrec_io_
                         000122 parity_error                tape_ansi_ibm_lrec_io_
                         000123 req_off                     tape_ansi_ibm_lrec_io_
                         000124 remain                      tape_ansi_ibm_lrec_io_
                         000125 ecode                       tape_ansi_ibm_lrec_io_
                         000126 data_len                    tape_ansi_ibm_lrec_io_
                         000127 first_span                  tape_ansi_ibm_lrec_io_
                         000130 dwP                         tape_ansi_ibm_lrec_io_
                         000132 fromP                       tape_ansi_ibm_lrec_io_
                         000134 toP                         tape_ansi_ibm_lrec_io_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              mod_fx1             enable              shorten_stack
ext_entry           int_entry           repeat              set_cs_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ascii_to_ebcdic_              ebcdic_to_ascii_              tape_ansi_file_cntl_$data_eof tape_ansi_file_cntl_$data_eot
tape_ansi_file_cntl_$position_for_output                    tape_ansi_nl_file_cntl_$data_eof
tape_ansi_nl_file_cntl_$data_eot                            tape_ansi_tape_io_$close      tape_ansi_tape_io_$get_buffer
tape_ansi_tape_io_$read       tape_ansi_tape_io_$release_buffer                           tape_ansi_tape_io_$write

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$eof_record       error_table_$eov_on_write     error_table_$fatal_error      error_table_$file_busy
error_table_$invalid_record_desc                            error_table_$long_record      error_table_$tape_error




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     77 000025        20 000040        21 000047       128 000050       130 000066       132 000074       133 000076
    134 000077       135 000102       138 000103       139 000117       140 000122       141 000124       142 000125
    146 000130       147 000132       148 000133       149 000134       152 000135       153 000140       154 000143
    155 000144       156 000145       158 000146       159 000151       161 000153       162 000161       163 000162
    164 000164       165 000170       166 000171       169 000172       171 000175       172 000176       173 000200
    174 000203       175 000205       177 000207       178 000211       179 000212       180 000213       182 000214
    183 000215       184 000225       185 000226       186 000231       187 000233       189 000235       190 000237
    191 000240       192 000241       194 000242       195 000243       196 000250       199 000265       200 000274
    201 000300       202 000302       203 000305       204 000307       206 000311       207 000313       208 000315
    209 000316       210 000317       212 000320       213 000321       214 000324       215 000325       217 000333
    218 000335       220 000336       221 000337       222 000341       223 000353       224 000354       226 000355
    227 000356       228 000360       229 000361       231 000362       232 000363       233 000365       235 000366
    236 000371       238 000372       240 000377       241 000405       242 000407       243 000412       244 000421
    245 000424       246 000425       325 000426       327 000444       329 000452       330 000454       331 000457
    334 000460       335 000474       336 000477       337 000501       338 000502       341 000505       342 000507
    343 000510       344 000511       347 000512       348 000514       349 000535       350 000547       354 000551
    358 000555       359 000561       360 000562       361 000565       362 000566       363 000567       364 000570
    366 000571       367 000575       368 000576       369 000601       370 000606       371 000631       372 000634
    373 000635       374 000643       375 000647       377 000650       378 000654       379 000656       380 000657
    381 000667       382 000670       384 000671       385 000676       386 000677       387 000705       390 000722
    391 000725       392 000727       393 000732       394 000733       395 000734       396 000742       397 000747
    399 000750       400 000754       401 000755       402 000756       403 000761       404 000766       405 000772
    407 000775       408 001002       409 001006       410 001014       411 001020       417 001025       418 001031
    419 001032       420 001047       421 001057       422 001065       423 001100       424 001106       425 001117
    426 001121       428 001123       430 001124       431 001125       432 001127       433 001130       434 001133
    435 001135       436 001137       437 001140       438 001147       439 001156       441 001157       442 001171
    444 001200       445 001204       446 001207       447 001215       449 001233       450 001244       451 001247
    452 001251       453 001253       454 001254       455 001256       456 001262       457 001265       458 001266
    459 001267       461 001274       462 001300       463 001302       464 001307       465 001310       466 001311
    468 001315       469 001317       472 001320       473 001323       475 001324       477 001331       478 001333
    479 001335       480 001337       481 001341       558 001342       561 001357       562 001363       563 001365
    564 001370       565 001374       568 001375       569 001401       570 001403       571 001412       572 001413
    574 001414       575 001430       576 001441       248 001442       249 001443       250 001450       251 001466
    252 001470       253 001473       254 001510       255 001521       256 001523       259 001524       263 001530
    264 001535       265 001543       266 001546       269 001563       270 001573       271 001574       272 001576
    273 001577       275 001600       276 001603       279 001604       280 001605       281 001612       284 001627
    285 001635       286 001644       287 001650       288 001656       289 001660       290 001662       291 001664
    294 001665       295 001666       296 001667       297 001670       298 001700       299 001701       301 001702
    302 001703       305 001704       306 001705       307 001710       308 001715       309 001723       310 001753
    311 001760       312 001762       315 001763       316 001764       317 001767       318 001772       319 001774
    320 002004       322 002020       483 002021       484 002022       485 002027       486 002043       487 002053
    489 002054       493 002055       494 002056       495 002060       496 002066       497 002073       498 002123
    499 002130       500 002132       501 002135       504 002136       505 002137       506 002147       507 002152
    509 002153       510 002162       511 002164       512 002204       513 002206       514 002207       515 002210
    516 002214       517 002223       520 002237       521 002242       522 002244       523 002246       525 002262
    526 002270       527 002303       531 002317       532 002334       533 002344       534 002347       535 002354
    537 002357       538 002373       539 002404       540 002406       542 002415       543 002417       544 002420
    545 002424       549 002425       551 002426       552 002436       553 002440       555 002441


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
