	COMPILATION LISTING OF SEGMENT mrds_dsl_open
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/01/88  1325.6 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 
       11 
       12 /****^  HISTORY COMMENTS:
       13*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
       14*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
       15*     This entry is being made to cover the change made on 85-05-02 by
       16*     John Hergert (mrds #135, phx19372).
       17*  2) change(86-06-09,Dupuis), approve(86-08-05,MCR7491), audit(86-08-08,Blair),
       18*     install(86-08-15,MR12.0-1127):
       19*     Changed the call to save_index_of_opening (phx20208, mrds 151).
       20*  3) change(86-06-11,Dupuis), approve(86-08-05,MCR7491), audit(86-08-08,Blair),
       21*     install(86-08-15,MR12.0-1127):
       22*     Changed the call to default_error_handler_$add_finish_handler.
       23*     (phx20097, mrds 152).
       24*                                                   END HISTORY COMMENTS */
       25 
       26 
       27 mrds_dsl_open:
       28 open:
       29      procedure ();
       30 	goto common;
       31 
       32 finish_handler_entry: entry ();
       33 
       34 	call finish_handler;
       35 
       36 	return;
       37 /*
       38*                    BEGIN_DESCRIPTION
       39*
       40*   this routine is to be called with "entry options(variable)", with a minimum
       41*   of  4  arguments,  1)  the  pathname  of  a database model or submodel 2) a
       42*   database index argument, 3) the opening mode, and 4) and error code.  there
       43*   may  be  any  number  of  pathname/index  pairs,  as  long as the number of
       44*   database already open plus the number of requests does not exceed 128.  the
       45*   function  is  to "open" a database using either a submodel or model view as
       46*   specifed   by   the  given  pathname,  making  it  ready  for  "ready_file"
       47*   operations.   upon  successfull  completion  of  open,  a database index is
       48*   returned  that  is  used  in all further reference to the database via dsl_
       49*   routines that ready/finish/close or manipulate data.
       50*
       51*
       52*   PARAMETERS:
       53*
       54*   call  dsl_$open  (database_path1,  database_index1,  usage_mode1,  .  .  .,
       55*   database_pathN, database_indexN, usage_modeN, error_code) ;
       56*
       57*
       58*   database_pathN  -  -  (input) char(*), the relative or absoulte pathname of
       59*   either   a  model  or  submodel  view  of  a  database,  as  obtained  when
       60*   create_mrds_db  or  create_mrds_dsm  was  invoked.   the  suffix  ".db" for
       61*   models(new)  or ".dsm" for submodels need not be given if no ambiguity will
       62*   result  as  to  whether  a  model  or  submodel  is meant.  this may be the
       63*   pathname  of  either  an  old  or  new  version database model or submodel,
       64*   however, versions can not be mixed in the same call to open.
       65*
       66*   database_indexN - - (output) fixed bin(35), an integer from 1 to 128, to be
       67*   used  in  all further references to the open data base in data manipulation
       68*   or other operations using either dsl_ or mrds_call interfaces.
       69*
       70*   usage_modeN  -  - The usage mode must be declare fixed binary (35) aligned,
       71*   and be a value between 1 and 4 for the allowed modes of:
       72*   1 - retrieve
       73*   2 - update
       74*   3 - exclusive retrieve
       75*   4 - exclusive update
       76*   where the first two allow concurrent access via the scope mechanism.
       77*
       78*   error_code  -  -  (output)  fixed bin(35), error type encoding, 0 unless an
       79*   error occurred
       80*
       81*   sub_error_  -  - (output) condition, signaled upon detection of an error to
       82*   provide futher error information
       83*   END_DESCRIPTION
       84*
       85*   HISTORY:
       86*
       87*   78-08-01 Oris Friesen: written
       88*
       89*   79-03-08 Al Kepner: to restrict opening of quiesced data bases.
       90*
       91*   79-03-14   Al   Kepner:   to  remove  quiesce_sw  parameter  from  call  to
       92*   mrds_dsl_init_res.
       93*
       94*   79-07-01 Jim Gray: rewritten to
       95*   1) add sub_err_ reporting of errors and structured error handling
       96*   2) remove restriction of having all databases opened at once
       97*   3) add ".db" model suffix logic
       98*   4) correct the logic detecting model/submodel - old/new version
       99*   5) correct the finish and cleanup handlers
      100*   6) add detection of mixed versions in open list
      101*   7) document and simplify the modules logic
      102*
      103*   79-09-01  Jim  Gray:  to  accept  old  style  calls  with  scope usage mode
      104*   argument.
      105*
      106*   80-01-01 Jim Gray: to enforce use of a mode in the open call.
      107*
      108*   80-03-01 Jim Gray: to capture db indexes used by old version open.
      109*
      110*   80-09-16  Jim  Gray:  to keep looking for foo.db, when foo given as path to
      111*   open, and the segment foo is found first.
      112*
      113*   80-12-10  Jim  Gray  : changed exclusive open calls to scope setting to ask
      114*   for  new r-s-m-d type scope modes rather than r-u types.  Also added use of
      115*   mrds_new_scope_modes and mrds_opening_modes_ include files.
      116*
      117*   80-12-22  Jim Gray : changed submodel version check to allow either version
      118*   4  or version 5 dsmd_version_number submodels to be considered "new", since
      119*   the old bound_v1_ code only handles earlier versions.
      120*
      121*   80-12-24  Jim  Gray  : improved error message from no_database to no_access
      122*   for case where user has null access to db_model
      123*
      124*   81-01-21  Jim Gray : added call to mrds_dm_authorization$set_needed_access,
      125*   so  that DBA's will have any needed access set automatically, this was done
      126*   in the get_model_version routine.
      127*
      128*   81-02-11  Jim  Gray  :  changed  calls to external dsmd_, into calls to the
      129*   internal interface rmds_dsm_dsmd.
      130*
      131*   81-04-30   Jim   Gray   :   added   capture  of  error_table_$no_info  from
      132*   hcs_$initiate  so  that mrds_error_$no_model_access could be returned, when
      133*   user has no acl on db dir or db_model.
      134*
      135*   81-06-02  Davids:  removed  declared  but  unreferenced  variables, changed
      136*   references  of  mrds_dsm_dsmd  to the appropriate mrds_dsm_** routine (user
      137*   interface  to  internal  mrds  interface)  in  the get_submodel_version and
      138*   cleanup internal procedures.
      139*
      140*   81-06-23  Jim  Gray  :  removed  code  defining builtin functions, to allow
      141*   definition   on   an   as   needed   basis,   and   put  into  the  routine
      142*   mrds_dsl_get_builtins.
      143*
      144*   81-08-07  Rickie  E.   Brinegar:  modified  to recognize that multi-segment
      145*   files without the ".dsm" are not submodels and to not attempt to treat them
      146*   as submodels.
      147*
      148*   81-09-25 Davids: Modified so that determining if the  input  path
      149*   has a ".db" or ".dsm" suffix is not done with a substr since this
      150*   can cause stringrange conditions to occur for short entry  names.
      151*   The  reason  why  the  strings  are  reversed  is  so that a name
      152*   "X.db.dsm"  will  be   identified   as   a   submodel.   declared
      153*   reversed_MODEL_SUFFIX and reversed_SUBMODEL_SUFFIX
      154*
      155*   82-01-26 R. Lackey : This is put in to handle the case where a directories
      156*   foo and foo.db reside in the same directory where foo is NOT a db and
      157*   foo.db is a db.  Associated with TR12288.
      158*
      159*   82-04-15 Davids: added code to check the consistancy bit in the db_model
      160*   and fail to open if the db is not consistant. code was added in the
      161*   get_model_version procedure.
      162*
      163*   82-04-29 Davids: updated to new calling sequence of mu_db_inconsistent
      164*
      165*   82-05-21 Mike Kubicar : fixed the bug where the wrong error code would
      166*   be returned when trying to open a quiesced database.  Also modified code
      167*   so that a database that is waiting to be quiesced by another process
      168*   can not be opened.
      169*
      170*   82-07-01  Roger Lackey : Modified the calls to mu_db_inconsistent to use
      171*   mdbm_util_$inconsistent_* for binding.
      172*
      173*   83-01-10  Roger Lackey : Modified to correct the use of view path for submodels.
      174*
      175*   83-02-01  Roger Lackey : Modified by removing 300 lines of code that 
      176*   included 4 internal procedures that determined db_version or submodel
      177*   and replaced with call to mrds_dsl_get_version$get_path_info.
      178*   Also removed the getting and releasing of tempseg for area replacing it with
      179*   an automatic area.
      180*
      181*  83-02-04 Roger Lackey :  Replaced code to check for inconsistent db.
      182*                           and fixed to open old submodels.
      183*
      184*
      185*  83-02-05  Roger Lackey : Fixed bug that would not allow open of old db 
      186*                           followed by new until old was closed.
      187*
      188*  83-03-08  Mike Kubicar : Changed call of mrds_dsl_get_version$get_path_info
      189*  to mrds_dsl_get_version$get_path_info_and_view_name so that opening links
      190*  will store the correct opening name in the resultant.
      191*
      192*  83-04-19 Davids: Modified to remove deep nesting by adding the label
      193*  exit_mrds_dsl_open and doing a goto after setting the error code. Also
      194*  changed the sense of some if statements so that null then clauses are
      195*  not needed.
      196*
      197*  83-04-21 Davids: Replaced use of index "/" operator with the divide
      198*  builtin. Removed the code that checked the default resultant storage
      199*  directory and set it to the pdir if it wasn't set since the code that
      200*  manages the resultant storage directory already did that. This was called
      201*  only during the first call to in a process. Removed rtrim's from around
      202*  paths which occur at the end of error messages. Rearanged the code in
      203*  process_path_index_pairs so that the code that is executed for a new version
      204*  database is controled with only 1 if instead of lots of ifs in lots of
      205*  places. Added the internal procedure error_exit which calls cleanup and then
      206*  goes to exit_mrds_dsl_open also added code to reset the invocation flag
      207*  during a normal exit, this removed the need to call clean_up on a normal
      208*  exit. Deleted variable BLANK, entries mrds_dsl_resultant_storage$get, $set,
      209*  and get_pdir, and builtin rtrim. Added builtin divide.
      210*
      211*  83-04-22 Davids: Deleted the entries mode_off which set a switch which
      212*  allowed openings without an opening mode. Also the mode_on entry which
      213*  reset the switch. Deleted the variable allow_new_open (which was the
      214*  above switch)
      215*
      216*  83-05-18 Davids: Split the internal procedure process_usage_mode into the
      217*  procedures get_usage_ready_modes and process_usage_mode. The get procedure
      218*  gets the usage mode argument, makes sure its the right type and in the 
      219*  correct range and sets the ready_mode based on the useage mode. (no changes
      220*  to the code). The process procedure sets the dbcb.open_mode based on the
      221*  usage mode, calls mrds_dsl_ready_all if the resultant still needs to be
      222*  built, and sets scopes. The only change is that ready_all is now called only
      223*  if the resultant still needs to be built (dbcb.res_already_made = "0"b). The
      224*  split was needed so that the ready_mode could be obtained before the call
      225*  to mrds_dsl_init_res which needs the ready mode to update the saved copy of
      226*  the resultant.
      227*
      228*  83-05-23 Davids: Added code after the call to mrds_dsl_ready_all to create
      229*  a copy of the resultant under the db_dir if the user is the db's DBA. This
      230*  required adding the administrator flag to the mrds_dsl_init_res parameter
      231*  list.
      232*
      233*  83-05-26 Davids: Corrected clean_up procedure to allways call mrds_dsl_close,
      234*  instead of doing it only if the clean_up_condition was signled. This cleans
      235*  up from all errors. Added check so that a saved resultant is not created if
      236*  the opening is via a submodel.
      237*
      238*  83-06-13 Davids: Changed call to sub_err_ for the case of tring to open an
      239*  inconsistent database so that error_code is passed to the sub_error handler
      240*  via the info pointer and the following call to error_exit is made only if the
      241*  error_code is still 0 when sub_err_ returns.
      242*
      243*  83-06-21 Davids: Removed code dealing with old and new database versions.
      244*  If its an old database version an error will be returned from
      245*  mrds_dsl_version$get_path_info.
      246*
      247*  85-05-02 John Hergert:  Moved location of call to save_index_of_opening.
      248*  The way it was prevented open from cleaning up when it discovered that
      249*  the DB was awaiting quiesceing or quiesced.  This left phantom users
      250*  registered.
      251*
      252*/* initialize */
      253 
      254 common:
      255 	area_ptr = null ();
      256 	clean_up_condition = OFF;
      257 	open_index_list_ptr = null ();
      258 	num_ptrs, num_dims = 0;
      259 
      260 /* check for correct argument count */
      261 
      262 	call cu_$arg_list_ptr (al_ptr);
      263 	nargs = divide (arg_list.desc_count, 2, 17, 0);	/* = number of args if called via entry options(variable) */
      264 
      265 	if nargs < 3 then do;
      266 		code = error_table_$wrong_no_of_args;
      267 		call sub_err_ (code, caller_name, continue, info_ptr, return_value,
      268 		     "^/^a ^d ^a ^a", "The number of arguments given =",
      269 		     arg_list.arg_count / 2, "was less than the minimum of 3,",
      270 		     "or the entry was not declared ""options (variable)"".");
      271 		call error_exit;
      272 	     end;
      273 
      274 	if arg_list.code = SPECIAL			/* initialize the error code argument */
      275 	then desc_index = nargs + 1;
      276 	else desc_index = nargs;
      277 	num_ptrs = desc_index + nargs;
      278 	desc_ptr = arg_list.arg_des_ptr (desc_index + nargs);
      279 	if desc_ptr -> descriptor_ovrly ^= fixed_bin_35_descr then do;
      280 		code = error_table_$bad_arg;
      281 		call sub_err_ (code, caller_name, continue, info_ptr, return_value,
      282 		     "^/^a",
      283 		     "The error code(last) argument was not declared ""fixed binary (35) aligned""."
      284 		     );
      285 		call error_exit;
      286 	     end;
      287 
      288 	error_code_ptr = arg_list.arg_des_ptr (nargs);
      289 	error_code, code = 0;			/* initialize */
      290 
      291 	if previous_invocation			/* make sure this is not a recursive call */
      292 	then do;
      293 		error_code = mrds_error_$no_recursion;
      294 		call sub_err_ (error_code, caller_name, continue, info_ptr,
      295 		     return_value, "^/^a",
      296 		     "Attempt to invoke this procedure recursively, a release must be done first."
      297 		     );
      298 		call error_exit;
      299 	     end;
      300 	previous_invocation = "1"b;
      301 
      302 	if first_time				/* set up a handler to clean up a dying process */
      303 	then do;
      304 		error_code = add_epilogue_handler_ (finish_handler_entry);
      305 		if error_code = 0
      306 		then first_time = OFF;
      307 		else do;
      308 			call sub_err_ (error_code, caller_name, continue, info_ptr,
      309 			     return_value, "^/^a",
      310 			     "Unable to add a finish handler to the default error handler."
      311 			     );
      312 			call error_exit;
      313 		     end;
      314 	     end;
      315 
      316 	on cleanup /* set up a handler in case the user does a quit/release */
      317 	     begin;
      318 		clean_up_condition = "1"b;
      319 		call clean_up ();
      320 	     end;
      321 
      322 	if ^too_many_open ()			/* check that the user is not exceeding the maximum number of openings allowed */
      323 	then call process_path_index_pairs ();		/* go through all pairs of model/submodel pathnames and open indexes */
      324 
      325 	previous_invocation = OFF;			/* reset the invocation flag */
      326 
      327 exit_mrds_dsl_open:
      328 	return;
      329 
      330 process_path_index_pairs:
      331      procedure ();
      332 
      333 /* look at each pair of pathname/index in the argument list,
      334*   and try to open the model/submodel at that location, returning the database opening index */
      335 
      336 	arg_count = 1;
      337 
      338 /* get some work space */
      339 
      340 	area_ptr = addr (work_area);
      341 
      342 	do while (arg_count < nargs);
      343 
      344 /* get the pathname argument */
      345 
      346 	     desc_ptr = arg_list.arg_des_ptr (desc_index + arg_count);
      347 	     if descriptor.type ^= CHAR_NONVAR
      348 	     then do;
      349 		     error_code = error_table_$bad_arg;
      350 		     call sub_err_ (error_code, caller_name, continue, info_ptr,
      351 			return_value, "^/^a ^d ^a", "The database pathname argument",
      352 			(arg_count + 1) / 2,
      353 			"was not declared ""character nonvarying"".");
      354 		     call error_exit;
      355 		end;
      356 
      357 	     view_path_ptr = arg_list.arg_des_ptr (arg_count);
      358 	     view_path_len = fixed (string (descriptor.size));
      359 
      360 /* get the database opening index argument */
      361 
      362 	     dbi_arg_count = arg_count + 1;
      363 
      364 /* find out from the pathname suffix, if any, and the status of the location addressed what type of entry we are
      365*   dealing with, a submodel or a model, and either an old version or a new version database. */
      366 
      367 	     call mrds_dsl_get_version$get_path_info_and_view_name
      368 		(view_path, area_ptr,
      369 		mrds_path_info_structure_version,
      370 		mrds_path_info_ptr, view_dir, view_entry,
      371 		error_code);
      372 	     abs_path = mrds_path_info.absolute_path;
      373 
      374 	     if error_code ^= 0
      375 	     then do;
      376 		     if error_code = mrds_error_$no_model_access
      377 		     then do;
      378 			     if mrds_path_info.model
      379 			     then error_message = "^/Unable to read the model using the database path " || abs_path;
      380 			     else error_message = "^/Unable to open the multi-segment file as a submodel using the path "
      381 				     || abs_path;
      382 			     call sub_err_ (error_code, caller_name, continue,
      383 				info_ptr, return_value, error_message);
      384 			end;
      385 		     else
      386 			if error_code = mrds_error_$no_database
      387 		     then do;
      388 			     error_message = "^/No data base found using the path "
      389 				|| abs_path;
      390 			     call sub_err_ (error_code, caller_name, continue,
      391 				info_ptr, return_value, error_message);
      392 			end;
      393 		     call error_exit;
      394 		end;
      395 
      396 	     if mrds_path_info.model
      397 	     then do;				/* It is a database path */
      398 		     dsm_sw = "0"b;
      399 
      400 		     call hcs_$initiate (abs_path, "db_model", "", 0, 0, data_model_ptr, error_code);
      401 		     if data_model_ptr ^= null ()
      402 		     then do;			/* seg db_model => new version */
      403 			     error_code = 0;
      404 			     call mdbm_util_$inconsistent_get_info
      405 				(data_model_ptr, incon_sw, incon_name, incon_message, incon_undo_request);
      406 			     if incon_sw
      407 			     then do;
      408 				     error_code = mrds_error_$inconsistent_database;
      409 				     call sub_err_ (error_code, caller_name, continue, addr (error_code), return_value,
      410 					"^a:   ^a", incon_name, incon_message);
      411 				     if error_code ^= 0 /* error_code may be reset */
      412 				     then call error_exit; /* by sub_error condition handler */
      413 				end;
      414 			end;
      415 		end;
      416 	     else dsm_sw = "1"b;			/* It is a submodel */
      417 
      418 	     db_index = 0;
      419 
      420 	     if mod (nargs - 1, 3) ^= 0
      421 	     then do;				/* mode argument not given */
      422 		     error_code = error_table_$noarg;
      423 		     call sub_err_ (error_code, caller_name, continue,
      424 			info_ptr, return_value, "^/^a^a^a",
      425 			"No opening mode was given for database """,
      426 			abs_path, """.");
      427 		     call error_exit;
      428 		end;
      429 
      430 	     call open_new_version;
      431 	     call process_usage_mode ();
      432 	     call /* assign the database index value to the user's argument */
      433 		mu_convert_parameter$convert_output_parameter (
      434 		addr (db_index), addr (fixed_bin_35_descr),
      435 		arg_list.arg_des_ptr (dbi_arg_count),
      436 		arg_list.arg_des_ptr (desc_index + dbi_arg_count),
      437 		error_code);
      438 	     if error_code ^= 0
      439 	     then do;
      440 		     call sub_err_ (error_code, caller_name, continue,
      441 			info_ptr, return_value, "^/^a^a^a ^a",
      442 			"The database index argument for database """,
      443 			abs_path,
      444 			""" could not be converted to user's data type",
      445 			"from ""fixed binary (35) aligned"".");
      446 		     call error_exit;
      447 		end;
      448 
      449 /* advance to the next pathname/index/mode triplet */
      450 
      451 	     arg_count = arg_count + 3;
      452 	end;
      453 
      454      end process_path_index_pairs;
      455 
      456 get_usage_and_ready_modes: proc;
      457 
      458 	call mu_convert_parameter$convert_input_parameter (arg_list
      459 	     .arg_des_ptr (arg_count + 2), desc_ptr, usage_mode_ptr,
      460 	     addr (fixed_bin_35_descr), area_ptr, code);
      461 	if code ^= 0
      462 	then do;
      463 		error_code = code;
      464 		call sub_err_ (code, caller_name, continue, info_ptr, return_value,
      465 		     "^/^a^a^a", "The opening scope usage mode for database """,
      466 		     abs_path,
      467 		     """ could not be converted to ""fixed binary (35) aligned"".");
      468 		call error_exit;
      469 	     end;
      470 
      471 /* get usage mode argument */
      472 
      473 	if usage_mode < RETRIEVAL | usage_mode > EXCLUSIVE_UPDATE
      474 	then do;
      475 		error_code = error_table_$bad_arg;
      476 		call sub_err_ (error_code, caller_name, continue, info_ptr, return_value,
      477 		     "^/^a ^d ^a^a^a^/^a^/^a", "The opening scope usage mode =",
      478 		     usage_mode, "given for database """, abs_path,
      479 		     """ was not between 1 and 4.", "Allowed modes are:",
      480 		     "1(retrieval), 2(update), 3(exclusive retrieval), 4(exclusive update).");
      481 		call error_exit;
      482 	     end;
      483 
      484 	if usage_mode = RETRIEVAL | usage_mode = EXCLUSIVE_RETRIEVAL then
      485 	     ready_mode = 5;			/* scope retrieve */
      486 	else ready_mode = 6;			/* scope update */
      487 
      488 	return;
      489 
      490      end;
      491 
      492 process_usage_mode:
      493      procedure ();
      494 
      495 	dbcb.open_mode = addr (usage_mode) -> mode_ovrly.bit_3;
      496 
      497 	if ^dbcb.res_already_made
      498 	then do;
      499 		call mrds_dsl_ready_all (db_index, ready_mode, error_code);
      500 		if error_code ^= 0
      501 		then call error_exit;
      502 		if administrator & ^dsm_sw
      503 		then do;
      504 			call mrds_dsl_create_res_copy$db_already_open
      505 			     (abs_path, dbcb_ptr, error_code);
      506 			if error_code ^= 0
      507 			then do;
      508 				call sub_err_ (error_code, caller_name, continue, info_ptr, return_value,
      509 				     "^/Could not create a copy of the resultant under the db directory" ||
      510 				     "^/Database has been successfully opened");
      511 				error_code = 0;	/* allow the opening to continue */
      512 			     end;
      513 		     end;
      514 	     end;
      515 
      516 
      517 /* exclusive usage modes will have equivalent file scopes set on all files,
      518*   this method is chosen because 1) opens may now be done in different calls, not
      519*   all in one call as in MR6, thus the old protocall can't be used.
      520*   2) this version of the open call interface is meant to be primarily a transition tool
      521*   3) it is the simplest method, that does not require major changes to
      522*   existing code, all of the mechanism can be contained in this module. */
      523 
      524 
      525 	if usage_mode > UPDATE
      526 	then do;					/* exclusive modes */
      527 		if usage_mode = EXCLUSIVE_RETRIEVAL	/* exclusive retrieve */
      528 		then do;
      529 			permit_operations = READ_ATTR;/* retrieve */
      530 			prevent_operations = UPDATE_OPS; /* update (store, delete, modify) */
      531 		     end;
      532 		else do;				/* exclusive update */
      533 			permit_operations = ALL_OPS;	/* retrieve, update (store, delete, modify) */
      534 			prevent_operations = permit_operations; /* nothing allowed */
      535 		     end;
      536 
      537 		call mrds_dsl_set_fscope$set_fscope_all (db_index,
      538 		     permit_operations, prevent_operations, wait_sec, error_code);
      539 
      540 		if error_code ^= 0
      541 		then do;
      542 			call sub_err_ (error_code, caller_name, continue, info_ptr,
      543 			     return_value, "^/^a^a^a ^d ^a",
      544 			     "Unable to obtain exclusive scope settings on all files for database """
      545 			     , abs_path, """ in order to make this mode =",
      546 			     usage_mode, "an exclusive mode opening.");
      547 			call error_exit;
      548 		     end;
      549 	     end;
      550      end;
      551 
      552 too_many_open:
      553      procedure () returns (bit (1));
      554 
      555 /* add the number already open to the number of requests,
      556*   and make sure that the number of openings allowed
      557*   has not been exceeded by this request */
      558 
      559 	current_number_of_openings = mu_database_index$get_number_open_dbs ();
      560 
      561 	number_of_requests = divide ((nargs - 1), 2, 17, 0);
      562 
      563 	if (number_of_requests + current_number_of_openings) <= mrds_data_$max_dbs
      564 	then max_opening_overflow = OFF;
      565 	else do;
      566 		max_opening_overflow = "1"b;
      567 		error_code = mrds_error_$too_many_dbs;
      568 		call sub_err_ (error_code, caller_name, continue, info_ptr, return_value,
      569 		     "^/^a ^d ^a ^d ^a ^d", "The number of open requests =",
      570 		     number_of_requests, "plus the current number of openings =",
      571 		     current_number_of_openings,
      572 		     "exceed the maximum number of openings allowed =",
      573 		     mrds_data_$max_dbs);
      574 		call error_exit;
      575 	     end;
      576 
      577 	return (max_opening_overflow);
      578 
      579 
      580 	declare max_opening_overflow	 bit (1);		/* on => too many databases would be open */
      581 
      582      end;
      583 
      584 open_new_version:
      585      procedure ();
      586 
      587 /* the resultant model can now be built for this opening,
      588*   initially only the dbcb(database control block) segment
      589*   rm_db_info(rdbi) segments will be created with a
      590*   file and rel array saved in the secure(rdbi) section of the resultant.
      591*   ready_file will later complete the building of the resultant */
      592 
      593 	dcl     quiesce_lock_copy	 bit (36) aligned;	/* Working copy of the quiesce lock */
      594 
      595 	desc_ptr = arg_list.arg_des_ptr (desc_index + arg_count + 2);
      596 	call get_usage_and_ready_modes;
      597 
      598 	call mrds_dsl_init_res (view_dir, view_entry, dsm_sw, ready_mode, db_index, dbcb_ptr, administrator,
      599 	     error_code);
      600 
      601 /* errors are reported by the lower routine */
      602 
      603 	if db_index ^= 0
      604 	then call save_index_of_opening ();		/* remember openings made, in case we have to back out */
      605 
      606 /* If the entire data base has been quiesced, only the quiescing process is allowed to open it. */
      607 
      608 	if error_code ^= 0
      609 	then call error_exit;
      610 
      611 	dbc_ptr = dbcb.dbc_ptr;
      612 
      613 /* Now check to see that the database is not quiesced or awaiting quiesce.
      614*   Note that no locks have to be set to check this.  The open list has
      615*   already been modified to show this user has the database open so no
      616*   further quiescing can take place.  If the database is found to be already
      617*   quiesced then this opening will be backed out.  */
      618 
      619 	quiesce_lock_copy = dbc.proper.quiesce_lock;
      620 	call set_lock_$lock (quiesce_lock_copy, 0, code);
      621 	if code ^= 0
      622 	then do;
      623 		if code = error_table_$invalid_lock_reset
      624 		then do;
      625 			error_code = mrds_error_$quiesced_dead_db;
      626 			dbc.proper.flags.trouble_switch = "1"b;
      627 		     end;
      628 		else
      629 		     if code = error_table_$lock_wait_time_exceeded
      630 		then do;
      631 			if dbc.proper.flags.quiesce_sw
      632 			then error_code = mrds_error_$quiesced_db;
      633 			else error_code = mrds_error_$quiesce_pending;
      634 		     end;
      635 		else
      636 		     if code ^= error_table_$locked_by_this_process
      637 		then error_code = code;
      638 
      639 		if error_code ^= 0
      640 		then do;
      641 			call sub_err_ (error_code, caller_name, continue,
      642 			     info_ptr, return_value, "^/The database, ^a, could not be opened.",
      643 			     abs_path);
      644 			call error_exit;
      645 		     end;
      646 	     end;
      647      end;
      648 
      649 save_index_of_opening:
      650      procedure ();
      651 
      652 /* remember the database index for this opening, in case we
      653*   have to close the databases already opened, due to an error */
      654 
      655 	allocate db_open set (open_index_ptr) in (work_area);
      656 
      657 	db_open.path = abs_path;
      658 	db_open.dsm_sw = dsm_sw;
      659 	db_open.index = db_index;
      660 	db_open.next = null ();
      661 
      662 /* link it into the list in order */
      663 
      664 	if open_index_list_ptr = null ()
      665 	then do;
      666 		open_index_list_ptr = open_index_ptr;
      667 		last_open_index_ptr = open_index_ptr;
      668 	     end;
      669 	else do;
      670 		last_open_index_ptr -> db_open.next = open_index_ptr;
      671 		last_open_index_ptr = open_index_ptr;
      672 	     end;
      673      end;
      674 
      675 error_exit: procedure ();
      676 
      677 	call clean_up;
      678 
      679 	goto exit_mrds_dsl_open;
      680 
      681      end;
      682 
      683 clean_up:
      684      procedure ();
      685 
      686 /* remove used space, close opened databases if cleanup condition, or error,
      687*   and reset the invocation flag */
      688 
      689 	if clean_up_condition
      690 	then do;
      691 		if substr (db_mrds_dsl_open, 1, 1)
      692 		then on sub_error_ ;		/* ignore this condition if cleanup was signaled */
      693 	     end;
      694 
      695 	if open_index_list_ptr ^= null ()
      696 	then do;
      697 		do open_index_ptr = open_index_list_ptr repeat saved_ptr
      698 		     while (open_index_ptr ^= null ());
      699 
      700 		     saved_ptr = db_open.next;
      701 		     close_index = db_open.index;
      702 
      703 		     call mrds_dsl_close (close_index, discard_code);
      704 		     if ^clean_up_condition & discard_code ^= 0
      705 		     then call sub_err_ (discard_code, caller_name, continue, info_ptr,
      706 			     return_value, "^/^a ^d",
      707 			     "Unable to close a database using opening index =",
      708 			     close_index);
      709 		end;
      710 
      711 		open_index_list_ptr = null ();
      712 	     end;
      713 
      714 	previous_invocation = OFF;
      715 
      716 	declare saved_ptr		 ptr;		/* temporary storage for next on list pointer */
      717 
      718      end;
      719 
      720 finish_handler:
      721      procedure ();
      722 
      723 /* before the process dies, we must close any open databases
      724*   the error code and sub_error_ condition from close will be ignored */
      725 
      726 	if ^substr (db_mrds_dsl_open, 1, 1) then
      727 	     ;
      728 	else on sub_error_ ;			/* ingore this condition */
      729 
      730 
      731 	number_of_openings = mu_database_index$get_number_open_dbs ();
      732 
      733 	number_closed = 0;
      734 	do close_index = 1 by 1 to mrds_data_$max_dbs
      735 	     while (number_closed < number_of_openings);
      736 
      737 	     call
      738 		mu_database_index$get_resultant_model_pointer (close_index,
      739 		dbcb_ptr);
      740 
      741 	     if dbcb_ptr = null () then
      742 		;				/* not a valid index */
      743 	     else do;
      744 
      745 		     call mrds_dsl_close (close_index, discard_code);
      746 		     number_closed = number_closed + 1;
      747 
      748 		end;
      749 
      750 	end;
      751 
      752      end finish_handler;
      753 
      754 	declare sub_error_		 condition;	/* signaled when sub_err_ called */
      755 
      756 	declare view_path_len	 fixed bin;	/* length of pathname */
      757 
      758 	declare db_index		 fixed bin (35);	/* index to data base (Output) */
      759 	declare code		 fixed bin (35);	/* internal status code */
      760 
      761 	dcl     nargs		 fixed bin;	/* number of arguments */
      762 
      763 
      764 	dcl     previous_invocation	 bit (1) static init ("0"b); /* indicates if ever entered and not finished */
      765 
      766 	dcl     first_time		 bit static init ("1"b);
      767 
      768 	dcl     dsm_sw		 bit (1);		/* ON => arg. list refers to data submodel */
      769 
      770 	dcl     cleanup		 condition;
      771 
      772 	dcl     (substr, mod, null, addr, empty, fixed, divide, string, rel) builtin;
      773 
      774 /*	Multics Subroutines		*/
      775 
      776 	dcl     add_epilogue_handler_  entry (entry) returns (fixed bin(35));
      777 
      778 	dcl     cu_$arg_list_ptr	 entry (ptr);
      779 
      780 /*	Other dsl routines		*/
      781 
      782 	dcl     mrds_dsl_close	 entry options (variable),
      783 	        mu_database_index$get_number_open_dbs entry returns (fixed bin),
      784 	        mrds_dsl_init_res	 entry (char (*), char (*), bit (1), fixed bin, fixed bin (35), ptr, bit (1), fixed bin (35));
      785 
      786 
      787 /*	System error_table_		*/
      788 
      789 	dcl     error_table_$invalid_lock_reset ext fixed bin (35);
      790 	dcl     error_table_$locked_by_this_process fixed bin (35) ext static;
      791 	dcl     error_table_$lock_wait_time_exceeded ext fixed bin (35);
      792 
      793 /*	mrds_error_table_		*/
      794 
      795 	dcl     (
      796 	        mrds_error_$no_recursion,
      797 	        mrds_error_$too_many_dbs
      798 	        )			 fixed bin (35) ext;
      799 
      800 	dcl     mrds_error_$quiesced_db ext fixed bin (35);
      801 	dcl     mrds_error_$quiesced_dead_db ext fixed bin (35);
      802 	dcl     mrds_error_$quiesce_pending ext fixed bin (35);
      803 
      804 /*	mrds_data_		*/
      805 
      806 	dcl     mrds_data_$max_dbs	 fixed bin ext;
      807 	declare sys_info$max_seg_size	 fixed bin (35) ext static;
      808 	declare sub_err_		 entry options (variable); /* error reporting routine */
      809 	declare caller_name		 char (15) init ("mrds_dsl_open"); /* name of calling routine */
      810 	declare continue		 char (1) init ("c"); /* don't stop after printing */
      811 	declare info_ptr		 ptr init (null ());/* unused */
      812 	declare return_value	 fixed bin (35) init (0); /* unused */
      813 	declare error_code		 fixed bin (35) based (error_code_ptr); /* error status code */
      814 	declare OFF		 bit (1) init ("0"b); /* false value */
      815 	declare 1 db_open		 aligned based (open_index_ptr), /* list of open database indexes for this call */
      816 		2 path		 char (168),	/* users pathname argument */
      817 		2 dsm_sw		 bit (1),		/* on => submodel, else model */
      818 		2 index		 fixed bin (35),	/* database index for this opening */
      819 		2 next		 ptr;		/* to next in list */
      820 	declare open_index_ptr	 ptr;		/* to db_open list element */
      821 	declare open_index_list_ptr	 ptr;		/* to first on list */
      822 	declare last_open_index_ptr	 ptr;		/* to last on list */
      823 	declare arg_count		 fixed bin;	/* current arg number being processed */
      824 	declare clean_up_condition	 bit (1);		/* on => cleanup has been signaled */
      825 	declare chase		 fixed bin (1) init (1b); /* 1 => chase links */
      826 	declare MODEL_SUFFIX	 char (3) init (".db"); /* suffix on new models */
      827 	declare reversed_MODEL_SUFFIX	 char (3) init ("bd."); /* model suffixed reversed */
      828 	declare SUBMODEL_SUFFIX	 char (4) init (".dsm"); /* suffix on submodels */
      829 	declare reversed_SUBMODEL_SUFFIX char (4) init ("msd."); /* submodel suffix reversed */
      830 	declare current_number_of_openings fixed bin;	/* number of databases alrady open */
      831 	declare number_of_requests	 fixed bin;	/* number of path/index pairs */
      832 	declare view_path_ptr	 ptr;		/* pointer to pathname argument */
      833 	declare view_path		 char (view_path_len) based (view_path_ptr);
      834 	declare view_dir		 char (500);	/* Dir name of the db specified by the user */
      835 	declare view_entry		 char (32);	/* Entry name of the db specified by the user */
      836 	declare error_code_ptr	 ptr;		/* pointer to error code argument */
      837 	declare error_table_$wrong_no_of_args fixed bin (35) ext; /* <3 or even number of args */
      838 	declare SEGMENT		 fixed bin init (1);/* type = 1 => segment */
      839 	dcl     DIRECTORY		 fixed bin init (2);/* type = 2 => directory or segment */
      840 	declare LINK		 fixed bin init (0);/* type = 0 => link */
      841 	declare DIRECTORY_BIT_COUNT	 fixed bin init (0);/* type = 2 & bit count = 0 => dir */
      842 
      843 	declare discard_code	 fixed bin (35);	/* unused error code */
      844 	declare number_closed	 fixed bin;	/* number closed so far during clean/finish */
      845 	declare number_of_openings	 fixed bin;	/* number currently open */
      846 	declare close_index		 fixed bin (35);	/* database index for db to be closed */
      847 	declare mu_database_index$get_resultant_model_pointer
      848 				 entry (fixed bin (35), ptr); /* get ptr given index */
      849 	declare descriptor_ovrly	 bit (36) unal based; /* overlay for descriptor word */
      850 	declare fixed_bin_35_descr	 bit (36)
      851 				 init ("100000100000000000000000000000100011"b); /* descriptor for fixed bin(35) aligned */
      852 	declare SPECIAL		 fixed bin init (8);/* special form of arg list code */
      853 	declare desc_index		 fixed bin;	/* offset to descriptors in arg list ptr array */
      854 	declare CHAR_NONVAR		 fixed bin init (21); /* character nonvarying data type */
      855 	declare error_table_$bad_arg	 fixed bin (35) ext;/* bad subroutine argument */
      856 
      857 	declare area_ptr		 ptr;		/* points to work area */
      858 	declare work_area		 area (2500);	/* work space for paramenter */
      859 	declare abs_path		 char (168);	/* expanded user input pathname */
      860 	declare usage_mode		 fixed bin (35) based (usage_mode_ptr); /* opening scope usage mode  argument */
      861 	declare usage_mode_ptr	 ptr;		/* points to usage mode argument */
      862 	declare ready_mode		 fixed bin (17);	/* file ready mode parameter to ready_all */
      863 	declare administrator	 bit (1);		/* indicates that the user is a DBA */
      864 	declare mrds_dsl_ready_all
      865 				 entry (fixed bin (35), fixed bin (17), fixed bin (35));
      866 						/* readies all files in database */
      867 	declare mrds_dsl_create_res_copy$db_already_open entry (char (168), ptr, fixed bin (35));
      868 	declare mrds_dsl_set_fscope$set_fscope_all entry options (variable);
      869 						/* sets scope on all files */
      870 	declare permit_operations	 fixed bin;	/* operations to allow caller */
      871 	declare prevent_operations	 fixed bin;	/* operations to dis-allow others */
      872 	declare wait_sec		 fixed bin (35) int static options (constant) init (30);
      873 						/* time to wait on busy file */
      874 	declare mu_convert_parameter$convert_input_parameter
      875 				 entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)); /* gets input in form needed */
      876 	declare mu_convert_parameter$convert_output_parameter
      877 				 entry (ptr, ptr, ptr, ptr, fixed bin (35)); /* assigns output values */
      878 	declare dbi_arg_count	 fixed bin;	/* remembered argument count of database index in arg_list */
      879 	declare error_table_$noarg	 fixed bin (35) ext;/* missing mode argument */
      880 	dcl     error_message	 char (256);
      881 	dcl     data_model_ptr	 ptr;
      882 	dcl     hcs_$initiate	 entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
      883 	dcl     incon_message	 char (200);
      884 	dcl     incon_name		 char (32);
      885 	dcl     incon_sw		 bit (1);
      886 	dcl     incon_undo_request	 char (100);
      887 	dcl     mrds_error_$inconsistent_database fixed bin (35) ext static;
      888 	dcl     mdbm_util_$inconsistent_get_info entry (ptr, bit (1), char (*), char (*), char (*));
      889 	dcl     mrds_error_$no_model_access fixed bin (35) ext static;
      890 	dcl     mrds_error_$no_database fixed bin (35) ext static;
      891 
      892 	declare 1 mode_ovrly	 unal based,	/* for assigning opening mode */
      893 		2 unused		 bit (33),
      894 		2 bit_3		 bit (3);
      895 
      896 
      897 	declare set_lock_$lock	 entry (bit (36) aligned, fixed bin, fixed bin (35));
      898 	dcl     mrds_dsl_get_version$get_path_info_and_view_name entry (char (*), ptr, fixed bin, ptr, char (*), char (*),
      899 				 fixed bin (35));
      900 
      901 
  1     1 /* BEGIN mdbm_descriptor.incl.pl1 -- jaw 5/31/78 */
  1     2 /* modified by Jim Gray - - Nov. 1979, to change type from fixed bin(5) to
  1     3*   unsigned fixed bin(6), so new packed decimal data types could be handled.
  1     4*   also the duplicate mrds_descriptor.incl.pl1 was eliminated. */
  1     5 
  1     6 dcl 1 descriptor based (desc_ptr),			/* map of Multics descriptor */
  1     7     2 version bit (1) unal,				/* DBM handles vers. 1 only */
  1     8     2 type unsigned fixed bin (6) unal,			/* data type */
  1     9     2 packed bit (1) unal,				/* on if data item is packed */
  1    10     2 number_dims bit (4) unal,			/* dimensions */
  1    11     2 size,					/* size for string data */
  1    12       3 scale bit (12) unal,				/* scale for num. data */
  1    13       3 precision bit (12) unal,			/* prec. for num. data */
  1    14     2 array_info (num_dims),
  1    15       3 lower_bound fixed bin (35),			/* lower bound of dimension */
  1    16       3 upper_bound fixed bin (35),			/* upper bound of dimension */
  1    17       3 multiplier fixed bin (35);			/*  element separation */
  1    18 
  1    19 dcl  desc_ptr ptr;
  1    20 dcl  num_dims fixed bin init (0) ;			/* more useful form of number_dims */
  1    21 
  1    22 /* END mdbm_descriptor.incl.pl1 */
  1    23 
  1    24 
      902 
      903 
  2     1 /* START OF:	mrds_opening_modes_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2     4 	/*									*/
  2     5 	/* Name:  mrds_opening_modes_.incl.pl1						*/
  2     6 	/*									*/
  2     7 	/* Defines named constants which can be used in calls to dsl_$open when opening a MRDS	*/
  2     8 	/* data base.								*/
  2     9 	/*									*/
  2    10 	/* Status									*/
  2    11 	/* 0)  Created by:   Gary C. Dixon; January 22, 1979				*/
  2    12 	/*									*/
  2    13 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    14 
  2    15      dcl (RETRIEVAL			init(1),
  2    16 	UPDATE			init(2),
  2    17 	EXCLUSIVE_RETRIEVAL		init(3),
  2    18 	EXCLUSIVE_UPDATE		init(4)) fixed bin(35) int static options(constant);
  2    19 	
  2    20 /* END OF:	mrds_opening_modes_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2    21 
      904 
      905 
  3     1 /* START OF:	mrds_new_scope_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3     2 
  3     3 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3     4 /* 									*/
  3     5 /* Name:  mrds_new_scope_modes.incl.pl1						*/
  3     6 /* 									*/
  3     7 /*      This include file defines named constants which can be used to specify the MRDS	*/
  3     8 /* operations to be permitted and prevented in a call to dsl_$set_scope.		*/
  3     9 /* 									*/
  3    10 /* Status									*/
  3    11 /* 									*/
  3    12 /* 0)   Created on January 25, 1980 by Jim Gray          				*/
  3    13 /* 1)   80-12-10 Jim Gray : r-u scope modes changed to r-s-m-d type scope modes,          */
  3    14 /*    also, names were changed to agree with security acl modes in MRDS.	          */
  3    15 /*									*/
  3    16 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3    17 
  3    18 dcl (NO_OP init (0),
  3    19      READ_ATTR init (1),
  3    20      APPEND_TUPLE init (2),
  3    21      DELETE_TUPLE init (4),
  3    22      MODIFY_ATTR init (8),
  3    23      UPDATE_OPS init (14),
  3    24      ALL_OPS init (15)) fixed bin int static options (constant);
  3    25 
  3    26 /* END OF:	mrds_new_scope_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      906 
      907 
  4     1 /* BEGIN mdbm_arg_list.incl.pl1 -- jaw 5/31/78 */
  4     2 /* the duplicate mrds_arg_list.incl.pl1 was eliminated by Jim Gray, Nov. 1979 */
  4     3 
  4     4 /* layout of argument list for IDS and DBM entries with options (variable) */
  4     5 
  4     6 dcl 1 arg_list based (al_ptr),
  4     7     2 arg_count fixed bin (17) unal,			/* 2 * no. of args. */
  4     8     2 code fixed bin (17) unal,			/* 4 => normal, 8 => special */
  4     9     2 desc_count fixed bin (17) unal,			/* 2 * no. of descriptors */
  4    10     2 pad fixed bin (17) unal,			/* must be 0 */
  4    11     2 arg_des_ptr (num_ptrs) ptr;			/* argument/descriptor pointer */
  4    12 
  4    13 dcl  al_ptr ptr;
  4    14 dcl  num_ptrs fixed bin;
  4    15 
  4    16 /* END mdbm_arg_list.incl.pl1  */
  4    17 
      908 
      909 
  5     1 /* BEGIN mrds_dbcb.incl.pl1 -- jaw, 11/7/78 */
  5     2 
  5     3 
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  5     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  5     8*     This entry is being made to cover the change made on 85-07-01 by Thanh
  5     9*     Nguyen. The scopes_changed flag was added to make checking for this
  5    10*     more efficient (mrds error list #137).
  5    11*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
  5    12*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
  5    13*     Add a bit called dont_check_txn_id to indicate whether or not we should
  5    14*     care if multiple txns use the same selection_expression. (mrds #156)
  5    15*  3) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  5    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  5    17*     Added parser_work_area_ptr and mrds_se_info_ptr for new parser.
  5    18*                                                   END HISTORY COMMENTS */
  5    19 
  5    20 
  5    21 /* WARNING
  5    22*          If the dbcb structure is changed then the mrds_data_
  5    23*          item saved_res_version MUST be incremented to invalidate all
  5    24*          existing saved resultants
  5    25**/
  5    26 
  5    27 /* HISTORY :
  5    28*
  5    29*   modified by Jim Gray - - 80-10-24, to add new_select_expr bit for
  5    30*   tid_list management
  5    31*
  5    32*   81-1-9 Jim Gray : added like reference for  ease  in  making  the
  5    33*   phony resultant in mu_database_index, without having the area dcl
  5    34*   included.
  5    35*
  5    36*   81-06-17 Roger Lackey :  added  last_store_rel_name  for  use  by
  5    37*   mrds_dsl_store
  5    38*
  5    39*   81-06-26 Roger Lackey : Added no_optimize and  print_search_order
  5    40*   switches
  5    41*
  5    42*   81-07-06 Jim Gray : added identifier for  the  current  selection
  5    43*   expression,  so  that relation statistics can be updated relative
  5    44*   to number of selection expressions seem. Also  removed  init  for
  5    45*   last_store_rel_name,   as   this   iw   now   properly   done  in
  5    46*   mrds_dsl_init_res.
  5    47*
  5    48*   81-07-17  Roger Lackey : added pred_ptr and unused_ptrs.
  5    49*
  5    50*   82-08-19  Mike Kubicar : added store_vector field.  This is needed
  5    51*   for the conversion to the relation manager.
  5    52*
  5    53*   82-08-23 Davids: added the relmgr_entries and access_costs
  5    54*   substructures so that the entries and costs can change
  5    55*   depending on the type of database that is opened.
  5    56*
  5    57*   82-09-09 Mike Kubicar : added modify_vector field.  This is needed
  5    58*   since modify uses a different vector type (general) than does store.
  5    59*
  5    60*   82-09-20 Davids: changed names of (store modify)_vector to
  5    61*   (store modify)_vector_ptr. Also (delete modify)_tuple_by_id to
  5    62*   (delete modify)_tuples_by_id. added the element cursor_storage_ptr
  5    63*   which should be inited to null and will be set by mu_cursor_manager_$get
  5    64*   during the first call.
  5    65*
  5    66*   82-09-21 Davids: renamed cursor_storage_ptr to cursor_ptrs_storage_ptr
  5    67*   since it deals with the pointers to the cursors and not the cursors
  5    68*   themelves and added the element cursor_storage_area_ptr which points
  5    69*   to the area where the cursors are kept.
  5    70*
  5    71*   82-09-22 Davids: renamed the transact_ctl_seg to transactions_needed.
  5    72*   the transact_ctl_seg always had a value of 0 and really didn't mean
  5    73*   anything.
  5    74*
  5    75*   82-09-22 Mike Kubicar : added create_relation, create_index and
  5    76*   destroy_relation_by_opening to relmgr_entries.  They are needed
  5    77*   by mrds_dsl_define_temp_rel.
  5    78*
  5    79*   82-09-24 Donna Woodka : added  put_tuple to  relmgr_entries. It
  5    80*   is needed by mu_store.
  5    81*
  5    82*   82-11-12 Davids: changed the declaration of the access_costs from fixed
  5    83*   bin to float bin since the values are not integers.
  5    84*
  5    85*   83-02-02 Davids: added the dbc_uid element. This will allow mrds to make
  5    86*   sure that the dbc_ptr still points to the correct segment. Element was 
  5    87*   added to the end of the structure to allow modules that don't use
  5    88*   the element to continue to reference the dbcb structure without recompiling.
  5    89*
  5    90*   83-02-25 Davids: added the concurrency_on and rollback_on elements. These
  5    91*   are needed so that temp rels can be created with the same file attributes
  5    92*   as the permanent relations.
  5    93*
  5    94*   83-05-02 Mike Kubicar : Deleted get_next_search_specification_ptr and
  5    95*   added the resultant_in_pdir bit.
  5    96*
  5    97*   83-05-18 Davids: reduced the number of reserved bits to 14 (from 15) and
  5    98*   added the res_already_made element.
  5    99*
  5   100*   83-05-24 Mike Kubicar : Updated the relation manager calling sequences.
  5   101*
  5   102*   83-08-03 Mike Kubicar : Added the element_id_list_segment_ptr and removed
  5   103*   one of the unused pointers.
  5   104*
  5   105*   83-09-20 Ron Harvey: Added relmgr_entries.get_population.
  5   106*
  5   107*   84-08-27 John Hergert:  Created compiled_se_info_ptr from unused_ptrs(2)
  5   108*   leaving unused_ptrs(1).
  5   109*
  5   110*   85-01-15 Thanh Nguyen:  Added the work_area_ptr and removed the last
  5   111*   unused_ptrs (1).
  5   112*
  5   113*   85-04-12 Thanh Nguyen:  Added user_started_transaction and 
  5   114*   non_shared_to_shared flags.  Also added se_transaction_id and some more
  5   115*   spare ptrs, entries and reserved storages for future enhancement, since
  5   116*   we changed the saved_res_version from rslt0001 to rslt0002.
  5   117*
  5   118*   85-07-01 Thanh Nguyen:  Added scopes_changed flag.  This flag is set by
  5   119*   common routine of mrds_dsl_set_scope, reset by mrds_dsl_optimize and 
  5   120*   mrds_dsl_gen_srch_prog when building of a new search_vars.
  5   121**/
  5   122 
  5   123 
  5   124 /* this structure is based on the {unique_name}.mrds.dbcb segment
  5   125*   that constitutes the non-secure portion of the resultant model that is
  5   126*   created during the opening of a database. it contains variables that
  5   127*   are used during the runtime access of the database, and an area
  5   128*   for evaluation of requests. it points to four other
  5   129*   segments in the resultant model, {unique_name}.mrds.rdbi, the secure
  5   130*   portion of the resultant(see mdbm_rm_db_info.incl.pl1),
  5   131*   {unique_name}.mrds.select, an area for selection expression evaluation,
  5   132*   {unique_name}.mrds.curdat, and {unique_name}.mrds.stadat, two segments
  5   133*   used in the elimination of duplicate tuples during a retrieve.
  5   134*   the dbcb area holds the structure in mdbm_scope_info.incl.pl1
  5   135*   that is used when the database is using the file scope mechanism
  5   136*   for concurrency control over file readying. the segment overlayed via
  5   137*   mrds_dbc.incl.pl1 structure is pointed to and also handles concurrency control,
  5   138*   across database openings. the pointer to this dbcb structure is kept in a table
  5   139*   which associates database indexes(returned from a call to dsl_$open), with particular
  5   140*   opening instances of resultant models. (see mu_database_index routine) */
  5   141 
  5   142      dcl	   1 dbcb		      aligned based (dbcb_ptr), /* DBCB -- non-secure portion */
  5   143 	     2 data	      like dbcb_data,
  5   144 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (dbcb.static_area))));
  5   145 
  5   146      dcl	   dbcb_ptr	      ptr;
  5   147 
  5   148      declare 1 dbcb_data	      based,		/* info part of dbcb, separated out so that
  5   149*						   like references can avoid getting the area declaration */
  5   150 	     2 rdbi_ptr	      ptr,		/* pointer to write protected mdbm_util_ info. */
  5   151 	     2 range_ptr	      ptr,		/*  ptr to range structure, or null */
  5   152 	     2 select_ptr	      ptr,		/* ptr to select list, or null */
  5   153 	     2 sv_ptr	      ptr,		/* pointer to search variables */
  5   154 	     2 so_ptr	      ptr,		/* pointer to search operators */
  5   155 	     2 ti_ptr	      ptr,		/* pointer to tuple info */
  5   156 	     2 lit_ptr	      ptr,		/* pointer to the literal area, or null */
  5   157 	     2 current_ptr	      ptr,		/* ptr to select list resulting from -current clause */
  5   158 	     2 ss_ptr	      ptr,		/* ptr to select sets block if not simple s.e. */
  5   159 	     2 retr_info_ptr      ptr,		/* ptr to retrieve info area */
  5   160 	     2 trel_info_ptr      ptr,		/* ptr to retrieve info area */
  5   161 	     2 sti_ptr	      ptr,		/* pointer to store info */
  5   162 	     2 dbc_ptr	      ptr,		/*  pointer to the data base control segment */
  5   163 	     2 sfi_ptr	      ptr,		/* points to head of scalar function list */
  5   164 	     2 scope_ptr	      ptr,		/* points to array of scope tuples */
  5   165 	     2 select_area_ptr    ptr,		/* ptr to area for current selection expression allocations */
  5   166 	     2 current_data_ptr   ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  5   167*						   for eliminating duplicate tuples. */
  5   168 	     2 static_data_ptr    ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  5   169*						   for eliminating duplicate tuples. */
  5   170 	     2 store_area_ptr     ptr,		/* temp storage area for dsl_$store */
  5   171 	     2 retrieve_area_ptr  ptr,		/* temp storage for dsl_$retrieve */
  5   172 	     2 modify_area_ptr    ptr,		/* temp storage area for dsl_$modify */
  5   173 	     2 delete_area_ptr    ptr,		/* temp storage area for dsl_$delete */
  5   174 	     2 def_temp_rel_area_ptr ptr,		/* temp storage area for dsl_$define_temp_rel */
  5   175 	     2 pred_ptr	      ptr,		/* Pointer to pred_array */
  5   176 	     2 store_vector_ptr   ptr,		/* Vector structure used during store operations */
  5   177 	     2 modify_vector_ptr  ptr,		/* Used during modifies */
  5   178 	     2 element_id_list_segment_ptr ptr,		/* Points to the segment used to hold element_id_list structures */
  5   179                2 compiled_se_info_ptr ptr,                  /* points to the segment containing all info on compiled sexs */
  5   180 	     2 work_area_ptr        ptr,		/* Work area for encode/decode value allocations in mu_retrieve */
  5   181 	     2 se_info_ptr          ptr,                  /* Points to se_info struct. Primarily for error reports */
  5   182 	     2 parser_work_area_ptr ptr,		/*  work area for parser */
  5   183 	     2 reserved_ptrs      (4) ptr,		/* Reserved for future use */
  5   184 	     2 another_flag	      bit (1) unal,		/* on if predicate was -another */
  5   185 	     2 current_flag	      bit (1) unal,		/* on if predicate was -current clause */
  5   186 	     2 dbc_incr	      bit (1) unal,		/* on if dbc open mode has been incremented for this user */
  5   187 	     2 delete_flag	      bit (1) unal,		/* On if search was called from mrds_dsl_sec_delete */
  5   188 	     2 dup_retain	      bit (1) unaligned,	/* On if dup tuples allowed for retrieval */
  5   189 	     2 prev_select	      bit (1) unal,		/* on if prev. select block processed in this s.e. */
  5   190 	     2 possible_op	      bit (1) unal,		/* on of arith op. allowed */
  5   191 	     2 sel_clause	      bit (1) unal,		/* on if currently in select clause */
  5   192 	     2 dsm_sw	      bit (1) unal,		/* on if data base was opened via data submodel */
  5   193 	     2 val_rtrv	      bit (1) unal,		/* if s.e. valid for retrieve */
  5   194 	     2 val_mod	      bit (1) unal,		/* for modify */
  5   195 	     2 val_del	      bit (1) unal,		/* for delete */
  5   196 	     2 val_dtr	      bit (1) unal,		/* for define temp rel */
  5   197 	     2 transactions_needed bit (1) unal,	/* On => transaction must be started or in progress does
  5   198*                                                                     not imply that the database is of type page_file */
  5   199 	     2 open_mode	      bit (3) unal,		/* 0=>unknown, 1=>r, 2=>u, 3=>er, 4=>eu, >4=>bad */
  5   200 	     2 new_select_expr    bit (1) unal,		/* on => starting a new tid list management period */
  5   201 	     2 no_optimize	      bit (1) unal,		/* On => no optimize */
  5   202 	     2 print_search_order bit (1) unal,		/*  On => print the search order */
  5   203 	     2 resultant_in_pdir  bit (1) unal,		/* On => Temp segments are in the process dir */
  5   204 	     2 res_already_made   bit (1) unal,           /* On => resultant has been made based on a saved copy */
  5   205 	     2 user_started_transaction bit (1) unal,     /* On => user already started his own transaction. */
  5   206 	     2 non_shared_to_shared bit (1) unal,         /* On => user changed the scope from non shared to shared
  5   207*						   inside a sequence of -another selection expression. */
  5   208 	     2 scopes_changed     bit (1) unal,           /* On => scopes had been changed by set_scopes or delete_scopes */
  5   209 	     2 dont_check_txn_id  bit (1) unal,           /* On => cpmd needs same selection exp across multiple txns */
  5   210 	     2 reserved	      bit (10) unal,	/* reserved for future use */
  5   211 	     2 nseq_sch	      fixed bin (35),	/* no. tuples located via sequential search */
  5   212 	     2 nind_sch	      fixed bin (35),	/* no. tuples located via index search */
  5   213 	     2 nhash_sch	      fixed bin (35),	/* no. tuples located via hash search */
  5   214 	     2 nlk_sch	      fixed bin (35),	/* no tuples located via link search */
  5   215 	     2 cur_lit_offset     fixed bin (35),	/* current bit offset in literal string */
  5   216 	     2 dbi	      fixed bin (35),	/* database index for this opening */
  5   217 	     2 last_s_e_id_num    fixed bin (35),	/* identifying number for last selection expression seen */
  5   218 	     2 se_transaction_id  bit (36) aligned,       /* transaction id from beginning of select expression */
  5   219 	     2 last_store_rel_name char (32),		/* Name of relation last used  for store */
  5   220 	     2 cursor_ptrs_storage_ptr ptr,		/* pointer to space where cursor ptrs are stored */
  5   221 	     2 cursor_storage_area_ptr ptr,		/* pointer to area where the cursors are kept */
  5   222 	     2 reserved_words     (10) fixed bin (35),	/* Reserved for future use */
  5   223 	     2 relmgr_entries,			/* relation manager entries */
  5   224 	       3 open	      entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  5   225 	       3 close	      entry (bit (36) aligned, fixed bin (35)),
  5   226 	       3 create_cursor    entry (bit (36) aligned, ptr, ptr, fixed bin (35)),
  5   227 	       3 destroy_cursor   entry (ptr, ptr, fixed bin (35)),
  5   228 	       3 set_scope	      entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35)),
  5   229 	       3 delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  5   230 	       3 modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35)),
  5   231 	       3 get_tuple_by_id  entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  5   232 	       3 get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)),
  5   233 	       3 get_tuple_id     entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  5   234 	       3 put_tuple	      entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  5   235 	       3 get_count	      entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  5   236 	       3 get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35)),
  5   237 	       3 get_population   entry (ptr, fixed bin (35), fixed bin (35)),
  5   238 	       3 create_relation  entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)),
  5   239 	       3 create_index     entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35)),
  5   240 	       3 destroy_relation_by_path entry (char (*), char (*), fixed bin (35)),
  5   241 	       3 reserved_entries (5) entry (),
  5   242 	     2 access_costs,			/* access costs for permute */
  5   243 	       3 total_primary_key_cost float bin,
  5   244 	       3 access_cost      float bin,
  5   245 	       3 access_overhead  float bin,
  5   246 	       3 us_access_cost   float bin,
  5   247 	       3 os_access_cost   float bin,
  5   248 	     2 dbc_uid	      bit (36) aligned,	/* uid of the segment containing the dbc structure */
  5   249 	     2 concurrency_on     bit (1) unal,		/* "1"b implies dmfile concurrency is being used */
  5   250 	     2 rollback_on	      bit (1) unal;		/* "1"b iomplies before journaling is to be done */
  5   251 
  5   252 /* END mrds_dbcb.incl.pl1 */
  5   253 
  5   254 
      910 
      911 
  6     1 /* BEGIN INCLUDE FILE definition.incl.pl1 */
  6     2 
  6     3 
  6     4 
  6     5 /****^  HISTORY COMMENTS:
  6     6*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  6     7*     audit(86-07-18,DGHowe), install(86-11-20,MR12.0-1222):
  6     8*     Modified to add indirect bit to definition flags.
  6     9*                                                   END HISTORY COMMENTS */
  6    10 
  6    11 
  6    12 dcl	1 definition	aligned based,
  6    13 	2 forward		unal bit(18),	/* offset of next def */
  6    14 	2 backward	unal bit(18),	/* offset of previous def */
  6    15 	2 value		unal bit(18),
  6    16 	2 flags		unal,
  6    17 	  3 new		bit(1),
  6    18 	  3 ignore	bit(1),
  6    19 	  3 entry		bit(1),
  6    20 	  3 retain	bit(1),
  6    21 	  3 argcount	bit(1),
  6    22 	  3 descriptors	bit(1),
  6    23 	  3 indirect	bit(1),
  6    24 	  3 unused	bit(8),
  6    25 	2 class		unal bit(3),
  6    26 	2 symbol		unal bit(18),	/* offset of ACC for symbol */
  6    27 	2 segname		unal bit(18);	/* offset of segname def */
  6    28 
  6    29 /* END INCLUDE FILE definition.incl.pl1 */
      912 
      913 
  7     1 /*	BEGIN INCLUDE FILE		mdbm_dbc.incl.pl1	08/23/78   odf			*/
  7     2 
  7     3 /* HISTORY:
  7     4*
  7     5*   Modified by odf for new version data bases in August 1978
  7     6*   Modified by Al Kepner, March 8, 1979 to add new flags for quiescing
  7     7*   Modified by M. Pierret, 8 April 1980 to look prettier, add pads
  7     8*   Modified by M. Pierret, 22 August 1980, grouping like fields (flags, offsets..)
  7     9*
  7    10*   80-11-19 Jim Gray : modified to change version number from 4  to 5 to allow
  7    11*   automatic update of dbc structures to new r-s-m-d-u scope codes from r-u.
  7    12**/
  7    13 
  7    14 dcl 1 dbc based (dbc_ptr),				/* data base control segment description */
  7    15     2 proper,
  7    16       3 version fixed bin,				/* version number of this structure */
  7    17       3 dtd_mrds fixed bin (71),			/* date time dumped by mrds utility */
  7    18       3 flags,
  7    19         4 trouble_switch bit (1) unal,			/* ON => ungraceful termination of a user process */
  7    20         4 dead_proc_flag bit (1) unal,			/* ON => dead process has access to part of data base */
  7    21         4 quiesce_sw bit (1) unal,			/* ON => db is quiesced for a administrative user */
  7    22         4 quiesce_db bit (1) unal,			/* ON => The entire data base is being quiesced. */
  7    23         4 quiesce_files bit (1) unal,			/* ON => A selected set of files is being quiesced. */
  7    24         4 pad bit (31) unal,				/* reserved for future use */
  7    25       3 quiesce_lock bit (36) aligned,			/* lock word for quiescing data base */
  7    26       3 wakeup_waiters fixed bin,			/* nbr users who have been sent a wakeup signal but have not yet
  7    27*						   received it */
  7    28       3 user_counts,
  7    29         4 open_users fixed bin,			/* nbr of users with data base open in any mode */
  7    30         4 active_users fixed bin,			/* nbr of users currently having a scope set */
  7    31         4 waiting_users fixed bin,			/* nbr of users waiting to set scope */
  7    32       3 open_lock bit (36) aligned,			/* lock word for opening data base */
  7    33       3 scope_lock bit (36) aligned,			/* lock word for setting and deleting scope */
  7    34       3 sa_size fixed bin (35),			/* size in words of static area  */
  7    35       3 pad2 bit (144),
  7    36       3 offsets,
  7    37         4 open_users_ofs bit (18) unal,			/* bit offset to list of users with data base currently open */
  7    38         4 active_users_ofs bit (18) unal,		/* bit offset to list of active users in shared mode */
  7    39         4 waiting_users_ofs bit (18) unal,		/* bit offset to list of waiting users in shared mode */
  7    40         4 obsolete bit (36) unal,			/* obsolete */
  7    41       3 pad3 bit (144),
  7    42     2 static_area area (sys_info$max_seg_size - fixed (rel (addr (dbc.static_area))) + 1);
  7    43 
  7    44 dcl  dbc_ptr ptr init (null ());
  7    45 
  7    46 dcl  VERSION_NBR fixed bin init (5) static internal options (constant);
  7    47 
  7    48 
  7    49 /* END mdbm_dcb.incl.pl1  */
  7    50 
  7    51 
      914 
      915 
  8     1 /* BEGIN INCLUDE FILE mrds_path_info.incl.pl1 - -  Jim Gray 81-01-22 */
  8     2 
  8     3 /* HISTORY:
  8     4*
  8     5*   81-01-22 Jim Gray : originaly created for the dsl_$get_path_info interface,
  8     6*   a slight extension to the undocumented mrds_dsl_get_version$header.
  8     7*
  8     8**/
  8     9 
  8    10 /* DESCRIPTION:
  8    11*
  8    12*   This structure returns information about a relative pathname, given
  8    13*   to a pathname accepting mrds interface. The information returned
  8    14*   is the absolute pathname, plus in the case that
  8    15*   the relative path points to a mrds database or submodel
  8    16*   whether it is a model or a submodel, the mrds version of
  8    17*   the model or submodel, it's creator, and the time of creation.
  8    18*
  8    19**/
  8    20 
  8    21 
  8    22 declare 1 mrds_path_info aligned based (mrds_path_info_ptr),
  8    23         2 version fixed bin,				/* version number for this structure */
  8    24         2 absolute_path char (168),			/* the absolute path from the input relative path */
  8    25         2 type,
  8    26 	3 not_mrds bit (1) unal,			/* on => path not to model or submodel */
  8    27 	3 model bit (1) unal,			/* on => path to database model, thus possible .db suffix */
  8    28 	3 submodel bit (1) unal,			/* on => path to submodel, thus possible .dsm suffix */
  8    29 	3 mbz1 bit (33) unal,
  8    30         2 mrds_version fixed bin,			/* the mrds version number of the model or submodel */
  8    31         2 creator_id char (32),			/* the person.project.tag of the creator */
  8    32         2 creation_time fixed bin (71),			/* convert date to binary form of time model/submodel created */
  8    33         2 mbz2 bit (36) unal ;
  8    34 
  8    35 
  8    36 declare  mrds_path_info_ptr ptr ;
  8    37 
  8    38 declare  mrds_path_info_structure_version fixed bin init (1) int static options (constant) ;
  8    39 
  8    40 /* END  INCLUDE FILE mrds_path_info.incl.pl1 */
      916 
      917 
  9     1 /* BEGIN INCLUDE FILE mrds_debug_names.incl.pl1     Jim Gray 8/7/79 */
  9     2 
  9     3 /* this include file associates module names with debug switches
  9     4*   that are stored in the data segment mrds_debug_
  9     5*   each module has it's own bit(9) debug switch, to define for various
  9     6*   debug actions, with new module names to be added to the end
  9     7*   of this list using the next in order array index in mrds_debug_
  9     8*   the convention for naming is db_{module's full name}
  9     9*   for the defined declaration over mrds_debug_$switch.
  9    10*   module.name array is then changed to reflect the new
  9    11*   number of modules, with the full module name added to the bottom
  9    12*   of the initialize list for the name array.
  9    13*   the module name array is used by the command level interface that sets/resets
  9    14*   the current status of the debug switches for each module.
  9    15*   the modules themselves use the db_{module name} declared variable for
  9    16*   that module to interagate the bits for proper debug action to take.
  9    17*   the definition of the meaning of the 9-bits is up to each individual module's
  9    18*   designer. */
  9    19 
  9    20 
  9    21 /*
  9    22*   HISTORY
  9    23*
  9    24*   80-11-12 Davids: added db_mus_mod_ubtup
  9    25*
  9    26*   80-11-13 Davids: added db_mu_sec_get_tuple and db_mu_sec_get_tid
  9    27*
  9    28*   80-12-15 Jim Gray :  added  mrds_dsl_set_fscope  to  display  non
  9    29*   error  info  about  being queued, and request being granted after
  9    30*   being queued.
  9    31*
  9    32*   81-01-15 Jim Gray : added  mu_concurrency_control  bit  to  allow
  9    33*   running  MR8  and  MR9 mrds against the same database at the same
  9    34*   time.
  9    35*
  9    36*   81-02-02  Jim  Gray  :  added  bit  for  mrds_rst_dmdm  to  allow
  9    37*   displaying internal tuple format bit offset, rather than the user
  9    38*   view.
  9    39*
  9    40*   81-02-06 Jim Gray : added bit for  new  mu_open_name_manager,  to
  9    41*   dump  an  element  from  the  list, when display_open_names entry
  9    42*   called with switch set.
  9    43*
  9    44*   81-05-20 Jim Gray : added bit for  mrds_dsl_where_clause  display
  9    45*   of sub_err_ messages, when cross domain compare occurs.
  9    46*
  9    47*   81-06-17 Jim Gray : added bit for mu_open_iocb_manager to display
  9    48*   iocb slot and rel name.
  9    49*
  9    50*   81-07-08 Jim Gray : added comment for bit 4 in mrds_dsl_permute
  9    51*
  9    52*   81-07-17 Jim Gray : added comment for bit 5 in mrds_dsl_permute
  9    53*
  9    54*   81-07-18 Jim Gray : added bit 1 for  mrds_dsl_gen_srch_prog  that
  9    55*   allows  key  searches, other than than specified by permute to be
  9    56*   done as comparisons instead.
  9    57*
  9    58*   81-07-22  Jim   Gray   :   added   comment   about   bit   2   in
  9    59*   mrds_dsl_gen_srch_prog
  9    60**/
  9    61 
  9    62 declare (
  9    63          db_mrds_dsl_eval_expr bit (9) unal defined (mrds_debug_$switch (1)),
  9    64          db_mrds_dsl_get_token bit (9) unal defined (mrds_debug_$switch (2)),
  9    65          db_mrds_dsl_permute bit (9) unal defined (mrds_debug_$switch (3)),
  9    66          db_mrds_dsl_optimize bit (9) unal defined (mrds_debug_$switch (4)),
  9    67          db_mrds_dsl_search bit (9) unal defined (mrds_debug_$switch (5)),
  9    68          db_mrds_dsl_translate bit (9) unal defined (mrds_debug_$switch (6)),
  9    69          db_mu_retrieve bit (9) unal defined (mrds_debug_$switch (7)),
  9    70          db_mrds_dsl_open bit (9) unal defined (mrds_debug_$switch (8)),
  9    71          db_mrds_dsl_close bit (9) unal defined (mrds_debug_$switch (9)),
  9    72          db_mrds_dsl_init_res bit (9) unal defined (mrds_debug_$switch (10)),
  9    73          db_mu_sec_init_res bit (9) unal defined (mrds_debug_$switch (11)),
  9    74          db_mus_mod_ubtup bit (9) unal defined (mrds_debug_$switch (12)),
  9    75          db_mu_sec_get_tuple bit (9) unal defined (mrds_debug_$switch (13)),
  9    76          db_mu_sec_get_tid bit (9) unal defined (mrds_debug_$switch (14)),
  9    77          db_mrds_dsl_set_fscope bit (9) unal defined (mrds_debug_$switch (15)),
  9    78          db_mu_concurrency_control bit (9) unal defined (mrds_debug_$switch (16)),
  9    79          db_mrds_rst_dmdm bit (9) unal defined (mrds_debug_$switch (17)),
  9    80          db_mu_open_name_manager bit (9) unal defined (mrds_debug_$switch (18)),
  9    81          db_mrds_dsl_where_clause bit (9) unal defined (mrds_debug_$switch (19)),
  9    82          db_mu_open_iocb_manager bit (9) unal defined (mrds_debug_$switch (20)),
  9    83          db_mrds_dsl_gen_srch_prog bit (9) unal defined (mrds_debug_$switch (21))
  9    84          ) ;
  9    85 
  9    86 /* list of known module names, with index into name array
  9    87*   the same as that into mrds_debug_$switch,
  9    88*   number is the current count of defined module names,
  9    89*   name is the modules full name. */
  9    90 
  9    91 declare 1 module options (constant) internal static,
  9    92         2 number fixed bin init (21),
  9    93         2 name char (32) dimension (21) init (
  9    94          "mrds_dsl_eval_expr",			/* 1 => display value of each expression */
  9    95          "mrds_dsl_get_token",			/* 1 => display the current token */
  9    96          "mrds_dsl_permute",				/* each 1 => lost cost path found,
  9    97*						   2 => reverse partial path
  9    98*						   3 => use range order for path
  9    99*						   4 => display access method costs
  9   100*						   5 => display details of final low cost path */
  9   101          "mrds_dsl_optimize",				/* 1 => pred tree,
  9   102*						   2 => paths to consider, 3 => calc_cost on */
  9   103          "mrds_dsl_search",				/* 1 => display each tuple located */
  9   104          "mrds_dsl_translate",			/* 1 => display the search program */
  9   105          "mu_retrieve",				/* 1 => display values compared, 2 => display tuple data */
  9   106          "mrds_dsl_open",				/* 1 => allow cleanup sub_error_ */
  9   107          "mrds_dsl_close",				/* 1 => allow cleanup sub_error_ */
  9   108          "mrds_dsl_init_res",				/* 1 => allow cleanup sub_error_ */
  9   109          "mu_sec_init_res",				/* 1 => allow cleanup sub_error_ */
  9   110          "mus_mod_ubtup",				/* 1 => consistency checking between the old
  9   111*						   and new tuple during modifies will be done */
  9   112          "mu_sec_get_tuple",				/* 1 => attribute values
  9   113*						   will be zeroed in the tuple structure
  9   114*						   is don't have read permission. */
  9   115          "mu_sec_get_tid",				/* 1 => read permission to the key
  9   116*						   is checked (if db is secured) */
  9   117          "mrds_dsl_set_fscope",			/* 1 => display being queued,
  9   118*						   and request granted from queue messages */
  9   119          "mu_concurrency_control",			/* 1 => allow both dbc and db.control segs under db
  9   120*						   so can test both MR8 and MR9 mrds
  9   121*						   against the same database at the same time */
  9   122          "mrds_rst_dmdm",				/* 1 => allow internal form of bit offset value
  9   123*						   for attributes to be displayed, rather than user view */
  9   124          "mu_open_name_manager",			/* 1 => dump mrds_open_name tree node structure,
  9   125*						   when display_open_names entry called */
  9   126          "mrds_dsl_where_clause",			/* 1 => display details of cross domain compares */
  9   127          "mu_open_iocb_manager",			/* 1 => display relation and slot getting iocb for */
  9   128          "mrds_dsl_gen_srch_prog"			/* 1 => do additional conditions as sequential, not key searches
  9   129*						   when the original access was a key,
  9   130*						   and the additional conditions can be done as key also
  9   131*						   2 => force key searches, regardless of strategy
  9   132*						   used to decide between compare or key search */
  9   133          ) ;
  9   134 
  9   135 declare  mrds_debug_$switch (1:400) bit (9) unal ext ;	/* data segment debug array */
  9   136 
  9   137 /* END INCLUDE FILE mrds_debug_names.incl.pl1 */
  9   138 
      918 
      919 
      920      end mrds_dsl_open;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/01/88  1315.0  mrds_dsl_open.pl1                 >special_ldd>install>MR12.2-1073>mrds_dsl_open.pl1
902          1    10/14/83  1608.6  mdbm_descriptor.incl.pl1          >ldd>include>mdbm_descriptor.incl.pl1
904          2    10/14/83  1608.6  mrds_opening_modes_.incl.pl1      >ldd>include>mrds_opening_modes_.incl.pl1
906          3    10/14/83  1608.7  mrds_new_scope_modes.incl.pl1     >ldd>include>mrds_new_scope_modes.incl.pl1
908          4    10/14/83  1609.0  mdbm_arg_list.incl.pl1            >ldd>include>mdbm_arg_list.incl.pl1
910          5    08/01/88  1300.0  mrds_dbcb.incl.pl1                >special_ldd>install>MR12.2-1073>mrds_dbcb.incl.pl1
912          6    11/24/86  1226.9  definition.incl.pl1               >ldd>include>definition.incl.pl1
914          7    10/14/83  1609.0  mdbm_dbc.incl.pl1                 >ldd>include>mdbm_dbc.incl.pl1
916          8    10/14/83  1608.8  mrds_path_info.incl.pl1           >ldd>include>mrds_path_info.incl.pl1
918          9    10/14/83  1609.0  mrds_debug_names.incl.pl1         >ldd>include>mrds_debug_names.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ALL_OPS                                constant        fixed bin(17,0)          initial dcl 3-18 ref 533
CHAR_NONVAR                     000373 automatic       fixed bin(17,0)          initial dcl 854 set ref 347 854*
DIRECTORY                       000361 automatic       fixed bin(17,0)          initial dcl 839 set ref 839*
DIRECTORY_BIT_COUNT             000363 automatic       fixed bin(17,0)          initial dcl 841 set ref 841*
EXCLUSIVE_RETRIEVAL                    constant        fixed bin(35,0)          initial dcl 2-15 ref 484 527
EXCLUSIVE_UPDATE                       constant        fixed bin(35,0)          initial dcl 2-15 ref 473
LINK                            000362 automatic       fixed bin(17,0)          initial dcl 840 set ref 840*
MODEL_SUFFIX                    000137 automatic       char(3)                  initial packed unaligned dcl 826 set ref 826*
OFF                             000125 automatic       bit(1)                   initial packed unaligned dcl 814 set ref 256 305 325
                                                                                  563 714 814*
READ_ATTR                              constant        fixed bin(17,0)          initial dcl 3-18 ref 529
RETRIEVAL                              constant        fixed bin(35,0)          initial dcl 2-15 ref 473 484
SEGMENT                         000360 automatic       fixed bin(17,0)          initial dcl 838 set ref 838*
SPECIAL                         000371 automatic       fixed bin(17,0)          initial dcl 852 set ref 274 852*
SUBMODEL_SUFFIX                 000141 automatic       char(4)                  initial packed unaligned dcl 828 set ref 828*
UPDATE                                 constant        fixed bin(35,0)          initial dcl 2-15 ref 525
UPDATE_OPS                             constant        fixed bin(17,0)          initial dcl 3-18 ref 530
abs_path                        005302 automatic       char(168)                packed unaligned dcl 859 set ref 372* 378 380 388
                                                                                  400* 423* 440* 464* 476* 504* 542* 641* 657
absolute_path             1            based           char(168)                level 2 dcl 8-22 ref 372
add_epilogue_handler_           000012 constant        entry                    external dcl 776 ref 304
addr                                                   builtin function         dcl 772 ref 340 409 409 432 432 432 432 458 458 495
administrator                   005357 automatic       bit(1)                   packed unaligned dcl 863 set ref 502 598*
al_ptr                          005616 automatic       pointer                  dcl 4-13 set ref 262* 263 267 274 278 288 346 357
                                                                                  432 432 458 595
area_ptr                        000374 automatic       pointer                  dcl 857 set ref 254* 340* 367* 458*
arg_count                       000134 automatic       fixed bin(17,0)          dcl 823 in procedure "open" set ref 336* 342 346 350
                                                                                  357 362 451* 451 458 595
arg_count                              based           fixed bin(17,0)          level 2 in structure "arg_list" packed packed
                                                                                  unaligned dcl 4-6 in procedure "open" ref 267
arg_des_ptr               2            based           pointer                  array level 2 dcl 4-6 set ref 278 288 346 357 432*
                                                                                  432* 458* 595
arg_list                               based           structure                level 1 unaligned dcl 4-6
bit_3                     0(33)        based           bit(3)                   level 2 packed packed unaligned dcl 892 ref 495
caller_name                     000114 automatic       char(15)                 initial packed unaligned dcl 809 set ref 267* 281*
                                                                                  294* 308* 350* 382* 390* 409* 423* 440* 464* 476*
                                                                                  508* 542* 568* 641* 704* 809*
chase                           000136 automatic       fixed bin(1,0)           initial dcl 825 set ref 825*
clean_up_condition              000135 automatic       bit(1)                   packed unaligned dcl 824 set ref 256* 318* 689 704
cleanup                         000106 stack reference condition                dcl 770 ref 316
close_index                     000367 automatic       fixed bin(35,0)          dcl 846 set ref 701* 703* 704* 734* 737* 745*
code                      0(18)        based           fixed bin(17,0)          level 2 in structure "arg_list" packed packed
                                                                                  unaligned dcl 4-6 in procedure "open" ref 274
code                            000102 automatic       fixed bin(35,0)          dcl 759 in procedure "open" set ref 266* 267* 280*
                                                                                  281* 289* 458* 461 463 464* 620* 621 623 628 635
                                                                                  635
continue                        000120 automatic       char(1)                  initial packed unaligned dcl 810 set ref 267* 281*
                                                                                  294* 308* 350* 382* 390* 409* 423* 440* 464* 476*
                                                                                  508* 542* 568* 641* 704* 810*
cu_$arg_list_ptr                000014 constant        entry                    external dcl 778 ref 262
current_number_of_openings      000143 automatic       fixed bin(17,0)          dcl 830 set ref 559* 563 568*
data                                   based           structure                level 2 dcl 5-142
data_model_ptr                  005464 automatic       pointer                  dcl 881 set ref 400* 401 404*
db_index                        000101 automatic       fixed bin(35,0)          dcl 758 set ref 418* 432 432 499* 537* 598* 603 659
db_mrds_dsl_open                       defined         bit(9)                   packed unaligned dcl 9-62 ref 691 726
db_open                                based           structure                level 1 dcl 815 set ref 655
dbc                                    based           structure                level 1 unaligned dcl 7-14
dbc_ptr                  30            based           pointer                  level 3 in structure "dbcb" dcl 5-142 in procedure
                                                                                  "open" ref 611
dbc_ptr                         005624 automatic       pointer                  initial dcl 7-44 in procedure "open" set ref 7-44*
                                                                                  611* 619 626 631
dbcb                                   based           structure                level 1 dcl 5-142
dbcb_data                              based           structure                level 1 unaligned dcl 5-148
dbcb_ptr                        005622 automatic       pointer                  dcl 5-146 set ref 495 497 504* 598* 611 737* 741
dbi_arg_count                   005362 automatic       fixed bin(17,0)          dcl 878 set ref 362* 432 432
desc_count                1            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 4-6 ref 263
desc_index                      000372 automatic       fixed bin(17,0)          dcl 853 set ref 274* 276* 277 278 346 432 595
desc_ptr                        005612 automatic       pointer                  dcl 1-19 set ref 278* 279 346* 347 358 458* 595*
descriptor                             based           structure                level 1 unaligned dcl 1-6
descriptor_ovrly                       based           bit(36)                  packed unaligned dcl 849 ref 279
discard_code                    000364 automatic       fixed bin(35,0)          dcl 843 set ref 703* 704 704* 745*
divide                                                 builtin function         dcl 772 ref 263 561
dsm_sw                          000104 automatic       bit(1)                   packed unaligned dcl 768 in procedure "open" set ref
                                                                                  398* 416* 502 598* 658
dsm_sw                   52            based           bit(1)                   level 2 in structure "db_open" dcl 815 in procedure
                                                                                  "open" set ref 658*
empty                                                  builtin function         dcl 772 ref 858
error_code                             based           fixed bin(35,0)          dcl 813 set ref 289* 293* 294* 304* 305 308* 349*
                                                                                  350* 367* 374 376 382* 385 390* 400* 403* 408*
                                                                                  409* 409 409 411 422* 423* 432* 438 440* 463* 475*
                                                                                  476* 499* 500 504* 506 508* 511* 537* 540 542*
                                                                                  567* 568* 598* 608 625* 631* 633* 635* 639 641*
error_code_ptr                  000356 automatic       pointer                  dcl 836 set ref 288* 289 293 294 304 305 308 349 350
                                                                                  367 374 376 382 385 390 400 403 408 409 409 409
                                                                                  411 422 423 432 438 440 463 475 476 499 500 504
                                                                                  506 508 511 537 540 542 567 568 598 608 625 631
                                                                                  633 635 639 641
error_message                   005363 automatic       char(256)                packed unaligned dcl 880 set ref 378* 380* 382* 388*
                                                                                  390*
error_table_$bad_arg            000054 external static fixed bin(35,0)          dcl 855 ref 280 349 475
error_table_$invalid_lock_reset 000024 external static fixed bin(35,0)          dcl 789 ref 623
error_table_$lock_wait_time_exceeded
                                000030 external static fixed bin(35,0)          dcl 791 ref 628
error_table_$locked_by_this_process
                                000026 external static fixed bin(35,0)          dcl 790 ref 635
error_table_$noarg              000070 external static fixed bin(35,0)          dcl 879 ref 422
error_table_$wrong_no_of_args   000050 external static fixed bin(35,0)          dcl 837 ref 266
first_time                      000011 internal static bit(1)                   initial packed unaligned dcl 766 set ref 302 305*
fixed                                                  builtin function         dcl 772 ref 358
fixed_bin_35_descr              000370 automatic       bit(36)                  initial packed unaligned dcl 850 set ref 279 432 432
                                                                                  458 458 850*
flags                     4            based           structure                level 3 packed packed unaligned dcl 7-14
hcs_$initiate                   000072 constant        entry                    external dcl 882 ref 400
incon_message                   005466 automatic       char(200)                packed unaligned dcl 883 set ref 404* 409*
incon_name                      005550 automatic       char(32)                 packed unaligned dcl 884 set ref 404* 409*
incon_sw                        005560 automatic       bit(1)                   packed unaligned dcl 885 set ref 404* 406
incon_undo_request              005561 automatic       char(100)                packed unaligned dcl 886 set ref 404*
index                    53            based           fixed bin(35,0)          level 2 dcl 815 set ref 659* 701
info_ptr                        000122 automatic       pointer                  initial dcl 811 set ref 267* 281* 294* 308* 350*
                                                                                  382* 390* 423* 440* 464* 476* 508* 542* 568* 641*
                                                                                  704* 811*
last_open_index_ptr             000132 automatic       pointer                  dcl 822 set ref 667* 670 671*
max_opening_overflow            005660 automatic       bit(1)                   packed unaligned dcl 580 set ref 563* 566* 577
mdbm_util_$inconsistent_get_info
                                000076 constant        entry                    external dcl 888 ref 404
mod                                                    builtin function         dcl 772 ref 420
mode_ovrly                             based           structure                level 1 packed packed unaligned dcl 892
model                    53(01)        based           bit(1)                   level 3 packed packed unaligned dcl 8-22 ref 378 396
mrds_data_$max_dbs              000044 external static fixed bin(17,0)          dcl 806 set ref 563 568* 734
mrds_debug_$switch              000110 external static bit(9)                   array packed unaligned dcl 9-135 ref 691 691 726 726
mrds_dsl_close                  000016 constant        entry                    external dcl 782 ref 703 745
mrds_dsl_create_res_copy$db_already_open
                                000060 constant        entry                    external dcl 867 ref 504
mrds_dsl_get_version$get_path_info_and_view_name
                                000106 constant        entry                    external dcl 898 ref 367
mrds_dsl_init_res               000022 constant        entry                    external dcl 782 ref 598
mrds_dsl_ready_all              000056 constant        entry                    external dcl 864 ref 499
mrds_dsl_set_fscope$set_fscope_all
                                000062 constant        entry                    external dcl 868 ref 537
mrds_error_$inconsistent_database
                                000074 external static fixed bin(35,0)          dcl 887 ref 408
mrds_error_$no_database         000102 external static fixed bin(35,0)          dcl 890 ref 385
mrds_error_$no_model_access     000100 external static fixed bin(35,0)          dcl 889 ref 376
mrds_error_$no_recursion        000032 external static fixed bin(35,0)          dcl 795 ref 293
mrds_error_$quiesce_pending     000042 external static fixed bin(35,0)          dcl 802 ref 633
mrds_error_$quiesced_db         000036 external static fixed bin(35,0)          dcl 800 ref 631
mrds_error_$quiesced_dead_db    000040 external static fixed bin(35,0)          dcl 801 ref 625
mrds_error_$too_many_dbs        000034 external static fixed bin(35,0)          dcl 795 ref 567
mrds_path_info                         based           structure                level 1 dcl 8-22
mrds_path_info_ptr              005626 automatic       pointer                  dcl 8-36 set ref 367* 372 378 396
mrds_path_info_structure_version
                                000062 constant        fixed bin(17,0)          initial dcl 8-38 set ref 367*
mu_convert_parameter$convert_input_parameter
                                000064 constant        entry                    external dcl 874 ref 458
mu_convert_parameter$convert_output_parameter
                                000066 constant        entry                    external dcl 876 ref 432
mu_database_index$get_number_open_dbs
                                000020 constant        entry                    external dcl 782 ref 559 731
mu_database_index$get_resultant_model_pointer
                                000052 constant        entry                    external dcl 847 ref 737
nargs                           000103 automatic       fixed bin(17,0)          dcl 761 set ref 263* 265 274 276 277 278 288 342 420
                                                                                  561
next                     54            based           pointer                  level 2 dcl 815 set ref 660* 670* 700
null                                                   builtin function         dcl 772 ref 254 257 811 7-44 401 660 664 695 697 711
                                                                                  741
num_dims                        005614 automatic       fixed bin(17,0)          initial dcl 1-20 set ref 258* 1-20*
num_ptrs                        005620 automatic       fixed bin(17,0)          dcl 4-14 set ref 258* 277*
number_closed                   000365 automatic       fixed bin(17,0)          dcl 844 set ref 733* 734 746* 746
number_of_openings              000366 automatic       fixed bin(17,0)          dcl 845 set ref 731* 734
number_of_requests              000144 automatic       fixed bin(17,0)          dcl 831 set ref 561* 563 568*
open_index_list_ptr             000130 automatic       pointer                  dcl 821 set ref 257* 664 666* 695 697 711*
open_index_ptr                  000126 automatic       pointer                  dcl 820 set ref 655* 657 658 659 660 666 667 670 671
                                                                                  697* 697* 700 701*
open_mode               106(14)        based           bit(3)                   level 3 packed packed unaligned dcl 5-142 set ref
                                                                                  495*
path                                   based           char(168)                level 2 dcl 815 set ref 657*
permit_operations               005360 automatic       fixed bin(17,0)          dcl 870 set ref 529* 533* 534 537*
prevent_operations              005361 automatic       fixed bin(17,0)          dcl 871 set ref 530* 534* 537*
previous_invocation             000010 internal static bit(1)                   initial packed unaligned dcl 764 set ref 291 300*
                                                                                  325* 714*
proper                                 based           structure                level 2 unaligned dcl 7-14
quiesce_lock              5            based           bit(36)                  level 3 dcl 7-14 ref 619
quiesce_lock_copy               005670 automatic       bit(36)                  dcl 593 set ref 619* 620*
quiesce_sw                4(02)        based           bit(1)                   level 4 packed packed unaligned dcl 7-14 ref 631
ready_mode                      005356 automatic       fixed bin(17,0)          dcl 862 set ref 484* 486* 499* 598*
res_already_made        106(21)        based           bit(1)                   level 3 packed packed unaligned dcl 5-142 ref 497
return_value                    000124 automatic       fixed bin(35,0)          initial dcl 812 set ref 267* 281* 294* 308* 350*
                                                                                  382* 390* 409* 423* 440* 464* 476* 508* 542* 568*
                                                                                  641* 704* 812*
reversed_MODEL_SUFFIX           000140 automatic       char(3)                  initial packed unaligned dcl 827 set ref 827*
reversed_SUBMODEL_SUFFIX        000142 automatic       char(4)                  initial packed unaligned dcl 829 set ref 829*
saved_ptr                       000100 automatic       pointer                  dcl 716 set ref 700* 709
set_lock_$lock                  000104 constant        entry                    external dcl 897 ref 620
size                      0(12)        based           structure                level 2 packed packed unaligned dcl 1-6 ref 358
string                                                 builtin function         dcl 772 ref 358
sub_err_                        000046 constant        entry                    external dcl 808 ref 267 281 294 308 350 382 390 409
                                                                                  423 440 464 476 508 542 568 641 704
sub_error_                      000000 stack reference condition                dcl 754 ref 691 728
substr                                                 builtin function         dcl 772 ref 691 726
trouble_switch            4            based           bit(1)                   level 4 packed packed unaligned dcl 7-14 set ref
                                                                                  626*
type                      0(01)        based           fixed bin(6,0)           level 2 in structure "descriptor" packed packed
                                                                                  unsigned unaligned dcl 1-6 in procedure "open" ref
                                                                                  347
type                     53            based           structure                level 2 in structure "mrds_path_info" dcl 8-22
                                                                                  in procedure "open"
usage_mode                             based           fixed bin(35,0)          dcl 860 set ref 473 473 476* 484 484 495 525 527
                                                                                  542*
usage_mode_ptr                  005354 automatic       pointer                  dcl 861 set ref 458* 473 473 476 484 484 495 525 527
                                                                                  542
view_dir                        000150 automatic       char(500)                packed unaligned dcl 834 set ref 367* 598*
view_entry                      000345 automatic       char(32)                 packed unaligned dcl 835 set ref 367* 598*
view_path                              based           char                     packed unaligned dcl 833 set ref 367*
view_path_len                   000100 automatic       fixed bin(17,0)          dcl 756 set ref 358* 367 367
view_path_ptr                   000146 automatic       pointer                  dcl 832 set ref 357* 367
wait_sec                        000000 constant        fixed bin(35,0)          initial dcl 872 set ref 537*
work_area                       000376 automatic       area(2500)               dcl 858 set ref 340 655 858*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
APPEND_TUPLE                           internal static fixed bin(17,0)          initial dcl 3-18
DELETE_TUPLE                           internal static fixed bin(17,0)          initial dcl 3-18
MODIFY_ATTR                            internal static fixed bin(17,0)          initial dcl 3-18
NO_OP                                  internal static fixed bin(17,0)          initial dcl 3-18
VERSION_NBR                            internal static fixed bin(17,0)          initial dcl 7-46
db_mrds_dsl_close                      defined         bit(9)                   packed unaligned dcl 9-62
db_mrds_dsl_eval_expr                  defined         bit(9)                   packed unaligned dcl 9-62
db_mrds_dsl_gen_srch_prog              defined         bit(9)                   packed unaligned dcl 9-62
db_mrds_dsl_get_token                  defined         bit(9)                   packed unaligned dcl 9-62
db_mrds_dsl_init_res                   defined         bit(9)                   packed unaligned dcl 9-62
db_mrds_dsl_optimize                   defined         bit(9)                   packed unaligned dcl 9-62
db_mrds_dsl_permute                    defined         bit(9)                   packed unaligned dcl 9-62
db_mrds_dsl_search                     defined         bit(9)                   packed unaligned dcl 9-62
db_mrds_dsl_set_fscope                 defined         bit(9)                   packed unaligned dcl 9-62
db_mrds_dsl_translate                  defined         bit(9)                   packed unaligned dcl 9-62
db_mrds_dsl_where_clause               defined         bit(9)                   packed unaligned dcl 9-62
db_mrds_rst_dmdm                       defined         bit(9)                   packed unaligned dcl 9-62
db_mu_concurrency_control              defined         bit(9)                   packed unaligned dcl 9-62
db_mu_open_iocb_manager                defined         bit(9)                   packed unaligned dcl 9-62
db_mu_open_name_manager                defined         bit(9)                   packed unaligned dcl 9-62
db_mu_retrieve                         defined         bit(9)                   packed unaligned dcl 9-62
db_mu_sec_get_tid                      defined         bit(9)                   packed unaligned dcl 9-62
db_mu_sec_get_tuple                    defined         bit(9)                   packed unaligned dcl 9-62
db_mu_sec_init_res                     defined         bit(9)                   packed unaligned dcl 9-62
db_mus_mod_ubtup                       defined         bit(9)                   packed unaligned dcl 9-62
definition                             based           structure                level 1 dcl 6-12
module                                 internal static structure                level 1 unaligned dcl 9-91
rel                                                    builtin function         dcl 772
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 807

NAMES DECLARED BY EXPLICIT CONTEXT.
clean_up                        003604 constant        entry                    internal dcl 683 ref 319 677
common                          001016 constant        label                    dcl 254 ref 30
error_exit                      003575 constant        entry                    internal dcl 675 ref 271 285 298 312 354 393 411 427
                                                                                  446 468 481 500 547 574 608 644
exit_mrds_dsl_open              001462 constant        label                    dcl 327 ref 679
finish_handler                  003763 constant        entry                    internal dcl 720 ref 34
finish_handler_entry            001003 constant        entry                    external dcl 32 ref 304 304
get_usage_and_ready_modes       002450 constant        entry                    internal dcl 456 ref 596
mrds_dsl_open                   000773 constant        entry                    external dcl 27
open                            000763 constant        entry                    external dcl 27
open_new_version                003341 constant        entry                    internal dcl 584 ref 430
process_path_index_pairs        001463 constant        entry                    internal dcl 330 ref 322
process_usage_mode              002725 constant        entry                    internal dcl 492 ref 431
save_index_of_opening           003543 constant        entry                    internal dcl 649 ref 603
too_many_open                   003205 constant        entry                    internal dcl 552 ref 322

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4660        4772    4114        4670
Length      5450    4114       112         442     544           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
open                               3668 external procedure  is an external procedure.  
on unit on line 316                  64 on unit               
process_path_index_pairs                internal procedure  shares stack frame of external procedure open.  
get_usage_and_ready_modes               internal procedure  shares stack frame of external procedure open.  
process_usage_mode                      internal procedure  shares stack frame of external procedure open.  
too_many_open                           internal procedure  shares stack frame of external procedure open.  
open_new_version                        internal procedure  shares stack frame of external procedure open.  
save_index_of_opening                   internal procedure  shares stack frame of external procedure open.  
error_exit                              internal procedure  shares stack frame of external procedure open.  
clean_up                            130 internal procedure  enables or reverts conditions.  
on unit on line 691                  64 on unit               
finish_handler                       92 internal procedure  enables or reverts conditions.  
on unit on line 728                  64 on unit               

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 previous_invocation         open
000011 first_time                  open

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
clean_up                 000100 saved_ptr                   clean_up
open                     000100 view_path_len               open
                         000101 db_index                    open
                         000102 code                        open
                         000103 nargs                       open
                         000104 dsm_sw                      open
                         000114 caller_name                 open
                         000120 continue                    open
                         000122 info_ptr                    open
                         000124 return_value                open
                         000125 OFF                         open
                         000126 open_index_ptr              open
                         000130 open_index_list_ptr         open
                         000132 last_open_index_ptr         open
                         000134 arg_count                   open
                         000135 clean_up_condition          open
                         000136 chase                       open
                         000137 MODEL_SUFFIX                open
                         000140 reversed_MODEL_SUFFIX       open
                         000141 SUBMODEL_SUFFIX             open
                         000142 reversed_SUBMODEL_SUFFIX    open
                         000143 current_number_of_openings  open
                         000144 number_of_requests          open
                         000146 view_path_ptr               open
                         000150 view_dir                    open
                         000345 view_entry                  open
                         000356 error_code_ptr              open
                         000360 SEGMENT                     open
                         000361 DIRECTORY                   open
                         000362 LINK                        open
                         000363 DIRECTORY_BIT_COUNT         open
                         000364 discard_code                open
                         000365 number_closed               open
                         000366 number_of_openings          open
                         000367 close_index                 open
                         000370 fixed_bin_35_descr          open
                         000371 SPECIAL                     open
                         000372 desc_index                  open
                         000373 CHAR_NONVAR                 open
                         000374 area_ptr                    open
                         000376 work_area                   open
                         005302 abs_path                    open
                         005354 usage_mode_ptr              open
                         005356 ready_mode                  open
                         005357 administrator               open
                         005360 permit_operations           open
                         005361 prevent_operations          open
                         005362 dbi_arg_count               open
                         005363 error_message               open
                         005464 data_model_ptr              open
                         005466 incon_message               open
                         005550 incon_name                  open
                         005560 incon_sw                    open
                         005561 incon_undo_request          open
                         005612 desc_ptr                    open
                         005614 num_dims                    open
                         005616 al_ptr                      open
                         005620 num_ptrs                    open
                         005622 dbcb_ptr                    open
                         005624 dbc_ptr                     open
                         005626 mrds_path_info_ptr          open
                         005660 max_opening_overflow        too_many_open
                         005670 quiesce_lock_copy           open_new_version

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac
mdfx1               enable_op           shorten_stack       ext_entry           int_entry           divide_fx1
op_alloc_           op_empty_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
add_epilogue_handler_         cu_$arg_list_ptr              hcs_$initiate
mdbm_util_$inconsistent_get_info                            mrds_dsl_close
mrds_dsl_create_res_copy$db_already_open                    mrds_dsl_get_version$get_path_info_and_view_name
mrds_dsl_init_res             mrds_dsl_ready_all            mrds_dsl_set_fscope$set_fscope_all
mu_convert_parameter$convert_input_parameter                mu_convert_parameter$convert_output_parameter
mu_database_index$get_number_open_dbs                       mu_database_index$get_resultant_model_pointer
set_lock_$lock                sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$invalid_lock_reset
error_table_$lock_wait_time_exceeded                        error_table_$locked_by_this_process
error_table_$noarg            error_table_$wrong_no_of_args mrds_data_$max_dbs            mrds_debug_$switch
mrds_error_$inconsistent_database                           mrds_error_$no_database       mrds_error_$no_model_access
mrds_error_$no_recursion      mrds_error_$quiesce_pending   mrds_error_$quiesced_db       mrds_error_$quiesced_dead_db
mrds_error_$too_many_dbs




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    809 000713       810 000716       811 000720       812 000722       814 000723       825 000724       826 000726
    827 000730       828 000732       829 000734       838 000736       839 000740       840 000742       841 000743
    850 000744       852 000746       854 000750       858 000752    1   20 000755    7   44 000756        27 000762
     30 001001        32 001002        34 001011        36 001015       254 001016       256 001020       257 001022
    258 001024       262 001026       263 001035       265 001042       266 001044       267 001047       271 001146
    274 001147       276 001160       277 001162       278 001164       279 001172       280 001176       281 001201
    285 001245       288 001246       289 001253       291 001255       293 001260       294 001262       298 001326
    300 001327       302 001332       304 001334       305 001350       308 001356       312 001423       316 001424
    318 001440       319 001443       320 001450       322 001451       325 001457       327 001462       330 001463
    336 001464       340 001466       342 001470       346 001473       347 001500       349 001505       350 001510
    354 001600       357 001601       358 001606       362 001611       367 001614       372 001657       374 001663
    376 001665       378 001670       380 001707       382 001723       384 001757       385 001760       388 001762
    390 001775       393 002031       396 002032       398 002036       400 002037       401 002104       403 002110
    404 002111       406 002142       408 002145       409 002150       411 002217       415 002222       416 002223
    418 002225       420 002226       422 002233       423 002236       427 002314       430 002315       431 002316
    432 002317       438 002350       440 002352       446 002443       451 002444       452 002446       454 002447
    456 002450       458 002451       461 002477       463 002501       464 002502       468 002562       473 002563
    475 002570       476 002573       481 002711       484 002712       486 002722       488 002724       492 002725
    495 002726       497 002734       499 002737       500 002752       502 002755       504 002763       506 002776
    508 003000       511 003037       525 003040       527 003043       529 003045       530 003047       531 003051
    533 003052       534 003054       537 003055       540 003103       542 003105       547 003203       550 003204
    552 003205       559 003207       561 003216       563 003222       566 003231       567 003233       568 003235
    574 003332       577 003333       584 003341       595 003342       596 003350       598 003351       603 003414
    608 003417       611 003422       619 003425       620 003427       621 003443       623 003445       625 003450
    626 003452       627 003455       628 003456       631 003460       633 003467       634 003471       635 003472
    639 003475       641 003477       644 003541       647 003542       649 003543       655 003544       657 003551
    658 003554       659 003557       660 003561       664 003563       666 003566       667 003567       668 003570
    670 003571       671 003573       673 003574       675 003575       677 003576       679 003602       683 003603
    689 003611       691 003614       695 003635       697 003642       700 003651       701 003654       703 003657
    704 003673       709 003750       711 003754       714 003756       718 003761       720 003762       726 003770
    728 003775       731 004012       733 004022       734 004024       737 004041       741 004052       745 004060
    746 004074       750 004076       752 004103


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
