	COMPILATION LISTING OF SEGMENT im_split
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/04/85  0926.4 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* DESCRIPTION:
        8*
        9*          This module splits the "old" control interval (identified by
       10*     p_old_ci).  A new control interval is allocated which becomes the "old"
       11*     control interval's new "left" sibling in the index.  This is referred to
       12*     as the "new" control interval and its identifier is placed in p_new_ci. 
       13*
       14*          It is necessary to get the "old" control interval's original "left"
       15*     sibling to update the doubly threaded list of siblings. The
       16*     index_header's count of control intervals is also updated.
       17**/
       18 
       19 /* HISTORY:
       20*
       21*Written by Lindsey Spratt, 04/21/82.
       22*Modified:
       23*06/16/82 by Matthew Pierret: Removed the beginning_offset argument from
       24*            calls to collection_manager_$put_element.
       25*08/09/82 by Matthew Pierret: Removed offset and length arguments from calls to
       26*            collection_manager_$get_element.
       27*08/11/82 by Matthew Pierret:  Changed to use the aligned new_ci variable in the
       28*            calling sequence to collection_manager_$allocate_control_interval.
       29*05/10/84 by Matthew Pierret:  Changed to align key_buffer on an even-word
       30*            boundary.
       31*06/07/84 by Matthew Pierret:  Re-named cm_$get_element to cm_$get,
       32*            cm_$put_element to cm_$modify, cm_$allocate_element to cm_$put.
       33*10/28/84 by Lindsey L. Spratt:  Changed to use version 2 of
       34*            index_opening_info.  Changed to base old_common_ci_header and
       35*            new_common_ci_header on automatic pointers instead of directly on
       36*            parameters.
       37*03/07/85 by R. Michael Tague:  Changed opening info version to version 3.
       38**/
       39 
       40 /* format: style2,ind3 */
       41 
       42 im_split:
       43    proc (p_index_opening_info_ptr, p_old_common_ci_header_ptr, p_old_ci, p_new_common_ci_header_ptr, p_new_ci, p_code);
       44 
       45 /* START OF DECLARATIONS */
       46 /* Parameter */
       47 
       48       dcl	    p_index_opening_info_ptr
       49 			       ptr parameter;
       50       dcl	    p_old_common_ci_header_ptr
       51 			       ptr;
       52       dcl	    p_old_ci	       fixed bin (24) unsigned unaligned;
       53       dcl	    p_new_common_ci_header_ptr
       54 			       ptr;
       55       dcl	    p_new_ci	       fixed bin (24) unsigned unaligned;
       56       dcl	    p_code	       fixed bin (35);
       57 
       58 /* Automatic */
       59 
       60       dcl	    key_buffer	       (DOUBLE_WORDS_PER_PAGE) fixed bin (71);
       61       dcl	    key_buffer_length      fixed bin (35) init (BITS_PER_PAGE);
       62       dcl	    key_length	       fixed bin (35);
       63       dcl	    new_ci	       fixed bin (24) unsigned;
       64       dcl	    new_common_ci_header_ptr
       65 			       ptr init (null);
       66       dcl	    old_common_ci_header_ptr
       67 			       ptr init (null);
       68       dcl	    prev_ci	       fixed bin (24) unsigned unaligned;
       69 
       70       dcl	    1 local_leaf_ci_header like leaf_ci_header;
       71       dcl	    1 local_branch_ci_header
       72 			       like branch_ci_header;
       73       dcl	    splitting_leaf	       bit (1) aligned;
       74       dcl	    prev_common_header_ptr ptr;
       75 
       76 /* Based */
       77 
       78       dcl	    1 old_common_header    like common_ci_header based (old_common_ci_header_ptr);
       79       dcl	    1 new_common_header    like common_ci_header based (new_common_ci_header_ptr);
       80       dcl	    1 prev_common_header   like common_ci_header based (prev_common_header_ptr);
       81 
       82 /* Builtin */
       83 
       84       dcl	    null		       builtin;
       85       dcl	    (addr, length, unspec) builtin;
       86 
       87 /* Controlled */
       88 /* Constant */
       89 
       90       dcl	    BEGINNING_OF_ELEMENT   init (-1) fixed bin (35) internal static options (constant);
       91       dcl	    BITS_PER_PAGE	       init (36 * 1024) fixed bin (17) internal static options (constant);
       92       dcl	    DOUBLE_WORDS_PER_PAGE  init (512) fixed bin (17) internal static options (constant);
       93       dcl	    myname	       init ("im_split") char (32) varying internal static options (constant);
       94 
       95 
       96 /* Entry */
       97 
       98       dcl	    sub_err_	       entry () options (variable);
       99 
      100       dcl	    im_init_leaf_ci_header entry (ptr);
      101       dcl	    im_init_branch_ci_header
      102 			       entry (ptr);
      103 
      104 /* External */
      105 
      106       dcl	    error_table_$unimplemented_version
      107 			       fixed bin (35) ext;
      108 
      109 /* END OF DECLARATIONS */
      110 
      111       index_opening_info_ptr = p_index_opening_info_ptr;
      112       call CHECK_VERSION (index_opening_info.version, INDEX_OPENING_INFO_VERSION_3, "index_opening_info");
      113 
      114       old_common_ci_header_ptr = p_old_common_ci_header_ptr;
      115       new_common_ci_header_ptr = p_new_common_ci_header_ptr;
      116 
      117       splitting_leaf = old_common_header.is_leaf;
      118 
      119 /* Allocate a new control interval.  This is the new "left" sibling for p_old_ci. */
      120 
      121       call collection_manager_$allocate_control_interval (index_opening_info.file_opening_id,
      122 	 index_opening_info.collection_id, new_ci, p_code);
      123       if p_code ^= 0
      124       then return;
      125       else p_new_ci = new_ci;
      126 
      127 /* The header (leaf or branch) for the new ci must be initialized. */
      128 
      129       if splitting_leaf
      130       then call im_init_leaf_ci_header (p_new_common_ci_header_ptr);
      131       else call im_init_branch_ci_header (p_new_common_ci_header_ptr);
      132       new_common_header.key_range = 0;
      133 
      134 /* Thread in with siblings ("old" and "prev"). */
      135 
      136       new_common_header.previous_id = old_common_header.previous_id;
      137       new_common_header.next_id = p_old_ci;
      138       old_common_header.previous_id = p_new_ci;
      139       element_id.index = DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT;
      140       element_id.control_interval_id = p_new_ci;
      141       if splitting_leaf
      142       then call collection_manager_$put (index_opening_info.file_opening_id, index_opening_info.collection_id,
      143 	      p_new_common_ci_header_ptr, length (unspec (local_leaf_ci_header)), element_id_string, (0), p_code);
      144       else call collection_manager_$put (index_opening_info.file_opening_id, index_opening_info.collection_id,
      145 	      p_new_common_ci_header_ptr, length (unspec (local_branch_ci_header)), element_id_string, (0), p_code);
      146 
      147 /* Adjust the parent of the split node so the old pointer to the split node
      148*becomes a pointer to the new node (the split node's new left sibling).
      149**/
      150 
      151       if addr (old_common_header.parent_id_string) -> element_id.control_interval_id ^= 0
      152       then
      153          do;
      154 	  if addr (old_common_header.parent_id_string) -> element_id.index = 0
      155 	  then
      156 	     do;
      157 	        element_id_string = old_common_header.parent_id_string;
      158 	        element_id.index = DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT;
      159 	        call collection_manager_$get (index_opening_info.file_opening_id, index_opening_info.collection_id,
      160 		   element_id_string, 0, addr (local_branch_ci_header), length (unspec (local_branch_ci_header)),
      161 		   null, "0"b, branch_ci_header_ptr, 0, p_code);
      162 	        if p_code ^= 0
      163 	        then return;
      164 
      165 	        branch_ci_header.low_branch_id = p_new_ci;
      166 
      167 
      168 	        call collection_manager_$modify (index_opening_info.file_opening_id, index_opening_info.collection_id,
      169 		   branch_ci_header_ptr, length (unspec (local_branch_ci_header)), element_id_string, 0, p_code);
      170 	        if p_code ^= 0
      171 	        then return;
      172 	     end;
      173 	  else
      174 	     do;
      175 	        element_id_string = old_common_header.parent_id_string;
      176 	        call collection_manager_$get (index_opening_info.file_opening_id, index_opening_info.collection_id,
      177 		   element_id_string, 0, addr (key_buffer), key_buffer_length, null, "0"b, branch_key_ptr, key_length,
      178 		   p_code);
      179 	        if p_code ^= 0
      180 	        then return;
      181 
      182 	        bk_string_length = key_length - BRANCH_KEY_HEADER_LENGTH_IN_BITS;
      183 	        branch_key.branch_id = p_new_ci;
      184 
      185 	        call collection_manager_$modify (index_opening_info.file_opening_id, index_opening_info.collection_id,
      186 		   branch_key_ptr, key_length, element_id_string, 0, p_code);
      187 	        if p_code ^= 0
      188 	        then return;
      189 
      190 	     end;
      191          end;
      192 
      193 /* Pick up the "prev" (now the "new" node's "left" sibling) node's header.
      194*This is adjusted to complete the threading in of the "new" node. */
      195 
      196       prev_ci = new_common_header.previous_id;
      197       if prev_ci > 0
      198       then
      199          do;
      200 
      201 	  element_id.control_interval_id = prev_ci;
      202 	  element_id.index = DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT;
      203 
      204 	  if splitting_leaf
      205 	  then call collection_manager_$get (index_opening_info.file_opening_id, index_opening_info.collection_id,
      206 		  element_id_string, (0), addr (local_leaf_ci_header), length (unspec (local_leaf_ci_header)), null,
      207 		  "0"b, prev_common_header_ptr, (0), p_code);
      208 	  else call collection_manager_$get (index_opening_info.file_opening_id, index_opening_info.collection_id,
      209 		  element_id_string, (0), addr (local_branch_ci_header), length (unspec (local_branch_ci_header)),
      210 		  null, "0"b, prev_common_header_ptr, (0), p_code);
      211 	  prev_common_header.next_id = p_new_ci;
      212 	  if splitting_leaf
      213 	  then call collection_manager_$modify (index_opening_info.file_opening_id, index_opening_info.collection_id,
      214 		  prev_common_header_ptr, length (unspec (local_leaf_ci_header)), element_id_string, (0), p_code);
      215 	  else call collection_manager_$modify (index_opening_info.file_opening_id, index_opening_info.collection_id,
      216 		  prev_common_header_ptr, length (unspec (local_branch_ci_header)), element_id_string, (0), p_code);
      217          end;
      218 
      219       return;
      220 
      221 CHECK_VERSION:
      222    proc (p_received_version, p_expected_version, p_structure_name);
      223       dcl	    p_received_version     char (8) aligned parameter;
      224       dcl	    p_expected_version     char (8) aligned parameter;
      225       dcl	    p_structure_name       char (*);
      226 
      227       if p_received_version ^= p_expected_version
      228       then call sub_err_ (error_table_$unimplemented_version, myname, "s", null, 0,
      229 	      "^/Expected version ^d of the ^a structure.
      230 Received version ^d instead.", p_expected_version, p_structure_name, p_received_version);
      231 
      232    end CHECK_VERSION;
      233 
  1     1 /* BEGIN INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*     This include file contains declarations of all collection_manager_ 
  1     5*     entrypoints.
  1     6**/
  1     7 
  1     8 /* HISTORY:
  1     9*Written by Matthew Pierret 
  1    10*Modified:
  1    11*04/14/82 by Lindsey Spratt: Changed the control_interval_id parameter of the
  1    12*	  allocate_control_interval operation to be unaligned, as well as
  1    13*	  unsigned.
  1    14*06/17/82 by Matthew Pierret: Added the put_element_portion opertion and
  1    15*            removed the beginning_location parameter from the put_element
  1    16*            operation. Added the create_page_file_operation.
  1    17*08/09/82 by Matthew Pierret: Changed "fixed bin (17)"s to "bit (36) aligned"s
  1    18*            wherever collection_id was required.
  1    19*            Also changed the control_interval_id parameter of the 
  1    20*            allocate_control_interval operation back to be aligned. So there.
  1    21*10/20/82 by Matthew Pierret: Changed $create_page_file to $create_file,
  1    22*            added the argument file_create_info_ptr to $create_file.
  1    23*12/13/82 by Lindsey Spratt:  Corrected $free_control_interval to
  1    24*	  include the zero_on_free bit.
  1    25*12/17/82 by Matthew Pierret: Added cm_$get_id.
  1    26*01/07/83 by Matthew Pierret: Added cm_$put_element_buffered, 
  1    27*            cm_$allocate_element_buffered, cm_$free_element_buffered.
  1    28*04/27/83 by Matthew Pierret: Added cm_$put_unprotected_element,
  1    29*            cm_$put_unprotected_header.
  1    30*11/07/83 by Matthew Pierret: Added $get_element_portion_buffered,
  1    31*             $simple_get_buffered_element.
  1    32*02/08/84 by Matthew Pierret:  Changed $get_id to have only one bit(1)aligned
  1    33*            parameter for specifying absolute/relative nature of search.
  1    34*03/16/84 by Matthew Pierret:  Added cm_$get_control_interval_ptr,
  1    35*            $get_element_ptr, $get_element_portion_ptr, $simple_get_element_ptr
  1    36*04/03/84 by Matthew Pierret:  Added cm_$compact_control_interval.
  1    37*06/06/84 by Matthew Pierret:  Re-named free_element* to delete and
  1    38*            delete_from_ci_buffer.
  1    39*            Re-named *_buffered_ci to =_ci_buffer.
  1    40*            get entries.
  1    41*            modify entries.
  1    42*            Changed calling sequence of modify entries to have a ptr/length
  1    43*            instead of length/ptr parameter pair.
  1    44*03/11/85 by R. Michael Tague:  Added $postcommit_increments.
  1    45**/
  1    46 
  1    47 /* This include file contains declarations of collection_manager_ entrypoints */
  1    48 
  1    49 /* format: style2,ind3 */
  1    50      dcl	   collection_manager_$allocate_control_interval
  1    51 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
  1    52      dcl	   collection_manager_$compact_control_interval
  1    53 			      entry (bit (36) aligned, fixed bin (24) uns, fixed bin (35));
  1    54      dcl	   collection_manager_$create_collection
  1    55 			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  1    56      dcl	   collection_manager_$create_file
  1    57 			      entry (char (*), char (*), ptr, bit (36) aligned, fixed bin (35));
  1    58      dcl	   collection_manager_$destroy_collection
  1    59 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  1    60      dcl	   collection_manager_$free_control_interval
  1    61 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, bit (1) aligned,
  1    62 			      fixed bin (35));
  1    63 
  1    64      dcl	   collection_manager_$delete
  1    65 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  1    66 			      fixed bin (35));
  1    67      dcl	   collection_manager_$delete_from_ci_buffer
  1    68 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  1    69 			      fixed bin (35));
  1    70 
  1    71      dcl	   collection_manager_$get
  1    72 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  1    73 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  1    74      dcl	   collection_manager_$get_control_interval_ptr
  1    75 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, ptr,
  1    76 			      fixed bin (35));
  1    77      dcl	   collection_manager_$get_from_ci_buffer
  1    78 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  1    79 			      ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  1    80      dcl	   collection_manager_$get_by_ci_ptr
  1    81 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  1    82 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), ptr, fixed bin (35));
  1    83      dcl	   collection_manager_$get_header
  1    84 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (17), ptr, bit (1) aligned,
  1    85 			      ptr, fixed bin (35), fixed bin (35));
  1    86      dcl	   collection_manager_$get_id
  1    87 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17),
  1    88 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  1    89      dcl	   collection_manager_$get_portion
  1    90 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  1    91 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  1    92 			      fixed bin (35), fixed bin (35));
  1    93      dcl	   collection_manager_$get_portion_from_ci_buffer
  1    94 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  1    95 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  1    96 			      fixed bin (35));
  1    97      dcl	   collection_manager_$get_portion_by_ci_ptr
  1    98 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  1    99 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  1   100 			      fixed bin (35));
  1   101      dcl	   collection_manager_$modify
  1   102 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  1   103 			      fixed bin (35), fixed bin (35));
  1   104      dcl	   collection_manager_$modify_unprotected
  1   105 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  1   106 			      fixed bin (35), fixed bin (35));
  1   107      dcl	   collection_manager_$modify_in_ci_buffer
  1   108 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  1   109 			      fixed bin (35), fixed bin (35));
  1   110      dcl	   collection_manager_$modify_portion
  1   111 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35), ptr,
  1   112 			      fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  1   113      dcl	   collection_manager_$postcommit_increments
  1   114 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  1   115      dcl	   collection_manager_$put
  1   116 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  1   117 			      fixed bin (35), fixed bin (35));
  1   118      dcl	   collection_manager_$put_in_ci_buffer
  1   119 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  1   120 			      fixed bin (35), fixed bin (35));
  1   121      dcl	   collection_manager_$put_header
  1   122 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  1   123      dcl	   collection_manager_$put_unprotected_header
  1   124 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  1   125 
  1   126      dcl	   collection_manager_$replace_ci_buffer
  1   127 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  1   128 			      fixed bin (35));
  1   129      dcl	   collection_manager_$setup_ci_buffer
  1   130 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  1   131 			      fixed bin (35));
  1   132      dcl	   collection_manager_$simple_get_by_ci_ptr
  1   133 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  1   134 			      fixed bin (35));
  1   135      dcl	   collection_manager_$simple_get_from_ci_buffer
  1   136 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  1   137 			      fixed bin (35));
  1   138 
  1   139 /* END INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
      234 
      235 
  2     1 /* BEGIN INCLUDE FILE - dm_im_ci_header.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*          Each node (control interval) in the index has a header which
  2     6*     describes the contents of that node.  Although there are two different
  2     7*     kinds of headers, leaf and branch, they have a great deal in common, the
  2     8*     common_ci_header.  The common_ci_header states which slots are used by
  2     9*     the keys (leaf or branch) in the key_range substructure.  There is an
  2    10*     "upward pointer" to the node's parent branch key (parent_id_string).
  2    11*     There are pointers to the previous and next nodes (previous_id and
  2    12*     next_id) on the same level to facilitate rotation of keys, and sequential
  2    13*     searching.  There is also a count of how much space is in use by the keys.
  2    14*
  2    15**/
  2    16 
  2    17 /* HISTORY:
  2    18*
  2    19*Written by Lindsey Spratt, 03/29/82.
  2    20*Modified:
  2    21*10/25/84 by Lindsey L. Spratt:  Added a description and fixed the history
  2    22*            section format.
  2    23**/
  2    24 
  2    25 /* format: style2,ind3 */
  2    26      dcl	   1 common_ci_header     based (common_ci_header_ptr),
  2    27 	     2 flags	      unaligned,
  2    28 	       3 is_leaf	      bit (1) unaligned,	/* ON for leaf_ci, OFF for branch_ci. */
  2    29 	       3 pad	      bit (17) unaligned,	/* Must be zero. */
  2    30 	     2 key_tail_space_used_since_last_prefix_compaction
  2    31 			      fixed bin (18) unsigned unal,
  2    32 	     2 key_range	      unaligned,
  2    33 	       3 first	      fixed bin (18) unsigned,
  2    34 	       3 last	      fixed bin (18) unsigned,
  2    35 	     2 parent_id_string   bit (36) aligned,
  2    36 	     2 previous_id	      fixed bin (24) unsigned unaligned,
  2    37 	     2 next_id	      fixed bin (24) unsigned unaligned,
  2    38 	     2 pad	      bit (24) unaligned;
  2    39 
  2    40 
  2    41      dcl	   common_ci_header_ptr   ptr;
  2    42 
  2    43      dcl	   1 leaf_ci_header	      based (leaf_ci_header_ptr),
  2    44 	     2 common	      like common_ci_header;
  2    45 
  2    46      dcl	   leaf_ci_header_ptr     ptr;
  2    47 
  2    48      dcl	   1 branch_ci_header     based (branch_ci_header_ptr),
  2    49 	     2 common	      like common_ci_header,
  2    50 	     2 low_branch_id      fixed bin (24) unsigned unaligned,
  2    51 	     2 pad	      bit (12) unaligned;
  2    52 
  2    53      dcl	   branch_ci_header_ptr   ptr;
  2    54 
  2    55 
  2    56      dcl	   (
  2    57 	   DEFAULT_INITIAL_KEY_SLOT
  2    58 			      init (2),
  2    59 	   DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT
  2    60 			      init (1),
  2    61 	   LEAF_CI_HEADER_LENGTH_IN_BITS
  2    62 			      init (180),
  2    63 	   BRANCH_CI_HEADER_LENGTH_IN_BITS
  2    64 			      init (216)
  2    65 	   )		      internal static options (constant) fixed bin;
  2    66 
  2    67 /* END INCLUDE FILE - dm_im_ci_header.incl.pl1 */
      236 
      237 
  3     1 /* BEGIN INCLUDE FILE - dm_im_key.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*
  3     5*          There are two formats for keys, the leaf_key structure and the
  3     6*     branch_key structure. The branch_key has two more pieces of information
  3     7*     than the leaf_key. One is the control interval id of the
  3     8*     node for all keys greater than the value of the branch key.  The other is
  3     9*     the number of fields for which there are values in the "string" portion
  3    10*     of the key.  This allows for the storing of only as much data as is needed
  3    11*     to discriminate between the children being split by the branch key.
  3    12**/
  3    13 
  3    14 /* HISTORY:
  3    15*
  3    16*Written by Lindsey Spratt, 03/29/82.
  3    17*Modified:
  3    18*10/25/84 by Lindsey L. Spratt:  Added history and description sections.
  3    19**/
  3    20 
  3    21 /* format: style2,ind3 */
  3    22      dcl	   key_string	      bit (key_string_length) based (key_string_ptr);
  3    23      dcl	   key_string_length      fixed bin (35);
  3    24      dcl	   key_string_ptr	      ptr;
  3    25 
  3    26      dcl	   1 leaf_key	      based (leaf_key_ptr) unaligned,
  3    27 	     2 string	      bit (lk_string_length) unal;
  3    28 
  3    29      dcl	   lk_string_length	      fixed bin (35);
  3    30      dcl	   leaf_key_ptr	      ptr;
  3    31 
  3    32      dcl	   1 branch_key	      based (branch_key_ptr) unaligned,
  3    33 	     2 branch_id	      fixed bin (24) unsigned unaligned,
  3    34 	     2 last_field_idx     fixed bin (12) unaligned unsigned,
  3    35 	     2 string	      bit (bk_string_length) unal;
  3    36 
  3    37      dcl	   BRANCH_KEY_HEADER_LENGTH_IN_BITS
  3    38 			      init (36) fixed bin (35) internal static options (constant);
  3    39      dcl	   bk_string_length	      fixed bin (35);
  3    40      dcl	   branch_key_ptr	      ptr;
  3    41 
  3    42 /* END INCLUDE FILE - dm_im_key.incl.pl1 */
      238 
      239 
  4     1 /* BEGIN INCLUDE FILE - dm_im_opening_info.incl.pl1 */
  4     2 
  4     3 /* DESRIPTION:
  4     4*
  4     5*          The index_opening_info is per-process information, stored in a
  4     6*     hash_table managed by the opening_manager_, which allows the
  4     7*     index_manager_ to quickly reference certain unchanging pieces of
  4     8*     information rapidly.
  4     9**/
  4    10 
  4    11 /* HISTORY:
  4    12*
  4    13*Written by Lindsey Spratt, 10/28/82.
  4    14*Modified:
  4    15*10/26/84 by Lindsey L. Spratt:  Changed version to char(8).  Added a
  4    16*            description.  Added the current_rollback_count.  Added the
  4    17*	  key_count_array_ptr.
  4    18*03/07/85 by R. Michael Tague:  Added key_count_increments_ptr and 
  4    19*	  key_counts_postcommit_written.  Changed to version 3.
  4    20*03/25/85 by R. Michael Tague:  Added key_count_unprotected_file.  This
  4    21*	  flag is used by im_update_opening_info to help it maintain the
  4    22*	  key count array info.
  4    23**/
  4    24 
  4    25 /* format: style2,ind3 */
  4    26      dcl	   1 index_opening_info   based (index_opening_info_ptr) aligned,
  4    27 	     2 version	      char (8) aligned,
  4    28 	     2 file_opening_id    bit (36) aligned,
  4    29 	     2 collection_id      bit (36) aligned,
  4    30 	     2 index_header_ptr   ptr init (null),
  4    31 	     2 field_table_ptr    ptr init (null),
  4    32 	     2 key_count_array_ptr
  4    33 			      ptr init (null),
  4    34 	     2 key_count_increments_ptr
  4    35 			      ptr init (null),
  4    36 	     2 flags,
  4    37 	       3 key_count_postcommit_written
  4    38 			      bit (1) unal init ("0"b),
  4    39 	       3 key_count_unprotected_file
  4    40 			      bit (1) unal init ("0"b),
  4    41 	       3 pad	      bit (34) unal init (""b),
  4    42 	     2 current_txn_id     fixed bin (35) init (0),
  4    43 	     2 current_rollback_count
  4    44 			      fixed bin (35) init (0);
  4    45 
  4    46      dcl	   index_opening_info_ptr ptr init (null);
  4    47      dcl	   INDEX_OPENING_INFO_VERSION_3
  4    48 			      init ("IdxOpn 3") char (8) aligned internal static options (constant);
  4    49 
  4    50 /* END INCLUDE FILE - dm_im_opening_info.incl.pl1 */
      240 
      241 
  5     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*
  5     5*        Contains the declaration of an element identifier.  Element
  5     6*   identifiers consist of two parts, the id (number) of the control interval
  5     7*   in which the element resides, and the index into the slot table of
  5     8*   the element in the control interval.  The declaration of the element_id 
  5     9*   structure reflects this division of the element identifier.  The structure 
  5    10*   is based on the automatic bit string element_id_string because programs
  5    11*   generally pass bit strings (element_id_string) to each other, then 
  5    12*   interpret the bit string by overlaying the element_id structure ony if
  5    13*   it is necessary to access the parts of the id.  Basing element_id on
  5    14*   addr(element_id_string) instead of on a pointer removes the necessity
  5    15*   for always setting that pointer explicitly and guarantees that changes
  5    16*   made to the string or structure do not get inconsistent.
  5    17*
  5    18*   Changes made to element_id must also be made to datum_id, declared in 
  5    19*   dm_cm_datum.incl.pl1.
  5    20**/
  5    21 
  5    22 /* HISTORY:
  5    23*Written by Matthew Pierret, 04/01/82.
  5    24*Modified:
  5    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  5    26**/
  5    27 
  5    28 /* format: style2,ind3,ll79 */
  5    29 
  5    30      dcl	   element_id_string      bit (36) aligned;
  5    31 
  5    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  5    33 	     2 control_interval_id
  5    34 			      fixed bin (24) unal unsigned,
  5    35 	     2 index	      fixed bin (12) unal unsigned;
  5    36 
  5    37 
  5    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      242 
      243    end im_split;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/04/85  0823.5  im_split.pl1                      >spec>on>7192.pbf-04/04/85>im_split.pl1
234          1    04/04/85  0819.0  dm_collmgr_entry_dcls.incl.pl1    >spec>on>7192.pbf-04/04/85>dm_collmgr_entry_dcls.incl.pl1
236          2    01/07/85  0858.8  dm_im_ci_header.incl.pl1          >ldd>include>dm_im_ci_header.incl.pl1
238          3    01/07/85  0858.9  dm_im_key.incl.pl1                >ldd>include>dm_im_key.incl.pl1
240          4    04/04/85  0818.8  dm_im_opening_info.incl.pl1       >spec>on>7192.pbf-04/04/85>dm_im_opening_info.incl.pl1
242          5    01/07/85  0858.5  dm_element_id.incl.pl1            >ldd>include>dm_element_id.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BITS_PER_PAGE                          constant        fixed bin(17,0)          initial dcl 91 ref 61
BRANCH_KEY_HEADER_LENGTH_IN_BITS       constant        fixed bin(35,0)          initial dcl 3-37 ref 182
DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT
                                       constant        fixed bin(17,0)          initial dcl 2-56 ref 139 158 202
DOUBLE_WORDS_PER_PAGE                  constant        fixed bin(17,0)          initial dcl 92 ref 60
INDEX_OPENING_INFO_VERSION_3    000000 constant        char(8)                  initial dcl 4-47 set ref 112*
addr                                                   builtin function         dcl 85 ref 139 140 151 154 158 159 159 176 176 201
                                                                                  202 204 204 208 208
bk_string_length                000132 automatic       fixed bin(35,0)          dcl 3-39 set ref 182*
branch_ci_header                       based           structure                level 1 unaligned dcl 2-48
branch_ci_header_ptr            000130 automatic       pointer                  dcl 2-53 set ref 159* 165 168*
branch_id                              based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 3-32 set ref
                                                                                  183*
branch_key                             based           structure                level 1 packed unaligned dcl 3-32
branch_key_ptr                  000134 automatic       pointer                  dcl 3-40 set ref 176* 183 185*
collection_id             3            based           bit(36)                  level 2 dcl 4-26 set ref 121* 141* 144* 159* 168*
                                                                                  176* 185* 204* 208* 212* 215*
collection_manager_$allocate_control_interval
                                000020 constant        entry                    external dcl 1-50 ref 121
collection_manager_$get         000022 constant        entry                    external dcl 1-71 ref 159 176 204 208
collection_manager_$modify      000024 constant        entry                    external dcl 1-101 ref 168 185 212 215
collection_manager_$put         000026 constant        entry                    external dcl 1-115 ref 141 144
common_ci_header                       based           structure                level 1 unaligned dcl 2-26
control_interval_id                    based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 5-32 set ref
                                                                                  140* 151 201*
element_id                             based           structure                level 1 dcl 5-32
element_id_string               000140 automatic       bit(36)                  dcl 5-30 set ref 139 140 141* 144* 157* 158 159*
                                                                                  168* 175* 176* 185* 201 202 204* 208* 212* 215*
error_table_$unimplemented_version
                                000016 external static fixed bin(35,0)          dcl 106 set ref 227*
file_opening_id           2            based           bit(36)                  level 2 dcl 4-26 set ref 121* 141* 144* 159* 168*
                                                                                  176* 185* 204* 208* 212* 215*
flags                                  based           structure                level 2 packed unaligned dcl 78
im_init_branch_ci_header        000014 constant        entry                    external dcl 101 ref 131
im_init_leaf_ci_header          000012 constant        entry                    external dcl 100 ref 129
index                     0(24)        based           fixed bin(12,0)          level 2 packed unsigned unaligned dcl 5-32 set ref
                                                                                  139* 154 158* 202*
index_opening_info                     based           structure                level 1 dcl 4-26
index_opening_info_ptr          000136 automatic       pointer                  initial dcl 4-46 set ref 111* 112 121 121 141 141
                                                                                  144 144 159 159 168 168 176 176 185 185 204 204
                                                                                  208 208 212 212 215 215 4-46*
is_leaf                                based           bit(1)                   level 3 packed unaligned dcl 78 ref 117
key_buffer                      000100 automatic       fixed bin(71,0)          array dcl 60 set ref 176 176
key_buffer_length               000100 automatic       fixed bin(35,0)          initial dcl 61 set ref 61* 176*
key_length                      000101 automatic       fixed bin(35,0)          dcl 62 set ref 176* 182 185*
key_range                 1            based           structure                level 2 packed unaligned dcl 79 set ref 132*
leaf_ci_header                         based           structure                level 1 unaligned dcl 2-43
length                                                 builtin function         dcl 85 ref 141 141 144 144 159 159 168 168 204 204
                                                                                  208 208 212 212 215 215
local_branch_ci_header          000116 automatic       structure                level 1 unaligned dcl 71 set ref 144 144 159 159 159
                                                                                  159 168 168 208 208 208 208 215 215
local_leaf_ci_header            000111 automatic       structure                level 1 unaligned dcl 70 set ref 141 141 204 204 204
                                                                                  204 212 212
low_branch_id             5            based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 2-48 set ref
                                                                                  165*
myname                          000002 constant        varying char(32)         initial dcl 93 set ref 227*
new_ci                          000102 automatic       fixed bin(24,0)          unsigned dcl 63 set ref 121* 125
new_common_ci_header_ptr        000104 automatic       pointer                  initial dcl 64 set ref 64* 115* 132 136 137 196
new_common_header                      based           structure                level 1 unaligned dcl 79
next_id                   3(24)        based           fixed bin(24,0)          level 2 in structure "prev_common_header" packed
                                                                                  unsigned unaligned dcl 80 in procedure "im_split"
                                                                                  set ref 211*
next_id                   3(24)        based           fixed bin(24,0)          level 2 in structure "new_common_header" packed
                                                                                  unsigned unaligned dcl 79 in procedure "im_split"
                                                                                  set ref 137*
null                                                   builtin function         dcl 84 ref 64 66 159 159 176 176 204 204 208 208
                                                                                  4-46 227 227
old_common_ci_header_ptr        000106 automatic       pointer                  initial dcl 66 set ref 66* 114* 117 136 138 151 154
                                                                                  157 175
old_common_header                      based           structure                level 1 unaligned dcl 78
p_code                                 parameter       fixed bin(35,0)          dcl 56 set ref 42 121* 123 141* 144* 159* 162 168*
                                                                                  170 176* 179 185* 187 204* 208* 212* 215*
p_expected_version                     parameter       char(8)                  dcl 224 set ref 221 227 227*
p_index_opening_info_ptr               parameter       pointer                  dcl 48 ref 42 111
p_new_ci                               parameter       fixed bin(24,0)          unsigned unaligned dcl 55 set ref 42 125* 138 140
                                                                                  165 183 211
p_new_common_ci_header_ptr             parameter       pointer                  dcl 53 set ref 42 115 129* 131* 141* 144*
p_old_ci                               parameter       fixed bin(24,0)          unsigned unaligned dcl 52 ref 42 137
p_old_common_ci_header_ptr             parameter       pointer                  dcl 50 ref 42 114
p_received_version                     parameter       char(8)                  dcl 223 set ref 221 227 227*
p_structure_name                       parameter       char                     unaligned dcl 225 set ref 221 227*
parent_id_string          2            based           bit(36)                  level 2 dcl 78 set ref 151 154 157 175
prev_ci                         000110 automatic       fixed bin(24,0)          unsigned unaligned dcl 68 set ref 196* 197 201
prev_common_header                     based           structure                level 1 unaligned dcl 80
prev_common_header_ptr          000126 automatic       pointer                  dcl 74 set ref 204* 208* 211 212* 215*
previous_id               3            based           fixed bin(24,0)          level 2 in structure "new_common_header" packed
                                                                                  unsigned unaligned dcl 79 in procedure "im_split"
                                                                                  set ref 136* 196
previous_id               3            based           fixed bin(24,0)          level 2 in structure "old_common_header" packed
                                                                                  unsigned unaligned dcl 78 in procedure "im_split"
                                                                                  set ref 136 138*
splitting_leaf                  000124 automatic       bit(1)                   dcl 73 set ref 117* 129 141 204 212
sub_err_                        000010 constant        entry                    external dcl 98 ref 227
unspec                                                 builtin function         dcl 85 ref 141 141 144 144 159 159 168 168 204 204
                                                                                  208 208 212 212 215 215
version                                based           char(8)                  level 2 dcl 4-26 set ref 112*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BEGINNING_OF_ELEMENT                   internal static fixed bin(35,0)          initial dcl 90
BRANCH_CI_HEADER_LENGTH_IN_BITS        internal static fixed bin(17,0)          initial dcl 2-56
DEFAULT_INITIAL_KEY_SLOT               internal static fixed bin(17,0)          initial dcl 2-56
LEAF_CI_HEADER_LENGTH_IN_BITS          internal static fixed bin(17,0)          initial dcl 2-56
collection_manager_$compact_control_interval
                                000000 constant        entry                    external dcl 1-52
collection_manager_$create_collection
                                000000 constant        entry                    external dcl 1-54
collection_manager_$create_file 000000 constant        entry                    external dcl 1-56
collection_manager_$delete      000000 constant        entry                    external dcl 1-64
collection_manager_$delete_from_ci_buffer
                                000000 constant        entry                    external dcl 1-67
collection_manager_$destroy_collection
                                000000 constant        entry                    external dcl 1-58
collection_manager_$free_control_interval
                                000000 constant        entry                    external dcl 1-60
collection_manager_$get_by_ci_ptr
                                000000 constant        entry                    external dcl 1-80
collection_manager_$get_control_interval_ptr
                                000000 constant        entry                    external dcl 1-74
collection_manager_$get_from_ci_buffer
                                000000 constant        entry                    external dcl 1-77
collection_manager_$get_header  000000 constant        entry                    external dcl 1-83
collection_manager_$get_id      000000 constant        entry                    external dcl 1-86
collection_manager_$get_portion 000000 constant        entry                    external dcl 1-89
collection_manager_$get_portion_by_ci_ptr
                                000000 constant        entry                    external dcl 1-97
collection_manager_$get_portion_from_ci_buffer
                                000000 constant        entry                    external dcl 1-93
collection_manager_$modify_in_ci_buffer
                                000000 constant        entry                    external dcl 1-107
collection_manager_$modify_portion
                                000000 constant        entry                    external dcl 1-110
collection_manager_$modify_unprotected
                                000000 constant        entry                    external dcl 1-104
collection_manager_$postcommit_increments
                                000000 constant        entry                    external dcl 1-113
collection_manager_$put_header  000000 constant        entry                    external dcl 1-121
collection_manager_$put_in_ci_buffer
                                000000 constant        entry                    external dcl 1-118
collection_manager_$put_unprotected_header
                                000000 constant        entry                    external dcl 1-123
collection_manager_$replace_ci_buffer
                                000000 constant        entry                    external dcl 1-126
collection_manager_$setup_ci_buffer
                                000000 constant        entry                    external dcl 1-129
collection_manager_$simple_get_by_ci_ptr
                                000000 constant        entry                    external dcl 1-132
collection_manager_$simple_get_from_ci_buffer
                                000000 constant        entry                    external dcl 1-135
common_ci_header_ptr                   automatic       pointer                  dcl 2-41
key_string                             based           bit                      unaligned dcl 3-22
key_string_length                      automatic       fixed bin(35,0)          dcl 3-23
key_string_ptr                         automatic       pointer                  dcl 3-24
leaf_ci_header_ptr                     automatic       pointer                  dcl 2-46
leaf_key                               based           structure                level 1 packed unaligned dcl 3-26
leaf_key_ptr                           automatic       pointer                  dcl 3-30
lk_string_length                       automatic       fixed bin(35,0)          dcl 3-29

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_VERSION                   001016 constant        entry                    internal dcl 221 ref 112
im_split                        000065 constant        entry                    external dcl 42

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1250        1300    1122        1260
Length      1576    1122        30         261     126           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
im_split                            224 external procedure  is an external procedure.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure im_split.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
im_split                 000100 key_buffer                  im_split
                         000100 key_buffer_length           im_split
                         000101 key_length                  im_split
                         000102 new_ci                      im_split
                         000104 new_common_ci_header_ptr    im_split
                         000106 old_common_ci_header_ptr    im_split
                         000110 prev_ci                     im_split
                         000111 local_leaf_ci_header        im_split
                         000116 local_branch_ci_header      im_split
                         000124 splitting_leaf              im_split
                         000126 prev_common_header_ptr      im_split
                         000130 branch_ci_header_ptr        im_split
                         000132 bk_string_length            im_split
                         000134 branch_key_ptr              im_split
                         000136 index_opening_info_ptr      im_split
                         000140 element_id_string           im_split

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              alloc_auto_adj      ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
collection_manager_$allocate_control_interval               collection_manager_$get       collection_manager_$modify
collection_manager_$put       im_init_branch_ci_header      im_init_leaf_ci_header        sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     42 000057        60 000072        61 000100        64 000102        66 000104    4   46 000105       111 000106
    112 000112       114 000137       115 000143       117 000146       121 000151       123 000167       125 000172
    129 000201       131 000213       132 000222       136 000227       137 000232       138 000237       139 000243
    140 000245       141 000250       144 000302       151 000331       154 000335       157 000340       158 000342
    159 000344       162 000413       165 000416       168 000423       170 000452       172 000455       175 000456
    176 000460       179 000524       182 000527       183 000535       185 000542       187 000567       196 000572
    197 000576       201 000601       202 000603       204 000605       208 000657       211 000726       212 000734
    215 000766       219 001015       221 001016       227 001027       232 001121


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
