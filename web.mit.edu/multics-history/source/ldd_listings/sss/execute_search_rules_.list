	COMPILATION LISTING OF SEGMENT execute_search_rules_
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/08/82  1533.1 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 execute_search_rules_: proc (rname, switches, dirname, ename, type, bit_count, code);
       12 
       13 /*   Arguments */
       14 
       15 dcl  rname char (32);
       16 dcl  switches bit (8) aligned;			/* chase_sw,target_sw,priname_sw,known_sw,
       17*						   link_sw,error_sw,show_sw,noref_sw */
       18 dcl  dirname char (168);
       19 dcl  ename char (32);
       20 dcl  type fixed bin (2);
       21 dcl  bit_count fixed bin (24);
       22 dcl  code fixed bin (35);
       23 
       24 
       25 /*    External Entries     */
       26 
       27 dcl  get_default_wdir_ ext entry returns (char (168) aligned);
       28 dcl  get_pdir_ ext entry returns (char (168) aligned);
       29 dcl  get_wdir_ ext entry returns (char (168) aligned);
       30 dcl  get_system_free_area_ ext entry returns (ptr);
       31 
       32 dcl  cu_$stack_frame_ptr ext entry (ptr);
       33 dcl  hcs_$fs_get_seg_ptr ext entry (char (*), ptr, fixed bin (35));
       34 dcl  hcs_$fs_get_path_name ext entry (ptr, char (*), fixed bin, char (*), fixed bin (35));
       35 dcl  hcs_$initiate ext entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
       36 dcl  hcs_$get_link_target ext entry (char (*), char (*), char (*), char (*), fixed bin (35));
       37 dcl  hcs_$terminate_noname ext entry (ptr, fixed bin (35));
       38 
       39 
       40 dcl  hcs_$get_search_rules ext entry (ptr);
       41 
       42 dcl  hcs_$status_long ext entry
       43     (char (*), char (*), fixed bin (1), ptr, ptr, fixed bin (35));
       44 
       45 dcl  hcs_$status_minf ext entry (char (*), char (*), fixed bin (1), fixed bin (2), fixed bin (24),
       46      fixed bin (35));
       47 dcl  ioa_ ext entry options (variable);
       48 dcl  com_err_ ext entry options (variable);
       49 
       50 /*	Error Table Entries		*/
       51 
       52 dcl  error_table_$bad_string ext fixed bin (35);		/* bad search rule or dirname */
       53 dcl  error_table_$name_not_found ext fixed bin (35);	/* if seg not initiated */
       54 dcl  error_table_$no_s_permission ext fixed bin (35);
       55 dcl  error_table_$noentry ext fixed bin (35);		/* ename not in this directory */
       56 dcl  error_table_$not_a_branch ext fixed bin (35);	/* to tell caller that entry is a link */
       57 dcl  error_table_$segknown ext fixed bin (35);		/* to tell caller that segment was initiated */
       58 
       59 
       60 /*     Work Variables     */
       61 
       62 /*						SWITCHES: if = "1"b then:		*/
       63 dcl  chase_sw bit (1) aligned;			/* return type and bitcount of target of link */
       64 dcl  target_sw bit (1) aligned;			/* return pathname of target of link */
       65 dcl  priname_sw bit (1) aligned;			/* return primary name on entry */
       66 dcl  known_sw bit (1) aligned;			/* if init seg, return error_table_$segknown */
       67 dcl  link_sw bit (1) aligned;				/* if a link, return error_table_$not_a_branch */
       68 dcl  error_sw bit (1) aligned;			/* if error in using a rule, continue with others */
       69 dcl  show_sw bit (1) aligned;				/* print rules, dirs, and error codes, while searching */
       70 dcl  noref_sw bit (1) aligned;			/* don't use referencing dir rule */
       71 
       72 dcl  chase fixed bin (1);
       73 
       74 dcl  search_rules_ptr ptr;
       75 dcl 1 search_rules aligned based (search_rules_ptr),
       76     2 number fixed bin,
       77     2 names (21) char (168) aligned;
       78 
       79 dcl 1 stack_search_rules like search_rules automatic;
       80 
       81 dcl  names_needed bit (1) aligned;
       82 dcl  no_s_permission bit (1) aligned;			/* to remember that status long returned this code */
       83 dcl  it_was_a_link bit (1) aligned;			/* to remember a link, when chasing it */
       84 dcl (i, j) fixed bin;
       85 dcl  ldn fixed bin;					/* return from fs get path name */
       86 dcl  dummy_ename char (32);				/* return from fs get path name, to avoid clobbering
       87*						   then original ename */
       88 dcl  dummy_dirname char (168);			/* to avoid clobbering original dirname */
       89 dcl  dummy_segptr ptr;				/* return from hcs initiate, to avoid clobbering
       90*						   original seg_ptr */
       91 
       92 dcl  me char (24) aligned int static init ("execute_search_rules_"); /* for com_err_ calls */
       93 
       94 dcl  stack_ptr ptr;
       95 
       96 dcl 1 stack_frame based (stack_ptr),
       97     2 pad (16) bit (36),
       98     2 back_ptr ptr,
       99     2 next_ptr ptr,
      100     2 return_ptr ptr,
      101     2 entry_ptr ptr;
      102 						/* we don't care about rest of frame */
      103 
      104 dcl 1 long_branch aligned,				/* structure for status long call */
      105     (2 long_type bit (2),
      106     2 nnames bit (16),
      107     2 nrp bit (18)) unaligned,
      108     2 pad (6) fixed bin (35),
      109     (2 curlen bit (12),
      110     2 long_bitcount bit (24)) unaligned,
      111     2 pad2 (2) fixed bin (35);
      112 
      113 dcl  lg_type fixed bin (2);				/* args for quick block: status_long_caller */
      114 dcl  lg_bitcount fixed bin (24);
      115 dcl  lg_name char (32);
      116 dcl  lg_priname_sw bit (1) aligned;
      117 dcl  lg_chase fixed bin (1);
      118 
      119 dcl  names (fnames) char (32) aligned based (ep);		/* names array for status long call */
      120 
      121 dcl  fnames fixed bin;
      122 dcl  ep ptr;
      123 dcl  system_free_ptr ptr int static init (null);
      124 dcl  system_free_area area based (system_free_ptr);
      125 
      126 dcl  seg_ptr ptr;
      127 
      128 dcl  error_code fixed bin (35) init (0);		/* to save error codes */
      129 dcl  error_dir char (168) aligned;			/* to save dir where error occurred */
      130 dcl  unexpected_error bit (1) aligned;			/* to distinguish between "not found"
      131*						   and other errors (like no access, or dir does not exist) */
      132 
      133 
      134 dcl (addr, fixed, null, ptr, substr) builtin;
      135 
      136 dcl  cleanup condition;
      137 
      138 /*     P  R  O  C  E  D  U  R  E     */
      139 	search_rules_ptr  = addr (stack_search_rules);
      140 	call hcs_$get_search_rules (search_rules_ptr);
      141 
      142 start:	;					/* come here from ptr entry point */
      143 
      144 
      145 /* copy switch values to bit(1) aligned for faster accessing */
      146 	chase_sw = substr (switches, 1, 1);
      147 	target_sw = substr (switches, 2, 1);
      148 	priname_sw = substr (switches, 3, 1);
      149 	known_sw = substr (switches, 4, 1);
      150 	link_sw = substr (switches, 5, 1);
      151 	error_sw = substr (switches, 6, 1);
      152 	show_sw = substr (switches, 7, 1);
      153 	noref_sw = substr (switches, 8, 1);
      154 
      155 	if chase_sw & ^target_sw & ^link_sw then chase = 1; /* if we don't want to know about links,
      156*						   then set chase switch for status_minf call */
      157 
      158 	ename = rname;				/* return the given rname as ename, unless we find, below, that:
      159*						   1) rname is not a name on the entry, or
      160*						   2) the primary name was requested, and is ^= rname */
      161 
      162 	type, bit_count = -1;			/* to distinguish from meaningful values, in case of error */
      163 
      164 search_loop: do i = 1 to search_rules.number;
      165 
      166 	     unexpected_error, it_was_a_link, no_s_permission, names_needed = "0"b;
      167 
      168 	     dirname = search_rules.names (i);
      169 
      170 	     if show_sw then
      171 	     call show (-3);			/* if show_sw then call ioa_ ("^/RULE: ^a",dirname) */
      172 
      173 	     if dirname = "" then goto end_search_loop;	/* as a convenience to callers of the s_r_ptr
      174*						   entry, who may want to call get_search_rules,
      175*						   and delete some rules from the structure. */
      176 
      177 
      178 	     if dirname = "initiated_segments" then
      179 check_init_segs: do;				/* see if it is initiated */
      180 
      181 		call hcs_$fs_get_seg_ptr (ename, seg_ptr, code);
      182 
      183 		if code ^= 0 then
      184 		if show_sw then
      185 		call show (1);			/* if show_sw then call com_err_ (code,me,"from get seg ptr") */
      186 
      187 		if code ^= 0 then
      188 		if code ^= error_table_$name_not_found then do;
      189 
      190 		     if ^error_sw then return;
      191 		     error_dir = dirname;
      192 		     error_code = code;
      193 		     unexpected_error = "1"b;
      194 		end;
      195 
      196 		if seg_ptr ^= null then
      197 it_was_init:	do;
      198 
      199 		     call hcs_$fs_get_path_name (seg_ptr, dirname, ldn, dummy_ename, code);
      200 
      201 		     if code ^= 0 then do;
      202 
      203 			if show_sw then
      204 			call show (2);		/* if show_sw then
      205*						   call com_err_ (code,me,"from get path name") */
      206 
      207 			if ^error_sw then return;
      208 			error_dir = dirname;
      209 			error_code = code;
      210 			unexpected_error = "1"b;
      211 		     end;
      212 
      213 		     else
      214 got_pathname:	     do;
      215 
      216 			call hcs_$status_minf (dirname, dummy_ename, chase, type, bit_count, code);
      217 
      218 			if code ^= 0 then
      219 			if show_sw then
      220 			call show (3);
      221 
      222 /* if code ^= 0, we are returning anyway, so just return it */
      223 
      224 			if code = 0 then
      225 check_init_options: 	do;
      226 
      227 			     if priname_sw then	/* if caller wants primary name */
      228 			     ename = dummy_ename;	/* then give him what fs_get_pathname returned */
      229 			     else			/* if caller wants rname instead of primary name */
      230 			     if ename ^= dummy_ename then /* and they are different */
      231 check_refname:		     do;			/* see if refname matches any name on segment */
      232 
      233 				call hcs_$initiate (dirname, ename, "", 0, 0, dummy_segptr, code);
      234 						/* try to initiate it using the reference name as the ename */
      235 				if seg_ptr ^= dummy_segptr /* if can't, or can but get different seg */
      236 				then ename = dummy_ename; /* then replace refname by a name on the seg */
      237 
      238 				if dummy_segptr ^= null then /* if initiate worked */
      239 				call hcs_$terminate_noname (dummy_segptr, code); /* then terminate it */
      240 
      241 				code = 0;		/* in case initiate or terminate set it nonzero */
      242 
      243 			     end check_refname;
      244 
      245 			     if known_sw then	/* if caller wants to know about initiated segs */
      246 			     code = error_table_$segknown; /* then tell him, just as hcs_$initiate does */
      247 
      248 			end check_init_options;
      249 
      250 
      251 			return;			/* skip rest of program */
      252 
      253 		     end got_pathname;
      254 
      255 		end it_was_init;
      256 
      257 	     end check_init_segs;
      258 
      259 	     else					/* this rule is not "initiated_segments" */
      260 check_non_init: do;					/* process all the rest of the rules */
      261 
      262 		if substr (dirname, 1, 1) ^= ">" then	/* if not a directory path */
      263 interpret_rule:	do;				/* then get one, from the given rule */
      264 
      265 		     if dirname = "referencing_dir" then
      266 get_refdir:	     do;
      267 
      268 			if noref_sw then goto end_search_loop; /* skip this rule, if caller so requested */
      269 
      270 			call cu_$stack_frame_ptr (stack_ptr); /* get ptr to our stack frame */
      271 			stack_ptr = stack_frame.back_ptr; /* get ptr to caller's frame */
      272 			seg_ptr = stack_frame.entry_ptr; /* get ptr to caller */
      273 						/* get pathname of caller */
      274 			call hcs_$fs_get_path_name (seg_ptr, dirname, ldn, dummy_ename, code);
      275 						/* we will use the directory portion of his pathname
      276*						   as the referencing_dir */
      277 
      278 			if code ^= 0 then do;
      279 			     if show_sw then
      280 			     call show (2);		/* if show_sw then
      281*						   call com_err_ (code,me,"from get path name") */
      282 
      283 			     if ^error_sw then return;
      284 			     error_dir = dirname;
      285 			     error_code = code;
      286 			     unexpected_error = "1"b;
      287 			end;
      288 
      289 		     end get_refdir;
      290 
      291 		     else if dirname = "working_dir" then
      292 		     dirname = get_wdir_ ();
      293 
      294 		     else if dirname = "process_dir" then
      295 		     dirname = get_pdir_ ();
      296 
      297 		     else if dirname = "home_dir" then
      298 		     dirname = get_default_wdir_ ();
      299 
      300 		     else
      301 bad_search_rule:	     do;
      302 			code = error_table_$bad_string;
      303 			if show_sw then
      304 			call show (0);		/* if show_sw then call com_err_ (code,me) */
      305 
      306 			if ^error_sw then return;
      307 			error_code = code;
      308 			error_dir = dirname;
      309 			unexpected_error = "1"b;
      310 		     end bad_search_rule;
      311 
      312 		end interpret_rule;
      313 
      314 		if show_sw then
      315 		if dirname ^= search_rules.names (i) then /* if directory different from rule */
      316 		call show (-2);
      317 
      318 		if ^unexpected_error then
      319 try_status:	do;
      320 
      321 		     if priname_sw then do;		/* call status long, to be sure we get the primary name */
      322 			lg_priname_sw = "1"b;
      323 			lg_chase = chase;
      324 			call status_long_caller;	/* internal procedure to set up for status long call */
      325 			type = lg_type;
      326 			bit_count = lg_bitcount;
      327 			ename = lg_name;		/* this will be the primary name */
      328 		     end;
      329 
      330 		     else do;			/*  call status minf - we will return rname */
      331 			call hcs_$status_minf (dirname, ename, chase, type, bit_count, code);
      332 
      333 			if code ^= 0 then
      334 			if show_sw then
      335 			call show (3);
      336 		     end;
      337 
      338 		     if code = error_table_$no_s_permission then goto found_it;
      339 		     if code = 0 then
      340 found_it: 	     do;
      341 
      342 			if type = 0 then		/* if this is a link */
      343 examine_link:		do;
      344 
      345 			     if link_sw then	/* if caller wants to know about links */
      346 			     it_was_a_link = "1"b;	/* remember to tell him so */
      347 			     if target_sw then	/* if caller wants name of target of links */
      348 get_target:		     do;
      349 
      350 				call hcs_$get_link_target (dirname, ename, dummy_dirname, dummy_ename, code);
      351 
      352 				if code ^= 0 then do;
      353 
      354 				     if show_sw then
      355 				     call show (4);	/* if show_sw then
      356*						   call com_err_ (code,me,"from get link target") */
      357 				     if ^error_sw then return;
      358 
      359 				     error_code = code;
      360 				     error_dir = dirname;
      361 				     unexpected_error = "1"b;
      362 				end;
      363 
      364 			     end get_target;
      365 
      366 			     if ^unexpected_error then
      367 get_target_info:		     do;
      368 				if target_sw then	/* if we got the target pathname */
      369 				if dummy_ename ^= ename then /* and its ename ^= the one the caller sent */
      370 				if ^priname_sw then	/* and the caller wants his, if it is on the entry */
      371 				names_needed = "1"b; /* then we must call status long, to get the names */
      372 
      373 				if ^names_needed then if chase_sw then do; /* if just chase, get target status */
      374 				     call hcs_$status_minf (dirname, ename, 1, type, bit_count, code);
      375 				     if code ^= 0 then do;
      376 					if show_sw then
      377 					call show (3);
      378 					if ^error_sw then return;
      379 					error_dir = dirname;
      380 					error_code = code;
      381 					unexpected_error = "1"b;
      382 				     end;
      383 				end;
      384 
      385 				if names_needed then do; /* call status long? */
      386 				     lg_priname_sw = "0"b;
      387 				     lg_chase = 1;
      388 				     call status_long_caller;
      389 				     if code = 0 then /* if code ^= 0, lg_name = ename;
      390*						   we don't want that for the target */
      391 				     dummy_ename = lg_name; /* rname, or primary name, if rname not on entry */
      392 				     if chase_sw then do; /* copy target status */
      393 					type = lg_type;
      394 					bit_count = lg_bitcount;
      395 				     end;		/* end copy target status */
      396 				end;		/* end wants target path */
      397 
      398 				if target_sw then do; /* copy return args from get link target */
      399 				     dirname = dummy_dirname;
      400 				     ename = dummy_ename; /* may have been changed in get_target_info */
      401 				end;
      402 
      403 			     end get_target_info;
      404 
      405 
      406 			end examine_link;
      407 
      408 			if ^unexpected_error then do;
      409 			     if it_was_a_link	/* if first status call found a link,
      410*						   and user asked to be told */
      411 			     then if code = 0	/* and there was no other error code */
      412 			     then code = error_table_$not_a_branch; /* then return the "it was a link" code */
      413 			     return;
      414 			end;
      415 
      416 		     end found_it;
      417 
      418 		     if code ^= error_table_$noentry then do;
      419 
      420 			if ^error_sw then return;
      421 
      422 			error_code = code;
      423 			error_dir = dirname;
      424 		     end;
      425 
      426 		end try_status;
      427 
      428 	     end check_non_init;
      429 
      430 end_search_loop:
      431 	end search_loop;
      432 
      433 /* fall thru when we run out of search rules */
      434 
      435 	if error_code ^= 0 then do;			/* if an unexpected error occurred */
      436 	     code = error_code;			/* that might be reason for not finding it */
      437 	     dirname = error_dir;			/* tell caller which rule had problem */
      438 	end;
      439 
      440 	else					/* if nothing special, we just didn't find it */
      441 	code = error_table_$noentry;
      442 
      443 	if show_sw then
      444 	call show (-1);				/* if show_sw then call com_err_ (code,me,ename) */
      445 	return;
      446 
      447 
      448 /*   I  N  T  E  R  N  A  L     P  R  O  C  E  D  U  R  E  S       */
      449 
      450 
      451 
      452 
      453 status_long_caller: proc;				/* procedure to call hcs_$status long, set up a
      454*						   cleanup handler to free the names array, examine the names,
      455*						   look for no_s_permission return code, and print
      456*						   error code if show switch is on */
      457 
      458 	     nnames = (16)"0"b;			/* for benefit of cleanup handler */
      459 	     on condition (cleanup) begin;
      460 
      461 		if nnames ^= (16)"0"b then do;	/* check this, instead of ep, since we build
      462*						   ep using ptr function, and might not have done so yet */
      463 		     ep = ptr (system_free_ptr, fixed (nrp)); /* build ptr to names array */
      464 		     free ep -> names in (system_free_area); /* free it */
      465 		end;				/* end do group */
      466 	     end;					/* end begin block */
      467 
      468 	     if system_free_ptr = null then		/* first time only */
      469 	     system_free_ptr = get_system_free_area_ ();	/* get ptr to system free area */
      470 
      471 	     call hcs_$status_long (dirname, ename, lg_chase, addr (long_branch), system_free_ptr, code);
      472 
      473 	     if code ^= 0 then do;
      474 		if show_sw then call show (5);
      475 		lg_name = ename;			/* always return a name */
      476 		if code = error_table_$no_s_permission then no_s_permission = "1"b;
      477 		else return;			/* if not the above, we have no good info */
      478 	     end;
      479 
      480 	     lg_type = fixed (long_type);
      481 	     if lg_type = 0 then			/* status long does not return a bitcount, for links */
      482 	     lg_bitcount = 0;
      483 	     else lg_bitcount = fixed (long_bitcount);
      484 
      485 	     if no_s_permission then return;		/* if we got status but no names */
      486 
      487 	     fnames = fixed (nnames);			/* length of names array */
      488 	     ep = ptr (system_free_ptr, fixed (nrp));	/* pointer to it */
      489 
      490 	     if lg_priname_sw then lg_name = names (1);
      491 
      492 	     else do;
      493 
      494 		do j = 1 to fnames			/* look thru names on entry */
      495 		     while (names (j) ^= ename);	/* to see if ename is one of them */
      496 		end;
      497 
      498 		if j > fnames then			/* if it isn't */
      499 		lg_name = names (1);		/* return the primary name */
      500 		else lg_name = ename;		/* if it is, return it */
      501 	     end;
      502 	     revert cleanup;			/* revert first; freeing non allocated variable usually
      503*						   clobbers the area badly enough to crash the process
      504*						   at the next attempted allocation */
      505 	     free ep -> names in (system_free_area);	/* free the names array */
      506 
      507 	     return;
      508 
      509 	end status_long_caller;
      510 
      511 
      512 show:	proc (action_code);
      513 
      514 dcl  action_code fixed bin;
      515 
      516 dcl  message char (32) aligned;
      517 
      518 dcl  messages (5) char (32) int static aligned init (
      519      "from hcs_$fs_get_seg_ptr",
      520      "from hcs_$fs_get_path_name",
      521      "from hcs_$status_minf",
      522      "from hcs_$get_link_target",
      523      "from hcs_$status_long");
      524 
      525 	     if action_code > 0 then
      526 positive:      do;
      527 		if action_code > 5 then return;	/* bad code - don't bother with error message */
      528 		message = messages (action_code);
      529 	     end positive;
      530 
      531 	     else
      532 negative:      do;
      533 		if action_code = -3 then do;
      534 		     call ioa_ ("^/RULE: ^a", dirname);
      535 		     return;
      536 		end;
      537 
      538 		if action_code = -2 then do;
      539 		     call ioa_ (dirname);
      540 		     return;
      541 		end;
      542 
      543 		else if action_code = -1 then
      544 		message = ename;
      545 		else if action_code = 0 then
      546 		message = "";
      547 		else return;			/* bad code - don't bother with error message */
      548 
      549 	     end negative;
      550 
      551 	     call com_err_ (code, "execute_search_rules_", message);
      552 	     return;
      553 	end show;
      554 
      555 
      556 /*      E  N  T  R  Y      */
      557 
      558 
      559 s_r_ptr:	entry (rname, switches, sptr, dirname, ename, type, bit_count, code);
      560 
      561 /* entry to use search rule structure supplied by caller, instead of the search rules currently in effect */
      562 
      563 
      564 dcl  sptr ptr;
      565 
      566 	search_rules_ptr = sptr;
      567 	goto start;
      568 
      569 
      570 
      571 
      572      end execute_search_rules_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/08/82  1528.8  execute_search_rules_.pl1         >dumps>old>recomp>execute_search_rules_.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
action_code                            parameter       fixed bin(17,0)          dcl 514 ref 512 525 527 528 533 538 543 545
addr                                                   builtin function         dcl 134 ref 139 471 471
back_ptr                 20            based           pointer                  level 2 dcl 96 ref 271
bit_count                              parameter       fixed bin(24,0)          dcl 21 set ref 11 162* 216* 326* 331* 374* 394* 559
chase                           000110 automatic       fixed bin(1,0)           dcl 72 set ref 155* 216* 323 331*
chase_sw                        000100 automatic       bit(1)                   dcl 63 set ref 146* 155 373 392
cleanup                         000000 stack reference condition                dcl 136 ref 459 502
code                                   parameter       fixed bin(35,0)          dcl 22 set ref 11 181* 183 187 187 192 199* 201 209
                                                                                  216* 218 224 233* 238* 241* 245* 274* 278 285 302*
                                                                                  307 331* 333 338 339 350* 352 359 374* 375 380 389
                                                                                  409 409* 418 422 436* 440* 471* 473 476 551* 559
com_err_                        000046 constant        entry                    external dcl 48 ref 551
cu_$stack_frame_ptr             000022 constant        entry                    external dcl 32 ref 270
dirname                                parameter       char(168)                unaligned dcl 18 set ref 11 168* 173 178 191 199*
                                                                                  208 216* 233* 262 265 274* 284 291 291* 294 294*
                                                                                  297 297* 308 314 331* 350* 360 374* 379 399* 423
                                                                                  437* 471* 534* 539* 559
dummy_dirname                   001715 automatic       char(168)                unaligned dcl 88 set ref 350* 399
dummy_ename                     001705 automatic       char(32)                 unaligned dcl 86 set ref 199* 216* 227 229 235 274*
                                                                                  350* 368 389* 400
dummy_segptr                    001770 automatic       pointer                  dcl 89 set ref 233* 235 238 238*
ename                                  parameter       char(32)                 unaligned dcl 19 set ref 11 158* 181* 227* 229 233*
                                                                                  235* 327* 331* 350* 368 374* 400* 471* 475 494 500
                                                                                  543 559
entry_ptr                26            based           pointer                  level 2 dcl 96 ref 272
ep                              002024 automatic       pointer                  dcl 122 set ref 463* 464 488* 490 494 498 505
error_code                      002030 automatic       fixed bin(35,0)          initial dcl 128 set ref 128* 192* 209* 285* 307*
                                                                                  359* 380* 422* 435 436
error_dir                       002031 automatic       char(168)                dcl 129 set ref 191* 208* 284* 308* 360* 379* 423*
                                                                                  437
error_sw                        000105 automatic       bit(1)                   dcl 68 set ref 151* 190 207 283 306 357 378 420
error_table_$bad_string         000050 external static fixed bin(35,0)          dcl 52 ref 302
error_table_$name_not_found     000052 external static fixed bin(35,0)          dcl 53 ref 187
error_table_$no_s_permission    000054 external static fixed bin(35,0)          dcl 54 ref 338 476
error_table_$noentry            000056 external static fixed bin(35,0)          dcl 55 ref 418 440
error_table_$not_a_branch       000060 external static fixed bin(35,0)          dcl 56 ref 409
error_table_$segknown           000062 external static fixed bin(35,0)          dcl 57 ref 245
fixed                                                  builtin function         dcl 134 ref 463 480 483 487 488
fnames                          002022 automatic       fixed bin(17,0)          dcl 121 set ref 464 487* 494 498 505
get_default_wdir_               000012 constant        entry                    external dcl 27 ref 297
get_pdir_                       000014 constant        entry                    external dcl 28 ref 294
get_system_free_area_           000020 constant        entry                    external dcl 30 ref 468
get_wdir_                       000016 constant        entry                    external dcl 29 ref 291
hcs_$fs_get_path_name           000026 constant        entry                    external dcl 34 ref 199 274
hcs_$fs_get_seg_ptr             000024 constant        entry                    external dcl 33 ref 181
hcs_$get_link_target            000032 constant        entry                    external dcl 36 ref 350
hcs_$get_search_rules           000036 constant        entry                    external dcl 40 ref 140
hcs_$initiate                   000030 constant        entry                    external dcl 35 ref 233
hcs_$status_long                000040 constant        entry                    external dcl 42 ref 471
hcs_$status_minf                000042 constant        entry                    external dcl 45 ref 216 331 374
hcs_$terminate_noname           000034 constant        entry                    external dcl 37 ref 238
i                               001702 automatic       fixed bin(17,0)          dcl 84 set ref 164* 168 314*
ioa_                            000044 constant        entry                    external dcl 47 ref 534 539
it_was_a_link                   001701 automatic       bit(1)                   dcl 83 set ref 166* 345* 409
j                               001703 automatic       fixed bin(17,0)          dcl 84 set ref 494* 494* 498
known_sw                        000103 automatic       bit(1)                   dcl 66 set ref 149* 245
ldn                             001704 automatic       fixed bin(17,0)          dcl 85 set ref 199* 274*
lg_bitcount                     002007 automatic       fixed bin(24,0)          dcl 114 set ref 326 394 481* 483*
lg_chase                        002021 automatic       fixed bin(1,0)           dcl 117 set ref 323* 387* 471*
lg_name                         002010 automatic       char(32)                 unaligned dcl 115 set ref 327 389 475* 490* 498*
                                                                                  500*
lg_priname_sw                   002020 automatic       bit(1)                   dcl 116 set ref 322* 386* 490
lg_type                         002006 automatic       fixed bin(2,0)           dcl 113 set ref 325 393 480* 481
link_sw                         000104 automatic       bit(1)                   dcl 67 set ref 150* 155 345
long_bitcount             7(12) 001774 automatic       bit(24)                  level 2 packed unaligned dcl 104 set ref 483
long_branch                     001774 automatic       structure                level 1 dcl 104 set ref 471 471
long_type                       001774 automatic       bit(2)                   level 2 packed unaligned dcl 104 set ref 480
message                         000100 automatic       char(32)                 dcl 516 set ref 528* 543* 545* 551*
messages                        000000 constant        char(32)                 initial array dcl 518 ref 528
names                     1            based           char(168)                array level 2 in structure "search_rules" dcl 75
                                                                                  in procedure "execute_search_rules_" ref 168 314
names                                  based           char(32)                 array dcl 119 in procedure "execute_search_rules_"
                                                                                  ref 464 490 494 498 505
names_needed                    001677 automatic       bit(1)                   dcl 81 set ref 166* 368* 373 385
nnames                    0(02) 001774 automatic       bit(16)                  level 2 packed unaligned dcl 104 set ref 458* 461
                                                                                  487
no_s_permission                 001700 automatic       bit(1)                   dcl 82 set ref 166* 476* 485
noref_sw                        000107 automatic       bit(1)                   dcl 70 set ref 153* 268
nrp                       0(18) 001774 automatic       bit(18)                  level 2 packed unaligned dcl 104 set ref 463 488
null                                                   builtin function         dcl 134 ref 196 238 468
number                                 based           fixed bin(17,0)          level 2 dcl 75 ref 164
priname_sw                      000102 automatic       bit(1)                   dcl 65 set ref 148* 227 321 368
ptr                                                    builtin function         dcl 134 ref 463 488
rname                                  parameter       char(32)                 unaligned dcl 15 ref 11 158 559
search_rules                           based           structure                level 1 dcl 75
search_rules_ptr                000112 automatic       pointer                  dcl 74 set ref 139* 140* 164 168 314 566*
seg_ptr                         002026 automatic       pointer                  dcl 126 set ref 181* 196 199* 235 272* 274*
show_sw                         000106 automatic       bit(1)                   dcl 69 set ref 152* 170 183 203 218 279 303 314 333
                                                                                  354 376 443 474
sptr                                   parameter       pointer                  dcl 564 ref 559 566
stack_frame                            based           structure                level 1 unaligned dcl 96
stack_ptr                       001772 automatic       pointer                  dcl 94 set ref 270* 271* 271 272
stack_search_rules              000114 automatic       structure                level 1 unaligned dcl 79 set ref 139
substr                                                 builtin function         dcl 134 ref 146 147 148 149 150 151 152 153 262
switches                               parameter       bit(8)                   dcl 16 ref 11 146 147 148 149 150 151 152 153 559
system_free_area                       based           area(1024)               dcl 124 ref 464 505
system_free_ptr                 000010 internal static pointer                  initial dcl 123 set ref 463 464 468 468* 471* 488
                                                                                  505
target_sw                       000101 automatic       bit(1)                   dcl 64 set ref 147* 155 347 368 398
type                                   parameter       fixed bin(2,0)           dcl 20 set ref 11 162* 216* 325* 331* 342 374* 393*
                                                                                  559
unexpected_error                002103 automatic       bit(1)                   dcl 130 set ref 166* 193* 210* 286* 309* 318 361*
                                                                                  366 381* 408

NAME DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
me                                     internal static char(24)                 initial dcl 92

NAMES DECLARED BY EXPLICIT CONTEXT.
bad_search_rule                 001033 constant        label                    dcl 300
check_init_options              000531 constant        label                    dcl 224
check_init_segs                 000317 constant        label                    dcl 178
check_non_init                  000645 constant        label                    dcl 259
check_refname                   000545 constant        label                    dcl 229
end_search_loop                 001465 constant        label                    dcl 430 ref 173 268
examine_link                    001212 constant        label                    dcl 342
execute_search_rules_           000136 constant        entry                    external dcl 11
found_it                        001210 constant        label                    dcl 339 ref 338
get_refdir                      000655 constant        label                    dcl 265
get_target                      001220 constant        label                    dcl 347
get_target_info                 001276 constant        label                    dcl 366
got_pathname                    000456 constant        label                    dcl 213
interpret_rule                  000651 constant        label                    dcl 262
it_was_init                     000376 constant        label                    dcl 196
negative                        002044 constant        label                    dcl 531
positive                        002034 constant        label                    dcl 525
s_r_ptr                         001524 constant        entry                    external dcl 559
search_loop                     000252 constant        label                    dcl 164
show                            002024 constant        entry                    internal dcl 512 ref 170 183 203 218 279 303 314 333
                                                                                  354 376 443 474
start                           000170 constant        label                    dcl 142 ref 567
status_long_caller              001553 constant        entry                    internal dcl 453 ref 324 388
try_status                      001106 constant        label                    dcl 318

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2464        2550    2160        2474
Length      2774    2160        64         210     303           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
execute_search_rules_              1252 external procedure  is an external procedure.  
status_long_caller                  104 internal procedure  enables or reverts conditions.  
on unit on line 459                  64 on unit               
show                                100 internal procedure  is called by several nonquick procedures.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 system_free_ptr             execute_search_rules_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
execute_search_rules_    000100 chase_sw                    execute_search_rules_
                         000101 target_sw                   execute_search_rules_
                         000102 priname_sw                  execute_search_rules_
                         000103 known_sw                    execute_search_rules_
                         000104 link_sw                     execute_search_rules_
                         000105 error_sw                    execute_search_rules_
                         000106 show_sw                     execute_search_rules_
                         000107 noref_sw                    execute_search_rules_
                         000110 chase                       execute_search_rules_
                         000112 search_rules_ptr            execute_search_rules_
                         000114 stack_search_rules          execute_search_rules_
                         001677 names_needed                execute_search_rules_
                         001700 no_s_permission             execute_search_rules_
                         001701 it_was_a_link               execute_search_rules_
                         001702 i                           execute_search_rules_
                         001703 j                           execute_search_rules_
                         001704 ldn                         execute_search_rules_
                         001705 dummy_ename                 execute_search_rules_
                         001715 dummy_dirname               execute_search_rules_
                         001770 dummy_segptr                execute_search_rules_
                         001772 stack_ptr                   execute_search_rules_
                         001774 long_branch                 execute_search_rules_
                         002006 lg_type                     execute_search_rules_
                         002007 lg_bitcount                 execute_search_rules_
                         002010 lg_name                     execute_search_rules_
                         002020 lg_priname_sw               execute_search_rules_
                         002021 lg_chase                    execute_search_rules_
                         002022 fnames                      execute_search_rules_
                         002024 ep                          execute_search_rules_
                         002026 seg_ptr                     execute_search_rules_
                         002030 error_code                  execute_search_rules_
                         002031 error_dir                   execute_search_rules_
                         002103 unexpected_error            execute_search_rules_
show                     000100 message                     show

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return              enable
ext_entry           int_entry           free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$stack_frame_ptr           get_default_wdir_             get_pdir_
get_system_free_area_         get_wdir_                     hcs_$fs_get_path_name         hcs_$fs_get_seg_ptr
hcs_$get_link_target          hcs_$get_search_rules         hcs_$initiate                 hcs_$status_long
hcs_$status_minf              hcs_$terminate_noname         ioa_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_string       error_table_$name_not_found   error_table_$no_s_permission  error_table_$noentry
error_table_$not_a_branch     error_table_$segknown




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    128 000125        11 000130       139 000157       140 000161       142 000170       146 000171       147 000175
    148 000201       149 000205       150 000211       151 000215       152 000221       153 000225       155 000231
    158 000241       162 000246       164 000252       166 000261       168 000265       170 000274       173 000306
    178 000313       181 000317       183 000340       187 000354       190 000361       191 000363       192 000367
    193 000370       196 000372       199 000376       201 000427       203 000431       207 000443       208 000445
    209 000451       210 000453       211 000455       216 000456       218 000513       224 000527       227 000531
    229 000540       233 000545       235 000610       238 000620       241 000635       245 000636       251 000643
    257 000644       262 000645       265 000651       268 000655       270 000657       271 000666       272 000671
    274 000673       278 000724       279 000726       283 000740       284 000742       285 000746       286 000750
    289 000752       291 000753       294 000773       297 001013       302 001033       303 001036       306 001047
    307 001051       308 001053       309 001057       314 001061       318 001104       321 001106       322 001110
    323 001112       324 001114       325 001120       326 001122       327 001124       328 001130       331 001131
    333 001166       338 001202       339 001206       342 001210       345 001212       347 001216       350 001220
    352 001246       354 001250       357 001262       359 001264       360 001266       361 001272       366 001274
    368 001276       373 001311       374 001315       375 001354       376 001356       378 001370       379 001372
    380 001376       381 001400       385 001402       386 001404       387 001405       388 001407       389 001413
    392 001420       393 001422       394 001424       398 001426       399 001430       400 001434       408 001440
    409 001442       413 001451       418 001452       420 001456       422 001460       423 001461       430 001465
    435 001467       436 001471       437 001472       438 001476       440 001477       443 001502       445 001514
    559 001515       566 001545       567 001551       453 001552       458 001560       459 001563       461 001577
    463 001604       464 001611       466 001615       468 001616       471 001631       473 001670       474 001673
    475 001706       476 001713       477 001722       480 001723       481 001726       483 001732       485 001735
    487 001737       488 001743       490 001751       494 001757       496 001777       498 002001       500 002011
    502 002015       505 002016       507 002022       512 002023       525 002031       527 002034       528 002036
    529 002043       533 002044       534 002046       535 002067       538 002070       539 002072       540 002103
    543 002104       545 002114       547 002122       551 002123       552 002152


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
