	COMPILATION LISTING OF SEGMENT vrmu_search_init
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/21/84  1338.2 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 vrmu_search_init: proc (I_cursor_ptr, I_spec_ptr, O_code);
        8 
        9 
       10 	dcl     I_cursor_ptr	 ptr parameter;	/* Pointer to vrm_cursor */
       11 	dcl     I_spec_ptr		 ptr parameter;	/* Pointer to dm_relation_search_specification*/
       12 	dcl     O_code		 fixed bin (35) parameter; /* Error code */
       13 
       14 /*	          BEGIN_DESCRIPTION
       15*
       16*    
       17*    This module builds the vrm_search_list. It is called from vrm_get_by_spec
       18*    to initialize for vrmu_search.
       19*
       20*    If a relation_search_specification constriants are supplied they are
       21*    translated to the vrm_search_list.   If a collection_id was supplied in the
       22*    relation_search_specification and key attribute constraints are supplied 
       23*    the vrm_search_list is optimized and setup for a seek_head (done in
       24*    vrmu_search) is done.
       25*
       26*    All key attribute constraints are compared to other constraints on
       27*    the same attribute.  Inconsistent constraints cause the switch
       28*    do_not_use_sw to be set.  Duplicate constraints are removed.
       29*
       30*                    END_DESCRIPTION
       31*
       32*    HISTORY:
       33*    Written by Roger Lackey:
       34*    83-10-01 Roger Lackey :  modified to handle multi attribute keys in 
       35*                             seek headed setup.
       36*    83-10-25 Roger Lackey : Added vrmu_scan_records$scan_records_init for the 
       37*                            case where num_and_groups = 0; 
       38*    84-06-11 Bert Moberg : Major rewrite to fix several problems including
       39*         		       not using all of the available key head and a sort
       40*		       loop that did not sort.
       41**/
       42 
       43 /* vrmu_search_init: proc (I_cursor_ptr, I_spec_ptr, O_code); */
       44 
       45 
       46 /* Init parameters */
       47 
       48 	vrm_cursor_ptr = I_cursor_ptr;
       49 
       50 	relation_search_specification_ptr = I_spec_ptr;
       51 	O_code = 0;
       52 
       53 /* Init local variables */
       54 
       55 	vrm_open_info_ptr = vrm_cursor.open_info_ptr;
       56 	vrm_com_ptr = vrm_open_info.com_ptr;
       57 	vrm_rel_desc_ptr = vrm_cursor.vrm_relation_desc_ptr;
       58 	num_search_keys_used = 0;
       59 
       60 /* Clean up old storage */
       61 	if vrm_cursor.search_list_ptr ^= null then
       62 	     free vrm_cursor.search_list_ptr -> vrm_search_list;
       63 	vrm_cursor.search_list_ptr = null;
       64 
       65 	if vrm_cursor.search_keys_ptr ^= null then
       66 	     free vrm_cursor.search_keys_ptr -> search_keys;
       67 	vrm_cursor.search_keys_ptr = null;
       68 
       69 	if relation_search_specification_ptr = null then do;
       70 	     vsl_number_of_and_groups = 0;
       71 	     vsl_max_number_of_constraints = 0;
       72 
       73 	     allocate vrm_search_list in (get_area) set (vrm_search_list_ptr);
       74 	     vrm_cursor.search_list_ptr = vrm_search_list_ptr;
       75 
       76 	     vrm_search_list.num_and_groups = vsl_number_of_and_groups;
       77 	     vrm_search_list.max_num_constraints = vsl_max_number_of_constraints;
       78 	end;
       79 
       80 	else do;  /* relation_search_specification_ptr ^= null */
       81 	     call vrmu_validate_spec (vrm_cursor_ptr,
       82 		relation_search_specification_ptr,
       83 		alloc_num_search_keys, code);
       84 	     if code ^= 0 then call error (code);
       85 
       86 	     if alloc_num_search_keys > 0 then do;
       87 		allocate search_keys in (get_area) set (search_keys_ptr);
       88 		vrm_cursor.search_keys_ptr = search_keys_ptr; ;
       89 	     end;
       90 
       91 	     vsl_number_of_and_groups = relation_search_specification.number_of_and_groups;
       92 	     vsl_max_number_of_constraints = relation_search_specification.maximum_number_of_constraints;
       93 
       94 	     allocate vrm_search_list in (get_area) set (vrm_search_list_ptr);
       95 	     vrm_cursor.search_list_ptr = vrm_search_list_ptr;
       96 
       97 	     vrm_search_list.num_and_groups = vsl_number_of_and_groups;
       98 	     vrm_search_list.max_num_constraints = vsl_max_number_of_constraints;
       99 
      100 	     do ag = 1 to relation_search_specification.number_of_and_groups; /* Look at all and groups */
      101 		key_head_attr_exists = "0"b;
      102 		call build_vrm_and_group;
      103 		if collection_id_found then call validate_all_key_constraints;
      104 		if key_head_attr_exists
      105 		 & ^vrm_search_list.and_groups (ag).do_not_use_sw
      106 		then call optimize_and_group;
      107 	     end;
      108 
      109 	end; /* relation_search_specification ^= null */
      110 
      111 	if vrm_search_list.num_and_groups > 0 then
      112 	     vrm_search_list.current_and_group = 1;
      113 	else do;					/* It has to be scan_records type */
      114 	     call vrmu_scan_records$scan_records_init (iocb_ptr, code);
      115 	     if code ^= 0 then call error (code);
      116 	     vrm_search_list.current_and_group = 0;
      117 	end;
      118 
      119 	if db_sw then call vrm_display_search_list$subroutine (vrm_cursor_ptr);
      120 
      121 exit:	return;
      122 
      123 build_vrm_and_group: proc;
      124 
      125 /* Fill in the vrm_search_list with info from relation_search_specification from vrm_rel_desc */
      126 
      127 	   vrm_search_list.and_groups (ag).num_cons_in_this_and_group =
      128 	        relation_search_specification.and_group (ag).number_of_constraints;
      129 
      130 	   vrm_search_list.and_groups (ag).seek_key_con_ix = 0;
      131 	   vrm_search_list.and_groups (ag).do_not_use_sw = "0"b;
      132 
      133 	   vrm_search_list.and_groups (ag).collection_id_supplied_sw =
      134 	        relation_search_specification.and_group (ag).flags.collection_id_supplied;
      135 
      136 	   vrm_search_list.and_groups (ag).collection_id =
      137 	        relation_search_specification.and_group (ag).search_collection_id;
      138 
      139 	   if vrm_search_list.and_groups (ag).num_cons_in_this_and_group > 0 then
      140 	        vrm_search_list.and_groups (ag).must_initialize_sw = "1"b;
      141 	   vrm_search_list.and_groups (ag).multi_attr_seek_head_sw = "0"b;
      142 	   vrm_search_list.and_groups (ag).full_key_equal_only_sw = "0"b;
      143 
      144 	   vrm_collection_info_ptr = null;
      145 	   collection_id_found = "0"b;
      146 
      147 	   if vrm_search_list.and_groups (ag).collection_id_supplied_sw then do;
      148 
      149 	        if vrm_search_list.and_groups (ag).collection_id = "0"b then do; /* Primary key collection */
      150 		   collection_id_found = "1"b;
      151 		   vrm_collection_info_ptr = vrm_open_info.primary_key_info_ptr;
      152 	        end;
      153 
      154 	        else if vrm_search_list.and_groups (ag).collection_id = RELATION_COLLECTION_ID then do;
      155 	        end;
      156 
      157  /* Since it is not the relation collection and it is not the primary key collect, it must be an index collection */
      158 	        else do;
      159 		   do i = 1 to vrm_open_info.number_of_index_collections while (^collection_id_found);
      160 		        if vrm_search_list.and_groups (ag).collection_id =
      161 			   vrm_open_info.index_collection (i).id then do;
      162 			   collection_id_found = "1"b;
      163 			   vrm_collection_info_ptr = vrm_open_info.index_collection (i).info_ptr;
      164 		        end;
      165 		   end;
      166 		   if ^collection_id_found then do;
      167 		        call sub_err_ (mrds_error_$internal_error,
      168 			   "vrmu_search_init", ACTION_CANT_RESTART, null, 0,
      169 			   "A collection_id was specified in the relation_search_specification that was not found in the relation.");
      170 		   end;
      171 	        end;	/* index collection id supplied */
      172 
      173 	   end;  /* collection id supplied */
      174 
      175 	   vrm_search_list.and_groups (ag).collection_info_ptr = vrm_collection_info_ptr;
      176 	   key_cons_this_group = 0;
      177 
      178 	   do c = 1 to relation_search_specification.and_group (ag).number_of_constraints;
      179 
      180 	        if relation_search_specification.and_group (ag).constraint (c).value_ptr ^= null
      181 	        then do;
      182 		   call convert_one_constraint;
      183 		   if collection_id_found then call check_for_key_attr;
      184 	        end;
      185 	        else call sub_err_ (mrds_error_$internal_error,
      186 			   "vrmu_search_init", ACTION_CANT_RESTART, null, 0,
      187 			   "A constraint was specified with a null value pointer");
      188 	   end;
      189 	   vrm_search_list.and_groups (ag).num_key_cons_in_this_and_group = key_cons_this_group;
      190 
      191      end build_vrm_and_group;
      192 
      193 /* * * * * * * * * *   convert_one_constraint   * * * * * * * * * */
      194 
      195 convert_one_constraint: proc;
      196 
      197 	unspec (vrm_search_list.and_groups (ag).cons (c)) = "0"b; /* Zero everything */
      198 
      199 	vrm_search_list.and_groups (ag).cons (c).valid_sw = "1"b;
      200 	vrm_search_list.and_groups (ag).cons (c).val_ptr =
      201 	     relation_search_specification.and_group (ag).constraint (c).value_ptr;
      202 
      203 	x = relation_search_specification.and_group (ag).constraint (c).field_id;
      204 
      205 	vrm_search_list.and_groups (ag).cons (c).attr_index = x;
      206 	vrm_search_list.and_groups (ag).cons (c).attr_desc_ptr = addr (vrm_rel_desc.attr (x).descriptor);
      207 	vrm_search_list.and_groups (ag).cons (c).attr_bit_length = vrm_rel_desc.attr (x).bit_length;
      208 
      209 	vrm_search_list.and_groups (ag).cons (c).encoded_key_ptr = null;
      210 
      211 	vrm_search_list.and_groups (ag).cons (c).operator =
      212 	     relation_search_specification.and_group (ag).constraint (c).operator_code;
      213 
      214 	vrm_search_list.and_groups (ag).cons (c).key_attr_sw = "0"b;	/* Until we know better */
      215 
      216 	return;
      217 
      218      end convert_one_constraint;
      219 
      220 /* * * * * * * * * * * * * * *   check_for_key_attr  * * * * * * * * * *   */
      221 
      222 check_for_key_attr: proc;
      223 
      224 	key_attr_found = "0"b;
      225 
      226 	do cx = 1 to vrm_collection_info.number_of_attributes while (^key_attr_found);
      227 
      228 	     if relation_search_specification.and_group (ag).constraint (c).field_id =
      229 		vrm_collection_info.attribute (cx).attr_index
      230 	     then do; /* It is a key attribute */
      231 
      232 		key_attr_found = "1"b;
      233 
      234 		key_cons_this_group = key_cons_this_group + 1;
      235 		vrm_search_list.and_groups (ag).cons (c).key_attr_sw = "1"b;
      236 		vrm_search_list.and_groups (ag).cons (c).attr_position_in_key = cx;
      237 
      238 		if vrm_collection_info.attribute (cx).key_offset = 0 then do;
      239 		     vrm_search_list.and_groups (ag).cons (c).key_head_sw = "1"b;
      240 		     key_head_attr_exists = "1"b;
      241 
      242 		     if vrm_search_list.and_groups (ag).cons (c).operator < 4 then
      243 			vrm_search_list.and_groups (ag).cons (c).seek_head_sw = "1"b;
      244 		end;
      245 
      246 		vrm_search_list.and_groups (ag).cons (c).key_offset =
      247 		     vrm_collection_info.attribute (cx).key_offset;
      248 
      249 		vrm_search_list.and_groups (ag).cons (c).key_bit_length =
      250 		     vrm_collection_info.attribute (cx).key_bit_len;
      251 
      252 		num_search_keys_used = num_search_keys_used + 1;
      253 
      254 		call vrmu_encode_key$encode_attr
      255 		     ((relation_search_specification.and_group (ag).constraint (c).value_ptr),
      256 		     addr (vrm_rel_desc.attr (relation_search_specification.and_group (ag).constraint (c).field_id).descriptor),
      257 		     search_keys (num_search_keys_used), code);
      258 
      259 		if code ^= 0 then call error (code);
      260 
      261 		vrm_search_list.and_groups (ag).cons (c).search_keys_ix = num_search_keys_used;
      262 
      263 		vrm_search_list.and_groups (ag).cons (c).encoded_key_ptr =
      264 		     addrel (addr (search_keys (num_search_keys_used)), 1);
      265 		vrm_search_list.and_groups (ag).cons (c).encoded_key_length =
      266 		     length (search_keys (num_search_keys_used));
      267 
      268 	     end; /* Found key attribute */
      269 
      270 	end; /* Look for key attribute */
      271 
      272 	if key_attr_found then do;
      273 
      274 /* if the key constraint is not at the begining of the constraint list, put it there */
      275 	     if c ^= key_cons_this_group then call switch_constraints (c, key_cons_this_group, switched);
      276 
      277 /* Sort the key constraints in order by their position within the key */
      278 /* If the attributes are in the same position, sort by operator */
      279 	     switched = "1"b;
      280 	     do cx = key_cons_this_group - 1 to 1 by -1 while (switched);
      281 		switched = "0"b;
      282 		/* if position in key wrong */
      283 		if vrm_search_list.and_groups (ag).cons (cx).attr_position_in_key >
      284 		     vrm_search_list.and_groups (ag).cons (cx + 1).attr_position_in_key
      285 		     then call switch_constraints (cx, cx + 1, switched);
      286 		/* else if position in key right, but operators in wrong order */
      287 		else if vrm_search_list.and_groups (ag).cons (cx).attr_position_in_key =
      288 		     vrm_search_list.and_groups (ag).cons (cx + 1).attr_position_in_key
      289 		   & vrm_search_list.and_groups (ag).cons (cx).operator >
      290 		     vrm_search_list.and_groups (ag).cons (cx + 1).operator
      291 		     then call switch_constraints (cx, cx + 1, switched);
      292 	     end; /* sort loop */
      293 
      294 	end;
      295 
      296      end check_for_key_attr;
      297 
      298 /* * * * * * * * * * * * * * *   validate_all_key_constraints  * * * * * * * * * *   */
      299 
      300 validate_all_key_constraints: proc;
      301 
      302 	c1 = 1;
      303 	do while (c1 < vrm_search_list.and_groups (ag).num_key_cons_in_this_and_group);
      304 
      305 retry_c2:	     do c2 = c1 + 1 to vrm_search_list.and_groups (ag).num_key_cons_in_this_and_group;
      306 
      307 /* If the current two constraints are on the sma attribute, cross validate them */
      308 		if vrm_search_list.and_groups (ag).cons (c1).attr_position_in_key
      309 		 = vrm_search_list.and_groups (ag).cons (c2).attr_position_in_key then do;
      310 		     call validate_constraints (c1, c2, action);
      311 		     go to perform (action);
      312 
      313 		/* keep both constraints */
      314 perform (1):	     goto next_c2;
      315 
      316 		/* remove first constraint */
      317 perform (2):	     call remove_key_constraint (c1);
      318 		     goto retry_c2;
      319 
      320 		/* remove second constraint */
      321 perform (3):	     call remove_key_constraint (c2);
      322 		     goto retry_c2;
      323 
      324 		/* remove second constraint and make first constraint equals operator */
      325 perform (4):	     call remove_key_constraint (c2);
      326 		     vrm_search_list.and_groups (ag).cons (c1).operator = 1;
      327 		     goto retry_c2;
      328 
      329 		/* kill and group */
      330 perform (5):	     vrm_search_list.and_groups (ag).do_not_use_sw = "1"b;
      331 		     return;
      332 
      333 		end;	/* Two constraints on same attribute */
      334 
      335 next_c2:
      336 	     end;		/* do while more attributes with same position */
      337 
      338 	     c1 = c1 + 1;
      339 	end;	/* do while more attributes in key */
      340 
      341 
      342      end validate_all_key_constraints;
      343 
      344 /* * * * * * * * * * * * * * *   validate_constraints  * * * * * * * * * *   */
      345 validate_constraints: proc (con_1, con_2, action);
      346 
      347 /* This procedure cross validates two constraints within an and group  */
      348 /* This procedure assumes that con_1 < con_2 and
      349*   cons (con_1).operator <= cons (con_2).operator	*/
      350 
      351 	dcl     con_1		 fixed bin parameter; /* First constraint */
      352 	dcl     con_2		 fixed bin parameter; /* Second constaint */
      353 	dcl     action		 fixed bin parameter;
      354 
      355 	goto first_op (vrm_search_list.and_groups (ag).cons (con_1).operator);
      356 
      357 /* If first operator is equals, then if this value meets the second constraint,
      358*   the second constraint is not needed.  If it does not meet the second
      359*   constraint, the and group will never match */
      360 
      361 first_op (1):	/* op1 is =, op2 is ? */
      362 	if key_compare (con_1, (vrm_search_list.and_groups (ag).cons (con_2).operator), con_2) then
      363 	     action = REMOVE_B;
      364 	else action = KILL_AND_GROUP;
      365 	return;
      366 
      367 first_op (2):	/* op1 is >, op2 is ? */
      368 	goto first_op_greater (vrm_search_list.and_groups (ag).cons (con_2).operator);
      369 
      370 first_op_greater (2):	/* op1 is >, op2 is > */
      371 	if key_compare (con_1, LESS_OPERATOR_CODE, con_2) then
      372 	     action = REMOVE_A;
      373 	else action = REMOVE_B;
      374 	return;
      375 
      376 first_op_greater (3):	/* op1 is >, op2 is >= */
      377 	if key_compare (con_1, LESS_OPERATOR_CODE, con_2) then
      378 	     action = REMOVE_A;
      379 	else action = REMOVE_B;
      380 	return;
      381 
      382 first_op_greater (4):	/* Not used */
      383 	goto bad_code;
      384 
      385 first_op_greater (5):	/* op1 is >, op2 is ^= */
      386 	if key_compare (con_1, LESS_OPERATOR_CODE, con_2) then
      387 	     action = KEEP_BOTH;
      388 	else action = REMOVE_B;
      389 	return;
      390 
      391 first_op_greater (6):	/* op1 is >, op2 is <= */
      392 	if key_compare (con_1, LESS_OPERATOR_CODE, con_2) then
      393 	     action = KEEP_BOTH;
      394 	else action = KILL_AND_GROUP;
      395 	return;
      396 
      397 first_op_greater (7):	/* op1 is >, op2 is < */
      398 	if key_compare (con_1, LESS_OPERATOR_CODE, con_2) then
      399 	     action = KEEP_BOTH;
      400 	else action = KILL_AND_GROUP;
      401 	return;
      402 
      403 first_op (3):	/* op1 is >=, op2 is ? */
      404 	goto first_op_greater_or_equal (vrm_search_list.and_groups (ag).cons (con_2).operator);
      405 
      406 first_op_greater_or_equal (3):	/* op1 is >=, op2 is >= */
      407 	if key_compare (con_1, LESS_OPERATOR_CODE, con_2) then
      408 	     action = REMOVE_A;
      409 	else action = REMOVE_B;
      410 	return;
      411 
      412 first_op_greater_or_equal (4):	/* Not used */
      413 	goto bad_code;
      414 
      415 first_op_greater_or_equal (5):	/* op1 is >=, op2 is ^= */
      416 	if key_compare (con_1, LESS_OR_EQUAL_OPERATOR_CODE, con_2) then
      417 	     action = KEEP_BOTH;
      418 	else action = REMOVE_B;
      419 	return;
      420 
      421 first_op_greater_or_equal (6):	/* op1 is >=, op2 is <= */
      422 	if key_compare (con_1, LESS_OPERATOR_CODE, con_2) then
      423 	     action = KEEP_BOTH;
      424 	else if key_compare (con_1, EQUAL_OPERATOR_CODE, con_2) then
      425 	     action = REMOVE_B_MAKE_A_EQUALS;
      426 	else action = KILL_AND_GROUP;
      427 	return;
      428 
      429 first_op_greater_or_equal (7):	/* op1 is >, op2 is < */
      430 	if key_compare (con_1, LESS_OPERATOR_CODE, con_2) then
      431 	     action = KEEP_BOTH;
      432 	else action = KILL_AND_GROUP;
      433 	return;
      434 
      435 first_op (4):	/* Not used */
      436 bad_code: call sub_err_ (mrds_error_$internal_error,
      437 	     "vrmu_search_init", ACTION_CANT_RESTART, null, 0,
      438 	     "A constraint was specified with an invalid operation code");
      439 
      440 first_op (5):	/* op1 is ^=, op2 is ? */
      441 	goto first_op_not_equal (vrm_search_list.and_groups (ag).cons (con_2).operator);
      442 
      443 first_op_not_equal (5):	/* op1 is ^=, op2 is ^= */
      444 	if key_compare (con_1, NOT_EQUAL_OPERATOR_CODE, con_2) then
      445 	     action = KEEP_BOTH;
      446 	else action = REMOVE_B;
      447 	return;
      448 
      449 first_op_not_equal (6):	/* op1 is ^=, op2 is <= */
      450 	if key_compare (con_1, LESS_OR_EQUAL_OPERATOR_CODE, con_2) then
      451 	     action = KEEP_BOTH;
      452 	else action = REMOVE_A;
      453 	return;
      454 
      455 first_op_not_equal (7):	/* op1 is ^=, op2 is < */
      456 	if key_compare (con_1, LESS_OPERATOR_CODE, con_2) then
      457 	     action = KEEP_BOTH;
      458 	else action = REMOVE_A;
      459 	return;
      460 
      461 first_op (6):	/* op1 is <=, op2 is ? */
      462 	goto first_op_less_or_equal (vrm_search_list.and_groups (ag).cons (con_2).operator);
      463 
      464 first_op_less_or_equal (6):	/* op1 is <=, op2 is <= */
      465 	if key_compare (con_1, GREATER_OPERATOR_CODE, con_2) then
      466 	     action = REMOVE_A;
      467 	else action = REMOVE_B;
      468 	return;
      469 
      470 first_op_less_or_equal (7):	/* op1 is <=, op2 is < */
      471 	if key_compare (con_1, GREATER_OR_EQUAL_OPERATOR_CODE, con_2) then
      472 	     action = REMOVE_A;
      473 	else action = REMOVE_B;
      474 	return;
      475 
      476 first_op (7):	/* op1 is <, op2 is < */
      477 	if key_compare (con_1, GREATER_OPERATOR_CODE, con_2) then
      478 	     action = REMOVE_A;
      479 	else action = REMOVE_B;
      480 	return;
      481 
      482      end validate_constraints;
      483 
      484 /*    * * * * * * * * * * * * *     key_compare    * * * * * * * * * * * *   */
      485 
      486 /* Compares two key values using one of six operators */
      487 
      488 key_compare: proc (con_1, operator, con_2) returns (bit (1));
      489 
      490 	dcl     con_1		 fixed bin parameter; /* First constraint */
      491 	dcl     con_2		 fixed bin parameter; /* Second constaint */
      492 	dcl     operator		 fixed bin (17) parameter; /* Comparison operator */
      493 
      494 	dcl     key_one_ptr		 ptr;		  /* Pointer to first key value */
      495 	dcl     key_two_ptr		 ptr;		  /* Pointer to second key value */
      496 	dcl     key_len		 fixed bin (17);	  /* Length of both key values in bits */
      497 
      498 	dcl     key_one		 bit (key_len) based (key_one_ptr);
      499 	dcl     key_two		 bit (key_len) based (key_two_ptr);
      500 
      501 	key_one_ptr = vrm_search_list.and_groups (ag).cons (con_1).encoded_key_ptr;
      502 	key_two_ptr = vrm_search_list.and_groups (ag).cons (con_2).encoded_key_ptr;
      503 	key_len = vrm_search_list.and_groups (ag).cons (con_1).key_bit_length;
      504 
      505 	goto k_compare (operator);
      506 
      507 k_compare (1):					/* Operator:  =  */
      508 	if key_one = key_two then return ("1"b);
      509 	else return ("0"b);
      510 
      511 k_compare (2):					/* Operator:  >  */
      512 	if key_one > key_two then return ("1"b);
      513 	else return ("0"b);
      514 
      515 k_compare (3):					/* Operator:  >=  */
      516 	if key_one >= key_two then return ("1"b);
      517 	else return ("0"b);
      518 
      519 k_compare (5):					/* Operator:  ^=  */
      520 	if key_one ^= key_two then return ("1"b);
      521 	else return ("0"b);
      522 
      523 k_compare (6):					/* Operator:  <=  */
      524 	if key_one <= key_two then return ("1"b);
      525 	else return ("0"b);
      526 
      527 k_compare (7):					/* Operator:  <  */
      528 	if key_one < key_two then return ("1"b);
      529 	else return ("0"b);
      530 
      531      end key_compare;
      532 
      533 /* * * * * * * * * * * * * * *   remove_key_constraint  * * * * * * * * * *   */
      534 remove_key_constraint: proc (con);
      535 
      536 	dcl     con		 fixed bin parameter; /* constraint to remove */
      537 	dcl     cx		 fixed bin;
      538 	dcl     switched		 bit (1) aligned;
      539 
      540 	do cx = con to vrm_search_list.and_groups (ag).num_cons_in_this_and_group - 1;
      541 	     call switch_constraints (cx, cx + 1, switched);
      542 	end;
      543 
      544 	vrm_search_list.and_groups (ag).num_cons_in_this_and_group =
      545 	     vrm_search_list.and_groups (ag).num_cons_in_this_and_group - 1;
      546 	vrm_search_list.and_groups (ag).num_key_cons_in_this_and_group =
      547 	     vrm_search_list.and_groups (ag).num_key_cons_in_this_and_group - 1;
      548 
      549 	return;
      550 
      551      end remove_key_constraint;
      552 
      553 /* * * * * * * * * * * * * * *   optimize_and_group  * * * * * * * * * *   */
      554 optimize_and_group: proc;
      555 
      556 	done_sw = "0"b;
      557 	last_op_was_equal = "0"b;
      558 	next_key_pos = 1;
      559 	num_seek_head_attr = 0;
      560 
      561 	do c = 1 to vrm_search_list.and_groups (ag).num_key_cons_in_this_and_group while (^done_sw);
      562 
      563 	     if vrm_search_list.and_groups (ag).cons (c).attr_position_in_key ^= next_key_pos then
      564 		done_sw = "1"b;
      565 	     else do;
      566 
      567 		last_op_was_equal = "0"b;
      568 		/* operator is = */
      569 		if vrm_search_list.and_groups (ag).cons (c).operator = 1 then do;
      570 		     last_op_was_equal = "1"b;
      571 		     next_key_pos = next_key_pos + 1;
      572 		     num_seek_head_attr = num_seek_head_attr + 1;
      573 		     vrm_search_list.and_groups (ag).cons (c).and_group_search_terminator = "1"b;
      574 		     vrm_search_list.and_groups (ag).cons (c).seek_head_sw = "1"b;
      575 		end;
      576 		/* operator is > or >= */
      577 		else if vrm_search_list.and_groups (ag).cons (c).operator < 4 then do;
      578 		     vrm_search_list.and_groups (ag).cons (c).seek_head_sw = "1"b;
      579 		     num_seek_head_attr = num_seek_head_attr + 1;
      580 		end;
      581 		/* operator is < or <= */
      582 		else if vrm_search_list.and_groups (ag).cons (c).operator > 5 then do;
      583 		     vrm_search_list.and_groups (ag).cons (c).and_group_search_terminator = "1"b;
      584 		     done_sw = "1"b;
      585 		end;
      586 
      587 	     end;		/* attribute in right position */
      588 
      589 	end;	/* loop over all attributes */
      590 
      591 	if last_op_was_equal then do;
      592 	     if vrm_collection_info.unique & num_seek_head_attr = vrm_collection_info.number_of_attributes then
      593 		vrm_search_list.and_groups (ag).full_key_equal_only_sw = "1"b;
      594 	end;
      595 
      596 /* See if a bad key attribute exist in key_head
      597*   One that cannot be character aligned */
      598 	if num_seek_head_attr < vrm_collection_info.number_of_attributes then do;
      599 
      600 	     done_sw = "0"b;
      601 	     do x = num_seek_head_attr to 1 by -1 while (^done_sw);
      602 		/* if the next key attribute does not start on a character
      603*		     position, we must back up on */
      604 		if mod (vrm_collection_info.attribute (x + 1).key_offset, 9) ^= 0 then do;
      605 		     vrm_search_list.and_groups (ag).cons (x).seek_head_sw = "0"b;
      606 		     vrm_search_list.and_groups (ag).cons (x).and_group_search_terminator = "0"b;
      607 		     num_seek_head_attr = num_seek_head_attr - 1;
      608 		end;
      609 		else done_sw = "1"b;
      610 	     end;
      611 	end;
      612 
      613 	vrm_search_list.and_groups (ag).seek_key_con_ix = num_seek_head_attr;
      614 	vrm_search_list.and_groups (ag).num_seek_key_attr_count = num_seek_head_attr;
      615 	if num_seek_head_attr > 1 then do;
      616 	     vrm_search_list.and_groups (ag).multi_attr_seek_head_sw = "1"b;
      617 	end;
      618 
      619      end optimize_and_group;
      620 
      621 /* * * * * * * * * * * * *     switch_constraints   * * * * * * * * * *    */
      622 
      623 switch_constraints: proc (con_1, con_2, switched_flag);
      624 
      625 /* This procedure switches constraint info with in an and group 
      626*   moving first constraint to seconds position and visa-versa          */
      627 
      628 	dcl     con_1		 fixed bin parameter; /* First constraint */
      629 	dcl     con_2		 fixed bin parameter; /* Second constaint */
      630 	dcl     switched_flag	 bit (1) aligned parameter;
      631 
      632 	switched_flag = "1"b;
      633 
      634 	temp_constraint_info = vrm_search_list.and_groups (ag).cons (con_1);
      635 
      636 	vrm_search_list.and_groups (ag).cons (con_1) =
      637 	     vrm_search_list.and_groups (ag).cons (con_2);
      638 
      639 	vrm_search_list.and_groups (ag).cons (con_2) = temp_constraint_info;
      640 
      641      end switch_constraints;
      642 
      643 /* * * * * * * * * * * * * * * * * * *     error   * * * * * * * * * * * *  */
      644 
      645 
      646 error: proc (cd);
      647 
      648 	dcl     cd		 fixed bin (35) parameter;
      649 
      650 	O_code = cd;
      651 	goto exit;
      652 
      653      end error;
      654 
      655 
      656 
      657 
      658 
      659 db_on: entry;
      660 	db_sw = "1"b;
      661 	return;
      662 
      663 
      664 db_off: entry;
      665 	db_sw = "0"b;
      666 	return;
      667 
  1     1 /* BEGIN INCLUDE FILE - dm_operator_constants.incl.pl1 */
  1     2 
  1     3 /* Written by Lindsey Spratt, 07/07/82
  1     4*Modified:
  1     5*10/07/82 by Lindsey Spratt:  Added the GREATER, LESS, GREATER_OR_EQUAL,
  1     6*	  LESS_OR_EQUAL and REGULAR_EXPRESSION operator codes.  Also, added
  1     7*	  bit(1) arrays for determining if a given operator code "uses" a
  1     8*	  given operator.  For example, USES_LESS_OPERATOR(x) = "1"b only if
  1     9*	  x = LESS_OPERATOR_CODE or x = LESS_OR_EQUAL_OPERATOR_CODE.
  1    10**/
  1    11 
  1    12 /* format: style2,ind3 */
  1    13      dcl	   (
  1    14 	   EQUAL_OPERATOR_CODE    init (1),
  1    15 	   GREATER_OPERATOR_CODE  init (2),
  1    16 	   LESS_OPERATOR_CODE     init (7),
  1    17 	   REGULAR_EXPRESSION_OPERATOR_CODE
  1    18 			      init (8),
  1    19 	   NOT_EQUAL_OPERATOR_CODE
  1    20 			      init (5),
  1    21 	   GREATER_OR_EQUAL_OPERATOR_CODE
  1    22 			      init (3),
  1    23 	   LESS_OR_EQUAL_OPERATOR_CODE
  1    24 			      init (6),
  1    25 	   EQUAL_IDX	      init (18),
  1    26 	   GREATER_IDX	      init (17),
  1    27 	   NOT_IDX	      init (16),
  1    28 	   REGULAR_EXPRESSION_IDX init (15)
  1    29 	   )		      fixed bin internal static options (constant);
  1    30 
  1    31      dcl	   (
  1    32 	   USES_LESS_OPERATOR     init ("0"b, (5) (1)"0"b, "1"b /* <= */, "1"b /* < */, (24) (1)"0"b),
  1    33 	   USES_GREATER_OPERATOR  init ("0"b, "0"b, "1"b /* > */, "1"b /* >= */, (28) (1)"0"b),
  1    34 	   USES_EQUAL_OPERATOR    init ("0"b, "1"b /* = */, "0"b, "1"b /* >= */, "0"b, "0"b, "1"b /* <= */,
  1    35 			      (25) (1)"0"b),
  1    36 	   USES_REGULAR_EXPRESSION_OPERATOR
  1    37 			      init ("0"b, (7) (1)"0"b, "1"b /* reg exp */, (3) (1)"0"b, "1"b /* not reg exp */,
  1    38 			      (19) (1)"0"b)
  1    39 	   )		      dimension (0:31) bit (1) unaligned internal static options (constant);
  1    40 
  1    41 /* END INCLUDE FILE - dm_operator_constants.incl.pl1 */
      668 
      669 
  2     1 /* BEGIN INCLUDE FILE dm_relation_spec.incl.pl1 */
  2     2 
  2     3 /* HISTORY:
  2     4*Written by Matthew Pierret, 05/10/83.
  2     5*Modified:
  2     6**/
  2     7 
  2     8 /* format: style2,ind3 */
  2     9      dcl	   1 relation_search_specification
  2    10 			      aligned based (relation_search_specification_ptr),
  2    11 	     2 head	      like specification_head,
  2    12 	     2 maximum_number_of_constraints
  2    13 			      fixed bin (17) unal,
  2    14 	     2 number_of_and_groups
  2    15 			      fixed bin (17) unal,
  2    16 	     2 flags	      unal,
  2    17 	       3 return_unique_tuples
  2    18 			      bit (1) unal,
  2    19 	       3 mbz	      bit (35) unal,
  2    20 	     2 range,
  2    21 	       3 type	      fixed bin (17),
  2    22 	       3 size	      fixed bin (17),
  2    23 	     2 and_group	      (rss_number_of_and_groups refer (relation_search_specification.number_of_and_groups)),
  2    24 	       3 search_collection_id
  2    25 			      bit (36) aligned,
  2    26 	       3 flags	      unal,
  2    27 	         4 collection_id_supplied
  2    28 			      bit (1) unal,
  2    29 	         4 mbz	      bit (17) unal,
  2    30 	       3 number_of_constraints
  2    31 			      fixed bin (17) unal,
  2    32 	       3 constraint	      (rss_maximum_number_of_constraints
  2    33 			      refer (relation_search_specification.maximum_number_of_constraints)),
  2    34 	         4 field_id	      fixed bin (17) unal,
  2    35 	         4 operator_code  fixed bin (17) unal,
  2    36 	         4 value_field_id fixed bin (17) unal,
  2    37 	         4 mbz	      bit (18) unal,
  2    38 	         4 value_ptr      ptr;
  2    39 
  2    40 
  2    41      dcl	   1 relation_numeric_specification
  2    42 			      aligned based (relation_numeric_specification_ptr),
  2    43 	     2 head	      like specification_head,
  2    44 	     2 collection_id      bit (36) aligned,
  2    45 	     2 range_size	      fixed bin (35),
  2    46 	     2 position_number    fixed bin (17) unal,
  2    47 	     2 pad	      bit (18) unal;
  2    48 
  2    49 
  2    50      dcl	   (relation_search_specification_ptr, relation_numeric_specification_ptr)
  2    51 			      ptr init (null);
  2    52      dcl	   (rss_number_of_and_groups, rss_maximum_number_of_constraints)
  2    53 			      fixed bin (17) init (0);
  2    54 
  2    55 
  2    56 
  2    57 /* END INCLUDE FILE dm_relation_spec.incl.pl1 */
      670 
      671 
  3     1 /* BEGIN INCLUDE FILE dm_specification_head.incl.pl1 */
  3     2 
  3     3 /* HISTORY:
  3     4*Written by Matthew Pierret, 05/11/83. (Extracted from dm_specification.incl.pl1)
  3     5*Modified:
  3     6*05/20/83 by Matthew Pierret: Changed to use version 4.
  3     7**/
  3     8 
  3     9 /* format: style2,ind3 */
  3    10      dcl	   1 specification_head   based (specification_head_ptr),
  3    11 	     2 version	      fixed bin (35),
  3    12 	     2 type	      fixed bin (17) unal,
  3    13 	     2 pad	      bit (18) unal,
  3    14 	     2 subset_specification_ptr
  3    15 			      ptr;
  3    16 
  3    17 
  3    18      dcl	   specification_head_ptr ptr;
  3    19      dcl	   SPECIFICATION_VERSION_4
  3    20 			      init (4) fixed bin (35) internal static options (constant);
  3    21 
  3    22      dcl	   (
  3    23 	   SEARCH_SPECIFICATION_TYPE
  3    24 			      init (1),
  3    25 	   ABSOLUTE_SEARCH_SPECIFICATION_TYPE
  3    26 			      init (1),
  3    27 	   NUMERIC_SPECIFICATION_TYPE
  3    28 			      init (2),
  3    29 	   ABSOLUTE_NUMERIC_SPECIFICATION_TYPE
  3    30 			      init (2),
  3    31 	   RELATIVE_SEARCH_SPECIFICATION_TYPE
  3    32 			      init (3),
  3    33 	   RELATIVE_NUMERIC_SPECIFICATION_TYPE
  3    34 			      init (4),
  3    35 	   ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
  3    36 			      init (5),
  3    37 	   RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
  3    38 			      init (6),
  3    39 	   ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
  3    40 			      init (7),
  3    41 	   RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
  3    42 			      init (8)
  3    43 	   )		      fixed bin (17) internal static options (constant);
  3    44 
  3    45 
  3    46 /* END INCLUDE FILE dm_specification_head.incl.pl1 */
      672 
      673 
  4     1 /* BEGIN INCLUDE vrm_search_list.incl.pl1 */
  4     2 
  4     3 dcl  vrm_search_list_ptr pointer;
  4     4 dcl  vsl_number_of_and_groups fixed bin;
  4     5 dcl  vsl_max_number_of_constraints fixed bin;
  4     6 
  4     7 dcl 1 vrm_search_list aligned based (vrm_search_list_ptr),
  4     8     2 num_and_groups fixed bin (17) unal,		/* Number of and groups in list */
  4     9     2 max_num_constraints fixed bin (17) unal,		/* Maximum number of constraints in any search spec and group */
  4    10     2 current_and_group fixed bin (17) unal,
  4    11     2 and_groups (vsl_number_of_and_groups refer (vrm_search_list.num_and_groups)),
  4    12       3 num_cons_in_this_and_group fixed bin (17) unal,	/* Number of constriants in this and group */
  4    13       3 num_key_cons_in_this_and_group fixed bin (17) unal, /* Number of key constraints in this and group */
  4    14       3 num_seek_key_attr_count fixed bin (17) unal,	/* Number of attributes in seek key */
  4    15       3 pos_of_first_bad_key_tail_attr fixed bin (17) unal,	/* Key attribute position of first bad key_tail attr */
  4    16       3 seek_key_con_ix fixed bin (17) unal,		/* Constraint index to be used for seek key */
  4    17       3 do_not_use_sw bit (1) unal,			/* ON = Do not use this and group
  4    18*						   it has been optimized out */
  4    19       3 collection_id_supplied_sw bit (1) unal,		/* ON IF collection id was supplied in search_spec */
  4    20       3 must_initialize_sw bit (1) unal,		/* ON = init must be done */
  4    21       3 multi_attr_seek_head_sw bit (1) unal,		/* ON = Seek head is a multi-attribute key */
  4    22       3 full_key_equal_only_sw bit (1) unal,		/* ON = All operators in seek head key were = 
  4    23*						     and it was the full key */
  4    24       3 unused bit (13) unal,
  4    25       3 collection_id bit (36) aligned,			/* Collection id if supplied_sw is ON */
  4    26       3 collection_info_ptr ptr unal,			/* IF collection_id_supplied_sw = ON then 
  4    27*						   this is vrm_collection_info_ptr */
  4    28 
  4    29       3 cons (vsl_max_number_of_constraints refer (vrm_search_list.max_num_constraints))
  4    30      like constraint_info;
  4    31 
  4    32 dcl 1 constraint_info based,
  4    33 
  4    34     2 val_ptr pointer unal,				/* Pointer to data value */
  4    35     2 attr_desc_ptr pointer unal,			/* Pointer to vrm_rel_desc attribute descriptor
  4    36*						   for this attribute */
  4    37     2 encoded_key_ptr pointer unal,			/* Pointer to encoded key value if this field
  4    38*						   is a key for this cursor */
  4    39     2 encoded_key_length fixed bin (17) unal,		/* Length in char of encoded key */
  4    40     2 search_keys_ix fixed bin (17) unal,		/* Index into encoded_key table for this key */
  4    41     2 key_offset fixed bin (17) unal,			/* Offset to first bit in key of this encoded key */
  4    42     2 key_bit_length fixed bin (17) unal,		/* Length of key in bits */
  4    43     2 attr_position_in_key fixed bin (17) unal,		/* Attribute position in multi key collection */
  4    44     2 operator fixed bin (17) unal,			/* Operator for this constraint */
  4    45     2 attr_index fixed bin (17) unal,			/* Index into vrm_rel_desc.attr array */
  4    46     2 attr_bit_length fixed bin (35),			/* Bit length of attribute */
  4    47     2 valid_sw bit (1) unal,				/* ON = This constraint is valid for spec */
  4    48     2 key_head_sw bit (1) unal,			/* ON = this attribute can be used as a key head with
  4    49*						   this cursor */
  4    50     2 key_attr_sw bit (1) unal,			/* ON = This attribute is a key in this cursor */
  4    51     2 and_group_search_terminator bit (1) unal,		/* ON =  If this attribute is an and group teminator */
  4    52     2 seek_head_sw bit (1) unal,			/* ON = this attribute was used
  4    53*						   for seek_head */
  4    54     2 seek_head_tail_sw bit (1) unal,			/* ON = This attr can be used for the last attribute of a seek head */
  4    55     2 unused bit (30) unal;				/* Unused bits */
  4    56 
  4    57 
  4    58 dcl  search_keys_ptr ptr;
  4    59 dcl  alloc_num_search_keys fixed bin (17);
  4    60 dcl  search_keys (alloc_num_search_keys) char (256) varying based (search_keys_ptr);
  4    61 
  4    62 /* END INCLUDE vrm_search_list.incl.pl1 */
      674 
      675 
  5     1 /* BEGIN INCLUDE   vrm_cursor.incl.pl1		*/
  5     2 
  5     3 /* 83-05-26 Roger Lackey : Modifyed for relation cursors */
  5     4 
  5     5 dcl  vrm_cursor_ptr pointer;				/* Pointer to this structure */
  5     6 
  5     7 dcl 1 vrm_cursor aligned based (vrm_cursor_ptr),		/* vfile relation manager cursor */
  5     8     2 opening_id bit (36) aligned,			/* ID of opening associated with this cursor */
  5     9     2 debug_sw unal,				/* Undefined MBZ */
  5    10       3 trace_open bit (1) unal,			/* Show opening of iocb cursor creation time */
  5    11       3 pad bit (35) unal,
  5    12     2 switches,
  5    13       3 shared bit (1) unal,				/* Other processes can use this relation */
  5    14       3 meter_sw bit (1) unal,			/* On = Keep meters for this cursor */
  5    15       3 pad bit (7) unal,				/* Unsed */
  5    16     2 opening_mode fixed bin,				/* Opening mode for this cursor (8 = KSQR  10 = KSQU) */
  5    17     2 open_info_ptr pointer,				/* Pointer to parent opening info structure */
  5    18     2 vrm_relation_desc_ptr pointer,			/* Pointer to parent rel desc */
  5    19     2 iocb_ptr pointer,				/* Pointer to attach iocb */
  5    20     2 secondary_iocb_ptr ptr,				/* Second iocb_ptr used by vrmu_search */
  5    21     2 search_list_ptr ptr,				/* Pointer to search_list */
  5    22     2 search_keys_ptr ptr,				/* Pointer to search_keys array */
  5    23     2 meter_ptr pointer,				/* Pointer metering str if metering is on or null */
  5    24     2 vrm_iocb_list_block_ptr pointer,			/* Pointer to vrm_iocb_list_block that contains this cursors iocb */
  5    25     2 vrm_iocb_list_block_iocbs_ix fixed bin;		/* Index into list_block.iocbs for location of iocb */
  5    26 
  5    27 
  5    28 /* END  INCLUDE vrm_cursor.incl.pl1	                  */
      676 
      677 
  6     1 /*   BEGIN INCLUDE   vrm_open_info.incl.pl1		    */
  6     2 
  6     3 /* R. Harvey  82-11-02 
  6     4*   82-09-82 Roger Lackey: added iocb_list_ptr */
  6     5 
  6     6 dcl 1 vrm_open_info aligned based (vrm_open_info_ptr),	/* Vfile relation description */
  6     7     2 version char (8),				/* Version number of this structure */
  6     8     2 opening_id bit (36) aligned,			/* Opening id associated with this desc */
  6     9     2 file_uid bit (36) aligned,			/* Unique id of msf dir */
  6    10     2 number_of_openings fixed bin,			/* Number of separate calls to vrm$open */
  6    11     2 switches,
  6    12       3 shared bit (1) unal,				/* Open relation in shared mode */
  6    13       3 pad bit (35) unal init ("0"b),			/* Unused must be zero */
  6    14     2 database_dir_path char (168) varying,		/* Absolute path of database */
  6    15     2 relation_name char (30) varying,			/* Name of relation */
  6    16     2 relation_model_ptr pointer,			/* Pointer to the relation_model in the relation itself or a temp seg */
  6    17     2 com_ptr pointer,				/* Temp seg for cursors and scratch space */
  6    18     2 iocb_list_ptr pointer,				/* Pointer to first vrm_iocb_list_block */
  6    19     2 primary_key_info_ptr pointer,			/* Special case collection info ptr */
  6    20     2 number_of_index_collections fixed bin,		/* Count of index collections (include primary key) */
  6    21     2 index_collection (voi_no_of_index_collections
  6    22 		   refer (vrm_open_info.number_of_index_collections)),
  6    23       3 id bit (36),
  6    24       3 info_ptr ptr unal;				/* Points to more detailed info */
  6    25 
  6    26 
  6    27 dcl  VRM_OPEN_INFO_VERSION_1 char (8) int static options (constant) init ("       1");
  6    28 dcl  vrm_open_info_ptr ptr;
  6    29 dcl  voi_no_of_index_collections fixed bin;
  6    30 
  6    31 /*   END INCLUDE  vrm_open_info.incl.pl1	   */
      678 
      679 
  7     1 /*   BEGIN INCLUDE  vrm_rel_desc.incl.pl1		   */
  7     2 
  7     3 /* 83-05-26 Roger Lackey : Added vrm_attr_info.key_head bit for relation_cursors */
  7     4 
  7     5 dcl 1 vrm_rel_desc based (vrm_rel_desc_ptr),
  7     6     2 record_id bit (12) unal,			/* Distinguish us from tuples and collection records */
  7     7     2 version char (8),				/* Version of this structure */
  7     8     2 file_id bit (7),				/* Value of file id from model */
  7     9     2 rel_id bit (12),				/* Relation id */
  7    10     2 switches,
  7    11       3 MRDS_compatible bit (1) unal,			/* For pre-relation_manager_ MRDS */
  7    12       3 stationary_records
  7    13      bit (1) unal,					/* On = stationary */
  7    14       3 indexed bit (1) unal,				/* This relation has attributes with secondary indices */
  7    15       3 pad bit (33) unal,
  7    16     2 var_offset fixed bin (35),			/* Position of first varying attr */
  7    17     2 maximum_data_length
  7    18      fixed bin (35),				/* Maximum size of tuple in characters */
  7    19     2 number_primary_key_attrs
  7    20      fixed bin,					/* Number of attributes which make up the primary key */
  7    21     2 number_sec_indexes fixed bin,			/* Number of attributes which have a secondary index */
  7    22     2 last_var_attr_no fixed bin,			/* Attr index of last varying attribute */
  7    23     2 number_var_attrs fixed bin,			/* Number of varying attributes */
  7    24     2 number_attrs fixed bin,				/* Number of attribute in rel */
  7    25     2 attr (vrd_no_of_attrs				/* Description of each attribute */
  7    26      refer (vrm_rel_desc.number_attrs)) aligned like vrm_attr_info;
  7    27 
  7    28 dcl 1 vrm_attr_info based (vrm_attr_info_ptr),
  7    29 						/* Attribute specific info */
  7    30     2 name char (32),				/* Name of the attribute */
  7    31     2 descriptor bit (36) aligned,			/* domain descriptor */
  7    32     2 varying bit (1) unal,				/* ON = This is a varying string */
  7    33     2 key_head bit (1) unal,				/* ON = This attr can be a keyhead */
  7    34     2 primary_key_attr bit (1) unal,			/* ON = This is a primary key attribute */
  7    35     2 pad bit (15) unal,				/* unused */
  7    36     2 index_collextion_ix fixed bin (17) unal,		/* Index into vrm_open_info.index_collection array if key_head is on */
  7    37     2 bit_length fixed bin (35),			/* Maximum bit length of tuple */
  7    38     2 bit_offset fixed bin (35);			/* Offset in tuple if fixed, index to offset in tuple if varying */
  7    39 
  7    40 
  7    41 dcl  vrm_rel_desc_ptr pointer;
  7    42 dcl  vrd_no_of_attrs fixed bin;
  7    43 dcl  VRM_REL_DESC_RECORD_ID bit (12) unal int static options (constant) init ("100000000000"b);
  7    44 dcl  VRM_REL_DESC_VERSION_1 char (8) int static options (constant) init ("       1");
  7    45 dcl  vrm_attr_info_ptr pointer;
  7    46 dcl  VRM_REL_DESC_KEY char (256) varying int static options (constant) init ("@relation_description");
  7    47 
  7    48 /*   END INCLUDE  vrm_rel_desc.incl.pl1		   */
      680 
      681 
  8     1 /*   BEGIN INCLUDE   vrm_collection_info.incl.pl1		    */
  8     2 
  8     3 /*  R. Harvey  82-11-02 */
  8     4 
  8     5 
  8     6      dcl	   1 vrm_collection_info  aligned based (vrm_collection_info_ptr),
  8     7 						/* Index collection description */
  8     8 	     2 record_id	      unal,
  8     9 	       3 header	      bit (4) unal,		/* collection type */
  8    10 	       3 id	      bit (8) unal,		/* index id */
  8    11 	     2 unique	      bit (1) unal,
  8    12 	     2 primary_key	      bit (1) unal,		/* This is the MRDS primary key collection */
  8    13 	     2 pad	      bit (26) unal,
  8    14 	     2 number_of_attributes
  8    15 			      fixed bin,
  8    16 	     2 attribute	      (vci_no_of_attributes refer (vrm_collection_info.number_of_attributes)),
  8    17 	       3 attr_index	      fixed bin,		/* Attribute number in relation description */
  8    18 	       3 key_offset	      fixed bin,		/* Offset within key in bits */
  8    19 	       3 key_bit_len      fixed bin ;		/* Length of key in bits */
  8    20 
  8    21      dcl	   vrm_collection_info_ptr
  8    22 			      ptr;
  8    23      dcl	   vci_no_of_attributes   fixed bin;
  8    24      dcl	   vrm_collection_header_type
  8    25 			      bit (4) unal int static options (constant) init ("1100"b);
  8    26      dcl	   VRM_COLLECTION_KEY_HEAD char (16) int static options (constant) init ("@collection_info");
  8    27 
  8    28 /*   END INCLUDE  vrm_collection_info.incl.pl1	   */
      682 
      683 
  9     1 /* BEGIN INCLUDE  vrm_meter.incl.pl1      */
  9     2 
  9     3 dcl  vrm_meter_ptr pointer;
  9     4 
  9     5 dcl 1 vrm_meter aligned based (vrm_meter_ptr),
  9     6     2 cursor_name char (32),				/* Name of cursor */
  9     7     2 meter_start_time fixed bin (71),
  9     8     2 switches,
  9     9       3 metering bit (1) unal,			/* On = meter being done */
  9    10       3 mbz bit (35) unal,
  9    11     2 cursor_ptr ptr,				/* Pointer to vrm_cursor structure */
  9    12     2 last_call_stats like statistics,
  9    13     2 total_stats like statistics;
  9    14 
  9    15 dcl 1 statistics based,				/* Used in like above */
  9    16     2 last_time_of_stats fixed bin (71),		/* Last clock value for stats taken */
  9    17     2 vcpu_time float bin (63),			/* The vcpu for this cursor */
  9    18     2 page_faults fixed bin (70),			/* Page faults for this cursor */
  9    19     2 number_times_locked fixed bin (70),		/* Number of time a lock was set */
  9    20     2 number_times_used fixed bin (70),			/* Number of time cursor was used */
  9    21     2 num_times_search_called fixed bin (70),		/* Number of time vrm_search was called */
  9    22     2 records_searched fixed bin (70),			/* The records searched */
  9    23     2 seek_heads fixed bin (70),			/* The seek heads done for key searches */
  9    24     2 special_seek_heads fixed bin (70),		/* The seek heads done for key searches */
  9    25     2 keys_read fixed bin (70),			/* The keys read by key search */
  9    26     2 keys_compared fixed bin (70),			/* The keys compared in key search */
  9    27     2 key_hits fixed bin (70),			/* The key hits for key search */
  9    28     2 non_key_compares fixed bin (70),			/* The non_key compares done for this cursor */
  9    29     2 non_key_hits fixed bin (70),			/* The non_key hits for this cursor */
  9    30     2 upper_limit_found_count fixed bin (70),		/* The number of times upper limit was exceeded */
  9    31     2 number_items_returned fixed bin (70),		/* Number of tuples or tid returned */
  9    32     2 number_tuples_deleted fixed bin (70),		/* Number of tuples deleted */
  9    33     2 number_tuples_modified fixed bin (70),		/* Number of tuples modified */
  9    34     2 number_tuples_stored fixed bin (70);		/* Number of tuples stored */
  9    35 
  9    36 /* END INCLUDE  vrm_meter.incl.pl1      */
      684 
      685 
 10     1 /*  BEGIN INCLUDE   vrm_com.incl.pl1		 */
 10     2 
 10     3 /*  Written 82-08-23 by R. Harvey		 */
 10     4 
 10     5      dcl	   vrm_com_ptr	      ptr;
 10     6      dcl	   1 vrm_com	      aligned based (vrm_com_ptr),
 10     7 	     2 get_seg_ptr	      ptr,		/* temp seg for retrieve routines */
 10     8 	     2 put_seg_ptr	      ptr,		/* temp seg for store routines */
 10     9 	     2 mod_seg_ptr	      ptr,		/* temp seg for modify routines */
 10    10 	     2 work_area_ptr      ptr,		/* freeing area for oid_table sections and rel_descriptors */
 10    11 	     2 highest_oid	      bit (36) aligned,	/* highest valid oid */
 10    12 	     2 next_free_oid      bit (36) aligned,	/* offset of first in free chain */
 10    13 	     2 first_assigned_oid bit (36) aligned,	/* offset of first in assigned chain */
 10    14 	     2 oid_area	      area (sys_info$max_seg_size - fixed (rel (addr (vrm_com.work_area_ptr))));
 10    15 
 10    16 /*  END INCLUDE    vrm_com.incl.pl1		 */
      686 
      687 
 11     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
 11     2 /* format: style3 */
 11     3 
 11     4 /* These constants are to be used for the flags argument of sub_err_ */
 11     5 /* They are just "string (condition_info_header.action_flags)" */
 11     6 
 11     7 declare	(
 11     8 	ACTION_CAN_RESTART	init (""b),
 11     9 	ACTION_CANT_RESTART init ("1"b),
 11    10 	ACTION_DEFAULT_RESTART
 11    11 			init ("01"b),
 11    12 	ACTION_QUIET_RESTART
 11    13 			init ("001"b),
 11    14 	ACTION_SUPPORT_SIGNAL
 11    15 			init ("0001"b)
 11    16 	)		bit (36) aligned internal static options (constant);
 11    17 
 11    18 /* End include file */
      688 
      689 
      690 
      691 	dcl     1 temp_constraint_info like constraint_info aligned;
      692 
      693 	dcl    (KEEP_BOTH			init (1),
      694 	        REMOVE_A			init (2),
      695 	        REMOVE_B			init (3),
      696 	        REMOVE_B_MAKE_A_EQUALS	init (4),
      697 	        KILL_AND_GROUP		init (5))
      698 	             fixed bin internal static options (constant);
      699 
      700 	dcl     action		 fixed bin;
      701 	dcl     addr		 builtin;
      702 	dcl     addrel		 builtin;
      703 	dcl     ag		 fixed bin;
      704 	dcl     switched		 bit (1) aligned;
      705 	dcl     c			 fixed bin;
      706 	dcl     c1		 fixed bin;
      707 	dcl     c2		 fixed bin;
      708 	dcl     code		 fixed bin (35);
      709 	dcl     collection_id_found	 bit (1) aligned;
      710 	dcl     cx		 fixed bin;
      711 	dcl     db_sw		 bit (1) int static init ("0"b);
      712 	dcl     done_sw		 bit (1) aligned;
      713 	dcl     fixed		 builtin;
      714 	dcl     get_area		 area (sys_info$max_seg_size) based (vrm_com.get_seg_ptr);
      715 	dcl     i			 fixed bin;
      716 	dcl     key_attr_found	 bit (1) aligned;
      717 	dcl     key_head_attr_exists	 bit (1) aligned;
      718 	dcl     last_op_was_equal	 bit (1) aligned;
      719 	dcl     length		 builtin;
      720 	dcl     mod		 builtin;
      721 	dcl     mrds_error_$internal_error fixed bin (35) ext static;
      722 	dcl     null		 builtin;
      723 	dcl     num_search_keys_used	 fixed bin;
      724 	dcl     num_seek_head_attr	 fixed bin;
      725 	dcl     rel		 builtin;
      726 	dcl     RELATION_COLLECTION_ID bit (36) int static options (constant) init ("111111111111111111111111111111111111"b);
      727 	dcl     sub_err_		 entry () options (variable);
      728 	dcl     sys_info$max_seg_size	 fixed bin (35) ext static;
      729 	dcl     unspec		 builtin;
      730 	dcl     vrmu_encode_key$encode_attr entry (ptr, ptr, char (*) var, fixed bin (35));
      731 	dcl     vrmu_scan_records$scan_records_init entry (ptr, fixed bin (35));
      732 	dcl     vrmu_validate_spec	 entry (ptr, ptr, fixed bin, fixed bin (35));
      733 	dcl     vrm_display_search_list$subroutine entry (ptr);
      734 	dcl     x			 fixed bin;
      735 	dcl     key_cons_this_group	 fixed bin;
      736 	dcl     next_key_pos	 fixed bin;
      737 
      738      end vrmu_search_init;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/21/84  0920.3  vrmu_search_init.pl1              >special_ldd>online>mrds_install>vrmu_search_init.pl1
668          1    10/14/83  1609.1  dm_operator_constants.incl.pl1    >ldd>include>dm_operator_constants.incl.pl1
670          2    10/14/83  1609.1  dm_relation_spec.incl.pl1         >ldd>include>dm_relation_spec.incl.pl1
672          3    10/14/83  1609.1  dm_specification_head.incl.pl1    >ldd>include>dm_specification_head.incl.pl1
674          4    10/14/83  1609.1  vrm_search_list.incl.pl1          >ldd>include>vrm_search_list.incl.pl1
676          5    10/14/83  1609.1  vrm_cursor.incl.pl1               >ldd>include>vrm_cursor.incl.pl1
678          6    10/14/83  1609.1  vrm_open_info.incl.pl1            >ldd>include>vrm_open_info.incl.pl1
680          7    10/14/83  1609.1  vrm_rel_desc.incl.pl1             >ldd>include>vrm_rel_desc.incl.pl1
682          8    10/14/83  1609.1  vrm_collection_info.incl.pl1      >ldd>include>vrm_collection_info.incl.pl1
684          9    10/14/83  1609.1  vrm_meter.incl.pl1                >ldd>include>vrm_meter.incl.pl1
686         10    10/14/83  1609.1  vrm_com.incl.pl1                  >ldd>include>vrm_com.incl.pl1
688         11    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000056 constant        bit(36)                  initial dcl 11-7 set ref 167* 185* 435*
EQUAL_OPERATOR_CODE             000064 constant        fixed bin(17,0)          initial dcl 1-13 set ref 424*
GREATER_OPERATOR_CODE           000063 constant        fixed bin(17,0)          initial dcl 1-13 set ref 464* 476*
GREATER_OR_EQUAL_OPERATOR_CODE  000061 constant        fixed bin(17,0)          initial dcl 1-13 set ref 470*
I_cursor_ptr                           parameter       pointer                  dcl 10 ref 7 48
I_spec_ptr                             parameter       pointer                  dcl 11 ref 7 50
KEEP_BOTH                              constant        fixed bin(17,0)          initial dcl 693 ref 385 391 397 415 421 429 443 449
                                                                                  455
KILL_AND_GROUP                         constant        fixed bin(17,0)          initial dcl 693 ref 364 394 400 426 432
LESS_OPERATOR_CODE              000043 constant        fixed bin(17,0)          initial dcl 1-13 set ref 370* 376* 385* 391* 397*
                                                                                  406* 421* 429* 455*
LESS_OR_EQUAL_OPERATOR_CODE     000051 constant        fixed bin(17,0)          initial dcl 1-13 set ref 415* 449*
NOT_EQUAL_OPERATOR_CODE         000057 constant        fixed bin(17,0)          initial dcl 1-13 set ref 443*
O_code                                 parameter       fixed bin(35,0)          dcl 12 set ref 7 51* 650*
RELATION_COLLECTION_ID          004034 constant        bit(36)                  initial unaligned dcl 726 ref 154
REMOVE_A                               constant        fixed bin(17,0)          initial dcl 693 ref 370 376 406 452 458 464 470 476
REMOVE_B                               constant        fixed bin(17,0)          initial dcl 693 ref 361 373 379 388 409 418 446 467
                                                                                  473 479
REMOVE_B_MAKE_A_EQUALS                 constant        fixed bin(17,0)          initial dcl 693 ref 424
action                          000141 automatic       fixed bin(17,0)          dcl 700 in procedure "vrmu_search_init" set ref 310*
                                                                                  311
action                                 parameter       fixed bin(17,0)          dcl 353 in procedure "validate_constraints" set ref
                                                                                  345 361* 364* 370* 373* 376* 379* 385* 388* 391*
                                                                                  394* 397* 400* 406* 409* 415* 418* 421* 424* 426*
                                                                                  429* 432* 443* 446* 449* 452* 455* 458* 464* 467*
                                                                                  470* 473* 476* 479*
addr                                                   builtin function         dcl 701 ref 206 254 254 263
addrel                                                 builtin function         dcl 702 ref 263
ag                              000142 automatic       fixed bin(17,0)          dcl 703 set ref 100* 104* 127 127 130 131 133 133
                                                                                  136 136 139 139 141 142 147 149 154 160 175 178
                                                                                  180 189 197 199 200 200 203 205 206 207 209 211
                                                                                  211 214 228 235 236 239 242 242 246 249 254 254
                                                                                  254 261 263 265 283 283 287 287 287 287 303 305
                                                                                  308 308 326 330 355 361 367 403 440 461 501 502
                                                                                  503 540 544 544 546 546 561 563 569 573 574 577
                                                                                  578 582 583 592 605 606 613 614 616 634 636 636
                                                                                  639
alloc_num_search_keys           000114 automatic       fixed bin(17,0)          dcl 4-59 set ref 65 81* 86 87
and_group                10            based           structure                array level 2 dcl 2-9
and_group_search_terminator
                         17(03)        based           bit(1)                   array level 4 packed unaligned dcl 4-7 set ref 573*
                                                                                  583* 606*
and_groups                2            based           structure                array level 2 dcl 4-7
attr                     14            based           structure                array level 2 dcl 7-5
attr_bit_length          16            based           fixed bin(35,0)          array level 4 dcl 4-7 set ref 207*
attr_desc_ptr            10            based           pointer                  array level 4 packed unaligned dcl 4-7 set ref 206*
attr_index               15            based           fixed bin(17,0)          array level 4 in structure "vrm_search_list" packed
                                                                                  unaligned dcl 4-7 in procedure "vrmu_search_init"
                                                                                  set ref 205*
attr_index                3            based           fixed bin(17,0)          array level 3 in structure "vrm_collection_info"
                                                                                  dcl 8-6 in procedure "vrmu_search_init" ref 228
attr_position_in_key     14            based           fixed bin(17,0)          array level 4 packed unaligned dcl 4-7 set ref 236*
                                                                                  283 283 287 287 308 308 563
attribute                 3            based           structure                array level 2 dcl 8-6
bit_length               26            based           fixed bin(35,0)          array level 3 dcl 7-5 ref 207
c                               000144 automatic       fixed bin(17,0)          dcl 705 set ref 178* 180* 197 199 200 200 203 205
                                                                                  206 207 209 211 211 214 228 235 236 239 242 242
                                                                                  246 249 254 254 254 261 263 265 275 275* 561* 563
                                                                                  569 573 574 577 578 582 583*
c1                              000145 automatic       fixed bin(17,0)          dcl 706 set ref 302* 303 305 308 310* 317* 326 338*
                                                                                  338
c2                              000146 automatic       fixed bin(17,0)          dcl 707 set ref 305* 308 310* 321* 325*
cd                                     parameter       fixed bin(35,0)          dcl 648 ref 646 650
code                            000147 automatic       fixed bin(35,0)          dcl 708 set ref 81* 84 84* 114* 115 115* 254* 259
                                                                                  259*
collection_id             5            based           bit(36)                  array level 3 dcl 4-7 set ref 136* 149 154 160
collection_id_found             000150 automatic       bit(1)                   dcl 709 set ref 103 145* 150* 159 162* 166 183
collection_id_supplied
                         11            based           bit(1)                   array level 4 packed unaligned dcl 2-9 ref 133
collection_id_supplied_sw
                          4(19)        based           bit(1)                   array level 3 packed unaligned dcl 4-7 set ref 133*
                                                                                  147
collection_info_ptr       6            based           pointer                  array level 3 packed unaligned dcl 4-7 set ref 175*
com_ptr                  74            based           pointer                  level 2 dcl 6-6 ref 56
con                                    parameter       fixed bin(17,0)          dcl 536 ref 534 540
con_1                                  parameter       fixed bin(17,0)          dcl 351 in procedure "validate_constraints" set ref
                                                                                  345 355 361* 370* 376* 385* 391* 397* 406* 415*
                                                                                  421* 424* 429* 443* 449* 455* 464* 470* 476*
con_1                                  parameter       fixed bin(17,0)          dcl 628 in procedure "switch_constraints" ref 623
                                                                                  634 636
con_1                                  parameter       fixed bin(17,0)          dcl 490 in procedure "key_compare" ref 488 501 503
con_2                                  parameter       fixed bin(17,0)          dcl 491 in procedure "key_compare" ref 488 502
con_2                                  parameter       fixed bin(17,0)          dcl 352 in procedure "validate_constraints" set ref
                                                                                  345 361 361* 367 370* 376* 385* 391* 397* 403 406*
                                                                                  415* 421* 424* 429* 440 443* 449* 455* 461 464*
                                                                                  470* 476*
con_2                                  parameter       fixed bin(17,0)          dcl 629 in procedure "switch_constraints" ref 623
                                                                                  636 639
cons                      7            based           structure                array level 3 dcl 4-7 set ref 197* 634 636* 636 639*
constraint               12            based           structure                array level 3 dcl 2-9
constraint_info                        based           structure                level 1 unaligned dcl 4-32
current_and_group         1            based           fixed bin(17,0)          level 2 packed unaligned dcl 4-7 set ref 111* 116*
cx                              000151 automatic       fixed bin(17,0)          dcl 710 in procedure "vrmu_search_init" set ref 226*
                                                                                  228 236 238 246 249* 280* 283 283 283* 283 287 287
                                                                                  287 287 287* 287*
cx                              000336 automatic       fixed bin(17,0)          dcl 537 in procedure "remove_key_constraint" set ref
                                                                                  540* 541* 541*
db_sw                           000010 internal static bit(1)                   initial unaligned dcl 711 set ref 119 660* 665*
descriptor               24            based           bit(36)                  array level 3 dcl 7-5 set ref 206 254 254
do_not_use_sw             4(18)        based           bit(1)                   array level 3 packed unaligned dcl 4-7 set ref 104
                                                                                  131* 330*
done_sw                         000152 automatic       bit(1)                   dcl 712 set ref 556* 561 563* 584* 600* 601 609*
encoded_key_length       12            based           fixed bin(17,0)          array level 4 packed unaligned dcl 4-7 set ref 265*
encoded_key_ptr          11            based           pointer                  array level 4 packed unaligned dcl 4-7 set ref 209*
                                                                                  263* 501 502
field_id                 12            based           fixed bin(17,0)          array level 4 packed unaligned dcl 2-9 ref 203 228
                                                                                  254 254
flags                    11            based           structure                array level 3 packed unaligned dcl 2-9
full_key_equal_only_sw
                          4(22)        based           bit(1)                   array level 3 packed unaligned dcl 4-7 set ref 142*
                                                                                  592*
get_area                               based           area                     dcl 714 ref 73 87 94
get_seg_ptr                            based           pointer                  level 2 dcl 10-6 ref 73 87 94
i                               000153 automatic       fixed bin(17,0)          dcl 715 set ref 159* 160 163*
id                      103            based           bit(36)                  array level 3 dcl 6-6 ref 160
index_collection        103            based           structure                array level 2 dcl 6-6
info_ptr                104            based           pointer                  array level 3 packed unaligned dcl 6-6 ref 163
iocb_ptr                 10            based           pointer                  level 2 dcl 5-7 set ref 114*
key_attr_found                  000154 automatic       bit(1)                   dcl 716 set ref 224* 226 232* 272
key_attr_sw              17(02)        based           bit(1)                   array level 4 packed unaligned dcl 4-7 set ref 214*
                                                                                  235*
key_bit_len               5            based           fixed bin(17,0)          array level 3 dcl 8-6 ref 249
key_bit_length           13(18)        based           fixed bin(17,0)          array level 4 packed unaligned dcl 4-7 set ref 249*
                                                                                  503
key_cons_this_group             000162 automatic       fixed bin(17,0)          dcl 735 set ref 176* 189 234* 234 275 275* 280
key_head_attr_exists            000155 automatic       bit(1)                   dcl 717 set ref 101* 104 240*
key_head_sw              17(01)        based           bit(1)                   array level 4 packed unaligned dcl 4-7 set ref 239*
key_len                         000326 automatic       fixed bin(17,0)          dcl 496 set ref 503* 507 507 511 511 515 515 519 519
                                                                                  523 523 527 527
key_offset                4            based           fixed bin(17,0)          array level 3 in structure "vrm_collection_info"
                                                                                  dcl 8-6 in procedure "vrmu_search_init" ref 238
                                                                                  246 604
key_offset               13            based           fixed bin(17,0)          array level 4 in structure "vrm_search_list" packed
                                                                                  unaligned dcl 4-7 in procedure "vrmu_search_init"
                                                                                  set ref 246*
key_one                                based           bit                      unaligned dcl 498 ref 507 511 515 519 523 527
key_one_ptr                     000322 automatic       pointer                  dcl 494 set ref 501* 507 511 515 519 523 527
key_two                                based           bit                      unaligned dcl 499 ref 507 511 515 519 523 527
key_two_ptr                     000324 automatic       pointer                  dcl 495 set ref 502* 507 511 515 519 523 527
last_op_was_equal               000156 automatic       bit(1)                   dcl 718 set ref 557* 567* 570* 591
length                                                 builtin function         dcl 719 ref 265
max_num_constraints       0(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 4-7 set ref 61 73* 77*
                                                                                  94* 98* 104 104 127 127 130 130 131 131 133 133
                                                                                  136 136 139 139 139 139 141 141 142 142 147 147
                                                                                  149 149 154 154 160 160 175 175 189 189 197 197
                                                                                  199 199 200 200 205 205 206 206 207 207 209 209
                                                                                  211 211 214 214 235 235 236 236 239 239 242 242
                                                                                  242 242 246 246 249 249 261 261 263 263 265 265
                                                                                  283 283 283 283 287 287 287 287 287 287 287 287
                                                                                  303 303 305 305 308 308 308 308 326 326 330 330
                                                                                  355 355 361 361 367 367 403 403 440 440 461 461
                                                                                  501 501 502 502 503 503 540 540 544 544 544 544
                                                                                  546 546 546 546 561 561 563 563 569 569 573 573
                                                                                  574 574 577 577 578 578 582 582 583 583 592 592
                                                                                  605 605 606 606 613 613 614 614 616 616 634 634
                                                                                  636 636 636 636 639 639
maximum_number_of_constraints
                          4            based           fixed bin(17,0)          level 2 packed unaligned dcl 2-9 ref 92 127 127 133
                                                                                  133 136 136 178 178 180 180 200 200 203 203 211
                                                                                  211 228 228 254 254 254 254 254 254
mod                                                    builtin function         dcl 720 ref 604
mrds_error_$internal_error      000012 external static fixed bin(35,0)          dcl 721 set ref 167* 185* 435*
multi_attr_seek_head_sw
                          4(21)        based           bit(1)                   array level 3 packed unaligned dcl 4-7 set ref 141*
                                                                                  616*
must_initialize_sw        4(20)        based           bit(1)                   array level 3 packed unaligned dcl 4-7 set ref 139*
next_key_pos                    000163 automatic       fixed bin(17,0)          dcl 736 set ref 558* 563 571* 571
null                                                   builtin function         dcl 722 ref 61 63 65 67 69 2-50 2-50 144 167 167 180
                                                                                  185 185 209 435 435
num_and_groups                         based           fixed bin(17,0)          level 2 packed unaligned dcl 4-7 set ref 61 73* 76*
                                                                                  94* 97* 111
num_cons_in_this_and_group
                          2            based           fixed bin(17,0)          array level 3 packed unaligned dcl 4-7 set ref 127*
                                                                                  139 540 544* 544
num_key_cons_in_this_and_group
                          2(18)        based           fixed bin(17,0)          array level 3 packed unaligned dcl 4-7 set ref 189*
                                                                                  303 305 546* 546 561
num_search_keys_used            000157 automatic       fixed bin(17,0)          dcl 723 set ref 58* 252* 252 254 261 263 265
num_seek_head_attr              000160 automatic       fixed bin(17,0)          dcl 724 set ref 559* 572* 572 579* 579 592 598 601
                                                                                  607* 607 613 614 615
num_seek_key_attr_count
                          3            based           fixed bin(17,0)          array level 3 packed unaligned dcl 4-7 set ref 614*
number_of_and_groups      4(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 2-9 ref 91 100
number_of_attributes      2            based           fixed bin(17,0)          level 2 dcl 8-6 ref 226 592 598
number_of_constraints
                         11(18)        based           fixed bin(17,0)          array level 3 packed unaligned dcl 2-9 ref 127 178
number_of_index_collections
                        102            based           fixed bin(17,0)          level 2 dcl 6-6 ref 159
open_info_ptr             4            based           pointer                  level 2 dcl 5-7 ref 55
operator                 14(18)        based           fixed bin(17,0)          array level 4 in structure "vrm_search_list" packed
                                                                                  unaligned dcl 4-7 in procedure "vrmu_search_init"
                                                                                  set ref 211* 242 287 287 326* 355 361 367 403 440
                                                                                  461 569 577 582
operator                               parameter       fixed bin(17,0)          dcl 492 in procedure "key_compare" ref 488 505
operator_code            12(18)        based           fixed bin(17,0)          array level 4 packed unaligned dcl 2-9 ref 211
primary_key_info_ptr    100            based           pointer                  level 2 dcl 6-6 ref 151
relation_numeric_specification_ptr
                                000102 automatic       pointer                  initial dcl 2-50 set ref 2-50*
relation_search_specification          based           structure                level 1 dcl 2-9
relation_search_specification_ptr
                                000100 automatic       pointer                  initial dcl 2-50 set ref 50* 69 81* 91 92 100 2-50*
                                                                                  127 133 136 178 180 200 203 211 228 254 254 254
rss_maximum_number_of_constraints
                                000105 automatic       fixed bin(17,0)          initial dcl 2-52 set ref 2-52*
rss_number_of_and_groups        000104 automatic       fixed bin(17,0)          initial dcl 2-52 set ref 2-52*
search_collection_id     10            based           bit(36)                  array level 3 dcl 2-9 ref 136
search_keys                            based           varying char(256)        array dcl 4-60 set ref 65 87 254* 263 265
search_keys_ix           12(18)        based           fixed bin(17,0)          array level 4 packed unaligned dcl 4-7 set ref 261*
search_keys_ptr          16            based           pointer                  level 2 in structure "vrm_cursor" dcl 5-7
                                                                                  in procedure "vrmu_search_init" set ref 65 65 67*
                                                                                  88*
search_keys_ptr                 000112 automatic       pointer                  dcl 4-58 in procedure "vrmu_search_init" set ref 87*
                                                                                  88 254 263 265
search_list_ptr          14            based           pointer                  level 2 dcl 5-7 set ref 61 61 63* 74* 95*
seek_head_sw             17(04)        based           bit(1)                   array level 4 packed unaligned dcl 4-7 set ref 242*
                                                                                  574* 578* 605*
seek_key_con_ix           4            based           fixed bin(17,0)          array level 3 packed unaligned dcl 4-7 set ref 130*
                                                                                  613*
specification_head                     based           structure                level 1 unaligned dcl 3-10
statistics                             based           structure                level 1 unaligned dcl 9-15
sub_err_                        000014 constant        entry                    external dcl 727 ref 167 185 435
switched                        000143 automatic       bit(1)                   dcl 704 in procedure "vrmu_search_init" set ref 275*
                                                                                  279* 280 281* 283* 287*
switched                        000337 automatic       bit(1)                   dcl 538 in procedure "remove_key_constraint" set ref
                                                                                  541*
switched_flag                          parameter       bit(1)                   dcl 630 set ref 623 632*
temp_constraint_info            000130 automatic       structure                level 1 dcl 691 set ref 634* 639
unique                    0(12)        based           bit(1)                   level 2 packed unaligned dcl 8-6 ref 592
unspec                                                 builtin function         dcl 729 set ref 197*
val_ptr                   7            based           pointer                  array level 4 packed unaligned dcl 4-7 set ref 200*
valid_sw                 17            based           bit(1)                   array level 4 packed unaligned dcl 4-7 set ref 199*
value_ptr                14            based           pointer                  array level 4 dcl 2-9 ref 180 200 254
vrm_attr_info                          based           structure                level 1 unaligned dcl 7-28
vrm_collection_info                    based           structure                level 1 dcl 8-6
vrm_collection_info_ptr         000124 automatic       pointer                  dcl 8-21 set ref 144* 151* 163* 175 226 228 238 246
                                                                                  249 592 592 598 604
vrm_com                                based           structure                level 1 dcl 10-6
vrm_com_ptr                     000126 automatic       pointer                  dcl 10-5 set ref 56* 73 87 94
vrm_cursor                             based           structure                level 1 dcl 5-7
vrm_cursor_ptr                  000116 automatic       pointer                  dcl 5-5 set ref 48* 55 57 61 61 63 65 65 67 74 81*
                                                                                  88 95 114 119*
vrm_display_search_list$subroutine
                                000024 constant        entry                    external dcl 733 ref 119
vrm_open_info                          based           structure                level 1 dcl 6-6
vrm_open_info_ptr               000120 automatic       pointer                  dcl 6-28 set ref 55* 56 151 159 160 163
vrm_rel_desc                           based           structure                level 1 unaligned dcl 7-5
vrm_rel_desc_ptr                000122 automatic       pointer                  dcl 7-41 set ref 57* 206 207 254 254
vrm_relation_desc_ptr
                          6            based           pointer                  level 2 dcl 5-7 ref 57
vrm_search_list                        based           structure                level 1 dcl 4-7 set ref 61 73 94
vrm_search_list_ptr             000106 automatic       pointer                  dcl 4-3 set ref 73* 74 76 77 94* 95 97 98 104 111
                                                                                  111 116 127 130 131 133 136 139 139 141 142 147
                                                                                  149 154 160 175 189 197 199 200 205 206 207 209
                                                                                  211 214 235 236 239 242 242 246 249 261 263 265
                                                                                  283 283 287 287 287 287 303 305 308 308 326 330
                                                                                  355 361 367 403 440 461 501 502 503 540 544 544
                                                                                  546 546 561 563 569 573 574 577 578 582 583 592
                                                                                  605 606 613 614 616 634 636 636 639
vrmu_encode_key$encode_attr     000016 constant        entry                    external dcl 730 ref 254
vrmu_scan_records$scan_records_init
                                000020 constant        entry                    external dcl 731 ref 114
vrmu_validate_spec              000022 constant        entry                    external dcl 732 ref 81
vsl_max_number_of_constraints   000111 automatic       fixed bin(17,0)          dcl 4-5 set ref 71* 73 73 77 92* 94 94 98
vsl_number_of_and_groups        000110 automatic       fixed bin(17,0)          dcl 4-4 set ref 70* 73 73 76 91* 94 94 97
x                               000161 automatic       fixed bin(17,0)          dcl 734 set ref 203* 205 206 207 601* 604 605 606*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABSOLUTE_NUMERIC_SPECIFICATION_TYPE    internal static fixed bin(17,0)          initial dcl 3-22
ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 3-22
ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 3-22
ABSOLUTE_SEARCH_SPECIFICATION_TYPE     internal static fixed bin(17,0)          initial dcl 3-22
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 11-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 11-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 11-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 11-7
EQUAL_IDX                              internal static fixed bin(17,0)          initial dcl 1-13
GREATER_IDX                            internal static fixed bin(17,0)          initial dcl 1-13
NOT_IDX                                internal static fixed bin(17,0)          initial dcl 1-13
NUMERIC_SPECIFICATION_TYPE             internal static fixed bin(17,0)          initial dcl 3-22
REGULAR_EXPRESSION_IDX                 internal static fixed bin(17,0)          initial dcl 1-13
REGULAR_EXPRESSION_OPERATOR_CODE       internal static fixed bin(17,0)          initial dcl 1-13
RELATIVE_NUMERIC_SPECIFICATION_TYPE    internal static fixed bin(17,0)          initial dcl 3-22
RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 3-22
RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 3-22
RELATIVE_SEARCH_SPECIFICATION_TYPE     internal static fixed bin(17,0)          initial dcl 3-22
SEARCH_SPECIFICATION_TYPE              internal static fixed bin(17,0)          initial dcl 3-22
SPECIFICATION_VERSION_4                internal static fixed bin(35,0)          initial dcl 3-19
USES_EQUAL_OPERATOR                    internal static bit(1)                   initial array unaligned dcl 1-31
USES_GREATER_OPERATOR                  internal static bit(1)                   initial array unaligned dcl 1-31
USES_LESS_OPERATOR                     internal static bit(1)                   initial array unaligned dcl 1-31
USES_REGULAR_EXPRESSION_OPERATOR       internal static bit(1)                   initial array unaligned dcl 1-31
VRM_COLLECTION_KEY_HEAD                internal static char(16)                 initial unaligned dcl 8-26
VRM_OPEN_INFO_VERSION_1                internal static char(8)                  initial unaligned dcl 6-27
VRM_REL_DESC_KEY                       internal static varying char(256)        initial dcl 7-46
VRM_REL_DESC_RECORD_ID                 internal static bit(12)                  initial unaligned dcl 7-43
VRM_REL_DESC_VERSION_1                 internal static char(8)                  initial unaligned dcl 7-44
fixed                                                  builtin function         dcl 713
rel                                                    builtin function         dcl 725
relation_numeric_specification         based           structure                level 1 dcl 2-41
specification_head_ptr                 automatic       pointer                  dcl 3-18
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 728
vci_no_of_attributes                   automatic       fixed bin(17,0)          dcl 8-23
voi_no_of_index_collections            automatic       fixed bin(17,0)          dcl 6-29
vrd_no_of_attrs                        automatic       fixed bin(17,0)          dcl 7-42
vrm_attr_info_ptr                      automatic       pointer                  dcl 7-45
vrm_collection_header_type             internal static bit(4)                   initial unaligned dcl 8-24
vrm_meter                              based           structure                level 1 dcl 9-5
vrm_meter_ptr                          automatic       pointer                  dcl 9-3

NAMES DECLARED BY EXPLICIT CONTEXT.
bad_code                        002602 constant        label                    dcl 435 ref 382 412
build_vrm_and_group             000536 constant        entry                    internal dcl 123 ref 102
check_for_key_attr              001317 constant        entry                    internal dcl 222 ref 183
convert_one_constraint          001165 constant        entry                    internal dcl 195 ref 182
db_off                          000525 constant        entry                    external dcl 664
db_on                           000512 constant        entry                    external dcl 659
error                           003732 constant        entry                    internal dcl 646 ref 84 115 259
exit                            000510 constant        label                    dcl 121 ref 651
first_op                        000005 constant        label                    array(7) dcl 361 ref 355
first_op_greater                000014 constant        label                    array(2:7) dcl 370 ref 367
first_op_greater_or_equal       000022 constant        label                    array(3:7) dcl 406 ref 403
first_op_less_or_equal          000032 constant        label                    array(6:7) dcl 464 ref 461
first_op_not_equal              000027 constant        label                    array(5:7) dcl 443 ref 440
k_compare                       000034 constant        label                    array(7) dcl 507 ref 505
key_compare                     003114 constant        entry                    internal dcl 488 ref 361 370 376 385 391 397 406 415
                                                                                  421 424 429 443 449 455 464 470 476
next_c2                         002122 constant        label                    dcl 335 ref 314
optimize_and_group              003374 constant        entry                    internal dcl 554 ref 104
perform                         000000 constant        label                    array(5) dcl 314 ref 311
remove_key_constraint           003300 constant        entry                    internal dcl 534 ref 317 321 325
retry_c2                        001774 constant        label                    dcl 305 ref 318 322 327
switch_constraints              003663 constant        entry                    internal dcl 623 ref 275 283 287 541
validate_all_key_constraints    001752 constant        entry                    internal dcl 300 ref 103
validate_constraints            002127 constant        entry                    internal dcl 345 ref 310
vrmu_search_init                000176 constant        entry                    external dcl 7

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4172        4220    4036        4202
Length      4636    4036        26         402     133           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
vrmu_search_init                    441 external procedure  is an external procedure.  
build_vrm_and_group                     internal procedure  shares stack frame of external procedure vrmu_search_init.  
convert_one_constraint                  internal procedure  shares stack frame of external procedure vrmu_search_init.  
check_for_key_attr                      internal procedure  shares stack frame of external procedure vrmu_search_init.  
validate_all_key_constraints            internal procedure  shares stack frame of external procedure vrmu_search_init.  
validate_constraints                    internal procedure  shares stack frame of external procedure vrmu_search_init.  
key_compare                             internal procedure  shares stack frame of external procedure vrmu_search_init.  
remove_key_constraint                   internal procedure  shares stack frame of external procedure vrmu_search_init.  
optimize_and_group                      internal procedure  shares stack frame of external procedure vrmu_search_init.  
switch_constraints                      internal procedure  shares stack frame of external procedure vrmu_search_init.  
error                                   internal procedure  shares stack frame of external procedure vrmu_search_init.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 db_sw                       vrmu_search_init

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
vrmu_search_init         000100 relation_search_specification_ptr
                                                            vrmu_search_init
                         000102 relation_numeric_specification_ptr
                                                            vrmu_search_init
                         000104 rss_number_of_and_groups    vrmu_search_init
                         000105 rss_maximum_number_of_constraints
                                                            vrmu_search_init
                         000106 vrm_search_list_ptr         vrmu_search_init
                         000110 vsl_number_of_and_groups    vrmu_search_init
                         000111 vsl_max_number_of_constraints
                                                            vrmu_search_init
                         000112 search_keys_ptr             vrmu_search_init
                         000114 alloc_num_search_keys       vrmu_search_init
                         000116 vrm_cursor_ptr              vrmu_search_init
                         000120 vrm_open_info_ptr           vrmu_search_init
                         000122 vrm_rel_desc_ptr            vrmu_search_init
                         000124 vrm_collection_info_ptr     vrmu_search_init
                         000126 vrm_com_ptr                 vrmu_search_init
                         000130 temp_constraint_info        vrmu_search_init
                         000141 action                      vrmu_search_init
                         000142 ag                          vrmu_search_init
                         000143 switched                    vrmu_search_init
                         000144 c                           vrmu_search_init
                         000145 c1                          vrmu_search_init
                         000146 c2                          vrmu_search_init
                         000147 code                        vrmu_search_init
                         000150 collection_id_found         vrmu_search_init
                         000151 cx                          vrmu_search_init
                         000152 done_sw                     vrmu_search_init
                         000153 i                           vrmu_search_init
                         000154 key_attr_found              vrmu_search_init
                         000155 key_head_attr_exists        vrmu_search_init
                         000156 last_op_was_equal           vrmu_search_init
                         000157 num_search_keys_used        vrmu_search_init
                         000160 num_seek_head_attr          vrmu_search_init
                         000161 x                           vrmu_search_init
                         000162 key_cons_this_group         vrmu_search_init
                         000163 next_key_pos                vrmu_search_init
                         000322 key_one_ptr                 key_compare
                         000324 key_two_ptr                 key_compare
                         000326 key_len                     key_compare
                         000336 cx                          remove_key_constraint
                         000337 switched                    remove_key_constraint

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              mod_fx1             ext_entry           alloc_based
free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
sub_err_                      vrm_display_search_list$subroutine                          vrmu_encode_key$encode_attr
vrmu_scan_records$scan_records_init                         vrmu_validate_spec

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
mrds_error_$internal_error




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 2   50 000163    2   52 000166         7 000172        48 000204        50 000210        51 000213        55 000214
     56 000216        57 000220        58 000222        61 000223        63 000243        65 000246        67 000255
     69 000260        70 000263        71 000264        73 000265        74 000304        76 000306        77 000311
     78 000313        81 000314        84 000331        86 000335        87 000337        88 000346        91 000350
     92 000355        94 000360        95 000377        97 000401        98 000404       100 000406       101 000421
    102 000422       103 000423       104 000426       107 000445       111 000447       114 000456       115 000470
    116 000474       119 000477       121 000510       659 000511       660 000520       661 000523       664 000524
    665 000533       666 000535       123 000536       127 000537       130 000571       131 000602       133 000614
    136 000631       139 000636       141 000645       142 000647       144 000651       145 000653       147 000654
    149 000657       150 000662       151 000664       152 000667       154 000670       155 000672       159 000673
    160 000705       162 000727       163 000731       165 000733       166 000735       167 000737       175 001006
    176 001022       178 001023       180 001047       182 001071       183 001072       184 001075       185 001076
    188 001145       189 001147       191 001164       195 001165       197 001166       199 001210       200 001213
    203 001235       205 001240       206 001243       207 001262       209 001264       211 001266       214 001303
    216 001316       222 001317       224 001320       226 001321       228 001333       232 001361       234 001363
    235 001364       236 001404       238 001411       239 001417       240 001432       242 001434       246 001445
    249 001464       252 001501       254 001502       259 001560       261 001564       263 001606       265 001627
    268 001634       270 001636       272 001640       275 001642       279 001647       280 001651       281 001662
    283 001663       287 001725       292 001746       296 001751       300 001752       302 001753       303 001755
    305 001774       308 002017       310 002050       311 002052       314 002054       317 002055       318 002057
    321 002060       322 002062       325 002063       326 002065       327 002105       330 002106       331 002121
    335 002122       338 002124       339 002125       342 002126       345 002127       355 002131       361 002150
    364 002204       365 002207       367 002210       370 002216       373 002242       374 002245       376 002246
    379 002272       380 002275       382 002276       385 002277       388 002323       389 002326       391 002327
    394 002353       395 002356       397 002357       400 002403       401 002406       403 002407       406 002415
    409 002441       410 002444       412 002445       415 002446       418 002472       419 002475       421 002476
    424 002522       426 002546       427 002551       429 002552       432 002576       433 002601       435 002602
    440 002651       443 002671       446 002714       447 002717       449 002720       452 002743       453 002746
    455 002747       458 002772       459 002775       461 002776       464 003004       467 003030       468 003033
    470 003034       473 003060       474 003063       476 003064       479 003110       480 003113       488 003114
    501 003116       502 003134       503 003143       505 003150       507 003152       509 003163       511 003170
    513 003202       515 003207       517 003220       519 003225       521 003236       523 003243       525 003255
    527 003262       529 003273       534 003300       540 003302       541 003325       542 003331       544 003333
    546 003354       549 003373       554 003374       556 003375       557 003376       558 003377       559 003401
    561 003402       563 003427       567 003454       569 003455       570 003464       571 003466       572 003467
    573 003470       574 003472       575 003474       577 003475       578 003477       579 003501       580 003502
    582 003503       583 003505       584 003507       589 003511       591 003513       592 003515       598 003537
    600 003543       601 003544       604 003553       605 003561       606 003600       607 003602       608 003604
    609 003605       610 003607       613 003612       614 003632       615 003645       616 003650       619 003662
    623 003663       632 003665       634 003667       636 003710       639 003724       641 003731       646 003732
    650 003734       651 003737


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
