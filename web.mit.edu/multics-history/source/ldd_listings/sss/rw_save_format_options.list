	COMPILATION LISTING OF SEGMENT rw_save_format_options
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/16/84  1127.8 mst Fri
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 /* format: off */



        7 
        8 /*   This is the main level procedure called by ssu_ to implement the
        9*     report_writer_ save_format_options request. Description and usage follows.
       10*
       11*     Description:
       12*
       13*     This request does EITHER 1, 2 or 3 listed below.
       14*     
       15*     1) Saves the ACTIVE option names and values.
       16*
       17*     2) Saves ALL the option names and values.
       18*
       19*     3) Saves USER SPECIFIED option names and values.
       20*     
       21*     Usage (1): "svfo path {-query}" or
       22*                "svfo path {-query} -active"
       23*
       24*     Only the active option names and values are saved to the
       25*     file specifed by path. The query is optionally saved
       26*     also.
       27*
       28*     Usage (2): "svfo path {-query} -all"
       29*
       30*     All of the formatting option names and values are saved to
       31*     the file specifed by path. The query is optionally saved
       32*     also.
       33*
       34*     Usage (3): "svfo path {-query} -format_option_args"
       35*
       36*     Where -format_option_args are the names of the formatting options whose
       37*     values are to be saved to the file specifed by path. The query
       38*     is optionally saved also.
       39*
       40*     The formatting option names and values are saved to the file as an
       41*     exec_com. The counterpart to this request, restore_format_options, does a
       42*     subsystem exec_com on this file to accomplish the restoring.
       43*
       44*     The old control argument of -selection_expression | -se is still accepted
       45*     but not documented.
       46*
       47*     Both parameters are passed to this request by ssu_.
       48*
       49*
       50*     Known Bugs:
       51*
       52*     Other Problems:
       53*
       54*     History:
       55*
       56*     Written - Al Dupuis - August 1983
       57*     Changed - Al Dupuis - October 1984 Became report_writer_.
       58*
       59**/
       60 
       61 rw_save_format_options: proc (
       62 
       63 	sci_ptr_parm,    /* ptr to the subsystem control info structure */
       64 	report_cip_parm  /* points to report_control_info */
       65 		         );



       66 
       67 dcl report_cip_parm ptr parm;
       68 dcl sci_ptr_parm ptr parm;



       69 
       70 /*
       71*          Mainline Processing Overview.
       72*
       73*          (1) Determine requested usage.
       74*
       75*          (2) Write the exec_com header and optionally the query.
       76*
       77*          (3) Get the option names and values. Either all of them, the
       78*	    active ones, or user provided ones.
       79*
       80*          (4) Write the option names and values.
       81*
       82*          (5) Write the exec_com footer.
       83**/
       84 



       85 
       86 	file_needs_terminating = OFF;
       87 	query_segment_ptr = null;
       88 	cleanup_signalled = OFF;

       89 
       90           on cleanup begin;
       91 	     cleanup_signalled = ON;
       92 	     call terminate;
       93 	end;

       94 
       95 	call initialize;
       96           call write_exec_com_header;

       97 
       98           if usage_1
       99 	then call rw_options$get_active (report_cip,
      100 	     names_and_values_info_ptr, no_of_names_and_values,
      101 	     names_and_values_ptr, size_of_names_and_values, code);
      102 	else if usage_2
      103 	     then call rw_options$get_all (report_cip,
      104 	          names_and_values_info_ptr, no_of_names_and_values,
      105 	          names_and_values_ptr, size_of_names_and_values, code);
      106 	     else do;
      107 		call get_user_specified_option_names;
      108 		call rw_options$get_named (report_cip, 
      109 		     option_name_table_ptr, no_of_options_in_name_table,
      110 		     names_and_values_info_ptr, no_of_names_and_values,
      111 		     names_and_values_ptr, size_of_names_and_values, code);
      112 	     end;

      113 
      114 	if code ^= 0 
      115 	then call ssu_$abort_line (sci_ptr, code);

      116 
      117           call write_the_names_and_values;
      118 	call write_exec_com_footer;
      119 	call terminate;

      120 
      121           return;
      122 
      123 get_user_specified_option_names: proc;



      124 
      125 /*
      126*	Load up the table with format option names and identifiers. The
      127*	variable number_of_format_option_names has been set back in the
      128*	initialize procedure when the first pass through the control args
      129*	was made. If the format option names and identifiers were specified
      130*	correctly then the table will be the exact size needed. If they
      131*	were incorrectly specified it will be diagnosed here before the
      132*	table can overflow.
      133**/

      134 
      135           names_and_values_area_ptr = report_control_info.name_value_area_ptr;
      136 	no_of_options_in_name_table = number_of_format_option_names;

      137 
      138 	allocate option_name_table in (names_and_values_area)
      139 	     set (option_name_table_ptr);

      140 
      141 	current_arg = 2;
      142           call get_next_format_option_arg (code);
      143           if code = NO_MORE_FORMAT_OPTION_ARGS
      144           then call ssu_$abort_line (sci_ptr, 0,
      145 	     "Logic error while processing the format option arguments.");

      146 
      147           still_processing_args = ON;
      148 	loop = 1;

      149 
      150           do while (still_processing_args);

      151 
      152 	     option_name = arg;
      153 	     call rw_options$check_name (report_cip, option_name,
      154 		long_option_name, identifier_needed, code);
      155 	     if code ^= 0
      156 	     then if code = rw_error_$bad_option_name
      157 		then call ssu_$abort_line (sci_ptr, code,
      158 		     "^/^a is not a valid option name.", option_name);
      159 	          else if code = rw_error_$no_columns_defined
      160 		     then call ssu_$abort_line (sci_ptr, code,
      161 		          "^/There must be columns defined before the value of ^a can be saved.",
      162 		          long_option_name);
      163 		     else call ssu_$abort_line (sci_ptr, code);
      164 	     else;
      165 	     option_name_table.the_name (loop) = long_option_name;

      166 
      167 	     if identifier_needed
      168 	     then do;
      169 		call get_next_format_option_arg (code);
      170 		if code = NO_MORE_FORMAT_OPTION_ARGS
      171 		then call ssu_$abort_line (sci_ptr, 0,
      172 		     "The option name ^a was not followed by an identifier.",
      173 		     option_name);
      174 		else option_name_table.the_identifier (loop) = arg;
      175 		call rw_options$check_identifier (report_cip,
      176 		     option_name_table.the_name (loop), 
      177 		     option_name_table.the_identifier (loop),
      178 		     normalized_option_name, code);
      179 		if code ^= 0
      180 		then if code = rw_error_$bad_option_identifier
      181 		     then call ssu_$abort_line (sci_ptr, code,
      182 		          "^/^a is not a valid column identifier for ^a.",
      183 		          option_name_table.the_identifier (loop),
      184 		          option_name_table.the_name (loop));
      185 		     else if code ^= error_table_$nostars
      186 			then call ssu_$abort_line (sci_ptr, code);
      187 		          else;
      188 		else;
      189 	     end;
      190 	     else option_name_table.the_identifier (loop) = "";

      191 
      192 	     loop = loop + 1;
      193 	     call get_next_format_option_arg (code);
      194 	     if code = NO_MORE_FORMAT_OPTION_ARGS
      195 	     then still_processing_args = OFF;

      196 
      197 	     if still_processing_args
      198 	     then if loop
      199 		> no_of_options_in_name_table
      200 		then call ssu_$abort_line (sci_ptr, 0,
      201 		     "A format option name or column identifier was incorrectly specified.");
      202 	          else;
      203 	     else;

      204 
      205 	end;

      206 
      207 	return;
      208 
      209 get_next_format_option_arg: proc (code_parm);



      210 
      211 /*
      212*	Skip over the control args and get to the format option arg. Set
      213*	code if there isn't any left.
      214**/

      215 
      216 dcl code_parm fixed bin (35) parm;

      217 
      218 	code_parm = 0;

      219 
      220 	do while (this_is_a_control_arg (current_arg));
      221 	     current_arg = current_arg + 1;
      222 	end;

      223 
      224 	if current_arg > no_of_args_supplied
      225 	then do;
      226 	     code_parm = NO_MORE_FORMAT_OPTION_ARGS;
      227 	     return;
      228 	end;

      229 
      230           call ssu_$arg_ptr (sci_ptr, current_arg, arg_ptr, arg_length);
      231 	current_arg = current_arg + 1;

      232 
      233 	return;

      234 
      235      end get_next_format_option_arg;

      236 
      237      end get_user_specified_option_names;
      238 
      239 initialize: proc;



      240 
      241 	sci_ptr = sci_ptr_parm;
      242 	report_cip = report_cip_parm;

      243 
      244           usage_1 = OFF;
      245 	usage_2 = OFF;
      246 	usage_3 = OFF;

      247 
      248 	query_statement_flag = OFF;
      249 	unspec (this_is_a_control_arg) = OFF;
      250 	number_of_control_args_found = 0;

      251 
      252 /* 
      253*
      254*          If no args are given then it is an error.  The first arg must be
      255*          pathname.  If no additional args are given then usage (1) has been
      256*          requested.  If "-active" is given, then usage (1) has been
      257*          requested by explicitely stating the default.  If -active and -all
      258*          are given the last one supplied is used.  -active and -all cannot
      259*          be used with the format_option_args.  If -all is used correctly
      260*          then usage (2) has been requested.  If -active and -all are not
      261*          found, then usage (3) is assumed, and invalid option names are
      262*          reported as they are encountered.
      263*
      264**/

      265 
      266 	call ssu_$arg_count (sci_ptr, no_of_args_supplied);

      267 
      268 	if no_of_args_supplied = 0
      269 	then call ssu_$abort_line (sci_ptr, error_table_$noarg,
      270 	     "^/Usage: save_format_options path {-format_options_args} {-control_args}.");
      271           else;

      272 
      273           /* Get the mandatory, positional pathname argument. */

      274 
      275           call ssu_$arg_ptr (sci_ptr, 1, arg_ptr, arg_length);
      276 	pathname = arg;
      277 
      278 /* 
      279*	Determine which usage was intended and count the number of
      280*          user supplied format option names so the table 
      281*          to hold them can be allocated. 
      282**/

      283 
      284           number_of_format_option_names = 0;
      285           if no_of_args_supplied = 1
      286 	then usage_1 = ON;
      287           else do loop = 2 to no_of_args_supplied;
      288 	     call ssu_$arg_ptr (sci_ptr, loop, arg_ptr, arg_length);
      289 	     if arg = "-all" | arg = "-a" 
      290 	     | arg = "-active" | arg = "-act"
      291 	     | arg = "-selection_expression" | arg = "-se" | arg = "-query"
      292 	     then do;
      293 		this_is_a_control_arg (loop) = ON;
      294 		number_of_control_args_found 
      295 		     = number_of_control_args_found + 1;
      296 		if arg = "-all" | arg = "-a"
      297 		then do;
      298 		     usage_2 = ON;
      299 		     usage_1 = OFF;
      300 		end;
      301 		else if arg = "-active" | arg = "-act"
      302 		     then do;
      303 			usage_1 = ON;
      304 			usage_2 = OFF;
      305 		     end;
      306 		     else query_statement_flag = ON;
      307 	     end;
      308 	     else do;
      309 		usage_3 = ON;
      310 		if substr (arg, 1, 1) = "-"
      311 		then number_of_format_option_names
      312 		     = number_of_format_option_names + 1;
      313 		else;
      314 	     end;
      315 	end;

      316 
      317 	if ^usage_1 & ^usage_2 & ^usage_3
      318 	then usage_1 = ON;

      319 
      320           /* Check for inconsistent combinations of control args. */

      321 
      322 	if (usage_3 & (usage_1 | usage_2))
      323 	| ((usage_1 | usage_2) & (number_of_format_option_names > 0))
      324 	then call ssu_$abort_line (sci_ptr, error_table_$inconsistent,
      325 	     "^/When ^[-all^;-active^] is used no format option args can be specified.",
      326 	     fixed (usage_1 || usage_2));
      327 	else if usage_3 & number_of_format_option_names ^> 0
      328                then call ssu_$abort_line (sci_ptr, error_table_$inconsistent,
      329 	          "^/At least one format option name must be specified.");
      330 	     else;

      331 
      332           /* Make sure a query statement is available if the user 
      333*             asked for it to be saved with the file. */

      334 
      335 	table_ip = report_control_info.table_information_ptr;
      336           if query_statement_flag & table_ip = null
      337 	then call ssu_$abort_line (sci_ptr, rw_error_$no_columns_defined,
      338 	     "^/The format was not saved.");

      339 
      340           /* Ready the file, truncate it if it exists. */

      341 
      342           call expand_pathname_$add_suffix (pathname,
      343 	     "fo." || rtrim (ltrim (report_control_info.subsystems_ec_suffix)),
      344 	     dir_name, entry_name, code);
      345 	if code ^= 0 
      346 	then call ssu_$abort_line (sci_ptr, code,
      347 	     "^/While trying to expand ^a.", pathname);

      348 
      349           switch_name = unique_chars_ ("0"b) || ".rw_svfo";

      350 
      351           call iox_$attach_name (switch_name, iocb_ptr, 
      352 	     "vfile_ " || rtrim (dir_name) || ">" || entry_name, null (), code);
      353 	if code ^= 0
      354 	then call ssu_$abort_line (sci_ptr, code,
      355 	     "^/While trying to attach ^a.", pathname);
      356 	file_needs_terminating = ON;
      357 	call iox_$open (iocb_ptr, Stream_output, "0"b, code);
      358 	if code ^= 0
      359 	then call ssu_$abort_line (sci_ptr, code,
      360 	     "^/While trying to open ^a.", pathname);

      361 
      362 	if query_statement_flag
      363 	then call ssu_$get_temp_segment (sci_ptr, "query segment", query_segment_ptr);

      364 
      365           return;

      366 
      367      end initialize;
      368 
      369 terminate: proc;



      370 
      371           if file_needs_terminating
      372 	then do;
      373 	     call iox_$close (iocb_ptr, code);
      374 	     call iox_$detach_iocb (iocb_ptr, code);
      375 	     call iox_$destroy_iocb (iocb_ptr, code);
      376 	     if cleanup_signalled
      377 	     then call delete_$path (dir_name, entry_name, "100111"b,
      378 		ME, code);
      379 	end;

      380 
      381 	if query_segment_ptr ^= null
      382 	then call ssu_$release_temp_segment (sci_ptr, query_segment_ptr);

      383 
      384           return;

      385 
      386      end terminate;
      387 
      388 write_exec_com_footer: proc;



      389 
      390           call ioa_$ioa_switch (iocb_ptr, "&detach^/&quit");

      391 
      392 	return;

      393 
      394      end write_exec_com_footer;
      395 
      396 write_exec_com_header: proc;



      397 
      398           /* First the necessary exec_com statements. */

      399 
      400           call ioa_$ioa_switch (iocb_ptr,
      401 	     "&version 2^/&trace off^/&attach");

      402 
      403           /* Then the query statement if requested. */

      404 
      405           if ^query_statement_flag
      406 	then return;

      407 
      408 	call rw_table_manager$get_query (report_cip,
      409 	     query_segment_ptr, query_segment_length, code);
      410 	if code ^= 0
      411 	then call ssu_$abort_line (sci_ptr, code,
      412 	     "^/Unable to save the query statement.");

      413 
      414 	query_segment_current_position = 1;
      415 	still_processing_query_lines = ON;

      416 
      417 	do while (still_processing_query_lines);
      418 	     query_segment_newline_index = index (substr (query_segment,
      419 		query_segment_current_position), NEWLINE);
      420 	     if query_segment_newline_index = 0
      421 	     then call ssu_$abort_line (sci_ptr, 0,
      422 		"Logic error while trying to save the query statement.");
      423 	     ampersand_position = index (substr (query_segment,
      424 		query_segment_current_position, query_segment_newline_index), AMPERSAND);
      425 	     if ampersand_position = 0
      426 	     then call ioa_$ioa_switch (iocb_ptr, "^a", substr (query_segment,
      427 		query_segment_current_position, query_segment_newline_index - 1));
      428 	     else do;
      429 		line_buffer = substr (query_segment, query_segment_current_position, query_segment_newline_index - 1);
      430 		starting_position = 1;
      431 		still_quoting_ampersands = ON;
      432 		do while (still_quoting_ampersands);
      433 		     line_buffer = substr (line_buffer,
      434 			1, ampersand_position - 1)
      435 			|| AMPERSAND || substr (line_buffer, ampersand_position);
      436 		     starting_position = ampersand_position + 2;
      437 		     if starting_position ^> length (line_buffer)
      438 		     then do;
      439 			ampersand_position = index (substr 
      440 			     (line_buffer, starting_position), AMPERSAND);
      441 			if ampersand_position = 0
      442 			then still_quoting_ampersands = OFF;
      443 			else ampersand_position 
      444 			     = ampersand_position + starting_position - 1;
      445 		     end;
      446 		     else still_quoting_ampersands = OFF;
      447 		end;
      448 		call ioa_$ioa_switch (iocb_ptr, "^a", line_buffer);
      449 	     end;
      450 	     query_segment_current_position = query_segment_current_position
      451 		+ query_segment_newline_index;
      452 	     if query_segment_current_position > query_segment_length
      453 	     then still_processing_query_lines = OFF;
      454 	     else;
      455 	end;

      456 
      457 	return;

      458 
      459      end write_exec_com_header;
      460 
      461 write_the_names_and_values: proc;



      462 
      463 /*
      464*	If the rw_options$get_active entry was called there may not be
      465*	any format option values to save.
      466**/ 

      467 
      468           if no_of_names_and_values = 0
      469 	then call ssu_$abort_line (sci_ptr, 0, "^/^a^/^a",
      470 	     "All of the formatting options are set to their default values.",
      471 	     "There are no column options defined. The format was not saved.");

      472 
      473 /*
      474*
      475*	Loop through the names and values writing them out to the exec_com
      476*	file as report writer set_format_options requests.  The values must
      477*	be special cased in the following way.  Version 2 exec_com strips
      478*	leading and trailing whitespace, so it must be protected.  Version 2
      479*	ec also barfs if the value contains an ampersand, so they must be
      480*	protected.  The ssu_ request processor does quote stripping, active
      481*	function evaluation, etc.  so all of these things must be protected.
      482*	The set_format_options request has a number of control args it takes,
      483*	so if the value is the same as any of these control args it must be
      484*	protected.  If the value is a zero length character string then it
      485*	must be translated to the request language zero length string "".
      486*	And finally, single line values do not have a trailing newline
      487*	character, so if it is going to be protected for any of the previous
      488*	reasons, it must have a newline added.
      489*
      490**/

      491 
      492           do loop = 1 to no_of_names_and_values;

      493 
      494                normalized_option_name = substr (names_and_values,
      495 		name_value_info.name.index (loop), 
      496 		name_value_info.name.length (loop));

      497 
      498 	     option_value = substr (names_and_values, 
      499 		name_value_info.value.index (loop), 
      500 		name_value_info.value.length (loop));

      501 
      502                special_characters_in_option_value = OFF;
      503 	     newline_needed = OFF;
      504 	     requoting_needed = OFF;

      505 
      506 	     option_value_length = length (option_value);
      507 	     if option_value_length = 0
      508 	     then do;
      509 		option_value = """""";
      510 		option_value_length = 2;
      511 	     end;
      512 	     else do;
      513 		if substr (option_value, option_value_length) ^= NEWLINE
      514 		then newline_needed = ON;
      515 		else;
      516 		if search (option_value, SPECIAL_CHARACTERS) ^= 0
      517 		then special_characters_in_option_value = ON;
      518 		else;
      519 		if substr (option_value, 1, 1) = "-"
      520 		then if option_value = "-reset" | option_value = "-rs"
      521 		     | option_value = "-no_reset" | option_value = "-nrs"
      522 		     | option_value = "-long" | option_value = "-lg"
      523 		     | option_value = "-brief" | option_value = "-bf"
      524 		     | option_value = "-prompt" | option_value = "-default"
      525 		     then special_characters_in_option_value = ON;
      526 		     else;
      527 		else;
      528 		if search (option_value, AMPERSAND_BLANK_OR_TAB) ^= 0
      529 		then requoting_needed = ON;
      530 		else;
      531 	     end;

      532 
      533 /* 
      534*
      535*	Do special exec_com quoting first.  Handle the easiest case first,
      536*	when it is just a one line value that needs a newline character after
      537*	exec_com quotes are added.  Values which are several lines long
      538*	must be quoted separately, as quoted strings that contain a
      539*	newline are not legal exec_com statements.
      540*
      541**/

      542 
      543                if requoting_needed
      544 	     then do;
      545 		if newline_needed
      546 		then option_value = AMPERSAND || requote_string_
      547 		     (substr (option_value, 1)) || NEWLINE;
      548 		else do;
      549 		     spare_option_value = "";
      550 		     still_creating_lines = ON;
      551 		     starting_position = 1;
      552 		     do while (still_creating_lines);
      553 			newline_position = index (substr (option_value, 
      554 			     starting_position), NEWLINE);
      555 			if newline_position ^= 0
      556 			then do;
      557 			     line_buffer = substr (option_value, 
      558 				starting_position, newline_position - 1);
      559 			     spare_option_value = spare_option_value || AMPERSAND
      560 				|| requote_string_ (substr (line_buffer, 1)) || NEWLINE;
      561 			     starting_position = starting_position + newline_position;
      562 			     if starting_position > option_value_length
      563 			     then still_creating_lines = OFF;
      564 			end;
      565 			else do;
      566 			     spare_option_value = spare_option_value || AMPERSAND
      567 				|| requote_string_ (substr (option_value, 
      568 				starting_position)) || NEWLINE;
      569 			     still_creating_lines = OFF;
      570 			end;
      571 		     end;
      572 		     option_value = spare_option_value;
      573 		end;
      574 	     end;
      575 	     else if newline_needed & special_characters_in_option_value
      576 		then option_value = option_value || NEWLINE;
      577 	          else;

      578 
      579 	     if special_characters_in_option_value
      580 	     then call ioa_$ioa_switch (iocb_ptr, "^a^x^a^x^a^/^a^a", 
      581 		"set_format_options", normalized_option_name, 
      582 		"-prompt -brief", option_value, ".");
      583 	     else call ioa_$ioa_switch (iocb_ptr, "^a^x^a^x^a",
      584 		"set_format_options", normalized_option_name, option_value);

      585 
      586 	end;

      587 
      588           return;

      589           
      590    end write_the_names_and_values;
      591 
      592 dcl AMPERSAND char (1) static int options (constant) init ("&");
      593 dcl AMPERSAND_BLANK_OR_TAB char (3) static int options (constant) init ("& 	");
      594 dcl OFF bit (1) aligned static int options (constant) init ("0"b);
      595 dcl ON bit (1) aligned static int options (constant) init ("1"b);
      596 dcl ME char (19) static int options (constant) init ("save_format_options");
      597 dcl NEWLINE char (1) static int options (constant) init ("
      598 ");
      599 dcl NO_MORE_FORMAT_OPTION_ARGS fixed bin (35) static int options (constant) init (1);
      600 /* SPECIAL_CHARACTERS are blank, tab, left and right bracket, left and right paraen, ampersand, quote, and newline */
      601 dcl SPECIAL_CHARACTERS char (9) static int options (constant) init (
      602 " 	[]()&""
      603 ");

      604 
      605 dcl ampersand_position fixed bin;
      606 dcl arg char (arg_length) based (arg_ptr);
      607 dcl arg_length fixed bin (21);
      608 dcl arg_ptr ptr;

      609 
      610 dcl cleanup condition;
      611 dcl cleanup_signalled bit (1) aligned;
      612 dcl code fixed bin (35);
      613 dcl current_arg fixed bin;

      614 
      615 dcl delete_$path entry (char(*), char(*), bit(6), char(*), fixed bin(35));
      616 dcl dir_name char (168);

      617 
      618 dcl entry_name char (32);
      619 dcl error_table_$inconsistent fixed bin(35) ext static;
      620 dcl error_table_$noarg fixed bin(35) ext static;
      621 dcl error_table_$nostars fixed bin(35) ext static;
      622 dcl expand_pathname_$add_suffix entry (char(*), char(*), char(*), char(*), fixed bin(35));

      623 
      624 dcl file_needs_terminating bit (1) aligned;
      625 dcl fixed builtin;

      626 
      627 dcl identifier_needed bit (1) aligned;
      628 dcl index builtin;
      629 dcl ioa_$ioa_switch entry() options(variable);
      630 dcl iocb_ptr ptr;
      631 dcl iox_$attach_name entry (char(*), ptr, char(*), ptr, fixed bin(35));
      632 dcl iox_$close entry (ptr, fixed bin(35));
      633 dcl iox_$destroy_iocb entry (ptr, fixed bin(35));
      634 dcl iox_$detach_iocb entry (ptr, fixed bin(35));
      635 dcl iox_$open entry (ptr, fixed bin, bit(1) aligned, fixed bin(35));

      636 
      637 dcl length builtin;
      638 dcl line_buffer char (4096) varying;
      639 dcl long_option_name char (MAXIMUM_OPTION_NAME_LENGTH) varying;
      640 dcl loop fixed bin;
      641 dcl ltrim builtin;

      642 
      643 dcl names_and_values_area area (sys_info$max_seg_size) based (names_and_values_area_ptr);
      644 dcl names_and_values_area_ptr ptr;
      645 dcl newline_needed bit (1) aligned;
      646 dcl newline_position fixed bin;
      647 dcl no_of_args_supplied fixed bin;
      648 dcl normalized_option_name char (MAXIMUM_NORMALIZED_OPTION_NAME_LENGTH) varying;
      649 dcl number_of_control_args_found fixed bin;
      650 dcl number_of_format_option_names fixed bin;
      651 dcl null builtin;

      652 
      653 dcl option_name char (MAXIMUM_OPTION_NAME_LENGTH) varying;
      654 dcl option_value char (MAXIMUM_OPTION_VALUE_LENGTH) varying;
      655 dcl option_value_length fixed bin;

      656 
      657 dcl pathname char (168);

      658 
      659 dcl query_segment char (query_segment_length) based (query_segment_ptr);
      660 dcl query_segment_current_position fixed bin (21);
      661 dcl query_segment_length fixed bin (21);
      662 dcl query_segment_newline_index fixed bin (21);
      663 dcl query_segment_ptr ptr;
      664 dcl query_statement_flag bit (1) aligned;

      665 
      666 dcl requote_string_ entry (char(*)) returns(char(*));
      667 dcl requoting_needed bit (1) aligned;
      668 dcl rtrim builtin;
      669 dcl rw_error_$bad_option_identifier fixed bin(35) ext static;
      670 dcl rw_error_$bad_option_name fixed bin(35) ext static;
      671 dcl rw_error_$no_columns_defined fixed bin(35) ext static;
      672 dcl rw_options$check_identifier entry (ptr, char(*) var, char(*) var, char(*) var, fixed bin(35));
      673 dcl rw_options$check_name entry (ptr, char(*) var, char(*) var, bit(1) aligned, fixed bin(35));
      674 dcl rw_options$get_active entry (ptr, ptr, fixed bin(21), ptr, fixed bin(21), fixed bin(35));
      675 dcl rw_options$get_all entry (ptr, ptr, fixed bin(21), ptr, fixed bin(21), fixed bin(35));
      676 dcl rw_options$get_named entry (ptr, ptr, fixed bin(21), ptr, fixed bin(21), ptr, fixed bin(21),	fixed bin(35));
      677 dcl rw_table_manager$get_query entry (ptr, ptr, fixed bin (21), fixed bin (35));

      678 
      679 dcl sci_ptr ptr;
      680 dcl search builtin;
      681 dcl spare_option_value char (MAXIMUM_OPTION_VALUE_LENGTH) varying;
      682 dcl special_characters_in_option_value bit (1) aligned;
      683 dcl ssu_$abort_line entry() options(variable);
      684 dcl ssu_$arg_count entry (ptr, fixed bin);
      685 dcl ssu_$arg_ptr entry (ptr, fixed bin, ptr, fixed bin(21));
      686 dcl ssu_$get_temp_segment entry (ptr, char(*), ptr);
      687 dcl ssu_$release_temp_segment entry (ptr, ptr);
      688 dcl starting_position fixed bin;
      689 dcl still_creating_lines bit (1) aligned;
      690 dcl still_processing_args bit (1) aligned;
      691 dcl still_quoting_ampersands bit (1) aligned;
      692 dcl still_processing_query_lines bit (1) aligned;
      693 dcl substr builtin;
      694 dcl switch_name char (32);
      695 dcl sys_info$max_seg_size fixed bin(35) ext static;

      696 
      697 dcl this_is_a_control_arg (360) bit (1) unaligned;

      698 
      699 dcl unique_chars_ entry (bit(*)) returns(char(15));
      700 dcl unspec builtin;
      701 dcl usage_1 bit (1) aligned;
      702 dcl usage_2 bit (1) aligned;
      703 dcl usage_3 bit (1) aligned;
      704 
  1     1 /* BEGIN INCLUDE FILE ... arg_descriptor.incl.pl1
  1     2*
  1     3*   James R. Davis 1 Mar 79 */
  1     4 /* Modified June 83 JMAthane for extended arg descriptor format */
  1     5 
  1     6      dcl	   1 arg_descriptor	      based (arg_descriptor_ptr) aligned,
  1     7 	     2 flag	      bit (1) unal,
  1     8 	     2 type	      fixed bin (6) unsigned unal,
  1     9 	     2 packed	      bit (1) unal,
  1    10 	     2 number_dims	      fixed bin (4) unsigned unal,
  1    11 	     2 size	      fixed bin (24) unsigned unal;
  1    12 
  1    13      dcl	   1 fixed_arg_descriptor based (arg_descriptor_ptr) aligned,
  1    14 	     2 flag	      bit (1) unal,
  1    15 	     2 type	      fixed bin (6) unsigned unal,
  1    16 	     2 packed	      bit (1) unal,
  1    17 	     2 number_dims	      fixed bin (4) unsigned unal,
  1    18 	     2 scale	      fixed bin (11) unal,
  1    19 	     2 precision	      fixed bin (12) unsigned unal;
  1    20 
  1    21      dcl	   1 extended_arg_descriptor based (arg_descriptor_ptr) aligned,
  1    22 	     2 flag	      bit (1) unal,		/* = "1"b */
  1    23 	     2 type	      fixed bin (6) unsigned unal, /* = 58 */
  1    24 	     2 packed	      bit (1) unal,		/* significant if number_dims ^= 0 */
  1    25 	     2 number_dims	      fixed (4) unsigned unal,/* number of variable dimensions */
  1    26 	     2 size	      bit (24) unal,
  1    27 	     2 dims	      (0 refer (extended_arg_descriptor.number_dims)), /* part referenced by called generated code */
  1    28 	       3 low	      fixed bin (35),
  1    29 	       3 high	      fixed bin (35),
  1    30 	       3 multiplier	      fixed bin (35),	/* in bits if packed, in words if not */
  1    31 	     2 real_type	      fixed bin (18) unsigned unal,
  1    32 	     2 type_offset	      fixed bin (18) unsigned unal; /* offset rel to symbol tree to symbol node for type, if any */
  1    33 
  1    34      dcl	   arg_descriptor_ptr     ptr;
  1    35 
  1    36      dcl	   extended_arg_type      fixed bin init (58);
  1    37 
  1    38 /* END INCLUDE file .... arg_descriptor.incl.pl1  */
      705 
      706 
  2     1 /* BEGIN INCLUDE FILE ... arg_list.incl.pl1
  2     2*
  2     3*   James R. Davis 10 May 79 */
  2     4 
  2     5      dcl	   1 arg_list	      aligned based,
  2     6 	     2 header,
  2     7 	       3 arg_count	      fixed bin (17) unsigned unal,
  2     8 	       3 pad1	      bit (1) unal,
  2     9 	       3 call_type	      fixed bin (18) unsigned unal,
  2    10 	       3 desc_count	      fixed bin (17) unsigned unal,
  2    11 	       3 pad2	      bit (19) unal,
  2    12 	     2 arg_ptrs	      (arg_list_arg_count refer (arg_list.arg_count)) ptr,
  2    13 	     2 desc_ptrs	      (arg_list_arg_count refer (arg_list.arg_count)) ptr;
  2    14 
  2    15 
  2    16 
  2    17      dcl	   1 arg_list_with_envptr aligned based,	/* used with non-quick int and entry-var calls */
  2    18 	     2 header,
  2    19 	       3 arg_count	      fixed bin (17) unsigned unal,
  2    20 	       3 pad1	      bit (1) unal,
  2    21 	       3 call_type	      fixed bin (18) unsigned unal,
  2    22 	       3 desc_count	      fixed bin (17) unsigned unal,
  2    23 	       3 pad2	      bit (19) unal,
  2    24 	     2 arg_ptrs	      (arg_list_arg_count refer (arg_list_with_envptr.arg_count)) ptr,
  2    25 	     2 envptr	      ptr,
  2    26 	     2 desc_ptrs	      (arg_list_arg_count refer (arg_list_with_envptr.arg_count)) ptr;
  2    27 
  2    28 
  2    29      dcl	   (
  2    30 	   Quick_call_type	      init (0),
  2    31 	   Interseg_call_type     init (4),
  2    32 	   Envptr_supplied_call_type
  2    33 			      init (8)
  2    34 	   )		      fixed bin (18) unsigned unal int static options (constant);
  2    35 
  2    36 /* The user must declare arg_list_arg_count - if an adjustable automatic structure
  2    37*   is being "liked" then arg_list_arg_count may be a parameter, in order to allocate
  2    38*   an argument list of the proper size in the user's stack
  2    39*
  2    40**/
  2    41 /* END INCLUDE FILE ... arg_list.incl.pl1 */
      707 
      708 
  3     1 /* Begin include file ..... iox_modes.incl.pl1 */
  3     2 
  3     3 /* Written by C. D. Tavares, 03/17/75 */
  3     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
  3     5 
  3     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
  3     7     ("stream_input", "stream_output", "stream_input_output",
  3     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
  3     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
  3    10      "direct_input", "direct_output", "direct_update");
  3    11 
  3    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
  3    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
  3    14 
  3    15 dcl (Stream_input initial (1),
  3    16      Stream_output initial (2),
  3    17      Stream_input_output initial (3),
  3    18      Sequential_input initial (4),
  3    19      Sequential_output initial (5),
  3    20      Sequential_input_output initial (6),
  3    21      Sequential_update initial (7),
  3    22      Keyed_sequential_input initial (8),
  3    23      Keyed_sequential_output initial (9),
  3    24      Keyed_sequential_update initial (10),
  3    25      Direct_input initial (11),
  3    26      Direct_output initial (12),
  3    27      Direct_update initial (13)) fixed bin int static options (constant);
  3    28 
  3    29 /* End include file ..... iox_modes.incl.pl1 */
      709 
      710 
  4     1 /* BEGIN INCLUDE FILE ... rw_names_and_values.incl.pl1
  4     2*
  4     3*   Names and values used for producing reports. These structures provide for
  4     4*   the passing of format report option names and values between requests and
  4     5*   the "rw_options" subroutine. The caller (usually a request) fills in the
  4     6*   "option_name_table" structure, or calls a bulk load entry point such as
  4     7*   rw_options$get_all. The rw_options subroutine uses the
  4     8*   "name_value_info" structure and the "names_and_values" character string to
  4     9*   return the requested names and values.
  4    10*
  4    11*   Al Dupuis - August 1983
  4    12**/
  4    13 /* format: off */



  4    14 
  4    15 	/* Describes the "names_and_values" character string below. */

  4    16 
  4    17 dcl 1 name_value_info (no_of_names_and_values) aligned based (names_and_values_info_ptr),
  4    18       2 name,			/* location and length in temp seg */
  4    19         3 index fixed bin (21),
  4    20         3 length fixed bin (21),
  4    21       2 value,			/* location and length in temp seg */
  4    22         3 index fixed bin (21),
  4    23         3 length fixed bin (21);

  4    24 
  4    25 	/* Described by "name_value_info" structure above. */

  4    26 
  4    27 dcl names_and_values char (size_of_names_and_values) based (names_and_values_ptr);

  4    28 
  4    29 dcl names_and_values_info_ptr ptr init (null());
  4    30 dcl names_and_values_ptr ptr init (null());
  4    31 dcl no_of_names_and_values fixed bin (21);
  4    32 dcl size_of_names_and_values fixed bin (21);



  4    33 
  4    34 	/* Filled in by the caller (i.e. "list_format_options" request) */

  4    35 
  4    36 dcl 1 option_name_table (no_of_options_in_name_table) based (option_name_table_ptr),
  4    37       2 the_name char (32) varying,		/* option name */
  4    38       2 the_identifier char (32) varying;	/* null, column name, or star name */

  4    39 
  4    40 dcl no_of_options_in_name_table fixed bin (21);
  4    41 dcl option_name_table_ptr ptr init (null());

  4    42 
  4    43 /* END INCLUDE FILE rw_names_and_values.incl.pl1 */
      711 
      712 
  5     1 /*	BEGIN INCLUDE FILE rw_options_extents.incl.pl1
  5     2*
  5     3*   Extents for the formatting options used for producing reports.
  5     4*   Kept as a separate include so that some programs may include this
  5     5*   file without including rw_format_options.incl.pl1
  5     6*
  5     7*    Al Dupuis - August 1983
  5     8*
  5     9**/
  5    10 /* format: off */

  5    11 
  5    12 /* The three types of format options that we have. */

  5    13 
  5    14 dcl GENERAL_REPORT_OPTION fixed bin static int options (constant) init (1);
  5    15 dcl GENERAL_COLUMN_OPTION fixed bin static int options (constant) init (2);
  5    16 dcl SPECIFIC_COLUMN_OPTION fixed bin static int options (constant) init (3);

  5    17 
  5    18 /* Used to determine how big the tables are without doing a hbound on it. */

  5    19 
  5    20 dcl NUMBER_OF_GENERAL_COLUMN_OPTIONS_IN_TABLE fixed bin static int options (constant) init (15);
  5    21 dcl NUMBER_OF_GENERAL_REPORT_OPTIONS_IN_TABLE fixed bin static int options (constant) init (9);
  5    22 dcl NUMBER_OF_SPECIFIC_COLUMN_OPTIONS_IN_TABLE fixed bin static int options (constant) init (6);

  5    23 
  5    24 /* Used to determine how much space is needed to list them. */

  5    25 
  5    26 dcl LONGEST_SPECIFIC_COLUMN_OPTION_NAME_LENGTH fixed bin static int options (constant) init (10); /* -alignment */
  5    27 dcl LONGEST_GENERAL_REPORT_OPTION_NAME_LENGTH fixed bin static int options (constant) init (25); /* -format_document_controls */
  5    28 dcl LONGEST_GENERAL_COLUMN_OPTION_NAME_LENGTH fixed bin static int options (constant) init (21); /* -group_footer_trigger */

  5    29 
  5    30 /* MAXIMUM_OPTION_IDENTIFIER_LENGTH + MAXIMUM_OPTION_NAME_LENGTH */

  5    31 
  5    32 dcl MAXIMUM_NORMALIZED_OPTION_NAME_LENGTH fixed bin static int options (constant) init (101);

  5    33 
  5    34 dcl MAXIMUM_OPTION_IDENTIFIER_LENGTH fixed bin static int options (constant) init (69);
  5    35 dcl MAXIMUM_OPTION_NAME_LENGTH fixed bin static int options (constant) init (32);
  5    36 dcl MAXIMUM_OPTION_VALUE_LENGTH fixed bin static int options (constant) init (4096);
  5    37 
  5    38 /* Used to index into the OPTIONS tables defined in rw_format_options.incl.pl1. */

  5    39 
  5    40 dcl INDEX_FOR_DELIMITER fixed bin static int options (constant) init (1);
  5    41 dcl INDEX_FOR_FORMAT_DOCUMENT_CONTROLS fixed bin static int options (constant) init (2);
  5    42 dcl INDEX_FOR_HYPHENATION fixed bin static int options (constant) init (3);
  5    43 dcl INDEX_FOR_PAGE_FOOTER_VALUE fixed bin static int options (constant) init (4);
  5    44 dcl INDEX_FOR_PAGE_HEADER_VALUE fixed bin static int options (constant) init (5);
  5    45 dcl INDEX_FOR_PAGE_LENGTH fixed bin static int options (constant) init (6);
  5    46 dcl INDEX_FOR_PAGE_WIDTH fixed bin static int options (constant) init (7);
  5    47 dcl INDEX_FOR_TITLE_LINE fixed bin static int options (constant) init (8);
  5    48 dcl INDEX_FOR_TRUNCATION fixed bin static int options (constant) init (9);

  5    49 
  5    50 dcl INDEX_FOR_COLUMN_ORDER fixed bin static int options (constant) init (1);
  5    51 dcl INDEX_FOR_COUNT  fixed bin static int options (constant) init (2);
  5    52 dcl INDEX_FOR_EXCLUDE fixed bin static int options (constant) init (3);
  5    53 dcl INDEX_FOR_GROUP fixed bin static int options (constant) init (4);
  5    54 dcl INDEX_FOR_GROUP_FOOTER_TRIGGER fixed bin static int options (constant) init (5);
  5    55 dcl INDEX_FOR_GROUP_FOOTER_VALUE fixed bin static int options (constant) init (6);
  5    56 dcl INDEX_FOR_GROUP_HEADER_TRIGGER fixed bin static int options (constant) init (7);
  5    57 dcl INDEX_FOR_GROUP_HEADER_VALUE fixed bin static int options (constant) init (8);
  5    58 dcl INDEX_FOR_OUTLINE fixed bin static int options (constant) init (9);
  5    59 dcl INDEX_FOR_PAGE_BREAK fixed bin static int options (constant) init (10);
  5    60 dcl INDEX_FOR_ROW_FOOTER_VALUE fixed bin static int options (constant) init (11);
  5    61 dcl INDEX_FOR_ROW_HEADER_VALUE fixed bin static int options (constant) init (12);
  5    62 dcl INDEX_FOR_SUBCOUNT fixed bin static int options (constant) init (13);
  5    63 dcl INDEX_FOR_SUBTOTAL fixed bin static int options (constant) init (14);
  5    64 dcl INDEX_FOR_TOTAL fixed bin static int options (constant) init (15);

  5    65 
  5    66 dcl INDEX_FOR_ALIGNMENT fixed bin static int options (constant) init (1);
  5    67 dcl INDEX_FOR_EDITING fixed bin static int options (constant) init (2);
  5    68 dcl INDEX_FOR_FOLDING fixed bin static int options (constant) init (3);
  5    69 dcl INDEX_FOR_SEPARATOR fixed bin static int options (constant) init (4);
  5    70 dcl INDEX_FOR_TITLE fixed bin static int options (constant) init (5);
  5    71 dcl INDEX_FOR_WIDTH fixed bin static int options (constant) init (6);

  5    72 
  5    73 /*    END INCLUDE FILE rw_options_extents */
      713 
      714 
  6     1 /*  BEGIN INCLUDE FILE rw_report_info.incl.pl1
  6     2*    Information needed to control the report environment.
  6     3*    Al Dupuis - August 1983
  6     4**/
  6     5 /* format: off */

  6     6 
  6     7      dcl	   1 report_control_info aligned  based (report_cip),
  6     8 	     2 flags,
  6     9 	       3 report_is_paginated bit (1) unaligned,	         /* paged or one continous stream */
  6    10 	       3 table_has_been_started bit (1) unaligned,         /* table clean up is necessary */
  6    11 	       3 table_is_full    bit (1) unaligned,	         /* no more retrieves are necessary */
  6    12 	       3 report_has_been_started bit (1) unaligned,        /* report clean up is necessary */
  6    13 	       3 report_is_formatted bit (1) unaligned,	         /* no more formatting is necessary */
  6    14 	       3 permanent_report bit (1) unaligned,	         /* or disposable */
  6    15 	       3 permanent_table  bit (1) unaligned,	         /* or disposable */
  6    16 	       3 report_has_just_been_completed bit (1) unaligned, /* used for printing timers */
  6    17 	       3 table_has_just_been_loaded bit (1) unaligned,     /* used for printing timers */
  6    18 	       3 multi_pass_mode bit (1) unaligned,	         /* on if we are to do more than 1 pass */
  6    19 	       3 available	      bit (26) unaligned,
  6    20 	     2 format_options_flags,		         	         /* used to determine if value is default */
  6    21 	       3 general_report_default_value (NUMBER_OF_GENERAL_REPORT_OPTIONS_IN_TABLE) bit (1) unaligned,
  6    22 	       3 general_column_default_value (NUMBER_OF_GENERAL_COLUMN_OPTIONS_IN_TABLE) bit (1) unaligned,
  6    23 	     2 value_seg_ptr      ptr,		         /* the options value seg */
  6    24 	     2 table_information_ptr ptr,		         /* points to table_info */
  6    25 	     2 table_control_info_ptr ptr,		         /* points to table_control_info */
  6    26 	     2 row_value_temp_segment_ptr ptr,		         /* points to a segment for the row value */
  6    27 	     2 general_work_area_ptr ptr,		         /* a freeing work area */
  6    28 	     2 name_value_area_ptr ptr,		         /* area for name-value allocations */
  6    29 	     2 subsystem_control_info_ptr ptr,		         /* ptr for ssu_ info structure */
  6    30 	     2 subsystems_info_ptr ptr,		         /* points to subsystems info structure */
  6    31 	     2 name_value_temp_seg_ptr ptr,		         /* temp seg for name-value space */
  6    32 	     2 report_temp_seg_ptr ptr,		         /* report workspace */
  6    33 	     2 report_work_area_ptr ptr,		         /* report workspace */
  6    34 	     2 format_report_info_ptr ptr,		         /* info needed to create a report */
  6    35 	     2 input_string_temp_seg_ptr ptr,		         /* report workspace */
  6    36 	     2 output_string_temp_seg_ptr ptr,		         /* report workspace */
  6    37 	     2 editing_strings_temp_seg_ptr ptr,	         /* report workspace */
  6    38 	     2 headers_temp_seg_ptr ptr,		         /* report workspace */
  6    39 	     2 display_iocb_ptr   ptr,		         /* report is displayed through this */
  6    40 	     2 area_info_ptr ptr,			         /* points to area_info structure */
  6    41 	     2 table_manager_delete_table_entry variable entry (ptr, fixed bin (35)), /* entry who deletes the table  */
  6    42 	     2 table_manager_get_query_entry variable entry (ptr, ptr, fixed bin (21), fixed bin (35)), /* entry who gets the query */
  6    43 	     2 table_manager_get_row_entry variable entry (ptr, fixed bin (35)), /* entry who loads rows  */
  6    44 	     2 table_manager_create_table_entry variable entry (ptr, fixed bin (35)), /* entry who makes a new table  */
  6    45 	     2 options_identifier fixed bin,		         /* current set of options */
  6    46 	     2 report_identifier  fixed bin,		         /* current report */
  6    47 	     2 no_of_rows_retrieved fixed bin (35),	         /* current no of rows */
  6    48 	     2 no_of_formatted_pages fixed bin (21),	         /* current no of pages */
  6    49 	     2 number_of_passes fixed bin,		         /* number of times report will be formatted */
  6    50 	     2 table_loading_time float bin (63),
  6    51 	     2 table_sorting_time float bin (63),
  6    52 	     2 table_deletion_time float bin (63),
  6    53 	     2 report_setup_time  float bin (63),
  6    54 	     2 report_formatting_time float bin (63),
  6    55 	     2 report_display_time float bin (63),
  6    56 	     2 report_deletion_time float bin (63),
  6    57 	     2 ssu_evaluate_active_string_time float bin (63),
  6    58 	     2 temp_dir_unique_id bit (36),		/* uid of temp dir */
  6    59 	     2 subsystems_ec_suffix char (32),		/* suffix for saving and restoring ecs */
  6    60 	     2 temp_dir_name      char (168) unaligned;	/* the dir where we place the retrieved table and report */
  6    61      dcl	   report_cip	      ptr init (null ());
  6    62 
  6    63 /*  END INCLUDE FILE rw_report_info.incl.pl1  */
      715 
      716 
  7     1 /*   BEGIN INCLUDE FILE rw_table_info.incl.pl1
  7     2*
  7     3*     Written - Al Dupuis
  7     4**/
  7     5 /* format: off */

  7     6 
  7     7 dcl 1 table_info aligned based (table_ip),
  7     8       2 version char (8),
  7     9       2 column_count fixed bin,
  7    10       2 maximum_column_name_length fixed bin,	   
  7    11       2 maximum_column_value_length fixed bin,
  7    12       2 row_value_length fixed bin (21),
  7    13       2 row_value_ptr ptr,
  7    14       2 columns (ti_init_column_count refer (table_info.column_count)),    
  7    15         3 column_name char (69) varying,
  7    16         3 column_data_type  bit (36),
  7    17         3 column_length fixed bin (21),
  7    18         3 column_index fixed bin (21);

  7    19 
  7    20 dcl table_ip ptr;
  7    21 dcl ti_init_column_count fixed bin;
  7    22 dcl TABLE_INFO_VERSION_1 char (8) internal static options (constant) init ("rwti_001");

  7    23 
  7    24 /* END INCLUDE FILE view_master_table_info.incl.pl1    */
      717 
      718 
      719      end rw_save_format_options;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/16/84  1107.2  rw_save_format_options.pl1        >special_ldd>online>7001-11/16/84>rw_save_format_options.pl1
705          1    11/02/83  1845.0  arg_descriptor.incl.pl1           >ldd>include>arg_descriptor.incl.pl1
707          2    10/23/81  1948.6  arg_list.incl.pl1                 >ldd>include>arg_list.incl.pl1
709          3    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
711          4    11/16/84  1107.7  rw_names_and_values.incl.pl1      >special_ldd>online>7001-11/16/84>rw_names_and_values.incl.pl1
713          5    11/16/84  1107.8  rw_options_extents.incl.pl1       >special_ldd>online>7001-11/16/84>rw_options_extents.incl.pl1
715          6    11/16/84  1107.6  rw_report_info.incl.pl1           >special_ldd>online>7001-11/16/84>rw_report_info.incl.pl1
717          7    11/16/84  1107.6  rw_table_info.incl.pl1            >special_ldd>online>7001-11/16/84>rw_table_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
AMPERSAND                       005067 constant        char(1)                  initial unaligned dcl 592 ref 423 433 439 545 559
                                                                                  566
AMPERSAND_BLANK_OR_TAB          000010 constant        char(3)                  initial unaligned dcl 593 ref 528
MAXIMUM_NORMALIZED_OPTION_NAME_LENGTH  constant        fixed bin(17,0)          initial dcl 5-32 ref 648
MAXIMUM_OPTION_NAME_LENGTH             constant        fixed bin(17,0)          initial dcl 5-35 ref 639 653
MAXIMUM_OPTION_VALUE_LENGTH            constant        fixed bin(17,0)          initial dcl 5-36 ref 654 681
ME                              000003 constant        char(19)                 initial unaligned dcl 596 set ref 376*
NEWLINE                         005066 constant        char(1)                  initial unaligned dcl 597 ref 418 513 545 553 559
                                                                                  566 575
NO_MORE_FORMAT_OPTION_ARGS             constant        fixed bin(35,0)          initial dcl 599 ref 143 170 194 226
NUMBER_OF_GENERAL_COLUMN_OPTIONS_IN_TABLE
                                       constant        fixed bin(17,0)          initial dcl 5-20 ref 135 335 342
NUMBER_OF_GENERAL_REPORT_OPTIONS_IN_TABLE
                                       constant        fixed bin(17,0)          initial dcl 5-21 ref 135 335 342
OFF                                    constant        bit(1)                   initial dcl 594 ref 86 88 194 244 245 246 248 249
                                                                                  299 304 441 446 452 502 503 504 562 569
ON                                     constant        bit(1)                   initial dcl 595 ref 91 147 285 293 298 303 306 309
                                                                                  317 356 415 431 513 516 519 528 550
SPECIAL_CHARACTERS              000000 constant        char(9)                  initial unaligned dcl 601 ref 516
Stream_output                   000063 constant        fixed bin(17,0)          initial dcl 3-15 set ref 357*
ampersand_position              000100 automatic       fixed bin(17,0)          dcl 605 set ref 423* 425 433 433 436 439* 441 443*
                                                                                  443
arg                                    based           char                     unaligned dcl 606 ref 152 174 276 289 289 289 289
                                                                                  289 289 289 296 296 301 301 310
arg_length                      000101 automatic       fixed bin(21,0)          dcl 607 set ref 152 174 230* 275* 276 288* 289 289
                                                                                  289 289 289 289 289 296 296 301 301 310
arg_ptr                         000102 automatic       pointer                  dcl 608 set ref 152 174 230* 275* 276 288* 289 289
                                                                                  289 289 289 289 289 296 296 301 301 310
cleanup                         000104 stack reference condition                dcl 610 ref 90
cleanup_signalled               000112 automatic       bit(1)                   dcl 611 set ref 88* 91* 376
code                            000113 automatic       fixed bin(35,0)          dcl 612 set ref 98* 102* 108* 114 114* 142* 143 153*
                                                                                  155 155 155* 159 159* 163* 169* 170 175* 179 179
                                                                                  179* 185 185* 193* 194 342* 345 345* 351* 353 353*
                                                                                  357* 358 358* 373* 374* 375* 376* 408* 410 410*
code_parm                              parameter       fixed bin(35,0)          dcl 216 set ref 209 218* 226*
current_arg                     000114 automatic       fixed bin(17,0)          dcl 613 set ref 141* 220 221* 221 224 230* 231* 231
delete_$path                    000010 constant        entry                    external dcl 615 ref 376
dir_name                        000115 automatic       char(168)                unaligned dcl 616 set ref 342* 351 376*
entry_name                      000167 automatic       char(32)                 unaligned dcl 618 set ref 342* 351 376*
error_table_$inconsistent       000012 external static fixed bin(35,0)          dcl 619 set ref 322* 327*
error_table_$noarg              000014 external static fixed bin(35,0)          dcl 620 set ref 268*
error_table_$nostars            000016 external static fixed bin(35,0)          dcl 621 ref 185
expand_pathname_$add_suffix     000020 constant        entry                    external dcl 622 ref 342
extended_arg_type               002335 automatic       fixed bin(17,0)          initial dcl 1-36 set ref 1-36*
file_needs_terminating          000177 automatic       bit(1)                   dcl 624 set ref 86* 356* 371
fixed                                                  builtin function         dcl 625 ref 322 322
identifier_needed               000200 automatic       bit(1)                   dcl 627 set ref 153* 167
index                                                  builtin function         dcl 628 in procedure "rw_save_format_options" ref
                                                                                  418 423 439 553
index                     2            based           fixed bin(21,0)          array level 3 in structure "name_value_info"
                                                                                  dcl 4-17 in procedure "rw_save_format_options" ref
                                                                                  498
index                                  based           fixed bin(21,0)          array level 3 in structure "name_value_info"
                                                                                  dcl 4-17 in procedure "rw_save_format_options" ref
                                                                                  494
ioa_$ioa_switch                 000022 constant        entry                    external dcl 629 ref 390 400 425 448 579 583
iocb_ptr                        000202 automatic       pointer                  dcl 630 set ref 351* 357* 373* 374* 375* 390* 400*
                                                                                  425* 448* 579* 583*
iox_$attach_name                000024 constant        entry                    external dcl 631 ref 351
iox_$close                      000026 constant        entry                    external dcl 632 ref 373
iox_$destroy_iocb               000030 constant        entry                    external dcl 633 ref 375
iox_$detach_iocb                000032 constant        entry                    external dcl 634 ref 374
iox_$open                       000034 constant        entry                    external dcl 635 ref 357
length                    3            based           fixed bin(21,0)          array level 3 in structure "name_value_info"
                                                                                  dcl 4-17 in procedure "rw_save_format_options" ref
                                                                                  498
length                    1            based           fixed bin(21,0)          array level 3 in structure "name_value_info"
                                                                                  dcl 4-17 in procedure "rw_save_format_options" ref
                                                                                  494
length                                                 builtin function         dcl 637 in procedure "rw_save_format_options" ref
                                                                                  437 506
line_buffer                     000204 automatic       varying char(4096)       dcl 638 set ref 429* 433* 433 433 437 439 448* 557*
                                                                                  559 559
long_option_name                002205 automatic       varying char             dcl 639 set ref 153* 159* 165
loop                            002205 automatic       fixed bin(17,0)          dcl 640 set ref 148* 165 174 175 175 179 179 190
                                                                                  192* 192 197 287* 288* 293* 492* 494 494 498 498*
ltrim                                                  builtin function         dcl 641 ref 342
name                                   based           structure                array level 2 dcl 4-17
name_value_area_ptr                    based           pointer                  level 2 dcl 6-7 ref 135
name_value_info                        based           structure                array level 1 dcl 4-17
names_and_values                       based           char                     unaligned dcl 4-27 ref 494 498
names_and_values_area                  based           area                     dcl 643 ref 138
names_and_values_area_ptr       002206 automatic       pointer                  dcl 644 set ref 135* 138
names_and_values_info_ptr       002336 automatic       pointer                  initial dcl 4-29 set ref 98* 102* 108* 4-29* 494 494
                                                                                  498 498
names_and_values_ptr            002340 automatic       pointer                  initial dcl 4-30 set ref 98* 102* 108* 4-30* 494 498
newline_needed                  002210 automatic       bit(1)                   dcl 645 set ref 503* 513* 545 575
newline_position                002211 automatic       fixed bin(17,0)          dcl 646 set ref 553* 555 557 561
no_of_args_supplied             002212 automatic       fixed bin(17,0)          dcl 647 set ref 224 266* 268 285 287
no_of_names_and_values          002342 automatic       fixed bin(21,0)          dcl 4-31 set ref 98* 102* 108* 468 492
no_of_options_in_name_table     002344 automatic       fixed bin(21,0)          dcl 4-40 set ref 108* 136* 138 197
normalized_option_name          002213 automatic       varying char             dcl 648 set ref 175* 494* 579* 583*
null                                                   builtin function         dcl 651 ref 87 4-29 4-30 4-41 6-61 336 351 351 381
number_of_control_args_found    002213 automatic       fixed bin(17,0)          dcl 649 set ref 250* 294* 294
number_of_format_option_names   002214 automatic       fixed bin(17,0)          dcl 650 set ref 136 284* 310* 310 322 327
option_name                     002215 automatic       varying char             dcl 653 set ref 152* 153* 155* 170*
option_name_table                      based           structure                array level 1 unaligned dcl 4-36 set ref 138
option_name_table_ptr           002346 automatic       pointer                  initial dcl 4-41 set ref 108* 4-41* 138* 165 174 175
                                                                                  175 179 179 190
option_value                    002215 automatic       varying char             dcl 654 set ref 498* 506 509* 513 516 519 519 519
                                                                                  519 519 519 519 519 519 519 519 528 545* 545 545
                                                                                  553 557 566 566 572* 575* 575 579* 583*
option_value_length             002215 automatic       fixed bin(17,0)          dcl 655 set ref 506* 507 510* 513 562
pathname                        002216 automatic       char(168)                unaligned dcl 657 set ref 276* 342* 345* 353* 358*
query_segment                          based           char                     unaligned dcl 659 ref 418 423 425 425 429
query_segment_current_position  002270 automatic       fixed bin(21,0)          dcl 660 set ref 414* 418 423 425 425 429 450* 450
                                                                                  452
query_segment_length            002271 automatic       fixed bin(21,0)          dcl 661 set ref 408* 418 423 425 425 429 452
query_segment_newline_index     002272 automatic       fixed bin(21,0)          dcl 662 set ref 418* 420 423 425 425 429 450
query_segment_ptr               002274 automatic       pointer                  dcl 663 set ref 87* 362* 381 381* 408* 418 423 425
                                                                                  425 429
query_statement_flag            002276 automatic       bit(1)                   dcl 664 set ref 248* 306* 336 362 405
report_cip                      002350 automatic       pointer                  initial dcl 6-61 set ref 98* 102* 108* 6-61* 135
                                                                                  153* 175* 242* 335 342 408*
report_cip_parm                        parameter       pointer                  dcl 67 ref 61 242
report_control_info                    based           structure                level 1 dcl 6-7
requote_string_                 000036 constant        entry                    external dcl 666 ref 545 559 566
requoting_needed                002277 automatic       bit(1)                   dcl 667 set ref 504* 528* 543
rtrim                                                  builtin function         dcl 668 ref 342 351
rw_error_$bad_option_identifier 000040 external static fixed bin(35,0)          dcl 669 ref 179
rw_error_$bad_option_name       000042 external static fixed bin(35,0)          dcl 670 ref 155
rw_error_$no_columns_defined    000044 external static fixed bin(35,0)          dcl 671 set ref 159 336*
rw_options$check_identifier     000046 constant        entry                    external dcl 672 ref 175
rw_options$check_name           000050 constant        entry                    external dcl 673 ref 153
rw_options$get_active           000052 constant        entry                    external dcl 674 ref 98
rw_options$get_all              000054 constant        entry                    external dcl 675 ref 102
rw_options$get_named            000056 constant        entry                    external dcl 676 ref 108
rw_table_manager$get_query      000060 constant        entry                    external dcl 677 ref 408
sci_ptr                         002300 automatic       pointer                  dcl 679 set ref 114* 143* 155* 159* 163* 170* 179*
                                                                                  185* 197* 230* 241* 266* 268* 275* 288* 322* 327*
                                                                                  336* 345* 353* 358* 362* 381* 410* 420* 468*
sci_ptr_parm                           parameter       pointer                  dcl 68 ref 61 241
search                                                 builtin function         dcl 680 ref 516 528
size_of_names_and_values        002343 automatic       fixed bin(21,0)          dcl 4-32 set ref 98* 102* 108* 494 498
spare_option_value              002302 automatic       varying char             dcl 681 set ref 549* 559* 559 566* 566 572
special_characters_in_option_value
                                002302 automatic       bit(1)                   dcl 682 set ref 502* 516* 519* 575 579
ssu_$abort_line                 000062 constant        entry                    external dcl 683 ref 114 143 155 159 163 170 179 185
                                                                                  197 268 322 327 336 345 353 358 410 420 468
ssu_$arg_count                  000064 constant        entry                    external dcl 684 ref 266
ssu_$arg_ptr                    000066 constant        entry                    external dcl 685 ref 230 275 288
ssu_$get_temp_segment           000070 constant        entry                    external dcl 686 ref 362
ssu_$release_temp_segment       000072 constant        entry                    external dcl 687 ref 381
starting_position               002303 automatic       fixed bin(17,0)          dcl 688 set ref 430* 436* 437 439 443 551* 553 557
                                                                                  561* 561 562 566 566
still_creating_lines            002304 automatic       bit(1)                   dcl 689 set ref 550* 552 562* 569*
still_processing_args           002305 automatic       bit(1)                   dcl 690 set ref 147* 150 194* 197
still_processing_query_lines    002307 automatic       bit(1)                   dcl 692 set ref 415* 417 452*
still_quoting_ampersands        002306 automatic       bit(1)                   dcl 691 set ref 431* 432 441* 446*
substr                                                 builtin function         dcl 693 ref 310 418 423 425 425 429 433 433 439 494
                                                                                  498 513 519 545 545 553 557 559 559 566 566
subsystems_ec_suffix                   based           char(32)                 level 2 dcl 6-7 ref 342
switch_name                     002310 automatic       char(32)                 unaligned dcl 694 set ref 349* 351*
table_information_ptr                  based           pointer                  level 2 dcl 6-7 ref 335
table_ip                        002352 automatic       pointer                  dcl 7-20 set ref 335* 336
the_identifier           11            based           varying char(32)         array level 2 dcl 4-36 set ref 174* 175* 179* 190*
the_name                               based           varying char(32)         array level 2 dcl 4-36 set ref 165* 175* 179*
this_is_a_control_arg           002320 automatic       bit(1)                   array unaligned dcl 697 set ref 220 249* 293*
unique_chars_                   000074 constant        entry                    external dcl 699 ref 349
unspec                                                 builtin function         dcl 700 set ref 249*
usage_1                         002332 automatic       bit(1)                   dcl 701 set ref 98 244* 285* 299* 303* 317 317* 322
                                                                                  322 322 322
usage_2                         002333 automatic       bit(1)                   dcl 702 set ref 102 245* 298* 304* 317 322 322 322
                                                                                  322
usage_3                         002334 automatic       bit(1)                   dcl 703 set ref 246* 309* 317 322 327
value                     2            based           structure                array level 2 dcl 4-17

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Direct_input                           internal static fixed bin(17,0)          initial dcl 3-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 3-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 3-15
Envptr_supplied_call_type              internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-29
GENERAL_COLUMN_OPTION                  internal static fixed bin(17,0)          initial dcl 5-15
GENERAL_REPORT_OPTION                  internal static fixed bin(17,0)          initial dcl 5-14
INDEX_FOR_ALIGNMENT                    internal static fixed bin(17,0)          initial dcl 5-66
INDEX_FOR_COLUMN_ORDER                 internal static fixed bin(17,0)          initial dcl 5-50
INDEX_FOR_COUNT                        internal static fixed bin(17,0)          initial dcl 5-51
INDEX_FOR_DELIMITER                    internal static fixed bin(17,0)          initial dcl 5-40
INDEX_FOR_EDITING                      internal static fixed bin(17,0)          initial dcl 5-67
INDEX_FOR_EXCLUDE                      internal static fixed bin(17,0)          initial dcl 5-52
INDEX_FOR_FOLDING                      internal static fixed bin(17,0)          initial dcl 5-68
INDEX_FOR_FORMAT_DOCUMENT_CONTROLS     internal static fixed bin(17,0)          initial dcl 5-41
INDEX_FOR_GROUP                        internal static fixed bin(17,0)          initial dcl 5-53
INDEX_FOR_GROUP_FOOTER_TRIGGER         internal static fixed bin(17,0)          initial dcl 5-54
INDEX_FOR_GROUP_FOOTER_VALUE           internal static fixed bin(17,0)          initial dcl 5-55
INDEX_FOR_GROUP_HEADER_TRIGGER         internal static fixed bin(17,0)          initial dcl 5-56
INDEX_FOR_GROUP_HEADER_VALUE           internal static fixed bin(17,0)          initial dcl 5-57
INDEX_FOR_HYPHENATION                  internal static fixed bin(17,0)          initial dcl 5-42
INDEX_FOR_OUTLINE                      internal static fixed bin(17,0)          initial dcl 5-58
INDEX_FOR_PAGE_BREAK                   internal static fixed bin(17,0)          initial dcl 5-59
INDEX_FOR_PAGE_FOOTER_VALUE            internal static fixed bin(17,0)          initial dcl 5-43
INDEX_FOR_PAGE_HEADER_VALUE            internal static fixed bin(17,0)          initial dcl 5-44
INDEX_FOR_PAGE_LENGTH                  internal static fixed bin(17,0)          initial dcl 5-45
INDEX_FOR_PAGE_WIDTH                   internal static fixed bin(17,0)          initial dcl 5-46
INDEX_FOR_ROW_FOOTER_VALUE             internal static fixed bin(17,0)          initial dcl 5-60
INDEX_FOR_ROW_HEADER_VALUE             internal static fixed bin(17,0)          initial dcl 5-61
INDEX_FOR_SEPARATOR                    internal static fixed bin(17,0)          initial dcl 5-69
INDEX_FOR_SUBCOUNT                     internal static fixed bin(17,0)          initial dcl 5-62
INDEX_FOR_SUBTOTAL                     internal static fixed bin(17,0)          initial dcl 5-63
INDEX_FOR_TITLE                        internal static fixed bin(17,0)          initial dcl 5-70
INDEX_FOR_TITLE_LINE                   internal static fixed bin(17,0)          initial dcl 5-47
INDEX_FOR_TOTAL                        internal static fixed bin(17,0)          initial dcl 5-64
INDEX_FOR_TRUNCATION                   internal static fixed bin(17,0)          initial dcl 5-48
INDEX_FOR_WIDTH                        internal static fixed bin(17,0)          initial dcl 5-71
Interseg_call_type                     internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-29
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 3-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 3-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 3-15
LONGEST_GENERAL_COLUMN_OPTION_NAME_LENGTH
                                       internal static fixed bin(17,0)          initial dcl 5-28
LONGEST_GENERAL_REPORT_OPTION_NAME_LENGTH
                                       internal static fixed bin(17,0)          initial dcl 5-27
LONGEST_SPECIFIC_COLUMN_OPTION_NAME_LENGTH
                                       internal static fixed bin(17,0)          initial dcl 5-26
MAXIMUM_OPTION_IDENTIFIER_LENGTH       internal static fixed bin(17,0)          initial dcl 5-34
NUMBER_OF_SPECIFIC_COLUMN_OPTIONS_IN_TABLE
                                       internal static fixed bin(17,0)          initial dcl 5-22
Quick_call_type                        internal static fixed bin(18,0)          initial unsigned unaligned dcl 2-29
SPECIFIC_COLUMN_OPTION                 internal static fixed bin(17,0)          initial dcl 5-16
Sequential_input                       internal static fixed bin(17,0)          initial dcl 3-15
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 3-15
Sequential_output                      internal static fixed bin(17,0)          initial dcl 3-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 3-15
Stream_input                           internal static fixed bin(17,0)          initial dcl 3-15
Stream_input_output                    internal static fixed bin(17,0)          initial dcl 3-15
TABLE_INFO_VERSION_1                   internal static char(8)                  initial unaligned dcl 7-22
arg_descriptor                         based           structure                level 1 dcl 1-6
arg_descriptor_ptr                     automatic       pointer                  dcl 1-34
arg_list                               based           structure                level 1 dcl 2-5
arg_list_with_envptr                   based           structure                level 1 dcl 2-17
extended_arg_descriptor                based           structure                level 1 dcl 1-21
fixed_arg_descriptor                   based           structure                level 1 dcl 1-13
iox_modes                              internal static char(24)                 initial array dcl 3-6
short_iox_modes                        internal static char(4)                  initial array dcl 3-12
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 695
table_info                             based           structure                level 1 dcl 7-7
ti_init_column_count                   automatic       fixed bin(17,0)          dcl 7-21

NAMES DECLARED BY EXPLICIT CONTEXT.
get_next_format_option_arg      001555 constant        entry                    internal dcl 209 ref 142 169 193
get_user_specified_option_names 001025 constant        entry                    internal dcl 123 ref 107
initialize                      001615 constant        entry                    internal dcl 239 ref 95
rw_save_format_options          000524 constant        entry                    external dcl 61
terminate                       002707 constant        entry                    internal dcl 369 ref 92 119
write_exec_com_footer           003030 constant        entry                    internal dcl 388 ref 118
write_exec_com_header           003053 constant        entry                    internal dcl 396 ref 96
write_the_names_and_values      003445 constant        entry                    internal dcl 461 ref 117

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5450        5546    5074        5460
Length      6176    5074        76         414     353           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rw_save_format_options             1692 external procedure  is an external procedure.  
on unit on line 90                   64 on unit               
get_user_specified_option_names
                                        internal procedure  shares stack frame of external procedure rw_save_format_options.  
get_next_format_option_arg              internal procedure  shares stack frame of external procedure rw_save_format_options.  
initialize                              internal procedure  shares stack frame of external procedure rw_save_format_options.  
terminate                            94 internal procedure  is called by several nonquick procedures.  
write_exec_com_footer                   internal procedure  shares stack frame of external procedure rw_save_format_options.  
write_exec_com_header                   internal procedure  shares stack frame of external procedure rw_save_format_options.  
write_the_names_and_values              internal procedure  shares stack frame of external procedure rw_save_format_options.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rw_save_format_options   000100 ampersand_position          rw_save_format_options
                         000101 arg_length                  rw_save_format_options
                         000102 arg_ptr                     rw_save_format_options
                         000112 cleanup_signalled           rw_save_format_options
                         000113 code                        rw_save_format_options
                         000114 current_arg                 rw_save_format_options
                         000115 dir_name                    rw_save_format_options
                         000167 entry_name                  rw_save_format_options
                         000177 file_needs_terminating      rw_save_format_options
                         000200 identifier_needed           rw_save_format_options
                         000202 iocb_ptr                    rw_save_format_options
                         000204 line_buffer                 rw_save_format_options
                         002205 loop                        rw_save_format_options
                         002205 long_option_name            rw_save_format_options
                         002206 names_and_values_area_ptr   rw_save_format_options
                         002210 newline_needed              rw_save_format_options
                         002211 newline_position            rw_save_format_options
                         002212 no_of_args_supplied         rw_save_format_options
                         002213 normalized_option_name      rw_save_format_options
                         002213 number_of_control_args_found
                                                            rw_save_format_options
                         002214 number_of_format_option_names
                                                            rw_save_format_options
                         002215 option_value                rw_save_format_options
                         002215 option_value_length         rw_save_format_options
                         002215 option_name                 rw_save_format_options
                         002216 pathname                    rw_save_format_options
                         002270 query_segment_current_position
                                                            rw_save_format_options
                         002271 query_segment_length        rw_save_format_options
                         002272 query_segment_newline_index rw_save_format_options
                         002274 query_segment_ptr           rw_save_format_options
                         002276 query_statement_flag        rw_save_format_options
                         002277 requoting_needed            rw_save_format_options
                         002300 sci_ptr                     rw_save_format_options
                         002302 special_characters_in_option_value
                                                            rw_save_format_options
                         002302 spare_option_value          rw_save_format_options
                         002303 starting_position           rw_save_format_options
                         002304 still_creating_lines        rw_save_format_options
                         002305 still_processing_args       rw_save_format_options
                         002306 still_quoting_ampersands    rw_save_format_options
                         002307 still_processing_query_lines
                                                            rw_save_format_options
                         002310 switch_name                 rw_save_format_options
                         002320 this_is_a_control_arg       rw_save_format_options
                         002332 usage_1                     rw_save_format_options
                         002333 usage_2                     rw_save_format_options
                         002334 usage_3                     rw_save_format_options
                         002335 extended_arg_type           rw_save_format_options
                         002336 names_and_values_info_ptr   rw_save_format_options
                         002340 names_and_values_ptr        rw_save_format_options
                         002342 no_of_names_and_values      rw_save_format_options
                         002343 size_of_names_and_values    rw_save_format_options
                         002344 no_of_options_in_name_table rw_save_format_options
                         002346 option_name_table_ptr       rw_save_format_options
                         002350 report_cip                  rw_save_format_options
                         002352 table_ip                    rw_save_format_options

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        call_int_this
call_int_other      return              alloc_auto_adj      enable              shorten_stack       ext_entry
int_entry           alloc_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
delete_$path                  expand_pathname_$add_suffix   ioa_$ioa_switch               iox_$attach_name
iox_$close                    iox_$destroy_iocb             iox_$detach_iocb              iox_$open
requote_string_               rw_options$check_identifier   rw_options$check_name         rw_options$get_active
rw_options$get_all            rw_options$get_named          rw_table_manager$get_query    ssu_$abort_line
ssu_$arg_count                ssu_$arg_ptr                  ssu_$get_temp_segment         ssu_$release_temp_segment
unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$inconsistent     error_table_$noarg            error_table_$nostars
rw_error_$bad_option_identifier                             rw_error_$bad_option_name     rw_error_$no_columns_defined




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     61 000520       639 000531       648 000541       653 000551       654 000561       681 000571    1   36 000601
 4   29 000603    4   30 000605    4   41 000606    6   61 000607       153 000610       155 000616       159 000621
    170 000624       175 000627       579 000632       583 000640        86 000646        87 000647        88 000651
     90 000652        91 000666        92 000671        93 000676        95 000677        96 000700        98 000701
    102 000725       107 000751       108 000752       114 000777       117 001016       118 001017       119 001020
    121 001024       123 001025       135 001026       136 001037       138 001041       141 001047       142 001051
    143 001053       147 001103       148 001105       150 001107       152 001112       153 001124       155 001156
    159 001214       163 001247       165 001263       167 001301       169 001305       170 001307       174 001345
    175 001363       179 001423       185 001472       189 001510       190 001511       192 001512       193 001513
    194 001515       197 001521       205 001553       207 001554       209 001555       218 001557       220 001560
    221 001565       222 001566       224 001567       226 001572       227 001575       230 001576       231 001613
    233 001614       239 001615       241 001616       242 001622       244 001625       245 001626       246 001627
    248 001630       249 001631       250 001634       266 001635       268 001646       275 001674       276 001713
    284 001720       285 001721       287 001727       288 001735       289 001752       293 002023       294 002027
    296 002030       298 002032       299 002034       300 002035       301 002036       303 002042       304 002044
    305 002045       306 002046       307 002050       309 002051       310 002053       315 002060       317 002062
    322 002072       327 002142       335 002172       336 002203       342 002235       345 002363       349 002416
    351 002450       353 002551       356 002604       357 002606       358 002625       362 002657       365 002705
    369 002706       371 002714       373 002717       374 002727       375 002741       376 002753       381 003011
    384 003027       388 003030       390 003031       392 003052       396 003053       400 003054       405 003074
    408 003077       410 003114       414 003142       415 003144       417 003146       418 003150       420 003170
    423 003216       425 003232       428 003271       429 003272       430 003303       431 003305       432 003307
    433 003312       436 003355       437 003361       439 003363       441 003401       443 003404       445 003407
    446 003410       447 003411       448 003412       450 003435       452 003437       455 003443       457 003444
    461 003445       468 003446       492 003511       494 003521       498 003537       502 003551       503 003552
    504 003553       506 003554       507 003556       509 003557       510 003567       511 003571       513 003572
    516 003605       519 003622       528 003712       543 003727       545 003731       548 004021       549 004022
    550 004023       551 004025       552 004027       553 004032       555 004053       557 004054       559 004064
    561 004164       562 004167       564 004173       566 004174       569 004273       571 004275       572 004276
    574 004310       575 004311       579 004324       583 004412       586 004457       588 004461


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
