	COMPILATION LISTING OF SEGMENT abs_io_list_vars
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phx. Az., Sys-M 
	Compiled on: 08/11/87  0925.7 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 abs_io_list_vars: proc (A_abs_data_ptr, A_parsed_args_ptr, A_error_msg, A_code);
        7 
        8 /* Does &list_variables for abs_io_v2_get_line. Similar to the logic in the value_list command. */
        9 /* Written 06/07/83 by Steve Herbst */
       10 
       11 
       12 /* Parameters */
       13 
       14 dcl (A_abs_data_ptr, A_parsed_args_ptr) ptr;
       15 dcl A_error_msg char (*);
       16 dcl A_code fixed bin (35);
       17 
       18 /* Based */
       19 
       20 dcl arg char (arg_len) based (arg_ptr);
       21 dcl based_area area based (area_ptr);
       22 
       23 /* Automatic */
       24 
       25 dcl (default_sw, exclude_first_sw, match_arg_sw, match_sw, val_sw, var_sw) bit (1) aligned;
       26 
       27 dcl (area_ptr, arg_ptr) ptr;
       28 
       29 dcl (i, name_index) fixed bin;
       30 dcl arg_len fixed bin (21);
       31 dcl code fixed bin (35);
       32 
       33 /* External */
       34 
       35 dcl error_table_$badstar fixed bin (35) ext;
       36 dcl error_table_$badsyntax fixed bin (35) ext;
       37 dcl error_table_$nomatch fixed bin (35) ext;
       38 
       39 /* Entries */
       40 
       41 dcl check_star_name_$entry entry (char(*), fixed bin(35));
       42 dcl get_system_free_area_ entry returns (ptr);
       43 dcl (ioa_, ioa_$nnl) entry options (variable);
       44 dcl requote_string_ entry (char(*)) returns(char(*));
       45 dcl value_$list entry (ptr, bit(36) aligned, ptr, ptr, ptr, fixed bin(35));
       46 
       47 /* Builtins */
       48 
       49 dcl (index, null, substr, unspec) builtin;
       50 
       51 /* Conditions */
       52 
       53 dcl cleanup condition;
       54 
       55 	abs_data_ptr = A_abs_data_ptr;
       56 	parsed_args_ptr = A_parsed_args_ptr;
       57 	A_code = 0;
       58 
       59 	match_info_ptr, value_list_info_ptr = null;
       60 
       61 	exclude_first_sw, match_sw, match_arg_sw, val_sw, var_sw = "0"b;
       62 	alloc_name_count, alloc_max_name_len = 0;
       63 
       64 	if parsed_args_ptr ^= null then
       65 	     do i = 1 to parsed_args.count;
       66 
       67 		arg_ptr = parsed_args.ptr (i);
       68 		arg_len = parsed_args.len (i);
       69 
       70 		if index (arg, "&") = 1 then
       71 
       72 		     if arg = "&exclude" | arg = "&ex" | arg = "&match" then do;
       73 			i = i + 1;
       74 			if i > parsed_args.count then call error ("No value specified for " || arg);
       75 			if ^match_sw & (arg = "&exclude" | arg = "&ex") then exclude_first_sw = "1"b;
       76 			match_sw = "1"b;
       77 			if arg = "&match" then match_arg_sw = "1"b;
       78 			arg_ptr = parsed_args.ptr (i);
       79 			arg_len = parsed_args.len (i);
       80 NAME:
       81 			alloc_name_count = alloc_name_count + 1;
       82 			alloc_max_name_len = max (alloc_max_name_len, arg_len);
       83 		     end;
       84 
       85 		     else if arg = "&value" | arg = "&val" then val_sw = "1"b;
       86 
       87 		     else if arg = "&variable" | arg = "&var" then var_sw = "1"b;
       88 
       89 		     else call error ("Invalid &list_variables control argument " || arg);
       90 
       91 		else do;
       92 		     match_sw, match_arg_sw = "1"b;
       93 		     go to NAME;
       94 		end;
       95 	     end;
       96 
       97 	if ^val_sw & ^var_sw then val_sw, var_sw = "1"b;	/* default is to print both var name and value */
       98 
       99 	default_sw = (alloc_name_count = 0);
      100 	if default_sw then do;
      101 	     alloc_name_count = 1;
      102 	     alloc_max_name_len = 2;
      103 	end;
      104 	else if exclude_first_sw then alloc_name_count = alloc_name_count + 1;
      105 						/* if &exclude is first, start by matching "**" */
      106 
      107 /* Allocate and fill the match structure */
      108 
      109 	area_ptr = get_system_free_area_ ();
      110 
      111 	on cleanup call clean_up;
      112 
      113 	allocate match_info in (based_area) set (match_info_ptr);
      114 
      115 	unspec (match_info) = "0"b;
      116 	match_info.version = match_info_version_1;
      117 	match_info.name_count = alloc_name_count;
      118 	match_info.max_name_len = alloc_max_name_len;
      119 
      120 	if default_sw | exclude_first_sw then do;
      121 	     name_index = 1;
      122 	     match_info.exclude_sw (1), match_info.regexp_sw (1) = "0"b;
      123 	     match_info.name (1) = "**";
      124 	end;
      125 	else name_index = 0;
      126 
      127 	if ^default_sw then do i = 1 to parsed_args.count;
      128 
      129 	     arg_ptr = parsed_args.ptr (i);
      130 	     arg_len = parsed_args.len (i);
      131 
      132 	     if index (arg, "&") = 1 then do;
      133 
      134 		if arg = "&exclude" | arg = "&ex" then do;
      135 		     name_index = name_index + 1;
      136 		     match_info.exclude_sw (name_index) = "1"b;
      137 MATCH_ARG:
      138 		     i = i + 1;
      139 MATCH_NAME:
      140 		     arg_ptr = parsed_args.ptr (i);
      141 		     arg_len = parsed_args.len (i);
      142 		     if substr (arg, 1, 1) = "/" & substr (arg, arg_len, 1) = "/" & arg ^= "/" then do;
      143 			match_info.regexp_sw (name_index) = "1"b;
      144 			match_info.name (name_index) = substr (arg, 2, arg_len - 2);
      145 		     end;
      146 		     else do;
      147 			call check_star_name_$entry (arg, code);
      148 			if code = error_table_$badstar then
      149 			     call error ("Invalid starname arg to &list_variables: " || arg);
      150 			match_info.regexp_sw (name_index) = "0"b;
      151 			match_info.name (name_index) = arg;
      152 		     end;
      153 		end;
      154 
      155 		else if arg = "&match" then do;
      156 		     name_index = name_index + 1;
      157 		     match_info.exclude_sw (name_index) = "0"b;
      158 		     go to MATCH_ARG;
      159 		end;
      160 	     end;
      161 
      162 	     else do;
      163 		name_index = name_index + 1;
      164 		match_info.exclude_sw (name_index) = "0"b;
      165 		go to MATCH_NAME;
      166 	     end;
      167 	end;
      168 
      169 	call value_$list (abs_data.variables_ptr, "01"b, match_info_ptr, area_ptr, value_list_info_ptr, code);
      170 	if code ^= 0 then
      171 	     if code = error_table_$nomatch then call ioa_ ("No variables set.");
      172 	     else do;
      173 		A_error_msg = "";
      174 		A_code = code;
      175 	     end;
      176 
      177 /* Print the results */
      178 
      179 	else do i = 1 to value_list_info.pair_count;
      180 
      181 	     if var_sw then call ioa_$nnl ("^2x^a^[^30t^]",
      182 		substr (value_list_info.chars, value_list_info.name_index (i), value_list_info.name_len (i)),
      183 		val_sw);
      184 	     if val_sw then call ioa_ ("^a", requote_string_ (
      185 		substr (value_list_info.chars, value_list_info.value_index (i), value_list_info.value_len (i))));
      186 	     else call ioa_ ("");
      187 	end;
      188 RETURN:
      189 	call clean_up;
      190 
      191 	return;
      192 
      193 clean_up: proc;
      194 
      195 	if match_info_ptr ^= null then free match_info_ptr -> match_info in (based_area);
      196 	if value_list_info_ptr ^= null then free value_list_info_ptr -> value_list_info in (based_area);
      197 
      198 end clean_up;
      199 
      200 error: proc (P_str);
      201 
      202 dcl P_str char (*);
      203 
      204 	A_error_msg = P_str;
      205 	A_code = error_table_$badsyntax;
      206 
      207 	go to RETURN;
      208 
      209 end error;
      210 
  1     1 /*  START OF:	abs_io_data.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(87-02-20,Parisek), approve(87-07-23,MCR7716),
  1     6*     audit(87-07-30,Fawcett), install(87-08-11,MR12.1-1080):
  1     7*     Added the noabort flag for determining whether or not to abort after
  1     8*     exec_com error occurs.
  1     9*                                                   END HISTORY COMMENTS */
  1    10 
  1    11 
  1    12 /* Initial coding: 25 June 79 by J. Spencer Love */
  1    13 /* login_channel option flag BIM 11/81 */
  1    14 /* Added this_action and next_action 04/20/82 S. Herbst */
  1    15 /* Added on_info, goto_statement_(pos len) 01/06/83 S. Herbst */
  1    16 /* Added output_file.turn_off_ssw 05/16/83 S. Herbst */
  1    17 /* Added attach.trim_whitespace_sw 06/02/83 S. Herbst */
  1    18 /* Added listener_pl1_label and get_line_pl1_label 11/17/83 S. Herbst */
  1    19 /* Added (command comment control input)_line.by_control_arg 03/20/84 S. Herbst */
  1    20 
  1    21 declare	abs_data_ptr		ptr;
  1    22 
  1    23 declare	1 abs_data		aligned based (abs_data_ptr),
  1    24 	  2 version		fixed bin,	/* Version = 1					*/
  1    25 	  2 io_module_name		char (32) varying,	/* either "abs_io_" or "ec_input_"			*/
  1    26 	  2 open_description	char (24) varying,	/* either "stream_input" or "stream_input_output"		*/
  1    27 	  2 unique_name		char (15) varying,	/* &! -- either blank or 15 char unique string		*/
  1    28 						/*						*/
  1    29 	  2 ec_data_ptr		ptr,		/* -> communication area for exec_com			*/
  1    30 	  2 expand_data_ptr		ptr,		/* -> structure for abs_io_expand_			*/
  1    31 						/*						*/
  1    32 	  2 instance_chain,				/* two way linked chain of abs_data blocks for debugging	*/
  1    33 	    3 prev_ptr		ptr,		/* -> next older abs_data instance			*/
  1    34 	    3 next_ptr		ptr,		/* -> next newer abs_data instance			*/
  1    35 	    3 level		fixed bin,	/* level of ec invocation in chain for debugging		*/
  1    36 	    3 pad			bit (36),		/*						*/
  1    37 						/*						*/
  1    38 	  2 arg_info,				/*						*/
  1    39 	    3 ec_path_ptr		ptr,		/* Ptr to allocated &ec_path string			*/
  1    40 	    3 ec_path_len		fixed bin (21),	/* Length of allocated &ec_path (&0) string		*/
  1    41 	    3 ec_path_quotes	fixed bin (21),	/* Number of quote chars in &ec_path, -1 if not yet counted */
  1    42 	    3 ec_name_ptr		ptr,		/* Ptr to allocated &ec_name string			*/
  1    43 	    3 ec_name_len		fixed bin (21),	/* Length of allocated &ec_name string			*/
  1    44 	    3 ec_name_quotes	fixed bin (21),	/* Number of quote chars in &ec_name, -1 if not yet counted */
  1    45 	    3 arg_ptr		ptr,		/* pointer to allocated structure containing args		*/
  1    46 	    3 arg_count		fixed bin,	/* number of arguments passed				*/
  1    47 	    3 args_copied		bit (1),		/* 1 indicates arguments were copied into work_area	*/
  1    48 	    3 default_arg_ptr	ptr,		/* pointer to allocated &default args			*/
  1    49 	    3 default_arg_count	fixed bin,	/* number of &default args				*/
  1    50 	    3 pad			bit (36),		/*						*/
  1    51 						/*						*/
  1    52 	  2 input_string,				/* data about input segment or archive component		*/
  1    53 	    3 ptr			ptr,		/* pointer to input file				*/
  1    54 	    3 len			fixed bin (21),	/* number of characters in input file			*/
  1    55 	    3 start		fixed bin (21),	/* initial value for input_pos, set beyond &version, if any */
  1    56 	    3 position		fixed bin (21),	/* current index into input file			*/
  1    57 	    3 limit		fixed bin (21),	/* farthest point yet reached...begin &label search here	*/
  1    58 						/*						*/
  1    59 	  2 open_data,				/* data saved at attach time for open time		*/
  1    60 	    3 output_dir		char (168) unal,	/* directory pathname of output file (if specified)	*/
  1    61 	    3 output_entry		char (32) unal,	/* entryname of output file (if specified)		*/
  1    62 	    3 parser_version	fixed bin,	/* indicates version of parser (get_line) for open	*/
  1    63 	    3 si			bit (1) unal,	/* 1 indicates opening for stream_input permitted		*/
  1    64 	    3 sio			bit (1) unal,	/* 1 indicates opening for stream_input_output permitted	*/
  1    65 	    3 ssf			bit (1) unal,	/* 1 indicates output file cannot be MSF		*/
  1    66 	    3 truncate		bit (1) unal,	/* 1 indicates output file truncated at open		*/
  1    67 	    3 no_set_bc		bit (1) unal,	/* 1 to set absout bitcount only at close		  */
  1    68 	    3 login_channel		bit (1) unal,       /* 1 to fish arguments from PIT */
  1    69 	    3 pad			bit (30) unal,	/* 						*/
  1    70 						/*						*/
  1    71 	  2 output_file,				/* data for abs_io_put_chars				*/
  1    72 	    3 fcb_ptr		ptr,		/* -> File Control Block for msf_manager_, null if SSF	*/
  1    73 	    3 seg_ptr		ptr,		/* -> base of current component of output file		*/
  1    74 	    3 current_len		fixed bin (21),	/* number of characters in current component		*/
  1    75 	    3 max_len		fixed bin (21),	/* max number of characters in a component		*/
  1    76 	    3 MSF_seg_idx		fixed bin,	/* index of current MSF component. Used to get new ones	*/
  1    77 	    3 switches		aligned,
  1    78 	     4 may_be_MSF		bit (1) unaligned,	/* 1 indicates absout can become an MSF		*/
  1    79 	     4 turn_off_ssw		bit (1) unaligned,	/* 1 means safety switch of absout was off originally	*/
  1    80 	     4 mbz		bit (34) unaligned,
  1    81 						/*						*/
  1    82 	  2 command_line,				/* substructure dealing with tracing command lines	*/
  1    83 	    3 by_control_arg	bit (1) unaligned,	/* 1 if trace modes specified by ec control arg		*/
  1    84 	    3 on			bit (1) unaligned,	/* 1 to print tracing information			*/
  1    85 	    3 expand		fixed bin (3) unal,	/* 1 to print unexpanded, 2 expanded, 3 all, 4 both	*/
  1    86 	    3 pad1		bit (66) unaligned,	/* pad to double word				*/
  1    87 	    3 iocb		ptr,		/* I/O switch to put trace out on			*/
  1    88 	    3 prefix		char (32) varying,	/* prefix for &trace tracing, eg. "COMMAND: "		*/
  1    89 	    3 pad2		bit (36),		/*						*/
  1    90 	  2 (comment_line,				/* for tracing comments..always unexpanded		*/
  1    91 	     control_line,				/* for tracing control lines				*/
  1    92 	     input_line)				/* for tracing input lines in &attach mode		*/
  1    93 				like abs_data.command_line,
  1    94 						/*						*/
  1    95 	  2 attach,				/*						*/
  1    96 	   3 victim_ptr		ptr,		/* -> IOCB affected by &attach (usually iox_$user_input	*/
  1    97 	   3 target_ptr		ptr,		/* -> IOCB &attached to (created by exec_com command)	*/
  1    98 	   3 save_ptr		ptr,		/* -> IOCB used to save previous victim_ptr -> IOCB	*/
  1    99 	   3 switches,
  1   100 	    4 trim_whitespace_sw	bit (1) unaligned,	/* OFF for &attach &trim off, ON by default		*/
  1   101               4 noabort                 bit (1) unaligned,	/* ON if continue after severity 1 error */
  1   102 	    4 pad			bit (34) unaligned,
  1   103 						/*						*/
  1   104 	  2 allocated_chars_ptr	ptr,		/* -> allocated buffer for freeing			*/
  1   105 	  2 chars_ptr		ptr,		/* -> characters in buffer waiting to be returned		*/
  1   106 	  2 else_clause_ptr		ptr,		/* -> characters in deferred else clause		*/
  1   107 	  2 allocated_chars_len	fixed bin (21),	/* total length of allocated buffer			*/
  1   108 	  2 chars_len		fixed bin (21),	/* characters left in buffer to be returned		*/
  1   109 	  2 else_clause_len		fixed bin (21),	/* length of deferred else clause			*/
  1   110 						/*						*/
  1   111 	  2 absentee		bit (1),		/* 1 indicates logout on &quit			*/
  1   112 	  2 quit			bit (1),		/* 1 indicates orderly exit, quit or return		*/
  1   113 						/*						*/
  1   114 	  2 active		bit (1),		/* 1 indicates get_line is busy, for recursion check	*/
  1   115 	  2 eof			bit (1),		/* 1 indicates &quit found or no more input		*/
  1   116 	  2 last_input_line_sw	bit (1),		/* previous line returned was an input line		*/
  1   117 	  2 label_search_sw		bit (1),		/* ON when searching for target of &goto		*/
  1   118 	  2 nest_level		fixed bin,	/* V1: depth of &if-&then-&else nesting			*/
  1   119 	  2 expected_nest_level	fixed bin,	/* V1: depth that must be reached to resume execution	*/
  1   120 						/*						*/
  1   121 	  2 goto_statement_pos	fixed bin (21),	/* position of last &goto stmt, for error msgs		*/
  1   122 	  2 goto_statement_len	fixed bin (21),	/* length of the &goto stmt				*/
  1   123 
  1   124 	  2 if_info aligned,			/* &if-&then-&else nesting info			*/
  1   125 	   3 if_sw		bit (1),		/* ON if inside an &if-&then-&else construct		*/
  1   126 	   3 true_sw		bit (1),		/* ON after "&if true"				*/
  1   127 	   3 got_then_sw		bit (1),		/* ON after the &then has been seen			*/
  1   128 	   3 got_else_sw		bit (1),		/* ON after the &else has been seen			*/
  1   129 	   3 clause_type		fixed bin,	/* previous &then or &else				*/
  1   130 	   3 skip_sw		bit (1),		/* ON if skipping a &then or &else clause		*/
  1   131 	   3 skip_block_level	fixed bin,	/* how many levels of &do we are inside while skipping	*/
  1   132 	   3 prev_if_ptr		ptr,		/* ptr to if_info (saved) of &if we are nested inside	*/
  1   133 	   3 this_action		fixed bin,	/* copy of expand_data.this_statement.action */
  1   134 	   3 next_action		fixed bin,	/* copy of expand_data.next_statement.action */
  1   135 
  1   136 	  2 on_info aligned,			/* info pertaining to &on units in the ec		*/
  1   137 	   3 cleanup_handler_ptr	ptr,		/* -> node for cleanup handler if any			*/
  1   138 	   3 first_handler_ptr	ptr,		/* -> top of chain of nodes for other handlers		*/
  1   139 	   3 switches		aligned,
  1   140 	    4 was_attached_sw	bit (1) unal,	/* 1 indicates parent ec was &attach'ed		*/
  1   141 	    4 in_handler_sw		bit (1) unal,	/* 1 indicates we are now executing some handler text	*/
  1   142 	    4 exit_sw		bit (1) unal,	/* 1 indicates ready to exit the handler via &exit or &goto	*/
  1   143 	    4 goto_sw		bit (1) unal,	/* 1 means this exit is accomplished by a nonlocal &goto	*/
  1   144 	    4 continue_to_signal_sw	bit (1) unal,	/* 1 means &continue_to_signal was executed		*/
  1   145 	    4 pad			bit (31) unal,
  1   146 	   3 handler_node_ptr	ptr,		/* -> parent's handler_node for this condition		*/
  1   147 	   3 parent_abs_data_ptr	ptr,		/* -> abs_data structure of parent ec				*/
  1   148 	   3 condition_info		aligned,		/* selected condition info if in_handler_sw is ON		*/
  1   149 	    4 condition_name	char (32),	/* name of condition signalled			*/
  1   150 	    4 mc_ptr		ptr,		/* machine conditions ptr for signal_			*/
  1   151 	    4 info_ptr		ptr,		/* ptr to specific condition info, for signal_		*/
  1   152 	    4 wc_ptr		ptr,		/* machine conditions for lower ring fault, for signal_	*/
  1   153 	   3 goto_label_ptr		ptr,		/* -> &goto label if goto_sw is on			*/
  1   154 	   3 goto_label_len		fixed bin (21),	/* length of the &goto label				*/
  1   155 	   3 listener_pl1_label	label variable,	/* for nonlocal goto to parent ec's listener's stack frame	*/
  1   156 	   3 get_line_pl1_label	label variable,	/* for nonlocal goto to parent ec's get_line's stack frame	*/
  1   157 						/*						*/
  1   158 	  2 saved_state_ptr		ptr,		/* -> top of parser stack				*/
  1   159 	  2 current_lex_block_ptr	ptr,		/* -> lex_block for current block position		*/
  1   160 	  2 current_proc_block_ptr	ptr,		/* -> proc block for current procedure			*/
  1   161 	  2 last_block_ptr		ptr,		/* -> last lex or proc block that has been allocated	*/
  1   162 	  2 current_loop_ptr	ptr,		/* -> loop_block for current active loop		*/
  1   163 	  2 last_loop_ptr		ptr,		/* -> last loop block that has been allocated 		*/
  1   164 						/*						*/
  1   165 	  2 labels_ptr		ptr,		/* hash table ptr for label hash table			*/
  1   166 	  2 first_xlabel_ptr	ptr,		/* first expandable label				*/
  1   167 	  2 last_xlabel_ptr		ptr,		/* last expandable label				*/
  1   168 	  2 variables_ptr		ptr,		/* hash table ptr for variable hash table		*/
  1   169 						/*						*/
  1   170 	  2 timed_input		bit (1),		/* 1 indicates input requests may be delayed		*/
  1   171 	  2 low_sleep_time		fixed bin (35),	/* low  sleep time for timed input			*/
  1   172 	  2 sleep_time_range	fixed bin (35),	/* high sleep time for timed input			*/
  1   173 	  2 seed			fixed bin (35),	/* seed for timed input random numbers			*/
  1   174 						/*						*/
  1   175 	  2 work_area		area (800);	/* extensible area for args, etc.			*/
  1   176 
  1   177 declare	abs_data_version_1		fixed bin static options (constant) initial (1),
  1   178 	Work_area_size		fixed bin static options (constant) initial (800);
  1   179 
  1   180 dcl (UNEXPANDED init (1), EXPANDED init (2), ALL init (3), BOTH init (4))
  1   181 	fixed bin int static options (constant);
  1   182 
  1   183 /*  END OF:	abs_io_data.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *	*/
      211 
      212 
  2     1 /* BEGIN INCLUDE FILE -- abs_io_expand.incl.pl1 -- 07/07/80  S. Herbst */
  2     2 
  2     3 /* Added label_search_values 10/06/82 S. Herbst */
  2     4 /* Added next_begin_pos 04/29/83 S. Herbst */
  2     5 /* Added trace_lines.by_control_arg 03/20/84 S. Herbst */
  2     6 
  2     7 
  2     8 dcl expand_data_ptr ptr;
  2     9 						/* In comments, (Input), (Output) and (I/O) refer
  2    10*						   to how abs_io_expand_ sees the item. */
  2    11 dcl 1 expand_data aligned based (expand_data_ptr),
  2    12    2 version fixed bin,				/* = 1 */
  2    13    2 abs_data_ptr ptr,				/* ptr back to abs_data for this invocation of ec */
  2    14    2 expand_data_ptr ptr,				/* ptr to data maintained by abs_io_expand_ */
  2    15    2 next_expand_data_ptr ptr,			/* ptr to this structure for next &proc or &fcn */
  2    16    2 last_expand_data_ptr ptr,			/* ptr to this structure for outer proc or fcn */
  2    17    2 area_ptr ptr,					/* ptr to area in which to allocate args */
  2    18 
  2    19    2 input_pos fixed bin (21),			/* current character position in input file (I/O) */
  2    20    2 caller_buffer_info,
  2    21     3 caller_buffer_ptr ptr,				/* caller's buffer for returned line (Input) */
  2    22     3 caller_buffer_len fixed bin (21),			/* character size of buffer (Input) */
  2    23     3 caller_actual_len fixed bin (21),			/* number of chars returned (Output) */
  2    24    2 allocated_buffer_info,
  2    25     3 allocated_ptr ptr,				/* ptr to expand_'s allocated rest-of-line (I/O) */
  2    26     3 allocated_len fixed bin (21),			/* length of rest-of-line (I/O) */
  2    27     3 allocated_buffer_len fixed bin (21),		/* original allocated size (Output) */
  2    28 
  2    29    2 trace_lines,					/* tracing info for command or input lines */
  2    30     3 by_control_arg bit (1) unaligned,			/* ON if trace mode was specified by ec control arg */
  2    31     3 on bit (1) unaligned,				/* ON to trace at all */
  2    32     3 expand fixed bin (3) unaligned,			/* 1=unexpanded, 2=expanded, 3=all, 4=both */
  2    33     3 pad1 bit (66) unaligned,			/* pad to double word */
  2    34     3 iocb ptr,					/* IOCB to put trace on */
  2    35     3 prefix char (32) varying,			/* prefix for &trace tracing, eg. "COMMAND: " */
  2    36     3 pad2 bit (36),
  2    37 
  2    38    2 predicate_values,
  2    39     3 is_absin bit (1),				/* &is_absin, ON if absentee (Input) */
  2    40     3 is_af bit (1),				/* &is_af, ON if ec active function (Input) */
  2    41     3 is_input bit (1),				/* &is_input_line, ON if input line */
  2    42     3 pad bit (33),
  2    43    2 first_loop_ptr ptr,				/* ptr to first iteration loop activation (I/O) */
  2    44    2 first_block_ptr ptr,				/* ptr to first &do block (I/O) */
  2    45 
  2    46    2 label_search_values,
  2    47     3 searching_for char (200),			/* label being searched for ($skip) */
  2    48     3 (next_begin_pos,				/* position of next &begin */
  2    49        next_do_pos,					/* position of next &do */
  2    50        next_end_pos,				/* position of next &end */
  2    51        next_label_pos,				/* position of next &label */
  2    52        next_quote_pos,				/* position of next &" */
  2    53        next_comment_pos) fixed bin (21),		/* position of next &- */
  2    54 
  2    55    2 expander_output,				/* returned by abs_io_expand_ after parsing */
  2    56     3 this_statement,
  2    57      4 pos fixed bin (21),				/* beginning of current (parsed) statement */
  2    58      4 len fixed bin (21),				/* length of entire statement */
  2    59      4 keyword_len fixed bin (21),			/* length of just the keyword portion */
  2    60      4 action fixed bin,				/* semantic number of this keyword */
  2    61     3 semant_info,
  2    62      4 semantics fixed bin,				/* additional information for the code that implements */
  2    63      4 modifier fixed bin,				/* and more info for certain ones */
  2    64      4 flag fixed bin,				/* what can I say? */
  2    65     3 arg_info,
  2    66      4 arg_ptr ptr,					/* ptr to single arg if keyword takes only one (Output) */
  2    67      4 arg_len fixed bin (21),			/* length of single arg (Output) */
  2    68      4 parsed_args_ptr ptr,				/* points to parsed_args structure if >1 args (Output) */
  2    69     3 next_statement like expand_data.this_statement,	/* next statement info (look-ahead) (Output) */
  2    70     3 expanded_sw bit (1),				/* ON if expand_ had to expand label stmt (Output) */
  2    71     3 error_msg char (168) aligned;			/* diagnosis if abs_io_expand returns code ^= 0 */
  2    72 
  2    73 
  2    74 dcl parsed_args_count fixed bin;
  2    75 dcl parsed_args_ptr ptr;
  2    76 
  2    77 dcl 1 parsed_args aligned based (parsed_args_ptr),
  2    78    2 count fixed bin,				/* number of arguments */
  2    79    2 array (parsed_args_count refer (parsed_args.count)),
  2    80     3 ptr ptr unaligned,				/* ptr to the argument */
  2    81     3 len fixed bin (21),				/* length of the argument */
  2    82     3 quote_count fixed bin,				/* number of internal quote chars (for allocating &r) */
  2    83     3 flags bit (36) aligned;				/* reserved for specific types of args */
  2    84 
  2    85 dcl expand_data_version_2 fixed bin int static options (constant) init (2);
  2    86 
  2    87 /* END INCLUDE FILE abs_io_expand.incl.pl1 */
      213 
      214 
  3     1 /* BEGIN value_structures.incl.pl1 */
  3     2 
  3     3 dcl (match_info_ptr, value_list_info_ptr) ptr;
  3     4 dcl (alloc_name_count, alloc_pair_count) fixed bin;
  3     5 dcl (alloc_max_name_len, alloc_chars_len) fixed bin (21);
  3     6 
  3     7 dcl 1 match_info aligned based (match_info_ptr),
  3     8    2 version fixed bin,				/* = 1 */
  3     9    2 name_count fixed bin,
  3    10    2 max_name_len fixed bin (21),
  3    11    2 name_array (alloc_name_count refer (match_info.name_count)),
  3    12     3 exclude_sw bit (1) unaligned,			/* ON for -exclude, OFF for -match */
  3    13     3 regexp_sw bit (1) unaligned,			/* ON for regular exp. without the //, OFF for starname */
  3    14     3 pad bit (34) unaligned,
  3    15     3 name char (alloc_max_name_len refer (match_info.max_name_len)) varying;
  3    16 
  3    17 dcl 1 value_list_info aligned based (value_list_info_ptr),
  3    18    2 version fixed bin,				/* = 1 */
  3    19    2 pair_count fixed bin,
  3    20    2 chars_len fixed bin (21),
  3    21    2 pairs (alloc_pair_count refer (value_list_info.pair_count)),
  3    22     3 type_switches bit (36),				/* correspond to the selection switches arg */
  3    23     3 (name_index, name_len) fixed bin (21),
  3    24     3 (value_index, value_len) fixed bin (21),
  3    25    2 chars char (alloc_chars_len refer (value_list_info.chars_len));
  3    26 
  3    27 dcl (match_info_version_1, value_list_info_version_1) fixed bin int static options (constant) init (1);
  3    28 
  3    29 /* END OF value_structures.incl.pl1 */
      215 
      216 
      217 
      218 end abs_io_list_vars;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/11/87  0925.7  abs_io_list_vars.pl1              >spec>install>MR12.1-1080>abs_io_list_vars.pl1
211          1    08/11/87  0925.5  abs_io_data.incl.pl1              >spec>install>MR12.1-1080>abs_io_data.incl.pl1
213          2    10/23/84  0848.6  abs_io_expand.incl.pl1            >ldd>include>abs_io_expand.incl.pl1
215          3    06/24/81  1743.9  value_structures.incl.pl1         >ldd>include>value_structures.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
A_abs_data_ptr                         parameter       pointer                  dcl 14 ref 6 55
A_code                                 parameter       fixed bin(35,0)          dcl 16 set ref 6 57* 174* 205*
A_error_msg                            parameter       char                     unaligned dcl 15 set ref 6 173* 204*
A_parsed_args_ptr                      parameter       pointer                  dcl 14 ref 6 56
P_str                                  parameter       char                     unaligned dcl 202 ref 200 204
abs_data                               based           structure                level 1 dcl 1-23
abs_data_ptr                    000124 automatic       pointer                  dcl 1-21 set ref 55* 169
alloc_max_name_len              000135 automatic       fixed bin(21,0)          dcl 3-5 set ref 62* 82* 82 102* 113 113 118
alloc_name_count                000134 automatic       fixed bin(17,0)          dcl 3-4 set ref 62* 80* 80 99 101* 104* 104 113 113
                                                                                  117
area_ptr                        000106 automatic       pointer                  dcl 27 set ref 109* 113 169* 195 196
arg                                    based           char                     unaligned dcl 20 set ref 70 70 70 70 74 75 75 77 85
                                                                                  85 87 87 89 132 134 134 142 142 142 144 147* 148
                                                                                  151 155
arg_len                         000114 automatic       fixed bin(21,0)          dcl 30 set ref 68* 70 70 70 70 74 75 75 77 79* 82 85
                                                                                  85 87 87 89 130* 132 134 134 141* 142 142 142 142
                                                                                  144 144 147 147 148 151 155
arg_ptr                         000110 automatic       pointer                  dcl 27 set ref 67* 70 70 70 70 74 75 75 77 78* 85 85
                                                                                  87 87 89 129* 132 134 134 139* 142 142 142 144 147
                                                                                  148 151 155
array                     1            based           structure                array level 2 dcl 2-77
based_area                             based           area(1024)               dcl 21 ref 113 195 196
chars                                  based           char                     level 2 dcl 3-17 ref 181 181 184 184
chars_len                 2            based           fixed bin(21,0)          level 2 dcl 3-17 ref 181 181 184 184 196
check_star_name_$entry          000016 constant        entry                    external dcl 41 ref 147
cleanup                         000116 stack reference condition                dcl 53 ref 111
code                            000115 automatic       fixed bin(35,0)          dcl 31 set ref 147* 148 169* 170 170 174
command_line            162            based           structure                level 2 dcl 1-23
count                                  based           fixed bin(17,0)          level 2 dcl 2-77 ref 64 74 127
default_sw                      000100 automatic       bit(1)                   dcl 25 set ref 99* 100 120 127
error_table_$badstar            000010 external static fixed bin(35,0)          dcl 35 ref 148
error_table_$badsyntax          000012 external static fixed bin(35,0)          dcl 36 ref 205
error_table_$nomatch            000014 external static fixed bin(35,0)          dcl 37 ref 170
exclude_first_sw                000101 automatic       bit(1)                   dcl 25 set ref 61* 75* 104 120
exclude_sw                3            based           bit(1)                   array level 3 packed unaligned dcl 3-7 set ref 122*
                                                                                  136* 157* 164*
expand_data                            based           structure                level 1 dcl 2-11
expander_output         144            based           structure                level 2 dcl 2-11
get_system_free_area_           000020 constant        entry                    external dcl 42 ref 109
i                               000112 automatic       fixed bin(17,0)          dcl 29 set ref 64* 67 68 73* 73 74 78 79* 127* 129
                                                                                  130 137* 137 139 141* 179* 181 181 181 181 184 184
                                                                                  184 184*
index                                                  builtin function         dcl 49 ref 70 132
ioa_                            000022 constant        entry                    external dcl 43 ref 170 184 186
ioa_$nnl                        000024 constant        entry                    external dcl 43 ref 181
len                       2            based           fixed bin(21,0)          array level 3 dcl 2-77 ref 68 79 130 141
match_arg_sw                    000102 automatic       bit(1)                   dcl 25 set ref 61* 77* 92*
match_info                             based           structure                level 1 dcl 3-7 set ref 113 115* 195
match_info_ptr                  000130 automatic       pointer                  dcl 3-3 set ref 59* 113* 115 116 117 118 122 122 123
                                                                                  136 143 144 150 151 157 164 169* 195 195
match_info_version_1                   constant        fixed bin(17,0)          initial dcl 3-27 ref 116
match_sw                        000103 automatic       bit(1)                   dcl 25 set ref 61* 75 76* 92*
max_name_len              2            based           fixed bin(21,0)          level 2 dcl 3-7 set ref 113* 115 118* 122 122 122
                                                                                  122 123 123 123 136 136 143 143 144 144 144 150
                                                                                  150 151 151 151 157 157 164 164 195
name                      4            based           varying char             array level 3 dcl 3-7 set ref 123* 144* 151*
name_array                3            based           structure                array level 2 dcl 3-7
name_count                1            based           fixed bin(17,0)          level 2 dcl 3-7 set ref 113* 115 117* 195
name_index                4            based           fixed bin(21,0)          array level 3 in structure "value_list_info"
                                                                                  dcl 3-17 in procedure "abs_io_list_vars" ref 181
                                                                                  181
name_index                      000113 automatic       fixed bin(17,0)          dcl 29 in procedure "abs_io_list_vars" set ref 121*
                                                                                  125* 135* 135 136 143 144 150 151 156* 156 157
                                                                                  163* 163 164
name_len                  5            based           fixed bin(21,0)          array level 3 dcl 3-17 ref 181 181
null                                                   builtin function         dcl 49 ref 59 64 195 196
pair_count                1            based           fixed bin(17,0)          level 2 dcl 3-17 ref 179 181 181 184 184 196
pairs                     3            based           structure                array level 2 dcl 3-17
parsed_args                            based           structure                level 1 dcl 2-77
parsed_args_ptr                 000126 automatic       pointer                  dcl 2-75 set ref 56* 64 64 67 68 74 78 79 127 129
                                                                                  130 139 141
ptr                       1            based           pointer                  array level 3 packed unaligned dcl 2-77 ref 67 78
                                                                                  129 139
regexp_sw                 3(01)        based           bit(1)                   array level 3 packed unaligned dcl 3-7 set ref 122*
                                                                                  143* 150*
requote_string_                 000026 constant        entry                    external dcl 44 ref 184
substr                                                 builtin function         dcl 49 ref 142 142 144 181 181 184 184
this_statement          144            based           structure                level 3 dcl 2-11
unspec                                                 builtin function         dcl 49 set ref 115*
val_sw                          000104 automatic       bit(1)                   dcl 25 set ref 61* 85* 97 97* 181* 184
value_$list                     000030 constant        entry                    external dcl 45 ref 169
value_index               6            based           fixed bin(21,0)          array level 3 dcl 3-17 ref 184 184
value_len                 7            based           fixed bin(21,0)          array level 3 dcl 3-17 ref 184 184
value_list_info                        based           structure                level 1 dcl 3-17 ref 196
value_list_info_ptr             000132 automatic       pointer                  dcl 3-3 set ref 59* 169* 179 181 181 181 181 181 181
                                                                                  184 184 184 184 184 184 196 196
var_sw                          000105 automatic       bit(1)                   dcl 25 set ref 61* 87* 97 97* 181
variables_ptr           410            based           pointer                  level 2 dcl 1-23 set ref 169*
version                                based           fixed bin(17,0)          level 2 dcl 3-7 set ref 116*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALL                                    internal static fixed bin(17,0)          initial dcl 1-180
BOTH                                   internal static fixed bin(17,0)          initial dcl 1-180
EXPANDED                               internal static fixed bin(17,0)          initial dcl 1-180
UNEXPANDED                             internal static fixed bin(17,0)          initial dcl 1-180
Work_area_size                         internal static fixed bin(17,0)          initial dcl 1-177
abs_data_version_1                     internal static fixed bin(17,0)          initial dcl 1-177
alloc_chars_len                        automatic       fixed bin(21,0)          dcl 3-5
alloc_pair_count                       automatic       fixed bin(17,0)          dcl 3-4
expand_data_ptr                        automatic       pointer                  dcl 2-8
expand_data_version_2                  internal static fixed bin(17,0)          initial dcl 2-85
parsed_args_count                      automatic       fixed bin(17,0)          dcl 2-74
value_list_info_version_1              internal static fixed bin(17,0)          initial dcl 3-27

NAMES DECLARED BY EXPLICIT CONTEXT.
MATCH_ARG                       000617 constant        label                    dcl 137 ref 158
MATCH_NAME                      000620 constant        label                    dcl 139 ref 165
NAME                            000300 constant        label                    dcl 80 ref 93
RETURN                          001304 constant        label                    dcl 188 ref 207
abs_io_list_vars                000101 constant        entry                    external dcl 6
clean_up                        001312 constant        entry                    internal dcl 193 ref 111 188
error                           001357 constant        entry                    internal dcl 200 ref 74 89 148

NAME DECLARED BY CONTEXT OR IMPLICATION.
max                                                    builtin function         ref 82

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1564        1616    1416        1574
Length      2060    1416        32         226     145           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
abs_io_list_vars                    137 external procedure  is an external procedure.  
on unit on line 111                  64 on unit               
clean_up                             65 internal procedure  is called by several nonquick procedures.  
error                                65 internal procedure  is called during a stack extension.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
abs_io_list_vars         000100 default_sw                  abs_io_list_vars
                         000101 exclude_first_sw            abs_io_list_vars
                         000102 match_arg_sw                abs_io_list_vars
                         000103 match_sw                    abs_io_list_vars
                         000104 val_sw                      abs_io_list_vars
                         000105 var_sw                      abs_io_list_vars
                         000106 area_ptr                    abs_io_list_vars
                         000110 arg_ptr                     abs_io_list_vars
                         000112 i                           abs_io_list_vars
                         000113 name_index                  abs_io_list_vars
                         000114 arg_len                     abs_io_list_vars
                         000115 code                        abs_io_list_vars
                         000124 abs_data_ptr                abs_io_list_vars
                         000126 parsed_args_ptr             abs_io_list_vars
                         000130 match_info_ptr              abs_io_list_vars
                         000132 value_list_info_ptr         abs_io_list_vars
                         000134 alloc_name_count            abs_io_list_vars
                         000135 alloc_max_name_len          abs_io_list_vars

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this
call_int_other      return_mac          tra_ext_1           enable_op           shorten_stack       ext_entry_desc
int_entry           int_entry_desc      op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
check_star_name_$entry        get_system_free_area_         ioa_                          ioa_$nnl
requote_string_               value_$list

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badstar          error_table_$badsyntax        error_table_$nomatch




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      6 000074        55 000114        56 000120        57 000123        59 000124        61 000127        62 000134
     64 000136        67 000151        68 000155        70 000160        73 000207        74 000210        75 000240
     76 000257        77 000261        78 000270        79 000275        80 000300        82 000301        83 000306
     85 000307        87 000322        89 000335        91 000363        92 000364        93 000367        95 000370
     97 000372        99 000402       100 000405       101 000406       102 000410       103 000412       104 000413
    109 000416       111 000425       113 000447       115 000465       116 000500       117 000502       118 000504
    120 000506       121 000512       122 000514       123 000526       124 000536       125 000537       127 000540
    129 000551       130 000555       132 000560       134 000572       135 000603       136 000604       137 000617
    139 000620       141 000625       142 000630       143 000644       144 000656       145 000674       147 000675
    148 000714       150 000746       151 000761       153 000777       155 001000       156 001004       157 001005
    158 001020       160 001021       163 001022       164 001023       165 001036       167 001037       169 001041
    170 001065       173 001106       174 001114       175 001115       179 001116       181 001127       184 001203
    186 001270       187 001302       188 001304       191 001310       193 001311       195 001317       196 001335
    198 001355       200 001356       204 001372       205 001404       207 001407


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
