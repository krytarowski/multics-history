	COMPILATION LISTING OF SEGMENT mrds_dsm_compute_access
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-05-05_1830.37_Fri_mdt
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 mrds_dsm_compute_access: proc (p_caller_name, p_submodel_path, p_listing_iocb_ptr, p_data_model_ptr, p_code);
       10 
       11 /*
       12*   where:
       13*   .   p_caller_name	char (*)		(input)
       14*   .     name of the module calling this  routine,  used  for  error
       15*   .     reporting
       16*   .   p_submodel_path	char (*)		(input)
       17*   .     path of submodel access bits are to be computed for
       18*   .   p_listing_iocb_ptr     ptr                 (input)
       19*   .     pointer to the listing iocb or null if no listing is  being
       20*   .     produced
       21*   .   p_data_model_ptr       ptr                 (input)
       22*   .     pointer to the data_model used for verifing relation access
       23*   .   p_code		fixed bin (35)	(output)
       24*   .     stand error code
       25*
       26*   Takes a  submodel  vfile  as  produced  by  create_mrds_dsm  (via
       27*   mrds_dsm_parse,  et.al.)  and  fills  in  the  access bits in the
       28*   relation records.
       29*
       30*   The  processing  of  the  dsm   is   done   via   two   switches,
       31*   relation_records_iocb_ptr  and  access_records_iocb_ptr. A select
       32*   control order is done on the relation_records_iocb_ptr switch  to
       33*   get  only the relation records. These are then processed one at a
       34*   time.
       35*
       36*   First calc_relation_access is called for  the  current  relation,
       37*   then calc_attr_access is called for each attribute in the current
       38*   relation. calc_relation_access and  calc_attr_access  operate  by
       39*   looking  around  in  the  dsm for various kinds of access records
       40*   which relate to the current object. The basic algorithm  is  that
       41*   the  access  records  are  looked  for  in  decreasing  order  of
       42*   specificity. Whenever an access record  is  found,  get_(relation
       43*   attribute)_access  is  called  to decode the access mode names in
       44*   the access record and set the appropriate bits in a bit string.
       45*
       46*   The access_records_iocb_ptr switch is used by the calc_* routines
       47*   so  that  their  poking  around  in the dsm won't through off the
       48*   positioning of the walk through all of  relations.  Also,  having
       49*   the  two  allows  the  use of a select order to find the relation
       50*   records and use read_record to sequence through them  instead  of
       51*   doing successive searches via get_key control orders.
       52*
       53*   When all the relations and their attributes have  been  processed
       54*   the access records are checked to be sure that they were all used
       55*   at least once. If a record is not  used  it  is  assumed  that  a
       56*   problem  exists  in  the  source  (possibly  a typo in the access
       57*   specification statement or the relation statement) and  an  error
       58*   is reported.
       59*
       60*   Internal procedures do not return error codes. If an error occurs
       61*   that  cannot  be  recovered from while in an internal procedure a
       62*   call to program_logic_error is made which will report the  error,
       63*   cleanup,   set  the  return  code,  and  do  a  non-local  go  to
       64*   exit_compute_access to exit this routine. If an error occurs that
       65*   can  be  recovered  from (semantic error based on incorrect cmdsm
       66*   source) it is reported and the error code  set  (via  a  call  to
       67*   report error) and processing is continued like it never happened.
       68*
       69*
       70*
       71*   Known Bugs:
       72*
       73*   Other Problems:
       74*   
       75*   HISTORY:
       76*
       77*   79-11-30 Spratt: Written
       78*
       79*   80-02-21 Spratt: to convert from  compute_dsm_access  command  to
       80*   .        mrds_dsm_compute_access subroutine.
       81*
       82*   80-12-05  Spratt:  the  p_caller_name  argument  added  to  allow
       83*   .        reporting of errors as though the calling  program  were
       84*   .        doing the reporting.
       85*
       86*   .        The get_access routine was changed  to  have  its  input
       87*   .        mode_name_array  argument  be  0  based so that it could
       88*   .        catch "null" modes  properly  (now  declared  (0:*)  was
       89*   .        declared (*)).
       90*
       91*   .        Added the null mode for relations,  removed  the  status
       92*   .        mode.
       93*
       94*   .        Changed all error messages to have initial newlines.
       95*
       96*   80-12-08 Spratt: Added a cleanup_handler routine, which is called
       97*   .        before any return  and  on  the  cleanup  condition.  It
       98*   .        primarily  ensures  that  the  iox_ switches against the
       99*   .        submodel are closed and detached.
      100*
      101*   .        Made the names of the dsm switches unique.
      102*
      103*   .        Changed myname from internal static options(constant) to
      104*   .        automatic, to allow it to be set.
      105*
      106*   81-01-23 Davids: modified the calls to iox_$read_record  so  that
      107*   .        they used as a buffer  size  sys_info$max_seg_size  *  4
      108*   .        rather  than 261120 which aside from being a constant is
      109*   .        just the number of words in a segment not the number  of
      110*   .        bytes.
      111*
      112*   81-05-01 Davids: reformated and remodulated - many, many changes.
      113*
      114*   81-05-04 Davids: added checks for  unused  access  specifications
      115*   .        and for continuing checking after the first  combination
      116*   .        of  null  and non-null access is found. Also if an error
      117*   .        is found it now returns a non-zero error code.
      118*
      119*   81-05-11  Davids  added  the  parameter  p_listing_iocb_ptr   and
      120*   .        changed report error  to  report  errors  via  ioa  over
      121*   .        iox_$error_output   and   the  listing_iocb_ptr  if  its
      122*   .        non-null.
      123*
      124*   81-05-12     Davids:     changed     error_table_$bad_arg      to
      125*   .        mrds_error_$inconsistent_submodel. The error  code  does
      126*   .        not have to be all that informative since each error has
      127*   .        an expanatory message associated with it.
      128*
      129*   81-05-22 Davids:  added  a check to be sure that keys of the form
      130*   .        model relation: are not used to read in access records.
      131*
      132*   .        added  the  data_model_ptr to the parameter list and the
      133*   .        internal procedure validate_relation_access
      134*
      135*   81-05-27 Davids: changed the action for  a  non-zero  error  code
      136*   .        returned      from       mrds_dm_get_attributes       in
      137*   .        validate_relation_access      from     a     call     to
      138*   .        program_logic_error to a simple return  statement.  this
      139*   .        is  because  the  failure  of mrds_dm_get_attributes has
      140*   .        already been reported in mrds_dsm_semantics.  processing
      141*   .        continues  (both  here  and in semantics) so the maximum
      142*   .        number of errors can be reported.
      143*
      144*   81-09-17  Davids:  added  a  local_key_string  variable  to   the
      145*   .        internal  procedure  verify_access_record_use  which  is
      146*   .        char   (256)   non-varying.   this   is  because  substr
      147*   .        (key_string, 1, 15) would cause a  stringsize  error  is
      148*   .        key_string  was  not  at  least  15  characters long. by
      149*   .        assigning key_string to local_key_string it  is  assured
      150*   .        that  the  string will be long enough - just padded with
      151*   .        blanks.
      152*
      153*   83-06-13 Harvey: changed references to addrel (addr (REL_HEAD), 1)
      154*   .        to  be  addrel (temp_ptr, 1)  instead.  This is due to  a
      155*   .	  compiler bug (TR 15402).
      156*
      157**/
      158 
      159 /* PARAMETER */
      160 
      161 	dcl     p_caller_name	 char (*);	/* (input) name of the module calling this
      162*						   routine - used for error reporting */
      163 	dcl     p_submodel_path	 char (*);	/* (input) path of submodel - including the .dsm suffix */
      164 	dcl     p_listing_iocb_ptr	 ptr;		/* (input) pointer to the listing iocb or */
      165 						/* null if no listing is being produced */
      166 	dcl     p_data_model_ptr	 ptr;		/* (input) pointer th the data_model, used
      167*						   to verify that the specified relation access is ok */
      168 	dcl     p_code		 fixed bin (35);	/* standard error code */
      169 
      170 /* AUTOMATIC */
      171 
      172 	dcl     access_record_len	 fixed bin (21);	/* length of the access record read */
      173 	dcl     access_records_iocb_ptr ptr init (null ()); /* iocb pointer used to reference the
      174*						   access records in the submodel */
      175 	dcl     attr_idx		 fixed bin;	/* index of attributes within a relation */
      176 	dcl     code		 fixed bin (35);	/* internal error code */
      177 	dcl     have_sought_default_attribute_access bit (1) /* "1"b if default attribute access has been determined */
      178 				 init ("0"b);
      179 	dcl     have_sought_default_relation_access bit (1) /* "1"b if default relation access has been determined */
      180 				 init ("0"b);
      181 	dcl     info_ptr		 ptr init (null ());/* pointer to the hi_sl_info structure used for
      182*						   setting up the subset of relation records */
      183 	dcl     key_string		 char (256) varying;/* used for submodel record keys */
      184 	dcl     last_rel_attr_access_sought_for char (32) varying; /* name of relation that the current
      185*						   rel_attr_access is setup for */
      186 	dcl     local_area_ptr	 ptr;		/* pointer to the local area */
      187 	dcl     rel_rec_5_len	 fixed bin (21);	/* length of the rel_rec_5 record read */
      188 	dcl     rel_rec_5_ptr	 ptr init (null ());/* pointer to the buffer used to store
      189*						   rel_rec_5 records after reading */
      190 	dcl     relation_name	 char (64) varying; /* name of relation access is currently being calculated for */
      191 	dcl     relation_records_iocb_ptr ptr init (null ()); /* pointer to the iocb used to read the relation records */
      192 	dcl     temp_ptr		 ptr;		/* becomes addr (REL_HEAD) */
      193 	dcl     temp_seg_ptrs	 (3) ptr init (null (), null (), null ());
      194 						/* pointers to three temporary segments
      195*						   - set by get_temp_segments_ */
      196 	dcl     01 default_attribute_access like attribute_access; /* the default attribute access */
      197 	dcl     01 default_relation_access like relation_access; /* the default relation access */
      198 	dcl     01 implicit_default_attribute_access /* default attribute access values used if the */
      199 				 like attribute_access; /* cmdsm source does not specify any other values */
      200 	dcl     01 implicit_default_relation_access /* default relation access values used if the */
      201 				 like relation_access; /* cmdsm source does not specify any other values */
      202 	dcl     01 rel_attr_access	 like attribute_access; /* default attribute access values for the current relation */
      203 
      204 /* BASED */
      205 
      206 	dcl     local_area		 area (sys_info$max_seg_size) based (local_area_ptr);
      207 						/* area for allocations */
      208 
      209 /* BUILTIN */
      210 
      211 	dcl     addr		 builtin;
      212 	dcl     addrel		 builtin;
      213 	dcl     empty		 builtin;
      214 	dcl     length		 builtin;
      215 	dcl     null		 builtin;
      216 	dcl     substr		 builtin;
      217 	dcl     unspec		 builtin;
      218 
      219 /* CONDITION */
      220 
      221 	dcl     cleanup		 condition;
      222 
      223 /* ENTRY */
      224 
      225 	dcl     get_temp_segments_	 entry (char (*), pointer dimension (*), fixed bin (35));
      226 	dcl     iox_$control	 entry (ptr, char (*), ptr, fixed bin (35));
      227 	dcl     iox_$position	 entry (ptr, fixed bin, fixed bin (21), fixed bin (35));
      228 	dcl     iox_$read_key	 entry (ptr, char (256) varying, fixed bin (21), fixed bin (35));
      229 	dcl     iox_$read_record	 entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35));
      230 	dcl     iox_$rewrite_record	 entry (ptr, ptr, fixed bin (21), fixed bin (35));
      231 	dcl     iox_$seek_key	 entry (ptr, char (256) varying, fixed bin (21), fixed bin (35));
      232 	dcl     mrds_dm_get_attributes entry (ptr, char (32), ptr, ptr, fixed bin (35));
      233 	dcl     mrds_dsm_close$force	 entry (ptr);
      234 	dcl     mrds_dsm_open$update_share entry (char (*), ptr, fixed bin (35));
      235 	dcl     release_temp_segments_ entry (char (*), pointer dimension (*), fixed bin (35));
      236 
      237 /* EXTERNAL */
      238 
      239 	dcl     error_table_$end_of_info fixed bin (35) external static; ;
      240 	dcl     error_table_$no_record fixed bin (35) external static;
      241 	dcl     mrds_error_$inconsistent_submodel fixed bin (35) external static;
      242 	dcl     sys_info$max_seg_size	 fixed bin (24) external static;
      243 
      244 /*
      245*   Set up initial values  for  variables  that  for  one  reason  or
      246*   another cannot be set in the variable's declaration statement.
      247**/
      248 
      249 
      250 
      251 	access_record_ptr = null;
      252 
      253 	default_relation_access.null = "0"b;
      254 	default_relation_access.append = "0"b;
      255 	default_relation_access.delete = "0"b;
      256 	default_relation_access.mbz1 = "0"b;
      257 
      258 	default_attribute_access.null = "0"b;
      259 	default_attribute_access.read = "0"b;
      260 	default_attribute_access.modify = "0"b;
      261 	default_attribute_access.mbz1 = "0"b;
      262 
      263 	implicit_default_relation_access.null = "1"b;
      264 	implicit_default_relation_access.append = "0"b;
      265 	implicit_default_relation_access.delete = "0"b;
      266 	implicit_default_relation_access.mbz1 = "0"b;
      267 
      268 	implicit_default_attribute_access.null = "0"b;
      269 	implicit_default_attribute_access.read = "1"b;
      270 	implicit_default_attribute_access.modify = "0"b;
      271 	implicit_default_attribute_access.mbz1 = "0"b;
      272 
      273 
      274 
      275 
      276 
      277 /*
      278*   Set up the cleanup condition handler.
      279**/
      280 
      281 	on cleanup call cleanup_handler;
      282 
      283 
      284 
      285 
      286 
      287 /*
      288*   Set the return error code to zero - do not assume its input value was zero
      289**/
      290 
      291 	p_code = 0;
      292 
      293 /*
      294*   Set up the switches for processing the submodel.
      295*
      296*   The submodel must be opened twice  for  update_share.  The  first
      297*   opening  (relation_records_iocb_ptr) is used to read the relation
      298*   records and update their access information. The  second  opening
      299*   (access_records_iocb_ptr)  is used to read the access records and
      300*   change the used element to "1"b without  changing  the  "current"
      301*   relation record.
      302**/
      303 
      304 
      305 	call mrds_dsm_open$update_share (p_submodel_path, relation_records_iocb_ptr, code);
      306 	if code ^= 0
      307 	then do;
      308 		call report_error (code, "^/Could not open ^a in shared update mode", "", "");
      309 		call cleanup_handler;
      310 		goto exit_compute_access;
      311 	     end;
      312 
      313 
      314 
      315 	call mrds_dsm_open$update_share (p_submodel_path, access_records_iocb_ptr, code);
      316 	if code ^= 0
      317 	then do;
      318 		call report_error (code, "^/Could not open ^a in shared read mode", "", "");
      319 		call cleanup_handler;
      320 		goto exit_compute_access;
      321 	     end;
      322 
      323 /*
      324*   Set up buffer space for reading the relation and access records,
      325*   and an area for allocating things in.
      326*
      327*   Three temporary segments are obtained from the temp segment pool.
      328*   the   pointers   to  these  segments  will  be  assigned  to  the
      329*   access_record_ptr,  the   rel_rec_5_ptr,  and the local_area_ptr.
      330*   Since records in a vfile_ cannot be longer  than  1  segment  the
      331*   buffer will always be adequate.
      332**/
      333 
      334 
      335 	call get_temp_segments_ (p_caller_name, temp_seg_ptrs, code);
      336 	if code ^= 0
      337 	then do;
      338 		call report_error (code, "^/Could not get temporary segment.", "", "");
      339 		call cleanup_handler;
      340 		goto exit_compute_access;
      341 	     end;
      342 
      343 
      344 	access_record_ptr = temp_seg_ptrs (1);
      345 	rel_rec_5_ptr = temp_seg_ptrs (2);
      346 	local_area_ptr = temp_seg_ptrs (3);
      347 	local_area = empty ();
      348 
      349 /*
      350*   Create a subset consisting of only the relation records using the
      351*   relation_records_iocb_ptr,  and setup to read the first record in
      352*   the subset.
      353*
      354*
      355*
      356*   A hi_sl_info structure is allocated in a small local  area.  This
      357*   structure  is  used to build a subset of the records in the vfile
      358*   which have keys greater than or equal to first_head and less than
      359*   of equal to last_head, in this case only one pair of keys is used
      360*   and the net effect is to select all records which have a key head
      361*   equal  to  the  string  contained  in REL_HEAD, i.e. all relation
      362*   records.
      363**/
      364 
      365 	sl_array_limit = 1;
      366 	allocate hi_sl_info in (local_area) set (info_ptr);
      367 	hi_sl_info.version = sl_info_version_0;
      368 	temp_ptr = addr (REL_HEAD);
      369 	hi_sl_info.first_head.kptr = addrel (temp_ptr, 1);
      370 	hi_sl_info.first_head.length = length (REL_HEAD);
      371 	hi_sl_info.last_head.length = length (REL_HEAD);
      372 	hi_sl_info.last_head.kptr = addrel (temp_ptr, 1);
      373 	hi_sl_info.list_type = 1;
      374 	hi_sl_info.status_only = "0"b;
      375 	hi_sl_info.output_descriptors = "0"b;
      376 	call iox_$control (relation_records_iocb_ptr, "select", info_ptr, code);
      377 	if code ^= 0
      378 	then call program_logic_error (code, "Unable to select relation subset.", "", "");
      379 
      380 
      381 
      382 /*
      383*   Position to the beginning of the "relation" subset just created.
      384**/
      385 
      386 	call iox_$position (relation_records_iocb_ptr, -1, 0, code);
      387 	if code ^= 0
      388 	then call program_logic_error (code, "Unable to position to beginning of relation records subset.", "", "");
      389 
      390 
      391 
      392 /*
      393*   Read the first key of the "relation" subset. This  is  equivalent
      394*   to getting the name of the first relation in the submodel.
      395**/
      396 
      397 	call iox_$read_key (relation_records_iocb_ptr, key_string, rel_rec_5_len, code);
      398 	if code ^= 0
      399 	then call program_logic_error (code, "Could not read first key in relation subset.", "", "");
      400 
      401 /*
      402*   Walk through the "relation" subset, one relation at a  time.  For
      403*   each  relation;  get its record (rel_rec_5), calculate the access
      404*   for  the  relation,  calculate  the  access  for  each   of   its
      405*   attributes, rewrite the record with the access bits set, and read
      406*   the key of the next relation record. When all the  relations  and
      407*   their  attributes  have  been processed check to be sure that all
      408*   the access records have been used.
      409**/
      410 
      411 
      412 	do while (code = 0);
      413 	     call iox_$read_record (relation_records_iocb_ptr, rel_rec_5_ptr,
      414 		(sys_info$max_seg_size * 4), rel_rec_5_len, code);
      415 	     if code ^= 0
      416 	     then call program_logic_error (code, "Unable to read record for key ^a.", key_string, "");
      417 
      418 
      419 
      420 	     relation_name = substr (key_string, length (REL_HEAD) + 1);
      421 	     call calc_relation_access (relation_name, addr (rel_rec_5_ptr -> rel_rec_5.access));
      422 
      423 
      424 	     do attr_idx = 1 to rel_rec_5_ptr -> rel_rec_5.attr_num;
      425 		call calc_attribute_access (relation_name, rel_rec_5_ptr -> rel_rec_5.attr (attr_idx).dsm_name,
      426 		     addr (rel_rec_5_ptr -> rel_rec_5.attr (attr_idx).access));
      427 	     end;
      428 
      429 
      430 	     call validate_relation_access;
      431 
      432 
      433 	     call iox_$rewrite_record (relation_records_iocb_ptr, rel_rec_5_ptr, rel_rec_5_len, code);
      434 	     if code ^= 0
      435 	     then call program_logic_error (code, "Unable to rewrite relation record for relation ^a.", relation_name, "");
      436 
      437 
      438 
      439 	     call iox_$read_key (relation_records_iocb_ptr, key_string, rel_rec_5_len, code);
      440 	     if code ^= 0 & code ^= error_table_$end_of_info
      441 	     then call program_logic_error (code, "Unable to  read a key from the relation subset.", "", "");
      442 	end;
      443 
      444 
      445 	call verify_access_record_use;
      446 
      447 
      448 
      449 	call cleanup_handler;
      450 
      451 exit_compute_access:
      452 	return;					/* Effective end of compute_dsm_access. */
      453 
      454 calc_relation_access: proc (a_rel_name, access_ptr);
      455 
      456 /*
      457*   This routine calculates a relation access and sets the results in
      458*   the relation_access structure.
      459*
      460*   Access records are searched for starting with the  most  specific
      461*   (case  1) and continuing to the least specific (case3). The cases
      462*   and the cmdsm statements that  generate  the  access  are  listed
      463*   below.
      464*
      465*   relation access: a_rel_name (specs)
      466*   .   Sets a_rel_name's access.
      467*
      468*   default relation access: (specs)
      469*   .   Sets the relation access for all relations which  do  have  a
      470*   .   relation access statement defining a specific access.
      471*
      472*   .   If no default relation  access  statement  is  in  the  cmdsm
      473*   .   source  than  those  relations  which  do not have a relation
      474*   .   access statement seting a  specific  access  will  given  the
      475*   .   implicit default relation access.
      476*
      477*   Cases  2  and  3  are  done  in  the  get_default_relation_access
      478*   routine.
      479**/
      480 
      481 /* PARAMETERS */
      482 
      483 	dcl     a_rel_name		 char (*) varying;
      484 	dcl     access_ptr		 ptr;
      485 
      486 /* AUTOMATIC */
      487 
      488 	dcl     key_string		 char (256) varying;
      489 
      490 
      491 	unspec (access_ptr -> relation_access) = "0"b;
      492 	key_string = REL_ACCESS_HEAD || a_rel_name;
      493 
      494 
      495 	call iox_$seek_key (access_records_iocb_ptr, key_string, access_record_len, code);
      496 	if code = 0
      497 	then call get_relation_access (key_string, access_ptr);
      498 	else
      499 	     if code = error_table_$no_record
      500 	then do;
      501 		if ^have_sought_default_relation_access
      502 		then do;
      503 			have_sought_default_relation_access = "1"b;
      504 			call get_default_relation_access;
      505 		     end;
      506 
      507 		access_ptr -> relation_access = default_relation_access;
      508 	     end;
      509 	else call program_logic_error (code, "Unable to seek key ^a.", key_string, "");
      510 
      511 	return;
      512 
      513      end calc_relation_access;
      514 
      515 calc_attribute_access: proc (a_rel_name, a_attr_name, access_ptr);
      516 
      517 /*
      518*   This routine calculates an attributes access and sets the results
      519*   in the attribute_access structure.
      520*
      521*   Access records are searched for starting with the  most  specific
      522*   (case  1)  and continuing through to the least specific (case 5).
      523*   The cases and the cmdsm statements that generate the  access  are
      524*   listed below.
      525*
      526*   attribute access: a_attr_name in relation a_rel_name  (specs);
      527*   .   Specifically sets the access of attribute a_attr_name for its
      528*   .   occurence in the relation a_rel_name.
      529*
      530*   attribute access: a_attr_name (specs);
      531*   .   Sets the access of attribute a_attr_name for its occurance in
      532*   .   any  relation  except where a_attr_name has an access defined
      533*   .   by the above case.
      534*
      535*   relation access: a_rel_name (specs) with attribute access (specs);
      536*   .   Sets the access for every attribute  in  relation  a_rel_name
      537*   .   except  for those attributes who have had an access specified
      538*   .   by either of the above cases.
      539*
      540*   default attribute access: (specs)
      541*   .   Sets the attribute access of every attribute in the  submodel
      542*   .   expect those attributes who have had an access defined by any
      543*   .   of the above cases.
      544*
      545*   .   If the default attribute access statement does not  exist  in
      546*   .   the cmdsm source than all the attributes not covered by cases
      547*   .   1, 2, or 3 are given an implicit default attribute access.
      548*
      549*   Cases 3, 4, and 5 are done in the get_rel_attr_access routine.
      550**/
      551 
      552 	dcl     a_rel_name		 char (*) varying;	/* name of attribute's relation */
      553 	dcl     a_attr_name		 char (*) varying;	/* (input) name of attribute whose access is being computed */
      554 	dcl     access_ptr		 ptr;		/* (input) pointer to attribute's access structure */
      555 
      556 /* AUTOMATIC */
      557 
      558 	dcl     key_string		 char (256) varying;/* key value of an access record */
      559 
      560 	unspec (access_ptr -> attribute_access) = "0"b;
      561 	key_string = ATTR_ACCESS_HEAD || a_attr_name || ATTR_REL_DELIMITER || a_rel_name;
      562 
      563 	call iox_$seek_key (access_records_iocb_ptr, key_string, access_record_len, code);
      564 	if code = 0
      565 	then call get_attribute_access (key_string, access_ptr);
      566 	else
      567 	     if code ^= error_table_$no_record
      568 	then call program_logic_error (code, "Could not seek for ^a", key_string, "");
      569 	else do;
      570 		key_string = ATTR_ACCESS_HEAD || a_attr_name;
      571 		call iox_$seek_key (access_records_iocb_ptr, key_string, access_record_len, code);
      572 		if code = 0
      573 		then call get_attribute_access (key_string, access_ptr);
      574 		else
      575 		     if code ^= error_table_$no_record
      576 		then call program_logic_error (code, "Could not seek for ^a", key_string, "");
      577 		else do;
      578 			if last_rel_attr_access_sought_for = a_rel_name
      579 			then access_ptr -> attribute_access = rel_attr_access;
      580 			else do;
      581 				last_rel_attr_access_sought_for = a_rel_name;
      582 				call get_rel_attr_access (a_rel_name, a_attr_name);
      583 				access_ptr -> attribute_access = rel_attr_access;
      584 			     end;
      585 		     end;
      586 	     end;
      587 
      588 	return;
      589 
      590      end calc_attribute_access;
      591 
      592 get_rel_attr_access: proc (a_rel_name, a_attr_name);
      593 
      594 /*
      595*   This routine determines the rel_attr_access. Every relation has a
      596*   default  attribute  access which will be the attribute access set
      597*   on attributes without an explicit access specifiction defined  in
      598*   the  cmdsm source. This access is rel_attr_access. It first looks
      599*   for a record explicitly stating  the  attribute  access  for  the
      600*   current  relation, if its found the access is interpreted and the
      601*   value of rel_attr_access set. If  the  error  code  no_record  is
      602*   returned  it  means  that  the  cmdsm  source  did not contain an
      603*   explicit statement seting the attribute access for  the  relation
      604*   (relation    access    statement    using   the   with   option),
      605*   rel_attr_access  is  therefore  set   to   the   value   of   the
      606*   default_attribute_access. If the default attribute access has not
      607*   yet been found it is determined before  rel_attr_access  is  set.
      608*   Any  other  error code indicates an unexpected error so a program
      609*   logic error is reported.
      610**/
      611 
      612 /* PARAMETER */
      613 
      614 	dcl     a_rel_name		 char (*) varying;	/* (input) the relation's name */
      615 	dcl     a_attr_name		 char (*) varying;	/* (input) the attribute's name */
      616 
      617 
      618 
      619 
      620 	call iox_$seek_key (access_records_iocb_ptr, REL_ATTR_ACCESS_HEAD || a_rel_name, access_record_len, code);
      621 	if code = 0
      622 	then call get_attribute_access ((REL_ATTR_ACCESS_HEAD), addr (rel_attr_access));
      623 	else
      624 	     if code = error_table_$no_record
      625 	then do;
      626 		if ^have_sought_default_attribute_access
      627 		then do;
      628 			have_sought_default_attribute_access = "1"b;
      629 			call get_default_attribute_access;
      630 		     end;
      631 
      632 		rel_attr_access = default_attribute_access;
      633 	     end;
      634 	else call program_logic_error (code,
      635 		"Could not determine access for ^a in relation ^a", a_attr_name, a_rel_name);
      636 
      637 	return;
      638 
      639      end get_rel_attr_access;
      640 
      641 get_default_attribute_access: proc;
      642 
      643 /*
      644*   This   routine   determines   the   default   attribute    access
      645*   specifications.  It  first  looks  for a default attribute access
      646*   specification record that was built  in  response  to  a  default
      647*   attribute  access statement in the cmdsm source. If the record is
      648*   found it interprets the contained access as the default attribute
      649*   access. If the error code no_record is returned it means that the
      650*   source did not contain a default attribute  access  statement  so
      651*   the  default  is  set  to  the  system  defined  default which is
      652*   recorded  in  implicit_default_attribute_access.  If  some  other
      653*   error  code  is returned a drastic problem has occured - report a
      654*   program logic error.
      655**/
      656 
      657 	call iox_$seek_key (access_records_iocb_ptr, (DEF_ATTR_ACCESS_HEAD), access_record_len, code);
      658 	if code = 0
      659 	then call get_attribute_access ((DEF_ATTR_ACCESS_HEAD), addr (default_attribute_access));
      660 	else
      661 	     if code = error_table_$no_record
      662 	then default_attribute_access = implicit_default_attribute_access;
      663 	else call program_logic_error (code, "Could not determine the default attribute access", "", "");
      664 
      665 	return;
      666 
      667      end get_default_attribute_access;
      668 
      669 get_default_relation_access: proc;
      670 
      671 /*
      672*   This   routine   determines   the   default    relation    access
      673*   specifications.  It  first  looks  for  a default relation access
      674*   specification record that was built  in  response  to  a  default
      675*   relation  access  statement in the cmdsm source. If the record is
      676*   found it interprets the contained access as the default  relation
      677*   access. If the error code no_record is returned it means that the
      678*   source did not contain a default relation access statement so the
      679*   default is set to the system defined default which is recorded in
      680*   implicit_default_relation_access. If some  other  error  code  is
      681*   returned  a  drastic problem has occured - report a program logic
      682*   error.
      683**/
      684 
      685 	call iox_$seek_key (access_records_iocb_ptr, (DEF_REL_ACCESS_HEAD), access_record_len, code);
      686 	if code = 0
      687 	then call get_relation_access ((DEF_REL_ACCESS_HEAD), addr (default_relation_access));
      688 	else
      689 	     if code = error_table_$no_record
      690 	then default_relation_access = implicit_default_relation_access;
      691 	else call program_logic_error (code, "Could not determine the default attribute access", "", "");
      692 
      693 	return;
      694 
      695      end get_default_relation_access;
      696 
      697 get_relation_access: proc (key_string, access_ptr);
      698 
      699 /*
      700*   This routine reads the current access record which was set up  by
      701*   the  caller. It interprets the record looking for relation access
      702*   modes   (null,   append_tuple,   delete_tuple)   and   sets   the
      703*   corresponding  bits  in  the  relation  access  structure.  If an
      704*   unrecognized access mode is found report a  program  logic  error
      705*   since  only  legal modes should have been written into the access
      706*   record. If a null access  is  specified  along  with  some  other
      707*   access  the  cmdsm source has a semantic error - report the error
      708*   and continue processing. After the record has been processed mark
      709*   it as having been used.
      710**/
      711 
      712 /* PARAMETER */
      713 
      714 	dcl     key_string		 char (256) varying;/* (input) key of the relation access record to be read */
      715 	dcl     access_ptr		 ptr;		/* (input) pointer to relation access storage for this relation */
      716 
      717 /* AUTOMATIC */
      718 
      719 	dcl     mode_idx		 fixed bin;	/* index of the access mode in the access record */
      720 
      721 
      722 
      723 
      724 
      725 	unspec (access_ptr -> relation_access) = "0"b;
      726 
      727 	call iox_$read_record (access_records_iocb_ptr, access_record_ptr,
      728 	     (sys_info$max_seg_size * 4), access_record_len, code);
      729 	if code ^= 0
      730 	then call program_logic_error (code, "Unable to read relation access record for key ^a.", key_string, "");
      731 
      732 	do mode_idx = 1 to access_record.mode_num;
      733 	     if access_record.modes (mode_idx) = "null"
      734 	     then access_ptr -> relation_access.null = "1"b;
      735 	     else
      736 		if access_record.modes (mode_idx) = "append_tuple"
      737 	     then access_ptr -> relation_access.append = "1"b;
      738 	     else
      739 		if access_record.modes (mode_idx) = "delete_tuple"
      740 	     then access_ptr -> relation_access.delete = "1"b;
      741 	     else call program_logic_error (mrds_error_$inconsistent_submodel,
      742 		     "Unrecognized relation access mode ^a", access_record.modes (mode_idx), "");
      743 	end;
      744 
      745 	if access_ptr -> relation_access.null &
      746 	     (access_ptr -> relation_access.append | access_ptr -> relation_access.delete)
      747 	then call report_error (mrds_error_$inconsistent_submodel,
      748 		"^/Null access given with other access modes for ^a", key_string, "");
      749 
      750 	access_record_ptr -> access_record.used = "1"b;
      751 	call iox_$rewrite_record (access_records_iocb_ptr, access_record_ptr, access_record_len, code);
      752 	if code ^= 0
      753 	then call program_logic_error (code, "Unable to mark access record as being used, record key is: ^a",
      754 		key_string, "");
      755 
      756 	return;
      757 
      758      end get_relation_access;
      759 
      760 get_attribute_access: proc (key_string, access_ptr);
      761 
      762 /*
      763*   This routine reads the current access record which was set up  by
      764*   its caller. It interprets the record looking for attribute access
      765*   modes (null, read, update) and sets the corresponding bits in the
      766*   attribute_access  structure.  If  an  unrecognized access mode is
      767*   found report a program logic error since only legal modes  should
      768*   have  been  written  into  the access record. If a null access is
      769*   specified with some other access the cmdsm source has a  semantic
      770*   error - report the  error  and  continue  processing.  After  the
      771*   record  has been processed mark it as having been used.
      772**/
      773 
      774 /* PARAMETER */
      775 
      776 	dcl     key_string		 char (256) varying;/* (input) key of the attribute access record to be read */
      777 	dcl     access_ptr		 ptr;		/* (input) pointer to attribute access storage */
      778 
      779 /* AUTOMATIC */
      780 
      781 	dcl     mode_idx		 fixed bin;	/* index of the access mode in the access record */
      782 
      783 
      784 
      785 
      786 
      787 	unspec (access_ptr -> attribute_access) = "0"b;
      788 
      789 	call iox_$read_record (access_records_iocb_ptr, access_record_ptr,
      790 	     (sys_info$max_seg_size * 4), access_record_len, code);
      791 	if code ^= 0
      792 	then call program_logic_error (code, "Unable to read attribute access record for key ^a.", key_string, "");
      793 
      794 	do mode_idx = 1 to access_record.mode_num;
      795 	     if access_record.modes (mode_idx) = "null"
      796 	     then access_ptr -> attribute_access.null = "1"b;
      797 	     else
      798 		if access_record.modes (mode_idx) = "read"
      799 	     then access_ptr -> attribute_access.read = "1"b;
      800 	     else
      801 		if access_record.modes (mode_idx) = "update"
      802 	     then access_ptr -> attribute_access.modify = "1"b;
      803 	     else call program_logic_error (mrds_error_$inconsistent_submodel,
      804 		     "Unrecognized attribute access mode ^a", access_record.modes (mode_idx), "");
      805 	end;
      806 
      807 	if access_ptr -> attribute_access.null &
      808 	     (access_ptr -> attribute_access.read | access_ptr -> attribute_access.modify)
      809 	then call report_error (mrds_error_$inconsistent_submodel,
      810 		"^/Null access given with other access modes for ^a", key_string, "");
      811 
      812 	access_record_ptr -> access_record.used = "1"b;
      813 	call iox_$rewrite_record (access_records_iocb_ptr, access_record_ptr, access_record_len, code);
      814 	if code ^= 0
      815 	then call program_logic_error (code, "Unable to mark access record as being used, record key is: ^a",
      816 		key_string, "");
      817 
      818 	return;
      819 
      820      end get_attribute_access;
      821 
      822 validate_relation_access: proc;
      823 
      824 /*
      825*   This procedure validates that the relation  access  specified  is
      826*   legal.  A submodel relation must be a full view of its base model
      827*   relation before it  can  have  either  append  or  delete  access
      828*   specified.  It is sufficient to check attribute numbers since the
      829*   model/submodel mapping has been checked by mrds_dsm_semantics  so
      830*   that  the only way the submodel relation can have the same number
      831*   of attributes as the model relation is if each model attribute is
      832*   used  to  define  1  submodel attribute. Also a submodel relation
      833*   must have read access specified on all the key attributes of  the
      834*   model  relation before append access can be specified. This is so
      835*   that  multiple  stores   cannot   be   made   until   the   error
      836*   tuple_not_found is returned - at which time the key values of the
      837*   tuple are known.
      838**/
      839 
      840 
      841 /* AUTOMATIC */
      842 
      843 	dcl     dm_attr		 fixed bin;	/* index of a datamodel attribute */
      844 	dcl     dsm_attr		 fixed bin;	/* index of a submodel attribute */
      845 	dcl     done		 bit (1) unal;	/* used to terminate searching loop */
      846 
      847 	call mrds_dm_get_attributes
      848 	     (p_data_model_ptr,
      849 	     (rel_rec_5_ptr -> rel_rec_5.rel_dm_name),
      850 	     local_area_ptr,
      851 	     rd_ptr,
      852 	     code);
      853 	if code ^= 0				/* the fact that no model relation exists has already been */
      854 	then return;				/* reported in semantics */
      855 
      856 	if (rel_rec_5_ptr -> rel_rec_5.access.append | rel_rec_5_ptr -> rel_rec_5.access.delete) &
      857 	     rel_rec_5_ptr -> rel_rec_5.attr_num ^= rd_ptr -> rel_desc.num_attr
      858 	then call report_error (mrds_error_$inconsistent_submodel,
      859 		"^/^a may not have append and/or delete access specified since its not a full view of ^a",
      860 		relation_name, rel_rec_5_ptr -> rel_rec_5.rel_dm_name);
      861 	else
      862 	     if rel_rec_5_ptr -> rel_rec_5.access.append
      863 	then do;
      864 		do dm_attr = 1 to rd_ptr -> rel_desc.num_attr;
      865 		     if rd_ptr -> rel_desc.attributes (dm_attr).key_flag
      866 		     then do;
      867 			     done = "0"b;
      868 			     do dsm_attr = 1 to rel_rec_5_ptr -> rel_rec_5.attr_num while (^done);
      869 				if rel_rec_5_ptr -> rel_rec_5.attr (dsm_attr).dm_name =
      870 				     rd_ptr -> rel_desc.attributes (dm_attr).attribute_name
      871 				then do;
      872 					if ^rel_rec_5_ptr -> rel_rec_5.attr (dsm_attr).access.read
      873 					then do;
      874 						call report_error (mrds_error_$inconsistent_submodel,
      875 						     "^/Relation ^a does not have read access on" ||
      876 						     " all of the key attributes of its base relation ^a",
      877 						     relation_name,
      878 						     rel_rec_5_ptr -> rel_rec_5.rel_dm_name);
      879 						done = "1"b;
      880 					     end;
      881 					else done = "1"b;
      882 				     end;
      883 			     end;
      884 			end;
      885 		end;
      886 	     end;
      887 
      888 
      889 	return;
      890 
      891      end validate_relation_access;
      892 
      893 verify_access_record_use: proc;
      894 
      895 /*
      896*   This procedure verifies that the access  records  have  all  been
      897*   used.  If  a  record  is  not  used a message is output using the
      898*   record's key as an identifier.
      899*
      900*   A "current" position is first set up by going to the beginning of
      901*   the  file  and then skipping the header record. All records after
      902*   the header record are either access records or relation  records.
      903*   The  key of the current record is read and if does not begin with
      904*   the string "relation:" it is treated as an access  record  -  the
      905*   associated record is read and the used field check. If the record
      906*   is a relation record the "current" position must be advanced  one
      907*   record, read_record does this authomatically.
      908*
      909*   Records are read until a non-zero code  is  returned.  Any  error
      910*   code other than end_of_info indicates that not all of the records
      911*   were read and is a program logic error.
      912**/
      913 
      914 	dcl     local_key_string	 char (256) init (""); /* non-varying version of key_string */
      915 						/* so that substr can be done without worry about the varying length */
      916 
      917 
      918 	call iox_$position (access_records_iocb_ptr, -1, 0, code);
      919 	if code ^= 0
      920 	then call program_logic_error (code, "Unable to position to the first record to begin access verification",
      921 		"", "");
      922 	call iox_$position (access_records_iocb_ptr, 0, 1, code);
      923 	if code ^= 0
      924 	then call program_logic_error (code, "Unable to skip header record to begin access verification", "", "");
      925 
      926 	do while (code = 0);
      927 	     call iox_$read_key (access_records_iocb_ptr, key_string, access_record_len, code);
      928 
      929 /* BEGIN CHANGE 81-09-17 */
      930 
      931 	     local_key_string = key_string;
      932 	     if code = 0 & substr (local_key_string, 1, 9) ^= "relation:" & substr (local_key_string, 1, 15) ^= "model relation:"
      933 
      934 /* END   CHANGE 81-09-17 */
      935 
      936 	     then do;
      937 		     call iox_$read_record (access_records_iocb_ptr, access_record_ptr, (sys_info$max_seg_size * 4),
      938 			access_record_len, code);
      939 		     if code = 0
      940 		     then do;
      941 			     if ^access_record_ptr -> access_record.used
      942 			     then call report_error (mrds_error_$inconsistent_submodel,
      943 				     "^/Access specification: ^a was never used", key_string, "");
      944 			end;
      945 		end;
      946 	     else do;
      947 		     call iox_$position (access_records_iocb_ptr, 0, 1, code);
      948 		     if code ^= 0 & code ^= error_table_$end_of_info
      949 		     then call program_logic_error (code, "Unable to skip a relation record during access verification",
      950 			     "", "");
      951 		end;
      952 	end;
      953 	if code ^= error_table_$end_of_info
      954 	then call program_logic_error (code, "Unable to verify access record usage", "", "");
      955 
      956 	return;
      957 
      958      end verify_access_record_use;
      959 
      960 program_logic_error: proc (icode, message, arg1, arg2);
      961 
      962 /*
      963*   This  routine  calls  report_error  to  report  the  error  after
      964*   concatinating  the  phrase "^/PROGRAM LOGIC ERROR^/" to the input
      965*   message, it then calls cleanup_handler to release  the  temporary
      966*   segments  and  close  the submodel, it then sets the value of the
      967*   return  error  code  and  then   does   a   non-local   goto   to
      968*   exit_compute_access.
      969*
      970*   NOTE this routine does NOT return it does  a  non-local  goto  to
      971*   exit_compute_access.
      972**/
      973 
      974 
      975 /* PARAMETERS */
      976 
      977 	dcl     icode		 fixed bin (35);	/* (input) error code */
      978 	dcl     message		 char (*);	/* (input) error message */
      979 	dcl     arg1		 char (*) varying;	/* (input) first error message argument */
      980 	dcl     arg2		 char (*) varying;	/* (input) second error message argument */
      981 
      982 
      983 
      984 
      985 
      986 	call report_error (icode, "^/PROGRAM LOGIC ERROR^/" || message, arg1, arg2);
      987 
      988 	call cleanup_handler;
      989 
      990 	p_code = icode;
      991 
      992 	goto exit_compute_access;
      993 
      994      end;						/* report_error */
      995 
      996 report_error: proc (icode, message, arg1, arg2);
      997 
      998 /*
      999*   This routine reports errors via the iox_$error_output switch  and
     1000*   the  lsiting_iocb switch (providing it is non-null). It also sets
     1001*   the value of the output error code
     1002**/
     1003 
     1004 
     1005 
     1006 /* PARAMETERS */
     1007 
     1008 	dcl     icode		 fixed bin (35);	/* (input) error code) */
     1009 	dcl     message		 char (*);	/* (input) error message */
     1010 	dcl     arg1		 char (*) varying;	/* (input) first argument to error message */
     1011 	dcl     arg2		 char (*) varying;	/* (input) second argument to error message */
     1012 
     1013 /* AUTOMATIC */
     1014 
     1015 	dcl     long_message	 char (100) aligned;/* long message associated with the error code */
     1016 	dcl     short_message	 char (8) aligned;	/* short message associated with the error code */
     1017 
     1018 /* ENTRIES */
     1019 
     1020 	dcl     convert_status_code_	 entry (fixed bin (35), char (8) aligned, char (100) aligned);
     1021 	dcl     ioa_$ioa_switch	 entry options (variable);
     1022 
     1023 /* EXTERNAL */
     1024 
     1025 	dcl     iox_$error_output	 ptr external static;
     1026 
     1027 
     1028 
     1029 	call convert_status_code_ (icode, short_message, long_message);
     1030 	call ioa_$ioa_switch (iox_$error_output, long_message || message || "^/", arg1, arg2);
     1031 
     1032 	if p_listing_iocb_ptr ^= null ()
     1033 	then call ioa_$ioa_switch (p_listing_iocb_ptr, long_message || message || "^/", arg1, arg2);
     1034 
     1035 
     1036 	p_code = icode;
     1037 
     1038 	return;
     1039 
     1040      end report_error;
     1041 
     1042 cleanup_handler: proc;
     1043 
     1044 /*
     1045*   This procedure releases the two temporary segments and closes the
     1046*   two openings of the submodel - after checking to be sure that the
     1047*   temporary segments have been set up and the submodel opened  (pts
     1048*   ^= null).
     1049*
     1050*   The error code returned by release_temp_segments_  is  ignored  -
     1051*   there  is  nothing  that  can be done anyway, and the submodel is
     1052*   closed using an entry that does not return an error code.
     1053**/
     1054 
     1055 
     1056 
     1057 
     1058 
     1059 	if temp_seg_ptrs (1) ^= null
     1060 	then call release_temp_segments_ (p_caller_name, temp_seg_ptrs, code);
     1061 
     1062 	if access_records_iocb_ptr ^= null
     1063 	then call mrds_dsm_close$force (access_records_iocb_ptr);
     1064 
     1065 	if relation_records_iocb_ptr ^= null
     1066 	then call mrds_dsm_close$force (relation_records_iocb_ptr);
     1067 
     1068 
     1069      end cleanup_handler;
     1070 
  1     1 /* BEGIN INCLUDE FILE  -  mrds_dsm_access_record.incl.pl1
  1     2*
  1     3*79-11-28 Spratt: written
  1     4*
  1     5*81-04-28 Davids: added the element used.
  1     6**/
  1     7 
  1     8      dcl	   access_record_ptr      ptr;
  1     9      dcl	   access_record_mode_num fixed bin;
  1    10 
  1    11      dcl	   1 access_record	      based (access_record_ptr),
  1    12 	     2 used               bit (1),
  1    13 	     2 mode_num	      fixed bin,
  1    14 	     2 modes	      (access_record_mode_num refer (access_record.mode_num)) char (32) varying;
  1    15 
  1    16 /* END INCLUDE FILE  - mrds_dsm_access_record.incl.pl1 */
     1071 
     1072 
  2     1 /* BEGIN INCLUDE FILE  -  mrds_dsm_head_strings.incl.pl1 */
  2     2 
  2     3 /*
  2     4*   All of the key heads used in the mrds submodel vfile declared  as
  2     5*   constants in this file.
  2     6*
  2     7*   Written  11/30/79  by  Lindsey L. Spratt
  2     8*
  2     9*   80-12-23 Davids: modified so that  strings  lengths  are  128  to
  2    10*   accomodate longer relation and attribute names.
  2    11*
  2    12*   81-05-20 Davids: added MODEL_REL_HEAD.
  2    13**/
  2    14 
  2    15 dcl  REL_ACCESS_HEAD char (128) varying internal static options (constant) init ("relation access:");
  2    16 dcl  REL_ATTR_ACCESS_HEAD char (128) varying internal static options (constant) init ("relation attribute access:");
  2    17 dcl  ATTR_ACCESS_HEAD char (128) varying internal static options (constant) init ("attribute access:");
  2    18 dcl  DEF_REL_ACCESS_HEAD char (128) varying internal static options (constant) init ("default relation access:");
  2    19 dcl  DEF_ATTR_ACCESS_HEAD char (128) varying internal static options (constant) init ("default attribute access:");
  2    20 dcl  REL_HEAD char (128) varying internal static options (constant) init ("relation:");
  2    21 dcl  ATTR_REL_DELIMITER char (128) varying internal static options (constant) init (":in:");
  2    22 dcl  MODEL_REL_HEAD char (128) varying internal static options (constant) init ("model relation:");
  2    23 
  2    24 /* END INCLUDE FILE  -  mrds_dsm_head_strings.incl.pl1 */
     1073 
     1074 
  3     1 /* BEGIN INCLUDE FILE - mrds_dsm_rel_rec_5.incl.pl1 */
  3     2 
  3     3 /*
  3     4*   This is the format of the relation record in version 5 submodels
  3     5*
  3     6*   HISTORY
  3     7*
  3     8*   80-12-23 Davids: written
  3     9*
  3    10*   81-04-29 Davids: changed the access elements from a bit string to
  3    11*   a  named set of bits and added the two structures relation_access
  3    12*   and attribute_access.
  3    13**/
  3    14 
  3    15 
  3    16 dcl 01 rel_rec_5 based,
  3    17     02 attr_num fixed bin,
  3    18     02 rel_dm_name char (256) varying,
  3    19     02 access like relation_access,
  3    20     02 attr (rel_rec_5_attr_num refer (rel_rec_5.attr_num)),
  3    21       03 dsm_name char (256) varying,
  3    22       03 dm_name char (256) varying,
  3    23       03 access like attribute_access;
  3    24 
  3    25 dcl  rel_rec_5_attr_num fixed bin;
  3    26 
  3    27 
  3    28 dcl 01 relation_access based,
  3    29     02 null bit (1) unal,
  3    30     02 append bit (1) unal,
  3    31     02 delete bit (1) unal,
  3    32     02 mbz1 bit (33) unal;
  3    33 
  3    34 
  3    35 dcl 01 attribute_access based,
  3    36     02 null bit (1) unal,
  3    37     02 read bit (1) unal,
  3    38     02 modify bit (1) unal,
  3    39     02 mbz1 bit (33) unal;
  3    40 
  3    41 /* END INCLUDE FILE - mrds_dsm_rel_rec_5.incl.pl1 */
     1075 
     1076 
  4     1 /*	BEGIN INCLUDE FILE		mrds_rel_desc.incl.pl1	rgl, 03/31/76		*/
  4     2 
  4     3 /* 76-09-20 R. Lackey : modified to handle inverted attributes	
  4     4*
  4     5*   76-11-16 J. A. Weeldreyer : modified to add domain name 
  4     6*
  4     7*   82-08-19 D. Woodka : deleted rel_desc.attributes.bit_offset field
  4     8*   for the DMS conversion
  4     9*
  4    10**/
  4    11 
  4    12 dcl 1 rel_desc based (rd_ptr),			/* record description of relation records */
  4    13     2 num_attr fixed bin,				/* number of attributes in the model */
  4    14     2 key_length fixed bin (35),			/* length in bits of data portion of tuple */
  4    15     2 data_length fixed bin (35),			/* length in bits of data portion of tuple */
  4    16     2 num_keys fixed bin,				/* number of key attributes */
  4    17     2 inversion bit (1) unal,				/* On if this relation contains any inverted  attributes */
  4    18     2 reserved bit (35) unal,				/* Reserved for future use */
  4    19     2 attributes (num_attr_alloc refer (rel_desc.num_attr)),
  4    20       3 attribute_name char (32),			/* name of attribute  */
  4    21       3 domain_name char (32),			/* name of underlying domain */
  4    22       3 bit_length bit (18) unaligned,			/* length of data item in bits */
  4    23       3 key_flag bit (1) unaligned,			/* indicates whether attribute is part of primary key */
  4    24       3 inver_flag bit (1) unaligned,			/* On if this attribute is inverted */
  4    25       3 unused bit (34) unaligned,			/* reserved for expansion */
  4    26       3 key_attr_order fixed bin,			/* order num of this key attr */
  4    27       3 descriptor bit (36);				/* Multics descriptor for attribute */
  4    28 
  4    29 dcl  num_attr_alloc fixed bin (10);			/* Number of attributes in relation for allocation purposes */
  4    30 
  4    31 dcl  rd_ptr ptr;
  4    32 
  4    33 /*	END INCLUDE FILE		mrds_rel_desc.incl.pl1				*/
  4    34 
     1077 
     1078 
  5     1 /* Include file for vfile_ control orders dealing with key ranges in indexed files */
  5     2 /* created by M. Asherman 4/7/77
  5     3*Modified:
  5     4*12/18/80  by  Lindsey Spratt: Add the delete_old_subsets bit.
  5     5**/
  5     6 
  5     7 /* format: style2 */
  5     8      dcl	   1 common_sl_info	      based (info_ptr),	/* info structure for select and exclude orders */
  5     9 	     2 flags	      aligned,		/* Input */
  5    10 	       3 list_type	      fixed (3) unal,	/* code identifies format of tail structure */
  5    11 	       3 status_only      bit (1) unal,		/* if set, subset info is returned, but current subset stays the same */
  5    12 	       3 output_descriptors
  5    13 			      bit (1) unal,		/* if set, resulting descriptor list is returned */
  5    14 	       3 delete_old_subsets
  5    15 			      bit (1) unal,		/* if set, causes all of the existing subsets on this switch to be deleted. */
  5    16 	       3 mbz	      bit (11) unal,	/* must be zero--in case of extensions */
  5    17 	       3 version	      fixed (17) unal,	/* current info version */
  5    18 	     2 array_limit	      fixed,		/* upper bound of array in tail of info structure */
  5    19 	     2 subset_no	      fixed,		/* identifies temporary subset-- Output */
  5    20 	     2 count	      fixed (34),		/* Output--number of distinct descrips */
  5    21 	     2 desc_arrayp	      ptr;		/* pointer to resulting array of descriptors */
  5    22 
  5    23 /* descriptor array generated if requested */
  5    24      dcl	   desc_array	      (1:common_sl_info.count) based (common_sl_info.desc_arrayp);
  5    25 
  5    26 /* this format allows specification in terms of index intervals defined by two heads or one key */
  5    27      dcl	   1 hi_sl_info	      based (info_ptr),	/* structure for list_type = 1 */
  5    28 	     2 common	      like common_sl_info,
  5    29 	     2 interval	      (1:sl_array_limit refer (hi_sl_info.array_limit)),
  5    30 	       3 first_head,
  5    31 	         4 length	      fixed,
  5    32 	         4 kptr	      ptr unal,
  5    33 	       3 last_head,
  5    34 	         4 length	      fixed,		/* if negative, this interval is defined by match with key */
  5    35 	         4 kptr	      ptr unal;
  5    36 
  5    37 /* format for specification in terms of an array of descriptors */
  5    38      dcl	   1 da_sl_info	      based (info_ptr),	/* list_type=2 */
  5    39 	     2 common	      like common_sl_info,
  5    40 	     2 desc_array	      (1:sl_array_limit refer (da_sl_info.array_limit)) fixed (35);
  5    41 
  5    42      dcl	   sl_array_limit	      fixed;
  5    43      dcl	   sl_info_version_0      static options (constant) internal fixed init (0);
  5    44 
  5    45 /* list_type=0 denotes reselection of a single, previously defined subset (no tail structure) */
     1079 
     1080 
     1081 
     1082      end;						/* End of compute_dsm_access. */
     1083 
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/05/00  1830.3  mrds_dsm_compute_access.pl1       >udd>sm>ds>w>ml>mrds_dsm_compute_access.pl1
1071         1    10/14/83  1708.8  mrds_dsm_access_record.incl.pl1   >ldd>incl>mrds_dsm_access_record.incl.pl1
1073         2    10/14/83  1708.9  mrds_dsm_head_strings.incl.pl1    >ldd>incl>mrds_dsm_head_strings.incl.pl1
1075         3    10/14/83  1708.9  mrds_dsm_rel_rec_5.incl.pl1       >ldd>incl>mrds_dsm_rel_rec_5.incl.pl1
1077         4    10/14/83  1709.0  mrds_rel_desc.incl.pl1            >ldd>incl>mrds_rel_desc.incl.pl1
1079         5    07/31/81  1918.2  select_info.incl.pl1              >ldd>incl>select_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ATTR_ACCESS_HEAD                000204 constant        varying char(128)        initial dcl 2-17 ref 561 570
ATTR_REL_DELIMITER              000000 constant        varying char(128)        initial dcl 2-21 ref 561
DEF_ATTR_ACCESS_HEAD            000102 constant        varying char(128)        initial dcl 2-19 ref 657 658
DEF_REL_ACCESS_HEAD             000143 constant        varying char(128)        initial dcl 2-18 ref 685 686
REL_ACCESS_HEAD                 000306 constant        varying char(128)        initial dcl 2-15 ref 492
REL_ATTR_ACCESS_HEAD            000245 constant        varying char(128)        initial dcl 2-16 ref 620 621
REL_HEAD                        000041 constant        varying char(128)        initial dcl 2-20 set ref 368 370 371 420
a_attr_name                            parameter       varying char             dcl 553 in procedure "calc_attribute_access" set ref
                                                                                  515 561 570 582*
a_attr_name                            parameter       varying char             dcl 615 in procedure "get_rel_attr_access" set ref
                                                                                  592 634*
a_rel_name                             parameter       varying char             dcl 483 in procedure "calc_relation_access" ref 454
                                                                                  492
a_rel_name                             parameter       varying char             dcl 614 in procedure "get_rel_attr_access" set ref
                                                                                  592 620 634*
a_rel_name                             parameter       varying char             dcl 552 in procedure "calc_attribute_access" set ref
                                                                                  515 561 578 581 582*
access                  305            based           structure                array level 3 in structure "rel_rec_5" packed packed
                                                                                  unaligned dcl 3-16 in procedure
                                                                                  "mrds_dsm_compute_access" set ref 425 425
access                  102            based           structure                level 2 in structure "rel_rec_5" packed packed
                                                                                  unaligned dcl 3-16 in procedure
                                                                                  "mrds_dsm_compute_access" set ref 421 421
access_ptr                             parameter       pointer                  dcl 554 in procedure "calc_attribute_access" set ref
                                                                                  515 560 564* 572* 578 583
access_ptr                             parameter       pointer                  dcl 484 in procedure "calc_relation_access" set ref
                                                                                  454 491 496* 507
access_ptr                             parameter       pointer                  dcl 777 in procedure "get_attribute_access" ref 760
                                                                                  787 795 797 800 807 807 807
access_ptr                             parameter       pointer                  dcl 715 in procedure "get_relation_access" ref 697
                                                                                  725 733 735 738 745 745 745
access_record                          based           structure                level 1 unaligned dcl 1-11
access_record_len               000100 automatic       fixed bin(21,0)          dcl 172 set ref 495* 563* 571* 620* 657* 685* 727*
                                                                                  751* 789* 813* 927* 937*
access_record_ptr               000302 automatic       pointer                  dcl 1-8 set ref 251* 344* 727* 732 733 735 738 741
                                                                                  750 751* 789* 794 795 797 800 803 812 813* 937*
                                                                                  941
access_records_iocb_ptr         000102 automatic       pointer                  initial dcl 173 set ref 173* 315* 495* 563* 571*
                                                                                  620* 657* 685* 727* 751* 789* 813* 918* 922* 927*
                                                                                  937* 947* 1062 1062*
addr                                                   builtin function         dcl 211 ref 368 421 421 425 425 621 621 658 658 686
                                                                                  686
addrel                                                 builtin function         dcl 212 ref 369 372
append                    0(01) 000271 automatic       bit(1)                   level 2 in structure
                                                                                  "implicit_default_relation_access" packed packed
                                                                                  unaligned dcl 200 in procedure
                                                                                  "mrds_dsm_compute_access" set ref 264*
append                    0(01) 000267 automatic       bit(1)                   level 2 in structure "default_relation_access"
                                                                                  packed packed unaligned dcl 197 in procedure
                                                                                  "mrds_dsm_compute_access" set ref 254*
append                    0(01)        based           bit(1)                   level 2 in structure "relation_access" packed packed
                                                                                  unaligned dcl 3-28 in procedure
                                                                                  "mrds_dsm_compute_access" set ref 735* 745
append                  102(01)        based           bit(1)                   level 3 in structure "rel_rec_5" packed packed
                                                                                  unaligned dcl 3-16 in procedure
                                                                                  "mrds_dsm_compute_access" set ref 856 861
arg1                                   parameter       varying char             dcl 979 in procedure "program_logic_error" set ref
                                                                                  960 986*
arg1                                   parameter       varying char             dcl 1010 in procedure "report_error" set ref 996
                                                                                  1030* 1032*
arg2                                   parameter       varying char             dcl 980 in procedure "program_logic_error" set ref
                                                                                  960 986*
arg2                                   parameter       varying char             dcl 1011 in procedure "report_error" set ref 996
                                                                                  1030* 1032*
array_limit               1            based           fixed bin(17,0)          level 3 dcl 5-27 set ref 366* 369 370 371 372
attr                    103            based           structure                array level 2 unaligned dcl 3-16
attr_idx                        000104 automatic       fixed bin(17,0)          dcl 175 set ref 424* 425 425 425*
attr_num                               based           fixed bin(17,0)          level 2 dcl 3-16 ref 424 856 868
attribute_access                       based           structure                level 1 packed packed unaligned dcl 3-35 set ref
                                                                                  560* 578* 583* 787*
attribute_name            5            based           char(32)                 array level 3 packed packed unaligned dcl 4-12 ref
                                                                                  869
attributes                5            based           structure                array level 2 unaligned dcl 4-12
cleanup                         000274 stack reference condition                dcl 221 ref 281
code                            000105 automatic       fixed bin(35,0)          dcl 176 set ref 305* 306 308* 315* 316 318* 335* 336
                                                                                  338* 376* 377 377* 386* 387 387* 397* 398 398* 412
                                                                                  413* 415 415* 433* 434 434* 439* 440 440 440* 495*
                                                                                  496 498 509* 563* 564 566 566* 571* 572 574 574*
                                                                                  620* 621 623 634* 657* 658 660 663* 685* 686 688
                                                                                  691* 727* 729 729* 751* 752 752* 789* 791 791*
                                                                                  813* 814 814* 847* 853 918* 919 919* 922* 923 923*
                                                                                  926 927* 932 937* 939 947* 948 948 948* 953 953*
                                                                                  1059*
common                                 based           structure                level 2 unaligned dcl 5-27
common_sl_info                         based           structure                level 1 unaligned dcl 5-8
convert_status_code_            000046 constant        entry                    external dcl 1020 ref 1029
default_attribute_access        000266 automatic       structure                level 1 packed packed unaligned dcl 196 set ref 632
                                                                                  658 658 660*
default_relation_access         000267 automatic       structure                level 1 packed packed unaligned dcl 197 set ref 507
                                                                                  686 686 688*
delete                    0(02) 000267 automatic       bit(1)                   level 2 in structure "default_relation_access"
                                                                                  packed packed unaligned dcl 197 in procedure
                                                                                  "mrds_dsm_compute_access" set ref 255*
delete                  102(02)        based           bit(1)                   level 3 in structure "rel_rec_5" packed packed
                                                                                  unaligned dcl 3-16 in procedure
                                                                                  "mrds_dsm_compute_access" set ref 856
delete                    0(02)        based           bit(1)                   level 2 in structure "relation_access" packed packed
                                                                                  unaligned dcl 3-28 in procedure
                                                                                  "mrds_dsm_compute_access" set ref 738* 745
delete                    0(02) 000271 automatic       bit(1)                   level 2 in structure
                                                                                  "implicit_default_relation_access" packed packed
                                                                                  unaligned dcl 200 in procedure
                                                                                  "mrds_dsm_compute_access" set ref 265*
dm_attr                         000602 automatic       fixed bin(17,0)          dcl 843 set ref 864* 865 869*
dm_name                 204            based           varying char(256)        array level 3 dcl 3-16 ref 869
done                            000604 automatic       bit(1)                   packed unaligned dcl 845 set ref 867* 868 879* 881*
dsm_attr                        000603 automatic       fixed bin(17,0)          dcl 844 set ref 868* 869 872*
dsm_name                103            based           varying char(256)        array level 3 dcl 3-16 set ref 425*
empty                                                  builtin function         dcl 213 ref 347
error_table_$end_of_info        000036 external static fixed bin(35,0)          dcl 239 ref 440 948 953
error_table_$no_record          000040 external static fixed bin(35,0)          dcl 240 ref 498 566 574 623 660 688
first_head                6            based           structure                array level 3 unaligned dcl 5-27
flags                                  based           structure                level 3 dcl 5-27
get_temp_segments_              000010 constant        entry                    external dcl 225 ref 335
have_sought_default_attribute_access
                                000106 automatic       bit(1)                   initial packed unaligned dcl 177 set ref 177* 626
                                                                                  628*
have_sought_default_relation_access
                                000107 automatic       bit(1)                   initial packed unaligned dcl 179 set ref 179* 501
                                                                                  503*
hi_sl_info                             based           structure                level 1 unaligned dcl 5-27 set ref 366
icode                                  parameter       fixed bin(35,0)          dcl 1008 in procedure "report_error" set ref 996
                                                                                  1029* 1036
icode                                  parameter       fixed bin(35,0)          dcl 977 in procedure "program_logic_error" set ref
                                                                                  960 986* 990
implicit_default_attribute_access
                                000270 automatic       structure                level 1 packed packed unaligned dcl 198 set ref 660
implicit_default_relation_access
                                000271 automatic       structure                level 1 packed packed unaligned dcl 200 set ref 688
info_ptr                        000110 automatic       pointer                  initial dcl 181 set ref 181* 366* 367 369 370 371
                                                                                  372 373 374 375 376*
interval                  6            based           structure                array level 2 unaligned dcl 5-27
ioa_$ioa_switch                 000050 constant        entry                    external dcl 1021 ref 1030 1032
iox_$control                    000012 constant        entry                    external dcl 226 ref 376
iox_$error_output               000052 external static pointer                  dcl 1025 set ref 1030*
iox_$position                   000014 constant        entry                    external dcl 227 ref 386 918 922 947
iox_$read_key                   000016 constant        entry                    external dcl 228 ref 397 439 927
iox_$read_record                000020 constant        entry                    external dcl 229 ref 413 727 789 937
iox_$rewrite_record             000022 constant        entry                    external dcl 230 ref 433 751 813
iox_$seek_key                   000024 constant        entry                    external dcl 231 ref 495 563 571 620 657 685
key_flag                 25(18)        based           bit(1)                   array level 3 packed packed unaligned dcl 4-12 ref
                                                                                  865
key_string                      000112 automatic       varying char(256)        dcl 183 in procedure "mrds_dsm_compute_access" set
                                                                                  ref 397* 415* 420 439* 927* 931 941*
key_string                             parameter       varying char(256)        dcl 776 in procedure "get_attribute_access" set ref
                                                                                  760 791* 807* 814*
key_string                      000430 automatic       varying char(256)        dcl 558 in procedure "calc_attribute_access" set ref
                                                                                  561* 563* 564* 566* 570* 571* 572* 574*
key_string                      000320 automatic       varying char(256)        dcl 488 in procedure "calc_relation_access" set ref
                                                                                  492* 495* 496* 509*
key_string                             parameter       varying char(256)        dcl 714 in procedure "get_relation_access" set ref
                                                                                  697 729* 745* 752*
kptr                     11            based           pointer                  array level 4 in structure "hi_sl_info" packed
                                                                                  packed unaligned dcl 5-27 in procedure
                                                                                  "mrds_dsm_compute_access" set ref 372*
kptr                      7            based           pointer                  array level 4 in structure "hi_sl_info" packed
                                                                                  packed unaligned dcl 5-27 in procedure
                                                                                  "mrds_dsm_compute_access" set ref 369*
last_head                10            based           structure                array level 3 unaligned dcl 5-27
last_rel_attr_access_sought_for 000213 automatic       varying char(32)         dcl 184 set ref 578 581*
length                    6            based           fixed bin(17,0)          array level 4 in structure "hi_sl_info" dcl 5-27
                                                                                  in procedure "mrds_dsm_compute_access" set ref
                                                                                  370*
length                                                 builtin function         dcl 214 in procedure "mrds_dsm_compute_access" ref
                                                                                  370 371 420
length                   10            based           fixed bin(17,0)          array level 4 in structure "hi_sl_info" dcl 5-27
                                                                                  in procedure "mrds_dsm_compute_access" set ref
                                                                                  371*
list_type                              based           fixed bin(3,0)           level 4 packed packed unaligned dcl 5-27 set ref
                                                                                  373*
local_area                             based           area                     dcl 206 set ref 347* 366
local_area_ptr                  000224 automatic       pointer                  dcl 186 set ref 346* 347 366 847*
local_key_string                000616 automatic       char(256)                initial packed unaligned dcl 914 set ref 914* 931*
                                                                                  932 932
long_message                    000100 automatic       char(100)                dcl 1015 set ref 1029* 1030 1032
mbz1                      0(03) 000267 automatic       bit(33)                  level 2 in structure "default_relation_access"
                                                                                  packed packed unaligned dcl 197 in procedure
                                                                                  "mrds_dsm_compute_access" set ref 256*
mbz1                      0(03) 000271 automatic       bit(33)                  level 2 in structure
                                                                                  "implicit_default_relation_access" packed packed
                                                                                  unaligned dcl 200 in procedure
                                                                                  "mrds_dsm_compute_access" set ref 266*
mbz1                      0(03) 000266 automatic       bit(33)                  level 2 in structure "default_attribute_access"
                                                                                  packed packed unaligned dcl 196 in procedure
                                                                                  "mrds_dsm_compute_access" set ref 261*
mbz1                      0(03) 000270 automatic       bit(33)                  level 2 in structure
                                                                                  "implicit_default_attribute_access" packed packed
                                                                                  unaligned dcl 198 in procedure
                                                                                  "mrds_dsm_compute_access" set ref 271*
message                                parameter       char                     packed unaligned dcl 978 in procedure
                                                                                  "program_logic_error" ref 960 986
message                                parameter       char                     packed unaligned dcl 1009 in procedure
                                                                                  "report_error" ref 996 1030 1032
mode_idx                        000562 automatic       fixed bin(17,0)          dcl 719 in procedure "get_relation_access" set ref
                                                                                  732* 733 735 738 741*
mode_idx                        000572 automatic       fixed bin(17,0)          dcl 781 in procedure "get_attribute_access" set ref
                                                                                  794* 795 797 800 803*
mode_num                  1            based           fixed bin(17,0)          level 2 dcl 1-11 ref 732 794
modes                     2            based           varying char(32)         array level 2 dcl 1-11 set ref 733 735 738 741* 795
                                                                                  797 800 803*
modify                    0(02)        based           bit(1)                   level 2 in structure "attribute_access" packed
                                                                                  packed unaligned dcl 3-35 in procedure
                                                                                  "mrds_dsm_compute_access" set ref 800* 807
modify                    0(02) 000270 automatic       bit(1)                   level 2 in structure
                                                                                  "implicit_default_attribute_access" packed packed
                                                                                  unaligned dcl 198 in procedure
                                                                                  "mrds_dsm_compute_access" set ref 270*
modify                    0(02) 000266 automatic       bit(1)                   level 2 in structure "default_attribute_access"
                                                                                  packed packed unaligned dcl 196 in procedure
                                                                                  "mrds_dsm_compute_access" set ref 260*
mrds_dm_get_attributes          000026 constant        entry                    external dcl 232 ref 847
mrds_dsm_close$force            000030 constant        entry                    external dcl 233 ref 1062 1065
mrds_dsm_open$update_share      000032 constant        entry                    external dcl 234 ref 305 315
mrds_error_$inconsistent_submodel
                                000042 external static fixed bin(35,0)          dcl 241 set ref 741* 745* 803* 807* 856* 874* 941*
null                            000270 automatic       bit(1)                   level 2 in structure
                                                                                  "implicit_default_attribute_access" packed packed
                                                                                  unaligned dcl 198 in procedure
                                                                                  "mrds_dsm_compute_access" set ref 268*
null                            000267 automatic       bit(1)                   level 2 in structure "default_relation_access"
                                                                                  packed packed unaligned dcl 197 in procedure
                                                                                  "mrds_dsm_compute_access" set ref 253*
null                                   based           bit(1)                   level 2 in structure "attribute_access" packed
                                                                                  packed unaligned dcl 3-35 in procedure
                                                                                  "mrds_dsm_compute_access" set ref 795* 807
null                                   based           bit(1)                   level 2 in structure "relation_access" packed packed
                                                                                  unaligned dcl 3-28 in procedure
                                                                                  "mrds_dsm_compute_access" set ref 733* 745
null                            000271 automatic       bit(1)                   level 2 in structure
                                                                                  "implicit_default_relation_access" packed packed
                                                                                  unaligned dcl 200 in procedure
                                                                                  "mrds_dsm_compute_access" set ref 263*
null                            000266 automatic       bit(1)                   level 2 in structure "default_attribute_access"
                                                                                  packed packed unaligned dcl 196 in procedure
                                                                                  "mrds_dsm_compute_access" set ref 258*
null                                                   builtin function         dcl 215 in procedure "mrds_dsm_compute_access" ref
                                                                                  173 181 188 191 193 193 193 251 1032 1059 1062
                                                                                  1065
num_attr                               based           fixed bin(17,0)          level 2 dcl 4-12 ref 856 864
output_descriptors        0(05)        based           bit(1)                   level 4 packed packed unaligned dcl 5-27 set ref
                                                                                  375*
p_caller_name                          parameter       char                     packed unaligned dcl 161 set ref 9 335* 1059*
p_code                                 parameter       fixed bin(35,0)          dcl 168 set ref 9 291* 990* 1036*
p_data_model_ptr                       parameter       pointer                  dcl 166 set ref 9 847*
p_listing_iocb_ptr                     parameter       pointer                  dcl 164 set ref 9 1032 1032*
p_submodel_path                        parameter       char                     packed unaligned dcl 163 set ref 9 305* 315*
rd_ptr                          000304 automatic       pointer                  dcl 4-31 set ref 847* 856 864 865 869
read                      0(01) 000270 automatic       bit(1)                   level 2 in structure
                                                                                  "implicit_default_attribute_access" packed packed
                                                                                  unaligned dcl 198 in procedure
                                                                                  "mrds_dsm_compute_access" set ref 269*
read                      0(01)        based           bit(1)                   level 2 in structure "attribute_access" packed
                                                                                  packed unaligned dcl 3-35 in procedure
                                                                                  "mrds_dsm_compute_access" set ref 797* 807
read                    305(01)        based           bit(1)                   array level 4 in structure "rel_rec_5" packed packed
                                                                                  unaligned dcl 3-16 in procedure
                                                                                  "mrds_dsm_compute_access" set ref 872
read                      0(01) 000266 automatic       bit(1)                   level 2 in structure "default_attribute_access"
                                                                                  packed packed unaligned dcl 196 in procedure
                                                                                  "mrds_dsm_compute_access" set ref 259*
rel_attr_access                 000272 automatic       structure                level 1 packed packed unaligned dcl 202 set ref 578
                                                                                  583 621 621 632*
rel_desc                               based           structure                level 1 unaligned dcl 4-12
rel_dm_name               1            based           varying char(256)        level 2 dcl 3-16 set ref 847 856* 874*
rel_rec_5                              based           structure                level 1 unaligned dcl 3-16
rel_rec_5_len                   000226 automatic       fixed bin(21,0)          dcl 187 set ref 397* 413* 433* 439*
rel_rec_5_ptr                   000230 automatic       pointer                  initial dcl 188 set ref 188* 345* 413* 421 421 424
                                                                                  425 425 425 433* 847 856 856 856 856 861 868 869
                                                                                  872 874
relation_access                        based           structure                level 1 packed packed unaligned dcl 3-28 set ref
                                                                                  491* 507* 725*
relation_name                   000232 automatic       varying char(64)         dcl 190 set ref 420* 421* 425* 434* 856* 874*
relation_records_iocb_ptr       000254 automatic       pointer                  initial dcl 191 set ref 191* 305* 376* 386* 397*
                                                                                  413* 433* 439* 1065 1065*
release_temp_segments_          000034 constant        entry                    external dcl 235 ref 1059
short_message                   000132 automatic       char(8)                  dcl 1016 set ref 1029*
sl_array_limit                  000306 automatic       fixed bin(17,0)          dcl 5-42 set ref 365* 366 366
sl_info_version_0                      constant        fixed bin(17,0)          initial dcl 5-43 ref 367
status_only               0(04)        based           bit(1)                   level 4 packed packed unaligned dcl 5-27 set ref
                                                                                  374*
substr                                                 builtin function         dcl 216 ref 420 932 932
sys_info$max_seg_size           000044 external static fixed bin(24,0)          dcl 242 ref 347 413 727 789 937
temp_ptr                        000256 automatic       pointer                  dcl 192 set ref 368* 369 372
temp_seg_ptrs                   000260 automatic       pointer                  initial array dcl 193 set ref 193* 193* 193* 335*
                                                                                  344 345 346 1059 1059*
unspec                                                 builtin function         dcl 217 set ref 491* 560* 725* 787*
used                                   based           bit(1)                   level 2 packed packed unaligned dcl 1-11 set ref
                                                                                  750* 812* 941
version                   0(18)        based           fixed bin(17,0)          level 4 packed packed unaligned dcl 5-27 set ref
                                                                                  367*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
MODEL_REL_HEAD                         internal static varying char(128)        initial dcl 2-22
access_record_mode_num                 automatic       fixed bin(17,0)          dcl 1-9
da_sl_info                             based           structure                level 1 unaligned dcl 5-38
desc_array                             based           fixed bin(17,0)          array dcl 5-24
num_attr_alloc                         automatic       fixed bin(10,0)          dcl 4-29
rel_rec_5_attr_num                     automatic       fixed bin(17,0)          dcl 3-25

NAMES DECLARED BY EXPLICIT CONTEXT.
calc_attribute_access           002347 constant        entry                    internal dcl 515 ref 425
calc_relation_access            002223 constant        entry                    internal dcl 454 ref 421
cleanup_handler                 005030 constant        entry                    internal dcl 1042 ref 281 309 319 339 449 988
exit_compute_access             002222 constant        label                    dcl 451 ref 310 320 340 992
get_attribute_access            003477 constant        entry                    internal dcl 760 ref 564 572 621 658
get_default_attribute_access    003014 constant        entry                    internal dcl 641 ref 629
get_default_relation_access     003072 constant        entry                    internal dcl 669 ref 504
get_rel_attr_access             002653 constant        entry                    internal dcl 592 ref 582
get_relation_access             003150 constant        entry                    internal dcl 697 ref 496 686
mrds_dsm_compute_access         001153 constant        entry                    external dcl 9
program_logic_error             004521 constant        entry                    internal dcl 960 ref 377 387 398 415 434 440 509 566
                                                                                  574 634 663 691 729 741 752 791 803 814 919 923
                                                                                  948 953
report_error                    004623 constant        entry                    internal dcl 996 ref 308 318 338 745 807 856 874 941
                                                                                  986
validate_relation_access        004025 constant        entry                    internal dcl 822 ref 430
verify_access_record_use        004241 constant        entry                    internal dcl 893 ref 445

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6052        6126    5554        6062
Length      6506    5554        54         343     275           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_dsm_compute_access            1110 external procedure  is an external procedure.  
on unit on line 281                  64 on unit               
calc_relation_access                    internal procedure  shares stack frame of external procedure mrds_dsm_compute_access.  
calc_attribute_access                   internal procedure  shares stack frame of external procedure mrds_dsm_compute_access.  
get_rel_attr_access                     internal procedure  shares stack frame of external procedure mrds_dsm_compute_access.  
get_default_attribute_access            internal procedure  shares stack frame of external procedure mrds_dsm_compute_access.  
get_default_relation_access             internal procedure  shares stack frame of external procedure mrds_dsm_compute_access.  
get_relation_access                     internal procedure  shares stack frame of external procedure mrds_dsm_compute_access.  
get_attribute_access                    internal procedure  shares stack frame of external procedure mrds_dsm_compute_access.  
validate_relation_access                internal procedure  shares stack frame of external procedure mrds_dsm_compute_access.  
verify_access_record_use                internal procedure  shares stack frame of external procedure mrds_dsm_compute_access.  
program_logic_error                     internal procedure  shares stack frame of external procedure mrds_dsm_compute_access.  
report_error                        126 internal procedure  is called during a stack extension.  
cleanup_handler                      78 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mrds_dsm_compute_access  000100 access_record_len           mrds_dsm_compute_access
                         000102 access_records_iocb_ptr     mrds_dsm_compute_access
                         000104 attr_idx                    mrds_dsm_compute_access
                         000105 code                        mrds_dsm_compute_access
                         000106 have_sought_default_attribute_access
                                                            mrds_dsm_compute_access
                         000107 have_sought_default_relation_access
                                                            mrds_dsm_compute_access
                         000110 info_ptr                    mrds_dsm_compute_access
                         000112 key_string                  mrds_dsm_compute_access
                         000213 last_rel_attr_access_sought_for
                                                            mrds_dsm_compute_access
                         000224 local_area_ptr              mrds_dsm_compute_access
                         000226 rel_rec_5_len               mrds_dsm_compute_access
                         000230 rel_rec_5_ptr               mrds_dsm_compute_access
                         000232 relation_name               mrds_dsm_compute_access
                         000254 relation_records_iocb_ptr   mrds_dsm_compute_access
                         000256 temp_ptr                    mrds_dsm_compute_access
                         000260 temp_seg_ptrs               mrds_dsm_compute_access
                         000266 default_attribute_access    mrds_dsm_compute_access
                         000267 default_relation_access     mrds_dsm_compute_access
                         000270 implicit_default_attribute_access
                                                            mrds_dsm_compute_access
                         000271 implicit_default_relation_access
                                                            mrds_dsm_compute_access
                         000272 rel_attr_access             mrds_dsm_compute_access
                         000302 access_record_ptr           mrds_dsm_compute_access
                         000304 rd_ptr                      mrds_dsm_compute_access
                         000306 sl_array_limit              mrds_dsm_compute_access
                         000320 key_string                  calc_relation_access
                         000430 key_string                  calc_attribute_access
                         000562 mode_idx                    get_relation_access
                         000572 mode_idx                    get_attribute_access
                         000602 dm_attr                     validate_relation_access
                         000603 dsm_attr                    validate_relation_access
                         000604 done                        validate_relation_access
                         000616 local_key_string            verify_access_record_use
report_error             000100 long_message                report_error
                         000132 short_message               report_error

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this
call_int_other      return_mac          enable_op           shorten_stack       ext_entry_desc      int_entry
int_entry_desc      op_alloc_           op_empty_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
convert_status_code_          get_temp_segments_            ioa_$ioa_switch               iox_$control
iox_$position                 iox_$read_key                 iox_$read_record              iox_$rewrite_record
iox_$seek_key                 mrds_dm_get_attributes        mrds_dsm_close$force          mrds_dsm_open$update_share
release_temp_segments_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$end_of_info      error_table_$no_record        iox_$error_output
mrds_error_$inconsistent_submodel                           sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      9 001146       173 001173       177 001175       179 001176       181 001177       188 001200       191 001201
    193 001202       251 001225       253 001226       254 001230       255 001232       256 001234       258 001236
    259 001240       260 001242       261 001244       263 001246       264 001250       265 001252       266 001254
    268 001256       269 001260       270 001262       271 001264       281 001266       291 001310       305 001312
    306 001334       308 001336       309 001366       310 001372       315 001373       316 001416       318 001420
    319 001450       320 001454       335 001455       336 001500       338 001502       339 001532       340 001536
    344 001537       345 001541       346 001543       347 001545       365 001551       366 001553       367 001564
    368 001566       369 001570       370 001607       371 001626       372 001644       373 001663       374 001667
    375 001671       376 001673       377 001721       386 001733       387 001753       397 001765       398 002002
    412 002014       413 002016       415 002040       420 002051       421 002063       424 002071       425 002101
    427 002131       430 002133       433 002134       434 002151       439 002162       440 002177       442 002214
    445 002215       449 002216       451 002222       454 002223       491 002234       492 002242       495 002265
    496 002303       498 002317       501 002322       503 002324       504 002326       507 002327       508 002336
    509 002337       511 002346       515 002347       560 002365       561 002373       563 002442       564 002460
    566 002474       570 002507       571 002533       572 002550       574 002564       578 002577       581 002616
    582 002626       583 002643       588 002652       592 002653       620 002671       621 002732       623 002747
    626 002752       628 002754       629 002756       632 002757       633 002761       634 002762       637 003013
    641 003014       657 003015       658 003037       660 003053       663 003061       665 003071       669 003072
    685 003073       686 003115       688 003131       691 003137       693 003147       697 003150       725 003152
    727 003157       729 003201       732 003234       733 003245       735 003265       738 003301       741 003315
    743 003352       745 003354       750 003424       751 003426       752 003443       756 003476       760 003477
    787 003501       789 003506       791 003530       794 003563       795 003573       797 003613       800 003627
    803 003643       805 003700       807 003702       812 003752       813 003754       814 003771       818 004024
    822 004025       847 004026       853 004053       856 004056       861 004123       864 004125       865 004135
    867 004142       868 004143       869 004155       872 004172       874 004177       879 004227       880 004231
    881 004232       883 004234       885 004236       889 004240       893 004241       914 004242       918 004245
    919 004265       922 004277       923 004317       926 004331       927 004334       931 004351       932 004355
    937 004367       939 004411       941 004413       945 004446       947 004447       948 004467       952 004504
    953 004505       956 004520       960 004521       986 004544       988 004610       990 004615       992 004621
    996 004622      1029 004650      1030 004663      1032 004740      1036 005020      1038 005026      1042 005027
   1059 005035      1062 005064      1065 005100      1069 005114


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
