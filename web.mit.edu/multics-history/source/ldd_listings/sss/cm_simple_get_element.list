	COMPILATION LISTING OF SEGMENT cm_simple_get_element
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 01/03/85  1640.4 mst Thu
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 
        9 /* DESCRIPTION
       10*
       11*        This module implements collection_manager_$simple_get_by_ci_ptr
       12*   and collection_manager_$simple_get_from_ci_buffer.  The two entries
       13*   behave identically.  Both exist to maintain symmetry of operations.
       14*
       15*        This module copies the specified element (identified by
       16*   p_element_id) from the given control interval to the caller's output
       17*   buffer pointed to by p_buffer_ptr.  If the element does not fit in the
       18*   buffer, i.e., the number of bytes required to hold the element is
       19*   greater than the number of whole bytes in p_buffer_length,
       20*   dm_error_$long_return_element is returned in the p_code parameter.
       21*   
       22*        The caller supplies a pointer (p_ci_ptr) to the control interval
       23*   from which the element is to be copied.  This pointer may point to the
       24*   actual control interval in the file or to a buffered copy of the
       25*   control interval.  The former is obtained by calling
       26*   collection_manager_$get_control_interval_pointer, the latter by calling
       27*   collection_manager_$setup_ci_buffer.  The element must be wholely
       28*   contained in the control interval, i.e., the element must be a single
       29*   datum element.
       30**/
       31 
       32 /* HISTORY:
       33*Written by Matthew Pierret, 11/10/83.
       34*   (63rd anniversary of O.S.Pierret's birth)
       35*Modified:
       36*04/13/84 by Matthew Pierret:  Changed name of p_buffered_ci_ptr to
       37*            p_ci_buffer_ptr to conform to documentation.
       38*10/04/84 by Matthew Pierret:  Changed bits-to-bytes calculation to
       39*            bytes = divide (bits + BITS_PER_BYTE -1, BITS_PER_BYTE, 17, 0) from
       40*            bytes = ceil (divide (bits, BITS_PER_BYTE, 35, 18)) as the former
       41*            is more efficient.  Changed name to cm_simple_get_element from
       42*            cm_simple_get_buf_element as it deals with both buffered and
       43*            unbuffered elements.
       44**/
       45 
       46 /* format: style2,ind3 */
       47 
       48 cm_simple_get_element:
       49    proc (p_ci_buffer_ptr, p_collection_id, p_element_id, p_buffer_ptr, p_buffer_length, p_element_length, p_code);
       50 
       51 
       52 /* START OF DECLARATIONS */
       53 /* Parameter */
       54 
       55       dcl	    p_ci_buffer_ptr	       ptr;
       56       dcl	    p_collection_id	       bit (36) aligned;
       57       dcl	    p_element_id	       bit (36) aligned;
       58       dcl	    p_buffer_ptr	       ptr;
       59       dcl	    p_buffer_length	       fixed bin (35);
       60       dcl	    p_element_length       fixed bin (35);
       61       dcl	    p_code	       fixed bin (35);
       62 
       63 /* Automatic */
       64 
       65       dcl	    buffer_length_in_bytes fixed bin (17);
       66       dcl	    datum_contents_length_in_bytes
       67 			       fixed bin (17);
       68       dcl	    datum_contents_offset_in_bytes
       69 			       fixed bin (17);
       70       dcl	    datum_slot_index       fixed bin (17);
       71 
       72       dcl	    buffer_ptr	       ptr;
       73 
       74 /* Based */
       75 
       76       dcl	    datum_contents_string  char (datum_contents_length_in_bytes) based;
       77 
       78 /* Builtin */
       79 
       80       dcl	    (addcharno, addr, divide, null)
       81 			       builtin;
       82 
       83 /* Controlled */
       84 /* Constant */
       85 
       86       dcl	    myname	       init ("cm_simple_get_element") char (32) varying internal static options (constant);
       87       dcl	    BITS_PER_BYTE	       init (9) fixed bin int static options (constant);
       88 
       89 /* Entry */
       90 
       91       dcl	    sub_err_	       entry () options (variable);
       92 
       93 /* External */
       94 
       95       dcl	    (
       96 	    dm_error_$ci_not_in_collection,
       97 	    dm_error_$no_element,
       98 	    dm_error_$unimplemented_ci_version,
       99 	    dm_error_$long_return_element
      100 	    )		       fixed bin (35) ext;
      101 
      102 /* END OF DECLARATIONS */
      103 
      104       p_code = 0;
      105 
      106       datum_slot_index = addr (p_element_id) -> element_id.index;
      107 
      108       basic_control_interval_ptr = p_ci_buffer_ptr;
      109 
      110       if basic_control_interval.header.layout_type ^= BASIC_CI_LAYOUT_1
      111       then call sub_err_ (dm_error_$unimplemented_ci_version, myname, ACTION_CANT_RESTART, null, 0,
      112 	      "^/Expected a control interval with a layout type of ""^a"";^/received layout ""^a"".", BASIC_CI_LAYOUT_1,
      113 	      basic_control_interval.header.layout_type);
      114 
      115       if basic_control_interval.header.collection_id ^= p_collection_id
      116       then call ERROR_RETURN (dm_error_$ci_not_in_collection);
      117 
      118       buffer_ptr = p_buffer_ptr;
      119       buffer_length_in_bytes = divide (p_buffer_length, BITS_PER_BYTE, 17, 0);
      120 
      121       datum_contents_offset_in_bytes = basic_control_interval.datum_position_table (datum_slot_index).offset_in_bytes;
      122       if datum_contents_offset_in_bytes = FREE_SLOT
      123       then call ERROR_RETURN (dm_error_$no_element);
      124 
      125       datum_contents_length_in_bits = basic_control_interval.datum_position_table (datum_slot_index).length_in_bits;
      126       if datum_contents_length_in_bits > buffer_length_in_bytes * BITS_PER_BYTE
      127       then call ERROR_RETURN (dm_error_$long_return_element);
      128 
      129       datum_contents_length_in_bytes = divide (datum_contents_length_in_bits + BITS_PER_BYTE - 1, BITS_PER_BYTE, 17, 0);
      130 
      131       /*** Copy the datum. */
      132 
      133       buffer_ptr -> datum_contents_string =
      134 	 addcharno (basic_control_interval_ptr, datum_contents_offset_in_bytes) -> datum_contents_string;
      135 
      136       p_element_length = datum_contents_length_in_bits;
      137 RETURN:
      138       return;
      139 
      140 FINISH:
      141    proc ();
      142 
      143    end FINISH;
      144 
      145 ERROR_RETURN:
      146    proc (er_p_code);
      147 
      148       dcl	    er_p_code	       fixed bin (35);
      149 
      150       p_code = er_p_code;
      151       call FINISH ();
      152       goto RETURN;
      153 
      154    end ERROR_RETURN;
      155 
  1     1 /* BEGIN INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*
  1     5*        The collection_manager_ manages the structure of the addressable
  1     6*   portion of a control interval.  The addressable portion is that portion of
  1     7*   a control interval which the file_manager_ will allow the
  1     8*   collection_manager_ to address.  In this description control interval will
  1     9*   be used to mean the addressable portion of a control interval.
  1    10*   
  1    11*        A control interval is divided into four parts: the header, the datum
  1    12*   position table (also known as the slot table or slots), un-used space and
  1    13*   used space.  The beginning of the header is at offset 0, and the end of the
  1    14*   used space is at the end of the control interval (curently offset 4072).
  1    15*   Pictoriarly, a control interval is structured as follows:
  1    16*   
  1    17*   ----------------------------------------------------------------------
  1    18*   |        || | | | | | ||               ||   | / / |       |/|   |    |
  1    19*   | Header || | slot  | || un-used space ||   |/ / /|       |/|   |    |
  1    20*   |        || | table | ||               ||   | / / |       |/|   |    |
  1    21*   |        || | | | | | ||               ||   |/ / /|       |/|   |    |
  1    22*   ----------------------------------------------------------------------
  1    23*                                           ^ ^    ^      ^    ^  ^   ^
  1    24*                                           | |    |      |    |  |   |
  1    25*                                           | |...........|.......|...|
  1    26*                        start of used space|      |           |      |
  1    27*                                                  |           |  each|
  1    28*                                          scattered free space|  is a used
  1    29*                                                                 datum
  1    30*   
  1    31*      The basic_control_interval structure describes the header
  1    32*   (basic_control_interval.header, bci_header) and the slots
  1    33*   (basic_control_interval.datum_position_table, datum_slot for one only).
  1    34*   Each datum_slot contains the offset (in bytes) and the length (in bits) of
  1    35*   a datum in the used space.  If the offset is equal to FREE_SLOT (declared
  1    36*   in dm_cm_basic_ci_const.incl.pl1), the slot is un-used.  The slot also
  1    37*   contains flags describing the type of datum (see dm_cm_datum.incl.pl1).
  1    38**/
  1    39 
  1    40 /* HISTORY:
  1    41*Written by Matthew Pierret, 02/07/82.
  1    42*Modified:
  1    43*03/25/82 by Matthew Pierret: Fixed alignment differences basic_control_interval
  1    44*            and its sub-structures.
  1    45*06/14/82 by Matthew Pierret: Removed common header and buffers. Changed
  1    46*            basic_ci_header to bci_header. Added previous_control_interval.
  1    47*07/12/82 by Matthew Pierret: Changed collection_id to be bit (36) aligned.
  1    48*10/29/82 by Matthew Pierret: Added flags to datum slots. 
  1    49*11/10/82 by Matthew Pierret: Removed continued_datum_is_present flag, as it
  1    50*            is not used.
  1    51*03/28/84 by Matthew Pierret: Added the constants BCI_HEADER_LENGTH_IN_BYTES
  1    52*            and DATUM_POSITION_TABLE_OFFSET_IN_BYTES.
  1    53**/
  1    54 
  1    55 /* format: style2 */
  1    56      dcl	   1 basic_control_interval
  1    57 			      aligned based (basic_control_interval_ptr),
  1    58 	     2 header	      like bci_header,
  1    59 	     2 datum_position_table
  1    60 			      (0 refer (basic_control_interval.number_of_datums)) like datum_slot;
  1    61 
  1    62 
  1    63      dcl	   1 bci_header	      aligned based (bci_header_ptr),
  1    64 	     2 layout_type	      char (4) aligned,
  1    65 	     2 collection_id      bit (36) aligned,
  1    66 	     2 next_control_interval
  1    67 			      fixed bin (24) uns unal,
  1    68 	     2 previous_control_interval
  1    69 			      fixed bin (24) uns unal,
  1    70 	     2 flags	      unal,
  1    71 	       3 continuation_datum_is_present
  1    72 			      bit (1) unal,
  1    73 	       3 free_slot_is_present
  1    74 			      bit (1) unal,
  1    75 	       3 must_be_zero     bit (4) unal,		/* reserved */
  1    76 	     2 scattered_free_space
  1    77 			      fixed bin (17) unal,
  1    78 	     2 start_of_used_space
  1    79 			      fixed bin (17) unal,
  1    80 	     2 number_of_datums   fixed bin (17) unal;
  1    81 
  1    82      dcl	   1 datum_slot	      aligned based (datum_slot_ptr),
  1    83 	     2 flags	      unal,
  1    84 	       3 special_format_datum
  1    85 			      bit (1) unal,		/* reserved */
  1    86 	       3 is_continued     bit (1) unal,
  1    87 	       3 is_continuation  bit (1) unal,
  1    88 	       3 mbz	      bit (1) unal,		/* reserved */
  1    89 	     2 offset_in_bytes    fixed bin (15) uns unal,
  1    90 	     2 length_in_bits     fixed bin (17) uns unal;
  1    91 
  1    92      dcl	   basic_control_interval_ptr
  1    93 			      ptr;
  1    94      dcl	   bci_header_ptr	      ptr;
  1    95      dcl	   datum_slot_ptr	      ptr;
  1    96 
  1    97      dcl	   BASIC_CI_LAYOUT_1      char (4) aligned init ("bci1") internal static options (constant);
  1    98 
  1    99 /* END INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
      156 
      157 
  2     1 /* BEGIN INCLUDE FILE dm_cm_basic_ci_const.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*   Contains constants useful in describing parts of a basic control interval.
  2     6**/
  2     7 
  2     8 /* HISTORY:
  2     9*Written by Matthew Pierret, 09/20/84.
  2    10*Modified:
  2    11**/
  2    12 
  2    13      dcl	   FREE_SLOT	      init (0) fixed bin (15) uns internal static options (constant);
  2    14      dcl	   BCI_HEADER_LENGTH_IN_BYTES
  2    15 			      init (20) fixed bin internal static options (constant);
  2    16      dcl	   DATUM_POSITION_TABLE_OFFSET_IN_BYTES
  2    17 			      init (20) fixed bin internal static options (constant);
  2    18 
  2    19 
  2    20 /* END INCLUDE FILE dm_cm_basic_ci_const.incl.pl1 */
      158 
      159 
  3     1 /* BEGIN INCLUDE FILE dm_cm_datum.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*        This include file contains the declarations of datum structures.
  3     5*   There are four tyes of datums: your ordinary, run-of-the-mill datum
  3     6*   (Datum); a continuation datum (CN Datum), which is a continuation of
  3     7*   another datum; a continued datum (CD Datum), which is continued (has a
  3     8*   continuation datum) but is not a continuation itself; and a continued
  3     9*   continuation datum (CDCN Datum), which is both continued and is a
  3    10*   continuation.  To illustrate, datums can be pieced combined in the
  3    11*   following ways:
  3    12*   
  3    13*   1) Datum alone.
  3    14*   
  3    15*   2) CD Datum -> CN Datum.
  3    16*   
  3    17*   3) CD Datum -> CDCN Datum {-> CDCN Datum -> ...-> CDCN Datum} -> CN Datum.
  3    18*
  3    19*   continued_datum and continued_continuation_datum each contains a header
  3    20*   which includes the identifier of the datum which is its continuation.
  3    21*   continued_datum.header.full_length is the length in bits of the entire
  3    22*   element, i.e., the addition of the length of contents structure component
  3    23*   of all of the datums from CD Datum to CN Datum.
  3    24**/
  3    25 
  3    26 /* HISTORY:
  3    27*Written by Matthew Pierret, 02/07/82.
  3    28*Modified:
  3    29*03/25/82 by Matthew Pierret: Changed all datum structures to be unaligned.
  3    30*06/14/82 by Matthew Pierret: Added DATUM_HEADER_LENGTH_IN_BYTES.
  3    31*08/04/82 by Matthew Pierret: Added DATUM_HEADER_LENGTH_IN_BITS.
  3    32*10/20/82 by Matthew Pierret:  Split into two include files, this one and
  3    33*            dm_cm_datum_constants.  The latter holds only and all constants
  3    34*            formerly in this include file.
  3    35*10/29/82 by Matthew Pierret:  Removed datum headers.
  3    36*09/18/84 by Matthew Pierret:  Added DESCRIPTION section.  Added datum and
  3    37*            continuation_datum (mainly for illustration).
  3    38*12/03/84 by Matthew Pierret:  Removed the non-based structures
  3    39*            (cd cdcn)_datum_headers.
  3    40**/
  3    41 
  3    42 /* format: style2,ll79,ind3 */
  3    43 
  3    44      dcl	   1 datum	      unaligned based (datum_ptr),
  3    45 	     2 contents	      bit (datum_contents_length_in_bits);
  3    46 
  3    47      dcl	   1 continuation_datum   unaligned based (datum_ptr),
  3    48 	     2 contents	      bit (datum_contents_length_in_bits);
  3    49 
  3    50      dcl	   1 continued_datum      unaligned based (datum_ptr),
  3    51 	     2 header,
  3    52 	       3 full_length      fixed bin (35),
  3    53 	       3 continuation     like datum_id,
  3    54 	     2 contents	      bit (datum_contents_length_in_bits);
  3    55 
  3    56      dcl	   1 continued_continuation_datum
  3    57 			      unaligned based (datum_ptr),
  3    58 	     2 header,
  3    59 	       3 continuation     like datum_id,
  3    60 	     2 contents	      bit (datum_contents_length_in_bits);
  3    61 
  3    62      dcl	   1 datum_id	      aligned based (datum_id_ptr),
  3    63 	     2 control_interval_id
  3    64 			      fixed bin (24) unal uns,
  3    65 	     2 index	      fixed bin (12) unal uns;
  3    66 
  3    67      dcl	   datum_ptr	      ptr init (null ());
  3    68      dcl	   datum_id_ptr	      ptr init (null ());
  3    69      dcl	   datum_contents_length_in_bits
  3    70 			      fixed bin (35) init (-1);
  3    71 
  3    72 
  3    73 
  3    74 /* END INCLUDE FILE dm_cm_datum.incl.pl1 */
      160 
      161 
  4     1 /* BEGIN INCLUDE FILE dm_cm_datum_constants.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*        Contains constants describing the extents of datums and datum
  4     5*   headers.  The datum headers are described in dm_cm_datum.incl.pl1.
  4     6*   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES is the byte length of the largest
  4     7*   datum that can be stored in a control interval, allowing for the largest
  4     8*   possibledatum header. MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS is the same
  4     9*   in bits instead of bytes.  MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
  4    10*   is the smallest length in bits which requires 
  4    11*   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES bytes to store.
  4    12**/
  4    13 
  4    14 /*
  4    15*HISTORY:
  4    16*Written by Matthew Pierret, 02/07/82.
  4    17*Modified:
  4    18*10/29/82 by Matthew Pierret:  Removed DATUM_HEADER*.
  4    19*11/02/82 by Matthew Pierret:  Added maximum datum contents lengths.
  4    20*12/01/82 by Lindsey Spratt:   Corrected values for datum header lengths.
  4    21*09/18/84 by Matthew Pierret:  Corrected values for maximum lengths. Added
  4    22*            MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS.  Added
  4    23*            DESCRIPTION section.
  4    24**/
  4    25 
  4    26 /* format: style2,ind3,ll79 */
  4    27      dcl	   CD_DATUM_HEADER_LENGTH_IN_BYTES
  4    28 			      fixed bin init (8) internal static
  4    29 			      options (constant);
  4    30 
  4    31      dcl	   CD_DATUM_HEADER_LENGTH_IN_BITS
  4    32 			      fixed bin init (72) internal static
  4    33 			      options (constant);
  4    34 
  4    35      dcl	   CDCN_DATUM_HEADER_LENGTH_IN_BYTES
  4    36 			      init (4) fixed bin int static
  4    37 			      options (constant);
  4    38 
  4    39      dcl	   CDCN_DATUM_HEADER_LENGTH_IN_BITS
  4    40 			      init (36) fixed bin int static
  4    41 			      options (constant);
  4    42 
  4    43      dcl	   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
  4    44 			      init (36360) fixed bin (35) internal
  4    45 			      static options (constant);
  4    46 
  4    47      dcl	   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES
  4    48 			      init (4040) fixed bin (35) internal
  4    49 			      static options (constant);
  4    50 
  4    51      dcl	   MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
  4    52 			      init (36352) fixed bin (35) internal
  4    53 			      static options (constant);
  4    54 
  4    55 /* END INCLUDE FILE dm_cm_datum.incl.pl1 */
      162 
      163 
  5     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*
  5     5*        Contains the declaration of an element identifier.  Element
  5     6*   identifiers consist of two parts, the id (number) of the control interval
  5     7*   in which the element resides, and the index into the slot table of
  5     8*   the element in the control interval.  The declaration of the element_id 
  5     9*   structure reflects this division of the element identifier.  The structure 
  5    10*   is based on the automatic bit string element_id_string because programs
  5    11*   generally pass bit strings (element_id_string) to each other, then 
  5    12*   interpret the bit string by overlaying the element_id structure ony if
  5    13*   it is necessary to access the parts of the id.  Basing element_id on
  5    14*   addr(element_id_string) instead of on a pointer removes the necessity
  5    15*   for always setting that pointer explicitly and guarantees that changes
  5    16*   made to the string or structure do not get inconsistent.
  5    17*
  5    18*   Changes made to element_id must also be made to datum_id, declared in 
  5    19*   dm_cm_datum.incl.pl1.
  5    20**/
  5    21 
  5    22 /* HISTORY:
  5    23*Written by Matthew Pierret, 04/01/82.
  5    24*Modified:
  5    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  5    26**/
  5    27 
  5    28 /* format: style2,ind3,ll79 */
  5    29 
  5    30      dcl	   element_id_string      bit (36) aligned;
  5    31 
  5    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  5    33 	     2 control_interval_id
  5    34 			      fixed bin (24) unal unsigned,
  5    35 	     2 index	      fixed bin (12) unal unsigned;
  5    36 
  5    37 
  5    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      164 
      165 
  6     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  6     2 /* format: style3 */
  6     3 
  6     4 /* These constants are to be used for the flags argument of sub_err_ */
  6     5 /* They are just "string (condition_info_header.action_flags)" */
  6     6 
  6     7 declare	(
  6     8 	ACTION_CAN_RESTART	init (""b),
  6     9 	ACTION_CANT_RESTART init ("1"b),
  6    10 	ACTION_DEFAULT_RESTART
  6    11 			init ("01"b),
  6    12 	ACTION_QUIET_RESTART
  6    13 			init ("001"b),
  6    14 	ACTION_SUPPORT_SIGNAL
  6    15 			init ("0001"b)
  6    16 	)		bit (36) aligned internal static options (constant);
  6    17 
  6    18 /* End include file */
      166 
      167 
      168    end cm_simple_get_element;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/03/85  1149.5  cm_simple_get_element.pl1         >spec>temp>famis1>cm_simple_get_element.pl1
156          1    01/03/85  1003.0  dm_cm_basic_ci.incl.pl1           >spec>temp>famis1>dm_cm_basic_ci.incl.pl1
158          2    01/03/85  1003.0  dm_cm_basic_ci_const.incl.pl1     >spec>temp>famis1>dm_cm_basic_ci_const.incl.pl1
160          3    01/03/85  1005.4  dm_cm_datum.incl.pl1              >spec>temp>famis1>dm_cm_datum.incl.pl1
162          4    01/03/85  1003.1  dm_cm_datum_constants.incl.pl1    >spec>temp>famis1>dm_cm_datum_constants.incl.pl1
164          5    01/03/85  1003.2  dm_element_id.incl.pl1            >spec>temp>famis1>dm_element_id.incl.pl1
166          6    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000000 constant        bit(36)                  initial dcl 6-7 set ref 110*
BASIC_CI_LAYOUT_1               000001 constant        char(4)                  initial dcl 1-97 set ref 110 110*
BITS_PER_BYTE                   000274 constant        fixed bin(17,0)          initial dcl 87 ref 119 126 129 129
FREE_SLOT                              constant        fixed bin(15,0)          initial unsigned dcl 2-13 ref 122
addcharno                                              builtin function         dcl 80 ref 133
addr                                                   builtin function         dcl 80 ref 106
basic_control_interval                 based           structure                level 1 dcl 1-56
basic_control_interval_ptr      000106 automatic       pointer                  dcl 1-92 set ref 108* 110 110 115 121 125 133
bci_header                             based           structure                level 1 dcl 1-63
buffer_length_in_bytes          000100 automatic       fixed bin(17,0)          dcl 65 set ref 119* 126
buffer_ptr                      000104 automatic       pointer                  dcl 72 set ref 118* 133
collection_id             1            based           bit(36)                  level 3 dcl 1-56 ref 115
datum_contents_length_in_bits   000114 automatic       fixed bin(35,0)          initial dcl 3-69 set ref 125* 126 129 136 3-69*
datum_contents_length_in_bytes  000101 automatic       fixed bin(17,0)          dcl 66 set ref 129* 133 133
datum_contents_offset_in_bytes  000102 automatic       fixed bin(17,0)          dcl 68 set ref 121* 122 133
datum_contents_string                  based           char                     unaligned dcl 76 set ref 133* 133
datum_id                               based           structure                level 1 dcl 3-62
datum_id_ptr                    000112 automatic       pointer                  initial dcl 3-68 set ref 3-68*
datum_position_table      5            based           structure                array level 2 dcl 1-56
datum_ptr                       000110 automatic       pointer                  initial dcl 3-67 set ref 3-67*
datum_slot                             based           structure                level 1 dcl 1-82
datum_slot_index                000103 automatic       fixed bin(17,0)          dcl 70 set ref 106* 121 125
divide                                                 builtin function         dcl 80 ref 119 129
dm_error_$ci_not_in_collection  000012 external static fixed bin(35,0)          dcl 95 set ref 115*
dm_error_$long_return_element   000020 external static fixed bin(35,0)          dcl 95 set ref 126*
dm_error_$no_element            000014 external static fixed bin(35,0)          dcl 95 set ref 122*
dm_error_$unimplemented_ci_version
                                000016 external static fixed bin(35,0)          dcl 95 set ref 110*
element_id                             based           structure                level 1 dcl 5-32
er_p_code                              parameter       fixed bin(35,0)          dcl 148 ref 145 150
header                                 based           structure                level 2 dcl 1-56
index                     0(24)        based           fixed bin(12,0)          level 2 packed unsigned unaligned dcl 5-32 ref 106
layout_type                            based           char(4)                  level 3 dcl 1-56 set ref 110 110*
length_in_bits            5(19)        based           fixed bin(17,0)          array level 3 packed unsigned unaligned dcl 1-56 ref
                                                                                  125
myname                          000002 constant        varying char(32)         initial dcl 86 set ref 110*
null                                                   builtin function         dcl 80 ref 110 110 3-67 3-68
offset_in_bytes           5(04)        based           fixed bin(15,0)          array level 3 packed unsigned unaligned dcl 1-56 ref
                                                                                  121
p_buffer_length                        parameter       fixed bin(35,0)          dcl 59 ref 48 119
p_buffer_ptr                           parameter       pointer                  dcl 58 ref 48 118
p_ci_buffer_ptr                        parameter       pointer                  dcl 55 ref 48 108
p_code                                 parameter       fixed bin(35,0)          dcl 61 set ref 48 104* 150*
p_collection_id                        parameter       bit(36)                  dcl 56 ref 48 115
p_element_id                           parameter       bit(36)                  dcl 57 set ref 48 106
p_element_length                       parameter       fixed bin(35,0)          dcl 60 set ref 48 136*
sub_err_                        000010 constant        entry                    external dcl 91 ref 110

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 6-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 6-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 6-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 6-7
BCI_HEADER_LENGTH_IN_BYTES             internal static fixed bin(17,0)          initial dcl 2-14
CDCN_DATUM_HEADER_LENGTH_IN_BITS       internal static fixed bin(17,0)          initial dcl 4-39
CDCN_DATUM_HEADER_LENGTH_IN_BYTES      internal static fixed bin(17,0)          initial dcl 4-35
CD_DATUM_HEADER_LENGTH_IN_BITS         internal static fixed bin(17,0)          initial dcl 4-31
CD_DATUM_HEADER_LENGTH_IN_BYTES        internal static fixed bin(17,0)          initial dcl 4-27
DATUM_POSITION_TABLE_OFFSET_IN_BYTES   internal static fixed bin(17,0)          initial dcl 2-16
MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS  internal static fixed bin(35,0)          initial dcl 4-43
MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES internal static fixed bin(35,0)          initial dcl 4-47
MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
                                       internal static fixed bin(35,0)          initial dcl 4-51
bci_header_ptr                         automatic       pointer                  dcl 1-94
continuation_datum                     based           structure                level 1 packed unaligned dcl 3-47
continued_continuation_datum           based           structure                level 1 packed unaligned dcl 3-56
continued_datum                        based           structure                level 1 packed unaligned dcl 3-50
datum                                  based           structure                level 1 packed unaligned dcl 3-44
datum_slot_ptr                         automatic       pointer                  dcl 1-95
element_id_string                      automatic       bit(36)                  dcl 5-30

NAMES DECLARED BY EXPLICIT CONTEXT.
ERROR_RETURN                    000265 constant        entry                    internal dcl 145 ref 115 122 126
FINISH                          000263 constant        entry                    internal dcl 140 ref 151
RETURN                          000262 constant        label                    dcl 137 ref 152
cm_simple_get_element           000056 constant        entry                    external dcl 48

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       376         420     275         406
Length       730     275        22         273     101           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cm_simple_get_element               148 external procedure  is an external procedure.  
FINISH                                  internal procedure  shares stack frame of external procedure cm_simple_get_element.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure cm_simple_get_element.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cm_simple_get_element    000100 buffer_length_in_bytes      cm_simple_get_element
                         000101 datum_contents_length_in_bytes
                                                            cm_simple_get_element
                         000102 datum_contents_offset_in_bytes
                                                            cm_simple_get_element
                         000103 datum_slot_index            cm_simple_get_element
                         000104 buffer_ptr                  cm_simple_get_element
                         000106 basic_control_interval_ptr  cm_simple_get_element
                         000110 datum_ptr                   cm_simple_get_element
                         000112 datum_id_ptr                cm_simple_get_element
                         000114 datum_contents_length_in_bits
                                                            cm_simple_get_element

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   return              ext_entry           divide_fx3

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$ci_not_in_collection                              dm_error_$long_return_element dm_error_$no_element
dm_error_$unimplemented_ci_version


CONSTANTS
000000  aa     400000000000

000001  aa  142 143 151 061	bci1

000002  aa     000000000025
000003  aa  143 155 137 163	cm_s
000004  aa  151 155 160 154	impl
000005  aa  145 137 147 145	e_ge
000006  aa  164 137 145 154	t_el
000007  aa  145 155 145 156	emen
000010  aa  164 040 040 040	t   
000011  aa  040 040 040 040	    
000012  aa  040 040 040 040	    

000013  aa     524000000004

000014  aa     524000000120

000015  aa     404000000005

000016  aa     530000000040

000274  aa     000000000011

000017  aa     404000000043

000020  aa     514000000044

000021  aa     464000000000

000022  aa     077777000043
000023  aa     000001000000

000024  aa  136 057 105 170	^/Ex
000025  aa  160 145 143 164	pect
000026  aa  145 144 040 141	ed a
000027  aa  040 143 157 156	 con
000030  aa  164 162 157 154	trol
000031  aa  040 151 156 164	 int
000032  aa  145 162 166 141	erva
000033  aa  154 040 167 151	l wi
000034  aa  164 150 040 141	th a
000035  aa  040 154 141 171	 lay
000036  aa  157 165 164 040	out 
000037  aa  164 171 160 145	type
000040  aa  040 157 146 040	 of 
000041  aa  042 136 141 042	"^a"
000042  aa  073 136 057 162	;^/r
000043  aa  145 143 145 151	ecei
000044  aa  166 145 144 040	ved 
000045  aa  154 141 171 157	layo
000046  aa  165 164 040 042	ut "
000047  aa  136 141 042 056	^a".

BEGIN PROCEDURE cm_simple_get_element
ENTRY TO cm_simple_get_element                              STATEMENT 1 ON LINE 48
cm_simple_get_element:
   proc (p_ci_buffer_ptr, p_collection_id, p_element_id, p_buffer_ptr, p_buffer_length, p_element_length, p_code);

000050  at     000007000021
000051  tt     000020000020
000052  tt     000021000017
000053  tt     000017000017
000054  ta     000050000000
000055  da     000075300000
000056  aa   000240 6270 00	eax7 	160
000057  aa  7 00034 3521 20	epp2 	pr7|28,*
000060  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000061  aa     000016000000
000062  aa     000000000000
						STATEMENT 1 ON LINE 67 OF FILE 3
000063  aa   777737 2370 04	ldaq 	-33,ic		000022 = 077777000043 000001000000
000064  aa  6 00110 7571 00	staq 	pr6|72		datum_ptr
						STATEMENT 1 ON LINE 68 OF FILE 3
000065  aa  6 00112 7571 00	staq 	pr6|74		datum_id_ptr
						STATEMENT 1 ON LINE 69 OF FILE 3
000066  aa   000001 3360 07	lcq  	1,dl
000067  aa  6 00114 7561 00	stq  	pr6|76		datum_contents_length_in_bits
						STATEMENT 1 ON LINE 104
      p_code = 0;

000070  aa  6 00032 3735 20	epp7 	pr6|26,*
000071  aa  7 00016 4501 20	stz  	pr7|14,*		p_code
						STATEMENT 1 ON LINE 106
      datum_slot_index = addr (p_element_id) -> element_id.index;

000072  aa  7 00006 2361 20	ldq  	pr7|6,*		element_id.index
000073  aa  0 00410 3771 00	anaq 	pr0|264		= 000000000000 000000007777
000074  aa  6 00103 7561 00	stq  	pr6|67		datum_slot_index
						STATEMENT 1 ON LINE 108
      basic_control_interval_ptr = p_ci_buffer_ptr;

000075  aa  7 00002 3715 20	epp5 	pr7|2,*		p_ci_buffer_ptr
000076  aa  5 00000 3715 20	epp5 	pr5|0,*		p_ci_buffer_ptr
000077  aa  6 00106 6515 00	spri5	pr6|70		basic_control_interval_ptr
						STATEMENT 1 ON LINE 110
      if basic_control_interval.header.layout_type ^= BASIC_CI_LAYOUT_1
      then call sub_err_ (dm_error_$unimplemented_ci_version, myname, ACTION_CANT_RESTART, null, 0,
	      "^/Expected a control interval with a layout type of ""^a"";^/received layout ""^a"".", BASIC_CI_LAYOUT_1,
	      basic_control_interval.header.layout_type);

000100  aa  5 00000 2351 00	lda  	pr5|0		basic_control_interval.layout_type
000101  aa   777700 1150 04	cmpa 	-64,ic		000001 = 142143151061
000102  aa   000052 6000 04	tze  	42,ic		000154
000103  aa   777717 3534 24	epp3 	-49,ic*
000104  aa  6 00132 2535 00	spri3	pr6|90
000105  aa  6 00134 4501 00	stz  	pr6|92
000106  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000107  aa   777716 00 0120	desc9a	-50,80		000024 = 136057105170
000110  aa  6 00136 00 0120	desc9a	pr6|94,80
000111  la  4 00016 3521 20	epp2 	pr4|14,*		dm_error_$unimplemented_ci_version
000112  aa  6 00164 2521 00	spri2	pr6|116
000113  aa   777670 3520 04	epp2 	-72,ic		000003 = 143155137163
000114  aa  6 00166 2521 00	spri2	pr6|118
000115  aa   777663 3520 04	epp2 	-77,ic		000000 = 400000000000
000116  aa  6 00170 2521 00	spri2	pr6|120
000117  aa  6 00132 3521 00	epp2 	pr6|90
000120  aa  6 00172 2521 00	spri2	pr6|122
000121  aa  6 00134 3521 00	epp2 	pr6|92
000122  aa  6 00174 2521 00	spri2	pr6|124
000123  aa  6 00136 3521 00	epp2 	pr6|94
000124  aa  6 00176 2521 00	spri2	pr6|126
000125  aa   777654 3520 04	epp2 	-84,ic		000001 = 142143151061
000126  aa  6 00200 2521 00	spri2	pr6|128
000127  aa  5 00000 3521 00	epp2 	pr5|0		basic_control_interval.layout_type
000130  aa  6 00202 2521 00	spri2	pr6|130
000131  aa   777666 3520 04	epp2 	-74,ic		000017 = 404000000043
000132  aa  6 00204 2521 00	spri2	pr6|132
000133  aa   777663 3520 04	epp2 	-77,ic		000016 = 530000000040
000134  aa  6 00206 2521 00	spri2	pr6|134
000135  aa   777663 3520 04	epp2 	-77,ic		000020 = 514000000044
000136  aa  6 00210 2521 00	spri2	pr6|136
000137  aa   777662 3520 04	epp2 	-78,ic		000021 = 464000000000
000140  aa  6 00212 2521 00	spri2	pr6|138
000141  aa   777654 3520 04	epp2 	-84,ic		000015 = 404000000005
000142  aa  6 00214 2521 00	spri2	pr6|140
000143  aa   777651 3520 04	epp2 	-87,ic		000014 = 524000000120
000144  aa  6 00216 2521 00	spri2	pr6|142
000145  aa   777646 3520 04	epp2 	-90,ic		000013 = 524000000004
000146  aa  6 00220 2521 00	spri2	pr6|144
000147  aa  6 00222 2521 00	spri2	pr6|146
000150  aa  6 00162 6211 00	eax1 	pr6|114
000151  aa   040000 4310 07	fld  	16384,dl
000152  la  4 00010 3521 20	epp2 	pr4|8,*		sub_err_
000153  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 115
      if basic_control_interval.header.collection_id ^= p_collection_id
      then call ERROR_RETURN (dm_error_$ci_not_in_collection);

000154  aa  6 00106 3735 20	epp7 	pr6|70,*		basic_control_interval_ptr
000155  aa  7 00001 2351 00	lda  	pr7|1		basic_control_interval.collection_id
000156  aa  6 00032 3715 20	epp5 	pr6|26,*
000157  aa  5 00004 1151 20	cmpa 	pr5|4,*		p_collection_id
000160  aa   000010 6000 04	tze  	8,ic		000170
000161  aa  6 00044 3701 20	epp4 	pr6|36,*
000162  la  4 00012 3521 20	epp2 	pr4|10,*		dm_error_$ci_not_in_collection
000163  aa  6 00140 2521 00	spri2	pr6|96
000164  aa  6 00136 3521 00	epp2 	pr6|94
000165  aa   004000 4310 07	fld  	2048,dl
000166  aa  2 00000 7571 00	staq 	pr2|0
000167  aa   000076 6700 04	tsp4 	62,ic		000265
						STATEMENT 1 ON LINE 118
      buffer_ptr = p_buffer_ptr;

000170  aa  6 00032 3735 20	epp7 	pr6|26,*
000171  aa  7 00010 3715 20	epp5 	pr7|8,*		p_buffer_ptr
000172  aa  5 00000 3715 20	epp5 	pr5|0,*		p_buffer_ptr
000173  aa  6 00104 6515 00	spri5	pr6|68		buffer_ptr
						STATEMENT 1 ON LINE 119
      buffer_length_in_bytes = divide (p_buffer_length, BITS_PER_BYTE, 17, 0);

000174  aa  7 00012 2361 20	ldq  	pr7|10,*		p_buffer_length
000175  aa   000011 5060 07	div  	9,dl
000176  aa  6 00100 7561 00	stq  	pr6|64		buffer_length_in_bytes
						STATEMENT 1 ON LINE 121
      datum_contents_offset_in_bytes = basic_control_interval.datum_position_table (datum_slot_index).offset_in_bytes;

000177  aa  6 00103 7271 00	lxl7 	pr6|67		datum_slot_index
000200  aa  6 00106 3535 20	epp3 	pr6|70,*		basic_control_interval_ptr
000201  aa  3 00004 2351 17	lda  	pr3|4,7		basic_control_interval.offset_in_bytes
000202  aa   000004 7350 00	als  	4
000203  aa   000071 7730 00	lrl  	57
000204  aa  6 00102 7561 00	stq  	pr6|66		datum_contents_offset_in_bytes
						STATEMENT 1 ON LINE 122
      if datum_contents_offset_in_bytes = FREE_SLOT
      then call ERROR_RETURN (dm_error_$no_element);

000205  aa   000010 6010 04	tnz  	8,ic		000215
000206  aa  6 00044 3701 20	epp4 	pr6|36,*
000207  la  4 00014 3521 20	epp2 	pr4|12,*		dm_error_$no_element
000210  aa  6 00140 2521 00	spri2	pr6|96
000211  aa  6 00136 3521 00	epp2 	pr6|94
000212  aa   004000 4310 07	fld  	2048,dl
000213  aa  2 00000 7571 00	staq 	pr2|0
000214  aa   000051 6700 04	tsp4 	41,ic		000265
						STATEMENT 1 ON LINE 125
      datum_contents_length_in_bits = basic_control_interval.datum_position_table (datum_slot_index).length_in_bits;

000215  aa  6 00103 7271 00	lxl7 	pr6|67		datum_slot_index
000216  aa  6 00106 3735 20	epp7 	pr6|70,*		basic_control_interval_ptr
000217  aa  7 00004 2361 17	ldq  	pr7|4,7		basic_control_interval.length_in_bits
000220  aa  0 00376 3771 00	anaq 	pr0|254		= 000000000000 000000377777
000221  aa  6 00114 7561 00	stq  	pr6|76		datum_contents_length_in_bits
						STATEMENT 1 ON LINE 126
      if datum_contents_length_in_bits > buffer_length_in_bytes * BITS_PER_BYTE
      then call ERROR_RETURN (dm_error_$long_return_element);

000222  aa  6 00100 2361 00	ldq  	pr6|64		buffer_length_in_bytes
000223  aa   000011 4020 07	mpy  	9,dl
000224  aa  6 00114 1161 00	cmpq 	pr6|76		datum_contents_length_in_bits
000225  aa   000010 6050 04	tpl  	8,ic		000235
000226  aa  6 00044 3701 20	epp4 	pr6|36,*
000227  la  4 00020 3521 20	epp2 	pr4|16,*		dm_error_$long_return_element
000230  aa  6 00140 2521 00	spri2	pr6|96
000231  aa  6 00136 3521 00	epp2 	pr6|94
000232  aa   004000 4310 07	fld  	2048,dl
000233  aa  2 00000 7571 00	staq 	pr2|0
000234  aa   000031 6700 04	tsp4 	25,ic		000265
						STATEMENT 1 ON LINE 129
      datum_contents_length_in_bytes = divide (datum_contents_length_in_bits + BITS_PER_BYTE - 1, BITS_PER_BYTE, 17, 0);

000235  aa  6 00114 2351 00	lda  	pr6|76		datum_contents_length_in_bits
000236  aa   000044 7330 00	lrs  	36
000237  aa   000011 0330 07	adl  	9,dl
000240  aa   000000 5330 00	negl 	0
000241  aa   000001 0330 07	adl  	1,dl
000242  aa   000000 5330 00	negl 	0
000243  aa   000031 3520 04	epp2 	25,ic		000274 = 000000000011
000244  aa  0 01264 7001 00	tsx0 	pr0|692		divide_fx3
000245  aa     000000000000
000246  aa  6 00101 7561 00	stq  	pr6|65		datum_contents_length_in_bytes
						STATEMENT 1 ON LINE 133
      buffer_ptr -> datum_contents_string =
	 addcharno (basic_control_interval_ptr, datum_contents_offset_in_bytes) -> datum_contents_string;

000247  aa  6 00106 3515 20	epp1 	pr6|70,*		basic_control_interval_ptr
000250  aa  6 00102 2361 00	ldq  	pr6|66		datum_contents_offset_in_bytes
000251  aa  1 00000 5005 06	a9bd 	pr1|0,ql
000252  aa  6 00104 3735 20	epp7 	pr6|68,*		buffer_ptr
000253  aa  6 00101 7271 00	lxl7 	pr6|65		datum_contents_length_in_bytes
000254  aa  040 140 100 540	mlr  	(pr,rl),(pr,rl),fill(040)
000255  aa  1 00000 00 0017	desc9a	pr1|0,x7		datum_contents_string
000256  aa  7 00000 00 0017	desc9a	pr7|0,x7		datum_contents_string
						STATEMENT 1 ON LINE 136
      p_element_length = datum_contents_length_in_bits;

000257  aa  6 00114 2361 00	ldq  	pr6|76		datum_contents_length_in_bits
000260  aa  6 00032 3715 20	epp5 	pr6|26,*
000261  aa  5 00014 7561 20	stq  	pr5|12,*		p_element_length
						STATEMENT 1 ON LINE 137
RETURN:
      return;

000262  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 168
   end cm_simple_get_element;

BEGIN PROCEDURE FINISH
ENTRY TO FINISH                                             STATEMENT 1 ON LINE 140
FINISH:
   proc ();

000263  aa  6 00116 6501 00	spri4	pr6|78
						STATEMENT 1 ON LINE 143
   end FINISH;

000264  aa  6 00116 6101 00	rtcd 	pr6|78
  END PROCEDURE FINISH
BEGIN PROCEDURE ERROR_RETURN
ENTRY TO ERROR_RETURN                                       STATEMENT 1 ON LINE 145
ERROR_RETURN:
   proc (er_p_code);

000265  aa  6 00124 6501 00	spri4	pr6|84
000266  aa  6 00126 2521 00	spri2	pr6|86
						STATEMENT 1 ON LINE 150
      p_code = er_p_code;

000267  aa  2 00002 2361 20	ldq  	pr2|2,*		er_p_code
000270  aa  6 00032 3735 20	epp7 	pr6|26,*
000271  aa  7 00016 7561 20	stq  	pr7|14,*		p_code
						STATEMENT 1 ON LINE 151
      call FINISH ();

000272  aa   777771 6700 04	tsp4 	-7,ic		000263
						STATEMENT 1 ON LINE 152
      goto RETURN;

000273  aa   777767 7100 04	tra  	-9,ic		000262
						STATEMENT 1 ON LINE 154
   end ERROR_RETURN;

  END PROCEDURE ERROR_RETURN
  END PROCEDURE cm_simple_get_element


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
