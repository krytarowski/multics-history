	COMPILATION LISTING OF SEGMENT im_process_keys
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/04/85  0956.3 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* DESCRIPTION:
        8*
        9*         This subroutine takes all of the leaf keys in a range (specified by
       10*     the element_id of the low key and the element_id of the high key), and
       11*     processes those which pass the supplied filter (identified by
       12*     p_specification_ptr) according to the specified operation (get, delete,
       13*     count, or position).  
       14*
       15*     Getting keys consists of creating simple_typed_vector representations of
       16*     them and adding these STVs to a typed_vector_array, which is returned to
       17*     the caller.  Deleting keys is accomplished by calling im_general_delete
       18*     on each key to be deleted.  The "count" processing is simply achieved by
       19*     incrementing a counter. The "position" processing simply stops with the
       20*     first key found to satisfy the filters.
       21*
       22*     The index_cursor is set in different ways, depending on the operation
       23*     (see SET_INDEX_CURSOR for the details).
       24*
       25*     All of the external entries have the following input parameters in common:
       26*     p_index_cursor_ptr, p_work_area_ptr, p_field_table_ptr, p_id_list_ptr,
       27*     p_specification_ptr, p_and_group_id_list_ptr,
       28*     p_number_of_fully_structural_fields, p_partial_structural_field_id, and
       29*     p_first_key_id_string, p_last_key_id_string.
       30*     
       31*     
       32*     They all have p_code as an output parameter.
       33*     
       34*     For the other parameters:
       35*     
       36*     
       37*     get - p_typed_vector_array_ptr (input/output)
       38*
       39*     position - p_number_of_keys_accepted (input/output)
       40*     
       41*     delete - p_key_count_array_ptr, p_number_of_keys_accepted (input/output)
       42*     
       43*     count - p_number_of_keys_accepted (input/output)
       44*
       45*
       46*     POSITION_INFO:     
       47*
       48*     All of the information which is global in this procedure is gathered
       49*     together in a structure called global_position_info.  The global data is
       50*     largely concerned with information related to (or derived from) the
       51*     current position in the index, hence the name of the structure.  There
       52*     are 3 major types of procedures which know about the structure of
       53*     position_info, the GET_*, SET_* and RESET_* procedures.  The other
       54*     procedures which know about the structure of position_info are NOTE_*
       55*     procedures, INITIALIZE_POSITION, NODE_IS_DELETED,
       56*     DECREMENT_LAST_KEY_ID_SLOT_INDEX, and FREE_VECTOR_STORAGE.  Each of these
       57*     procedures only references a very limited portion of the position_info
       58*     structure, using the other procedures (where possible) to access other
       59*     portions of the position_info structure.
       60*     
       61*     ***All other procedures rely entirely on the aforementioned procedures to
       62*     use any of the data in position_info.***
       63*     
       64*     The kind of data in position_info is logically divided into variables
       65*     and constants.  The constants are only referenced by GET_* procedures,
       66*     and never change after being initialized by INITIALIZE_POSITION.
       67*     
       68*     The variables are again of two kinds, those for which the value is
       69*     generated from other info in position_info,  and those which are
       70*     explicitly set (via a SET_* routine).  Each of the generated variables in
       71*     position_info is dependent on the value of (at least) one of the
       72*     explicitly set values.  Therefore, whenever a SET_* procedure is invoked,
       73*     it must RESET_* all of the generated variables which depend on it, as
       74*     well as RESET_*'ing the explicitly set values whose correct
       75*     interpretation depends on the variable being SET_*.
       76*     
       77*     A GET_* of a generated variable will generate the value for that variable
       78*     if there is no valid value for it already.  (RESET_*'ing a generated
       79*     variable sets the variable to "invalid", as does INITIALIZE_POSITION.)
       80*
       81*     The elements of the position_info structure are as follows:
       82*
       83*     - entire_vector_ptr
       84*         This points at a vector which contains all of the fields in the
       85*       current key.  This value is GENERATED by GET_ENTIRE_VECTOR, RESET by
       86*       RESET_VECTORS.  It depends on key_buffer_contains_current_key.
       87*
       88*     - field_table_ptr
       89*         This is a CONSTANT, from p_field_table_ptr.  
       90*
       91*     - first_key_id_string
       92*         This is a CONSTANT from p_first_key_id_string.  
       93*
       94*     - flags.header_buffer_contains_current_header
       95*         Indicates the validity of the header buffer contents.  This value is
       96*       GENERATED by GET_CI_HEADER, RESET by RESET_CI_HEADER. It depends on
       97*       node_id. 
       98*
       99*     - flags.key_buffer_contains_current_key
      100*         Indicates the validity of the key buffer contents.  This value is
      101*       GENERATED by GET_KEY, RESET by RESET_KEY. It depends on slot_index.
      102*
      103*     - flags.node_is_deleted
      104*         Indicates that the current node was deleted by the deletion of the
      105*       current key. This value is SET by NOTE_NODE_IS_DELETED, RESET by
      106*       RESET_NODE_ID. 
      107*
      108*     - flags.vector_in_use
      109*         Indicates the selected_vector is to be saved for use in the output.
      110*       This value is SET by NOTE_VECTOR_IN_USE, RESET by RESET_VECTORS.
      111*
      112*     - header_buffer_length
      113*         This is a CONSTANT from length(unspec(local_leaf_ci_header)). 
      114*
      115*     - header_buffer_ptr
      116*         This buffer holds the leaf_ci_header for the current node.  This is a
      117*       CONSTANT from addr(local_leaf_ci_header). 
      118*
      119*     - id_list_ptr
      120*         This is a CONSTANT from p_id_list_ptr. 
      121*
      122*     - index_cursor_ptr
      123*         This is a CONSTANT from p_index_cursor_ptr. 
      124*
      125*     - key_buffer_length
      126*         This is a CONSTANT from  length(key_buffer). 
      127*
      128*     - key_buffer_ptr
      129*         This buffer holds the data string for the current leaf key.  This is
      130*       a CONSTANT from addr(key_buffer).
      131*
      132*     - last_key_id_string
      133*         This is SET by INITIALIZE_POSITION and DECREMENT_LAST_KEY_SLOT_INDEX. 
      134*
      135*     - lk_string_length
      136*         This is the length of the data string for the current leaf key. This
      137*       value is GENERATED by GET_KEY, RESET by RESET_KEY.  It depends on
      138*       slot_index.
      139*
      140*     - node_id
      141*         The current node id.  This value is SET by SET_NODE_ID, RESET by
      142*       RESET_NODE_ID. 
      143*
      144*     - node_ptr
      145*         The ptr to the current node.  This value is GENERATED by
      146*       GET_NODE_PTR, RESET by RESET_NODE_PTR.  It depends on node_id. 
      147*
      148*     - selected_vector_ptr
      149*         This points to a vector which contains only those fields listed by
      150*       p_id_list. This value is GENERATED by GET_SELECTED_VECTOR, RESET by
      151*       RESET_VECTORS.  It depends on key_buffer_contains_current_key.
      152*
      153*     - slot_index
      154*         This is the slot index of the current key.  This value is SET by
      155*       SET_SLOT_INDEX, RESET by RESET_SLOT_INDEX. 
      156*
      157*     - work_area_ptr
      158*         This is a CONSTANT from p_work_area_ptr. 
      159*
      160**/
      161 
      162 /* HISTORY:
      163*
      164*Written by Lindsey L. Spratt, 06/21/82.
      165*Modified:
      166*07/07/82 by Lindsey Spratt:  Added the use of the sequential_specification.
      167*	  Added the p_sequential_specification_ptr to the calling sequence.
      168*07/13/82 by Lindsey Spratt:  Added the p_range and p_range_type parameters.
      169*	  If p_range is greater than 0, then no more than p_range vectors
      170*	  will be put in the typed_vector_array (including any which may
      171*	  have already been present in the array).  If p_range_type equals
      172*	  HIGH_RANGE_TYPE, then the vectors will be taken from the high end
      173*	  of the given interval first (i.e., get_keys_in_reverse is turned
      174*	  on).
      175*08/06/82 by Lindsey Spratt:  Changed from im_add_keys_to_array to
      176*	  im_process_keys.  There are now two entry points, get and delete.
      177*	  A "get" switch was added to distinguish which entry was called.
      178*	  The delete entry invokes im_general_delete on all of the matching
      179*	  keys.
      180*08/09/82 by Matthew Pierret:  Removed offset and length arguments from calls
      181*            to collection_manager_$get_element.
      182*08/17/82 by Matthew Pierret:  Changed call to im_compare_sequential to call to
      183*            data_mgmt_util_$compare_sequential.
      184*08/19/82 by Lindsey Spratt:  Added the p_id_list_ptr parameter to the "get"
      185*	  call and passed the pointer on to the dmu_$cv_string_to_vector
      186*	  utility.
      187*08/26/82 by Lindsey Spratt:  Added the "position" entry.  Added the "delete"
      188*	  switch which , in combination with the "get" switch, distinguishes
      189*	  between the three entries, get, delete and position.
      190*	  Also, added setting of the index_cursor to the correct position.
      191*10/07/82 by Lindsey Spratt:  Changed to use the search_specification version
      192*	  2. Added the "count" entry.  Changes to all calling sequences.
      193*10/18/82 by Lindsey Spratt:  Fixed to create a "full" simple_typed_vector for
      194*	  the call to im_compare_subset, rather than use the p_id_list_ptr.
      195*	  This vector is freed when using the "get" entry and the
      196*	  p_id_list_ptr is not equal to null.
      197*10/19/82 by Lindsey Spratt:  Changed to get the last key positioned to, when
      198*	  executing the "position" entry and the last key positioned to was
      199*	  not gotten in the course of doing comparisons.  This is done so
      200*	  that the index_cursor.key_check_value can be set.
      201*10/21/82 by Lindsey Spratt:  Added code to implement the numeric specification.
      202*10/27/82 by Lindsey Spratt:  Changed KEY_LOOP to always initialize
      203*	  leaf_key_ptr to null, then for each place which needs to have the
      204*	  leaf_key value to check that leaf_key_ptr ^= null before using the
      205*	  value.  If it is null, then the value is
      206*	  retrieved at that time.
      207*10/29/82 by Lindsey Spratt:  Added updating of the key counts.  Changed the
      208*	  calling sequence of delete to include the pointer to the
      209*	  key_count_array.
      210*11/09/82 by Lindsey Spratt:  Removed the index_header_ptr from all entry
      211*	  sequences.  Changed to use new calling sequence of
      212*	  im_general_delete which does not use the index_header_ptr.
      213*12/09/82 by Lindsey Spratt:  Fixed to set the element_id_string when the
      214*	  leaf_key_ptr is null and the current key is supposed to be deleted.
      215*12/10/82 by Lindsey Spratt:  Fixed deletion to set the current_slot_index to 0
      216*	  after a successful deletion of the last key in the current
      217*	  ci.  The various positioning activities were changed to be
      218*	  cognizant of this protocol.
      219*01/20/83 by Matthew Pierret: Fixed to set p_typed_vector_array_ptr after
      220*            allocating a new typed_vector_array.
      221*02/28/83 by Lindsey Spratt:  Changed to use the new index_cursor (version 3)
      222*	  and the new im_set_cursor module for setting it.
      223*03/23/83 by Lindsey Spratt:  Changed to use version 2 of the field_table.
      224*	  Also, uppercased the internal procedure names.
      225*04/28/83 by Lindsey L. Spratt:  Fixed the AFTER_END routine to return true if
      226*            the current CI is the "last" one and the next key to be processed
      227*            is in the next CI.
      228*05/23/83 by Matthew Pierret: Changed to use version 4 of specification_head.
      229*            Split dm_specification.incl.pl1 into dm_specification_head,
      230*            dm_specification and dm_range_types.incl.pl1.
      231*11/07/83 by Lindsey L. Spratt:  Converted to use the buffered access method of
      232*            the collection_manager_.  Also, made minor changes to the coding
      233*            style including:  Added unique prefixes to all variables local to
      234*            an internal procedure; and, converted all error reporting to be
      235*            done through an internal procedure ERROR_RETURN, so that calls to
      236*            internal procedures only return when they are successful and no
      237*            code need be passed or checked by the caller.
      238*11/17/83 by Lindsey L. Spratt:  Fixed to put a modified node buffer after the
      239*            KEY_LOOP.
      240*11/28/83 by Lindsey L. Spratt:  Fixed to not replace the current ci/node when
      241*            the node is deleted.
      242*03/27/84 by Matthew Pierret:  Changed to get a pointer to the current ci/node
      243*            instead of setting up a buffer, and accessing it via 
      244*            collection_manager_$simple_get_element_ptr. Replaced 
      245*            SETUP_NODE_BUFFER with GET_NEW_NODE, which gets a pointer to a
      246*            ci/node and sets the value of the current node. Removed all
      247*            logic relating to replacing the node buffer (PUT_NODE_BUFFER,
      248*            current_node_has_been_modified) as modifications are now 
      249*            actually done by im_general_delete (and its subroutines).
      250*05/04/84 by Matthew Pierret:  Changed to use FIELD_TABLE_VERSION_3.  Chnaged
      251*            value of myname to be im_process_keys.
      252*05/10/84 by Matthew Pierret:  Changed to align key_buffer on an even-word
      253*            boundary.
      254*06/07/84 by Matthew Pierret:  Re-named cm_$simple_get_element_ptr to
      255*            cm_$simple_get_by_ci_ptr.
      256*10/02/84 by Lindsey L. Spratt:  Changed to have $get as the main entry point
      257*            (the proc statement label).  Changed a loop that was using
      258*            (vector_slot_index + 1) as its initial value for its loop index to
      259*            use the more meaningful (typed_vector_array.number_of_vectors +
      260*            1).
      261*10/17/84 by Lindsey L. Spratt:  Completely restructured the code.  Introduced
      262*	  the position_info structure, added many internal procedures, and
      263*	  added a great deal of documentation.
      264**/
      265 
      266 /* format: style2,ind3 */
      267 
      268 im_process_keys$get:
      269    proc (p_index_cursor_ptr, p_work_area_ptr, p_field_table_ptr, p_id_list_ptr, p_specification_ptr,
      270         p_and_group_id_list_ptr, p_number_of_fully_structural_fields, p_partial_structural_field_id,
      271         p_first_key_id_string, p_last_key_id_string, p_typed_vector_array_ptr, p_code);
      272 
      273 
      274 /* START OF DECLARATIONS */
      275 /* Parameter */
      276 
      277       dcl	    p_index_cursor_ptr     ptr parameter;
      278       dcl	    p_work_area_ptr	       ptr parameter;
      279       dcl	    p_field_table_ptr      ptr parameter;
      280       dcl	    p_id_list_ptr	       ptr parameter;
      281       dcl	    p_specification_ptr    ptr parameter;
      282       dcl	    p_and_group_id_list_ptr
      283 			       ptr parameter;
      284       dcl	    p_number_of_fully_structural_fields
      285 			       fixed bin (17);
      286       dcl	    p_partial_structural_field_id
      287 			       fixed bin (17);
      288       dcl	    p_first_key_id_string  bit (36) aligned parameter;
      289       dcl	    p_last_key_id_string   bit (36) aligned parameter;
      290       dcl	    p_typed_vector_array_ptr
      291 			       ptr parameter;
      292       dcl	    p_key_count_array_ptr  ptr parameter;
      293       dcl	    p_number_of_keys_accepted
      294 			       fixed bin (35) parameter;
      295       dcl	    p_code	       fixed bin (35) parameter;
      296 
      297 /* Automatic */
      298 
      299       dcl	    operation	       fixed bin init (0);
      300 
      301       dcl	    (number_of_keys_accepted, input_number_of_keys_accepted, position_count, range_size)
      302 			       fixed bin (35) init (0);
      303       dcl	    finished	       bit (1) aligned;
      304       dcl	    (get_keys_in_reverse_order, is_search_specification, key_satisfies_specification, set_cursor)
      305 			       bit (1) aligned init ("0"b);
      306       dcl	    key_count	       fixed bin (35);
      307       dcl	    1 local_leaf_ci_header like leaf_ci_header;
      308       dcl	    local_key_buffer       (DOUBLE_WORDS_PER_PAGE) fixed bin (71);
      309 						/* Forces even-word alignment */
      310 
      311       dcl	    global_position_info_ptr
      312 			       ptr init (null);
      313 
      314       dcl	    1 global_position_info aligned like position_info;
      315 
      316 
      317 /* Based */
      318 
      319       dcl	    1 position_info	       aligned based,
      320 	      2 entire_vector_ptr  ptr,
      321 	      2 field_table_ptr    ptr,
      322 	      2 first_key_id_string
      323 			       bit (36) aligned,
      324 	      2 flags	       aligned,
      325 	        3 header_buffer_contains_current_header
      326 			       bit (1) unaligned,
      327 	        3 key_buffer_contains_current_key
      328 			       bit (1) unaligned,
      329 	        3 node_is_deleted  bit (1) unaligned,
      330 	        3 vector_in_use    bit (1) unaligned,
      331 	        3 pad	       bit (32) unaligned,
      332 	      2 header_buffer_length
      333 			       fixed bin (35),
      334 	      2 header_buffer_ptr  ptr,
      335 	      2 id_list_ptr	       ptr,
      336 	      2 index_cursor_ptr   ptr,
      337 	      2 key_buffer_length  fixed bin (35),
      338 	      2 key_buffer_ptr     ptr,
      339 	      2 last_key_id_string bit (36) aligned,
      340 	      2 lk_string_length   fixed bin (35),
      341 	      2 node_id	       fixed bin (24) unsigned,
      342 	      2 node_ptr	       ptr,
      343 	      2 selected_vector_ptr
      344 			       ptr,
      345 	      2 slot_index	       fixed bin (12) unsigned,
      346 	      2 work_area_ptr      ptr;
      347 
      348       dcl	    key_buffer	       bit (BITS_PER_PAGE) aligned based (addr (local_key_buffer));
      349 
      350 /* Builtin */
      351 
      352       dcl	    (addr, abs, bin, divide, length, null, string, unspec)
      353 			       builtin;
      354 
      355 /* Constant */
      356 
      357       dcl	    myname	       init ("im_process_keys") char (32) varying internal static options (constant);
      358 
      359       dcl	    NULL_PSEUDO_FIELD_VALUE
      360 			       init ("0"b) bit (36) internal static options (constant);
      361       dcl	    IS_BEING_DELETED       init ("0"b) bit (1) aligned internal static options (constant);
      362 
      363       dcl	    (
      364 	    COUNT_OPERATION	       init (1),
      365 	    DELETE_OPERATION       init (2),
      366 	    GET_OPERATION	       init (3),
      367 	    POSITION_OPERATION     init (4),
      368 	    BITS_PER_BYTE	       init (9),
      369 	    BITS_PER_PAGE	       init (1024 * 36),
      370 	    DOUBLE_WORDS_PER_PAGE  init (512),
      371 	    VECTOR_SLOT_PAD	       init (100),
      372 	    LIMIT_TO_STOP_INFINITE_LOOPING
      373 			       init (1e6)
      374 	    )		       fixed bin (35) internal static options (constant);
      375 
      376 /* Entry */
      377 
      378       dcl	    hash_index_	       entry (ptr, fixed bin (35), fixed bin (35), fixed bin (35)) returns (fixed bin (35));
      379 
      380       dcl	    im_general_delete      entry (ptr, ptr, ptr, bit (36) aligned, bit (1) aligned, fixed bin (35));
      381       dcl	    im_compare_subset      entry (ptr, ptr, ptr, bit (1) aligned, bit (*), fixed bin (35));
      382       dcl	    im_update_key_counts   entry (ptr, ptr, ptr, ptr, bit (1) aligned, ptr, bit (36) aligned, ptr,
      383 			       fixed bin (35), ptr, fixed bin (35));
      384 
      385       dcl	    im_set_cursor$at_current
      386 			       entry (ptr, bit (36) aligned, ptr, fixed bin (24), fixed bin (35));
      387       dcl	    im_set_cursor$no_current
      388 			       entry (ptr, bit (36) aligned, ptr, fixed bin (24), fixed bin (35));
      389       dcl	    im_set_cursor$at_beginning
      390 			       entry (ptr, bit (36) aligned, ptr, fixed bin (24), fixed bin (35));
      391       dcl	    im_set_cursor$at_end   entry (ptr, bit (36) aligned, ptr, fixed bin (24), fixed bin (35));
      392 
      393       dcl	    data_format_util_$compare_sequential
      394 			       entry (ptr, ptr, ptr, fixed bin (17), fixed bin (17), bit (*), bit (1) aligned,
      395 			       fixed bin (35));
      396       dcl	    sub_err_	       entry options (variable);
      397       dcl	    data_format_util_$cv_string_to_vector
      398 			       entry (ptr, ptr, ptr, fixed bin (35), ptr, ptr, fixed bin (35));
      399 
      400 /* External */
      401 
      402       dcl	    (
      403 	    error_table_$unimplemented_version,
      404 	    dm_error_$wrong_cursor_type,
      405 	    dm_error_$bad_first_key_idx,
      406 	    dm_error_$bad_last_key_idx,
      407 	    dm_error_$bad_leaf_node,
      408 	    dm_error_$programming_error
      409 	    )		       fixed bin (35) ext;
      410 
      411 
      412 /* END OF DECLARATIONS */
      413 
      414 /* The main entry is - 
      415*get:
      416*   entry (p_index_cursor_ptr, p_work_area_ptr, p_field_table_ptr, p_id_list_ptr, p_specification_ptr,
      417*      p_and_group_id_list_ptr, p_number_of_fully_structural_fields, p_partial_structural_field_id, p_first_key_id_string,
      418*      p_last_key_id_string, p_typed_vector_array_ptr, p_code);
      419**/
      420 
      421       operation = GET_OPERATION;
      422       typed_vector_array_ptr = p_typed_vector_array_ptr;
      423       call CHECK_VERSION ((typed_vector_array.version), (TYPED_VECTOR_ARRAY_VERSION_2), "typed_vector_array");
      424       goto JOIN;
      425 
      426 position:
      427    entry (p_index_cursor_ptr, p_work_area_ptr, p_field_table_ptr, p_specification_ptr, p_and_group_id_list_ptr,
      428         p_number_of_fully_structural_fields, p_partial_structural_field_id, p_first_key_id_string, p_last_key_id_string,
      429         p_number_of_keys_accepted, p_code);
      430 
      431       operation = POSITION_OPERATION;
      432       typed_vector_array_ptr = null;
      433       goto JOIN;
      434 
      435 delete:
      436    entry (p_index_cursor_ptr, p_work_area_ptr, p_field_table_ptr, p_specification_ptr, p_and_group_id_list_ptr,
      437         p_number_of_fully_structural_fields, p_partial_structural_field_id, p_first_key_id_string, p_last_key_id_string,
      438         p_key_count_array_ptr, p_number_of_keys_accepted, p_code);
      439       operation = DELETE_OPERATION;
      440       typed_vector_array_ptr = null;
      441       goto JOIN;
      442 
      443 count:
      444    entry (p_index_cursor_ptr, p_work_area_ptr, p_field_table_ptr, p_specification_ptr, p_and_group_id_list_ptr,
      445         p_number_of_fully_structural_fields, p_partial_structural_field_id, p_first_key_id_string, p_last_key_id_string,
      446         p_number_of_keys_accepted, p_code);
      447 
      448       operation = COUNT_OPERATION;
      449       typed_vector_array_ptr = null;
      450       goto JOIN;
      451 
      452 /*   The operation of the top level of this program (starting with JOIN), is as
      453*     follows:
      454*
      455*     - Set up the global data (copied from the parameters, largely), and
      456*       initialize various control variables based on the specification.
      457*     - For a numeric_specification, make the current position whatever the spec
      458*       says.
      459*
      460*     - Find all of the keys between the current position and the end of the
      461*       interval (last_key_id, if getting keys in forward order, first_key_id if
      462*       getting keys in reverse order).
      463*     - For each of these keys, check against the "filters" (the search_spec and
      464*       the subset_spec).
      465*     - For the keys which pass the filter, do the operation appropriate to the
      466*       external entry (ADD_KEY_TO_OUTPUT for get, DELETE_KEY_FROM_INDEX for 
      467*       delete, others just need to have the accepted-keys count incremented).
      468*
      469*     - Finally, prepare for returning to the caller by setting the output
      470*     parameters as appropriate.
      471**/
      472 
      473 JOIN:
      474       p_code = 0;
      475       index_cursor_ptr = p_index_cursor_ptr;
      476       if index_cursor.type ^= INDEX_CURSOR_TYPE
      477       then call sub_err_ (dm_error_$wrong_cursor_type, myname, "s", null, 0,
      478 	      "^/Expected an index cursor, type ^d. Received a cursor of type ^d.", INDEX_CURSOR_TYPE,
      479 	      index_cursor.type);
      480 
      481       call CHECK_VERSION ((index_cursor.version), (INDEX_CURSOR_VERSION_3), "index_cursor");
      482 
      483       specification_head_ptr = p_specification_ptr;
      484       call CHECK_VERSION (specification_head.version, SPECIFICATION_VERSION_4, "specification");
      485 
      486 
      487       field_table_ptr = p_field_table_ptr;
      488       call CHECK_VERSION_CHAR (field_table.version, FIELD_TABLE_VERSION_3, "field_table");
      489 
      490       call INTERPRET_SPECIFICATION (p_specification_ptr, p_first_key_id_string, is_search_specification,
      491 	 search_specification_ptr, numeric_specification_ptr, get_keys_in_reverse_order, range_size, position_count);
      492 
      493       global_position_info_ptr = addr (global_position_info);
      494 
      495       call INITIALIZE_POSITION (index_cursor_ptr, addr (local_leaf_ci_header), length (unspec (local_leaf_ci_header)),
      496 	 addr (key_buffer), length (key_buffer), field_table_ptr, p_work_area_ptr, p_first_key_id_string,
      497 	 p_last_key_id_string, p_id_list_ptr, get_keys_in_reverse_order, global_position_info_ptr);
      498 
      499 
      500       if operation = GET_OPERATION
      501       then number_of_keys_accepted, input_number_of_keys_accepted = typed_vector_array.number_of_vectors;
      502       else number_of_keys_accepted, input_number_of_keys_accepted = p_number_of_keys_accepted;
      503 
      504       finished = "0"b;
      505 
      506       if ^is_search_specification
      507       then call FIND_POSITION (get_keys_in_reverse_order, global_position_info_ptr, position_count, finished);
      508 
      509 KEY_LOOP:
      510       do key_count = 1 to LIMIT_TO_STOP_INFINITE_LOOPING while (^finished);
      511 
      512          if is_search_specification
      513          then call SEARCH_SPEC_COMPARISON (search_specification_ptr, p_and_group_id_list_ptr,
      514 	         p_number_of_fully_structural_fields, p_partial_structural_field_id, global_position_info_ptr,
      515 	         key_satisfies_specification);
      516          else key_satisfies_specification = "1"b;
      517 
      518          if key_satisfies_specification & specification_head.subset_specification_ptr ^= null
      519          then call SUBSET_SPEC_COMPARISON (specification_head.subset_specification_ptr, global_position_info_ptr,
      520 	         key_satisfies_specification);
      521 
      522 
      523          if key_satisfies_specification
      524          then
      525 	  do;
      526 	     set_cursor = "1"b;
      527 	     if operation = GET_OPERATION
      528 	     then call ADD_KEY_TO_OUTPUT (global_position_info_ptr, typed_vector_array_ptr, number_of_keys_accepted);
      529 	     else if operation = DELETE_OPERATION
      530 	     then call DELETE_KEY_FROM_INDEX (get_keys_in_reverse_order, global_position_info_ptr,
      531 		     number_of_keys_accepted, p_key_count_array_ptr);
      532 	     else number_of_keys_accepted = number_of_keys_accepted + 1;
      533 	  end;
      534 
      535 
      536          call SETUP_NEXT_KEY (operation, is_search_specification, range_size, get_keys_in_reverse_order,
      537 	    key_satisfies_specification, global_position_info_ptr, number_of_keys_accepted, finished);
      538 
      539       end KEY_LOOP;
      540 
      541       if key_count > LIMIT_TO_STOP_INFINITE_LOOPING
      542       then call sub_err_ (dm_error_$programming_error, myname, ACTION_CANT_RESTART, null, 0,
      543 	      "^/This program was apparently infinitely looping processing a range of keys.
      544 This either indicates a damaged index or an internal programming logic problem.
      545 The first key id is ^.3b, and the last key id is ^.3b.", p_first_key_id_string, p_last_key_id_string);
      546 
      547       if operation = GET_OPERATION
      548       then
      549          do;
      550 	  if get_keys_in_reverse_order
      551 	  then call REVERSE_VECTOR_SLOTS (input_number_of_keys_accepted, typed_vector_array_ptr);
      552 	  p_typed_vector_array_ptr = typed_vector_array_ptr;
      553          end;
      554       else p_number_of_keys_accepted = number_of_keys_accepted;
      555 
      556 
      557       if set_cursor
      558       then call SET_INDEX_CURSOR (operation, global_position_info_ptr);
      559 
      560 MAIN_RETURN:
      561       return;
      562 
      563 
      564 
      565 FINISH:
      566    proc ();
      567    end;
      568 
      569 ERROR_RETURN:
      570    proc (er_p_code);
      571       dcl	    er_p_code	       fixed bin (35);
      572       p_code = er_p_code;
      573       call FINISH;
      574       goto MAIN_RETURN;
      575    end ERROR_RETURN;
      576 
      577 
      578 ADD_KEY_TO_OUTPUT:
      579    proc (akto_p_position_info_ptr, akto_p_typed_vector_array_ptr, akto_p_number_of_keys_accepted);
      580 
      581       dcl	    akto_p_position_info_ptr
      582 			       ptr parameter;
      583       dcl	    akto_p_typed_vector_array_ptr
      584 			       ptr parameter;
      585       dcl	    akto_p_number_of_keys_accepted
      586 			       fixed bin (35) parameter;
      587 
      588       dcl	    akto_code	       fixed bin (35) init (0);
      589       dcl	    akto_new_tva_ptr       ptr init (null);
      590       dcl	    akto_old_tva_ptr       ptr init (null);
      591       dcl	    akto_vector_ptr	       ptr;
      592       dcl	    akto_vector_slot_idx   fixed bin;
      593       dcl	    akto_work_area	       area based (akto_work_area_ptr);
      594       dcl	    akto_work_area_ptr     ptr init (null);
      595 
      596 
      597       call GET_SELECTED_VECTOR (akto_p_position_info_ptr, akto_vector_ptr);
      598 
      599       akto_p_typed_vector_array_ptr -> typed_vector_array.number_of_vectors =
      600 	 akto_p_typed_vector_array_ptr -> typed_vector_array.number_of_vectors + 1;
      601       if akto_p_typed_vector_array_ptr -> typed_vector_array.number_of_vectors
      602 	 <= akto_p_typed_vector_array_ptr -> typed_vector_array.number_of_vector_slots
      603       then akto_p_typed_vector_array_ptr
      604 	      -> typed_vector_array
      605 	      .vector_slot (akto_p_typed_vector_array_ptr -> typed_vector_array.number_of_vectors) = akto_vector_ptr;
      606       else
      607          do;
      608 	  call GET_WORK_AREA (akto_p_position_info_ptr, akto_work_area_ptr);
      609 	  tva_number_of_vector_slots =
      610 	       akto_p_typed_vector_array_ptr -> typed_vector_array.number_of_vectors + VECTOR_SLOT_PAD;
      611 	  tva_number_of_dimensions = akto_p_typed_vector_array_ptr -> typed_vector_array.number_of_dimensions;
      612 	  tva_maximum_dimension_name_length =
      613 	       akto_p_typed_vector_array_ptr -> typed_vector_array.maximum_dimension_name_length;
      614 
      615 	  akto_old_tva_ptr = akto_p_typed_vector_array_ptr;
      616 
      617 	  alloc typed_vector_array in (akto_work_area) set (akto_new_tva_ptr);
      618 
      619 	  akto_new_tva_ptr -> typed_vector_array.version = TYPED_VECTOR_ARRAY_VERSION_2;
      620 	  akto_new_tva_ptr -> typed_vector_array.number_of_vectors =
      621 	       akto_old_tva_ptr -> typed_vector_array.number_of_vectors;
      622 	  akto_new_tva_ptr -> typed_vector_array.dimension_table =
      623 	       akto_old_tva_ptr -> typed_vector_array.dimension_table;
      624 	  do akto_vector_slot_idx = 1 to akto_new_tva_ptr -> typed_vector_array.number_of_vectors - 1;
      625 	     akto_new_tva_ptr -> typed_vector_array.vector_slot (akto_vector_slot_idx) =
      626 		akto_old_tva_ptr -> typed_vector_array.vector_slot (akto_vector_slot_idx);
      627 	  end;
      628 	  akto_new_tva_ptr
      629 	       -> typed_vector_array.vector_slot (akto_new_tva_ptr -> typed_vector_array.number_of_vectors) =
      630 	       akto_vector_ptr;
      631 	  do akto_vector_slot_idx = akto_new_tva_ptr -> typed_vector_array.number_of_vectors + 1
      632 	       to akto_new_tva_ptr -> typed_vector_array.number_of_vector_slots;
      633 	     akto_new_tva_ptr -> typed_vector_array.vector_slot (akto_vector_slot_idx) = null;
      634 	  end;
      635 	  free akto_old_tva_ptr -> typed_vector_array in (akto_work_area);
      636 	  akto_p_typed_vector_array_ptr = akto_new_tva_ptr;
      637          end;
      638       akto_p_number_of_keys_accepted = akto_p_typed_vector_array_ptr -> typed_vector_array.number_of_vectors;
      639 
      640       call NOTE_VECTOR_IN_USE (akto_p_position_info_ptr);
      641    end ADD_KEY_TO_OUTPUT;
      642 
      643 AFTER_END:
      644    proc (ae_p_position_info_ptr, ae_p_ci, ae_p_index) returns (bit (1) aligned);
      645       dcl	    ae_p_position_info_ptr ptr parameter;
      646       dcl	    ae_p_ci	       fixed bin (24) unsigned parameter;
      647       dcl	    ae_p_index	       fixed bin (12) unsigned parameter;
      648 
      649       dcl	    1 ae_last_key_id       based (addr (ae_last_key_id_string)) like element_id;
      650       dcl	    ae_last_key_id_string  bit (36) aligned;
      651       dcl	    1 ae_leaf_ci_header    based (ae_leaf_ci_header_ptr) like leaf_ci_header;
      652       dcl	    ae_leaf_ci_header_ptr  ptr;
      653 
      654       call GET_CI_HEADER (ae_p_position_info_ptr, ae_leaf_ci_header_ptr);
      655       call GET_LAST_KEY_ID (ae_p_position_info_ptr, ae_last_key_id_string);
      656 
      657       return ((ae_p_ci = ae_last_key_id.control_interval_id & (ae_p_index > ae_last_key_id.index | ae_p_index = 0))
      658 	 | ((ae_p_index = 0 | ae_p_index > ae_leaf_ci_header.common.key_range.last)
      659 	 & ae_leaf_ci_header.common.next_id = 0));	/* ae_p_index = 0 indicates that the current ci is empty. */
      660    end AFTER_END;
      661 
      662 BEFORE_BEGINNING:
      663    proc (bb_p_position_info_ptr, bb_p_ci, bb_p_index) returns (bit (1) aligned);
      664       dcl	    bb_p_position_info_ptr ptr parameter;
      665       dcl	    bb_p_ci	       fixed bin (24) unsigned parameter;
      666       dcl	    bb_p_index	       fixed bin (12) unsigned parameter;
      667 
      668       dcl	    1 bb_first_key_id      based (addr (bb_first_key_id_string)) like element_id;
      669       dcl	    bb_first_key_id_string bit (36) aligned;
      670       dcl	    1 bb_leaf_ci_header    based (bb_leaf_ci_header_ptr) like leaf_ci_header;
      671       dcl	    bb_leaf_ci_header_ptr  ptr;
      672 
      673       call GET_CI_HEADER (bb_p_position_info_ptr, bb_leaf_ci_header_ptr);
      674       call GET_FIRST_KEY_ID (bb_p_position_info_ptr, bb_first_key_id_string);
      675 
      676       return ((bb_p_ci = bb_first_key_id.control_interval_id & bb_p_index < bb_first_key_id.index)
      677 	 | (bb_leaf_ci_header.common.previous_id = 0 & bb_leaf_ci_header.common.key_range.first > bb_p_index));
      678 
      679    end BEFORE_BEGINNING;
      680 
      681 CHECK_VERSION:
      682    proc (cv_p_received_version, cv_p_expected_version, cv_p_structure_name);
      683 
      684       dcl	    cv_p_received_version  fixed bin (35);
      685       dcl	    cv_p_expected_version  fixed bin (35);
      686       dcl	    cv_p_structure_name    char (*);
      687 
      688       if cv_p_received_version ^= cv_p_expected_version
      689       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      690 	      "^/Expected version ^d of the ^a structure.
      691 Received version ^d, instead.", cv_p_expected_version, cv_p_structure_name, cv_p_received_version);
      692 
      693    end CHECK_VERSION;
      694 
      695 CHECK_VERSION_CHAR:
      696    proc (cvc_p_expected_version, cvc_p_received_version, cvc_p_structure_name);
      697       dcl	    (cvc_p_expected_version, cvc_p_received_version)
      698 			       char (8) aligned;
      699       dcl	    cvc_p_structure_name   char (*) parameter;
      700 
      701       if cvc_p_expected_version ^= cvc_p_received_version
      702       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      703 	      "^/Expected version ^a of the ^a structure.  
      704 Received version ^a, instead.", cvc_p_expected_version, cvc_p_structure_name, cvc_p_received_version);
      705    end CHECK_VERSION_CHAR;
      706 
      707 DECREMENT_LAST_KEY_SLOT_INDEX:
      708    proc (dlksi_p_position_info_ptr);
      709       dcl	    dlksi_p_position_info_ptr
      710 			       ptr parameter;
      711       dcl	    1 dlksi_p_position_info
      712 			       based (dlksi_p_position_info_ptr) aligned like position_info;
      713 
      714       addr (dlksi_p_position_info.last_key_id_string) -> element_id.index =
      715 	 addr (dlksi_p_position_info.last_key_id_string) -> element_id.index - 1;
      716 
      717    end DECREMENT_LAST_KEY_SLOT_INDEX;
      718 
      719 
      720 
      721 
      722 DELETE_KEY_FROM_INDEX:
      723    proc (dkfi_p_get_keys_in_reverse_order, dkfi_p_position_info_ptr, dkfi_p_number_of_keys_accepted,
      724         dkfi_p_key_count_array_ptr);
      725 
      726       dcl	    dkfi_p_get_keys_in_reverse_order
      727 			       bit (1) aligned parameter;
      728       dcl	    dkfi_p_position_info_ptr
      729 			       ptr parameter;
      730       dcl	    dkfi_p_number_of_keys_accepted
      731 			       fixed bin (35) parameter;
      732       dcl	    dkfi_p_key_count_array_ptr
      733 			       ptr parameter;
      734 
      735 
      736       dcl	    dkfi_code	       fixed bin (35) init (0);
      737       dcl	    dkfi_deleted_node      bit (1) aligned init ("0"b);
      738       dcl	    1 dkfi_element_id      based (addr (dkfi_element_id_string)) like element_id;
      739       dcl	    dkfi_element_id_string bit (36) aligned;
      740       dcl	    dkfi_field_table_ptr   ptr;
      741       dcl	    dkfi_index_cursor_ptr  ptr;
      742       dcl	    1 dkfi_last_key_id     based (addr (dkfi_last_key_id_string)) like element_id;
      743       dcl	    dkfi_last_key_id_string
      744 			       bit (36) aligned;
      745       dcl	    dkfi_leaf_ci_header_ptr
      746 			       ptr;
      747       dcl	    dkfi_leaf_key_ptr      ptr;
      748       dcl	    dkfi_lk_string_length  fixed bin (35);
      749       dcl	    dkfi_node_id	       fixed bin (24) unsigned;
      750       dcl	    dkfi_node_ptr	       ptr;
      751       dcl	    dkfi_slot_index	       fixed bin (12) unsigned;
      752       dcl	    dkfi_work_area_ptr     ptr;
      753 
      754       call GET_WORK_AREA (dkfi_p_position_info_ptr, dkfi_work_area_ptr);
      755       call GET_FIELD_TABLE (dkfi_p_position_info_ptr, dkfi_field_table_ptr);
      756       call GET_INDEX_CURSOR (dkfi_p_position_info_ptr, dkfi_index_cursor_ptr);
      757       call GET_CI_HEADER (dkfi_p_position_info_ptr, dkfi_leaf_ci_header_ptr);
      758       call GET_NODE_ID (dkfi_p_position_info_ptr, dkfi_node_id);
      759       call GET_NODE_PTR (dkfi_p_position_info_ptr, dkfi_node_ptr);
      760       call GET_SLOT_INDEX (dkfi_p_position_info_ptr, dkfi_slot_index);
      761       call GET_KEY (dkfi_p_position_info_ptr, dkfi_leaf_key_ptr, dkfi_lk_string_length);
      762       call GET_LAST_KEY_ID (dkfi_p_position_info_ptr, dkfi_last_key_id_string);
      763 
      764       dkfi_element_id.control_interval_id = dkfi_node_id;
      765       dkfi_element_id.index = dkfi_slot_index;
      766 
      767       call im_update_key_counts (dkfi_node_ptr, dkfi_index_cursor_ptr, dkfi_work_area_ptr, dkfi_field_table_ptr,
      768 	 IS_BEING_DELETED, dkfi_leaf_ci_header_ptr, dkfi_element_id_string, dkfi_leaf_key_ptr, dkfi_lk_string_length,
      769 	 dkfi_p_key_count_array_ptr, dkfi_code);
      770       if dkfi_code ^= 0
      771       then call ERROR_RETURN (dkfi_code);
      772 
      773       dkfi_p_number_of_keys_accepted = dkfi_p_number_of_keys_accepted + 1;
      774 
      775       call im_general_delete (dkfi_node_ptr, dkfi_index_cursor_ptr, dkfi_leaf_ci_header_ptr, dkfi_element_id_string,
      776 	 dkfi_deleted_node, dkfi_code);		/* This modifies the contents of the control interval */
      777 						/* at which dkfi_p_current_node_ptr points. */
      778       if dkfi_code ^= 0
      779       then call ERROR_RETURN (dkfi_code);
      780 
      781       if dkfi_deleted_node
      782       then call NOTE_NODE_IS_DELETED (dkfi_p_position_info_ptr);
      783 
      784 
      785       if dkfi_last_key_id.control_interval_id = dkfi_node_id & ^dkfi_p_get_keys_in_reverse_order
      786       then call DECREMENT_LAST_KEY_SLOT_INDEX (dkfi_p_position_info_ptr);
      787    end DELETE_KEY_FROM_INDEX;
      788 
      789 FIND_POSITION:
      790    proc (fp_p_get_keys_in_reverse_order, fp_p_position_info_ptr, fp_p_position_count, fp_p_finished);
      791 
      792       dcl	    fp_p_get_keys_in_reverse_order
      793 			       bit (1) aligned parameter;
      794       dcl	    fp_p_position_info_ptr ptr parameter;
      795       dcl	    fp_p_position_count    fixed bin (35) parameter;
      796       dcl	    fp_p_finished	       bit (1) aligned parameter;
      797 
      798 
      799       dcl	    1 fp_leaf_ci_header    based (fp_leaf_ci_header_ptr) like leaf_ci_header;
      800       dcl	    fp_leaf_ci_header_ptr  ptr;
      801       dcl	    fp_node_id	       fixed bin (24) unsigned;
      802       dcl	    fp_position_change     fixed bin (35) init (0);
      803       dcl	    fp_slot_index	       fixed bin (12) unsigned;
      804 
      805       call GET_NODE_ID (fp_p_position_info_ptr, fp_node_id);
      806       call GET_CI_HEADER (fp_p_position_info_ptr, fp_leaf_ci_header_ptr);
      807       call GET_SLOT_INDEX (fp_p_position_info_ptr, fp_slot_index);
      808 
      809       if fp_p_get_keys_in_reverse_order
      810       then
      811          do;
      812 	  fp_position_change = fp_p_position_count;	/* Try to move the entire distance. */
      813 	  if BEFORE_BEGINNING (fp_p_position_info_ptr, fp_node_id, fp_slot_index - fp_position_change)
      814 	  then fp_p_finished = "1"b;
      815 	  else if fp_slot_index - fp_position_change >= fp_leaf_ci_header.common.key_range.first
      816 	  then call SET_SLOT_INDEX (fp_slot_index - fp_position_change, fp_p_position_info_ptr);
      817 	  else
      818 	     do;
      819 	        do while (^BEFORE_BEGINNING (fp_p_position_info_ptr, fp_node_id, fp_slot_index - fp_position_change)
      820 		   & (fp_slot_index - fp_position_change < fp_leaf_ci_header.common.key_range.first));
      821 		 fp_position_change =
      822 		      fp_position_change - (fp_slot_index - fp_leaf_ci_header.common.key_range.first + 1);
      823 
      824 		 fp_node_id = fp_leaf_ci_header.common.previous_id;
      825 		 call SET_NODE_ID (fp_node_id, fp_p_position_info_ptr);
      826 
      827 		 call GET_CI_HEADER (fp_p_position_info_ptr, fp_leaf_ci_header_ptr);
      828 		 fp_slot_index = fp_leaf_ci_header.common.key_range.last;
      829 	        end;
      830 	        call SET_SLOT_INDEX (fp_slot_index, fp_p_position_info_ptr);
      831 	        if BEFORE_BEGINNING (fp_p_position_info_ptr, fp_node_id, fp_slot_index - fp_position_change)
      832 	        then fp_p_finished = "1"b;
      833 	        else
      834 		 do;
      835 		    fp_p_position_count = 0;
      836 		    fp_slot_index = fp_slot_index - fp_position_change;
      837 		    call SET_SLOT_INDEX (fp_slot_index, fp_p_position_info_ptr);
      838 		 end;
      839 	     end;
      840          end;
      841       else
      842          do;
      843 	  fp_position_change = fp_p_position_count;
      844 	  if AFTER_END (fp_p_position_info_ptr, fp_node_id, fp_slot_index + fp_position_change)
      845 	  then fp_p_finished = "1"b;
      846 	  else if fp_slot_index + fp_position_change <= fp_leaf_ci_header.common.key_range.last
      847 	  then call SET_SLOT_INDEX (fp_slot_index + fp_position_change, fp_p_position_info_ptr);
      848 	  else
      849 	     do;
      850 	        do while (^AFTER_END (fp_p_position_info_ptr, fp_node_id, fp_slot_index + fp_position_change)
      851 		   & (fp_slot_index + fp_position_change > fp_leaf_ci_header.common.key_range.last));
      852 		 fp_position_change =
      853 		      fp_position_change - (fp_leaf_ci_header.common.key_range.last - fp_slot_index + 1);
      854 
      855 		 fp_node_id = fp_leaf_ci_header.common.next_id;
      856 		 call SET_NODE_ID (fp_node_id, fp_p_position_info_ptr);
      857 
      858 		 call GET_CI_HEADER (fp_p_position_info_ptr, fp_leaf_ci_header_ptr);
      859 		 fp_slot_index = fp_leaf_ci_header.common.key_range.first;
      860 	        end;
      861 	        call SET_SLOT_INDEX (fp_slot_index, fp_p_position_info_ptr);
      862 
      863 	        if AFTER_END (fp_p_position_info_ptr, fp_node_id, fp_slot_index + fp_position_change)
      864 	        then fp_p_finished = "1"b;
      865 	        else
      866 		 do;
      867 		    fp_slot_index = fp_slot_index + fp_position_change;
      868 		    call SET_SLOT_INDEX (fp_slot_index, fp_p_position_info_ptr);
      869 		 end;
      870 	     end;
      871 	  fp_p_position_count = 0;
      872          end;
      873 
      874    end FIND_POSITION;
      875 
      876 FREE_ENTIRE_VECTOR:
      877    proc (fev_p_vector_ptr);
      878       dcl	    fev_p_vector_ptr       ptr parameter;
      879 
      880       dcl	    fev_based_dummy	       fixed bin based;
      881       dcl	    fev_dimension_idx      fixed bin (35) init (0);
      882 
      883       do fev_dimension_idx = 1 to fev_p_vector_ptr -> simple_typed_vector.number_of_dimensions;
      884          free fev_p_vector_ptr -> simple_typed_vector.dimension (fev_dimension_idx).value_ptr -> fev_based_dummy;
      885       end;
      886       free fev_p_vector_ptr -> simple_typed_vector;
      887       fev_p_vector_ptr = null;
      888 
      889    end FREE_ENTIRE_VECTOR;
      890 
      891 
      892 
      893 
      894 GET_CI_HEADER:
      895    proc (gch_p_position_info_ptr, gch_p_leaf_ci_header_ptr);
      896       dcl	    gch_p_position_info_ptr
      897 			       ptr parameter;
      898       dcl	    gch_p_leaf_ci_header_ptr
      899 			       ptr parameter;
      900 
      901       dcl	    gch_code	       fixed bin (35) init (0);
      902       dcl	    gch_collection_id      bit (36) aligned;
      903       dcl	    1 gch_element_id       aligned based (addr (gch_element_id_string)) like element_id;
      904       dcl	    gch_element_id_string  bit (36) aligned;
      905       dcl	    gch_node_id	       fixed bin (24) unsigned;
      906       dcl	    gch_node_ptr	       ptr;
      907       dcl	    1 gch_p_position_info  based (gch_p_position_info_ptr) aligned like position_info;
      908 
      909       if ^gch_p_position_info.header_buffer_contains_current_header
      910       then
      911          do;
      912 	  call GET_COLLECTION_ID (gch_p_position_info_ptr, gch_collection_id);
      913 	  call GET_NODE_ID (gch_p_position_info_ptr, gch_node_id);
      914 	  call GET_NODE_PTR (gch_p_position_info_ptr, gch_node_ptr);
      915 
      916 	  gch_element_id.control_interval_id = gch_node_id;
      917 	  gch_element_id.index = DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT;
      918 
      919 	  call collection_manager_$simple_get_by_ci_ptr (gch_node_ptr, gch_collection_id, gch_element_id_string,
      920 	       gch_p_position_info.header_buffer_ptr, gch_p_position_info.header_buffer_length, (0), gch_code);
      921 	  if gch_code ^= 0
      922 	  then call ERROR_RETURN (gch_code);
      923 	  if ^gch_p_position_info.header_buffer_ptr -> common_ci_header.is_leaf
      924 	  then call ERROR_RETURN (dm_error_$bad_leaf_node);
      925 	  else if gch_p_position_info.header_buffer_ptr -> leaf_ci_header.common.key_range.first < 0
      926 	  then call ERROR_RETURN (dm_error_$bad_first_key_idx);
      927 	  else if gch_p_position_info.header_buffer_ptr -> leaf_ci_header.common.key_range.last
      928 		  < gch_p_position_info.header_buffer_ptr -> leaf_ci_header.common.key_range.first
      929 	  then call ERROR_RETURN (dm_error_$bad_last_key_idx);
      930 	  gch_p_position_info.header_buffer_contains_current_header = "1"b;
      931          end;
      932       gch_p_leaf_ci_header_ptr = gch_p_position_info.header_buffer_ptr;
      933 
      934       return;
      935    end GET_CI_HEADER;
      936 
      937 GET_COLLECTION_ID:
      938    proc (gci_p_position_info_ptr, gci_p_collection_id);
      939       dcl	    gci_p_position_info_ptr
      940 			       ptr parameter;
      941       dcl	    gci_p_collection_id    bit (36) aligned parameter;
      942 
      943       gci_p_collection_id = gci_p_position_info_ptr -> position_info.index_cursor_ptr -> index_cursor.collection_id;
      944 
      945    end GET_COLLECTION_ID;
      946 
      947 
      948 
      949 GET_ENTIRE_VECTOR:
      950    proc (gev_p_position_info_ptr, gev_p_vector_ptr);
      951       dcl	    gev_p_position_info_ptr
      952 			       ptr parameter;
      953       dcl	    gev_p_vector_ptr       ptr parameter;
      954 
      955       dcl	    1 gev_p_position_info  aligned based (gev_p_position_info_ptr) like position_info;
      956 
      957       dcl	    gev_code	       fixed bin (35);
      958       dcl	    gev_field_table_ptr    ptr;
      959       dcl	    gev_leaf_key_ptr       ptr;
      960       dcl	    gev_lk_string_length   fixed bin (35);
      961       dcl	    gev_work_area_ptr      ptr;
      962 
      963       if gev_p_position_info.entire_vector_ptr = null
      964       then
      965          do;
      966 
      967 	  call GET_KEY (gev_p_position_info_ptr, gev_leaf_key_ptr, gev_lk_string_length);
      968 	  call GET_FIELD_TABLE (gev_p_position_info_ptr, gev_field_table_ptr);
      969 	  call GET_WORK_AREA (gev_p_position_info_ptr, gev_work_area_ptr);
      970 
      971 	  call data_format_util_$cv_string_to_vector (gev_field_table_ptr, gev_work_area_ptr, gev_leaf_key_ptr,
      972 	       gev_lk_string_length, null (), gev_p_position_info.entire_vector_ptr, gev_code);
      973 	  if gev_code ^= 0
      974 	  then call ERROR_RETURN (gev_code);
      975 
      976          end;
      977       gev_p_vector_ptr = gev_p_position_info.entire_vector_ptr;
      978 
      979    end GET_ENTIRE_VECTOR;
      980 
      981 GET_FIELD_TABLE:
      982    proc (gft_p_position_info_ptr, gft_p_field_table_ptr);
      983       dcl	    gft_p_position_info_ptr
      984 			       ptr parameter;
      985       dcl	    gft_p_field_table_ptr  ptr parameter;
      986 
      987       gft_p_field_table_ptr = gft_p_position_info_ptr -> position_info.field_table_ptr;
      988 
      989    end GET_FIELD_TABLE;
      990 
      991 
      992 GET_FILE_OPENING_ID:
      993    proc (gfoi_p_position_info_ptr, gfoi_p_file_opening_id);
      994       dcl	    gfoi_p_position_info_ptr
      995 			       ptr parameter;
      996       dcl	    gfoi_p_file_opening_id bit (36) aligned parameter;
      997 
      998       gfoi_p_file_opening_id = gfoi_p_position_info_ptr -> position_info.index_cursor_ptr -> index_cursor.file_opening_id;
      999 
     1000    end GET_FILE_OPENING_ID;
     1001 
     1002 
     1003 GET_FIRST_KEY_ID:
     1004    proc (gfki_p_position_info_ptr, gfki_p_first_key_id_string);
     1005       dcl	    gfki_p_position_info_ptr
     1006 			       ptr parameter;
     1007       dcl	    gfki_p_first_key_id_string
     1008 			       bit (36) aligned parameter;
     1009 
     1010       gfki_p_first_key_id_string = gfki_p_position_info_ptr -> position_info.first_key_id_string;
     1011 
     1012    end GET_FIRST_KEY_ID;
     1013 
     1014 
     1015 GET_INDEX_CURSOR:
     1016    proc (gic_p_position_info_ptr, gic_p_index_cursor_ptr);
     1017       dcl	    gic_p_position_info_ptr
     1018 			       ptr parameter;
     1019       dcl	    gic_p_index_cursor_ptr ptr parameter;
     1020 
     1021       gic_p_index_cursor_ptr = gic_p_position_info_ptr -> position_info.index_cursor_ptr;
     1022    end GET_INDEX_CURSOR;
     1023 
     1024 GET_KEY:
     1025    proc (gk_p_position_info_ptr, gk_p_leaf_key_ptr, gk_p_leaf_key_string_length);
     1026       dcl	    gk_p_position_info_ptr ptr parameter;
     1027       dcl	    gk_p_leaf_key_ptr      ptr parameter;
     1028       dcl	    gk_p_leaf_key_string_length
     1029 			       fixed bin (35) parameter;
     1030 
     1031       dcl	    gk_code	       fixed bin (35);
     1032       dcl	    gk_collection_id       bit (36) aligned;
     1033       dcl	    1 gk_element_id	       aligned based (addr (gk_element_id_string)) like element_id;
     1034       dcl	    gk_element_id_string   bit (36) aligned;
     1035       dcl	    gk_node_id	       fixed bin (24) unsigned;
     1036       dcl	    gk_node_ptr	       ptr;
     1037       dcl	    1 gk_p_position_info   based (gk_p_position_info_ptr) aligned like position_info;
     1038       dcl	    gk_slot_index	       fixed bin (12) unsigned;
     1039 
     1040       if ^gk_p_position_info.key_buffer_contains_current_key
     1041       then
     1042          do;
     1043 	  call GET_COLLECTION_ID (gk_p_position_info_ptr, gk_collection_id);
     1044 	  call GET_NODE_ID (gk_p_position_info_ptr, gk_node_id);
     1045 	  call GET_NODE_PTR (gk_p_position_info_ptr, gk_node_ptr);
     1046 	  call GET_SLOT_INDEX (gk_p_position_info_ptr, gk_slot_index);
     1047 
     1048 	  gk_element_id.control_interval_id = gk_node_id;
     1049 	  gk_element_id.index = gk_slot_index;
     1050 
     1051 	  call collection_manager_$simple_get_by_ci_ptr (gk_node_ptr, gk_collection_id, gk_element_id_string,
     1052 	       gk_p_position_info.key_buffer_ptr, gk_p_position_info.key_buffer_length,
     1053 	       gk_p_position_info.lk_string_length, gk_code);
     1054 	  if gk_code ^= 0
     1055 	  then call ERROR_RETURN (gk_code);
     1056 	  gk_p_position_info.key_buffer_contains_current_key = "1"b;
     1057          end;
     1058 
     1059       gk_p_leaf_key_ptr = gk_p_position_info.key_buffer_ptr;
     1060       gk_p_leaf_key_string_length = gk_p_position_info.lk_string_length;
     1061 
     1062 
     1063    end GET_KEY;
     1064 
     1065 
     1066 
     1067 GET_LAST_KEY_ID:
     1068    proc (glki_p_position_info_ptr, glki_p_last_key_id_string);
     1069       dcl	    glki_p_position_info_ptr
     1070 			       ptr parameter;
     1071       dcl	    glki_p_last_key_id_string
     1072 			       bit (36) aligned parameter;
     1073 
     1074       glki_p_last_key_id_string = glki_p_position_info_ptr -> position_info.last_key_id_string;
     1075 
     1076    end GET_LAST_KEY_ID;
     1077 
     1078 
     1079 GET_NODE_ID:
     1080    proc (gni_p_position_info_ptr, gni_p_node_id);
     1081       dcl	    gni_p_position_info_ptr
     1082 			       ptr parameter;
     1083       dcl	    gni_p_node_id	       fixed bin (24) unsigned parameter;
     1084 
     1085       gni_p_node_id = gni_p_position_info_ptr -> position_info.node_id;
     1086 
     1087    end GET_NODE_ID;
     1088 
     1089 GET_NODE_PTR:
     1090    proc (gnp_p_position_info_ptr, gnp_p_node_ptr);
     1091       dcl	    gnp_p_position_info_ptr
     1092 			       ptr parameter;
     1093       dcl	    gnp_p_node_ptr	       ptr parameter;
     1094 
     1095       dcl	    gnp_code	       fixed bin (35);
     1096       dcl	    gnp_collection_id      bit (36) aligned;
     1097       dcl	    gnp_file_opening_id    bit (36) aligned;
     1098       dcl	    gnp_node_id	       fixed bin (24) unsigned;
     1099       dcl	    1 gnp_p_position_info  based (gnp_p_position_info_ptr) aligned like position_info;
     1100 
     1101       if gnp_p_position_info.node_ptr = null
     1102       then
     1103          do;
     1104 	  call GET_FILE_OPENING_ID (gnp_p_position_info_ptr, gnp_file_opening_id);
     1105 	  call GET_COLLECTION_ID (gnp_p_position_info_ptr, gnp_collection_id);
     1106 	  call GET_NODE_ID (gnp_p_position_info_ptr, gnp_node_id);
     1107 
     1108 	  call collection_manager_$get_control_interval_ptr (gnp_file_opening_id, gnp_collection_id, gnp_node_id,
     1109 	       gnp_p_position_info.node_ptr, gnp_code);
     1110 	  if gnp_code ^= 0
     1111 	  then call ERROR_RETURN (gnp_code);
     1112          end;
     1113 
     1114       gnp_p_node_ptr = gnp_p_position_info.node_ptr;
     1115    end GET_NODE_PTR;
     1116 
     1117 GET_SELECTED_VECTOR:
     1118    proc (gsv_p_position_info_ptr, gsv_p_vector_ptr);
     1119 
     1120       dcl	    gsv_p_position_info_ptr
     1121 			       ptr parameter;
     1122       dcl	    gsv_p_vector_ptr       ptr parameter;
     1123 
     1124       dcl	    gsv_code	       fixed bin (35);
     1125       dcl	    gsv_field_table_ptr    ptr;
     1126       dcl	    gsv_leaf_key_ptr       ptr;
     1127       dcl	    gsv_lk_string_length   fixed bin (35);
     1128       dcl	    1 gsv_p_position_info  based (gsv_p_position_info_ptr) aligned like position_info;
     1129       dcl	    gsv_work_area_ptr      ptr;
     1130 
     1131       if gsv_p_position_info.selected_vector_ptr = null
     1132       then if gsv_p_position_info.id_list_ptr = null
     1133 	 then call GET_ENTIRE_VECTOR (gsv_p_position_info_ptr, gsv_p_position_info.selected_vector_ptr);
     1134 	 else
     1135 	    do;
     1136 
     1137 	       call GET_KEY (gsv_p_position_info_ptr, gsv_leaf_key_ptr, gsv_lk_string_length);
     1138 	       call GET_FIELD_TABLE (gsv_p_position_info_ptr, gsv_field_table_ptr);
     1139 	       call GET_WORK_AREA (gsv_p_position_info_ptr, gsv_work_area_ptr);
     1140 
     1141 	       call data_format_util_$cv_string_to_vector (gsv_field_table_ptr, gsv_work_area_ptr, gsv_leaf_key_ptr,
     1142 		  gsv_lk_string_length, gsv_p_position_info.id_list_ptr, gsv_p_position_info.selected_vector_ptr,
     1143 		  gsv_code);
     1144 	       if gsv_code ^= 0
     1145 	       then call ERROR_RETURN (gsv_code);
     1146 	    end;
     1147       gsv_p_vector_ptr = gsv_p_position_info.selected_vector_ptr;
     1148 
     1149    end GET_SELECTED_VECTOR;
     1150 
     1151 
     1152 GET_SLOT_INDEX:
     1153    proc (gsi_p_position_info_ptr, gsi_p_slot_index);
     1154       dcl	    gsi_p_position_info_ptr
     1155 			       ptr parameter;
     1156       dcl	    gsi_p_slot_index       fixed bin (12) unsigned parameter;
     1157 
     1158       gsi_p_slot_index = gsi_p_position_info_ptr -> position_info.slot_index;
     1159    end GET_SLOT_INDEX;
     1160 
     1161 
     1162 
     1163 GET_WORK_AREA:
     1164    proc (gci_p_position_info_ptr, gci_p_work_area_ptr);
     1165       dcl	    gci_p_position_info_ptr
     1166 			       ptr parameter;
     1167       dcl	    gci_p_work_area_ptr    ptr parameter;
     1168 
     1169       gci_p_work_area_ptr = gci_p_position_info_ptr -> position_info.work_area_ptr;
     1170 
     1171    end GET_WORK_AREA;
     1172 
     1173 INITIALIZE_POSITION:
     1174    proc (ip_p_index_cursor_ptr, ip_p_header_buffer_ptr, ip_p_header_buffer_length, ip_p_key_buffer_ptr,
     1175         ip_p_key_buffer_length, ip_p_field_table_ptr, ip_p_work_area_ptr, ip_p_first_key_id_string,
     1176         ip_p_last_key_id_string, ip_p_id_list_ptr, ip_p_get_keys_in_reverse_order, ip_p_position_info_ptr);
     1177 
     1178       dcl	    ip_p_index_cursor_ptr  ptr parameter;
     1179       dcl	    ip_p_header_buffer_ptr ptr parameter;
     1180       dcl	    ip_p_header_buffer_length
     1181 			       fixed bin (35) parameter;
     1182       dcl	    ip_p_key_buffer_ptr    ptr parameter;
     1183       dcl	    ip_p_key_buffer_length fixed bin (35) parameter;
     1184       dcl	    ip_p_field_table_ptr   ptr parameter;
     1185       dcl	    ip_p_work_area_ptr     ptr parameter;
     1186       dcl	    ip_p_first_key_id_string
     1187 			       bit (36) aligned;
     1188       dcl	    ip_p_last_key_id_string
     1189 			       bit (36) aligned;
     1190       dcl	    ip_p_id_list_ptr       ptr parameter;
     1191       dcl	    ip_p_get_keys_in_reverse_order
     1192 			       bit (1) aligned parameter;
     1193       dcl	    ip_p_position_info_ptr ptr parameter;
     1194 
     1195       dcl	    1 ip_p_position_info   based (ip_p_position_info_ptr) aligned like position_info;
     1196 
     1197       ip_p_position_info.node_ptr = null;
     1198       ip_p_position_info.entire_vector_ptr = null;
     1199       ip_p_position_info.selected_vector_ptr = null;
     1200       ip_p_position_info.lk_string_length = 0;
     1201       ip_p_position_info.node_id = 0;
     1202       ip_p_position_info.slot_index = 0;
     1203       string (ip_p_position_info.flags) = "0"b;
     1204       ip_p_position_info.index_cursor_ptr = ip_p_index_cursor_ptr;
     1205       ip_p_position_info.key_buffer_length = ip_p_key_buffer_length;
     1206       ip_p_position_info.key_buffer_ptr = ip_p_key_buffer_ptr;
     1207       ip_p_position_info.header_buffer_length = ip_p_header_buffer_length;
     1208       ip_p_position_info.header_buffer_ptr = ip_p_header_buffer_ptr;
     1209       ip_p_position_info.field_table_ptr = ip_p_field_table_ptr;
     1210       ip_p_position_info.work_area_ptr = ip_p_work_area_ptr;
     1211       ip_p_position_info.first_key_id_string = ip_p_first_key_id_string;
     1212       ip_p_position_info.last_key_id_string = ip_p_last_key_id_string;
     1213       ip_p_position_info.id_list_ptr = ip_p_id_list_ptr;
     1214 
     1215 
     1216       if ip_p_get_keys_in_reverse_order
     1217       then
     1218          do;
     1219 	  call SET_NODE_ID ((addr (ip_p_last_key_id_string) -> element_id.control_interval_id), ip_p_position_info_ptr);
     1220 	  call SET_SLOT_INDEX ((addr (p_last_key_id_string) -> element_id.index), ip_p_position_info_ptr);
     1221          end;
     1222       else
     1223          do;
     1224 	  call SET_NODE_ID ((addr (ip_p_first_key_id_string) -> element_id.control_interval_id), ip_p_position_info_ptr)
     1225 	       ;
     1226 	  call SET_SLOT_INDEX ((addr (ip_p_first_key_id_string) -> element_id.index), ip_p_position_info_ptr);
     1227          end;
     1228 
     1229 
     1230    end INITIALIZE_POSITION;
     1231 
     1232 INTERPRET_SPECIFICATION:
     1233    proc (is_p_specification_head_ptr, is_p_first_key_id_string, is_p_is_search_specification,
     1234         is_p_search_specification_ptr, is_p_numeric_specification_ptr, is_p_get_keys_in_reverse_order, is_p_range_size,
     1235         is_p_position_count);
     1236 
     1237       dcl	    is_p_specification_head_ptr
     1238 			       ptr parameter;
     1239       dcl	    is_p_first_key_id_string
     1240 			       bit (36) aligned parameter;
     1241       dcl	    is_p_is_search_specification
     1242 			       bit (1) aligned parameter;
     1243       dcl	    is_p_search_specification_ptr
     1244 			       ptr parameter;
     1245       dcl	    is_p_numeric_specification_ptr
     1246 			       ptr parameter;
     1247       dcl	    is_p_get_keys_in_reverse_order
     1248 			       bit (1) aligned parameter;
     1249       dcl	    is_p_range_size	       fixed bin (35) parameter;
     1250       dcl	    is_p_position_count    fixed bin (35) parameter;
     1251 
     1252 
     1253       if is_p_specification_head_ptr -> specification_head.type = ABSOLUTE_SEARCH_SPECIFICATION_TYPE
     1254 	 | is_p_specification_head_ptr -> specification_head.type = RELATIVE_SEARCH_SPECIFICATION_TYPE
     1255       then
     1256          do;
     1257 	  is_p_is_search_specification = "1"b;
     1258 	  is_p_search_specification_ptr = is_p_specification_head_ptr;
     1259 	  is_p_get_keys_in_reverse_order =
     1260 	       (is_p_first_key_id_string = "0"b
     1261 	       | is_p_search_specification_ptr -> search_specification.range.type = HIGH_RANGE_TYPE);
     1262 	  is_p_range_size = is_p_search_specification_ptr -> search_specification.range.size;
     1263          end;
     1264       else if is_p_specification_head_ptr -> specification_head.type = ABSOLUTE_NUMERIC_SPECIFICATION_TYPE
     1265 	      | is_p_specification_head_ptr -> specification_head.type = RELATIVE_NUMERIC_SPECIFICATION_TYPE
     1266       then
     1267          do;
     1268 	  is_p_is_search_specification = "0"b;
     1269 	  is_p_numeric_specification_ptr = is_p_specification_head_ptr;
     1270 	  is_p_get_keys_in_reverse_order =
     1271 	       (is_p_numeric_specification_ptr -> numeric_specification.position_number < 0);
     1272 	  is_p_range_size = is_p_numeric_specification_ptr -> numeric_specification.range_size;
     1273 	  is_p_position_count = abs (is_p_numeric_specification_ptr -> numeric_specification.position_number);
     1274          end;
     1275       else call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
     1276 	      "^/The specification structure does not have a recognizable type.  
     1277 Recognized types are ^d, ^d, ^d, or ^d.  Received type was ^d.", ABSOLUTE_SEARCH_SPECIFICATION_TYPE,
     1278 	      RELATIVE_SEARCH_SPECIFICATION_TYPE, ABSOLUTE_NUMERIC_SPECIFICATION_TYPE,
     1279 	      RELATIVE_NUMERIC_SPECIFICATION_TYPE, is_p_specification_head_ptr -> specification_head.type);
     1280 
     1281    end INTERPRET_SPECIFICATION;
     1282 
     1283 NODE_IS_DELETED:
     1284    proc (nie_p_position_info_ptr) returns (bit (1) aligned);
     1285       dcl	    nie_p_position_info_ptr
     1286 			       ptr parameter;
     1287 
     1288       return (nie_p_position_info_ptr -> position_info.node_is_deleted);
     1289    end NODE_IS_DELETED;
     1290 
     1291 
     1292 
     1293 NOTE_NODE_IS_DELETED:
     1294    proc (nnid_p_position_info_ptr);
     1295       dcl	    nnid_p_position_info_ptr
     1296 			       ptr parameter;
     1297 
     1298       nnid_p_position_info_ptr -> position_info.node_is_deleted = "1"b;
     1299       nnid_p_position_info_ptr -> position_info.node_ptr = null;
     1300    end NOTE_NODE_IS_DELETED;
     1301 
     1302 
     1303 NOTE_VECTOR_IN_USE:
     1304    proc (nviu_p_position_info_ptr);
     1305       dcl	    nviu_p_position_info_ptr
     1306 			       ptr parameter;
     1307 
     1308       nviu_p_position_info_ptr -> position_info.vector_in_use = "1"b;
     1309    end NOTE_VECTOR_IN_USE;
     1310 
     1311 RESET_CI_HEADER:
     1312    proc (rch_p_position_info_ptr);
     1313       dcl	    rch_p_position_info_ptr
     1314 			       ptr parameter;
     1315       rch_p_position_info_ptr -> position_info.header_buffer_contains_current_header = "0"b;
     1316    end RESET_CI_HEADER;
     1317 
     1318 
     1319 RESET_KEY:
     1320    proc (rk_p_position_info_ptr);
     1321       dcl	    rk_p_position_info_ptr ptr parameter;
     1322       call RESET_VECTORS (rk_p_position_info_ptr);
     1323       rk_p_position_info_ptr -> position_info.key_buffer_contains_current_key = "0"b;
     1324       rk_p_position_info_ptr -> position_info.lk_string_length = 0;
     1325    end RESET_KEY;
     1326 
     1327 
     1328 RESET_NODE_ID:
     1329    proc (rni_p_position_info_ptr);
     1330 
     1331       dcl	    rni_p_position_info_ptr
     1332 			       ptr parameter;
     1333 
     1334       rni_p_position_info_ptr -> position_info.node_id = 0;
     1335       rni_p_position_info_ptr -> position_info.node_is_deleted = "0"b;
     1336 
     1337       call RESET_CI_HEADER (rni_p_position_info_ptr);
     1338       call RESET_NODE_PTR (rni_p_position_info_ptr);
     1339       call RESET_SLOT_INDEX (rni_p_position_info_ptr);
     1340 
     1341    end RESET_NODE_ID;
     1342 
     1343 
     1344 RESET_NODE_PTR:
     1345    proc (rnp_p_position_info_ptr);
     1346       dcl	    rnp_p_position_info_ptr
     1347 			       ptr parameter;
     1348       rnp_p_position_info_ptr -> position_info.node_ptr = null ();
     1349    end RESET_NODE_PTR;
     1350 
     1351 
     1352 RESET_SLOT_INDEX:
     1353    proc (rsi_p_position_info_ptr);
     1354       dcl	    rsi_p_position_info_ptr
     1355 			       ptr parameter;
     1356       call RESET_KEY (rsi_p_position_info_ptr);
     1357       rsi_p_position_info_ptr -> position_info.slot_index = 0;
     1358    end RESET_SLOT_INDEX;
     1359 
     1360 RESET_VECTORS:
     1361    proc (rv_p_position_info_ptr);
     1362       dcl	    rv_p_position_info_ptr ptr parameter;
     1363 
     1364       dcl	    1 rv_p_position_info   based (rv_p_position_info_ptr) aligned like position_info;
     1365 
     1366 /* If the entire and selected vectors are the same vector, avoid trying to free
     1367*it twice (or freeing it as the entire_vector when the vector, as the
     1368*selected_vector, should not be freed because it is in the output array)
     1369*by setting the entire_vector_ptr to null.
     1370**/
     1371 
     1372       if rv_p_position_info.entire_vector_ptr = rv_p_position_info.selected_vector_ptr
     1373       then rv_p_position_info.entire_vector_ptr = null;
     1374 
     1375       if rv_p_position_info.entire_vector_ptr ^= null
     1376       then call FREE_ENTIRE_VECTOR (rv_p_position_info.entire_vector_ptr);
     1377 
     1378       if ^rv_p_position_info.vector_in_use & rv_p_position_info.selected_vector_ptr ^= null
     1379       then call FREE_ENTIRE_VECTOR (rv_p_position_info.selected_vector_ptr);
     1380 
     1381       rv_p_position_info.selected_vector_ptr = null;
     1382       rv_p_position_info.entire_vector_ptr = null;
     1383       rv_p_position_info.vector_in_use = "0"b;
     1384 
     1385    end RESET_VECTORS;
     1386 
     1387 REVERSE_VECTOR_SLOTS:
     1388    proc (rvs_p_input_number_of_keys_accepted, rvs_p_typed_vector_array_ptr);
     1389       dcl	    rvs_p_input_number_of_keys_accepted
     1390 			       fixed bin (35) parameter;
     1391       dcl	    rvs_p_typed_vector_array_ptr
     1392 			       ptr parameter;
     1393 
     1394       dcl	    rvs_vector_slot_idx    fixed bin (35) init (0);
     1395       dcl	    rvs_vector_ptr	       ptr init (null);
     1396 
     1397       do rvs_vector_slot_idx = rvs_p_input_number_of_keys_accepted + 1
     1398 	 to
     1399 	 divide (rvs_p_typed_vector_array_ptr -> typed_vector_array.number_of_vectors
     1400 	 - rvs_p_input_number_of_keys_accepted, 2, 35, 0) + rvs_p_input_number_of_keys_accepted;
     1401          rvs_vector_ptr = rvs_p_typed_vector_array_ptr -> typed_vector_array.vector_slot (rvs_vector_slot_idx);
     1402          rvs_p_typed_vector_array_ptr -> typed_vector_array.vector_slot (rvs_vector_slot_idx) =
     1403 	    rvs_p_typed_vector_array_ptr
     1404 	    -> typed_vector_array
     1405 	    .
     1406 	    vector_slot (rvs_p_typed_vector_array_ptr -> typed_vector_array.number_of_vectors - rvs_vector_slot_idx + 1)
     1407 	    ;
     1408          rvs_p_typed_vector_array_ptr
     1409 	    -> typed_vector_array
     1410 	    .
     1411 	    vector_slot (rvs_p_typed_vector_array_ptr -> typed_vector_array.number_of_vectors - rvs_vector_slot_idx + 1)
     1412 	    = rvs_vector_ptr;
     1413       end;
     1414    end REVERSE_VECTOR_SLOTS;
     1415 
     1416 SEARCH_SPEC_COMPARISON:
     1417    proc (sesc_p_search_specification_ptr, sesc_p_and_group_id_list_ptr, sesc_p_number_of_fully_structural_fields,
     1418         sesc_p_partial_structural_field_id, sesc_p_position_info_ptr, sesc_p_key_satisfies_specification);
     1419 
     1420       dcl	    sesc_p_search_specification_ptr
     1421 			       ptr parameter;
     1422       dcl	    sesc_p_and_group_id_list_ptr
     1423 			       ptr parameter;
     1424       dcl	    sesc_p_number_of_fully_structural_fields
     1425 			       fixed bin parameter;
     1426       dcl	    sesc_p_partial_structural_field_id
     1427 			       fixed bin (17) parameter;
     1428       dcl	    sesc_p_position_info_ptr
     1429 			       ptr parameter;
     1430       dcl	    sesc_p_key_satisfies_specification
     1431 			       bit (1) aligned parameter;
     1432 
     1433       dcl	    sesc_code	       fixed bin (35) init (0);
     1434       dcl	    sesc_field_table_ptr   ptr init (null);
     1435       dcl	    sesc_leaf_key_ptr      ptr init (null);
     1436       dcl	    sesc_lk_string_length  fixed bin (35) init (0);
     1437 
     1438 
     1439 
     1440       call GET_FIELD_TABLE (sesc_p_position_info_ptr, sesc_field_table_ptr);
     1441 
     1442       if (sesc_p_search_specification_ptr -> search_specification.number_of_and_groups = 0
     1443 	 & sesc_p_and_group_id_list_ptr = null)
     1444 	 | (sesc_p_number_of_fully_structural_fields = sesc_field_table_ptr -> field_table.number_of_fields)
     1445       then sesc_p_key_satisfies_specification = "1"b;
     1446       else
     1447          do;
     1448 	  call GET_KEY (sesc_p_position_info_ptr, sesc_leaf_key_ptr, sesc_lk_string_length);
     1449 
     1450 	  lk_string_length = sesc_lk_string_length;	/* The global variable lk_string_length is used here because leaf_key references it. */
     1451 	  call data_format_util_$compare_sequential (sesc_field_table_ptr, sesc_p_search_specification_ptr,
     1452 	       sesc_p_and_group_id_list_ptr, sesc_p_number_of_fully_structural_fields,
     1453 	       sesc_p_partial_structural_field_id, sesc_leaf_key_ptr -> leaf_key.string,
     1454 	       sesc_p_key_satisfies_specification, sesc_code);
     1455 	  if sesc_code ^= 0
     1456 	  then call ERROR_RETURN (sesc_code);
     1457          end;
     1458 
     1459    end SEARCH_SPEC_COMPARISON;
     1460 
     1461 SET_INDEX_CURSOR:
     1462    proc (sc_p_operation, sc_p_position_info_ptr);
     1463 
     1464       dcl	    sc_p_operation	       fixed bin parameter;
     1465       dcl	    sc_p_position_info_ptr ptr parameter;
     1466 
     1467       dcl	    sc_code	       fixed bin (35) init (0);
     1468       dcl	    sc_index_cursor_ptr    ptr;
     1469       dcl	    sc_leaf_ci_header_ptr  ptr;
     1470       dcl	    1 sc_leaf_ci_header    based (sc_leaf_ci_header_ptr) like leaf_ci_header;
     1471       dcl	    sc_leaf_key_ptr	       ptr;
     1472       dcl	    sc_lk_string_length    fixed bin (35);
     1473       dcl	    sc_node_id	       fixed bin (24) unsigned;
     1474       dcl	    sc_slot_index	       fixed bin (12) unsigned;
     1475 
     1476       dcl	    sc_element_id_string   bit (36) aligned;
     1477       dcl	    1 sc_element_id	       based (addr (sc_element_id_string)) like element_id;
     1478 
     1479 
     1480       call GET_INDEX_CURSOR (sc_p_position_info_ptr, sc_index_cursor_ptr);
     1481       call GET_CI_HEADER (sc_p_position_info_ptr, sc_leaf_ci_header_ptr);
     1482       call GET_KEY (sc_p_position_info_ptr, sc_leaf_key_ptr, sc_lk_string_length);
     1483       call GET_NODE_ID (sc_p_position_info_ptr, sc_node_id);
     1484       call GET_SLOT_INDEX (sc_p_position_info_ptr, sc_slot_index);
     1485 
     1486       sc_element_id.control_interval_id = sc_node_id;
     1487       sc_element_id.index = sc_slot_index;
     1488 
     1489       if sc_p_operation = GET_OPERATION
     1490       then
     1491          do;
     1492 	  call im_set_cursor$at_current (sc_index_cursor_ptr, sc_element_id_string, sc_leaf_key_ptr,
     1493 	       (sc_lk_string_length), sc_code);
     1494 	  if sc_code ^= 0
     1495 	  then call ERROR_RETURN (sc_code);
     1496          end;
     1497       else if sc_p_operation = POSITION_OPERATION
     1498       then
     1499          do;
     1500 	  call GET_KEY (sc_p_position_info_ptr, sc_leaf_key_ptr, sc_lk_string_length);
     1501 	  call im_set_cursor$at_current (sc_index_cursor_ptr, sc_element_id_string, sc_leaf_key_ptr,
     1502 	       (sc_lk_string_length), sc_code);
     1503 	  if sc_code ^= 0
     1504 	  then call ERROR_RETURN (sc_code);
     1505          end;
     1506       else if sc_p_operation = DELETE_OPERATION
     1507       then
     1508          do;
     1509 	  if sc_slot_index > sc_leaf_ci_header.common.key_range.last | NODE_IS_DELETED (sc_p_position_info_ptr)
     1510 	  then
     1511 	     do;
     1512 	        sc_node_id = sc_leaf_ci_header.common.next_id;
     1513 	        call SET_NODE_ID (sc_node_id, sc_p_position_info_ptr);
     1514 	        if sc_node_id ^= 0
     1515 	        then
     1516 		 do;
     1517 		    call GET_CI_HEADER (sc_p_position_info_ptr, sc_leaf_ci_header_ptr);
     1518 		    sc_slot_index = sc_leaf_ci_header.common.key_range.first;
     1519 		    call SET_SLOT_INDEX (sc_slot_index, sc_p_position_info_ptr);
     1520 		 end;
     1521 
     1522 	     end;
     1523 	  if sc_node_id > 0
     1524 	  then
     1525 	     do;
     1526 	        call GET_KEY (sc_p_position_info_ptr, sc_leaf_key_ptr, sc_lk_string_length);
     1527 
     1528 	        sc_element_id.control_interval_id = sc_node_id;
     1529 	        sc_element_id.index = sc_slot_index;
     1530 
     1531 	        call im_set_cursor$at_current (sc_index_cursor_ptr, sc_element_id_string, sc_leaf_key_ptr,
     1532 		   (sc_lk_string_length), sc_code);
     1533 	        if sc_code ^= 0
     1534 	        then call ERROR_RETURN (sc_code);
     1535 	     end;
     1536 	  else
     1537 	     do;
     1538 	        call im_set_cursor$at_end (sc_index_cursor_ptr, "0"b, null, 0, sc_code);
     1539 	        if sc_code ^= 0
     1540 	        then call ERROR_RETURN (sc_code);
     1541 	     end;
     1542          end;
     1543    end SET_INDEX_CURSOR;
     1544 
     1545 SET_NODE_ID:
     1546    proc (sni_p_node_id, sni_p_position_info_ptr);
     1547 
     1548 /* This subroutine sets the current node id and gets a pointer to it. */
     1549 
     1550       dcl	    sni_p_node_id	       fixed bin (24) unsigned;
     1551       dcl	    sni_p_position_info_ptr
     1552 			       ptr parameter;
     1553 
     1554       if sni_p_position_info_ptr -> position_info.node_id > 0
     1555       then call RESET_NODE_ID (sni_p_position_info_ptr);
     1556 
     1557       sni_p_position_info_ptr -> position_info.node_id = sni_p_node_id;
     1558    end SET_NODE_ID;
     1559 
     1560 
     1561 
     1562 SET_SLOT_INDEX:
     1563    proc (ssi_p_slot_index, ssi_p_position_info_ptr);
     1564       dcl	    ssi_p_slot_index       fixed bin (12) unsigned parameter;
     1565       dcl	    ssi_p_position_info_ptr
     1566 			       ptr parameter;
     1567 
     1568       if ssi_p_position_info_ptr -> position_info.slot_index > 0
     1569       then call RESET_SLOT_INDEX (ssi_p_position_info_ptr);
     1570 
     1571       ssi_p_position_info_ptr -> position_info.slot_index = ssi_p_slot_index;
     1572 
     1573 
     1574    end SET_SLOT_INDEX;
     1575 
     1576 /* This procedure determines if there is a "next" key, and, if so, it advances
     1577*the current position to that next key.
     1578**/
     1579 
     1580 SETUP_NEXT_KEY:
     1581    proc (snk_p_operation, snk_p_is_search_specification, snk_p_range_size, snk_p_get_keys_in_reverse_order,
     1582         snk_p_key_satisfies_specification, snk_p_position_info_ptr, snk_p_number_of_keys_accepted, snk_p_finished);
     1583 
     1584       dcl	    snk_p_operation	       fixed bin parameter;
     1585       dcl	    snk_p_is_search_specification
     1586 			       bit (1) aligned parameter;
     1587       dcl	    snk_p_range_size       fixed bin (35) parameter;
     1588       dcl	    snk_p_get_keys_in_reverse_order
     1589 			       bit (1) aligned parameter;
     1590       dcl	    snk_p_key_satisfies_specification
     1591 			       bit (1) aligned parameter;
     1592       dcl	    snk_p_position_info_ptr
     1593 			       ptr parameter;
     1594       dcl	    snk_p_number_of_keys_accepted
     1595 			       fixed bin (35) parameter;
     1596       dcl	    snk_p_finished	       bit (1) aligned parameter;
     1597 
     1598 
     1599       dcl	    snk_leaf_ci_header_ptr ptr init (null);
     1600       dcl	    1 snk_leaf_ci_header   based (snk_leaf_ci_header_ptr) like leaf_ci_header;
     1601       dcl	    snk_node_id	       fixed bin (24) unsigned;
     1602       dcl	    snk_position_change    fixed bin (35) init (0);
     1603       dcl	    snk_slot_index	       fixed bin (12) unsigned;
     1604 
     1605       snk_p_finished = "0"b;
     1606 
     1607       if snk_p_range_size > 0 & snk_p_number_of_keys_accepted = snk_p_range_size
     1608       then
     1609          do;
     1610 	  snk_p_finished = "1"b;
     1611 	  return;
     1612          end;
     1613       else
     1614 REALLY_LOOK:
     1615          do;
     1616 
     1617 	  call GET_NODE_ID (snk_p_position_info_ptr, snk_node_id);
     1618 	  call GET_SLOT_INDEX (snk_p_position_info_ptr, snk_slot_index);
     1619 	  call GET_CI_HEADER (snk_p_position_info_ptr, snk_leaf_ci_header_ptr);
     1620 
     1621 	  if snk_p_is_search_specification
     1622 	  then
     1623 	     do;
     1624 	        if snk_p_get_keys_in_reverse_order
     1625 	        then
     1626 		 do;
     1627 		    snk_position_change = 1;
     1628 		    if BEFORE_BEGINNING (snk_p_position_info_ptr, snk_node_id, snk_slot_index - snk_position_change)
     1629 		    then
     1630 		       do;
     1631 			snk_p_finished = "1"b;
     1632 			return;
     1633 		       end;
     1634 		    else if snk_slot_index - snk_position_change >= snk_leaf_ci_header.common.key_range.first
     1635 		    then call SET_SLOT_INDEX (snk_slot_index - snk_position_change, snk_p_position_info_ptr);
     1636 		    else
     1637 		       do;
     1638 			call SET_NODE_ID ((snk_leaf_ci_header.common.previous_id), snk_p_position_info_ptr);
     1639 			call GET_CI_HEADER (snk_p_position_info_ptr, snk_leaf_ci_header_ptr);
     1640 
     1641 			call SET_SLOT_INDEX ((snk_leaf_ci_header.common.key_range.last), snk_p_position_info_ptr);
     1642 		       end;
     1643 		 end;
     1644 	        else
     1645 		 do;
     1646 		    snk_position_change = bin (snk_p_operation ^= DELETE_OPERATION);
     1647 		    if AFTER_END (snk_p_position_info_ptr, snk_node_id, snk_slot_index + snk_position_change)
     1648 		         | (snk_p_operation = POSITION_OPERATION & snk_p_key_satisfies_specification)
     1649 		    then
     1650 		       do;
     1651 			snk_p_finished = "1"b;
     1652 			return;
     1653 		       end;
     1654 		    else if snk_slot_index + snk_position_change <= snk_leaf_ci_header.common.key_range.last
     1655 			    & snk_slot_index ^= 0
     1656 		    then call SET_SLOT_INDEX (snk_slot_index + snk_position_change, snk_p_position_info_ptr);
     1657 		    else
     1658 		       do;
     1659 			call SET_NODE_ID ((snk_leaf_ci_header.common.next_id), snk_p_position_info_ptr);
     1660 			call GET_CI_HEADER (snk_p_position_info_ptr, snk_leaf_ci_header_ptr);
     1661 			call SET_SLOT_INDEX ((DEFAULT_INITIAL_KEY_SLOT), snk_p_position_info_ptr);
     1662 		       end;
     1663 		 end;
     1664 	     end;
     1665 	  else
     1666 FINISH_NUMERIC:
     1667 	     do;
     1668 	        if snk_p_range_size = 0 & snk_p_key_satisfies_specification
     1669 	        then
     1670 		 do;
     1671 		    snk_p_finished = "1"b;
     1672 		    return;
     1673 		 end;
     1674 
     1675 	        else if snk_p_get_keys_in_reverse_order
     1676 	        then
     1677 		 do;
     1678 		    snk_position_change = 1;
     1679 		    if BEFORE_BEGINNING (snk_p_position_info_ptr, snk_node_id, snk_slot_index - snk_position_change)
     1680 		    then
     1681 		       do;
     1682 			snk_p_finished = "1"b;
     1683 			return;
     1684 		       end;
     1685 		    else if snk_slot_index - snk_position_change >= snk_leaf_ci_header.common.key_range.first
     1686 		    then call SET_SLOT_INDEX (snk_slot_index - snk_position_change, snk_p_position_info_ptr);
     1687 		    else
     1688 		       do;
     1689 			call SET_NODE_ID ((snk_leaf_ci_header.common.previous_id), snk_p_position_info_ptr);
     1690 			call GET_CI_HEADER (snk_p_position_info_ptr, snk_leaf_ci_header_ptr);
     1691 
     1692 			call SET_SLOT_INDEX ((snk_leaf_ci_header.common.key_range.last), snk_p_position_info_ptr);
     1693 		       end;
     1694 		 end;
     1695 	        else
     1696 		 do;
     1697 		    snk_position_change = bin (snk_p_operation ^= DELETE_OPERATION);
     1698 		    if AFTER_END (snk_p_position_info_ptr, snk_node_id, snk_slot_index + snk_position_change)
     1699 		    then
     1700 		       do;
     1701 			snk_p_finished = "1"b;
     1702 			return;
     1703 		       end;
     1704 		    else if snk_slot_index + snk_position_change <= snk_leaf_ci_header.common.key_range.last
     1705 			    & snk_slot_index ^= 0
     1706 		    then call SET_SLOT_INDEX (snk_slot_index + snk_position_change, snk_p_position_info_ptr);
     1707 		    else
     1708 		       do;
     1709 			call SET_NODE_ID ((snk_leaf_ci_header.common.next_id), snk_p_position_info_ptr);
     1710 			call GET_CI_HEADER (snk_p_position_info_ptr, snk_leaf_ci_header_ptr);
     1711 
     1712 			call SET_SLOT_INDEX ((snk_leaf_ci_header.common.key_range.first), snk_p_position_info_ptr);
     1713 		       end;
     1714 		 end;
     1715 	     end FINISH_NUMERIC;
     1716          end REALLY_LOOK;
     1717    end SETUP_NEXT_KEY;
     1718 
     1719 /* This procedure determines if the current key satisfies the subset
     1720*specification.
     1721**/
     1722 
     1723 SUBSET_SPEC_COMPARISON:
     1724    proc (susc_p_subset_specification_ptr, susc_p_position_info_ptr, susc_p_key_satisfies_specification);
     1725 
     1726       dcl	    susc_p_subset_specification_ptr
     1727 			       ptr parameter;
     1728       dcl	    susc_p_position_info_ptr
     1729 			       ptr parameter;
     1730       dcl	    susc_p_key_satisfies_specification
     1731 			       bit (1) aligned parameter;
     1732 
     1733       dcl	    susc_code	       fixed bin (35) init (0);
     1734       dcl	    susc_vector_ptr	       ptr init (null);
     1735       dcl	    susc_work_area_ptr     ptr;
     1736 
     1737       call GET_ENTIRE_VECTOR (susc_p_position_info_ptr, susc_vector_ptr);
     1738 
     1739       call GET_WORK_AREA (susc_p_position_info_ptr, susc_work_area_ptr);
     1740 
     1741       call im_compare_subset (susc_p_subset_specification_ptr, susc_vector_ptr, susc_work_area_ptr,
     1742 	 susc_p_key_satisfies_specification, NULL_PSEUDO_FIELD_VALUE, susc_code);
     1743       if susc_code ^= 0
     1744       then call ERROR_RETURN (susc_code);
     1745    end SUBSET_SPEC_COMPARISON;
     1746 
     1747 
  1     1 /* BEGIN INCLUDE FILE - dm_im_cursor.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*
  1     5*          This structure specifies a DM file, an index collection in that DM
  1     6*file, and a position (key) in that index collection.
  1     7*
  1     8**/
  1     9 
  1    10 /* HISTORY:
  1    11*
  1    12*Written by Lindsey Spratt, 03/29/82
  1    13*Modified:
  1    14*08/09/82 by Matthew Pierret: Changed collection_id from "fixed bin (17)" to
  1    15*            "bit (35) aligned".
  1    16*08/26/82 by Lindsey Spratt:  Changed to version 2.  Added the is_valid and
  1    17*	  is_at_end_of_index flags.  Changed the key_check_value to fixed
  1    18*	  bin (35).  Added the IM_HASH_BIAS, which is used to increment the
  1    19*	  value developed by hash_index_, and IM_HASH_NUMBER_OF_BUCKETS,
  1    20*	  which is a unique number used by hash_index_ to develop the
  1    21*	  key_check_value.
  1    22*02/23/83 by Lindsey Spratt: Changed to keep the current key value in the
  1    23*	  cursor.  Also, implemented the ability to have the cursor
  1    24*	  positioned before or after the index.  
  1    25*10/23/84 by Lindsey L. Spratt:  Added a description section.
  1    26**/
  1    27 
  1    28 /* format: style2,ind3 */
  1    29      dcl	   1 index_cursor	      based (index_cursor_ptr),
  1    30 	     2 type	      fixed bin (17) unaligned,
  1    31 	     2 version	      fixed bin (17) unaligned,
  1    32 	     2 file_opening_id    bit (36) aligned,
  1    33 	     2 collection_id      bit (36) aligned,
  1    34 	     2 key_id_string      bit (36) aligned,	/* Is the location of the current key, */
  1    35 						/* if flags.current_key_exists is on. Is the location */
  1    36 						/* of the end of the index if flags.is_at_end_of_index */
  1    37 						/* is on, which is only available via an operation */
  1    38 						/* requiring the "previous" key.  Is the location of */
  1    39 						/* the "next" key, otherwise. */
  1    40 	     2 area_ptr	      ptr,		/* Area in which the cursor and key_string area allocated. */
  1    41 						/* Must be a freeing area. */
  1    42 	     2 current_key_string_ptr
  1    43 			      ptr,		/* Points to the value of the current key. */
  1    44 	     2 current_key_string_length
  1    45 			      fixed bin (24) unal,	/* Is the length of the current key in bits. */
  1    46 	     2 pad	      bit (12) unal,
  1    47 	     2 flags	      aligned,
  1    48 	       3 is_at_beginning_of_index
  1    49 			      bit (1) unaligned,	/* Only the "next" key is defined. */
  1    50 	       3 is_at_end_of_index
  1    51 			      bit (1) unaligned,	/* Only the "previous" key is defined. */
  1    52 	       3 current_key_exists
  1    53 			      bit (1) unaligned,	/* If on, indicates that the "current" key is identified */
  1    54 						/* by the key_id_string.  If off, the "current" position */
  1    55 						/* is undefined, and the key_id_string identifies the */
  1    56 						/* previous or next key, depending on whether */
  1    57 						/* flags.is_at_end_of_index is off or on, respectively. */
  1    58 	       3 is_valid	      bit (1) unaligned,	/* If off, the index_manager_ was interrupted while */
  1    59 						/* setting the cursor position and the cursor is not */
  1    60 						/* to be trusted for relative position operations. */
  1    61 	       3 pad	      bit (32) unal;
  1    62 
  1    63 
  1    64      dcl	   index_cursor_ptr	      ptr;
  1    65 
  1    66      dcl	   INDEX_CURSOR_VERSION_3 fixed bin (17) init (3) internal static options (constant);
  1    67      dcl	   INDEX_CURSOR_TYPE      init (2) fixed bin (17) internal static options (constant);
  1    68 
  1    69 /* END INCLUDE FILE - dm_im_cursor.incl.pl1 */
     1748 
     1749 
  2     1 /* ***********************************************************
  2     2*   *                                                         *
  2     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
  2     4*   *                                                         *
  2     5*   *********************************************************** */
  2     6 /* BEGIN INCLUDE FILE vu_typed_vector_array.incl.pl1 */
  2     7 
  2     8 /* Written by Lindsey Spratt, 03/04/82.
  2     9*Modified:
  2    10*06/23/82 by Lindsey Spratt: Changed to version 2.  The cv entry declarations
  2    11*	  were altered.  cv_to_typed now takes ptr to the descriptor, ptr to
  2    12*	  the print_vector value (char varying), ptr to the typed_vector
  2    13*	  value location, and a code. cv_to_print now takes ptr to the
  2    14*	  descriptor, ptr to the typed_vector value, the print_vector value
  2    15*	  (char(*) varying), the maximum allowed length for the print_vector
  2    16*	  value, a temp_seg to put the value in if its to big to fit into
  2    17*	  the print_vector, and a code.
  2    18**/
  2    19 
  2    20 /* format: style2,ind3 */
  2    21      dcl	   1 typed_vector_array   based (typed_vector_array_ptr) aligned,
  2    22 	     2 version	      fixed bin (35),
  2    23 	     2 number_of_dimensions
  2    24 			      fixed bin (17),
  2    25 	     2 number_of_vectors  fixed bin (17),
  2    26 	     2 number_of_vector_slots
  2    27 			      fixed bin (17),
  2    28 	     2 maximum_dimension_name_length
  2    29 			      fixed bin (17),
  2    30 	     2 dimension_table    (tva_number_of_dimensions refer (typed_vector_array.number_of_dimensions)),
  2    31 	       3 name	      char (tva_maximum_dimension_name_length
  2    32 			      refer (typed_vector_array.maximum_dimension_name_length)) varying,
  2    33 	       3 descriptor_ptr   ptr,		/* call cv_to_print (descriptor_ptr, typed_value_ptr, */
  2    34 						/* temp_seg_ptr, max_length_for_print_value, */
  2    35 						/* print_value, code) */
  2    36 	       3 cv_to_print      entry (ptr, ptr, ptr, fixed bin (35), char (*) varying, fixed bin (35)),
  2    37 						/* call cv_to_typed (descriptor_ptr, area_ptr, */
  2    38 						/* print_value_ptr, typed_value_ptr, code) */
  2    39 	       3 cv_to_typed      entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  2    40 	     2 vector_slot	      (tva_number_of_vector_slots refer (typed_vector_array.number_of_vector_slots))
  2    41 			      pointer;
  2    42 
  2    43      dcl	   typed_vector_array_ptr ptr;
  2    44      dcl	   tva_number_of_vector_slots
  2    45 			      fixed bin;
  2    46      dcl	   tva_number_of_dimensions
  2    47 			      fixed bin;
  2    48      dcl	   tva_maximum_dimension_name_length
  2    49 			      fixed bin;
  2    50      dcl	   TYPED_VECTOR_ARRAY_VERSION_2
  2    51 			      fixed bin (35) int static options (constant) init (2);
  2    52 
  2    53 /* END INCLUDE FILE vu_typed_vector_array.incl.pl1 */
     1750 
     1751 
  3     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  3     2 /* format: style3 */
  3     3 
  3     4 /* These constants are to be used for the flags argument of sub_err_ */
  3     5 /* They are just "string (condition_info_header.action_flags)" */
  3     6 
  3     7 declare	(
  3     8 	ACTION_CAN_RESTART	init (""b),
  3     9 	ACTION_CANT_RESTART init ("1"b),
  3    10 	ACTION_DEFAULT_RESTART
  3    11 			init ("01"b),
  3    12 	ACTION_QUIET_RESTART
  3    13 			init ("001"b),
  3    14 	ACTION_SUPPORT_SIGNAL
  3    15 			init ("0001"b)
  3    16 	)		bit (36) aligned internal static options (constant);
  3    17 
  3    18 /* End include file */
     1752 
     1753 
  4     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*
  4     5*        Contains the declaration of an element identifier.  Element
  4     6*   identifiers consist of two parts, the id (number) of the control interval
  4     7*   in which the element resides, and the index into the slot table of
  4     8*   the element in the control interval.  The declaration of the element_id 
  4     9*   structure reflects this division of the element identifier.  The structure 
  4    10*   is based on the automatic bit string element_id_string because programs
  4    11*   generally pass bit strings (element_id_string) to each other, then 
  4    12*   interpret the bit string by overlaying the element_id structure ony if
  4    13*   it is necessary to access the parts of the id.  Basing element_id on
  4    14*   addr(element_id_string) instead of on a pointer removes the necessity
  4    15*   for always setting that pointer explicitly and guarantees that changes
  4    16*   made to the string or structure do not get inconsistent.
  4    17*
  4    18*   Changes made to element_id must also be made to datum_id, declared in 
  4    19*   dm_cm_datum.incl.pl1.
  4    20**/
  4    21 
  4    22 /* HISTORY:
  4    23*Written by Matthew Pierret, 04/01/82.
  4    24*Modified:
  4    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  4    26**/
  4    27 
  4    28 /* format: style2,ind3,ll79 */
  4    29 
  4    30      dcl	   element_id_string      bit (36) aligned;
  4    31 
  4    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  4    33 	     2 control_interval_id
  4    34 			      fixed bin (24) unal unsigned,
  4    35 	     2 index	      fixed bin (12) unal unsigned;
  4    36 
  4    37 
  4    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
     1754 
     1755 
  5     1 /* BEGIN INCLUDE FILE - dm_im_ci_header.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*
  5     5*          Each node (control interval) in the index has a header which
  5     6*     describes the contents of that node.  Although there are two different
  5     7*     kinds of headers, leaf and branch, they have a great deal in common, the
  5     8*     common_ci_header.  The common_ci_header states which slots are used by
  5     9*     the keys (leaf or branch) in the key_range substructure.  There is an
  5    10*     "upward pointer" to the node's parent branch key (parent_id_string).
  5    11*     There are pointers to the previous and next nodes (previous_id and
  5    12*     next_id) on the same level to facilitate rotation of keys, and sequential
  5    13*     searching.  There is also a count of how much space is in use by the keys.
  5    14*
  5    15**/
  5    16 
  5    17 /* HISTORY:
  5    18*
  5    19*Written by Lindsey Spratt, 03/29/82.
  5    20*Modified:
  5    21*10/25/84 by Lindsey L. Spratt:  Added a description and fixed the history
  5    22*            section format.
  5    23**/
  5    24 
  5    25 /* format: style2,ind3 */
  5    26      dcl	   1 common_ci_header     based (common_ci_header_ptr),
  5    27 	     2 flags	      unaligned,
  5    28 	       3 is_leaf	      bit (1) unaligned,	/* ON for leaf_ci, OFF for branch_ci. */
  5    29 	       3 pad	      bit (17) unaligned,	/* Must be zero. */
  5    30 	     2 key_tail_space_used_since_last_prefix_compaction
  5    31 			      fixed bin (18) unsigned unal,
  5    32 	     2 key_range	      unaligned,
  5    33 	       3 first	      fixed bin (18) unsigned,
  5    34 	       3 last	      fixed bin (18) unsigned,
  5    35 	     2 parent_id_string   bit (36) aligned,
  5    36 	     2 previous_id	      fixed bin (24) unsigned unaligned,
  5    37 	     2 next_id	      fixed bin (24) unsigned unaligned,
  5    38 	     2 pad	      bit (24) unaligned;
  5    39 
  5    40 
  5    41      dcl	   common_ci_header_ptr   ptr;
  5    42 
  5    43      dcl	   1 leaf_ci_header	      based (leaf_ci_header_ptr),
  5    44 	     2 common	      like common_ci_header;
  5    45 
  5    46      dcl	   leaf_ci_header_ptr     ptr;
  5    47 
  5    48      dcl	   1 branch_ci_header     based (branch_ci_header_ptr),
  5    49 	     2 common	      like common_ci_header,
  5    50 	     2 low_branch_id      fixed bin (24) unsigned unaligned,
  5    51 	     2 pad	      bit (12) unaligned;
  5    52 
  5    53      dcl	   branch_ci_header_ptr   ptr;
  5    54 
  5    55 
  5    56      dcl	   (
  5    57 	   DEFAULT_INITIAL_KEY_SLOT
  5    58 			      init (2),
  5    59 	   DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT
  5    60 			      init (1),
  5    61 	   LEAF_CI_HEADER_LENGTH_IN_BITS
  5    62 			      init (180),
  5    63 	   BRANCH_CI_HEADER_LENGTH_IN_BITS
  5    64 			      init (216)
  5    65 	   )		      internal static options (constant) fixed bin;
  5    66 
  5    67 /* END INCLUDE FILE - dm_im_ci_header.incl.pl1 */
     1756 
     1757 
  6     1 /* BEGIN INCLUDE FILE - dm_im_key.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*
  6     5*          There are two formats for keys, the leaf_key structure and the
  6     6*     branch_key structure. The branch_key has two more pieces of information
  6     7*     than the leaf_key. One is the control interval id of the
  6     8*     node for all keys greater than the value of the branch key.  The other is
  6     9*     the number of fields for which there are values in the "string" portion
  6    10*     of the key.  This allows for the storing of only as much data as is needed
  6    11*     to discriminate between the children being split by the branch key.
  6    12**/
  6    13 
  6    14 /* HISTORY:
  6    15*
  6    16*Written by Lindsey Spratt, 03/29/82.
  6    17*Modified:
  6    18*10/25/84 by Lindsey L. Spratt:  Added history and description sections.
  6    19**/
  6    20 
  6    21 /* format: style2,ind3 */
  6    22      dcl	   key_string	      bit (key_string_length) based (key_string_ptr);
  6    23      dcl	   key_string_length      fixed bin (35);
  6    24      dcl	   key_string_ptr	      ptr;
  6    25 
  6    26      dcl	   1 leaf_key	      based (leaf_key_ptr) unaligned,
  6    27 	     2 string	      bit (lk_string_length) unal;
  6    28 
  6    29      dcl	   lk_string_length	      fixed bin (35);
  6    30      dcl	   leaf_key_ptr	      ptr;
  6    31 
  6    32      dcl	   1 branch_key	      based (branch_key_ptr) unaligned,
  6    33 	     2 branch_id	      fixed bin (24) unsigned unaligned,
  6    34 	     2 last_field_idx     fixed bin (12) unaligned unsigned,
  6    35 	     2 string	      bit (bk_string_length) unal;
  6    36 
  6    37      dcl	   BRANCH_KEY_HEADER_LENGTH_IN_BITS
  6    38 			      init (36) fixed bin (35) internal static options (constant);
  6    39      dcl	   bk_string_length	      fixed bin (35);
  6    40      dcl	   branch_key_ptr	      ptr;
  6    41 
  6    42 /* END INCLUDE FILE - dm_im_key.incl.pl1 */
     1758 
     1759 
  7     1 /* BEGIN INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
  7     2 
  7     3 /* DESCRIPTION:
  7     4*     This include file contains declarations of all collection_manager_ 
  7     5*     entrypoints.
  7     6**/
  7     7 
  7     8 /* HISTORY:
  7     9*Written by Matthew Pierret 
  7    10*Modified:
  7    11*04/14/82 by Lindsey Spratt: Changed the control_interval_id parameter of the
  7    12*	  allocate_control_interval operation to be unaligned, as well as
  7    13*	  unsigned.
  7    14*06/17/82 by Matthew Pierret: Added the put_element_portion opertion and
  7    15*            removed the beginning_location parameter from the put_element
  7    16*            operation. Added the create_page_file_operation.
  7    17*08/09/82 by Matthew Pierret: Changed "fixed bin (17)"s to "bit (36) aligned"s
  7    18*            wherever collection_id was required.
  7    19*            Also changed the control_interval_id parameter of the 
  7    20*            allocate_control_interval operation back to be aligned. So there.
  7    21*10/20/82 by Matthew Pierret: Changed $create_page_file to $create_file,
  7    22*            added the argument file_create_info_ptr to $create_file.
  7    23*12/13/82 by Lindsey Spratt:  Corrected $free_control_interval to
  7    24*	  include the zero_on_free bit.
  7    25*12/17/82 by Matthew Pierret: Added cm_$get_id.
  7    26*01/07/83 by Matthew Pierret: Added cm_$put_element_buffered, 
  7    27*            cm_$allocate_element_buffered, cm_$free_element_buffered.
  7    28*04/27/83 by Matthew Pierret: Added cm_$put_unprotected_element,
  7    29*            cm_$put_unprotected_header.
  7    30*11/07/83 by Matthew Pierret: Added $get_element_portion_buffered,
  7    31*             $simple_get_buffered_element.
  7    32*02/08/84 by Matthew Pierret:  Changed $get_id to have only one bit(1)aligned
  7    33*            parameter for specifying absolute/relative nature of search.
  7    34*03/16/84 by Matthew Pierret:  Added cm_$get_control_interval_ptr,
  7    35*            $get_element_ptr, $get_element_portion_ptr, $simple_get_element_ptr
  7    36*04/03/84 by Matthew Pierret:  Added cm_$compact_control_interval.
  7    37*06/06/84 by Matthew Pierret:  Re-named free_element* to delete and
  7    38*            delete_from_ci_buffer.
  7    39*            Re-named *_buffered_ci to =_ci_buffer.
  7    40*            get entries.
  7    41*            modify entries.
  7    42*            Changed calling sequence of modify entries to have a ptr/length
  7    43*            instead of length/ptr parameter pair.
  7    44*03/11/85 by R. Michael Tague:  Added $postcommit_increments.
  7    45**/
  7    46 
  7    47 /* This include file contains declarations of collection_manager_ entrypoints */
  7    48 
  7    49 /* format: style2,ind3 */
  7    50      dcl	   collection_manager_$allocate_control_interval
  7    51 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
  7    52      dcl	   collection_manager_$compact_control_interval
  7    53 			      entry (bit (36) aligned, fixed bin (24) uns, fixed bin (35));
  7    54      dcl	   collection_manager_$create_collection
  7    55 			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  7    56      dcl	   collection_manager_$create_file
  7    57 			      entry (char (*), char (*), ptr, bit (36) aligned, fixed bin (35));
  7    58      dcl	   collection_manager_$destroy_collection
  7    59 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  7    60      dcl	   collection_manager_$free_control_interval
  7    61 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, bit (1) aligned,
  7    62 			      fixed bin (35));
  7    63 
  7    64      dcl	   collection_manager_$delete
  7    65 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  7    66 			      fixed bin (35));
  7    67      dcl	   collection_manager_$delete_from_ci_buffer
  7    68 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  7    69 			      fixed bin (35));
  7    70 
  7    71      dcl	   collection_manager_$get
  7    72 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  7    73 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  7    74      dcl	   collection_manager_$get_control_interval_ptr
  7    75 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, ptr,
  7    76 			      fixed bin (35));
  7    77      dcl	   collection_manager_$get_from_ci_buffer
  7    78 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  7    79 			      ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  7    80      dcl	   collection_manager_$get_by_ci_ptr
  7    81 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  7    82 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), ptr, fixed bin (35));
  7    83      dcl	   collection_manager_$get_header
  7    84 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (17), ptr, bit (1) aligned,
  7    85 			      ptr, fixed bin (35), fixed bin (35));
  7    86      dcl	   collection_manager_$get_id
  7    87 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17),
  7    88 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  7    89      dcl	   collection_manager_$get_portion
  7    90 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  7    91 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  7    92 			      fixed bin (35), fixed bin (35));
  7    93      dcl	   collection_manager_$get_portion_from_ci_buffer
  7    94 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  7    95 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  7    96 			      fixed bin (35));
  7    97      dcl	   collection_manager_$get_portion_by_ci_ptr
  7    98 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  7    99 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  7   100 			      fixed bin (35));
  7   101      dcl	   collection_manager_$modify
  7   102 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  7   103 			      fixed bin (35), fixed bin (35));
  7   104      dcl	   collection_manager_$modify_unprotected
  7   105 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  7   106 			      fixed bin (35), fixed bin (35));
  7   107      dcl	   collection_manager_$modify_in_ci_buffer
  7   108 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  7   109 			      fixed bin (35), fixed bin (35));
  7   110      dcl	   collection_manager_$modify_portion
  7   111 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35), ptr,
  7   112 			      fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  7   113      dcl	   collection_manager_$postcommit_increments
  7   114 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  7   115      dcl	   collection_manager_$put
  7   116 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  7   117 			      fixed bin (35), fixed bin (35));
  7   118      dcl	   collection_manager_$put_in_ci_buffer
  7   119 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  7   120 			      fixed bin (35), fixed bin (35));
  7   121      dcl	   collection_manager_$put_header
  7   122 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  7   123      dcl	   collection_manager_$put_unprotected_header
  7   124 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  7   125 
  7   126      dcl	   collection_manager_$replace_ci_buffer
  7   127 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  7   128 			      fixed bin (35));
  7   129      dcl	   collection_manager_$setup_ci_buffer
  7   130 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  7   131 			      fixed bin (35));
  7   132      dcl	   collection_manager_$simple_get_by_ci_ptr
  7   133 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  7   134 			      fixed bin (35));
  7   135      dcl	   collection_manager_$simple_get_from_ci_buffer
  7   136 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  7   137 			      fixed bin (35));
  7   138 
  7   139 /* END INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
     1760 
     1761 
  8     1 /* BEGIN INCLUDE FILE - dm_specification.incl.pl1 */
  8     2 
  8     3 /* DESCRIPTION:
  8     4*
  8     5*          The specification structure is used to identify sets items based on
  8     6*     the value of some of the contents of the items (the
  8     7*     search_specification), or based on the ordinal position (the
  8     8*     numeric_specification) of the first or last item in the desired set of
  8     9*     items in the set of all possible items.  It is used with the relation,
  8    10*     index and record managers.  The items for these three managers are
  8    11*     tuples, keys and records, respectively.  The sets of "all possible
  8    12*     items", for determination of ordinal position for these three managers
  8    13*     are: a relation, an index, and a record collection, respectively.
  8    14*     
  8    15*          The specification_head structure, in dm_specification_head.incl.pl1,
  8    16*     must be included in any program which uses this (the
  8    17*     dm_specification.incl.pl1) include file.
  8    18**/
  8    19 
  8    20 /* HISTORY:
  8    21*
  8    22*Written by Lindsey Spratt, 05/19/82.
  8    23*Modified:
  8    24*08/17/82 by Matthew Pierret:  Added all specification type constants.
  8    25*09/24/82 by Ronald Harvey: Changed version and added and_groups.
  8    26*10/22/82 by Lindsey Spratt:  Added the range_size to the numeric_specification.
  8    27*	  Changed the version to 3.
  8    28*05/11/83 by Matthew Pierret: Moved specification_head and and type constants
  8    29*            to dm_specification_head.incl.pl1. Added constraint.value_field_id.
  8    30*            Moved range type constants into dm_range_constants.incl.pl1.
  8    31*05/20/83 by Matthew Pierret: Added constraint.value_field_id for specifying
  8    32*            intra-key/record compares.
  8    33*10/02/84 by Lindsey L. Spratt:  Moved a misplaced journalization comment.
  8    34*            Added a DESCRIPTION comment.
  8    35**/
  8    36 
  8    37 /* format: style2,ind3 */
  8    38      dcl	   1 search_specification based (search_specification_ptr),
  8    39 	     2 head	      like specification_head,
  8    40 	     2 maximum_number_of_constraints
  8    41 			      fixed bin (17) unal,
  8    42 	     2 number_of_and_groups
  8    43 			      fixed bin (17) unal,
  8    44 	     2 range	      unal,
  8    45 	       3 type	      fixed bin (17),
  8    46 	       3 size	      fixed bin (17),
  8    47 	     2 and_group	      (ss_number_of_and_groups refer (search_specification.number_of_and_groups)),
  8    48 	       3 number_of_constraints
  8    49 			      fixed bin (17) unal,
  8    50 	       3 constraint	      (ss_maximum_number_of_constraints
  8    51 			      refer (search_specification.maximum_number_of_constraints)),
  8    52 	         4 field_id	      fixed bin (17) unal,
  8    53 	         4 operator_code  fixed bin (17) unal,
  8    54 	         4 value_field_id fixed bin (17) unal,
  8    55 	         4 pad	      bit (18) unal,
  8    56 	         4 value_ptr      ptr unal;
  8    57 
  8    58      dcl	   search_specification_ptr
  8    59 			      ptr;
  8    60      dcl	   (ss_number_of_and_groups, ss_maximum_number_of_constraints)
  8    61 			      fixed bin (17);
  8    62 
  8    63      dcl	   1 numeric_specification
  8    64 			      based (numeric_specification_ptr),
  8    65 	     2 head	      like specification_head,
  8    66 	     2 range_size	      fixed bin (35) aligned,
  8    67 	     2 position_number    fixed bin (17) unal,
  8    68 	     2 pad	      bit (18) unal;
  8    69 
  8    70      dcl	   numeric_specification_ptr
  8    71 			      ptr;
  8    72 
  8    73 /* END INCLUDE FILE - dm_specification.incl.pl1 */
     1762 
     1763 
  9     1 /* BEGIN INCLUDE FILE dm_specification_head.incl.pl1 */
  9     2 
  9     3 /* HISTORY:
  9     4*Written by Matthew Pierret, 05/11/83. (Extracted from dm_specification.incl.pl1)
  9     5*Modified:
  9     6*05/20/83 by Matthew Pierret: Changed to use version 4.
  9     7**/
  9     8 
  9     9 /* format: style2,ind3 */
  9    10      dcl	   1 specification_head   based (specification_head_ptr),
  9    11 	     2 version	      fixed bin (35),
  9    12 	     2 type	      fixed bin (17) unal,
  9    13 	     2 pad	      bit (18) unal,
  9    14 	     2 subset_specification_ptr
  9    15 			      ptr;
  9    16 
  9    17 
  9    18      dcl	   specification_head_ptr ptr;
  9    19      dcl	   SPECIFICATION_VERSION_4
  9    20 			      init (4) fixed bin (35) internal static options (constant);
  9    21 
  9    22      dcl	   (
  9    23 	   SEARCH_SPECIFICATION_TYPE
  9    24 			      init (1),
  9    25 	   ABSOLUTE_SEARCH_SPECIFICATION_TYPE
  9    26 			      init (1),
  9    27 	   NUMERIC_SPECIFICATION_TYPE
  9    28 			      init (2),
  9    29 	   ABSOLUTE_NUMERIC_SPECIFICATION_TYPE
  9    30 			      init (2),
  9    31 	   RELATIVE_SEARCH_SPECIFICATION_TYPE
  9    32 			      init (3),
  9    33 	   RELATIVE_NUMERIC_SPECIFICATION_TYPE
  9    34 			      init (4),
  9    35 	   ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
  9    36 			      init (5),
  9    37 	   RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
  9    38 			      init (6),
  9    39 	   ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
  9    40 			      init (7),
  9    41 	   RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
  9    42 			      init (8)
  9    43 	   )		      fixed bin (17) internal static options (constant);
  9    44 
  9    45 
  9    46 /* END INCLUDE FILE dm_specification_head.incl.pl1 */
     1764 
     1765 
 10     1 /* BEGIN INCLUDE FILE dm_range_constants.incl.pl1. */
 10     2 
 10     3 /* HISTORY:
 10     4*Written by Matthew Pierret, 05/27/83.
 10     5*Modified:
 10     6**/
 10     7 
 10     8      dcl	   (
 10     9 	   ALL_RANGE_TYPE	      init (1),
 10    10 	   LOW_RANGE_TYPE	      init (2),
 10    11 	   HIGH_RANGE_TYPE	      init (3)
 10    12 	   )		      fixed bin internal static options (constant);
 10    13 
 10    14 
 10    15 /* END INCLUDE FILE dm_range_constants.incl.pl1. */
     1766 
     1767 
 11     1 /* ********** BEGIN INCLUDE FILE dm_field_table.incl.pl1 ********** */
 11     2 
 11     3 /* DESCRIPTION:
 11     4*
 11     5*          The field_table describes the layout of a set of fields in a
 11     6*     formatted data string.  Such a string is the stored representation of a
 11     7*     record or a key.  Fields are placed side-by-side in the string in the
 11     8*     order they appear in the field_table.field array.  The string is divided
 11     9*     into the fixed portion and the varying portion.  In the fixed portion
 11    10*     appear fixed-length fields and fixed-size length-fields for
 11    11*     varying-length fields.  In the varying portion appear varying length
 11    12*     fields.  The length-field for a varying-length field contains the length
 11    13*     of the field values either in bits or in characters, depending on the
 11    14*     data type of the field.
 11    15**/
 11    16 
 11    17 /* HISTORY:
 11    18*Written by Matthew Pierret, 04/01/82.
 11    19*Modified:
 11    20*04/20/82 by Matthew Pierret: Added length_is_in_characters, meaning, if on,
 11    21*	  that if the field is varying, its length is expressed in
 11    22*	  bytes/characters.
 11    23*03/22/83 by Lindsey Spratt:  Changed lofvf to have a precision of 35 instead
 11    24*	  of 17, changed version to 2, changed version field to char(8) from
 11    25*	  fixed bin (17).
 11    26*05/01/84 by Matthew Pierret:  Changed version to 3. Removed field.name and
 11    27*            put field names in one string (field_names) at the end of the 
 11    28*            structure. Added field.location_of_name and field.length_of_name
 11    29*            for locating the field name in field_names. Aligned all "fixed bin"
 11    30*            structure elements.  Changed maximum_field_name_length to 
 11    31*            length_of_field_names.
 11    32**/
 11    33 
 11    34 /* format: style2 */
 11    35 
 11    36      dcl	   1 field_table	      aligned based (field_table_ptr),
 11    37 	     2 version	      char (8) aligned init (FIELD_TABLE_VERSION_3),
 11    38 	     2 number_of_fields   fixed bin (17),
 11    39 	     2 length_of_field_names
 11    40 			      fixed bin (17),	/* length of field_names in characters */
 11    41 	     2 location_of_first_varying_field
 11    42 			      fixed bin (35),	/* location of first bit in the varying portion of the formatted string */
 11    43 	     2 field	      (ft_number_of_fields refer (field_table.number_of_fields)),
 11    44 	       3 flags	      aligned,
 11    45 	         4 descriptor_is_varying
 11    46 			      bit (1) unal,		/* if on, the descriptor is not limited to the standard 36 bits */
 11    47 						/* and is stored in a stand-alone fashion, with field.descriptor */
 11    48 						/* containing the id of the element in which the descriptor is stored. */
 11    49 	         4 length_is_in_characters
 11    50 			      bit (1) unal,		/* if field is varying, the length field describes its length */
 11    51 						/* in characters instead of in bits */
 11    52 	         4 must_be_zero   bit (34) unal,
 11    53 	       3 descriptor	      bit (36) aligned,
 11    54 	       3 location	      fixed bin (35),	/* location of first bit of field in formatted string */
 11    55 	       3 length_in_bits   fixed bin (35),	/* length of field in bits */
 11    56 	     3 location_of_name   fixed bin (17),	/* location of first character of field name in field_names */
 11    57 	     3 length_of_name     fixed bin (17),	/* length of name in characters */
 11    58 	     2 varying_field_map  (ft_number_of_fields refer (field_table.number_of_fields)),
 11    59 	       3 field_id	      fixed bin (17),	/* field_id of Nth varying field */
 11    60 	       3 varying_field_index
 11    61 			      fixed bin (17),	/* ordinality among varying fields of field N */
 11    62 	     2 field_names	      char (ft_length_of_field_names refer (field_table.length_of_field_names));
 11    63 
 11    64 
 11    65      dcl	   field_table_ptr	      ptr;
 11    66      dcl	   ft_length_of_field_names
 11    67 			      fixed bin;
 11    68      dcl	   ft_number_of_fields    fixed bin;
 11    69      dcl	   FIELD_TABLE_VERSION_3  char (8) aligned init ("FldTbl 3") internal static options (constant);
 11    70 
 11    71 dcl field_name char (field_name_length) based (field_name_ptr);
 11    72 
 11    73 dcl field_name_length fixed bin;
 11    74 dcl field_name_ptr ptr;
 11    75 
 11    76 /* END INCLUDE FILE dm_field_table.incl.pl1 */
     1768 
     1769 
 12     1 /* BEGIN INCLUDE FILE dm_ci_lengths.incl.pl1 */
 12     2 
 12     3 /* DESCRIPTION:
 12     4*       This include file contains constants which are the length in bytes
 12     5*   of the addressable portion of a control interval.  The addressable portion
 12     6*   is that part of the control interval which callers of file_manager_
 12     7*   may access, specifically, everything between the end of the control
 12     8*   interval header (ci_header) and the control interval trailer (ci_trailer).
 12     9*   Control interval 0 is slightly different, as it also contains an 
 12    10*   unaddressable portion in which it maintains the file attributes.  For
 12    11*   control interval 0 the addressable portion is everything between the end
 12    12*   of the control interval header and the beginning of the file attributes.
 12    13**/
 12    14 
 12    15 /* HISTORY:
 12    16*Written by Matthew Pierret, 11/02/84.
 12    17*Modified:
 12    18**/
 12    19 
 12    20 /* format: style2,ind3 */
 12    21 
 12    22      dcl	   CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES
 12    23 			      fixed bin (17) init (4072) int static options (constant);
 12    24 
 12    25      dcl	   CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES
 12    26 			      fixed bin (17) init (3176) int static options (constant);
 12    27 
 12    28 
 12    29      dcl	   CI_ADDRESSABLE_LENGTH  fixed bin (17) init (4072) int static options (constant);
 12    30 
 12    31      dcl	   CI_0_ADDRESSABLE_LENGTH
 12    32 			      fixed bin (17) init (3176) int static options (constant);
 12    33 
 12    34 /* END INCLUDE FILE dm_ci_lengths.incl.pl1 */
     1770 
     1771 
 13     1 /* ***********************************************************
 13     2*   *                                                         *
 13     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
 13     4*   *                                                         *
 13     5*   *********************************************************** */
 13     6 /* BEGIN INCLUDE FILE - vu_typed_vector.incl.pl1 */
 13     7 
 13     8 /* Written by Lindsey Spratt, 04/02/82.
 13     9*Modified:
 13    10*09/01/82 by Lindsey Spratt:  Changed value_ptr in simple_typed_vector to be
 13    11*	  unaligned.  Changed the type number of the simple_typed_vector to
 13    12*	  "3" from "1".  The OLD_SIMPLE_TYPED_VECTOR_TYPE is now an invalid
 13    13*	  type.
 13    14**/
 13    15 
 13    16 /* format: style2,ind3 */
 13    17      dcl	   1 simple_typed_vector  based (simple_typed_vector_ptr),
 13    18 	     2 type	      fixed bin (17) unal,
 13    19 	     2 number_of_dimensions
 13    20 			      fixed bin (17) unal,
 13    21 	     2 dimension	      (stv_number_of_dimensions refer (simple_typed_vector.number_of_dimensions)),
 13    22 	       3 value_ptr	      ptr unaligned;
 13    23 
 13    24      dcl	   1 general_typed_vector based (general_typed_vector_ptr),
 13    25 	     2 type	      fixed bin (17) unal,
 13    26 	     2 number_of_dimensions
 13    27 			      fixed bin (17) unal,
 13    28 	     2 dimension	      (gtv_number_of_dimensions refer (general_typed_vector.number_of_dimensions)),
 13    29 	       3 identifier	      fixed bin (17) unal,
 13    30 	       3 pad	      bit (18) unal,
 13    31 	       3 value_ptr	      ptr unal;
 13    32 
 13    33      dcl	   simple_typed_vector_ptr
 13    34 			      ptr;
 13    35      dcl	   stv_number_of_dimensions
 13    36 			      fixed bin (17);
 13    37 
 13    38      dcl	   general_typed_vector_ptr
 13    39 			      ptr;
 13    40      dcl	   gtv_number_of_dimensions
 13    41 			      fixed bin (17);
 13    42 
 13    43      dcl	   (
 13    44 	   OLD_SIMPLE_TYPED_VECTOR_TYPE
 13    45 			      init (1),		/* value_ptr was aligned. */
 13    46 	   GENERAL_TYPED_VECTOR_TYPE
 13    47 			      init (2),
 13    48 	   SIMPLE_TYPED_VECTOR_TYPE
 13    49 			      init (3)
 13    50 	   )		      fixed bin (17) internal static options (constant);
 13    51 
 13    52 /* END INCLUDE FILE - vu_typed_vector.incl.pl1 */
     1772 
     1773    end im_process_keys$get;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/04/85  0913.3  im_process_keys.pl1               >spec>on>7192.pbf-04/04/85>im_process_keys.pl1
1748         1    01/07/85  0858.9  dm_im_cursor.incl.pl1             >ldd>include>dm_im_cursor.incl.pl1
1750         2    10/14/83  1609.1  vu_typed_vector_array.incl.pl1    >ldd>include>vu_typed_vector_array.incl.pl1
1752         3    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
1754         4    01/07/85  0858.5  dm_element_id.incl.pl1            >ldd>include>dm_element_id.incl.pl1
1756         5    01/07/85  0858.8  dm_im_ci_header.incl.pl1          >ldd>include>dm_im_ci_header.incl.pl1
1758         6    01/07/85  0858.9  dm_im_key.incl.pl1                >ldd>include>dm_im_key.incl.pl1
1760         7    04/04/85  0819.0  dm_collmgr_entry_dcls.incl.pl1    >spec>on>7192.pbf-04/04/85>dm_collmgr_entry_dcls.incl.pl1
1762         8    01/07/85  0859.8  dm_specification.incl.pl1         >ldd>include>dm_specification.incl.pl1
1764         9    10/14/83  1609.1  dm_specification_head.incl.pl1    >ldd>include>dm_specification_head.incl.pl1
1766        10    10/14/83  1609.1  dm_range_constants.incl.pl1       >ldd>include>dm_range_constants.incl.pl1
1768        11    01/07/85  0858.8  dm_field_table.incl.pl1           >ldd>include>dm_field_table.incl.pl1
1770        12    01/07/85  0900.7  dm_ci_lengths.incl.pl1            >ldd>include>dm_ci_lengths.incl.pl1
1772        13    10/14/83  1609.1  vu_typed_vector.incl.pl1          >ldd>include>vu_typed_vector.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ABSOLUTE_NUMERIC_SPECIFICATION_TYPE
                                000047 constant        fixed bin(17,0)          initial dcl 9-22 set ref 1264 1275*
ABSOLUTE_SEARCH_SPECIFICATION_TYPE
                                000050 constant        fixed bin(17,0)          initial dcl 9-22 set ref 1253 1275*
ACTION_CANT_RESTART             000025 constant        bit(36)                  initial dcl 3-7 set ref 541* 688* 701* 1275*
BITS_PER_PAGE                          constant        fixed bin(35,0)          initial dcl 363 ref 495 495 495 495
COUNT_OPERATION                        constant        fixed bin(35,0)          initial dcl 363 ref 448
DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT
                                       constant        fixed bin(17,0)          initial dcl 5-56 ref 917
DEFAULT_INITIAL_KEY_SLOT               constant        fixed bin(17,0)          initial dcl 5-56 ref 1661
DELETE_OPERATION                       constant        fixed bin(35,0)          initial dcl 363 ref 439 529 1506 1646 1697
DOUBLE_WORDS_PER_PAGE                  constant        fixed bin(35,0)          initial dcl 363 ref 308
FIELD_TABLE_VERSION_3           000000 constant        char(8)                  initial dcl 11-69 set ref 488*
GET_OPERATION                          constant        fixed bin(35,0)          initial dcl 363 ref 421 500 527 547 1489
HIGH_RANGE_TYPE                        constant        fixed bin(17,0)          initial dcl 10-8 ref 1259
INDEX_CURSOR_TYPE               000047 constant        fixed bin(17,0)          initial dcl 1-67 set ref 476 476*
INDEX_CURSOR_VERSION_3                 constant        fixed bin(17,0)          initial dcl 1-66 ref 481
IS_BEING_DELETED                000037 constant        bit(1)                   initial dcl 361 set ref 767*
LIMIT_TO_STOP_INFINITE_LOOPING  000002 constant        fixed bin(35,0)          initial dcl 363 ref 509 541
NULL_PSEUDO_FIELD_VALUE         000037 constant        bit(36)                  initial unaligned dcl 359 set ref 1741*
POSITION_OPERATION                     constant        fixed bin(35,0)          initial dcl 363 ref 431 1497 1647
RELATIVE_NUMERIC_SPECIFICATION_TYPE
                                000045 constant        fixed bin(17,0)          initial dcl 9-22 set ref 1264 1275*
RELATIVE_SEARCH_SPECIFICATION_TYPE
                                000046 constant        fixed bin(17,0)          initial dcl 9-22 set ref 1253 1275*
SPECIFICATION_VERSION_4         000045 constant        fixed bin(35,0)          initial dcl 9-19 set ref 484*
TYPED_VECTOR_ARRAY_VERSION_2           constant        fixed bin(35,0)          initial dcl 2-50 ref 423 619
VECTOR_SLOT_PAD                        constant        fixed bin(35,0)          initial dcl 363 ref 609
abs                                                    builtin function         dcl 352 ref 1273
addr                                                   builtin function         dcl 352 ref 493 495 495 495 495 495 495 495 495 657
                                                                                  657 676 676 714 714 764 765 785 916 917 1048 1049
                                                                                  1219 1220 1224 1226 1486 1487 1528 1529
ae_last_key_id                         based           structure                level 1 packed unaligned dcl 649
ae_last_key_id_string           000274 automatic       bit(36)                  dcl 650 set ref 655* 657 657
ae_leaf_ci_header                      based           structure                level 1 unaligned dcl 651
ae_leaf_ci_header_ptr           000276 automatic       pointer                  dcl 652 set ref 654* 657 657
ae_p_ci                                parameter       fixed bin(24,0)          unsigned dcl 646 ref 643 657
ae_p_index                             parameter       fixed bin(12,0)          unsigned dcl 647 ref 643 657 657 657 657
ae_p_position_info_ptr                 parameter       pointer                  dcl 645 set ref 643 654* 655*
akto_code                       000250 automatic       fixed bin(35,0)          initial dcl 588 set ref 588*
akto_new_tva_ptr                000252 automatic       pointer                  initial dcl 589 set ref 589* 617* 619 620 622 624
                                                                                  625 628 628 631 631 633 636
akto_old_tva_ptr                000254 automatic       pointer                  initial dcl 590 set ref 590* 615* 620 622 625 635
akto_p_number_of_keys_accepted         parameter       fixed bin(35,0)          dcl 585 set ref 578 638*
akto_p_position_info_ptr               parameter       pointer                  dcl 581 set ref 578 597* 608* 640*
akto_p_typed_vector_array_ptr          parameter       pointer                  dcl 583 set ref 578 599 599 601 601 601 601 609 611
                                                                                  612 615 636* 638
akto_vector_ptr                 000256 automatic       pointer                  dcl 591 set ref 597* 601 628
akto_vector_slot_idx            000260 automatic       fixed bin(17,0)          dcl 592 set ref 624* 625 625* 631* 633*
akto_work_area                         based           area(1024)               dcl 593 ref 617 635
akto_work_area_ptr              000262 automatic       pointer                  initial dcl 594 set ref 594* 608* 617 635
bb_first_key_id                        based           structure                level 1 packed unaligned dcl 668
bb_first_key_id_string          000306 automatic       bit(36)                  dcl 669 set ref 674* 676 676
bb_leaf_ci_header                      based           structure                level 1 unaligned dcl 670
bb_leaf_ci_header_ptr           000310 automatic       pointer                  dcl 671 set ref 673* 676 676
bb_p_ci                                parameter       fixed bin(24,0)          unsigned dcl 665 ref 662 676
bb_p_index                             parameter       fixed bin(12,0)          unsigned dcl 666 ref 662 676 676
bb_p_position_info_ptr                 parameter       pointer                  dcl 664 set ref 662 673* 674*
bin                                                    builtin function         dcl 352 ref 1646 1697
collection_id             2            based           bit(36)                  level 2 dcl 1-29 ref 943
collection_manager_$get_control_interval_ptr
                                000044 constant        entry                    external dcl 7-74 ref 1108
collection_manager_$simple_get_by_ci_ptr
                                000046 constant        entry                    external dcl 7-132 ref 919 1051
common                                 based           structure                level 2 in structure "snk_leaf_ci_header" unaligned
                                                                                  dcl 1600 in procedure "SETUP_NEXT_KEY"
common                                 based           structure                level 2 in structure "bb_leaf_ci_header" unaligned
                                                                                  dcl 670 in procedure "BEFORE_BEGINNING"
common                                 based           structure                level 2 in structure "fp_leaf_ci_header" unaligned
                                                                                  dcl 799 in procedure "FIND_POSITION"
common                                 based           structure                level 2 in structure "sc_leaf_ci_header" unaligned
                                                                                  dcl 1470 in procedure "SET_INDEX_CURSOR"
common                                 based           structure                level 2 in structure "ae_leaf_ci_header" unaligned
                                                                                  dcl 651 in procedure "AFTER_END"
common                                 based           structure                level 2 in structure "leaf_ci_header" unaligned
                                                                                  dcl 5-43 in procedure "im_process_keys$get"
common_ci_header                       based           structure                level 1 unaligned dcl 5-26
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "dkfi_last_key_id" packed
                                                                                  unsigned unaligned dcl 742 in procedure
                                                                                  "DELETE_KEY_FROM_INDEX" ref 785
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "gch_element_id" packed
                                                                                  unsigned unaligned dcl 903 in procedure
                                                                                  "GET_CI_HEADER" set ref 916*
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "gk_element_id" packed unsigned
                                                                                  unaligned dcl 1033 in procedure "GET_KEY" set ref
                                                                                  1048*
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "dkfi_element_id" packed
                                                                                  unsigned unaligned dcl 738 in procedure
                                                                                  "DELETE_KEY_FROM_INDEX" set ref 764*
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "ae_last_key_id" packed
                                                                                  unsigned unaligned dcl 649 in procedure
                                                                                  "AFTER_END" ref 657
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "element_id" packed unsigned
                                                                                  unaligned dcl 4-32 in procedure
                                                                                  "im_process_keys$get" ref 1219 1224
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "sc_element_id" packed unsigned
                                                                                  unaligned dcl 1477 in procedure "SET_INDEX_CURSOR"
                                                                                  set ref 1486* 1528*
control_interval_id                    based           fixed bin(24,0)          level 2 in structure "bb_first_key_id" packed
                                                                                  unsigned unaligned dcl 668 in procedure
                                                                                  "BEFORE_BEGINNING" ref 676
cv_p_expected_version                  parameter       fixed bin(35,0)          dcl 685 set ref 681 688 688*
cv_p_received_version                  parameter       fixed bin(35,0)          dcl 684 set ref 681 688 688*
cv_p_structure_name                    parameter       char                     unaligned dcl 686 set ref 681 688*
cvc_p_expected_version                 parameter       char(8)                  dcl 697 set ref 695 701 701*
cvc_p_received_version                 parameter       char(8)                  dcl 697 set ref 695 701 701*
cvc_p_structure_name                   parameter       char                     unaligned dcl 699 set ref 695 701*
data_format_util_$compare_sequential
                                000022 constant        entry                    external dcl 393 ref 1451
data_format_util_$cv_string_to_vector
                                000026 constant        entry                    external dcl 397 ref 971 1141
dimension                 1            based           structure                array level 2 packed unaligned dcl 13-17
dimension_table           6            based           structure                array level 2 dcl 2-21 set ref 622* 622
divide                                                 builtin function         dcl 352 ref 1397
dkfi_code                       000342 automatic       fixed bin(35,0)          initial dcl 736 set ref 736* 767* 770 770* 775* 778
                                                                                  778*
dkfi_deleted_node               000343 automatic       bit(1)                   initial dcl 737 set ref 737* 775* 781
dkfi_element_id                        based           structure                level 1 packed unaligned dcl 738
dkfi_element_id_string          000344 automatic       bit(36)                  dcl 739 set ref 764 765 767* 775*
dkfi_field_table_ptr            000346 automatic       pointer                  dcl 740 set ref 755* 767*
dkfi_index_cursor_ptr           000350 automatic       pointer                  dcl 741 set ref 756* 767* 775*
dkfi_last_key_id                       based           structure                level 1 packed unaligned dcl 742
dkfi_last_key_id_string         000352 automatic       bit(36)                  dcl 743 set ref 762* 785
dkfi_leaf_ci_header_ptr         000354 automatic       pointer                  dcl 745 set ref 757* 767* 775*
dkfi_leaf_key_ptr               000356 automatic       pointer                  dcl 747 set ref 761* 767*
dkfi_lk_string_length           000360 automatic       fixed bin(35,0)          dcl 748 set ref 761* 767*
dkfi_node_id                    000361 automatic       fixed bin(24,0)          unsigned dcl 749 set ref 758* 764 785
dkfi_node_ptr                   000362 automatic       pointer                  dcl 750 set ref 759* 767* 775*
dkfi_p_get_keys_in_reverse_order       parameter       bit(1)                   dcl 726 ref 722 785
dkfi_p_key_count_array_ptr             parameter       pointer                  dcl 732 set ref 722 767*
dkfi_p_number_of_keys_accepted         parameter       fixed bin(35,0)          dcl 730 set ref 722 773* 773
dkfi_p_position_info_ptr               parameter       pointer                  dcl 728 set ref 722 754* 755* 756* 757* 758* 759*
                                                                                  760* 761* 762* 781* 785*
dkfi_slot_index                 000364 automatic       fixed bin(12,0)          unsigned dcl 751 set ref 760* 765
dkfi_work_area_ptr              000366 automatic       pointer                  dcl 752 set ref 754* 767*
dlksi_p_position_info                  based           structure                level 1 dcl 711
dlksi_p_position_info_ptr              parameter       pointer                  dcl 709 ref 707 714 714
dm_error_$bad_first_key_idx     000034 external static fixed bin(35,0)          dcl 402 set ref 925*
dm_error_$bad_last_key_idx      000036 external static fixed bin(35,0)          dcl 402 set ref 927*
dm_error_$bad_leaf_node         000040 external static fixed bin(35,0)          dcl 402 set ref 923*
dm_error_$programming_error     000042 external static fixed bin(35,0)          dcl 402 set ref 541*
dm_error_$wrong_cursor_type     000032 external static fixed bin(35,0)          dcl 402 set ref 476*
element_id                             based           structure                level 1 dcl 4-32
entire_vector_ptr                      based           pointer                  level 2 in structure "ip_p_position_info" dcl 1195
                                                                                  in procedure "INITIALIZE_POSITION" set ref 1198*
entire_vector_ptr                      based           pointer                  level 2 in structure "rv_p_position_info" dcl 1364
                                                                                  in procedure "RESET_VECTORS" set ref 1372 1372*
                                                                                  1375 1375* 1382*
entire_vector_ptr                      based           pointer                  level 2 in structure "gev_p_position_info" dcl 955
                                                                                  in procedure "GET_ENTIRE_VECTOR" set ref 963 971*
                                                                                  977
er_p_code                              parameter       fixed bin(35,0)          dcl 571 ref 569 572
error_table_$unimplemented_version
                                000030 external static fixed bin(35,0)          dcl 402 set ref 688* 701* 1275*
fev_based_dummy                        based           fixed bin(17,0)          dcl 880 ref 884
fev_dimension_idx               000412 automatic       fixed bin(35,0)          initial dcl 881 set ref 881* 883* 884*
fev_p_vector_ptr                       parameter       pointer                  dcl 878 set ref 876 883 884 886 887*
field_table                            based           structure                level 1 dcl 11-36
field_table_ptr           2            based           pointer                  level 2 in structure "position_info" dcl 319
                                                                                  in procedure "im_process_keys$get" ref 987
field_table_ptr                 000176 automatic       pointer                  dcl 11-65 in procedure "im_process_keys$get" set ref
                                                                                  487* 488 495*
field_table_ptr           2            based           pointer                  level 2 in structure "ip_p_position_info" dcl 1195
                                                                                  in procedure "INITIALIZE_POSITION" set ref 1209*
file_opening_id           1            based           bit(36)                  level 2 dcl 1-29 ref 998
finished                        000105 automatic       bit(1)                   dcl 303 set ref 504* 506* 509 536*
first                     1            based           fixed bin(18,0)          level 4 in structure "sc_leaf_ci_header" packed
                                                                                  unsigned unaligned dcl 1470 in procedure
                                                                                  "SET_INDEX_CURSOR" ref 1518
first                     1            based           fixed bin(18,0)          level 4 in structure "leaf_ci_header" packed
                                                                                  unsigned unaligned dcl 5-43 in procedure
                                                                                  "im_process_keys$get" ref 925 927
first                     1            based           fixed bin(18,0)          level 4 in structure "bb_leaf_ci_header" packed
                                                                                  unsigned unaligned dcl 670 in procedure
                                                                                  "BEFORE_BEGINNING" ref 676
first                     1            based           fixed bin(18,0)          level 4 in structure "snk_leaf_ci_header" packed
                                                                                  unsigned unaligned dcl 1600 in procedure
                                                                                  "SETUP_NEXT_KEY" ref 1634 1685 1712
first                     1            based           fixed bin(18,0)          level 4 in structure "fp_leaf_ci_header" packed
                                                                                  unsigned unaligned dcl 799 in procedure
                                                                                  "FIND_POSITION" ref 815 819 821 859
first_key_id_string       4            based           bit(36)                  level 2 in structure "position_info" dcl 319
                                                                                  in procedure "im_process_keys$get" ref 1010
first_key_id_string       4            based           bit(36)                  level 2 in structure "ip_p_position_info" dcl 1195
                                                                                  in procedure "INITIALIZE_POSITION" set ref 1211*
flags                     5            based           structure                level 2 in structure "rv_p_position_info" dcl 1364
                                                                                  in procedure "RESET_VECTORS"
flags                     5            based           structure                level 2 in structure "gch_p_position_info" dcl 907
                                                                                  in procedure "GET_CI_HEADER"
flags                                  based           structure                level 2 in structure "common_ci_header" packed
                                                                                  unaligned dcl 5-26 in procedure
                                                                                  "im_process_keys$get"
flags                     5            based           structure                level 2 in structure "position_info" dcl 319
                                                                                  in procedure "im_process_keys$get"
flags                     5            based           structure                level 2 in structure "gk_p_position_info" dcl 1037
                                                                                  in procedure "GET_KEY"
flags                     5            based           structure                level 2 in structure "ip_p_position_info" dcl 1195
                                                                                  in procedure "INITIALIZE_POSITION" set ref 1203*
fp_leaf_ci_header                      based           structure                level 1 unaligned dcl 799
fp_leaf_ci_header_ptr           000376 automatic       pointer                  dcl 800 set ref 806* 815 819 821 824 827* 828 846
                                                                                  850 852 855 858* 859
fp_node_id                      000400 automatic       fixed bin(24,0)          unsigned dcl 801 set ref 805* 813* 819* 824* 825*
                                                                                  831* 844* 850* 855* 856* 863*
fp_p_finished                          parameter       bit(1)                   dcl 796 set ref 789 813* 831* 844* 863*
fp_p_get_keys_in_reverse_order         parameter       bit(1)                   dcl 792 ref 789 809
fp_p_position_count                    parameter       fixed bin(35,0)          dcl 795 set ref 789 812 835* 843 871*
fp_p_position_info_ptr                 parameter       pointer                  dcl 794 set ref 789 805* 806* 807* 813* 815* 819*
                                                                                  825* 827* 830* 831* 837* 844* 846* 850* 856* 858*
                                                                                  861* 863* 868*
fp_position_change              000401 automatic       fixed bin(35,0)          initial dcl 802 set ref 802* 812* 813 815 815 819
                                                                                  819 821* 821 831 836 843* 844 846 846 850 850 852*
                                                                                  852 863 867
fp_slot_index                   000402 automatic       fixed bin(12,0)          unsigned dcl 803 set ref 807* 813 815 815 819 819
                                                                                  821 828* 830* 831 836* 836 837* 844 846 846 850
                                                                                  850 852 859* 861* 863 867* 867 868*
gch_code                        000444 automatic       fixed bin(35,0)          initial dcl 901 set ref 901* 919* 921 921*
gch_collection_id               000445 automatic       bit(36)                  dcl 902 set ref 912* 919*
gch_element_id                         based           structure                level 1 dcl 903
gch_element_id_string           000446 automatic       bit(36)                  dcl 904 set ref 916 917 919*
gch_node_id                     000447 automatic       fixed bin(24,0)          unsigned dcl 905 set ref 913* 916
gch_node_ptr                    000450 automatic       pointer                  dcl 906 set ref 914* 919*
gch_p_leaf_ci_header_ptr               parameter       pointer                  dcl 898 set ref 894 932*
gch_p_position_info                    based           structure                level 1 dcl 907
gch_p_position_info_ptr                parameter       pointer                  dcl 896 set ref 894 909 912* 913* 914* 919 919 923
                                                                                  925 927 927 930 932
gci_p_collection_id                    parameter       bit(36)                  dcl 941 set ref 937 943*
gci_p_position_info_ptr                parameter       pointer                  dcl 939 in procedure "GET_COLLECTION_ID" ref 937 943
gci_p_position_info_ptr                parameter       pointer                  dcl 1165 in procedure "GET_WORK_AREA" ref 1163 1169
gci_p_work_area_ptr                    parameter       pointer                  dcl 1167 set ref 1163 1169*
get_keys_in_reverse_order       000106 automatic       bit(1)                   initial dcl 304 set ref 304* 490* 495* 506* 529*
                                                                                  536* 550
gev_code                        000466 automatic       fixed bin(35,0)          dcl 957 set ref 971* 973 973*
gev_field_table_ptr             000470 automatic       pointer                  dcl 958 set ref 968* 971*
gev_leaf_key_ptr                000472 automatic       pointer                  dcl 959 set ref 967* 971*
gev_lk_string_length            000474 automatic       fixed bin(35,0)          dcl 960 set ref 967* 971*
gev_p_position_info                    based           structure                level 1 dcl 955
gev_p_position_info_ptr                parameter       pointer                  dcl 951 set ref 949 963 967* 968* 969* 971 977
gev_p_vector_ptr                       parameter       pointer                  dcl 953 set ref 949 977*
gev_work_area_ptr               000476 automatic       pointer                  dcl 961 set ref 969* 971*
gfki_p_first_key_id_string             parameter       bit(36)                  dcl 1007 set ref 1003 1010*
gfki_p_position_info_ptr               parameter       pointer                  dcl 1005 ref 1003 1010
gfoi_p_file_opening_id                 parameter       bit(36)                  dcl 996 set ref 992 998*
gfoi_p_position_info_ptr               parameter       pointer                  dcl 994 ref 992 998
gft_p_field_table_ptr                  parameter       pointer                  dcl 985 set ref 981 987*
gft_p_position_info_ptr                parameter       pointer                  dcl 983 ref 981 987
gic_p_index_cursor_ptr                 parameter       pointer                  dcl 1019 set ref 1015 1021*
gic_p_position_info_ptr                parameter       pointer                  dcl 1017 ref 1015 1021
gk_code                         000536 automatic       fixed bin(35,0)          dcl 1031 set ref 1051* 1054 1054*
gk_collection_id                000537 automatic       bit(36)                  dcl 1032 set ref 1043* 1051*
gk_element_id                          based           structure                level 1 dcl 1033
gk_element_id_string            000540 automatic       bit(36)                  dcl 1034 set ref 1048 1049 1051*
gk_node_id                      000541 automatic       fixed bin(24,0)          unsigned dcl 1035 set ref 1044* 1048
gk_node_ptr                     000542 automatic       pointer                  dcl 1036 set ref 1045* 1051*
gk_p_leaf_key_ptr                      parameter       pointer                  dcl 1027 set ref 1024 1059*
gk_p_leaf_key_string_length            parameter       fixed bin(35,0)          dcl 1028 set ref 1024 1060*
gk_p_position_info                     based           structure                level 1 dcl 1037
gk_p_position_info_ptr                 parameter       pointer                  dcl 1026 set ref 1024 1040 1043* 1044* 1045* 1046*
                                                                                  1051 1051 1051 1056 1059 1060
gk_slot_index                   000544 automatic       fixed bin(12,0)          unsigned dcl 1038 set ref 1046* 1049
glki_p_last_key_id_string              parameter       bit(36)                  dcl 1071 set ref 1067 1074*
glki_p_position_info_ptr               parameter       pointer                  dcl 1069 ref 1067 1074
global_position_info            000122 automatic       structure                level 1 dcl 314 set ref 493
global_position_info_ptr        000120 automatic       pointer                  initial dcl 311 set ref 311* 493* 495* 506* 512*
                                                                                  518* 527* 529* 536* 557*
gni_p_node_id                          parameter       fixed bin(24,0)          unsigned dcl 1083 set ref 1079 1085*
gni_p_position_info_ptr                parameter       pointer                  dcl 1081 ref 1079 1085
gnp_code                        000570 automatic       fixed bin(35,0)          dcl 1095 set ref 1108* 1110 1110*
gnp_collection_id               000571 automatic       bit(36)                  dcl 1096 set ref 1105* 1108*
gnp_file_opening_id             000572 automatic       bit(36)                  dcl 1097 set ref 1104* 1108*
gnp_node_id                     000573 automatic       fixed bin(24,0)          unsigned dcl 1098 set ref 1106* 1108*
gnp_p_node_ptr                         parameter       pointer                  dcl 1093 set ref 1089 1114*
gnp_p_position_info                    based           structure                level 1 dcl 1099
gnp_p_position_info_ptr                parameter       pointer                  dcl 1091 set ref 1089 1101 1104* 1105* 1106* 1108
                                                                                  1114
gsi_p_position_info_ptr                parameter       pointer                  dcl 1154 ref 1152 1158
gsi_p_slot_index                       parameter       fixed bin(12,0)          unsigned dcl 1156 set ref 1152 1158*
gsv_code                        000602 automatic       fixed bin(35,0)          dcl 1124 set ref 1141* 1144 1144*
gsv_field_table_ptr             000604 automatic       pointer                  dcl 1125 set ref 1138* 1141*
gsv_leaf_key_ptr                000606 automatic       pointer                  dcl 1126 set ref 1137* 1141*
gsv_lk_string_length            000610 automatic       fixed bin(35,0)          dcl 1127 set ref 1137* 1141*
gsv_p_position_info                    based           structure                level 1 dcl 1128
gsv_p_position_info_ptr                parameter       pointer                  dcl 1120 set ref 1117 1131 1131 1131* 1131 1137*
                                                                                  1138* 1139* 1141 1141 1147
gsv_p_vector_ptr                       parameter       pointer                  dcl 1122 set ref 1117 1147*
gsv_work_area_ptr               000612 automatic       pointer                  dcl 1129 set ref 1139* 1141*
header_buffer_contains_current_header
                          5            based           bit(1)                   level 3 in structure "gch_p_position_info" packed
                                                                                  unaligned dcl 907 in procedure "GET_CI_HEADER" set
                                                                                  ref 909 930*
header_buffer_contains_current_header
                          5            based           bit(1)                   level 3 in structure "position_info" packed
                                                                                  unaligned dcl 319 in procedure
                                                                                  "im_process_keys$get" set ref 1315*
header_buffer_length      6            based           fixed bin(35,0)          level 2 in structure "ip_p_position_info" dcl 1195
                                                                                  in procedure "INITIALIZE_POSITION" set ref 1207*
header_buffer_length      6            based           fixed bin(35,0)          level 2 in structure "gch_p_position_info" dcl 907
                                                                                  in procedure "GET_CI_HEADER" set ref 919*
header_buffer_ptr        10            based           pointer                  level 2 in structure "ip_p_position_info" dcl 1195
                                                                                  in procedure "INITIALIZE_POSITION" set ref 1208*
header_buffer_ptr        10            based           pointer                  level 2 in structure "gch_p_position_info" dcl 907
                                                                                  in procedure "GET_CI_HEADER" set ref 919* 923 925
                                                                                  927 927 932
id_list_ptr              12            based           pointer                  level 2 in structure "gsv_p_position_info" dcl 1128
                                                                                  in procedure "GET_SELECTED_VECTOR" set ref 1131
                                                                                  1141*
id_list_ptr              12            based           pointer                  level 2 in structure "ip_p_position_info" dcl 1195
                                                                                  in procedure "INITIALIZE_POSITION" set ref 1213*
im_compare_subset               000012 constant        entry                    external dcl 381 ref 1741
im_general_delete               000010 constant        entry                    external dcl 380 ref 775
im_set_cursor$at_current        000016 constant        entry                    external dcl 385 ref 1492 1501 1531
im_set_cursor$at_end            000020 constant        entry                    external dcl 391 ref 1538
im_update_key_counts            000014 constant        entry                    external dcl 382 ref 767
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "gch_element_id" packed
                                                                                  unsigned unaligned dcl 903 in procedure
                                                                                  "GET_CI_HEADER" set ref 917*
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "sc_element_id" packed unsigned
                                                                                  unaligned dcl 1477 in procedure "SET_INDEX_CURSOR"
                                                                                  set ref 1487* 1529*
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "dkfi_element_id" packed
                                                                                  unsigned unaligned dcl 738 in procedure
                                                                                  "DELETE_KEY_FROM_INDEX" set ref 765*
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "ae_last_key_id" packed
                                                                                  unsigned unaligned dcl 649 in procedure
                                                                                  "AFTER_END" ref 657
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "gk_element_id" packed unsigned
                                                                                  unaligned dcl 1033 in procedure "GET_KEY" set ref
                                                                                  1049*
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "bb_first_key_id" packed
                                                                                  unsigned unaligned dcl 668 in procedure
                                                                                  "BEFORE_BEGINNING" ref 676
index                     0(24)        based           fixed bin(12,0)          level 2 in structure "element_id" packed unsigned
                                                                                  unaligned dcl 4-32 in procedure
                                                                                  "im_process_keys$get" set ref 714* 714 1220 1226
index_cursor                           based           structure                level 1 unaligned dcl 1-29
index_cursor_ptr         14            based           pointer                  level 2 in structure "position_info" dcl 319
                                                                                  in procedure "im_process_keys$get" ref 943 998
                                                                                  1021
index_cursor_ptr         14            based           pointer                  level 2 in structure "ip_p_position_info" dcl 1195
                                                                                  in procedure "INITIALIZE_POSITION" set ref 1204*
index_cursor_ptr                000160 automatic       pointer                  dcl 1-64 in procedure "im_process_keys$get" set ref
                                                                                  475* 476 476 481 495*
input_number_of_keys_accepted   000102 automatic       fixed bin(35,0)          initial dcl 301 set ref 301* 500* 502* 550*
ip_p_field_table_ptr                   parameter       pointer                  dcl 1184 ref 1173 1209
ip_p_first_key_id_string               parameter       bit(36)                  dcl 1186 set ref 1173 1211 1224 1226
ip_p_get_keys_in_reverse_order         parameter       bit(1)                   dcl 1191 ref 1173 1216
ip_p_header_buffer_length              parameter       fixed bin(35,0)          dcl 1180 ref 1173 1207
ip_p_header_buffer_ptr                 parameter       pointer                  dcl 1179 ref 1173 1208
ip_p_id_list_ptr                       parameter       pointer                  dcl 1190 ref 1173 1213
ip_p_index_cursor_ptr                  parameter       pointer                  dcl 1178 ref 1173 1204
ip_p_key_buffer_length                 parameter       fixed bin(35,0)          dcl 1183 ref 1173 1205
ip_p_key_buffer_ptr                    parameter       pointer                  dcl 1182 ref 1173 1206
ip_p_last_key_id_string                parameter       bit(36)                  dcl 1188 set ref 1173 1212 1219
ip_p_position_info                     based           structure                level 1 dcl 1195
ip_p_position_info_ptr                 parameter       pointer                  dcl 1193 set ref 1173 1197 1198 1199 1200 1201 1202
                                                                                  1203 1204 1205 1206 1207 1208 1209 1210 1211 1212
                                                                                  1213 1219* 1220* 1224* 1226*
ip_p_work_area_ptr                     parameter       pointer                  dcl 1185 ref 1173 1210
is_leaf                                based           bit(1)                   level 3 packed unaligned dcl 5-26 ref 923
is_p_first_key_id_string               parameter       bit(36)                  dcl 1239 ref 1232 1259
is_p_get_keys_in_reverse_order         parameter       bit(1)                   dcl 1247 set ref 1232 1259* 1270*
is_p_is_search_specification           parameter       bit(1)                   dcl 1241 set ref 1232 1257* 1268*
is_p_numeric_specification_ptr         parameter       pointer                  dcl 1245 set ref 1232 1269* 1270 1272 1273
is_p_position_count                    parameter       fixed bin(35,0)          dcl 1250 set ref 1232 1273*
is_p_range_size                        parameter       fixed bin(35,0)          dcl 1249 set ref 1232 1262* 1272*
is_p_search_specification_ptr          parameter       pointer                  dcl 1243 set ref 1232 1258* 1259 1262
is_p_specification_head_ptr            parameter       pointer                  dcl 1237 ref 1232 1253 1253 1258 1264 1264 1269 1275
is_search_specification         000107 automatic       bit(1)                   initial dcl 304 set ref 304* 490* 506 512 536*
key_buffer                             based           bit                      dcl 348 set ref 495 495 495 495
key_buffer_contains_current_key
                          5(01)        based           bit(1)                   level 3 in structure "position_info" packed
                                                                                  unaligned dcl 319 in procedure
                                                                                  "im_process_keys$get" set ref 1323*
key_buffer_contains_current_key
                          5(01)        based           bit(1)                   level 3 in structure "gk_p_position_info" packed
                                                                                  unaligned dcl 1037 in procedure "GET_KEY" set ref
                                                                                  1040 1056*
key_buffer_length        16            based           fixed bin(35,0)          level 2 in structure "ip_p_position_info" dcl 1195
                                                                                  in procedure "INITIALIZE_POSITION" set ref 1205*
key_buffer_length        16            based           fixed bin(35,0)          level 2 in structure "gk_p_position_info" dcl 1037
                                                                                  in procedure "GET_KEY" set ref 1051*
key_buffer_ptr           20            based           pointer                  level 2 in structure "gk_p_position_info" dcl 1037
                                                                                  in procedure "GET_KEY" set ref 1051* 1059
key_buffer_ptr           20            based           pointer                  level 2 in structure "ip_p_position_info" dcl 1195
                                                                                  in procedure "INITIALIZE_POSITION" set ref 1206*
key_count                       000112 automatic       fixed bin(35,0)          dcl 306 set ref 509* 541
key_range                 1            based           structure                level 3 in structure "snk_leaf_ci_header" packed
                                                                                  unaligned dcl 1600 in procedure "SETUP_NEXT_KEY"
key_range                 1            based           structure                level 3 in structure "leaf_ci_header" packed
                                                                                  unaligned dcl 5-43 in procedure
                                                                                  "im_process_keys$get"
key_range                 1            based           structure                level 3 in structure "bb_leaf_ci_header" packed
                                                                                  unaligned dcl 670 in procedure "BEFORE_BEGINNING"
key_range                 1            based           structure                level 3 in structure "sc_leaf_ci_header" packed
                                                                                  unaligned dcl 1470 in procedure "SET_INDEX_CURSOR"
key_range                 1            based           structure                level 3 in structure "ae_leaf_ci_header" packed
                                                                                  unaligned dcl 651 in procedure "AFTER_END"
key_range                 1            based           structure                level 3 in structure "fp_leaf_ci_header" packed
                                                                                  unaligned dcl 799 in procedure "FIND_POSITION"
key_satisfies_specification     000110 automatic       bit(1)                   initial dcl 304 set ref 304* 512* 516* 518 518* 523
                                                                                  536*
last                      1(18)        based           fixed bin(18,0)          level 4 in structure "sc_leaf_ci_header" packed
                                                                                  unsigned unaligned dcl 1470 in procedure
                                                                                  "SET_INDEX_CURSOR" ref 1509
last                      1(18)        based           fixed bin(18,0)          level 4 in structure "ae_leaf_ci_header" packed
                                                                                  unsigned unaligned dcl 651 in procedure
                                                                                  "AFTER_END" ref 657
last                      1(18)        based           fixed bin(18,0)          level 4 in structure "snk_leaf_ci_header" packed
                                                                                  unsigned unaligned dcl 1600 in procedure
                                                                                  "SETUP_NEXT_KEY" ref 1641 1654 1692 1704
last                      1(18)        based           fixed bin(18,0)          level 4 in structure "leaf_ci_header" packed
                                                                                  unsigned unaligned dcl 5-43 in procedure
                                                                                  "im_process_keys$get" ref 927
last                      1(18)        based           fixed bin(18,0)          level 4 in structure "fp_leaf_ci_header" packed
                                                                                  unsigned unaligned dcl 799 in procedure
                                                                                  "FIND_POSITION" ref 828 846 850 852
last_key_id_string       22            based           bit(36)                  level 2 in structure "position_info" dcl 319
                                                                                  in procedure "im_process_keys$get" ref 1074
last_key_id_string       22            based           bit(36)                  level 2 in structure "ip_p_position_info" dcl 1195
                                                                                  in procedure "INITIALIZE_POSITION" set ref 1212*
last_key_id_string       22            based           bit(36)                  level 2 in structure "dlksi_p_position_info" dcl 711
                                                                                  in procedure "DECREMENT_LAST_KEY_SLOT_INDEX" set
                                                                                  ref 714 714
leaf_ci_header                         based           structure                level 1 unaligned dcl 5-43
leaf_key                               based           structure                level 1 packed unaligned dcl 6-26
length                                                 builtin function         dcl 352 ref 495 495 495 495
lk_string_length         23            based           fixed bin(35,0)          level 2 in structure "gk_p_position_info" dcl 1037
                                                                                  in procedure "GET_KEY" set ref 1051* 1060
lk_string_length                000167 automatic       fixed bin(35,0)          dcl 6-29 in procedure "im_process_keys$get" set ref
                                                                                  1450* 1451 1451
lk_string_length         23            based           fixed bin(35,0)          level 2 in structure "position_info" dcl 319
                                                                                  in procedure "im_process_keys$get" set ref 1324*
lk_string_length         23            based           fixed bin(35,0)          level 2 in structure "ip_p_position_info" dcl 1195
                                                                                  in procedure "INITIALIZE_POSITION" set ref 1200*
local_key_buffer                000120 automatic       fixed bin(71,0)          array dcl 308 set ref 495 495 495 495
local_leaf_ci_header            000113 automatic       structure                level 1 unaligned dcl 307 set ref 495 495 495 495
maximum_dimension_name_length
                          4            based           fixed bin(17,0)          level 2 dcl 2-21 set ref 601 612 617* 622 625 625
                                                                                  628 633 635 1401 1402 1402 1408
myname                          000003 constant        varying char(32)         initial dcl 357 set ref 476* 541* 688* 701* 1275*
next_id                   3(24)        based           fixed bin(24,0)          level 3 in structure "sc_leaf_ci_header" packed
                                                                                  unsigned unaligned dcl 1470 in procedure
                                                                                  "SET_INDEX_CURSOR" ref 1512
next_id                   3(24)        based           fixed bin(24,0)          level 3 in structure "fp_leaf_ci_header" packed
                                                                                  unsigned unaligned dcl 799 in procedure
                                                                                  "FIND_POSITION" ref 855
next_id                   3(24)        based           fixed bin(24,0)          level 3 in structure "ae_leaf_ci_header" packed
                                                                                  unsigned unaligned dcl 651 in procedure
                                                                                  "AFTER_END" ref 657
next_id                   3(24)        based           fixed bin(24,0)          level 3 in structure "snk_leaf_ci_header" packed
                                                                                  unsigned unaligned dcl 1600 in procedure
                                                                                  "SETUP_NEXT_KEY" ref 1659 1709
nie_p_position_info_ptr                parameter       pointer                  dcl 1285 ref 1283 1288
nnid_p_position_info_ptr               parameter       pointer                  dcl 1295 ref 1293 1298 1299
node_id                  24            based           fixed bin(24,0)          level 2 in structure "position_info" unsigned
                                                                                  dcl 319 in procedure "im_process_keys$get" set ref
                                                                                  1085 1334* 1554 1557*
node_id                  24            based           fixed bin(24,0)          level 2 in structure "ip_p_position_info" unsigned
                                                                                  dcl 1195 in procedure "INITIALIZE_POSITION" set
                                                                                  ref 1201*
node_is_deleted           5(02)        based           bit(1)                   level 3 packed unaligned dcl 319 set ref 1288 1298*
                                                                                  1335*
node_ptr                 26            based           pointer                  level 2 in structure "ip_p_position_info" dcl 1195
                                                                                  in procedure "INITIALIZE_POSITION" set ref 1197*
node_ptr                 26            based           pointer                  level 2 in structure "gnp_p_position_info" dcl 1099
                                                                                  in procedure "GET_NODE_PTR" set ref 1101 1108*
                                                                                  1114
node_ptr                 26            based           pointer                  level 2 in structure "position_info" dcl 319
                                                                                  in procedure "im_process_keys$get" set ref 1299*
                                                                                  1348*
null                                                   builtin function         dcl 352 ref 311 432 440 449 476 476 518 541 541 589
                                                                                  590 594 633 688 688 701 701 887 963 971 971 1101
                                                                                  1131 1131 1197 1198 1199 1275 1275 1299 1348 1372
                                                                                  1375 1378 1381 1382 1395 1434 1435 1442 1538 1538
                                                                                  1599 1734
number_of_and_groups      4(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 8-38 ref 1442
number_of_dimensions      0(18)        based           fixed bin(17,0)          level 2 in structure "simple_typed_vector" packed
                                                                                  unaligned dcl 13-17 in procedure
                                                                                  "im_process_keys$get" ref 883 886
number_of_dimensions      1            based           fixed bin(17,0)          level 2 in structure "typed_vector_array" dcl 2-21
                                                                                  in procedure "im_process_keys$get" set ref 601 611
                                                                                  617* 622 625 625 628 633 635 1401 1402 1402 1408
number_of_fields          2            based           fixed bin(17,0)          level 2 dcl 11-36 ref 1442
number_of_keys_accepted         000101 automatic       fixed bin(35,0)          initial dcl 301 set ref 301* 500* 502* 527* 529*
                                                                                  532* 532 536* 554
number_of_vector_slots
                          3            based           fixed bin(17,0)          level 2 dcl 2-21 set ref 601 617* 631 635
number_of_vectors         2            based           fixed bin(17,0)          level 2 dcl 2-21 set ref 500 599* 599 601 601 609
                                                                                  620* 620 624 628 631 638 1397 1402 1408
numeric_specification                  based           structure                level 1 unaligned dcl 8-63
numeric_specification_ptr       000172 automatic       pointer                  dcl 8-70 set ref 490*
nviu_p_position_info_ptr               parameter       pointer                  dcl 1305 ref 1303 1308
operation                       000100 automatic       fixed bin(17,0)          initial dcl 299 set ref 299* 421* 431* 439* 448* 500
                                                                                  527 529 536* 547 557*
p_and_group_id_list_ptr                parameter       pointer                  dcl 282 set ref 268 426 435 443 512*
p_code                                 parameter       fixed bin(35,0)          dcl 295 set ref 268 426 435 443 473* 572*
p_field_table_ptr                      parameter       pointer                  dcl 279 ref 268 426 435 443 487
p_first_key_id_string                  parameter       bit(36)                  dcl 288 set ref 268 426 435 443 490* 495* 541*
p_id_list_ptr                          parameter       pointer                  dcl 280 set ref 268 495*
p_index_cursor_ptr                     parameter       pointer                  dcl 277 ref 268 426 435 443 475
p_key_count_array_ptr                  parameter       pointer                  dcl 292 set ref 435 529*
p_last_key_id_string                   parameter       bit(36)                  dcl 289 set ref 268 426 435 443 495* 541* 1220
p_number_of_fully_structural_fields    parameter       fixed bin(17,0)          dcl 284 set ref 268 426 435 443 512*
p_number_of_keys_accepted              parameter       fixed bin(35,0)          dcl 293 set ref 426 435 443 502 554*
p_partial_structural_field_id          parameter       fixed bin(17,0)          dcl 286 set ref 268 426 435 443 512*
p_specification_ptr                    parameter       pointer                  dcl 281 set ref 268 426 435 443 483 490*
p_typed_vector_array_ptr               parameter       pointer                  dcl 290 set ref 268 422 552*
p_work_area_ptr                        parameter       pointer                  dcl 278 set ref 268 426 435 443 495*
position_count                  000103 automatic       fixed bin(35,0)          initial dcl 301 set ref 301* 490* 506*
position_info                          based           structure                level 1 dcl 319
position_number           5            based           fixed bin(17,0)          level 2 packed unaligned dcl 8-63 ref 1270 1273
previous_id               3            based           fixed bin(24,0)          level 3 in structure "snk_leaf_ci_header" packed
                                                                                  unsigned unaligned dcl 1600 in procedure
                                                                                  "SETUP_NEXT_KEY" ref 1638 1689
previous_id               3            based           fixed bin(24,0)          level 3 in structure "fp_leaf_ci_header" packed
                                                                                  unsigned unaligned dcl 799 in procedure
                                                                                  "FIND_POSITION" ref 824
previous_id               3            based           fixed bin(24,0)          level 3 in structure "bb_leaf_ci_header" packed
                                                                                  unsigned unaligned dcl 670 in procedure
                                                                                  "BEFORE_BEGINNING" ref 676
range                     5            based           structure                level 2 packed unaligned dcl 8-38
range_size                      000104 automatic       fixed bin(35,0)          initial dcl 301 in procedure "im_process_keys$get"
                                                                                  set ref 301* 490* 536*
range_size                4            based           fixed bin(35,0)          level 2 in structure "numeric_specification"
                                                                                  dcl 8-63 in procedure "im_process_keys$get" ref
                                                                                  1272
rch_p_position_info_ptr                parameter       pointer                  dcl 1313 ref 1311 1315
rk_p_position_info_ptr                 parameter       pointer                  dcl 1321 set ref 1319 1322* 1323 1324
rni_p_position_info_ptr                parameter       pointer                  dcl 1331 set ref 1328 1334 1335 1337* 1338* 1339*
rnp_p_position_info_ptr                parameter       pointer                  dcl 1346 ref 1344 1348
rsi_p_position_info_ptr                parameter       pointer                  dcl 1354 set ref 1352 1356* 1357
rv_p_position_info                     based           structure                level 1 dcl 1364
rv_p_position_info_ptr                 parameter       pointer                  dcl 1362 ref 1360 1372 1372 1372 1375 1375 1378 1378
                                                                                  1378 1381 1382 1383
rvs_p_input_number_of_keys_accepted    parameter       fixed bin(35,0)          dcl 1389 ref 1387 1397 1397 1397
rvs_p_typed_vector_array_ptr           parameter       pointer                  dcl 1391 ref 1387 1397 1401 1402 1402 1402 1408 1408
rvs_vector_ptr                  000742 automatic       pointer                  initial dcl 1395 set ref 1395* 1401* 1408
rvs_vector_slot_idx             000740 automatic       fixed bin(35,0)          initial dcl 1394 set ref 1394* 1397* 1401 1402 1402
                                                                                  1408*
sc_code                         000772 automatic       fixed bin(35,0)          initial dcl 1467 set ref 1467* 1492* 1494 1494*
                                                                                  1501* 1503 1503* 1531* 1533 1533* 1538* 1539 1539*
sc_element_id                          based           structure                level 1 packed unaligned dcl 1477
sc_element_id_string            001005 automatic       bit(36)                  dcl 1476 set ref 1486 1487 1492* 1501* 1528 1529
                                                                                  1531*
sc_index_cursor_ptr             000774 automatic       pointer                  dcl 1468 set ref 1480* 1492* 1501* 1531* 1538*
sc_leaf_ci_header                      based           structure                level 1 unaligned dcl 1470
sc_leaf_ci_header_ptr           000776 automatic       pointer                  dcl 1469 set ref 1481* 1509 1512 1517* 1518
sc_leaf_key_ptr                 001000 automatic       pointer                  dcl 1471 set ref 1482* 1492* 1500* 1501* 1526* 1531*
sc_lk_string_length             001002 automatic       fixed bin(35,0)          dcl 1472 set ref 1482* 1492 1500* 1501 1526* 1531
sc_node_id                      001003 automatic       fixed bin(24,0)          unsigned dcl 1473 set ref 1483* 1486 1512* 1513*
                                                                                  1514 1523 1528
sc_p_operation                         parameter       fixed bin(17,0)          dcl 1464 ref 1461 1489 1497 1506
sc_p_position_info_ptr                 parameter       pointer                  dcl 1465 set ref 1461 1480* 1481* 1482* 1483* 1484*
                                                                                  1500* 1509* 1513* 1517* 1519* 1526*
sc_slot_index                   001004 automatic       fixed bin(12,0)          unsigned dcl 1474 set ref 1484* 1487 1509 1518*
                                                                                  1519* 1529
search_specification                   based           structure                level 1 unaligned dcl 8-38
search_specification_ptr        000170 automatic       pointer                  dcl 8-58 set ref 490* 512*
selected_vector_ptr      30            based           pointer                  level 2 in structure "gsv_p_position_info" dcl 1128
                                                                                  in procedure "GET_SELECTED_VECTOR" set ref 1131
                                                                                  1131* 1141* 1147
selected_vector_ptr      30            based           pointer                  level 2 in structure "rv_p_position_info" dcl 1364
                                                                                  in procedure "RESET_VECTORS" set ref 1372 1378
                                                                                  1378* 1381*
selected_vector_ptr      30            based           pointer                  level 2 in structure "ip_p_position_info" dcl 1195
                                                                                  in procedure "INITIALIZE_POSITION" set ref 1199*
sesc_code                       000754 automatic       fixed bin(35,0)          initial dcl 1433 set ref 1433* 1451* 1455 1455*
sesc_field_table_ptr            000756 automatic       pointer                  initial dcl 1434 set ref 1434* 1440* 1442 1451*
sesc_leaf_key_ptr               000760 automatic       pointer                  initial dcl 1435 set ref 1435* 1448* 1451
sesc_lk_string_length           000762 automatic       fixed bin(35,0)          initial dcl 1436 set ref 1436* 1448* 1450
sesc_p_and_group_id_list_ptr           parameter       pointer                  dcl 1422 set ref 1416 1442 1451*
sesc_p_key_satisfies_specification     parameter       bit(1)                   dcl 1430 set ref 1416 1442* 1451*
sesc_p_number_of_fully_structural_fields
                                       parameter       fixed bin(17,0)          dcl 1424 set ref 1416 1442 1451*
sesc_p_partial_structural_field_id     parameter       fixed bin(17,0)          dcl 1426 set ref 1416 1451*
sesc_p_position_info_ptr               parameter       pointer                  dcl 1428 set ref 1416 1440* 1448*
sesc_p_search_specification_ptr        parameter       pointer                  dcl 1420 set ref 1416 1442 1451*
set_cursor                      000111 automatic       bit(1)                   initial dcl 304 set ref 304* 526* 557
simple_typed_vector                    based           structure                level 1 packed unaligned dcl 13-17 ref 886
size                      5(18)        based           fixed bin(17,0)          level 3 packed unaligned dcl 8-38 ref 1262
slot_index               32            based           fixed bin(12,0)          level 2 in structure "ip_p_position_info" unsigned
                                                                                  dcl 1195 in procedure "INITIALIZE_POSITION" set
                                                                                  ref 1202*
slot_index               32            based           fixed bin(12,0)          level 2 in structure "position_info" unsigned
                                                                                  dcl 319 in procedure "im_process_keys$get" set ref
                                                                                  1158 1357* 1568 1571*
sni_p_node_id                          parameter       fixed bin(24,0)          unsigned dcl 1550 ref 1545 1557
sni_p_position_info_ptr                parameter       pointer                  dcl 1551 set ref 1545 1554 1554* 1557
snk_leaf_ci_header                     based           structure                level 1 unaligned dcl 1600
snk_leaf_ci_header_ptr          001030 automatic       pointer                  initial dcl 1599 set ref 1599* 1619* 1634 1638 1639*
                                                                                  1641 1654 1659 1660* 1685 1689 1690* 1692 1704
                                                                                  1709 1710* 1712
snk_node_id                     001032 automatic       fixed bin(24,0)          unsigned dcl 1601 set ref 1617* 1628* 1647* 1679*
                                                                                  1698*
snk_p_finished                         parameter       bit(1)                   dcl 1596 set ref 1580 1605* 1610* 1631* 1651* 1671*
                                                                                  1682* 1701*
snk_p_get_keys_in_reverse_order        parameter       bit(1)                   dcl 1588 ref 1580 1624 1675
snk_p_is_search_specification          parameter       bit(1)                   dcl 1585 ref 1580 1621
snk_p_key_satisfies_specification      parameter       bit(1)                   dcl 1590 ref 1580 1647 1668
snk_p_number_of_keys_accepted          parameter       fixed bin(35,0)          dcl 1594 ref 1580 1607
snk_p_operation                        parameter       fixed bin(17,0)          dcl 1584 ref 1580 1646 1647 1697
snk_p_position_info_ptr                parameter       pointer                  dcl 1592 set ref 1580 1617* 1618* 1619* 1628* 1634*
                                                                                  1638* 1639* 1641* 1647* 1654* 1659* 1660* 1661*
                                                                                  1679* 1685* 1689* 1690* 1692* 1698* 1704* 1709*
                                                                                  1710* 1712*
snk_p_range_size                       parameter       fixed bin(35,0)          dcl 1587 ref 1580 1607 1607 1668
snk_position_change             001033 automatic       fixed bin(35,0)          initial dcl 1602 set ref 1602* 1627* 1628 1634 1634
                                                                                  1646* 1647 1654 1654 1678* 1679 1685 1685 1697*
                                                                                  1698 1704 1704
snk_slot_index                  001034 automatic       fixed bin(12,0)          unsigned dcl 1603 set ref 1618* 1628 1634 1634 1647
                                                                                  1654 1654 1654 1679 1685 1685 1698 1704 1704 1704
specification_head                     based           structure                level 1 unaligned dcl 9-10
specification_head_ptr          000174 automatic       pointer                  dcl 9-18 set ref 483* 484 518 518
ssi_p_position_info_ptr                parameter       pointer                  dcl 1565 set ref 1562 1568 1568* 1571
ssi_p_slot_index                       parameter       fixed bin(12,0)          unsigned dcl 1564 ref 1562 1571
string                                                 builtin function         dcl 352 in procedure "im_process_keys$get" set ref
                                                                                  1203*
string                                 based           bit                      level 2 in structure "leaf_key" packed unaligned
                                                                                  dcl 6-26 in procedure "im_process_keys$get" set
                                                                                  ref 1451*
sub_err_                        000024 constant        entry                    external dcl 396 ref 476 541 688 701 1275
subset_specification_ptr
                          2            based           pointer                  level 2 dcl 9-10 set ref 518 518*
susc_code                       001044 automatic       fixed bin(35,0)          initial dcl 1733 set ref 1733* 1741* 1743 1743*
susc_p_key_satisfies_specification     parameter       bit(1)                   dcl 1730 set ref 1723 1741*
susc_p_position_info_ptr               parameter       pointer                  dcl 1728 set ref 1723 1737* 1739*
susc_p_subset_specification_ptr        parameter       pointer                  dcl 1726 set ref 1723 1741*
susc_vector_ptr                 001046 automatic       pointer                  initial dcl 1734 set ref 1734* 1737* 1741*
susc_work_area_ptr              001050 automatic       pointer                  dcl 1735 set ref 1739* 1741*
tva_maximum_dimension_name_length
                                000166 automatic       fixed bin(17,0)          dcl 2-48 set ref 612* 617 617
tva_number_of_dimensions        000165 automatic       fixed bin(17,0)          dcl 2-46 set ref 611* 617 617
tva_number_of_vector_slots      000164 automatic       fixed bin(17,0)          dcl 2-44 set ref 609* 617 617
type                                   based           fixed bin(17,0)          level 2 in structure "index_cursor" packed unaligned
                                                                                  dcl 1-29 in procedure "im_process_keys$get" set
                                                                                  ref 476 476*
type                      5            based           fixed bin(17,0)          level 3 in structure "search_specification" packed
                                                                                  unaligned dcl 8-38 in procedure
                                                                                  "im_process_keys$get" ref 1259
type                      1            based           fixed bin(17,0)          level 2 in structure "specification_head" packed
                                                                                  unaligned dcl 9-10 in procedure
                                                                                  "im_process_keys$get" set ref 1253 1253 1264 1264
                                                                                  1275*
typed_vector_array                     based           structure                level 1 dcl 2-21 set ref 617 635
typed_vector_array_ptr          000162 automatic       pointer                  dcl 2-43 set ref 422* 423 432* 440* 449* 500 527*
                                                                                  550* 552
unspec                                                 builtin function         dcl 352 ref 495 495
value_ptr                 1            based           pointer                  array level 3 packed unaligned dcl 13-17 ref 884
vector_in_use             5(03)        based           bit(1)                   level 3 in structure "position_info" packed
                                                                                  unaligned dcl 319 in procedure
                                                                                  "im_process_keys$get" set ref 1308*
vector_in_use             5(03)        based           bit(1)                   level 3 in structure "rv_p_position_info" packed
                                                                                  unaligned dcl 1364 in procedure "RESET_VECTORS"
                                                                                  set ref 1378 1383*
vector_slot                            based           pointer                  array level 2 dcl 2-21 set ref 601* 625* 625 628*
                                                                                  633* 1401 1402* 1402 1408*
version                   0(18)        based           fixed bin(17,0)          level 2 in structure "index_cursor" packed unaligned
                                                                                  dcl 1-29 in procedure "im_process_keys$get" ref
                                                                                  481
version                                based           fixed bin(35,0)          level 2 in structure "typed_vector_array" dcl 2-21
                                                                                  in procedure "im_process_keys$get" set ref 423
                                                                                  619*
version                                based           fixed bin(35,0)          level 2 in structure "specification_head" dcl 9-10
                                                                                  in procedure "im_process_keys$get" set ref 484*
version                                based           char(8)                  initial level 2 in structure "field_table" dcl 11-36
                                                                                  in procedure "im_process_keys$get" set ref 488*
work_area_ptr            34            based           pointer                  level 2 in structure "ip_p_position_info" dcl 1195
                                                                                  in procedure "INITIALIZE_POSITION" set ref 1210*
work_area_ptr            34            based           pointer                  level 2 in structure "position_info" dcl 319
                                                                                  in procedure "im_process_keys$get" ref 1169

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 9-22
ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 9-22
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 3-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 3-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 3-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 3-7
ALL_RANGE_TYPE                         internal static fixed bin(17,0)          initial dcl 10-8
BITS_PER_BYTE                          internal static fixed bin(35,0)          initial dcl 363
BRANCH_CI_HEADER_LENGTH_IN_BITS        internal static fixed bin(17,0)          initial dcl 5-56
BRANCH_KEY_HEADER_LENGTH_IN_BITS       internal static fixed bin(35,0)          initial dcl 6-37
CI_0_ADDRESSABLE_LENGTH                internal static fixed bin(17,0)          initial dcl 12-31
CI_ADDRESSABLE_LENGTH                  internal static fixed bin(17,0)          initial dcl 12-29
CONTROL_INTERVAL_ADDRESSABLE_LENGTH_IN_BYTES
                                       internal static fixed bin(17,0)          initial dcl 12-22
CONTROL_INTERVAL_ZERO_ADDRESSABLE_LENGTH_IN_BYTES
                                       internal static fixed bin(17,0)          initial dcl 12-25
GENERAL_TYPED_VECTOR_TYPE              internal static fixed bin(17,0)          initial dcl 13-43
LEAF_CI_HEADER_LENGTH_IN_BITS          internal static fixed bin(17,0)          initial dcl 5-56
LOW_RANGE_TYPE                         internal static fixed bin(17,0)          initial dcl 10-8
NUMERIC_SPECIFICATION_TYPE             internal static fixed bin(17,0)          initial dcl 9-22
OLD_SIMPLE_TYPED_VECTOR_TYPE           internal static fixed bin(17,0)          initial dcl 13-43
RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 9-22
RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 9-22
SEARCH_SPECIFICATION_TYPE              internal static fixed bin(17,0)          initial dcl 9-22
SIMPLE_TYPED_VECTOR_TYPE               internal static fixed bin(17,0)          initial dcl 13-43
bk_string_length                       automatic       fixed bin(35,0)          dcl 6-39
branch_ci_header                       based           structure                level 1 unaligned dcl 5-48
branch_ci_header_ptr                   automatic       pointer                  dcl 5-53
branch_key                             based           structure                level 1 packed unaligned dcl 6-32
branch_key_ptr                         automatic       pointer                  dcl 6-40
collection_manager_$allocate_control_interval
                                000000 constant        entry                    external dcl 7-50
collection_manager_$compact_control_interval
                                000000 constant        entry                    external dcl 7-52
collection_manager_$create_collection
                                000000 constant        entry                    external dcl 7-54
collection_manager_$create_file 000000 constant        entry                    external dcl 7-56
collection_manager_$delete      000000 constant        entry                    external dcl 7-64
collection_manager_$delete_from_ci_buffer
                                000000 constant        entry                    external dcl 7-67
collection_manager_$destroy_collection
                                000000 constant        entry                    external dcl 7-58
collection_manager_$free_control_interval
                                000000 constant        entry                    external dcl 7-60
collection_manager_$get         000000 constant        entry                    external dcl 7-71
collection_manager_$get_by_ci_ptr
                                000000 constant        entry                    external dcl 7-80
collection_manager_$get_from_ci_buffer
                                000000 constant        entry                    external dcl 7-77
collection_manager_$get_header  000000 constant        entry                    external dcl 7-83
collection_manager_$get_id      000000 constant        entry                    external dcl 7-86
collection_manager_$get_portion 000000 constant        entry                    external dcl 7-89
collection_manager_$get_portion_by_ci_ptr
                                000000 constant        entry                    external dcl 7-97
collection_manager_$get_portion_from_ci_buffer
                                000000 constant        entry                    external dcl 7-93
collection_manager_$modify      000000 constant        entry                    external dcl 7-101
collection_manager_$modify_in_ci_buffer
                                000000 constant        entry                    external dcl 7-107
collection_manager_$modify_portion
                                000000 constant        entry                    external dcl 7-110
collection_manager_$modify_unprotected
                                000000 constant        entry                    external dcl 7-104
collection_manager_$postcommit_increments
                                000000 constant        entry                    external dcl 7-113
collection_manager_$put         000000 constant        entry                    external dcl 7-115
collection_manager_$put_header  000000 constant        entry                    external dcl 7-121
collection_manager_$put_in_ci_buffer
                                000000 constant        entry                    external dcl 7-118
collection_manager_$put_unprotected_header
                                000000 constant        entry                    external dcl 7-123
collection_manager_$replace_ci_buffer
                                000000 constant        entry                    external dcl 7-126
collection_manager_$setup_ci_buffer
                                000000 constant        entry                    external dcl 7-129
collection_manager_$simple_get_from_ci_buffer
                                000000 constant        entry                    external dcl 7-135
common_ci_header_ptr                   automatic       pointer                  dcl 5-41
element_id_string                      automatic       bit(36)                  dcl 4-30
field_name                             based           char                     unaligned dcl 11-71
field_name_length                      automatic       fixed bin(17,0)          dcl 11-73
field_name_ptr                         automatic       pointer                  dcl 11-74
ft_length_of_field_names               automatic       fixed bin(17,0)          dcl 11-66
ft_number_of_fields                    automatic       fixed bin(17,0)          dcl 11-68
general_typed_vector                   based           structure                level 1 packed unaligned dcl 13-24
general_typed_vector_ptr               automatic       pointer                  dcl 13-38
gtv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 13-40
hash_index_                     000000 constant        entry                    external dcl 378
im_set_cursor$at_beginning      000000 constant        entry                    external dcl 389
im_set_cursor$no_current        000000 constant        entry                    external dcl 387
key_string                             based           bit                      unaligned dcl 6-22
key_string_length                      automatic       fixed bin(35,0)          dcl 6-23
key_string_ptr                         automatic       pointer                  dcl 6-24
leaf_ci_header_ptr                     automatic       pointer                  dcl 5-46
leaf_key_ptr                           automatic       pointer                  dcl 6-30
simple_typed_vector_ptr                automatic       pointer                  dcl 13-33
ss_maximum_number_of_constraints       automatic       fixed bin(17,0)          dcl 8-60
ss_number_of_and_groups                automatic       fixed bin(17,0)          dcl 8-60
stv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 13-35

NAMES DECLARED BY EXPLICIT CONTEXT.
ADD_KEY_TO_OUTPUT               001320 constant        entry                    internal dcl 578 ref 527
AFTER_END                       001664 constant        entry                    internal dcl 643 ref 844 850 863 1647 1698
BEFORE_BEGINNING                001750 constant        entry                    internal dcl 662 ref 813 819 831 1628 1679
CHECK_VERSION                   002024 constant        entry                    internal dcl 681 ref 423 481 484
CHECK_VERSION_CHAR              002120 constant        entry                    internal dcl 695 ref 488
DECREMENT_LAST_KEY_SLOT_INDEX   002222 constant        entry                    internal dcl 707 ref 785
DELETE_KEY_FROM_INDEX           002233 constant        entry                    internal dcl 722 ref 529
ERROR_RETURN                    001312 constant        entry                    internal dcl 569 ref 770 778 921 923 925 927 973
                                                                                  1054 1110 1144 1455 1494 1503 1533 1539 1743
FIND_POSITION                   002511 constant        entry                    internal dcl 789 ref 506
FINISH                          001310 constant        entry                    internal dcl 565 ref 573
FINISH_NUMERIC                  006327 constant        label                    dcl 1665
FREE_ENTIRE_VECTOR              003311 constant        entry                    internal dcl 876 ref 1375 1378
GET_CI_HEADER                   003367 constant        entry                    internal dcl 894 ref 654 673 757 806 827 858 1481
                                                                                  1517 1619 1639 1660 1690 1710
GET_COLLECTION_ID               003552 constant        entry                    internal dcl 937 ref 912 1043 1105
GET_ENTIRE_VECTOR               003562 constant        entry                    internal dcl 949 ref 1131 1737
GET_FIELD_TABLE                 003666 constant        entry                    internal dcl 981 ref 755 968 1138 1440
GET_FILE_OPENING_ID             003675 constant        entry                    internal dcl 992 ref 1104
GET_FIRST_KEY_ID                003705 constant        entry                    internal dcl 1003 ref 674
GET_INDEX_CURSOR                003714 constant        entry                    internal dcl 1015 ref 756 1480
GET_KEY                         003723 constant        entry                    internal dcl 1024 ref 761 967 1137 1448 1482 1500
                                                                                  1526
GET_LAST_KEY_ID                 004053 constant        entry                    internal dcl 1067 ref 655 762
GET_NODE_ID                     004062 constant        entry                    internal dcl 1079 ref 758 805 913 1044 1106 1483
                                                                                  1617
GET_NODE_PTR                    004071 constant        entry                    internal dcl 1089 ref 759 914 1045
GET_SELECTED_VECTOR             004167 constant        entry                    internal dcl 1117 ref 597
GET_SLOT_INDEX                  004310 constant        entry                    internal dcl 1152 ref 760 807 1046 1484 1618
GET_WORK_AREA                   004317 constant        entry                    internal dcl 1163 ref 608 754 969 1139 1739
INITIALIZE_POSITION             004326 constant        entry                    internal dcl 1173 ref 495
INTERPRET_SPECIFICATION         004500 constant        entry                    internal dcl 1232 ref 490
JOIN                            000564 constant        label                    dcl 473 ref 424 433 441 450
KEY_LOOP                        001061 constant        label                    dcl 509
MAIN_RETURN                     001307 constant        label                    dcl 560 ref 574
NODE_IS_DELETED                 004650 constant        entry                    internal dcl 1283 ref 1509
NOTE_NODE_IS_DELETED            004661 constant        entry                    internal dcl 1293 ref 781
NOTE_VECTOR_IN_USE              004672 constant        entry                    internal dcl 1303 ref 640
REALLY_LOOK                     006000 constant        label                    dcl 1613
RESET_CI_HEADER                 004701 constant        entry                    internal dcl 1311 ref 1337
RESET_KEY                       004710 constant        entry                    internal dcl 1319 ref 1356
RESET_NODE_ID                   004727 constant        entry                    internal dcl 1328 ref 1554
RESET_NODE_PTR                  004763 constant        entry                    internal dcl 1344 ref 1338
RESET_SLOT_INDEX                004772 constant        entry                    internal dcl 1352 ref 1339 1568
RESET_VECTORS                   005007 constant        entry                    internal dcl 1360 ref 1322
REVERSE_VECTOR_SLOTS            005070 constant        entry                    internal dcl 1387 ref 550
SEARCH_SPEC_COMPARISON          005213 constant        entry                    internal dcl 1416 ref 512
SETUP_NEXT_KEY                  005763 constant        entry                    internal dcl 1580 ref 536
SET_INDEX_CURSOR                005342 constant        entry                    internal dcl 1461 ref 557
SET_NODE_ID                     005717 constant        entry                    internal dcl 1545 ref 825 856 1219 1224 1513 1638
                                                                                  1659 1689 1709
SET_SLOT_INDEX                  005741 constant        entry                    internal dcl 1562 ref 815 830 837 846 861 868 1220
                                                                                  1226 1519 1634 1641 1654 1661 1685 1692 1704 1712
SUBSET_SPEC_COMPARISON          006623 constant        entry                    internal dcl 1723 ref 518
count                           000530 constant        entry                    external dcl 443
delete                          000472 constant        entry                    external dcl 435
im_process_keys$get             000344 constant        entry                    external dcl 268
position                        000425 constant        entry                    external dcl 426

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      7376        7446    7076        7406
Length     10154    7076        50         472     300           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
im_process_keys$get                1308 external procedure  is an external procedure.  
FINISH                                  internal procedure  shares stack frame of external procedure im_process_keys$get.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure im_process_keys$get.  
ADD_KEY_TO_OUTPUT                       internal procedure  shares stack frame of external procedure im_process_keys$get.  
AFTER_END                               internal procedure  shares stack frame of external procedure im_process_keys$get.  
BEFORE_BEGINNING                        internal procedure  shares stack frame of external procedure im_process_keys$get.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure im_process_keys$get.  
CHECK_VERSION_CHAR                      internal procedure  shares stack frame of external procedure im_process_keys$get.  
DECREMENT_LAST_KEY_SLOT_INDEX           internal procedure  shares stack frame of external procedure im_process_keys$get.  
DELETE_KEY_FROM_INDEX                   internal procedure  shares stack frame of external procedure im_process_keys$get.  
FIND_POSITION                           internal procedure  shares stack frame of external procedure im_process_keys$get.  
FREE_ENTIRE_VECTOR                      internal procedure  shares stack frame of external procedure im_process_keys$get.  
GET_CI_HEADER                           internal procedure  shares stack frame of external procedure im_process_keys$get.  
GET_COLLECTION_ID                       internal procedure  shares stack frame of external procedure im_process_keys$get.  
GET_ENTIRE_VECTOR                       internal procedure  shares stack frame of external procedure im_process_keys$get.  
GET_FIELD_TABLE                         internal procedure  shares stack frame of external procedure im_process_keys$get.  
GET_FILE_OPENING_ID                     internal procedure  shares stack frame of external procedure im_process_keys$get.  
GET_FIRST_KEY_ID                        internal procedure  shares stack frame of external procedure im_process_keys$get.  
GET_INDEX_CURSOR                        internal procedure  shares stack frame of external procedure im_process_keys$get.  
GET_KEY                                 internal procedure  shares stack frame of external procedure im_process_keys$get.  
GET_LAST_KEY_ID                         internal procedure  shares stack frame of external procedure im_process_keys$get.  
GET_NODE_ID                             internal procedure  shares stack frame of external procedure im_process_keys$get.  
GET_NODE_PTR                            internal procedure  shares stack frame of external procedure im_process_keys$get.  
GET_SELECTED_VECTOR                     internal procedure  shares stack frame of external procedure im_process_keys$get.  
GET_SLOT_INDEX                          internal procedure  shares stack frame of external procedure im_process_keys$get.  
GET_WORK_AREA                           internal procedure  shares stack frame of external procedure im_process_keys$get.  
INITIALIZE_POSITION                     internal procedure  shares stack frame of external procedure im_process_keys$get.  
INTERPRET_SPECIFICATION                 internal procedure  shares stack frame of external procedure im_process_keys$get.  
NODE_IS_DELETED                         internal procedure  shares stack frame of external procedure im_process_keys$get.  
NOTE_NODE_IS_DELETED                    internal procedure  shares stack frame of external procedure im_process_keys$get.  
NOTE_VECTOR_IN_USE                      internal procedure  shares stack frame of external procedure im_process_keys$get.  
RESET_CI_HEADER                         internal procedure  shares stack frame of external procedure im_process_keys$get.  
RESET_KEY                               internal procedure  shares stack frame of external procedure im_process_keys$get.  
RESET_NODE_ID                           internal procedure  shares stack frame of external procedure im_process_keys$get.  
RESET_NODE_PTR                          internal procedure  shares stack frame of external procedure im_process_keys$get.  
RESET_SLOT_INDEX                        internal procedure  shares stack frame of external procedure im_process_keys$get.  
RESET_VECTORS                           internal procedure  shares stack frame of external procedure im_process_keys$get.  
REVERSE_VECTOR_SLOTS                    internal procedure  shares stack frame of external procedure im_process_keys$get.  
SEARCH_SPEC_COMPARISON                  internal procedure  shares stack frame of external procedure im_process_keys$get.  
SET_INDEX_CURSOR                        internal procedure  shares stack frame of external procedure im_process_keys$get.  
SET_NODE_ID                             internal procedure  shares stack frame of external procedure im_process_keys$get.  
SET_SLOT_INDEX                          internal procedure  shares stack frame of external procedure im_process_keys$get.  
SETUP_NEXT_KEY                          internal procedure  shares stack frame of external procedure im_process_keys$get.  
SUBSET_SPEC_COMPARISON                  internal procedure  shares stack frame of external procedure im_process_keys$get.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
im_process_keys$get      000100 operation                   im_process_keys$get
                         000101 number_of_keys_accepted     im_process_keys$get
                         000102 input_number_of_keys_accepted
                                                            im_process_keys$get
                         000103 position_count              im_process_keys$get
                         000104 range_size                  im_process_keys$get
                         000105 finished                    im_process_keys$get
                         000106 get_keys_in_reverse_order   im_process_keys$get
                         000107 is_search_specification     im_process_keys$get
                         000110 key_satisfies_specification im_process_keys$get
                         000111 set_cursor                  im_process_keys$get
                         000112 key_count                   im_process_keys$get
                         000113 local_leaf_ci_header        im_process_keys$get
                         000120 local_key_buffer            im_process_keys$get
                         000120 global_position_info_ptr    im_process_keys$get
                         000122 global_position_info        im_process_keys$get
                         000160 index_cursor_ptr            im_process_keys$get
                         000162 typed_vector_array_ptr      im_process_keys$get
                         000164 tva_number_of_vector_slots  im_process_keys$get
                         000165 tva_number_of_dimensions    im_process_keys$get
                         000166 tva_maximum_dimension_name_length
                                                            im_process_keys$get
                         000167 lk_string_length            im_process_keys$get
                         000170 search_specification_ptr    im_process_keys$get
                         000172 numeric_specification_ptr   im_process_keys$get
                         000174 specification_head_ptr      im_process_keys$get
                         000176 field_table_ptr             im_process_keys$get
                         000250 akto_code                   ADD_KEY_TO_OUTPUT
                         000252 akto_new_tva_ptr            ADD_KEY_TO_OUTPUT
                         000254 akto_old_tva_ptr            ADD_KEY_TO_OUTPUT
                         000256 akto_vector_ptr             ADD_KEY_TO_OUTPUT
                         000260 akto_vector_slot_idx        ADD_KEY_TO_OUTPUT
                         000262 akto_work_area_ptr          ADD_KEY_TO_OUTPUT
                         000274 ae_last_key_id_string       AFTER_END
                         000276 ae_leaf_ci_header_ptr       AFTER_END
                         000306 bb_first_key_id_string      BEFORE_BEGINNING
                         000310 bb_leaf_ci_header_ptr       BEFORE_BEGINNING
                         000342 dkfi_code                   DELETE_KEY_FROM_INDEX
                         000343 dkfi_deleted_node           DELETE_KEY_FROM_INDEX
                         000344 dkfi_element_id_string      DELETE_KEY_FROM_INDEX
                         000346 dkfi_field_table_ptr        DELETE_KEY_FROM_INDEX
                         000350 dkfi_index_cursor_ptr       DELETE_KEY_FROM_INDEX
                         000352 dkfi_last_key_id_string     DELETE_KEY_FROM_INDEX
                         000354 dkfi_leaf_ci_header_ptr     DELETE_KEY_FROM_INDEX
                         000356 dkfi_leaf_key_ptr           DELETE_KEY_FROM_INDEX
                         000360 dkfi_lk_string_length       DELETE_KEY_FROM_INDEX
                         000361 dkfi_node_id                DELETE_KEY_FROM_INDEX
                         000362 dkfi_node_ptr               DELETE_KEY_FROM_INDEX
                         000364 dkfi_slot_index             DELETE_KEY_FROM_INDEX
                         000366 dkfi_work_area_ptr          DELETE_KEY_FROM_INDEX
                         000376 fp_leaf_ci_header_ptr       FIND_POSITION
                         000400 fp_node_id                  FIND_POSITION
                         000401 fp_position_change          FIND_POSITION
                         000402 fp_slot_index               FIND_POSITION
                         000412 fev_dimension_idx           FREE_ENTIRE_VECTOR
                         000444 gch_code                    GET_CI_HEADER
                         000445 gch_collection_id           GET_CI_HEADER
                         000446 gch_element_id_string       GET_CI_HEADER
                         000447 gch_node_id                 GET_CI_HEADER
                         000450 gch_node_ptr                GET_CI_HEADER
                         000466 gev_code                    GET_ENTIRE_VECTOR
                         000470 gev_field_table_ptr         GET_ENTIRE_VECTOR
                         000472 gev_leaf_key_ptr            GET_ENTIRE_VECTOR
                         000474 gev_lk_string_length        GET_ENTIRE_VECTOR
                         000476 gev_work_area_ptr           GET_ENTIRE_VECTOR
                         000536 gk_code                     GET_KEY
                         000537 gk_collection_id            GET_KEY
                         000540 gk_element_id_string        GET_KEY
                         000541 gk_node_id                  GET_KEY
                         000542 gk_node_ptr                 GET_KEY
                         000544 gk_slot_index               GET_KEY
                         000570 gnp_code                    GET_NODE_PTR
                         000571 gnp_collection_id           GET_NODE_PTR
                         000572 gnp_file_opening_id         GET_NODE_PTR
                         000573 gnp_node_id                 GET_NODE_PTR
                         000602 gsv_code                    GET_SELECTED_VECTOR
                         000604 gsv_field_table_ptr         GET_SELECTED_VECTOR
                         000606 gsv_leaf_key_ptr            GET_SELECTED_VECTOR
                         000610 gsv_lk_string_length        GET_SELECTED_VECTOR
                         000612 gsv_work_area_ptr           GET_SELECTED_VECTOR
                         000740 rvs_vector_slot_idx         REVERSE_VECTOR_SLOTS
                         000742 rvs_vector_ptr              REVERSE_VECTOR_SLOTS
                         000754 sesc_code                   SEARCH_SPEC_COMPARISON
                         000756 sesc_field_table_ptr        SEARCH_SPEC_COMPARISON
                         000760 sesc_leaf_key_ptr           SEARCH_SPEC_COMPARISON
                         000762 sesc_lk_string_length       SEARCH_SPEC_COMPARISON
                         000772 sc_code                     SET_INDEX_CURSOR
                         000774 sc_index_cursor_ptr         SET_INDEX_CURSOR
                         000776 sc_leaf_ci_header_ptr       SET_INDEX_CURSOR
                         001000 sc_leaf_key_ptr             SET_INDEX_CURSOR
                         001002 sc_lk_string_length         SET_INDEX_CURSOR
                         001003 sc_node_id                  SET_INDEX_CURSOR
                         001004 sc_slot_index               SET_INDEX_CURSOR
                         001005 sc_element_id_string        SET_INDEX_CURSOR
                         001030 snk_leaf_ci_header_ptr      SETUP_NEXT_KEY
                         001032 snk_node_id                 SETUP_NEXT_KEY
                         001033 snk_position_change         SETUP_NEXT_KEY
                         001034 snk_slot_index              SETUP_NEXT_KEY
                         001044 susc_code                   SUBSET_SPEC_COMPARISON
                         001046 susc_vector_ptr             SUBSET_SPEC_COMPARISON
                         001050 susc_work_area_ptr          SUBSET_SPEC_COMPARISON

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_l_a               r_g_a               r_e_as              r_ne_as             call_ext_out_desc   call_ext_out
return              alloc_auto_adj      ext_entry           divide_fx3          alloc_based         free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
collection_manager_$get_control_interval_ptr                collection_manager_$simple_get_by_ci_ptr
data_format_util_$compare_sequential                        data_format_util_$cv_string_to_vector
im_compare_subset             im_general_delete             im_set_cursor$at_current      im_set_cursor$at_end
im_update_key_counts          sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bad_first_key_idx   dm_error_$bad_last_key_idx    dm_error_$bad_leaf_node       dm_error_$programming_error
dm_error_$wrong_cursor_type   error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    299 000310       301 000311       304 000315       308 000321       311 000327       268 000333       421 000371
    422 000373       423 000377       424 000414       426 000415       431 000454       432 000456       433 000460
    435 000461       439 000521       440 000523       441 000525       443 000526       448 000557       449 000561
    450 000563       473 000564       475 000565       476 000571       481 000652       483 000670       484 000673
    487 000716       488 000722       490 000745       493 000771       495 000773       500 001040       502 001050
    504 001053       506 001054       509 001061       512 001074       516 001120       518 001122       523 001144
    526 001147       527 001151       529 001157       532 001177       536 001203       539 001205       541 001212
    547 001265       550 001270       552 001275       553 001300       554 001301       557 001303       560 001307
    565 001310       567 001311       569 001312       572 001314       573 001316       574 001317       578 001320
    588 001322       589 001323       590 001325       594 001326       597 001327       599 001337       601 001343
    608 001367       609 001377       611 001406       612 001410       615 001412       617 001413       619 001446
    620 001450       622 001453       624 001471       625 001501       627 001540       628 001542       631 001564
    633 001575       634 001617       635 001621       636 001645       638 001650       640 001655       641 001663
    643 001664       654 001666       655 001676       657 001707       662 001750       673 001752       674 001762
    676 001773       681 002024       688 002035       693 002117       695 002120       701 002131       705 002221
    707 002222       714 002224       717 002232       722 002233       736 002235       737 002236       754 002237
    755 002247       756 002260       757 002271       758 002302       759 002313       760 002324       761 002335
    762 002350       764 002361       765 002364       767 002366       770 002422       773 002426       775 002433
    778 002454       781 002460       785 002472       787 002510       789 002511       802 002513       805 002514
    806 002524       807 002535       809 002546       812 002552       813 002554       815 002605       819 002636
    821 002705       824 002717       825 002723       827 002734       828 002745       829 002751       830 002752
    831 002763       835 003015       836 003017       837 003025       840 003035       843 003036       844 003040
    846 003067       850 003116       852 003161       855 003173       856 003201       858 003212       859 003223
    860 003227       861 003230       863 003241       867 003271       868 003275       871 003306       874 003310
    876 003311       881 003313       883 003314       884 003331       885 003343       886 003350       887 003363
    889 003366       894 003367       901 003371       909 003372       912 003377       913 003407       914 003420
    916 003431       917 003434       919 003436       921 003465       923 003471       925 003507       927 003524
    930 003537       932 003544       934 003551       937 003552       943 003554       945 003561       949 003562
    963 003564       967 003571       968 003603       969 003614       971 003625       973 003654       977 003660
    979 003665       981 003666       987 003670       989 003674       992 003675       998 003677      1000 003704
   1003 003705      1010 003707      1012 003713      1015 003714      1021 003716      1022 003722      1024 003723
   1040 003725      1043 003732      1044 003742      1045 003753      1046 003764      1048 003775      1049 004000
   1051 004002      1054 004030      1056 004034      1059 004041      1060 004046      1063 004052      1067 004053
   1074 004055      1076 004061      1079 004062      1085 004064      1087 004070      1089 004071      1101 004073
   1104 004101      1105 004111      1106 004122      1108 004133      1110 004155      1114 004161      1115 004166
   1117 004167      1131 004171      1137 004214      1138 004226      1139 004237      1141 004250      1144 004276
   1147 004302      1149 004307      1152 004310      1158 004312      1159 004316      1163 004317      1169 004321
   1171 004325      1173 004326      1197 004330      1198 004334      1199 004336      1200 004341      1201 004344
   1202 004345      1203 004346      1204 004347      1205 004352      1206 004356      1207 004361      1208 004365
   1209 004370      1210 004375      1211 004402      1212 004406      1213 004410      1216 004413      1219 004416
   1220 004432      1221 004446      1224 004447      1226 004463      1230 004477      1232 004500      1253 004502
   1257 004513      1258 004515      1259 004516      1262 004531      1263 004535      1264 004536      1268 004542
   1269 004543      1270 004544      1272 004552      1273 004555      1274 004562      1275 004563      1281 004647
   1283 004650      1288 004652      1293 004661      1298 004663      1299 004667      1300 004671      1303 004672
   1308 004674      1309 004700      1311 004701      1315 004703      1316 004707      1319 004710      1322 004712
   1323 004720      1324 004725      1325 004726      1328 004727      1334 004731      1335 004734      1337 004736
   1338 004744      1339 004753      1341 004762      1344 004763      1348 004765      1349 004771      1352 004772
   1356 004774      1357 005002      1358 005006      1360 005007      1372 005011      1375 005021      1378 005034
   1381 005054      1382 005061      1383 005063      1385 005067      1387 005070      1394 005072      1395 005073
   1397 005075      1401 005124      1402 005151      1408 005161      1413 005205      1414 005212      1416 005213
   1433 005215      1434 005216      1435 005220      1436 005221      1440 005222      1442 005232      1448 005254
   1450 005266      1451 005270      1455 005335      1459 005341      1461 005342      1467 005344      1480 005345
   1481 005355      1482 005366      1483 005401      1484 005412      1486 005423      1487 005426      1489 005430
   1492 005434      1494 005455      1496 005461      1497 005462      1500 005464      1501 005476      1503 005517
   1505 005523      1506 005524      1509 005526      1512 005550      1513 005555      1514 005566      1517 005570
   1518 005601      1519 005605      1523 005616      1526 005620      1528 005633      1529 005636      1531 005640
   1533 005661      1535 005665      1538 005666      1539 005712      1543 005716      1545 005717      1554 005721
   1557 005733      1558 005740      1562 005741      1568 005743      1571 005755      1574 005762      1580 005763
   1599 005765      1602 005767      1605 005770      1607 005771      1610 005775      1611 005777      1617 006000
   1618 006010      1619 006021      1621 006032      1624 006036      1627 006041      1628 006043      1631 006070
   1632 006073      1634 006074      1638 006125      1639 006141      1641 006152      1643 006167      1646 006170
   1647 006175      1651 006232      1652 006234      1654 006235      1659 006265      1660 006302      1661 006313
   1664 006326      1668 006327      1671 006334      1672 006336      1675 006337      1678 006342      1679 006344
   1682 006371      1683 006374      1685 006375      1689 006426      1690 006442      1692 006453      1694 006470
   1697 006471      1698 006476      1701 006521      1702 006524      1704 006525      1709 006556      1710 006574
   1712 006605      1717 006622      1723 006623      1733 006625      1734 006626      1737 006630      1739 006640
   1741 006651      1743 006705      1745 006711


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
