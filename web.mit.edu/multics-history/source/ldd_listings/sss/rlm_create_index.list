	COMPILATION LISTING OF SEGMENT rlm_create_index
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-05-05_1828.24_Fri_mdt
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /* DESCRIPTION:
        9*
       10*          This routine creates an index in a relation.  The fields in the keys
       11*     of the index are either all of the fields of the record tuples if
       12*     p_id_list_ptr is null, or those fields identified by
       13*     p_id_list_ptr->id_list if non-null.  The keys also have one addition
       14*     field, which is the tuple_id of the tuple which the key identifies.  This
       15*     field is bit (36) aligned.
       16*          Before creating the index, all of the records of the relation are
       17*     retrieved in a typed_vector_array.  If there are no records in the
       18*     relation, a typed_vector_array whose dimension_table describes the fields
       19*     of the keys is created by hand.  index_manager_$create_index stores the
       20*     keys in the typed_vector_array, if there are any, after creating the
       21*     index. 
       22**/
       23 
       24 /* HISTORY:
       25*Written by Matthew Pierret, 06/01/82.
       26*Modified:
       27*06/18/82 by Matthew Pierret: Removed BEGINNING_OF_ELEMENT argument from
       28*            put_element calling sequence.
       29*09/22/82 by Matthew Pierret:  Changed to use id_list and to create unique or
       30*            non-unique indices.
       31*09/30/82 by Matthew Pierret:  Changed to use the area pointed to by
       32*            dm_area_ptr.  Added cleanup handler.
       33*10/12/82 by Matthew Pierret:  Changed to get and reset the opening info.
       34*            Changed to allocate descriptor_string in dm_area rather than
       35*            use an automatic structure so that vu_$free_typed_vector_array
       36*            doesn't blow out.
       37*            Changed to use index_manager_$create_index instead of
       38*	  $create_collection.
       39*11/30/82 by Lindsey Spratt:  Added the (nosubrg) condition prefix to protect
       40*	  statements for which the compiler emits the wrong code (i.e., when
       41*	  assigning from an array into another array which are different
       42*	  instances of the same structure, with different refer extents).
       43*12/02/82 by Lindsey Spratt:  Fixed to copy the attribute_descriptor array
       44*	  when extending the index_attribute_map.
       45*03/01/83 by Matthew Pierret: Added copyright notice. Removed the create_index 
       46*            label. Changed to use relation_opening_info, and to update the
       47*            file copy of index_attribute_map via rlm_update_opening_info.
       48*06/14/83 by Matthew Pierret:  Changed to load the newly created index if there
       49*            are any data already stored in the relation.  This is done by
       50*            retrieving the appropriate fields and the record_id of each record
       51*            in the record collection, and passing the typed_vector_array
       52*            holding these values to index_manager_$create_index, which stores
       53*            them as keys after creating the index.  The record_id is retrieved
       54*            by specifying a value of -1 for the last field_id in the 
       55*            retrieval_id_list.  
       56*            Also added the ERROR_RETURN routine to replace the
       57*            "do;call FINISH;return;end;" cliche with 
       58*            "call ERROR_RETURN (code);".
       59*            Changed BUILD_TVA to use local variables and a parameter.
       60*09/20/83 by Lindsey L. Spratt:  Changed to use
       61*            dm_relation_index_flags.incl.pl1.
       62*04/13/84 by Lee Baldwin:  Changed the calling sequence of 
       63*            record_manager_$get_records_by_spec which no longer takes
       64*            typed_vector_array_version.
       65*05/29/84 by Matthew Pierret:  Changed to RELATION_HEADER_VERSION_3.  Changed
       66*            to copy p_code and p_id_list_ptr parameters into local variables.
       67*            Moved setting of dm_area_ptr and establishment of cleanup handler
       68*            to just before they are needed.
       69*06/07/84 by Lee Baldwin:  Renamed dm_error_$nonempty_relation to
       70*            dm_error_$non_empty_relation.
       71*10/31/84 by Stanford S. Cox: MAIN - Added p_style check.  GET_OR_CREATE_* - Added
       72*   	  index_attribute_map version asgn.
       73*11/01/84 by Lindsey L. Spratt:  Changed to use error_table_$unsupported
       74*            operation instead of the (obsolete) dm_error_$not_implemented.
       75*12/20/84 by Lindsey L. Spratt:  Fixed to use dm_vector_util_ instead of
       76*            vector_util_.
       77*02/05/85 by Lindsey L. Spratt:  Fixed to handle the case where the keys to be
       78*            loaded won't all fit into a single TVA.
       79*02/14/85 by Lindsey L. Spratt:  Moved "on cleanup" statement to precede the
       80*            define_area_ call and changed FINISH to test and release
       81*            local_area_info.areap instead of vector_area_ptr.  Changed
       82*            PUT_REST_OF_KEYS to simply return if the prok_code =
       83*            dm_error_$record_not_found.  Fixed the builtin dcls to be only
       84*            those builtins actually used.
       85**/
       86 
       87 /* format: style2,ind3 */
       88 
       89 rlm_create_index:
       90    proc (p_rel_opening_id, p_id_list_ptr, p_flags, p_style, p_index_collection_id, p_code);
       91 
       92 /* START OF DECLARATIONS */
       93 /* Parameter */
       94 
       95       dcl	    p_rel_opening_id       bit (36) aligned;
       96       dcl	    p_id_list_ptr	       ptr;
       97       dcl	    p_flags	       bit (36) aligned;
       98       dcl	    p_style	       fixed bin (17);
       99       dcl	    p_index_collection_id  bit (36) aligned;
      100       dcl	    p_code	       fixed bin (35);
      101 
      102 /* Automatic */
      103 
      104       dcl	    attribute_idx	       fixed bin;
      105       dcl	    code		       fixed bin (35);
      106       dcl	    index_all_attributes   bit (1) aligned init ("0"b);
      107       dcl	    index_idx	       fixed bin;
      108       dcl	    1 local_area_info      aligned like area_info;
      109       dcl	    number_of_key_fields   fixed bin;
      110       dcl	    relation_is_nonempty   bit (1) aligned init (NO);
      111       dcl	    there_are_more_records bit (1) aligned init (NO);
      112       dcl	    vector_area_ptr	       ptr init (null ());
      113 
      114       dcl	    (descriptor_string_ptr, index_cursor_ptr, input_id_list_ptr, old_index_attribute_map_ptr, record_cursor_ptr,
      115 	    retrieval_id_list_ptr) ptr init (null);
      116 
      117 /* Based */
      118 
      119       dcl	    descriptor_string      bit (36) aligned based (descriptor_string_ptr);
      120       dcl	    dm_area	       area (sys_info$max_seg_size) based (dm_area_ptr);
      121       dcl	    vector_area	       area (sys_info$max_seg_size) based (vector_area_ptr);
      122 
      123 /* Builtin */
      124 
      125       dcl	    (addr, hbound, max, null, unspec, string)
      126 			       builtin;
      127 
      128 /* Condition */
      129 
      130       dcl	    cleanup	       condition;
      131 
      132 /* Constant */
      133 
      134       dcl	    myname	       init ("rlm_create_index") char (32) varying;
      135       dcl	    BITS_PER_WORD	       init (36) fixed bin int static options (constant);
      136       dcl	    MAXIMUM_RANGE_SIZE_FOR_SUBSEQUENT_RETRIEVALS
      137 			       init (131072 /* 2**17 */) fixed bin (35) int static options (constant);
      138       dcl	    TREE_STYLE_INDEX       init (1) fixed bin int static options (constant);
      139       dcl	    (
      140 	    YES		       init ("1"b),
      141 	    NO		       init ("0"b)
      142 	    )		       bit (1) aligned internal static options (constant);
      143 
      144 /* Entry */
      145 
      146       dcl	    get_dm_free_area_      entry () returns (ptr);
      147       dcl	    ioa_$rsnnl	       entry () options (variable);
      148       dcl	    define_area_	       entry (ptr, fixed bin (35));
      149       dcl	    dm_vector_util_$free_typed_vector_array
      150 			       entry (ptr, ptr, fixed bin (35));
      151       dcl	    dm_vector_util_$merge_typed_vector_array
      152 			       entry (ptr, fixed bin (17), ptr, ptr, ptr, fixed bin (35));
      153       dcl	    record_manager_$get_field_info
      154 			       entry (bit (36) aligned, bit (36) aligned, ptr, ptr, fixed bin (35));
      155       dcl	    release_area_	       entry (ptr);
      156       dcl	    rlm_opening_info$get   entry (bit (36) aligned, ptr, fixed bin (35));
      157       dcl	    rlm_update_opening_info$index_attribute_map
      158 			       entry (ptr, ptr, fixed bin (35));
      159       dcl	    sub_err_	       entry () options (variable);
      160 
      161 /* External */
      162 
      163       dcl	    (
      164 	    dm_error_$record_not_found,
      165 	    dm_error_$non_empty_relation,
      166 	    error_table_$area_too_small,
      167 	    error_table_$unimplemented_version,
      168 	    error_table_$unsupported_operation
      169 	    )		       fixed bin (35) ext;
      170 
      171       dcl	    sys_info$max_seg_size  ext fixed bin (35);
      172 
      173 /* Static */
      174 
      175       dcl	    dm_area_ptr	       ptr init (null) internal static;
      176 
      177 /* END OF DECLARATIONS */
      178 
      179 /* format: ^indblkcom,indcomtxt */
      180 
      181 
      182       p_code, code = 0;
      183       typed_vector_array_ptr = null;
      184       input_id_list_ptr = p_id_list_ptr;
      185       if p_style ^= TREE_STYLE_INDEX			/* hash index is not implemented */
      186       then call ERROR_RETURN (error_table_$unsupported_operation);
      187 
      188 /**** Get opening information structures for this relation. */
      189 
      190       call rlm_opening_info$get (p_rel_opening_id, relation_opening_info_ptr, code);
      191       if code ^= 0
      192       then call ERROR_RETURN (code);			/* relation not open */
      193 
      194       call CHECK_VERSION ("relation_opening_info", relation_opening_info.version, RELATION_OPENING_INFO_VERSION_2);
      195 
      196       relation_header_ptr = relation_opening_info.relation_header_ptr;
      197       call CHECK_VERSION ("relation_header", relation_header.version, RELATION_HEADER_VERSION_3);
      198 
      199       attribute_info_ptr = relation_opening_info.attribute_info_ptr;
      200       call CHECK_VERSION ("attribute_info", attribute_info.version, ATTRIBUTE_INFO_VERSION_1);
      201 
      202       index_attribute_map_ptr = relation_opening_info.index_attribute_map_ptr;
      203       call CHECK_VERSION ("index_attribute_map", index_attribute_map.version, INDEX_ATTRIBUTE_MAP_VERSION_2);
      204 
      205 /**** Determine how many fields will make up the key. One is added to the number
      206*      of attributes selected because all keys have an extra field for the tuple
      207*      identifier. */
      208 
      209       if input_id_list_ptr = null
      210       then
      211          do;
      212 	  index_all_attributes = "1"b;
      213 	  number_of_key_fields = attribute_info.number_of_attributes + 1;
      214          end;
      215       else
      216          do;
      217 	  call CHECK_VERSION_FB ("id_list", (input_id_list_ptr -> id_list.version), (ID_LIST_VERSION_1));
      218 	  number_of_key_fields = input_id_list_ptr -> id_list.number_of_ids + 1;
      219          end;
      220 
      221 /**** Get a pointer to an area and set up a cleanup handler. */
      222 
      223       if dm_area_ptr = null
      224       then dm_area_ptr = get_dm_free_area_ ();
      225 
      226       local_area_info.version = area_info_version_1;
      227       local_area_info.owner = myname;
      228       string (local_area_info.control) = "0"b;
      229       local_area_info.control.zero_on_alloc = YES;
      230       local_area_info.areap = null ();
      231 
      232 
      233       local_area_info.size = sys_info$max_seg_size;
      234 
      235       on cleanup call FINISH ();
      236 
      237       call define_area_ (addr (local_area_info), code);
      238       if code ^= 0
      239       then call ERROR_RETURN (code);
      240 
      241       vector_area_ptr = local_area_info.areap;
      242 
      243 
      244 /**** Find an entry in the index_attribute_map.index array for the new index.
      245*      If all of the entries are in use, the array must be extended. */
      246 
      247       index_idx = -1;
      248 
      249       call GET_OR_CREATE_INDEX_ATTRIBUTE_MAP_ENTRY
      250 	 ((index_attribute_map.number_of_indices = index_attribute_map.maximum_number_of_indices),
      251 	 (number_of_key_fields - 1 > index_attribute_map.maximum_number_of_attributes_per_index), index_idx);
      252 
      253 /**** Retrieve the field values that will be stored in the new index
      254*      in a typed_vector_array, or, if there are no data in the relation,
      255*      create a typed_vector_array with a dimension_table describing the
      256*      fields of the keys of the new index. */
      257 
      258       call BUILD_ID_LIST_WITH_TUPLE_ID (number_of_key_fields, input_id_list_ptr, retrieval_id_list_ptr);
      259 
      260       call record_manager_$create_cursor (p_rel_opening_id, relation_header.record_collection_id, dm_area_ptr,
      261 	 record_cursor_ptr, code);
      262       if code ^= 0
      263       then call ERROR_RETURN (code);
      264 
      265       call record_manager_$get_records_by_spec (null (), retrieval_id_list_ptr, vector_area_ptr, record_cursor_ptr,
      266 	 typed_vector_array_ptr, code);
      267       if code = 0
      268       then
      269          do;
      270 	  relation_is_nonempty = YES;
      271 	  there_are_more_records = NO;
      272          end;
      273       else if code = dm_error_$record_not_found
      274       then
      275          do;
      276 	  there_are_more_records = NO;
      277 	  relation_is_nonempty = NO;
      278          /*** There are no tuples in the relation. This is not an error.
      279*	    Create a typed_vector_array by hand to use in creating the index. */
      280 
      281 	  code = 0;
      282 	  call BUILD_TVA (typed_vector_array_ptr);
      283          end;
      284       else if code = error_table_$area_too_small
      285       then
      286          do;
      287 	  code = 0;
      288 	  there_are_more_records = YES;
      289 	  relation_is_nonempty = YES;
      290          end;
      291       else call ERROR_RETURN (code);
      292 
      293       if addr (p_flags) -> relation_index_flags.relation_must_be_empty & relation_is_nonempty = YES
      294       then call ERROR_RETURN (dm_error_$non_empty_relation);
      295 
      296 
      297 /**** Create the new index collection. Use the typed_vector_array to
      298*      describe the fields in the keys of the new index, and set up
      299*      the number of duplication fields (the third argument in the calling
      300*      sequence of index_mananager_$create_index).  If the index is to be
      301*      unique, the number of duplication fields is equal to the number of
      302*      fields excluding the field which contains the tuple_id.  Otherwise,
      303*      the number of duplication fields is equal to the number of key fields.
      304**/
      305 
      306       if addr (p_flags) -> relation_index_flags.index_is_unique
      307       then call index_manager_$create_index (p_rel_opening_id, typed_vector_array_ptr, number_of_key_fields - 1,
      308 	      index_attribute_map.index (index_idx).collection_id, code);
      309       else call index_manager_$create_index (p_rel_opening_id, typed_vector_array_ptr, number_of_key_fields,
      310 	      index_attribute_map.index (index_idx).collection_id, code);
      311 
      312       if code ^= 0
      313       then call ERROR_RETURN (code);
      314 
      315       if there_are_more_records
      316       then
      317          do;
      318 	  call index_manager_$create_cursor (p_rel_opening_id, index_attribute_map.index (index_idx).collection_id,
      319 	       dm_area_ptr, index_cursor_ptr, code);
      320 	  if code ^= 0
      321 	  then call ERROR_RETURN (code);
      322 	  call PUT_REST_OF_KEYS (record_cursor_ptr, retrieval_id_list_ptr, vector_area_ptr, index_cursor_ptr,
      323 	       typed_vector_array_ptr);
      324          end;
      325 
      326 
      327 /**** Update the index_attribute_map to reflect the exixtence of the new
      328*      index. */
      329 
      330       index_attribute_map.number_of_indices = index_attribute_map.number_of_indices + 1;
      331       index_attribute_map.index (index_idx).number_of_attributes = number_of_key_fields - 1;
      332       do attribute_idx = 1 to number_of_key_fields - 1;
      333          if index_all_attributes
      334          then index_attribute_map.index (index_idx).attribute_id (attribute_idx) = attribute_idx;
      335          else index_attribute_map.index (index_idx).attribute_id (attribute_idx) =
      336 	         input_id_list_ptr -> id_list.id (attribute_idx);
      337       end;
      338 
      339 /**** Update the opening copy of the index_attribute_map, as well as the file
      340*      copy and any necessary updates to relation_header to keep the relation
      341*      consistent. */
      342 
      343       call rlm_update_opening_info$index_attribute_map (relation_opening_info_ptr, index_attribute_map_ptr, code);
      344 
      345       if code ^= 0
      346       then call sub_err_ (code, myname, ACTION_CANT_RESTART, null, 0,
      347 	      "The index was created, but an error occurred while resetting the opening information.");
      348 
      349 
      350 /**** Set return argument and return. */
      351 
      352       p_index_collection_id = index_attribute_map.index (index_idx).collection_id;
      353 
      354       call FINISH ();
      355 
      356 MAIN_RETURN:
      357       return;
      358 
      359 CHECK_VERSION:
      360    proc (p_structure_name, p_received_version, p_expected_version);
      361 
      362       dcl	    p_received_version     char (8) aligned;
      363       dcl	    p_expected_version     char (8) aligned;
      364       dcl	    p_structure_name       char (*);
      365 
      366       if p_received_version ^= p_expected_version
      367       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      368 	      "^/Expected version ^8a of the ^a structure.
      369 Received version ^8a, instead.", p_expected_version, p_structure_name, p_received_version);
      370 
      371    end CHECK_VERSION;
      372 
      373 
      374 CHECK_VERSION_FB:
      375    proc (p_structure_name, p_received_version, p_expected_version);
      376 
      377       dcl	    p_received_version     fixed bin (35);
      378       dcl	    p_expected_version     fixed bin (35);
      379       dcl	    p_structure_name       char (*);
      380 
      381       if p_received_version ^= p_expected_version
      382       then call sub_err_ (error_table_$unimplemented_version, myname, ACTION_CANT_RESTART, null, 0,
      383 	      "^/Expected version ^d of the ^a structure.
      384 Received version ^d, instead.", p_expected_version, p_structure_name, p_received_version);
      385 
      386    end CHECK_VERSION_FB;
      387 
      388 ERROR_RETURN:
      389    proc (er_code);
      390 
      391       dcl	    er_code	       fixed bin (35);
      392 
      393       p_code = er_code;
      394       call FINISH ();
      395       goto MAIN_RETURN;
      396 
      397    end ERROR_RETURN;
      398 
      399 
      400 FINISH:
      401    proc ();
      402 
      403       if local_area_info.areap ^= null
      404       then call release_area_ (local_area_info.areap);
      405 
      406       if retrieval_id_list_ptr ^= null
      407       then free retrieval_id_list_ptr -> id_list in (dm_area);
      408 
      409       if record_cursor_ptr ^= null
      410       then call record_manager_$destroy_cursor (record_cursor_ptr, (0));
      411 
      412       if index_cursor_ptr ^= null
      413       then call index_manager_$destroy_cursor (index_cursor_ptr, (0));
      414 
      415       if old_index_attribute_map_ptr ^= index_attribute_map_ptr
      416       then if old_index_attribute_map_ptr ^= null
      417 	      & old_index_attribute_map_ptr ^= relation_opening_info.index_attribute_map_ptr
      418 	 then free old_index_attribute_map_ptr -> index_attribute_map in (dm_area);
      419 	 else if index_attribute_map_ptr ^= null
      420 	      & index_attribute_map_ptr ^= relation_opening_info.index_attribute_map_ptr
      421 	 then free index_attribute_map in (dm_area);
      422 
      423 
      424    end FINISH;
      425 
      426 BUILD_ID_LIST_WITH_TUPLE_ID:
      427    proc (bil_number_of_key_fields, bil_input_id_list_ptr, bil_output_id_list_ptr);
      428 
      429       dcl	    bil_number_of_key_fields
      430 			       fixed bin parameter;
      431       dcl	    bil_input_id_list_ptr  ptr parameter;
      432       dcl	    bil_output_id_list_ptr ptr parameter;
      433       dcl	    bil_id_idx	       fixed bin;
      434 
      435 
      436       il_number_of_ids = bil_number_of_key_fields;
      437       alloc id_list in (dm_area) set (bil_output_id_list_ptr);
      438       bil_output_id_list_ptr -> id_list.version = ID_LIST_VERSION_1;
      439 
      440       if bil_input_id_list_ptr = null
      441       then
      442          do bil_id_idx = 1 to bil_number_of_key_fields - 1;
      443 	  bil_output_id_list_ptr -> id_list.id (bil_id_idx) = bil_id_idx;
      444          end;
      445       else
      446          do bil_id_idx = 1 to bil_number_of_key_fields - 1;
      447 	  bil_output_id_list_ptr -> id_list.id (bil_id_idx) = bil_input_id_list_ptr -> id_list.id (bil_id_idx);
      448          end;
      449       bil_output_id_list_ptr -> id_list.id (bil_id_idx) = -1;
      450 
      451       return;
      452 
      453    end BUILD_ID_LIST_WITH_TUPLE_ID;
      454 
      455 BUILD_TVA:
      456    proc (bt_key_typed_vector_array_ptr);
      457 
      458       dcl	    bt_key_typed_vector_array_ptr
      459 			       ptr parameter;
      460       dcl	    bt_record_typed_vector_array_ptr
      461 			       ptr;
      462       dcl	    bt_dimension_name      char (32) varying init ("");
      463       dcl	    bt_code	       fixed bin (35);
      464 
      465       call record_manager_$get_field_info (p_rel_opening_id, relation_header.record_collection_id, vector_area_ptr,
      466 	 bt_record_typed_vector_array_ptr, bt_code);
      467       if bt_code ^= 0
      468       then call ERROR_RETURN (bt_code);
      469 
      470       call CHECK_VERSION_FB ("typed_vector_array", (bt_record_typed_vector_array_ptr -> typed_vector_array.version),
      471 	 (TYPED_VECTOR_ARRAY_VERSION_2));
      472 
      473       if index_all_attributes
      474       then number_of_key_fields = bt_record_typed_vector_array_ptr -> typed_vector_array.number_of_dimensions + 1;
      475 
      476       call dm_vector_util_$merge_typed_vector_array (vector_area_ptr, number_of_key_fields, input_id_list_ptr,
      477 	 bt_record_typed_vector_array_ptr, bt_key_typed_vector_array_ptr, bt_code);
      478       if bt_code ^= 0
      479       then call ERROR_RETURN (bt_code);
      480 
      481       call CHECK_VERSION_FB ("typed_vector_array", (bt_key_typed_vector_array_ptr -> typed_vector_array.version),
      482 	 (TYPED_VECTOR_ARRAY_VERSION_2));
      483 
      484 /*
      485*   Append the tuple_id field to the end.
      486**/
      487 
      488       alloc descriptor_string in (vector_area);
      489       arg_descriptor_ptr = descriptor_string_ptr;
      490       unspec (descriptor_string) = "0"b;
      491       fixed_arg_descriptor.flag = "1"b;
      492       fixed_arg_descriptor.type = bit_dtype;
      493       fixed_arg_descriptor.precision = 36;
      494 
      495       bt_key_typed_vector_array_ptr -> typed_vector_array.dimension_table (number_of_key_fields).name = "0";
      496       bt_key_typed_vector_array_ptr -> typed_vector_array.dimension_table (number_of_key_fields).descriptor_ptr =
      497 	 arg_descriptor_ptr;
      498 
      499       return;
      500 
      501    end BUILD_TVA;
      502 
      503 GET_OR_CREATE_INDEX_ATTRIBUTE_MAP_ENTRY:
      504    proc (p_extend_index_array, p_increase_maximum_number_of_attributes, p_index_idx);
      505 
      506       dcl	    p_extend_index_array   bit (1) aligned;
      507       dcl	    p_increase_maximum_number_of_attributes
      508 			       bit (1) aligned;
      509       dcl	    p_index_idx	       fixed bin;
      510       dcl	    iam_idx	       fixed bin;
      511       dcl	    attribute_idx	       fixed bin;
      512 
      513       old_index_attribute_map_ptr = index_attribute_map_ptr;
      514 
      515       if p_extend_index_array | p_increase_maximum_number_of_attributes
      516       then
      517 ALLOCATE_NEW_IAM:
      518          do;
      519 	  if p_extend_index_array
      520 	  then iam_maximum_number_of_indices =
      521 		  hbound (old_index_attribute_map_ptr -> index_attribute_map.index, 1) + INITIAL_NUMBER_OF_INDICES;
      522 	  else iam_maximum_number_of_indices = hbound (old_index_attribute_map_ptr -> index_attribute_map.index, 1);
      523 
      524 	  iam_maximum_number_of_attributes_per_index =
      525 	       max (old_index_attribute_map_ptr -> index_attribute_map.maximum_number_of_attributes_per_index,
      526 	       number_of_key_fields - 1);
      527 
      528 	  alloc index_attribute_map in (dm_area);
      529 	  index_attribute_map.version = INDEX_ATTRIBUTE_MAP_VERSION_2;
      530 	  index_attribute_map.number_of_indices = old_index_attribute_map_ptr -> index_attribute_map.number_of_indices;
      531 
      532 	  do iam_idx = 1 to hbound (old_index_attribute_map_ptr -> index_attribute_map.index, 1);
      533 	     if ^p_increase_maximum_number_of_attributes
      534 	     then
      535 (nosubrg):
      536 	        index_attribute_map.index (iam_idx) =
      537 		   old_index_attribute_map_ptr -> index_attribute_map.index (iam_idx);
      538 	     else
      539 	        do;
      540 (nosubrg):
      541 		 index_attribute_map.index (iam_idx).collection_id =
      542 		      old_index_attribute_map_ptr -> index_attribute_map.index (iam_idx).collection_id;
      543 (nosubrg):
      544 		 index_attribute_map.index (iam_idx).style =
      545 		      old_index_attribute_map_ptr -> index_attribute_map.index (iam_idx).style;
      546 (nosubrg):
      547 		 index_attribute_map.index (iam_idx).number_of_duplication_fields =
      548 		      old_index_attribute_map_ptr -> index_attribute_map.index (iam_idx).number_of_duplication_fields;
      549 (nosubrg):
      550 		 index_attribute_map.index (iam_idx).number_of_attributes =
      551 		      old_index_attribute_map_ptr -> index_attribute_map.index (iam_idx).number_of_attributes;
      552 		 index_attribute_map.index (iam_idx).attribute_id (*) = 0;
      553 
      554 		 do attribute_idx = 1 to index_attribute_map.index (iam_idx).number_of_attributes;
      555 (nosubrg):
      556 		    index_attribute_map.index (iam_idx).attribute_id (attribute_idx) =
      557 		         old_index_attribute_map_ptr
      558 		         -> index_attribute_map.index (iam_idx).attribute_id (attribute_idx);
      559 		 end;
      560 	        end;
      561 	  end;
      562 
      563 	  if p_extend_index_array
      564 	  then
      565 	     do;
      566 
      567 	        p_index_idx = iam_idx;
      568 
      569 	        do iam_idx = iam_idx to index_attribute_map.maximum_number_of_indices;
      570 		 unspec (index_attribute_map.index (iam_idx)) = "0"b;
      571 	        end;
      572 	     end;
      573          end ALLOCATE_NEW_IAM;
      574 
      575       if p_index_idx = -1
      576       then
      577          do p_index_idx = 1 to hbound (index_attribute_map.index, 1)
      578 	    while (index_attribute_map.index (p_index_idx).number_of_attributes ^= UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY);
      579          end;
      580 
      581       return;
      582 
      583    end GET_OR_CREATE_INDEX_ATTRIBUTE_MAP_ENTRY;
      584 
      585 PUT_REST_OF_KEYS:
      586    proc (prok_p_record_cursor_ptr, prok_p_record_id_list_ptr, prok_p_vector_area_ptr, prok_p_index_cursor_ptr,
      587         prok_p_typed_vector_array_ptr);
      588       dcl	    prok_p_record_cursor_ptr
      589 			       ptr parm;
      590       dcl	    prok_p_record_id_list_ptr
      591 			       ptr parm;
      592       dcl	    prok_p_vector_area_ptr ptr parm;
      593       dcl	    prok_p_index_cursor_ptr
      594 			       ptr parm;
      595       dcl	    prok_p_typed_vector_array_ptr
      596 			       ptr parm;
      597 
      598       dcl	    prok_p_vector_area     area based (prok_p_vector_area_ptr);
      599 
      600       dcl	    prok_code	       fixed bin (35) init (0);
      601       dcl	    1 prok_numeric_specification
      602 			       aligned like numeric_specification;
      603       dcl	    prok_there_are_more_records
      604 			       bit (1) aligned init (YES);
      605 
      606       prok_numeric_specification.head.version = SPECIFICATION_VERSION_4;
      607       prok_numeric_specification.head.type = RELATIVE_NUMERIC_SPECIFICATION_TYPE;
      608       prok_numeric_specification.position_number = 1;
      609       prok_numeric_specification.range_size = MAXIMUM_RANGE_SIZE_FOR_SUBSEQUENT_RETRIEVALS;
      610 
      611       do while (prok_there_are_more_records);
      612 
      613          call release_area_ (prok_p_vector_area_ptr);
      614          local_area_info.areap = null ();
      615          call define_area_ (addr (local_area_info), prok_code);
      616          prok_p_vector_area_ptr = local_area_info.areap;
      617 
      618          prok_p_typed_vector_array_ptr = null ();
      619 
      620          call record_manager_$get_records_by_spec (addr (prok_numeric_specification), prok_p_record_id_list_ptr,
      621 	    prok_p_vector_area_ptr, prok_p_record_cursor_ptr, prok_p_typed_vector_array_ptr, prok_code);
      622          if prok_code = 0
      623          then prok_there_are_more_records = NO;
      624          else if prok_code = error_table_$area_too_small
      625          then prok_there_are_more_records = YES;
      626          else if prok_code = dm_error_$record_not_found
      627          then return;
      628          else call ERROR_RETURN (prok_code);
      629 
      630          call index_manager_$put_key_array (prok_p_typed_vector_array_ptr, prok_p_index_cursor_ptr, prok_code);
      631          if prok_code ^= 0
      632          then call ERROR_RETURN (prok_code);
      633       end;
      634    end PUT_REST_OF_KEYS;
      635 
  1     1 /* BEGIN INCLUDE FILE - dm_rlm_opening_info.incl.pl1 */
  1     2 
  1     3 /* Written by Matthew Pierret, 09/08/82. 
  1     4*Modified:
  1     5*01/18/83 by Matthew Pierret:  Changed version to be char (8). Added 
  1     6*            transaction_id.
  1     7*02/25/83 by Matthew Pierret:  Changed to relation_opening_info (from
  1     8*            relation_info).
  1     9*10/29/84 by Stanford S. Cox:  Changed to not init version.
  1    10**/
  1    11 
  1    12 
  1    13 /* format: style2,ind3 */
  1    14 
  1    15      dcl	   1 relation_opening_info
  1    16 			      aligned based (relation_opening_info_ptr),
  1    17 	     2 version	      char (8),
  1    18 	     2 per_process,
  1    19 	       3 current_transaction_id
  1    20 			      bit (36) aligned init ("0"b),
  1    21 	       3 current_rollback_count
  1    22 			      fixed bin (35) init (0),
  1    23 	       3 file_opening_id  bit (36) aligned init ("0"b),
  1    24 	       3 number_of_openings
  1    25 			      fixed bin (17) aligned init (0),
  1    26 	       3 lock_advice      aligned,
  1    27 	         4 this_process   bit (2) unaligned init ("0"b),
  1    28 	         4 other_processes
  1    29 			      bit (2) unaligned init ("0"b),
  1    30 	         4 mbz1	      bit (32) unaligned init ("0"b),
  1    31 	       3 record_cursor_ptr
  1    32 			      ptr init (null),
  1    33 	       3 index_cursor_array_ptr
  1    34 			      ptr init (null),
  1    35 	     2 relation_header_ptr
  1    36 			      ptr init (null),
  1    37 	     2 attribute_info_ptr ptr init (null),
  1    38 	     2 index_attribute_map_ptr
  1    39 			      ptr init (null);
  1    40 
  1    41      dcl	   relation_opening_info_ptr
  1    42 			      ptr;
  1    43      dcl	   RELATION_OPENING_INFO_VERSION_2
  1    44 			      init ("rlmopen2") char (8) aligned internal static options (constant);
  1    45 
  1    46 
  1    47 /* END INCLUDE FILE - dm_rlm_opening_info.incl.pl1 */
      636 
      637 
  2     1 /* BEGIN INCLUDE FILE - dm_rlm_header.incl.pl1 */
  2     2 
  2     3 /* HISTORY:
  2     4*Written by Matthew Pierret, 1982.
  2     5*Modified:
  2     6*02/25/83 by Matthew Pierret: Added attribute_info_element_id, 
  2     7*            header_info_update_count, RELATION_HEADER_VERSION_2.
  2     8*05/29/84 by Matthew Pierret: Added caller_header_element_id, 
  2     9*            RELATION_HEADER_VERSION_3.
  2    10*10/29/84 by Stanford S. Cox:  Changed to not init version.
  2    11**/
  2    12 
  2    13 /* format: style2,ind3 */
  2    14 
  2    15      dcl	   1 relation_header      aligned based (relation_header_ptr),
  2    16 	     2 version	      char (8),
  2    17 	     2 header_info_update_count
  2    18 			      fixed bin (35) aligned init (0),
  2    19 	     2 record_collection_id
  2    20 			      bit (36) aligned init ("0"b),
  2    21 	     2 cluster_index_id   bit (36) aligned init ("0"b),
  2    22 	     2 attribute_info_element_id
  2    23 			      bit (36) aligned init ("0"b),
  2    24 	     2 index_attribute_map_element_id
  2    25 			      bit (36) aligned init ("0"b),
  2    26 	     2 caller_header_element_id
  2    27 			      bit (36) aligned init ("0"b);
  2    28 
  2    29      dcl	   relation_header_ptr    ptr init (null);
  2    30      dcl	   RELATION_HEADER_VERSION_3
  2    31 			      init ("RelHdr 3") char (8) aligned internal static options (constant);
  2    32 
  2    33 /* END INCLUDE FILE - dm_rlm_header.incl.pl1 */
      638 
      639 
  3     1 /* BEGIN INCLUDE FILE dm_rlm_attribute_info.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION
  3     4*        
  3     5*   Relation attributes descriptor and name.  This info is kept in the header
  3     6*   collection of existing files, therefore this incl should not be changed.
  3     7**/
  3     8 
  3     9 /* HISTORY:
  3    10*Written by Matthew Pierret, 02/25/83.
  3    11*Modified:
  3    12*10/29/84 by Stanford S. Cox:  Changed to not init version.
  3    13*12/14/84 by Stanford S. Cox:  Backed out previous structure alignment changes
  3    14*   which were incompatible with existing DM files.        
  3    15**/
  3    16 
  3    17 /* format: style2,ind3 */
  3    18      dcl	   1 attribute_info	      aligned based (attribute_info_ptr),
  3    19 	     2 version	      char (8),
  3    20 	     2 number_of_attributes
  3    21 			      fixed bin (17) unal,
  3    22 	     2 maximum_attribute_name_length
  3    23 			      fixed bin (17) unal,
  3    24 	     2 attribute	      (ai_number_of_attributes refer (attribute_info.number_of_attributes)),
  3    25 	       3 descriptor	      bit (36) aligned,
  3    26 	       3 name	      char (ai_maximum_attribute_name_length
  3    27 			      refer (attribute_info.maximum_attribute_name_length)) varying;
  3    28 
  3    29      dcl	   attribute_info_ptr     ptr init (null);
  3    30      dcl	   ai_maximum_attribute_name_length
  3    31 			      fixed bin (17);
  3    32      dcl	   ai_number_of_attributes
  3    33 			      fixed bin (17);
  3    34      dcl	   ATTRIBUTE_INFO_VERSION_1
  3    35 			      init ("attrinf1") char (8) aligned internal static options (constant);
  3    36 
  3    37 /* END INCLUDE FILE dm_rlm_attribute_info.incl.pl1 */
  3    38 
      640 
      641 
  4     1 /* BEGIN INCLUDE FILE - dm_rlm_index_attr_map.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION
  4     4*        
  4     5*   Relation index components.  This info is kept in the header
  4     6*   collection of existing files, therefore this incl should not be changed.
  4     7**/
  4     8 
  4     9 /* HISTORY:
  4    10*Written by Matthew Pierret, 01/15/83.
  4    11*Modified:
  4    12*10/29/84 by Stanford S. Cox: Changed to not init version.
  4    13*12/14/84 by Stanford S. Cox:  Backed out previous structure alignment changes
  4    14*   which were incompatible with existing DM files.        
  4    15**/
  4    16 
  4    17 /* format: style2,ind3 */
  4    18      dcl	   1 index_attribute_map  aligned based (index_attribute_map_ptr),
  4    19 	     2 version	      char (8),
  4    20 	     2 number_of_indices  fixed bin (17) unal init (0),
  4    21 	     2 maximum_number_of_indices
  4    22 			      fixed bin (17) unal,
  4    23 	     2 maximum_number_of_attributes_per_index
  4    24 			      fixed bin (17) unal,
  4    25 	     2 mbz	      fixed bin (17) unal,
  4    26 	     2 index	      (iam_maximum_number_of_indices refer (index_attribute_map.maximum_number_of_indices)),
  4    27 	       3 collection_id    bit (36) aligned,
  4    28 	       3 style	      fixed bin (17) unal,
  4    29 	       3 number_of_duplication_fields
  4    30 			      fixed bin (17) unal,
  4    31 	       3 number_of_attributes
  4    32 			      fixed bin (17) unal,
  4    33 	       3 attribute_id     (iam_maximum_number_of_attributes_per_index
  4    34 			      refer (index_attribute_map.maximum_number_of_attributes_per_index)) fixed
  4    35 			      bin (17) unal;
  4    36 
  4    37      dcl	   index_attribute_map_ptr
  4    38 			      ptr init (null);
  4    39      dcl	   iam_maximum_number_of_indices
  4    40 			      fixed bin (17);
  4    41      dcl	   iam_maximum_number_of_attributes_per_index
  4    42 			      fixed bin (17);
  4    43      dcl	   INDEX_ATTRIBUTE_MAP_VERSION_2
  4    44 			      init ("idx_map2") char (8) aligned internal static options (constant);
  4    45      dcl	   INITIAL_NUMBER_OF_INDICES
  4    46 			      init (5) fixed bin (17);
  4    47      dcl	   UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY
  4    48 			      init (0) fixed bin (17);
  4    49 
  4    50 /* END INCLUDE FILE - dm_rlm_index_attr_map.incl.pl1 */
      642 
      643 
  5     1 /* BEGIN INCLUDE FILE - dm_id_list.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION
  5     4*        The id_list structure is used to identify attributes, fields and
  5     5*   dimensions by various modules of the Data Management System.
  5     6**/
  5     7 
  5     8 /* HISTORY:
  5     9*Written by Matthew Pierret, '82.
  5    10*Modified:
  5    11*08/17/83 by Matthew Pierret: Made version constant 'internal static options
  5    12*            (constant)' and to initialize automatic variables.
  5    13**/
  5    14 
  5    15 /* format: style2,ind3 */
  5    16      dcl	   1 id_list	      aligned based (id_list_ptr),
  5    17 	     2 version	      fixed bin (35),
  5    18 	     2 number_of_ids      fixed bin (17),
  5    19 	     2 id		      (il_number_of_ids refer (id_list.number_of_ids)) fixed bin (17);
  5    20 
  5    21      dcl	   id_list_ptr	      ptr init (null);
  5    22      dcl	   il_number_of_ids	      fixed bin (17) init (-1);
  5    23      dcl	   ID_LIST_VERSION_1      fixed bin (17) init (1) internal static options (constant);
  5    24 
  5    25 /* END INCLUDE FILE - dm_id_list.incl.pl1 */
      644 
      645 
  6     1 /* ***********************************************************
  6     2*   *                                                         *
  6     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
  6     4*   *                                                         *
  6     5*   *********************************************************** */
  6     6 /* BEGIN INCLUDE FILE vu_typed_vector_array.incl.pl1 */
  6     7 
  6     8 /* Written by Lindsey Spratt, 03/04/82.
  6     9*Modified:
  6    10*06/23/82 by Lindsey Spratt: Changed to version 2.  The cv entry declarations
  6    11*	  were altered.  cv_to_typed now takes ptr to the descriptor, ptr to
  6    12*	  the print_vector value (char varying), ptr to the typed_vector
  6    13*	  value location, and a code. cv_to_print now takes ptr to the
  6    14*	  descriptor, ptr to the typed_vector value, the print_vector value
  6    15*	  (char(*) varying), the maximum allowed length for the print_vector
  6    16*	  value, a temp_seg to put the value in if its to big to fit into
  6    17*	  the print_vector, and a code.
  6    18**/
  6    19 
  6    20 /* format: style2,ind3 */
  6    21      dcl	   1 typed_vector_array   based (typed_vector_array_ptr) aligned,
  6    22 	     2 version	      fixed bin (35),
  6    23 	     2 number_of_dimensions
  6    24 			      fixed bin (17),
  6    25 	     2 number_of_vectors  fixed bin (17),
  6    26 	     2 number_of_vector_slots
  6    27 			      fixed bin (17),
  6    28 	     2 maximum_dimension_name_length
  6    29 			      fixed bin (17),
  6    30 	     2 dimension_table    (tva_number_of_dimensions refer (typed_vector_array.number_of_dimensions)),
  6    31 	       3 name	      char (tva_maximum_dimension_name_length
  6    32 			      refer (typed_vector_array.maximum_dimension_name_length)) varying,
  6    33 	       3 descriptor_ptr   ptr,		/* call cv_to_print (descriptor_ptr, typed_value_ptr, */
  6    34 						/* temp_seg_ptr, max_length_for_print_value, */
  6    35 						/* print_value, code) */
  6    36 	       3 cv_to_print      entry (ptr, ptr, ptr, fixed bin (35), char (*) varying, fixed bin (35)),
  6    37 						/* call cv_to_typed (descriptor_ptr, area_ptr, */
  6    38 						/* print_value_ptr, typed_value_ptr, code) */
  6    39 	       3 cv_to_typed      entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  6    40 	     2 vector_slot	      (tva_number_of_vector_slots refer (typed_vector_array.number_of_vector_slots))
  6    41 			      pointer;
  6    42 
  6    43      dcl	   typed_vector_array_ptr ptr;
  6    44      dcl	   tva_number_of_vector_slots
  6    45 			      fixed bin;
  6    46      dcl	   tva_number_of_dimensions
  6    47 			      fixed bin;
  6    48      dcl	   tva_maximum_dimension_name_length
  6    49 			      fixed bin;
  6    50      dcl	   TYPED_VECTOR_ARRAY_VERSION_2
  6    51 			      fixed bin (35) int static options (constant) init (2);
  6    52 
  6    53 /* END INCLUDE FILE vu_typed_vector_array.incl.pl1 */
      646 
      647 
  7     1 /* BEGIN INCLUDE FILE ... arg_descriptor.incl.pl1
  7     2*
  7     3*   James R. Davis 1 Mar 79 */
  7     4 /* Modified June 83 JMAthane for extended arg descriptor format */
  7     5 
  7     6      dcl	   1 arg_descriptor	      based (arg_descriptor_ptr) aligned,
  7     7 	     2 flag	      bit (1) unal,
  7     8 	     2 type	      fixed bin (6) unsigned unal,
  7     9 	     2 packed	      bit (1) unal,
  7    10 	     2 number_dims	      fixed bin (4) unsigned unal,
  7    11 	     2 size	      fixed bin (24) unsigned unal;
  7    12 
  7    13      dcl	   1 fixed_arg_descriptor based (arg_descriptor_ptr) aligned,
  7    14 	     2 flag	      bit (1) unal,
  7    15 	     2 type	      fixed bin (6) unsigned unal,
  7    16 	     2 packed	      bit (1) unal,
  7    17 	     2 number_dims	      fixed bin (4) unsigned unal,
  7    18 	     2 scale	      fixed bin (11) unal,
  7    19 	     2 precision	      fixed bin (12) unsigned unal;
  7    20 
  7    21      dcl	   1 extended_arg_descriptor based (arg_descriptor_ptr) aligned,
  7    22 	     2 flag	      bit (1) unal,		/* = "1"b */
  7    23 	     2 type	      fixed bin (6) unsigned unal, /* = 58 */
  7    24 	     2 packed	      bit (1) unal,		/* significant if number_dims ^= 0 */
  7    25 	     2 number_dims	      fixed (4) unsigned unal,/* number of variable dimensions */
  7    26 	     2 size	      bit (24) unal,
  7    27 	     2 dims	      (0 refer (extended_arg_descriptor.number_dims)), /* part referenced by called generated code */
  7    28 	       3 low	      fixed bin (35),
  7    29 	       3 high	      fixed bin (35),
  7    30 	       3 multiplier	      fixed bin (35),	/* in bits if packed, in words if not */
  7    31 	     2 real_type	      fixed bin (18) unsigned unal,
  7    32 	     2 type_offset	      fixed bin (18) unsigned unal; /* offset rel to symbol tree to symbol node for type, if any */
  7    33 
  7    34      dcl	   arg_descriptor_ptr     ptr;
  7    35 
  7    36      dcl	   extended_arg_type      fixed bin init (58);
  7    37 
  7    38 /* END INCLUDE file .... arg_descriptor.incl.pl1  */
      648 
      649 
  8     1 /* BEGIN INCLUDE FILE ... std_descriptor_types.incl.pl1 */
  8     2 
  8     3 
  8     4 /****^  HISTORY COMMENTS:
  8     5*  1) change(86-09-05,JMAthane), approve(86-09-05,MCR7525),
  8     6*     audit(86-09-11,Martinson), install(86-11-12,MR12.0-1208):
  8     7*     Added pascal_string_type_dtype descriptor type.  Its number is 87.
  8     8*     Objects of this type are PASCAL string types.
  8     9*  2) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  8    10*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  8    11*     Added the new C types.
  8    12*                                                   END HISTORY COMMENTS */
  8    13 
  8    14 /* This include file defines mnemonic names for the Multics
  8    15*   standard descriptor types, using both pl1 and cobol terminology.
  8    16*   PG 780613
  8    17*   JRD 790530
  8    18*   JRD 791016
  8    19*   MBW 810731
  8    20*   TGO 830614 Add hex types.
  8    21*   Modified June 83 JMAthane to add PASCAL data types
  8    22*   TGO 840120 Add float dec extended and generic, float binary generic
  8    23**/
  8    24 
  8    25      dcl	   (real_fix_bin_1_dtype  init (1),
  8    26 	   real_fix_bin_2_dtype   init (2),
  8    27 	   real_flt_bin_1_dtype   init (3),
  8    28 	   real_flt_bin_2_dtype   init (4),
  8    29 	   cplx_fix_bin_1_dtype   init (5),
  8    30 	   cplx_fix_bin_2_dtype   init (6),
  8    31 	   cplx_flt_bin_1_dtype   init (7),
  8    32 	   cplx_flt_bin_2_dtype   init (8),
  8    33 	   real_fix_dec_9bit_ls_dtype init (9),
  8    34 	   real_flt_dec_9bit_dtype init (10),
  8    35 	   cplx_fix_dec_9bit_ls_dtype init (11),
  8    36 	   cplx_flt_dec_9bit_dtype init (12),
  8    37 	   pointer_dtype	      init (13),
  8    38 	   offset_dtype	      init (14),
  8    39 	   label_dtype	      init (15),
  8    40 	   entry_dtype	      init (16),
  8    41 	   structure_dtype	      init (17),
  8    42 	   area_dtype	      init (18),
  8    43 	   bit_dtype	      init (19),
  8    44 	   varying_bit_dtype      init (20),
  8    45 	   char_dtype	      init (21),
  8    46 	   varying_char_dtype     init (22),
  8    47 	   file_dtype	      init (23),
  8    48 	   real_fix_dec_9bit_ls_overp_dtype init (29),
  8    49 	   real_fix_dec_9bit_ts_overp_dtype init (30),
  8    50 	   real_fix_bin_1_uns_dtype init (33),
  8    51 	   real_fix_bin_2_uns_dtype init (34),
  8    52 	   real_fix_dec_9bit_uns_dtype init (35),
  8    53 	   real_fix_dec_9bit_ts_dtype init (36),
  8    54 	   real_fix_dec_4bit_uns_dtype init (38),	/* digit-aligned */
  8    55 	   real_fix_dec_4bit_ts_dtype init (39),	/* byte-aligned */
  8    56 	   real_fix_dec_4bit_bytealigned_uns_dtype init (40), /* COBOL */
  8    57 	   real_fix_dec_4bit_ls_dtype init (41),	/* digit-aligned */
  8    58 	   real_flt_dec_4bit_dtype init (42),		/* digit-aligned */
  8    59 	   real_fix_dec_4bit_bytealigned_ls_dtype init (43),
  8    60 	   real_flt_dec_4bit_bytealigned_dtype init (44),
  8    61 	   cplx_fix_dec_4bit_bytealigned_ls_dtype init (45),
  8    62 	   cplx_flt_dec_4bit_bytealigned_dtype init (46),
  8    63 	   real_flt_hex_1_dtype   init (47),
  8    64 	   real_flt_hex_2_dtype   init (48),
  8    65 	   cplx_flt_hex_1_dtype   init (49),
  8    66 	   cplx_flt_hex_2_dtype   init (50),
  8    67 	   c_typeref_dtype        init (54),
  8    68 	   c_enum_dtype           init (55),
  8    69              c_enum_const_dtype     init (56),
  8    70 	   c_union_dtype          init (57),
  8    71 	   algol68_straight_dtype init (59),
  8    72 	   algol68_format_dtype   init (60),
  8    73 	   algol68_array_descriptor_dtype init (61),
  8    74 	   algol68_union_dtype    init (62),
  8    75 
  8    76 	   cobol_comp_6_dtype     init (1),
  8    77 	   cobol_comp_7_dtype     init (1),
  8    78 	   cobol_display_ls_dtype init (9),
  8    79 	   cobol_structure_dtype  init (17),
  8    80 	   cobol_char_string_dtype init (21),
  8    81 	   cobol_display_ls_overp_dtype init (29),
  8    82 	   cobol_display_ts_overp_dtype init (30),
  8    83 	   cobol_display_uns_dtype init (35),
  8    84 	   cobol_display_ts_dtype init (36),
  8    85 	   cobol_comp_8_uns_dtype init (38),		/* digit aligned */
  8    86 	   cobol_comp_5_ts_dtype  init (39),		/* byte aligned */
  8    87 	   cobol_comp_5_uns_dtype init (40),
  8    88 	   cobol_comp_8_ls_dtype  init (41),		/* digit aligned */
  8    89 	   real_flt_dec_extended_dtype init (81),	/* 9-bit exponent */
  8    90 	   cplx_flt_dec_extended_dtype init (82),	/* 9-bit exponent */
  8    91 	   real_flt_dec_generic_dtype init (83),	/* generic float decimal */
  8    92 	   cplx_flt_dec_generic_dtype init (84),
  8    93 	   real_flt_bin_generic_dtype init (85),	/* generic float binary */
  8    94 	   cplx_flt_bin_generic_dtype init (86)) fixed bin internal static options (constant);
  8    95 
  8    96      dcl	   (ft_integer_dtype      init (1),
  8    97 	   ft_real_dtype	      init (3),
  8    98 	   ft_double_dtype	      init (4),
  8    99 	   ft_complex_dtype	      init (7),
  8   100 	   ft_complex_double_dtype init (8),
  8   101 	   ft_external_dtype      init (16),
  8   102 	   ft_logical_dtype	      init (19),
  8   103 	   ft_char_dtype	      init (21),
  8   104 	   ft_hex_real_dtype      init (47),
  8   105 	   ft_hex_double_dtype    init (48),
  8   106 	   ft_hex_complex_dtype   init (49),
  8   107 	   ft_hex_complex_double_dtype init (50)
  8   108 	   )		      fixed bin internal static options (constant);
  8   109 
  8   110      dcl	   (algol68_short_int_dtype init (1),
  8   111 	   algol68_int_dtype      init (1),
  8   112 	   algol68_long_int_dtype init (2),
  8   113 	   algol68_real_dtype     init (3),
  8   114 	   algol68_long_real_dtype init (4),
  8   115 	   algol68_compl_dtype    init (7),
  8   116 	   algol68_long_compl_dtype init (8),
  8   117 	   algol68_bits_dtype     init (19),
  8   118 	   algol68_bool_dtype     init (19),
  8   119 	   algol68_char_dtype     init (21),
  8   120 	   algol68_byte_dtype     init (21),
  8   121 	   algol68_struct_struct_char_dtype init (22),
  8   122 	   algol68_struct_struct_bool_dtype init (20)
  8   123 	   )		      fixed bin internal static options (constant);
  8   124 
  8   125      dcl	   (label_constant_runtime_dtype init (24),
  8   126 	   int_entry_runtime_dtype init (25),
  8   127 	   ext_entry_runtime_dtype init (26),
  8   128 	   ext_procedure_runtime_dtype init (27),
  8   129 	   picture_runtime_dtype  init (63)
  8   130 	   )		      fixed bin internal static options (constant);
  8   131 
  8   132      dcl	   (pascal_integer_dtype  init (1),
  8   133 	   pascal_real_dtype      init (4),
  8   134 	   pascal_label_dtype     init (24),
  8   135 	   pascal_internal_procedure_dtype init (25),
  8   136 	   pascal_exportable_procedure_dtype init (26),
  8   137 	   pascal_imported_procedure_dtype init (27),
  8   138 	   pascal_typed_pointer_type_dtype init (64),
  8   139 	   pascal_char_dtype      init (65),
  8   140 	   pascal_boolean_dtype   init (66),
  8   141 	   pascal_record_file_type_dtype init (67),
  8   142 	   pascal_record_type_dtype init (68),
  8   143 	   pascal_set_dtype	      init (69),
  8   144 	   pascal_enumerated_type_dtype init (70),
  8   145 	   pascal_enumerated_type_element_dtype init (71),
  8   146 	   pascal_enumerated_type_instance_dtype init (72),
  8   147 	   pascal_user_defined_type_dtype init (73),
  8   148 	   pascal_user_defined_type_instance_dtype init (74),
  8   149 	   pascal_text_file_dtype init (75),
  8   150 	   pascal_procedure_type_dtype init (76),
  8   151 	   pascal_variable_formal_parameter_dtype init (77),
  8   152 	   pascal_value_formal_parameter_dtype init (78),
  8   153 	   pascal_entry_formal_parameter_dtype init (79),
  8   154 	   pascal_parameter_procedure_dtype init (80),
  8   155 	   pascal_string_type_dtype init (87)) fixed bin int static options (constant);
  8   156 
  8   157 
  8   158 /* END INCLUDE FILE ... std_descriptor_types.incl.pl1 */
      650 
      651 
  9     1 /* BEGIN INCLUDE FILE - dm_hdr_collection_id.incl.pl1 */
  9     2 
  9     3 /* DESCRIPTION:
  9     4*
  9     5*        Contains the identifier of the Header Collection for a file
  9     6*   managed by the collection_manager_.  This is used by callers of 
  9     7*   collection_manager who wish to maintain their own file header or who wish
  9     8*   to maintain their own collection header information beyond the caller
  9     9*   collection header provided by colleciton_manager_$(get put)_header.
  9    10**/
  9    11 
  9    12 /* HISTORY:
  9    13*Written by Matthew Pierret, 09/24/84.
  9    14*Modified:
  9    15**/
  9    16 
  9    17 /* format: style2,ind3,ll79 */
  9    18 
  9    19      dcl	   HEADER_COLLECTION_ID   init ("000000000001"b3) bit (36)
  9    20 			      aligned internal static options (constant);
  9    21 
  9    22 /* END INCLUDE FILE - dm_hdr_collection_id.incl.pl1 */
      652 
      653 
 10     1 /* BEGIN INCLUDE FILE - dm_specification.incl.pl1 */
 10     2 
 10     3 /* DESCRIPTION:
 10     4*
 10     5*          The specification structure is used to identify sets items based on
 10     6*     the value of some of the contents of the items (the
 10     7*     search_specification), or based on the ordinal position (the
 10     8*     numeric_specification) of the first or last item in the desired set of
 10     9*     items in the set of all possible items.  It is used with the relation,
 10    10*     index and record managers.  The items for these three managers are
 10    11*     tuples, keys and records, respectively.  The sets of "all possible
 10    12*     items", for determination of ordinal position for these three managers
 10    13*     are: a relation, an index, and a record collection, respectively.
 10    14*     
 10    15*          The specification_head structure, in dm_specification_head.incl.pl1,
 10    16*     must be included in any program which uses this (the
 10    17*     dm_specification.incl.pl1) include file.
 10    18**/
 10    19 
 10    20 /* HISTORY:
 10    21*
 10    22*Written by Lindsey Spratt, 05/19/82.
 10    23*Modified:
 10    24*08/17/82 by Matthew Pierret:  Added all specification type constants.
 10    25*09/24/82 by Ronald Harvey: Changed version and added and_groups.
 10    26*10/22/82 by Lindsey Spratt:  Added the range_size to the numeric_specification.
 10    27*	  Changed the version to 3.
 10    28*05/11/83 by Matthew Pierret: Moved specification_head and and type constants
 10    29*            to dm_specification_head.incl.pl1. Added constraint.value_field_id.
 10    30*            Moved range type constants into dm_range_constants.incl.pl1.
 10    31*05/20/83 by Matthew Pierret: Added constraint.value_field_id for specifying
 10    32*            intra-key/record compares.
 10    33*10/02/84 by Lindsey L. Spratt:  Moved a misplaced journalization comment.
 10    34*            Added a DESCRIPTION comment.
 10    35**/
 10    36 
 10    37 /* format: style2,ind3 */
 10    38      dcl	   1 search_specification based (search_specification_ptr),
 10    39 	     2 head	      like specification_head,
 10    40 	     2 maximum_number_of_constraints
 10    41 			      fixed bin (17) unal,
 10    42 	     2 number_of_and_groups
 10    43 			      fixed bin (17) unal,
 10    44 	     2 range	      unal,
 10    45 	       3 type	      fixed bin (17),
 10    46 	       3 size	      fixed bin (17),
 10    47 	     2 and_group	      (ss_number_of_and_groups refer (search_specification.number_of_and_groups)),
 10    48 	       3 number_of_constraints
 10    49 			      fixed bin (17) unal,
 10    50 	       3 constraint	      (ss_maximum_number_of_constraints
 10    51 			      refer (search_specification.maximum_number_of_constraints)),
 10    52 	         4 field_id	      fixed bin (17) unal,
 10    53 	         4 operator_code  fixed bin (17) unal,
 10    54 	         4 value_field_id fixed bin (17) unal,
 10    55 	         4 pad	      bit (18) unal,
 10    56 	         4 value_ptr      ptr unal;
 10    57 
 10    58      dcl	   search_specification_ptr
 10    59 			      ptr;
 10    60      dcl	   (ss_number_of_and_groups, ss_maximum_number_of_constraints)
 10    61 			      fixed bin (17);
 10    62 
 10    63      dcl	   1 numeric_specification
 10    64 			      based (numeric_specification_ptr),
 10    65 	     2 head	      like specification_head,
 10    66 	     2 range_size	      fixed bin (35) aligned,
 10    67 	     2 position_number    fixed bin (17) unal,
 10    68 	     2 pad	      bit (18) unal;
 10    69 
 10    70      dcl	   numeric_specification_ptr
 10    71 			      ptr;
 10    72 
 10    73 /* END INCLUDE FILE - dm_specification.incl.pl1 */
      654 
      655 
 11     1 /* BEGIN INCLUDE FILE dm_specification_head.incl.pl1 */
 11     2 
 11     3 /* HISTORY:
 11     4*Written by Matthew Pierret, 05/11/83. (Extracted from dm_specification.incl.pl1)
 11     5*Modified:
 11     6*05/20/83 by Matthew Pierret: Changed to use version 4.
 11     7**/
 11     8 
 11     9 /* format: style2,ind3 */
 11    10      dcl	   1 specification_head   based (specification_head_ptr),
 11    11 	     2 version	      fixed bin (35),
 11    12 	     2 type	      fixed bin (17) unal,
 11    13 	     2 pad	      bit (18) unal,
 11    14 	     2 subset_specification_ptr
 11    15 			      ptr;
 11    16 
 11    17 
 11    18      dcl	   specification_head_ptr ptr;
 11    19      dcl	   SPECIFICATION_VERSION_4
 11    20 			      init (4) fixed bin (35) internal static options (constant);
 11    21 
 11    22      dcl	   (
 11    23 	   SEARCH_SPECIFICATION_TYPE
 11    24 			      init (1),
 11    25 	   ABSOLUTE_SEARCH_SPECIFICATION_TYPE
 11    26 			      init (1),
 11    27 	   NUMERIC_SPECIFICATION_TYPE
 11    28 			      init (2),
 11    29 	   ABSOLUTE_NUMERIC_SPECIFICATION_TYPE
 11    30 			      init (2),
 11    31 	   RELATIVE_SEARCH_SPECIFICATION_TYPE
 11    32 			      init (3),
 11    33 	   RELATIVE_NUMERIC_SPECIFICATION_TYPE
 11    34 			      init (4),
 11    35 	   ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
 11    36 			      init (5),
 11    37 	   RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
 11    38 			      init (6),
 11    39 	   ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
 11    40 			      init (7),
 11    41 	   RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
 11    42 			      init (8)
 11    43 	   )		      fixed bin (17) internal static options (constant);
 11    44 
 11    45 
 11    46 /* END INCLUDE FILE dm_specification_head.incl.pl1 */
      656 
      657 
 12     1 /*  BEGIN INCLUDE FILE - dm_relation_index_flags.incl.pl1 */
 12     2 
 12     3 /* DESCRIPTION:
 12     4*
 12     5*	This structure is used to control the creation of an index by the 
 12     6*     relation_manager_.
 12     7**/
 12     8 
 12     9 /* HISTORY:
 12    10*
 12    11*Written by Lindsey Spratt, 09/20/83.
 12    12*Modified:
 12    13**/
 12    14 
 12    15 /* format: style2,ind3 */
 12    16      dcl	   1 relation_index_flags based (relation_index_flags_ptr) aligned,
 12    17 	     2 relation_must_be_empty
 12    18 			      bit (1) unal,
 12    19 	     2 index_is_clustering
 12    20 			      bit (1) unal,
 12    21 	     2 index_is_unique    bit (1) unal,
 12    22 	     2 pad	      bit (33) unal;
 12    23 
 12    24      dcl	   relation_index_flags_ptr
 12    25 			      ptr init (null);
 12    26 
 12    27 /*  END INCLUDE FILE - dm_relation_index_flags.incl.pl1 */
      658 
      659 
 13     1 /* BEGIN INCLUDE FILE - dm_idxmgr_entry_dcls.incl.pl1 */
 13     2 
 13     3 /* DESCRIPTION:
 13     4*
 13     5*          This include file has all of the declarations for the index_manager_
 13     6*     external interface.  It is useful for programs which are making extensive
 13     7*     use of the index_manager_ to include this include file rather than
 13     8*     individually declaring each of the entries.
 13     9*     
 13    10**/
 13    11 
 13    12 /* HISTORY:
 13    13*
 13    14*Written by Lindsey Spratt, 06/25/82.
 13    15*Modified:
 13    16*07/28/82 by Lindsey Spratt: Extended the create_collection entry calling
 13    17*	  sequence to include the number_of_duplication_fields.
 13    18*08/10/82 by Matthew Pierret: Changed the create_collection entry calling 
 13    19*            sequence to return a "bit (36) aligned" collection id instead of
 13    20*            "fixed bin (17)".  Changed create_cursor calling sequence likewise.
 13    21*08/19/82 by Lindsey Spratt:  Renamed create_collection to create_index. Added
 13    22*	  the put_key_array entry.  Added the id_list_ptr to the get_key
 13    23*	  entry.  Added the create_subset_index entry.
 13    24*08/23/82 by Lindsey Spratt:  Added the position_cursor entry.
 13    25*09/27/82 by Lindsey Spratt:  Added the get_count and get_duplicate_key_count
 13    26*	  entries.
 13    27*11/09/82 by Lindsey Spratt:  Added ptr to get_key for the interval_list.
 13    28*	  Changed get_duplicate_key_count to get_key_count_array.
 13    29*05/31/83 by Matthew Pierret: Added $destroy_index and $destroy_cursor.
 13    30*05/02/84 by Lee Baldwin:  Renamed $get_count to $get_key_count_by_spec.
 13    31*10/23/84 by Lindsey L. Spratt:  Addressed auditing comments - alphabetized
 13    32*            entries, fixed $create_index to use "fixed bin (17)" instead of
 13    33*            just "fixed bin", added a description section.
 13    34**/
 13    35 
 13    36 /* format: style2,ind3 */
 13    37 
 13    38      dcl	   index_manager_$create_cursor entry (bit (36) aligned, bit (36) aligned, ptr, ptr, fixed bin (35));
 13    39      dcl	   index_manager_$create_index entry (bit (36) aligned, ptr, fixed bin (17), bit (36) aligned, fixed bin (35));
 13    40      dcl	   index_manager_$create_subset_index entry (ptr, bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
 13    41      dcl	   index_manager_$delete_key entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35));
 13    42      dcl	   index_manager_$destroy_cursor entry (ptr, fixed bin (35));
 13    43      dcl	   index_manager_$destroy_index entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
 13    44      dcl	   index_manager_$get_key entry (ptr, ptr, ptr, ptr, ptr, ptr, fixed bin (35));
 13    45      dcl	   index_manager_$get_key_count_array entry (ptr, ptr, ptr, fixed bin (35));
 13    46      dcl	   index_manager_$get_key_count_by_spec entry (ptr, ptr, fixed bin (35), fixed bin (35));
 13    47      dcl	   index_manager_$position_cursor entry (ptr, ptr, ptr, fixed bin (35));
 13    48      dcl	   index_manager_$put_key entry (ptr, ptr, fixed bin (35));
 13    49      dcl	   index_manager_$put_key_array entry (ptr, ptr, fixed bin (35));
 13    50 
 13    51 /* END INCLUDE FILE - dm_idxmgr_entry_dcls.incl.pl1 */
      660 
      661 
 14     1 /* BEGIN INCLUDE FILE dm_rcdmgr_entry_dcls.incl.pl1 */
 14     2 
 14     3 /* This include file contains declarations of record_manager_ entry points. */
 14     4 
 14     5 /* HISTORY:
 14     6*Written by Matthew Pierret 05/12/82.
 14     7*Modified:
 14     8*12/14/82 by Matthew Pierret: Changed $get_ids to $get_id.
 14     9*04/01/83 by Matthew Pierret: Added $get_records_and_ids and
 14    10*            $get_records_and_ids_by_interval.
 14    11*04/04/83 by Matthew Pierret: Added $destroy_collection and $destroy_cursor.
 14    12*05/24/83 by Matthew Pierret: Corrected mis-spelling of "manger" for
 14    13*            rcm_$destroy_cursor.
 14    14*06/06/83 by Matthew Pierret: Corrected rcm_$get_record_count_by_intervals -
 14    15*            added a ptr parameter. 
 14    16*06/13/83 by Matthew Pierret:  Changed rcm_$*_by_intervals to correctly be
 14    17*            rcm_$=_by_interval.
 14    18*04/12/84 by Lee Baldwin:  Renamed some of the entry points (see 
 14    19*            record_manager_.alm) and changed the declarations of
 14    20*            those that used to pass a typed_vector_type and a
 14    21*            typed_vector_array_version.
 14    22*04/26/84 by Lee Baldwin:  Changed the arg list of
 14    23*            $get_record_count_by_interval to not take a work_area_ptr.
 14    24**/
 14    25 
 14    26 /* format: style2,ind3 */
 14    27      dcl	   record_manager_$create_collection
 14    28 			      entry (bit (36) aligned, ptr, ptr, ptr, bit (36) aligned, fixed bin (35));
 14    29      dcl	   record_manager_$create_cursor
 14    30 			      entry (bit (36) aligned, bit (36) aligned, ptr, ptr, fixed bin (35));
 14    31      dcl	   record_manager_$destroy_collection
 14    32 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
 14    33      dcl	   record_manager_$destroy_cursor
 14    34 			      entry (ptr, fixed bin (35));
 14    35 
 14    36      dcl	   record_manager_$get_record_by_id
 14    37 			      entry (bit (36) aligned, ptr, ptr, ptr, ptr, fixed bin (35));
 14    38      dcl	   record_manager_$get_records_by_id_list
 14    39 			      entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35));
 14    40      dcl	   record_manager_$get_records_by_spec
 14    41 			      entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35));
 14    42      dcl	   record_manager_$get_records_by_interval
 14    43 			      entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35), ptr, ptr, fixed bin (35));
 14    44      dcl	   record_manager_$get_records_and_ids_by_spec
 14    45 			      entry (ptr, ptr, ptr, ptr, ptr, ptr, fixed bin (35));
 14    46      dcl	   record_manager_$get_records_and_ids_by_interval
 14    47 			      entry (ptr, ptr, ptr, ptr, ptr, fixed bin (17), ptr, ptr, ptr, fixed bin (35));
 14    48      dcl	   record_manager_$get_record_ids_by_spec
 14    49                                     entry (ptr, ptr, ptr, ptr, fixed bin (35));
 14    50      dcl	   record_manager_$get_record_ids_by_interval
 14    51 			      entry (ptr, ptr, ptr, ptr, ptr, ptr, fixed bin (35));
 14    52      dcl	   record_manager_$get_record_count
 14    53 			      entry (ptr, ptr, fixed bin (35), fixed bin (35));
 14    54      dcl	   record_manager_$get_record_count_by_interval
 14    55 			      entry (ptr, ptr, ptr, ptr, fixed bin (35), fixed bin (35));
 14    56 
 14    57      dcl	   record_manager_$put_record_by_id
 14    58 			      entry (bit (36) aligned, ptr, fixed bin (35), ptr, bit (36) aligned, fixed bin (35));
 14    59 
 14    60      dcl	   record_manager_$put_records_by_id
 14    61 			      entry (bit (36) aligned, ptr, fixed bin (35), ptr, ptr, fixed bin (35));
 14    62 
 14    63      dcl	   record_manager_$delete_record_by_id
 14    64 			      entry (bit (36) aligned, ptr, fixed bin (35));
 14    65 
 14    66      dcl	   record_manager_$delete_records_by_id_list
 14    67 			      entry (ptr, ptr, fixed bin (35), fixed bin (35));
 14    68 
 14    69      dcl	   record_manager_$delete_records_by_spec
 14    70 			      entry (ptr, ptr, fixed bin (35), fixed bin (35));
 14    71 
 14    72      dcl	   record_manager_$modify_record_by_id
 14    73 			      entry (bit (36) aligned, ptr, ptr, fixed bin (35));
 14    74 
 14    75      dcl	   record_manager_$modify_records_by_id_list
 14    76 			      entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35));
 14    77 
 14    78      dcl	   record_manager_$modify_records_by_spec
 14    79 			      entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35));
 14    80 
 14    81 /* END INCLUDE FILE dm_rcdmgr_entry_dcls.incl.pl1 */
      662 
      663 
 15     1 /* BEGIN INCLUDE FILE area_info.incl.pl1  12/75 */
 15     2 
 15     3 dcl  area_info_version_1 fixed bin static init (1) options (constant);
 15     4 
 15     5 dcl  area_infop ptr;
 15     6 
 15     7 dcl 1 area_info aligned based (area_infop),
 15     8     2 version fixed bin,				/* version number for this structure is 1 */
 15     9     2 control aligned like area_control,		/* control bits for the area */
 15    10     2 owner char (32) unal,				/* creator of the area */
 15    11     2 n_components fixed bin,				/* number of components in the area (returned only) */
 15    12     2 size fixed bin (18),				/* size of the area in words */
 15    13     2 version_of_area fixed bin,			/* version of area (returned only) */
 15    14     2 areap ptr,					/* pointer to the area (first component on multisegment area) */
 15    15     2 allocated_blocks fixed bin,			/* number of blocks allocated */
 15    16     2 free_blocks fixed bin,				/* number of free blocks not in virgin */
 15    17     2 allocated_words fixed bin (30),			/* number of words allocated in the area */
 15    18     2 free_words fixed bin (30);			/* number of words free in area not in virgin */
 15    19 
 15    20 dcl 1 area_control aligned based,
 15    21     2 extend bit (1) unal,				/* says area is extensible */
 15    22     2 zero_on_alloc bit (1) unal,			/* says block gets zerod at allocation time */
 15    23     2 zero_on_free bit (1) unal,			/* says block gets zerod at free time */
 15    24     2 dont_free bit (1) unal,			/* debugging aid, turns off free requests */
 15    25     2 no_freeing bit (1) unal,			/* for allocation method without freeing */
 15    26     2 system bit (1) unal,				/* says area is managed by system */
 15    27     2 pad bit (30) unal;
 15    28 
 15    29 /* END INCLUDE FILE area_info.incl.pl1 */
      664 
      665 
 16     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
 16     2 /* format: style3 */
 16     3 
 16     4 /* These constants are to be used for the flags argument of sub_err_ */
 16     5 /* They are just "string (condition_info_header.action_flags)" */
 16     6 
 16     7 declare	(
 16     8 	ACTION_CAN_RESTART	init (""b),
 16     9 	ACTION_CANT_RESTART init ("1"b),
 16    10 	ACTION_DEFAULT_RESTART
 16    11 			init ("01"b),
 16    12 	ACTION_QUIET_RESTART
 16    13 			init ("001"b),
 16    14 	ACTION_SUPPORT_SIGNAL
 16    15 			init ("0001"b)
 16    16 	)		bit (36) aligned internal static options (constant);
 16    17 
 16    18 /* End include file */
      666 
      667    end rlm_create_index;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/05/00  1828.2  rlm_create_index.pl1              >udd>sm>ds>w>ml>rlm_create_index.pl1
636          1    01/07/85  0959.6  dm_rlm_opening_info.incl.pl1      >ldd>incl>dm_rlm_opening_info.incl.pl1
638          2    01/07/85  0959.4  dm_rlm_header.incl.pl1            >ldd>incl>dm_rlm_header.incl.pl1
640          3    01/07/85  1001.7  dm_rlm_attribute_info.incl.pl1    >ldd>incl>dm_rlm_attribute_info.incl.pl1
642          4    01/07/85  1001.7  dm_rlm_index_attr_map.incl.pl1    >ldd>incl>dm_rlm_index_attr_map.incl.pl1
644          5    10/14/83  1709.1  dm_id_list.incl.pl1               >ldd>incl>dm_id_list.incl.pl1
646          6    10/14/83  1709.1  vu_typed_vector_array.incl.pl1    >ldd>incl>vu_typed_vector_array.incl.pl1
648          7    11/02/83  1945.0  arg_descriptor.incl.pl1           >ldd>incl>arg_descriptor.incl.pl1
650          8    10/26/88  1355.5  std_descriptor_types.incl.pl1     >ldd>incl>std_descriptor_types.incl.pl1
652          9    01/07/85  0958.8  dm_hdr_collection_id.incl.pl1     >ldd>incl>dm_hdr_collection_id.incl.pl1
654         10    01/07/85  0959.8  dm_specification.incl.pl1         >ldd>incl>dm_specification.incl.pl1
656         11    10/14/83  1709.1  dm_specification_head.incl.pl1    >ldd>incl>dm_specification_head.incl.pl1
658         12    10/14/83  1709.1  dm_relation_index_flags.incl.pl1  >ldd>incl>dm_relation_index_flags.incl.pl1
660         13    01/07/85  0958.8  dm_idxmgr_entry_dcls.incl.pl1     >ldd>incl>dm_idxmgr_entry_dcls.incl.pl1
662         14    01/07/85  0959.3  dm_rcdmgr_entry_dcls.incl.pl1     >ldd>incl>dm_rcdmgr_entry_dcls.incl.pl1
664         15    06/11/76  1143.4  area_info.incl.pl1                >ldd>incl>area_info.incl.pl1
666         16    04/16/82  1058.1  sub_err_flags.incl.pl1            >ldd>incl>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000021 constant        bit(36)                  initial dcl 16-7 set ref 345* 366* 381*
ATTRIBUTE_INFO_VERSION_1        000002 constant        char(8)                  initial dcl 3-34 set ref 200*
ID_LIST_VERSION_1                      constant        fixed bin(17,0)          initial dcl 5-23 ref 217 438
INDEX_ATTRIBUTE_MAP_VERSION_2   000000 constant        char(8)                  initial dcl 4-43 set ref 203* 529
INITIAL_NUMBER_OF_INDICES       000204 automatic       fixed bin(17,0)          initial dcl 4-45 set ref 4-45* 519
MAXIMUM_RANGE_SIZE_FOR_SUBSEQUENT_RETRIEVALS
                                       constant        fixed bin(35,0)          initial dcl 136 ref 609
NO                                     constant        bit(1)                   initial dcl 139 ref 110 111 271 276 277 622
RELATION_HEADER_VERSION_3       000004 constant        char(8)                  initial dcl 2-30 set ref 197*
RELATION_OPENING_INFO_VERSION_2 000006 constant        char(8)                  initial dcl 1-43 set ref 194*
RELATIVE_NUMERIC_SPECIFICATION_TYPE    constant        fixed bin(17,0)          initial dcl 11-22 ref 607
SPECIFICATION_VERSION_4                constant        fixed bin(35,0)          initial dcl 11-19 ref 606
TREE_STYLE_INDEX                       constant        fixed bin(17,0)          initial dcl 138 ref 185
TYPED_VECTOR_ARRAY_VERSION_2           constant        fixed bin(35,0)          initial dcl 6-50 ref 470 481
UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY
                                000205 automatic       fixed bin(17,0)          initial dcl 4-47 set ref 4-47* 575
YES                                    constant        bit(1)                   initial dcl 139 ref 229 270 288 289 293 603 624
addr                                                   builtin function         dcl 125 ref 237 237 293 306 615 615 620 620
area_control                           based           structure                level 1 dcl 15-20
area_info                              based           structure                level 1 dcl 15-7
area_info_version_1                    constant        fixed bin(17,0)          initial dcl 15-3 ref 226
areap                    16     000104 automatic       pointer                  level 2 dcl 108 set ref 230* 241 403 403* 614* 616
arg_descriptor_ptr              000214 automatic       pointer                  dcl 7-34 set ref 489* 491 492 493 496
attribute_id              6(18)        based           fixed bin(17,0)          array level 3 packed packed unaligned dcl 4-18 set
                                                                                  ref 333* 335* 552* 555* 555
attribute_idx                   000100 automatic       fixed bin(17,0)          dcl 104 in procedure "rlm_create_index" set ref 332*
                                                                                  333 333 335 335*
attribute_idx                   000311 automatic       fixed bin(17,0)          dcl 511 in procedure
                                                                                  "GET_OR_CREATE_INDEX_ATTRIBUTE_MAP_ENTRY" set ref
                                                                                  554* 555 555*
attribute_info                         based           structure                level 1 dcl 3-18
attribute_info_ptr              000176 automatic       pointer                  initial dcl 3-29 in procedure "rlm_create_index" set
                                                                                  ref 199* 200 213 3-29*
attribute_info_ptr       16            based           pointer                  initial level 2 in structure "relation_opening_info"
                                                                                  dcl 1-15 in procedure "rlm_create_index" ref 199
bil_id_idx                      000254 automatic       fixed bin(17,0)          dcl 433 set ref 440* 443 443* 445* 447 447* 449
bil_input_id_list_ptr                  parameter       pointer                  dcl 431 ref 426 440 447
bil_number_of_key_fields               parameter       fixed bin(17,0)          dcl 429 ref 426 436 440 445
bil_output_id_list_ptr                 parameter       pointer                  dcl 432 set ref 426 437* 438 443 447 449
bit_dtype                              constant        fixed bin(17,0)          initial dcl 8-25 ref 492
bt_code                         000301 automatic       fixed bin(35,0)          dcl 463 set ref 465* 467 467* 476* 478 478*
bt_dimension_name               000270 automatic       varying char(32)         initial dcl 462 set ref 462*
bt_key_typed_vector_array_ptr          parameter       pointer                  dcl 458 set ref 455 476* 481 495 496
bt_record_typed_vector_array_ptr
                                000266 automatic       pointer                  dcl 460 set ref 465* 470 473 476*
cleanup                         000152 stack reference condition                dcl 130 ref 235
code                            000101 automatic       fixed bin(35,0)          dcl 105 set ref 182* 190* 191 191* 237* 238 238*
                                                                                  260* 262 262* 265* 267 273 281* 284 287* 291* 306*
                                                                                  309* 312 312* 318* 320 320* 343* 345 345*
collection_id             4            based           bit(36)                  array level 3 dcl 4-18 set ref 306* 309* 318* 352
                                                                                  540* 540
control                   1     000104 automatic       structure                level 2 dcl 108 set ref 228*
define_area_                    000014 constant        entry                    external dcl 148 ref 237 615
descriptor_ptr                         based           pointer                  array level 3 dcl 6-21 set ref 496*
descriptor_string                      based           bit(36)                  dcl 119 set ref 488 490*
descriptor_string_ptr           000136 automatic       pointer                  initial dcl 114 set ref 114* 488* 489 490
dimension_table           6            based           structure                array level 2 dcl 6-21
dm_area                                based           area                     dcl 120 ref 406 415 419 437 528
dm_area_ptr                     000010 internal static pointer                  initial dcl 175 set ref 223 223* 260* 318* 406 415
                                                                                  419 437 528
dm_error_$non_empty_relation    000034 external static fixed bin(35,0)          dcl 163 set ref 293*
dm_error_$record_not_found      000032 external static fixed bin(35,0)          dcl 163 ref 273 626
dm_vector_util_$merge_typed_vector_array
                                000016 constant        entry                    external dcl 151 ref 476
er_code                                parameter       fixed bin(35,0)          dcl 391 ref 388 393
error_table_$area_too_small     000036 external static fixed bin(35,0)          dcl 163 ref 284 624
error_table_$unimplemented_version
                                000040 external static fixed bin(35,0)          dcl 163 set ref 366* 381*
error_table_$unsupported_operation
                                000042 external static fixed bin(35,0)          dcl 163 set ref 185*
extended_arg_type               000216 automatic       fixed bin(17,0)          initial dcl 7-36 set ref 7-36*
fixed_arg_descriptor                   based           structure                level 1 dcl 7-13
flag                                   based           bit(1)                   level 2 packed packed unaligned dcl 7-13 set ref
                                                                                  491*
get_dm_free_area_               000012 constant        entry                    external dcl 146 ref 223
hbound                                                 builtin function         dcl 125 ref 519 522 532 575
head                            000372 automatic       structure                level 2 dcl 601
iam_idx                         000310 automatic       fixed bin(17,0)          dcl 510 set ref 532* 533 533 540 540 543 543 546 546
                                                                                  549 549 552 554 555 555* 567 569* 569* 570*
iam_maximum_number_of_attributes_per_index
                                000203 automatic       fixed bin(17,0)          dcl 4-41 set ref 524* 528 528
iam_maximum_number_of_indices   000202 automatic       fixed bin(17,0)          dcl 4-39 set ref 519* 522* 528 528
id                        2            based           fixed bin(17,0)          array level 2 dcl 5-16 set ref 335 443* 447* 447
                                                                                  449*
id_list                                based           structure                level 1 dcl 5-16 set ref 406 437
id_list_ptr                     000206 automatic       pointer                  initial dcl 5-21 set ref 5-21*
il_number_of_ids                000210 automatic       fixed bin(17,0)          initial dcl 5-22 set ref 5-22* 436* 437 437
index                     4            based           structure                array level 2 dcl 4-18 set ref 519 522 532 533* 533
                                                                                  570* 575
index_all_attributes            000102 automatic       bit(1)                   initial dcl 106 set ref 106* 212* 333 473
index_attribute_map                    based           structure                level 1 dcl 4-18 set ref 415 419 528
index_attribute_map_ptr         000200 automatic       pointer                  initial dcl 4-37 in procedure "rlm_create_index" set
                                                                                  ref 202* 203 249 249 249 306 309 318 330 330 331
                                                                                  333 335 343* 352 4-37* 415 419 419 419 513 528*
                                                                                  529 530 533 540 543 546 549 552 554 555 569 570
                                                                                  575 575
index_attribute_map_ptr
                         20            based           pointer                  initial level 2 in structure "relation_opening_info"
                                                                                  dcl 1-15 in procedure "rlm_create_index" ref 202
                                                                                  415 419
index_cursor_ptr                000140 automatic       pointer                  initial dcl 114 set ref 114* 318* 322* 412 412*
index_idx                       000103 automatic       fixed bin(17,0)          dcl 107 set ref 247* 249* 306 309 318 331 333 335
                                                                                  352
index_is_unique           0(02)        based           bit(1)                   level 2 packed packed unaligned dcl 12-16 ref 306
index_manager_$create_cursor    000046 constant        entry                    external dcl 13-38 ref 318
index_manager_$create_index     000050 constant        entry                    external dcl 13-39 ref 306 309
index_manager_$destroy_cursor   000052 constant        entry                    external dcl 13-42 ref 412
index_manager_$put_key_array    000054 constant        entry                    external dcl 13-49 ref 630
input_id_list_ptr               000142 automatic       pointer                  initial dcl 114 set ref 114* 184* 209 217 218 258*
                                                                                  335 476*
local_area_info                 000104 automatic       structure                level 1 dcl 108 set ref 237 237 615 615
max                                                    builtin function         dcl 125 ref 524
maximum_dimension_name_length
                          4            based           fixed bin(17,0)          level 2 dcl 6-21 ref 495 495 495 496 496 496
maximum_number_of_attributes_per_index
                          3            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 4-18 set ref 249
                                                                                  306 306 309 309 318 318 331 331 333 333 335 335
                                                                                  352 352 415 419 524 528* 533 533 533 533 533 540
                                                                                  540 540 540 543 543 543 543 546 546 546 546 549
                                                                                  549 549 549 552 552 552 554 554 555 555 555 555
                                                                                  570 570 570 575 575
maximum_number_of_indices
                          2(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 4-18 set ref 249
                                                                                  415 419 519 522 528* 532 569 575
myname                          000160 automatic       varying char(32)         initial dcl 134 set ref 134* 227 345* 366* 381*
name                      6            based           varying char             array level 3 dcl 6-21 set ref 495*
null                                                   builtin function         dcl 125 ref 112 114 114 114 114 114 114 183 209 223
                                                                                  230 265 265 345 345 2-29 3-29 4-37 5-21 12-24 366
                                                                                  366 381 381 403 406 409 412 415 419 440 614 618
number_of_attributes      6            based           fixed bin(17,0)          array level 3 in structure "index_attribute_map"
                                                                                  packed packed unaligned dcl 4-18 in procedure
                                                                                  "rlm_create_index" set ref 331* 549* 549 554 575
number_of_attributes      2            based           fixed bin(17,0)          level 2 in structure "attribute_info" packed packed
                                                                                  unaligned dcl 3-18 in procedure "rlm_create_index"
                                                                                  ref 213
number_of_dimensions      1            based           fixed bin(17,0)          level 2 dcl 6-21 ref 473
number_of_duplication_fields
                          5(18)        based           fixed bin(17,0)          array level 3 packed packed unaligned dcl 4-18 set
                                                                                  ref 546* 546
number_of_ids             1            based           fixed bin(17,0)          level 2 dcl 5-16 set ref 218 406 437*
number_of_indices         2            based           fixed bin(17,0)          initial level 2 packed packed unaligned dcl 4-18 set
                                                                                  ref 249 330* 330 528* 530* 530
number_of_key_fields            000130 automatic       fixed bin(17,0)          dcl 109 set ref 213* 218* 249 258* 306 309* 331 332
                                                                                  473* 476* 495 496 524
numeric_specification                  based           structure                level 1 unaligned dcl 10-63
old_index_attribute_map_ptr     000144 automatic       pointer                  initial dcl 114 set ref 114* 415 415 415 415 513*
                                                                                  519 522 524 530 532 533 540 543 546 549 555
owner                     2     000104 automatic       char(32)                 level 2 packed packed unaligned dcl 108 set ref 227*
p_code                                 parameter       fixed bin(35,0)          dcl 100 set ref 89 182* 393*
p_expected_version                     parameter       char(8)                  dcl 363 in procedure "CHECK_VERSION" set ref 359 366
                                                                                  366*
p_expected_version                     parameter       fixed bin(35,0)          dcl 378 in procedure "CHECK_VERSION_FB" set ref 374
                                                                                  381 381*
p_extend_index_array                   parameter       bit(1)                   dcl 506 ref 503 515 519 563
p_flags                                parameter       bit(36)                  dcl 97 set ref 89 293 306
p_id_list_ptr                          parameter       pointer                  dcl 96 ref 89 184
p_increase_maximum_number_of_attributes
                                       parameter       bit(1)                   dcl 507 ref 503 515 533
p_index_collection_id                  parameter       bit(36)                  dcl 99 set ref 89 352*
p_index_idx                            parameter       fixed bin(17,0)          dcl 509 set ref 503 567* 575 575* 575*
p_received_version                     parameter       fixed bin(35,0)          dcl 377 in procedure "CHECK_VERSION_FB" set ref 374
                                                                                  381 381*
p_received_version                     parameter       char(8)                  dcl 362 in procedure "CHECK_VERSION" set ref 359 366
                                                                                  366*
p_rel_opening_id                       parameter       bit(36)                  dcl 95 set ref 89 190* 260* 306* 309* 318* 465*
p_structure_name                       parameter       char                     packed unaligned dcl 379 in procedure
                                                                                  "CHECK_VERSION_FB" set ref 374 381*
p_structure_name                       parameter       char                     packed unaligned dcl 364 in procedure
                                                                                  "CHECK_VERSION" set ref 359 366*
p_style                                parameter       fixed bin(17,0)          dcl 98 ref 89 185
position_number           5     000372 automatic       fixed bin(17,0)          level 2 packed packed unaligned dcl 601 set ref 608*
precision                 0(24)        based           fixed bin(12,0)          level 2 packed packed unsigned unaligned dcl 7-13
                                                                                  set ref 493*
prok_code                       000370 automatic       fixed bin(35,0)          initial dcl 600 set ref 600* 615* 620* 622 624 626
                                                                                  628* 630* 631 631*
prok_numeric_specification      000372 automatic       structure                level 1 dcl 601 set ref 620 620
prok_p_index_cursor_ptr                parameter       pointer                  dcl 593 set ref 585 630*
prok_p_record_cursor_ptr               parameter       pointer                  dcl 588 set ref 585 620*
prok_p_record_id_list_ptr              parameter       pointer                  dcl 590 set ref 585 620*
prok_p_typed_vector_array_ptr          parameter       pointer                  dcl 595 set ref 585 618* 620* 630*
prok_p_vector_area_ptr                 parameter       pointer                  dcl 592 set ref 585 613* 616* 620*
prok_there_are_more_records     000400 automatic       bit(1)                   initial dcl 603 set ref 603* 611 622* 624*
range_size                4     000372 automatic       fixed bin(35,0)          level 2 dcl 601 set ref 609*
record_collection_id      3            based           bit(36)                  initial level 2 dcl 2-15 set ref 260* 465*
record_cursor_ptr               000146 automatic       pointer                  initial dcl 114 set ref 114* 260* 265* 322* 409 409*
record_manager_$create_cursor   000056 constant        entry                    external dcl 14-29 ref 260
record_manager_$destroy_cursor  000060 constant        entry                    external dcl 14-33 ref 409
record_manager_$get_field_info  000020 constant        entry                    external dcl 153 ref 465
record_manager_$get_records_by_spec
                                000062 constant        entry                    external dcl 14-40 ref 265 620
relation_header                        based           structure                level 1 dcl 2-15
relation_header_ptr             000174 automatic       pointer                  initial dcl 2-29 in procedure "rlm_create_index" set
                                                                                  ref 196* 197 260 2-29* 465
relation_header_ptr      14            based           pointer                  initial level 2 in structure "relation_opening_info"
                                                                                  dcl 1-15 in procedure "rlm_create_index" ref 196
relation_index_flags                   based           structure                level 1 dcl 12-16
relation_index_flags_ptr        000220 automatic       pointer                  initial dcl 12-24 set ref 12-24*
relation_is_nonempty            000131 automatic       bit(1)                   initial dcl 110 set ref 110* 270* 277* 289* 293
relation_must_be_empty                 based           bit(1)                   level 2 packed packed unaligned dcl 12-16 ref 293
relation_opening_info                  based           structure                level 1 dcl 1-15
relation_opening_info_ptr       000172 automatic       pointer                  dcl 1-41 set ref 190* 194 196 199 202 343* 415 419
release_area_                   000022 constant        entry                    external dcl 155 ref 403 613
retrieval_id_list_ptr           000150 automatic       pointer                  initial dcl 114 set ref 114* 258* 265* 322* 406 406
rlm_opening_info$get            000024 constant        entry                    external dcl 156 ref 190
rlm_update_opening_info$index_attribute_map
                                000026 constant        entry                    external dcl 157 ref 343
size                     13     000104 automatic       fixed bin(18,0)          level 2 dcl 108 set ref 233*
specification_head                     based           structure                level 1 unaligned dcl 11-10
string                                                 builtin function         dcl 125 set ref 228*
style                     5            based           fixed bin(17,0)          array level 3 packed packed unaligned dcl 4-18 set
                                                                                  ref 543* 543
sub_err_                        000030 constant        entry                    external dcl 159 ref 345 366 381
sys_info$max_seg_size           000044 external static fixed bin(35,0)          dcl 171 ref 233
there_are_more_records          000132 automatic       bit(1)                   initial dcl 111 set ref 111* 271* 276* 288* 315
type                      0(01)        based           fixed bin(6,0)           level 2 in structure "fixed_arg_descriptor" packed
                                                                                  packed unsigned unaligned dcl 7-13 in procedure
                                                                                  "rlm_create_index" set ref 492*
type                      1     000372 automatic       fixed bin(17,0)          level 3 in structure "prok_numeric_specification"
                                                                                  packed packed unaligned dcl 601 in procedure
                                                                                  "PUT_REST_OF_KEYS" set ref 607*
typed_vector_array                     based           structure                level 1 dcl 6-21
typed_vector_array_ptr          000212 automatic       pointer                  dcl 6-43 set ref 183* 265* 282* 306* 309* 322*
unspec                                                 builtin function         dcl 125 set ref 490* 570*
vector_area                            based           area                     dcl 121 ref 488
vector_area_ptr                 000134 automatic       pointer                  initial dcl 112 set ref 112* 241* 265* 322* 465*
                                                                                  476* 488
version                                based           char(8)                  level 2 in structure "relation_opening_info"
                                                                                  dcl 1-15 in procedure "rlm_create_index" set ref
                                                                                  194*
version                                based           fixed bin(35,0)          level 2 in structure "typed_vector_array" dcl 6-21
                                                                                  in procedure "rlm_create_index" ref 470 481
version                                based           char(8)                  level 2 in structure "relation_header" dcl 2-15
                                                                                  in procedure "rlm_create_index" set ref 197*
version                                based           char(8)                  level 2 in structure "attribute_info" dcl 3-18
                                                                                  in procedure "rlm_create_index" set ref 200*
version                         000104 automatic       fixed bin(17,0)          level 2 in structure "local_area_info" dcl 108
                                                                                  in procedure "rlm_create_index" set ref 226*
version                                based           fixed bin(35,0)          level 2 in structure "id_list" dcl 5-16 in procedure
                                                                                  "rlm_create_index" set ref 217 438*
version                                based           char(8)                  level 2 in structure "index_attribute_map" dcl 4-18
                                                                                  in procedure "rlm_create_index" set ref 203* 529*
version                         000372 automatic       fixed bin(35,0)          level 3 in structure "prok_numeric_specification"
                                                                                  dcl 601 in procedure "PUT_REST_OF_KEYS" set ref
                                                                                  606*
zero_on_alloc             1(01) 000104 automatic       bit(1)                   level 3 packed packed unaligned dcl 108 set ref 229*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABSOLUTE_NUMERIC_SPECIFICATION_TYPE    internal static fixed bin(17,0)          initial dcl 11-22
ABSOLUTE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 11-22
ABSOLUTE_RELATION_SEARCH_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 11-22
ABSOLUTE_SEARCH_SPECIFICATION_TYPE     internal static fixed bin(17,0)          initial dcl 11-22
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 16-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 16-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 16-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 16-7
BITS_PER_WORD                          internal static fixed bin(17,0)          initial dcl 135
HEADER_COLLECTION_ID                   internal static bit(36)                  initial dcl 9-19
NUMERIC_SPECIFICATION_TYPE             internal static fixed bin(17,0)          initial dcl 11-22
RELATIVE_RELATION_NUMERIC_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 11-22
RELATIVE_RELATION_SEARCH_SPECIFICATION_TYPE
                                       internal static fixed bin(17,0)          initial dcl 11-22
RELATIVE_SEARCH_SPECIFICATION_TYPE     internal static fixed bin(17,0)          initial dcl 11-22
SEARCH_SPECIFICATION_TYPE              internal static fixed bin(17,0)          initial dcl 11-22
ai_maximum_attribute_name_length       automatic       fixed bin(17,0)          dcl 3-30
ai_number_of_attributes                automatic       fixed bin(17,0)          dcl 3-32
algol68_array_descriptor_dtype         internal static fixed bin(17,0)          initial dcl 8-25
algol68_bits_dtype                     internal static fixed bin(17,0)          initial dcl 8-110
algol68_bool_dtype                     internal static fixed bin(17,0)          initial dcl 8-110
algol68_byte_dtype                     internal static fixed bin(17,0)          initial dcl 8-110
algol68_char_dtype                     internal static fixed bin(17,0)          initial dcl 8-110
algol68_compl_dtype                    internal static fixed bin(17,0)          initial dcl 8-110
algol68_format_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
algol68_int_dtype                      internal static fixed bin(17,0)          initial dcl 8-110
algol68_long_compl_dtype               internal static fixed bin(17,0)          initial dcl 8-110
algol68_long_int_dtype                 internal static fixed bin(17,0)          initial dcl 8-110
algol68_long_real_dtype                internal static fixed bin(17,0)          initial dcl 8-110
algol68_real_dtype                     internal static fixed bin(17,0)          initial dcl 8-110
algol68_short_int_dtype                internal static fixed bin(17,0)          initial dcl 8-110
algol68_straight_dtype                 internal static fixed bin(17,0)          initial dcl 8-25
algol68_struct_struct_bool_dtype       internal static fixed bin(17,0)          initial dcl 8-110
algol68_struct_struct_char_dtype       internal static fixed bin(17,0)          initial dcl 8-110
algol68_union_dtype                    internal static fixed bin(17,0)          initial dcl 8-25
area_dtype                             internal static fixed bin(17,0)          initial dcl 8-25
area_infop                             automatic       pointer                  dcl 15-5
arg_descriptor                         based           structure                level 1 dcl 7-6
c_enum_const_dtype                     internal static fixed bin(17,0)          initial dcl 8-25
c_enum_dtype                           internal static fixed bin(17,0)          initial dcl 8-25
c_typeref_dtype                        internal static fixed bin(17,0)          initial dcl 8-25
c_union_dtype                          internal static fixed bin(17,0)          initial dcl 8-25
char_dtype                             internal static fixed bin(17,0)          initial dcl 8-25
cobol_char_string_dtype                internal static fixed bin(17,0)          initial dcl 8-25
cobol_comp_5_ts_dtype                  internal static fixed bin(17,0)          initial dcl 8-25
cobol_comp_5_uns_dtype                 internal static fixed bin(17,0)          initial dcl 8-25
cobol_comp_6_dtype                     internal static fixed bin(17,0)          initial dcl 8-25
cobol_comp_7_dtype                     internal static fixed bin(17,0)          initial dcl 8-25
cobol_comp_8_ls_dtype                  internal static fixed bin(17,0)          initial dcl 8-25
cobol_comp_8_uns_dtype                 internal static fixed bin(17,0)          initial dcl 8-25
cobol_display_ls_dtype                 internal static fixed bin(17,0)          initial dcl 8-25
cobol_display_ls_overp_dtype           internal static fixed bin(17,0)          initial dcl 8-25
cobol_display_ts_dtype                 internal static fixed bin(17,0)          initial dcl 8-25
cobol_display_ts_overp_dtype           internal static fixed bin(17,0)          initial dcl 8-25
cobol_display_uns_dtype                internal static fixed bin(17,0)          initial dcl 8-25
cobol_structure_dtype                  internal static fixed bin(17,0)          initial dcl 8-25
cplx_fix_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
cplx_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
cplx_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 8-25
cplx_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
cplx_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
dm_vector_util_$free_typed_vector_array
                                000000 constant        entry                    external dcl 149
entry_dtype                            internal static fixed bin(17,0)          initial dcl 8-25
ext_entry_runtime_dtype                internal static fixed bin(17,0)          initial dcl 8-125
ext_procedure_runtime_dtype            internal static fixed bin(17,0)          initial dcl 8-125
extended_arg_descriptor                based           structure                level 1 dcl 7-21
file_dtype                             internal static fixed bin(17,0)          initial dcl 8-25
ft_char_dtype                          internal static fixed bin(17,0)          initial dcl 8-96
ft_complex_double_dtype                internal static fixed bin(17,0)          initial dcl 8-96
ft_complex_dtype                       internal static fixed bin(17,0)          initial dcl 8-96
ft_double_dtype                        internal static fixed bin(17,0)          initial dcl 8-96
ft_external_dtype                      internal static fixed bin(17,0)          initial dcl 8-96
ft_hex_complex_double_dtype            internal static fixed bin(17,0)          initial dcl 8-96
ft_hex_complex_dtype                   internal static fixed bin(17,0)          initial dcl 8-96
ft_hex_double_dtype                    internal static fixed bin(17,0)          initial dcl 8-96
ft_hex_real_dtype                      internal static fixed bin(17,0)          initial dcl 8-96
ft_integer_dtype                       internal static fixed bin(17,0)          initial dcl 8-96
ft_logical_dtype                       internal static fixed bin(17,0)          initial dcl 8-96
ft_real_dtype                          internal static fixed bin(17,0)          initial dcl 8-96
index_manager_$create_subset_index
                                000000 constant        entry                    external dcl 13-40
index_manager_$delete_key       000000 constant        entry                    external dcl 13-41
index_manager_$destroy_index    000000 constant        entry                    external dcl 13-43
index_manager_$get_key          000000 constant        entry                    external dcl 13-44
index_manager_$get_key_count_array
                                000000 constant        entry                    external dcl 13-45
index_manager_$get_key_count_by_spec
                                000000 constant        entry                    external dcl 13-46
index_manager_$position_cursor  000000 constant        entry                    external dcl 13-47
index_manager_$put_key          000000 constant        entry                    external dcl 13-48
int_entry_runtime_dtype                internal static fixed bin(17,0)          initial dcl 8-125
ioa_$rsnnl                      000000 constant        entry                    external dcl 147
label_constant_runtime_dtype           internal static fixed bin(17,0)          initial dcl 8-125
label_dtype                            internal static fixed bin(17,0)          initial dcl 8-25
numeric_specification_ptr              automatic       pointer                  dcl 10-70
offset_dtype                           internal static fixed bin(17,0)          initial dcl 8-25
pascal_boolean_dtype                   internal static fixed bin(17,0)          initial dcl 8-132
pascal_char_dtype                      internal static fixed bin(17,0)          initial dcl 8-132
pascal_entry_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 8-132
pascal_enumerated_type_dtype           internal static fixed bin(17,0)          initial dcl 8-132
pascal_enumerated_type_element_dtype   internal static fixed bin(17,0)          initial dcl 8-132
pascal_enumerated_type_instance_dtype  internal static fixed bin(17,0)          initial dcl 8-132
pascal_exportable_procedure_dtype      internal static fixed bin(17,0)          initial dcl 8-132
pascal_imported_procedure_dtype        internal static fixed bin(17,0)          initial dcl 8-132
pascal_integer_dtype                   internal static fixed bin(17,0)          initial dcl 8-132
pascal_internal_procedure_dtype        internal static fixed bin(17,0)          initial dcl 8-132
pascal_label_dtype                     internal static fixed bin(17,0)          initial dcl 8-132
pascal_parameter_procedure_dtype       internal static fixed bin(17,0)          initial dcl 8-132
pascal_procedure_type_dtype            internal static fixed bin(17,0)          initial dcl 8-132
pascal_real_dtype                      internal static fixed bin(17,0)          initial dcl 8-132
pascal_record_file_type_dtype          internal static fixed bin(17,0)          initial dcl 8-132
pascal_record_type_dtype               internal static fixed bin(17,0)          initial dcl 8-132
pascal_set_dtype                       internal static fixed bin(17,0)          initial dcl 8-132
pascal_string_type_dtype               internal static fixed bin(17,0)          initial dcl 8-132
pascal_text_file_dtype                 internal static fixed bin(17,0)          initial dcl 8-132
pascal_typed_pointer_type_dtype        internal static fixed bin(17,0)          initial dcl 8-132
pascal_user_defined_type_dtype         internal static fixed bin(17,0)          initial dcl 8-132
pascal_user_defined_type_instance_dtype
                                       internal static fixed bin(17,0)          initial dcl 8-132
pascal_value_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 8-132
pascal_variable_formal_parameter_dtype internal static fixed bin(17,0)          initial dcl 8-132
picture_runtime_dtype                  internal static fixed bin(17,0)          initial dcl 8-125
pointer_dtype                          internal static fixed bin(17,0)          initial dcl 8-25
prok_p_vector_area                     based           area(1024)               dcl 598
real_fix_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
real_fix_bin_1_uns_dtype               internal static fixed bin(17,0)          initial dcl 8-25
real_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
real_fix_bin_2_uns_dtype               internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_4bit_bytealigned_uns_dtype
                                       internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_4bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_4bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_4bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_9bit_ls_overp_dtype       internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_9bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_9bit_ts_overp_dtype       internal static fixed bin(17,0)          initial dcl 8-25
real_fix_dec_9bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 8-25
real_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
real_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
real_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 8-25
real_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 8-25
real_flt_dec_4bit_dtype                internal static fixed bin(17,0)          initial dcl 8-25
real_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 8-25
real_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 8-25
real_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 8-25
real_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
real_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 8-25
record_manager_$create_collection
                                000000 constant        entry                    external dcl 14-27
record_manager_$delete_record_by_id
                                000000 constant        entry                    external dcl 14-63
record_manager_$delete_records_by_id_list
                                000000 constant        entry                    external dcl 14-66
record_manager_$delete_records_by_spec
                                000000 constant        entry                    external dcl 14-69
record_manager_$destroy_collection
                                000000 constant        entry                    external dcl 14-31
record_manager_$get_record_by_id
                                000000 constant        entry                    external dcl 14-36
record_manager_$get_record_count
                                000000 constant        entry                    external dcl 14-52
record_manager_$get_record_count_by_interval
                                000000 constant        entry                    external dcl 14-54
record_manager_$get_record_ids_by_interval
                                000000 constant        entry                    external dcl 14-50
record_manager_$get_record_ids_by_spec
                                000000 constant        entry                    external dcl 14-48
record_manager_$get_records_and_ids_by_interval
                                000000 constant        entry                    external dcl 14-46
record_manager_$get_records_and_ids_by_spec
                                000000 constant        entry                    external dcl 14-44
record_manager_$get_records_by_id_list
                                000000 constant        entry                    external dcl 14-38
record_manager_$get_records_by_interval
                                000000 constant        entry                    external dcl 14-42
record_manager_$modify_record_by_id
                                000000 constant        entry                    external dcl 14-72
record_manager_$modify_records_by_id_list
                                000000 constant        entry                    external dcl 14-75
record_manager_$modify_records_by_spec
                                000000 constant        entry                    external dcl 14-78
record_manager_$put_record_by_id
                                000000 constant        entry                    external dcl 14-57
record_manager_$put_records_by_id
                                000000 constant        entry                    external dcl 14-60
search_specification                   based           structure                level 1 unaligned dcl 10-38
search_specification_ptr               automatic       pointer                  dcl 10-58
specification_head_ptr                 automatic       pointer                  dcl 11-18
ss_maximum_number_of_constraints       automatic       fixed bin(17,0)          dcl 10-60
ss_number_of_and_groups                automatic       fixed bin(17,0)          dcl 10-60
structure_dtype                        internal static fixed bin(17,0)          initial dcl 8-25
tva_maximum_dimension_name_length      automatic       fixed bin(17,0)          dcl 6-48
tva_number_of_dimensions               automatic       fixed bin(17,0)          dcl 6-46
tva_number_of_vector_slots             automatic       fixed bin(17,0)          dcl 6-44
varying_bit_dtype                      internal static fixed bin(17,0)          initial dcl 8-25
varying_char_dtype                     internal static fixed bin(17,0)          initial dcl 8-25

NAMES DECLARED BY EXPLICIT CONTEXT.
ALLOCATE_NEW_IAM                002226 constant        label                    dcl 515
BUILD_ID_LIST_WITH_TUPLE_ID     001711 constant        entry                    internal dcl 426 ref 258
BUILD_TVA                       002006 constant        entry                    internal dcl 455 ref 282
CHECK_VERSION                   001315 constant        entry                    internal dcl 359 ref 194 197 200 203
CHECK_VERSION_FB                001417 constant        entry                    internal dcl 374 ref 217 470 481
ERROR_RETURN                    001513 constant        entry                    internal dcl 388 ref 185 191 238 262 291 293 312 320
                                                                                  467 478 628 631
FINISH                          001526 constant        entry                    internal dcl 400 ref 235 354 394
GET_OR_CREATE_INDEX_ATTRIBUTE_MAP_ENTRY
                                002213 constant        entry                    internal dcl 503 ref 249
MAIN_RETURN                     001314 constant        label                    dcl 356 ref 395
PUT_REST_OF_KEYS                002714 constant        entry                    internal dcl 585 ref 322
rlm_create_index                000177 constant        entry                    external dcl 89

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3530        3614    3203        3540
Length      4364    3203        64         533     325           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rlm_create_index                    522 external procedure  is an external procedure.  
on unit on line 235                  64 on unit               
CHECK_VERSION                           internal procedure  shares stack frame of external procedure rlm_create_index.  
CHECK_VERSION_FB                        internal procedure  shares stack frame of external procedure rlm_create_index.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure rlm_create_index.  
FINISH                               76 internal procedure  is called by several nonquick procedures.  
BUILD_ID_LIST_WITH_TUPLE_ID             internal procedure  shares stack frame of external procedure rlm_create_index.  
BUILD_TVA                               internal procedure  shares stack frame of external procedure rlm_create_index.  
GET_OR_CREATE_INDEX_ATTRIBUTE_MAP_ENTRY
                                        internal procedure  shares stack frame of external procedure rlm_create_index.  
PUT_REST_OF_KEYS                        internal procedure  shares stack frame of external procedure rlm_create_index.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 dm_area_ptr                 rlm_create_index

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rlm_create_index         000100 attribute_idx               rlm_create_index
                         000101 code                        rlm_create_index
                         000102 index_all_attributes        rlm_create_index
                         000103 index_idx                   rlm_create_index
                         000104 local_area_info             rlm_create_index
                         000130 number_of_key_fields        rlm_create_index
                         000131 relation_is_nonempty        rlm_create_index
                         000132 there_are_more_records      rlm_create_index
                         000134 vector_area_ptr             rlm_create_index
                         000136 descriptor_string_ptr       rlm_create_index
                         000140 index_cursor_ptr            rlm_create_index
                         000142 input_id_list_ptr           rlm_create_index
                         000144 old_index_attribute_map_ptr rlm_create_index
                         000146 record_cursor_ptr           rlm_create_index
                         000150 retrieval_id_list_ptr       rlm_create_index
                         000160 myname                      rlm_create_index
                         000172 relation_opening_info_ptr   rlm_create_index
                         000174 relation_header_ptr         rlm_create_index
                         000176 attribute_info_ptr          rlm_create_index
                         000200 index_attribute_map_ptr     rlm_create_index
                         000202 iam_maximum_number_of_indices
                                                            rlm_create_index
                         000203 iam_maximum_number_of_attributes_per_index
                                                            rlm_create_index
                         000204 INITIAL_NUMBER_OF_INDICES   rlm_create_index
                         000205 UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY
                                                            rlm_create_index
                         000206 id_list_ptr                 rlm_create_index
                         000210 il_number_of_ids            rlm_create_index
                         000212 typed_vector_array_ptr      rlm_create_index
                         000214 arg_descriptor_ptr          rlm_create_index
                         000216 extended_arg_type           rlm_create_index
                         000220 relation_index_flags_ptr    rlm_create_index
                         000254 bil_id_idx                  BUILD_ID_LIST_WITH_TUPLE_ID
                         000266 bt_record_typed_vector_array_ptr
                                                            BUILD_TVA
                         000270 bt_dimension_name           BUILD_TVA
                         000301 bt_code                     BUILD_TVA
                         000310 iam_idx                     GET_OR_CREATE_INDEX_ATTRIBUTE_MAP_ENTRY
                         000311 attribute_idx               GET_OR_CREATE_INDEX_ATTRIBUTE_MAP_ENTRY
                         000370 prok_code                   PUT_REST_OF_KEYS
                         000372 prok_numeric_specification  PUT_REST_OF_KEYS
                         000400 prok_there_are_more_records PUT_REST_OF_KEYS

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return_mac          enable_op           ext_entry           int_entry           op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
define_area_                  dm_vector_util_$merge_typed_vector_array                    get_dm_free_area_
index_manager_$create_cursor  index_manager_$create_index   index_manager_$destroy_cursor index_manager_$put_key_array
record_manager_$create_cursor record_manager_$destroy_cursor
record_manager_$get_field_info                              record_manager_$get_records_by_spec
release_area_                 rlm_opening_info$get          rlm_update_opening_info$index_attribute_map
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$non_empty_relation  dm_error_$record_not_found    error_table_$area_too_small
error_table_$unimplemented_version                          error_table_$unsupported_operation
sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     89 000171       106 000204       110 000205       111 000206       112 000207       114 000211       134 000217
 2   29 000224    3   29 000226    4   37 000227    4   45 000230    4   47 000232    5   21 000233    5   22 000235
 7   36 000237   12   24 000241       182 000243       183 000246       184 000247       185 000252       190 000263
    191 000277       194 000303       196 000330       197 000333       199 000356       200 000361       202 000404
    203 000407       209 000431       212 000435       213 000437       214 000444       217 000445       218 000456
    223 000462       226 000475       227 000477       228 000503       229 000504       230 000506       233 000510
    235 000513       237 000535       238 000550       241 000554       247 000556       249 000560       258 000604
    260 000606       262 000627       265 000633       267 000656       270 000660       271 000662       272 000663
    273 000664       276 000667       277 000670       281 000671       282 000672       283 000674       284 000675
    287 000677       288 000700       289 000702       290 000703       291 000704       293 000706       306 000724
    309 000766       312 001020       315 001024       318 001026       320 001061       322 001065       330 001067
    331 001075       332 001115       333 001125       335 001157       337 001210       343 001212       345 001225
    352 001272       354 001310       356 001314       359 001315       366 001326       371 001416       374 001417
    381 001430       386 001512       388 001513       393 001515       394 001520       395 001524       400 001525
    403 001533       406 001546       409 001560       412 001577       415 001616       419 001656       424 001710
    426 001711       436 001713       437 001715       438 001727       440 001731       443 001745       444 001751
    445 001754       447 001765       448 001775       449 001777       451 002005       455 002006       462 002010
    465 002011       467 002032       470 002036       473 002053       476 002061       478 002103       481 002107
    488 002126       489 002133       490 002134       491 002135       492 002137       493 002143       495 002146
    496 002201       499 002212       503 002213       513 002215       515 002217       519 002226       522 002237
    524 002244       528 002255       529 002302       530 002305       532 002310       533 002321       540 002364
    543 002413       546 002416       549 002444       552 002466       554 002522       555 002541       559 002602
    561 002604       563 002606       567 002612       569 002613       570 002625       571 002651       575 002653
    579 002711       581 002713       585 002714       600 002716       603 002717       606 002721       607 002723
    608 002725       609 002727       611 002731       613 002734       614 002744       615 002746       616 002761
    618 002764       620 002766       622 003011       624 003015       626 003023       628 003026       630 003030
    631 003044       633 003050       634 003051


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
