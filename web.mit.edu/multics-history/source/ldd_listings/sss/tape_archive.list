	COMPILATION LISTING OF SEGMENT tape_archive
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 02/16/84  1257.3 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 tape_archive: ta: proc;
       19 
       20 /* This procedure is the main command interface for the tape_archive command.
       21*   The tape_archive command gives a user the facility of keeping a set of
       22*   files on magnetic tape for archival or file transfer purposes, and provides
       23*   an easy interface for extracting, rewriting, deleting, and keeping track
       24*   of these files.
       25*
       26*   Written 05/10/77 by C. D. Tavares.
       27*   Modified 09/24/79 by CDT for "." and ".." in direct mode.
       28*   Modified 09/03/80 by CDT for version 3; also to improve output of "."
       29*   request.
       30*   Modified 09/16/80 by CDT to fix error message when no access to table.
       31*   Last modified 83-03-16 by S. G. Harris (UNCA) for version 4.
       32*   Modified 7/83 by S. Krupp for conversion to mtape_
       33**/
       34 
       35 /* INCLUDE FILES */
       36 
  1     1 /* ---------- BEGIN include file tape_archive_table_dcl.incl.pl1 ---------- */
  1     2 
  1     3 /* Version 2 lengthened volume names from 6 to 32 characters */
  1     4 /* Version 3 introduced density field, workspace strategy for updates, */
  1     5 /* and the mount lock, which is less of a lock than a retain indicator. */
  1     6 /* Version 4 expanded density field to an array for independent volume set */
  1     7 /* densities and added uid fields for table deletion checking. */
  1     8 /* Modified 09/21/80 by C. D. Tavares for version 3 */
  1     9 /* Modified 12/9/81 by CDT to add highest_mount_type field */
  1    10 /* Last modified 83-03-16 by S. G. Harris (UNCA) for version 4. */
  1    11 /* Modified 09/16/83 by S. Krupp to add the TAPE_ARCHIVE_IO_MODULE
  1    12*   declaration for conversion to the mtape_ I/O module. */
  1    13 
  1    14 dcl 1 tape_archive_table aligned based (table_ptr),	/* online segment for tape_archive command */
  1    15     2 nonvolatile_part aligned,			/* temp table moving doesn't touch these */
  1    16       3 version_number fixed bin,			/* of table */
  1    17       3 magic_constant char (8),			/* "ta table" */
  1    18       3 compaction_warning_threshold float bin,		/* when to suggest compaction to user */
  1    19       3 auto_compaction_threshold float bin,		/* when to compact when user doesn't take hint */
  1    20       3 table_is_consistent bit (1) unaligned,		/* update in progress indicator */
  1    21       3 lock bit (36),				/* allows shared tape archives */
  1    22       3 lock_reason fixed bin,			/* reason seg already locked, for failure msg */
  1    23       3 locker_id char (32),				/* userid of locking process, for failure msg */
  1    24       3 io_module_name char (32),			/* tape_ansi_ or tape_ibm_ */
  1    25       3 recovery_info_offset bit (18) aligned,		/* holds address of workspace for table updates */
  1    26       3 perm_table_uid bit (36),			/* used to prevent table deletion */
  1    27       3 future_expansion (6) bit (36),			/* ... */
  1    28     2 volatile_part aligned,				/* these can get altered due to temp table moves */
  1    29       3 n_components fixed bin,			/* number valid (undeleted) components in archive */
  1    30       3 n_component_slots fixed bin,			/* number of used component slots in table */
  1    31       3 n_queued_requests fixed bin,			/* number requests to be performed next mount */
  1    32       3 n_request_slots fixed bin,			/* number of used request slots in table */
  1    33       3 next_mount_type fixed bin,			/* read only, write, or compact */
  1    34       3 date_time_tape_modified bit (36),		/* last time tape written on */
  1    35       3 date_time_last_compacted bit (36),		/* last time tape compacted */
  1    36       3 total_records fixed bin (35),			/* data out on tape, in Multics records */
  1    37       3 dead_records fixed bin (35),			/* records wasted (deletions, replacements) */
  1    38       3 incomplete_write_op_last bit (1),		/* ON if determined that user or sys crashed while writing tape */
  1    39       3 last_tape_file_no fixed bin,			/* number of last file existing on volume set */
  1    40       3 last_table_no fixed bin,			/* number of copies of online table on this volume set */
  1    41       3 mount_lock bit (36) aligned,			/* set to lock_id while volume set mounted */
  1    42       3 highest_mount_type fixed bin,			/* max of next_mount_type since retained */
  1    43       3 future_expansion (6) bit (36),			/* ... */
  1    44       3 tape_info aligned,
  1    45         4 density (2) fixed bin (17) unal,		/* post version 3 volume set densities */
  1    46         4 active_set fixed bin,			/* which of the two is most current */
  1    47         4 n_volumes_in_set (2) fixed bin,		/* how many reels comprise volume set */
  1    48         4 volume_set (2) aligned,
  1    49 	5 volume_id (8) char (168),			/* physical reel and slot info */
  1    50       3 component_table (0 refer (tape_archive_table.n_component_slots)) aligned like component,
  1    51       3 request_queue (0 refer (tape_archive_table.n_request_slots)) aligned like request;
  1    52 
  1    53 dcl 1 component aligned based (component_ptr),		/* format of one component entry */
  1    54     2 entry_status_descriptor like entry_status_descriptor aligned,
  1    55     2 previous_instance_backchain fixed bin,		/* index of file it replaced, if any */
  1    56     2 associated_request_index fixed bin,		/* if extract pending, index of request with dirpath */
  1    57     2 date_time_deleted bit (36) aligned,		/* if logically deleted, when. */
  1    58     2 future_expansion (5) bit (36) aligned;		/* ... */
  1    59 
  1    60 dcl 1 request aligned based (request_ptr),		/* format of a queued request */
  1    61     2 entry_status_descriptor like entry_status_descriptor aligned,
  1    62     2 directory_name char (168) unaligned,		/* in Multics file system */
  1    63     2 requested_ops unaligned,
  1    64       3 append bit (1) unaligned,			/* add to tape */
  1    65       3 replace bit (1) unaligned,			/* replace to tape */
  1    66       3 extract bit (1) unaligned,			/* extract from tape */
  1    67       3 delete bit (1) unaligned,			/* delete from tape or file system */
  1    68       3 force bit (1) unaligned,			/* forcibly do any of the above */
  1    69       3 single_name bit (1) unaligned,			/* append/extract with only given name */
  1    70       3 future_expansion bit (30) unaligned,
  1    71     2 existing_reference fixed bin,			/* index of component block, if exists (e.g. read) */
  1    72     2 future_expansion (4) bit (36) aligned;
  1    73 
  1    74 dcl 1 entry_status_descriptor aligned based,
  1    75     2 valid bit (1) unaligned,			/* an undeleted component or request if on */
  1    76     2 no_final_newline bit (1) unaligned,		/* ON if last char in file was not newline */
  1    77     2 safety_switch bit (1) unaligned,			/* reflects safety switch of file while online */
  1    78     2 pad bit (33) unaligned,
  1    79     2 file_info aligned,				/* main tape file for this entry */
  1    80       3 tape_file_name char (17),
  1    81       3 entry_name char (32) unaligned,			/* for Multics file system */
  1    82       3 date_time_archived bit (36),			/* when it was put on tape */
  1    83       3 recording_mode char (8) aligned,		/* "ascii", "binary", "ebcdic", etc. */
  1    84       3 date_time_branch_modified bit (36),		/* last modified while in file system */
  1    85       3 date_time_dumped bit (36),			/* by backup facility */
  1    86       3 bitcount_author char (32),			/* last person who modified it while online */
  1    87       3 file_length fixed bin (35),			/* in Multics pages */
  1    88       3 attribute_file_no fixed bin,			/* file number of attribute file on tape */
  1    89       3 n_tape_records fixed bin (35),			/* number of logical records on tape for this file */
  1    90     2 uid bit (36) aligned,				/* used to prevent table deletion */
  1    91     2 future_expansion bit (36) aligned;
  1    92 
  1    93 dcl 1 workspace based (workspace_ptr) aligned,		/* to prevent update inconsistencies */
  1    94     2 workspace_id char (8),				/* "wrkspace" */
  1    95     2 component_no fixed bin,
  1    96     2 request_no fixed bin,
  1    97     2 n_queued_requests fixed bin,
  1    98     2 dead_records fixed bin,
  1    99     2 total_records fixed bin,
  1   100     2 n_components fixed bin,
  1   101     2 n_request_slots fixed bin,
  1   102     2 next_mount_type fixed bin,
  1   103     2 future_expansion (70) fixed bin (35),
  1   104     2 tape_info_copy aligned like tape_archive_table.tape_info,
  1   105     2 future_expansion2 (16) fixed bin (35),
  1   106     2 component_copy like component aligned,
  1   107     2 future_expansion3 (16) fixed bin (35),
  1   108     2 request_copy like request aligned;
  1   109 
  1   110 dcl 1 based_tape_info based (tape_info_ptr) like tape_archive_table.tape_info aligned;
  1   111 
  1   112 dcl (table_ptr, component_ptr, request_ptr, workspace_ptr, tape_info_ptr) pointer;
  1   113 
  1   114 dcl ((None initial (0),				/* next scheduled processing flags */
  1   115      Delete initial (1),
  1   116      Read initial (2),
  1   117      Write initial (3),
  1   118      Compact initial (4),
  1   119 
  1   120      Examine initial (1),				/* current lock reason flags */
  1   121      Modify initial (2),
  1   122      Process_tape initial (3),
  1   123 
  1   124      Deletion initial (1),				/* pending_operation flags */
  1   125      Extraction initial (2),
  1   126      Replacement initial (3),
  1   127      Cancellation initial (4),
  1   128      Deletion_cancellation initial (5),
  1   129      Volume_alteration initial (6),
  1   130      Table_creation initial (7),
  1   131      Table_copy initial (8),
  1   132 
  1   133      Default_density initial (1600),
  1   134 
  1   135      tape_archive_version_4 initial (4)) fixed bin,
  1   136 
  1   137      TAPE_ARCHIVE_IO_MODULE char(6) init("mtape_"),
  1   138 
  1   139      Lock_reasons (0:3) char (24) initial
  1   140     ("no discernable reason", "table examination", "table modification", "tape processing"),
  1   141 
  1   142      Magic_constant char (8) initial ("ta table"),
  1   143      Magic_workspace_constant char (8) initial ("wrkspace")) static options (constant);
  1   144 
  1   145 /* ---------------- END include file tape_archive_table_dcl.incl.pl1 ---------------- */
       37 
       38 
  2     1 /*	BEGIN INCLUDE FILE query_info.incl.pl1		TAC June 1, 1973 */
  2     2 /*        Renamed to query_info.incl.pl1 and cp_escape_control added, 08/10/78 WOS */
  2     3 /*	version number changed to 4, 08/10/78 WOS */
  2     4 /* Version 5 adds explanation_(ptr len) 05/08/81 S. Herbst */
  2     5 /* Version 6 adds literal_sw, prompt_after_explanation switch 12/15/82 S. Herbst */
  2     6 
  2     7 dcl 1 query_info aligned,				/* argument structure for command_query_ call */
  2     8     2 version fixed bin,				/* version of this structure - must be set, see below */
  2     9     2 switches aligned,                                     /* various bit switch values */
  2    10       3 yes_or_no_sw bit (1) unaligned init ("0"b),		/* not a yes-or-no question, by default */
  2    11       3 suppress_name_sw bit (1) unaligned init ("0"b),	/* do not suppress command name */
  2    12       3 cp_escape_control bit (2) unaligned init ("00"b),   /* obey static default value */
  2    13                                                             /* "01" -> invalid, "10" -> don't allow, "11" -> allow */
  2    14       3 suppress_spacing bit (1) unaligned init ("0"b),     /* whether to print extra spacing */
  2    15       3 literal_sw bit (1) unaligned init ("0"b),		/* ON => do not strip leading/trailing white space */
  2    16       3 prompt_after_explanation bit (1) unaligned init ("0"b),  /* ON => repeat question after explanation */
  2    17       3 padding bit (29) unaligned init (""b),		/* pads it out to t word */
  2    18     2 status_code fixed bin (35) init (0),		/* query not prompted by any error, by default */
  2    19     2 query_code fixed bin (35) init (0),		/* currently has no meaning */
  2    20 
  2    21 /*  Limit of data defined for version 2 */
  2    22 
  2    23     2 question_iocbp ptr init (null ()),		/* IO switch to write question */
  2    24     2 answer_iocbp ptr init (null ()),			/* IO switch to read answer */
  2    25     2 repeat_time fixed bin (71) init (0),		/* repeat question every N seconds if no answer */
  2    26 						/* minimum of 30 seconds required for repeat */
  2    27 						/* otherwise, no repeat will occur */
  2    28 /* Limit of data defined for version 4 */
  2    29 
  2    30     2 explanation_ptr ptr init (null ()),		/* explanation of question to be printed if */
  2    31     2 explanation_len fixed bin (21) init (0);		/* user answers "?" (disabled if ptr=null or len=0) */
  2    32 
  2    33 dcl  query_info_version_3 fixed bin int static options (constant) init (3);
  2    34 dcl  query_info_version_4 fixed bin int static options (constant) init (4);
  2    35 dcl  query_info_version_5 fixed bin int static options (constant) init (5);
  2    36 dcl  query_info_version_6 fixed bin int static options (constant) init (6); /* the current version number */
  2    37 
  2    38 /*	END INCLUDE FILE query_info.incl.pl1 */
       39 
       40 
  3     1 /* BEGIN INCLUDE FILE ... object_info.incl.pl1
  3     2*coded February 8, 1972 by Michael J. Spier	*/
  3     3 /* modified May 26, 1972 by M. Weaver */
  3     4 /* modified 15 April, 1975 by M. Weaver */
  3     5 
  3     6 declare	1 object_info aligned based,		/* structure containing object info based, returned by object_info_ */
  3     7 	2 version_number fixed bin,		/* version number of current structure format (=2) */
  3     8 	2 textp pointer,			/* pointer to beginning of text section */
  3     9 	2 defp pointer,			/* pointer to beginning of definition section */
  3    10 	2 linkp pointer,			/* pointer to beginning of linkage section */
  3    11 	2 statp pointer,			/* pointer to beginning of static section */
  3    12 	2 symbp pointer,			/* pointer to beginning of symbol section */
  3    13 	2 bmapp pointer,			/* pointer to beginning of break map (may be null) */
  3    14 	2 tlng fixed bin,			/* length in words of text section */
  3    15 	2 dlng fixed bin,			/* length in words of definition section */
  3    16 	2 llng fixed bin,			/* length in words of linkage section */
  3    17 	2 ilng fixed bin,			/* length in words of static section */
  3    18 	2 slng fixed bin,			/* length in words of symbol section */
  3    19 	2 blng fixed bin,			/* length in words of break map */
  3    20 	2 format,				/* word containing bit flags about object type */
  3    21 	  3 old_format bit(1) unaligned,	/* on if segment isn't in new format, i.e. has old style object map */
  3    22 	  3 bound bit(1) unaligned,		/* on if segment is bound */
  3    23 	  3 relocatable bit(1) unaligned,	/* on if seg has relocation info in its first symbol block */
  3    24 	  3 procedure bit(1) unaligned,	/* on if segment is an executable object program */
  3    25 	  3 standard bit(1) unaligned,	/* on if seg is in standard format (more than just standard map) */
  3    26 	  3 gate bit(1) unaligned,		/* on if segment is a gate */
  3    27 	  3 separate_static bit(1) unaligned,	/* on if static not in linkage */
  3    28 	  3 links_in_text bit(1) unaligned,	/* on if there are threaded links in text */
  3    29 	  3 perprocess_static bit (1) unaligned, /* on if static is not to be per run unit */
  3    30 	  3 pad bit(27) unaligned,
  3    31 	2 entry_bound fixed bin,		/* entry bound if segment is a gate */
  3    32 	2 textlinkp pointer,		/* ptr to first link in text */
  3    33 
  3    34 	/* LIMIT OF BRIEF STRUCTURE */
  3    35 
  3    36 	2 compiler char(8) aligned,		/* name of processor which generated segment */
  3    37 	2 compile_time fixed bin(71),		/* clock reading of date/time object was generated */
  3    38 	2 userid char(32) aligned,		/* standard Multics id of creator of object segment */
  3    39 	2 cvers aligned,			/* generator version name in printable char string form */
  3    40 	  3 offset bit(18) unaligned,		/* offset of name in words relative to base of symbol section */
  3    41 	  3 length bit(18) unaligned,		/* length of name in characters */
  3    42 	2 comment aligned,			/* printable comment concerning generator or generation of segment */
  3    43 	  3 offset bit(18) unaligned,		/* offset of comment in words relative to base of symbol section */
  3    44 	  3 length bit(18) unaligned,		/* length of comment in characters */
  3    45 	2 source_map fixed bin,		/* offset, relative to base of symbol section, of source map structure */
  3    46 
  3    47 	/* LIMIT OF DISPLAY STRUCTURE */
  3    48 
  3    49 	2 rel_text pointer,			/* pointer to text section relocation info */
  3    50 	2 rel_def pointer,			/* pointer to definition section relocation info */
  3    51 	2 rel_link pointer,			/* pointer to linkage section relocation info */
  3    52 	2 rel_static pointer,		/* pointer to static section relocation info */
  3    53 	2 rel_symbol pointer,		/* pointer to symbol section relocation info */
  3    54 	2 text_boundary fixed bin,		/* specifies mod  of text section base boundary */
  3    55 	2 static_boundary fixed bin,		/* specifies mod of internal static base boundary */
  3    56 					/* currently not used by system */
  3    57 	2 default_truncate fixed bin,		/* offset rel to symbp for binder to automatically trunc. symb sect. */
  3    58 	2 optional_truncate fixed bin;	/* offset rel to symbp for binder to optionally trunc. symb sect. */
  3    59 
  3    60 declare	object_info_version_2 fixed bin int static init(2);
  3    61 
  3    62 /* END INCLUDE FILE ... object_info.incl.pl1 */
       41 
       42 
       43 /* AUTOMATIC */
       44 
       45 dcl  al fixed bin,
       46      alp pointer,
       47      answer char (4) varying,
       48      ap pointer,
       49      arg char (al) based (ap),
       50      code fixed bin (35),
       51      delete bit (1) aligned,
       52      dummy fixed bin,
       53      dummy_args (100) char (168),
       54      dummy_args_based (n_dummy_args) char (168) based (addr (dummy_args)),
       55      me_bc fixed bin (24),
       56      me_ptr pointer,
       57      my_date_time char (24),
       58      n_dummy_args fixed bin,
       59      force bit (1) aligned,
       60      i fixed bin,
       61      input_line char (300),
       62      key char (12),
       63      keynum fixed bin,
       64      library_description char (168),
       65      n_chars_read fixed bin (21),
       66      nargs fixed bin,
       67      p pointer,
       68      perm_table_ptr pointer,
       69      prog_dir char (168),
       70      prog_ent char (32),
       71      requests_outstanding bit (1) aligned,
       72      retain_sw bit (1) aligned,
       73      table_dir char (168),
       74      table_name char (32),
       75      temp_table_ptr (1) pointer,
       76      w_permit bit (1) aligned;
       77 
       78 dcl 1 oi aligned automatic like object_info;
       79 
       80 /* CONSTANTS */
       81 
       82 dcl 1 key_structure aligned static options (constant),
       83     2 key_names (23) char (12) initial
       84     ("a", "ad", "adf",				/* 1, 2, 3 */
       85      "r", "rd", "rdf",				/* 4, 5, 6 */
       86      "u", "ud", "udf",				/* 7, 8, 9 */
       87      "x", "xd", "xdf", "xf",				/* 10, 11, 12, 13 */
       88      "d", "df",					/* 14, 15 */
       89      "cancel",					/* 16 */
       90      "t",						/* 17 */
       91      "compact",					/* 18 */
       92      "alter",					/* 19 */
       93      "go",					/* 20 */
       94      "load_table",					/* 21 */
       95      "reconstruct",					/* 22 */
       96      "direct"),					/* 23 */
       97     2 delete bit (23) initial ("011011011011"b),
       98     2 force bit (23) initial ("001001001001101"b),
       99     2 table_must_exist bit (23) initial ("00000011111111111111000"b),
      100     2 w_permit_needed bit (23) initial ("11111111111111110111001"b);
      101 
      102 dcl  allowed_in_input_mode fixed bin static initial (19) options (constant),
      103      explanation char (168) static initial ("Usage:  ta key table_path filepath1... filepathN.") options (constant);
      104 
      105 dcl 1 search_libraries (2) static options (constant),
      106     2 dir char (168) initial (">sss", ">exl>tape_archive_dir"),
      107     2 description char (64) initial ("Installed", "Experimental");
      108 
      109 /* EXTERNAL STATIC */
      110 
      111 dcl (error_table_$badopt,
      112      error_table_$moderr,
      113      error_table_$noentry,
      114      error_table_$long_record) ext fixed bin (35) static,
      115      iox_$user_input ext pointer static;
      116 
      117 /* ENTRIES */
      118 
      119 dcl  com_err_ ext entry options (variable),
      120      com_err_$suppress_name ext entry options (variable),
      121      command_query_ ext entry options (variable),
      122      cu_$arg_count ext entry (fixed bin),
      123      cu_$arg_list_ptr ext entry (pointer),
      124      cu_$arg_ptr ext entry (fixed bin, pointer, fixed bin, fixed bin (35)),
      125      cu_$arg_ptr_rel ext entry (fixed bin, pointer, fixed bin, fixed bin (35), pointer),
      126      cu_$cp ext entry (pointer, fixed bin, fixed bin (35)),
      127      date_time_ entry (fixed bin (71), char (*)),
      128      expand_pathname_ ext entry (char (*), char (*), char (*), fixed bin (35)),
      129      get_temp_segments_ ext entry (char (*), pointer dimension (*), fixed bin (35)),
      130      hcs_$fs_get_path_name entry (ptr, char (*), fixed bin, char (*), fixed bin (35)),
      131      hcs_$initiate entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35)),
      132      hcs_$status_mins entry (ptr, fixed bin (2), fixed bin (24), fixed bin (35)),
      133      hcs_$terminate_noname ext entry (pointer, fixed bin (35)),
      134      ioa_ ext entry options (variable),
      135      iox_$get_line ext entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
      136      object_info_$display entry (ptr, fixed bin (24), ptr, fixed bin (35)),
      137      release_temp_segments_ ext entry (char (*), pointer dimension (*), fixed bin (35)),
      138      sub_err_ ext entry options (variable),
      139      suffixed_name_$make ext entry (char (*), char (*), char (32), fixed bin (35));
      140 
      141 dcl  ta_delete_ ext entry (pointer, char (168) dimension (*), bit (1) aligned, char (*), fixed bin (35)),
      142      ta_extract_ ext entry (pointer, char (168) dimension (*), bit (1) aligned, bit (1) aligned, char (*), fixed bin (35)),
      143      ta_list_table_ ext entry (pointer, char (168) dimension (*), char (*), fixed bin (35)),
      144      ta_load_table_ ext entry (pointer, char (168) dimension (*), char (*), fixed bin (35)),
      145      ta_process_volume_set_$no_lock ext entry (pointer, char (168) dimension (*), char (*), fixed bin (35)),
      146      ta_process_volume_set_ ext entry (pointer, char (168) dimension (*), char (*), fixed bin (35)),
      147      ta_process_volume_set_$dismount ext entry (pointer, bit (1) aligned, fixed bin (35)),
      148      ta_reconstruct_table_ ext entry (pointer, char (168) dimension (*), char (*), fixed bin (35)),
      149      ta_replace_ ext entry (pointer, char (168) dimension (*), bit (1) aligned, bit (1) aligned, char (*), fixed bin (35)),
      150      ta_replace_$append ext entry (pointer, char (168) dimension (*), bit (1) aligned, bit (1) aligned, char (*), fixed bin (35)),
      151      ta_replace_$update ext entry (pointer, char (168) dimension (*), bit (1) aligned, bit (1) aligned, char (*), fixed bin (35)),
      152      ta_table_mgr_$alter_attributes ext entry (pointer, char (168) dimension (*), char (*), fixed bin (35)),
      153      ta_table_mgr_$check_compaction ext entry (pointer, char (*), fixed bin (35)),
      154      ta_table_mgr_$copy_to_perm ext entry (pointer, pointer, fixed bin (35)),
      155      ta_table_mgr_$copy_to_temp ext entry (pointer, pointer, fixed bin(35)),
      156      ta_table_mgr_$create_table ext entry (char (*), char (*), pointer, fixed bin (35)),
      157      ta_table_mgr_$find_and_verify ext entry (char (*), char (*), pointer, bit (1) aligned, fixed bin (35)),
      158      ta_table_mgr_$cancel_component ext entry (pointer, char (168) dimension (*), char (*), fixed bin (35)),
      159      ta_table_mgr_$lock ext entry (pointer, char(*), fixed bin, fixed bin(35)),
      160      ta_table_mgr_$unlock ext entry (pointer, fixed bin (35)),
      161      ta_util_$get_next_token ext entry (char (*)) returns (char (168));
      162 
      163 /* BUILTINS */
      164 
      165 dcl (addr, baseno, baseptr, codeptr, dim, length, null, substr) builtin;
      166 
      167 /* CONDITIONS */
      168 
      169 dcl (cleanup, program_interrupt) condition;
      170 
      171 	table_ptr = null;				/* initialize state of the world */
      172 	query_info.version = query_info_version_5;
      173 
      174 	call cu_$arg_ptr (1, ap, al, code);		/* get key */
      175 	if code ^= 0 then do;
      176 print_usage:   call com_err_ (code, "tape_archive", explanation);
      177 	     return;
      178 	end;
      179 
      180 	key = arg;
      181 
      182 	call cu_$arg_ptr (2, ap, al, code);		/* get table name */
      183 	if code ^= 0 then goto print_usage;
      184 
      185 	call expand_pathname_ (arg, table_dir, table_name, code);
      186 	if code ^= 0 then goto print_usage;
      187 
      188 	call suffixed_name_$make ((table_name), "ta", table_name, code); /* force the "ta" suffix */
      189 	if code ^= 0 then do;
      190 	     call com_err_ (code, "tape_archive", "^a.ta", table_name);
      191 	     return;
      192 	end;
      193 
      194 	do keynum = 1 to dim (key_names, 1) while (key_names (keynum) ^= key);
      195 	end;					/* search to see if key is a known key */
      196 
      197 	if keynum > dim (key_names, 1) then do;		/* no, it wasn't */
      198 	     call com_err_ (0, "tape_archive", "^a not a valid key.", key);
      199 	     return;
      200 	end;
      201 
      202 	call ta_table_mgr_$find_and_verify (table_dir, table_name, table_ptr, w_permit, code);
      203 						/* find the table if it exists */
      204 	if code ^= 0 then				/* some error */
      205 	     if table_ptr = null then
      206 		if code = error_table_$noentry then;	/* can't find table, but this may not matter */
      207 		else do;				/* some other reason for null ptr */
      208 		     call com_err_ (code, "tape_archive", "^a>^a", table_dir, table_name);
      209 		     return;
      210 		end;
      211 	     else do;				/* bad code but good pointer */
      212 		call hcs_$terminate_noname (table_ptr, code);
      213 		return;				/* error message already printed */
      214 	     end;
      215 
      216 	if substr (w_permit_needed, keynum, 1) = "1"b then
      217 	     if ^w_permit then do;			/* doesn't have w access to table and needs it */
      218 		call com_err_ (error_table_$moderr, "tape_archive", "^a>^a", table_dir, table_name);
      219 		call hcs_$terminate_noname (table_ptr, code);
      220 		return;
      221 	     end;





      222 
      223 
      224 /* INTERACTIVE MODE SECTION */
      225 
      226 	if key = "direct" then do;
      227 
      228 	     call cu_$arg_count (nargs);		/* are there any more arguments? */
      229 
      230 	     retain_sw = ""b;			/* default is to dismount tapes when done */
      231 
      232 	     do i = 3 to nargs;			/* process the extra args */
      233 		call cu_$arg_ptr (i, ap, al, code);	/* get one arg */
      234 		if arg = "-retain" then do;
      235 		     i = i + 1;			/* see if next arg */
      236 		     call cu_$arg_ptr (i, ap, al, code);
      237 		     if i > nargs then retain_sw = "1"b; /* no next arg, but what the heck, give it to him */
      238 		     else if arg = "all" then retain_sw = "1"b;
      239 		end;
      240 		if retain_sw = ""b then do;		/* we didn't recognize something */
      241 		     call com_err_ (error_table_$badopt, "tape_archive", arg);
      242 		     call hcs_$terminate_noname (table_ptr, code);
      243 		     return;
      244 		end;
      245 	     end;
      246 
      247 	     if table_ptr = null then do;		/* we have to create a new table */
      248 		call ta_table_mgr_$create_table (table_dir, table_name, table_ptr, code);
      249 		if code ^= 0 then do;		/* oops */
      250 		     call com_err_ (code, "tape_archive", "Creating ^a>^a.", table_dir, table_name);
      251 		     return;
      252 		end;
      253 	     end;
      254 
      255 	     temp_table_ptr (1) = null;
      256 	     perm_table_ptr = table_ptr;		/* get set to copy table */
      257 
      258 	     on cleanup call cleanerup;
      259 
      260 cleanerup:     proc;
      261 
      262 		if temp_table_ptr (1) ^= null then
      263 		     call release_temp_segments_ ("tape_archive", temp_table_ptr, 0);
      264 		if perm_table_ptr ^= null then do;
      265 		     call ta_process_volume_set_$dismount (perm_table_ptr, retain_sw, code);
      266 		     call ta_table_mgr_$unlock (perm_table_ptr, code);
      267 		     call hcs_$terminate_noname (perm_table_ptr, 0);
      268 		end;
      269 		retain_sw = ""b;
      270 		perm_table_ptr, table_ptr = null;
      271 	     end cleanerup;
      272 
      273 	     call ta_table_mgr_$lock(perm_table_ptr, table_name, Modify, code);
      274 	     if code ^= 0
      275 	     then do;
      276 	          call cleanerup();
      277 		return;
      278 	     end;
      279 
      280 	     do dummy = 1, 1 by 1 while (retain_sw);	/* This is a wierd way to get "trailing test" loop */
      281 
      282 		call get_temp_segments_ ("tape_archive", temp_table_ptr, code); /* create libensraum */
      283 		if code ^= 0 then do;
      284 		     call com_err_ (code, "tape_archive", "Could not get temp segment.");
      285 		     return;
      286 		end;
      287 
      288 		call ta_table_mgr_$copy_to_temp(perm_table_ptr, temp_table_ptr (1), code);
      289 						/* make a copy of the table to fiddle with */
      290 		if code ^= 0 then do;
      291 		     call cleanerup;
      292 		     return;
      293 		end;
      294 
      295 		table_ptr = temp_table_ptr (1);	/* remember to use the copy */
      296 
      297 		requests_outstanding = ""b;		/* no diffs between perm and temp table yet */
      298 
      299 		on program_interrupt goto pi_label;
      300 
      301 pi_label:		key = "";
      302 
      303 		call ioa_ ("Input.");
      304 
      305 		do while (key ^= "go");		/* process requests one by one */
      306 
      307 		     code = 1;
      308 		     do while (code ^= 0);		/* get an input line */
      309 			call iox_$get_line (iox_$user_input, addr (input_line), length (input_line),
      310 			     n_chars_read, code);
      311 			if code ^= 0 then
      312 			     if code = error_table_$long_record then
      313 				call com_err_ (code, "tape_archive",
      314 				"Max input line length = ^d chars; line discarded.",
      315 				length (input_line));
      316 			     else do;		/* uglies */
      317 				call com_err_ (code, "tape_archive", "While reading from user_input.");
      318 				call cleanerup;	/* take no chances */
      319 				return;
      320 			     end;
      321 
      322 			else if n_chars_read = 1 then /* blank line */
      323 			     code = 1;
      324 		     end;
      325 
      326 		     substr (input_line, n_chars_read) = ""; /* kill from the newline out */
      327 		     key = ta_util_$get_next_token (input_line);
      328 
      329 		     do keynum = 1 to allowed_in_input_mode while (key ^= key_names (keynum));
      330 		     end;				/* search known keys to see if key is valid */
      331 
      332 		     if keynum > allowed_in_input_mode then do; /* not clearly valid */
      333 
      334 			if key = "save" then do;	/* This one is ok */
      335 			     call ta_table_mgr_$copy_to_perm(table_ptr, perm_table_ptr, code);
      336 						/* replace perm table with temp table */
      337 			     if code ^= 0 then call sub_err_ (code, "tape_archive", "s", null, 0,
      338 				"Cannot save table, cannot recover.");
      339 			     call ta_table_mgr_$copy_to_temp(perm_table_ptr, temp_table_ptr (1), code);   /* now whip it back to continue */
      340 			     if code ^= 0 then do;
      341 				call com_err_ (code, "tape_archive",
      342 				     "Requests have been saved, but processing cannot continue.");
      343 				call cleanerup;	/* could be worse. */
      344 				return;
      345 			     end;
      346 			     requests_outstanding = ""b; /* back to ground zero again */
      347 			end;
      348 
      349 			else if key = "go" then do;	/* spin tapes */
      350 			     dummy_args (1) = "-retain";
      351 			     if retain_sw then
      352 				dummy_args (2) = "all";
      353 			     else dummy_args (2) = "none";
      354 
      355 			     do n_dummy_args = 3 to dim (dummy_args, 1) while (input_line ^= "");
      356 				dummy_args (n_dummy_args) = ta_util_$get_next_token (input_line);
      357 			     end;
      358 
      359 			     n_dummy_args = n_dummy_args - 1;
      360 
      361 			     if input_line ^= "" then do;
      362 				call com_err_ (0, "tape_archive", "Max number of args allowed = ^d; line discarded.",
      363 				     dim (dummy_args, 1) - 2);
      364 				key = "not go";
      365 			     end;
      366 
      367 			     else do;
      368 				call ta_table_mgr_$copy_to_perm(table_ptr, perm_table_ptr, code);
      369 						/* first make the requests permanent */
      370 				table_ptr = perm_table_ptr;
      371 
      372 				call release_temp_segments_ ("tape_archive", temp_table_ptr, 0);
      373 				temp_table_ptr = null; /* lead us not into temptation */
      374 
      375 				call ta_process_volume_set_$no_lock(table_ptr, dummy_args_based, table_name, code); /* roll 'em */
      376 				requests_outstanding = ""b;
      377 			     end;
      378 			end;
      379 
      380 			else if key = "quit" | key = "q" then do;
      381 
      382 			     if ^requests_outstanding then answer = "yes"; /* we're clean */
      383 
      384 			     else do;		/* unsaved requests exist */
      385 				query_info.yes_or_no_sw = "1"b; /* must answer yes or no */
      386 				call command_query_ (addr (query_info), answer, "tape_archive",
      387 				     "Unsaved requests may be lost if you quit now.^/^-Do you still wish to quit?");
      388 			     end;
      389 
      390 			     if answer = "yes" then do;
      391 				call ta_table_mgr_$unlock (perm_table_ptr, code); /* unlock the perm table */
      392 				if code ^= 0 then call sub_err_ (code, "tape_archive", "s", null, 0,
      393 				     "Cannot unlock table, cannot recover.");
      394 				call cleanerup;
      395 				return;
      396 			     end;
      397 			end;
      398 
      399 			else if key = ".." then
      400 			     call cu_$cp (addr (input_line), length (input_line), 0);
      401 
      402 			else if key = "." then do;
      403 here_label:		     me_ptr = baseptr (baseno (codeptr (here_label)));
      404 						/* get pointer to base of my own segment */
      405 
      406 			     library_description = "";
      407 
      408 			     do i = 1 to dim (search_libraries, 1) while (library_description = "");
      409 				call hcs_$initiate (search_libraries (i).dir, "tape_archive", "", 0, 0, p, code);
      410 				if p ^= null then do;
      411 				     if p = me_ptr then library_description = search_libraries.description (i);
      412 				     call hcs_$terminate_noname (p, 0);
      413 				end;
      414 			     end;
      415 
      416 			     if library_description = "" then do;
      417 				call hcs_$fs_get_path_name (me_ptr, prog_dir, 0, prog_ent, code);
      418 				if code ^= 0 then
      419 				     call com_err_ (code, "tape_archive",
      420 				     "Determining pathname of this version of tape_archive.");
      421 
      422 				else call ioa_ ("tape_archive version ^d; ^a>^a (private version)",
      423 				     tape_archive_version_4, prog_dir, prog_ent);
      424 			     end;
      425 
      426 			     else do;
      427 				oi.version_number = object_info_version_2;
      428 
      429 				call hcs_$status_mins (me_ptr, 0, me_bc, code);
      430 				if code = 0 then
      431 				     call object_info_$display (me_ptr, me_bc, addr (oi), code);
      432 				if code ^= 0 then
      433 				     call com_err_ (code, "tape_archive",
      434 				     "Determining version of tape_archive.");
      435 
      436 				else do;
      437 				     call date_time_ (oi.compile_time, my_date_time);
      438 
      439 				     call ioa_ ("tape_archive; ^a version ^d of ^a.", library_description,
      440 					tape_archive_version_4, my_date_time);
      441 				end;
      442 			     end;
      443 			end;
      444 
      445 			else call com_err_$suppress_name (0, "tape_archive", "Not a recognized request:  ^a", key);
      446 		     end;
      447 
      448 		     else do;			/* process the good key */
      449 
      450 			do i = 1 to dim (dummy_args, 1) while (input_line ^= "");
      451 			     dummy_args (i) = ta_util_$get_next_token (input_line);
      452 						/* split input line into "arguments" */
      453 			end;
      454 
      455 			if input_line ^= "" then call com_err_ (0, "tape_archive",
      456 			     "Max number of args allowed = ^d;  line discarded.", dim (dummy_args, 1));
      457 
      458 			else do;
      459 			     call process_command_line (i-1, null, dummy_args, code);
      460 			     if code = 0 then requests_outstanding = "1"b;
      461 						/* This errs on the side of safety, because some
      462*						   subroutines don't return nonzero codes for errors */
      463 			end;
      464 		     end;
      465 		end;
      466 	     end;
      467 	end;





      468 
      469 
      470 /* ONE-SHOT INVOCATION MODE SECTION */
      471 
      472 	else do;
      473 	     call cu_$arg_count (nargs);		/* get extra args */
      474 	     call cu_$arg_list_ptr (alp);
      475 	     call process_command_line (nargs-2, alp, dummy_args, code); /* send 'em on in */
      476 	end;
      477 
      478 	if table_ptr ^= null then call hcs_$terminate_noname (table_ptr, code);
      479 	return;
      480 
      481 process_command_line: proc (nargs, alp, passed_args, code);
      482 
      483 /* This internal subroutine dispatches commands and arguments to the proper subroutine to
      484*   handle that particular key. */
      485 
      486 dcl  nargs fixed bin parameter,
      487      alp pointer parameter,
      488      passed_args char (168) dimension (*) parameter,
      489      code fixed bin (35) parameter;
      490 
      491 dcl  rest_of_args (nargs) char (168);
      492 
      493 	     if alp = null then			/* args are passed in passed_args */
      494 		do i = 1 to nargs;
      495 		rest_of_args (i) = passed_args (i);
      496 	     end;
      497 
      498 	     else					/* args are in the arglist at alp */
      499 	     do i = 1 to nargs;
      500 		call cu_$arg_ptr_rel (i+2, ap, al, code, alp);
      501 		rest_of_args (i) = arg;
      502 	     end;
      503 
      504 	     if table_ptr = null then			/* no table, should we create? */
      505 		if substr (key_structure.table_must_exist, keynum, 1) then do; /* no, we should complain */
      506 		     call com_err_ (error_table_$noentry, "tape_archive",
      507 			"^a must already exist to process the ""^a"" request.", table_name, key);
      508 		     return;
      509 		end;
      510 
      511 		else do;				/* ok to create table, so do it */
      512 		     call ta_table_mgr_$create_table (table_dir, table_name, table_ptr, code);
      513 		     if code ^= 0 then return;	/* it has already complained */
      514 		end;
      515 
      516 	     delete = substr (key_structure.delete, keynum, 1);
      517 	     force = substr (key_structure.force, keynum, 1);
      518 
      519 	     goto act_on_key (keynum);
      520 
      521 act_on_key (1): act_on_key (2): act_on_key (3):		/* a, ad, adf */
      522 	     call ta_replace_$append (table_ptr, rest_of_args, delete, force, table_name, code);
      523 	     goto act_on_key_end;
      524 
      525 act_on_key (4): act_on_key (5): act_on_key (6):		/* r, rd, rdf */
      526 	     call ta_replace_ (table_ptr, rest_of_args, delete, force, table_name, code);
      527 	     goto act_on_key_end;
      528 
      529 act_on_key (7): act_on_key (8): act_on_key (9):		/* u, ud, udf */
      530 	     call ta_replace_$update (table_ptr, rest_of_args, delete, force, table_name, code);
      531 	     goto act_on_key_end;
      532 						
      533 act_on_key (10): act_on_key (11): act_on_key (12): act_on_key (13):	/* x, xd, xdf, xf */
      534                call ta_extract_ (table_ptr, rest_of_args, delete, force, table_name, code);
      535 	     goto act_on_key_end;
      536 
      537 act_on_key (14): act_on_key (15):			/* d, df */
      538 	     call ta_delete_ (table_ptr, rest_of_args, force, table_name, code);
      539 	     goto act_on_key_end;
      540 
      541 act_on_key (16):					/* cancel */
      542 	     call ta_table_mgr_$cancel_component (table_ptr, rest_of_args, table_name, code);
      543 	     goto act_on_key_end;
      544 
      545 act_on_key (17):					/* t */
      546 	     call ta_list_table_ (table_ptr, rest_of_args, table_name, code);
      547 	     return;
      548 
      549 act_on_key (18):					/* compact */
      550 	     tape_archive_table.next_mount_type = Compact;
      551 	     return;
      552 
      553 act_on_key (19):					/* alter */
      554 	     call ta_table_mgr_$alter_attributes (table_ptr, rest_of_args, table_name, code);
      555 	     return;
      556 
      557 act_on_key (20):					/* go */
      558 	     call ta_process_volume_set_ (table_ptr, rest_of_args, table_name, code);
      559 	     return;
      560 
      561 act_on_key (21):					/* load_table */
      562 	     call ta_load_table_ (table_ptr, rest_of_args, table_name, code);
      563 	     return;
      564 
      565 act_on_key (22):					/* reconstruct */
      566 	     call ta_reconstruct_table_ (table_ptr, rest_of_args, table_name, code);
      567 	     return;
      568 
      569 
      570 act_on_key_end:
      571 	     call ta_table_mgr_$check_compaction (table_ptr, table_name, code);
      572 						/* see if this request deserves an auto compaction or warning */
      573 	     return;
      574 
      575 	end process_command_line;
      576 
      577      end tape_archive;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    02/16/84  1249.5  tape_archive.pl1                  >spec>on>mtape>tape_archive.pl1
37           1    02/16/84  1230.3  tape_archive_table_dcl.incl.pl1   >spec>on>mtape>tape_archive_table_dcl.incl.pl1
39           2    03/11/83  1204.3  query_info_.incl.pl1              >ldd>include>query_info.incl.pl1
41           3    08/05/77  1022.5  object_info.incl.pl1              >ldd>include>object_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Compact                                constant        fixed bin(17,0)          initial dcl 1-114 ref 549
Modify                          000452 constant        fixed bin(17,0)          initial dcl 1-114 set ref 273*
addr                                                   builtin function         dcl 165 ref 309 309 375 386 386 399 399 430 430
al                              000117 automatic       fixed bin(17,0)          dcl 45 set ref 174* 180 182* 185 185 233* 234 236*
                                                                                  238 241 241 500* 501
allowed_in_input_mode                  constant        fixed bin(17,0)          initial dcl 102 ref 329 332
alp                             000120 automatic       pointer                  dcl 45 in procedure "ta" set ref 474* 475*
alp                                    parameter       pointer                  dcl 486 in procedure "process_command_line" set ref
                                                                                  481 493 500*
answer                          000122 automatic       varying char(4)          dcl 45 set ref 382* 386* 390
answer_iocbp              6     000102 automatic       pointer                  initial level 2 dcl 2-7 set ref 2-7*
ap                              000124 automatic       pointer                  dcl 45 set ref 174* 180 182* 185 233* 234 236* 238
                                                                                  241 500* 501
arg                                    based           char                     unaligned dcl 45 set ref 180 185* 234 238 241* 501
baseno                                                 builtin function         dcl 165 ref 403
baseptr                                                builtin function         dcl 165 ref 403
cleanup                         010754 stack reference condition                dcl 169 ref 258
code                                   parameter       fixed bin(35,0)          dcl 486 in procedure "process_command_line" set ref
                                                                                  481 500* 512* 513 521* 525* 529* 533* 537* 541*
                                                                                  545* 553* 557* 561* 565* 570*
code                            000126 automatic       fixed bin(35,0)          dcl 45 in procedure "ta" set ref 174* 175 176* 182*
                                                                                  183 185* 186 188* 189 190* 202* 204 204 208* 212*
                                                                                  219* 233* 236* 242* 248* 249 250* 265* 266* 273*
                                                                                  274 282* 283 284* 288* 290 307* 308 309* 311 311
                                                                                  311* 317* 322* 335* 337 337* 339* 340 341* 368*
                                                                                  375* 391* 392 392* 409* 417* 418 418* 429* 430
                                                                                  430* 432 432* 459* 460 475* 478*
codeptr                                                builtin function         dcl 165 ref 403
com_err_                        000022 constant        entry                    external dcl 119 ref 176 190 198 208 218 241 250 284
                                                                                  311 317 341 362 418 432 455 506
com_err_$suppress_name          000024 constant        entry                    external dcl 119 ref 445
command_query_                  000026 constant        entry                    external dcl 119 ref 386
compile_time             32     010666 automatic       fixed bin(71,0)          level 2 dcl 78 set ref 437*
component                              based           structure                level 1 dcl 1-53
cp_escape_control         1(02) 000102 automatic       bit(2)                   initial level 3 packed unaligned dcl 2-7 set ref
                                                                                  2-7*
cu_$arg_count                   000030 constant        entry                    external dcl 119 ref 228 473
cu_$arg_list_ptr                000032 constant        entry                    external dcl 119 ref 474
cu_$arg_ptr                     000034 constant        entry                    external dcl 119 ref 174 182 233 236
cu_$arg_ptr_rel                 000036 constant        entry                    external dcl 119 ref 500
cu_$cp                          000040 constant        entry                    external dcl 119 ref 399
date_time_                      000042 constant        entry                    external dcl 119 ref 437
delete                  105     000000 constant        bit(23)                  initial level 2 in structure "key_structure" dcl 82
                                                                                  in procedure "ta" ref 516
delete                          000127 automatic       bit(1)                   dcl 45 in procedure "ta" set ref 516* 521* 525* 529*
                                                                                  533*
description              52     000111 constant        char(64)                 initial array level 2 packed unaligned dcl 105 ref
                                                                                  411
dim                                                    builtin function         dcl 165 ref 194 197 355 362 408 450 455 455
dir                             000111 constant        char(168)                initial array level 2 packed unaligned dcl 105 set
                                                                                  ref 409*
dummy                           000130 automatic       fixed bin(17,0)          dcl 45 set ref 280*
dummy_args                      000131 automatic       char(168)                array unaligned dcl 45 set ref 350* 351* 353* 355
                                                                                  356* 362 375 450 451* 455 455 459* 475*
dummy_args_based                       based           char(168)                array unaligned dcl 45 set ref 375*
entry_status_descriptor                based           structure                level 1 dcl 1-74
error_table_$badopt             000010 external static fixed bin(35,0)          dcl 111 set ref 241*
error_table_$long_record        000016 external static fixed bin(35,0)          dcl 111 ref 311
error_table_$moderr             000012 external static fixed bin(35,0)          dcl 111 set ref 218*
error_table_$noentry            000014 external static fixed bin(35,0)          dcl 111 set ref 204 506*
expand_pathname_                000044 constant        entry                    external dcl 119 ref 185
explanation                     000323 constant        char(168)                initial unaligned dcl 102 set ref 176*
explanation_len          14     000102 automatic       fixed bin(21,0)          initial level 2 dcl 2-7 set ref 2-7*
explanation_ptr          12     000102 automatic       pointer                  initial level 2 dcl 2-7 set ref 2-7*
force                           010313 automatic       bit(1)                   dcl 45 in procedure "ta" set ref 517* 521* 525* 529*
                                                                                  533* 537*
force                   106     000000 constant        bit(23)                  initial level 2 in structure "key_structure" dcl 82
                                                                                  in procedure "ta" ref 517
get_temp_segments_              000046 constant        entry                    external dcl 119 ref 282
hcs_$fs_get_path_name           000050 constant        entry                    external dcl 119 ref 417
hcs_$initiate                   000052 constant        entry                    external dcl 119 ref 409
hcs_$status_mins                000054 constant        entry                    external dcl 119 ref 429
hcs_$terminate_noname           000056 constant        entry                    external dcl 119 ref 212 219 242 267 412 478
i                               010314 automatic       fixed bin(17,0)          dcl 45 set ref 232* 233* 235* 235 236* 237* 408* 409
                                                                                  411* 450* 451* 459 493* 495 495* 498* 500 501*
input_line                      010315 automatic       char(300)                unaligned dcl 45 set ref 309 309 309 309 311 311
                                                                                  326* 327* 355 356* 361 399 399 399 399 450 451*
                                                                                  455
ioa_                            000060 constant        entry                    external dcl 119 ref 303 422 439
iox_$get_line                   000062 constant        entry                    external dcl 119 ref 309
iox_$user_input                 000020 external static pointer                  dcl 111 set ref 309*
key                             010430 automatic       char(12)                 unaligned dcl 45 set ref 180* 194 198* 226 301* 305
                                                                                  327* 329 334 349 364* 380 380 399 402 445* 506*
key_names                       000000 constant        char(12)                 initial array level 2 dcl 82 ref 194 194 197 329
key_structure                   000000 constant        structure                level 1 dcl 82
keynum                          010433 automatic       fixed bin(17,0)          dcl 45 set ref 194* 194* 197 216 329* 329* 332 504
                                                                                  516 517 519
length                                                 builtin function         dcl 165 ref 309 309 311 311 399 399
library_description             010434 automatic       char(168)                unaligned dcl 45 set ref 406* 408 411* 416 439*
literal_sw                1(05) 000102 automatic       bit(1)                   initial level 3 packed unaligned dcl 2-7 set ref
                                                                                  2-7*
me_bc                           010301 automatic       fixed bin(24,0)          dcl 45 set ref 429* 430*
me_ptr                          010302 automatic       pointer                  dcl 45 set ref 403* 411 417* 429* 430*
my_date_time                    010304 automatic       char(24)                 unaligned dcl 45 set ref 437* 439*
n_chars_read                    010506 automatic       fixed bin(21,0)          dcl 45 set ref 309* 322 326
n_dummy_args                    010312 automatic       fixed bin(17,0)          dcl 45 set ref 355* 356* 359* 359 375
nargs                           010507 automatic       fixed bin(17,0)          dcl 45 in procedure "ta" set ref 228* 232 237 473*
                                                                                  475
nargs                                  parameter       fixed bin(17,0)          dcl 486 in procedure "process_command_line" ref 481
                                                                                  491 493 498
next_mount_type          44            based           fixed bin(17,0)          level 3 dcl 1-14 set ref 549*
null                                                   builtin function         dcl 165 ref 171 204 247 255 337 337 373 392 392 410
                                                                                  459 459 478 2-7 2-7 2-7 262 264 270 493 504
object_info                            based           structure                level 1 dcl 3-6
object_info_$display            000064 constant        entry                    external dcl 119 ref 430
object_info_version_2                  constant        fixed bin(17,0)          initial dcl 3-60 ref 427
oi                              010666 automatic       structure                level 1 dcl 78 set ref 430 430
p                               010510 automatic       pointer                  dcl 45 set ref 409* 410 411 412*
padding                   1(07) 000102 automatic       bit(29)                  initial level 3 packed unaligned dcl 2-7 set ref
                                                                                  2-7*
passed_args                            parameter       char(168)                array unaligned dcl 486 ref 481 495
perm_table_ptr                  010512 automatic       pointer                  dcl 45 set ref 256* 264 265* 266* 267* 270* 273*
                                                                                  288* 335* 339* 368* 370 391*
prog_dir                        010514 automatic       char(168)                unaligned dcl 45 set ref 417* 422*
prog_ent                        010566 automatic       char(32)                 unaligned dcl 45 set ref 417* 422*
program_interrupt               010762 stack reference condition                dcl 169 ref 299
prompt_after_explanation
                          1(06) 000102 automatic       bit(1)                   initial level 3 packed unaligned dcl 2-7 set ref
                                                                                  2-7*
query_code                3     000102 automatic       fixed bin(35,0)          initial level 2 dcl 2-7 set ref 2-7*
query_info                      000102 automatic       structure                level 1 dcl 2-7 set ref 386 386
query_info_version_5                   constant        fixed bin(17,0)          initial dcl 2-35 ref 172
question_iocbp            4     000102 automatic       pointer                  initial level 2 dcl 2-7 set ref 2-7*
release_temp_segments_          000066 constant        entry                    external dcl 119 ref 262 372
repeat_time              10     000102 automatic       fixed bin(71,0)          initial level 2 dcl 2-7 set ref 2-7*
request                                based           structure                level 1 dcl 1-60
requests_outstanding            010576 automatic       bit(1)                   dcl 45 set ref 297* 346* 376* 382 460*
rest_of_args                    000100 automatic       char(168)                array unaligned dcl 491 set ref 495* 501* 521* 525*
                                                                                  529* 533* 537* 541* 545* 553* 557* 561* 565*
retain_sw                       010577 automatic       bit(1)                   dcl 45 set ref 230* 237* 238* 240 265* 269* 351 466
search_libraries                000111 constant        structure                array level 1 packed unaligned dcl 105 set ref 408
status_code               2     000102 automatic       fixed bin(35,0)          initial level 2 dcl 2-7 set ref 2-7*
sub_err_                        000070 constant        entry                    external dcl 119 ref 337 392
substr                                                 builtin function         dcl 165 set ref 216 326* 504 516 517
suffixed_name_$make             000072 constant        entry                    external dcl 119 ref 188
suppress_name_sw          1(01) 000102 automatic       bit(1)                   initial level 3 packed unaligned dcl 2-7 set ref
                                                                                  2-7*
suppress_spacing          1(04) 000102 automatic       bit(1)                   initial level 3 packed unaligned dcl 2-7 set ref
                                                                                  2-7*
switches                  1     000102 automatic       structure                level 2 dcl 2-7
ta_delete_                      000074 constant        entry                    external dcl 141 ref 537
ta_extract_                     000076 constant        entry                    external dcl 141 ref 533
ta_list_table_                  000100 constant        entry                    external dcl 141 ref 545
ta_load_table_                  000102 constant        entry                    external dcl 141 ref 561
ta_process_volume_set_          000106 constant        entry                    external dcl 141 ref 557
ta_process_volume_set_$dismount 000110 constant        entry                    external dcl 141 ref 265
ta_process_volume_set_$no_lock  000104 constant        entry                    external dcl 141 ref 375
ta_reconstruct_table_           000112 constant        entry                    external dcl 141 ref 565
ta_replace_                     000114 constant        entry                    external dcl 141 ref 525
ta_replace_$append              000116 constant        entry                    external dcl 141 ref 521
ta_replace_$update              000120 constant        entry                    external dcl 141 ref 529
ta_table_mgr_$alter_attributes  000122 constant        entry                    external dcl 141 ref 553
ta_table_mgr_$cancel_component  000136 constant        entry                    external dcl 141 ref 541
ta_table_mgr_$check_compaction  000124 constant        entry                    external dcl 141 ref 570
ta_table_mgr_$copy_to_perm      000126 constant        entry                    external dcl 141 ref 335 368
ta_table_mgr_$copy_to_temp      000130 constant        entry                    external dcl 141 ref 288 339
ta_table_mgr_$create_table      000132 constant        entry                    external dcl 141 ref 248 512
ta_table_mgr_$find_and_verify   000134 constant        entry                    external dcl 141 ref 202
ta_table_mgr_$lock              000140 constant        entry                    external dcl 141 ref 273
ta_table_mgr_$unlock            000142 constant        entry                    external dcl 141 ref 266 391
ta_util_$get_next_token         000144 constant        entry                    external dcl 141 ref 327 356 451
table_dir                       010600 automatic       char(168)                unaligned dcl 45 set ref 185* 202* 208* 218* 248*
                                                                                  250* 512*
table_must_exist        107     000000 constant        bit(23)                  initial level 2 dcl 82 ref 504
table_name                      010652 automatic       char(32)                 unaligned dcl 45 set ref 185* 188 188* 190* 202*
                                                                                  208* 218* 248* 250* 273* 375* 506* 512* 521* 525*
                                                                                  529* 533* 537* 541* 545* 553* 557* 561* 565* 570*
table_ptr                       000100 automatic       pointer                  dcl 1-112 set ref 171* 202* 204 212* 219* 242* 247
                                                                                  248* 256 270* 295* 335* 368* 370* 375* 478 478*
                                                                                  504 512* 521* 525* 529* 533* 537* 541* 545* 549
                                                                                  553* 557* 561* 565* 570*
tape_archive_table                     based           structure                level 1 dcl 1-14
tape_archive_version_4          000451 constant        fixed bin(17,0)          initial dcl 1-114 set ref 422* 439*
tape_info                64            based           structure                level 3 dcl 1-14
temp_table_ptr                  010662 automatic       pointer                  array dcl 45 set ref 255* 262 262* 282* 288* 295
                                                                                  339* 372* 373*
version                         000102 automatic       fixed bin(17,0)          level 2 dcl 2-7 set ref 172*
version_number                  010666 automatic       fixed bin(17,0)          level 2 dcl 78 set ref 427*
volatile_part            40            based           structure                level 2 dcl 1-14
w_permit                        010664 automatic       bit(1)                   dcl 45 set ref 202* 216
w_permit_needed         110     000000 constant        bit(23)                  initial level 2 dcl 82 ref 216
yes_or_no_sw              1     000102 automatic       bit(1)                   initial level 3 packed unaligned dcl 2-7 set ref
                                                                                  385* 2-7*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Cancellation                           internal static fixed bin(17,0)          initial dcl 1-114
Default_density                        internal static fixed bin(17,0)          initial dcl 1-114
Delete                                 internal static fixed bin(17,0)          initial dcl 1-114
Deletion                               internal static fixed bin(17,0)          initial dcl 1-114
Deletion_cancellation                  internal static fixed bin(17,0)          initial dcl 1-114
Examine                                internal static fixed bin(17,0)          initial dcl 1-114
Extraction                             internal static fixed bin(17,0)          initial dcl 1-114
Lock_reasons                           internal static char(24)                 initial array unaligned dcl 1-114
Magic_constant                         internal static char(8)                  initial unaligned dcl 1-114
Magic_workspace_constant               internal static char(8)                  initial unaligned dcl 1-114
None                                   internal static fixed bin(17,0)          initial dcl 1-114
Process_tape                           internal static fixed bin(17,0)          initial dcl 1-114
Read                                   internal static fixed bin(17,0)          initial dcl 1-114
Replacement                            internal static fixed bin(17,0)          initial dcl 1-114
TAPE_ARCHIVE_IO_MODULE                 internal static char(6)                  initial unaligned dcl 1-114
Table_copy                             internal static fixed bin(17,0)          initial dcl 1-114
Table_creation                         internal static fixed bin(17,0)          initial dcl 1-114
Volume_alteration                      internal static fixed bin(17,0)          initial dcl 1-114
Write                                  internal static fixed bin(17,0)          initial dcl 1-114
based_tape_info                        based           structure                level 1 dcl 1-110
component_ptr                          automatic       pointer                  dcl 1-112
query_info_version_3                   internal static fixed bin(17,0)          initial dcl 2-33
query_info_version_4                   internal static fixed bin(17,0)          initial dcl 2-34
query_info_version_6                   internal static fixed bin(17,0)          initial dcl 2-36
request_ptr                            automatic       pointer                  dcl 1-112
tape_info_ptr                          automatic       pointer                  dcl 1-112
workspace                              based           structure                level 1 dcl 1-93
workspace_ptr                          automatic       pointer                  dcl 1-112

NAMES DECLARED BY EXPLICIT CONTEXT.
act_on_key                      000275 constant        label                    array(22) dcl 521 ref 519
act_on_key_end                  005372 constant        label                    dcl 570 ref 523 527 531 535 539 543
cleanerup                       004221 constant        entry                    internal dcl 260 ref 258 276 291 318 343 394
here_label                      003315 constant        label                    dcl 403 ref 403
pi_label                        002242 constant        label                    dcl 301 set ref 299
print_usage                     001104 constant        label                    dcl 176 ref 183 186
process_command_line            004334 constant        entry                    internal dcl 481 ref 459 475
ta                              001041 constant        entry                    external dcl 18
tape_archive                    001051 constant        entry                    external dcl 18

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6224        6372    5431        6234
Length      6754    5431       146         345     573           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
ta                                 4722 external procedure  is an external procedure.  
on unit on line 258                  64 on unit               
cleanerup                            84 internal procedure  is called by several nonquick procedures.  
on unit on line 299                  64 on unit               
process_command_line                190 internal procedure  uses auto adjustable storage.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
process_command_line     000100 rest_of_args                process_command_line
ta                       000100 table_ptr                   ta
                         000102 query_info                  ta
                         000117 al                          ta
                         000120 alp                         ta
                         000122 answer                      ta
                         000124 ap                          ta
                         000126 code                        ta
                         000127 delete                      ta
                         000130 dummy                       ta
                         000131 dummy_args                  ta
                         010301 me_bc                       ta
                         010302 me_ptr                      ta
                         010304 my_date_time                ta
                         010312 n_dummy_args                ta
                         010313 force                       ta
                         010314 i                           ta
                         010315 input_line                  ta
                         010430 key                         ta
                         010433 keynum                      ta
                         010434 library_description         ta
                         010506 n_chars_read                ta
                         010507 nargs                       ta
                         010510 p                           ta
                         010512 perm_table_ptr              ta
                         010514 prog_dir                    ta
                         010566 prog_ent                    ta
                         010576 requests_outstanding        ta
                         010577 retain_sw                   ta
                         010600 table_dir                   ta
                         010652 table_name                  ta
                         010662 temp_table_ptr              ta
                         010664 w_permit                    ta
                         010666 oi                          ta

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this       call_int_other      return
tra_ext             alloc_auto_adj      enable              ext_entry           int_entry           int_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      com_err_$suppress_name        command_query_                cu_$arg_count
cu_$arg_list_ptr              cu_$arg_ptr                   cu_$arg_ptr_rel               cu_$cp
date_time_                    expand_pathname_              get_temp_segments_            hcs_$fs_get_path_name
hcs_$initiate                 hcs_$status_mins              hcs_$terminate_noname         ioa_
iox_$get_line                 object_info_$display          release_temp_segments_        sub_err_
suffixed_name_$make           ta_delete_                    ta_extract_                   ta_list_table_
ta_load_table_                ta_process_volume_set_        ta_process_volume_set_$dismount
ta_process_volume_set_$no_lock                              ta_reconstruct_table_         ta_replace_
ta_replace_$append            ta_replace_$update            ta_table_mgr_$alter_attributes
ta_table_mgr_$cancel_component                              ta_table_mgr_$check_compaction
ta_table_mgr_$copy_to_perm    ta_table_mgr_$copy_to_temp    ta_table_mgr_$create_table    ta_table_mgr_$find_and_verify
ta_table_mgr_$lock            ta_table_mgr_$unlock          ta_util_$get_next_token

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$long_record      error_table_$moderr           error_table_$noentry
iox_$user_input




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 2    7 001006        18 001040       171 001057       172 001061       174 001063       175 001102       176 001104
    177 001131       180 001132       182 001137       183 001156       185 001160       186 001210       188 001212
    189 001244       190 001246       191 001301       194 001302       195 001315       197 001317       198 001322
    199 001357       202 001360       204 001411       208 001424       209 001462       210 001463       212 001464
    213 001475       216 001476       218 001506       219 001545       220 001556       226 001557       228 001563
    230 001572       232 001573       233 001603       234 001620       235 001626       236 001627       237 001644
    238 001652       240 001662       241 001665       242 001715       243 001726       245 001727       247 001731
    248 001735       249 001762       250 001764       251 002027       255 002030       256 002032       258 002034
    273 002056       274 002103       276 002105       277 002111       280 002112       282 002116       283 002143
    284 002145       285 002175       288 002176       290 002211       291 002213       292 002217       295 002220
    297 002222       299 002223       301 002242       303 002245       305 002260       307 002264       308 002266
    309 002270       311 002313       317 002356       318 002405       319 002411       320 002412       322 002413
    324 002420       326 002421       327 002432       329 002453       330 002471       332 002473       334 002476
    335 002502       337 002515       339 002570       340 002603       341 002605       343 002635       344 002641
    346 002642       347 002643       349 002644       350 002650       351 002653       353 002662       355 002665
    356 002677       357 002715       359 002717       361 002721       362 002725       364 002764       365 002767
    368 002770       370 003003       372 003005       373 003033       375 003047       376 003104       378 003105
    380 003106       382 003116       385 003125       386 003127       390 003165       391 003172       392 003203
    394 003256       395 003262       397 003263       399 003264       402 003311       403 003315       406 003323
    408 003326       409 003340       410 003411       411 003415       412 003427       414 003441       416 003443
    417 003447       418 003501       422 003534       424 003564       427 003565       429 003567       430 003605
    432 003626       437 003661       439 003676       443 003726       445 003727       446 003764       450 003765
    451 003777       453 004015       455 004017       459 004063       460 004113       465 004117       466 004120
    467 004134       473 004135       474 004144       475 004153       478 004202       479 004217       260 004220
    262 004226       264 004260       265 004265       266 004300       267 004312       269 004325       270 004327
    271 004332       481 004333       491 004341       521 004350       525 004360       529 004371       533 004401
    537 004411       541 004421       545 004431       553 004441       557 004451       561 004461       565 004471
    493 004501       495 004516       496 004540       498 004543       500 004554       501 004576       502 004610
    504 004612       506 004624       508 004664       512 004665       513 004713       516 004716       517 004724
    519 004730       521 004731       523 004766       525 004767       527 005024       529 005025       531 005062
    533 005063       535 005120       537 005121       539 005153       541 005154       543 005202       545 005203
    547 005231       549 005232       551 005235       553 005236       555 005264       557 005265       559 005313
    561 005314       563 005342       565 005343       567 005371       570 005372       573 005415


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
