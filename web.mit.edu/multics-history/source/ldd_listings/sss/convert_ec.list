	COMPILATION LISTING OF SEGMENT convert_ec
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/29/86  0939.6 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 
       11 
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(86-04-14,Herbst), approve(86-04-14,MCR7377),
       15*     audit(86-04-17,Kissel), install(86-04-22,MR12.0-1041):
       16*     Fixed to apply equal convention correctly to -of argument.
       17*                                                   END HISTORY COMMENTS */
       18 
       19 
       20 /* format: off */
       21 
       22 convert_ec: cvec: proc;
       23 
       24 /* Converts a version 1 exec_com to version 2 */
       25 /* Conversions of note are:	leading/trailing whitespace
       26*				->  &SP, &HT, etc.	V2 ignores leading/trailing white
       27*			&<whitespace>  ->  &-	new comment sequence
       28*			&if [...]  -> &if &[...]	af expansion in control lines
       29*			&&...&  ->  &&&&...&&	double strings of 2 or more &'s
       30*			&(...)  ->  &&(...)		do command kludge
       31*			&0  ->  &ec_path		&0 is obsolete in V2
       32*			&NN     ->  &(NN)		2 or more digit params
       33*			&command_line  ->  &trace &command
       34*			&comment_line  ->  &trace &comment
       35*			&control_line  -> &trace &control
       36*			&input_line  ->  &trace &input
       37*			&unknown (beginning of line)  ->  comment line  (causes warning unless -bf)
       38*			&unknown -> &&unknown	(causes warning unless -bf)
       39*/* Written 12/08/80 S. Herbst */
       40 /* Converted to final MCR'd version 05/13/81 */
       41 /* Changed to accept .absin suffix explicitly 12/17/81 S. Herbst */
       42 /* Fixed to restore original if replacement is interrupted 01/03/84 S. Herbst */
       43 
       44 
       45 /* Constants */
       46 
       47 dcl KEYWORDS_STRING char (KEYWORDS_LEN) aligned based (addr (KEYWORDS));
       48 dcl ME char (32) int static options (constant) init ("convert_ec");
       49 dcl KEYWORDS (28) char (32) int static options (constant) init
       50 	("&attach", "&command_line", "&comment_line", "&control_line", "&detach",
       51 	 "&ec_dir", "&ec_name", "&ec_switch", "&else", "&f&n",
       52 	 "&goto", "&if", "&input_line", "&is_absin", "&is_active_function",
       53 	 "&is_af", "&is_attached", "&is_input_line", "&label", "&n",
       54 	 "&print", "&q&n", "&quit", "&r&n", "&ready",
       55 	 "&ready_proc", "&return", "&then");
       56 
       57 dcl DIGITS char (10) int static options (constant) init ("0123456789");
       58 dcl ALPHABET char (27) int static options (constant) init ("abcdefghijklmnopqrstuvwxyz_");
       59 dcl (BRANCHES init (2), BRANCHES_AND_LINKS init (3)) fixed (2) int static options (constant);
       60 dcl WHITE char (4) int static options (constant) init (" 	");  /* SP HT VT FF */
       61 dcl SP char (1) int static options (constant) init (" ");
       62 dcl NL char (1) int static options (constant) init ("
       63 ");
       64 
       65 dcl PREFIXES (10) char (8) varying int static options (constant) init
       66 	("q", "r", "f", "qf", "rf", "q&n", "r&n", "f&n", "qf&n", "rf&n");
       67 
       68 dcl TAKES_ARG (10) bit (1) int static options (constant) init
       69 	("1"b, "1"b, "1"b, "1"b, "1"b, "0"b, "0"b, "0"b, "0"b, "0"b);
       70 
       71 /* Based */
       72 
       73 dcl arg char (arg_len) based (arg_ptr);
       74 
       75 
       76 /* Automatic */
       77 
       78 dcl (dn1, dn2, temp_dn) char (168);
       79 dcl (en1, en2, suffix, temp_en) char (32);
       80 
       81 dcl (absin_sw, begin_line_sw, chase_sw, check_sw, force_sw, got_path1_sw, got_path2_sw, star_sw) bit (1);
       82 
       83 dcl arg_ptr ptr;
       84 
       85 dcl KEYWORDS_LEN fixed;
       86 dcl (arg_count, i, severity) fixed;
       87 dcl star_select fixed (2);
       88 dcl arg_len fixed (21);
       89 dcl code fixed (35);
       90 
       91 dcl error_table_$action_not_performed fixed (35) ext;
       92 dcl error_table_$badopt fixed (35) ext;
       93 dcl error_table_$namedup fixed bin (35) ext;
       94 dcl error_table_$segknown fixed (35) ext;
       95 dcl error_table_$segnamedup fixed (35) ext;
       96 
       97 dcl iox_$error_output ptr ext;
       98 
       99 dcl (com_err_, com_err_$suppress_name) entry options (variable);
      100 dcl check_star_name_$entry entry (char (*), fixed (35));
      101 dcl cu_$arg_count entry (fixed, fixed (35));
      102 dcl cu_$arg_ptr entry (fixed, ptr, fixed (21), fixed (35));
      103 dcl cv_dec_check_ entry (char (*), fixed (35)) returns (fixed);
      104 dcl delete_$ptr entry (ptr, bit (6), char (*), fixed bin (35));
      105 dcl expand_pathname_ entry (char (*), char (*), char (*), fixed (35));
      106 dcl expand_pathname_$add_suffix entry (char (*), char (*), char (*), char (*), fixed (35));
      107 dcl get_equal_name_ entry (char (*), char (*), char (*), fixed (35));
      108 dcl get_pdir_ entry returns (char (168));
      109 dcl get_system_free_area_ entry returns (ptr);
      110 dcl get_temp_segment_ entry (char (*), ptr, fixed (35));
      111 dcl hcs_$chname_seg entry (ptr, char (*), char (*), fixed (35));
      112 dcl hcs_$delentry_seg entry (ptr, fixed bin (35));
      113 dcl hcs_$fs_get_path_name entry (ptr, char (*), fixed, char (*), fixed (35));
      114 dcl hcs_$initiate_count entry (char (*), char (*), char (*), fixed (24), fixed (2), ptr, fixed (35));
      115 dcl hcs_$make_seg entry (char (*), char (*), char (*), fixed (5), ptr, fixed (35));
      116 dcl hcs_$set_bc_seg entry (ptr, fixed (24), fixed (35));
      117 dcl hcs_$star_ entry (char (*), char (*), fixed (2), ptr, fixed, ptr, ptr, fixed (35));
      118 dcl hcs_$terminate_noname entry (ptr, fixed (35));
      119 dcl ioa_$ioa_switch entry options (variable);
      120 dcl ioa_$rsnnl entry options (variable);
      121 dcl nd_handler_ entry (char (*), char (*), char (*), fixed (35));
      122 dcl pathname_ entry (char(*), char(*)) returns(char(168));
      123 dcl release_temp_segment_ entry (char (*), ptr, fixed (35));
      124 
      125 dcl (addr, copy, divide, hbound, fixed, index, length, null, rtrim, reverse, search, substr, verify) builtin;
      126 
      127 dcl cleanup condition;
      128 
      129 	KEYWORDS_LEN = length (KEYWORDS (1)) * hbound (KEYWORDS, 1);
      130 
      131 	call cu_$arg_count (arg_count, code);
      132 	if code ^= 0 then do;
      133 	     call com_err_ (code, ME);
      134 	     return;
      135 	end;
      136 
      137 /* Read control args */
      138 
      139 	chase_sw, check_sw, force_sw = "0"b;
      140 	got_path1_sw, got_path2_sw = "0"b;
      141 	severity = 2;
      142 
      143 	do i = 1 to arg_count;
      144 
      145 	     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
      146 
      147 	     if index (arg, "-") = 1 then
      148 		if arg = "-chase" then chase_sw = "1"b;
      149 		else if arg = "-check" | arg = "-ck" then check_sw = "1"b;
      150 		else if arg = "-force" | arg = "-fc" then force_sw = "1"b;
      151 		else if arg = "-no_chase" then chase_sw = "0"b;
      152 		else if arg = "-no_check" | arg = "-nck" then check_sw = "0"b;
      153 		else if arg = "-no_force" | arg = "-nfc" then force_sw = "0"b;
      154 
      155 		else if arg = "-output_file" | arg = "-of" then do;
      156 		     i = i + 1;
      157 		     if i > arg_count then do;
      158 			call com_err_ (0, ME, "No value specified for -output_file");
      159 			return;
      160 		     end;
      161 		     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
      162 
      163 		     call expand_pathname_ (arg, dn2, en2, code);
      164 		     if code ^= 0 then do;
      165 ARG_ERR:			call com_err_ (code, ME, "^a", arg);
      166 			return;
      167 		     end;
      168 		     got_path2_sw = "1"b;
      169 		end;
      170 
      171 		else if arg = "-severity" | arg = "-sv" then do;
      172 		     i = i + 1;
      173 		     if i > arg_count then do;
      174 			call com_err_ (0, ME, "No value specified for -severity");
      175 			return;
      176 		     end;
      177 		     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
      178 		     severity = cv_dec_check_ (arg, code);
      179 		     if code ^= 0 then go to ARG_ERR;
      180 		end;
      181 
      182 		else do;
      183 		     call com_err_ (error_table_$badopt, ME, "^a", arg);
      184 		     return;
      185 		end;
      186 
      187 	     else if got_path1_sw then do;
      188 USAGE:		call com_err_$suppress_name (0, ME, "Usage:  convert_ec path {-control_args}");
      189 		return;
      190 	     end;
      191 
      192 	     else do;
      193 		suffix = "ec";
      194 		if length (arg) > 6 then
      195 		     if substr (arg, length (arg) - 5, 6) = ".absin" then suffix = "absin";
      196 
      197 		call expand_pathname_$add_suffix (arg, suffix, dn1, en1, code);
      198 		if code ^= 0 then go to ARG_ERR;
      199 
      200 		call check_star_name_$entry (en1, code);
      201 		if code ^= 0 then
      202 		     if code = 1 | code = 2 then star_sw = "1"b;
      203 		     else do;
      204 			call com_err_ (code, ME, "^a", pathname_ (dn2, en2));
      205 			return;
      206 		     end;
      207 		else star_sw = "0"b;
      208 
      209 		got_path1_sw = "1"b;
      210 	     end;
      211 	end;
      212 
      213 	if ^got_path1_sw then go to USAGE;
      214 
      215 	if got_path2_sw then
      216 
      217 	     if star_sw then call convert_stars (dn1, en1, dn2, en2);
      218 
      219 	     else call convert_one (dn1, en1, dn2, en2);
      220 
      221 	else if star_sw then call convert_stars (dn1, en1, dn1, "===");
      222 
      223 	else call convert_one (dn1, en1, dn1, en1);
      224 
      225 RETURN:	return;
      226 
      227 convert_stars: proc (P_dn1, P_en1, P_dn2, P_en2);
      228 
      229 dcl (P_dn1, P_en1, P_dn2, P_en2) char (*);
      230 dcl 1 entries (entry_count) aligned based (entries_ptr),
      231    2 pad bit (18) unaligned,
      232    2 nindex bit (18) unaligned;
      233 dcl names (999) char (32) based (names_ptr);
      234 dcl area area based (area_ptr);
      235 dcl (area_ptr, entries_ptr, names_ptr) ptr;
      236 dcl (entry_count, j) fixed;
      237 
      238 	area_ptr = get_system_free_area_ ();
      239 	entries_ptr, names_ptr = null;
      240 
      241 	if chase_sw then star_select = BRANCHES_AND_LINKS;
      242 	else star_select = BRANCHES;
      243 
      244 	on cleanup call star_cleanup;
      245 
      246 	call hcs_$star_ (P_dn1, P_en1, star_select, area_ptr, entry_count, entries_ptr, names_ptr, code);
      247 	if code ^= 0 then do;
      248 	     call com_err_ (code, ME, "^a^[>^]^a", P_dn1, P_dn1 ^= ">", P_en1);
      249 	     return;
      250 	end;
      251 
      252 	do j = 1 to entry_count;
      253 
      254 	     call convert_one (P_dn1, names_ptr -> names (fixed (entries_ptr -> entries (j).nindex)), P_dn2, P_en2);
      255 	end;
      256 
      257 	call star_cleanup;
      258 
      259 	return;
      260 
      261 star_cleanup: proc;
      262 
      263 	if entries_ptr ^= null then free entries in (area);
      264 	if names_ptr ^= null then free names in (area);
      265 
      266 end star_cleanup;
      267 
      268 end convert_stars;
      269 
      270 convert_one: proc (P_dn1, P_en1, P_dn2, P_en2);
      271 
      272 dcl (P_dn1, P_en1, P_dn2, P_en2) char (*);
      273 dcl seg1 char (len1) based (ptr1);
      274 dcl seg2 char (len2) based (ptr2);
      275 dcl (digit_str, target_en) char (32);
      276 dcl keyword_name char (32) varying;
      277 dcl next_char char (1);
      278 dcl (errors_sw, found_sw, replacing_orig_sw) bit (1);
      279 dcl (ptr1, ptr2, safe_copy_ptr, target_ptr) ptr;
      280 dcl bit_count fixed (24);
      281 dcl (len1, len2, pos1) fixed (21);
      282 dcl (i, line_number) fixed;
      283 dcl (code, safe_copy_code) fixed (35);
      284 
      285 	call get_equal_name_ (P_en1, P_en2, target_en, code);
      286 	if code ^= 0 then do;
      287 	     call com_err_ (code, ME, "^a for ^a", P_en2, P_en1);
      288 	     go to RETURN;
      289 	end;
      290 
      291 /* Add suffix if necessary to target entry name */
      292 
      293 	call expand_pathname_$add_suffix (target_en, suffix, (""), target_en, code);
      294 	if code ^= 0 then do;
      295 	     call com_err_ (code, ME, "^a", target_en);
      296 	     go to RETURN;
      297 	end;
      298 
      299 	ptr1, ptr2, safe_copy_ptr, target_ptr = null;
      300 	replacing_orig_sw = "0"b;
      301 
      302 	on cleanup call clean_up;
      303 
      304 	call hcs_$initiate_count (P_dn1, P_en1, "", bit_count, 0, ptr1, code);
      305 	if ptr1 = null then do;
      306 	     call com_err_ (code, ME, "^a", pathname_ (P_dn1, P_en1));
      307 	     return;
      308 	end;
      309 
      310 RETRY:	if ^check_sw then do;
      311 	     call hcs_$make_seg (P_dn2, target_en, "", 01010b, target_ptr, code);
      312 	     if target_ptr = null then do;
      313 		call com_err_ (code, ME, "^a", pathname_ (P_dn2, target_en));
      314 		go to RETURN;
      315 	     end;
      316 	     else if (code = error_table_$namedup | code = error_table_$segknown) & target_ptr ^= ptr1 then do;
      317 		call nd_handler_ (ME, dn2, target_en, code);
      318 		if code = error_table_$action_not_performed then return;
      319 		else go to RETRY;
      320 	     end;
      321 	end;
      322 
      323 	len1 = divide (bit_count, 9, 21, 0);
      324 	line_number = 1;
      325 	pos1 = verify (seg1, WHITE);
      326 
      327 	len2 = 0;
      328 
      329 	if substr (seg1, pos1, 8) = "&version" then do;
      330 	     pos1 = pos1 + 8;
      331 	     if substr (seg1, pos1, 1) ^= SP then do;
      332 BAD_VERSION:	call com_err_ (0, ME, "Invalid &version statement on first line.");
      333 CLEANUP_TARGET:	if target_ptr ^= null & target_ptr ^= ptr1 then call hcs_$delentry_seg (target_ptr, code);
      334 		go to RETURN;
      335 	     end;
      336 
      337 	     i = verify (substr (seg1, pos1), WHITE);
      338 	     if i = 0 then go to BAD_VERSION;
      339 	     pos1 = pos1 + i - 1;
      340 	     if substr (seg1, pos1, 1) = NL then go to BAD_VERSION;  /* no number */
      341 	     if index (WHITE || NL, substr (seg1, pos1 + 1, 1)) = 0 then go to BAD_VERSION;  /* not 1 char */
      342 
      343 	     if substr (seg1, pos1, 1) = "2" then do;
      344 		call com_err_ (0, ME, "Segment is already version 2.  ^a",
      345 		     pathname_ (P_dn1, P_dn2));
      346 		go to CLEANUP_TARGET;
      347 	     end;
      348 	     else if substr (seg1, pos1, 1) ^= "1" then go to BAD_VERSION;
      349 
      350 	     pos1 = pos1 + verify (substr (seg1, pos1 + 1), WHITE || NL);  /* skip the &version stmt */
      351 	end;
      352 	else pos1 = 1;				/* if no &version 1, don't strip leading white space */
      353 
      354 	if ^check_sw then do;
      355 	     call get_temp_segment_ (ME, ptr2, code);
      356 	     if code ^= 0 then do;
      357 		call com_err_ (code, ME, "Temp segment.");
      358 		go to CLEANUP_TARGET;
      359 	     end;
      360 	end;
      361 
      362 	call output ("&version 2" || NL);
      363 
      364 /* Convert the segment */
      365 
      366 	errors_sw = "0"b;
      367 
      368 	i = verify (seg1, WHITE);			/* look for initial leading whitespace */
      369 	if i > 1 then do;
      370 
      371 	     call convert_white (substr (seg1, 1, i - 1));
      372 
      373 	     pos1 = i;
      374 	end;
      375 
      376 	do while (pos1 <= len1);
      377 
      378 	     i = search (substr (seg1, pos1), "&" || NL);
      379 
      380 	     if i = 0 then do;
      381 
      382 		if index (WHITE, substr (seg1, len1, 1)) ^= 0 then
      383 
      384 		     call convert_trailing_white (substr (seg1, pos1));
      385 
      386 		else call output (substr (seg1, pos1));
      387 
      388 		go to COPY_SEG;
      389 	     end;
      390 
      391 	     if substr (seg1, pos1 + i - 1, 1) = NL then do;  /* NL */
      392 		if i > 1 then			/* some text in between */
      393 		     if index (WHITE, substr (seg1, pos1 + i - 2, 1)) ^= 0 then
      394 
      395 			call convert_trailing_white (substr (seg1, pos1, i - 1));
      396 
      397 		     else call output (substr (seg1, pos1, i - 1));
      398 
      399 		call output (NL);
      400 
      401 		line_number = line_number + 1;
      402 		pos1 = pos1 + i;			/* position past the NL */
      403 		i = verify (substr (seg1, pos1), WHITE);  /* look for leading whitespace */
      404 		if i > 1 then do;
      405 
      406 		     call convert_white (substr (seg1, pos1, i - 1));
      407 
      408 		     pos1 = pos1 + i - 1;
      409 		end;
      410 
      411 		go to NEXT;
      412 	     end;
      413 
      414 /*  &  */
      415 	     if i > 1 then call output (substr (seg1, pos1, i - 1));  /* copy up to the & */
      416 
      417 	     pos1 = pos1 + i - 1;			/* position of the & */
      418 
      419 	     if pos1 = len1 | index (WHITE || NL, substr (seg1, pos1 + 1, 1)) ^= 0 then do;  /* comment */
      420 		i = index (substr (seg1, pos1), NL);  /* take whole comment line */
      421 		if i = 0 then do;
      422 		     call warn (3, "Segment does not end in newline.");
      423 
      424 		     if pos1 = len1 then call output ("&-");
      425 
      426 		     else call output ("&-" || substr (seg1, pos1 + 1));
      427 
      428 		     go to COPY_SEG;
      429 		end;
      430 		else if pos1 = 1 then do;
      431 
      432 GOOD_COMMENT:	     call output ("&-" || substr (seg1, pos1 + 1, i - 1));
      433 
      434 		     line_number = line_number + 1;
      435 		     pos1 = pos1 + i;
      436 		end;
      437 		else if substr (seg1, pos1 - 1, 1) = NL then go to GOOD_COMMENT;
      438 		else do;
      439 		     call warn (1, "&<SP> does not begin line; converted to &&<SP>");
      440 
      441 		     call output ("&& ");
      442 
      443 		     pos1 = pos1 + 2;
      444 		end;
      445 	     end;
      446 
      447 	     else if substr (seg1, pos1 + 1, 1) = "&" then do;  /* double 2 or more &'s */
      448 		i = verify (substr (seg1, pos1), "&") - 1;
      449 		if i = -1 then i = len1 - pos1 + 1;
      450 
      451 		call output (copy ("&", i * 2));
      452 
      453 		pos1 = pos1 + i;
      454 	     end;
      455 
      456 	     else do;				/* &keyword */
      457 
      458 		if substr (seg1, pos1 + 1, 1) = "(" then do;  /* the do command kludge */
      459 						/* change &(1) -> &&(1) */
      460 		     call output ("&" || substr (seg1, pos1, 2));
      461 
      462 		     pos1 = pos1 + 2;
      463 		end;
      464 
      465 		else do;
      466 
      467 		     if pos1 = 1 then begin_line_sw = "1"b;
      468 		     else if substr (seg1, pos1 - 1, 1) = NL then begin_line_sw = "1"b;
      469 		     else begin_line_sw = "0"b;
      470 
      471 		     pos1 = pos1 + 1;
      472 		     next_char = substr (seg1, pos1, 1);
      473 
      474 		     if index (DIGITS, next_char) ^= 0 then do;  /* &1 parameter */
      475 
      476 			call output ("&");
      477 
      478 PARAM:			i = verify (substr (seg1, pos1), DIGITS);
      479 			if i = 0 then do;
      480 			     call warn (3, "Segment does not end in newline.");
      481 			     digit_str = substr (seg1, pos1);
      482 			end;
      483 			else digit_str = substr (seg1, pos1, i - 1);
      484 
      485 			if length (rtrim (digit_str)) = 1 then
      486 
      487 			     if digit_str = "0" then call output ("ec_path");
      488 
      489 			     else call output (rtrim (digit_str));
      490 
      491 			else call output ("(" || rtrim (digit_str) || ")");  /* &12 -> &(12) */
      492 
      493 			pos1 = pos1 + length (rtrim (digit_str));
      494 		     end;
      495 
      496 		     else do;			/* some &keyword */
      497 
      498 			if index ("fqr", next_char) ^= 0 then do;  /* might be &r, &q, &f something */
      499 
      500 			     do i = hbound (PREFIXES, 1) by -1 to 1
      501 				while (index (substr (seg1, pos1), PREFIXES (i)) ^= 1); end;
      502 
      503 			     if i ^= 0 then do;	/* it is */
      504 				if TAKES_ARG (i) then do;
      505 				     if pos1 < len1 &
      506 				       index (DIGITS, substr (seg1, pos1 + length (PREFIXES (i)), 1)) ^= 0 then do;
      507 
      508 					call output ("&" || PREFIXES (i));
      509 
      510 					pos1 = pos1 + length (PREFIXES (i));
      511 					go to PARAM;
      512 				     end;
      513 				end;
      514 
      515 				else do;		/* &f&n, &r&n, &q&n, &rf&n, &qf&n */
      516 
      517 				     call output ("&" || PREFIXES (i));
      518 
      519 				     pos1 = pos1 + length (PREFIXES (i));
      520 				     go to NEXT;
      521 				end;
      522 			     end;
      523 			end;
      524 
      525 			keyword_name = "&";
      526 			found_sw = "0"b;
      527 
      528 			do while (^found_sw);
      529 
      530 			     keyword_name = keyword_name || next_char;
      531 			     pos1 = pos1 + 1;
      532 
      533 			     if known (keyword_name) then do;
      534 
      535 				found_sw = "1"b;
      536 
      537 				if keyword_name = "&command_line" then call output ("&trace &command");
      538 				else if keyword_name = "&input_line" then call output ("&trace &input");
      539 				else if keyword_name = "&comment_line" then call output ("&trace &comment");
      540 				else if keyword_name = "&control_line" then call output ("&trace &control");
      541 
      542 				else do;
      543 
      544 				     call output ((keyword_name));
      545 
      546 				     if keyword_name = "&if" then do;  /* &if [ -> &if &[ */
      547 					pos1 = pos1 + verify (substr (seg1, pos1), WHITE) - 1;
      548 					if substr (seg1, pos1, 1) = "[" then do;
      549 					     pos1 = pos1 + 1;
      550 
      551 					     call output (" &[");
      552 					end;
      553 
      554 					else call output (" ");
      555 				     end;
      556 
      557 				     else if keyword_name = "&print" then do;  /* look for &print ^-^/^x etc. */
      558 					i = index (substr (seg1, pos1), NL);
      559 					if i = 0 then i = len1 - pos1 + 1;
      560 					if index (substr (seg1, pos1, i), "^") ^= 0 then
      561 					     call warn (3, "ioa_ controls in &print statement:  "
      562 						|| rtrim (substr (seg1, pos1 + 1, i - 1), NL) || NL
      563 						|| "Should be replaced by literals such as &SP");
      564 				     end;
      565 				end;
      566 			     end;
      567 
      568 			     else do;
      569 				if pos1 > len1 | index (ALPHABET, substr (seg1, pos1, 1)) = 0 then do;
      570 
      571 				     found_sw = "1"b;  /* stop the loop */
      572 
      573 				     if begin_line_sw then do; /* &word  begins line; convert line to comment */
      574 					call warn (2, "Invalid stmt " || keyword_name ||
      575 					     " converted to comment.");
      576 					i = index (substr (seg1, pos1), NL);
      577 					if i = 0 then call output ("&-" || keyword_name || substr (seg1, pos1));
      578 
      579 					else do;
      580 
      581 					     call output ("&-" || keyword_name || substr (seg1, pos1, i - 1));
      582 
      583 					     pos1 = pos1 + i - 1;  /* skip to NL at end of line */
      584 					end;
      585 				     end;
      586 				     else do;
      587 					call warn (1, "Invalid keyword " || keyword_name
      588 					     || " converted to literal string.");
      589 
      590 					call output ("&" || keyword_name);  /* convert to literal &&string */
      591 				     end;
      592 				end;
      593 
      594 				else next_char = substr (seg1, pos1, 1);
      595 			     end;
      596 			end;
      597 		     end;
      598 		end;
      599 	     end;
      600 NEXT:	end;
      601 
      602 COPY_SEG:
      603 	if ^check_sw then do;			/* write the converted seg */
      604 
      605 	     if errors_sw & ^force_sw then do;
      606 		call hcs_$set_bc_seg (ptr2, len2 * 9, 0);
      607 
      608 		call hcs_$fs_get_path_name (ptr2, temp_dn, 0, temp_en, code);
      609 		if code ^= 0 then do;
      610 		     temp_dn = get_pdir_ ();
      611 		     go to TERMINATE;
      612 		end;
      613 
      614 RENAME_TEMP:	call hcs_$chname_seg (ptr2, temp_en, target_en, code);
      615 		if code ^= 0 then do;
      616 		     if code = error_table_$namedup | code = error_table_$segnamedup then do;
      617 			call com_err_ (0, ME, "Errors found.");
      618 			call nd_handler_ (ME, temp_dn, target_en, code);
      619 			if code = 0 then go to RENAME_TEMP;
      620 			if code = error_table_$action_not_performed then go to DELETE_OFILE;
      621 		     end;
      622 		     call com_err_ (code, ME, "Errors found; unable to rename temp copy in ^[^a^;[pd]^]",
      623 			temp_dn ^= get_pdir_ (), temp_dn);
      624 		end;
      625 		else do;
      626 TERMINATE:	     call hcs_$terminate_noname (ptr2, code);
      627 		     ptr2 = null;			/* so release_temp_segments_ doesn't get it */
      628 
      629 		     call com_err_ (code, ME, "Errors found; look for copy ^[^a;^s[pd]>^a^]",
      630 			temp_dn ^= get_pdir_ (), pathname_ (temp_dn, temp_en), temp_en);
      631 		end;
      632 
      633 DELETE_OFILE:	if target_ptr ^= null & target_ptr ^= ptr1 then do;
      634 		     call delete_$ptr (target_ptr, "000100"b, ME, 0);
      635 		     target_ptr = null;
      636 		end;
      637 	     end;
      638 
      639 	     else do;
      640 		call get_temp_segment_ (ME, safe_copy_ptr, safe_copy_code);  /* keep copy of orig */
      641 		if code = 0 then safe_copy_ptr -> seg1 = ptr1 -> seg1;  /* in case replacement is interrupted */
      642 		else safe_copy_ptr = null;
      643 
      644 		replacing_orig_sw = "1"b;
      645 
      646 		target_ptr -> seg2 = ptr2 -> seg2;
      647 
      648 		call hcs_$set_bc_seg (target_ptr, len2 * 9, code);
      649 	     end;
      650 	end;
      651 
      652 	call finish_up;
      653 
      654 	return;
      655 
      656 convert_trailing_white: proc (P_str);
      657 
      658 /* Outputs up to the trailing whitespace, then outputs
      659*   literals instead of the trailing whitespace */
      660 
      661 dcl P_str char (*);
      662 dcl white_len fixed;
      663 
      664 	if length (P_str) = 0 then return;
      665 
      666 	white_len = verify (reverse (P_str), WHITE) - 1;
      667 	if white_len = -1 then white_len = length (P_str);
      668 
      669 	call output (substr (P_str, 1, length (P_str) - white_len));
      670 
      671 	call convert_white (substr (P_str, length (P_str) - white_len + 1));
      672 
      673 end convert_trailing_white;
      674 
      675 convert_white: proc (P_str);
      676 
      677 /* P_str is all whitespace; output as literals */
      678 
      679 dcl P_str char (*);
      680 dcl LITERAL (4) char (2) int static options (constant) init ("SP", "HT", "VT", "FF");
      681 dcl literal_string char (32) varying;
      682 dcl (count, i, type, type2) fixed;
      683 
      684 	if length (P_str) = 0 then return;
      685 
      686 	type = index (WHITE, substr (P_str, 1, 1));
      687 	count = 1;
      688 
      689 	do i = 2 to length (P_str);
      690 
      691 	     type2 = index (WHITE, substr (P_str, i, 1));
      692 
      693 	     if type2 = type then count = count + 1;
      694 	     else do;
      695 ADD_LITERAL:	call ioa_$rsnnl ("&^a(^d)", literal_string, length (literal_string),
      696 		     LITERAL (type), count);
      697 
      698 		call output ((literal_string));
      699 
      700 		type = type2;
      701 		count = 1;
      702 		if i >= length (P_str) then return;
      703 	     end;
      704 	end;
      705 
      706 	go to ADD_LITERAL;
      707 
      708 end convert_white;
      709 
      710 clean_up: proc;
      711 
      712 	if target_ptr ^= null & target_ptr ^= ptr1 then do;
      713 	     call delete_$ptr (target_ptr, "000100"b, ME, 0);
      714 	     target_ptr = null;
      715 	end;
      716 	if replacing_orig_sw then
      717 	     if safe_copy_ptr = null then
      718 		call com_err_ (safe_copy_code, ME, "Unable to get temp seg; can't restore original.");
      719 	     else ptr1 -> seg1 = safe_copy_ptr -> seg1;
      720 	call finish_up ();
      721 
      722 end clean_up;
      723 
      724 
      725 finish_up: proc;
      726 
      727 	if ptr1 ^= null then call hcs_$terminate_noname (ptr1, 0);
      728 	if ptr2 ^= null then call release_temp_segment_ (ME, ptr2, 0);
      729 	if safe_copy_ptr ^= null then call release_temp_segment_ (ME, safe_copy_ptr, 0);
      730 	if target_ptr ^= null then call hcs_$terminate_noname (target_ptr, 0);
      731 	ptr1, ptr2, safe_copy_ptr, target_ptr = null;
      732 	replacing_orig_sw = "0"b;
      733 
      734 end finish_up;
      735 
      736 
      737 output: proc (P_str);
      738 
      739 dcl P_str char (*);
      740 dcl i fixed;
      741 
      742 	if check_sw then return;
      743 	i = length (P_str);
      744 	len2 = len2 + i;
      745 	substr (seg2, len2 - i + 1) = P_str;
      746 
      747 end output;
      748 
      749 
      750 warn: proc (P_severity, P_str);
      751 
      752 dcl P_severity fixed;
      753 dcl P_str char (*);
      754 
      755 	if P_severity >= 2 then errors_sw = "1"b;
      756 	if P_severity < severity then return;
      757 	call ioa_$ioa_switch (iox_$error_output, "(sv ^d) Line ^d: ^a", P_severity, line_number, P_str);
      758 
      759 end warn;
      760 
      761 end convert_one;
      762 
      763 known: proc (P_keyword) returns (bit (1));
      764 
      765 dcl P_keyword char (*) varying;
      766 dcl i fixed;
      767 
      768 	i = index (KEYWORDS_STRING, P_keyword || " ");
      769 
      770 	return (i > 0);
      771 
      772 end known;
      773 
      774 end convert_ec;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/29/86  0939.6  convert_ec.pl1                    >spec>install>1041>convert_ec.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ALPHABET                        000043 constant        char(27)                 initial unaligned dcl 58 ref 569
BRANCHES                               constant        fixed bin(2,0)           initial dcl 59 ref 242
BRANCHES_AND_LINKS                     constant        fixed bin(2,0)           initial dcl 59 ref 241
DIGITS                          000052 constant        char(10)                 initial unaligned dcl 57 ref 474 478 505
KEYWORDS                        000055 constant        char(32)                 initial array unaligned dcl 49 set ref 129 129 768
KEYWORDS_LEN                    000350 automatic       fixed bin(17,0)          dcl 85 set ref 129* 768
KEYWORDS_STRING                        based           char                     dcl 47 ref 768
LITERAL                         000000 constant        char(2)                  initial array unaligned dcl 680 set ref 695*
ME                              000415 constant        char(32)                 initial unaligned dcl 48 set ref 133* 158* 165* 174*
                                                                                  183* 188* 204* 248* 287* 295* 306* 313* 317* 332*
                                                                                  344* 355* 357* 617* 618* 622* 629* 634* 640* 713*
                                                                                  716* 728* 729*
NL                              000041 constant        char(1)                  initial unaligned dcl 62 set ref 340 341 350 362 378
                                                                                  391 399* 419 420 437 468 558 560 560 576
PREFIXES                        000003 constant        varying char(8)          initial array dcl 65 ref 500 500 505 508 510 517 519
P_dn1                                  parameter       char                     unaligned dcl 229 in procedure "convert_stars" set
                                                                                  ref 227 246* 248* 248 254*
P_dn1                                  parameter       char                     unaligned dcl 272 in procedure "convert_one" set ref
                                                                                  270 304* 306* 306* 344* 344*
P_dn2                                  parameter       char                     unaligned dcl 229 in procedure "convert_stars" set
                                                                                  ref 227 254*
P_dn2                                  parameter       char                     unaligned dcl 272 in procedure "convert_one" set ref
                                                                                  270 311* 313* 313* 344* 344*
P_en1                                  parameter       char                     unaligned dcl 272 in procedure "convert_one" set ref
                                                                                  270 285* 287* 304* 306* 306*
P_en1                                  parameter       char                     unaligned dcl 229 in procedure "convert_stars" set
                                                                                  ref 227 246* 248*
P_en2                                  parameter       char                     unaligned dcl 229 in procedure "convert_stars" set
                                                                                  ref 227 254*
P_en2                                  parameter       char                     unaligned dcl 272 in procedure "convert_one" set ref
                                                                                  270 285* 287*
P_keyword                              parameter       varying char             dcl 765 ref 763 768
P_severity                             parameter       fixed bin(17,0)          dcl 752 set ref 750 755 756 757*
P_str                                  parameter       char                     unaligned dcl 679 in procedure "convert_white" ref
                                                                                  675 684 686 689 691 702
P_str                                  parameter       char                     unaligned dcl 739 in procedure "output" ref 737 743
                                                                                  745
P_str                                  parameter       char                     unaligned dcl 661 in procedure
                                                                                  "convert_trailing_white" ref 656 664 666 667 669
                                                                                  669 669 669 671 671 671 671
P_str                                  parameter       char                     unaligned dcl 753 in procedure "warn" set ref 750
                                                                                  757*
SP                              010214 constant        char(1)                  initial unaligned dcl 61 ref 331
TAKES_ARG                       000002 constant        bit(1)                   initial array unaligned dcl 68 ref 504
WHITE                           000042 constant        char(4)                  initial unaligned dcl 60 ref 325 337 341 350 368 382
                                                                                  392 403 419 547 666 686 691
addr                                                   builtin function         dcl 125 ref 768
area                                   based           area(1024)               dcl 234 ref 263 264
area_ptr                        000100 automatic       pointer                  dcl 235 set ref 238* 246* 263 264
arg                                    based           char                     unaligned dcl 73 set ref 147 147 149 149 150 150 151
                                                                                  152 152 153 153 155 155 163* 165* 171 171 178*
                                                                                  183* 194 194 194 197*
arg_count                       000351 automatic       fixed bin(17,0)          dcl 86 set ref 131* 143 157 173
arg_len                         000355 automatic       fixed bin(21,0)          dcl 88 set ref 145* 147 147 149 149 150 150 151 152
                                                                                  152 153 153 155 155 161* 163 163 165 165 171 171
                                                                                  177* 178 178 183 183 194 194 194 197 197
arg_ptr                         000346 automatic       pointer                  dcl 83 set ref 145* 147 147 149 149 150 150 151 152
                                                                                  152 153 153 155 155 161* 163 165 171 171 177* 178
                                                                                  183 194 194 194 197
begin_line_sw                   000336 automatic       bit(1)                   unaligned dcl 81 set ref 467* 468* 469* 573
bit_count                       000146 automatic       fixed bin(24,0)          dcl 280 set ref 304* 323
chase_sw                        000337 automatic       bit(1)                   unaligned dcl 81 set ref 139* 147* 151* 241
check_star_name_$entry          000030 constant        entry                    external dcl 100 ref 200
check_sw                        000340 automatic       bit(1)                   unaligned dcl 81 set ref 139* 149* 152* 310 354 602
                                                                                  742
cleanup                         000000 stack reference condition                dcl 127 ref 244 302
code                            000154 automatic       fixed bin(35,0)          dcl 283 in procedure "convert_one" set ref 285* 286
                                                                                  287* 293* 294 295* 304* 306* 311* 313* 316 316
                                                                                  317* 318 333* 355* 356 357* 608* 609 614* 615 616
                                                                                  616 618* 619 620 622* 626* 629* 641 648*
code                            000356 automatic       fixed bin(35,0)          dcl 89 in procedure "cvec" set ref 131* 132 133*
                                                                                  145* 161* 163* 164 165* 177* 178* 179 197* 198
                                                                                  200* 201 201 201 204* 246* 247 248*
com_err_                        000024 constant        entry                    external dcl 99 ref 133 158 165 174 183 204 248 287
                                                                                  295 306 313 332 344 357 617 622 629 716
com_err_$suppress_name          000026 constant        entry                    external dcl 99 ref 188
copy                                                   builtin function         dcl 125 ref 451 451
count                           000111 automatic       fixed bin(17,0)          dcl 682 set ref 687* 693* 693 695* 701*
cu_$arg_count                   000032 constant        entry                    external dcl 101 ref 131
cu_$arg_ptr                     000034 constant        entry                    external dcl 102 ref 145 161 177
cv_dec_check_                   000036 constant        entry                    external dcl 103 ref 178
delete_$ptr                     000040 constant        entry                    external dcl 104 ref 634 713
digit_str                       000100 automatic       char(32)                 unaligned dcl 275 set ref 481* 483* 485 485 489 489
                                                                                  491 493
divide                                                 builtin function         dcl 125 ref 323
dn1                             000100 automatic       char(168)                unaligned dcl 78 set ref 197* 215* 219* 221* 221*
                                                                                  223* 223*
dn2                             000152 automatic       char(168)                unaligned dcl 78 set ref 163* 204* 204* 215* 219*
                                                                                  317*
en1                             000276 automatic       char(32)                 unaligned dcl 79 set ref 197* 200* 215* 219* 221*
                                                                                  223* 223*
en2                             000306 automatic       char(32)                 unaligned dcl 79 set ref 163* 204* 204* 215* 219*
entries                                based           structure                array level 1 dcl 230 ref 263
entries_ptr                     000102 automatic       pointer                  dcl 235 set ref 239* 246* 254 263 263
entry_count                     000106 automatic       fixed bin(17,0)          dcl 236 set ref 246* 252 263
error_table_$action_not_performed
                                000010 external static fixed bin(35,0)          dcl 91 ref 318 620
error_table_$badopt             000012 external static fixed bin(35,0)          dcl 92 set ref 183*
error_table_$namedup            000014 external static fixed bin(35,0)          dcl 93 ref 316 616
error_table_$segknown           000016 external static fixed bin(35,0)          dcl 94 ref 316
error_table_$segnamedup         000020 external static fixed bin(35,0)          dcl 95 ref 616
errors_sw                       000132 automatic       bit(1)                   unaligned dcl 278 set ref 366* 605 755*
expand_pathname_                000042 constant        entry                    external dcl 105 ref 163
expand_pathname_$add_suffix     000044 constant        entry                    external dcl 106 ref 197 293
fixed                                                  builtin function         dcl 125 ref 254
force_sw                        000341 automatic       bit(1)                   unaligned dcl 81 set ref 139* 150* 153* 605
found_sw                        000133 automatic       bit(1)                   unaligned dcl 278 set ref 526* 528 535* 571*
get_equal_name_                 000046 constant        entry                    external dcl 107 ref 285
get_pdir_                       000050 constant        entry                    external dcl 108 ref 610 622 629
get_system_free_area_           000052 constant        entry                    external dcl 109 ref 238
get_temp_segment_               000054 constant        entry                    external dcl 110 ref 355 640
got_path1_sw                    000342 automatic       bit(1)                   unaligned dcl 81 set ref 140* 187 209* 213
got_path2_sw                    000343 automatic       bit(1)                   unaligned dcl 81 set ref 140* 168* 215
hbound                                                 builtin function         dcl 125 ref 129 500
hcs_$chname_seg                 000056 constant        entry                    external dcl 111 ref 614
hcs_$delentry_seg               000060 constant        entry                    external dcl 112 ref 333
hcs_$fs_get_path_name           000062 constant        entry                    external dcl 113 ref 608
hcs_$initiate_count             000064 constant        entry                    external dcl 114 ref 304
hcs_$make_seg                   000066 constant        entry                    external dcl 115 ref 311
hcs_$set_bc_seg                 000070 constant        entry                    external dcl 116 ref 606 648
hcs_$star_                      000072 constant        entry                    external dcl 117 ref 246
hcs_$terminate_noname           000074 constant        entry                    external dcl 118 ref 626 727 730
i                               000100 automatic       fixed bin(17,0)          dcl 740 in procedure "output" set ref 743* 744 745
i                               000152 automatic       fixed bin(17,0)          dcl 282 in procedure "convert_one" set ref 337* 338
                                                                                  339 368* 369 371 371 373 378* 380 391 392 392 392
                                                                                  392 397 397 402 403* 404 406 406 408 415 415 415
                                                                                  417 420* 421 432 435 448* 449 449* 451 451 453
                                                                                  478* 479 483 500* 500* 503 504 505 508 510 517 519
                                                                                  558* 559 559* 560 560 576* 577 581 583
i                               000352 automatic       fixed bin(17,0)          dcl 86 in procedure "cvec" set ref 143* 145* 156*
                                                                                  156 157 161* 172* 172 173 177*
i                               000172 automatic       fixed bin(17,0)          dcl 766 in procedure "known" set ref 768* 770
i                               000112 automatic       fixed bin(17,0)          dcl 682 in procedure "convert_white" set ref 689*
                                                                                  691 702*
index                                                  builtin function         dcl 125 ref 147 341 382 392 419 420 474 498 500 505
                                                                                  558 560 569 576 686 691 768
ioa_$ioa_switch                 000076 constant        entry                    external dcl 119 ref 757
ioa_$rsnnl                      000100 constant        entry                    external dcl 120 ref 695
iox_$error_output               000022 external static pointer                  dcl 97 set ref 757*
j                               000107 automatic       fixed bin(17,0)          dcl 236 set ref 252* 254*
keyword_name                    000120 automatic       varying char(32)         dcl 276 set ref 525* 530* 530 533* 537 538 539 540
                                                                                  544 546 557 574 577 581 587 590
len1                            000147 automatic       fixed bin(21,0)          dcl 281 set ref 323* 325 329 331 337 340 341 343 348
                                                                                  350 368 371 371 376 378 382 382 382 382 386 386
                                                                                  391 392 392 392 397 397 403 406 406 415 415 419
                                                                                  419 420 424 426 432 437 447 448 449 458 460 468
                                                                                  472 478 481 483 500 505 505 547 548 558 559 560
                                                                                  560 569 569 576 577 581 594 641 641 719 719
len2                            000150 automatic       fixed bin(21,0)          dcl 281 set ref 327* 606 646 646 648 744* 744 745
                                                                                  745
length                                                 builtin function         dcl 125 ref 129 194 194 485 493 505 510 519 664 667
                                                                                  669 669 671 671 684 689 695 695 702 743
line_number                     000153 automatic       fixed bin(17,0)          dcl 282 set ref 324* 401* 401 434* 434 757*
literal_string                  000100 automatic       varying char(32)         dcl 681 set ref 695* 695 695 698
names                                  based           char(32)                 array unaligned dcl 233 set ref 254* 264
names_ptr                       000104 automatic       pointer                  dcl 235 set ref 239* 246* 254 264 264
nd_handler_                     000102 constant        entry                    external dcl 121 ref 317 618
next_char                       000131 automatic       char(1)                  unaligned dcl 277 set ref 472* 474 498 530 594*
nindex                    0(18)        based           bit(18)                  array level 2 packed unaligned dcl 230 ref 254
null                                                   builtin function         dcl 125 ref 239 263 264 299 305 312 333 627 633 635
                                                                                  642 712 714 716 727 728 729 730 731
pathname_                       000104 constant        entry                    external dcl 122 ref 204 204 306 306 313 313 344 344
                                                                                  629 629
pos1                            000151 automatic       fixed bin(21,0)          dcl 281 set ref 325* 329 330* 330 331 337 339* 339
                                                                                  340 341 343 348 350* 350 350 352* 373* 376 378 382
                                                                                  382 386 386 391 392 392 392 397 397 402* 402 403
                                                                                  406 406 408* 408 415 415 417* 417 419 419 420 424
                                                                                  426 430 432 435* 435 437 443* 443 447 448 449 453*
                                                                                  453 458 460 462* 462 467 468 471* 471 472 478 481
                                                                                  483 493* 493 500 505 505 510* 510 519* 519 531*
                                                                                  531 547* 547 547 548 549* 549 558 559 560 560 569
                                                                                  569 576 577 581 583* 583 594
ptr1                            000136 automatic       pointer                  dcl 279 set ref 299* 304* 305 316 325 329 331 333
                                                                                  337 340 341 343 348 350 368 371 371 378 382 382
                                                                                  382 386 386 391 392 392 392 397 397 403 406 406
                                                                                  415 415 419 420 426 432 437 447 448 458 460 468
                                                                                  472 478 481 483 500 505 547 548 558 560 560 569
                                                                                  576 577 581 594 633 641 712 719 727 727* 731*
ptr2                            000140 automatic       pointer                  dcl 279 set ref 299* 355* 606* 608* 614* 626* 627*
                                                                                  646 728 728* 731* 745
release_temp_segment_           000106 constant        entry                    external dcl 123 ref 728 729
replacing_orig_sw               000134 automatic       bit(1)                   unaligned dcl 278 set ref 300* 644* 716 732*
reverse                                                builtin function         dcl 125 ref 666
rtrim                                                  builtin function         dcl 125 ref 485 489 489 491 493 560
safe_copy_code                  000155 automatic       fixed bin(35,0)          dcl 283 set ref 640* 716*
safe_copy_ptr                   000142 automatic       pointer                  dcl 279 set ref 299* 640* 641 642* 716 719 729 729*
                                                                                  731*
search                                                 builtin function         dcl 125 ref 378
seg1                                   based           char                     unaligned dcl 273 set ref 325 329 331 337 340 341
                                                                                  343 348 350 368 371 371 378 382 382 382 386 386
                                                                                  391 392 392 392 397 397 403 406 406 415 415 419
                                                                                  420 426 432 437 447 448 458 460 468 472 478 481
                                                                                  483 500 505 547 548 558 560 560 569 576 577 581
                                                                                  594 641* 641 719* 719
seg2                                   based           char                     unaligned dcl 274 set ref 646* 646 745*
severity                        000353 automatic       fixed bin(17,0)          dcl 86 set ref 141* 178* 756
star_select                     000354 automatic       fixed bin(2,0)           dcl 87 set ref 241* 242* 246*
star_sw                         000344 automatic       bit(1)                   unaligned dcl 81 set ref 201* 207* 215 221
substr                                                 builtin function         dcl 125 set ref 194 329 331 337 340 341 343 348 350
                                                                                  371 371 378 382 382 382 386 386 391 392 392 392
                                                                                  397 397 403 406 406 415 415 419 420 426 432 437
                                                                                  447 448 458 460 468 472 478 481 483 500 505 547
                                                                                  548 558 560 560 569 576 577 581 594 669 669 671
                                                                                  671 686 691 745*
suffix                          000316 automatic       char(32)                 unaligned dcl 79 set ref 193* 194* 197* 293*
target_en                       000110 automatic       char(32)                 unaligned dcl 275 set ref 285* 293* 293* 295* 311*
                                                                                  313* 313* 317* 614* 618*
target_ptr                      000144 automatic       pointer                  dcl 279 set ref 299* 311* 312 316 333 333 333* 633
                                                                                  633 634* 635* 646 648* 712 712 713* 714* 730 730*
                                                                                  731*
temp_dn                         000224 automatic       char(168)                unaligned dcl 78 set ref 608* 610* 618* 622 622* 629
                                                                                  629* 629*
temp_en                         000326 automatic       char(32)                 unaligned dcl 79 set ref 608* 614* 629* 629* 629*
type                            000113 automatic       fixed bin(17,0)          dcl 682 set ref 686* 693 695 700*
type2                           000114 automatic       fixed bin(17,0)          dcl 682 set ref 691* 693 700
verify                                                 builtin function         dcl 125 ref 325 337 350 368 403 448 478 547 666
white_len                       000100 automatic       fixed bin(17,0)          dcl 662 set ref 666* 667 667* 669 669 671 671

NAME DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
absin_sw                               automatic       bit(1)                   unaligned dcl 81

NAMES DECLARED BY EXPLICIT CONTEXT.
ADD_LITERAL                     007042 constant        label                    dcl 695 ref 706
ARG_ERR                         001400 constant        label                    dcl 165 ref 179 198
BAD_VERSION                     003265 constant        label                    dcl 332 ref 338 340 341 348
CLEANUP_TARGET                  003312 constant        label                    dcl 333 ref 346 358
COPY_SEG                        006120 constant        label                    dcl 602 ref 388 428
DELETE_OFILE                    006512 constant        label                    dcl 633 ref 620
GOOD_COMMENT                    004314 constant        label                    dcl 432 ref 437
NEXT                            006117 constant        label                    dcl 600 ref 411 520
PARAM                           004567 constant        label                    dcl 478 ref 511
RENAME_TEMP                     006214 constant        label                    dcl 614 ref 619
RETRY                           003040 constant        label                    dcl 310 ref 318
RETURN                          002133 constant        label                    dcl 225 set ref 288 296 314 334
TERMINATE                       006402 constant        label                    dcl 626 ref 611
USAGE                           001602 constant        label                    dcl 188 ref 213
clean_up                        007135 constant        entry                    internal dcl 710 ref 302
convert_ec                      001072 constant        entry                    external dcl 22
convert_one                     002463 constant        entry                    internal dcl 270 ref 219 223 254
convert_stars                   002135 constant        entry                    internal dcl 227 ref 215 221
convert_trailing_white          006644 constant        entry                    internal dcl 656 ref 382 392
convert_white                   006756 constant        entry                    internal dcl 675 ref 371 406 671
cvec                            001063 constant        entry                    external dcl 22
finish_up                       007252 constant        entry                    internal dcl 725 ref 652 720
known                           007530 constant        entry                    internal dcl 763 ref 533
output                          007403 constant        entry                    internal dcl 737 ref 362 386 397 399 415 424 426 432
                                                                                  441 451 460 476 485 489 491 508 517 537 538 539
                                                                                  540 544 551 554 577 581 590 669 698
star_cleanup                    002436 constant        entry                    internal dcl 261 ref 244 257
warn                            007445 constant        entry                    internal dcl 750 ref 422 439 480 560 574 587

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     10720       11030   10226       10730
Length     11324   10226       110         260     472           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cvec                                354 external procedure  is an external procedure.  
convert_stars                       124 internal procedure  enables or reverts conditions.  
on unit on line 244                  64 on unit               
star_cleanup                         64 internal procedure  is called by several nonquick procedures.  
convert_one                         252 internal procedure  enables or reverts conditions.  
on unit on line 302                 104 on unit               
convert_trailing_white               79 internal procedure  is called during a stack extension.  
convert_white                       104 internal procedure  is called during a stack extension.  
clean_up                                internal procedure  shares stack frame of on unit on line 302.  
finish_up                            88 internal procedure  is called by several nonquick procedures.  
output                               67 internal procedure  is called during a stack extension.  
warn                                 94 internal procedure  is called during a stack extension.  
known                                   internal procedure  shares stack frame of internal procedure convert_one.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
convert_one              000100 digit_str                   convert_one
                         000110 target_en                   convert_one
                         000120 keyword_name                convert_one
                         000131 next_char                   convert_one
                         000132 errors_sw                   convert_one
                         000133 found_sw                    convert_one
                         000134 replacing_orig_sw           convert_one
                         000136 ptr1                        convert_one
                         000140 ptr2                        convert_one
                         000142 safe_copy_ptr               convert_one
                         000144 target_ptr                  convert_one
                         000146 bit_count                   convert_one
                         000147 len1                        convert_one
                         000150 len2                        convert_one
                         000151 pos1                        convert_one
                         000152 i                           convert_one
                         000153 line_number                 convert_one
                         000154 code                        convert_one
                         000155 safe_copy_code              convert_one
                         000172 i                           known
convert_stars            000100 area_ptr                    convert_stars
                         000102 entries_ptr                 convert_stars
                         000104 names_ptr                   convert_stars
                         000106 entry_count                 convert_stars
                         000107 j                           convert_stars
convert_trailing_white   000100 white_len                   convert_trailing_white
convert_white            000100 literal_string              convert_white
                         000111 count                       convert_white
                         000112 i                           convert_white
                         000113 type                        convert_white
                         000114 type2                       convert_white
cvec                     000100 dn1                         cvec
                         000152 dn2                         cvec
                         000224 temp_dn                     cvec
                         000276 en1                         cvec
                         000306 en2                         cvec
                         000316 suffix                      cvec
                         000326 temp_en                     cvec
                         000336 begin_line_sw               cvec
                         000337 chase_sw                    cvec
                         000340 check_sw                    cvec
                         000341 force_sw                    cvec
                         000342 got_path1_sw                cvec
                         000343 got_path2_sw                cvec
                         000344 star_sw                     cvec
                         000346 arg_ptr                     cvec
                         000350 KEYWORDS_LEN                cvec
                         000351 arg_count                   cvec
                         000352 i                           cvec
                         000353 severity                    cvec
                         000354 star_select                 cvec
                         000355 arg_len                     cvec
                         000356 code                        cvec
output                   000100 i                           output

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_ne_as             alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out
call_int_this_desc  call_int_this       call_int_other_desc call_int_other      return              tra_ext
mpfx2               enable              shorten_stack       ext_entry           int_entry           int_entry_desc
set_cs_eis          index_cs_eis        verify_eis          search_eis          free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
check_star_name_$entry        com_err_                      com_err_$suppress_name        cu_$arg_count
cu_$arg_ptr                   cv_dec_check_                 delete_$ptr                   expand_pathname_
expand_pathname_$add_suffix   get_equal_name_               get_pdir_                     get_system_free_area_
get_temp_segment_             hcs_$chname_seg               hcs_$delentry_seg             hcs_$fs_get_path_name
hcs_$initiate_count           hcs_$make_seg                 hcs_$set_bc_seg               hcs_$star_
hcs_$terminate_noname         ioa_$ioa_switch               ioa_$rsnnl                    nd_handler_
pathname_                     release_temp_segment_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$badopt           error_table_$namedup
error_table_$segknown         error_table_$segnamedup       iox_$error_output




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     22 001062       129 001077       131 001101       132 001111       133 001113       134 001130       139 001131
    140 001134       141 001136       143 001140       145 001147       147 001164       149 001207       150 001222
    151 001235       152 001243       153 001255       155 001267       156 001277       157 001300       158 001303
    159 001330       161 001331       163 001346       164 001376       165 001400       166 001432       168 001433
    169 001435       171 001436       172 001446       173 001447       174 001452       175 001477       177 001500
    178 001515       179 001541       180 001543       183 001544       184 001576       185 001577       187 001600
    188 001602       189 001627       193 001630       194 001633       197 001645       198 001677       200 001701
    201 001716       204 001727       205 001776       206 001777       207 002000       209 002001       211 002003
    213 002005       215 002007       219 002036       221 002061       223 002111       225 002133       227 002134
    238 002167       239 002175       241 002200       242 002206       244 002210       246 002232       247 002300
    248 002303       249 002356       252 002357       254 002367       255 002426       257 002430       259 002434
    261 002435       263 002443       264 002452       266 002461       270 002462       285 002515       286 002542
    287 002544       288 002603       293 002606       294 002636       295 002640       296 002666       299 002671
    300 002676       302 002677       304 002715       305 002761       306 002765       307 003037       310 003040
    311 003043       312 003104       313 003110       314 003162       316 003165       317 003177       318 003223
    323 003230       324 003233       325 003235       327 003251       329 003252       330 003256       331 003260
    332 003265       333 003312       334 003333       337 003336       338 003355       339 003356       340 003361
    341 003365       343 003402       344 003411       346 003465       348 003466       350 003470       351 003501
    352 003502       354 003504       355 003507       356 003530       357 003532       358 003561       362 003562
    366 003600       368 003601       369 003615       371 003617       373 003637       376 003642       378 003645
    380 003666       382 003667       386 003722       388 003743       391 003745       392 003753       397 004013
    399 004036       401 004047       402 004050       403 004052       404 004073       406 004075       408 004116
    411 004123       415 004124       417 004150       419 004155       420 004177       421 004216       422 004217
    424 004240       426 004256       428 004307       430 004311       432 004314       434 004345       435 004347
    436 004351       437 004352       439 004356       441 004377       443 004411       445 004413       447 004414
    448 004417       449 004436       451 004444       453 004464       454 004467       458 004470       460 004472
    462 004512       463 004514       467 004515       468 004524       469 004534       471 004536       472 004537
    474 004544       476 004555       478 004567       479 004610       480 004611       481 004632       482 004644
    483 004645       485 004651       489 004704       491 004723       493 004760       494 004773       498 004774
    500 005005       501 005035       503 005040       504 005042       505 005046       508 005067       510 005115
    511 005122       513 005123       517 005124       519 005154       520 005161       525 005162       526 005166
    528 005167       530 005172       531 005201       533 005202       535 005210       537 005212       538 005236
    539 005262       540 005306       544 005332       546 005352       547 005360       548 005403       549 005407
    551 005410       552 005422       554 005423       555 005435       557 005436       558 005443       559 005463
    560 005470       564 005571       566 005572       569 005573       571 005613       573 005615       574 005620
    576 005663       577 005705       579 005751       581 005752       583 006013       585 006020       587 006021
    590 006064       591 006112       592 006113       594 006114       596 006116       600 006117       602 006120
    605 006123       606 006127       608 006146       609 006201       610 006203       611 006213       614 006214
    615 006241       616 006243       617 006250       618 006277       619 006324       620 006326       622 006331
    624 006401       626 006402       627 006413       629 006415       633 006512       634 006522       635 006552
    637 006554       640 006555       641 006576       642 006607       644 006611       646 006613       648 006621
    652 006636       654 006642       656 006643       664 006657       666 006661       667 006674       669 006700
    671 006722       673 006753       675 006755       684 006771       686 006773       687 007006       689 007010
    691 007023       693 007036       695 007042       698 007101       700 007122       701 007125       702 007127
    704 007132       706 007134       710 007135       712 007136       713 007147       714 007177       716 007202
    719 007235       720 007243       722 007250       725 007251       727 007257       728 007275       729 007324
    730 007353       731 007372       732 007400       734 007401       737 007402       742 007416       743 007422
    744 007423       745 007425       747 007443       750 007444       755 007460       756 007467       757 007474
    759 007527       763 007530       768 007541       770 007570


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
