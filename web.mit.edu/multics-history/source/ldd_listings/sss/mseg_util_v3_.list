	COMPILATION LISTING OF SEGMENT mseg_util_v3_
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-05-05_1831.81_Fri_mdt
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 mseg_util_v3_: proc;
       12 
       13 /* Modified for version 3 message segments by J. Stern, 10/22/74 */
       14 /* Modified to use mseg_error_ by J. Stern, 11/12/75 */
       15 /* Modified 3/77 by Charlie Davis for the installation of version 4 message segments */
       16 
       17 dcl (a_mptr,					/* pointer to the message segment */
       18      prev_tr_ptr,					/* pointer to previous message trailer */
       19      next_tr_ptr,					/* pointer to next message trailer */
       20      prev_in_bucket_ptr,				/* pointer to previous message in hash bucket */
       21      ms_ptr,					/* pointer to message wanted */
       22      ret_ptr init (null),
       23      deletep,					/* pointer to block to be zeroed out */
       24      a_arg_ptr,					/*  pointer to return_arg structure (argument) */
       25      arg_ptr,					/* pointer to return_arg structure (internal) */
       26      t_ptr,					/* scan pointer for returning message */
       27      a_area_ptr,					/* pointer to allocated area */
       28      a_ms_ptr,					/* pointer to updating message */
       29      area_ptr) ptr;
       30 
       31 dcl (read init ("0"b),				/* ON for read or read and delete entry */
       32      incr_read init ("0"b),				/* ON for incremental read entry */
       33      delete init ("0"b),				/* ON for delete or read and delete entry */
       34      update init ("0"b),				/* ON for update entry */
       35      get_count init ("0"b),				/* ON for get_count entry */
       36      mseg_priv,					/* ON if calling process has privileged access */
       37      a_own,					/* ON if reading own message (argument) */
       38      own,						/* ON if reading own message (internal) */
       39      last,					/* ON if message is last in segment */
       40      first,					/* ON if message is first in segment */
       41      search_sw,					/* ON if message id not found for incremental reading */
       42      ms_end) bit (1) aligned;				/* ON when end of message is found */
       43 
       44 dcl  back_in_bucket_offset bit (18) aligned;		/* offset of message one back in hash bucket */
       45 
       46 dcl (tr_offset,					/* offset from beginning of block to trailer */
       47      ms_count,					/* number of messages in segment */
       48      a_count,					/* message count (argument) */
       49      count,					/* message count (internal) */
       50      prev_offset,					/* offset to previous message */
       51      next_offset,					/* offset to next message */
       52      block_size,					/* size of a message block */
       53      blocks_in_message,				/* number of blocks used for message */
       54      copy_size,					/* size of bit copy mask */
       55      delete_size,					/* bit size of block to be zeroed out */
       56      a_ms_len,					/* length of message in block trailer */
       57      ms_len,
       58      found_ms_len,					/* actual message size */
       59      update_len,					/* size of update message */
       60      loc,
       61      bit_off) fixed bin (18);				/* location of allocation bit to be turned off */
       62 
       63 dcl (a_first_or_last,				/* ON if last message wanted (argument) */
       64      first_or_last) bit (1) aligned;			/* ON if last message wanted (internal) */
       65 
       66 dcl (a_dir,					/* direction of incremental search */
       67      dir init ("00"b)) bit (2) aligned;
       68 
       69 dcl (a_ms_id,					/* message ID (argument) */
       70      ms_id) bit (72) aligned;				/* message ID (internal) */
       71 
       72 dcl (authorization,					/* authorization of calling process */
       73      access_class) bit (72) aligned;			/* access class of message segment */
       74 
       75 dcl  privileges bit (36) aligned;			/* privileges of calling process */
       76 dcl 1 based_priv unal based (addr (privileges)) like aim_template.privileges;
       77 
       78 dcl (
       79      alloc_len,					/* length of allocation bit string */
       80      level,					/* user level: 0 = non-own entry, 1 = own entry (internal) */
       81      ms_word_len,					/* length of message in words */
       82      htx,						/* hash table index */
       83      id_len) fixed bin;				/* length of person-project portion of group id */
       84 
       85 dcl (
       86      a_code,					/* error code (argument) */
       87      code						/* error code (internal) */
       88      ) fixed bin (35);
       89 
       90 dcl (addr, addrel, bit, divide, fixed, index, null, ptr, rel, size, substr) builtin;
       91 
       92 dcl (
       93      area,
       94      cleanup
       95      ) condition;
       96 
       97 dcl  area_array area (30) aligned based (area_ptr),	/* for allocating */
       98      ms_word_array (ms_word_len) fixed bin aligned based (ret_ptr);
       99 
      100 dcl (caller_id,					/* id of caller */
      101      ms_sender_id) char (32) aligned;			/* id of message sender */
      102 
      103 dcl  proc_name char (32);				/* procedure name */
      104 dcl  reason char (40);				/* reason why operation failed */
      105 
      106 dcl  bit_copy_mask bit (copy_size) based;		/* bit copy mask */
      107 
      108 dcl  bits (copy_size) bit (1) based unaligned;		/* for resetting copy-to pointer */
      109 
      110 dcl 1 return_args aligned based (arg_ptr),		/* return argument structure */
      111     2 ms_ptr ptr,					/* pointer to message */
      112     2 ms_len fixed bin (18),				/* length of message in bits */
      113     2 sender_id char (32),				/* person-project ID of message sender */
      114     2 level fixed bin,				/* validation level of sender */
      115     2 ms_id bit (72),				/* unique ID of message */
      116     2 sender_authorization bit (72),			/* access authorization of message sender */
      117     2 access_class bit (72);				/* message access class */
      118 
  1     1 /* BEGIN include file mseg_hdr_v3.incl.pl1 */
  1     2 
  1     3 dcl  mptr ptr,					/* pointer to message segment */
  1     4 
  1     5      1 mseg_hdr aligned based (mptr),			/* message segment header format */
  1     6      2 lock bit (36) aligned,				/* standard file system lock */
  1     7      2 mseg_pattern bit (36) aligned,			/* to identify message segments */
  1     8      2 hdr_ms_access_class bit (72) aligned,		/* access class of header message */
  1     9      2 pad (4) fixed bin,
  1    10      2 first_ms_offset bit (18) aligned,		/* offset to first logical message */
  1    11      2 last_ms_offset bit (18) aligned,			/* offset to last logical message */
  1    12      2 alloc_len fixed bin,				/* length of allocation bit string */
  1    13      2 space_left fixed bin,				/* number of empty blocks */
  1    14      2 number_of_messages fixed bin,			/* number of messages in segment */
  1    15      2 block_size fixed bin,				/* message block size */
  1    16      2 switches,
  1    17      3 mip bit (1) unaligned,				/* ON if modification is in progress */
  1    18      3 os bit (1) unaligned,				/* ON if message segment was salvaged */
  1    19      3 ms_in_hdr bit (1) unaligned,			/* ON if there is a message in the header */
  1    20      3 sip bit (1) unaligned,				/* ON if salvage is in progress */
  1    21      3 pad2 bit (32) unaligned,
  1    22      2 version_number fixed bin,
  1    23      2 hdr_ms bit (64 * 36) aligned,			/* space for header message */
  1    24      2 hash_table aligned,				/* message ID hash table */
  1    25      3 last_in_bucket (0:511) bit (18) unaligned,		/* offset of last message in this hash table bucket */
  1    26      2 alloc_bits bit (alloc_len) aligned;		/* allocation bit string */
  1    27 
  1    28 dcl (version_number fixed bin init (3),			/* message segment version number */
  1    29      header_pattern bit (36) aligned init ((18) "01"b))	/* header identification pattern */
  1    30      internal static;
  1    31 
  1    32 /* END include file mseg_hdr_v3.incl.pl1 */
      119 
      120 
  2     1 /* BEGIN Message Block Header include file */
  2     2 
  2     3 dcl  block_ptr ptr,					/* pointer to message block */
  2     4 
  2     5      1 ms_block_hdr aligned based(block_ptr),		/* message block header structure */
  2     6       2 f_offset bit(18) unaligned,			/* offset to next block of message */
  2     7       2 first_block bit(1) unaligned,			/* ON if block is first in message */
  2     8       2 block_count bit(17) unaligned;			/* number of message bits in block */
  2     9 
  2    10 /* END Message Block Header include file */
      121 
      122 
  3     1 /* BEGIN include file ms_block_trailer_v3.incl.pl1 */
  3     2 
  3     3 dcl  tr_ptr ptr,					/* pointer to message block trailer area */
  3     4 
  3     5      1 ms_block_trailer aligned based (tr_ptr),		/* message block trailer structure */
  3     6      2 tr_pattern bit (36) aligned,			/* for identifying beginning of trailer */
  3     7      2 f_offset bit (18) unaligned,			/* offset to next logical message */
  3     8      2 b_offset bit (18) unaligned,			/* offset to previous logical message */
  3     9      2 ms_size bit (18) unaligned,			/* bit count of message */
  3    10      2 back_in_bucket bit (18) unaligned,		/* offset of preceding message in same hash bucket */
  3    11      2 ms_id bit (72) aligned,			/* message id */
  3    12      2 ring_no bit (18) unaligned,			/* validation level */
  3    13      2 pad bit (18) unaligned,
  3    14      2 sender_id char (32) aligned,			/* id of message sender */
  3    15      2 sender_authorization bit (72) aligned,		/* access authorization of message sender */
  3    16      2 access_class bit (72) aligned;			/* access class of this message */
  3    17 
  3    18 dcl  trailer_pattern bit (36) aligned init ((36) "1"b)	/* trailer identification pattern */
  3    19      internal static;
  3    20 
  3    21 /* END include file ms_block_trailer_v3.incl.pl1 */
      123 
      124 
  4     1 /* BEGIN INCLUDE FILE aim_template.incl.pl1 */
  4     2 
  4     3 /* Created 740723 by PG */
  4     4 /* Modified 06/28/78 by C. D. Tavares to add rcp privilege */
  4     5 /* Modified 83-05-10 by E. N. Kitltitz to add communications privilege */
  4     6 
  4     7 /* This structure defines the components of both an access
  4     8*   class and an access authorization as interpreted by the
  4     9*   Access Isolation Mechanism. */
  4    10 
  4    11 
  4    12 dcl  1 aim_template aligned based,			/* authorization/access class template */
  4    13        2 categories bit (36),				/* access categories */
  4    14        2 level fixed bin (17) unaligned,		/* sensitivity level */
  4    15        2 privileges unaligned,			/* special access privileges (in authorization only) */
  4    16         (3 ipc,					/* interprocess communication privilege */
  4    17          3 dir,					/* directory privilege */
  4    18          3 seg,					/* segment privilege */
  4    19          3 soos,					/* security out-of-service privilege */
  4    20          3 ring1,					/* ring 1 access privilege */
  4    21          3 rcp,					/* RCP resource access privilege */
  4    22          3 comm) bit (1),				/* communications cross-AIM privilege */
  4    23          3 pad bit (11);
  4    24 
  4    25 
  4    26 /* END INCLUDE FILE aim_template.incl.pl1 */
      125 
      126 
      127 dcl  error_table_$bad_segment ext fixed bin (35);
      128 dcl  error_table_$ai_restricted ext fixed bin (35);
      129 dcl  error_table_$no_message ext fixed bin (35);
      130 dcl  error_table_$inconsistent ext fixed bin (35);
      131 dcl  error_table_$bigarg ext fixed bin (35);
      132 dcl  error_table_$noalloc ext fixed bin (35);
      133 
      134 dcl  get_group_id_$tag_star ext entry returns (char (32) aligned);
      135 dcl  get_authorization_ ext entry returns (bit (72) aligned);
      136 dcl  get_privileges_ ext entry returns (bit (36) aligned);
      137 dcl  hcs_$get_access_class_seg ext entry (ptr, bit (72) aligned, fixed bin (35));
      138 dcl  mseg_error_v3_ entry options (variable);
      139 dcl  read_allowed_ ext entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
      140 dcl  read_write_allowed_ ext entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
      141 
      142 /*  */
      143 read:	entry (a_mptr, a_area_ptr, a_first_or_last, a_arg_ptr, a_own, a_code);
      144 
      145 	proc_name = "mseg_util_$read";
      146 	first_or_last = a_first_or_last;
      147 	area_ptr = a_area_ptr;
      148 	read = "1"b;
      149 	go to COMMON;
      150 
      151 delete:	entry (a_mptr, a_ms_id, a_own, a_code);
      152 
      153 	proc_name = "mseg_util_$delete";
      154 	ms_id = a_ms_id;
      155 	delete = "1"b;
      156 	go to COMMON;
      157 
      158 read_and_delete: entry (a_mptr, a_area_ptr, a_first_or_last, a_arg_ptr, a_own, a_code);
      159 
      160 	proc_name = "mseg_util_$read_and_delete";
      161 	first_or_last = a_first_or_last;
      162 	area_ptr = a_area_ptr;
      163 	read, delete = "1"b;
      164 	go to COMMON;
      165 
      166 incremental_read: entry (a_mptr, a_area_ptr, a_dir, a_ms_id, a_arg_ptr, a_own, a_code);
      167 
      168 	proc_name = "mseg_util_$incremental_read";
      169 	ms_id = a_ms_id;
      170 	dir = a_dir;
      171 	if dir = "11"b then do;			/* undefined */
      172 	     code = error_table_$inconsistent;
      173 	     go to FIN;
      174 	end;
      175 	area_ptr = a_area_ptr;
      176 	incr_read = "1"b;
      177 	go to COMMON;
      178 
      179 
      180 update:	entry (a_mptr, a_ms_ptr, a_ms_len, a_ms_id, a_own, a_code);
      181 
      182 	proc_name = "mseg_util_$update";
      183 	update = "1"b;
      184 	ms_id = a_ms_id;
      185 	go to COMMON;
      186 
      187 get_count: entry (a_mptr, a_count, a_code);
      188 
      189 	proc_name = "mseg_util_$get_count";
      190 	get_count = "1"b;
      191 	own = "0"b;
      192 	go to COMMON2;
      193 
      194 /*  */
      195 
      196 COMMON:
      197 	own = a_own;
      198 
      199 COMMON2:
      200 	mptr = a_mptr;
      201 	code = 0;
      202 	search_sw = "0"b;
      203 
      204 	ms_count =				/* get number of messages */
      205 	     fixed (mptr -> mseg_hdr.number_of_messages, 18);
      206 
      207 	block_size = fixed (mseg_hdr.block_size, 18);	/* pick out block size from header */
      208 
      209 	tr_offset = block_size - size (ms_block_trailer); /* calculate trailer offset */
      210 
      211 /* See if first or last message wanted */
      212 
      213 	if get_count then go to COUNT;		/* start counting with first message */
      214 
      215 	if read then do;				/* read first or last message */
      216 	     if first_or_last = "1"b			/* last message wanted */
      217 	     then do;
      218 		dir = "10"b;			/* prepare to scan backward */
      219 LAST:		loc = fixed (mptr -> mseg_hdr.last_ms_offset, 18); /* get offset of last message */
      220 	     end;
      221 
      222 	     else do;				/* first message wanted */
      223 COUNT:		dir = "01"b;			/* prepare to scan forward */
      224 FIRST:		loc = fixed (mptr -> mseg_hdr.first_ms_offset, 18); /* get offset of first message */
      225 	     end;
      226 	     if delete then do;
      227 		ms_ptr = ptr (mptr, loc);
      228 		tr_ptr = addrel (ms_ptr, tr_offset);
      229 		ms_id = tr_ptr -> ms_block_trailer.ms_id;
      230 		go to THREAD;
      231 	     end;
      232 	end;
      233 
      234 /* look up message ID in hash table */
      235 
      236 	else do;					/* for incr read, update ; delete */
      237 THREAD:	     htx = fixed (substr (ms_id, 64, 9));	/* hash table index = low 9 bits of message ID */
      238 	     loc = fixed (hash_table.last_in_bucket (htx), 18); /* get loc of last message in bucket */
      239 	     prev_in_bucket_ptr = null;		/* no previous message yet */
      240 
      241 	     do while (loc ^= 0);			/* search bucket for matching message ID */
      242 		ms_ptr = ptr (mptr, loc);		/* get ptr to first block of message */
      243 		if ^ms_ptr -> ms_block_hdr.first_block	/* check if really first block */
      244 		then do;
      245 		     reason = "not first block in hash lookup";
      246 		     go to BAD_SEG;
      247 		end;
      248 		tr_ptr = addrel (ms_ptr, tr_offset);	/* get trailer ptr */
      249 		if tr_ptr -> ms_block_trailer.tr_pattern ^= trailer_pattern /* check pattern */
      250 		then do;
      251 		     reason = "bad trailer pattern in hash lookup";
      252 		     go to BAD_SEG;
      253 		end;
      254 		if tr_ptr -> ms_block_trailer.ms_id = ms_id /* found it */
      255 		then go to FOUND_ID;
      256 		prev_in_bucket_ptr = tr_ptr;		/* remember ptr to this message */
      257 		loc = fixed (tr_ptr -> ms_block_trailer.back_in_bucket, 18); /* go back one in bucket */
      258 	     end;
      259 
      260 	     if incr_read then
      261 		if dir ^= "00"b then do;		/* forward or backward incr read */
      262 		     search_sw = "1"b;		/* search for next message even though this message is gone */
      263 		     if dir = "10"b then go to LAST;	/* search for largest message id < ms_id */
      264 		     else go to FIRST;		/* search for smallest message id > ms_id */
      265 		end;
      266 
      267 	     go to NO_MSG;				/* bucket exhausted */
      268 FOUND_ID:
      269 	end;
      270 
      271 
      272 /* prepare to check access */
      273 
      274 	authorization = get_authorization_ ();		/* get caller's authorization */
      275 	privileges = get_privileges_ ();		/* get caller's privileges */
      276 	mseg_priv = based_priv.ring1;			/* get ring 1 privilege flag */
      277 	if own					/* caller can only reference his own message */
      278 	then do;
      279 	     caller_id = get_group_id_$tag_star ();	/* get caller's goup id */
      280 	     id_len = index (caller_id, ".*");		/* find index of the ".*" tag */
      281 	end;
      282 
      283 /* get_count */
      284 
      285 	if get_count
      286 	then do;
      287 	     if mseg_priv				/* caller has privileged access */
      288 	     then do;
      289 FULL_COUNT:	a_count = ms_count;			/* return full count */
      290 		go to FIN;
      291 	     end;
      292 	     call hcs_$get_access_class_seg (mptr, access_class, code); /* get message seg access class */
      293 	     if code ^= 0 then go to FIN;
      294 	     if read_allowed_ (authorization, access_class) /* caller is authorized to see all messages */
      295 	     then go to FULL_COUNT;			/* return full count */
      296 	     count = 0;				/* initialize count */
      297 	     go to READ;				/* get count of read-accessible messages */
      298 	end;
      299 
      300 /* incremental read */
      301 
      302 	else if search_sw then go to READ;
      303 	else if incr_read
      304 	then do;
      305 	     if own				/* must be caller's own message */
      306 	     then if substr (ms_block_trailer.sender_id, 1, id_len) ^= substr (caller_id, 1, id_len) /* not his own */
      307 		then go to NO_MSG;			/* pretend it doesn't exist */
      308 	     if ^mseg_priv				/* no special access privilege */
      309 	     then if ^read_allowed_ (authorization, tr_ptr -> ms_block_trailer.access_class) /* no read permit */
      310 		then go to NO_MSG;			/* pretend it doesn't exist */
      311 
      312 	     if dir = "10"b				/* previous message wanted */
      313 	     then do;				/* increment message pointer */
      314 		if tr_ptr -> ms_block_trailer.b_offset = "0"b
      315 		then do;				/* error, no previous message */
      316 		     if fixed (mseg_hdr.first_ms_offset, 18) ^= loc
      317 		     then do;
      318 			reason = "bad first offset";
      319 			go to BAD_SEG;
      320 		     end;
      321 NO_MSG:		     code = error_table_$no_message;
      322 		     go to FIN;
      323 		end;
      324 		loc = fixed (tr_ptr -> ms_block_trailer.b_offset, 18);
      325 		go to READ;
      326 	     end;
      327 
      328 	     else if dir = "01"b			/* next message wanted */
      329 	     then do;				/* increment message pointer */
      330 		if tr_ptr -> ms_block_trailer.f_offset = "0"b
      331 		then do;				/* error, no next message */
      332 		     if fixed (mseg_hdr.last_ms_offset, 18) ^= loc
      333 		     then do;
      334 			reason = "bad last offset";
      335 			go to BAD_SEG;
      336 		     end;
      337 		     go to NO_MSG;
      338 		end;
      339 		loc = fixed (tr_ptr -> ms_block_trailer.f_offset, 18);
      340 		go to READ;
      341 	     end;
      342 
      343 	end;
      344 
      345 /* read */
      346 
      347 	else if read
      348 	then do;
      349 READ:	     do while (loc ^= 0);			/* scan for read-accessible message */
      350 		ms_ptr = ptr (mptr, loc);		/* get ptr to first block of message */
      351 		if ^ms_ptr -> ms_block_hdr.first_block	/* check if really first block */
      352 		then do;
      353 		     reason = "not first block";
      354 		     go to BAD_SEG;
      355 		end;
      356 		tr_ptr = addrel (ms_ptr, tr_offset);	/* get trailer ptr */
      357 		if tr_ptr -> ms_block_trailer.tr_pattern ^= trailer_pattern /* check pattern */
      358 		then do;
      359 		     reason = "bad trailer pattern";
      360 		     go to BAD_SEG;
      361 		end;
      362 		if own				/* must be caller's own message */
      363 		then if substr (ms_block_trailer.sender_id, 1, id_len) ^= substr (caller_id, 1, id_len) /* not his own */
      364 		     then go to NEXT;		/* skip it */
      365 		if ^mseg_priv			/* no special access privileges */
      366 		then do;
      367 		     if ^read_allowed_ (authorization, tr_ptr -> ms_block_trailer.access_class) /* no read permit */
      368 		     then go to NEXT;		/* skip over this one */
      369 		     if delete			/* read and delete requested */
      370 		     then if ^read_write_allowed_ (authorization, tr_ptr -> ms_block_trailer.access_class)
      371 			then go to AI_ERR;		/* cannot delete this message */
      372 		end;
      373 		if get_count			/* get_count entry */
      374 		then count = count + 1;		/* increment count of read-accessible messages */
      375 		else if search_sw
      376 		then if dir = "01"b
      377 		     then if substr (tr_ptr -> ms_block_trailer.ms_id, 19, 54) > substr (ms_id, 19, 54)
      378 			then go to EXIT;		/* found the one we're searching for */
      379 			else go to NEXT;
      380 		     else if substr (tr_ptr -> ms_block_trailer.ms_id, 19, 54) < substr (ms_id, 19, 54)
      381 		     then go to EXIT;		/* found it */
      382 		     else go to NEXT;
      383 		else go to EXIT;			/* found a message to read, exit loop */
      384 NEXT:
      385 		if dir = "01"b			/* scanning forward */
      386 		then loc = fixed (tr_ptr -> ms_block_trailer.f_offset, 18); /* get loc of next message */
      387 		else loc = fixed (tr_ptr -> ms_block_trailer.b_offset, 18); /* get loc of previous message */
      388 	     end;
      389 
      390 	     if get_count				/* we're finished counting */
      391 	     then do;
      392 		a_count = count;
      393 		go to FIN;
      394 	     end;
      395 	     go to NO_MSG;				/* couldn't find anything to read */
      396 EXIT:	end;
      397 
      398 /* update or delete */
      399 
      400 	else if update | delete
      401 	then do;
      402 	     if own				/* must be caller's own message */
      403 	     then if substr (ms_block_trailer.sender_id, 1, id_len) ^= substr (caller_id, 1, id_len) /* not his own */
      404 		then go to NO_MSG;			/* pretend it doesn't exist */
      405 	     if ^mseg_priv				/* no special access privilege */
      406 	     then if ^read_write_allowed_ (authorization, tr_ptr -> ms_block_trailer.access_class) /* no read-write permit */
      407 		then if ^read_allowed_ (authorization, tr_ptr -> ms_block_trailer.access_class) /* not even read permit */
      408 		     then go to NO_MSG;		/* pretend it doesn't exist */
      409 		     else do;			/* caller has read permit, but not modify */
      410 AI_ERR:			code = error_table_$ai_restricted;
      411 			go to FIN;
      412 		     end;
      413 	end;
      414 
      415 /* prepare to perform requested operation */
      416 
      417 	ms_len = fixed (ms_block_trailer.ms_size, 18);	/* pick out message size */
      418 
      419 	if update
      420 	then do;
      421 	     update_len = a_ms_len;
      422 	     if update_len > ms_len			/* incorrect message size specified */
      423 	     then do;
      424 		code = error_table_$bigarg;		/* user message too big */
      425 		go to FIN;
      426 	     end;
      427 	     t_ptr = a_ms_ptr;			/* initialize copy ptr */
      428 	end;
      429 
      430 	if delete
      431 	then do;
      432 
      433 	     if fixed (mptr -> mseg_hdr.first_ms_offset, 18) = loc /* first message */
      434 	     then first = "1"b;			/* set flag to remember */
      435 	     else first = "0"b;
      436 	     if fixed (mptr -> mseg_hdr.last_ms_offset, 18) = loc /* last message */
      437 	     then last = "1"b;			/* set flag to remember */
      438 	     else last = "0"b;
      439 
      440 	     if (^first)
      441 	     then do;				/* not first message */
      442 		prev_offset =			/* get offset to previous message */
      443 		     fixed (tr_ptr -> ms_block_trailer.b_offset, 18);
      444 		prev_tr_ptr =			/* make pointer to previous trailer */
      445 		     ptr (mptr, prev_offset+tr_offset);
      446 	     end;
      447 
      448 	     if (^last)
      449 	     then do;				/* not last message */
      450 		next_offset =			/* get offset to next message */
      451 		     fixed (tr_ptr -> ms_block_trailer.f_offset, 18);
      452 		next_tr_ptr =			/* make pointer to next trailer */
      453 		     ptr (mptr, next_offset+tr_offset);
      454 	     end;
      455 
      456 	     back_in_bucket_offset = tr_ptr -> ms_block_trailer.back_in_bucket;
      457 
      458 	     delete_size = block_size * 36;		/* the block size in bits */
      459 	     alloc_len = mptr -> mseg_hdr.alloc_len;	/* a local copy of the number of allocation bits */
      460 
      461 	end;
      462 
      463 	if read | incr_read
      464 	then do;
      465 	     ms_sender_id = tr_ptr -> ms_block_trailer.sender_id; /* pick out senders' id */
      466 	     level = fixed (ms_block_trailer.ring_no, 17); /* pick out validation level */
      467 	     ms_id = tr_ptr -> ms_block_trailer.ms_id;	/* pick out message id */
      468 	     authorization = tr_ptr -> ms_block_trailer.sender_authorization; /* pick out sender authorization */
      469 	     access_class = tr_ptr -> ms_block_trailer.access_class; /* pick out message access class */
      470 
      471 /* allocate an area for the returned message */
      472 
      473 	     on cleanup begin;			/* establish cleanup handler to free allocated message */
      474 		if ret_ptr ^= null			/* a message was allocated */
      475 		then do;
      476 		     free ms_word_array in (area_array); /* free it */
      477 		     a_arg_ptr -> return_args.ms_ptr = null; /* and return null argument ptr */
      478 		end;
      479 	     end;
      480 
      481 	     on area begin;
      482 		code = error_table_$noalloc;
      483 		go to FIN;
      484 	     end;
      485 
      486 	     ms_word_len = divide (ms_len+35, 36, 17, 0); /* compute word length from bit count */
      487 	     allocate ms_word_array in (area_array) set (ret_ptr); /* allocate the area */
      488 	     t_ptr = ret_ptr;			/* initialize scan pointer */
      489 	end;
      490 
      491 /*  */
      492 /* chase the message thread */
      493 
      494 	found_ms_len = 0;				/* initialize size of found message */
      495 
      496 	blocks_in_message = 0;			/* initialize count */
      497 	block_ptr = ms_ptr;				/* initialize block pointer */
      498 	ms_end = "0"b;				/* initialize end of message flag */
      499 
      500 	if delete					/* user is deleting a message */
      501 	then mseg_hdr.mip = "1"b;			/* turn on mip bit */
      502 
      503 	do while (^ms_end);
      504 
      505 	     blocks_in_message =			/* increment message block count */
      506 		blocks_in_message + 1;
      507 
      508 	     found_ms_len = found_ms_len + fixed (ms_block_hdr.block_count, 18); /* increment message size */
      509 	     if found_ms_len > ms_len			/* more message than block trailer specified */
      510 	     then do;				/* error in message segment */
      511 		reason = "message too long";
      512 		go to BAD_SEG;
      513 	     end;
      514 
      515 
      516 	     if (read | incr_read | update)
      517 	     then do;				/* return message for reading */
      518 		copy_size =			/* set size of copy mask */
      519 		     fixed (block_ptr -> ms_block_hdr.block_count, 18);
      520 		if update then do;			/* updating message */
      521 		     if found_ms_len > update_len then do; /* update only part of this block */
      522 			copy_size = copy_size - (found_ms_len - update_len);
      523 			ms_end = "1"b;
      524 		     end;
      525 		     addrel (block_ptr, size (ms_block_hdr)) -> bit_copy_mask
      526 			= t_ptr -> bit_copy_mask;	/* overwrite */
      527 		end;
      528 		else				/* reading message */
      529 		t_ptr -> bit_copy_mask =		/* copy message */
      530 		     addrel (block_ptr, size (ms_block_hdr)) -> bit_copy_mask;
      531 		t_ptr = addr (t_ptr -> bits (copy_size + 1)); /* increment copy ptr */
      532 	     end;
      533 
      534 	     if (delete)
      535 	     then do;				/* user is deleting a message */
      536 		bit_off = divide (fixed (rel (block_ptr), 18), block_size, 18, 0)+1; /* calculate alloc bit for block */
      537 		if substr (mseg_hdr.alloc_bits, bit_off, 1) = "0"b /* block not in use */
      538 		then do;
      539 		     reason = "unprotected block";
      540 		     go to BAD_SEG;
      541 		end;
      542 		else
      543 		substr (mseg_hdr.alloc_bits, bit_off, 1) = "0"b; /* turn bit off */
      544 		deletep = block_ptr;		/* remember block ptr to delete later */
      545 	     end;
      546 
      547 	     if ^ms_end then
      548 		if block_ptr -> ms_block_hdr.f_offset = "0"b
      549 		then do;				/* message block is last in message */
      550 		     if found_ms_len ^= ms_len	/* found size doesn't agree with trailer */
      551 		     then do;
      552 			reason = "bad message length";
      553 			go to BAD_SEG;
      554 		     end;
      555 		     else
      556 		     ms_end = "1"b;			/* indicate end of message */
      557 		end;
      558 
      559 		else do;
      560 		     block_ptr =			/* step the block pointer */
      561 			ptr (block_ptr, fixed (block_ptr -> ms_block_hdr.f_offset, 18));
      562 		end;
      563 
      564 	     if (delete)				/* message is being deleted */
      565 	     then do;
      566 		copy_size = delete_size;		/* set size of copy mask */
      567 		deletep -> bit_copy_mask = "0"b;	/* use mask to zero out block */
      568 	     end;
      569 
      570 	end;
      571 
      572 /*  */
      573 /* finish deleting message if requested */
      574 
      575 	if (delete) then do;
      576 
      577 	     if ms_count > 1			/* there will be a remaining message */
      578 	     then do;
      579 
      580 /* unthread the message */
      581 
      582 		if (first) then do;			/* unthread first message */
      583 		     mptr -> mseg_hdr.first_ms_offset =
      584 			bit (fixed (next_offset, 18), 18); /* reset header offset to new first message */
      585 		     next_tr_ptr -> ms_block_trailer.b_offset =
      586 			"0"b;			/* reset new first message back pointer */
      587 		end;
      588 
      589 		if (last) then do;			/* unthread last message */
      590 		     mptr -> mseg_hdr.last_ms_offset =
      591 			bit (fixed (prev_offset, 18), 18); /* reset header offset to new last message */
      592 		     prev_tr_ptr -> ms_block_trailer.f_offset =
      593 			"0"b;			/* reset new last message forward pointer */
      594 		end;
      595 
      596 		if (^first) then if (^last) then do;	/* unthread mid message */
      597 			prev_tr_ptr -> ms_block_trailer.f_offset =
      598 			     bit (fixed (next_offset, 18), 18); /* reset forward offset of previous message */
      599 			next_tr_ptr -> ms_block_trailer.b_offset =
      600 			     bit (fixed (prev_offset, 18), 18); /* reset backward offset of next message */
      601 		     end;
      602 
      603 	     end;
      604 
      605 	     else					/* no messages left */
      606 	     mseg_hdr.first_ms_offset,		/* zero out hdr pointers */
      607 		mseg_hdr.last_ms_offset = "0"b;
      608 
      609 /* rethread the hash bucket */
      610 	     if prev_in_bucket_ptr = null then
      611 		hash_table.last_in_bucket (htx) = back_in_bucket_offset;
      612 	     else prev_in_bucket_ptr -> ms_block_trailer.back_in_bucket = back_in_bucket_offset;
      613 
      614 /* update header after deletion */
      615 
      616 	     mptr -> mseg_hdr.space_left =		/* reset space left */
      617 		mptr -> mseg_hdr.space_left + blocks_in_message;
      618 
      619 	     ms_count = ms_count - 1;
      620 	     mptr -> mseg_hdr.number_of_messages =	/* reset number of messages */
      621 		fixed (ms_count);
      622 
      623 	     mptr -> mseg_hdr.mip = "0"b;		/* turn off modification in progress bit */
      624 
      625 	end;
      626 
      627 	if read | incr_read
      628 	then do;					/* fill in return argument structure */
      629 	     arg_ptr = a_arg_ptr;			/* copy ptr to return_args structure */
      630 	     return_args.ms_ptr = ret_ptr;		/* ptr to message */
      631 	     return_args.ms_len = ms_len;		/* length of message */
      632 	     return_args.sender_id = ms_sender_id;	/* person-project ID of message sender */
      633 	     return_args.level = level;		/* validation level of message sender */
      634 	     return_args.ms_id = ms_id;		/* message ID */
      635 	     return_args.sender_authorization = authorization; /* authorization of message sender */
      636 	     return_args.access_class = access_class;	/* access class of message */
      637 	end;
      638 
      639 FIN:
      640 
      641 	a_code = code;
      642 	return;
      643 
      644 BAD_SEG:
      645 	call mseg_error_v3_ (mptr, 0, proc_name, reason);
      646 	code = error_table_$bad_segment;
      647 	go to FIN;
      648 
      649 
      650      end mseg_util_v3_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/05/00  1831.8  mseg_util_v3_.pl1                 >udd>sm>ds>w>ml>mseg_util_v3_.pl1
119          1    05/17/85  0715.6  mseg_hdr_v3.incl.pl1              >ldd>incl>mseg_hdr_v3.incl.pl1
121          2    05/17/85  0715.5  ms_block_hdr_v3.incl.pl1          >ldd>incl>ms_block_hdr_v3.incl.pl1
123          3    05/17/85  0715.6  ms_block_trailer_v3.incl.pl1      >ldd>incl>ms_block_trailer_v3.incl.pl1
125          4    09/07/83  1710.6  aim_template.incl.pl1             >ldd>incl>aim_template.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_area_ptr                             parameter       pointer                  dcl 17 ref 143 147 158 162 166 175
a_arg_ptr                              parameter       pointer                  dcl 17 ref 143 158 166 477 629
a_code                                 parameter       fixed bin(35,0)          dcl 85 set ref 143 151 158 166 180 187 639*
a_count                                parameter       fixed bin(18,0)          dcl 46 set ref 187 289* 392*
a_dir                                  parameter       bit(2)                   dcl 66 ref 166 170
a_first_or_last                        parameter       bit(1)                   dcl 63 ref 143 146 158 161
a_mptr                                 parameter       pointer                  dcl 17 ref 143 151 158 166 180 187 199
a_ms_id                                parameter       bit(72)                  dcl 69 ref 151 154 166 169 180 184
a_ms_len                               parameter       fixed bin(18,0)          dcl 46 ref 180 421
a_ms_ptr                               parameter       pointer                  dcl 17 ref 180 427
a_own                                  parameter       bit(1)                   dcl 31 ref 143 151 158 166 180 196
access_class             20            based           bit(72)                  level 2 in structure "ms_block_trailer" dcl 3-3
                                                                                  in procedure "mseg_util_v3_" set ref 308* 367*
                                                                                  369* 405* 405* 469
access_class             20            based           bit(72)                  level 2 in structure "return_args" dcl 110
                                                                                  in procedure "mseg_util_v3_" set ref 636*
access_class                    000162 automatic       bit(72)                  dcl 72 in procedure "mseg_util_v3_" set ref 292*
                                                                                  294* 469* 636
addr                                                   builtin function         dcl 90 ref 276 531
addrel                                                 builtin function         dcl 90 ref 228 248 356 525 528
aim_template                           based           structure                level 1 dcl 4-12
alloc_bits              520            based           bit                      level 2 dcl 1-3 set ref 537 542*
alloc_len                       000165 automatic       fixed bin(17,0)          dcl 78 in procedure "mseg_util_v3_" set ref 459* 537
                                                                                  542
alloc_len                12            based           fixed bin(17,0)          level 2 in structure "mseg_hdr" dcl 1-3 in procedure
                                                                                  "mseg_util_v3_" ref 459
area                            000174 stack reference condition                dcl 92 ref 481
area_array                             based           area(30)                 dcl 97 ref 476 487
area_ptr                        000120 automatic       pointer                  dcl 17 set ref 147* 162* 175* 476 487
arg_ptr                         000114 automatic       pointer                  dcl 17 set ref 629* 630 631 632 633 634 635 636
authorization                   000160 automatic       bit(72)                  dcl 72 set ref 274* 294* 308* 367* 369* 405* 405*
                                                                                  468* 635
b_offset                  1(18)        based           bit(18)                  level 2 packed packed unaligned dcl 3-3 set ref 314
                                                                                  324 387 442 585* 599*
back_in_bucket            2(18)        based           bit(18)                  level 2 packed packed unaligned dcl 3-3 set ref 257
                                                                                  456 612*
back_in_bucket_offset           000135 automatic       bit(18)                  dcl 44 set ref 456* 610 612
based_priv                             based           structure                level 1 packed packed unaligned dcl 76
bit                                                    builtin function         dcl 90 ref 583 590 597 599
bit_copy_mask                          based           bit                      packed unaligned dcl 106 set ref 525* 525 528* 528
                                                                                  567*
bit_off                         000153 automatic       fixed bin(18,0)          dcl 46 set ref 536* 537 542
bits                                   based           bit(1)                   array packed unaligned dcl 108 set ref 531
block_count               0(19)        based           bit(17)                  level 2 packed packed unaligned dcl 2-3 ref 508 518
block_ptr                       000254 automatic       pointer                  dcl 2-3 set ref 497* 508 518 525 525 528 528 536 544
                                                                                  547 560* 560 560
block_size                      000143 automatic       fixed bin(18,0)          dcl 46 in procedure "mseg_util_v3_" set ref 207* 209
                                                                                  458 536
block_size               15            based           fixed bin(17,0)          level 2 in structure "mseg_hdr" dcl 1-3 in procedure
                                                                                  "mseg_util_v3_" ref 207
blocks_in_message               000144 automatic       fixed bin(18,0)          dcl 46 set ref 496* 505* 505 616
caller_id                       000210 automatic       char(32)                 dcl 100 set ref 279* 280 305 362 402
cleanup                         000202 stack reference condition                dcl 92 ref 473
code                            000172 automatic       fixed bin(35,0)          dcl 85 set ref 172* 201* 292* 293 321* 410* 424*
                                                                                  482* 639 646*
copy_size                       000145 automatic       fixed bin(18,0)          dcl 46 set ref 518* 522* 522 525 525 528 528 531
                                                                                  566* 567
count                           000140 automatic       fixed bin(18,0)          dcl 46 set ref 296* 373* 373 392
delete                          000124 automatic       bit(1)                   initial dcl 31 set ref 31* 155* 163* 226 369 400 430
                                                                                  500 534 564 575
delete_size                     000146 automatic       fixed bin(18,0)          dcl 46 set ref 458* 566
deletep                         000112 automatic       pointer                  dcl 17 set ref 544* 567
dir                             000155 automatic       bit(2)                   initial dcl 66 set ref 66* 170* 171 218* 223* 260
                                                                                  263 312 328 375 384
divide                                                 builtin function         dcl 90 ref 486 536
error_table_$ai_restricted      000012 external static fixed bin(35,0)          dcl 128 ref 410
error_table_$bad_segment        000010 external static fixed bin(35,0)          dcl 127 ref 646
error_table_$bigarg             000020 external static fixed bin(35,0)          dcl 131 ref 424
error_table_$inconsistent       000016 external static fixed bin(35,0)          dcl 130 ref 172
error_table_$no_message         000014 external static fixed bin(35,0)          dcl 129 ref 321
error_table_$noalloc            000022 external static fixed bin(35,0)          dcl 132 ref 482
f_offset                  1            based           bit(18)                  level 2 in structure "ms_block_trailer" packed
                                                                                  packed unaligned dcl 3-3 in procedure
                                                                                  "mseg_util_v3_" set ref 330 339 384 450 592* 597*
f_offset                               based           bit(18)                  level 2 in structure "ms_block_hdr" packed packed
                                                                                  unaligned dcl 2-3 in procedure "mseg_util_v3_" ref
                                                                                  547 560
first                           000132 automatic       bit(1)                   dcl 31 set ref 433* 435* 440 582 596
first_block               0(18)        based           bit(1)                   level 2 packed packed unaligned dcl 2-3 ref 243 351
first_ms_offset          10            based           bit(18)                  level 2 dcl 1-3 set ref 224 316 433 583* 605*
first_or_last                   000154 automatic       bit(1)                   dcl 63 set ref 146* 161* 216
fixed                                                  builtin function         dcl 90 ref 204 207 219 224 237 238 257 316 324 332
                                                                                  339 384 387 417 433 436 442 450 466 508 518 536
                                                                                  560 583 590 597 599 620
found_ms_len                    000150 automatic       fixed bin(18,0)          dcl 46 set ref 494* 508* 508 509 521 522 550
get_authorization_              000026 constant        entry                    external dcl 135 ref 274
get_count                       000126 automatic       bit(1)                   initial dcl 31 set ref 31* 190* 213 285 373 390
get_group_id_$tag_star          000024 constant        entry                    external dcl 134 ref 279
get_privileges_                 000030 constant        entry                    external dcl 136 ref 275
hash_table              120            based           structure                level 2 dcl 1-3
hcs_$get_access_class_seg       000032 constant        entry                    external dcl 137 ref 292
htx                             000170 automatic       fixed bin(17,0)          dcl 78 set ref 237* 238 610
id_len                          000171 automatic       fixed bin(17,0)          dcl 78 set ref 280* 305 305 362 362 402 402
incr_read                       000123 automatic       bit(1)                   initial dcl 31 set ref 31* 176* 260 303 463 516 627
index                                                  builtin function         dcl 90 ref 280
last                            000131 automatic       bit(1)                   dcl 31 set ref 436* 438* 448 589 596
last_in_bucket          120            based           bit(18)                  array level 3 packed packed unaligned dcl 1-3 set
                                                                                  ref 238 610*
last_ms_offset           11            based           bit(18)                  level 2 dcl 1-3 set ref 219 332 436 590* 605*
level                           000166 automatic       fixed bin(17,0)          dcl 78 in procedure "mseg_util_v3_" set ref 466* 633
level                    13            based           fixed bin(17,0)          level 2 in structure "return_args" dcl 110
                                                                                  in procedure "mseg_util_v3_" set ref 633*
loc                             000152 automatic       fixed bin(18,0)          dcl 46 set ref 219* 224* 227 238* 241 242 257* 316
                                                                                  324* 332 339* 349 350 384* 387* 433 436
mip                      16            based           bit(1)                   level 3 packed packed unaligned dcl 1-3 set ref 500*
                                                                                  623*
mptr                            000252 automatic       pointer                  dcl 1-3 set ref 199* 204 207 219 224 227 238 242
                                                                                  292* 316 332 350 433 436 444 452 459 500 537 542
                                                                                  583 590 605 605 610 616 616 620 623 644*
ms_block_hdr                           based           structure                level 1 dcl 2-3 ref 525 528
ms_block_trailer                       based           structure                level 1 dcl 3-3 set ref 209
ms_count                        000137 automatic       fixed bin(18,0)          dcl 46 set ref 204* 289 577 619* 619 620
ms_end                          000134 automatic       bit(1)                   dcl 31 set ref 498* 503 523* 547 555*
ms_id                     3            based           bit(72)                  level 2 in structure "ms_block_trailer" dcl 3-3
                                                                                  in procedure "mseg_util_v3_" ref 229 254 375 380
                                                                                  467
ms_id                           000156 automatic       bit(72)                  dcl 69 in procedure "mseg_util_v3_" set ref 154*
                                                                                  169* 184* 229* 237 254 375 380 467* 634
ms_id                    14            based           bit(72)                  level 2 in structure "return_args" dcl 110
                                                                                  in procedure "mseg_util_v3_" set ref 634*
ms_len                          000147 automatic       fixed bin(18,0)          dcl 46 in procedure "mseg_util_v3_" set ref 417* 422
                                                                                  486 509 550 631
ms_len                    2            based           fixed bin(18,0)          level 2 in structure "return_args" dcl 110
                                                                                  in procedure "mseg_util_v3_" set ref 631*
ms_ptr                                 based           pointer                  level 2 in structure "return_args" dcl 110
                                                                                  in procedure "mseg_util_v3_" set ref 477* 630*
ms_ptr                          000106 automatic       pointer                  dcl 17 in procedure "mseg_util_v3_" set ref 227* 228
                                                                                  242* 243 248 350* 351 356 497
ms_sender_id                    000220 automatic       char(32)                 dcl 100 set ref 465* 632
ms_size                   2            based           bit(18)                  level 2 packed packed unaligned dcl 3-3 ref 417
ms_word_array                          based           fixed bin(17,0)          array dcl 97 ref 476 487
ms_word_len                     000167 automatic       fixed bin(17,0)          dcl 78 set ref 476 486* 487
mseg_error_v3_                  000034 constant        entry                    external dcl 138 ref 644
mseg_hdr                               based           structure                level 1 dcl 1-3
mseg_priv                       000127 automatic       bit(1)                   dcl 31 set ref 276* 287 308 365 405
next_offset                     000142 automatic       fixed bin(18,0)          dcl 46 set ref 450* 452 583 597
next_tr_ptr                     000102 automatic       pointer                  dcl 17 set ref 452* 585 599
null                                                   builtin function         dcl 90 ref 17 239 474 477 610
number_of_messages       14            based           fixed bin(17,0)          level 2 dcl 1-3 set ref 204 620*
own                             000130 automatic       bit(1)                   dcl 31 set ref 191* 196* 277 305 362 402
prev_in_bucket_ptr              000104 automatic       pointer                  dcl 17 set ref 239* 256* 610 612
prev_offset                     000141 automatic       fixed bin(18,0)          dcl 46 set ref 442* 444 590 599
prev_tr_ptr                     000100 automatic       pointer                  dcl 17 set ref 444* 592 597
privileges                      000164 automatic       bit(36)                  dcl 75 in procedure "mseg_util_v3_" set ref 275* 276
privileges                1(18)        based           structure                level 2 in structure "aim_template" packed packed
                                                                                  unaligned dcl 4-12 in procedure "mseg_util_v3_"
proc_name                       000230 automatic       char(32)                 packed unaligned dcl 103 set ref 145* 153* 160* 168*
                                                                                  182* 189* 644*
ptr                                                    builtin function         dcl 90 ref 227 242 350 444 452 560
read                            000122 automatic       bit(1)                   initial dcl 31 set ref 31* 148* 163* 215 347 463 516
                                                                                  627
read_allowed_                   000036 constant        entry                    external dcl 139 ref 294 308 367 405
read_write_allowed_             000040 constant        entry                    external dcl 140 ref 369 405
reason                          000240 automatic       char(40)                 packed unaligned dcl 104 set ref 245* 251* 318* 334*
                                                                                  353* 359* 511* 539* 552* 644*
rel                                                    builtin function         dcl 90 ref 536
ret_ptr                         000110 automatic       pointer                  initial dcl 17 set ref 17* 474 476 487* 488 630
return_args                            based           structure                level 1 dcl 110
ring1                     0(04)        based           bit(1)                   level 2 packed packed unaligned dcl 76 ref 276
ring_no                   5            based           bit(18)                  level 2 packed packed unaligned dcl 3-3 ref 466
search_sw                       000133 automatic       bit(1)                   dcl 31 set ref 202* 262* 302 375
sender_authorization     16            based           bit(72)                  level 2 in structure "ms_block_trailer" dcl 3-3
                                                                                  in procedure "mseg_util_v3_" ref 468
sender_authorization     16            based           bit(72)                  level 2 in structure "return_args" dcl 110
                                                                                  in procedure "mseg_util_v3_" set ref 635*
sender_id                 3            based           char(32)                 level 2 in structure "return_args" dcl 110
                                                                                  in procedure "mseg_util_v3_" set ref 632*
sender_id                 6            based           char(32)                 level 2 in structure "ms_block_trailer" dcl 3-3
                                                                                  in procedure "mseg_util_v3_" ref 305 362 402 465
size                                                   builtin function         dcl 90 ref 209 525 528
space_left               13            based           fixed bin(17,0)          level 2 dcl 1-3 set ref 616* 616
substr                                                 builtin function         dcl 90 set ref 237 305 305 362 362 375 375 380 380
                                                                                  402 402 537 542*
switches                 16            based           structure                level 2 dcl 1-3
t_ptr                           000116 automatic       pointer                  dcl 17 set ref 427* 488* 525 528 531* 531
tr_offset                       000136 automatic       fixed bin(18,0)          dcl 46 set ref 209* 228 248 356 444 452
tr_pattern                             based           bit(36)                  level 2 dcl 3-3 ref 249 357
tr_ptr                          000256 automatic       pointer                  dcl 3-3 set ref 209 228* 229 248* 249 254 256 257
                                                                                  305 308 314 324 330 339 356* 357 362 367 369 375
                                                                                  380 384 387 402 405 405 417 442 450 456 465 466
                                                                                  467 468 469
trailer_pattern                 002077 constant        bit(36)                  initial dcl 3-18 ref 249 357
update                          000125 automatic       bit(1)                   initial dcl 31 set ref 31* 183* 400 419 516 520
update_len                      000151 automatic       fixed bin(18,0)          dcl 46 set ref 421* 422 521 522

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
header_pattern                         internal static bit(36)                  initial dcl 1-28
version_number                         internal static fixed bin(17,0)          initial dcl 1-28

NAMES DECLARED BY EXPLICIT CONTEXT.
AI_ERR                          001305 constant        label                    dcl 410 ref 369
BAD_SEG                         002044 constant        label                    dcl 644 ref 246 252 319 335 354 360 512 540 553
COMMON                          000452 constant        label                    dcl 196 ref 149 156 164 177 185
COMMON2                         000455 constant        label                    dcl 199 ref 192
COUNT                           000507 constant        label                    dcl 223 ref 213
EXIT                            001231 constant        label                    dcl 396 ref 375 375 380
FIN                             002041 constant        label                    dcl 639 ref 173 290 293 322 393 411 425 483 647
FIRST                           000511 constant        label                    dcl 224 ref 264
FOUND_ID                        000623 constant        label                    dcl 268 ref 254
FULL_COUNT                      000673 constant        label                    dcl 289 ref 294
LAST                            000502 constant        label                    dcl 219 ref 263
NEXT                            001205 constant        label                    dcl 384 ref 362 367 379 382
NO_MSG                          001012 constant        label                    dcl 321 ref 267 305 308 337 395 402 405
READ                            001050 constant        label                    dcl 349 ref 297 302 325 340
THREAD                          000533 constant        label                    dcl 237 ref 230
delete                          000231 constant        entry                    external dcl 151
get_count                       000432 constant        entry                    external dcl 187
incremental_read                000323 constant        entry                    external dcl 166
mseg_util_v3_                   000155 constant        entry                    external dcl 11
read                            000172 constant        entry                    external dcl 143
read_and_delete                 000262 constant        entry                    external dcl 158
update                          000377 constant        entry                    external dcl 180

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2346        2410    2100        2356
Length      2702    2100        42         255     246           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mseg_util_v3_                       218 external procedure  is an external procedure.  
on unit on line 473                  64 on unit               
on unit on line 481                  64 on unit               

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mseg_util_v3_            000100 prev_tr_ptr                 mseg_util_v3_
                         000102 next_tr_ptr                 mseg_util_v3_
                         000104 prev_in_bucket_ptr          mseg_util_v3_
                         000106 ms_ptr                      mseg_util_v3_
                         000110 ret_ptr                     mseg_util_v3_
                         000112 deletep                     mseg_util_v3_
                         000114 arg_ptr                     mseg_util_v3_
                         000116 t_ptr                       mseg_util_v3_
                         000120 area_ptr                    mseg_util_v3_
                         000122 read                        mseg_util_v3_
                         000123 incr_read                   mseg_util_v3_
                         000124 delete                      mseg_util_v3_
                         000125 update                      mseg_util_v3_
                         000126 get_count                   mseg_util_v3_
                         000127 mseg_priv                   mseg_util_v3_
                         000130 own                         mseg_util_v3_
                         000131 last                        mseg_util_v3_
                         000132 first                       mseg_util_v3_
                         000133 search_sw                   mseg_util_v3_
                         000134 ms_end                      mseg_util_v3_
                         000135 back_in_bucket_offset       mseg_util_v3_
                         000136 tr_offset                   mseg_util_v3_
                         000137 ms_count                    mseg_util_v3_
                         000140 count                       mseg_util_v3_
                         000141 prev_offset                 mseg_util_v3_
                         000142 next_offset                 mseg_util_v3_
                         000143 block_size                  mseg_util_v3_
                         000144 blocks_in_message           mseg_util_v3_
                         000145 copy_size                   mseg_util_v3_
                         000146 delete_size                 mseg_util_v3_
                         000147 ms_len                      mseg_util_v3_
                         000150 found_ms_len                mseg_util_v3_
                         000151 update_len                  mseg_util_v3_
                         000152 loc                         mseg_util_v3_
                         000153 bit_off                     mseg_util_v3_
                         000154 first_or_last               mseg_util_v3_
                         000155 dir                         mseg_util_v3_
                         000156 ms_id                       mseg_util_v3_
                         000160 authorization               mseg_util_v3_
                         000162 access_class                mseg_util_v3_
                         000164 privileges                  mseg_util_v3_
                         000165 alloc_len                   mseg_util_v3_
                         000166 level                       mseg_util_v3_
                         000167 ms_word_len                 mseg_util_v3_
                         000170 htx                         mseg_util_v3_
                         000171 id_len                      mseg_util_v3_
                         000172 code                        mseg_util_v3_
                         000210 caller_id                   mseg_util_v3_
                         000220 ms_sender_id                mseg_util_v3_
                         000230 proc_name                   mseg_util_v3_
                         000240 reason                      mseg_util_v3_
                         000252 mptr                        mseg_util_v3_
                         000254 block_ptr                   mseg_util_v3_
                         000256 tr_ptr                      mseg_util_v3_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          tra_ext_1           enable_op           ext_entry
int_entry           op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_authorization_            get_group_id_$tag_star        get_privileges_               hcs_$get_access_class_seg
mseg_error_v3_                read_allowed_                 read_write_allowed_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$ai_restricted    error_table_$bad_segment      error_table_$bigarg           error_table_$inconsistent
error_table_$no_message       error_table_$noalloc




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     17 000142        31 000144        66 000151        11 000154       143 000163       145 000207       146 000212
    147 000216       148 000221       149 000223       151 000224       153 000246       154 000251       155 000255
    156 000257       158 000260       160 000277       161 000302       162 000306       163 000311       164 000314
    166 000315       168 000342       169 000345       170 000351       171 000355       172 000357       173 000362
    175 000363       176 000366       177 000370       180 000371       182 000414       183 000417       184 000421
    185 000425       187 000426       189 000443       190 000446       191 000450       192 000451       196 000452
    199 000455       201 000461       202 000462       204 000463       207 000465       209 000467       213 000471
    215 000473       216 000475       218 000500       219 000502       220 000506       223 000507       224 000511
    226 000515       227 000517       228 000522       229 000526       230 000531       232 000532       237 000533
    238 000536       239 000546       241 000550       242 000552       243 000555       245 000560       246 000563
    248 000564       249 000570       251 000573       252 000576       254 000577       256 000603       257 000604
    258 000607       260 000610       262 000614       263 000616       264 000621       267 000622       274 000623
    275 000632       276 000641       277 000645       279 000647       280 000656       285 000667       287 000671
    289 000673       290 000676       292 000677       293 000712       294 000714       296 000732       297 000733
    302 000734       303 000736       305 000740       308 000750       312 000771       314 000774       316 001001
    318 001006       319 001011       321 001012       322 001015       324 001016       325 001020       328 001021
    330 001023       332 001030       334 001035       335 001040       337 001041       339 001042       340 001044
    343 001045       347 001046       349 001050       350 001052       351 001055       353 001060       354 001063
    356 001064       357 001070       359 001073       360 001076       362 001077       365 001106       367 001110
    369 001126       373 001147       375 001153       379 001172       380 001173       382 001204       384 001205
    387 001215       388 001221       390 001222       392 001224       393 001227       395 001230       400 001231
    402 001235       405 001245       410 001305       411 001310       417 001311       419 001315       421 001317
    422 001322       424 001324       425 001327       427 001330       430 001333       433 001335       435 001345
    436 001346       438 001355       440 001356       442 001360       444 001363       448 001367       450 001371
    452 001374       456 001400       458 001403       459 001406       463 001410       465 001414       466 001417
    467 001422       468 001425       469 001430       473 001433       474 001447       476 001454       477 001456
    479 001462       481 001463       482 001477       483 001502       486 001505       487 001511       488 001516
    494 001517       496 001520       497 001521       498 001523       500 001524       503 001531       505 001534
    508 001535       509 001542       511 001545       512 001550       516 001551       518 001557       520 001562
    521 001564       522 001567       523 001573       525 001575       527 001604       528 001605       531 001613
    534 001617       536 001621       537 001626       539 001633       540 001636       542 001637       544 001642
    547 001644       550 001652       552 001655       553 001660       555 001661       557 001663       560 001664
    564 001670       566 001672       567 001674       570 001700       575 001701       577 001703       582 001706
    583 001710       585 001716       589 001721       590 001723       592 001731       596 001734       597 001740
    599 001746       603 001754       605 001755       610 001760       612 001773       616 001777       619 002002
    620 002004       623 002006       627 002010       629 002014       630 002017       631 002021       632 002023
    633 002026       634 002030       635 002033       636 002036       639 002041       642 002043       644 002044
    646 002072       647 002075


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
