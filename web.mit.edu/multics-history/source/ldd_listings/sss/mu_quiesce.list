	COMPILATION LISTING OF SEGMENT mu_quiesce
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 10/23/86  1013.0 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 mu_quiesce: proc;
       19 
       20 /* HISTORY:
       21*
       22*   Originally written by Al Kepner, March 1979.
       23*
       24*   80-12-09 Jim Gray : changed method of getting dbc_ptr, so that a common
       25*   routine could determine if AMDB -rs needed to be run to update the
       26*   dbc structure versions.
       27*
       28*   82-05-19 Mike Kubicar : modified to allow multiple database quiesces
       29*   per process.  Also removed code that started to implement multiple
       30*   quiesces per call.
       31*
       32*   84-10-23 Paul Benjamin : changed to use a smaller lock wait time when 
       33*   calling set_lock_$lock from the cleanup handler.
       34**/
       35 
       36 /* DESCRIPTION:
       37*
       38*
       39*   BEGIN_DESCRIPTION
       40*   " N__a_m_e:  mu_quiesce
       41*   "
       42*   "      This  routine allows  the caller to  quiesce an  entire data
       43*   " base   or  selected   files   for  such   purposes   as  dumping,
       44*   " restructuring, or file ring changes. Files which are quiesced are
       45*   " reserved  for the  exclusive use  of the  process which  does the
       46*   " quiescing.
       47*   "
       48*   "
       49*   " E__n_t_r_y:  mu_quiesce$quiesce_quiet
       50*   "
       51*   "
       52*   "      This  entry is  called  to quiesce  an entire  data  base or
       53*   " selected files.
       54*   "
       55*   "
       56*   " U__s_a_g_e
       57*   "
       58*   "      dcl  mu_quiesce$quiesce_quiet entry (char (168), fixed bin (17),
       59*   "	     fix bin (35));
       60*   "
       61*   "      call mu_quiesce$quiesce_quiet (database_pathname, wait_time, code);
       62*   "
       63*   " where:
       64*   "
       65*   " 1.   database_pathname    (Input)
       66*   "             the pathname of the database to be quiesced.
       67*   "
       68*   " 2.   wait_time            (Input)
       69*   "             the length of time (in seconds) to wait on locks.
       70*   "
       71*   " 3.   code                 (Output)
       72*   "             is a standard system error code.  If the wait time is
       73*   "             exceeded   the   error    code   returned   will   be
       74*   "             mdbm_error_$db_busy.  The data base has been quiesced
       75*   "             only  if a  0 error  code  is returned.   Other error
       76*   "             codes     which    may     be     returned    include
       77*   "             mdbm_error_$quiesced_dead_db (The data  base has been
       78*   "             quiesced  by  a  process  which  no  longer  exists,)
       79*   "             mdbm_error_$my_quiesced_db (Attempt to quiesce a data
       80*   "             base  which   has  already  been   quiesced  by  this
       81*   "             process,)  mdbm_error_$hold_quiesced_db  (Attempt  to
       82*   "             quiesce a  data base before  previously quiesced data
       83*   "             bases  have  been  freed,)
       84*   "             mdbm_error_$trouble_lock (The data base is locked and
       85*   "             may          be          inconsistent.)           and
       86*   "             mdbm_error_$quiesce_too_few (The number of data bases
       87*   "             to quiesce is negative or zero.)
       88*   "
       89*   "
       90*   " N__o_t_e_s
       91*   "
       92*   "      Only one user  at a time may quiesce a given
       93*   " data base.  The  data base is locked against  further attempts to
       94*   " quiesce  until  mu_quiesce$quiesce_free  is  called by  the  same
       95*   " process which first called mu_quiesce$quiesce_quiet.
       96*   "
       97*   "
       98*   " E__n_t_r_y:  mu_quiesce$quiesce_free
       99*   "
      100*   "
      101*   "      This entry  is called to  free the files or  data base which
      102*   " have been quiesced.
      103*   "
      104*   "
      105*   " U__s_a_g_e
      106*   "
      107*   "      dcl  mu_quiesce$quiesce_free entry (char (168), fixed bin(35));
      108*   "
      109*   "      call mu_quiesce$quiesce_free (database_pathname, code);
      110*   "
      111*   " where:
      112*   "
      113*   " 1.   database_pathname    (Input)
      114*   "             the pathname of the database to be freed.
      115*   "
      116*   " 2.   code                 (Output)
      117*   "             is a  standard system error code.   Error codes which
      118*   "             may be returned  include mdbm_error_$quiesced_db (The
      119*   "             data  base  has been  quiesced  by another  process,)
      120*   "             mdbm_error_$quiesced_dead_db (The data  base has been
      121*   "             quiesced  by  a  process  which  no  longer  exists,)
      122*   "             mdbm_error_$trouble_lock (The data base is locked and
      123*   "             may          be           inconsistent,)          and
      124*   "             mdbm_error_$free_not_quiesced (Attempt to free a data
      125*   "             base which was not quiesced.)
      126*   "
      127*   "
      128*   END_DESCRIPTION
      129*
      130**/
      131 
      132 quiesce_quiet: quiet: entry (db_path, quiesce_wait_time, code);
      133 	dcl     db_path		 char (168);
      134 	dcl     quiesce_wait_time	 fixed bin (17);
      135 	dcl     code		 fixed bin (35) parm;
      136 
      137 /* Initialization: */
      138 	hold_ul_ptr, dbc_ptr = null ();
      139 	handling_a_cleanup = "0"b;
      140 	on cleanup begin;
      141 	     handling_a_cleanup = "1"b;
      142 	     call tidy_up;
      143 	end;
      144 	code = 0;
      145 
      146 /* Obtain a pointer to the dbc (dbc_ptr). */
      147 	call get_dbc_ptr (bc, dbc_ptr);
      148 
      149 /* Lock the db against other attempts to quiesce. */
      150 	call set_lock_$lock (dbc.quiesce_lock,
      151 	     quiesce_wait_time,
      152 	     icode);
      153 	if icode ^= 0 then do;
      154 		if icode = error_table_$lock_wait_time_exceeded
      155 		then call error (mdbm_error_$db_busy);
      156 		if icode = error_table_$invalid_lock_reset
      157 		then do;
      158 			dbc.trouble_switch = "1"b;
      159 			call error (mdbm_error_$quiesced_dead_db);
      160 		     end;
      161 		if icode = error_table_$locked_by_this_process
      162 		then call error (mdbm_error_$my_quiesced_db);
      163 		call error (icode);
      164 	     end;
      165 
      166 	time_remaining = quiesce_wait_time;
      167 	go to check_opens;
      168 
      169 	do while (time_remaining > 0);
      170 
      171 /* Sleep for 30 seconds. */
      172 	     time_remaining = time_remaining - 30;
      173 	     call timer_manager_$sleep (30, "11"b);
      174 
      175 check_opens:   ;
      176 
      177 /* Lock open_lock using the wait time suppied. */
      178 	     call set_lock_$lock (dbc.open_lock,
      179 		quiesce_wait_time,
      180 		icode);
      181 	     if icode ^= 0 then do;
      182 		     if icode = error_table_$lock_wait_time_exceeded
      183 		     then call error (mdbm_error_$db_busy);
      184 		     if icode = error_table_$invalid_lock_reset
      185 		     then do;
      186 			     dbc.trouble_switch = "1"b;
      187 			     call error (mdbm_error_$trouble_lock);
      188 			end;
      189 		     else call error (icode);
      190 		end;
      191 
      192 /* Check for potentially inconsistent data base. */
      193 	     if dbc.trouble_switch then do;
      194 		     call set_lock_$unlock (dbc.open_lock, icode);
      195 		     call error (mdbm_error_$trouble_lock);
      196 		end;
      197 
      198 /* Determine if any users have the db open. */
      199 	     if dbc.open_users = 0 then go to quiesce_db_ok;
      200 
      201 /* Unlock open_lock. */
      202 	     call set_lock_$unlock (dbc.open_lock, icode);
      203 	     if icode ^= 0 then call error (icode);
      204 	end;
      205 
      206 /* The wait time has been exceeded. */
      207 	call error (mdbm_error_$db_busy);
      208 
      209 quiesce_db_ok: ;
      210 	quiesce_sw = "1"b;
      211 	quiesce_db = "1"b;
      212 
      213 /* Add information about the quiescing process to the users list. */
      214 	num_filns = 0;
      215 	allocate user_list in (dbc.static_area) set (hold_ul_ptr);
      216 	ul_ptr = hold_ul_ptr;
      217 	call get_lock_id_ (user_list.db_lock_id);
      218 	if icode ^= 0 then call error (icode);
      219 	user_list.rdbi_bits = "0"b;
      220 	user_list.num_filns = 0;
      221 	user_list.fil_list_ofs = NULL_OFS;
      222 	user_list.next_active_ofs = NULL_OFS;
      223 	user_list.next_waiting_ofs = NULL_OFS;
      224 	user_list.next_open_ofs = dbc.open_users_ofs;	/* Add user to list of data base
      225*						   open users. */
      226 	dbc.open_users_ofs = rel (ul_ptr);
      227 	user_list.group_id = get_group_id_ ();
      228 	user_list.open_mode = mdbm_data_$quiesce_mode;
      229 	user_list.bypass_count = 0;
      230 	user_list.allowance_count = 0;
      231 	user_list.process_id = get_process_id_ ();
      232 	user_list.ev_chn_id = 0;
      233 	user_list.dead_proc = "0"b;
      234 	user_list.dead_proc_conflict = "0"b;
      235 	user_list.priority_high = "0"b;
      236 	user_list.waiting_sw = "0"b;
      237 	user_list.active_sw = "0"b;
      238 	user_list.event_signal_sw = "0"b;
      239 	user_list.passive_sw = "1"b;			/* assume passivity */
      240 	call set_lock_$unlock (dbc.open_lock, icode);
      241 	if icode ^= 0 then call error (icode);
      242 	go to common_exit;
      243 
      244 quiesce_free: free: entry (db_path, code);
      245 
      246 /* Initialization: */
      247 	hold_ul_ptr, dbc_ptr = null ();
      248 	handling_a_cleanup = "0"b;
      249 	on cleanup begin;
      250 	     handling_a_cleanup = "1"b;
      251 	     call tidy_up;
      252 	end;
      253 	code = 0;
      254 
      255 /* Obtain a pointer to the dbc (dbc_ptr). */
      256 	call get_dbc_ptr (bc, dbc_ptr);
      257 
      258 /* Make sure quiesce_lock was locked by this process.
      259*   If not give an appropriate error code and return. */
      260 
      261 	call get_lock_id_ (lock_id);
      262 	if dbc.quiesce_lock ^= lock_id
      263 	then do;
      264 		call set_lock_$lock (dbc.quiesce_lock,
      265 		     0, icode);
      266 		if icode = 0
      267 		then do;
      268 			call free_db;
      269 			call error (mdbm_error_$free_not_quiesced);
      270 		     end;
      271 		else if icode = error_table_$invalid_lock_reset
      272 		then do;
      273 			dbc.trouble_switch = "1"b;
      274 			call error (mdbm_error_$quiesced_dead_db);
      275 		     end;
      276 		else if icode = error_table_$lock_wait_time_exceeded
      277 		then call error (mdbm_error_$quiesced_db);
      278 		else call error (icode);
      279 	     end;
      280 	else do;
      281 		call free_db;
      282 	     end;
      283 common_exit: ;
      284 	return;
      285 
      286 convert: proc (a_ptr, ofs) returns (ptr);
      287 
      288 /* this procedure function converts an offset from NULL_OFS to null
      289*   or from the offset value to a pointer value within the segment denoted by a_ptr
      290**/
      291 
      292 	dcl     result		 ptr;		/* the resultant pointer value */
      293 	dcl     a_ptr		 ptr;		/* ptr to the segment to which the offset refers */
      294 	dcl     ofs		 bit (18) unal;	/* the bit offset */
      295 
      296 	dcl     (null, ptr)		 builtin;
      297 
      298 	if ofs ^= NULL_OFS
      299 	then result = ptr (a_ptr, ofs);
      300 	else result = null;
      301 
      302 	return (result);
      303 
      304      end convert;
      305 
      306 delete_quiesce_user_from_list: proc;
      307 
      308 /* This routine deletes the quiesce user entry out of the list of open
      309*   users.  It is called in response to (1) most errors, (2) the cleanup condition,
      310*   and (3) the mu_quiesce$free entry point. */
      311 
      312 	previous_ul_ptr = null ();
      313 	proc_id = get_process_id_ ();
      314 	do ul_ptr = convert (dbc_ptr, dbc.open_users_ofs)
      315 	     repeat convert (dbc_ptr, user_list.next_open_ofs)
      316 	     while (ul_ptr ^= null ());
      317 	     if user_list.process_id = proc_id
      318 		& user_list.open_mode = mdbm_data_$quiesce_mode
      319 	     then do;
      320 		     hold_ul_ptr = ul_ptr;
      321 		     if previous_ul_ptr = null ()
      322 		     then dbc.open_users_ofs = user_list.next_open_ofs;
      323 		     else previous_ul_ptr -> user_list.next_open_ofs = user_list.next_open_ofs;
      324 		     go to free_user_storage;
      325 		     dcl	   proc_id	      bit (36); /* process_id of this process. */
      326 		     dcl	   previous_ul_ptr	      ptr;/* ptr to the user_list entry which precedes the current one */
      327 		end;
      328 	     previous_ul_ptr = ul_ptr;
      329 	end;
      330 free_user_storage: ;
      331 	if hold_ul_ptr ^= null ()
      332 	then free hold_ul_ptr -> user_list in (dbc.static_area);
      333 	return;
      334      end delete_quiesce_user_from_list;
      335 
      336 error: proc (cd);
      337 	dcl     cd		 fixed bin (35) parm;
      338 	code = cd;
      339 	call tidy_up;
      340 	go to common_exit;
      341      end error;
      342 
      343 free_db: proc;
      344 	call set_lock_$lock (dbc.open_lock,
      345 	     mdbm_data_$lock_wait, icode);
      346 	if icode ^= 0 then do;
      347 		if icode = error_table_$lock_wait_time_exceeded
      348 		then call error (mdbm_error_$db_busy);
      349 		if icode = error_table_$invalid_lock_reset
      350 		then do;
      351 			dbc.trouble_switch = "1"b;
      352 			call error (mdbm_error_$trouble_lock);
      353 		     end;
      354 		else call error (icode);
      355 	     end;
      356 
      357 /* Check for potentially inconsistent data base. */
      358 	if dbc.trouble_switch then do;
      359 		call set_lock_$unlock (dbc.open_lock, icode);
      360 		call error (mdbm_error_$trouble_lock);
      361 	     end;
      362 	quiesce_sw = "0"b;
      363 	quiesce_db = "0"b;
      364 	call delete_quiesce_user_from_list;
      365 	call set_lock_$unlock (dbc.open_lock, icode);
      366 	if icode ^= 0 then call error (icode);
      367 	call set_lock_$unlock (dbc.quiesce_lock, icode);
      368 	if icode ^= 0 then call error (icode);
      369 	return;
      370      end free_db;
      371 
      372 get_dbc_ptr: proc (bc, dbc_ptr);
      373 	dcl     bc		 fixed bin (24) parm;
      374 	dcl     dbc_ptr		 ptr parm;
      375 
      376 /* Use the data base pathname supplied in the quiesce data structure to
      377*   obtain a pointer to the dbc. */
      378 
      379 	call mu_concurrency_control$open_control_segment (db_path,
      380 	     dbc_ptr, bc, icode);
      381 	if icode ^= 0 then
      382 	     call error (icode);
      383 
      384 	return;
      385      end get_dbc_ptr;
      386 
      387 tidy_up: proc;
      388 
      389 /* This routine is called when any error occurs and for the
      390*   cleanup condition. It attempts to leave the dbc in a non quiesced state. */
      391 	if code = mdbm_error_$my_quiesced_db then return;
      392 	if code = mdbm_error_$hold_quiesced_db then return;
      393 	if code = mdbm_error_$quiesce_too_few then return;
      394 	if dbc_ptr = null () then return;
      395 	call get_lock_id_ (lock_id);
      396 	if dbc.quiesce_lock ^= lock_id
      397 	then return;
      398 	if handling_a_cleanup
      399 	     then call set_lock_$lock (dbc.open_lock,	/* mdbm_data_$lock_wait is too */
      400 	     mdbm_data_$cleanup_lock_wait, icode);	/* long for a cleanup handler */
      401 	else call set_lock_$lock (dbc.open_lock,
      402 	     mdbm_data_$lock_wait, icode);
      403 	if icode = 0 | icode = error_table_$locked_by_this_process
      404 	then do;
      405 		quiesce_sw = "0"b;
      406 		quiesce_db = "0"b;
      407 		call delete_quiesce_user_from_list;
      408 		call set_lock_$unlock (dbc.open_lock, icode);
      409 		call set_lock_$unlock (dbc.quiesce_lock, icode);
      410 	     end;
      411      end tidy_up;
      412 
      413 /* VARIABLES FOR MU_QUIESCE */
      414 	dcl     bc		 fixed bin (24);
      415 	dcl     cleanup		 condition;
      416 	dcl     error_table_$invalid_lock_reset ext fixed bin (35);
      417 	dcl     error_table_$lock_wait_time_exceeded ext fixed bin (35);
      418 	dcl     error_table_$locked_by_this_process ext fixed bin (35);
      419 	dcl     get_group_id_	 entry returns (char (32));
      420 	dcl     get_lock_id_	 entry (bit (36) aligned);
      421 	dcl     get_process_id_	 entry returns (bit (36));
      422 	dcl     handling_a_cleanup     bit (1) aligned;
      423 	dcl     hold_ul_ptr		 ptr;		/* ptr to user_list entry when newly allocated
      424*						   or about to be freed. */
      425 	dcl     icode		 fixed bin (35);
      426 	dcl     lock_id		 bit (36) aligned;
      427 	dcl     mdbm_data_$cleanup_lock_wait ext fixed bin (17);
      428 	dcl     mdbm_data_$lock_wait	 ext fixed bin (17);
      429 	dcl     mdbm_data_$quiesce_mode ext fixed bin (17);
      430 	dcl     mdbm_error_$db_busy	 ext fixed bin (35);
      431 	dcl     mdbm_error_$free_not_quiesced ext fixed bin (35);
      432 	dcl     mdbm_error_$hold_quiesced_db ext fixed bin (35);
      433 	dcl     mdbm_error_$my_quiesced_db ext fixed bin (35);
      434 	dcl     mdbm_error_$quiesce_too_few ext fixed bin (35);
      435 	dcl     mdbm_error_$quiesced_db ext fixed bin (35);
      436 	dcl     mdbm_error_$quiesced_dead_db ext fixed bin (35);
      437 	dcl     mdbm_error_$trouble_lock ext fixed bin (35);
      438 	dcl     set_lock_$lock	 entry (bit (36) aligned, fixed bin, fixed bin (35));
      439 	dcl     set_lock_$unlock	 entry (bit (36) aligned, fixed bin (35));
      440 	dcl     sys_info$max_seg_size	 ext fixed bin (35);
      441 	dcl     time_remaining	 fixed bin (71);
      442 	dcl     timer_manager_$sleep	 entry (fixed bin (71), bit (2));
      443 	dcl     mu_concurrency_control$open_control_segment entry (char (168), ptr, fixed bin (24), fixed bin (35)); /* opens dbc_ptr */
      444 	dcl     (fixed, null, rel) builtin;
      445 
  1     1 /*	BEGIN INCLUDE FILE		mdbm_dbc.incl.pl1	08/23/78   odf			*/
  1     2 
  1     3 /* HISTORY:
  1     4*
  1     5*   Modified by odf for new version data bases in August 1978
  1     6*   Modified by Al Kepner, March 8, 1979 to add new flags for quiescing
  1     7*   Modified by M. Pierret, 8 April 1980 to look prettier, add pads
  1     8*   Modified by M. Pierret, 22 August 1980, grouping like fields (flags, offsets..)
  1     9*
  1    10*   80-11-19 Jim Gray : modified to change version number from 4  to 5 to allow
  1    11*   automatic update of dbc structures to new r-s-m-d-u scope codes from r-u.
  1    12**/
  1    13 
  1    14 dcl 1 dbc based (dbc_ptr),				/* data base control segment description */
  1    15     2 proper,
  1    16       3 version fixed bin,				/* version number of this structure */
  1    17       3 dtd_mrds fixed bin (71),			/* date time dumped by mrds utility */
  1    18       3 flags,
  1    19         4 trouble_switch bit (1) unal,			/* ON => ungraceful termination of a user process */
  1    20         4 dead_proc_flag bit (1) unal,			/* ON => dead process has access to part of data base */
  1    21         4 quiesce_sw bit (1) unal,			/* ON => db is quiesced for a administrative user */
  1    22         4 quiesce_db bit (1) unal,			/* ON => The entire data base is being quiesced. */
  1    23         4 quiesce_files bit (1) unal,			/* ON => A selected set of files is being quiesced. */
  1    24         4 pad bit (31) unal,				/* reserved for future use */
  1    25       3 quiesce_lock bit (36) aligned,			/* lock word for quiescing data base */
  1    26       3 wakeup_waiters fixed bin,			/* nbr users who have been sent a wakeup signal but have not yet
  1    27*						   received it */
  1    28       3 user_counts,
  1    29         4 open_users fixed bin,			/* nbr of users with data base open in any mode */
  1    30         4 active_users fixed bin,			/* nbr of users currently having a scope set */
  1    31         4 waiting_users fixed bin,			/* nbr of users waiting to set scope */
  1    32       3 open_lock bit (36) aligned,			/* lock word for opening data base */
  1    33       3 scope_lock bit (36) aligned,			/* lock word for setting and deleting scope */
  1    34       3 sa_size fixed bin (35),			/* size in words of static area  */
  1    35       3 pad2 bit (144),
  1    36       3 offsets,
  1    37         4 open_users_ofs bit (18) unal,			/* bit offset to list of users with data base currently open */
  1    38         4 active_users_ofs bit (18) unal,		/* bit offset to list of active users in shared mode */
  1    39         4 waiting_users_ofs bit (18) unal,		/* bit offset to list of waiting users in shared mode */
  1    40         4 obsolete bit (36) unal,			/* obsolete */
  1    41       3 pad3 bit (144),
  1    42     2 static_area area (sys_info$max_seg_size - fixed (rel (addr (dbc.static_area))) + 1);
  1    43 
  1    44 dcl  dbc_ptr ptr init (null ());
  1    45 
  1    46 dcl  VERSION_NBR fixed bin init (5) static internal options (constant);
  1    47 
  1    48 
  1    49 /* END mdbm_dcb.incl.pl1  */
  1    50 
  1    51 
      446 
      447 
  2     1 /* BEGIN mdbm_users.incl.pl1   -- odf, 08/10/78  */
  2     2 
  2     3 
  2     4 
  2     5 /****^  HISTORY COMMENTS:
  2     6*  1) change(86-10-03,Dupuis), approve(86-10-21,MCR7562), audit(86-10-22,Blair),
  2     7*     install(86-10-23,MR12.0-1199):
  2     8*     Deleted the DEFAULT_WAIT variable.
  2     9*                                                   END HISTORY COMMENTS */
  2    10 
  2    11 
  2    12 /* HISTORY:
  2    13*   Written by Oris Friesen August 10, 1978.
  2    14*   Modified by M. Pierret 13 December 1979, changing wakeup messages.
  2    15*   Modified by M. Pierret 13 April 1980 (Jason's birthday) to remove priority and wakeup structures
  2    16*   Modified by M. Pierret 13 August 1980 to group like fields (ids, offsets...)
  2    17*   Modified by Jim Gray - - 80-11-19, to add fields to fil_list to allow for complete
  2    18*   r-u-s-m-d scope codes, instead of just r-u.
  2    19*
  2    20*   80-12-10 Jim Gray : change names of fil_list prevent/permit modes
  2    21*   store to append_tuple, retreive to read_attr, delete to delete_tuple, modify to modify_attr,
  2    22*   and pad to mbz for consistency with MRDS access acl modes.
  2    23*
  2    24*   80-12-12 Jim Gray : Changed DEFAULT_WAIT declaration to fixed bin 35 from 71,
  2    25*   so that the wait_seconds fb35 overlay would not get 0 and thus never wait.
  2    26*   This is currently only used in mrds_dsl_set_fscope.
  2    27*
  2    28*   82-09-22 Davids: addede the opening_id element to the fil_list structure.
  2    29*   Put it at the end to make the new structure compatable with the old so
  2    30*   that testing could take place without having to recompile all the modules
  2    31*   that use the structure.
  2    32*
  2    33*   82-10-14 Davids: removed the opening_id element and added the rmri_ptr
  2    34*   element. This was done because set_fscope must be able to open the
  2    35*   relation if its not yet opened.
  2    36*   ---------------------------------------------------------------------------
  2    37*   DESCRIPTION:
  2    38*
  2    39*   The dbc contains the following information in its static area.
  2    40*   One group of information is composed of structures (user_list)
  2    41*   threaded 3 ways to form 3 lists. They are the list of active
  2    42*   scope users, of open users, and of users waiting to set scope.
  2    43*   The beginning of each of these lists is pointed to by fields
  2    44*   in the dbc proper.  All of these lists share the user_list structures,
  2    45*   and are completely contained within these structures, i.e., there
  2    46*   is no extraneous information in some knook in Scottsdale.
  2    47*
  2    48*   Associated with each user_list structure is a linked list of
  2    49*   fil_list structures.  The list is of all of the files (relations)
  2    50*   included in the user's scope request.  Unlike the user_list
  2    51*   structures which were shared by several different lists, the structures
  2    52*   in a user's file list are exclusively hers.  The entries contain
  2    53*   information about the scope request and the file name, and have
  2    54*   no real connection with the actual files in the resultant model.
  2    55*   --------------------------------------------------------------------------- */
  2    56 
  2    57 dcl 1 user_list based (ul_ptr),
  2    58     2 ids,
  2    59       3 group_id char (32),				/* group identifier of this user */
  2    60       3 process_id bit (36),				/* process identifier of this user */
  2    61       3 db_lock_id bit (36) aligned,			/* the unique lock id for this process --
  2    62*						   used to identify dead processes */
  2    63       3 ev_chn_id fixed bin (71),			/* event channel id for this process */
  2    64       3 rdbi_bits bit (72),				/* bit string of rdbi_ptr
  2    65*						   to allow concurrent openings by same process */
  2    66     2 flags,
  2    67       3 open_mode fixed bin unal,			/* the mode of the db. opening -- NORMAL or QUIESCE */
  2    68       3 passive_sw bit (1) unal,			/* OFF => -permit update on some file */
  2    69       3 active_sw bit (1) unal,			/* ON => user has a scope set */
  2    70       3 waiting_sw bit (1) unal,			/* ON => user is waiting for scope to be set */
  2    71       3 priority_high bit (1) unal,			/* obsolete */
  2    72       3 event_signal_sw bit (1) unal,			/* ON => user has been signalled thru event wait channel */
  2    73       3 dead_proc bit (1) unal,			/* ON => this user's process has died  and is inactive */
  2    74       3 dead_proc_conflict
  2    75      bit (1) unal,					/* this user's scope request conflicts with a dead process */
  2    76       3 queue_activ bit (1) unal,			/* activated from the waiting queue */
  2    77       3 pad bit (28),				/* reserved for future use */
  2    78     2 allowance_count fixed bin,			/* obsolete */
  2    79     2 bypass_count fixed bin,				/* obsolete */
  2    80     2 offsets,
  2    81       3 fil_list_ofs bit (18) unal,			/* bit offset to list of files in this user's scope request */
  2    82       3 next_active_ofs bit (18) unal,			/* bit offset to next user in this list of active scope users */
  2    83       3 next_waiting_ofs bit (18) unal,			/* bit offset to next user in user list waiting to set scope */
  2    84       3 next_open_ofs bit (18) unal,			/* bit offset to next user who has data base open in any mode */
  2    85     2 num_filns fixed bin,				/* number of files potentially accessible by this user */
  2    86     2 file (num_filns refer (user_list.num_filns)) char (30);
  2    87 						/* names of files accessible by this user */
  2    88 
  2    89 dcl 1 fil_list based (fl_ptr),			/* of files which a given user has specified for a scope  */
  2    90     2 name char (30),				/* data model name of the file specified in scope request */
  2    91     2 permits,					/* permit codes for scope setting or deleting */
  2    92       3 mbz1 bit (15) unal,
  2    93       3 modify_attr bit (1) unal,
  2    94       3 delete_tuple bit (1) unal,
  2    95       3 append_tuple bit (1) unal,
  2    96       3 update bit (1) unal,
  2    97       3 read_attr bit (1) unal,
  2    98     2 prevents,					/* prevent codes for scope setting or deleting */
  2    99       3 update bit (1) unal,
  2   100       3 read_attr bit (1) unal,
  2   101       3 append_tuple bit (1) unal,
  2   102       3 delete_tuple bit (1) unal,
  2   103       3 modify_attr bit (1) unal,
  2   104       3 mbz2 bit (29) unal,
  2   105     2 next_ofs bit (18) unal,				/* bit offset to next file entry for this user's scope request */
  2   106     2 rmri_ptr ptr;                                         /* pointer to the relation's rm_rel_info str */
  2   107                                                             /* needed so that the relation can be opened if need be */
  2   108 
  2   109 dcl  ul_ptr ptr init (null ());
  2   110 dcl  fl_ptr ptr init (null ());
  2   111 
  2   112 dcl  num_filns fixed bin;				/* number of files accessible by a given user */
  2   113 
  2   114 
  2   115 dcl  WAIT init (0) fixed bin int static options (constant);
  2   116 						/* the number of later user requests for which a user
  2   117*						   request will wait before it must be honored */
  2   118 dcl  NULL_OFS bit (18) init ("111111111111111111"b) unal int static options (constant);
  2   119 dcl  DQ_OPEN bit (1) unal init ("1"b) int static options (constant);
  2   120 						/* dequeue from open list */
  2   121 dcl  NO_DQ_OPEN bit (1) init ("0"b) int static options (constant);
  2   122 						/*  do not dequeue from open list */
  2   123 dcl  CHAR_Q_F char (8) init ("que_free") int static options (constant);
  2   124 dcl  QUE_FREE fixed bin (71);
  2   125 dcl  CHAR_ALARM char (8) init ("alarm___") int static options (constant);
  2   126 						/* wakeup up signal for time-out */
  2   127 dcl  ALARM fixed bin (71);
  2   128 dcl  FIRST_QUEUE bit (1) init ("1"b) int static options (constant);
  2   129 						/* this is the 1st time process will asleep */
  2   130 dcl  QUEUE_AGAIN bit (1) init ("0"b) int static options (constant);
  2   131 						/* being queued for the 2nd, 3rd ... time */
  2   132 dcl  SET bit (1) unal init ("1"b) int static options (constant);
  2   133 						/* check to see which scopes can be set */
  2   134 dcl  DEL bit (1) unal init ("0"b) int static options (constant);
  2   135 						/* check to see which scopes can be deleted */
  2   136 dcl  ALIVE init ("1"b) bit (1) unal int static options (constant);
  2   137 						/* process is alive */
  2   138 dcl  DEAD init ("0"b) bit (1) unal int static options (constant);
  2   139 						/* process is dead */
  2   140 dcl  Q_PRM init (3) fixed bin (35) int static options (constant);
  2   141 						/* permit retrieve, update */
  2   142 dcl  Q_PRV init (3) fixed bin (35) int static options (constant);
  2   143 						/* prevent retrieve, update */
  2   144 dcl  Q_PRM_BITS bit (2) unal init ("11"b) int static options (constant);
  2   145 						/* permit retrieve, update */
  2   146 dcl  Q_PRV_BITS bit (2) unal init ("11"b) int static options (constant);
  2   147 						/* prevent retrieve, update */
  2   148 dcl  REL_SEC bit (2) init ("11"b) int static options (constant);
  2   149 						/* measure wait time in relative seconds */
  2   150 dcl  FREE_FIL_LIST bit (1) unal init ("1"b) int static options (constant);
  2   151 						/* free this user's file lists */
  2   152 dcl  SAVE_FIL_LIST bit (1) unal init ("0"b) int static options (constant);
  2   153 						/* do not free this user's file lists */
  2   154 
  2   155 /* END mdbm_users.incl.pl1 */
  2   156 
      448 
      449      end mu_quiesce;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/23/86  1008.9  mu_quiesce.pl1                    >spec>install>1199>mu_quiesce.pl1
446          1    10/14/83  1609.0  mdbm_dbc.incl.pl1                 >ldd>include>mdbm_dbc.incl.pl1
448          2    10/23/86  1006.0  mdbm_users.incl.pl1               >spec>install>1199>mdbm_users.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
NULL_OFS                               constant        bit(18)                  initial unaligned dcl 2-118 ref 221 222 223 298
a_ptr                                  parameter       pointer                  dcl 293 ref 286 298
active_sw                16(19)        based           bit(1)                   level 3 packed unaligned dcl 2-57 set ref 237*
allowance_count          20            based           fixed bin(17,0)          level 2 dcl 2-57 set ref 230*
bc                                     parameter       fixed bin(24,0)          dcl 373 in procedure "get_dbc_ptr" set ref 372 379*
bc                              000100 automatic       fixed bin(24,0)          dcl 414 in procedure "mu_quiesce" set ref 147* 256*
bypass_count             21            based           fixed bin(17,0)          level 2 dcl 2-57 set ref 229*
cd                                     parameter       fixed bin(35,0)          dcl 337 ref 336 338
cleanup                         000102 stack reference condition                dcl 415 ref 140 249
code                                   parameter       fixed bin(35,0)          dcl 135 set ref 132 132 144* 244 244 253* 338* 391
                                                                                  392 393
db_lock_id               11            based           bit(36)                  level 3 dcl 2-57 set ref 217*
db_path                                parameter       char(168)                unaligned dcl 133 set ref 132 132 244 244 379*
dbc                                    based           structure                level 1 unaligned dcl 1-14
dbc_ptr                         000120 automatic       pointer                  initial dcl 1-44 in procedure "mu_quiesce" set ref
                                                                                  138* 147* 150 158 178 186 193 194 199 202 210 211
                                                                                  215 224 226 240 247* 256* 262 264 273 1-44* 314*
                                                                                  314 321 329* 331 344 351 358 359 362 363 365 367
                                                                                  394 396 398 401 405 406 408 409
dbc_ptr                                parameter       pointer                  dcl 374 in procedure "get_dbc_ptr" set ref 372 379*
dead_proc                16(23)        based           bit(1)                   level 3 packed unaligned dcl 2-57 set ref 233*
dead_proc_conflict       16(24)        based           bit(1)                   level 3 packed unaligned dcl 2-57 set ref 234*
error_table_$invalid_lock_reset 000010 external static fixed bin(35,0)          dcl 416 ref 156 184 271 349
error_table_$lock_wait_time_exceeded
                                000012 external static fixed bin(35,0)          dcl 417 ref 154 182 276 347
error_table_$locked_by_this_process
                                000014 external static fixed bin(35,0)          dcl 418 ref 161 403
ev_chn_id                12            based           fixed bin(71,0)          level 3 dcl 2-57 set ref 232*
event_signal_sw          16(22)        based           bit(1)                   level 3 packed unaligned dcl 2-57 set ref 238*
fil_list_ofs             22            based           bit(18)                  level 3 packed unaligned dcl 2-57 set ref 221*
fl_ptr                          000124 automatic       pointer                  initial dcl 2-110 set ref 2-110*
flags                    16            based           structure                level 2 in structure "user_list" packed unaligned
                                                                                  dcl 2-57 in procedure "mu_quiesce"
flags                     4            based           structure                level 3 in structure "dbc" packed unaligned dcl 1-14
                                                                                  in procedure "mu_quiesce"
get_group_id_                   000016 constant        entry                    external dcl 419 ref 227
get_lock_id_                    000020 constant        entry                    external dcl 420 ref 217 261 395
get_process_id_                 000022 constant        entry                    external dcl 421 ref 231 313
group_id                               based           char(32)                 level 3 packed unaligned dcl 2-57 set ref 227*
handling_a_cleanup              000110 automatic       bit(1)                   dcl 422 set ref 139* 141* 248* 250* 398
hold_ul_ptr                     000112 automatic       pointer                  dcl 423 set ref 138* 215* 216 247* 320* 331 331
icode                           000114 automatic       fixed bin(35,0)          dcl 425 set ref 150* 153 154 156 161 163* 178* 181
                                                                                  182 184 189* 194* 202* 203 203* 218 218* 240* 241
                                                                                  241* 264* 266 271 276 278* 344* 346 347 349 354*
                                                                                  359* 365* 366 366* 367* 368 368* 379* 381 381*
                                                                                  398* 401* 403 403 408* 409*
ids                                    based           structure                level 2 unaligned dcl 2-57
lock_id                         000115 automatic       bit(36)                  dcl 426 set ref 261* 262 395* 396
mdbm_data_$cleanup_lock_wait    000024 external static fixed bin(17,0)          dcl 427 set ref 398*
mdbm_data_$lock_wait            000026 external static fixed bin(17,0)          dcl 428 set ref 344* 401*
mdbm_data_$quiesce_mode         000030 external static fixed bin(17,0)          dcl 429 ref 228 317
mdbm_error_$db_busy             000032 external static fixed bin(35,0)          dcl 430 set ref 154* 182* 207* 347*
mdbm_error_$free_not_quiesced   000034 external static fixed bin(35,0)          dcl 431 set ref 269*
mdbm_error_$hold_quiesced_db    000036 external static fixed bin(35,0)          dcl 432 ref 392
mdbm_error_$my_quiesced_db      000040 external static fixed bin(35,0)          dcl 433 set ref 161* 391
mdbm_error_$quiesce_too_few     000042 external static fixed bin(35,0)          dcl 434 ref 393
mdbm_error_$quiesced_db         000044 external static fixed bin(35,0)          dcl 435 set ref 276*
mdbm_error_$quiesced_dead_db    000046 external static fixed bin(35,0)          dcl 436 set ref 159* 274*
mdbm_error_$trouble_lock        000050 external static fixed bin(35,0)          dcl 437 set ref 187* 195* 352* 360*
mu_concurrency_control$open_control_segment
                                000060 constant        entry                    external dcl 443 ref 379
next_active_ofs          22(18)        based           bit(18)                  level 3 packed unaligned dcl 2-57 set ref 222*
next_open_ofs            23(18)        based           bit(18)                  level 3 packed unaligned dcl 2-57 set ref 224* 321
                                                                                  323* 323 329*
next_waiting_ofs         23            based           bit(18)                  level 3 packed unaligned dcl 2-57 set ref 223*
null                                                   builtin function         dcl 444 in procedure "mu_quiesce" ref 138 247 1-44
                                                                                  2-109 2-110 312 314 321 331 394
null                                                   builtin function         dcl 296 in procedure "convert" ref 300
num_filns                24            based           fixed bin(17,0)          level 2 in structure "user_list" dcl 2-57
                                                                                  in procedure "mu_quiesce" set ref 215* 220* 331
num_filns                       000126 automatic       fixed bin(17,0)          dcl 2-112 in procedure "mu_quiesce" set ref 214* 215
                                                                                  215
offsets                  21            based           structure                level 3 in structure "dbc" packed unaligned dcl 1-14
                                                                                  in procedure "mu_quiesce"
offsets                  22            based           structure                level 2 in structure "user_list" packed unaligned
                                                                                  dcl 2-57 in procedure "mu_quiesce"
ofs                                    parameter       bit(18)                  unaligned dcl 294 ref 286 298 298
open_lock                12            based           bit(36)                  level 3 dcl 1-14 set ref 178* 194* 202* 240* 344*
                                                                                  359* 365* 398* 401* 408*
open_mode                16            based           fixed bin(17,0)          level 3 packed unaligned dcl 2-57 set ref 228* 317
open_users                7            based           fixed bin(17,0)          level 4 dcl 1-14 ref 199
open_users_ofs           21            based           bit(18)                  level 4 packed unaligned dcl 1-14 set ref 224 226*
                                                                                  314* 321*
passive_sw               16(18)        based           bit(1)                   level 3 packed unaligned dcl 2-57 set ref 239*
previous_ul_ptr                 000112 automatic       pointer                  dcl 326 set ref 312* 321 323 328*
priority_high            16(21)        based           bit(1)                   level 3 packed unaligned dcl 2-57 set ref 235*
proc_id                         000110 automatic       bit(36)                  unaligned dcl 325 set ref 313* 317
process_id               10            based           bit(36)                  level 3 packed unaligned dcl 2-57 set ref 231* 317
proper                                 based           structure                level 2 unaligned dcl 1-14
ptr                                                    builtin function         dcl 296 ref 298
quiesce_db                4(03)        based           bit(1)                   level 4 packed unaligned dcl 1-14 set ref 211* 363*
                                                                                  406*
quiesce_lock              5            based           bit(36)                  level 3 dcl 1-14 set ref 150* 262 264* 367* 396 409*
quiesce_sw                4(02)        based           bit(1)                   level 4 packed unaligned dcl 1-14 set ref 210* 362*
                                                                                  405*
quiesce_wait_time                      parameter       fixed bin(17,0)          dcl 134 set ref 132 132 150* 166 178*
rdbi_bits                14            based           bit(72)                  level 3 packed unaligned dcl 2-57 set ref 219*
rel                                                    builtin function         dcl 444 ref 226
result                          000106 automatic       pointer                  dcl 292 set ref 298* 300* 302
set_lock_$lock                  000052 constant        entry                    external dcl 438 ref 150 178 264 344 398 401
set_lock_$unlock                000054 constant        entry                    external dcl 439 ref 194 202 240 359 365 367 408 409
static_area              30            based           area                     level 2 dcl 1-14 ref 215 331
time_remaining                  000116 automatic       fixed bin(71,0)          dcl 441 set ref 166* 169 172* 172
timer_manager_$sleep            000056 constant        entry                    external dcl 442 ref 173
trouble_switch            4            based           bit(1)                   level 4 packed unaligned dcl 1-14 set ref 158* 186*
                                                                                  193 273* 351* 358
ul_ptr                          000122 automatic       pointer                  initial dcl 2-109 set ref 216* 217 219 220 221 222
                                                                                  223 224 226 227 228 229 230 231 232 233 234 235
                                                                                  236 237 238 239 2-109* 314* 314* 317 317 320 321
                                                                                  323 328* 329
user_counts               7            based           structure                level 3 unaligned dcl 1-14
user_list                              based           structure                level 1 unaligned dcl 2-57 set ref 215 331
waiting_sw               16(20)        based           bit(1)                   level 3 packed unaligned dcl 2-57 set ref 236*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALARM                                  automatic       fixed bin(71,0)          dcl 2-127
ALIVE                                  internal static bit(1)                   initial unaligned dcl 2-136
CHAR_ALARM                             internal static char(8)                  initial unaligned dcl 2-125
CHAR_Q_F                               internal static char(8)                  initial unaligned dcl 2-123
DEAD                                   internal static bit(1)                   initial unaligned dcl 2-138
DEL                                    internal static bit(1)                   initial unaligned dcl 2-134
DQ_OPEN                                internal static bit(1)                   initial unaligned dcl 2-119
FIRST_QUEUE                            internal static bit(1)                   initial unaligned dcl 2-128
FREE_FIL_LIST                          internal static bit(1)                   initial unaligned dcl 2-150
NO_DQ_OPEN                             internal static bit(1)                   initial unaligned dcl 2-121
QUEUE_AGAIN                            internal static bit(1)                   initial unaligned dcl 2-130
QUE_FREE                               automatic       fixed bin(71,0)          dcl 2-124
Q_PRM                                  internal static fixed bin(35,0)          initial dcl 2-140
Q_PRM_BITS                             internal static bit(2)                   initial unaligned dcl 2-144
Q_PRV                                  internal static fixed bin(35,0)          initial dcl 2-142
Q_PRV_BITS                             internal static bit(2)                   initial unaligned dcl 2-146
REL_SEC                                internal static bit(2)                   initial unaligned dcl 2-148
SAVE_FIL_LIST                          internal static bit(1)                   initial unaligned dcl 2-152
SET                                    internal static bit(1)                   initial unaligned dcl 2-132
VERSION_NBR                            internal static fixed bin(17,0)          initial dcl 1-46
WAIT                                   internal static fixed bin(17,0)          initial dcl 2-115
fil_list                               based           structure                level 1 unaligned dcl 2-89
fixed                                                  builtin function         dcl 444
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 440

NAMES DECLARED BY EXPLICIT CONTEXT.
check_opens                     000235 constant        label                    dcl 175 ref 167
common_exit                     000710 constant        label                    dcl 283 set ref 242 340
convert                         000712 constant        entry                    internal dcl 286 ref 314 329
delete_quiesce_user_from_list   000736 constant        entry                    internal dcl 306 ref 364 407
error                           001060 constant        entry                    internal dcl 336 ref 154 159 161 163 182 187 189 195
                                                                                  203 207 218 241 269 274 276 278 347 352 354 360
                                                                                  366 368 381
free                            000533 constant        entry                    external dcl 244
free_db                         001071 constant        entry                    internal dcl 343 ref 268 281
free_user_storage               001042 constant        label                    dcl 330 ref 324
get_dbc_ptr                     001233 constant        entry                    internal dcl 372 ref 147 256
mu_quiesce                      000030 constant        entry                    external dcl 18
quiesce_db_ok                   000362 constant        label                    dcl 209 ref 199
quiesce_free                    000547 constant        entry                    external dcl 244
quiesce_quiet                   000057 constant        entry                    external dcl 132
quiet                           000043 constant        entry                    external dcl 132
tidy_up                         001262 constant        entry                    internal dcl 387 ref 142 251 339

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2024        2106    1440        2034
Length      2374    1440        62         252     363           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mu_quiesce                          138 external procedure  is an external procedure.  
on unit on line 140                  64 on unit               
on unit on line 249                  64 on unit               
convert                                 internal procedure  shares stack frame of internal procedure delete_quiesce_user_from_list  
delete_quiesce_user_from_list        92 internal procedure  is called by several nonquick procedures.  
error                                   internal procedure  shares stack frame of external procedure mu_quiesce.  
free_db                                 internal procedure  shares stack frame of external procedure mu_quiesce.  
get_dbc_ptr                             internal procedure  shares stack frame of external procedure mu_quiesce.  
tidy_up                              76 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
delete_quiesce_user_from_list
                         000106 result                      convert
                         000110 proc_id                     delete_quiesce_user_from_list
                         000112 previous_ul_ptr             delete_quiesce_user_from_list
mu_quiesce               000100 bc                          mu_quiesce
                         000110 handling_a_cleanup          mu_quiesce
                         000112 hold_ul_ptr                 mu_quiesce
                         000114 icode                       mu_quiesce
                         000115 lock_id                     mu_quiesce
                         000116 time_remaining              mu_quiesce
                         000120 dbc_ptr                     mu_quiesce
                         000122 ul_ptr                      mu_quiesce
                         000124 fl_ptr                      mu_quiesce
                         000126 num_filns                   mu_quiesce

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        call_int_this       call_int_other      return_mac          enable_op           ext_entry
int_entry           op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_group_id_                 get_lock_id_                  get_process_id_
mu_concurrency_control$open_control_segment                 set_lock_$lock                set_lock_$unlock
timer_manager_$sleep

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$invalid_lock_reset                             error_table_$lock_wait_time_exceeded
error_table_$locked_by_this_process                         mdbm_data_$cleanup_lock_wait  mdbm_data_$lock_wait
mdbm_data_$quiesce_mode       mdbm_error_$db_busy           mdbm_error_$free_not_quiesced mdbm_error_$hold_quiesced_db
mdbm_error_$my_quiesced_db    mdbm_error_$quiesce_too_few   mdbm_error_$quiesced_db       mdbm_error_$quiesced_dead_db
mdbm_error_$trouble_lock




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 1   44 000021    2  109 000023    2  110 000024        18 000027       132 000036       138 000070       139 000073
    140 000074       141 000110       142 000113       143 000120       144 000121       147 000122       150 000124
    153 000141       154 000143       156 000154       158 000160       159 000163       161 000171       163 000203
    166 000205       167 000211       169 000212       172 000214       173 000220       175 000235       178 000236
    181 000253       182 000255       184 000266       186 000272       187 000275       188 000303       189 000304
    193 000306       194 000312       195 000323       199 000332       202 000335       203 000346       204 000352
    207 000353       209 000362       210 000363       211 000366       214 000370       215 000371       216 000405
    217 000406       218 000416       219 000422       220 000426       221 000427       222 000431       223 000433
    224 000435       226 000441       227 000443       228 000452       229 000457       230 000460       231 000461
    232 000467       233 000472       234 000474       235 000476       236 000500       237 000502       238 000504
    239 000506       240 000510       241 000522       242 000526       244 000527       247 000560       248 000563
    249 000564       250 000600       251 000603       252 000610       253 000611       256 000612       261 000614
    262 000623       264 000627       266 000643       268 000645       269 000646       270 000655       271 000656
    273 000661       274 000664       275 000672       276 000673       278 000704       279 000706       281 000707
    283 000710       284 000711       286 000712       298 000714       300 000730       302 000732       306 000735
    312 000743       313 000745       314 000753       317 000775       320 001006       321 001007       323 001020
    324 001023       328 001024       329 001025       330 001042       331 001043       333 001057       336 001060
    338 001062       339 001064       340 001070       343 001071       344 001072       346 001106       347 001110
    349 001121       351 001125       352 001130       353 001136       354 001137       358 001141       359 001145
    360 001156       362 001165       363 001170       364 001172       365 001176       366 001210       367 001214
    368 001226       369 001232       372 001233       379 001235       381 001254       384 001260       387 001261
    391 001267       392 001273       393 001275       394 001277       395 001303       396 001311       398 001316
    401 001334       403 001347       405 001355       406 001360       407 001362       408 001367       409 001402
    411 001415


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
