	COMPILATION LISTING OF SEGMENT fm_attribute_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/24/85  0833.5 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* DESCRIPTION:
        8*
        9*          This module and the module fm_attribute_fref_ together contain
       10*     all operations which deal with Data Management files as file system
       11*     objects.  These operations mimic the operations in the suffix_chess_
       12*     example in MTB-671.
       13*     These operations are the eventual targets of entries in
       14*     fs_util_, the file system utility for handling file system objects
       15*     and extended objects. fm_attribute_fref_ contains those operations
       16*     which require the process to be using Data Management - per-process
       17*     initialization will be executed if it has not already been executed.
       18*     This module, fm_attribute_, contains those operations which do not
       19*     require the process to be using Data Management.
       20**/
       21 
       22 /* HISTORY:
       23*
       24*Written by Steve Herbst, 02/25/83.
       25*            (Copied from mbx_suffix_.)
       26*Modified:
       27*03/25/83 by S. Herbst:  Deleted $delentry_file (file_manager_ will call 
       28*            file_manager_$delete), fixed bugs.
       29*05/23/83 by S. Herbst:  Fixed $suffix_info to return modes of "rew".
       30*06/17/83 by S. Herbst:  Changed $suffix_info to set new copy_flags.
       31*06/28/83 by S. Herbst:  Changed to use copy_flags.incl.pl1.
       32*07/07/83 by S. Herbst:  Fixed ACL entries to reject modes other than r, rw, 
       33*            and null.
       34*07/20/83 by S. Herbst:  Fixed $get_user_access_modes to return the mode on 
       35*            the 1st component.
       36*08/18/83 by S. Herbst:  Added suffix_info.info_pathname.
       37*10/25/83 by L. Spratt: Added sub_error_ handler to validate_proc to turn any 
       38*            sub_error_ into a not_seg_type error .
       39*12/12/83 by Lee Baldwin:  Changed the description and history sections to the
       40*            canonical format.
       41*12/13/83 by Lee Baldwin:  Moved ACL primitives from fm_open_ to this
       42*            procedure.  Changed entries which require validation to use
       43*            fm_validate_ instead of validate_proc.  Removed the "open" and
       44*            "validate_proc" routines.  Removed the format: off stmt.
       45*12/22/83 by Matthew Pierret:  Changed to return dm_error_$file_not_dm_type if
       46*            the call to fm_validate_ fails.
       47*03/16/84 by Matthew Pierret:  Changed to return dm_error_$file_not_dm_type
       48*            only if fm_validate_ returns error_table_$not_seg_type.
       49*07/30/84 by Matthew Pierret:  Changed to check extended ring brackets.
       50*11/13/84 by Matthew Pierret:  Split into fm_attribute_ and fm_attribute_fref_.
       51*            Moved get_switch and chname_file to fm_attribute_fref_.
       52*            Changed list_switches to return the protection, concurrency and
       53*            rollback switches.
       54*12/06/84 by Matthew Pierret:  Changed RETURN to set p_code to 0.  Changed
       55*            list_switches to not call RETURN as it does not have a p_code.
       56*            Added declaration for rtrim, removed several declarations of 
       57*            un-used variables.
       58*12/07/84 by Lee A. Newcomb:  Removed rtrim usage in pathname_ calls.
       59*12/20/84 by Matthew Pierret:  Changed several entries to match the calling
       60*            sequences of suffix_chess_ in MTB671, which fm_attribute_ and
       61*            fm_attribute_fref_ are intended to duplicate.
       62*            add_acl_entries - removed p_acl_count, made to accept only
       63*            p_acl_ptr->general_acl, convert general_acl to segment_acl_array
       64*            for use by msf_manager_$acl_add;
       65*            add_extended_acl_entries - changed p_exmodes to p_acl_ptr;
       66*            delete_acl_entries - removed p_arg_count, made to accept only
       67*            p_acl_ptr->general_acl, convert general_acl to delete_acl_array;
       68*            get_user_access_modes - to set validation level;
       69*            list_acl - removed p_listed_acl_ptr, p_explicit_acl_ptr and
       70*            p_acl_count in favor of p_acl_ptr, made to correctly interpret
       71*            input values (null p_acl_ptr means get everything, non-null
       72*            p_acl_ptr means get whats in p_acl_ptr->general_acl, null
       73*            p_user_area_ptr means allocate in get_user_free_area_()), made
       74*            to convert to and from segment_acl_array around calls to
       75*            msf_manager_, add p_version_wanted parameter;
       76*            list_extended_acl - add p_version_wanted parameter;
       77*            list_switches - added short names of switches, add p_code and
       78*            p_version_wnated parameters, made to use get_user_free_area_() if 
       79*            p_user_area_ptr is null;
       80*            replace_acl - removed p_acl_count, made to only accept
       81*            general_acl, to convert general_acl to segment_acl_array;
       82*            replace_extended_acl - removed p_acl_count.
       83*12/26/84 by Matthew Pierret: Changed suffix_info to set type, standard_object,
       84*            and num_ring_brackets.
       85*01/03/85 by Lee A. Newcomb:  Fixed $get_user_access_modes to set p_modes
       86*            return parameter instead of leaving it null; fixed "Written by"
       87*            HISTORY line so subsys_add_journalization.ec works.
       88*01/04/85 by Matthew Pierret:  Fixed replace_acl's one incorrect use of
       89*            segment_acl to the correct general_acl.  Changed suffix_info
       90*            to return a max_mode_len of 3 (instead of 2) and the mode string
       91*            "r w" (instead of "rw").  This change allows callers to use
       92*            the standard access mode constants.
       93*05/12/85 by S. Cox: (add delete)_acl_entries/replace_acl: Chg so the DM daemon 
       94*	  will always have 'rw' access, overriding whatever the user gave.
       95*04/16/85 by Lindsey L. Spratt:  Added initializtion to "null()" for all of the
       96*            automatic pointers.  Initializing msf_ptr to null fixed a bug in
       97*            calls to the FINISH proc where spurious attempts to close the
       98*            (non-existent) msf identified by the (garbage) msf_ptr caused
       99*            random faults.  Added initialization to UNSET_VALIDATION_LEVEL of
      100*	  the callers_validation_level.  These initializations were being 
      101*	  done in the INIT_FOR_FINISH proc, but not all entries remembered
      102*	  to call INIT_FOR_FINISH.  Doing the inits in the declarations
      103*	  guarantees that the initializations are done, rather than rely on
      104*	  each entry to remember to call INIT_FOR_FINISH.
      105*	       Changed suffix_info entry to turn off the copy flags for
      106*	  max_length, and the copy and dumper switches.  Changed uses of
      107*	  "1"b and "0"b to YES and NO, respectively.
      108**/
      109 
      110 /* format: style2,ind3 */
      111 
      112 fm_attribute_$suffix_info:
      113    procedure (p_suffix_info_ptr);
      114 
      115 
      116 /* Parameter */
      117 
      118       dcl	    p_acl_ptr	       pointer parameter;
      119       dcl	    p_bit_count	       fixed bin (24) parameter;
      120       dcl	    p_code	       fixed bin (35) parameter;
      121       dcl	    p_ename	       char (*) parameter;
      122       dcl	    p_exmodes	       bit (36) aligned parameter;
      123       dcl	    p_dirname	       char (*) parameter;
      124       dcl	    p_max_length	       fixed bin (19) parameter;
      125       dcl	    p_modes	       bit (36) aligned parameter;
      126       dcl	    p_no_sysdaemon	       bit (1) parameter;
      127       dcl	    p_ring	       fixed bin parameter;
      128       dcl	    p_ring_brackets	       (2) fixed bin (3) parameter;
      129       dcl	    p_suffix_info_ptr      pointer parameter;
      130       dcl	    p_switch_list_ptr      ptr parameter;
      131       dcl	    p_switch_name	       char (*) parameter;
      132       dcl	    p_switch_value	       bit (1) parameter;
      133       dcl	    p_user_area_ptr	       pointer parameter;
      134       dcl	    p_user_name	       char (*) parameter;
      135       dcl	    p_version_wanted       char (*) parameter;
      136 
      137 /* Automatic */
      138 
      139       dcl	    dirname	       char (168);
      140       dcl	    ename		       char (32);
      141       dcl	    user_name	       char (64);
      142       dcl	    version_wanted	       char (8) aligned;
      143 
      144       dcl	    delete_acl_array_ptr   ptr init (null ());
      145       dcl	    msf_ptr	       ptr init (null ());
      146       dcl	    segment_acl_array_ptr  ptr init (null ());
      147       dcl	    system_area_ptr	       ptr init (null ());
      148       dcl	    user_area_ptr	       ptr init (null ());
      149 
      150 
      151       dcl	    acl_idx	       fixed bin;
      152       dcl	    callers_validation_level
      153 			       fixed bin init (UNSET_VALIDATION_LEVEL);
      154       dcl	    attempt_to_change_daemon_access
      155 			       bit (1) aligned init (NO);
      156       dcl	    code		       fixed bin (35) init (0);
      157       dcl	    extended_ring_brackets (2) fixed bin (3);
      158       dcl	    exmodes	       bit (36) aligned;
      159       dcl	    mode_bits	       bit (3);
      160       dcl	    modes		       bit (36) aligned;
      161       dcl	    no_sysdaemon	       bit (1);
      162       dcl	    ring		       fixed bin;
      163 
      164 /* Based */
      165 
      166       dcl	    user_area	       area based (user_area_ptr);
      167       dcl	    system_area	       area based (system_area_ptr);
      168 
      169 /* Builtins */
      170 
      171       dcl	    (null, string, substr, unspec)
      172 			       builtin;
      173 
      174 /* Condition */
      175 
      176       dcl	    cleanup	       condition;
      177 
      178 /* Constant */
      179 
      180       dcl	    (
      181 	    READ_BRACKET_IDX       init (2),
      182 	    WRITE_BRACKET_IDX      init (1)
      183 	    )		       fixed bin internal static options (constant);
      184 /**** Cannot use dm_system_data_$initializer_name since it sets off the fref */
      185       dcl	    DM_INITIALIZER_NAME    char (32) aligned static options (constant) init ("Data_Management.Daemon.*");
      186       dcl	    UNSET_VALIDATION_LEVEL init (-1) fixed bin internal static options (constant);
      187       dcl	    (
      188 	    NO		       init ("0"b),
      189 	    YES		       init ("1"b)
      190 	    )		       bit (1) aligned internal static options (constant);
      191 
      192 /* Entry */
      193 
      194       dcl	    cu_$level_get	       entry (fixed bin);
      195       dcl	    cu_$level_set	       entry (fixed bin);
      196       dcl	    fm_validate_$check_read_ring_bracket
      197 			       entry (char (*), char (*), fixed bin (35));
      198       dcl	    fm_validate_$check_write_ring_bracket
      199 			       entry (char (*), char (*), fixed bin (35));
      200       dcl	    fm_validate_$get_ring_brackets
      201 			       entry (char (*), char (*), (2) fixed bin (3), fixed bin (35));
      202       dcl	    get_ring_	       entry returns (fixed bin);
      203       dcl	    get_system_free_area_  entry () returns (ptr);
      204       dcl	    get_user_free_area_    entry () returns (ptr);
      205       dcl	    hcs_$get_user_access_modes
      206 			       entry (char (*), char (*), char (*), fixed bin, bit (36) aligned, bit (36) aligned,
      207 			       fixed bin (35));
      208       dcl	    msf_manager_$acl_add   entry (ptr, ptr, fixed bin, fixed bin (35));
      209       dcl	    msf_manager_$acl_delete
      210 			       entry (ptr, ptr, fixed bin, fixed bin (35));
      211       dcl	    msf_manager_$acl_list  entry (ptr, ptr, ptr, ptr, fixed bin, fixed bin (35));
      212       dcl	    msf_manager_$acl_replace
      213 			       entry (ptr, ptr, fixed bin, bit (1), fixed bin (35));
      214       dcl	    msf_manager_$close     entry (ptr);
      215       dcl	    msf_manager_$open      entry (char (*), char (*), ptr, fixed bin (35));
      216       dcl	    pathname_	       entry (char (*), char (*)) returns (char (168));
      217 
      218 /* External */
      219 
      220       dcl	    dm_error_$file_not_dm_type
      221 			       fixed bin (35) ext;
      222       dcl	    error_table_$invalid_mode
      223 			       fixed bin (35) ext;
      224       dcl	    error_table_$not_seg_type
      225 			       fixed bin (35) ext;
      226       dcl	    error_table_$unimplemented_version
      227 			       fixed bin (35) ext;
      228       dcl	    error_table_$unsupported_operation
      229 			       fixed bin (35) ext;
      230 
      231 /* DESCRIPTION OF suffix_info ENTRY:
      232*
      233*        Returns generic information about DM files.  
      234*   p_suffix_info_ptr must point to a suffix_info structure which has
      235*   its version element set.
      236**/
      237 
      238 /* The actual entry is the main procedure statement. 
      239*   It is repeated here for clarity.
      240*
      241*suffix_info:
      242*   entry (p_suffix_info_ptr);
      243**/
      244 
      245       suffix_info_ptr = p_suffix_info_ptr;
      246 
      247       suffix_info.version = SUFFIX_INFO_VERSION_1;
      248       suffix_info.type = FS_OBJECT_TYPE_DM_FILE;
      249       suffix_info.type_name = "DM file";
      250       suffix_info.plural_name = "DM files";
      251       string (suffix_info.flags) = ""b;
      252       suffix_info.standard_object = YES;
      253       suffix_info.extended_acl = NO;
      254       suffix_info.modes = "r w";
      255       suffix_info.max_mode_len = 3;
      256       suffix_info.num_ring_brackets = 2;
      257 
      258       unspec (suffix_info.copy_flags) = ""b;
      259       suffix_info.copy_flags.names = YES;
      260       suffix_info.copy_flags.acl = YES;
      261       suffix_info.copy_flags.max_length = NO;
      262       suffix_info.copy_flags.copy_switch = NO;
      263       suffix_info.copy_flags.safety_switch = NO;
      264       suffix_info.copy_flags.dumper_switches = NO;
      265 
      266       suffix_info.info_pathname = "";
      267 
      268 MAIN_RETURN:
      269       return;
      270 
      271 RETURN:
      272    proc ();
      273 
      274       p_code = 0;
      275       go to MAIN_RETURN;
      276 
      277    end RETURN;
      278 
      279 ERROR_RETURN:
      280    proc (er_p_code);
      281 
      282       dcl	    er_p_code	       fixed bin (35) parameter;
      283 
      284       p_code = er_p_code;
      285       call FINISH ();
      286       go to MAIN_RETURN;
      287 
      288    end ERROR_RETURN;
      289 
      290 FINISH:
      291    proc ();
      292 
      293       if msf_ptr ^= null ()
      294       then call msf_manager_$close (msf_ptr);
      295       if delete_acl_array_ptr ^= null
      296       then
      297          do;
      298 	  free delete_acl_array_ptr -> delete_acl_array;
      299 	  delete_acl_array_ptr = null ();
      300          end;
      301       if segment_acl_array_ptr ^= null ()
      302       then
      303          do;
      304 	  free segment_acl_array_ptr -> segment_acl_array;
      305 	  segment_acl_array_ptr = null ();
      306          end;
      307       if callers_validation_level ^= UNSET_VALIDATION_LEVEL
      308       then call cu_$level_set (callers_validation_level);
      309 
      310    end FINISH;
      311 
      312 /* DESCRIPTION OF add_acl_entries ENTRY:
      313*   
      314*        Adds ACL entries to a DM file.
      315*   
      316*   p_dirname is the pathname of the directory containing the DM file.
      317*   p_ename is the entry name of the DM file.
      318*   p_acl_ptr points to a general_acl structure containing the new
      319*             ACL entries.
      320*   p_code is an output status code.
      321**/
      322 
      323 add_acl_entries:
      324    entry (p_dirname, p_ename, p_acl_ptr, p_code);
      325 
      326       dirname = p_dirname;
      327       ename = p_ename;
      328       acl_ptr = p_acl_ptr;
      329 
      330       code = 0;
      331 
      332       if acl_ptr -> general_acl.version ^= GENERAL_ACL_VERSION_1
      333       then call ERROR_RETURN (error_table_$unimplemented_version);
      334 
      335       acl_count = acl_ptr -> general_acl.count;
      336       do acl_idx = 1 to acl_count;			/* check for invalid DM file modes */
      337          mode_bits = substr (acl_ptr -> general_acl.entries (acl_idx).mode, 1, 3);
      338          if mode_bits ^= R_ACCESS & mode_bits ^= RW_ACCESS & mode_bits ^= N_ACCESS
      339          then call ERROR_RETURN (error_table_$invalid_mode);
      340       end;
      341 
      342       call fm_validate_$check_write_ring_bracket (dirname, ename, code);
      343       if code ^= 0
      344       then if code = error_table_$not_seg_type
      345 	 then call ERROR_RETURN (dm_error_$file_not_dm_type);
      346 	 else call ERROR_RETURN (code);
      347 
      348       call cu_$level_get (callers_validation_level);
      349       on cleanup call FINISH ();
      350       call cu_$level_set (get_ring_ ());
      351 
      352       system_area_ptr = get_system_free_area_ ();
      353 
      354       allocate segment_acl_array in (system_area) set (segment_acl_array_ptr);
      355 
      356       segment_acl_array_ptr -> segment_acl_array.access_name (*) = acl_ptr -> general_acl.entries.access_name (*);
      357       segment_acl_array_ptr -> segment_acl_array.mode (*) = acl_ptr -> general_acl.entries.mode (*);
      358       segment_acl_array_ptr -> segment_acl_array.extended_mode (*) = ""b;
      359       segment_acl_array_ptr -> segment_acl_array.status_code (*) = acl_ptr -> general_acl.entries.status_code (*);
      360 
      361       do acl_idx = 1 to acl_count
      362 	 while (segment_acl_array_ptr -> segment_acl_array (acl_idx).access_name ^= DM_INITIALIZER_NAME);
      363       end;
      364       if acl_idx <= acl_count				/* daemon access must be rw */
      365       then segment_acl_array_ptr -> segment_acl_array (acl_idx).mode = RW_ACCESS;
      366 
      367       call msf_manager_$open (dirname, ename, msf_ptr, code);
      368       if msf_ptr = null
      369       then call ERROR_RETURN (code);
      370 
      371       call msf_manager_$acl_add (msf_ptr, segment_acl_array_ptr, acl_count, code);
      372       if code ^= 0
      373       then call ERROR_RETURN (code);
      374 
      375 
      376       call FINISH ();
      377 
      378       call RETURN ();
      379 
      380 /* DESCRIPTION OF add_extended_acl_entries ENTRY:  Unsupported */
      381 
      382 add_extended_acl_entries:
      383    entry (p_dirname, p_ename, p_acl_ptr, p_code);
      384 
      385       call ERROR_RETURN (error_table_$unsupported_operation);
      386 
      387 
      388 /*  DESCRIPTION OF delete_acl_entries ENTRY:
      389*   
      390*        Deletes ACL entries from a DM file.
      391*   
      392*   p_dirname is the pathname of the directory containing the DM file.
      393*   p_ename is the entry name of the DM file.
      394*   p_acl_ptr points to a general_acl structure containing the 
      395*             ACL entries to be deleted.
      396*   p_code is an output status code.
      397*
      398**/
      399 
      400 delete_acl_entries:
      401    entry (p_dirname, p_ename, p_acl_ptr, p_code);
      402 
      403       dirname = p_dirname;
      404       ename = p_ename;
      405       acl_ptr = p_acl_ptr;
      406 
      407       code = 0;
      408       attempt_to_change_daemon_access = NO;
      409 
      410       if acl_ptr -> general_acl.version ^= GENERAL_ACL_VERSION_1
      411       then call ERROR_RETURN (error_table_$unimplemented_version);
      412 
      413       acl_count = acl_ptr -> general_acl.count;
      414 
      415       call fm_validate_$check_write_ring_bracket (dirname, ename, code);
      416       if code ^= 0
      417       then if code = error_table_$not_seg_type
      418 	 then call ERROR_RETURN (dm_error_$file_not_dm_type);
      419 	 else call ERROR_RETURN (code);
      420 
      421       call cu_$level_get (callers_validation_level);
      422       on cleanup call FINISH ();
      423       call cu_$level_set (get_ring_ ());
      424 
      425       system_area_ptr = get_system_free_area_ ();
      426 
      427       alloc delete_acl_array in (system_area) set (delete_acl_array_ptr);
      428 
      429       delete_acl_array_ptr -> delete_acl_array.access_name (*) = acl_ptr -> general_acl.entries.access_name (*);
      430       delete_acl_array_ptr -> delete_acl_array.status_code (*) = acl_ptr -> general_acl.entries.status_code (*);
      431 
      432       do acl_idx = 1 to acl_count
      433 	 while (delete_acl_array_ptr -> delete_acl_array (acl_idx).access_name ^= DM_INITIALIZER_NAME);
      434       end;
      435       if acl_idx <= acl_count
      436       then attempt_to_change_daemon_access = YES;		/* explicitly readd daemon access */
      437 
      438       call msf_manager_$open (dirname, ename, msf_ptr, code);
      439       if msf_ptr = null
      440       then call ERROR_RETURN (code);
      441 
      442       call msf_manager_$acl_delete (msf_ptr, delete_acl_array_ptr, acl_count, code);
      443       if code ^= 0
      444       then call ERROR_RETURN (code);
      445 
      446       if attempt_to_change_daemon_access
      447       then
      448          do;
      449 	  allocate segment_acl_array in (system_area) set (segment_acl_array_ptr);
      450 	  unspec (segment_acl_array_ptr -> segment_acl_array) = ""b;
      451 	  segment_acl_array_ptr -> segment_acl_array.access_name (1) = DM_INITIALIZER_NAME;
      452 	  segment_acl_array_ptr -> segment_acl_array.mode (1) = RW_ACCESS;
      453 	  call msf_manager_$acl_add (msf_ptr, segment_acl_array_ptr, (1), code);
      454 	  if code ^= 0
      455 	  then call ERROR_RETURN (code);
      456          end;
      457 
      458       call FINISH ();
      459 
      460       call RETURN ();
      461 
      462 /* DESCRIPTION OF get_bit_count ENTRY:  Unsupported. */
      463 
      464 get_bit_count:
      465    entry (p_dirname, p_ename, p_bit_count, p_code);
      466 
      467       call ERROR_RETURN (error_table_$unsupported_operation);
      468 
      469 /* DESCRIPTION OF get_max_length ENTRY:  Unsupported. */
      470 
      471 get_max_length:
      472    entry (p_dirname, p_ename, p_max_length, p_code);
      473 
      474       call ERROR_RETURN (error_table_$unsupported_operation);
      475 
      476 /* DESCRIPTION OF get_ring_brackets ENTRY:
      477*
      478*        Gets the file ring brackets of the DM file.  The file ring brackets
      479*   are maintained by file_manager_ and are not necessarily the same as the
      480*   file system ring brackets.  The file ring brackets are stored in two
      481*   places: the file_attributes in the file and in an encoded form as the
      482*   bit count of the file's first component.  This entry gets the encoded
      483*   ring brackets, which can be referenced without requiring per-process
      484*   initialization.
      485**/
      486 
      487 get_ring_brackets:
      488    entry (p_dirname, p_ename, p_ring_brackets, p_code);
      489 
      490       dirname = p_dirname;
      491       ename = p_ename;
      492 
      493       code = 0;
      494 
      495       call fm_validate_$get_ring_brackets (dirname, ename, extended_ring_brackets, code);
      496       if code ^= 0
      497       then call ERROR_RETURN (code);
      498 
      499       p_ring_brackets (*) = extended_ring_brackets (*);
      500 
      501       call RETURN ();
      502 
      503 /* DESCRIPTION OF get_user_access_modes ENTRY:
      504*
      505*        Gets the access modes and extended access modes (not yet supported) 
      506*   of a DM file for a user.
      507**/
      508 
      509 get_user_access_modes:
      510    entry (p_dirname, p_ename, p_user_name, p_ring, p_modes, p_exmodes, p_code);
      511 
      512       dirname = p_dirname;
      513       ename = p_ename;
      514       user_name = p_user_name;
      515       ring = p_ring;
      516 
      517 
      518       code = 0;
      519       p_modes = ""b;
      520       p_exmodes = ""b;				/* Not supported */
      521 
      522       call fm_validate_$get_ring_brackets (dirname, ename, extended_ring_brackets, code);
      523       if code ^= 0
      524       then call ERROR_RETURN (code);
      525 
      526       call cu_$level_get (callers_validation_level);
      527       on cleanup call FINISH ();
      528       call cu_$level_set (get_ring_ ());
      529 
      530       call hcs_$get_user_access_modes (pathname_ (dirname, ename), "0", user_name, get_ring_ (), modes, exmodes, code);
      531       if code ^= 0
      532       then call ERROR_RETURN (code);
      533 
      534       if ring <= extended_ring_brackets (WRITE_BRACKET_IDX)
      535       then modes = (modes & RW_ACCESS);
      536       else if ring <= extended_ring_brackets (READ_BRACKET_IDX)
      537       then modes = (modes & R_ACCESS);
      538       else modes = ""b;
      539 
      540       call FINISH ();
      541 
      542       p_modes = modes;
      543       call RETURN ();
      544 
      545 /* DESCRIPTION OF list_acl ENTRY:
      546*   
      547*        Lists ACL entries on a DM file.
      548*
      549*   p_dirname is the pathname of the directory containing the DM file.
      550*   p_ename is the entry name of the DM file.
      551*   p_version_wanted is the version of the structure to be returned.
      552*             Only GENERAL_ACL_VERSION_1 is supported.
      553*   p_user_area_ptr is a pointer to an area in which to allocate the return
      554*             if one must be allocated.  If null, get_user_free_area_() is used.
      555*   p_acl_ptr is a pointer to a general_acl structure.  If null, the general_acl
      556*             structure is allocated in the user area and contains all of the
      557*             ACL entries on the file.  If non-null, then p_acl_ptr->general_acl
      558*             is filled in with the ACL entries specified by
      559*             p_acl_ptr->general_acl.entries.access_name(*).
      560*   p_code is an output status code.
      561*
      562*   */
      563 
      564 list_acl:
      565    entry (p_dirname, p_ename, p_version_wanted, p_user_area_ptr, p_acl_ptr, p_code);
      566 
      567       dirname = p_dirname;
      568       ename = p_ename;
      569       version_wanted = p_version_wanted;
      570       user_area_ptr = p_user_area_ptr;
      571       acl_ptr = p_acl_ptr;
      572 
      573 
      574       code = 0;
      575 
      576       if acl_ptr = null ()
      577       then if version_wanted ^= GENERAL_ACL_VERSION_1
      578 	 then call ERROR_RETURN (error_table_$unimplemented_version);
      579 	 else acl_count = 0;
      580       else if acl_ptr -> general_acl.version ^= GENERAL_ACL_VERSION_1
      581       then call ERROR_RETURN (error_table_$unimplemented_version);
      582       else acl_count = acl_ptr -> general_acl.count;
      583 
      584       call fm_validate_$check_read_ring_bracket (dirname, ename, code);
      585       if code ^= 0
      586       then if code = error_table_$not_seg_type
      587 	 then call ERROR_RETURN (dm_error_$file_not_dm_type);
      588 	 else call ERROR_RETURN (code);
      589 
      590       call cu_$level_get (callers_validation_level);
      591       on cleanup call FINISH ();
      592       call cu_$level_set (get_ring_ ());
      593 
      594       call msf_manager_$open (dirname, ename, msf_ptr, code);
      595       if msf_ptr = null
      596       then call ERROR_RETURN (code);
      597 
      598       system_area_ptr = get_system_free_area_ ();
      599       if acl_ptr ^= null ()
      600       then
      601          do;
      602 	  alloc segment_acl_array in (system_area) set (segment_acl_array_ptr);
      603 	  segment_acl_array_ptr -> segment_acl_array.access_name (*) = acl_ptr -> general_acl.entries.access_name (*);
      604 
      605 	  call msf_manager_$acl_list (msf_ptr, null (), null (), segment_acl_array_ptr, acl_count, code);
      606 	  if code ^= 0
      607 	  then call ERROR_RETURN (code);
      608 
      609 	  acl_ptr -> general_acl.entries.access_name (*) = segment_acl_array_ptr -> segment_acl_array.access_name (*);
      610 	  acl_ptr -> general_acl.entries.mode (*) = segment_acl_array_ptr -> segment_acl_array.mode (*);
      611 	  acl_ptr -> general_acl.entries.status_code (*) = segment_acl_array_ptr -> segment_acl_array.status_code (*);
      612 
      613          end;
      614       else
      615          do;
      616 	  call msf_manager_$acl_list (msf_ptr, system_area_ptr, segment_acl_array_ptr, null (), acl_count, code);
      617 	  if code ^= 0
      618 	  then call ERROR_RETURN (code);
      619 
      620 	  if user_area_ptr = null
      621 	  then user_area_ptr = get_user_free_area_ ();
      622 
      623 	  alloc general_acl in (user_area) set (acl_ptr);
      624 
      625 	  acl_ptr -> general_acl.version = version_wanted;
      626 	  acl_ptr -> general_acl.entries.access_name (*) = segment_acl_array_ptr -> segment_acl_array.access_name (*);
      627 	  acl_ptr -> general_acl.entries.mode (*) = segment_acl_array_ptr -> segment_acl_array.mode (*);
      628 	  acl_ptr -> general_acl.entries.status_code (*) = segment_acl_array_ptr -> segment_acl_array.status_code (*);
      629          end;
      630 
      631       p_acl_ptr = acl_ptr;
      632 
      633       call FINISH ();
      634 
      635       call RETURN ();
      636 
      637 
      638 /* DESCRIPTION OF list_extended_acl ENTRY:  Unsupported. */
      639 
      640 list_extended_acl:
      641    entry (p_dirname, p_ename, p_version_wanted, p_user_area_ptr, p_acl_ptr, p_code);
      642 
      643       call ERROR_RETURN (error_table_$unsupported_operation);
      644 
      645 /* DESCRIPTION OF list_switches ENTRY:
      646*     
      647*        Returns names of non-standard switches.  Three switches are
      648*   supported: protection, concurrency and rollback.
      649*
      650*   p_version_wanted is the version of the switch_list to be returned.
      651*             Only SWITCH_LIST_VERSION_1 is supported.   
      652*   p_user_area_ptr points to the area in which the output switch_list structure
      653*             is to be allocated.  If null, get_user_free_area_() is used.
      654*   p_switch_list_ptr is set to point to the allocated switch_list structure.
      655*   p_code is a status code.
      656**/
      657 
      658 list_switches:
      659    entry (p_version_wanted, p_user_area_ptr, p_switch_list_ptr, p_code);
      660 
      661       version_wanted = p_version_wanted;
      662       user_area_ptr = p_user_area_ptr;
      663 
      664 
      665 
      666       if version_wanted ^= SWITCH_LIST_VERSION_1
      667       then call ERROR_RETURN (error_table_$unimplemented_version);
      668       if user_area_ptr = null
      669       then user_area_ptr = get_user_free_area_ ();
      670 
      671       alloc_switch_count = 3;
      672       alloc_switch_name_count = 6;
      673       allocate switch_list in (user_area);
      674 
      675       switch_list.version = SWITCH_LIST_VERSION_1;
      676 
      677       switch_list.switches (1).name_index = 1;
      678       switch_list.switches (1).name_count = 2;
      679       switch_list.switches (1).default_value = YES;
      680       switch_list.switches (1).mbz1 = ""b;
      681       switch_list.names (1) = "protection";
      682       switch_list.names (2) = "prot";
      683 
      684       switch_list.switches (2).name_index = 2;
      685       switch_list.switches (2).name_count = 2;
      686       switch_list.switches (2).default_value = YES;
      687       switch_list.switches (2).mbz1 = ""b;
      688       switch_list.names (3) = "concurrency";
      689       switch_list.names (4) = "conc";
      690 
      691       switch_list.switches (3).name_index = 3;
      692       switch_list.switches (3).name_count = 2;
      693       switch_list.switches (3).default_value = YES;
      694       switch_list.switches (3).mbz1 = ""b;
      695       switch_list.names (5) = "rollback";
      696       switch_list.names (6) = "rlb";
      697 
      698       p_switch_list_ptr = switch_list_ptr;
      699 
      700       call RETURN ();
      701 
      702 /* DESCRIPTION OF replace_acl ENTRY:
      703*
      704*        Replaces the ACL of a DM file.
      705*
      706*      p_dirname is the pathname of the directory containing the DM file.
      707*      p_ename is the entry anem of the DM file.
      708*      p_acl_ptr points to the general_acl structure which is the new ACL.
      709*      p_pno_sysdaemon indicates, if on, to ignore the SysDaemon ACL entry.
      710*      p_code is a status code.
      711* */
      712 
      713 replace_acl:
      714    entry (p_dirname, p_ename, p_acl_ptr, p_no_sysdaemon, p_code);
      715 
      716       dirname = p_dirname;
      717       ename = p_ename;
      718       acl_ptr = p_acl_ptr;
      719       no_sysdaemon = p_no_sysdaemon;
      720 
      721       code = 0;
      722       attempt_to_change_daemon_access = NO;
      723 
      724       if acl_ptr = null
      725       then acl_count = 1;				/* allow one for readding daemon */
      726       else
      727          do;
      728 	  if acl_ptr -> general_acl.version ^= GENERAL_ACL_VERSION_1
      729 	  then call ERROR_RETURN (error_table_$unimplemented_version);
      730 	  acl_count = acl_ptr -> general_acl.count;
      731 	  do acl_idx = 1 to acl_count;		/* check for invalid DM file modes */
      732 	     mode_bits = substr (acl_ptr -> general_acl.entries (acl_idx).mode, 1, 3);
      733 	     if mode_bits ^= R_ACCESS & mode_bits ^= RW_ACCESS & mode_bits ^= N_ACCESS
      734 	     then call ERROR_RETURN (error_table_$invalid_mode);
      735 	  end;
      736          end;
      737 
      738       call fm_validate_$check_write_ring_bracket (dirname, ename, code);
      739       if code ^= 0
      740       then if code = error_table_$not_seg_type
      741 	 then call ERROR_RETURN (dm_error_$file_not_dm_type);
      742 	 else call ERROR_RETURN (code);
      743 
      744       call cu_$level_get (callers_validation_level);
      745       on cleanup call FINISH ();
      746       call cu_$level_set (get_ring_ ());
      747 
      748       call msf_manager_$open (dirname, ename, msf_ptr, code);
      749       if msf_ptr = null
      750       then call ERROR_RETURN (code);
      751 
      752       system_area_ptr = get_system_free_area_ ();
      753 
      754       if acl_ptr = null ()				/* daemon must be on acl */
      755       then
      756          do;
      757 	  allocate segment_acl_array in (system_area) set (segment_acl_array_ptr);
      758 	  unspec (segment_acl_array_ptr -> segment_acl_array) = ""b;
      759 	  segment_acl_array_ptr -> segment_acl_array.access_name (1) = DM_INITIALIZER_NAME;
      760 	  segment_acl_array_ptr -> segment_acl_array.mode (1) = RW_ACCESS;
      761          end;
      762       else
      763          do;
      764 	  allocate segment_acl_array in (system_area) set (segment_acl_array_ptr);
      765 	  segment_acl_array_ptr -> segment_acl_array.access_name (*) = acl_ptr -> general_acl.entries.access_name (*);
      766 	  segment_acl_array_ptr -> segment_acl_array.mode (*) = acl_ptr -> general_acl.entries.mode (*);
      767 	  segment_acl_array_ptr -> segment_acl_array.extended_mode (*) = ""b;
      768 	  segment_acl_array_ptr -> segment_acl_array.status_code (*) = acl_ptr -> general_acl.entries.status_code (*);
      769 
      770 	  do acl_idx = 1 to acl_count
      771 	       while (segment_acl_array_ptr -> segment_acl_array (acl_idx).access_name ^= DM_INITIALIZER_NAME);
      772 	  end;
      773 	  if acl_idx <= acl_count
      774 	  then segment_acl_array_ptr -> segment_acl_array (acl_idx).mode = RW_ACCESS;
      775 	  else attempt_to_change_daemon_access = YES;	/* daemon not specified so explicitly readd it */
      776          end;
      777 
      778       call msf_manager_$acl_replace (msf_ptr, segment_acl_array_ptr, acl_count, no_sysdaemon, code);
      779       if code ^= 0
      780       then call ERROR_RETURN (code);
      781 
      782       if attempt_to_change_daemon_access
      783       then
      784          do;
      785 	  unspec (segment_acl_array_ptr -> segment_acl_array) = ""b;
      786 	  segment_acl_array_ptr -> segment_acl_array.access_name (1) = DM_INITIALIZER_NAME;
      787 	  segment_acl_array_ptr -> segment_acl_array.mode (1) = RW_ACCESS;
      788 	  call msf_manager_$acl_add (msf_ptr, segment_acl_array_ptr, (1), code);
      789 	  if code ^= 0
      790 	  then call ERROR_RETURN (code);
      791          end;
      792 
      793       call FINISH ();
      794 
      795       call RETURN ();
      796 
      797 /* DESCRIPTION OF replace_extended_acl ENTRY:  Unsupported: */
      798 
      799 replace_extended_acl:
      800    entry (p_dirname, p_ename, p_acl_ptr, p_no_sysdaemon, p_code);
      801 
      802       call ERROR_RETURN (error_table_$unsupported_operation);
      803 
      804 
      805 /* DESCRIPTION OF set_bit_count ENTRY:  Unsupported. */
      806 
      807 set_bit_count:
      808    entry (p_dirname, p_ename, p_bit_count, p_code);
      809 
      810       call ERROR_RETURN (error_table_$unsupported_operation);
      811 
      812 
      813 /* DESCRIPTION OF set_max_length ENTRY:  Unsupported. */
      814 
      815 set_max_length:
      816    entry (p_dirname, p_ename, p_max_length, p_code);
      817 
      818       call ERROR_RETURN (error_table_$unsupported_operation);
      819 
      820 /* DESCRIPTION OF set_switch ENTRY:  Unsupported. */
      821 
      822 set_switch:
      823    entry (p_dirname, p_ename, p_switch_name, p_switch_value, p_code);
      824 
      825       call ERROR_RETURN (error_table_$unsupported_operation);
      826 
  1     1 /* Begin include file -- acl_structures.incl.pl1 BIM 3/82 */
  1     2 /* format: style3,indcomtxt,idind30 */
  1     3 
  1     4 declare   acl_ptr                       pointer;
  1     5 declare   acl_count                     fixed bin;
  1     6 
  1     7 declare 1 general_acl                   aligned based (acl_ptr), /* for fs_util_ */
  1     8           2 version                     char (8) aligned,
  1     9           2 count                       fixed bin,
  1    10           2 entries                     (acl_count refer (general_acl.count)) aligned like general_acl_entry;
  1    11 
  1    12 declare 1 general_acl_entry             based,
  1    13           2 access_name                 character (32) unaligned,
  1    14           2 mode                        bit (36) aligned,
  1    15           2 status_code                 fixed bin (35);
  1    16 
  1    17 
  1    18 declare 1 general_extended_acl          aligned based (acl_ptr), /* for fs_util_ */
  1    19           2 version                     char (8) aligned,
  1    20           2 count                       fixed bin,
  1    21           2 entries                     (acl_count refer (general_extended_acl.count)) aligned like general_extended_acl_entry;
  1    22 
  1    23 declare 1 general_extended_acl_entry    aligned based,
  1    24           2 access_name                 character (32) unaligned,
  1    25           2 mode                        bit (36) aligned,
  1    26           2 extended_mode               bit (36) aligned,
  1    27           2 status_code                 fixed bin (35);
  1    28 
  1    29 
  1    30 declare 1 general_delete_acl            aligned based (acl_ptr), /* for file_system_ */
  1    31           2 version                     char (8) aligned,
  1    32           2 count                       fixed bin,
  1    33           2 entries                     (acl_count refer (general_delete_acl.count)) aligned like delete_acl_entry;
  1    34 
  1    35 declare 1 general_delete_acl_entry      aligned based,
  1    36           2 access_name                 character (32) unaligned,
  1    37           2 status_code                 fixed bin (35);
  1    38 
  1    39 
  1    40 declare 1 segment_acl                   aligned based (acl_ptr),
  1    41           2 version                     fixed bin,
  1    42           2 count                       fixed bin,
  1    43           2 entries                     (acl_count refer (segment_acl.count)) aligned like segment_acl_entry;
  1    44 
  1    45 declare 1 segment_acl_entry             like general_extended_acl_entry aligned based;
  1    46 declare 1 segment_acl_array             (acl_count) aligned like segment_acl_entry based (acl_ptr);
  1    47 
  1    48 
  1    49 declare 1 directory_acl                 aligned based (acl_ptr),
  1    50           2 version                     fixed bin,
  1    51           2 count                       fixed bin,
  1    52           2 entries                     (acl_count refer (directory_acl.count)) aligned like directory_acl_entry;
  1    53 
  1    54 declare 1 directory_acl_entry           like general_acl_entry aligned based;
  1    55 declare 1 directory_acl_array           (acl_count) aligned like directory_acl_entry based (acl_ptr);
  1    56 
  1    57 
  1    58 declare 1 delete_acl                    based (acl_ptr) aligned,
  1    59           2 version                     fixed bin,
  1    60           2 count                       fixed bin,
  1    61           2 entries                     (acl_count refer (delete_acl.count)) aligned like delete_acl_entry;
  1    62 
  1    63 declare 1 delete_acl_entry              like general_delete_acl_entry aligned based;
  1    64 declare 1 delete_acl_array              (acl_count) aligned like delete_acl_entry based (acl_ptr);
  1    65 
  1    66 
  1    67 declare  (SEG_ACL_VERSION_1             init ("sga1"),
  1    68           DIR_ACL_VERSION_1             init ("dra1"),
  1    69           DELETE_ACL_VERSION_1          init ("dla1"))
  1    70                                         char (4) int static options (constant);
  1    71 
  1    72 declare  (GENERAL_ACL_VERSION_1         init ("gacl001"),
  1    73           GENERAL_EXTENDED_ACL_VERSION_1 init ("gxacl001"),
  1    74           GENERAL_DELETE_ACL_VERSION_1  init ("gdacl001"))
  1    75                                         char (8) internal static options (constant);
  1    76 
  1    77 declare   ACL_VERSION_1                 fixed bin init (1) int static options (constant);
  1    78 
  1    79 /* End include file acl_structures.incl.pl1 */
      827 
      828 
  2     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  2     2*
  2     3*   Values for the "access mode" argument so often used in hardcore
  2     4*   James R. Davis 26 Jan 81  MCR 4844
  2     5*   Added constants for SM access 4/28/82 Jay Pattin
  2     6*   Added text strings 03/19/85 Chris Jones
  2     7**/
  2     8 
  2     9 
  2    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  2    11 dcl	(
  2    12 	N_ACCESS		   init ("000"b),
  2    13 	R_ACCESS		   init ("100"b),
  2    14 	E_ACCESS		   init ("010"b),
  2    15 	W_ACCESS		   init ("001"b),
  2    16 	RE_ACCESS		   init ("110"b),
  2    17 	REW_ACCESS	   init ("111"b),
  2    18 	RW_ACCESS		   init ("101"b),
  2    19 	S_ACCESS		   init ("100"b),
  2    20 	M_ACCESS		   init ("010"b),
  2    21 	A_ACCESS		   init ("001"b),
  2    22 	SA_ACCESS		   init ("101"b),
  2    23 	SM_ACCESS		   init ("110"b),
  2    24 	SMA_ACCESS	   init ("111"b)
  2    25 	)		   bit (3) internal static options (constant);
  2    26 
  2    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  2    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  2    29 
  2    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  2    31 			   static options (constant);
  2    32 
  2    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  2    34 			   static options (constant);
  2    35 
  2    36 dcl	(
  2    37 	N_ACCESS_BIN	   init (00000b),
  2    38 	R_ACCESS_BIN	   init (01000b),
  2    39 	E_ACCESS_BIN	   init (00100b),
  2    40 	W_ACCESS_BIN	   init (00010b),
  2    41 	RW_ACCESS_BIN	   init (01010b),
  2    42 	RE_ACCESS_BIN	   init (01100b),
  2    43 	REW_ACCESS_BIN	   init (01110b),
  2    44 	S_ACCESS_BIN	   init (01000b),
  2    45 	M_ACCESS_BIN	   init (00010b),
  2    46 	A_ACCESS_BIN	   init (00001b),
  2    47 	SA_ACCESS_BIN	   init (01001b),
  2    48 	SM_ACCESS_BIN	   init (01010b),
  2    49 	SMA_ACCESS_BIN	   init (01011b)
  2    50 	)		   fixed bin (5) internal static options (constant);
  2    51 
  2    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      829 
      830 
  3     1 /* BEGIN INCLUDE FILE:  copy_flags.incl.pl1 */
  3     2 
  3     3 /* Flags for attributes that should/may be copied by the copy_ subroutine. This include file is
  3     4*   required by suffix_info.incl.pl1 and copy_options.incl.pl1
  3     5*
  3     6*   Jay Pattin 6/23/83 */
  3     7 
  3     8 declare   1 copy_flags                  aligned based,      /* ON means that this attribute may be copied by copy_ */
  3     9           2 names                       bit (1) unaligned,
  3    10           2 acl                         bit (1) unaligned,
  3    11           2 ring_brackets               bit (1) unaligned,
  3    12           2 max_length                  bit (1) unaligned,
  3    13           2 copy_switch                 bit (1) unaligned,
  3    14           2 safety_switch               bit (1) unaligned,
  3    15           2 dumper_switches             bit (1) unaligned,
  3    16           2 entry_bound                 bit (1) unaligned,  /* only for vanilla object segments */
  3    17           2 extend                      bit (1) unaligned,  /* copy_ may append to end of existing object */
  3    18           2 update                      bit (1) unaligned,  /* copy_ may replace contents of existing object */
  3    19           2 mbz                         bit (26) unaligned;
  3    20 
  3    21 /* END INCLUDE FILE:  copy_flags.incl.pl1 */
      831 
      832 
  4     1 /* BEGIN INCLUDE FILE: suffix_info.incl.pl1 */
  4     2 /* format: style3,indcomtxt,idind30 */
  4     3 /**** Jay Pattin 2/13/83
  4     4*      M. Pandolf 1984.11.30 to set FS_OBJECT_TYPE_MSF to -multisegment_file
  4     5*
  4     6*      The include file copy_flags.incl.pl1 must be included in any program using this include file.
  4     7*
  4     8*      This structure is returned by the suffix_XXX_$suffix_info subroutines */
  4     9 
  4    10 declare   suffix_info_ptr               ptr;
  4    11 
  4    12 declare   1 suffix_info                 aligned based (suffix_info_ptr),
  4    13             2 version                   char (8),
  4    14             2 type                      char (32) unaligned,
  4    15             2 type_name                 char (32) unaligned,          /* Singular name of the object type, e.g. "mailbox" */
  4    16             2 plural_name               char (32) unaligned,          /* Plural of above, e.g. "mailboxes" */
  4    17             2 flags                     unaligned,
  4    18               3 standard_object         bit (1) unaligned,  /* ON if not an extended object (no suffix_XXX_) */
  4    19               3 extended_acl            bit (1) unaligned,  /* ON if uses extended ACLs, off if regular ACLs */
  4    20               3 has_switches            bit (1) unaligned,  /* ON if supports switches for objects */
  4    21               3 mbz1                    bit (33) unaligned,
  4    22             2 modes                     char (36),          /* correspondence between bits and chars for extended modes */
  4    23             2 max_mode_len              fixed bin,          /* maximum number of modes on an object */
  4    24             2 num_ring_brackets         fixed bin,          /* number of ring brackets on object */
  4    25             2 copy_flags                like copy_flags,    /* See copy_flags.incl.pl1 */
  4    26             2 info_pathname             char (168) unaligned;
  4    27                                                             /* pathname of info segment containing more info */
  4    28 
  4    29 declare   SUFFIX_INFO_VERSION_1         char (8) static options (constant) init ("SUFFIX01");
  4    30 
  4    31 /* This information is returned by the suffix_XXX_$list_switches subroutines */
  4    32 
  4    33 declare   switch_list_ptr               ptr,
  4    34           alloc_switch_count            fixed bin,
  4    35           alloc_switch_name_count       fixed bin;
  4    36 
  4    37 declare   1 switch_list                 aligned based (switch_list_ptr),
  4    38             2 version                   char (8),           /* SWITCH_LIST_VERSION_1 */
  4    39             2 switch_count              fixed bin,          /* total number of switches */
  4    40             2 switch_name_count         fixed bin,          /* total number of names */
  4    41             2 switches                  (alloc_switch_count refer (switch_list.switch_count)),
  4    42               3 name_index              fixed bin,          /* index of first name for this switch */
  4    43               3 name_count              fixed bin,          /* number of names for this switch */
  4    44               3 default_value           bit (1) aligned,    /* default setting for this switch */
  4    45               3 mbz1                    bit (36) aligned,   /* reserved for future use */
  4    46             2 names                     (alloc_switch_name_count refer (switch_list.switch_name_count)) char (32);
  4    47 
  4    48 declare   SWITCH_LIST_VERSION_1         char (8) static options (constant) init ("SWLIST01");
  4    49 
  4    50 declare   (
  4    51           FS_OBJECT_TYPE_SEGMENT        init ("-segment"),
  4    52           FS_OBJECT_TYPE_DIRECTORY      init ("-directory"),
  4    53           FS_OBJECT_TYPE_MSF            init ("-multisegment_file"),
  4    54           FS_OBJECT_TYPE_DM_FILE        init ("-dm_file"),
  4    55           FS_OBJECT_TYPE_LINK           init ("-link")
  4    56           )                             char (32) unaligned int static options (constant);
  4    57 
  4    58 /* END INCLUDE FILE: suffix_info.incl.pl1 */
      833 
      834 
      835    end fm_attribute_$suffix_info;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/24/85  0803.2  fm_attribute_.pl1                 >spec>on>41-21>fm_attribute_.pl1
827          1    10/14/83  1606.6  acl_structures.incl.pl1           >ldd>include>acl_structures.incl.pl1
829          2    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
831          3    10/14/83  1606.7  copy_flags.incl.pl1               >ldd>include>copy_flags.incl.pl1
833          4    03/05/85  1807.3  suffix_info.incl.pl1              >ldd>include>suffix_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
DM_INITIALIZER_NAME             000016 constant        char(32)                 initial dcl 185 ref 361 432 451 759 770 786
FS_OBJECT_TYPE_DM_FILE          000000 constant        char(32)                 initial unaligned dcl 4-50 ref 248
GENERAL_ACL_VERSION_1           000014 constant        char(8)                  initial unaligned dcl 1-72 ref 332 410 576 580 728
NO                                     constant        bit(1)                   initial dcl 187 ref 154 253 261 262 263 264 408 722
N_ACCESS                               constant        bit(3)                   initial unaligned dcl 2-11 ref 338 733
READ_BRACKET_IDX                       constant        fixed bin(17,0)          initial dcl 180 ref 536
RW_ACCESS                              constant        bit(3)                   initial unaligned dcl 2-11 ref 338 364 452 534 733
                                                                                  760 773 787
R_ACCESS                               constant        bit(3)                   initial unaligned dcl 2-11 ref 338 536 733
SUFFIX_INFO_VERSION_1           000012 constant        char(8)                  initial unaligned dcl 4-29 ref 247
SWITCH_LIST_VERSION_1           000010 constant        char(8)                  initial unaligned dcl 4-48 ref 666 675
UNSET_VALIDATION_LEVEL          004557 constant        fixed bin(17,0)          initial dcl 186 ref 152 307
WRITE_BRACKET_IDX                      constant        fixed bin(17,0)          initial dcl 180 ref 534
YES                                    constant        bit(1)                   initial dcl 187 ref 252 259 260 435 679 686 693 775
access_name                            based           char(32)                 array level 2 in structure "delete_acl_array" packed
                                                                                  unaligned dcl 1-64 in procedure
                                                                                  "fm_attribute_$suffix_info" set ref 429* 432
access_name               3            based           char(32)                 array level 3 in structure "general_acl" packed
                                                                                  unaligned dcl 1-7 in procedure
                                                                                  "fm_attribute_$suffix_info" set ref 356 429 603
                                                                                  609* 626* 765
access_name                            based           char(32)                 array level 2 in structure "segment_acl_array"
                                                                                  packed unaligned dcl 1-46 in procedure
                                                                                  "fm_attribute_$suffix_info" set ref 356* 361 451*
                                                                                  603* 609 626 759* 765* 770 786*
acl                      46(01)        based           bit(1)                   level 3 packed unaligned dcl 4-12 set ref 260*
acl_count                       000242 automatic       fixed bin(17,0)          dcl 1-5 set ref 298 304 335* 336 354 356 357 358 359
                                                                                  361 364 371* 413* 427 429 430 432 435 442* 449 450
                                                                                  579* 582* 602 603 605* 609 609 609 609 610 611
                                                                                  616* 623 623 626 626 626 626 627 628 724* 730* 731
                                                                                  757 758 764 765 766 767 768 770 773 778* 785
acl_idx                         000216 automatic       fixed bin(17,0)          dcl 151 set ref 336* 337* 361* 361* 364 364 432*
                                                                                  432* 435 731* 732* 770* 770* 773 773
acl_ptr                         000240 automatic       pointer                  dcl 1-4 set ref 328* 332 335 337 356 357 359 405*
                                                                                  410 413 429 430 571* 576 580 582 599 603 609 610
                                                                                  611 623* 625 626 627 628 631 718* 724 728 730 732
                                                                                  754 765 766 768
alloc_switch_count              000250 automatic       fixed bin(17,0)          dcl 4-33 set ref 671* 673 673
alloc_switch_name_count         000251 automatic       fixed bin(17,0)          dcl 4-33 set ref 672* 673 673
attempt_to_change_daemon_access 000220 automatic       bit(1)                   initial dcl 154 set ref 154* 408* 435* 446 722* 775*
                                                                                  782
callers_validation_level        000217 automatic       fixed bin(17,0)          initial dcl 152 set ref 152* 307 307* 348* 421* 526*
                                                                                  590* 744*
cleanup                         000232 stack reference condition                dcl 176 ref 349 422 527 591 745
code                            000221 automatic       fixed bin(35,0)          initial dcl 156 set ref 156* 330* 342* 343 343 346*
                                                                                  367* 368* 371* 372 372* 407* 415* 416 416 419*
                                                                                  438* 439* 442* 443 443* 453* 454 454* 493* 495*
                                                                                  496 496* 518* 522* 523 523* 530* 531 531* 574*
                                                                                  584* 585 585 588* 594* 595* 605* 606 606* 616* 617
                                                                                  617* 721* 738* 739 739 742* 748* 749* 778* 779
                                                                                  779* 788* 789 789*
copy_flags               46            based           structure                level 2 in structure "suffix_info" dcl 4-12
                                                                                  in procedure "fm_attribute_$suffix_info" set ref
                                                                                  258*
copy_flags                             based           structure                level 1 dcl 3-8 in procedure
                                                                                  "fm_attribute_$suffix_info"
copy_switch              46(04)        based           bit(1)                   level 3 packed unaligned dcl 4-12 set ref 262*
count                     2            based           fixed bin(17,0)          level 2 dcl 1-7 set ref 335 356 356 356 356 357 359
                                                                                  413 429 429 429 429 430 582 603 603 603 603 609
                                                                                  610 611 623* 626 627 628 730 765 765 765 765 766
                                                                                  768
cu_$level_get                   000010 constant        entry                    external dcl 194 ref 348 421 526 590 744
cu_$level_set                   000012 constant        entry                    external dcl 195 ref 307 350 423 528 592 746
default_value             6            based           bit(1)                   array level 3 dcl 4-37 set ref 679* 686* 693*
delete_acl_array                       based           structure                array level 1 dcl 1-64 set ref 298 427
delete_acl_array_ptr            000204 automatic       pointer                  initial dcl 144 set ref 144* 295 298 299* 427* 429
                                                                                  430 432 442*
delete_acl_entry                       based           structure                level 1 dcl 1-63
directory_acl_entry                    based           structure                level 1 dcl 1-54
dirname                         000100 automatic       char(168)                unaligned dcl 139 set ref 326* 342* 367* 403* 415*
                                                                                  438* 490* 495* 512* 522* 530* 530* 567* 584* 594*
                                                                                  716* 738* 748*
dm_error_$file_not_dm_type      000050 external static fixed bin(35,0)          dcl 220 set ref 343* 416* 585* 739*
dumper_switches          46(06)        based           bit(1)                   level 3 packed unaligned dcl 4-12 set ref 264*
ename                           000152 automatic       char(32)                 unaligned dcl 140 set ref 327* 342* 367* 404* 415*
                                                                                  438* 491* 495* 513* 522* 530* 530* 568* 584* 594*
                                                                                  717* 738* 748*
entries                   3            based           structure                array level 2 dcl 1-7
er_p_code                              parameter       fixed bin(35,0)          dcl 282 ref 279 284
error_table_$invalid_mode       000052 external static fixed bin(35,0)          dcl 222 set ref 338* 733*
error_table_$not_seg_type       000054 external static fixed bin(35,0)          dcl 224 ref 343 416 585 739
error_table_$unimplemented_version
                                000056 external static fixed bin(35,0)          dcl 226 set ref 332* 410* 576* 580* 666* 728*
error_table_$unsupported_operation
                                000060 external static fixed bin(35,0)          dcl 228 set ref 385* 467* 474* 643* 802* 810* 818*
                                                                                  825*
exmodes                         000224 automatic       bit(36)                  dcl 158 set ref 530*
extended_acl             32(01)        based           bit(1)                   level 3 packed unaligned dcl 4-12 set ref 253*
extended_mode            11            based           bit(36)                  array level 2 dcl 1-46 set ref 358* 767*
extended_ring_brackets          000222 automatic       fixed bin(3,0)           array dcl 157 set ref 495* 499 522* 534 536
flags                    32            based           structure                level 2 packed unaligned dcl 4-12 set ref 251*
fm_validate_$check_read_ring_bracket
                                000014 constant        entry                    external dcl 196 ref 584
fm_validate_$check_write_ring_bracket
                                000016 constant        entry                    external dcl 198 ref 342 415 738
fm_validate_$get_ring_brackets  000020 constant        entry                    external dcl 200 ref 495 522
general_acl                            based           structure                level 1 dcl 1-7 set ref 623
general_acl_entry                      based           structure                level 1 unaligned dcl 1-12
general_delete_acl_entry               based           structure                level 1 dcl 1-35
general_extended_acl_entry             based           structure                level 1 dcl 1-23
get_ring_                       000022 constant        entry                    external dcl 202 ref 350 350 423 423 528 528 530 530
                                                                                  592 592 746 746
get_system_free_area_           000024 constant        entry                    external dcl 203 ref 352 425 598 752
get_user_free_area_             000026 constant        entry                    external dcl 204 ref 620 668
hcs_$get_user_access_modes      000030 constant        entry                    external dcl 205 ref 530
info_pathname            47            based           char(168)                level 2 packed unaligned dcl 4-12 set ref 266*
max_length               46(03)        based           bit(1)                   level 3 packed unaligned dcl 4-12 set ref 261*
max_mode_len             44            based           fixed bin(17,0)          level 2 dcl 4-12 set ref 255*
mbz1                      7            based           bit(36)                  array level 3 dcl 4-37 set ref 680* 687* 694*
mode                     13            based           bit(36)                  array level 3 in structure "general_acl" dcl 1-7
                                                                                  in procedure "fm_attribute_$suffix_info" set ref
                                                                                  337 357 610* 627* 732 766
mode                     10            based           bit(36)                  array level 2 in structure "segment_acl_array"
                                                                                  dcl 1-46 in procedure "fm_attribute_$suffix_info"
                                                                                  set ref 357* 364* 452* 610 627 760* 766* 773* 787*
mode_bits                       000225 automatic       bit(3)                   unaligned dcl 159 set ref 337* 338 338 338 732* 733
                                                                                  733 733
modes                    33            based           char(36)                 level 2 in structure "suffix_info" dcl 4-12
                                                                                  in procedure "fm_attribute_$suffix_info" set ref
                                                                                  254*
modes                           000226 automatic       bit(36)                  dcl 160 in procedure "fm_attribute_$suffix_info" set
                                                                                  ref 530* 534* 534 536* 536 538* 542
msf_manager_$acl_add            000032 constant        entry                    external dcl 208 ref 371 453 788
msf_manager_$acl_delete         000034 constant        entry                    external dcl 209 ref 442
msf_manager_$acl_list           000036 constant        entry                    external dcl 211 ref 605 616
msf_manager_$acl_replace        000040 constant        entry                    external dcl 212 ref 778
msf_manager_$close              000042 constant        entry                    external dcl 214 ref 293
msf_manager_$open               000044 constant        entry                    external dcl 215 ref 367 438 594 748
msf_ptr                         000206 automatic       pointer                  initial dcl 145 set ref 145* 293 293* 367* 368 371*
                                                                                  438* 439 442* 453* 594* 595 605* 616* 748* 749
                                                                                  778* 788*
name_count                5            based           fixed bin(17,0)          array level 3 dcl 4-37 set ref 678* 685* 692*
name_index                4            based           fixed bin(17,0)          array level 3 dcl 4-37 set ref 677* 684* 691*
names                                  based           char(32)                 array level 2 in structure "switch_list" dcl 4-37
                                                                                  in procedure "fm_attribute_$suffix_info" set ref
                                                                                  681* 682* 688* 689* 695* 696*
names                    46            based           bit(1)                   level 3 in structure "suffix_info" packed unaligned
                                                                                  dcl 4-12 in procedure "fm_attribute_$suffix_info"
                                                                                  set ref 259*
no_sysdaemon                    000227 automatic       bit(1)                   unaligned dcl 161 set ref 719* 778*
null                                                   builtin function         dcl 171 ref 144 145 146 147 148 293 295 299 301 305
                                                                                  368 439 576 595 599 605 605 605 605 616 616 620
                                                                                  668 724 749 754
num_ring_brackets        45            based           fixed bin(17,0)          level 2 dcl 4-12 set ref 256*
p_acl_ptr                              parameter       pointer                  dcl 118 set ref 323 328 382 400 405 564 571 631* 640
                                                                                  713 718 799
p_bit_count                            parameter       fixed bin(24,0)          dcl 119 ref 464 807
p_code                                 parameter       fixed bin(35,0)          dcl 120 set ref 274* 284* 323 382 400 464 471 487
                                                                                  509 564 640 658 713 799 807 815 822
p_dirname                              parameter       char                     unaligned dcl 123 ref 323 326 382 400 403 464 471
                                                                                  487 490 509 512 564 567 640 713 716 799 807 815
                                                                                  822
p_ename                                parameter       char                     unaligned dcl 121 ref 323 327 382 400 404 464 471
                                                                                  487 491 509 513 564 568 640 713 717 799 807 815
                                                                                  822
p_exmodes                              parameter       bit(36)                  dcl 122 set ref 509 520*
p_max_length                           parameter       fixed bin(19,0)          dcl 124 ref 471 815
p_modes                                parameter       bit(36)                  dcl 125 set ref 509 519* 542*
p_no_sysdaemon                         parameter       bit(1)                   unaligned dcl 126 ref 713 719 799
p_ring                                 parameter       fixed bin(17,0)          dcl 127 ref 509 515
p_ring_brackets                        parameter       fixed bin(3,0)           array dcl 128 set ref 487 499*
p_suffix_info_ptr                      parameter       pointer                  dcl 129 ref 112 245
p_switch_list_ptr                      parameter       pointer                  dcl 130 set ref 658 698*
p_switch_name                          parameter       char                     unaligned dcl 131 ref 822
p_switch_value                         parameter       bit(1)                   unaligned dcl 132 ref 822
p_user_area_ptr                        parameter       pointer                  dcl 133 ref 564 570 640 658 662
p_user_name                            parameter       char                     unaligned dcl 134 ref 509 514
p_version_wanted                       parameter       char                     unaligned dcl 135 ref 564 569 640 658 661
pathname_                       000046 constant        entry                    external dcl 216 ref 530 530
plural_name              22            based           char(32)                 level 2 packed unaligned dcl 4-12 set ref 250*
ring                            000230 automatic       fixed bin(17,0)          dcl 162 set ref 515* 534 536
safety_switch            46(05)        based           bit(1)                   level 3 packed unaligned dcl 4-12 set ref 263*
segment_acl_array                      based           structure                array level 1 dcl 1-46 set ref 304 354 449 450* 602
                                                                                  757 758* 764 785*
segment_acl_array_ptr           000210 automatic       pointer                  initial dcl 146 set ref 146* 301 304 305* 354* 356
                                                                                  357 358 359 361 364 371* 449* 450 451 452 453*
                                                                                  602* 603 605* 609 610 611 616* 626 627 628 757*
                                                                                  758 759 760 764* 765 766 767 768 770 773 778* 785
                                                                                  786 787 788*
segment_acl_entry                      based           structure                level 1 dcl 1-45
standard_object          32            based           bit(1)                   level 3 packed unaligned dcl 4-12 set ref 252*
status_code              12            based           fixed bin(35,0)          array level 2 in structure "segment_acl_array"
                                                                                  dcl 1-46 in procedure "fm_attribute_$suffix_info"
                                                                                  set ref 359* 611 628 768*
status_code              10            based           fixed bin(35,0)          array level 2 in structure "delete_acl_array"
                                                                                  dcl 1-64 in procedure "fm_attribute_$suffix_info"
                                                                                  set ref 430*
status_code              14            based           fixed bin(35,0)          array level 3 in structure "general_acl" dcl 1-7
                                                                                  in procedure "fm_attribute_$suffix_info" set ref
                                                                                  359 430 611* 628* 768
string                                                 builtin function         dcl 171 set ref 251*
substr                                                 builtin function         dcl 171 ref 337 732
suffix_info                            based           structure                level 1 dcl 4-12
suffix_info_ptr                 000244 automatic       pointer                  dcl 4-10 set ref 245* 247 248 249 250 251 252 253
                                                                                  254 255 256 258 259 260 261 262 263 264 266
switch_count              2            based           fixed bin(17,0)          level 2 dcl 4-37 set ref 673* 681 682 688 689 695
                                                                                  696
switch_list                            based           structure                level 1 dcl 4-37 set ref 673
switch_list_ptr                 000246 automatic       pointer                  dcl 4-33 set ref 673* 675 677 678 679 680 681 682
                                                                                  684 685 686 687 688 689 691 692 693 694 695 696
                                                                                  698
switch_name_count         3            based           fixed bin(17,0)          level 2 dcl 4-37 set ref 673*
switches                  4            based           structure                array level 2 dcl 4-37
system_area                            based           area(1024)               dcl 167 ref 354 427 449 602 757 764
system_area_ptr                 000212 automatic       pointer                  initial dcl 147 set ref 147* 352* 354 425* 427 449
                                                                                  598* 602 616* 752* 757 764
type                      2            based           char(32)                 level 2 packed unaligned dcl 4-12 set ref 248*
type_name                12            based           char(32)                 level 2 packed unaligned dcl 4-12 set ref 249*
unspec                                                 builtin function         dcl 171 set ref 258* 450* 758* 785*
user_area                              based           area(1024)               dcl 166 ref 623 673
user_area_ptr                   000214 automatic       pointer                  initial dcl 148 set ref 148* 570* 620 620* 623 662*
                                                                                  668 668* 673
user_name                       000162 automatic       char(64)                 unaligned dcl 141 set ref 514* 530*
version                                based           char(8)                  level 2 in structure "general_acl" dcl 1-7
                                                                                  in procedure "fm_attribute_$suffix_info" set ref
                                                                                  332 410 580 625* 728
version                                based           char(8)                  level 2 in structure "suffix_info" dcl 4-12
                                                                                  in procedure "fm_attribute_$suffix_info" set ref
                                                                                  247*
version                                based           char(8)                  level 2 in structure "switch_list" dcl 4-37
                                                                                  in procedure "fm_attribute_$suffix_info" set ref
                                                                                  675*
version_wanted                  000202 automatic       char(8)                  dcl 142 set ref 569* 576 625 661* 666

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACL_VERSION_1                          internal static fixed bin(17,0)          initial dcl 1-77
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 2-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
DELETE_ACL_VERSION_1                   internal static char(4)                  initial unaligned dcl 1-67
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 2-33
DIR_ACL_VERSION_1                      internal static char(4)                  initial unaligned dcl 1-67
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 2-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
FS_OBJECT_TYPE_DIRECTORY               internal static char(32)                 initial unaligned dcl 4-50
FS_OBJECT_TYPE_LINK                    internal static char(32)                 initial unaligned dcl 4-50
FS_OBJECT_TYPE_MSF                     internal static char(32)                 initial unaligned dcl 4-50
FS_OBJECT_TYPE_SEGMENT                 internal static char(32)                 initial unaligned dcl 4-50
GENERAL_DELETE_ACL_VERSION_1           internal static char(8)                  initial unaligned dcl 1-72
GENERAL_EXTENDED_ACL_VERSION_1         internal static char(8)                  initial unaligned dcl 1-72
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 2-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
REW_ACCESS                             internal static bit(3)                   initial unaligned dcl 2-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 2-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 2-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 2-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 2-30
SEG_ACL_VERSION_1                      internal static char(4)                  initial unaligned dcl 1-67
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 2-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 2-36
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 2-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 2-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 2-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
delete_acl                             based           structure                level 1 dcl 1-58
directory_acl                          based           structure                level 1 dcl 1-49
directory_acl_array                    based           structure                array level 1 dcl 1-55
general_delete_acl                     based           structure                level 1 dcl 1-30
general_extended_acl                   based           structure                level 1 dcl 1-18
segment_acl                            based           structure                level 1 dcl 1-40

NAMES DECLARED BY EXPLICIT CONTEXT.
ERROR_RETURN                    004451 constant        entry                    internal dcl 279 ref 332 338 343 346 368 372 385 410
                                                                                  416 419 439 443 454 467 474 496 523 531 576 580
                                                                                  585 588 595 606 617 643 666 728 733 739 742 749
                                                                                  779 789 802 810 818 825
FINISH                          004463 constant        entry                    internal dcl 290 ref 285 349 376 422 458 527 540 591
                                                                                  633 745 793
MAIN_RETURN                     000174 constant        label                    dcl 268 ref 275 286
RETURN                          004446 constant        entry                    internal dcl 271 ref 378 460 501 543 635 700 795
add_acl_entries                 000202 constant        entry                    external dcl 323
add_extended_acl_entries        000713 constant        entry                    external dcl 382
delete_acl_entries              000753 constant        entry                    external dcl 400
fm_attribute_$suffix_info       000112 constant        entry                    external dcl 112
get_bit_count                   001452 constant        entry                    external dcl 464
get_max_length                  001513 constant        entry                    external dcl 471
get_ring_brackets               001554 constant        entry                    external dcl 487
get_user_access_modes           001662 constant        entry                    external dcl 509
list_acl                        002172 constant        entry                    external dcl 564
list_extended_acl               003146 constant        entry                    external dcl 640
list_switches                   003217 constant        entry                    external dcl 658
replace_acl                     003420 constant        entry                    external dcl 713
replace_extended_acl            004246 constant        entry                    external dcl 799
set_bit_count                   004306 constant        entry                    external dcl 807
set_max_length                  004344 constant        entry                    external dcl 815
set_switch                      004405 constant        entry                    external dcl 822

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5302        5364    4560        5312
Length      5752    4560        62         352     522           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
fm_attribute_$suffix_info           320 external procedure  is an external procedure.  
RETURN                                  internal procedure  shares stack frame of external procedure fm_attribute_$suffix_info.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure fm_attribute_$suffix_info.  
FINISH                               68 internal procedure  is called by several nonquick procedures.  
on unit on line 349                  64 on unit               
on unit on line 422                  64 on unit               
on unit on line 527                  64 on unit               
on unit on line 591                  64 on unit               
on unit on line 745                  64 on unit               

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
fm_attribute_$suffix_info
                         000100 dirname                     fm_attribute_$suffix_info
                         000152 ename                       fm_attribute_$suffix_info
                         000162 user_name                   fm_attribute_$suffix_info
                         000202 version_wanted              fm_attribute_$suffix_info
                         000204 delete_acl_array_ptr        fm_attribute_$suffix_info
                         000206 msf_ptr                     fm_attribute_$suffix_info
                         000210 segment_acl_array_ptr       fm_attribute_$suffix_info
                         000212 system_area_ptr             fm_attribute_$suffix_info
                         000214 user_area_ptr               fm_attribute_$suffix_info
                         000216 acl_idx                     fm_attribute_$suffix_info
                         000217 callers_validation_level    fm_attribute_$suffix_info
                         000220 attempt_to_change_daemon_access
                                                            fm_attribute_$suffix_info
                         000221 code                        fm_attribute_$suffix_info
                         000222 extended_ring_brackets      fm_attribute_$suffix_info
                         000224 exmodes                     fm_attribute_$suffix_info
                         000225 mode_bits                   fm_attribute_$suffix_info
                         000226 modes                       fm_attribute_$suffix_info
                         000227 no_sysdaemon                fm_attribute_$suffix_info
                         000230 ring                        fm_attribute_$suffix_info
                         000240 acl_ptr                     fm_attribute_$suffix_info
                         000242 acl_count                   fm_attribute_$suffix_info
                         000244 suffix_info_ptr             fm_attribute_$suffix_info
                         000246 switch_list_ptr             fm_attribute_$suffix_info
                         000250 alloc_switch_count          fm_attribute_$suffix_info
                         000251 alloc_switch_name_count     fm_attribute_$suffix_info

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_temp          call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return
bound_check_signal  enable              shorten_stack       ext_entry           ext_entry_desc      int_entry
alloc_based         free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cu_$level_get                 cu_$level_set                 fm_validate_$check_read_ring_bracket
fm_validate_$check_write_ring_bracket                       fm_validate_$get_ring_brackets
get_ring_                     get_system_free_area_         get_user_free_area_           hcs_$get_user_access_modes
msf_manager_$acl_add          msf_manager_$acl_delete       msf_manager_$acl_list         msf_manager_$acl_replace
msf_manager_$close            msf_manager_$open             pathname_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$file_not_dm_type    error_table_$invalid_mode     error_table_$not_seg_type
error_table_$unimplemented_version                          error_table_$unsupported_operation




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    144 000073       145 000075       146 000076       147 000077       148 000100       152 000101       154 000103
    156 000104       112 000107       245 000120       247 000124       248 000127       249 000132       250 000135
    251 000140       252 000141       253 000143       254 000145       255 000150       256 000152       258 000154
    259 000155       260 000157       261 000161       262 000163       263 000165       264 000167       266 000171
    268 000174       323 000175       326 000230       327 000236       328 000243       330 000246       332 000247
    335 000262       336 000265       337 000273       338 000300       340 000315       342 000317       343 000340
    346 000354       348 000356       349 000365       350 000407       352 000425       354 000434       356 000442
    357 000524       358 000545       359 000560       361 000577       363 000616       364 000620       367 000627
    368 000654       371 000662       372 000677       376 000703       378 000707       382 000710       385 000741
    400 000750       403 001001       404 001007       405 001014       407 001017       408 001020       410 001021
    413 001034       415 001037       416 001060       419 001074       421 001076       422 001105       423 001127
    425 001145       427 001154       429 001162       430 001244       432 001265       434 001304       435 001306
    438 001313       439 001340       442 001346       443 001363       446 001367       449 001371       450 001377
    451 001407       452 001412       453 001414       454 001433       458 001437       460 001443       464 001444
    467 001476       471 001505       474 001537       487 001546       490 001600       491 001606       493 001613
    495 001614       496 001641       499 001645       501 001652       509 001653       512 001713       513 001721
    514 001726       515 001733       518 001735       519 001736       520 001737       522 001740       523 001765
    526 001771       527 002000       528 002022       530 002040       531 002131       534 002135       536 002144
    538 002152       540 002153       542 002157       543 002162       564 002163       567 002226       568 002234
    569 002241       570 002251       571 002254       574 002257       576 002260       579 002277       580 002301
    582 002315       584 002317       585 002340       588 002354       590 002356       591 002365       592 002407
    594 002425       595 002452       598 002460       599 002467       602 002473       603 002501       605 002562
    606 002607       609 002613       610 002674       611 002715       613 002735       616 002736       617 002761
    620 002765       623 003000       625 003011       626 003014       627 003074       628 003115       631 003135
    633 003136       635 003142       640 003143       643 003202       658 003211       661 003237       662 003247
    666 003252       668 003264       671 003277       672 003301       673 003303       675 003322       677 003325
    678 003327       679 003331       680 003333       681 003334       682 003342       684 003346       685 003350
    686 003351       687 003353       688 003354       689 003362       691 003366       692 003370       693 003372
    694 003374       695 003375       696 003403       698 003407       700 003411       713 003412       716 003446
    717 003454       718 003461       719 003464       721 003471       722 003472       724 003473       728 003502
    730 003515       731 003520       732 003527       733 003534       735 003551       738 003553       739 003574
    742 003610       744 003612       745 003621       746 003643       748 003661       749 003706       752 003714
    754 003723       757 003727       758 003735       759 003745       760 003750       761 003752       764 003753
    765 003761       766 004042       767 004063       768 004076       770 004115       772 004134       773 004136
    775 004146       778 004150       779 004167       782 004173       785 004175       786 004206       787 004211
    788 004213       789 004232       793 004236       795 004242       799 004243       802 004274       807 004303
    810 004332       815 004341       818 004370       822 004377       825 004436       835 004445       271 004446
    274 004447       275 004450       279 004451       284 004453       285 004455       286 004461       290 004462
    293 004470       295 004503       298 004510       299 004514       301 004517       304 004523       305 004527
    307 004532       310 004544


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
