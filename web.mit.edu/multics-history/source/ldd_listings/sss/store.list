	COMPILATION LISTING OF SEGMENT store
	Compiled by: Multics PL/I Compiler, Release 28d, of September 14, 1983
	Compiled at: Honeywell LCPD Phoenix, System M
	Compiled on: 10/03/83  1702.5 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* Procedure to generate store sequences
       12*
       13*   Initial Version: 10 September 1971 by BLW
       14*	Modified: 4 November 1972 by BLW
       15*	Modified:	15 February 1973 by RAB
       16*	Modified:	22 June 1973 by RAB for EIS
       17*	Modified:	26 October 1975 by RAB to spec case fixed bin unal
       18*	Modified:	19 March 1977 by RAB for aq_man$left_shift
       19*		and aq_man$right_shift
       20*	Modified:	7 August 1978 by RAB to fix 1751 by changing setting
       21*		of store_it for complex_flt_bin_1
       22*	Modified:	30 March 1980 by RAB for reference.(padded aligned)_for_store_ref.
       23*		See prepare_operand for details.	*/
       24 
       25 store:	proc(pt);
       26 
       27 dcl	pt ptr;		/* points at reference node */
       28 
       29 dcl	cg_stat$save_exp_called bit(1) aligned ext,
       30 	cg_stat$text_pos fixed bin(18) ext,
       31 	cg_stat$complex_ac ptr ext;
       32 
       33 dcl	(p,q,arg(2)) ptr,
       34 	(type,size,cfo,unit_size,unit_offset,d,i,j,k,u,n,n1,n2,n3,n4,units) fixed bin,
       35 	(store_it,contiguous,all_ones,all_zeros,b1,arith) bit(1) aligned,
       36 	(macro,offset) fixed bin(15),
       37 	shift fixed bin(8),
       38 	bs bit(12),
       39 	mask bit(72) aligned,
       40 	in_q fixed bin(1) initial(0),
       41 	base3 bit(3) aligned,
       42 	xec(2) bit(36) aligned,
       43 	(ta,tq) bit(6);
       44 
       45 dcl	m_a entry(ptr,bit(2) aligned);
       46 dcl	c_a entry(fixed bin,fixed bin) returns(ptr),
       47 	xr_man$load_const entry(fixed bin,fixed bin),
       48 	expmac$abs entry(ptr,fixed bin),
       49 	expmac$zero entry(fixed bin(15)),
       50 	expmac$many entry(fixed bin(15),ptr,fixed bin),
       51 	expmac$two_eis entry(fixed bin(15),ptr,ptr),
       52 	long_op$c_or_b entry(ptr,fixed bin,fixed bin(15)),
       53 	xr_man$load_var entry(ptr,fixed bin),
       54 	base_man$load_any_var entry(fixed bin,ptr,bit(3) aligned),
       55 	stack_temp$assign_block entry(ptr,fixed bin),
       56 	state_man$flush_ref entry(ptr),
       57 	state_man$erase_reg entry(bit(19) aligned),
       58 	(aq_man$left_shift, aq_man$right_shift) entry(fixed bin(8),bit(1) aligned),
       59 	aq_man$check_strings entry(fixed bin),
       60 	aq_man$trim_aq entry(fixed bin),
       61 	generate_constant entry(bit(*) aligned,fixed bin) returns(ptr),
       62 	adjust_ref_count entry(ptr,fixed bin),
       63 	expmac$one entry(fixed bin(15),ptr,fixed bin),
       64 	expmac entry(fixed bin(15),ptr);
       65 
       66 dcl	(abs,addr,addrel,bit,divide,fixed,mod,min,null,string,substr) builtin;
       67 
       68 dcl (	bytes(2)		init(9,6),
       69 	nbspw(2)		init(4,6)) fixed bin int static;
       70 
       71 dcl	operator_table	init(262046) fixed bin(18) int static;	/* = 262144 - 98 */
       72 
       73 	/* The following values are offsets obtained from a compilation
       74*	   of pl1_operators_ */
       75 
       76 dcl (	co_to_bo		init(0),
       77 	ho_to_bo		init(4),
       78 	store_a9_co	init(6),
       79 	store_q9_co	init(26),		/* 32 octal */
       80 	store_a9_ho	init(42),		/* 52 octal */
       81 	store_q9_ho	init(54),		/* 66 octal */
       82 	store_a6_ho	init(64),		/* 100 octal */
       83 	store_q6_ho	init(82))		/* 122 octal */
       84 			fixed bin static;
       85 
       86 dcl	full(2) aligned bit(6) int static init("111100"b, "111111"b);
       87 
       88 dcl	init_xec_7(2) bit(36) aligned int static
       89 	init(	"000000000000000000111111011001011111"b,	/* lrl ap|0,7*	*/
       90 		"000000000000000000111001110001001111"b);	/* xec ap|0,7	*/
       91 
       92 dcl	init_xec_q(2) bit(36) aligned int static
       93 	init(	"000000000000000000111111001001010110"b,	/* arl ap|0,ql*	*/
       94 		"000000000000000000111001110001000110"b);	/* xec ap|0,ql	*/
       95 
       96 dcl (	stfx1		init(15),
       97 	stfx2		init(16),
       98 	store_pt		init(61),
       99 	shift_and_mask	init(106),
      100 	als		init(134),
      101 	ana(0:1)		init(40,688),
      102 	anaq		init(42),
      103 	era(0:1)		init(52,689),
      104 	ersa(0:1)		init(55,690),
      105 	lls		init(63),
      106 	lrl		init(62),
      107 	arl		init(245),
      108 	orsa		init(49),
      109 	pack_fl1		init(489),
      110 	pack_cfl1		init(491),
      111 	move_chars	init(98),
      112 	store_units(2)	init(295,297),
      113 	sta		init(4),
      114 	st_reg(0:1)	init(4,15),
      115 	store_logical	init(381)) fixed bin(15) int static;
      116 
  1     1 /* BEGIN INCLUDE FILE ... cgsystem.incl.pl1 */
  1     2 
  1     3 /* Modified: 25 Apr 1979 by PCK to implement 4-bit decimal */
  1     4 
  1     5 dcl (	bits_per_char		init(9),
  1     6 	bits_per_half		init(18),
  1     7 	bits_per_word		init(36),
  1     8 	bits_per_two_words		init(72),
  1     9 	bits_per_four_words		init(144),
  1    10 	bits_per_words(2)		init(36,72),
  1    11 	packed_digits_per_char	init(2),
  1    12 	chars_per_word		init(4),
  1    13 	packed_digits_per_word	init(8),
  1    14 
  1    15 	break_even_bits		init(216),
  1    16 	break_even_words		init(6),
  1    17 
  1    18 	label_size		init(4),
  1    19 
  1    20 	convert_size(13:14)		init(9,1),
  1    21 	max_offset(13:14)		init(27,35),
  1    22 	max_short_size(13:14)	init(8,72),
  1    23 
  1    24 	units_per_word(0:5)		init(1,36,8,4,2,1),
  1    25 
  1    26 	max_dec_scale		init(32),
  1    27 	min_dec_scale		init(-31),
  1    28 	max_p_xreg		init(18),
  1    29 	max_p_fix_bin_1		init(35),
  1    30 	max_p_flt_bin_1		init(27),
  1    31 	max_p_fix_dec		init(59),
  1    32 	max_length_p		init(24),
  1    33 	default_fix_bin_p		init(17)) fixed bin(8) int static options(constant);
  1    34 
  1    35 dcl      (convert_offset(0:5)		init(36,1,4.5,9,18,36),
  1    36 	bits_per_packed_digit	init(4.5)) fixed bin(8,1) int static options(constant);
  1    37 
  1    38 dcl	max_index_register_value	init(262143) fixed bin(31) int static options(constant);
  1    39 
  1    40 /* END INCLUDE FILE ... cgsystem.incl.pl1 */
  1    41 
      117 
  2     1 /* BEGIN INCLUDE FILE ... reference.incl.pl1 */
  2     2 
  2     3 dcl	1 reference		based aligned,
  2     4 	2 node_type		bit(9) unaligned,
  2     5 	2 array_ref		bit(1) unaligned,
  2     6 	2 varying_ref		bit(1) unaligned,
  2     7 	2 shared			bit(1) unaligned,
  2     8 	2 put_data_sw		bit(1) unaligned,
  2     9 	2 processed		bit(1) unaligned,
  2    10 	2 units			fixed(3) unaligned,
  2    11 	2 ref_count		fixed(17) unaligned,
  2    12 	2 c_offset		fixed(24),
  2    13 	2 c_length		fixed(24),
  2    14 	2 symbol			ptr unaligned,
  2    15 	2 qualifier		ptr unaligned,
  2    16 	2 offset			ptr unaligned,
  2    17 	2 length			ptr unaligned,
  2    18 	2 subscript_list		ptr unaligned,
  2    19 						/* these fields are used by the 645 code generator */
  2    20 	2 address			structure unaligned,
  2    21 	  3 base			bit(3),
  2    22 	  3 offset		bit(15),
  2    23 	  3 op			bit(9),
  2    24 	  3 no_address		bit(1),
  2    25 	  3 inhibit		bit(1),
  2    26 	  3 ext_base		bit(1),
  2    27 	  3 tag			bit(6),
  2    28 	2 info			structure unaligned,
  2    29 	  3 address_in		structure,
  2    30 	    4 b			dimension(0:7) bit(1),
  2    31 	    4 storage		bit(1),
  2    32 	  3 value_in		structure,
  2    33 	    4 a			bit(1),
  2    34 	    4 q			bit(1),
  2    35 	    4 aq			bit(1),
  2    36 	    4 string_aq		bit(1),
  2    37 	    4 complex_aq		bit(1),
  2    38 	    4 decimal_aq		bit(1),
  2    39 	    4 b			dimension(0:7) bit(1),
  2    40 	    4 storage		bit(1),
  2    41 	    4 indicators		bit(1),
  2    42 	    4 x			dimension(0:7) bit(1),
  2    43 	  3 other			structure,
  2    44 	    4 big_offset		bit(1),
  2    45 	    4 big_length		bit(1),
  2    46 	    4 modword_in_offset	bit(1),
  2    47 	2 data_type		fixed(5) unaligned,
  2    48 	2 bits			structure unaligned,
  2    49 	  3 padded_ref		bit(1),
  2    50 	  3 aligned_ref		bit(1),
  2    51 	  3 long_ref		bit(1),
  2    52 	  3 forward_ref		bit(1),
  2    53 	  3 ic_ref		bit(1),
  2    54 	  3 temp_ref		bit(1),
  2    55 	  3 defined_ref		bit(1),
  2    56 	  3 evaluated		bit(1),
  2    57 	  3 allocate		bit(1),
  2    58 	  3 allocated		bit(1),
  2    59 	  3 aliasable		bit(1),
  2    60 	  3 even			bit(1),
  2    61 	  3 perm_address		bit(1),
  2    62 	  3 aggregate		bit(1),
  2    63 	  3 hit_zero		bit(1),
  2    64 	  3 dont_save		bit(1),
  2    65 	  3 fo_in_qual		bit(1),
  2    66 	  3 hard_to_load		bit(1),
  2    67 	2 relocation		bit(12) unaligned,
  2    68 	2 more_bits		structure unaligned,
  2    69 	  3 substr		bit(1),
  2    70 	  3 padded_for_store_ref	bit(1),
  2    71 	  3 aligned_for_store_ref	bit(1),
  2    72 	  3 mbz			bit(15),
  2    73 	2 store_ins		bit(18) unaligned;
  2    74 
  2    75 /* END INCLUDE FILE ... reference.incl.pl1 */
      118 
  3     1 /* BEGIN INCLUDE FILE ... machine_state.incl.pl1 */
  3     2 
  3     3 dcl	cg_static_$m_s_p ptr ext static,
  3     4 	m_s_p ptr init(cg_static_$m_s_p);
  3     5 
  3     6 dcl	1 machine_state	aligned based(m_s_p),
  3     7 	2 node_type	bit(9),
  3     8 	2 indicators	fixed bin,
  3     9 	2 next		ptr unal,
  3    10 	2 a_reg,
  3    11 	  3 variable(10)	ptr unal,
  3    12 	  3 number	fixed bin(17),
  3    13 	  3 size		fixed bin(8),
  3    14 	  3 length	fixed bin(8),
  3    15 	  3 offset	fixed bin(8),
  3    16 	  3 constant	fixed bin(24),
  3    17 	  3 changed	fixed bin(18),
  3    18 	  3 instruction	bit(36),
  3    19 	  3 locked	bit(1) aligned,
  3    20 	  3 number_h_o	fixed bin,
  3    21 	  3 has_offset(3)	ptr unal,
  3    22 	2 q_reg,
  3    23 	  3 variable(10)	ptr unal,
  3    24 	  3 number	fixed bin(17),
  3    25 	  3 size		fixed bin(8),
  3    26 	  3 length	fixed bin(8),
  3    27 	  3 offset	fixed bin(8),
  3    28 	  3 constant	fixed bin(24),
  3    29 	  3 changed	fixed bin(18),
  3    30 	  3 instruction	bit(36),
  3    31 	  3 locked	bit(1) aligned,
  3    32 	  3 number_h_o	fixed bin,
  3    33 	  3 has_offset(3)	ptr unal,
  3    34 	2 string_reg,
  3    35 	  3 variable	ptr unal,
  3    36 	  3 size		fixed bin(8),
  3    37 	  3 offset	fixed bin(8),
  3    38 	2 complex_reg,
  3    39 	  3 variable	ptr unal,
  3    40 	  3 size		fixed bin(8),
  3    41 	  3 scale		fixed bin(8),
  3    42 	2 decimal_reg,
  3    43 	  3 variable	ptr unal,
  3    44 	  3 size		fixed bin(8),
  3    45 	  3 scale		fixed bin(8),
  3    46 	2 index_regs(0:7),
  3    47 	  3 variable	ptr unal,
  3    48 	  3 constant	fixed bin,
  3    49 	  3 type		fixed bin(8),
  3    50 	  3 used		fixed bin(18),
  3    51 	  3 changed	fixed bin(18),
  3    52 	  3 instruction	bit(36),
  3    53 	  3 filler	fixed bin,
  3    54 	2 base_regs(0:7),
  3    55 	  3 variable	ptr unal,
  3    56 	  3 constant	fixed bin,
  3    57 	  3 type		fixed bin(8),
  3    58 	  3 pad (12)	fixed bin,	/* future...room to make 5 element array for variable, constant, type */
  3    59 	  3 number	fixed bin (17),	/* future...number of valid elements in array */
  3    60 	  3 used		fixed bin(18),
  3    61 	  3 changed	fixed bin(18),
  3    62 	  3 instruction	bit(36),
  3    63 	  3 locked	fixed bin(2),
  3    64 	2 indicators_ref(2:3) ptr unal;
  3    65 
  3    66 /* Permissible values for machine_state.indicators. */
  3    67 
  3    68 dcl (	ind_known_refs	init (-2),		/* set by comparison of known, nonzero, references */
  3    69 	ind_invalid	init (-1),
  3    70 	ind_string_aq	init (0),			/* logical value in storage */
  3    71 	ind_logical	init (1),			/* logical value in A or AQ */
  3    72 	ind_arithmetic	init (2),			/* arith value in Q, AQ, or EAQ */
  3    73 	ind_x (0:7)	init (6, 7, 8, 9, 10, 11, 12, 13),
  3    74 	ind_decimal_reg	init (14)
  3    75 	) fixed bin internal static options (constant);
  3    76 
  3    77 /* END INCLUDE FILE ... machine_state.incl.pl1 */
      119 
  4     1 dcl (	real_fix_bin_1		init(1),
  4     2 	real_fix_bin_2		init(2),
  4     3 	real_flt_bin_1		init(3),
  4     4 	real_flt_bin_2		init(4),
  4     5 	complex_fix_bin_1		init(5),
  4     6 	complex_fix_bin_2		init(6),
  4     7 	complex_flt_bin_1		init(7),
  4     8 	complex_flt_bin_2		init(8),
  4     9 	real_fix_dec		init(9),
  4    10 	real_flt_dec		init(10),
  4    11 	complex_fix_dec		init(11),
  4    12 	complex_flt_dec		init(12),
  4    13 	char_string		init(13),
  4    14 	bit_string		init(14),
  4    15 	label_constant		init(15),
  4    16 	local_label_variable	init(16),
  4    17 	label_variable		init(17),
  4    18 	entry_variable		init(18),
  4    19 	ext_entry_in		init(19),
  4    20 	ext_entry_out		init(20),
  4    21 	int_entry			init(21),
  4    22 	int_entry_other		init(22),
  4    23 	unpacked_ptr		init(23),
  4    24 	packed_ptr		init(24)) fixed bin(15) int static options(constant);
      120 
  5     1 /* BEGIN INCLUDE FILE ... boundary.incl.pl1 */
  5     2 
  5     3 /* Modified: 26 Apr 1979 by PCK to implement 4-bit decimal */
  5     4 
  5     5 dcl (	bit_		init(1),
  5     6 	digit_		init(2),
  5     7 	character_	init(3),
  5     8 	half_		init(4),
  5     9 	word_		init(5),
  5    10 	mod2_		init(6),
  5    11 	mod4_		init(7)) fixed bin(3) int static options(constant);
  5    12 
  5    13 /* END INCLUDE FILE ... boundary.incl.pl1 */
      121 
  6     1 dcl	bases(0:7) bit(3) aligned int static init("000"b, "010"b, "100"b,  "001"b, "011"b, "101"b, "111"b,"110"b)
  6     2 	options(constant);
  6     3 
  6     4 dcl (	ap	defined(bases(0)),
  6     5 	bp	defined(bases(1)),
  6     6 	lp	defined(bases(2)),
  6     7 	sp	defined(bases(7))) bit(3) aligned;
  6     8 
  6     9 dcl (	ab	defined(bases(3)),
  6    10 	bb	defined(bases(4)),
  6    11 	lb	defined(bases(5)),
  6    12 	sb	defined(bases(6))) bit(3) aligned;
  6    13 
  6    14 dcl	which_base(0:7) fixed bin int static init(0,3,1,4,2,5,7,6) options(constant);
      122 
      123 
      124 	all_zeros, all_ones = "0"b;
      125 
      126 s0:	p = pt;
      127 
      128 	if p -> reference.temp_ref & ^ p -> reference.aggregate
      129 	then do;
      130 	     if ^ p -> reference.allocated
      131 	     then do;
      132 		if p -> reference.data_type = complex_flt_bin_1
      133 		then call expmac((stfx2),cg_stat$complex_ac);
      134 		return;
      135 		end;
      136 
      137 	     store_it = cg_stat$save_exp_called;
      138 	     end;
      139 	else store_it = "1"b;
      140 
      141 	goto l0;
      142 
      143 store$force: entry(pt);
      144 
      145 	all_zeros, all_ones = "0"b;
      146 	p = pt;
      147 	store_it = "1"b;
      148 
      149 l0:	call state_man$flush_ref(p);
      150 
      151 	type = p -> reference.data_type;
      152 
      153 	if type = unpacked_ptr
      154 	then do;
      155 	     type = real_fix_bin_2;
      156 	     goto l1;
      157 	     end;
      158 
      159 	if type = packed_ptr
      160 	then do;
      161 	     type = real_fix_bin_1;
      162 	     goto l1;
      163 	     end;
      164 
      165 	if type >= char_string
      166 	then do;
      167 	     arith = "0"b;
      168 	     goto string_;
      169 	     end;
      170 
      171 l1:	arith = "1"b;
      172 
      173 	if ^ p -> reference.aligned_for_store_ref
      174 	then do;
      175 
      176 	     if p -> reference.temp_ref
      177 		then p -> reference.value_in.storage = "1"b;
      178 
      179 	     if type = real_fix_bin_1
      180 	     then do;
      181 		size = p -> reference.c_length;
      182 
      183 		if p -> reference.hard_to_load
      184 		then if size = bits_per_word
      185 		     then do;
      186 			in_q = 1;
      187 			go to str1;
      188 			end;
      189 		     else;
      190 		else do;
      191 		     cfo = mod(p -> reference.c_offset * convert_offset(p -> reference.units),36);
      192 		     if cfo < 0 then cfo = cfo + 36;
      193 
      194 		     if cfo = bits_per_word - size
      195 		     then do;
      196 			in_q = 1;
      197 			go to str1;
      198 			end;
      199 		     end;
      200 		end;
      201 
      202 	     call state_man$erase_reg("1"b);	/* erase a register */
      203 
      204 	     a_reg.size, size = p -> reference.c_length;
      205 	     a_reg.length = 72;
      206 
      207 	     if type <= real_fix_bin_2
      208 	     then do;
      209 		a_reg.offset = 72 - size;
      210 		goto str1;
      211 		end;
      212 
      213 	     if type <= real_flt_bin_2
      214 	     then do;
      215 		call expmac$zero(pack_fl1 - real_flt_bin_1 + type);
      216 		a_reg.offset = 0;
      217 		goto str1;
      218 		end;
      219 
      220 	     if type = complex_flt_bin_1
      221 	     then do;
      222 		k = bits_per_word - divide(size,2,17,0);
      223 		if k > 0
      224 		     then call expmac((pack_cfl1),c_a(k,1));
      225 		a_reg.offset = 0;
      226 		goto str1;
      227 		end;
      228 
      229 	     goto str1;
      230 	     end;
      231 
      232 	if type = complex_flt_bin_1 then macro = stfx2;
      233 	else macro = stfx1 - 1 + type;
      234 
      235 	if store_it then call expmac(macro,p);
      236 
      237 up_q:	do i = 1 to q_reg.number;
      238 	     if q_reg.variable(i) = p then goto thru;
      239 	     end;
      240 
      241 	if i < 11
      242 	then do;
      243 	     q_reg.number = i;
      244 	     q_reg.variable(i) = p;
      245 	     p -> reference.value_in.q = "1"b;
      246 	     end;
      247 
      248 thru:	if p -> reference.temp_ref & store_it
      249 	then do;
      250 	     p -> reference.store_ins = bit(fixed(cg_stat$text_pos - 1,18),18);
      251 	     p -> reference.value_in.storage = "1"b;
      252 	     end;
      253 
      254 	return;
      255 
      256 string_:	if ^ store_it then goto update_a;
      257 
      258 	size = p -> reference.c_length * convert_size(type);
      259 
      260 str1:
      261 
      262 /* If a reference is hard_to_load, it is also hard to store and we will use EIS to
      263*   accomplish the feat */
      264 
      265 	if p -> reference.hard_to_load
      266 	then do;
      267 
      268 	     /* First shift string to the left of the aq */
      269 
      270 	     if in_q = 0
      271 	     then if a_reg.offset > 0
      272 		then call aq_man$left_shift(a_reg.offset, a_reg.length > bits_per_word);
      273 
      274 	     /* store the string in the double temp (sp|46) */
      275 
      276 	     q = c_a(46,4);
      277 	     q -> reference.c_length = p -> reference.c_length;
      278 
      279 	     call expmac$one((st_reg(in_q)),q,fixed(size > bits_per_word,1));
      280 
      281 	     /* Now update the machine state */
      282 
      283 	     if ^ arith
      284 		then call up_a;
      285 		else type = bit_string;
      286 
      287 	     /* Finally move from the temp to the actual reference */
      288 
      289 	     if p -> reference.temp_ref
      290 		then p -> reference.value_in.storage = "1"b;
      291 
      292 	     call expmac$two_eis((move_chars + type - char_string),p,q);
      293 
      294 	     if in_q ^= 0 then go to up_q;
      295 	     return;
      296 	     end;
      297 
      298 	units = p -> reference.units;
      299 
      300 	if units = word_
      301 	then cfo = 0;
      302 	else do;
      303 	     cfo = mod(p -> reference.c_offset * convert_offset(units),36);
      304 	     if cfo < 0 then cfo = cfo + 36;
      305 	     end;
      306 
      307 	/* have constant bit offset, do the store out-of-line if
      308*	   the string overlaps into third word */
      309 
      310 	offset = cfo;
      311 	k = size + offset;
      312 	d = fixed(k > 36,1);
      313 	contiguous = k <= 36;
      314 
      315 	if all_zeros then goto s1;
      316 	if in_q > 0 then goto s1;
      317 
      318 	shift = offset - a_reg.offset;
      319 	if shift = 0 then goto s1;
      320 
      321 	b1 = a_reg.length <= 36 & contiguous;
      322 
      323 	if shift < 0
      324 	then call aq_man$left_shift(- shift, ^ b1);
      325 
      326 	else do;
      327 
      328 	     if b1
      329 		then i = bits_per_word;
      330 		else i = bits_per_two_words;
      331 
      332 	     call aq_man$check_strings(i-shift);
      333 	     if a_reg.size + offset > i then a_reg.size = i - offset;
      334 
      335 	     call aq_man$right_shift(shift, ^ b1);
      336 	     end;
      337 
      338 s1:	if offset > 0 then goto check;
      339 
      340           if size = 0
      341           then if ^ p -> reference.temp_ref
      342 	     then goto easy_done;
      343 
      344 	if mod(size,36) = 0
      345 	then do;
      346 	     if a_reg.length < size then call aq_man$trim_aq(size);
      347 	     goto blast;
      348 	     end;
      349 
      350 	if ^ p -> reference.padded_for_store_ref then goto check;
      351 
      352 	/* can do single store, trim any excess bits on right */
      353 
      354 	if all_zeros then goto blast;
      355 
      356 	if a_reg.size > size | a_reg.length < 36*(d + 1)
      357 	then do;
      358 	     call aq_man$trim_aq(size);
      359 	     a_reg.size = size;
      360 	     end;
      361 
      362 blast:	call expmac$one((sta),p,d);
      363 	goto easy_done;
      364 
      365 	/* if offset is a constant multiple of 6 or 9 and size is a
      366*	   multiple also, generate a stca-stcq or stba-stbq sequence.
      367*	   otherwise, use insert code */
      368 
      369 check:
      370 
      371 	do i = 1 to 2;
      372 	     u = bytes(i);
      373 	     if mod(offset,u) = 0
      374 	     then do;
      375 		j = mod(size,u);
      376 		if j = 0 then goto easy;
      377 
      378 		if p -> reference.padded_for_store_ref
      379 		then do;
      380 		     size = size + (u - j);
      381 		     goto easy;
      382 		     end;
      383 
      384 		end;
      385 	     end;
      386 
      387 	/* we must insert value into storage */
      388 
      389 insert:	if all_ones
      390 	then do;
      391 	     call expmac$one((orsa),p,d);
      392 	     go to easy_done;
      393 	     end;
      394 
      395 	if ^p -> reference.shared
      396 	     then p -> reference.ref_count = p -> reference.ref_count + 1;
      397 
      398 	call expmac$one((era(in_q)),p,d);
      399 
      400 	p -> reference.perm_address = "1"b;
      401 
      402 
      403 	/* have constant bit offset, no shifting needed */
      404 
      405 	if offset = 0 then q = c_a(k,5);
      406 	else do;
      407 	     mask = (72)"0"b;
      408 	     substr(mask,offset+1,size) = (72)"1"b;
      409 	     if substr(mask,72,1) then q = c_a((offset),7);
      410 	     else q = generate_constant(mask,d+1);
      411 	     end;
      412 
      413 	call expmac$one((ana(in_q)),q,d);
      414 
      415 	call expmac$one((ersa(in_q)),p,d);
      416 
      417 	p -> reference.perm_address = "0"b;
      418 
      419 	if in_q > 0
      420 	     then return;
      421 
      422 done:	a_reg.size = 0;
      423 
      424 	do i = 1 to a_reg.number;
      425 	a_reg.variable(i) -> reference.value_in.a = "0"b;
      426 	end;
      427 
      428 	a_reg.number = 0;
      429 
      430 	return;
      431 
      432 	/* can use special character instructions, calculate modifiers */
      433 
      434 easy:	unit_offset = divide(offset,u,17,0);
      435 	unit_size = divide(size,u,17,0);
      436 
      437 	bs = "0"b;
      438 	substr(bs,unit_offset+1,unit_size) = (12)"1"b;
      439 
      440 	n = nbspw(i);
      441 	ta = substr(bs,1,n);
      442 	tq = substr(bs,n+1,n);
      443 
      444 	/* make destination addressable, place address in any base register if original address
      445*	   has any tag other than 0 */
      446 
      447 	call m_a(p,"0"b);
      448 
      449 	if p -> reference.tag
      450 	then do;
      451 	     if cfo ^= 0
      452 		then p -> reference.units = word_;	/* Inhibit base_man from loading fractional offset */
      453 	     p -> reference.perm_address = "1"b;
      454 	     if ^p -> reference.shared
      455 		then p -> reference.ref_count = p -> reference.ref_count + 1;
      456 	     call base_man$load_any_var(2,p,base3);
      457 	     if cfo ^= 0
      458 	     then do;
      459 
      460 		/* Since we do not have full address in the pointer register,
      461*		   we must flush its address from the machine state */
      462 
      463 		p -> reference.units = units;
      464 		j = which_base(fixed(base3,3));
      465 		base_regs(j).type = 0;
      466 		p -> reference.address_in.b(j) = "0"b;
      467 		end;
      468 	     end;
      469 
      470 	p -> reference.perm_address = "1"b;
      471 
      472 	if ta = full(i) then macro = sta;
      473 	else do;
      474 	     macro = store_units(i) + in_q;
      475 	     p -> reference.tag = ta;
      476 	     end;
      477 
      478 	if ^p -> reference.shared
      479 	     then p -> reference.ref_count = p -> reference.ref_count + 1;
      480 
      481 	call expmac(macro,p);
      482 
      483 	if k <= 36
      484 	then do;
      485 	     call adjust_ref_count(p,-1);
      486 	     if in_q > 0 then go to up_q;
      487 	     go to easy_done;
      488 	     end;
      489 
      490 	if tq = full(i)
      491 	then do;
      492 	     macro = stfx1;
      493 	     tq = "0"b;
      494 	     end;
      495 	else macro = store_units(i) + 1;
      496 
      497 	p -> address.offset = bit(fixed(fixed(p -> address.offset,15)+1,15),15);
      498 	p -> address.tag = tq;
      499 
      500 
      501 	call expmac(macro,p);
      502 
      503 	a_reg.size = size;
      504 	a_reg.length = size + offset;
      505 
      506 easy_done:
      507 	p -> reference.perm_address = "0"b;
      508 
      509 	if arith then return;
      510 
      511 	a_reg.offset = offset;
      512 
      513 update_a:	call up_a;
      514 
      515 	if a_reg.number = 0
      516 	     then return;
      517 	     else go to thru;
      518 
      519 store$all_ones: entry(pt);
      520 
      521 	all_ones = "1"b;
      522 	all_zeros = "0"b;
      523 	goto s0;
      524 
      525 store$all_zeros: entry(pt);
      526 
      527 	all_ones = "0"b;
      528 	all_zeros = "1"b;
      529 	goto s0;
      530 
      531 store$save_string_temp: entry(pt);
      532 
      533 	p = pt;
      534 	call stack_temp$assign_block(p,2);
      535 	p -> reference.address_in.storage = "0"b;
      536 	p -> reference.store_ins = bit(cg_stat$text_pos,18);
      537 	call expmac((store_pt),p);
      538 	p -> reference.address_in.storage = "1"b;
      539 	return;
      540 
      541 
      542 up_a:	proc;
      543 
      544 	do i = 1 to a_reg.number;
      545 	if a_reg.variable(i) = p then return;
      546 	end;
      547 
      548 	if i < 11
      549 	then do;
      550 	     a_reg.number = i;
      551 	     a_reg.variable(i) = p;
      552 	     p -> reference.value_in.a = "1"b;
      553 	     end;
      554 
      555 end;
      556 
      557 
      558 	end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/03/83  1009.4  store.pl1                         >spec>on>pl128d>store.pl1
117          1    10/25/79  1645.8  cgsystem.incl.pl1                 >ldd>include>cgsystem.incl.pl1
118          2    07/21/80  1546.3  reference.incl.pl1                >ldd>include>reference.incl.pl1
119          3    11/13/79  1015.8  machine_state.incl.pl1            >ldd>include>machine_state.incl.pl1
120          4    05/03/76  1320.4  data_types.incl.pl1               >ldd>include>data_types.incl.pl1
121          5    10/25/79  1645.8  boundary.incl.pl1                 >ldd>include>boundary.incl.pl1
122          6    05/03/76  1320.8  bases.incl.pl1                    >ldd>include>bases.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a                        11(09)        based           bit(1)                   level 4 packed unaligned dcl 2-3 set ref 425* 552*
a_reg                     3            based           structure                level 2 dcl 3-6
address                  10            based           structure                level 2 packed unaligned dcl 2-3
address_in               11            based           structure                level 3 packed unaligned dcl 2-3
adjust_ref_count                000050 constant        entry                    external dcl 46 ref 485
aggregate                12(19)        based           bit(1)                   level 3 packed unaligned dcl 2-3 ref 128
aligned_for_store_ref
                         13(02)        based           bit(1)                   level 3 packed unaligned dcl 2-3 ref 173
all_ones                        000122 automatic       bit(1)                   dcl 33 set ref 124* 145* 389 521* 527*
all_zeros                       000123 automatic       bit(1)                   dcl 33 set ref 124* 145* 315 354 522* 528*
allocated                12(15)        based           bit(1)                   level 3 packed unaligned dcl 2-3 ref 130
ana                             000030 constant        fixed bin(15,0)          initial array dcl 96 ref 413
aq_man$check_strings            000042 constant        entry                    external dcl 46 ref 332
aq_man$left_shift               000036 constant        entry                    external dcl 46 ref 270 323
aq_man$right_shift              000040 constant        entry                    external dcl 46 ref 335
aq_man$trim_aq                  000044 constant        entry                    external dcl 46 ref 346 358
arith                           000125 automatic       bit(1)                   dcl 33 set ref 167* 171* 283 509
b                        11            based           bit(1)                   array level 4 packed unaligned dcl 2-3 set ref 466*
b1                              000124 automatic       bit(1)                   dcl 33 set ref 321* 323 328 335
base3                           000135 automatic       bit(3)                   dcl 33 set ref 456* 464
base_man$load_any_var           000026 constant        entry                    external dcl 46 ref 456
base_regs               160            based           structure                array level 2 dcl 3-6
bit                                                    builtin function         dcl 66 ref 250 497 536
bit_string                             constant        fixed bin(15,0)          initial dcl 4-1 ref 285
bits                     12(06)        based           structure                level 2 packed unaligned dcl 2-3
bits_per_two_words                     constant        fixed bin(8,0)           initial dcl 1-5 ref 330
bits_per_word                          constant        fixed bin(8,0)           initial dcl 1-5 ref 183 194 222 270 279 279 328
bs                              000131 automatic       bit(12)                  unaligned dcl 33 set ref 437* 438* 441 442
bytes                           000036 constant        fixed bin(17,0)          initial array dcl 68 ref 372
c_a                             000020 constant        entry                    external dcl 46 ref 223 223 276 405 409
c_length                  2            based           fixed bin(24,0)          level 2 dcl 2-3 set ref 181 204 258 277* 277
c_offset                  1            based           fixed bin(24,0)          level 2 dcl 2-3 ref 191 303
cfo                             000106 automatic       fixed bin(17,0)          dcl 33 set ref 191* 192 192* 192 194 300* 303* 304
                                                                                  304* 304 310 451 457
cg_stat$complex_ac              000014 external static pointer                  dcl 29 set ref 132*
cg_stat$save_exp_called         000010 external static bit(1)                   dcl 29 ref 137
cg_stat$text_pos                000012 external static fixed bin(18,0)          dcl 29 ref 250 536
cg_static_$m_s_p                000056 external static pointer                  dcl 3-3 ref 3-3
char_string                            constant        fixed bin(15,0)          initial dcl 4-1 ref 165 292
complex_flt_bin_1                      constant        fixed bin(15,0)          initial dcl 4-1 ref 132 220 232
contiguous                      000121 automatic       bit(1)                   dcl 33 set ref 313* 321
convert_offset                  000010 constant        fixed bin(8,1)           initial array dcl 1-35 ref 191 303
convert_size                    000016 constant        fixed bin(8,0)           initial array dcl 1-5 ref 258
d                               000111 automatic       fixed bin(17,0)          dcl 33 set ref 312* 356 362* 391* 398* 410 413* 415*
data_type                12            based           fixed bin(5,0)           level 2 packed unaligned dcl 2-3 ref 132 151
divide                                                 builtin function         dcl 66 ref 222 434 435
era                             000026 constant        fixed bin(15,0)          initial array dcl 96 ref 398
ersa                            000024 constant        fixed bin(15,0)          initial array dcl 96 ref 415
expmac                          000054 constant        entry                    external dcl 46 ref 132 223 235 481 501 537
expmac$one                      000052 constant        entry                    external dcl 46 ref 279 362 391 398 413 415
expmac$two_eis                  000024 constant        entry                    external dcl 46 ref 292
expmac$zero                     000022 constant        entry                    external dcl 46 ref 215
fixed                                                  builtin function         dcl 66 ref 250 279 279 312 464 497 497
full                            000032 constant        bit(6)                   initial array dcl 86 ref 472 490
generate_constant               000046 constant        entry                    external dcl 46 ref 410
hard_to_load             12(23)        based           bit(1)                   level 3 packed unaligned dcl 2-3 ref 183 260
i                               000112 automatic       fixed bin(17,0)          dcl 33 set ref 237* 238* 241 243 244 328* 330* 332
                                                                                  333 333 369* 372* 424* 425* 440 472 474 490 495
                                                                                  544* 545* 548 550 551
in_q                            000134 automatic       fixed bin(1,0)           initial dcl 33 set ref 33* 186* 196* 270 279 294 316
                                                                                  398 413 415 419 474 486
info                     11            based           structure                level 2 packed unaligned dcl 2-3
j                               000113 automatic       fixed bin(17,0)          dcl 33 set ref 375* 376 380 464* 465 466
k                               000114 automatic       fixed bin(17,0)          dcl 33 set ref 222* 223 223* 223* 311* 312 313 405*
                                                                                  483
length                   17            based           fixed bin(8,0)           level 3 dcl 3-6 set ref 205* 270 321 346 356 504*
m_a                             000016 constant        entry                    external dcl 45 ref 447
m_s_p                           000140 automatic       pointer                  initial dcl 3-3 set ref 204 205 209 216 225 237 238
                                                                                  243 244 270 270 270 318 321 333 333 346 356 356
                                                                                  359 422 424 425 428 465 503 504 511 515 3-3* 544
                                                                                  545 550 551
machine_state                          based           structure                level 1 dcl 3-6
macro                           000126 automatic       fixed bin(15,0)          dcl 33 set ref 232* 233* 235* 472* 474* 481* 492*
                                                                                  495* 501*
mask                            000132 automatic       bit(72)                  dcl 33 set ref 407* 408* 409 410*
mod                                                    builtin function         dcl 66 ref 191 303 344 373 375
more_bits                13            based           structure                level 2 packed unaligned dcl 2-3
move_chars                             constant        fixed bin(15,0)          initial dcl 96 ref 292
n                               000116 automatic       fixed bin(17,0)          dcl 33 set ref 440* 441 442 442
nbspw                           000034 constant        fixed bin(17,0)          initial array dcl 68 ref 440
number                   15            based           fixed bin(17,0)          level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "store" set ref 424 428* 515 544 550*
number                   43            based           fixed bin(17,0)          level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "store" set ref 237 243*
offset                   20            based           fixed bin(8,0)           level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "store" set ref 209* 216* 225* 270
                                                                                  270* 318 511*
offset                          000127 automatic       fixed bin(15,0)          dcl 33 in procedure "store" set ref 310* 311 318 333
                                                                                  333 338 373 405 408 409 434 504 511
offset                   10(03)        based           bit(15)                  level 3 in structure "reference" packed unaligned
                                                                                  dcl 2-3 in procedure "store" set ref 497* 497
orsa                                   constant        fixed bin(15,0)          initial dcl 96 ref 391
p                               000100 automatic       pointer                  dcl 33 set ref 126* 128 128 130 132 146* 149* 151
                                                                                  173 176 176 181 183 191 191 204 235* 238 244 245
                                                                                  248 250 251 258 260 277 289 289 292* 298 303 340
                                                                                  350 362* 378 391* 395 395 395 398* 400 415* 417
                                                                                  447* 449 451 453 454 454 454 456* 463 466 470 475
                                                                                  478 478 478 481* 485* 497 497 498 501* 506 533*
                                                                                  534* 535 536 537* 538 545 551 552
pack_cfl1                              constant        fixed bin(15,0)          initial dcl 96 ref 223
pack_fl1                               constant        fixed bin(15,0)          initial dcl 96 ref 215
packed_ptr                             constant        fixed bin(15,0)          initial dcl 4-1 ref 159
padded_for_store_ref     13(01)        based           bit(1)                   level 3 packed unaligned dcl 2-3 ref 350 378
perm_address             12(18)        based           bit(1)                   level 3 packed unaligned dcl 2-3 set ref 400* 417*
                                                                                  453* 470* 506*
pt                                     parameter       pointer                  dcl 27 ref 25 126 143 146 519 525 531 533
q                               000102 automatic       pointer                  dcl 33 in procedure "store" set ref 276* 277 279*
                                                                                  292* 405* 409* 410* 413*
q                        11(10)        based           bit(1)                   level 4 in structure "reference" packed unaligned
                                                                                  dcl 2-3 in procedure "store" set ref 245*
q_reg                    31            based           structure                level 2 dcl 3-6
real_fix_bin_1                         constant        fixed bin(15,0)          initial dcl 4-1 ref 161 179
real_fix_bin_2                         constant        fixed bin(15,0)          initial dcl 4-1 ref 155 207
real_flt_bin_1                         constant        fixed bin(15,0)          initial dcl 4-1 ref 215
real_flt_bin_2                         constant        fixed bin(15,0)          initial dcl 4-1 ref 213
ref_count                 0(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 2-3 set ref 395* 395
                                                                                  454* 454 478* 478
reference                              based           structure                level 1 dcl 2-3
shared                    0(11)        based           bit(1)                   level 2 packed unaligned dcl 2-3 ref 395 454 478
shift                           000130 automatic       fixed bin(8,0)           dcl 33 set ref 318* 319 323 323 332 335*
size                            000105 automatic       fixed bin(17,0)          dcl 33 in procedure "store" set ref 181* 183 194
                                                                                  204* 209 222 258* 279 279 311 340 344 346 346* 356
                                                                                  358* 359 375 380* 380 408 435 503 504
size                     16            based           fixed bin(8,0)           level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "store" set ref 204* 333 333* 356
                                                                                  359* 422* 503*
st_reg                          000020 constant        fixed bin(15,0)          initial array dcl 96 ref 279
sta                                    constant        fixed bin(15,0)          initial dcl 96 ref 362 472
stack_temp$assign_block         000030 constant        entry                    external dcl 46 ref 534
state_man$erase_reg             000034 constant        entry                    external dcl 46 ref 202
state_man$flush_ref             000032 constant        entry                    external dcl 46 ref 149
stfx1                                  constant        fixed bin(15,0)          initial dcl 96 ref 233 492
stfx2                                  constant        fixed bin(15,0)          initial dcl 96 ref 132 232
storage                  11(23)        based           bit(1)                   level 4 in structure "reference" packed unaligned
                                                                                  dcl 2-3 in procedure "store" set ref 176* 251*
                                                                                  289*
storage                  11(08)        based           bit(1)                   level 4 in structure "reference" packed unaligned
                                                                                  dcl 2-3 in procedure "store" set ref 535* 538*
store_ins                13(18)        based           bit(18)                  level 2 packed unaligned dcl 2-3 set ref 250* 536*
store_it                        000120 automatic       bit(1)                   dcl 33 set ref 137* 139* 147* 235 248 256
store_pt                               constant        fixed bin(15,0)          initial dcl 96 ref 537
store_units                     000022 constant        fixed bin(15,0)          initial array dcl 96 ref 474 495
substr                                                 builtin function         dcl 66 set ref 408* 409 438* 441 442
ta                              000136 automatic       bit(6)                   unaligned dcl 33 set ref 441* 472 475
tag                      10(30)        based           bit(6)                   level 3 packed unaligned dcl 2-3 set ref 449 475*
                                                                                  498*
temp_ref                 12(11)        based           bit(1)                   level 3 packed unaligned dcl 2-3 ref 128 176 248 289
                                                                                  340
tq                              000137 automatic       bit(6)                   unaligned dcl 33 set ref 442* 490 493* 498
type                    162            based           fixed bin(8,0)           array level 3 in structure "machine_state" dcl 3-6
                                                                                  in procedure "store" set ref 465*
type                            000104 automatic       fixed bin(17,0)          dcl 33 in procedure "store" set ref 151* 153 155*
                                                                                  159 161* 165 179 207 213 215 220 232 233 258 285*
                                                                                  292
u                               000115 automatic       fixed bin(17,0)          dcl 33 set ref 372* 373 375 380 434 435
unit_offset                     000110 automatic       fixed bin(17,0)          dcl 33 set ref 434* 438
unit_size                       000107 automatic       fixed bin(17,0)          dcl 33 set ref 435* 438
units                     0(14)        based           fixed bin(3,0)           level 2 in structure "reference" packed unaligned
                                                                                  dcl 2-3 in procedure "store" set ref 191 298 451*
                                                                                  463*
units                           000117 automatic       fixed bin(17,0)          dcl 33 in procedure "store" set ref 298* 300 303 463
unpacked_ptr                           constant        fixed bin(15,0)          initial dcl 4-1 ref 153
value_in                 11(09)        based           structure                level 3 packed unaligned dcl 2-3
variable                  3            based           pointer                  array level 3 in structure "machine_state" packed
                                                                                  unaligned dcl 3-6 in procedure "store" set ref 425
                                                                                  545 551*
variable                 31            based           pointer                  array level 3 in structure "machine_state" packed
                                                                                  unaligned dcl 3-6 in procedure "store" set ref 238
                                                                                  244*
which_base                      000000 constant        fixed bin(17,0)          initial array dcl 6-14 ref 464
word_                                  constant        fixed bin(3,0)           initial dcl 5-5 ref 300 451

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ab                                     defined         bit(3)                   dcl 6-9
abs                                                    builtin function         dcl 66
addr                                                   builtin function         dcl 66
addrel                                                 builtin function         dcl 66
als                                    internal static fixed bin(15,0)          initial dcl 96
anaq                                   internal static fixed bin(15,0)          initial dcl 96
ap                                     defined         bit(3)                   dcl 6-4
arg                                    automatic       pointer                  array dcl 33
arl                                    internal static fixed bin(15,0)          initial dcl 96
bases                                  internal static bit(3)                   initial array dcl 6-1
bb                                     defined         bit(3)                   dcl 6-9
bit_                                   internal static fixed bin(3,0)           initial dcl 5-5
bits_per_char                          internal static fixed bin(8,0)           initial dcl 1-5
bits_per_four_words                    internal static fixed bin(8,0)           initial dcl 1-5
bits_per_half                          internal static fixed bin(8,0)           initial dcl 1-5
bits_per_packed_digit                  internal static fixed bin(8,1)           initial dcl 1-35
bits_per_words                         internal static fixed bin(8,0)           initial array dcl 1-5
bp                                     defined         bit(3)                   dcl 6-4
break_even_bits                        internal static fixed bin(8,0)           initial dcl 1-5
break_even_words                       internal static fixed bin(8,0)           initial dcl 1-5
character_                             internal static fixed bin(3,0)           initial dcl 5-5
chars_per_word                         internal static fixed bin(8,0)           initial dcl 1-5
co_to_bo                               internal static fixed bin(17,0)          initial dcl 76
complex_fix_bin_1                      internal static fixed bin(15,0)          initial dcl 4-1
complex_fix_bin_2                      internal static fixed bin(15,0)          initial dcl 4-1
complex_fix_dec                        internal static fixed bin(15,0)          initial dcl 4-1
complex_flt_bin_2                      internal static fixed bin(15,0)          initial dcl 4-1
complex_flt_dec                        internal static fixed bin(15,0)          initial dcl 4-1
default_fix_bin_p                      internal static fixed bin(8,0)           initial dcl 1-5
digit_                                 internal static fixed bin(3,0)           initial dcl 5-5
entry_variable                         internal static fixed bin(15,0)          initial dcl 4-1
expmac$abs                      000000 constant        entry                    external dcl 46
expmac$many                     000000 constant        entry                    external dcl 46
ext_entry_in                           internal static fixed bin(15,0)          initial dcl 4-1
ext_entry_out                          internal static fixed bin(15,0)          initial dcl 4-1
half_                                  internal static fixed bin(3,0)           initial dcl 5-5
ho_to_bo                               internal static fixed bin(17,0)          initial dcl 76
ind_arithmetic                         internal static fixed bin(17,0)          initial dcl 3-68
ind_decimal_reg                        internal static fixed bin(17,0)          initial dcl 3-68
ind_invalid                            internal static fixed bin(17,0)          initial dcl 3-68
ind_known_refs                         internal static fixed bin(17,0)          initial dcl 3-68
ind_logical                            internal static fixed bin(17,0)          initial dcl 3-68
ind_string_aq                          internal static fixed bin(17,0)          initial dcl 3-68
ind_x                                  internal static fixed bin(17,0)          initial array dcl 3-68
init_xec_7                             internal static bit(36)                  initial array dcl 88
init_xec_q                             internal static bit(36)                  initial array dcl 92
int_entry                              internal static fixed bin(15,0)          initial dcl 4-1
int_entry_other                        internal static fixed bin(15,0)          initial dcl 4-1
label_constant                         internal static fixed bin(15,0)          initial dcl 4-1
label_size                             internal static fixed bin(8,0)           initial dcl 1-5
label_variable                         internal static fixed bin(15,0)          initial dcl 4-1
lb                                     defined         bit(3)                   dcl 6-9
lls                                    internal static fixed bin(15,0)          initial dcl 96
local_label_variable                   internal static fixed bin(15,0)          initial dcl 4-1
long_op$c_or_b                  000000 constant        entry                    external dcl 46
lp                                     defined         bit(3)                   dcl 6-4
lrl                                    internal static fixed bin(15,0)          initial dcl 96
max_dec_scale                          internal static fixed bin(8,0)           initial dcl 1-5
max_index_register_value               internal static fixed bin(31,0)          initial dcl 1-38
max_length_p                           internal static fixed bin(8,0)           initial dcl 1-5
max_offset                             internal static fixed bin(8,0)           initial array dcl 1-5
max_p_fix_bin_1                        internal static fixed bin(8,0)           initial dcl 1-5
max_p_fix_dec                          internal static fixed bin(8,0)           initial dcl 1-5
max_p_flt_bin_1                        internal static fixed bin(8,0)           initial dcl 1-5
max_p_xreg                             internal static fixed bin(8,0)           initial dcl 1-5
max_short_size                         internal static fixed bin(8,0)           initial array dcl 1-5
min                                                    builtin function         dcl 66
min_dec_scale                          internal static fixed bin(8,0)           initial dcl 1-5
mod2_                                  internal static fixed bin(3,0)           initial dcl 5-5
mod4_                                  internal static fixed bin(3,0)           initial dcl 5-5
n1                                     automatic       fixed bin(17,0)          dcl 33
n2                                     automatic       fixed bin(17,0)          dcl 33
n3                                     automatic       fixed bin(17,0)          dcl 33
n4                                     automatic       fixed bin(17,0)          dcl 33
null                                                   builtin function         dcl 66
operator_table                         internal static fixed bin(18,0)          initial dcl 71
packed_digits_per_char                 internal static fixed bin(8,0)           initial dcl 1-5
packed_digits_per_word                 internal static fixed bin(8,0)           initial dcl 1-5
real_fix_dec                           internal static fixed bin(15,0)          initial dcl 4-1
real_flt_dec                           internal static fixed bin(15,0)          initial dcl 4-1
sb                                     defined         bit(3)                   dcl 6-9
shift_and_mask                         internal static fixed bin(15,0)          initial dcl 96
sp                                     defined         bit(3)                   dcl 6-4
store_a6_ho                            internal static fixed bin(17,0)          initial dcl 76
store_a9_co                            internal static fixed bin(17,0)          initial dcl 76
store_a9_ho                            internal static fixed bin(17,0)          initial dcl 76
store_logical                          internal static fixed bin(15,0)          initial dcl 96
store_q6_ho                            internal static fixed bin(17,0)          initial dcl 76
store_q9_co                            internal static fixed bin(17,0)          initial dcl 76
store_q9_ho                            internal static fixed bin(17,0)          initial dcl 76
string                                                 builtin function         dcl 66
units_per_word                         internal static fixed bin(8,0)           initial array dcl 1-5
xec                                    automatic       bit(36)                  array dcl 33
xr_man$load_const               000000 constant        entry                    external dcl 46
xr_man$load_var                 000000 constant        entry                    external dcl 46

NAMES DECLARED BY EXPLICIT CONTEXT.
blast                           001062 constant        label                    dcl 362 ref 347 354
check                           001100 constant        label                    dcl 369 ref 338 350
done                            001342 constant        label                    dcl 422
easy                            001364 constant        label                    dcl 434 ref 376 381
easy_done                       001643 constant        label                    dcl 506 ref 340 363 392 487
insert                          001131 constant        label                    dcl 389
l0                              000157 constant        label                    dcl 149 ref 141
l1                              000210 constant        label                    dcl 171 ref 156 162
s0                              000073 constant        label                    dcl 126 ref 523 529
s1                              001002 constant        label                    dcl 338 ref 315 316 319
store                           000063 constant        entry                    external dcl 25
store$all_ones                  001662 constant        entry                    external dcl 519
store$all_zeros                 001676 constant        entry                    external dcl 525
store$force                     000141 constant        entry                    external dcl 143
store$save_string_temp          001712 constant        entry                    external dcl 531
str1                            000505 constant        label                    dcl 260 ref 187 197 210 217 226 229
string_                         000477 constant        label                    dcl 256 ref 168
thru                            000455 constant        label                    dcl 248 ref 238 515
up_a                            001766 constant        entry                    internal dcl 542 ref 283 513
up_q                            000424 constant        label                    dcl 237 ref 294 486
update_a                        001653 constant        label                    dcl 513 ref 256

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2344        2424    2026        2354
Length      2764    2026        60         324     316           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
store                               140 external procedure  is an external procedure.  
up_a                                    internal procedure  shares stack frame of external procedure store.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
store                    000100 p                           store
                         000102 q                           store
                         000104 type                        store
                         000105 size                        store
                         000106 cfo                         store
                         000107 unit_size                   store
                         000110 unit_offset                 store
                         000111 d                           store
                         000112 i                           store
                         000113 j                           store
                         000114 k                           store
                         000115 u                           store
                         000116 n                           store
                         000117 units                       store
                         000120 store_it                    store
                         000121 contiguous                  store
                         000122 all_ones                    store
                         000123 all_zeros                   store
                         000124 b1                          store
                         000125 arith                       store
                         000126 macro                       store
                         000127 offset                      store
                         000130 shift                       store
                         000131 bs                          store
                         000132 mask                        store
                         000134 in_q                        store
                         000135 base3                       store
                         000136 ta                          store
                         000137 tq                          store
                         000140 m_s_p                       store

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_le_a              unpk_to_pk          call_ext_out_desc   call_ext_out        return
mod_fx1             ext_entry           trunc_fx1           scaled_mod_fx1

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
adjust_ref_count              aq_man$check_strings          aq_man$left_shift             aq_man$right_shift
aq_man$trim_aq                base_man$load_any_var         c_a                           expmac
expmac$one                    expmac$two_eis                expmac$zero                   generate_constant
m_a                           stack_temp$assign_block       state_man$erase_reg           state_man$flush_ref

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
cg_stat$complex_ac            cg_stat$save_exp_called       cg_stat$text_pos              cg_static_$m_s_p




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     33 000051    3    3 000052        25 000060       124 000071       126 000073       128 000077       130 000105
    132 000110       134 000127       137 000130       138 000133       139 000134       141 000136       143 000137
    145 000147       146 000151       147 000155       149 000157       151 000166       153 000172       155 000174
    156 000176       159 000177       161 000201       162 000203       165 000204       167 000206       168 000207
    171 000210       173 000212       176 000215       179 000222       181 000224       183 000226       186 000233
    187 000235       189 000236       191 000237       192 000254       194 000257       196 000263       197 000265
    202 000266       204 000277       205 000304       207 000306       209 000311       210 000314       213 000315
    215 000317       216 000331       217 000333       220 000334       222 000336       223 000344       225 000375
    226 000377       229 000400       232 000401       233 000406       235 000411       237 000424       238 000435
    239 000443       241 000445       243 000447       244 000451       245 000453       248 000455       250 000463
    251 000474       254 000476       256 000477       258 000501       260 000505       270 000511       276 000533
    277 000552       279 000556       283 000601       285 000605       289 000607       292 000615       294 000634
    295 000636       298 000637       300 000643       303 000647       304 000661       310 000664       311 000666
    312 000670       313 000674       315 000700       316 000702       318 000704       319 000710       321 000711
    323 000716       328 000736       330 000743       332 000745       333 000756       335 000766       338 001002
    340 001004       344 001012       346 001015       347 001030       350 001031       354 001035       356 001037
    358 001050       359 001057       362 001062       363 001077       369 001100       372 001105       373 001107
    375 001113       376 001116       378 001117       380 001123       381 001126       385 001127       389 001131
    391 001133       392 001150       395 001151       398 001162       400 001200       405 001203       407 001223
    408 001225       409 001232       410 001255       413 001301       415 001317       417 001335       419 001340
    422 001342       424 001344       425 001353       426 001357       428 001361       430 001363       434 001364
    435 001367       437 001372       438 001373       440 001377       441 001402       442 001406       447 001412
    449 001425       451 001431       453 001437       454 001441       456 001451       457 001466       463 001470
    464 001475       465 001501       466 001504       470 001511       472 001514       474 001523       475 001526
    478 001530       481 001540       483 001551       485 001554       486 001567       487 001571       490 001572
    492 001576       493 001600       494 001601       495 001602       497 001605       498 001622       501 001625
    503 001636       504 001641       506 001643       509 001646       511 001650       513 001653       515 001654
    519 001660       521 001670       522 001672       523 001673       525 001674       527 001704       528 001705
    529 001707       531 001710       533 001720       534 001724       535 001737       536 001742       537 001750
    538 001762       539 001765       542 001766       544 001767       545 001777       546 002006       548 002010
    550 002012       551 002014       552 002016       555 002020


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
