	COMPILATION LISTING OF SEGMENT rw_display_scroll
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/16/84  1126.4 mst Fri
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 /* format: off */



        7 
        8 /*   This is the subroutine called by the display request to implement the
        9*     report writer display scrolling feature. Description and usage follows.
       10*
       11*     Description:
       12*     
       13*     This module provides for the display of paginated and unpaginated
       14*     reports through the video system. It also provides the function of
       15*     setting a scroll function to a provided key sequence. This program
       16*     operates in conjunction with rw_display_process_args (initial
       17*     setup of the scroll_info structure) and rw_display (the caller of
       18*     this subroutine).
       19*
       20*     Usage:
       21*
       22*     See the entrypoints for parameter descriptions.  The entrypoint set_fkey
       23*     is called by rw_display_process_args to set any functions to key
       24*     sequences provided on the request line when the display request is given.
       25*     The start, continue, and stop entrypoints are called by the rw_display
       26*     module for setup, scrolling, and termination respectively.
       27*
       28*     Known Bugs:
       29*
       30*     Other Problems:
       31*
       32*     History:
       33*
       34*     Written - Al Dupuis - August 1983
       35*     Changed - Al Dupuis - October 1984 - Became report_writer_.
       36*
       37**/
       38 
       39 rw_display_scroll: proc;



       40 
       41 	/* These parameters are described at each entry where they are used. */

       42 
       43 dcl code_parm fixed bin (35) parm;
       44 dcl display_arg_results_ptr_parm ptr parm;
       45 dcl function_name_parm char (*) parm;
       46 dcl function_key_sequence_parm char (*) parm;
       47 dcl rci_ptr_parm ptr parm;
       48 dcl sci_ptr_parm ptr parm;
       49 dcl scroll_info_ptr_parm ptr parm;
       50 dcl work_area_ptr_parm ptr parm;



       51 
       52 RETURN_TO_CALLING_PROGRAM:

       53 
       54 	return;
       55 
       56 continue: entry (
       57 
       58 	scroll_info_ptr_parm,	/* input: ptr to the scroll_info structure */
       59 	code_parm			/* output: success, failure, or user quit (error_table_$end_of_info) */
       60 	 );



       61 
       62 /*
       63*
       64*	Mainline Processing Overview
       65*
       66*	(1) Perform initialization.
       67*
       68*	(2) Display a portion of the current page or buffer. Signal 
       69*	    display_buffer_empty if we cross a buffer boundary in the
       70*	    middle of the display (unpaginated reports only).
       71*
       72*	(3) Read a key sequence which tells us what to do next.
       73*
       74*	(4) Perform the function the user has requested (e.g. forward).
       75*
       76*	(5) Repeat 2 through 4 if we're still in the current page or buffer.
       77*	    Return to caller if we're outside of it, or if we crossed a
       78*	    buffer boundary during the display.
       79*
       80**/



       81 
       82 	scroll_ip = scroll_info_ptr_parm;
       83 	code_parm = 0;
       84 	call housekeeping;
       85 	call scroll_the_report;
       86 	code_parm = code;

       87 
       88 	return;
       89 
       90 set_fkey: entry (
       91 
       92 	scroll_info_ptr_parm,	/* input: ptr to the scroll_info strucure */
       93 	function_name_parm,		/* input: function to set the key to */
       94 	function_key_sequence_parm,	/* input: the key sequence */
       95 	code_parm			/* output: success or failure */
       96 	     );



       97 
       98 /*
       99*
      100*	Mainline Processing Overview
      101*
      102*	(1) Translate any mnemonic key sequences into the characters
      103*	    the terminal generates ("escape-", "esc-", "control-" and
      104*	    "ctl-" are translated).
      105*
      106*	(2) Translate key sequences given as mnemonics into the characters
      107*	    the terminal generates (i.e. translate "up_arrow" into whatever
      108*	    the particular terminal generates when the up arrow is pressed).
      109*
      110*	(3) Assign the translated key sequence to the table entry for that
      111*	    particular function.
      112*
      113**/



      114 
      115 	scroll_ip = scroll_info_ptr_parm;
      116 	function_key_data_ptr = scroll_info.function_key_data_pointer;
      117 	function_name = function_name_parm;
      118 	function_key_sequence = function_key_sequence_parm;
      119 	call set_function_key (function_name, function_key_sequence, code);
      120 	code_parm = code;

      121 
      122 	return;
      123 
      124 start: entry (
      125 
      126 	sci_ptr_parm,		/* input: ptr to the subsystem control info structure */
      127 	rci_ptr_parm,		/* input: ptr to the report_control_info structure */
      128 	display_arg_results_ptr_parm,	/* input: ptr to the display_arg_results structure */
      129 	work_area_ptr_parm		/* input: ptr to a work area */
      130 	  );



      131 
      132 /*
      133*
      134*	Mainline Processing Overview
      135*
      136*	(1) Allocate various structures needed for the video system.
      137*
      138*	(2) Turn on the video system if it's not already on.
      139*
      140*	(3) If window was specified by the user check it out to make sure it 
      141*	    meets the requirements. If window wasn't  specified, then set
      142*	    one up and shrink user_i/o.
      143*
      144*	(4) Setup the format_document_options structure for filling of help
      145*	    strings to the window width.
      146*
      147**/



      148 
      149 	sci_ptr = sci_ptr_parm;
      150 	report_cip = rci_ptr_parm;
      151 	display_results_ptr = display_arg_results_ptr_parm;
      152 	work_area_ptr = work_area_ptr_parm;
      153 	call setup_scroll;

      154 
      155 	return;
      156 
      157 stop: entry (
      158 
      159 	scroll_info_ptr_parm	/* input: ptr to the scroll_info structure */
      160 	 );



      161 
      162 /*
      163*
      164*	Mainline Processing Overview
      165*
      166*	(1) If window wasn't specified by the user then destroy the
      167*	    window we created and put back user_i/o to the same state
      168*	    as we found it.
      169*
      170*	(2) Turn off the video system if we turned it on.
      171*
      172**/



      173 
      174 	if scroll_info_ptr_parm = null ()
      175 	then return;
      176 	scroll_ip = scroll_info_ptr_parm;
      177 	call housekeeping;
      178 	call terminate_scroll;

      179 
      180 	return;
      181 
      182 abort_line: proc (
      183 
      184 	code_parm,	/* input: the code that caused the error */
      185 	message_parm	/* input: additional information */
      186 	       );

      187 
      188 dcl code_parm fixed bin (35) parm;
      189 dcl message_parm_length fixed bin;
      190 dcl message_parm char (*) parm;



      191 
      192 	if code_parm ^= 0
      193 	then do;
      194 	     call convert_status_code_ (code_parm, short_message, long_message);
      195 	     error_message = "^/" || rtrim (long_message);
      196 	end;
      197 	else error_message = "";

      198 
      199 	message_parm_length = length (rtrim (message_parm));
      200 	if message_parm_length > 0
      201 	then error_message = error_message || "^/" || rtrim (message_parm);

      202 
      203 	call ssu_$abort_line (sci_ptr, rw_error_$bad_report_display, error_message);

      204 
      205      end abort_line;
      206 
      207 check_code: proc;



      208 
      209 /*
      210*
      211*	It is only valid to call this proc if the entrypoint "continue" 
      212*	was called. This proc takes care of the details of hiding the
      213*	"window_status_pending" error code returned by any of the many,
      214*	many different window_ entrypoints this subroutine calls. When this
      215*	ugly error code is returned there is not enough information that
      216*	can be gotten to do anything reasonable. For example, if we could
      217*	determine from the video system where in the window the asyncronous
      218*	output was written to, we could at least write around it or prompt
      219*	the user to see if she has read it. But there isn't anything like
      220*	that. Instead we get two bits, saying if there was asyncronous
      221*	output or that the screen is invalid. This proc does a 
      222*	get_window_status control order, returns to rw_display, who 
      223*	immediately calls back here, resulting in a redisplay of the window.
      224*	Invalid screens are the only thing we get in the default case, so 
      225*	this is always the correct action. In the case of the experienced
      226*	user who has set up her own windows, if she has missed a message
      227*	through this redisplay she can see them again with the multics_mode
      228*	function or set up her windows more intelligently next time.
      229*
      230**/

      231 
      232 	if code = 0
      233 	then return;

      234 
      235 	if code = video_et_$window_status_pending
      236 	then call iox_$control (window_iocb_ptr, "get_window_status",
      237 	     window_status_info_ptr, code);

      238 
      239 	code_parm = code;
      240 	goto RETURN_TO_CALLING_PROGRAM;

      241 
      242      end check_code;
      243 
      244 display_chunk_of_page: proc;

      245 
      246 dcl dcop_buffer_empty_pending bit (1) aligned;
      247 dcl dcop_current_line_on_page fixed bin;
      248 dcl dcop_current_line_on_screen fixed bin;
      249 dcl dcop_number_of_chars_to_write fixed bin;
      250 dcl dcop_loop fixed bin;
      251 dcl dcop_loop_limit fixed bin;
      252 dcl display_buffer_empty condition;

      253 
      254 	dcop_buffer_empty_pending = OFF;
      255 	call window_$clear_window (window_iocb_ptr, code);
      256 	call check_code;

      257 
      258 	/* Set the width so we don't exceed the portion of the page left or the window width. */

      259 
      260 	if page_info.width - 1 <= report_output_window_position_info.width
      261 	then;
      262 	else if scroll_info.left_vertical_position + report_output_window_position_info.width > page_info.width
      263 	     then scroll_info.left_vertical_position = page_info.width - report_output_window_position_info.width;
      264 	dcop_number_of_chars_to_write = min (page_info.width - scroll_info.left_vertical_position,
      265 	     report_output_window_position_info.width);

      266 
      267 	/* target_line_number can be less than 1 or greater than the page length. Adjust accordingly. */

      268 
      269 	if scroll_info.target_line_number < 1
      270 	then scroll_info.target_line_number = 1;
      271 	else if report_control_info.flags.report_is_paginated
      272 	     then if scroll_info.target_line_number > page_info.length
      273 	          then scroll_info.target_line_number
      274 	               = max (1, page_info.length - scroll_info.vertical_scroll_distance);
      275 	          else;
      276 	     else;

      277 
      278 	/* Simulate the line printer software's 3 blank lines if appropriate. */

      279 
      280 	if scroll_info.target_line_number = 1
      281 	& (report_control_info.flags.report_is_paginated	| scroll_info.target_page_number = 1)
      282 	then scroll_info.top_margin_offset = 3;
      283 	else scroll_info.top_margin_offset = 0;

      284 
      285 	/* Set limits, prepare to hit a buffer boundary for unpaginated reports in the middle of the display. */

      286 
      287 	dcop_current_line_on_page = scroll_info.target_line_number;
      288 	dcop_current_line_on_screen = scroll_info.top_margin_offset + 1;
      289 	dcop_loop_limit = min (
      290 	     report_output_window_position_info.height - dcop_current_line_on_screen + 1,
      291 	     page_info.length - dcop_current_line_on_page + 1);

      292 
      293 	if ^report_control_info.flags.report_is_paginated
      294 	then if (page_info.length - dcop_current_line_on_page + 1 
      295 	     < report_output_window_position_info.height - dcop_current_line_on_screen + 1)
      296 	     & (^report_control_info.flags.report_is_formatted
      297 	     | (report_control_info.flags.report_is_formatted
      298 	     & scroll_info.target_page_number ^= report_control_info.no_of_formatted_pages))
      299 	     then do;
      300 		dcop_loop_limit = report_output_window_position_info.height - dcop_current_line_on_screen + 1;
      301 		dcop_buffer_empty_pending = ON;
      302 	     end;
      303 	     else;
      304 	else;

      305 
      306 	/* Do the display, don't bother to write blank lines. */

      307 
      308 	do dcop_loop = 1 to dcop_loop_limit;
      309 	     call window_$position_cursor (window_iocb_ptr, dcop_current_line_on_screen, 1, code);
      310 	     call check_code;
      311 	     if substr (page_defined_as_lines (dcop_current_line_on_page),
      312 	     scroll_info.left_vertical_position, dcop_number_of_chars_to_write) = BLANK
      313 	     then;
      314 	     else do;
      315 		call window_$overwrite_text (window_iocb_ptr,
      316 		     substr (page_defined_as_lines (dcop_current_line_on_page),
      317 		     scroll_info.left_vertical_position, dcop_number_of_chars_to_write), code);
      318 		call check_code;
      319 	     end;
      320 	     dcop_current_line_on_screen = dcop_current_line_on_screen + 1;
      321 	     dcop_current_line_on_page = dcop_current_line_on_page + 1;
      322 	     if dcop_buffer_empty_pending
      323 	     then if dcop_current_line_on_page > page_info.length
      324 		then do;
      325 		     scroll_info.target_page_number = scroll_info.target_page_number + 1;
      326 		     scroll_info.last_line_number_in_previous_buffer = page_info.length;
      327 		     signal display_buffer_empty;
      328 		     scroll_info.flags.buffer_boundary_just_crossed = ON;
      329 		     scroll_info.target_page_number = scroll_info.target_page_number - 1;
      330 		     dcop_current_line_on_page = 1;
      331 		     page_ip = scroll_info.page_info_pointer;
      332 		end;
      333 		else;
      334 	     else;
      335 	end;

      336 
      337 	/* Position cursor to bottom right hand side of window. */

      338 
      339 	call window_$position_cursor (window_iocb_ptr,
      340 	     report_output_window_position_info.height,
      341 	     report_output_window_position_info.width, code);
      342 	call check_code;

      343 
      344 	return;

      345 
      346      end display_chunk_of_page;
      347 
      348 get_users_response: proc (gur_buffer_parm);

      349 
      350 dcl gur_buffer_parm char (*) parm;
      351 dcl gur_character_read char (1) varying;
      352 dcl gur_loop fixed bin;
      353 dcl gur_partial_match bit (1) aligned;

      354 
      355 	/* Keep reading characters until we get a match, get a mis-match, or fill the buffer. */

      356 
      357 	gur_buffer_parm = "";
      358 	gur_partial_match = ON;

      359 
      360 	do gur_loop = 1 to length (gur_buffer_parm)
      361 	     while (gur_partial_match);
      362 	     call window_$get_one_unechoed_char (window_iocb_ptr, gur_character_read, ON, code);
      363 	     call check_code;
      364 	     substr (gur_buffer_parm, gur_loop, 1) = gur_character_read;
      365 	     if (gur_buffer_parm = scroll_info.keys.forward)
      366 	     | (gur_buffer_parm = scroll_info.keys.backward)
      367 	     | (gur_buffer_parm = scroll_info.keys.left)
      368 	     | (gur_buffer_parm = scroll_info.keys.right)
      369 	     | (gur_buffer_parm = scroll_info.keys.help)
      370 	     | (gur_buffer_parm = scroll_info.keys.set_key)
      371 	     | (gur_buffer_parm = scroll_info.keys.set_scroll_increment)
      372 	     | (gur_buffer_parm = scroll_info.keys.quit)
      373 	     | (gur_buffer_parm = scroll_info.keys.redisplay)
      374 	     | (gur_buffer_parm = scroll_info.keys.start_of_report)
      375 	     | (gur_buffer_parm = scroll_info.keys.end_of_report)
      376 	     | (gur_buffer_parm = scroll_info.keys.multics_mode)
      377 	     | (gur_buffer_parm = scroll_info.keys.goto)
      378 	     then return;
      379 	     gur_partial_match
      380 		= (substr (gur_buffer_parm, 1, gur_loop) = substr (scroll_info.keys.forward, 1, gur_loop))
      381 		| (substr (gur_buffer_parm, 1, gur_loop) = substr (scroll_info.keys.backward, 1, gur_loop))
      382 		| (substr (gur_buffer_parm, 1, gur_loop) = substr (scroll_info.keys.left, 1, gur_loop))
      383 		| (substr (gur_buffer_parm, 1, gur_loop) = substr (scroll_info.keys.right, 1, gur_loop))
      384 		| (substr (gur_buffer_parm, 1, gur_loop) = substr (scroll_info.keys.help, 1, gur_loop))
      385 		| (substr (gur_buffer_parm, 1, gur_loop) = substr (scroll_info.keys.set_key, 1, gur_loop))
      386 		| (substr (gur_buffer_parm, 1, gur_loop) = substr (scroll_info.keys.set_scroll_increment, 1, gur_loop))
      387 		| (substr (gur_buffer_parm, 1, gur_loop) = substr (scroll_info.keys.quit, 1, gur_loop))
      388 		| (substr (gur_buffer_parm, 1, gur_loop) = substr (scroll_info.keys.redisplay, 1, gur_loop))
      389 		| (substr (gur_buffer_parm, 1, gur_loop) = substr (scroll_info.keys.start_of_report, 1, gur_loop))
      390 		| (substr (gur_buffer_parm, 1, gur_loop) = substr (scroll_info.keys.end_of_report, 1, gur_loop))
      391 		| (substr (gur_buffer_parm, 1, gur_loop) = substr (scroll_info.keys.multics_mode, 1, gur_loop))
      392 		| (substr (gur_buffer_parm, 1, gur_loop) = substr (scroll_info.keys.goto, 1, gur_loop));
      393 	end;

      394 
      395 	return;

      396 
      397      end get_users_response;
      398 
      399 housekeeping: proc;



      400 
      401 	/* Move the pointers for our needed structures. */

      402 
      403 	display_results_ptr = scroll_info.display_arg_results_ptr;
      404 	report_cip = scroll_info.report_control_info_ptr;
      405 	work_area_ptr = scroll_info.area_ptr;
      406 	user_io_window_position_ip = scroll_info.user_io_window_position_info_ptr;
      407 	report_output_window_position_ip = scroll_info.report_output_window_position_info_ptr;
      408 	sci_ptr = scroll_info.ssu_info_ptr;
      409 	window_iocb_ptr = report_control_info.display_iocb_ptr;
      410 	page_ip = scroll_info.page_info_pointer;
      411 	window_status_info_ptr = scroll_info.window_status_info_pointer;
      412 	function_key_data_ptr = scroll_info.function_key_data_pointer;
      413 	format_document_options_ptr = scroll_info.format_document_op;

      414 
      415 	return;

      416 
      417      end housekeeping;
      418 
      419 prompt_for_more: proc (
      420 
      421 	pfm_line_in_window_parm,	/* input: where to write the prompt */
      422 	pfm_user_wants_more_parm	/* output: on if user wants more */
      423 		  );



      424 
      425 dcl pfm_break_character char (1) varying;
      426 dcl pfm_buffer char (1);
      427 dcl pfm_line_in_window_parm fixed bin parm;
      428 dcl pfm_number_of_chars_read fixed bin (21);
      429 dcl pfm_still_looking_for_a_valid_response bit (1) aligned;
      430 dcl pfm_user_wants_more_parm bit (1) aligned parm;

      431 
      432 	/* Write the more prompt on caller designated line. Accept CR and DEL and mark parm accordingly. */

      433 
      434 	pfm_still_looking_for_a_valid_response = ON;

      435 
      436 	do while (pfm_still_looking_for_a_valid_response);
      437 	     pfm_still_looking_for_a_valid_response = OFF;
      438 	     call window_$position_cursor (window_iocb_ptr, pfm_line_in_window_parm, 1, code);
      439 	     call check_code;
      440 	     call window_$clear_to_end_of_line (window_iocb_ptr, code);
      441 	     call check_code;
      442 	     call window_$write_sync_read (window_iocb_ptr, MORE_PROMPT, 1,
      443 		pfm_buffer, pfm_number_of_chars_read, pfm_break_character, code);
      444 	     call check_code;
      445 	     if pfm_number_of_chars_read = 0
      446 	     then if pfm_break_character = CARRIAGE_RETURN
      447 		then pfm_user_wants_more_parm = ON;
      448 	          else if pfm_break_character = DEL
      449 		     then pfm_user_wants_more_parm = OFF;
      450 		     else pfm_still_looking_for_a_valid_response = ON;
      451 	     else pfm_still_looking_for_a_valid_response = ON;
      452 	     if pfm_still_looking_for_a_valid_response
      453 	     then do;
      454 		call window_$bell (window_iocb_ptr, code);
      455 		call check_code;
      456 	     end;
      457 	end;

      458 
      459 	return;

      460 
      461      end prompt_for_more;
      462 
      463 prompt_user: proc (
      464 
      465 	pu_prompt_parm,	/* input: the prompt */
      466 	pu_number_parm,	/* output: the numeric response, or, */
      467 	pu_response_parm,	/* output: the character response */
      468           pu_numeric_parm	/* input: if on a numeric response is required */
      469 	        );

      470 
      471 dcl pu_number_of_chars_read fixed bin (21);
      472 dcl pu_number_parm fixed bin (35) parm;
      473 dcl pu_numeric_parm bit (1) aligned parm;
      474 dcl pu_prompt_parm char (*) parm;
      475 dcl pu_response_buffer char (256);
      476 dcl pu_response_line fixed bin;
      477 dcl pu_response_parm char (*) parm;
      478 dcl pu_still_looking_for_a_valid_response bit (1) aligned;
      479 dcl pu_window_status_pending condition;
      480 dcl pu_window_status_pending_flag bit (1) aligned;



      481 
      482 /*
      483*	Prompt the user with the supplied prompt in the last line of the 
      484*	window. Accept a numeric or character response depending on the
      485*	setting of pu_numeric_parm. Keep prompting until we get a valid
      486*	response. If we get a window_status_pending then re-write prompt
      487*	on the first line of the window after doing a get_window_status
      488*	control order. Use the iox_ entry point rather than a window_
      489*	entrypoint because the window_ system still doesn't have an
      490*	equivalent. Note that the horrid window_status_pending never
      491*	comes back from the iox_ entrypoint.
      492**/

      493 
      494 	pu_window_status_pending_flag = OFF;

      495 
      496 	on pu_window_status_pending begin;
      497 	     pu_window_status_pending_flag = ON;
      498 	     pu_response_line = 1;	     
      499 	     call write_prompt;
      500 	end;

      501 
      502 	pu_number_parm = 0;
      503 	pu_response_parm = "";
      504 	pu_still_looking_for_a_valid_response = ON;
      505 	pu_response_line = report_output_window_position_info.height;
      506 
      507 	do while (pu_still_looking_for_a_valid_response);
      508 	     call write_prompt;
      509 	     call iox_$get_line (window_iocb_ptr, addr (pu_response_buffer),
      510 		length (pu_response_buffer), pu_number_of_chars_read, code);
      511 	     if code ^= 0
      512 	     then if code = error_table_$long_record
      513 		then;
      514 	          else call abort_line (code, "Unable to read prompt response.");
      515 	     else do;
      516 		pu_number_of_chars_read = pu_number_of_chars_read - 1;
      517 		if pu_numeric_parm
      518 		then if pu_number_of_chars_read > 0 & pu_number_of_chars_read < 10
      519 		     then pu_still_looking_for_a_valid_response
      520 			= (verify (substr (pu_response_buffer, 1, pu_number_of_chars_read), DIGITS) ^= 0);
      521 		     else;
      522 		else pu_still_looking_for_a_valid_response = OFF;
      523 	     end;
      524 	     if pu_still_looking_for_a_valid_response
      525 	     then do;
      526 		call window_$bell (window_iocb_ptr, code);
      527 		if code ^= 0
      528 		then signal pu_window_status_pending;
      529 		else;
      530 	     end;
      531 	end;

      532 
      533 	if pu_numeric_parm
      534 	then pu_number_parm = convert (pu_number_parm,
      535 	     substr (pu_response_buffer, 1, pu_number_of_chars_read));
      536 	else pu_response_parm = substr (pu_response_buffer, 1, pu_number_of_chars_read);

      537 
      538 	return;
      539 
      540 write_prompt: proc;



      541 
      542 	/* Repeat the sequence until we correctly write the prompt. */

      543 
      544 	if pu_window_status_pending_flag
      545 	then do;
      546 	     call iox_$control (window_iocb_ptr, "get_window_status",
      547 		window_status_info_ptr, code);
      548 	     if code ^= 0
      549 	     then call abort_line (code, "Unable to peform a get_window_status control order.");
      550 	     pu_window_status_pending_flag = OFF;
      551 	end;

      552 
      553 	call window_$position_cursor (window_iocb_ptr, pu_response_line, 1, code);
      554 	call window_$clear_to_end_of_line (window_iocb_ptr, code);
      555 	call window_$overwrite_text (window_iocb_ptr,
      556 	     rtrim (pu_prompt_parm) || " (end with RETURN) ->", code);

      557 
      558 	if code ^= 0
      559 	then if code = video_et_$window_status_pending
      560 	     then signal pu_window_status_pending;
      561 	     else call abort_line (code, "Unable to write the prompt.");
      562 	else;

      563 
      564 	return;

      565 
      566      end write_prompt;

      567 
      568      end prompt_user;
      569 
      570 scroll_the_report: proc;



      571 
      572 /*
      573*	Display a chunk of the page or buffer. Perform the scrolling
      574*	function requested by the user. Return to the caller if we're
      575*	outside of the current page, or if we just crossed a buffer boundary.
      576**/

      577 
      578 	still_in_the_scrolling_business = ON;

      579 
      580 	do while (still_in_the_scrolling_business);
      581 	     call display_chunk_of_page;
      582 	     call setup_for_next_chunk;
      583 	end;

      584 
      585           return;

      586 
      587      end scroll_the_report;
      588 
      589 set_function_key: proc (
      590 
      591 	sfk_function_name_parm,	  /* input: function to set key to */
      592 	sfk_function_key_sequence_parm, /* input: key sequence to set */
      593 	sfk_code_parm		  /* output: success or failure */
      594 		   );



      595 
      596 dcl sfk_char_10 char (10);
      597 dcl sfk_character_loop char (length (CONTROL_HYPHEN));
      598 dcl sfk_code_parm fixed bin (35) parm;
      599 dcl sfk_function_name_parm char (*) parm;
      600 dcl sfk_function_key_sequence_parm char (*) parm;
      601 dcl sfk_function_key_sequence char (32);
      602 dcl sfk_function_key_sequence_buffer char (32);
      603 dcl sfk_loop fixed bin;
      604 dcl sfk_no_match bit (1) aligned;



      605 
      606 /*
      607*	Translate "escape-", "esc-", "control-X", "ctl-X", to the sequence
      608*	the terminal generates, where X is the character following the
      609*	"control-" or "ctl-" mnemonic. Next translate any of the recognized
      610*	mnemonics in the provided key sequence to what the terminal generates
      611*	(i.e. translate "down_arrow" into whatever the terminal generates).
      612*	Look up the supplied scrolling function name and assign the key
      613*	sequence to the slot in the table. Assign the mnemonic key sequence
      614*	to the slot in another table for it's display when help is invoked.
      615**/

      616 
      617 	sfk_code_parm = 0;
      618 	if index (sfk_function_key_sequence_parm, ESCAPE_HYPHEN) = 0
      619 	&  index (sfk_function_key_sequence_parm, ESC_HYPHEN) = 0
      620 	&  index (sfk_function_key_sequence_parm, CONTROL_HYPHEN) = 0
      621 	&  index (sfk_function_key_sequence_parm, CTL_HYPHEN) = 0
      622 	then sfk_function_key_sequence = sfk_function_key_sequence_parm;
      623 	else do;
      624 	     sfk_function_key_sequence = sfk_function_key_sequence_parm;
      625 	     do sfk_character_loop = ESCAPE_HYPHEN, ESC_HYPHEN, CONTROL_HYPHEN, CTL_HYPHEN;
      626 		call translate_mnemonics (sfk_function_key_sequence,
      627 		     sfk_character_loop, sfk_function_key_sequence_buffer, sfk_code_parm);
      628 		if sfk_code_parm ^= 0
      629 		then return;
      630 		sfk_function_key_sequence = sfk_function_key_sequence_buffer;
      631 	     end;
      632 	end;
      633 
      634 	if sfk_function_key_sequence = KEY_MNEMONICS.FORWARD
      635 	then sfk_function_key_sequence = substr (function_key_seqs,
      636 	     function_key_data.cursor_motion_keys.down (KEY_PLAIN).sequence_index,
      637 	     function_key_data.cursor_motion_keys.down (KEY_PLAIN).sequence_length);
      638 	else if sfk_function_key_sequence = KEY_MNEMONICS.BACKWARD
      639 	then sfk_function_key_sequence = substr (function_key_seqs,
      640 	     function_key_data.cursor_motion_keys.up (KEY_PLAIN).sequence_index,
      641 	     function_key_data.cursor_motion_keys.up (KEY_PLAIN).sequence_length);
      642 	else if sfk_function_key_sequence = KEY_MNEMONICS.LEFT
      643 	then sfk_function_key_sequence = substr (function_key_seqs,
      644 	     function_key_data.cursor_motion_keys.left (KEY_PLAIN).sequence_index,
      645 	     function_key_data.cursor_motion_keys.left (KEY_PLAIN).sequence_length);
      646 	else if sfk_function_key_sequence = KEY_MNEMONICS.RIGHT
      647 	then sfk_function_key_sequence = substr (function_key_seqs,
      648 	     function_key_data.cursor_motion_keys.right (KEY_PLAIN).sequence_index,
      649 	     function_key_data.cursor_motion_keys.right (KEY_PLAIN).sequence_length);
      650 	else if sfk_function_key_sequence = HOME
      651 	then sfk_function_key_sequence = substr (function_key_seqs,
      652 	     function_key_data.cursor_motion_keys.home (KEY_PLAIN).sequence_index,
      653 	     function_key_data.cursor_motion_keys.home (KEY_PLAIN).sequence_length);
      654 	else do;
      655 	     sfk_no_match = ON;
      656 	     do sfk_loop = 0 to hbound (function_key_data.function_keys, 1)
      657 		while (sfk_no_match);
      658 		if sfk_function_key_sequence
      659 		= "f" || ltrim (convert (sfk_char_10, sfk_loop))
      660 		then do;
      661 		     sfk_function_key_sequence = substr (function_key_seqs,
      662 			function_key_data.function_keys (sfk_loop, KEY_PLAIN).sequence_index,
      663 			function_key_data.function_keys (sfk_loop, KEY_PLAIN).sequence_length);
      664 		     sfk_no_match = OFF;
      665 		end;
      666 	     end;
      667 	end;

      668 
      669 	do sfk_loop = 1 to HIGHEST_DISPLAY_FUNCTION_NUMBER;
      670 	     if sfk_function_name_parm = FUNCTION_NAMES_AS_A_TABLE (sfk_loop)
      671 	     then do;
      672 		keys_as_a_table (sfk_loop) = sfk_function_key_sequence;
      673 		mnemonic_key_sequences_as_a_table (sfk_loop)
      674 		     = sfk_function_key_sequence_parm;
      675 		return;
      676 	     end;
      677 	end;

      678 
      679 	sfk_code_parm = rw_error_$bad_fkey_name;

      680 
      681 	return;
      682 
      683 translate_mnemonics: proc (
      684 
      685 	tm_string_in_parm,	/* input: string to be translated */
      686 	tm_mnemonic_parm,   /* input: the mnemonic to be translated */
      687 	tm_string_out_parm, /* output: the translated string */
      688 	tm_code_parm	/* output: success or failure */
      689 		      );

      690 
      691 dcl tm_code_parm fixed bin (35) parm;
      692 dcl tm_current_position fixed bin;
      693 dcl tm_escape_is_replacement_char bit (1) aligned;
      694 dcl tm_mnemonic_length fixed bin;
      695 dcl tm_mnemonic char (32) varying;
      696 dcl tm_mnemonic_parm char (*) parm;
      697 dcl tm_still_translating bit (1) aligned;
      698 dcl tm_string_in_parm char (*) parm;
      699 dcl tm_string_index fixed bin;
      700 dcl tm_string_length fixed bin;
      701 dcl tm_string_out_parm char (*) parm;
      702 dcl tm_string_varying char (32) varying;
      703 dcl tm_target_character_index fixed bin;
      704 dcl tm_translation_index fixed bin;



      705 
      706 /*
      707*	Translate "escape-", "esc-", "control-X", and "ctl-X" into the
      708*	sequence the terminal generates. The "control-" or "ctl-"
      709*	mnemonic has to be followed by another character, as a terminal
      710*	can't generate control without pressing some other key.
      711**/

      712 
      713 	tm_code_parm = 0;
      714 	tm_mnemonic = rtrim (tm_mnemonic_parm);

      715 
      716 	if index (tm_string_in_parm, tm_mnemonic) = 0
      717 	then do;
      718 	     tm_string_out_parm = tm_string_in_parm;
      719 	     return;
      720 	end;

      721 
      722 	tm_mnemonic_length = length (tm_mnemonic);
      723 	tm_escape_is_replacement_char = (tm_mnemonic = ESCAPE_HYPHEN | tm_mnemonic = ESC_HYPHEN);
      724 	tm_string_varying = "";
      725 	tm_still_translating = ON;
      726 	tm_string_length = length (rtrim (tm_string_in_parm));
      727 	tm_current_position = 1;
      728 
      729 	do while (tm_still_translating);
      730 	     tm_string_index = index (substr (tm_string_in_parm, tm_current_position), tm_mnemonic);
      731 	     if tm_string_index ^= 0
      732 	     then do;
      733 		if tm_current_position < tm_string_index
      734 		then tm_string_varying = tm_string_varying || substr (tm_string_in_parm,
      735 		     tm_current_position, tm_string_index - tm_current_position);
      736 		if tm_escape_is_replacement_char
      737 		then do;
      738 		     tm_string_varying = tm_string_varying || ESCAPE;
      739 		     tm_current_position = tm_current_position + tm_string_index + tm_mnemonic_length - 1;
      740 		end;
      741 		else do;
      742 		     tm_target_character_index = tm_current_position + tm_string_index + tm_mnemonic_length - 1;
      743 		     if tm_target_character_index > tm_string_length
      744 		     then do;
      745 			tm_code_parm = rw_error_$bad_fkey_sequence;
      746 			return;
      747 		     end;
      748 		     tm_translation_index = index (TRANSLATION_TABLE,
      749 			substr (tm_string_in_parm, tm_target_character_index, 1));
      750 		     if tm_translation_index = 0
      751 		     then do;
      752 			tm_code_parm = rw_error_$bad_fkey_sequence;
      753 			return;
      754 		     end;
      755 		     if tm_translation_index > 32
      756 		     then tm_translation_index = tm_translation_index - 32;
      757 		     tm_string_varying = tm_string_varying || byte (tm_translation_index - 1);
      758 		     tm_current_position = tm_target_character_index + 1;
      759 		end;
      760 		if tm_current_position > tm_string_length
      761 		then tm_still_translating = OFF;
      762 	     end;
      763 	     else do;
      764 		if tm_string_length >= tm_current_position
      765 		then tm_string_varying = tm_string_varying
      766 		     || substr (tm_string_in_parm, tm_current_position);
      767 		tm_still_translating = OFF;
      768 	     end;
      769 	end;

      770 
      771 	tm_string_out_parm = tm_string_varying;

      772 
      773 	return;

      774 
      775      end translate_mnemonics;

      776 
      777      end set_function_key;
      778 
      779 setup_for_next_chunk: proc;

      780 
      781 dcl sfnc_function_key_procs (HIGHEST_DISPLAY_FUNCTION_NUMBER) entry init (
      782 	fkp_forward,
      783 	fkp_backward,
      784 	fkp_left,
      785 	fkp_right,
      786 	fkp_help,
      787 	fkp_set_key,
      788 	fkp_set_scroll_increment,
      789 	fkp_quit,
      790 	fkp_redisplay,
      791 	fkp_start_of_report,
      792 	fkp_end_of_report,
      793 	fkp_multics_mode,
      794 	fkp_goto);
      795 dcl sfnc_function_number fixed bin;
      796 dcl sfnc_loop fixed bin;
      797 dcl sfnc_still_looking_for_a_valid_response bit (1) aligned;
      798 dcl sfnc_users_response char (32);

      799 
      800 	/* Get a valid user response for a scroll function. Perform the function. */

      801 
      802 	sfnc_still_looking_for_a_valid_response = ON;

      803 
      804 	do while (sfnc_still_looking_for_a_valid_response);
      805 	     call get_users_response (sfnc_users_response);

      806 
      807 	     do sfnc_loop = 1 to HIGHEST_DISPLAY_FUNCTION_NUMBER
      808 		while (sfnc_still_looking_for_a_valid_response);
      809 		if sfnc_users_response = keys_as_a_table (sfnc_loop)
      810 		then do;
      811 		     sfnc_function_number = sfnc_loop;
      812 		     sfnc_still_looking_for_a_valid_response = OFF;
      813 		end;
      814 	     end;

      815 
      816 	     if ^sfnc_still_looking_for_a_valid_response
      817 	     then call sfnc_function_key_procs (sfnc_function_number);
      818 	     if sfnc_still_looking_for_a_valid_response
      819 	     then do;
      820 		call window_$bell (window_iocb_ptr, code);
      821 		call check_code;
      822 	     end;

      823 
      824 	end;

      825 
      826 	return;
      827 
      828 fkp_backward: proc;

      829 
      830 dcl fb_beginning_line_number fixed bin;



      831 
      832 /*
      833*	Make sure we don't try to go backward if we're at the beginning
      834*	of the report. If we're at the first line of a page then set the
      835*	page number back one and return to rw_display, and set the line
      836*	number very large so display_chunk_of_page can determine what the
      837*	last line of the previous page is once that information is available
      838*	(when we are called again). If we're not on the first line of a page
      839*	then decrement the current line number and return.
      840**/

      841 
      842 	if scroll_info.target_line_number = 1
      843 	then if scroll_info.target_page_number = 1
      844 	     then do;
      845 		sfnc_still_looking_for_a_valid_response = ON;
      846 		return;
      847 	     end;
      848 	     else if report_control_info.flags.report_is_paginated
      849 		then do;
      850 		     scroll_info.target_page_number = scroll_info.target_page_number - 1;
      851 		     scroll_info.target_line_number = 99999;
      852 		     still_in_the_scrolling_business = OFF;
      853 		     return;
      854 		end;
      855 		else;
      856 	else if report_control_info.flags.report_is_paginated
      857 	     then do;
      858 		scroll_info.target_line_number
      859 		     = scroll_info.target_line_number - scroll_info.vertical_scroll_distance;
      860 		return;
      861 	     end;

      862 
      863 /*
      864*	We only make it this far if it's an unpaginated report. If the
      865*	beginning line number is less than 1 then return to rw_display
      866*	so it can get us the previous buffer.
      867**/

      868 
      869 	fb_beginning_line_number
      870 	     = scroll_info.target_line_number - scroll_info.vertical_scroll_distance;
      871 	if fb_beginning_line_number < 1
      872 	then if scroll_info.target_page_number = 1
      873 	     then do;
      874 		scroll_info.target_line_number = 1;
      875 		return;
      876 	     end;
      877 	     else do;
      878 		scroll_info.target_line_number
      879 		     = scroll_info.last_line_number_in_previous_buffer
      880 		     + scroll_info.target_line_number - scroll_info.vertical_scroll_distance;
      881 		still_in_the_scrolling_business = OFF;
      882 		scroll_info.target_page_number = scroll_info.target_page_number - 1;
      883 		return;
      884 	     end;
      885 	else;

      886 
      887 /*
      888*	Return to rw_display to get us the previous buffer if we
      889*	used two buffers for the previous display.
      890**/

      891 
      892 	scroll_info.target_line_number = fb_beginning_line_number;
      893 	if scroll_info.flags.buffer_boundary_just_crossed
      894 	then do;
      895 	     scroll_info.flags.buffer_boundary_just_crossed = OFF;
      896 	     still_in_the_scrolling_business = OFF;
      897 	end;

      898 
      899 	return;

      900 
      901      end fkp_backward;
      902 
      903 fkp_end_of_report: proc;



      904 
      905 /*
      906*	If the report is paginated then set the page number very large. If
      907*	the report is unpaginated then set the goto_line_number_pending
      908*	flag and set the line number very large. Return to rw_display.
      909**/

      910 
      911 	still_in_the_scrolling_business = OFF;

      912 
      913 	if report_control_info.flags.report_is_paginated
      914 	then do;
      915 	     scroll_info.target_page_number = LARGEST_PAGE_NUMBER;
      916 	     scroll_info.target_line_number = 1;
      917 	end;
      918 	else do;
      919 	     scroll_info.flags.goto_line_number_pending = ON;
      920 	     scroll_info.target_line_number = LARGEST_LINE_NUMBER;
      921 	end;

      922 
      923 	return;

      924 
      925      end fkp_end_of_report;
      926 
      927 fkp_forward: proc;

      928 
      929 dcl ff_beginning_line_number fixed bin;
      930 dcl ff_number_of_left_over_lines fixed bin;

      931 
      932 /*
      933*	Handle unpaginated reports first. If we just crossed a buffer
      934*	boundary and the first line to be displayed is in the first
      935*	buffer then return to rw_display so it can get it. Otherwise
      936*	we have just moved to the buffer we currently have.
      937**/

      938 
      939 	if scroll_info.flags.buffer_boundary_just_crossed
      940 	then do;
      941 	     scroll_info.flags.buffer_boundary_just_crossed = OFF;
      942 	     ff_number_of_left_over_lines
      943 		= scroll_info.last_line_number_in_previous_buffer - scroll_info.target_line_number + 1;
      944 	     if ff_number_of_left_over_lines > scroll_info.vertical_scroll_distance
      945 	     then do;
      946 		scroll_info.target_line_number = scroll_info.target_line_number
      947 		     + scroll_info.vertical_scroll_distance;
      948 		still_in_the_scrolling_business = OFF;
      949 		return;
      950 	     end;
      951 	     scroll_info.target_line_number = scroll_info.vertical_scroll_distance - ff_number_of_left_over_lines + 1;
      952 	     scroll_info.target_page_number = scroll_info.target_page_number + 1;
      953 	     return;
      954 	end;

      955 
      956 /*
      957*	This code does paginated reports. Advance line number. Make sure
      958*	we don't move off the end of the report. Return to rw_display
      959*	if we move off the current page.
      960**/

      961 
      962 	ff_beginning_line_number = scroll_info.target_line_number
      963 	     + scroll_info.vertical_scroll_distance - scroll_info.top_margin_offset;
      964 	if ff_beginning_line_number > page_info.length
      965 	then if report_control_info.flags.report_is_formatted
      966 	     & scroll_info.target_page_number = report_control_info.no_of_formatted_pages
      967 	     then sfnc_still_looking_for_a_valid_response = ON;
      968 	     else do;
      969 		scroll_info.target_page_number = scroll_info.target_page_number + 1;
      970 		scroll_info.target_line_number = 1;
      971 		still_in_the_scrolling_business = OFF;
      972 	     end;
      973 	else scroll_info.target_line_number = ff_beginning_line_number;

      974 
      975 	return;

      976 
      977      end fkp_forward;
      978 
      979 fkp_goto: proc;

      980 
      981 dcl fg_prompt char (11);
      982 dcl fg_line_or_page_number fixed bin (35);
      983 dcl fg_still_looking_for_a_valid_response bit (1) aligned;



      984 
      985 /*
      986*	Prompt for page or line number. Accept only a positive integer.
      987*	Return to rw_display to get the page or buffer.
      988**/

      989 
      990 	if report_control_info.flags.report_is_paginated
      991 	then fg_prompt = "Page number";
      992 	else fg_prompt = "Line number";

      993 
      994 	fg_still_looking_for_a_valid_response = ON;
      995 	do while (fg_still_looking_for_a_valid_response);
      996 	     call prompt_user (fg_prompt, fg_line_or_page_number,
      997 		users_response, NUMERIC_RESPONSE);
      998 	     if fg_line_or_page_number ^= 0
      999 	     then do;
     1000 		if report_control_info.flags.report_is_paginated
     1001 		then do;
     1002 		     scroll_info.target_page_number = fg_line_or_page_number;
     1003 		     scroll_info.target_line_number = 1;
     1004 		end;
     1005 		else do;
     1006 		     scroll_info.flags.goto_line_number_pending = ON;
     1007 		     scroll_info.target_line_number = fg_line_or_page_number;
     1008 		end;
     1009 		fg_still_looking_for_a_valid_response = OFF;
     1010 		still_in_the_scrolling_business = OFF;
     1011 	     end;
     1012 	     else do;
     1013 		call window_$bell (window_iocb_ptr, code);
     1014 		call check_code;
     1015 	     end;
     1016 	end;

     1017 
     1018 	return;

     1019 
     1020      end fkp_goto;
     1021 
     1022 fkp_help: proc;



     1023 
     1024 dcl fh_character_read char (1) varying;
     1025 dcl fh_help_string char (1024);
     1026 dcl fh_help_string_length fixed bin (21);
     1027 dcl fh_number_of_chars_read fixed bin (21);
     1028 dcl fh_still_looking_for_a_valid_response bit (1) aligned;
     1029 dcl fh_returned_help_list char (512);
     1030 dcl fh_still_helpful bit (1) aligned;
     1031 dcl fh_users_response char (256);

     1032 
     1033 /*
     1034*	Format and write the general help message. Format and write the
     1035*	mnemonic key sequences and function names list, or, the specific
     1036*	help string for one of the functions. Repeat if user wants more help.
     1037**/

     1038 
     1039 	fh_still_helpful = ON;

     1040 
     1041 	do while (fh_still_helpful);
     1042 	     call format_document_$string (GENERAL_HELP_MESSAGE, fh_help_string,
     1043 		fh_help_string_length, format_document_options_ptr, code);
     1044 	     if code ^= 0
     1045 	     then call abort_line (code, "");
     1046 	     fh_still_looking_for_a_valid_response = ON;

     1047 
     1048 	     do while (fh_still_looking_for_a_valid_response);
     1049 		fh_still_looking_for_a_valid_response = OFF;
     1050 		call write_help_string (NO_PROMPT, fh_character_read);
     1051 		call iox_$get_line (window_iocb_ptr, addr (fh_users_response),
     1052 		     length (fh_users_response), fh_number_of_chars_read, code);
     1053 		if code ^= 0
     1054 		then call abort_line (code, "");
     1055 		if fh_number_of_chars_read ^> 1
     1056 		then fh_still_looking_for_a_valid_response = ON;
     1057 		else do;
     1058 		     fh_number_of_chars_read = fh_number_of_chars_read - 1;
     1059 		     if substr (fh_users_response, 1, fh_number_of_chars_read) = GENERAL_HELP_LIST
     1060 		     then do;
     1061 			call ioa_$rsnnl (GENERAL_HELP_LIST_MESSAGE, fh_help_string,
     1062 			     fh_help_string_length, mnemonic_key_sequences.forward, 
     1063 			     mnemonic_key_sequences.backward, mnemonic_key_sequences.left,
     1064 			     mnemonic_key_sequences.right, mnemonic_key_sequences.help,
     1065 			     mnemonic_key_sequences.set_key, mnemonic_key_sequences.set_scroll_increment,
     1066 			     mnemonic_key_sequences.quit, mnemonic_key_sequences.redisplay,
     1067 			     mnemonic_key_sequences.start_of_report, mnemonic_key_sequences.end_of_report,
     1068 			     mnemonic_key_sequences.multics_mode, mnemonic_key_sequences.goto);
     1069 			call write_help_string (PROMPT, fh_character_read);
     1070 		     end;
     1071 		     else call help_for_function (fh_still_looking_for_a_valid_response);
     1072 		end;
     1073 		if fh_still_looking_for_a_valid_response
     1074 		then do;
     1075 		     call window_$bell (window_iocb_ptr, code);
     1076 		     call check_code;
     1077 		end;
     1078 	     end;

     1079 
     1080 	     if fh_character_read ^= "h"
     1081 	     then fh_still_helpful = OFF;

     1082 
     1083 	end;

     1084 
     1085 	return;
     1086 
     1087 help_for_function: proc (
     1088 
     1089 	hff_invalid_function_parm	/* output: off if it was a valid function */
     1090 		    );

     1091 
     1092 dcl hff_function_number fixed bin;
     1093 dcl hff_invalid_function_parm bit (1) aligned parm;
     1094 dcl hff_loop fixed bin;
     1095 dcl hff_target_function char (32);

     1096 
     1097 /*
     1098*	Find the scroll function by name or mnemonic key sequence. Write
     1099*	the help string for it.
     1100**/

     1101 
     1102 	hff_invalid_function_parm = ON;
     1103 	hff_target_function = substr (fh_users_response, 1, fh_number_of_chars_read);

     1104 
     1105 	do hff_loop = 1 to HIGHEST_DISPLAY_FUNCTION_NUMBER
     1106 	     while (hff_invalid_function_parm);
     1107 	     if hff_target_function = FUNCTION_NAMES_AS_A_TABLE (hff_loop)
     1108 	     | hff_target_function = mnemonic_key_sequences_as_a_table (hff_loop)
     1109 	     then do;
     1110 		hff_invalid_function_parm = OFF;
     1111 		hff_function_number = hff_loop;
     1112 	     end;
     1113 	end;

     1114 
     1115 	if hff_invalid_function_parm
     1116 	then return;

     1117 
     1118 	call ioa_$rsnnl (HELP_HEADER_CONTROL_STRING, fh_returned_help_list,
     1119 	     fh_number_of_chars_read, FUNCTION_NAMES_AS_A_TABLE (hff_function_number),
     1120 	     mnemonic_key_sequences_as_a_table (hff_function_number), HELP_MESSAGES (hff_function_number));
     1121 	call format_document_$string (fh_returned_help_list, fh_help_string,
     1122 	     fh_help_string_length, format_document_options_ptr, code);
     1123 	if code ^= 0
     1124 	then call abort_line (code, "");
     1125 	call write_help_string (PROMPT, fh_character_read);

     1126 
     1127 	return;

     1128 
     1129      end help_for_function;
     1130 
     1131 write_help_string: proc (
     1132 
     1133 	whs_prompt_parm,	/* input: on means prompt to make sure user has seen it */
     1134 	whs_char_read_parm  /* output: the char read if above bit is on */
     1135 		    );

     1136 
     1137 dcl whs_char_read_parm char (1) varying parm;
     1138 dcl whs_current_position fixed bin;
     1139 dcl whs_current_line_on_screen fixed bin;
     1140 dcl whs_new_line_position fixed bin;
     1141 dcl whs_prompt_parm bit (1) aligned parm;
     1142 dcl whs_still_filling bit (1) aligned;
     1143 dcl whs_wants_more bit (1) aligned;

     1144 
     1145 	/* Fill and write the help string with optional prompt. */

     1146 
     1147 	whs_still_filling = ON;
     1148 	whs_current_position = 1;
     1149 	whs_current_line_on_screen = 1;
     1150 	if whs_prompt_parm
     1151 	then do;
     1152 	     substr (fh_help_string, fh_help_string_length + 1) = HOW_TO_END_DISPLAY_MESSAGE;
     1153 	     fh_help_string_length = fh_help_string_length + length (HOW_TO_END_DISPLAY_MESSAGE) + 1;
     1154 	end;
     1155 	else whs_char_read_parm = "";
     1156 	call window_$clear_window (window_iocb_ptr, code);
     1157 	call check_code;

     1158 
     1159 	do while (whs_still_filling);
     1160 	     whs_new_line_position = index (substr (fh_help_string, whs_current_position), NEWLINE);
     1161 	     if whs_new_line_position = 0
     1162 	     then whs_still_filling = OFF;
     1163 	     else do;
     1164 		if whs_current_line_on_screen = report_output_window_position_info.height
     1165 		then do;
     1166 		     call prompt_for_more (whs_current_line_on_screen, whs_wants_more);
     1167 		     if ^whs_wants_more
     1168 		     then do;
     1169 			call fkp_redisplay;
     1170 			return;
     1171 		     end;
     1172 		     else whs_current_line_on_screen = 1;
     1173 		end;
     1174 		call window_$position_cursor (window_iocb_ptr, whs_current_line_on_screen, 1, code);
     1175 		call check_code;
     1176 		call window_$clear_to_end_of_line (window_iocb_ptr, code);
     1177 		call check_code;
     1178 		call window_$overwrite_text (window_iocb_ptr,
     1179 		     substr (fh_help_string, whs_current_position, whs_new_line_position - 1), code);
     1180 		call check_code;
     1181 		whs_current_line_on_screen = whs_current_line_on_screen + 1;
     1182 		whs_current_position = whs_current_position + whs_new_line_position;
     1183 		if whs_current_position > fh_help_string_length
     1184 		then whs_still_filling = OFF;
     1185 	     end;
     1186 	end;

     1187 
     1188 	if whs_prompt_parm
     1189 	then do;
     1190 	     call window_$get_one_unechoed_char (window_iocb_ptr, whs_char_read_parm, ON, code);
     1191 	     call check_code;
     1192 	end;

     1193 
     1194 	return;

     1195 
     1196      end write_help_string;

     1197 
     1198      end fkp_help;
     1199 
     1200 fkp_left: proc;



     1201 
     1202 /*
     1203*	Make sure we don't go left if we're at character position 1. Move
     1204*	left and adjust if we're too far left. If we've used two buffers
     1205*	in the previous display return to rw_display so it can get us
     1206*	back to the first.
     1207**/

     1208 
     1209 	if scroll_info.left_vertical_position = 1
     1210 	then do;
     1211 	     sfnc_still_looking_for_a_valid_response = ON;
     1212 	     return;
     1213 	end;

     1214 
     1215 	scroll_info.left_vertical_position = max (
     1216 	     scroll_info.left_vertical_position - scroll_info.horizontal_scroll_distance, 1);

     1217 
     1218 	if scroll_info.flags.buffer_boundary_just_crossed
     1219 	then do;
     1220 	     still_in_the_scrolling_business = OFF;
     1221 	     scroll_info.flags.buffer_boundary_just_crossed = OFF;
     1222 	end;

     1223 
     1224 	return;

     1225 
     1226      end fkp_left;
     1227 
     1228 fkp_multics_mode: proc;



     1229 
     1230 /*
     1231*	If window is user_i/o then clear it. Write message telling user how
     1232*	to get back to display. Get to Multics level. Do a redisplay.
     1233**/

     1234 
     1235 	if window_iocb_ptr = iox_$user_io | window_iocb_ptr = iox_$user_output
     1236 	then call window_$clear_window (window_iocb_ptr, code);
     1237 	call check_code;
     1238 	call window_$position_cursor (window_iocb_ptr, 1, 1, code);
     1239 	call check_code;
     1240 	call window_$clear_to_end_of_line (window_iocb_ptr, code);
     1241 	call check_code;
     1242 	call window_$overwrite_text (window_iocb_ptr, HOW_TO_GET_BACK_MESSAGE, code);
     1243 	call check_code;
     1244 	if window_iocb_ptr = iox_$user_io | window_iocb_ptr = iox_$user_output
     1245 	then do;
     1246 	     call window_$position_cursor (window_iocb_ptr, 2, 1, code);
     1247 	     call check_code;
     1248 	end;

     1249 
     1250 	unspec (command_level_flags) = OFF;
     1251 	call cu_$cl (command_level_flags);
     1252 	call fkp_redisplay;

     1253 
     1254 	return;

     1255 
     1256      end fkp_multics_mode;
     1257 
     1258 fkp_quit: proc;



     1259 
     1260 	/* Thank you for using this product. Come back y'all. */

     1261 
     1262 	code = error_table_$end_of_info;
     1263 	still_in_the_scrolling_business = OFF;

     1264 
     1265 	return;

     1266 
     1267      end fkp_quit;
     1268 
     1269 fkp_redisplay: proc;



     1270 
     1271 	/* This is all it takes to get a redisplay. Pretty simple huh? */

     1272 
     1273 	still_in_the_scrolling_business = OFF;

     1274 
     1275 	return;

     1276 
     1277      end fkp_redisplay;
     1278 
     1279 fkp_right: proc;



     1280 
     1281 /*
     1282*	Make sure we son't go too far right. If we used two buffers during 
     1283*	the last display then return to rw_display so it can get us
     1284*	back the first one.
     1285**/

     1286 
     1287 	if scroll_info.left_vertical_position + report_output_window_position_info.width >= page_info.width
     1288 	then do;
     1289 	     sfnc_still_looking_for_a_valid_response = ON;
     1290 	     return;
     1291 	end;

     1292 
     1293 	scroll_info.left_vertical_position
     1294 	     = scroll_info.left_vertical_position + scroll_info.horizontal_scroll_distance;

     1295 
     1296 	if scroll_info.flags.buffer_boundary_just_crossed
     1297 	then do;
     1298 	     still_in_the_scrolling_business = OFF;
     1299 	     scroll_info.flags.buffer_boundary_just_crossed = OFF;
     1300 	end;

     1301 
     1302 	return;

     1303 
     1304      end fkp_right;
     1305 
     1306 fkp_set_key: proc;



     1307 
     1308 dcl fkp_valid_response bit (1) aligned;
     1309 dcl fkp_prompt char (21);

     1310 
     1311 /*
     1312*	Prompt for function name and mnemonic key sequence. Assign the
     1313*	key sequence to the function.
     1314**/

     1315 
     1316 	fkp_prompt = "Function name";
     1317 	fkp_valid_response = OFF;

     1318 
     1319 	do while (^fkp_valid_response);
     1320 	     call prompt_user (fkp_prompt, 0, users_response, NON_NUMERIC_RESPONSE);
     1321 	     function_name = users_response;
     1322 	     fkp_valid_response = valid_function_name (function_name);
     1323 	     if ^fkp_valid_response
     1324 	     then call window_$bell (window_iocb_ptr, code);
     1325 	     call check_code;
     1326 	end;

     1327 
     1328 	fkp_prompt = "Mnemonic key sequence";
     1329 	fkp_valid_response = OFF;

     1330 
     1331 	do while (^fkp_valid_response);
     1332 	     call prompt_user (fkp_prompt, 0,
     1333 		users_response, NON_NUMERIC_RESPONSE);
     1334 	     call set_function_key (function_name, users_response, code);
     1335 	     fkp_valid_response = (code = 0);
     1336 	     if ^fkp_valid_response
     1337 	     then call window_$bell (window_iocb_ptr, code);
     1338 	     call check_code;
     1339 	end;

     1340 
     1341 	return;

     1342 
     1343      end fkp_set_key;
     1344 
     1345 fkp_set_scroll_increment: proc;



     1346 
     1347 	call set_scroll_height_or_width;

     1348 
     1349 	return;

     1350 
     1351      end fkp_set_scroll_increment;
     1352 
     1353 fkp_start_of_report: proc;



     1354 
     1355 	/* Return to rw_display so it can get us page 1 or buffer 1. */

     1356 
     1357 	still_in_the_scrolling_business = OFF;
     1358 	scroll_info.target_page_number = 1;
     1359 	scroll_info.target_line_number = 1;

     1360 
     1361 	return;

     1362 
     1363      end fkp_start_of_report;
     1364 
     1365 set_scroll_height_or_width: proc;

     1366 
     1367 dcl sshow_height bit (1) aligned;
     1368 dcl sshow_prompt char (42);
     1369 dcl sshow_scroll_height_or_width fixed bin (35);
     1370 dcl sshow_still_looking_for_a_valid_response bit (1) aligned;

     1371 
     1372 	/* Set the scroll increment for height or width. */

     1373 
     1374 	sshow_prompt = """h"" for height, anything else for width";
     1375 	call prompt_user (sshow_prompt, sshow_scroll_height_or_width,
     1376 	     users_response, NON_NUMERIC_RESPONSE);
     1377 	sshow_height = (users_response = "h");
     1378 	if sshow_height
     1379 	then sshow_prompt = "New scroll height";
     1380 	else sshow_prompt = "New scroll width";

     1381 
     1382 	sshow_still_looking_for_a_valid_response = ON;

     1383 
     1384 	do while (sshow_still_looking_for_a_valid_response);
     1385 	     sshow_still_looking_for_a_valid_response = OFF;
     1386 	     call prompt_user (sshow_prompt, sshow_scroll_height_or_width,
     1387 		users_response, NUMERIC_RESPONSE);
     1388 	     if sshow_height
     1389 	     then if sshow_scroll_height_or_width > page_info.length
     1390 		| sshow_scroll_height_or_width < TOP_MARGIN_HEIGHT
     1391 		then sshow_still_looking_for_a_valid_response = ON;
     1392 	          else;
     1393 	     else if sshow_scroll_height_or_width > page_info.width
     1394 		then sshow_still_looking_for_a_valid_response = ON;
     1395 	          else;
     1396 	     if ^sshow_still_looking_for_a_valid_response
     1397 	     then if sshow_height
     1398 		then scroll_info.vertical_scroll_distance = sshow_scroll_height_or_width;
     1399 	          else scroll_info.horizontal_scroll_distance = sshow_scroll_height_or_width;
     1400 	     else;
     1401 	     if ^sshow_still_looking_for_a_valid_response
     1402 	     then call fkp_redisplay;
     1403 	     else do;
     1404 		call window_$bell (window_iocb_ptr, code);
     1405 		call check_code;
     1406 	     end;
     1407 	end;

     1408 
     1409 	return;

     1410 
     1411      end set_scroll_height_or_width;

     1412 
     1413      end setup_for_next_chunk;
     1414 
     1415 setup_scroll: proc;



     1416 
     1417 	/* Set the pointers we will need. */

     1418 
     1419 	scroll_ip = display_results.scroll_info_ptr;
     1420 	scroll_info.display_arg_results_ptr = display_results_ptr;
     1421 	scroll_info.report_control_info_ptr = report_cip;
     1422 	scroll_info.area_ptr = work_area_ptr;
     1423 	scroll_info.ssu_info_ptr = sci_ptr;

     1424 
     1425 	/* Allocate the structures for the user_i/o and report windows, and the window_status_info. */

     1426 
     1427 	allocate user_io_window_position_info in (work_area)
     1428 	     set (user_io_window_position_ip);
     1429 	scroll_info.user_io_window_position_info_ptr
     1430 	     = user_io_window_position_ip;
     1431 	unspec (user_io_window_position_info) = OFF;
     1432 	user_io_window_position_info.version = window_position_info_version_1;

     1433 
     1434 	allocate report_output_window_position_info in (work_area)
     1435 	     set (report_output_window_position_ip);
     1436 	scroll_info.report_output_window_position_info_ptr
     1437 	     = report_output_window_position_ip;
     1438 	report_output_window_position_info = user_io_window_position_info;

     1439 
     1440 	allocate window_status_info in (work_area) set (window_status_info_ptr);
     1441 	window_status_info.version = window_status_version_1;
     1442 	scroll_info.window_status_info_pointer = window_status_info_ptr;

     1443 
     1444 	/* Turn on the video system if it's not already on. */

     1445 
     1446 	if video_data_$terminal_iocb = null ()
     1447 	then do;
     1448 	     scroll_info.flags.video_was_already_on = OFF;
     1449 	     call video_utils_$turn_on_login_channel (code, reason);
     1450 	     if code ^= 0
     1451 	     then call abort_line (code, reason);
     1452 	end;
     1453 	else scroll_info.flags.video_was_already_on = ON;
     1454 
     1455 /*
     1456*	If -window was specified by the user make sure it meets the 
     1457*	requirements. If it wasn't setup a shriek named window and
     1458*	shrink user_i/o.
     1459**/

     1460 
     1461 	if display_results.window_flag
     1462 	then do;
     1463 	     call iox_$look_iocb (display_results.window_name, window_iocb_ptr, code);
     1464 	     if code ^= 0
     1465 	     then call abort_line (code, "The window " || rtrim (display_results.window_name) || " doesn't exist.");
     1466 	     if window_iocb_ptr -> iocb.attach_descrip_ptr ^= null ()
     1467 	     then if window_iocb_ptr -> iocb.open_descrip_ptr = null ()
     1468 		then call abort_line (0, "The output switch "
     1469 		     || rtrim (display_results.window_name) || " is attached but not open.");
     1470 	          else;
     1471 	     else call abort_line (0, "The output switch "
     1472 		|| rtrim (display_results.window_name) || " is not attached.");
     1473 	     scroll_info.flags.user_io_was_shrunk = OFF;
     1474 	     call iox_$control (window_iocb_ptr, "get_window_info", 
     1475 		report_output_window_position_ip, code);
     1476 	     if code ^= 0
     1477 	     then call abort_line (code, "Unable to get the window information.");
     1478 	     if report_output_window_position_info.height < MINIMUM_WINDOW_SIZE
     1479 	     then call abort_line (0, MINIMUM_WINDOW_SIZE_ERROR_MESSAGE);
     1480 	end;
     1481 	else do;
     1482 	     scroll_info.flags.user_io_was_shrunk = ON;
     1483 	     call iox_$control (iox_$user_io, "get_window_info", 
     1484 		user_io_window_position_ip, code);
     1485 	     if code ^= 0
     1486 	     then call abort_line (code, "Unable to get the window information.");
     1487 	     if user_io_window_position_info.height < MINIMUM_LINES_NEEDED
     1488 	     then call abort_line (video_et_$insuff_room_for_window,
     1489 		MINIMUM_LINES_NEEDED_ERROR_MESSAGE);
     1490 	     call window_$clear_window (iox_$user_io, code);
     1491 	     if code ^= 0
     1492 	     then call abort_line (code, "Unable to clear the user_i/o window.");
     1493 	     report_output_window_position_info = user_io_window_position_info;
     1494 	     user_io_window_position_info.line = user_io_window_position_info.line
     1495 		+ user_io_window_position_info.height - USER_IO_WINDOW_HEIGHT;
     1496 	     user_io_window_position_info.height = USER_IO_WINDOW_HEIGHT;
     1497 	     call iox_$control (iox_$user_io, "set_window_info",
     1498 		user_io_window_position_ip, code);
     1499 	     if code ^= 0
     1500 	     then call abort_line (code, "Unable to set the window info for user_i/o.");
     1501 	     switch_name =  unique_chars_ ("0"b) || ".rw_display";
     1502 	     call iox_$find_iocb (switch_name, window_iocb_ptr, code);
     1503 	     if code ^= 0
     1504 	     then call abort_line (code, "Unable to find the io control block for "
     1505 		|| rtrim (switch_name) || ".");
     1506 	     report_output_window_position_info.height
     1507 		= report_output_window_position_info.height - USER_IO_WINDOW_HEIGHT;
     1508 	     call window_$create (video_data_$terminal_iocb,
     1509 		report_output_window_position_ip, window_iocb_ptr, code);
     1510 	     if code ^= 0
     1511 	     then call abort_line (code, "Unable to create the window for the report.");
     1512 	end;

     1513 
     1514 	/* Fill in the scroll_info and format_document_options structures. */

     1515 
     1516 	report_control_info.display_iocb_ptr = window_iocb_ptr;

     1517 
     1518 	scroll_info.number_of_lines_for_report_display = report_output_window_position_info.height;
     1519 	scroll_info.vertical_scroll_distance = report_output_window_position_info.height - 1;
     1520 	scroll_info.horizontal_scroll_distance = report_output_window_position_info.width - 10;
     1521 	scroll_info.target_page_number = 1;
     1522 	scroll_info.target_line_number = 1;
     1523 	scroll_info.left_vertical_position = 1;

     1524 
     1525 	allocate format_document_options in (work_area) set (format_document_options_ptr);
     1526 	unspec (format_document_options) = OFF;
     1527 	format_document_options.version_number = format_document_version_2;
     1528 	format_document_options.switches.galley_sw = ON;
     1529 	format_document_options.switches.break_word_sw = ON;
     1530 	format_document_options.switches.max_line_length_sw = ON;
     1531 	format_document_options.switches.sub_err_sw = ON;
     1532 	format_document_options.switches.literal_sw = ON;
     1533 	format_document_options.switches.dont_compress_sw = ON;
     1534 	format_document_options.line_length = report_output_window_position_info.width;
     1535 	format_document_options.switches.adj_sw = OFF;
     1536 	scroll_info.format_document_op = format_document_options_ptr;

     1537 
     1538 	return;

     1539 
     1540      end setup_scroll;
     1541 
     1542 terminate_scroll: proc;



     1543 
     1544 /*
     1545*	Clear the window. Destroy the window and restore user_i/o back to
     1546*	it's original size if -window wasn't given by the user. Turn off
     1547*	the video system if we turned it on.
     1548**/

     1549 
     1550 	call window_$clear_window (window_iocb_ptr, code);
     1551 	if code ^= 0
     1552 	then call ssu_$print_message (sci_ptr, code);

     1553 
     1554 	if ^display_results.window_flag
     1555 	then do;
     1556 	     call window_$destroy (window_iocb_ptr, code);
     1557 	     if code ^= 0
     1558 	     then call ssu_$print_message (sci_ptr, code);
     1559 	     user_io_window_position_info.line
     1560 		= report_output_window_position_info.line;
     1561 	     user_io_window_position_info.height 
     1562 		= report_output_window_position_info.height
     1563 		+ user_io_window_position_info.height;
     1564 	     call iox_$control (iox_$user_io, "set_window_info",
     1565 		user_io_window_position_info_ptr, code);
     1566 	     if code ^= 0
     1567 	     then call ssu_$print_message (sci_ptr, code);
     1568 	     call iox_$destroy_iocb (window_iocb_ptr, code);
     1569 	     if code ^= 0
     1570 	     then call ssu_$print_message (sci_ptr, code);
     1571 	end;

     1572 
     1573 	if ^scroll_info.flags.video_was_already_on
     1574 	then do;
     1575 	     call video_utils_$turn_off_login_channel (code);
     1576 	     if code ^= 0
     1577 	     then call ssu_$print_message (sci_ptr, code);
     1578 	end;

     1579 
     1580 	if user_io_window_position_ip ^= null
     1581 	then free user_io_window_position_info;
     1582 	if report_output_window_position_ip ^= null
     1583 	then free report_output_window_position_info;
     1584 	if window_status_info_ptr ^= null
     1585 	then free window_status_info;
     1586 	if format_document_options_ptr ^= null
     1587 	then free format_document_options;

     1588 
     1589 	return;

     1590 
     1591      end terminate_scroll;
     1592 
     1593 valid_function_name: proc (
     1594 
     1595 	vfn_function_name_parm)	/* input: function name */
     1596 
     1597 	returns (bit (1) aligned);



     1598 
     1599 dcl vfn_function_name_parm char (*) parm;

     1600 
     1601 	/* Return true if it's a valid function name. */



     1602 
     1603 	return ((vfn_function_name_parm = FUNCTION_NAMES.FORWARD)
     1604 	     | (vfn_function_name_parm = FUNCTION_NAMES.BACKWARD)
     1605 	     | (vfn_function_name_parm = FUNCTION_NAMES.LEFT)
     1606 	     | (vfn_function_name_parm = FUNCTION_NAMES.RIGHT)
     1607 	     | (vfn_function_name_parm = FUNCTION_NAMES.HELP)
     1608 	     | (vfn_function_name_parm = FUNCTION_NAMES.SET_KEY)
     1609 	     | (vfn_function_name_parm = FUNCTION_NAMES.SET_SCROLL_INCREMENT)
     1610 	     | (vfn_function_name_parm = FUNCTION_NAMES.QUIT)
     1611 	     | (vfn_function_name_parm = FUNCTION_NAMES.REDISPLAY)
     1612 	     | (vfn_function_name_parm = FUNCTION_NAMES.START_OF_REPORT)
     1613 	     | (vfn_function_name_parm = FUNCTION_NAMES.END_OF_REPORT)
     1614 	     | (vfn_function_name_parm = FUNCTION_NAMES.MULTICS_MODE)
     1615 	     | (vfn_function_name_parm = FUNCTION_NAMES.GOTO));

     1616 
     1617      end valid_function_name;
     1618 
     1619 dcl BLANK char (1) static internal options (constant) init (" ");

     1620 
     1621 dcl CARRIAGE_RETURN char (1) static internal options (constant) init ("");
     1622 dcl CONTROL_HYPHEN char (8) static internal options (constant) init ("control-");
     1623 dcl CTL_HYPHEN char (4) static internal options (constant) init ("ctl-");

     1624 
     1625 dcl DEL char (1) static internal options (constant) init ("");
     1626 dcl DIGITS char (10) static int options (constant) init ("0123456789");

     1627 
     1628 dcl ESCAPE char (1) static internal options (constant) init ("");
     1629 dcl ESC_HYPHEN char (4) static internal options (constant) init ("esc-");
     1630 dcl ESCAPE_HYPHEN char (7) static internal options (constant) init ("escape-");

     1631 
     1632 dcl GENERAL_HELP_MESSAGE char (128) static internal options (constant) init (
     1633 "Type the function name or mnemonic key sequence, or type ?? for a list of function names and key sequences. (end with RETURN) ->");
     1634 dcl GENERAL_HELP_LIST char (2) static internal options (constant) init ("??");
     1635 dcl GENERAL_HELP_LIST_MESSAGE char (203) static internal options (constant) init (
     1636 "forward (^a)^/backward (^a)^/left (^a)^/right (^a)^/help (^a)^/set_key (^a)^/set_scroll_increment (^a)^/quit (^a)^/redisplay (^a)^/start_of_report (^a)^/end_of_report (^a)^/multics_mode (^a)^/goto (^a)^/");

     1637 
     1638 dcl HOME char (4) static internal options (constant) init ("home");
     1639 dcl HELP_HEADER_CONTROL_STRING char (15) internal static options (constant) init ("^a^x(^a)^2/^a^/");
     1640 dcl HELP_MESSAGES (13) char (254) internal static options (constant) init (
     1641 
     1642 "The forward function moves the window forward into the report. The scroll height controls how many lines forward the window moves. The set_scroll_increment function can be used to change the scroll height.",
     1643 
     1644 "The backward function moves the window backward into the report. The scroll height controls how many lines backward the window moves. The set_scroll_increment function can be used to change the scroll height.",
     1645 
     1646 "The left function moves the window left in the report. The scroll width controls how many characters left the window moves. The set_scroll_increment function can be used to change the scroll width.",
     1647 
     1648 "The right function moves the window right in the report. The scroll width controls how many characters right the window moves. The set_scroll_increment function can be used to change the scroll width.",
     1649 
     1650 "The help function provides general information on the display function names and key sequences used to invoke the functions, or, more detailed help on any specific display function.",
     1651 
     1652 "The set_key function provides a way to associate key sequences with display functions. The function name and mnemonic key sequences are prompted for.",
     1653 
     1654 "The set_scroll_increment function provides a way to change the scroll height and width. Height is the number of lines forward or backward that the window will move; width is the number of characters left or right that the window will move.",
     1655 
     1656 "The quit function terminates the current invocation of the display request.",
     1657 
     1658 "The redisplay function redisplays the contents of the window. This is useful after the window contents have become invalid due to line noise, interactive messages, etc.",
     1659 
     1660 "The start_of_report function provides a way to get back to the start of the report from any arbitrary place in the report.",
     1661 
     1662 "The end_of_report function provides a way to get to the end of the report from any arbitrary place in the report.",
     1663 
     1664 "The multics_mode function provides a way to suspend the current invocation of display and use other Multics facilities. Typing ""start"" resumes the suspended invocation of display.",
     1665 
     1666 "The goto function provides a means to go directly to any page within a paginated report, or, directly to any line number within an unpaginated report."
     1667 );
     1668 dcl HOW_TO_END_DISPLAY_MESSAGE char (62) static internal options (constant) init ("Type any single character for redisplay or h for more help ->
     1669 ");
     1670 dcl HOW_TO_GET_BACK_MESSAGE char (38) static internal options (constant) init (
     1671 "Type ""start"" to get back to display.");

     1672 
     1673 dcl LARGEST_LINE_NUMBER fixed bin (35) static internal options (constant) init (34359738365);
     1674 dcl LARGEST_PAGE_NUMBER fixed bin (21) static internal options (constant) init (2097151);

     1675 
     1676 dcl MINIMUM_LINES_NEEDED fixed bin static internal options (constant) init (9);
     1677 dcl MINIMUM_LINES_NEEDED_ERROR_MESSAGE char (45) static internal options (constant) init ("The user_i/o window must be at least 9 lines.");
     1678 dcl MINIMUM_WINDOW_SIZE fixed bin static internal options (constant) init (5);
     1679 dcl MINIMUM_WINDOW_SIZE_ERROR_MESSAGE char (45) static internal options (constant) init (
     1680 "The provided window must be at least 5 lines.");
     1681 dcl MORE_PROMPT char (47) static internal options (constant) init (
     1682 "More? (RETURN for more; DEL to discard output.)");

     1683 
     1684 dcl NEWLINE char (1) static internal options (constant) init ("
     1685 ");
     1686 dcl NO_PROMPT bit (1) aligned internal static options (constant) init ("0"b);
     1687 dcl NON_NUMERIC_RESPONSE bit (1) aligned static int options (constant) init ("0"b);
     1688 dcl NUMERIC_RESPONSE bit (1) aligned static int options (constant) init ("1"b);

     1689 
     1690 dcl OFF bit (1) aligned static internal options (constant) init ("0"b);
     1691 dcl ON bit (1) aligned static internal options (constant) init ("1"b);

     1692 
     1693 dcl PROMPT bit (1) aligned internal static options (constant) init ("1"b);

     1694 
     1695 dcl TRANSLATION_TABLE char (63) internal static options (constant) init (
     1696 "@ABCDEFGHIJKLMNOPQRSTUVWXYZ1\]^_`abcdefghijklmnopqrstuvwxyz{|}~");
     1697 dcl TOP_MARGIN_HEIGHT fixed bin static int options (constant) init (4);

     1698 
     1699 dcl USER_IO_WINDOW_HEIGHT fixed bin static int options (constant) init (4);
     1700 
     1701 dcl addr builtin;

     1702 
     1703 dcl byte builtin;

     1704 
     1705 dcl code fixed bin (35);
     1706 dcl 1 command_level_flags aligned,
     1707       2 reset_sw bit (1) unaligned,
     1708       2 mbx bit (35) unaligned;
     1709 dcl convert builtin;
     1710 dcl convert_status_code_ entry (fixed bin(35), char(8) aligned, char(100) aligned);
     1711 dcl cu_$cl entry (1 aligned, 2 bit(1) unal, 2 bit(35) unal);

     1712 
     1713 dcl 1 display_results like display_arg_results based (display_results_ptr);
     1714 dcl display_results_ptr ptr;

     1715 
     1716 dcl error_message char (256) varying;
     1717 dcl error_table_$end_of_info fixed bin(35) ext static;
     1718 dcl error_table_$long_record fixed bin(35) ext static;

     1719 
     1720 dcl format_document_$string entry (char(*), char(*), fixed bin(21), ptr, fixed bin(35));
     1721 dcl function_name char (32);
     1722 dcl function_key_sequence char (32);

     1723 
     1724 dcl hbound builtin;

     1725 
     1726 dcl index builtin;
     1727 dcl ioa_$rsnnl entry() options(variable);

     1728 
     1729 dcl length builtin;
     1730 dcl long_message char (100) aligned;
     1731 dcl ltrim builtin;

     1732 
     1733 dcl max builtin;
     1734 dcl min builtin;

     1735 
     1736 dcl null builtin;

     1737 
     1738 dcl reason char (64);
     1739 dcl 1 report_output_window_position_info like window_position_info based (report_output_window_position_ip);
     1740 dcl report_output_window_position_ip ptr;
     1741 dcl rtrim builtin;
     1742 dcl rw_error_$bad_fkey_name fixed bin(35) ext static;
     1743 dcl rw_error_$bad_fkey_sequence fixed bin(35) ext static;
     1744 dcl rw_error_$bad_report_display fixed bin(35) ext static;

     1745 
     1746 dcl sci_ptr ptr;
     1747 dcl short_message char (8) aligned;
     1748 dcl ssu_$abort_line entry() options(variable);
     1749 dcl ssu_$print_message entry() options(variable);
     1750 dcl still_in_the_scrolling_business bit (1) aligned;
     1751 dcl substr builtin;
     1752 dcl switch_name char (42);
     1753 dcl sys_info$max_seg_size fixed bin(35) ext static;

     1754 
     1755 dcl unique_chars_ entry (bit(*)) returns(char(15));
     1756 dcl unspec builtin;
     1757 dcl 1 user_io_window_position_info like window_position_info based (user_io_window_position_ip);
     1758 dcl user_io_window_position_ip ptr;
     1759 dcl users_response char (32);

     1760 
     1761 dcl verify builtin;
     1762 dcl video_data_$terminal_iocb ptr static external;
     1763 dcl video_et_$insuff_room_for_window fixed bin(35) ext static;
     1764 dcl video_et_$window_status_pending fixed bin(35) ext static;
     1765 dcl video_utils_$turn_on_login_channel entry (fixed bin(35), char(*));
     1766 dcl video_utils_$turn_off_login_channel entry (fixed bin(35));

     1767 
     1768 dcl window_iocb_ptr ptr;
     1769 dcl work_area area (sys_info$max_seg_size) based (work_area_ptr);
     1770 dcl work_area_ptr ptr;
     1771 
  1     1 /*	BEGIN INCLUDE FILE   format_document_options.incl.pl1	     
  1     2*
  1     3*     Modified 82.10.18 by Paul W. Benjamin to add dont_compress_sw and upgrade
  1     4*			to version_2.
  1     5*     Modified 83.02.15 by PWB to add break_word_sw and max_line_length_sw.
  1     6*     Modified 83.03.01 by PWB to add dont_break_indented_lines_sw.
  1     7*     Modified 83.03.03 by PWB to add sub_err_sw.
  1     8*     Modified 83.06.07 by PWB to add dont_fill_sw.
  1     9*     Modified 83.06.09 by PWB to add hyphenation_sw and syllable_size.
  1    10**/
  1    11 
  1    12 dcl 1 format_document_options aligned based (format_document_options_ptr),
  1    13       2 version_number        fixed bin,		/* input */
  1    14                                                             /* must be format_document_version_2 */
  1    15       2 indentation           fixed bin,		/* input */
  1    16 						/* all lines must be indented by this value */
  1    17       2 line_length           fixed bin,		/* input */
  1    18 						/* initial line length */
  1    19       2 switches,
  1    20         3 pgno_sw             bit (1) unal,		/* input */
  1    21 						/* end each page with a centered page number */
  1    22         3 adj_sw              bit (1) unal,		/* input */
  1    23 						/* adjust mode initially on */
  1    24                                                             /* only meaningful if dont_fill_sw = "0"b */
  1    25         3 galley_sw           bit (1) unal,		/* input */
  1    26 						/* galley mode -- no page breaks */
  1    27         3 error_sw            bit (1) unal,		/* input */
  1    28 						/* report all errors on error_output */
  1    29         3 literal_sw          bit (1) unal,		/* input */
  1    30 						/* "1"b - interpret all lines as text */
  1    31 						/* "0"b - lines that start with "." are controls */
  1    32         3 file_sw             bit (1) unal,		/* output */
  1    33 						/* has meaning for non-zero storage system status codes */
  1    34 						/* "1"b code refers to output file */
  1    35 						/* "0"b code refers to input file */
  1    36         3 dont_compress_sw    bit (1) unal,		/* input */
  1    37 						/* "1"b - don't compress white space */
  1    38 						/* "0"b - compress white space when filling */
  1    39         3 break_word_sw      bit (1) unal,		/* input */
  1    40 						/* "1"b - break a word rather than exceed line_length */
  1    41 						/* "0"b - write an overlength line if no spaces found */
  1    42         3 max_line_length_sw  bit (1) unal,		/* input */
  1    43 						/* "1"b - line_length cannot be exceeded */
  1    44 						/* "0"b - line_length can be exceeded (by .pdw controls) */
  1    45         3 dont_break_indented_lines_sw			/* input */
  1    46 			bit (1) unal,		/* don't break a line that begins with whitespace */
  1    47 						/* when it is the last line, or the next line is */
  1    48 						/* null or the next line begins with whitespace */
  1    49         3 sub_err_sw	bit (1) unal,		/* input */
  1    50 						/* quietly call sub_err_ with diagnostic errors */
  1    51         3 dont_fill_sw        bit (1) unal,                 /* input */
  1    52                                                             /* "1"b - fill mode off initially */
  1    53                                                             /* "0"b - fill mode on initially */
  1    54         3 hyphenation_sw      bit (1) unal,
  1    55         3 mbz                 bit (23) unal,		/* input */
  1    56 						/* MUST be zero */
  1    57       2 syllable_size
  1    58 			fixed bin;		/* input */
  1    59 						/* smallest portion of word */
  1    60 						/* to be left by hyphenation */
  1    61 
  1    62 dcl  format_document_options_ptr ptr;
  1    63 dcl  format_document_version_2 fixed bin int static options (constant) init (2);
  1    64 dcl  format_document_version_1 fixed bin int static options (constant) init (1);
  1    65 	
  1    66 /*	END INCLUDE FILE   format_document_options.incl.pl1	     */
     1772 
     1773 
  2     1 /* BEGIN INCLUDE FILE ... function_key_data.incl.pl1 
  2     2*
  2     3*   This include file defines the structure used for ttt_info_$function_key_data
  2     4*   MCR 4671      James R. Davis Sept 80
  2     5**/
  2     6 
  2     7 dcl 1 function_key_data aligned based (function_key_data_ptr),
  2     8       2 version fixed bin,
  2     9       2 highest fixed bin,				/* highest fkey */
  2    10       2 sequence,					/* string of all seqs. */
  2    11         3 seq_ptr pointer,
  2    12         3 seq_len fixed bin (21),
  2    13       2 cursor_motion_keys,
  2    14         3 home (0:3) like key_info,
  2    15         3 left (0:3) like key_info,
  2    16         3 up (0:3) like key_info,
  2    17         3 right (0:3) like key_info,
  2    18         3 down (0:3) like key_info,
  2    19       2 function_keys (0:function_key_data_highest refer
  2    20 	(function_key_data.highest), 0:3) like key_info;
  2    21 
  2    22 dcl (KEY_PLAIN init (0),
  2    23      KEY_SHIFT init (1),
  2    24      KEY_CTRL init (2),
  2    25      KEY_CTRL_AND_SHIFT init (3)
  2    26      ) fixed bin internal static options (constant);
  2    27 
  2    28 dcl 1 key_info unaligned based (key_info_ptr),
  2    29       2 sequence_index fixed bin (12) unsigned unaligned,
  2    30       2 sequence_length fixed bin (6) unsigned unaligned;	/* 0 -> not exist */
  2    31 
  2    32 dcl function_key_seqs char (function_key_data.sequence.seq_len)
  2    33 	based (function_key_data.sequence.seq_ptr);
  2    34 dcl function_key_data_ptr ptr;
  2    35 dcl function_key_data_highest fixed bin;
  2    36 dcl function_key_data_version_1
  2    37 	fixed bin internal static options (constant) init (1);
  2    38 dcl key_info_ptr ptr;
  2    39 
  2    40 
  2    41 /* END INCLUDE FILE ... function_key_data.incl.pl1 */
     1774 
     1775 
  3     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  3     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  3     3*      version number to IOX2. */
  3     4 /* format: style2 */
  3     5 
  3     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  3     7 	     2 version	      character (4) aligned,	/* IOX2 */
  3     8 	     2 name	      char (32),		/* I/O name of this block. */
  3     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  3    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  3    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  3    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  3    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  3    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
  3    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  3    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  3    17 						/* open(p,mode,not_used,s) */
  3    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  3    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  3    20 						/* get_line(p,bufptr,buflen,actlen,s) */
  3    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  3    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
  3    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  3    24 						/* put_chars(p,bufptr,buflen,s) */
  3    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  3    26 						/* modes(p,newmode,oldmode,s) */
  3    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  3    28 						/* position(p,u1,u2,s) */
  3    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  3    30 						/* control(p,order,infptr,s) */
  3    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  3    32 						/* read_record(p,bufptr,buflen,actlen,s) */
  3    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  3    34 						/* write_record(p,bufptr,buflen,s) */
  3    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  3    36 						/* rewrite_record(p,bufptr,buflen,s) */
  3    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  3    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  3    39 						/* seek_key(p,key,len,s) */
  3    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  3    41 						/* read_key(p,key,len,s) */
  3    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
  3    43 						/* read_length(p,len,s) */
  3    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  3    45 						/* open_file(p,mode,desc,not_used,s) */
  3    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  3    47 						/* close_file(p,desc,s) */
  3    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
  3    49 						/* detach(p,desc,s) */
  3    50 
  3    51      declare iox_$iocb_version_sentinel
  3    52 			      character (4) aligned external static;
  3    53 
  3    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
     1776 
     1777 
  4     1 /* --------------- BEGIN include file iox_dcls.incl.pl1 --------------- */
  4     2 
  4     3 /* Written 05/04/78 by C. D. Tavares */
  4     4 /* Fixed declaration of iox_$find_iocb_n 05/07/80 by R. Holmstedt */
  4     5 /* Modified 5/83 by S. Krupp to add declarations for:  iox_$open_file,
  4     6*     iox_$close_file, iox_$detach and iox_$attach_loud entries. */
  4     7 
  4     8 dcl  iox_$attach_name entry (char (*), pointer, char (*), pointer, fixed bin (35)),
  4     9      iox_$attach_ptr entry (pointer, char (*), pointer, fixed bin (35)),
  4    10      iox_$close entry (pointer, fixed bin (35)),
  4    11      iox_$control entry (pointer, char (*), pointer, fixed bin (35)),
  4    12      iox_$delete_record entry (pointer, fixed bin (35)),
  4    13      iox_$destroy_iocb entry (pointer, fixed bin (35)),
  4    14      iox_$detach_iocb entry (pointer, fixed bin (35)),
  4    15      iox_$err_not_attached entry options (variable),
  4    16      iox_$err_not_closed entry options (variable),
  4    17      iox_$err_no_operation entry options (variable),
  4    18      iox_$err_not_open entry options (variable),
  4    19      iox_$find_iocb entry (char (*), pointer, fixed bin (35)),
  4    20      iox_$find_iocb_n entry (fixed bin, ptr, fixed bin(35)),
  4    21      iox_$get_chars entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  4    22      iox_$get_line entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  4    23      iox_$look_iocb entry (char (*), pointer, fixed bin (35)),
  4    24      iox_$modes entry (pointer, char (*), char (*), fixed bin (35)),
  4    25      iox_$move_attach entry (pointer, pointer, fixed bin (35)),
  4    26      iox_$open entry (pointer, fixed bin, bit (1) aligned, fixed bin (35)),
  4    27      iox_$position entry (pointer, fixed bin, fixed bin (21), fixed bin (35)),
  4    28      iox_$propagate entry (pointer),
  4    29      iox_$put_chars entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  4    30      iox_$read_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  4    31      iox_$read_length entry (pointer, fixed bin (21), fixed bin (35)),
  4    32      iox_$read_record entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  4    33      iox_$rewrite_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  4    34      iox_$seek_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  4    35      iox_$write_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  4    36      iox_$open_file entry(ptr, fixed bin, char(*), bit(1) aligned, fixed bin(35)),
  4    37      iox_$close_file entry(ptr, char(*), fixed bin(35)),
  4    38      iox_$detach entry(ptr, char(*), fixed bin(35)),
  4    39      iox_$attach_loud entry(ptr, char(*), ptr, fixed bin(35));
  4    40 
  4    41 dcl (iox_$user_output,
  4    42      iox_$user_input,
  4    43      iox_$user_io,
  4    44      iox_$error_output) external static pointer;
  4    45 
  4    46 /* ---------------- END include file iox_dcls.incl.pl1 ---------------- */
     1778 
     1779 
  5     1 /*	BEGIN INCLUDE FILE rw_display_arg_list.incl.pl1
  5     2*
  5     3*	Shared structure between the rw_display request and
  5     4*	its argument processor, rw_display_process_args.
  5     5*
  5     6*	Al Dupuis - August 1983
  5     7**/
  5     8 /* format: off */



  5     9 
  5    10 dcl 1 display_arg_results aligned,
  5    11 
  5    12       2 flags,
  5    13         3 all_flag bit (1) aligned,		/* DEFAULT */
  5    14         3 character_positions_flag bit (1) aligned,
  5    15         3 debug_flag bit (1) aligned,
  5    16         3 keep_report_flag bit (1) aligned,
  5    17         3 keep_retrieval_flag bit (1) aligned,
  5    18         3 long_flag bit (1) aligned,		/* DEFAULT */
  5    19         3 new_report_flag bit (1) aligned,	/* DEFAULT */
  5    20         3 new_retrieval_flag bit (1) aligned,	/* DEFAULT */
  5    21         3 output_file_flag bit (1) aligned,
  5    22         3 output_switch_flag bit (1) aligned,
  5    23         3 truncate_flag bit (1) aligned,	/* DEFAULT */
  5    24         3 pages_flag bit (1) aligned,
  5    25         3 last_page_flag bit (1) aligned,
  5    26         3 scroll_flag bit (1) aligned,
  5    27         3 sort_flag bit (1) aligned,
  5    28         3 temp_dir_flag bit (1) aligned,
  5    29         3 time_flag bit (1) aligned,
  5    30         3 window_flag bit (1) aligned,
  5    31         3 passes_flag bit (1) aligned,
  5    32 
  5    33       2 pathnames,
  5    34         3 output_switch_name char (32) unal,		/* -output_switch */
  5    35         3 output_file_directory_name char (168) unal,	/* -output_file */
  5    36         3 output_file_entry_name char (32) unal,		/* -output_file */
  5    37         3 output_file_pathname char (168) unal,		/* -output_file */
  5    38         3 temp_dir_pathname char (168) unal,		/* -temp_dir */
  5    39         3 window_name char (32) unal,			/* -window */
  5    40 
  5    41       2 miscellaneous,
  5    42         3 left_margin_position fixed bin,	/* -character_positions */
  5    43         3 right_margin_position fixed bin,	/* -character_positions */
  5    44         3 number_of_passes fixed bin,		/* -passes */
  5    45         3 sort_information_ptr ptr,		/* -sort */
  5    46         3 scroll_info_ptr ptr,		/* -scroll */
  5    47         3 specified_pages (NUMBER_OF_ALLOWED_SPECIFIED_PAGES) bit (1) unal;	/* -pages */

  5    48 
  5    49 dcl NUMBER_OF_ALLOWED_SPECIFIED_PAGES static internal options (constant) init (10000);
  5    50 /*	END INCLUDE FILE rw_display_arg_list.incl.pl1 */
     1780 
     1781 
  6     1 /*	BEGIN INCLUDE FILE rw_options_extents.incl.pl1
  6     2*
  6     3*   Extents for the formatting options used for producing reports.
  6     4*   Kept as a separate include so that some programs may include this
  6     5*   file without including rw_format_options.incl.pl1
  6     6*
  6     7*    Al Dupuis - August 1983
  6     8*
  6     9**/
  6    10 /* format: off */

  6    11 
  6    12 /* The three types of format options that we have. */

  6    13 
  6    14 dcl GENERAL_REPORT_OPTION fixed bin static int options (constant) init (1);
  6    15 dcl GENERAL_COLUMN_OPTION fixed bin static int options (constant) init (2);
  6    16 dcl SPECIFIC_COLUMN_OPTION fixed bin static int options (constant) init (3);

  6    17 
  6    18 /* Used to determine how big the tables are without doing a hbound on it. */

  6    19 
  6    20 dcl NUMBER_OF_GENERAL_COLUMN_OPTIONS_IN_TABLE fixed bin static int options (constant) init (15);
  6    21 dcl NUMBER_OF_GENERAL_REPORT_OPTIONS_IN_TABLE fixed bin static int options (constant) init (9);
  6    22 dcl NUMBER_OF_SPECIFIC_COLUMN_OPTIONS_IN_TABLE fixed bin static int options (constant) init (6);

  6    23 
  6    24 /* Used to determine how much space is needed to list them. */

  6    25 
  6    26 dcl LONGEST_SPECIFIC_COLUMN_OPTION_NAME_LENGTH fixed bin static int options (constant) init (10); /* -alignment */
  6    27 dcl LONGEST_GENERAL_REPORT_OPTION_NAME_LENGTH fixed bin static int options (constant) init (25); /* -format_document_controls */
  6    28 dcl LONGEST_GENERAL_COLUMN_OPTION_NAME_LENGTH fixed bin static int options (constant) init (21); /* -group_footer_trigger */

  6    29 
  6    30 /* MAXIMUM_OPTION_IDENTIFIER_LENGTH + MAXIMUM_OPTION_NAME_LENGTH */

  6    31 
  6    32 dcl MAXIMUM_NORMALIZED_OPTION_NAME_LENGTH fixed bin static int options (constant) init (101);

  6    33 
  6    34 dcl MAXIMUM_OPTION_IDENTIFIER_LENGTH fixed bin static int options (constant) init (69);
  6    35 dcl MAXIMUM_OPTION_NAME_LENGTH fixed bin static int options (constant) init (32);
  6    36 dcl MAXIMUM_OPTION_VALUE_LENGTH fixed bin static int options (constant) init (4096);
  6    37 
  6    38 /* Used to index into the OPTIONS tables defined in rw_format_options.incl.pl1. */

  6    39 
  6    40 dcl INDEX_FOR_DELIMITER fixed bin static int options (constant) init (1);
  6    41 dcl INDEX_FOR_FORMAT_DOCUMENT_CONTROLS fixed bin static int options (constant) init (2);
  6    42 dcl INDEX_FOR_HYPHENATION fixed bin static int options (constant) init (3);
  6    43 dcl INDEX_FOR_PAGE_FOOTER_VALUE fixed bin static int options (constant) init (4);
  6    44 dcl INDEX_FOR_PAGE_HEADER_VALUE fixed bin static int options (constant) init (5);
  6    45 dcl INDEX_FOR_PAGE_LENGTH fixed bin static int options (constant) init (6);
  6    46 dcl INDEX_FOR_PAGE_WIDTH fixed bin static int options (constant) init (7);
  6    47 dcl INDEX_FOR_TITLE_LINE fixed bin static int options (constant) init (8);
  6    48 dcl INDEX_FOR_TRUNCATION fixed bin static int options (constant) init (9);

  6    49 
  6    50 dcl INDEX_FOR_COLUMN_ORDER fixed bin static int options (constant) init (1);
  6    51 dcl INDEX_FOR_COUNT  fixed bin static int options (constant) init (2);
  6    52 dcl INDEX_FOR_EXCLUDE fixed bin static int options (constant) init (3);
  6    53 dcl INDEX_FOR_GROUP fixed bin static int options (constant) init (4);
  6    54 dcl INDEX_FOR_GROUP_FOOTER_TRIGGER fixed bin static int options (constant) init (5);
  6    55 dcl INDEX_FOR_GROUP_FOOTER_VALUE fixed bin static int options (constant) init (6);
  6    56 dcl INDEX_FOR_GROUP_HEADER_TRIGGER fixed bin static int options (constant) init (7);
  6    57 dcl INDEX_FOR_GROUP_HEADER_VALUE fixed bin static int options (constant) init (8);
  6    58 dcl INDEX_FOR_OUTLINE fixed bin static int options (constant) init (9);
  6    59 dcl INDEX_FOR_PAGE_BREAK fixed bin static int options (constant) init (10);
  6    60 dcl INDEX_FOR_ROW_FOOTER_VALUE fixed bin static int options (constant) init (11);
  6    61 dcl INDEX_FOR_ROW_HEADER_VALUE fixed bin static int options (constant) init (12);
  6    62 dcl INDEX_FOR_SUBCOUNT fixed bin static int options (constant) init (13);
  6    63 dcl INDEX_FOR_SUBTOTAL fixed bin static int options (constant) init (14);
  6    64 dcl INDEX_FOR_TOTAL fixed bin static int options (constant) init (15);

  6    65 
  6    66 dcl INDEX_FOR_ALIGNMENT fixed bin static int options (constant) init (1);
  6    67 dcl INDEX_FOR_EDITING fixed bin static int options (constant) init (2);
  6    68 dcl INDEX_FOR_FOLDING fixed bin static int options (constant) init (3);
  6    69 dcl INDEX_FOR_SEPARATOR fixed bin static int options (constant) init (4);
  6    70 dcl INDEX_FOR_TITLE fixed bin static int options (constant) init (5);
  6    71 dcl INDEX_FOR_WIDTH fixed bin static int options (constant) init (6);

  6    72 
  6    73 /*    END INCLUDE FILE rw_options_extents */
     1782 
     1783 
  7     1 /*   BEGIN INCLUDE FILE rw_page_info.incl.pl1
  7     2*
  7     3*   Written - Al Dupuis - August 1983
  7     4**/
  7     5 /* format: off */

  7     6 
  7     7      dcl	   1 formatted_page_info  aligned based (formatted_page_ip),
  7     8 	     2 maximum_number_of_detail_blocks fixed bin, /* the most that can appear on a page */
  7     9 	     2 page_header_length fixed bin,		/* page header in lines */
  7    10 	     2 title_block_length fixed bin,		/* titles in lines */
  7    11 	     2 page_footer_length fixed bin,		/* page footer in lines */
  7    12 	     2 number_of_detail_blocks fixed bin,
  7    13 	     2 detail_blocks      (fpi_init_maximum_number_of_detail_blocks
  7    14 			      refer (formatted_page_info.maximum_number_of_detail_blocks)),
  7    15 	       3 row_number	      fixed bin (35),	/* position in the table */
  7    16 	       3 beginning_line_number fixed bin,	/* beginning line on page */
  7    17 	       3 group_header_length fixed bin,		/* group header length in lines */
  7    18 	       3 row_header_length fixed bin,		/* row header in lines */
  7    19 	       3 row_length	      fixed bin,		/* row value in lines */
  7    20 	       3 subtotal_length  fixed bin,		/* subtotal in lines */
  7    21 	       3 subcount_length  fixed bin,		/* subcount in lines */
  7    22 	       3 total_length     fixed bin,		/* total in lines */
  7    23 	       3 count_length     fixed bin,		/* count in lines */
  7    24 	       3 row_footer_length fixed bin,		/* row footer in lines */
  7    25 	       3 group_footer_length fixed bin;		/* group footer length in lines */
  7    26      dcl	   formatted_page_ip      ptr;
  7    27      dcl	   fpi_init_maximum_number_of_detail_blocks fixed bin;

  7    28 
  7    29      dcl	   1 page_info aligned    based (page_ip),
  7    30 	     2 width	      fixed bin,		/* width in chars */
  7    31 	     2 length	      fixed bin,		/* length in lines */
  7    32 	     2 total_characters   fixed bin (21),	/* width * length */
  7    33 	     2 page_info_size     fixed bin,		/* size of this structure in words */
  7    34 	     2 page_ptr	      ptr,		/* points to the actual page */
  7    35 	     2 page_overstrike_info_ptr ptr,		/* points to the overstrike info */
  7    36 	     2 formatted_page_info_ptr ptr;		/* points to formatted_page_info */

  7    37 
  7    38      dcl	   page_defined_as_chars  (page_info.total_characters) char (1) based (page_info.page_ptr);
  7    39      dcl	   page_defined_as_lines  (page_info.length) char (page_info.width) based (page_info.page_ptr);
  7    40      dcl	   page_defined_as_a_string char (page_info.total_characters) based (page_info.page_ptr);
  7    41      dcl	   page_ip	      ptr;

  7    42 
  7    43      dcl	   1 page_overstrike_info aligned based (page_overstrike_ip),
  7    44 	     2 number_of_bits_or_chars fixed bin (21),	/* number of chars in the page */
  7    45 	     2 bit_map (page_info.total_characters	/* on means this char on the page is overstruck */
  7    46 		     refer (page_overstrike_info.number_of_bits_or_chars)) bit (1) unaligned, 
  7    47 	     2 chars (page_info.total_characters	/* this is the overstrike character */
  7    48 		     refer (page_overstrike_info.number_of_bits_or_chars)) char (1) unaligned;
  7    49      dcl	   page_overstrike_ip     ptr;
  7    50 
  7    51      dcl	   1 page_overstrike_info_redefined aligned based (page_overstrike_ip),
  7    52 	     2 number_of_bits_or_chars fixed bin (21),
  7    53 	     2 bit_map bit (page_overstrike_info_redefined.number_of_bits_or_chars) unaligned,
  7    54 	     2 chars char (page_overstrike_info_redefined.number_of_bits_or_chars) unaligned;
  7    55 
  7    56 /*   END INCLUDE FILE rw_page_info.incl.pl1 */
     1784 
     1785 
  8     1 /*  BEGIN INCLUDE FILE rw_report_info.incl.pl1
  8     2*    Information needed to control the report environment.
  8     3*    Al Dupuis - August 1983
  8     4**/
  8     5 /* format: off */

  8     6 
  8     7      dcl	   1 report_control_info aligned  based (report_cip),
  8     8 	     2 flags,
  8     9 	       3 report_is_paginated bit (1) unaligned,	         /* paged or one continous stream */
  8    10 	       3 table_has_been_started bit (1) unaligned,         /* table clean up is necessary */
  8    11 	       3 table_is_full    bit (1) unaligned,	         /* no more retrieves are necessary */
  8    12 	       3 report_has_been_started bit (1) unaligned,        /* report clean up is necessary */
  8    13 	       3 report_is_formatted bit (1) unaligned,	         /* no more formatting is necessary */
  8    14 	       3 permanent_report bit (1) unaligned,	         /* or disposable */
  8    15 	       3 permanent_table  bit (1) unaligned,	         /* or disposable */
  8    16 	       3 report_has_just_been_completed bit (1) unaligned, /* used for printing timers */
  8    17 	       3 table_has_just_been_loaded bit (1) unaligned,     /* used for printing timers */
  8    18 	       3 multi_pass_mode bit (1) unaligned,	         /* on if we are to do more than 1 pass */
  8    19 	       3 available	      bit (26) unaligned,
  8    20 	     2 format_options_flags,		         	         /* used to determine if value is default */
  8    21 	       3 general_report_default_value (NUMBER_OF_GENERAL_REPORT_OPTIONS_IN_TABLE) bit (1) unaligned,
  8    22 	       3 general_column_default_value (NUMBER_OF_GENERAL_COLUMN_OPTIONS_IN_TABLE) bit (1) unaligned,
  8    23 	     2 value_seg_ptr      ptr,		         /* the options value seg */
  8    24 	     2 table_information_ptr ptr,		         /* points to table_info */
  8    25 	     2 table_control_info_ptr ptr,		         /* points to table_control_info */
  8    26 	     2 row_value_temp_segment_ptr ptr,		         /* points to a segment for the row value */
  8    27 	     2 general_work_area_ptr ptr,		         /* a freeing work area */
  8    28 	     2 name_value_area_ptr ptr,		         /* area for name-value allocations */
  8    29 	     2 subsystem_control_info_ptr ptr,		         /* ptr for ssu_ info structure */
  8    30 	     2 subsystems_info_ptr ptr,		         /* points to subsystems info structure */
  8    31 	     2 name_value_temp_seg_ptr ptr,		         /* temp seg for name-value space */
  8    32 	     2 report_temp_seg_ptr ptr,		         /* report workspace */
  8    33 	     2 report_work_area_ptr ptr,		         /* report workspace */
  8    34 	     2 format_report_info_ptr ptr,		         /* info needed to create a report */
  8    35 	     2 input_string_temp_seg_ptr ptr,		         /* report workspace */
  8    36 	     2 output_string_temp_seg_ptr ptr,		         /* report workspace */
  8    37 	     2 editing_strings_temp_seg_ptr ptr,	         /* report workspace */
  8    38 	     2 headers_temp_seg_ptr ptr,		         /* report workspace */
  8    39 	     2 display_iocb_ptr   ptr,		         /* report is displayed through this */
  8    40 	     2 area_info_ptr ptr,			         /* points to area_info structure */
  8    41 	     2 table_manager_delete_table_entry variable entry (ptr, fixed bin (35)), /* entry who deletes the table  */
  8    42 	     2 table_manager_get_query_entry variable entry (ptr, ptr, fixed bin (21), fixed bin (35)), /* entry who gets the query */
  8    43 	     2 table_manager_get_row_entry variable entry (ptr, fixed bin (35)), /* entry who loads rows  */
  8    44 	     2 table_manager_create_table_entry variable entry (ptr, fixed bin (35)), /* entry who makes a new table  */
  8    45 	     2 options_identifier fixed bin,		         /* current set of options */
  8    46 	     2 report_identifier  fixed bin,		         /* current report */
  8    47 	     2 no_of_rows_retrieved fixed bin (35),	         /* current no of rows */
  8    48 	     2 no_of_formatted_pages fixed bin (21),	         /* current no of pages */
  8    49 	     2 number_of_passes fixed bin,		         /* number of times report will be formatted */
  8    50 	     2 table_loading_time float bin (63),
  8    51 	     2 table_sorting_time float bin (63),
  8    52 	     2 table_deletion_time float bin (63),
  8    53 	     2 report_setup_time  float bin (63),
  8    54 	     2 report_formatting_time float bin (63),
  8    55 	     2 report_display_time float bin (63),
  8    56 	     2 report_deletion_time float bin (63),
  8    57 	     2 ssu_evaluate_active_string_time float bin (63),
  8    58 	     2 temp_dir_unique_id bit (36),		/* uid of temp dir */
  8    59 	     2 subsystems_ec_suffix char (32),		/* suffix for saving and restoring ecs */
  8    60 	     2 temp_dir_name      char (168) unaligned;	/* the dir where we place the retrieved table and report */
  8    61      dcl	   report_cip	      ptr init (null ());
  8    62 
  8    63 /*  END INCLUDE FILE rw_report_info.incl.pl1  */
     1786 
     1787 
  9     1 /*   BEGIN INCLUDE FILE rw_scroll_info.incl.pl1
  9     2*
  9     3*   Written - Al Dupuis - August 1983
  9     4**/
  9     5 /* format: off */

  9     6 
  9     7 dcl 1 ESCAPE_KEYS aligned static internal options (constant),
  9     8       2 FORWARD char (2) init ("f"),
  9     9       2 BACKWARD char (2) init ("b"),
  9    10       2 LEFT char (2) init ("l"),
  9    11       2 RIGHT char (2) init ("r"),
  9    12       2 HELP char (2) init ("?"),
  9    13       2 SET_KEY char (2) init ("k"),
  9    14       2 SET_SCROLL_INCREMENT char (2) init ("i"),
  9    15       2 QUIT char (2) init ("q"),
  9    16       2 REDISPLAY char (2) init ("d"),
  9    17       2 START_OF_REPORT char (2) init ("s"),
  9    18       2 END_OF_REPORT char (2) init ("e"),
  9    19       2 MULTICS_MODE char (2) init ("m"),
  9    20       2 GOTO char (2) init ("g");

  9    21 
  9    22 dcl ESCAPE_KEYS_AS_A_TABLE (HIGHEST_DISPLAY_FUNCTION_NUMBER) aligned char (2) based (addr (ESCAPE_KEYS));

  9    23 
  9    24 dcl 1 ESCAPE_KEY_MNEMONICS aligned static internal options (constant),
  9    25       2 FORWARD char (5) init ("esc-f"),
  9    26       2 BACKWARD char (5) init ("esc-b"),
  9    27       2 LEFT char (5) init ("esc-l"),
  9    28       2 RIGHT char (5) init ("esc-r"),
  9    29       2 HELP char (5) init ("esc-?"),
  9    30       2 SET_KEY char (5) init ("esc-k"),
  9    31       2 SET_SCROLL_INCREMENT char (5) init ("esc-i"),
  9    32       2 QUIT char (5) init ("esc-q"),
  9    33       2 REDISPLAY char (5) init ("esc-d"),
  9    34       2 START_OF_REPORT char (5) init ("esc-s"),
  9    35       2 END_OF_REPORT char (5) init ("esc-e"),
  9    36       2 MULTICS_MODE char (5) init ("esc-m"),
  9    37       2 GOTO char (5) init ("esc-g");

  9    38 
  9    39 dcl ESCAPE_KEY_MNEMONICS_AS_A_TABLE (HIGHEST_DISPLAY_FUNCTION_NUMBER) aligned char (5) based (addr (ESCAPE_KEY_MNEMONICS));

  9    40 
  9    41 dcl 1 FUNCTION_NAMES aligned static internal options (constant),
  9    42       2 FORWARD char (32) init ("forward"),
  9    43       2 BACKWARD char (32) init ("backward"),
  9    44       2 LEFT char (32) init ("left"),
  9    45       2 RIGHT char (32) init ("right"),
  9    46       2 HELP char (32) init ("help"),
  9    47       2 SET_KEY char (32) init ("set_key"),
  9    48       2 SET_SCROLL_INCREMENT char (32) init ("set_scroll_increment"),
  9    49       2 QUIT char (32) init ("quit"),
  9    50       2 REDISPLAY char (32) init ("redisplay"),
  9    51       2 START_OF_REPORT char (32) init ("start_of_report"),
  9    52       2 END_OF_REPORT char (32) init ("end_of_report"),
  9    53       2 MULTICS_MODE char (32) init ("multics_mode"),
  9    54       2 GOTO char (32) init ("goto");

  9    55 
  9    56 dcl FUNCTION_NAMES_AS_A_TABLE (HIGHEST_DISPLAY_FUNCTION_NUMBER) aligned char (32) based (addr (FUNCTION_NAMES));

  9    57 
  9    58 dcl HIGHEST_DISPLAY_FUNCTION_NUMBER fixed bin static int options (constant) init (13);

  9    59 
  9    60 dcl HIGHEST_NUMBERED_FUNCTION_KEY_NEEDED fixed bin static int options (constant) init (9);

  9    61 
  9    62 dcl 1 KEY_MNEMONICS aligned static internal options (constant),
  9    63       2 FORWARD char (12) init ("down_arrow"),
  9    64       2 BACKWARD char (12) init ("up_arrow"),
  9    65       2 LEFT char (12) init ("left_arrow"),
  9    66       2 RIGHT char (12) init ("right_arrow"),
  9    67       2 HELP char (12) init ("f1"),
  9    68       2 SET_KEY char (12) init ("f2"),
  9    69       2 SET_SCROLL_INCREMENT char (12) init ("f3"),
  9    70       2 QUIT char (12) init ("f4"),
  9    71       2 REDISPLAY char (12) init ("f5"),
  9    72       2 START_OF_REPORT char (12) init ("f6"),
  9    73       2 END_OF_REPORT char (12) init ("f7"),
  9    74       2 MULTICS_MODE char (12) init ("f8"),
  9    75       2 GOTO char (12) init ("f9");

  9    76 
  9    77 dcl KEY_MNEMONICS_AS_A_TABLE (HIGHEST_DISPLAY_FUNCTION_NUMBER) aligned char (12) based (addr (KEY_MNEMONICS));

  9    78 
  9    79 dcl 1 function_key_info aligned,
  9    80       2 forward char (32),			/* down arrow or esc-f */
  9    81       2 backward char (32),			/* up arrow or esc-b */
  9    82       2 left char (32),			/* left arrow or esc-l */
  9    83       2 right char (32),			/* right arrow or esc-r */
  9    84       2 help char (32),			/* F1 or esc-? */
  9    85       2 set_key char (32),			/* F2 or esc-k */
  9    86       2 set_scroll_increment char (32),		/* F3 or esc-i */
  9    87       2 quit char (32),			/* F4 or esc-q */
  9    88       2 redisplay char (32),			/* F5 or esc-d */
  9    89       2 start_of_report char (32),		/* F6 or esc-s */
  9    90       2 end_of_report char (32),		/* F7 or esc-e */
  9    91       2 multics_mode char (32),		/* F8 or esc-m */
  9    92       2 goto char (32);			/* F9 or esc-g */

  9    93 
  9    94 dcl keys_as_a_table (HIGHEST_DISPLAY_FUNCTION_NUMBER) char (32) based (addr (scroll_info.keys));

  9    95 
  9    96 dcl mnemonic_key_sequences_as_a_table (HIGHEST_DISPLAY_FUNCTION_NUMBER) aligned char (32) based (addr (scroll_info.mnemonic_key_sequences));

  9    97 
  9    98 dcl 1 scroll_info aligned based (scroll_ip),
  9    99       2 flags,
  9   100         3 video_was_already_on bit (1) unaligned,
  9   101         3 user_io_was_shrunk bit (1) unaligned,
  9   102         3 escapes_in_use bit (1) unaligned,
  9   103         3 on_the_last_page bit (1) unaligned,
  9   104         3 buffer_boundary_just_crossed bit (1) unaligned,
  9   105         3 goto_line_number_pending bit (1) unaligned,
  9   106         3 available bit (30) unaligned,
  9   107       2 number_of_lines_for_report_display fixed bin,
  9   108       2 target_page_number fixed bin (21),
  9   109       2 target_line_number fixed bin (35),
  9   110       2 left_vertical_position fixed bin,
  9   111       2 top_margin_offset fixed bin,
  9   112       2 horizontal_scroll_distance fixed bin,
  9   113       2 vertical_scroll_distance fixed bin,
  9   114       2 last_line_number_in_previous_buffer fixed bin,
  9   115       2 user_io_window_position_info_ptr ptr,
  9   116       2 report_output_window_position_info_ptr ptr,
  9   117       2 display_arg_results_ptr ptr,
  9   118       2 area_ptr ptr,
  9   119       2 report_control_info_ptr ptr,
  9   120       2 function_key_data_pointer ptr,
  9   121       2 window_status_info_pointer ptr,
  9   122       2 page_info_pointer ptr,
  9   123       2 ssu_info_ptr ptr,
  9   124       2 format_document_op ptr,
  9   125       2 keys like function_key_info,
  9   126       2 mnemonic_key_sequences like function_key_info;

  9   127 
  9   128 dcl scroll_ip ptr;

  9   129 
  9   130 /*   END INCLUDE FILE rw_scroll_info.incl.pl1 */
     1788 
     1789 
 10     1 /* BEGIN INCLUDE FILE ... window_control_info.incl.pl1 JRD  */
 10     2 /* format: style3 */
 10     3 
 10     4 /* Modified 26 January 1982 by William York to add the set_more_handler
 10     5*   and reset_more_handler control orders. */
 10     6 /* Modified October 1982 by WMY to add set and get_token_characters,
 10     7*   set and get_more_prompt. */
 10     8 /* Modified February 1983 by WMY to add the line_editor_key_binding_info
 10     9*   structure. */
 10    10 /* Modified 30 September 1983 by Jon A. Rochlis to add the origin.column for
 10    11*   partial screen width windows. */
 10    12 /* Modified 9 October 1983 by JR to add version 1 window_edit_line_info. 
 10    13*   This should be removed when window_info.incl.pl1 is created. */
 10    14 /* Modified 29 February 1984 by Barmar to add version 1 
 10    15*   get_editor_key_bindings_info. */
 10    16 /* Modified 1 March 1984 by Barmar to add version 1 
 10    17*   set_editor_key_bindings_info. */
 10    18 /* Modified 2 March 1984 by Barmar to upgrade to version 3
 10    19*   line_editor_key_bindings_info, which includes the name, description, and
 10    20*   info path */
 10    21 
 10    22 /* structure for the set_window_info and get_window_info
 10    23*   control orders. */
 10    24 
 10    25 dcl	1 window_position_info
 10    26 			based (window_position_info_ptr),
 10    27 	  2 version	fixed bin,
 10    28 	  2 origin,
 10    29 	    3 column	fixed bin,
 10    30 	    3 line	fixed bin,
 10    31 	  2 extent,
 10    32 	    3 width	fixed bin,
 10    33 	    3 height	fixed bin;
 10    34 
 10    35 dcl	(window_position_info_version, window_position_info_version_1)
 10    36 			fixed bin internal static init (1) options (constant);
 10    37 dcl	window_position_info_ptr
 10    38 			pointer;
 10    39 
 10    40 /* structure for the set_window_status and get_window_status
 10    41*   control orders */
 10    42 
 10    43 declare	window_status_info_ptr
 10    44 			pointer;
 10    45 declare	1 window_status_info
 10    46 			aligned based (window_status_info_ptr),
 10    47 	  2 version	fixed bin,
 10    48 	  2 status_string	bit (36) aligned;		/* string (window_status) */
 10    49 /* see window_status.incl.pl1 for the contents of this string */
 10    50 
 10    51 
 10    52 declare	(window_status_version, window_status_version_1)
 10    53 			fixed bin internal static init (1) options (constant);
 10    54 
 10    55 /* info structure for the set_more_responses and get_more_responses control 
 10    56*   orders */
 10    57 
 10    58 
 10    59 dcl	1 more_responses_info
 10    60 			aligned based (more_responses_info_ptr),
 10    61 	  2 version	fixed bin,
 10    62 	  2 n_yeses	fixed bin, /* how many valid characters in the strings below */
 10    63 	  2 n_noes	fixed bin,
 10    64 	  2 yeses		char (32) unaligned,
 10    65 	  2 noes		char (32) unaligned;
 10    66 
 10    67 dcl	(more_responses_info_version_1, more_responses_version)
 10    68 			fixed bin internal static init (1) options (constant);
 10    69 dcl	more_responses_info_ptr
 10    70 			pointer;
 10    71 
 10    72 /* structure for the set_break_table and get_break_table
 10    73*   control orders */
 10    74 
 10    75 declare	break_table_ptr	pointer;
 10    76 declare	1 break_table_info	aligned based (break_table_ptr),
 10    77 	  2 version	fixed bin,
 10    78 	  2 breaks	(0:127) bit (1) unaligned;
 10    79 
 10    80 declare	(break_table_info_version, break_table_info_version_1)
 10    81 			fixed bin init (1) internal static options (constant);
 10    82 
 10    83 declare	1 more_handler_info aligned based (more_handler_info_ptr),
 10    84 	  2 version	fixed bin,
 10    85 	  2 flags		unaligned,
 10    86 	    3 old_handler_valid
 10    87 			bit(1),
 10    88 	    3 pad		bit(35),
 10    89 	  2 more_handler	entry (pointer, bit(1) aligned),
 10    90 	  2 old_more_handler entry (pointer, bit(1) aligned);
 10    91 
 10    92 declare	more_handler_info_ptr pointer;
 10    93 
 10    94 declare	(more_handler_info_version, more_handler_info_version_3)
 10    95 			fixed bin internal static options (constant) init (3);
 10    96 			
 10    97 declare   1 token_characters_info aligned based (token_characters_info_ptr),
 10    98 	  2 version	char(8),
 10    99 	  2 token_character_count
 10   100 			fixed bin,
 10   101 	  2 token_characters
 10   102 			char (128) unaligned;
 10   103 
 10   104 declare   token_characters_info_ptr pointer;
 10   105 
 10   106 declare   token_characters_info_version_1 char(8) internal static options (constant) init ("wtci0001");
 10   107 
 10   108 declare   1 more_prompt_info	aligned based (more_prompt_info_ptr),
 10   109 	  2 version	char(8),
 10   110 	  2 more_prompt	char(80);
 10   111 
 10   112 declare   more_prompt_info_ptr pointer;
 10   113 
 10   114 declare   more_prompt_info_version_1 char(8) static options (constant) init ("wsmp0001");
 10   115 
 10   116 /* Line editor stuff ... */
 10   117 
 10   118 dcl  line_editor_key_binding_info_ptr
 10   119 			pointer;
 10   120 
 10   121 dcl  line_editor_binding_count
 10   122 			fixed bin;
 10   123 dcl  line_editor_longest_sequence
 10   124 			fixed bin;
 10   125 /* For each binding, action defines what to do for that sequence. Constants
 10   126*   are defined in window_editor_values.incl.pl1. Only if action is set to
 10   127*   EXTERNAL_ROUTINE does the editor_routine entry variable get examined. */
 10   128 
 10   129 dcl  1 line_editor_key_binding_info
 10   130 			aligned based (line_editor_key_binding_info_ptr),
 10   131        2 version		char(8),
 10   132        2 binding_count	fixed bin,
 10   133        2 longest_sequence	fixed bin,
 10   134        2 bindings		(line_editor_binding_count refer
 10   135 			(line_editor_key_binding_info.binding_count)),
 10   136          3 sequence		char(line_editor_longest_sequence refer
 10   137 			(line_editor_key_binding_info.longest_sequence)) varying,
 10   138          3 action		fixed bin,
 10   139          3 numarg_action      fixed binary,
 10   140          3 editor_routine	entry (pointer, fixed bin(35)),
 10   141          3 name		char (64) varying unaligned,
 10   142          3 description	char (256) varying unaligned,
 10   143          3 info_path	unaligned,
 10   144 	 4 info_dir	char (168),
 10   145 	 4 info_entry	char (32);
 10   146 	
 10   147 
 10   148 dcl  line_editor_key_binding_info_version_3
 10   149 			char(8) static options (constant) init ("lekbi003");
 10   150 
 10   151 dcl 1 get_editor_key_bindings_info	aligned based (get_editor_key_bindings_info_ptr),
 10   152       2 version			char (8),
 10   153       2 flags,
 10   154         3 entire_state		bit (1) unaligned,
 10   155         3 mbz			bit (35) unaligned,
 10   156       2 key_binding_info_ptr		ptr,
 10   157       2 entire_state_ptr		ptr;
 10   158 
 10   159 dcl get_editor_key_bindings_info_ptr	ptr;
 10   160 dcl get_editor_key_bindings_info_version_1 char (8) int static options (constant) init ("gekbi_01");
 10   161 
 10   162 dcl 1 set_editor_key_bindings_info	aligned
 10   163 				based (set_editor_key_bindings_info_ptr),
 10   164       2 version			char (8),
 10   165       2 flags,
 10   166         3 replace			bit (1) unaligned,
 10   167         3 update			bit (1) unaligned,
 10   168         3 mbz			bit (34) unaligned,
 10   169       2 key_binding_info_ptr		ptr;
 10   170 
 10   171 dcl set_editor_key_bindings_info_ptr	ptr;
 10   172 dcl set_editor_key_bindings_info_version_1 char (8) int static options (constant) init ("sekbi_01");
 10   173 
 10   174 /* This should be moved to window_info.incl.pl1 when that include file is
 10   175*   created.  JR 2/1/84 */
 10   176 
 10   177 dcl	1 window_edit_line_info
 10   178 			based (window_edit_line_info_ptr),
 10   179 	  2 version	char (8),
 10   180 	  2 line_ptr	ptr,
 10   181 	  2 line_length	fixed bin (21);		/* later we will hack initial cursor position, key bindings, etc. */
 10   182 
 10   183 dcl	window_edit_line_info_version_1
 10   184 			char (8) static options (constant) init ("wedl0001");
 10   185 
 10   186 dcl	window_edit_line_info_ptr
 10   187 			ptr;
 10   188 
 10   189 /* END INCLUDE FILE window_control_info.incl.pl1 */
     1790 
     1791 
 11     1 /* begin include fine window_dcls.incl.pl1 BIM June 1981 */
 11     2 /* Modified 9 October 1983 by Jon A. Rochlis to add window_$edit_line. */
 11     3 
 11     4 /* format: style3 */
 11     5 
 11     6 declare	window_$bell	entry (pointer, fixed binary (35));
 11     7 declare	window_$clear_region
 11     8 			entry (pointer, fixed binary, fixed binary, fixed binary, fixed binary, fixed binary (35));
 11     9 declare	window_$clear_to_end_of_line
 11    10 			entry (pointer, fixed binary (35));
 11    11 declare	window_$clear_to_end_of_window
 11    12 			entry (pointer, fixed binary (35));
 11    13 declare	window_$clear_window
 11    14 			entry (pointer, fixed binary (35));
 11    15 declare	window_$delete_chars
 11    16 			entry (pointer, fixed binary, fixed binary (35));
 11    17 declare	window_$get_cursor_position
 11    18 			entry (pointer, fixed binary, fixed binary, fixed binary (35));
 11    19 
 11    20 /* Call window_$get_echoed_chars (iocb_ptr, n_to_read, read_buffer, n_read, read_break, code); */
 11    21 
 11    22 declare	window_$get_echoed_chars
 11    23 			entry (pointer, fixed binary (21), character (*), fixed binary (21), character (1) var,
 11    24 			fixed binary (35));
 11    25 declare	window_$get_unechoed_chars
 11    26 			entry (pointer, fixed binary (21), character (*), fixed binary (21), character (1) var,
 11    27 			fixed binary (35));
 11    28 declare	window_$insert_text entry (pointer, character (*), fixed binary (35));
 11    29 declare	window_$overwrite_text
 11    30 			entry (pointer, character (*), fixed binary (35));
 11    31 declare	window_$position_cursor
 11    32 			entry (pointer, fixed binary, fixed binary, fixed binary (35));
 11    33 
 11    34 /* Call window_$position_cursor_rel (iocb_ptr, delta_line, delta_column, code); */
 11    35 
 11    36 declare	window_$position_cursor_rel
 11    37 			entry (pointer, fixed binary, fixed binary, fixed binary (35));
 11    38 
 11    39 /* Call window_$scroll_region (iocb_ptr, first_line_of_region, n_lines_of_region, distance_to_scroll_region_negative_is_up,
 11    40*        code); */
 11    41 
 11    42 declare	window_$scroll_region
 11    43 			entry (pointer, fixed binary, fixed binary, fixed binary, fixed binary (35));
 11    44 declare	window_$sync	entry (pointer, fixed binary (35));
 11    45 
 11    46 /* Call window_$write_raw_text (iocb_ptr, text_string, code); */
 11    47 
 11    48 declare	window_$write_raw_text
 11    49 			entry (pointer, character (*), fixed binary (35));
 11    50 
 11    51 /* Call window_$write_sync_read (iocb_ptr, prompt_string, n_to_read, read_buffer, n_read, break_char, code); */
 11    52 
 11    53 declare	window_$write_sync_read
 11    54 			entry (pointer, character (*), fixed bin (21), character (*), fixed binary (21),
 11    55 			character (1) var, fixed binary (35));
 11    56 
 11    57 /* Call window_$change_line (iocb_ptr, new_line, code); */
 11    58 
 11    59 declare	window_$change_line entry (pointer, fixed binary, fixed binary (35));
 11    60 
 11    61 /* Call window_$change_column (iocb_ptr, new_column, code); */
 11    62 
 11    63 declare	window_$change_column
 11    64 			entry (pointer, fixed binary, fixed binary (35));
 11    65 
 11    66 /* Call window_$get_one_unechoed (iocb_ptr, char_or_len_0, block_flag, code); */
 11    67 declare	(
 11    68 	window_$get_one_unechoed,
 11    69 	window_$get_one_unechoed_char
 11    70 	)		entry (pointer, character (1) var, bit (1) aligned, fixed binary (35));
 11    71 
 11    72 declare	window_$create	entry (pointer, pointer, pointer, fixed binary (35));
 11    73 
 11    74 declare	window_$destroy	entry (pointer, fixed binary (35));
 11    75 
 11    76 declare   window_$edit_line	entry (pointer, pointer, pointer, fixed bin(21), fixed bin(21), fixed bin(35));
 11    77 
 11    78 /* call window_$edit_line (iocb_ptr, window_edit_line_info_ptr, buffer_ptr,
 11    79*                           buffer_len, n_returned, code); */
 11    80 
 11    81 
 11    82 /* end include file window_dcls.incl.pl1 */
     1792 

     1793 
     1794      end rw_display_scroll;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/16/84  1107.1  rw_display_scroll.pl1             >special_ldd>online>7001-11/16/84>rw_display_scroll.pl1
1772         1    11/01/84  1514.0  format_document_options.incl.pl1  >ldd>include>format_document_options.incl.pl1
1774         2    02/23/81  2146.3  function_key_data.incl.pl1        >ldd>include>function_key_data.incl.pl1
1776         3    05/20/83  1846.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
1778         4    05/23/83  0916.6  iox_dcls.incl.pl1                 >ldd>include>iox_dcls.incl.pl1
1780         5    11/16/84  1107.7  rw_display_arg_list.incl.pl1      >special_ldd>online>7001-11/16/84>rw_display_arg_list.incl.pl1
1782         6    11/16/84  1107.8  rw_options_extents.incl.pl1       >special_ldd>online>7001-11/16/84>rw_options_extents.incl.pl1
1784         7    11/16/84  1107.8  rw_page_info.incl.pl1             >special_ldd>online>7001-11/16/84>rw_page_info.incl.pl1
1786         8    11/16/84  1107.6  rw_report_info.incl.pl1           >special_ldd>online>7001-11/16/84>rw_report_info.incl.pl1
1788         9    11/16/84  1107.9  rw_scroll_info.incl.pl1           >special_ldd>online>7001-11/16/84>rw_scroll_info.incl.pl1
1790        10    09/12/84  0916.7  window_control_info.incl.pl1      >ldd>include>window_control_info.incl.pl1
1792        11    09/12/84  0916.7  window_dcls.incl.pl1              >ldd>include>window_dcls.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BACKWARD                  3     000150 constant        char(12)                 initial level 2 in structure "KEY_MNEMONICS"
                                                                                  dcl 9-62 in procedure "rw_display_scroll" ref 638
BACKWARD                 10     000000 constant        char(32)                 initial level 2 in structure "FUNCTION_NAMES"
                                                                                  dcl 9-41 in procedure "rw_display_scroll" set ref
                                                                                  1603
BLANK                           012764 constant        char(1)                  initial unaligned dcl 1619 ref 311
CARRIAGE_RETURN                 012763 constant        char(1)                  initial unaligned dcl 1621 ref 445
CONTROL_HYPHEN                  002172 constant        char(8)                  initial unaligned dcl 1622 ref 597 618 625
CTL_HYPHEN                      002170 constant        char(4)                  initial unaligned dcl 1623 ref 618 625
DEL                             012762 constant        char(1)                  initial unaligned dcl 1625 ref 448
DIGITS                          002165 constant        char(10)                 initial unaligned dcl 1626 ref 517
END_OF_REPORT           120     000000 constant        char(32)                 initial level 2 dcl 9-41 set ref 1603
ESCAPE                          012761 constant        char(1)                  initial unaligned dcl 1628 ref 738
ESCAPE_HYPHEN                   002162 constant        char(7)                  initial unaligned dcl 1630 ref 618 625 723
ESC_HYPHEN                      002164 constant        char(4)                  initial unaligned dcl 1629 ref 618 625 723
FORWARD                         000150 constant        char(12)                 initial level 2 in structure "KEY_MNEMONICS"
                                                                                  dcl 9-62 in procedure "rw_display_scroll" ref 634
FORWARD                         000000 constant        char(32)                 initial level 2 in structure "FUNCTION_NAMES"
                                                                                  dcl 9-41 in procedure "rw_display_scroll" set ref
                                                                                  1603
FUNCTION_NAMES                  000000 constant        structure                level 1 dcl 9-41 set ref 670 1107 1118
FUNCTION_NAMES_AS_A_TABLE              based           char(32)                 array dcl 9-56 set ref 670 1107 1118*
GENERAL_HELP_LIST               012760 constant        char(2)                  initial unaligned dcl 1634 ref 1059
GENERAL_HELP_LIST_MESSAGE       002037 constant        char(203)                initial unaligned dcl 1635 set ref 1061*
GENERAL_HELP_MESSAGE            002122 constant        char(128)                initial unaligned dcl 1632 set ref 1042*
GOTO                    140     000000 constant        char(32)                 initial level 2 dcl 9-41 set ref 1603
HELP                     40     000000 constant        char(32)                 initial level 2 dcl 9-41 set ref 1603
HELP_HEADER_CONTROL_STRING      002032 constant        char(15)                 initial unaligned dcl 1639 set ref 1118*
HELP_MESSAGES                   000340 constant        char(254)                initial array unaligned dcl 1640 set ref 1118*
HIGHEST_DISPLAY_FUNCTION_NUMBER        constant        fixed bin(17,0)          initial dcl 9-58 ref 669 781 807 1105
HOME                            002036 constant        char(4)                  initial unaligned dcl 1638 ref 650
HOW_TO_END_DISPLAY_MESSAGE      000320 constant        char(62)                 initial unaligned dcl 1668 ref 1152 1153
HOW_TO_GET_BACK_MESSAGE         000306 constant        char(38)                 initial unaligned dcl 1670 set ref 1242*
KEY_MNEMONICS                   000150 constant        structure                level 1 dcl 9-62
KEY_PLAIN                              constant        fixed bin(17,0)          initial dcl 2-22 ref 634 634 638 638 642 642 646 646
                                                                                  650 650 661 661
LARGEST_LINE_NUMBER             000305 constant        fixed bin(35,0)          initial dcl 1673 ref 920
LARGEST_PAGE_NUMBER             000304 constant        fixed bin(21,0)          initial dcl 1674 ref 915
LEFT                     20     000000 constant        char(32)                 initial level 2 in structure "FUNCTION_NAMES"
                                                                                  dcl 9-41 in procedure "rw_display_scroll" set ref
                                                                                  1603
LEFT                      6     000150 constant        char(12)                 initial level 2 in structure "KEY_MNEMONICS"
                                                                                  dcl 9-62 in procedure "rw_display_scroll" ref 642
MINIMUM_LINES_NEEDED                   constant        fixed bin(17,0)          initial dcl 1676 ref 1487
MINIMUM_LINES_NEEDED_ERROR_MESSAGE
                                000270 constant        char(45)                 initial unaligned dcl 1677 set ref 1487*
MINIMUM_WINDOW_SIZE                    constant        fixed bin(17,0)          initial dcl 1678 ref 1478
MINIMUM_WINDOW_SIZE_ERROR_MESSAGE
                                000254 constant        char(45)                 initial unaligned dcl 1679 set ref 1478*
MORE_PROMPT                     000240 constant        char(47)                 initial unaligned dcl 1681 set ref 442*
MULTICS_MODE            130     000000 constant        char(32)                 initial level 2 dcl 9-41 set ref 1603
NEWLINE                                constant        char(1)                  initial unaligned dcl 1684 ref 1160
NON_NUMERIC_RESPONSE            002231 constant        bit(1)                   initial dcl 1687 set ref 1320* 1332* 1375*
NO_PROMPT                              constant        bit(1)                   initial dcl 1686 set ref 1050*
NUMBER_OF_ALLOWED_SPECIFIED_PAGES      constant        fixed bin(17,0)          initial dcl 5-49 ref 5-10
NUMBER_OF_GENERAL_COLUMN_OPTIONS_IN_TABLE
                                       constant        fixed bin(17,0)          initial dcl 6-20 ref 293 409 964 1516
NUMBER_OF_GENERAL_REPORT_OPTIONS_IN_TABLE
                                       constant        fixed bin(17,0)          initial dcl 6-21 ref 293 409 964 1516
NUMERIC_RESPONSE                000237 constant        bit(1)                   initial dcl 1688 set ref 996* 1386*
OFF                                    constant        bit(1)                   initial dcl 1690 ref 254 437 448 494 522 550 664 760
                                                                                  767 812 852 881 895 896 911 941 948 971 1009 1010
                                                                                  1049 1080 1110 1161 1183 1220 1221 1250 1263 1273
                                                                                  1298 1299 1317 1329 1357 1385 1431 1448 1473 1526
                                                                                  1535
ON                              000237 constant        bit(1)                   initial dcl 1691 set ref 301 328 358 362* 434 445
                                                                                  450 451 497 504 578 655 725 802 845 919 964 994
                                                                                  1006 1039 1046 1055 1102 1147 1190* 1211 1289 1382
                                                                                  1388 1393 1453 1482 1528 1529 1530 1531 1532 1533
PROMPT                                 constant        bit(1)                   initial dcl 1693 set ref 1069* 1125*
QUIT                     70     000000 constant        char(32)                 initial level 2 dcl 9-41 set ref 1603
REDISPLAY               100     000000 constant        char(32)                 initial level 2 dcl 9-41 set ref 1603
RIGHT                    30     000000 constant        char(32)                 initial level 2 in structure "FUNCTION_NAMES"
                                                                                  dcl 9-41 in procedure "rw_display_scroll" set ref
                                                                                  1603
RIGHT                    11     000150 constant        char(12)                 initial level 2 in structure "KEY_MNEMONICS"
                                                                                  dcl 9-62 in procedure "rw_display_scroll" ref 646
SET_KEY                  50     000000 constant        char(32)                 initial level 2 dcl 9-41 set ref 1603
SET_SCROLL_INCREMENT     60     000000 constant        char(32)                 initial level 2 dcl 9-41 set ref 1603
START_OF_REPORT         110     000000 constant        char(32)                 initial level 2 dcl 9-41 set ref 1603
TOP_MARGIN_HEIGHT                      constant        fixed bin(17,0)          initial dcl 1697 ref 1388
TRANSLATION_TABLE               000217 constant        char(63)                 initial unaligned dcl 1695 ref 748
USER_IO_WINDOW_HEIGHT                  constant        fixed bin(17,0)          initial dcl 1699 ref 1494 1496 1506
addr                                                   builtin function         dcl 1701 ref 509 509 670 672 673 809 1051 1051 1107
                                                                                  1107 1118 1118
adj_sw                    3(01)        based           bit(1)                   level 3 packed unaligned dcl 1-12 set ref 1535*
area_ptr                 20            based           pointer                  level 2 dcl 9-98 set ref 405 1422*
attach_descrip_ptr       14            based           pointer                  level 2 dcl 3-6 ref 1466
backward                216            based           char(32)                 level 3 in structure "scroll_info" dcl 9-98
                                                                                  in procedure "rw_display_scroll" set ref 1061*
backward                 46            based           char(32)                 level 3 in structure "scroll_info" dcl 9-98
                                                                                  in procedure "rw_display_scroll" set ref 365 379
break_word_sw             3(07)        based           bit(1)                   level 3 packed unaligned dcl 1-12 set ref 1529*
buffer_boundary_just_crossed
                          0(04)        based           bit(1)                   level 3 packed unaligned dcl 9-98 set ref 328* 893
                                                                                  895* 939 941* 1218 1221* 1296 1299*
byte                                                   builtin function         dcl 1703 ref 757
code                            000100 automatic       fixed bin(35,0)          dcl 1705 set ref 86 119* 120 232 235 235* 239 255*
                                                                                  309* 315* 339* 362* 438* 440* 442* 454* 509* 511
                                                                                  511 514* 526* 527 546* 548 548* 553* 554* 555* 558
                                                                                  558 561* 820* 1013* 1042* 1044 1044* 1051* 1053
                                                                                  1053* 1075* 1121* 1123 1123* 1156* 1174* 1176*
                                                                                  1178* 1190* 1235* 1238* 1240* 1242* 1246* 1262*
                                                                                  1323* 1334* 1335 1336* 1404* 1449* 1450 1450*
                                                                                  1463* 1464 1464* 1474* 1476 1476* 1483* 1485 1485*
                                                                                  1490* 1491 1491* 1497* 1499 1499* 1502* 1503 1503*
                                                                                  1508* 1510 1510* 1550* 1551 1551* 1556* 1557 1557*
                                                                                  1564* 1566 1566* 1568* 1569 1569* 1575* 1576 1576*
code_parm                              parameter       fixed bin(35,0)          dcl 43 in procedure "rw_display_scroll" set ref 56
                                                                                  83* 86* 90 120* 239*
code_parm                              parameter       fixed bin(35,0)          dcl 188 in procedure "abort_line" set ref 182 192
                                                                                  194*
command_level_flags             000101 automatic       structure                level 1 dcl 1706 set ref 1250* 1251*
convert                                                builtin function         dcl 1709 ref 533 658
convert_status_code_            000010 constant        entry                    external dcl 1710 ref 194
cu_$cl                          000012 constant        entry                    external dcl 1711 ref 1251
cursor_motion_keys        5            based           structure                level 2 dcl 2-7
dcop_buffer_empty_pending       000534 automatic       bit(1)                   dcl 246 set ref 254* 301* 322
dcop_current_line_on_page       000535 automatic       fixed bin(17,0)          dcl 247 set ref 287* 289 293 311 315 315 321* 321
                                                                                  322 330*
dcop_current_line_on_screen     000536 automatic       fixed bin(17,0)          dcl 248 set ref 288* 289 293 300 309* 320* 320
dcop_loop                       000540 automatic       fixed bin(17,0)          dcl 250 set ref 308*
dcop_loop_limit                 000541 automatic       fixed bin(17,0)          dcl 251 set ref 289* 300* 308
dcop_number_of_chars_to_write   000537 automatic       fixed bin(17,0)          dcl 249 set ref 264* 311 315 315
display_arg_results             000342 automatic       structure                level 1 dcl 5-10
display_arg_results_ptr
                         16            based           pointer                  level 2 dcl 9-98 set ref 403 1420*
display_arg_results_ptr_parm           parameter       pointer                  dcl 44 ref 124 151
display_buffer_empty            000542 stack reference condition                dcl 252 ref 327
display_iocb_ptr                       based           pointer                  level 2 dcl 8-7 set ref 409 1516*
display_results                        based           structure                level 1 unaligned dcl 1713
display_results_ptr             000102 automatic       pointer                  dcl 1714 set ref 151* 403* 1419 1420 1461 1463 1464
                                                                                  1466 1471 1554
dont_compress_sw          3(06)        based           bit(1)                   level 3 packed unaligned dcl 1-12 set ref 1533*
down                     25            based           structure                array level 3 dcl 2-7
end_of_report           326            based           char(32)                 level 3 in structure "scroll_info" dcl 9-98
                                                                                  in procedure "rw_display_scroll" set ref 1061*
end_of_report           156            based           char(32)                 level 3 in structure "scroll_info" dcl 9-98
                                                                                  in procedure "rw_display_scroll" set ref 365 379
error_message                   000104 automatic       varying char(256)        dcl 1716 set ref 195* 197* 200* 200 203*
error_table_$end_of_info        000014 external static fixed bin(35,0)          dcl 1717 ref 1262
error_table_$long_record        000016 external static fixed bin(35,0)          dcl 1718 ref 511
extent                    3            based           structure                level 2 in structure "user_io_window_position_info"
                                                                                  unaligned dcl 1757 in procedure
                                                                                  "rw_display_scroll"
extent                    3            based           structure                level 2 in structure
                                                                                  "report_output_window_position_info" unaligned
                                                                                  dcl 1739 in procedure "rw_display_scroll"
fb_beginning_line_number        000100 automatic       fixed bin(17,0)          dcl 830 set ref 869* 871 892
ff_beginning_line_number        000100 automatic       fixed bin(17,0)          dcl 929 set ref 962* 964 973
ff_number_of_left_over_lines    000101 automatic       fixed bin(17,0)          dcl 930 set ref 942* 944 951
fg_line_or_page_number          000103 automatic       fixed bin(35,0)          dcl 982 set ref 996* 998 1002 1007
fg_prompt                       000100 automatic       char(11)                 unaligned dcl 981 set ref 990* 992* 996*
fg_still_looking_for_a_valid_response
                                000104 automatic       bit(1)                   dcl 983 set ref 994* 995 1009*
fh_character_read               000114 automatic       varying char(1)          dcl 1024 set ref 1050* 1069* 1080 1125*
fh_help_string                  000116 automatic       char(1024)               unaligned dcl 1025 set ref 1042* 1061* 1121* 1152*
                                                                                  1160 1178 1178
fh_help_string_length           000516 automatic       fixed bin(21,0)          dcl 1026 set ref 1042* 1061* 1121* 1152 1153* 1153
                                                                                  1183
fh_number_of_chars_read         000517 automatic       fixed bin(21,0)          dcl 1027 set ref 1051* 1055 1058* 1058 1059 1103
                                                                                  1118*
fh_returned_help_list           000521 automatic       char(512)                unaligned dcl 1029 set ref 1118* 1121*
fh_still_helpful                000721 automatic       bit(1)                   dcl 1030 set ref 1039* 1041 1080*
fh_still_looking_for_a_valid_response
                                000520 automatic       bit(1)                   dcl 1028 set ref 1046* 1048 1049* 1055* 1071* 1073
fh_users_response               000722 automatic       char(256)                unaligned dcl 1031 set ref 1051 1051 1051 1051 1059
                                                                                  1103
fkp_prompt                      000101 automatic       char(21)                 unaligned dcl 1309 set ref 1316* 1320* 1328* 1332*
fkp_valid_response              000100 automatic       bit(1)                   dcl 1308 set ref 1317* 1319 1322* 1323 1329* 1331
                                                                                  1335* 1336
flags                                  based           structure                level 2 in structure "display_results" unaligned
                                                                                  dcl 1713 in procedure "rw_display_scroll"
flags                                  based           structure                level 2 in structure "scroll_info" dcl 9-98
                                                                                  in procedure "rw_display_scroll"
flags                                  based           structure                level 2 in structure "report_control_info" dcl 8-7
                                                                                  in procedure "rw_display_scroll"
format_document_$string         000020 constant        entry                    external dcl 1720 ref 1042 1121
format_document_op       34            based           pointer                  level 2 dcl 9-98 set ref 413 1536*
format_document_options                based           structure                level 1 dcl 1-12 set ref 1525 1526* 1586
format_document_options_ptr     000336 automatic       pointer                  dcl 1-62 set ref 413* 1042* 1121* 1525* 1526 1527
                                                                                  1528 1529 1530 1531 1532 1533 1534 1535 1536 1586
                                                                                  1586
format_document_version_2              constant        fixed bin(17,0)          initial dcl 1-63 ref 1527
forward                 206            based           char(32)                 level 3 in structure "scroll_info" dcl 9-98
                                                                                  in procedure "rw_display_scroll" set ref 1061*
forward                  36            based           char(32)                 level 3 in structure "scroll_info" dcl 9-98
                                                                                  in procedure "rw_display_scroll" set ref 365 379
function_key_data                      based           structure                level 1 dcl 2-7
function_key_data_pointer
                         24            based           pointer                  level 2 dcl 9-98 ref 116 412
function_key_data_ptr           000340 automatic       pointer                  dcl 2-34 set ref 116* 412* 634 634 634 634 638 638
                                                                                  638 638 642 642 642 642 646 646 646 646 650 650
                                                                                  650 650 656 661 661 661 661
function_key_info               000346 automatic       structure                level 1 dcl 9-79
function_key_seqs                      based           char                     unaligned dcl 2-32 ref 634 638 642 646 650 661
function_key_sequence           000215 automatic       char(32)                 unaligned dcl 1722 set ref 118* 119*
function_key_sequence_parm             parameter       char                     unaligned dcl 46 ref 90 118
function_keys            31            based           structure                array level 2 dcl 2-7 ref 656
function_name                   000205 automatic       char(32)                 unaligned dcl 1721 set ref 117* 119* 1321* 1322*
                                                                                  1334*
function_name_parm                     parameter       char                     unaligned dcl 45 ref 90 117
galley_sw                 3(02)        based           bit(1)                   level 3 packed unaligned dcl 1-12 set ref 1528*
goto                    176            based           char(32)                 level 3 in structure "scroll_info" dcl 9-98
                                                                                  in procedure "rw_display_scroll" set ref 365 379
goto                    346            based           char(32)                 level 3 in structure "scroll_info" dcl 9-98
                                                                                  in procedure "rw_display_scroll" set ref 1061*
goto_line_number_pending
                          0(05)        based           bit(1)                   level 3 packed unaligned dcl 9-98 set ref 919* 1006*
gur_buffer_parm                        parameter       char                     unaligned dcl 350 set ref 348 357* 360 364* 365 365
                                                                                  365 365 365 365 365 365 365 365 365 365 365 379
                                                                                  379 379 379 379 379 379 379 379 379 379 379 379
gur_character_read              000106 automatic       varying char(1)          dcl 351 set ref 362* 364
gur_loop                        000110 automatic       fixed bin(17,0)          dcl 352 set ref 360* 364 379 379 379 379 379 379 379
                                                                                  379 379 379 379 379 379 379 379 379 379 379 379
                                                                                  379 379 379 379 379 379 379*
gur_partial_match               000111 automatic       bit(1)                   dcl 353 set ref 358* 360 379*
hbound                                                 builtin function         dcl 1724 ref 656
height                    4            based           fixed bin(17,0)          level 3 in structure
                                                                                  "report_output_window_position_info" dcl 1739
                                                                                  in procedure "rw_display_scroll" set ref 289 293
                                                                                  300 339* 505 1164 1478 1506* 1506 1518 1519 1561
height                    4            based           fixed bin(17,0)          level 3 in structure "user_io_window_position_info"
                                                                                  dcl 1757 in procedure "rw_display_scroll" set ref
                                                                                  1487 1494 1496* 1561* 1561
help                     76            based           char(32)                 level 3 in structure "scroll_info" dcl 9-98
                                                                                  in procedure "rw_display_scroll" set ref 365 379
help                    246            based           char(32)                 level 3 in structure "scroll_info" dcl 9-98
                                                                                  in procedure "rw_display_scroll" set ref 1061*
hff_function_number             001030 automatic       fixed bin(17,0)          dcl 1092 set ref 1111* 1118 1118 1118
hff_invalid_function_parm              parameter       bit(1)                   dcl 1093 set ref 1087 1102* 1105 1110* 1115
hff_loop                        001031 automatic       fixed bin(17,0)          dcl 1094 set ref 1105* 1107 1107 1111*
hff_target_function             001032 automatic       char(32)                 unaligned dcl 1095 set ref 1103* 1107 1107
highest                   1            based           fixed bin(17,0)          level 2 dcl 2-7 ref 656
home                      5            based           structure                array level 3 dcl 2-7
horizontal_scroll_distance
                          6            based           fixed bin(17,0)          level 2 dcl 9-98 set ref 1215 1293 1399* 1520*
index                                                  builtin function         dcl 1726 ref 618 618 618 618 716 730 748 1160
ioa_$rsnnl                      000022 constant        entry                    external dcl 1727 ref 1061 1118
iocb                                   based           structure                level 1 dcl 3-6
iox_$control                    000052 constant        entry                    external dcl 4-8 ref 235 546 1474 1483 1497 1564
iox_$destroy_iocb               000054 constant        entry                    external dcl 4-8 ref 1568
iox_$find_iocb                  000056 constant        entry                    external dcl 4-8 ref 1502
iox_$get_line                   000060 constant        entry                    external dcl 4-8 ref 509 1051
iox_$look_iocb                  000062 constant        entry                    external dcl 4-8 ref 1463
iox_$user_io                    000066 external static pointer                  dcl 4-41 set ref 1235 1244 1483* 1490* 1497* 1564*
iox_$user_output                000064 external static pointer                  dcl 4-41 ref 1235 1244
key_info                               based           structure                level 1 packed unaligned dcl 2-28
keys                     36            based           structure                level 2 dcl 9-98 set ref 672 809
keys_as_a_table                        based           char(32)                 array unaligned dcl 9-94 set ref 672* 809
last_line_number_in_previous_buffer
                         10            based           fixed bin(17,0)          level 2 dcl 9-98 set ref 326* 878 942
left                    226            based           char(32)                 level 3 in structure "scroll_info" dcl 9-98
                                                                                  in procedure "rw_display_scroll" set ref 1061*
left                     11            based           structure                array level 3 in structure "function_key_data"
                                                                                  dcl 2-7 in procedure "rw_display_scroll"
left                     56            based           char(32)                 level 3 in structure "scroll_info" dcl 9-98
                                                                                  in procedure "rw_display_scroll" set ref 365 379
left_vertical_position
                          4            based           fixed bin(17,0)          level 2 dcl 9-98 set ref 262 262* 264 311 315 315
                                                                                  1209 1215* 1215 1287 1293* 1293 1523*
length                                                 builtin function         dcl 1729 in procedure "rw_display_scroll" ref 199
                                                                                  360 509 509 597 722 726 1051 1051 1153
length                    1            based           fixed bin(17,0)          level 2 in structure "page_info" dcl 7-29
                                                                                  in procedure "rw_display_scroll" ref 271 271 289
                                                                                  293 322 326 964 1388
line                      2            based           fixed bin(17,0)          level 3 in structure "user_io_window_position_info"
                                                                                  dcl 1757 in procedure "rw_display_scroll" set ref
                                                                                  1494* 1494 1559*
line                      2            based           fixed bin(17,0)          level 3 in structure
                                                                                  "report_output_window_position_info" dcl 1739
                                                                                  in procedure "rw_display_scroll" set ref 1559
line_length               2            based           fixed bin(17,0)          level 2 dcl 1-12 set ref 1534*
literal_sw                3(04)        based           bit(1)                   level 3 packed unaligned dcl 1-12 set ref 1532*
long_message                    000225 automatic       char(100)                dcl 1730 set ref 194* 195
ltrim                                                  builtin function         dcl 1731 ref 658
max                                                    builtin function         dcl 1733 ref 271 1215
max_line_length_sw        3(08)        based           bit(1)                   level 3 packed unaligned dcl 1-12 set ref 1530*
message_parm                           parameter       char                     unaligned dcl 190 ref 182 199 200
message_parm_length             000100 automatic       fixed bin(17,0)          dcl 189 set ref 199* 200
min                                                    builtin function         dcl 1734 ref 264 289
miscellaneous           252            based           structure                level 2 unaligned dcl 1713
mnemonic_key_sequences
                        206            based           structure                level 2 dcl 9-98 set ref 673 1107 1118
mnemonic_key_sequences_as_a_table      based           char(32)                 array dcl 9-96 set ref 673* 1107 1118*
multics_mode            166            based           char(32)                 level 3 in structure "scroll_info" dcl 9-98
                                                                                  in procedure "rw_display_scroll" set ref 365 379
multics_mode            336            based           char(32)                 level 3 in structure "scroll_info" dcl 9-98
                                                                                  in procedure "rw_display_scroll" set ref 1061*
no_of_formatted_pages                  based           fixed bin(21,0)          level 2 dcl 8-7 ref 293 964
null                                                   builtin function         dcl 1736 ref 174 8-61 1446 1466 1466 1580 1582 1584
                                                                                  1586
number_of_lines_for_report_display
                          1            based           fixed bin(17,0)          level 2 dcl 9-98 set ref 1518*
open_descrip_ptr         20            based           pointer                  level 2 dcl 3-6 ref 1466
origin                    1            based           structure                level 2 in structure "user_io_window_position_info"
                                                                                  unaligned dcl 1757 in procedure
                                                                                  "rw_display_scroll"
origin                    1            based           structure                level 2 in structure
                                                                                  "report_output_window_position_info" unaligned
                                                                                  dcl 1739 in procedure "rw_display_scroll"
page_defined_as_lines                  based           char                     array unaligned dcl 7-39 ref 311 315 315
page_info                              based           structure                level 1 dcl 7-29
page_info_pointer        30            based           pointer                  level 2 dcl 9-98 ref 331 410
page_ip                         000342 automatic       pointer                  dcl 7-41 set ref 260 262 262 264 271 271 289 293 311
                                                                                  311 311 311 315 315 315 315 315 315 315 315 322
                                                                                  326 331* 410* 964 1287 1388 1393
page_ptr                  4            based           pointer                  level 2 dcl 7-29 ref 311 315 315
pathnames                23            based           structure                level 2 packed unaligned dcl 1713
pfm_break_character             000106 automatic       varying char(1)          dcl 425 set ref 442* 445 448
pfm_buffer                      000110 automatic       char(1)                  unaligned dcl 426 set ref 442*
pfm_line_in_window_parm                parameter       fixed bin(17,0)          dcl 427 set ref 419 438*
pfm_number_of_chars_read        000111 automatic       fixed bin(21,0)          dcl 428 set ref 442* 445
pfm_still_looking_for_a_valid_response
                                000112 automatic       bit(1)                   dcl 429 set ref 434* 436 437* 450* 451* 452
pfm_user_wants_more_parm               parameter       bit(1)                   dcl 430 set ref 419 445* 448*
pu_number_of_chars_read         000100 automatic       fixed bin(21,0)          dcl 471 set ref 509* 516* 516 517 517 517 533 536
pu_number_parm                         parameter       fixed bin(35,0)          dcl 472 set ref 463 502* 533* 533
pu_numeric_parm                        parameter       bit(1)                   dcl 473 ref 463 517 533
pu_prompt_parm                         parameter       char                     unaligned dcl 474 ref 463 555
pu_response_buffer              000101 automatic       char(256)                unaligned dcl 475 set ref 509 509 509 509 517 533
                                                                                  536
pu_response_line                000201 automatic       fixed bin(17,0)          dcl 476 set ref 498* 505* 553*
pu_response_parm                       parameter       char                     unaligned dcl 477 set ref 463 503* 536*
pu_still_looking_for_a_valid_response
                                000202 automatic       bit(1)                   dcl 478 set ref 504* 507 517* 522* 524
pu_window_status_pending        000204 stack reference condition                dcl 479 ref 496 527 558
pu_window_status_pending_flag   000212 automatic       bit(1)                   dcl 480 set ref 494* 497* 544 550*
quit                    276            based           char(32)                 level 3 in structure "scroll_info" dcl 9-98
                                                                                  in procedure "rw_display_scroll" set ref 1061*
quit                    126            based           char(32)                 level 3 in structure "scroll_info" dcl 9-98
                                                                                  in procedure "rw_display_scroll" set ref 365 379
rci_ptr_parm                           parameter       pointer                  dcl 47 ref 124 150
reason                          000256 automatic       char(64)                 unaligned dcl 1738 set ref 1449* 1450*
redisplay               136            based           char(32)                 level 3 in structure "scroll_info" dcl 9-98
                                                                                  in procedure "rw_display_scroll" set ref 365 379
redisplay               306            based           char(32)                 level 3 in structure "scroll_info" dcl 9-98
                                                                                  in procedure "rw_display_scroll" set ref 1061*
report_cip                      000344 automatic       pointer                  initial dcl 8-61 set ref 150* 8-61* 271 280 293 293
                                                                                  293 293 404* 409 848 856 913 964 964 990 1000 1421
                                                                                  1516
report_control_info                    based           structure                level 1 dcl 8-7
report_control_info_ptr
                         22            based           pointer                  level 2 dcl 9-98 set ref 404 1421*
report_is_formatted       0(04)        based           bit(1)                   level 3 packed unaligned dcl 8-7 ref 293 293 964
report_is_paginated                    based           bit(1)                   level 3 packed unaligned dcl 8-7 ref 271 280 293 848
                                                                                  856 913 990 1000
report_output_window_position_info     based           structure                level 1 unaligned dcl 1739 set ref 1434 1438* 1493*
                                                                                  1582
report_output_window_position_info_ptr
                         14            based           pointer                  level 2 dcl 9-98 set ref 407 1436*
report_output_window_position_ip
                                000276 automatic       pointer                  dcl 1740 set ref 260 262 262 264 289 293 300 339 339
                                                                                  407* 505 1164 1287 1434* 1436 1438 1474* 1478 1493
                                                                                  1506 1506 1508* 1518 1519 1520 1534 1559 1561 1582
                                                                                  1582
right                   236            based           char(32)                 level 3 in structure "scroll_info" dcl 9-98
                                                                                  in procedure "rw_display_scroll" set ref 1061*
right                    21            based           structure                array level 3 in structure "function_key_data"
                                                                                  dcl 2-7 in procedure "rw_display_scroll"
right                    66            based           char(32)                 level 3 in structure "scroll_info" dcl 9-98
                                                                                  in procedure "rw_display_scroll" set ref 365 379
rtrim                                                  builtin function         dcl 1741 ref 195 199 200 555 714 726 1464 1466 1471
                                                                                  1503
rw_error_$bad_fkey_name         000024 external static fixed bin(35,0)          dcl 1742 ref 679
rw_error_$bad_fkey_sequence     000026 external static fixed bin(35,0)          dcl 1743 ref 745 752
rw_error_$bad_report_display    000030 external static fixed bin(35,0)          dcl 1744 set ref 203*
sci_ptr                         000300 automatic       pointer                  dcl 1746 set ref 149* 203* 408* 1423 1551* 1557*
                                                                                  1566* 1569* 1576*
sci_ptr_parm                           parameter       pointer                  dcl 48 ref 124 149
scroll_info                            based           structure                level 1 dcl 9-98
scroll_info_ptr         260            based           pointer                  level 3 dcl 1713 ref 1419
scroll_info_ptr_parm                   parameter       pointer                  dcl 49 ref 56 82 90 115 157 174 176
scroll_ip                       000516 automatic       pointer                  dcl 9-128 set ref 82* 115* 116 176* 262 262 264 269
                                                                                  269 271 271 271 280 280 280 283 287 288 293 311
                                                                                  315 315 325 325 326 328 329 329 331 365 365 365
                                                                                  365 365 365 365 365 365 365 365 365 365 379 379
                                                                                  379 379 379 379 379 379 379 379 379 379 379 403
                                                                                  404 405 406 407 408 410 411 412 413 672 673 809
                                                                                  842 842 850 850 851 858 858 858 869 869 871 874
                                                                                  878 878 878 878 882 882 892 893 895 915 916 919
                                                                                  920 939 941 942 942 944 946 946 946 951 951 952
                                                                                  952 962 962 962 964 969 969 970 973 1002 1003 1006
                                                                                  1007 1061 1061 1061 1061 1061 1061 1061 1061 1061
                                                                                  1061 1061 1061 1061 1107 1118 1209 1215 1215 1215
                                                                                  1218 1221 1287 1293 1293 1293 1296 1299 1358 1359
                                                                                  1396 1399 1419* 1420 1421 1422 1423 1429 1436 1442
                                                                                  1448 1453 1473 1482 1518 1519 1520 1521 1522 1523
                                                                                  1536 1564 1573
seq_len                   4            based           fixed bin(21,0)          level 3 dcl 2-7 ref 634 638 642 646 650 661
seq_ptr                   2            based           pointer                  level 3 dcl 2-7 ref 634 638 642 646 650 661
sequence                  2            based           structure                level 2 dcl 2-7
sequence_index           25            based           fixed bin(12,0)          array level 4 in structure "function_key_data"
                                                                                  packed unsigned unaligned dcl 2-7 in procedure
                                                                                  "rw_display_scroll" ref 634
sequence_index           21            based           fixed bin(12,0)          array level 4 in structure "function_key_data"
                                                                                  packed unsigned unaligned dcl 2-7 in procedure
                                                                                  "rw_display_scroll" ref 646
sequence_index           11            based           fixed bin(12,0)          array level 4 in structure "function_key_data"
                                                                                  packed unsigned unaligned dcl 2-7 in procedure
                                                                                  "rw_display_scroll" ref 642
sequence_index            5            based           fixed bin(12,0)          array level 4 in structure "function_key_data"
                                                                                  packed unsigned unaligned dcl 2-7 in procedure
                                                                                  "rw_display_scroll" ref 650
sequence_index           15            based           fixed bin(12,0)          array level 4 in structure "function_key_data"
                                                                                  packed unsigned unaligned dcl 2-7 in procedure
                                                                                  "rw_display_scroll" ref 638
sequence_index           31            based           fixed bin(12,0)          array level 3 in structure "function_key_data"
                                                                                  packed unsigned unaligned dcl 2-7 in procedure
                                                                                  "rw_display_scroll" ref 661
sequence_length          25(12)        based           fixed bin(6,0)           array level 4 in structure "function_key_data"
                                                                                  packed unsigned unaligned dcl 2-7 in procedure
                                                                                  "rw_display_scroll" ref 634
sequence_length          11(12)        based           fixed bin(6,0)           array level 4 in structure "function_key_data"
                                                                                  packed unsigned unaligned dcl 2-7 in procedure
                                                                                  "rw_display_scroll" ref 642
sequence_length          21(12)        based           fixed bin(6,0)           array level 4 in structure "function_key_data"
                                                                                  packed unsigned unaligned dcl 2-7 in procedure
                                                                                  "rw_display_scroll" ref 646
sequence_length           5(12)        based           fixed bin(6,0)           array level 4 in structure "function_key_data"
                                                                                  packed unsigned unaligned dcl 2-7 in procedure
                                                                                  "rw_display_scroll" ref 650
sequence_length          31(12)        based           fixed bin(6,0)           array level 3 in structure "function_key_data"
                                                                                  packed unsigned unaligned dcl 2-7 in procedure
                                                                                  "rw_display_scroll" ref 661
sequence_length          15(12)        based           fixed bin(6,0)           array level 4 in structure "function_key_data"
                                                                                  packed unsigned unaligned dcl 2-7 in procedure
                                                                                  "rw_display_scroll" ref 638
set_key                 106            based           char(32)                 level 3 in structure "scroll_info" dcl 9-98
                                                                                  in procedure "rw_display_scroll" set ref 365 379
set_key                 256            based           char(32)                 level 3 in structure "scroll_info" dcl 9-98
                                                                                  in procedure "rw_display_scroll" set ref 1061*
set_scroll_increment    266            based           char(32)                 level 3 in structure "scroll_info" dcl 9-98
                                                                                  in procedure "rw_display_scroll" set ref 1061*
set_scroll_increment    116            based           char(32)                 level 3 in structure "scroll_info" dcl 9-98
                                                                                  in procedure "rw_display_scroll" set ref 365 379
sfk_char_10                            automatic       char(10)                 unaligned dcl 596 ref 658
sfk_character_loop              000100 automatic       char                     unaligned dcl 597 set ref 625* 626*
sfk_code_parm                          parameter       fixed bin(35,0)          dcl 598 set ref 589 617* 626* 628 679*
sfk_function_key_sequence       000100 automatic       char(32)                 unaligned dcl 601 set ref 618* 624* 626* 630* 634
                                                                                  634* 638 638* 642 642* 646 646* 650 650* 658 661*
                                                                                  672
sfk_function_key_sequence_buffer
                                000110 automatic       char(32)                 unaligned dcl 602 set ref 626* 630
sfk_function_key_sequence_parm         parameter       char                     unaligned dcl 600 ref 589 618 618 618 618 618 624
                                                                                  673
sfk_function_name_parm                 parameter       char                     unaligned dcl 599 ref 589 670
sfk_loop                        000120 automatic       fixed bin(17,0)          dcl 603 set ref 656* 658 661 661* 669* 670 672 673*
sfk_no_match                    000121 automatic       bit(1)                   dcl 604 set ref 655* 656 664*
sfnc_function_key_procs         000114 automatic       entry variable           initial array dcl 781 set ref 781* 781* 781* 781*
                                                                                  781* 781* 781* 781* 781* 781* 781* 781* 781* 816
sfnc_function_number            000114 automatic       fixed bin(17,0)          dcl 795 set ref 811* 816
sfnc_loop                       000115 automatic       fixed bin(17,0)          dcl 796 set ref 807* 809 811*
sfnc_still_looking_for_a_valid_response
                                000116 automatic       bit(1)                   dcl 797 set ref 802* 804 807 812* 816 818 845* 964*
                                                                                  1211* 1289*
sfnc_users_response             000117 automatic       char(32)                 unaligned dcl 798 set ref 805* 809
short_message                   000302 automatic       char(8)                  dcl 1747 set ref 194*
sshow_height                    000106 automatic       bit(1)                   dcl 1367 set ref 1377* 1378 1388 1396
sshow_prompt                    000107 automatic       char(42)                 unaligned dcl 1368 set ref 1374* 1375* 1378* 1380*
                                                                                  1386*
sshow_scroll_height_or_width    000122 automatic       fixed bin(35,0)          dcl 1369 set ref 1375* 1386* 1388 1388 1393 1396
                                                                                  1399
sshow_still_looking_for_a_valid_response
                                000123 automatic       bit(1)                   dcl 1370 set ref 1382* 1384 1385* 1388* 1393* 1396
                                                                                  1401
ssu_$abort_line                 000032 constant        entry                    external dcl 1748 ref 203
ssu_$print_message              000034 constant        entry                    external dcl 1749 ref 1551 1557 1566 1569 1576
ssu_info_ptr             32            based           pointer                  level 2 dcl 9-98 set ref 408 1423*
start_of_report         316            based           char(32)                 level 3 in structure "scroll_info" dcl 9-98
                                                                                  in procedure "rw_display_scroll" set ref 1061*
start_of_report         146            based           char(32)                 level 3 in structure "scroll_info" dcl 9-98
                                                                                  in procedure "rw_display_scroll" set ref 365 379
still_in_the_scrolling_business 000304 automatic       bit(1)                   dcl 1750 set ref 578* 580 852* 881* 896* 911* 948*
                                                                                  971* 1010* 1220* 1263* 1273* 1298* 1357*
sub_err_sw                3(10)        based           bit(1)                   level 3 packed unaligned dcl 1-12 set ref 1531*
substr                                                 builtin function         dcl 1751 set ref 311 315 315 364* 379 379 379 379
                                                                                  379 379 379 379 379 379 379 379 379 379 379 379
                                                                                  379 379 379 379 379 379 379 379 379 379 517 533
                                                                                  536 634 638 642 646 650 661 730 733 748 764 1059
                                                                                  1103 1152* 1160 1178 1178
switch_name                     000305 automatic       char(42)                 unaligned dcl 1752 set ref 1501* 1502* 1503
switches                  3            based           structure                level 2 dcl 1-12
target_line_number        3            based           fixed bin(35,0)          level 2 dcl 9-98 set ref 269 269* 271 271* 280 287
                                                                                  842 851* 858* 858 869 874* 878* 878 892* 916* 920*
                                                                                  942 946* 946 951* 962 970* 973* 1003* 1007* 1359*
                                                                                  1522*
target_page_number        2            based           fixed bin(21,0)          level 2 dcl 9-98 set ref 280 293 325* 325 329* 329
                                                                                  842 850* 850 871 882* 882 915* 952* 952 964 969*
                                                                                  969 1002* 1358* 1521*
tm_code_parm                           parameter       fixed bin(35,0)          dcl 691 set ref 683 713* 745* 752*
tm_current_position             000142 automatic       fixed bin(17,0)          dcl 692 set ref 727* 730 733 733 733 739* 739 742
                                                                                  758* 760 764 764
tm_escape_is_replacement_char   000143 automatic       bit(1)                   dcl 693 set ref 723* 736
tm_mnemonic                     000145 automatic       varying char(32)         dcl 695 set ref 714* 716 722 723 723 730
tm_mnemonic_length              000144 automatic       fixed bin(17,0)          dcl 694 set ref 722* 739 742
tm_mnemonic_parm                       parameter       char                     unaligned dcl 696 ref 683 714
tm_still_translating            000156 automatic       bit(1)                   dcl 697 set ref 725* 729 760* 767*
tm_string_in_parm                      parameter       char                     unaligned dcl 698 ref 683 716 718 726 730 733 748
                                                                                  764
tm_string_index                 000157 automatic       fixed bin(17,0)          dcl 699 set ref 730* 731 733 733 739 742
tm_string_length                000160 automatic       fixed bin(17,0)          dcl 700 set ref 726* 743 760 764
tm_string_out_parm                     parameter       char                     unaligned dcl 701 set ref 683 718* 771*
tm_string_varying               000161 automatic       varying char(32)         dcl 702 set ref 724* 733* 733 738* 738 757* 757 764*
                                                                                  764 771
tm_target_character_index       000172 automatic       fixed bin(17,0)          dcl 703 set ref 742* 743 748 758
tm_translation_index            000173 automatic       fixed bin(17,0)          dcl 704 set ref 748* 750 755 755* 755 757
top_margin_offset         5            based           fixed bin(17,0)          level 2 dcl 9-98 set ref 280* 283* 288 962
unique_chars_                   000036 constant        entry                    external dcl 1755 ref 1501
unspec                                                 builtin function         dcl 1756 set ref 1250* 1431* 1526*
up                       15            based           structure                array level 3 dcl 2-7
user_io_was_shrunk        0(01)        based           bit(1)                   level 3 packed unaligned dcl 9-98 set ref 1473*
                                                                                  1482*
user_io_window_position_info           based           structure                level 1 unaligned dcl 1757 set ref 1427 1431* 1438
                                                                                  1493 1580
user_io_window_position_info_ptr
                         12            based           pointer                  level 2 dcl 9-98 set ref 406 1429* 1564*
user_io_window_position_ip      000320 automatic       pointer                  dcl 1758 set ref 406* 1427* 1429 1431 1432 1438
                                                                                  1483* 1487 1493 1494 1494 1494 1496 1497* 1559
                                                                                  1561 1561 1580 1580
users_response                  000322 automatic       char(32)                 unaligned dcl 1759 set ref 996* 1320* 1321 1332*
                                                                                  1334* 1375* 1377 1386*
verify                                                 builtin function         dcl 1761 ref 517
version                                based           fixed bin(17,0)          level 2 in structure "user_io_window_position_info"
                                                                                  dcl 1757 in procedure "rw_display_scroll" set ref
                                                                                  1432*
version                                based           fixed bin(17,0)          level 2 in structure "window_status_info" dcl 10-45
                                                                                  in procedure "rw_display_scroll" set ref 1441*
version_number                         based           fixed bin(17,0)          level 2 dcl 1-12 set ref 1527*
vertical_scroll_distance
                          7            based           fixed bin(17,0)          level 2 dcl 9-98 set ref 271 858 869 878 944 946 951
                                                                                  962 1396* 1519*
vfn_function_name_parm                 parameter       char                     unaligned dcl 1599 ref 1593 1603 1603 1603 1603 1603
                                                                                  1603 1603 1603 1603 1603 1603 1603 1603
video_data_$terminal_iocb       000040 external static pointer                  dcl 1762 set ref 1446 1508*
video_et_$insuff_room_for_window
                                000042 external static fixed bin(35,0)          dcl 1763 set ref 1487*
video_et_$window_status_pending 000044 external static fixed bin(35,0)          dcl 1764 ref 235 558
video_utils_$turn_off_login_channel
                                000050 constant        entry                    external dcl 1766 ref 1575
video_utils_$turn_on_login_channel
                                000046 constant        entry                    external dcl 1765 ref 1449
video_was_already_on                   based           bit(1)                   level 3 packed unaligned dcl 9-98 set ref 1448*
                                                                                  1453* 1573
whs_char_read_parm                     parameter       varying char(1)          dcl 1137 set ref 1131 1155* 1190*
whs_current_line_on_screen      001053 automatic       fixed bin(17,0)          dcl 1139 set ref 1149* 1164 1166* 1172* 1174* 1181*
                                                                                  1181
whs_current_position            001052 automatic       fixed bin(17,0)          dcl 1138 set ref 1148* 1160 1178 1178 1182* 1182
                                                                                  1183
whs_new_line_position           001054 automatic       fixed bin(17,0)          dcl 1140 set ref 1160* 1161 1178 1178 1182
whs_prompt_parm                        parameter       bit(1)                   dcl 1141 ref 1131 1150 1188
whs_still_filling               001055 automatic       bit(1)                   dcl 1142 set ref 1147* 1159 1161* 1183*
whs_wants_more                  001056 automatic       bit(1)                   dcl 1143 set ref 1166* 1167
width                     3            based           fixed bin(17,0)          level 3 in structure
                                                                                  "report_output_window_position_info" dcl 1739
                                                                                  in procedure "rw_display_scroll" set ref 260 262
                                                                                  262 264 339* 1287 1520 1534
width                                  based           fixed bin(17,0)          level 2 in structure "page_info" dcl 7-29
                                                                                  in procedure "rw_display_scroll" ref 260 262 262
                                                                                  264 311 311 311 315 315 315 315 315 315 1287 1393
window_$bell                    000070 constant        entry                    external dcl 11-6 ref 454 526 820 1013 1075 1323
                                                                                  1336 1404
window_$clear_to_end_of_line    000072 constant        entry                    external dcl 11-9 ref 440 554 1176 1240
window_$clear_window            000074 constant        entry                    external dcl 11-13 ref 255 1156 1235 1490 1550
window_$create                  000106 constant        entry                    external dcl 11-72 ref 1508
window_$destroy                 000110 constant        entry                    external dcl 11-74 ref 1556
window_$get_one_unechoed_char   000104 constant        entry                    external dcl 11-67 ref 362 1190
window_$overwrite_text          000076 constant        entry                    external dcl 11-29 ref 315 555 1178 1242
window_$position_cursor         000100 constant        entry                    external dcl 11-31 ref 309 339 438 553 1174 1238
                                                                                  1246
window_$write_sync_read         000102 constant        entry                    external dcl 11-53 ref 442
window_flag              21            based           bit(1)                   level 3 dcl 1713 ref 1461 1554
window_iocb_ptr                 000332 automatic       pointer                  dcl 1768 set ref 235* 255* 309* 315* 339* 362* 409*
                                                                                  438* 440* 442* 454* 509* 526* 546* 553* 554* 555*
                                                                                  820* 1013* 1051* 1075* 1156* 1174* 1176* 1178*
                                                                                  1190* 1235 1235 1235* 1238* 1240* 1242* 1244 1244
                                                                                  1246* 1323* 1336* 1404* 1463* 1466 1466 1474*
                                                                                  1502* 1508* 1516 1550* 1556* 1568*
window_name             241            based           char(32)                 level 3 packed unaligned dcl 1713 set ref 1463* 1464
                                                                                  1466 1471
window_position_info                   based           structure                level 1 unaligned dcl 10-25
window_position_info_version_1         constant        fixed bin(17,0)          initial dcl 10-35 ref 1432
window_status_info                     based           structure                level 1 dcl 10-45 set ref 1440 1584
window_status_info_pointer
                         26            based           pointer                  level 2 dcl 9-98 set ref 411 1442*
window_status_info_ptr          000520 automatic       pointer                  dcl 10-43 set ref 235* 411* 546* 1440* 1441 1442
                                                                                  1584 1584
window_status_version_1                constant        fixed bin(17,0)          initial dcl 10-52 ref 1441
work_area                              based           area                     dcl 1769 ref 1427 1434 1440 1525
work_area_ptr                   000334 automatic       pointer                  dcl 1770 set ref 152* 405* 1422 1427 1434 1440 1525
work_area_ptr_parm                     parameter       pointer                  dcl 50 ref 124 152

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ESCAPE_KEYS                            internal static structure                level 1 dcl 9-7
ESCAPE_KEYS_AS_A_TABLE                 based           char(2)                  array dcl 9-22
ESCAPE_KEY_MNEMONICS                   internal static structure                level 1 dcl 9-24
ESCAPE_KEY_MNEMONICS_AS_A_TABLE        based           char(5)                  array dcl 9-39
GENERAL_COLUMN_OPTION                  internal static fixed bin(17,0)          initial dcl 6-15
GENERAL_REPORT_OPTION                  internal static fixed bin(17,0)          initial dcl 6-14
HIGHEST_NUMBERED_FUNCTION_KEY_NEEDED   internal static fixed bin(17,0)          initial dcl 9-60
INDEX_FOR_ALIGNMENT                    internal static fixed bin(17,0)          initial dcl 6-66
INDEX_FOR_COLUMN_ORDER                 internal static fixed bin(17,0)          initial dcl 6-50
INDEX_FOR_COUNT                        internal static fixed bin(17,0)          initial dcl 6-51
INDEX_FOR_DELIMITER                    internal static fixed bin(17,0)          initial dcl 6-40
INDEX_FOR_EDITING                      internal static fixed bin(17,0)          initial dcl 6-67
INDEX_FOR_EXCLUDE                      internal static fixed bin(17,0)          initial dcl 6-52
INDEX_FOR_FOLDING                      internal static fixed bin(17,0)          initial dcl 6-68
INDEX_FOR_FORMAT_DOCUMENT_CONTROLS     internal static fixed bin(17,0)          initial dcl 6-41
INDEX_FOR_GROUP                        internal static fixed bin(17,0)          initial dcl 6-53
INDEX_FOR_GROUP_FOOTER_TRIGGER         internal static fixed bin(17,0)          initial dcl 6-54
INDEX_FOR_GROUP_FOOTER_VALUE           internal static fixed bin(17,0)          initial dcl 6-55
INDEX_FOR_GROUP_HEADER_TRIGGER         internal static fixed bin(17,0)          initial dcl 6-56
INDEX_FOR_GROUP_HEADER_VALUE           internal static fixed bin(17,0)          initial dcl 6-57
INDEX_FOR_HYPHENATION                  internal static fixed bin(17,0)          initial dcl 6-42
INDEX_FOR_OUTLINE                      internal static fixed bin(17,0)          initial dcl 6-58
INDEX_FOR_PAGE_BREAK                   internal static fixed bin(17,0)          initial dcl 6-59
INDEX_FOR_PAGE_FOOTER_VALUE            internal static fixed bin(17,0)          initial dcl 6-43
INDEX_FOR_PAGE_HEADER_VALUE            internal static fixed bin(17,0)          initial dcl 6-44
INDEX_FOR_PAGE_LENGTH                  internal static fixed bin(17,0)          initial dcl 6-45
INDEX_FOR_PAGE_WIDTH                   internal static fixed bin(17,0)          initial dcl 6-46
INDEX_FOR_ROW_FOOTER_VALUE             internal static fixed bin(17,0)          initial dcl 6-60
INDEX_FOR_ROW_HEADER_VALUE             internal static fixed bin(17,0)          initial dcl 6-61
INDEX_FOR_SEPARATOR                    internal static fixed bin(17,0)          initial dcl 6-69
INDEX_FOR_SUBCOUNT                     internal static fixed bin(17,0)          initial dcl 6-62
INDEX_FOR_SUBTOTAL                     internal static fixed bin(17,0)          initial dcl 6-63
INDEX_FOR_TITLE                        internal static fixed bin(17,0)          initial dcl 6-70
INDEX_FOR_TITLE_LINE                   internal static fixed bin(17,0)          initial dcl 6-47
INDEX_FOR_TOTAL                        internal static fixed bin(17,0)          initial dcl 6-64
INDEX_FOR_TRUNCATION                   internal static fixed bin(17,0)          initial dcl 6-48
INDEX_FOR_WIDTH                        internal static fixed bin(17,0)          initial dcl 6-71
KEY_CTRL                               internal static fixed bin(17,0)          initial dcl 2-22
KEY_CTRL_AND_SHIFT                     internal static fixed bin(17,0)          initial dcl 2-22
KEY_MNEMONICS_AS_A_TABLE               based           char(12)                 array dcl 9-77
KEY_SHIFT                              internal static fixed bin(17,0)          initial dcl 2-22
LONGEST_GENERAL_COLUMN_OPTION_NAME_LENGTH
                                       internal static fixed bin(17,0)          initial dcl 6-28
LONGEST_GENERAL_REPORT_OPTION_NAME_LENGTH
                                       internal static fixed bin(17,0)          initial dcl 6-27
LONGEST_SPECIFIC_COLUMN_OPTION_NAME_LENGTH
                                       internal static fixed bin(17,0)          initial dcl 6-26
MAXIMUM_NORMALIZED_OPTION_NAME_LENGTH  internal static fixed bin(17,0)          initial dcl 6-32
MAXIMUM_OPTION_IDENTIFIER_LENGTH       internal static fixed bin(17,0)          initial dcl 6-34
MAXIMUM_OPTION_NAME_LENGTH             internal static fixed bin(17,0)          initial dcl 6-35
MAXIMUM_OPTION_VALUE_LENGTH            internal static fixed bin(17,0)          initial dcl 6-36
NUMBER_OF_SPECIFIC_COLUMN_OPTIONS_IN_TABLE
                                       internal static fixed bin(17,0)          initial dcl 6-22
SPECIFIC_COLUMN_OPTION                 internal static fixed bin(17,0)          initial dcl 6-16
break_table_info                       based           structure                level 1 dcl 10-76
break_table_info_version               internal static fixed bin(17,0)          initial dcl 10-80
break_table_info_version_1             internal static fixed bin(17,0)          initial dcl 10-80
break_table_ptr                        automatic       pointer                  dcl 10-75
format_document_version_1              internal static fixed bin(17,0)          initial dcl 1-64
formatted_page_info                    based           structure                level 1 dcl 7-7
formatted_page_ip                      automatic       pointer                  dcl 7-26
fpi_init_maximum_number_of_detail_blocks
                                       automatic       fixed bin(17,0)          dcl 7-27
function_key_data_highest              automatic       fixed bin(17,0)          dcl 2-35
function_key_data_version_1            internal static fixed bin(17,0)          initial dcl 2-36
get_editor_key_bindings_info           based           structure                level 1 dcl 10-151
get_editor_key_bindings_info_ptr       automatic       pointer                  dcl 10-159
get_editor_key_bindings_info_version_1 internal static char(8)                  initial unaligned dcl 10-160
iox_$attach_loud                000000 constant        entry                    external dcl 4-8
iox_$attach_name                000000 constant        entry                    external dcl 4-8
iox_$attach_ptr                 000000 constant        entry                    external dcl 4-8
iox_$close                      000000 constant        entry                    external dcl 4-8
iox_$close_file                 000000 constant        entry                    external dcl 4-8
iox_$delete_record              000000 constant        entry                    external dcl 4-8
iox_$detach                     000000 constant        entry                    external dcl 4-8
iox_$detach_iocb                000000 constant        entry                    external dcl 4-8
iox_$err_no_operation           000000 constant        entry                    external dcl 4-8
iox_$err_not_attached           000000 constant        entry                    external dcl 4-8
iox_$err_not_closed             000000 constant        entry                    external dcl 4-8
iox_$err_not_open               000000 constant        entry                    external dcl 4-8
iox_$error_output                      external static pointer                  dcl 4-41
iox_$find_iocb_n                000000 constant        entry                    external dcl 4-8
iox_$get_chars                  000000 constant        entry                    external dcl 4-8
iox_$iocb_version_sentinel             external static char(4)                  dcl 3-51
iox_$modes                      000000 constant        entry                    external dcl 4-8
iox_$move_attach                000000 constant        entry                    external dcl 4-8
iox_$open                       000000 constant        entry                    external dcl 4-8
iox_$open_file                  000000 constant        entry                    external dcl 4-8
iox_$position                   000000 constant        entry                    external dcl 4-8
iox_$propagate                  000000 constant        entry                    external dcl 4-8
iox_$put_chars                  000000 constant        entry                    external dcl 4-8
iox_$read_key                   000000 constant        entry                    external dcl 4-8
iox_$read_length                000000 constant        entry                    external dcl 4-8
iox_$read_record                000000 constant        entry                    external dcl 4-8
iox_$rewrite_record             000000 constant        entry                    external dcl 4-8
iox_$seek_key                   000000 constant        entry                    external dcl 4-8
iox_$user_input                        external static pointer                  dcl 4-41
iox_$write_record               000000 constant        entry                    external dcl 4-8
key_info_ptr                           automatic       pointer                  dcl 2-38
line_editor_binding_count              automatic       fixed bin(17,0)          dcl 10-121
line_editor_key_binding_info           based           structure                level 1 dcl 10-129
line_editor_key_binding_info_ptr       automatic       pointer                  dcl 10-118
line_editor_key_binding_info_version_3 internal static char(8)                  initial unaligned dcl 10-148
line_editor_longest_sequence           automatic       fixed bin(17,0)          dcl 10-123
more_handler_info                      based           structure                level 1 dcl 10-83
more_handler_info_ptr                  automatic       pointer                  dcl 10-92
more_handler_info_version              internal static fixed bin(17,0)          initial dcl 10-94
more_handler_info_version_3            internal static fixed bin(17,0)          initial dcl 10-94
more_prompt_info                       based           structure                level 1 dcl 10-108
more_prompt_info_ptr                   automatic       pointer                  dcl 10-112
more_prompt_info_version_1             internal static char(8)                  initial unaligned dcl 10-114
more_responses_info                    based           structure                level 1 dcl 10-59
more_responses_info_ptr                automatic       pointer                  dcl 10-69
more_responses_info_version_1          internal static fixed bin(17,0)          initial dcl 10-67
more_responses_version                 internal static fixed bin(17,0)          initial dcl 10-67
page_defined_as_a_string               based           char                     unaligned dcl 7-40
page_defined_as_chars                  based           char(1)                  array unaligned dcl 7-38
page_overstrike_info                   based           structure                level 1 dcl 7-43
page_overstrike_info_redefined         based           structure                level 1 dcl 7-51
page_overstrike_ip                     automatic       pointer                  dcl 7-49
set_editor_key_bindings_info           based           structure                level 1 dcl 10-162
set_editor_key_bindings_info_ptr       automatic       pointer                  dcl 10-171
set_editor_key_bindings_info_version_1 internal static char(8)                  initial unaligned dcl 10-172
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 1753
token_characters_info                  based           structure                level 1 dcl 10-97
token_characters_info_ptr              automatic       pointer                  dcl 10-104
token_characters_info_version_1        internal static char(8)                  initial unaligned dcl 10-106
window_$change_column           000000 constant        entry                    external dcl 11-63
window_$change_line             000000 constant        entry                    external dcl 11-59
window_$clear_region            000000 constant        entry                    external dcl 11-7
window_$clear_to_end_of_window  000000 constant        entry                    external dcl 11-11
window_$delete_chars            000000 constant        entry                    external dcl 11-15
window_$edit_line               000000 constant        entry                    external dcl 11-76
window_$get_cursor_position     000000 constant        entry                    external dcl 11-17
window_$get_echoed_chars        000000 constant        entry                    external dcl 11-22
window_$get_one_unechoed        000000 constant        entry                    external dcl 11-67
window_$get_unechoed_chars      000000 constant        entry                    external dcl 11-25
window_$insert_text             000000 constant        entry                    external dcl 11-28
window_$position_cursor_rel     000000 constant        entry                    external dcl 11-36
window_$scroll_region           000000 constant        entry                    external dcl 11-42
window_$sync                    000000 constant        entry                    external dcl 11-44
window_$write_raw_text          000000 constant        entry                    external dcl 11-48
window_edit_line_info                  based           structure                level 1 unaligned dcl 10-177
window_edit_line_info_ptr              automatic       pointer                  dcl 10-186
window_edit_line_info_version_1        internal static char(8)                  initial unaligned dcl 10-183
window_position_info_ptr               automatic       pointer                  dcl 10-37
window_position_info_version           internal static fixed bin(17,0)          initial dcl 10-35
window_status_version                  internal static fixed bin(17,0)          initial dcl 10-52

NAMES DECLARED BY EXPLICIT CONTEXT.
RETURN_TO_CALLING_PROGRAM       002537 constant        label                    dcl 52 ref 240
abort_line                      002741 constant        entry                    internal dcl 182 ref 514 548 561 1044 1053 1123 1450
                                                                                  1464 1466 1471 1476 1478 1485 1487 1491 1499 1503
                                                                                  1510
check_code                      003134 constant        entry                    internal dcl 207 ref 256 310 318 342 363 439 441 444
                                                                                  455 821 1014 1076 1157 1175 1177 1180 1191 1237
                                                                                  1239 1241 1243 1247 1325 1338 1405
continue                        002544 constant        entry                    external dcl 56
display_chunk_of_page           003205 constant        entry                    internal dcl 244 ref 581
fkp_backward                    006322 constant        entry                    internal dcl 828 ref 781
fkp_end_of_report               006435 constant        entry                    internal dcl 903 ref 781
fkp_forward                     006465 constant        entry                    internal dcl 927 ref 781
fkp_goto                        006574 constant        entry                    internal dcl 979 ref 781
fkp_help                        006721 constant        entry                    internal dcl 1022 ref 781
fkp_left                        007734 constant        entry                    internal dcl 1200 ref 781
fkp_multics_mode                007770 constant        entry                    internal dcl 1228 ref 781
fkp_quit                        010204 constant        entry                    internal dcl 1258 ref 781
fkp_redisplay                   010220 constant        entry                    internal dcl 1269 ref 781 1169 1252 1401
fkp_right                       010232 constant        entry                    internal dcl 1279 ref 781
fkp_set_key                     010265 constant        entry                    internal dcl 1306 ref 781
fkp_set_scroll_increment        010506 constant        entry                    internal dcl 1345 ref 781
fkp_start_of_report             010516 constant        entry                    internal dcl 1353 ref 781
get_users_response              003560 constant        entry                    internal dcl 348 ref 805
help_for_function               007236 constant        entry                    internal dcl 1087 ref 1071
housekeeping                    004057 constant        entry                    internal dcl 399 ref 84 177
prompt_for_more                 004127 constant        entry                    internal dcl 419 ref 1166
prompt_user                     004334 constant        entry                    internal dcl 463 ref 996 1320 1332 1375 1386
rw_display_scroll               002531 constant        entry                    external dcl 39
scroll_the_report               005037 constant        entry                    internal dcl 570 ref 85
set_fkey                        002574 constant        entry                    external dcl 90
set_function_key                005054 constant        entry                    internal dcl 589 ref 119 1334
set_scroll_height_or_width      010534 constant        entry                    internal dcl 1365 ref 1347
setup_for_next_chunk            006074 constant        entry                    internal dcl 779 ref 582
setup_scroll                    010731 constant        entry                    internal dcl 1415 ref 153
start                           002667 constant        entry                    external dcl 124
stop                            002717 constant        entry                    external dcl 157
terminate_scroll                012111 constant        entry                    internal dcl 1542 ref 178
translate_mnemonics             005553 constant        entry                    internal dcl 683 ref 626
valid_function_name             012365 constant        entry                    internal dcl 1593 ref 1322
write_help_string               007443 constant        entry                    internal dcl 1131 ref 1050 1069 1125
write_prompt                    004603 constant        entry                    internal dcl 540 ref 499 508

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     13656       13770   12771       13666
Length     14610   12771       112         603     665           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rw_display_scroll                   538 external procedure  is an external procedure.  
abort_line                           92 internal procedure  is called during a stack extension.  
check_code                           88 internal procedure  is called by several nonquick procedures.  
display_chunk_of_page                   internal procedure  shares stack frame of external procedure rw_display_scroll.  
get_users_response                      internal procedure  shares stack frame of internal procedure setup_for_next_chunk.  
housekeeping                            internal procedure  shares stack frame of external procedure rw_display_scroll.  
prompt_for_more                         internal procedure  shares stack frame of internal procedure fkp_help.  
prompt_user                         326 internal procedure  enables or reverts conditions.  
on unit on line 496                  64 on unit               
write_prompt                        110 internal procedure  is called by several nonquick procedures.  
scroll_the_report                       internal procedure  shares stack frame of external procedure rw_display_scroll.  
set_function_key                    156 internal procedure  uses auto adjustable storage.  
translate_mnemonics                     internal procedure  shares stack frame of internal procedure set_function_key.  
setup_for_next_chunk                124 internal procedure  uses auto adjustable storage.  
fkp_backward                         65 internal procedure  is assigned to an entry variable.  
fkp_end_of_report                    64 internal procedure  is assigned to an entry variable.  
fkp_forward                          67 internal procedure  is assigned to an entry variable.  
fkp_goto                             90 internal procedure  is assigned to an entry variable.  
fkp_help                            756 internal procedure  is assigned to an entry variable.  
help_for_function                       internal procedure  shares stack frame of internal procedure fkp_help.  
write_help_string                       internal procedure  shares stack frame of internal procedure fkp_help.  
fkp_left                             64 internal procedure  is assigned to an entry variable.  
fkp_multics_mode                     96 internal procedure  is assigned to an entry variable.  
fkp_quit                             64 internal procedure  is assigned to an entry variable.  
fkp_redisplay                        64 internal procedure  is assigned to an entry variable.  
fkp_right                            64 internal procedure  is assigned to an entry variable.  
fkp_set_key                         113 internal procedure  is assigned to an entry variable.  
fkp_set_scroll_increment            105 internal procedure  is assigned to an entry variable.  
fkp_start_of_report                  64 internal procedure  is assigned to an entry variable.  
set_scroll_height_or_width              internal procedure  shares stack frame of internal procedure fkp_set_scroll_increment.  
setup_scroll                            internal procedure  shares stack frame of external procedure rw_display_scroll.  
terminate_scroll                        internal procedure  shares stack frame of external procedure rw_display_scroll.  
valid_function_name                     internal procedure  shares stack frame of internal procedure fkp_set_key.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
abort_line               000100 message_parm_length         abort_line
fkp_backward             000100 fb_beginning_line_number    fkp_backward
fkp_forward              000100 ff_beginning_line_number    fkp_forward
                         000101 ff_number_of_left_over_lines
                                                            fkp_forward
fkp_goto                 000100 fg_prompt                   fkp_goto
                         000103 fg_line_or_page_number      fkp_goto
                         000104 fg_still_looking_for_a_valid_response
                                                            fkp_goto
fkp_help                 000106 pfm_break_character         prompt_for_more
                         000110 pfm_buffer                  prompt_for_more
                         000111 pfm_number_of_chars_read    prompt_for_more
                         000112 pfm_still_looking_for_a_valid_response
                                                            prompt_for_more
                         000114 fh_character_read           fkp_help
                         000116 fh_help_string              fkp_help
                         000516 fh_help_string_length       fkp_help
                         000517 fh_number_of_chars_read     fkp_help
                         000520 fh_still_looking_for_a_valid_response
                                                            fkp_help
                         000521 fh_returned_help_list       fkp_help
                         000721 fh_still_helpful            fkp_help
                         000722 fh_users_response           fkp_help
                         001030 hff_function_number         help_for_function
                         001031 hff_loop                    help_for_function
                         001032 hff_target_function         help_for_function
                         001052 whs_current_position        write_help_string
                         001053 whs_current_line_on_screen  write_help_string
                         001054 whs_new_line_position       write_help_string
                         001055 whs_still_filling           write_help_string
                         001056 whs_wants_more              write_help_string
fkp_set_key              000100 fkp_valid_response          fkp_set_key
                         000101 fkp_prompt                  fkp_set_key
fkp_set_scroll_increment 000106 sshow_height                set_scroll_height_or_width
                         000107 sshow_prompt                set_scroll_height_or_width
                         000122 sshow_scroll_height_or_width
                                                            set_scroll_height_or_width
                         000123 sshow_still_looking_for_a_valid_response
                                                            set_scroll_height_or_width
prompt_user              000100 pu_number_of_chars_read     prompt_user
                         000101 pu_response_buffer          prompt_user
                         000201 pu_response_line            prompt_user
                         000202 pu_still_looking_for_a_valid_response
                                                            prompt_user
                         000212 pu_window_status_pending_flag
                                                            prompt_user
rw_display_scroll        000100 code                        rw_display_scroll
                         000101 command_level_flags         rw_display_scroll
                         000102 display_results_ptr         rw_display_scroll
                         000104 error_message               rw_display_scroll
                         000205 function_name               rw_display_scroll
                         000215 function_key_sequence       rw_display_scroll
                         000225 long_message                rw_display_scroll
                         000256 reason                      rw_display_scroll
                         000276 report_output_window_position_ip
                                                            rw_display_scroll
                         000300 sci_ptr                     rw_display_scroll
                         000302 short_message               rw_display_scroll
                         000304 still_in_the_scrolling_business
                                                            rw_display_scroll
                         000305 switch_name                 rw_display_scroll
                         000320 user_io_window_position_ip  rw_display_scroll
                         000322 users_response              rw_display_scroll
                         000332 window_iocb_ptr             rw_display_scroll
                         000334 work_area_ptr               rw_display_scroll
                         000336 format_document_options_ptr rw_display_scroll
                         000340 function_key_data_ptr       rw_display_scroll
                         000342 display_arg_results         rw_display_scroll
                         000342 page_ip                     rw_display_scroll
                         000344 report_cip                  rw_display_scroll
                         000346 function_key_info           rw_display_scroll
                         000516 scroll_ip                   rw_display_scroll
                         000520 window_status_info_ptr      rw_display_scroll
                         000534 dcop_buffer_empty_pending   display_chunk_of_page
                         000535 dcop_current_line_on_page   display_chunk_of_page
                         000536 dcop_current_line_on_screen display_chunk_of_page
                         000537 dcop_number_of_chars_to_write
                                                            display_chunk_of_page
                         000540 dcop_loop                   display_chunk_of_page
                         000541 dcop_loop_limit             display_chunk_of_page
set_function_key         000100 sfk_character_loop          set_function_key
                         000100 sfk_function_key_sequence   set_function_key
                         000110 sfk_function_key_sequence_buffer
                                                            set_function_key
                         000120 sfk_loop                    set_function_key
                         000121 sfk_no_match                set_function_key
                         000142 tm_current_position         translate_mnemonics
                         000143 tm_escape_is_replacement_char
                                                            translate_mnemonics
                         000144 tm_mnemonic_length          translate_mnemonics
                         000145 tm_mnemonic                 translate_mnemonics
                         000156 tm_still_translating        translate_mnemonics
                         000157 tm_string_index             translate_mnemonics
                         000160 tm_string_length            translate_mnemonics
                         000161 tm_string_varying           translate_mnemonics
                         000172 tm_target_character_index   translate_mnemonics
                         000173 tm_translation_index        translate_mnemonics
setup_for_next_chunk     000106 gur_character_read          get_users_response
                         000110 gur_loop                    get_users_response
                         000111 gur_partial_match           get_users_response
                         000114 sfnc_function_key_procs     setup_for_next_chunk
                         000114 sfnc_function_number        setup_for_next_chunk
                         000115 sfnc_loop                   setup_for_next_chunk
                         000116 sfnc_still_looking_for_a_valid_response
                                                            setup_for_next_chunk
                         000117 sfnc_users_response         setup_for_next_chunk

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             alloc_cs            cat_realloc_cs      call_var            call_ext_out_desc
call_ext_out        call_int_this_desc  call_int_this       call_int_other_desc call_int_other      return
tra_ext             alloc_auto_adj      signal              enable              shorten_stack       ext_entry
ext_entry_desc      int_entry           int_entry_desc      set_cs_eis          index_cs_eis        any_to_any_tr
alloc_based         free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
convert_status_code_          cu_$cl                        format_document_$string       ioa_$rsnnl
iox_$control                  iox_$destroy_iocb             iox_$find_iocb                iox_$get_line
iox_$look_iocb                ssu_$abort_line               ssu_$print_message            unique_chars_
video_utils_$turn_off_login_channel                         video_utils_$turn_on_login_channel
window_$bell                  window_$clear_to_end_of_line  window_$clear_window          window_$create
window_$destroy               window_$get_one_unechoed_char window_$overwrite_text        window_$position_cursor
window_$write_sync_read

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$end_of_info      error_table_$long_record      iox_$user_io                  iox_$user_output
rw_error_$bad_fkey_name       rw_error_$bad_fkey_sequence   rw_error_$bad_report_display  video_data_$terminal_iocb
video_et_$insuff_room_for_window                            video_et_$window_status_pending




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 5   10 002516    8   61 002524        39 002530        52 002537        56 002540        82 002555        83 002561
     84 002562        85 002563        86 002564        88 002566        90 002567       115 002620       116 002624
    117 002626       118 002633       119 002640       120 002657       122 002661       124 002662       149 002675
    150 002701       151 002704       152 002707       153 002712       155 002713       157 002714       174 002725
    176 002732       177 002735       178 002736       180 002737       182 002740       192 002754       194 002757
    195 002772       196 003025       197 003027       199 003031       200 003046       203 003107       205 003132
    207 003133       232 003141       235 003144       239 003177       240 003202       244 003205       254 003206
    255 003207       256 003220       260 003224       262 003232       264 003242       269 003251       271 003257
    280 003273       283 003311       287 003312       288 003314       289 003317       293 003335       300 003364
    301 003367       308 003371       309 003401       310 003420       311 003424       315 003445       318 003476
    320 003503       321 003504       322 003505       325 003513       326 003515       327 003517       328 003522
    329 003524       330 003527       331 003531       335 003533       339 003535       342 003553       344 003557
    348 003560       357 003571       358 003576       360 003600       362 003615       363 003633       364 003640
    365 003647       379 003737       393 004054       395 004056       399 004057       403 004060       404 004063
    405 004066       406 004071       407 004074       408 004077       409 004102       410 004112       411 004115
    412 004120       413 004123       415 004126       419 004127       434 004131       436 004133       437 004136
    438 004137       439 004161       440 004166       441 004201       442 004206       444 004252       445 004257
    448 004272       450 004302       451 004305       452 004307       454 004311       455 004324       457 004331
    459 004332       463 004333       494 004354       496 004355       497 004371       498 004374       499 004376
    500 004403       502 004404       503 004406       504 004413       505 004415       507 004421       508 004424
    509 004430       511 004454       514 004463       516 004504       517 004506       521 004531       522 004532
    524 004533       526 004535       527 004547       531 004555       533 004556       536 004573       538 004601
    540 004602       544 004610       546 004613       548 004645       550 004671       553 004673       554 004713
    555 004726       558 005002       561 005016       564 005036       570 005037       578 005040       580 005042
    581 005044       582 005045       583 005051       585 005052       589 005053       597 005074       626 005103
    617 005106       618 005110       624 005152       625 005157       626 005167       628 005213       630 005216
    631 005221       634 005252       638 005274       642 005316       646 005340       650 005362       655 005404
    656 005406       658 005421       661 005462       664 005502       666 005503       669 005505       670 005515
    672 005527       673 005535       675 005543       677 005544       679 005546       681 005552       683 005553
    713 005576       714 005600       716 005622       718 005631       719 005640       722 005641       723 005643
    724 005660       725 005661       726 005663       727 005677       729 005701       730 005704       731 005725
    733 005726       736 005745       738 005747       739 005756       740 005763       742 005764       743 005771
    745 005773       746 005776       748 005777       750 006010       752 006011       753 006014       755 006015
    757 006021       758 006034       760 006037       762 006042       764 006043       767 006061       769 006062
    771 006063       773 006072       779 006073       781 006101       802 006226       804 006230       805 006232
    807 006235       809 006247       811 006257       812 006261       814 006262       816 006264       818 006276
    820 006300       821 006312       824 006317       826 006320       828 006321       842 006327       845 006340
    846 006343       848 006344       850 006347       851 006351       852 006353       853 006354       855 006355
    856 006356       858 006361       860 006367       869 006370       871 006401       874 006406       875 006410
    878 006411       881 006420       882 006421       883 006423       892 006424       893 006425       895 006430
    896 006432       899 006433       903 006434       911 006442       913 006445       915 006450       916 006453
    917 006455       919 006456       920 006460       923 006463       927 006464       939 006472       941 006477
    942 006501       944 006511       946 006513       948 006517       949 006520       951 006521       952 006525
    953 006526       962 006527       964 006537       969 006564       970 006565       971 006567       972 006570
    973 006571       975 006572       979 006573       990 006601       992 006614       994 006617       995 006621
    996 006624       998 006653      1000 006655      1002 006662      1003 006664      1004 006666      1006 006667
   1007 006671      1009 006673      1010 006674      1011 006675      1013 006676      1014 006711      1016 006716
   1018 006717      1022 006720      1039 006726      1041 006730      1042 006732      1044 006765      1046 007006
   1048 007010      1049 007013      1050 007014      1051 007016      1053 007043      1055 007064      1058 007072
   1059 007074      1061 007101      1069 007175      1070 007177      1071 007200      1073 007202      1075 007205
   1076 007220      1078 007225      1080 007226      1083 007234      1085 007235      1087 007236      1102 007240
   1103 007242      1105 007246      1107 007261      1110 007300      1111 007301      1113 007303      1115 007305
   1118 007312      1121 007364      1123 007417      1125 007440      1127 007442      1131 007443      1147 007445
   1148 007447      1149 007451      1150 007452      1152 007455      1153 007463      1154 007466      1155 007467
   1156 007471      1157 007504      1159 007511      1160 007514      1161 007533      1164 007536      1166 007544
   1167 007546      1169 007551      1170 007556      1172 007557      1174 007561      1175 007602      1176 007607
   1177 007622      1178 007627      1180 007664      1181 007672      1182 007673      1183 007675      1186 007701
   1188 007702      1190 007706      1191 007725      1194 007732      1200 007733      1209 007741      1211 007747
   1212 007752      1215 007753      1218 007760      1220 007763      1221 007764      1224 007766      1228 007767
   1235 007775      1237 010017      1238 010024      1239 010046      1240 010053      1241 010066      1242 010073
   1243 010116      1244 010123      1246 010136      1247 010156      1250 010163      1251 010166      1252 010175
   1254 010202      1258 010203      1262 010211      1263 010215      1265 010216      1269 010217      1273 010225
   1275 010230      1279 010231      1287 010237      1289 010247      1290 010252      1293 010253      1296 010255
   1298 010260      1299 010261      1302 010263      1306 010264      1316 010272      1317 010275      1319 010276
   1320 010301      1321 010331      1322 010336      1323 010352      1325 010370      1326 010375      1328 010376
   1329 010401      1331 010402      1332 010405      1334 010435      1335 010457      1336 010464      1338 010476
   1339 010503      1341 010504      1345 010505      1347 010513      1349 010514      1353 010515      1357 010523
   1358 010526      1359 010531      1361 010533      1365 010534      1374 010535      1375 010540      1377 010567
   1378 010576      1380 010603      1382 010606      1384 010610      1385 010612      1386 010613      1388 010642
   1392 010656      1393 010657      1396 010666      1399 010677      1401 010701      1404 010711      1405 010722
   1407 010727      1409 010730      1415 010731      1419 010732      1420 010735      1421 010737      1422 010741
   1423 010743      1427 010745      1429 010752      1431 010754      1432 010760      1434 010762      1436 010767
   1438 010771      1440 010776      1441 011003      1442 011005      1446 011007      1448 011014      1449 011016
   1450 011032      1452 011050      1453 011051      1461 011053      1463 011056      1464 011077      1466 011154
   1470 011242      1471 011244      1473 011320      1474 011323      1476 011353      1478 011374      1480 011415
   1482 011416      1483 011420      1485 011450      1487 011471      1490 011512      1491 011523      1493 011544
   1494 011551      1496 011555      1497 011557      1499 011607      1501 011630      1502 011662      1503 011704
   1506 011760      1508 011764      1510 012001      1516 012022      1518 012033      1519 012037      1520 012042
   1521 012045      1522 012047      1523 012051      1525 012053      1526 012060      1527 012063      1528 012065
   1529 012067      1530 012071      1531 012073      1532 012075      1533 012077      1534 012101      1535 012104
   1536 012106      1538 012110      1542 012111      1550 012112      1551 012123      1554 012142      1556 012145
   1557 012156      1559 012175      1561 012201      1564 012203      1566 012234      1568 012253      1569 012264
   1573 012303      1575 012306      1576 012315      1580 012334      1582 012342      1584 012350      1586 012356
   1589 012364      1593 012365      1603 012376


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
