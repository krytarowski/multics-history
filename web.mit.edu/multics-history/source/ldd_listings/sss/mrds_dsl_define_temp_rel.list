	COMPILATION LISTING OF SEGMENT mrds_dsl_define_temp_rel
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-04-18_1111.93_Tue_mdt
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
       15*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
       16*     This entry is being made to cover the change made on 85-04-19,
       17*     85-06-14, and 85-07-09 by Thanh Nguyen. (see mrds #136 and
       18*     #139 (phx19906))
       19*  2) change(86-11-18,Blair), approve(86-11-18,PBF7311), audit(86-11-26,Dupuis),
       20*     install(86-12-09,MR12.0-1237):
       21*     Change to use mrds_data_$relation_blocking_factor to create temp
       22*     relations.
       23*  3) change(87-01-22,Hergert), approve(88-07-11,MCR7903),
       24*     audit(88-05-19,Dupuis), install(88-08-01,MR12.2-1073):
       25*     For new parser, changed references of sel_ptr to select_list_ptr.
       26*                                                   END HISTORY COMMENTS */
       27 
       28 mrds_dsl_define_temp_rel:
       29 define_temp_rel:
       30      proc;
       31 
       32 /* (database_index, selection_expression, sel_value, rel_index, code)
       33*
       34*   DESCRIPTION:
       35*
       36*		      BEGIN_DESCRIPTION
       37*   The  purpose  of  this  procedure  is to implement the dsl_$define_temp_rel
       38*   function.  This procedure creates an argument list, for and calls translate
       39*   then calls search or retrieve_set_tuple.
       40*
       41*   If  the rel_index is zero on input, a new temporary relation is defined and
       42*   its index is returned in rel_index as an output parameter.  If rel_index is
       43*   >zero  on  input,  and  a  temorary  relation possessing this index already
       44*   exists, that temporary relation is redefined.  If rel index is <zero, and a
       45*   temporary relation possessing that index already exists, it is deleted, and
       46*   it's index made available for future use in another definition (rel_index =
       47*   0).
       48*		       END_DESCRIPTION
       49*
       50*
       51*
       52*
       53*
       54*
       55*   INPUT CONDITIONS:
       56*
       57*   database_index   is  the  index  of  the  database  the  caller  wishes  to
       58*   define_temp_rel.
       59*
       60*   selection_expression  is  the expression supplied by the user to select the
       61*   tuplies to be include in the temp rel.  the selection_expression is ignored
       62*   in the case of a negative rel_index.
       63*
       64*   se_value selection expression values (optional);
       65*
       66*   rel_index index designating the temp_rel being defined, It is zero on input
       67*   if  a  new temp_rel is to be defined and the index is returned as an output
       68*   paramater.  an input value for the rel_index of >0 means redefine that temp
       69*   rel, and an input value of <0 means delete that temp rel definition.
       70*
       71*
       72*
       73*   OUTPUT CONDITIONS:
       74*
       75*   If no errors are encountered the temp_rel definition was performed.
       76*
       77*   code = 0; If no errors are detected.
       78*
       79*   code  =  mrds_error_$invalid_db_index;  If  no  dbcb_ptr  was found for the
       80*   database index.
       81*
       82*   code  =  mrds_error_$undefined_temp_rel_index; If the value of rel_index on
       83*   input  is non-zero or does not refer to an existing temporary relation when
       84*   non-zero.
       85*
       86*   code  =  mrds_error_$max_temp_rels  If  the  number  of definitions exceeds
       87*   mrds_data_$max_temp_rels
       88*
       89*   code = something else; If some other error was detected;
       90*
       91*   rel_index  = numeric value of the temporary relation created.  or it is set
       92*   to 0, if an index was being deleted(i.e.  <0 on input)
       93*
       94*
       95*   If  less  then  4  arguments  were  passed  to this procedure the condition
       96*   arg_error will be signaled.
       97*
       98*
       99*
      100*
      101*
      102*   HISTORY:
      103*
      104*   76-01-01 R. D. Lackey: Initially written.
      105*
      106*   78-10-01 J. A. Weeldreyer: Modified for MR7.0.
      107*
      108*   79-03-26 Al Kepner: Modified to add caller parameter to mrds_dsl_translate.
      109*
      110*   79-07-13  Al  Kepner:  Modified to handle char varying attributes stored in
      111*   the data base by Pl/I standards.
      112*
      113*   79-10-01 Jim Gray : Modified to correct key order counting.
      114*
      115*   79-10-02  Jim  Gray  :  Modified  to  ignore duplicate key value tuples per
      116*   documentation.
      117*
      118*   79-10-03   Jim   Gray   :   Modified   to   change   iox_$attach_ioname  to
      119*   iox_$attach_name, so that temp_rels can be properly deleted.
      120*
      121*   79-10-04  Jim Gray : Modified to put temp rel info structures in rm_db_info
      122*   area,  rather  than dbcb area, so that structures are handled consistantly,
      123*   and so rdbi_ptr can be gotten simply after calls to mus_ptr_man$get_rip.
      124*
      125*   79-12-01  Jim  Gray  :  Modified  to change the real_bit_length calculation
      126*   routine,  to  use  whether  the  data  type  is varying character, not just
      127*   varying,  to  determine  the bit length from the count field of the varying
      128*   data item.
      129*
      130*   80-01-01  Jim  Gray : Modified to handle undefined temp rel indexes, and to
      131*   make negative temp rel indexes mean delete that temp rel definition, and to
      132*   correct some undefined mrds_error_ table entries.
      133*
      134*   80-01-02  Jim  Gray  : Modified to correct order of inititalization problem
      135*   with  rm_rel_info/rm_rel_info in create_temp_rel_file that caused the value
      136*   of the rmri_ptr to become unknown.
      137*
      138*   80-01-03 Jim Gray : Modified to fix tidy_up problem on >max_temp_rel error,
      139*   and to prevent recursive calls to tidy_up, when an error occurs.
      140*
      141*   80-01-04  Jim Gray : Modified to fixed multiple redefinition problem (added
      142*   destroy_iocb)
      143*
      144*   80-02-01  Jim  Gray  : Modified to detect non-unique attr names in relation
      145*   definition.
      146*
      147*   80-02-02 Jim Gray : Modified to put allocations in a non-freeing extensible
      148*   area managed by this routine.
      149*
      150*   80-05-07 Davids: modified assignments of tuple_num_atts and tuple_nvar_atts
      151*   to  take  values from rm_rel_info.model_num_attr and model_nvar_atts rather
      152*   than  rm_rel_info.num_attr  and  nvar_atts.  This was to fix a problem with
      153*   submodels were the submodel view did not contain a varying string attribute
      154*   and the model did.
      155*
      156*   80-05-12     Rickie     E.      Brinegar:     Modified     to    initialize
      157*   rm_rel_info.model_nvar_atts      and      rm_rel_info.model_num_attr     in
      158*   create_temp_rel_file  to  the  same initial values as rm_rel_info.nvar_atts
      159*   and   rm_rel_info.num_attr   respectively.    This  was  necessary  because
      160*   define_temp_rel builds its own tuple structure.
      161*
      162*   80-06-01  Jim Gray : Modified to add first_time_flag to store direct entry,
      163*   so that allocated space could be reused, especially for large temp rels.
      164*
      165*   80-09-16  Jim  Gray  :  Modified to put the temp rel (vfile) storage in the
      166*   same  place  as  the  resultant  model,  which  may  have  been  changed by
      167*   set_mrds_temp_dir
      168*
      169*   80-10-01  Jim  Gray  : Modified to make the $del_trels entry know about the
      170*   proper  place  to get the resultant model temp dir, instead of always using
      171*   the pdir.
      172*
      173*   80-10-03  Jim Gray : Modified to make temp rel redefinition delete the temp
      174*   rel, if the new temp rel definition did not find any tuples.  This makes it
      175*   work  the  way  it used to before the recursive tidy up problem fix entered
      176*   this rebug.
      177*
      178*   80-10-17  Jim  Gray  :  Modified to allow empty temp rels to be created, or
      179*   defined by redefinition, according to customer wishes.
      180*
      181*   80-11-05  Jim  Gray : Modified to set mdbm_secured bit and ??_perm bits the
      182*   same  way  as  a  normal  relation  would  be set, for proper handling when
      183*   secure_mrds_db was invoked.
      184*
      185*   80-11-10  Jim Gray : Modified to change dele_$path to hcs_$del_dir_tree and
      186*   hcs_$delentry_file calls in order to improve performance.
      187*
      188*   81-1-13   Jim  Gray  :  added  routine  (from  mrds_rst_format_file  logic)
      189*   force_msf_temp_rel,  to  always  start  temporary  relations  out  as  full
      190*   multi-segment  files,  just  like  permanent  relations  are.   This avoids
      191*   problems  with  vfile_ and msf_manager_ when the ssf grows to msf and there
      192*   are  multiple  openings.   This  is  a  fix  for critical TR 8871.  It also
      193*   results  in  a  permformance  improvement for cases where as msf would have
      194*   been created on temp_rel creation (i.e.  most non-empty temp rels)
      195*
      196*   81-01-29 Jim Gray : removed references to mdbm_data_$current_version, using
      197*   a constant instead, to allow future db version expansion.
      198*
      199*   81-01-29  Jim  Gray  :  added  proper  alignment of different data type and
      200*   alignment   type   attributes   within   the  tuple,  as  already  done  in
      201*   mrds_rst_file_handler  for  permanent  relations,  so that the logic in the
      202*   rest  of  mrds  can  find the attributes in the tuple.  TR 9021 pointed out
      203*   that  where  clause  comparisons  were failing due to improper alignment of
      204*   temp  rel  tuple  attrs.   Also  found  that tuples were 9 times as long as
      205*   necessary,  because  improper use of bit versus character lengths was being
      206*   done, compare rel_info versus rm_rel_info as init in mu_sec_make_res.
      207*
      208*   81-01-30  Jim  Gray  : added interface get_temp_rel_population according to
      209*   suggestion  TR  8991,  this  required  a change to rm_rel_info that will be
      210*   usefull in improving finding approx tuple count in perm relations.
      211*
      212*   81-01-30  Jim Gray : added padding logic to align varying strings to a word
      213*   boundary  in the get_tuple routine.  this was done because the previous fix
      214*   only  set  the  max_data_len for the tuple, and var_offset (i.e.  the start
      215*   and  end  of  the varying attr section of the tuple) but not the offsets of
      216*   the  varying  attrs, because they are stored in current length fashion, and
      217*   must be set at data definition time.
      218*
      219*   81-02-03  Jim  Gray  : changed declaration of fb35 to unaligned and renamed
      220*   fb35u,  in  answer  to  TR  9041.   Note this was done as a quick and dirty
      221*   because  the  tuple  defined by a set operation is not properly aligned and
      222*   padded.   Thus  it is different in structure from perm and temp rel tuples.
      223*   However,  since  it can only be used in retrieves, and temp rel definition,
      224*   this fix is adequate for now, until we build a common tuple manager.
      225*
      226*   81-03-17  Davids:  added  code  to  set  the rm_rel_info.model_nkey_attr to
      227*   nkey_attr_init  in  the internal procedure create_temp_rel_file, this fixed
      228*   tr9211.   also removed some unused declarations and explicity declared some
      229*   builtins.   added  the  page  macro  between  include file declarations and
      230*   removed  the form feeds that were there, also removed extra form feeds that
      231*   were  causing  blank pages.  reformated the header section so that the text
      232*   is justified.
      233*
      234*   81-03-24  Jim  Gray  :  added  capability  for  selection  expression to be
      235*   declared by caller to be char varying as well as just char.
      236*
      237*   81-03-27    Jim   Gray   :   changed   dbi   to   dbcb_ptr   parameter   to
      238*   mu_store$store_direct as part of getting rid of the mus_ptr_man module.
      239*
      240*   81-06-02 Jim Gray : changed to use new resultant structure.
      241*
      242*   81-06-17 Jim Gray : changed iocb pointer init to call mu_open_iocb_manager.
      243*
      244*   81-10-05  Rickie  E.   Brinegar: collapsed all of the processing to be done
      245*   when  the  arg_list.code  =  4  and  when  it  is not into one if-then-else
      246*   statement as opposed to the three that used to exist.
      247*
      248*   81-10-14 Davids: corrected value of the adpl_ptr so it pointed to
      249*   the descriptor of the argument following the selection expression
      250*   instead of the selection expression  descriptor.  This  corrected
      251*   .V. problems.
      252*
      253*   81-10-23 Davids: Have converted references of the form:
      254*   .          ptr = addr (bit_array (large_offset))
      255*   .	              to
      256*   .          ptr = add_bit_offset (bit_array_ptr, large_offset - 1)
      257*   This gets around a pl1 bug (tr11784) that causes the first method
      258*   to  produce  the  wrong  value  when  the code is compiled with a
      259*   subscriptrange condition. The "-1" is needed because  bit_array's
      260*   first element is 1 not 0.
      261*
      262*   81-12-04 Davids: changed the value of rm_rel_info.file_id_len  to
      263*   be  equal to the constant 9 rather than computing it based on the
      264*   max  number  of  temp  rels.  This  value  should   be   set   to
      265*   db_model.unblk_file_id_len  but  it  was  easier  just to use the
      266*   constant  value.  Also  set  rm_rel_info.file_id  to   "0"b   and
      267*   rm_rel_info.file_type to UNBLK (= 1). All this is so that the tid
      268*   created for a temp rel tuple will look the same (except  for  the
      269*   component  and  offset)  as tids created for permanent relations.
      270*   This is done so that the moving the data into the database dir to
      271*   create a permanent relation will not cause any problems.
      272*
      273*   81-12-16 Davids: modified to handle self-defined temp  rels,  i.e
      274*   the  temp  rel refers to itself in the defining SE. This required
      275*   changing the rm_rel_array refering to temp rels to have  1  extra
      276*   slot, i.e. have a dimension of mrds_data_$max_temp_rels + 1, this
      277*   was done in mu_sec_init_res. In this routine  all  references  to
      278*   rm_rel_array.num_rels   have   been   changed  to  references  to
      279*   mrds_data_$max_temp_rels becuase num_rels is now too big. The new
      280*   relation  is  defined using the extra index and then the old temp
      281*   rel is deleted and the rm_rel_array fields copied. for TR11630
      282*
      283*   81-12-18         Davids:         modified         so         that
      284*   rm_rel_array.last_statistics_update_s_e_ref_num   is  set  to  0,
      285*   rm_rel_array.ready_mode is set to SCOPE_UPDATE instead  of  LOAD,
      286*   the  view permissions modify and delete in rm_rel_info are set to
      287*   "1"b (retrieve and store were already set), the scope permissions
      288*   rm_attr_info.modify_perm  was  set  to  "1"b (others were already
      289*   set) and reformated the assignments so they were easier to  read.
      290*   All this so that temp rels can be updated.
      291*
      292*   82-04-21  R. Lackey : Add rm_rel_info.number_selected = 0;
      293*   To help keep track of how much space is used and delete old subsets.
      294*   TR12205 (Suggestion).
      295*
      296*   82-04-26 R. Lackey : removed get_tuple internal procedure and made it
      297*   external with the name mu_get_tuple providing common code for
      298*   rmdb_create_relation with a selection exp.
      299*
      300*   82-05-24 R. Lackey : Modified the initialization of rm_rel_info.file_id_len
      301*   from 9 to 7 cause the tuple_id_unbl.file_id length is only 7 bits.
      302*   This corrected a stringsize condition.
      303*
      304*   82-06-09 Mike Kubicar : added the fix for TR phx12347.  If a temp relation
      305*   had varying strings in it but the last attribute in it is not a varying
      306*   string, the temp relation would be missing data.
      307*
      308*   82-08-20 D. Woodka : deleted references to rm_rel_info.max_data_len
      309*   and to rm_attr_info.bit_offset for DMS conversion
      310*
      311*   82-08-25 Mike Kubicar : Converted the use of the tuple structure to
      312*   the simple vector structure.
      313*
      314*   82-09-12 Mike Kubicar : Converted to use relation manager.
      315*
      316*   82-12-10 Davids: Modified the call to dbcb.relmgr_entries.create_relation
      317*   and destroy_relation_by_path by enclosing the relation name in ()s.
      318*   This was needed because the declaration of the relation manager entries
      319*   in the dbcb was changed from options variable to reality. The relation name
      320*   is declared as character aligned in the include file while the entry expects
      321*   character unaligned.
      322*
      323*   83-01-31 Mike Kubicar : Added included files to call transaction manager
      324*   when using a dm file database.
      325*
      326*   83-02-17 Ron Harvey : Modified to call $create_relation with the attribute
      327*   names.
      328*
      329*   83-02-25 Davids: Modified to set the protected, no_concurrency and
      330*   no_rollback elements of the file_create_info structure from the 
      331*   transactions_needed, concurrency_on, rollback_on elements of the
      332*   dbcb structure. This allows temp rels to be created with the same
      333*   file attributes as the permanent relations.
      334*
      335*   83-05-04 Davids: Modified so that mu_define_area is called with a name
      336*   of MRDS || dbi_pic. This will allow closes to be faster since all
      337*   temp_segments with the name MRDS || dbi_pic can be deleted/freed in 1 call.
      338*   the variable dbi_pic was created as an easy way to convert from fixed bin
      339*   to character.
      340*
      341*   83-06-20 Davids: Removed check for old version database and the call
      342*   to v1 code if it was an old version db (old version dbs can no longer
      343*   be opened)
      344*
      345*   84-08-22 Pierret: Changed usage of file_create_info structure for version
      346*   FILE_CREATE_INFO_VERSION_2.  This add the ring_brackets component, which
      347*   is set to 0 to get the default action.
      348*
      349*   85-01-15 Thanh Nguyen:  Added code to create a special work area using 
      350*   mu_define_area$define_spec_temp_dir_area.  For now, this work area is used
      351*   by mu_retrieve and mu_get_data to "allocate" value_for_db and value_for_user
      352*   thru function mrds_space_allocate and reinitialize the area thru subroutine
      353*   mrds_area_initialize.
      354*
      355*   85-06-14 Thanh Nguyen:  Initialized the rm_rel_info.scope_flags_ptr to null
      356*   so later noone would have some gabages overwrite on their good areas when
      357*   accidentally referencing scope_flags_ptr.
      358*
      359*   85-07-09 Thanh Nguyen:  Modified the code to set rm_rel_info.file_type as
      360*   TEMPORARY (3) from UNBLCK (1).
      361**/
      362 
      363 	area_ptr, dbcb_ptr, simple_typed_vector_ptr = null;
      364 	tri = 0;					/* initialize */
      365 	no_recurse = "0"b;
      366 	created_resultant = "0"b;
      367 	mstxn_txn_id = "0"b;
      368 	entry_point_name = "mrds_dsl_define_temp_rel";
      369 
      370 	call cu_$arg_list_ptr (al_ptr);		/* Get pointer to this proc arg list */
      371 	if al_ptr = null then
      372 	     signal arg_error;			/* This returns you to command level */
      373 	nargs = arg_list.arg_count / 2;		/* Get the number of arguments to this proc */
      374 	if nargs < 4 then
      375 	     signal arg_error;			/* This returns to command level */
      376 
      377 	call cu_$arg_ptr (nargs, cd_ptr, arg_len, icode); /* Get  pointer to callers return code */
      378 	if icode ^= 0 then
      379 	     signal arg_error;			/* This returns to command level */
      380 
      381 	call cu_$arg_ptr (1, dbi_ptr, arg_len, icode);	/* Get pointer to database index */
      382 	if icode ^= 0 then
      383 	     call error (icode);
      384 
      385 	call cu_$arg_ptr (2, se_ptr, se_len, icode);	/* Get pointer to selection expression */
      386 	if icode ^= 0 then
      387 	     call error (icode);
      388 
      389 	if arg_list.code = 4 then do;
      390 		num_ptrs = arg_list.arg_count;	/* Determine number of pointers in arg list */
      391 		adpl_ptr = addr (arg_list.arg_des_ptr (nargs + 3)); /* Get pointer to descriptor ptr list for
      392*						   args after SE for translate */
      393 		desc_ptr = arg_list.arg_des_ptr (nargs + 2); /* Get pointer to descriptor of the selection expression */
      394 	     end;
      395 	else do;
      396 		num_ptrs = arg_list.arg_count + 1;
      397 		adpl_ptr = addr (arg_list.arg_des_ptr (nargs + 4));
      398 		desc_ptr = arg_list.arg_des_ptr (nargs + 3);
      399 	     end;
      400 
      401 	if descriptor.type = 22 then do;
      402 		se_len_ptr = addrel (se_ptr, -1);	/* get current length of varying string */
      403 		se_len = se_len_ptr -> se_len_ovrly;
      404 	     end;
      405 
      406 	call cu_$arg_ptr (nargs - 1, rel_index_ptr, arg_len, icode);
      407 						/* Get the rel_index */
      408 	if icode ^= 0 then
      409 	     call error (icode);
      410 
      411 	appl_ptr = addr (arg_list.arg_des_ptr (3));	/* Get ptr to the start  of the arg_ptr_list for translate */
      412 
      413 	num_args = nargs - 4;			/* Number of args passed to translate */
      414 
      415 	call
      416 	     mu_database_index$get_resultant_model_pointer (database_index,
      417 	     dbcb_ptr);				/* Get the dbcb pointer */
      418 	if dbcb_ptr = null then
      419 	     call error (mrds_error_$invalid_db_index);
      420 
      421 	rdbi_ptr = dbcb.rdbi_ptr;
      422 
      423 	tr_dir = get_resultant_dir (database_index);	/* put temp rels in same dir as resultant model */
      424 
      425 	dbi_pic = dbcb.dbi;
      426 	call
      427 	     mu_define_area$define_temp_dir_area (dbcb.def_temp_rel_area_ptr,
      428 	     database_index, (sys_info$max_seg_size),
      429 	     "MRDS" || dbi_pic, "0"b /* not extensible */, "1"b /* no freeing */, "0"b,
      430 	     "0"b /* no zeroing */, icode);
      431 	area_ptr = dbcb.def_temp_rel_area_ptr;
      432 	if icode ^= 0 then
      433 	     call error (icode);
      434 	rmra_ptr = rm_db_info.tra_ptr;		/* get rel and file aray ptrs */
      435 						/* Create a work area for mu_retrieve to allocate the value_for_users. */
      436 	call mu_define_area$define_spec_temp_dir_area (dbcb.work_area_ptr, database_index, "MRDS" || dbi_pic, icode);
      437 	if icode ^= 0 then call error (icode);
      438 
      439 
      440 	if rel_index = 0 then do;			/* if new temp rel */
      441 		tri = 0;
      442 		do i = 1 to mrds_data_$max_temp_rels;
      443 		     if rm_rel_array.rel_data.ri_ptr (i) = null () & tri = 0 then
      444 			tri = i;
      445 		end;
      446 		if tri = 0 then
      447 		     call error (mrds_error_$max_temp_rels);
      448 	     end;					/* if new temp rel */
      449 	else do;					/* if redefinition */
      450 		if abs (rel_index) > mrds_data_$max_temp_rels then
      451 		     call error (mrds_error_$undefined_temp_rel_index);
      452 		tri = abs (rel_index);
      453 		if rm_rel_array.rel_data.ri_ptr (tri) = null () then
      454 		     call error (mrds_error_$undefined_temp_rel_index);
      455 	     end;					/* if redefin. */
      456 	mstxn_transactions_needed = dbcb.transactions_needed;
      457 	save_appl_ptr = appl_ptr;
      458 	save_adpl_ptr = adpl_ptr;
      459 	save_num_args = num_args;
      460 	on cleanup
      461 	     begin;
      462 		call mstxn_cleanup;
      463 		call tidy_up;
      464 	     end;
      465 	on any_other call mstxn_any_other;
  1     1 /* ====== BEGIN INCLUDE FILE	          mrds_start_transaction.incl.pl1 =========================== */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  1     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  1     8*     This entry is being made to cover the changes made on 85-05-06 and
  1     9*     85-04-19 by Thanh Nguyen. The dependency on dbcb.user_started_transaction
  1    10*     was removed because not all modules need the dbcb, and the
  1    11*     user_transaction_id field was added for mrds_dsl_retrieve (mrds error
  1    12*     list #136).
  1    13*                                                   END HISTORY COMMENTS */
  1    14 
  1    15 
  1    16 /*
  1    17*                    BEGIN_DESCRIPTION
  1    18*
  1    19*   A generalized routine accessed by all MRDS modules (with the temporary 
  1    20*   (perhaps) exception of restructuring modules) that must start transactions 
  1    21*   if none are present.  The intent is that it be executed as inline code.
  1    22*   The variable mstxn_transactions_needed must be set prior to entering this
  1    23*   code.  In most cases a simple assignment from dbcb_data.transactions_needed
  1    24*   will suffice.  Included are procedures called mstxn_cleanup and 
  1    25*   mstxn_any_other.  These procedures must be called by cleanup and any_other 
  1    26*   handlers in the program.  Such handlers should be established just prior to
  1    27*   the inclusion of this code and disabled just following the inclusion of
  1    28*   mrds_finish_transaction.  Directly prior to establishing the handlers
  1    29*   mstxn_txn_id must be set to "0"b.  This must be done even though this 
  1    30*   include file does the same, because this code might not have been entered 
  1    31*   yet when the handler is invoked.  Directly following this include file the 
  1    32*   contents of mstxn_code should be examined.  If zero, then either the 
  1    33*   transaction was successfully started or no transaction was required.  If the
  1    34*   mrds_finish_transaction code is referenced in general error handling 
  1    35*   situations where the possibility exists that the code in this include file 
  1    36*   has not been executed, it is necessary to initialize mstxn_txn_id to "0"b at
  1    37*   the beginning of the program.
  1    38*
  1    39*                    END_DESCRIPTION
  1    40*
  1    41*   Written 82-09-28 by Paul W. Benjamin.
  1    42*   Modified 82-12-09 by PWB to include mstxn_any_other.
  1    43*   Modified 83-01-07 by PWB to not reference the dbcb.
  1    44*   Modified 83-01-10 by PWB to add a call to continue_to_signal_ to the
  1    45*		 any_other handler in situations where the module did
  1    46*		 not start the transaction.
  1    47*   Modified 83-05-05 by PWB to abandon when abort fails.
  1    48*   Modified 83-05-18 by PWB to use mstxn_temp_code in calls to abandon and
  1    49*		 and abort.
  1    50*   Modified 83-05-19 by PWB to handle transaction_deadlock and 
  1    51*		 transaction_bj_full conditions.
  1    52*   Modified 84-02-04 by PWB to add trailing underscores to the 2 conditions
  1    53*		 and to handle transaction_lock_timeout_.
  1    54*   Modified 85-04-14 by Thanh Nguyen: Added code to set the 
  1    55*                     dbcb.user_started_transaction flag.
  1    56*   Modified 85-04-19 by Thanh Nguyen to add user_started_transaction flag.
  1    57*   Modified 85-05-06 By Thanh Nguyen to synchronize this include file in the 
  1    58*                     directory >ldd>include and >exl>mrd>i
  1    59**/
  1    60 
  1    61 dcl continue_to_signal_ entry (fixed bin(35));
  1    62 dcl dm_error_$no_current_transaction fixed bin (35) ext static;
  1    63 dcl error_table_$null_info_ptr fixed bin(35) ext static;
  1    64 dcl find_condition_info_ entry (ptr, ptr, fixed bin(35));
  1    65 dcl mstxn_code fixed bin (35);
  1    66 dcl mstxn_retries fixed;
  1    67 dcl mstxn_temp_code fixed bin (35);
  1    68 dcl mstxn_transactions_needed bit (1) aligned;
  1    69 dcl user_started_transaction bit (1) aligned;
  1    70 dcl mstxn_txn_id bit (36) aligned;
  1    71 dcl user_transaction_id bit (36) aligned;
  1    72 dcl transaction_manager_$abandon_txn entry (bit (36) aligned, fixed bin (35));
  1    73 dcl transaction_manager_$abort_txn entry (bit (36) aligned, fixed bin (35));
  1    74 dcl transaction_manager_$begin_txn entry (fixed bin, fixed bin (35), bit (36) aligned, fixed bin (35));
  1    75 dcl transaction_manager_$get_current_txn_id entry (bit (36) aligned, fixed bin (35));
  1    76 dcl transaction_manager_$handle_conditions entry ();
  1    77 dcl 1 mstxn_condition_info like condition_info;
  1    78 
  2     1 /*  START OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 /* HISTORY:
  2     4*
  2     5*Designed by Matthew C. Pierret, 01/26/82.
  2     6*Coded by Jeffrey D. Ives, 04/30/82.
  2     7*Modified:
  2     8*10/18/82 by Steve Herbst: Names changed.
  2     9*01/19/83 by Steve Herbst: Added (LOWEST HIGHEST)_MODE.
  2    10**/
  2    11 
  2    12 dcl (LOWEST_MODE init (1),
  2    13      HIGHEST_MODE init (8)) fixed bin int static options (constant);
  2    14 
  2    15      dcl	   TM_NORMAL_MODE	      fixed bin static options (constant) init (1);
  2    16      dcl	   TM_STATISTICAL_MODE   fixed bin static options (constant) init (2);
  2    17      dcl	   TM_READ_ONLY_MODE     fixed bin static options (constant) init (3);
  2    18      dcl	   TM_NEVER_WRITE_MODE   fixed bin static options (constant) init (4);
  2    19      dcl	   TM_TEST_NORMAL_MODE   fixed bin static options (constant) init (5);
  2    20      dcl	   TM_TEST_STATISTICAL_MODE fixed bin static options (constant) init (6);
  2    21      dcl	   TM_TEST_READ_ONLY_MODE fixed bin static options (constant) init (7);
  2    22      dcl	   TM_TEST_NEVER_WRITE_MODE fixed bin static options (constant) init (8);
  2    23 
  2    24 /*  END OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1    79 

  1    80 
  3     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  3     2 
  3     3 /* Structure for find_condition_info_.
  3     4*
  3     5*   Written 1-Mar-79 by M. N. Davidoff.
  3     6**/
  3     7 
  3     8 /* automatic */
  3     9 
  3    10      declare condition_info_ptr     pointer;
  3    11 
  3    12 /* based */
  3    13 
  3    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  3    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  3    16 	     2 version	      fixed binary,		/* Must be 1 */
  3    17 	     2 condition_name     char (32) varying,	/* name of condition */
  3    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  3    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  3    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  3    21 	     2 flags	      unaligned,
  3    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  3    23 	       3 pad1	      bit (35),
  3    24 	     2 pad2	      bit (36),
  3    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  3    26 	     2 pad3	      (4) bit (36);
  3    27 
  3    28 /* internal static */
  3    29 
  3    30      declare condition_info_version_1
  3    31 			      fixed binary internal static options (constant) initial (1);
  3    32 
  3    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
  1    81 
  1    82 
  1    83 	mstxn_code = 0;
  1    84 	mstxn_txn_id = "0"b;
  1    85 	
  1    86 	if ^mstxn_transactions_needed			/* only need transactions */
  1    87 	     then goto mstxn_exit;			/* for protected page files */
  1    88 	mstxn_retries = 0;
  1    89 	call transaction_manager_$get_current_txn_id (mstxn_txn_id, mstxn_code);
  1    90 	if mstxn_code ^= dm_error_$no_current_transaction	/* and if none already in progress */
  1    91 	     then do;				
  1    92 	     user_started_transaction = "1"b;
  1    93 	     user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  1    94 	     mstxn_txn_id = "0"b;			/* you didn't start it, it's none of your business */
  1    95 	     goto mstxn_exit;	
  1    96 	end;
  1    97 
  1    98 	user_started_transaction = "0"b;
  1    99 	call transaction_manager_$begin_txn (TM_NORMAL_MODE, 0, mstxn_txn_id, mstxn_code);
  1   100 	user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  1   101 
  1   102 mstxn_cleanup:
  1   103 proc;
  1   104 
  1   105 /*  This procedure MUST be called by a cleanup handler. */
  1   106 
  1   107           if mstxn_txn_id ^= "0"b
  1   108           then do;
  1   109 	     call transaction_manager_$abort_txn (mstxn_txn_id, mstxn_temp_code);
  1   110 	     if mstxn_temp_code ^= 0
  1   111 		then call transaction_manager_$abandon_txn (mstxn_txn_id, mstxn_temp_code);
  1   112 	end;
  1   113 	
  1   114      end mstxn_cleanup;
  1   115 
  1   116 mstxn_any_other:
  1   117 proc;
  1   118 
  1   119 /*  This procedure MUST be called by an any_other handler. */
  1   120 
  1   121           if mstxn_txn_id ^= "0"b
  1   122           then do;
  1   123 	     call find_condition_info_ (null (), addr(mstxn_condition_info), mstxn_temp_code);
  1   124 	     if mstxn_condition_info.condition_name = "transaction_deadlock_"
  1   125 		then do;
  1   126 		mftxn_code = dm_error_$lock_deadlock;
  1   127 		goto mftxn_check_code;
  1   128 	     end;
  1   129 	     else if mstxn_condition_info.condition_name = "transaction_bj_full_"
  1   130 		| mstxn_condition_info.condition_name = "transaction_lock_timeout_"
  1   131 		then do;
  1   132 		mftxn_code = dm_error_$bj_journal_full;
  1   133 		goto mftxn_check_code;
  1   134 	     end;
  1   135 	     else call transaction_manager_$handle_conditions;
  1   136 	end;
  1   137 	else call continue_to_signal_ (mstxn_code);	/* code returned will always be zero */
  1   138      end mstxn_any_other;
  1   139      
  1   140 mstxn_exit:
  1   141      
  1   142 /* ------ END INCLUDE FILE	          mrds_start_transaction.incl.pl1 --------------------------- */
      466 
      467 	if mstxn_code ^= 0
      468 	then call error (mstxn_code);
      469 
      470 	dbcb.user_started_transaction = user_started_transaction;
      471 	if rel_index < 0 then
      472 	     ;					/* ignore selection expr, when only deleting temp rel */
      473 	else do;
      474 		call
      475 		     mrds_dsl_translate (dbcb_ptr, area_ptr,
      476 		     mrds_data_$caller_define_temp_rel, se_ptr, se_len, appl_ptr,
      477 		     adpl_ptr, num_args, icode);
      478 		if icode ^= 0 then
      479 		     call error (icode);
      480 		if ^dbcb.val_dtr then
      481 		     call error (mrds_error_$inval_dtr_expr);
      482 
      483 		if dbcb.ss_ptr ^= null then do;	/* set ptrs needed later */
      484 			ss_ptr = dbcb.ss_ptr;
      485 			select_list_ptr = select_sets.items.select_ptr (1);
      486 			range_ptr = select_sets.items.range_ptr (1);
      487 			ti_ptr = select_sets.items.ti_ptr (1);
      488 			self_defined = "0"b;
      489 			do i = 1 to select_sets.nitems while (^self_defined & rel_index > 0);
      490 			     self_defined = check_self_definition (select_sets.items (i).range_ptr, rel_index);
      491 			end;
      492 		     end;
      493 		else do;
      494 			range_ptr = dbcb.range_ptr;	/* initialize */
      495 			select_list_ptr = dbcb.select_ptr;
      496 			ti_ptr = dbcb.ti_ptr;
      497 			self_defined = "0"b;
      498 			if rel_index > 0
      499 			then self_defined = check_self_definition (range_ptr, rel_index);
      500 		     end;
      501 		stv_number_of_dimensions = mrds_data_$max_attributes;
      502 		allocate simple_typed_vector set (simple_typed_vector_ptr)
      503 		     in (work_area);
      504 		simple_typed_vector.type = SIMPLE_TYPED_VECTOR_TYPE;
      505 	     end;
      506 
      507 	if self_defined				/* this saves the actual user requested temp */
      508 	then do;					/* rel index and sets up to use a temporary */
      509 		actual_rel_index = rel_index;		/* temp rel index */
      510 		rel_index = mrds_data_$max_temp_rels + 1;
      511 		tri = rel_index;
      512 	     end;
      513 	else actual_rel_index = tri;
      514 
      515 	if rel_index ^= 0 then /* if redefining an old temp rel */
      516 	     call delete_temp_rel_file;		/* Delete the existing file for this temp_rel */
      517 	if rel_index < 0 then
      518 	     rel_index = 0;				/* only deleting previously defined temp rel */
      519 	else do;					/* redefine or initial define */
      520 		call create_temp_rel_file;		/* Create a new temp_rel file for this temp_rel */
      521 		ntuples_retrieved = 0;
      522 		dbcb.last_store_rel_name = "!!!!!!!... ...!!!!!"; /*  Temparory store bad rel name incase this store fails */
      523 		call mu_get_tuple (dbcb_ptr, area_ptr, rmri_ptr, simple_typed_vector_ptr, icode); /* get a tuple */
      524 		do while (icode = 0);		/* so long as there are tuples to be retrieved */
      525 		     call
      526 			mu_store$store_direct (dbcb_ptr, rmri_ptr, simple_typed_vector_ptr,
      527 			icode);			/* add tuple */
      528 		     if icode = 0 | icode = dm_error_$key_duplication then do;
      529 						/* ignore duplicates */
      530 			     if icode = 0 then
      531 				ntuples_retrieved = ntuples_retrieved + 1;
      532 			     dbcb.another_flag = "1"b;
      533 			     call mu_get_tuple (dbcb_ptr, area_ptr, rmri_ptr, simple_typed_vector_ptr, icode);
      534 			end;
      535 		end;
      536 		if icode = mrds_error_$tuple_not_found then do; /* allow empty temp rels */
      537 			rm_rel_info.current_tuple_population
      538 			     = ntuples_retrieved;
      539 			rm_rel_info.last_statistics_update_time,
      540 			     rm_rel_info.last_statistics_update_s_e_ref_num = 0;
      541 		     end;
      542 		else call error (icode);
      543 		if rel_index = 0 then /* A new temp_rel file was created */
      544 		     rel_index = tri;		/* let caller know the index */
      545 
      546 		if self_defined
      547 		then call complete_definition;
      548 
      549 	     end;
      550 	code = 0;
      551 exit:
      552 
      553 	mftxn_code = code;
  4     1 /* ====== BEGIN INCLUDE FILE           mrds_finish_transaction.incl.pl1 =========================== */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  4     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  4     8*     This entry is being made to cover the change made on 85-05-06 by Thanh
  4     9*     Nguyen. The code now checks a local flag. (mrds error list #136).
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 
  4    13 /*
  4    14*                    BEGIN_DESCRIPTION
  4    15*
  4    16*   A generalized routine accessed by all MRDS modules that begin and commit 
  4    17*   transactions.  The intent is that it be executed as inline code. It is 
  4    18*   assumed that mrds_start_transaction was executed previously in the 
  4    19*   procedure.  Prior to this include file the program should assign the value 
  4    20*   of its local error code to mftxn_code.  The program utilizing this
  4    21*   include file must supply a function labeled should_rollback that returns
  4    22*   bit (1).  This routine should examine the error code mftxn_code and whether
  4    23*   the transaction should be aborted or rolled back.  "0"b means abort and "1"b
  4    24*   means rollback.  This procedure may choose to simply return "0"b as it 
  4    25*   appears that MRDS will generally NOT rollback transactions.  This routine
  4    26*   does rollback and restart if the before journal is full but only attempts it
  4    27*   once.  A procedure labelled restore_significant_data must also be supplied, 
  4    28*   where any data that was saved prior to the transaction is restored.  A 
  4    29*   procedure consisting solely of a return statement can be supplied if 
  4    30*   necessary.  After execution of this include file, mftxn_code must be
  4    31*   examined.  If it was 0 before entering the code and is non-zero afterward,
  4    32*   then the commit has failed.  Otherwise it will be unchanged.
  4    33*
  4    34*                    END_DESCRIPTION
  4    35*
  4    36*   Written 82-09-30 by Paul W. Benjamin.
  4    37*   Modified 83-01-13 by PWB to add retry on deadlocks and to return a non-zero 
  4    38*                     error code only when the transaction is in an error state.
  4    39*   Modified 83-02-04 by PWB to reset transaction id to 0 upon completion.
  4    40*   Modified 83-05-05 by PWB to abort when rollback fails, abandon when abort
  4    41*		 fails, and to abort rather than rollback when bj is full.
  4    42*   Modified 83-05-18 by PWB to use mftxn_temp_code in calls to abandon, abort
  4    43*		 and rollback.
  4    44*   Modified 83-05-19 by PWB to add mftxn_check_code label.  It is transferred
  4    45*		 to by the mstxn_any_other procedure.
  4    46*   Modified 85-04-14 by Thanh Nguyen not to commit the transaction in case of
  4    47*                     the user already started his own transaction.
  4    48*   Modified 85-05-06 by Thanh Nguyen to synchronize this include file between
  4    49*                     the directory >ldd>include and >exl>mrd>i.
  4    50**/
  4    51 
  4    52 dcl dm_error_$bj_journal_full fixed bin(35) ext static;
  4    53 dcl dm_error_$lock_deadlock fixed bin(35) ext static;
  4    54 dcl mftxn_code fixed bin (35);
  4    55 dcl mftxn_temp_code fixed bin (35);
  4    56 dcl transaction_manager_$commit_txn entry (bit (36) aligned, fixed bin (35));
  4    57 dcl transaction_manager_$rollback_txn entry (bit (36) aligned, fixed bin (17), fixed bin (35));
  4    58 	
  4    59 
  4    60 	if mstxn_txn_id = "0"b | user_started_transaction = "1"b	/* No transaction or we did not started it */
  4    61 	     then do;
  4    62 	     mftxn_code = 0;
  4    63 	     goto mftxn_exit;
  4    64 	end;
  4    65 mftxn_check_code:
  4    66 	if mftxn_code = 0
  4    67 	     then do;
  4    68 	     call transaction_manager_$commit_txn (mstxn_txn_id, mftxn_code);
  4    69 	     if mftxn_code ^= 0
  4    70 		then do;
  4    71 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    72 		if mftxn_temp_code ^= 0
  4    73 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    74 	     end;
  4    75 	end;
  4    76 	else do;
  4    77 	     call restore_significant_data;
  4    78 	     if mftxn_code = dm_error_$lock_deadlock	/* retry just once if deadlock */
  4    79 		& mstxn_retries < 1		
  4    80 		then do;
  4    81 		     mstxn_retries = mstxn_retries + 1;
  4    82 		     call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    83 		     if mftxn_temp_code ^= 0
  4    84 			then do;
  4    85 			call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    86 			if mftxn_temp_code ^= 0
  4    87 			     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    88 		     end;
  4    89 		     else do;
  4    90 			mstxn_code = 0;
  4    91 			goto mstxn_exit;		/* go back and try again */
  4    92 		     end;
  4    93 		end;
  4    94 	     else if should_rollback ()		/* let the program decide */
  4    95 		then do;
  4    96 		call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    97 		if mftxn_temp_code ^= 0
  4    98 		     then do;
  4    99 		     call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   100 		     if mftxn_temp_code ^= 0
  4   101 			then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   102 		end;
  4   103 		else do;
  4   104 		     mstxn_code = 0;
  4   105 		     goto mstxn_exit;		/* go back and try again */
  4   106 		end;
  4   107 	     end;
  4   108 	     else do;
  4   109 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   110 		if mftxn_temp_code ^= 0
  4   111 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   112 	     end;
  4   113 	end;
  4   114 	mstxn_txn_id = "0"b;			/* should never be nonzero unless there is a txn */
  4   115 mftxn_exit:
  4   116      
  4   117 /* ------ END INCLUDE FILE	          mrds_finish_transaction.incl.pl1 --------------------------- */
      554 
      555 	if mftxn_code ^= 0
      556 	then code = mftxn_code;
      557 
      558 	if dbcb_ptr = null () then
      559 	     ;
      560 	else if dbcb.def_temp_rel_area_ptr ^= null then
      561 	     call mu_release_area (dbcb.def_temp_rel_area_ptr);
      562 	return;					/* Return to the caller with a code */
      563 
      564 get_temp_rel_population:
      565      entry (a_db_index, temporary_relation_index, tuple_count, a_error_code);
      566 
      567 /* entry to get the number of tuples in a given temp
      568*   rel definition, given it's temp rel index.  Note that no transactions
      569*   need be started by this entry point.  It is used exclusively as an
      570*   internal entry point by dsl_$get_population.  This module will have
      571*   already started a transaction */
      572 
      573 	a_error_code, tuple_count = 0;		/* init */
      574 	no_recurse = "0"b;
      575 	entry_point_name = "get_temp_rel_population";
      576 
      577 	call mu_database_index$get_resultant_model_pointer (a_db_index, dbcb_ptr);
      578 	if dbcb_ptr = null () then
      579 	     a_error_code = mrds_error_$invalid_db_index;
      580 	else do;
      581 		rdbi_ptr = dbcb.rdbi_ptr;
      582 
      583 		rmra_ptr = rm_db_info.tra_ptr;
      584 
      585 		if temporary_relation_index <= 0
      586 		     | temporary_relation_index > mrds_data_$max_temp_rels then
      587 		     a_error_code = mrds_error_$undefined_temp_rel_index;
      588 		else do;
      589 			rmri_ptr =
      590 			     rm_rel_array.rel_data.ri_ptr (temporary_relation_index);
      591 
      592 			if rm_rel_array.rel_data.ri_ptr (temporary_relation_index)
      593 			     = null () then
      594 			     a_error_code = mrds_error_$undefined_temp_rel_index;
      595 			else do;
      596 
      597 				tuple_count = rm_rel_info.current_tuple_population;
      598 
      599 			     end;
      600 		     end;
      601 	     end;
      602 
      603 	return;
      604 
      605 del_trels:
      606      entry (a_dbcb_ptr);
      607 
      608 /* Entry to delete temp files.  This entry point is used only internally by
      609*   mrds in dsl_$close.  Thus, it need not start its own transaction. */
      610 
      611 	dcl     a_dbcb_ptr		 ptr;
      612 	dcl     num_defined		 fixed bin;
      613 
      614 	dbcb_ptr = a_dbcb_ptr;
      615 	rdbi_ptr = dbcb.rdbi_ptr;
      616 	rmra_ptr = rm_db_info.tra_ptr;
      617 	area_ptr = null ();
      618 	no_recurse = "0"b;
      619 	entry_point_name = "del_trels";
      620 
      621 	if rmra_ptr ^= null then do;
      622 		tr_dir = get_resultant_dir (dbcb.dbi);
      623 		num_defined = mrds_data_$max_temp_rels;
      624 		do tri = 1 to mrds_data_$max_temp_rels; /* delete all temp files and rels */
      625 		     call delete_temp_rel_file;
      626 		end;
      627 	     end;
      628 
      629 	return;
      630 
      631 get_resultant_dir:
      632      procedure (db_index) returns (char (168));
      633 
      634 /* routine to get the resultant models storage directory */
      635 
      636 	dcl     pathname		 char (168);	/* directory under which resultant model is stored */
      637 	dcl     db_index		 fixed bin (35);	/* local version of databsae opening index */
      638 	dcl     mrds_dsl_resultant_storage$get_opening_temp_dir
      639 				 entry (fixed bin (35), fixed bin (35)) returns (char (168));
      640 						/* gets temp dir for a particular opening */
      641 
      642 /* good index, get a pathname from the dbcb segment pointer */
      643 
      644 	pathname =
      645 	     mrds_dsl_resultant_storage$get_opening_temp_dir (db_index, icode);
      646 	if icode ^= 0 then
      647 	     call error (icode);			/* does not return */
      648 
      649 /* 				The dbcb segment pointer could not be expanded into a pathname. */
      650 
      651 	else return (pathname);			/* good path of model dir found */
      652 
      653      end;
      654 
      655 delete_temp_rel_file:
      656      proc;
      657 
      658 /* Procedure to delete a temporary relation. */
      659 
      660 	dcl     j			 fixed bin;
      661 
      662 	if rm_rel_array.rel_data.ri_ptr (tri) ^= null then do; /* if there */
      663 		rmri_ptr = rm_rel_array.rel_data.ri_ptr (tri); /* clean up file stuff */
      664 
      665 		no_recurse = "1"b;			/* prevent recursive tidy_up calls */
      666 
      667 		if rm_rel_info.opening_id ^= "0"b then do; /* Don't close if not open */
      668 			call mu_cursor_manager_$destroy_and_free_on_opening_id (
      669 			     rm_rel_info.opening_id, dbcb.cursor_storage_area_ptr,
      670 			     dbcb.cursor_ptrs_storage_ptr, dbcb.relmgr_entries.destroy_cursor,
      671 			     dbcb.relmgr_entries.close, icode);
      672 			if icode ^= 0
      673 			then call error (icode);
      674 			call dbcb.destroy_relation_by_path (
      675 			     tr_dir, (rm_rel_info.name), icode);
      676 			if icode ^= 0 then
      677 			     call error (icode);
      678 		     end;
      679 		rm_rel_array.name.submodel (tri),
      680 		     rm_rel_array.rel_data.model_name (tri) = "";
      681 		rm_rel_array.rel_data.ri_ptr (tri) = null;
      682 
      683 		if rmri_ptr ^= null then do;
      684 			do j = 1 to rm_rel_info.num_attr; /* free attr infos */
      685 			     rai_ptr = rm_rel_info.attr_ptrs (j);
      686 			     if rai_ptr ^= null then do;
      687 				     free rm_attr_info in (dbcb.static_area);
      688 				     rai_ptr = null ();
      689 				     rm_rel_info.attr_ptrs (j) = null ();
      690 				end;
      691 			end;
      692 		     end;				/* freeing rel info */
      693 		free rm_rel_info.id_list_ptr -> id_list in (dbcb.static_area);
      694 		free rm_rel_info in (rm_db_info.static_area);
      695 		no_recurse = "0"b;			/* turn off, so temp rel redefinition deletes
      696*						   when no tuple found */
      697 	     end;
      698 
      699      end delete_temp_rel_file;
      700 
      701 create_temp_rel_file:
      702      proc;
      703 
      704 /* Procedure to create a temporary relation. */
      705 
      706 	dcl     actual_rel_pic	 pic "99";
      707 	dcl     cibi_ptr		 ptr;		/* ptr to ci_build_index structure */
      708 	dcl     1 ci_build_index	 based (cibi_ptr),	/* To record which attributes are indexed */
      709 		2 num_indices	 fixed bin,	/* How many? */
      710 		2 index_position	 (max_build_indices refer
      711 				 (ci_build_index.num_indices)) fixed bin; /* Position in attribute */
      712 	dcl     create_index_flags	 bit (36) aligned;	/* Flag bits for create_index call */
      713 	dcl     i			 fixed bin;
      714 	dcl     j			 fixed bin;
      715 	dcl     max_build_indices	 fixed bin;	/* Maximum number of indices */
      716 	dcl     retrieve_id_list_ptr	 ptr;		/* Pointer to id list to be used for gets */
      717 	dcl     SORTING_STYLE	 fixed bin init (1) int static
      718 				 options (constant);/* Create index index style */
      719 	dcl     var_att_index	 fixed bin;
      720 
      721 	rmri_ptr = null ();
      722 	created_resultant = "1"b;
      723 	actual_rel_pic = actual_rel_index;		/* for easier manipulation */
      724 	natts_init = select_list.num_items;
      725 	nvar_atts_init = 0;
      726 	do i = 1 to select_list.num_items;
      727 	     raip = select_list.item.ai_ptr (i);
      728 	end;					/* counting varying attrs */
      729 	nkey_attr_init = 0;
      730 	do i = 1 to select_list.num_items;		/* count keys */
      731 	     if select_list.item.key (i) then
      732 		nkey_attr_init = nkey_attr_init + 1;
      733 	end;
      734 	if nkey_attr_init < 1 then
      735 	     call error (mrds_error_$no_tr_keys);	/* must have key */
      736 
      737 	allocate rm_rel_info in (rm_db_info.static_area);
      738 
      739 	rm_rel_array.rel_data.ri_ptr (tri) = rmri_ptr;
      740 	rm_rel_info.model_name, rm_rel_info.name,
      741 	     rm_rel_array.name.submodel (tri),
      742 	     rm_rel_array.rel_data.model_name (tri) =
      743 	     unique_chars_ ("0"b) || "." || actual_rel_pic || ".temp_rel";
      744 	rm_rel_info.ready_mode = SCOPE_UPDATE;
      745 	rm_rel_info.file_type = TEMPORARY;
      746 	rm_rel_info.tuple_id_len = 36;
      747 	rm_rel_info.retrieve,
      748 	     rm_rel_info.store,
      749 	     rm_rel_info.delete,
      750 	     rm_rel_info.modify = "1"b;
      751 
      752 	rm_rel_info.status_perm,
      753 	     rm_rel_info.delete_tuple_perm,
      754 	     rm_rel_info.append_tuple_perm,
      755 	     rm_rel_info.unused_perm = "1"b;
      756 
      757 	rm_rel_info.total_key = "1"b;
      758 
      759 	rm_rel_info.mdbm_secured = rm_db_info.mdbm_secured; /* temp secured if db is */
      760 
      761 	rm_rel_info.last_model_attr_char_var,
      762 	     rm_rel_info.indexed,
      763 	     rm_rel_info.reserved = "0"b;
      764 
      765 	rm_rel_info.nsec_inds,
      766 	     rm_rel_info.max_key_len = 0;
      767 
      768 	rm_rel_info.num_attr = natts_init;
      769 	rm_rel_info.model_num_attr = natts_init;
      770 	rm_rel_info.nkey_attr = nkey_attr_init;
      771 	rm_rel_info.model_nkey_attr = nkey_attr_init;	/* added on 81-03-17 */
      772 	rm_rel_info.scope_flags_ptr = null;/* temp. relation so no need scope. */
      773 	var_att_index, key_order = 0;
      774 
      775 	il_number_of_ids = select_list.num_items;
      776 	allocate id_list in (rm_db_info.static_area) set (retrieve_id_list_ptr);
      777 	retrieve_id_list_ptr -> id_list.version = ID_LIST_VERSION_1;
      778 	retrieve_id_list_ptr -> id_list.number_of_ids = select_list.num_items;
      779 
      780 /* Set up the structures needed to keep track of indices */
      781 
      782 	allocate id_list in (work_area);
      783 	id_list.version = ID_LIST_VERSION_1;
      784 	id_list.number_of_ids = 0;
      785 
      786 	max_build_indices = select_list.num_items;
      787 	allocate ci_build_index in (work_area);
      788 	ci_build_index.num_indices = 0;
      789 
      790 	tva_number_of_vector_slots = 0;
      791 	tva_number_of_dimensions = select_list.num_items;
      792 	tva_maximum_dimension_name_length = 32;
      793 	allocate typed_vector_array in (work_area);
      794 	typed_vector_array.version = TYPED_VECTOR_ARRAY_VERSION_2;
      795 
      796 	do i = 1 to select_list.num_items;		/* do the attr infos */
      797 
      798 	     raip = select_list.item.ai_ptr (i);	/* pick up one for source attr */
      799 	     allocate rm_attr_info in (rm_db_info.static_area);
      800 	     rm_attr_info.model_name, rm_attr_info.name = raip -> rm_attr_info.name;
      801 
      802 	     do x = 1 by 1 to i - 1;			/* check for duplicate attr selection */
      803 		temp_rai_ptr = select_list.item.ai_ptr (x);
      804 		if rm_attr_info.name = temp_rai_ptr -> rm_attr_info.name then
      805 		     icode = mrds_error_$dup_temp_rel_attr;
      806 	     end;
      807 
      808 	     rm_attr_info.key_attr = select_list.item.key (i);
      809 	     rm_attr_info.index_attr, rm_attr_info.reserved, rm_attr_info.index_id =
      810 		"0"b;
      811 
      812 	     rm_attr_info.read_perm,
      813 		rm_attr_info.modify_perm = "1"b;
      814 
      815 	     rm_attr_info.index_id = "0"b;
      816 	     rm_attr_info.mdbm_secured = rm_rel_info.mdbm_secured;
      817 	     rm_attr_info.defn_order = i;
      818 	     rm_attr_info.model_defn_order = i;
      819 	     rm_attr_info.bit_length = raip -> rm_attr_info.bit_length;
      820 	     retrieve_id_list_ptr -> id_list.id (i) = i;
      821 
      822 /*  Save some of the attribute's information so that we can later create
      823*    the relations and indices */
      824 
      825 	     if select_list.item.index (i) then do;	/* is the attribute indexed? */
      826 		     ci_build_index.num_indices =
      827 			ci_build_index.num_indices + 1;
      828 		     ci_build_index.index_position = i;
      829 		end;
      830 
      831 	     typed_vector_array.dimension_table (i).name =
      832 		raip -> rm_attr_info.name;
      833 	     typed_vector_array.dimension_table (i).descriptor_ptr =
      834 		addr (raip -> rm_attr_info.domain_ptr ->
      835 		rm_domain_info.db_desc);
      836 
      837 
      838 /* ********************************************************************* */
      839 /* 	compute the bit offset within the tuple			*/
      840 
      841 	     rm_attr_info.domain_ptr, rdi_ptr = raip -> rm_attr_info.domain_ptr;
      842 
      843 	     rm_rel_info.attr_ptrs (i) = rai_ptr;
      844 
      845 	     if select_list.item.key (i) then do;
      846 		     rm_attr_info.key_order, key_order = key_order + 1;
      847 		     rm_rel_info.key_attr_ptrs (key_order) = rai_ptr;
      848 		     rm_rel_info.max_key_len =
      849 			rm_rel_info.max_key_len + rm_attr_info.bit_length;
      850 		     id_list.number_of_ids = key_order;
      851 		     id_list.id (key_order) = i;
      852 		end;
      853 	end;					/* initial attr loop */
      854 	rm_rel_info.max_key_len = ceil (rm_rel_info.max_key_len / 9);
      855 
      856 /* ******************************************************************* */
      857 
      858 	rm_rel_info.id_list_ptr = retrieve_id_list_ptr;
      859 
      860 
      861 /*  Now create the relation and the indices */
      862 
      863 	allocate rel_creation_info in (work_area);
      864 	allocate file_create_info in (work_area);
      865 	file_create_info.version = FILE_CREATE_INFO_VERSION_2;
      866 	file_create_info.ci_size_in_bytes = 4096;
      867 	file_create_info.blocking_factor = mrds_data_$relation_blocking_factor;
      868 	file_create_info.flags.protected = "0"b;
      869 	file_create_info.flags.no_concurrency = "1"b;
      870 	file_create_info.flags.no_rollback = "1"b;
      871 	file_create_info.flags.mbz_1 = "0"b;
      872 	file_create_info.ring_brackets (*) = 0;
      873 	file_create_info.mbz_2 = 0;
      874 	file_create_info.mbz_3 = "0"b;
      875 	rel_creation_info.version = REL_CREATION_INFO_VERSION_2;
      876 	rel_creation_info.file_create_info_ptr = file_create_info_ptr;
      877 	rel_creation_info.esm_info_ptr, rel_creation_info.cism_info_ptr
      878 	     = null ();
      879 
      880 	rm_rel_info.opening_id = "0"b;		/* If open fails, we will
      881*					  assume there has been no
      882*					  new relation created */
      883 	call dbcb.relmgr_entries.create_relation (tr_dir,
      884 	     (rm_rel_info.name), rel_creation_info_ptr,
      885 	     typed_vector_array_ptr, rm_rel_info.opening_id,
      886 	     rm_rel_info.rel_id, icode);
      887 
      888 	if icode ^= 0
      889 	then call error (icode);
      890 
      891 /* We're done with the relation, now create the indices (and primary key) */
      892 
      893 	create_index_flags = "0"b;
      894 	relation_index_flags_ptr = addr (create_index_flags);
      895 	relation_index_flags.relation_must_be_empty = "1"b;
      896 	relation_index_flags.index_is_unique = "1"b;	/* For primary key */
      897 	call dbcb.relmgr_entries.create_index (rm_rel_info.opening_id,
      898 	     id_list_ptr, create_index_flags, SORTING_STYLE,
      899 	     rm_rel_info.primary_key_index_id, icode);
      900 	if icode ^= 0
      901 	then call error (icode);
      902 
      903 /*  Create the secondary indices */
      904 
      905 	id_list.number_of_ids = 1;
      906 	relation_index_flags.index_is_unique = "0"b;
      907 
      908 	do j = 1 to ci_build_index.num_indices;
      909 	     id_list.id (1) = ci_build_index.index_position (j);
      910 	     call dbcb.relmgr_entries.create_index (rm_rel_info.opening_id,
      911 		id_list_ptr, create_index_flags, SORTING_STYLE,
      912 		rm_rel_info.attr_ptrs (ci_build_index.index_position (j))
      913 		-> rm_attr_info.index_id, icode);
      914 	     if icode ^= 0
      915 	     then call error (icode);
      916 	end;
      917 
      918      end create_temp_rel_file;
      919 
      920 check_self_definition: proc (range_ptr, rel_index) returns (bit (1));
      921 
      922 /*
      923*   This procedure will return true if any of the  relations  in  the
      924*   defining  SE  are  temporary relations and have an index equal to
      925*   rel_index, i.e. it will return true if the requested temp rel  is
      926*   to be defined in terms of itself.
      927**/
      928 
      929 /* PARAMETERS */
      930 
      931 	dcl     range_ptr		 ptr;		/* (input) pointer to the range structure */
      932 	dcl     rel_index		 fixed bin (35);	/* (input) index of the temp rel to be defined */
      933 
      934 /* AUTOMATIC */
      935 
      936 	dcl     i			 fixed bin;	/* loop index */
      937 	dcl     self_defined_flag	 bit (1) init ("0"b); /* true if the temp rel index appears in the */
      938 						/* range of the defining SE */
      939 
      940 
      941 	do i = 1 to range.num_vars while (^self_defined_flag);
      942 	     if range.tup_var (i).temp_rel
      943 	     then do;
      944 		     if bin (substr (range.tup_var (i).ri_ptr -> rm_rel_info.name, 17, 2)) = rel_index
      945 		     then self_defined_flag = "1"b;
      946 		end;
      947 	end;
      948 
      949 	return (self_defined_flag);
      950 
      951      end;
      952 
      953 complete_definition: proc;
      954 
      955 /*
      956*   This procedure completes the definition of a temp  rel  that  was
      957*   defined  in  terms  of itself.
      958**/
      959 
      960 /* AUTOMATIC */
      961 
      962 	dcl     temporary_index	 fixed bin (35);	/* This will always be max_temp_rels + 1 */
      963 
      964 
      965 	temporary_index = rel_index;
      966 	rel_index = actual_rel_index;
      967 	tri = rel_index;
      968 	call delete_temp_rel_file;
      969 
      970 	rm_rel_array.name (tri).submodel = rm_rel_array.name (temporary_index).submodel;
      971 	rm_rel_array.rel_data (tri).model_name = rm_rel_array.rel_data (temporary_index).model_name;
      972 	rm_rel_array.rel_data (tri).ri_ptr = rm_rel_array.rel_data (temporary_index).ri_ptr;
      973 	rm_rel_array.rel_data (temporary_index).ri_ptr = null ();
      974 
      975 	return;
      976 
      977      end;
      978 
      979 error:
      980      proc (cd);					/* Internal error  procedure */
      981 
      982 /* Error procedure */
      983 
      984 	dcl     cd		 fixed bin (35);
      985 
      986 	if entry_point_name = "del_trels"
      987 	then goto exit;				/* Errors are ignored for that entry point */
      988 	code = cd;				/* Return the error code to caller */
      989 	if no_recurse then
      990 	     cd = original_cd;
      991 	else do;
      992 		original_cd = cd;
      993 		call tidy_up;
      994 	     end;
      995 	go to exit;
      996 
      997      end error;
      998 
      999 	dcl     original_cd		 fixed bin (35);	/* The original error code, in case of recursive calls */
     1000 
     1001 tidy_up:
     1002      proc;
     1003 
     1004 /* Cleanup procedure */
     1005 
     1006 
     1007 
     1008 
     1009 
     1010 	if tri > 0 & tri <= mrds_data_$max_temp_rels + 1 then do;
     1011 		call delete_temp_rel_file;
     1012 		tri = 0;
     1013 	     end;
     1014 	if dbcb_ptr ^= null then
     1015 	     call mrds_dsl_delete_se (dbcb_ptr, (mrds_data_$caller_define_temp_rel), icode);
     1016 
     1017      end tidy_up;
     1018 
     1019 /***********
     1020**
     1021**   These routines are used by the transaction processing include files.
     1022**   Restore_significant_data is called to reinitialize variables in case
     1023**   of a rollback.  Should_rollback determines whether a transaction should
     1024**   be rolled back or aborted on error.  Currently, it is always aborted.
     1025**
     1026***********/
     1027 
     1028 
     1029 restore_significant_data:
     1030      proc;
     1031 
     1032 	dcl     ignore_icode	 fixed bin (35);	/* Ignore errors from mu_cursor_manager_ */
     1033 
     1034 /* Uncreate the resultant if necessary */
     1035 
     1036 	if created_resultant & rmri_ptr ^= null () then do;
     1037 		do i = 1 to rm_rel_info.model_num_attr;
     1038 		     free rm_rel_info.attr_ptrs (i) -> rm_attr_info;
     1039 		end;
     1040 
     1041 
     1042 /* Destroy any cursors if the relation is open.  Ignore any errors. */
     1043 
     1044 		if rm_rel_info.opening_id ^= "0"b
     1045 		then call mu_cursor_manager_$destroy_and_free_on_opening_id
     1046 			(rm_rel_info.opening_id, dbcb.cursor_storage_area_ptr,
     1047 			dbcb.cursor_ptrs_storage_ptr, dbcb.relmgr_entries.destroy_cursor,
     1048 			dbcb.relmgr_entries.close, ignore_icode);
     1049 
     1050 
     1051 /* Restore the rest of the data */
     1052 
     1053 		free rm_rel_info;
     1054 		rmri_ptr, rm_rel_array.rel_data.ri_ptr (tri) = null ();
     1055 	     end;
     1056 	if self_defined
     1057 	then rel_index = actual_rel_index;
     1058 	appl_ptr = save_appl_ptr;
     1059 	adpl_ptr = save_adpl_ptr;
     1060 	num_args = save_num_args;
     1061 
     1062      end restore_significant_data;
     1063 
     1064 
     1065 
     1066 should_rollback:
     1067      proc returns (bit (1));
     1068 	return ("0"b);
     1069 						/* MRDS currently does not do rollbacks (or windows) */
     1070      end should_rollback;
     1071 
     1072 
  5     1 /* BEGIN INCLUDE FILE - dm_rel_creation_info.incl.pl1 */
  5     2 
  5     3 /* format: style1 */
  5     4      dcl	   1 rel_creation_info    aligned based (rel_creation_info_ptr),
  5     5 	     2 version	      fixed bin (35),
  5     6 	     2 file_create_info_ptr ptr,
  5     7 	     2 esm_info_ptr	      ptr,
  5     8 	     2 cism_info_ptr      ptr;
  5     9 
  5    10      dcl	   rel_creation_info_ptr  ptr;
  5    11      dcl	   REL_CREATION_INFO_VERSION_2 fixed bin (35) init (2);
  5    12 
  5    13 /* END INCLUDE FILE - dm_rel_creation_info.incl.pl1 */
     1073 
     1074 
  6     1 /* BEGIN INCLUDE FILE: dm_file_create_info.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*     This include file contains the declaration of the file_create_info
  6     5*     structure.  This structure is used to specify to file_manager_
  6     6*     attributes a file is to have.
  6     7**/
  6     8 
  6     9 /* HISTORY:
  6    10*Written by Jeffery D. Ives, 09/16/82.
  6    11*  (Original concept by Lindsey L. Spratt.)
  6    12*Modified:
  6    13*06/15/84 by Matthew Pierret:  Added ring_brackets. Changed to a char (8)
  6    14*            version.
  6    15*11/07/84 by Matthew Pierret:  Extended mbz_3 to by one word to cover the
  6    16*            gap caused by the double-word alignment of mbz_2.
  6    17**/
  6    18 
  6    19 /* format: style2,ind3 */
  6    20 
  6    21      dcl	   1 file_create_info     aligned based (file_create_info_ptr),
  6    22 	     2 version	      char (8) aligned,
  6    23 	     2 ci_size_in_bytes   fixed bin (35) init (4096),
  6    24 						/* control interval physical size, must be 4096	*/
  6    25 	     2 blocking_factor    fixed bin init (255),	/* # of cis in each msf seg, must be 64 or 255	*/
  6    26 	     2 flags	      unal,
  6    27 	       3 protected	      bit (1) unal init ("1"b),
  6    28 						/* protected against inconsistency		*/
  6    29 	       3 no_concurrency   bit (1) unal init ("0"b),
  6    30 						/* don't protect against concurrent access	*/
  6    31 	       3 no_rollback      bit (1) unal init ("0"b),
  6    32 						/* don't protect against system failure		*/
  6    33 	       3 mbz_1	      bit (15) unal init ("0"b),
  6    34 						/* must be zero for future compatability	*/
  6    35 	     2 ring_brackets      (2) fixed bin (3) unal init (0, 0),
  6    36 						/* write bracket is first element, read bracket is second */
  6    37 	     2 mbz_3	      bit (46) unal init ("0"b),
  6    38 						/* must be zero for future compatability */
  6    39 	     2 mbz_2	      (30) fixed bin (71);	/* must be zero for future compatability	*/
  6    40 
  6    41      dcl	   file_create_info_ptr   ptr;
  6    42 
  6    43      dcl	   FILE_CREATE_INFO_VERSION_2
  6    44 			      char (8) aligned static options (constant) init ("FileCr 2");
  6    45      dcl	   (
  6    46 	   FCI_WRITE_BRACKET_IDX  init (1),
  6    47 	   FCI_READ_BRACKET_IDX   init (2)
  6    48 	   )		      internal static options (constant);
  6    49 
  6    50 /* ************ END OF INCLUDE FILE: dm_file_create_info.incl.pl1 ********** */
     1075 
     1076 
  7     1 /* ***********************************************************
  7     2*   *                                                         *
  7     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
  7     4*   *                                                         *
  7     5*   *********************************************************** */
  7     6 /* BEGIN INCLUDE FILE vu_typed_vector_array.incl.pl1 */
  7     7 
  7     8 /* Written by Lindsey Spratt, 03/04/82.
  7     9*Modified:
  7    10*06/23/82 by Lindsey Spratt: Changed to version 2.  The cv entry declarations
  7    11*	  were altered.  cv_to_typed now takes ptr to the descriptor, ptr to
  7    12*	  the print_vector value (char varying), ptr to the typed_vector
  7    13*	  value location, and a code. cv_to_print now takes ptr to the
  7    14*	  descriptor, ptr to the typed_vector value, the print_vector value
  7    15*	  (char(*) varying), the maximum allowed length for the print_vector
  7    16*	  value, a temp_seg to put the value in if its to big to fit into
  7    17*	  the print_vector, and a code.
  7    18**/
  7    19 
  7    20 /* format: style2,ind3 */
  7    21      dcl	   1 typed_vector_array   based (typed_vector_array_ptr) aligned,
  7    22 	     2 version	      fixed bin (35),
  7    23 	     2 number_of_dimensions
  7    24 			      fixed bin (17),
  7    25 	     2 number_of_vectors  fixed bin (17),
  7    26 	     2 number_of_vector_slots
  7    27 			      fixed bin (17),
  7    28 	     2 maximum_dimension_name_length
  7    29 			      fixed bin (17),
  7    30 	     2 dimension_table    (tva_number_of_dimensions refer (typed_vector_array.number_of_dimensions)),
  7    31 	       3 name	      char (tva_maximum_dimension_name_length
  7    32 			      refer (typed_vector_array.maximum_dimension_name_length)) varying,
  7    33 	       3 descriptor_ptr   ptr,		/* call cv_to_print (descriptor_ptr, typed_value_ptr, */
  7    34 						/* temp_seg_ptr, max_length_for_print_value, */
  7    35 						/* print_value, code) */
  7    36 	       3 cv_to_print      entry (ptr, ptr, ptr, fixed bin (35), char (*) varying, fixed bin (35)),
  7    37 						/* call cv_to_typed (descriptor_ptr, area_ptr, */
  7    38 						/* print_value_ptr, typed_value_ptr, code) */
  7    39 	       3 cv_to_typed      entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  7    40 	     2 vector_slot	      (tva_number_of_vector_slots refer (typed_vector_array.number_of_vector_slots))
  7    41 			      pointer;
  7    42 
  7    43      dcl	   typed_vector_array_ptr ptr;
  7    44      dcl	   tva_number_of_vector_slots
  7    45 			      fixed bin;
  7    46      dcl	   tva_number_of_dimensions
  7    47 			      fixed bin;
  7    48      dcl	   tva_maximum_dimension_name_length
  7    49 			      fixed bin;
  7    50      dcl	   TYPED_VECTOR_ARRAY_VERSION_2
  7    51 			      fixed bin (35) int static options (constant) init (2);
  7    52 
  7    53 /* END INCLUDE FILE vu_typed_vector_array.incl.pl1 */
     1077 
     1078 
  8     1 /* BEGIN INCLUDE FILE - dm_id_list.incl.pl1 */
  8     2 
  8     3 /* DESCRIPTION
  8     4*        The id_list structure is used to identify attributes, fields and
  8     5*   dimensions by various modules of the Data Management System.
  8     6**/
  8     7 
  8     8 /* HISTORY:
  8     9*Written by Matthew Pierret, '82.
  8    10*Modified:
  8    11*08/17/83 by Matthew Pierret: Made version constant 'internal static options
  8    12*            (constant)' and to initialize automatic variables.
  8    13**/
  8    14 
  8    15 /* format: style2,ind3 */
  8    16      dcl	   1 id_list	      aligned based (id_list_ptr),
  8    17 	     2 version	      fixed bin (35),
  8    18 	     2 number_of_ids      fixed bin (17),
  8    19 	     2 id		      (il_number_of_ids refer (id_list.number_of_ids)) fixed bin (17);
  8    20 
  8    21      dcl	   id_list_ptr	      ptr init (null);
  8    22      dcl	   il_number_of_ids	      fixed bin (17) init (-1);
  8    23      dcl	   ID_LIST_VERSION_1      fixed bin (17) init (1) internal static options (constant);
  8    24 
  8    25 /* END INCLUDE FILE - dm_id_list.incl.pl1 */
     1079 
     1080 
  9     1 /*  BEGIN INCLUDE FILE - dm_relation_index_flags.incl.pl1 */
  9     2 
  9     3 /* DESCRIPTION:
  9     4*
  9     5*	This structure is used to control the creation of an index by the 
  9     6*     relation_manager_.
  9     7**/
  9     8 
  9     9 /* HISTORY:
  9    10*
  9    11*Written by Lindsey Spratt, 09/20/83.
  9    12*Modified:
  9    13**/
  9    14 
  9    15 /* format: style2,ind3 */
  9    16      dcl	   1 relation_index_flags based (relation_index_flags_ptr) aligned,
  9    17 	     2 relation_must_be_empty
  9    18 			      bit (1) unal,
  9    19 	     2 index_is_clustering
  9    20 			      bit (1) unal,
  9    21 	     2 index_is_unique    bit (1) unal,
  9    22 	     2 pad	      bit (33) unal;
  9    23 
  9    24      dcl	   relation_index_flags_ptr
  9    25 			      ptr init (null);
  9    26 
  9    27 /*  END INCLUDE FILE - dm_relation_index_flags.incl.pl1 */
     1081 
     1082 
 10     1 /* BEGIN mrds_dbcb.incl.pl1 -- jaw, 11/7/78 */
 10     2 
 10     3 
 10     4 
 10     5 /****^  HISTORY COMMENTS:
 10     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
 10     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
 10     8*     This entry is being made to cover the change made on 85-07-01 by Thanh
 10     9*     Nguyen. The scopes_changed flag was added to make checking for this
 10    10*     more efficient (mrds error list #137).
 10    11*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
 10    12*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
 10    13*     Add a bit called dont_check_txn_id to indicate whether or not we should
 10    14*     care if multiple txns use the same selection_expression. (mrds #156)
 10    15*  3) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
 10    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
 10    17*     Added parser_work_area_ptr and mrds_se_info_ptr for new parser.
 10    18*                                                   END HISTORY COMMENTS */
 10    19 
 10    20 
 10    21 /* WARNING
 10    22*          If the dbcb structure is changed then the mrds_data_
 10    23*          item saved_res_version MUST be incremented to invalidate all
 10    24*          existing saved resultants
 10    25**/
 10    26 
 10    27 /* HISTORY :
 10    28*
 10    29*   modified by Jim Gray - - 80-10-24, to add new_select_expr bit for
 10    30*   tid_list management
 10    31*
 10    32*   81-1-9 Jim Gray : added like reference for  ease  in  making  the
 10    33*   phony resultant in mu_database_index, without having the area dcl
 10    34*   included.
 10    35*
 10    36*   81-06-17 Roger Lackey :  added  last_store_rel_name  for  use  by
 10    37*   mrds_dsl_store
 10    38*
 10    39*   81-06-26 Roger Lackey : Added no_optimize and  print_search_order
 10    40*   switches
 10    41*
 10    42*   81-07-06 Jim Gray : added identifier for  the  current  selection
 10    43*   expression,  so  that relation statistics can be updated relative
 10    44*   to number of selection expressions seem. Also  removed  init  for
 10    45*   last_store_rel_name,   as   this   iw   now   properly   done  in
 10    46*   mrds_dsl_init_res.
 10    47*
 10    48*   81-07-17  Roger Lackey : added pred_ptr and unused_ptrs.
 10    49*
 10    50*   82-08-19  Mike Kubicar : added store_vector field.  This is needed
 10    51*   for the conversion to the relation manager.
 10    52*
 10    53*   82-08-23 Davids: added the relmgr_entries and access_costs
 10    54*   substructures so that the entries and costs can change
 10    55*   depending on the type of database that is opened.
 10    56*
 10    57*   82-09-09 Mike Kubicar : added modify_vector field.  This is needed
 10    58*   since modify uses a different vector type (general) than does store.
 10    59*
 10    60*   82-09-20 Davids: changed names of (store modify)_vector to
 10    61*   (store modify)_vector_ptr. Also (delete modify)_tuple_by_id to
 10    62*   (delete modify)_tuples_by_id. added the element cursor_storage_ptr
 10    63*   which should be inited to null and will be set by mu_cursor_manager_$get
 10    64*   during the first call.
 10    65*
 10    66*   82-09-21 Davids: renamed cursor_storage_ptr to cursor_ptrs_storage_ptr
 10    67*   since it deals with the pointers to the cursors and not the cursors
 10    68*   themelves and added the element cursor_storage_area_ptr which points
 10    69*   to the area where the cursors are kept.
 10    70*
 10    71*   82-09-22 Davids: renamed the transact_ctl_seg to transactions_needed.
 10    72*   the transact_ctl_seg always had a value of 0 and really didn't mean
 10    73*   anything.
 10    74*
 10    75*   82-09-22 Mike Kubicar : added create_relation, create_index and
 10    76*   destroy_relation_by_opening to relmgr_entries.  They are needed
 10    77*   by mrds_dsl_define_temp_rel.
 10    78*
 10    79*   82-09-24 Donna Woodka : added  put_tuple to  relmgr_entries. It
 10    80*   is needed by mu_store.
 10    81*
 10    82*   82-11-12 Davids: changed the declaration of the access_costs from fixed
 10    83*   bin to float bin since the values are not integers.
 10    84*
 10    85*   83-02-02 Davids: added the dbc_uid element. This will allow mrds to make
 10    86*   sure that the dbc_ptr still points to the correct segment. Element was 
 10    87*   added to the end of the structure to allow modules that don't use
 10    88*   the element to continue to reference the dbcb structure without recompiling.
 10    89*
 10    90*   83-02-25 Davids: added the concurrency_on and rollback_on elements. These
 10    91*   are needed so that temp rels can be created with the same file attributes
 10    92*   as the permanent relations.
 10    93*
 10    94*   83-05-02 Mike Kubicar : Deleted get_next_search_specification_ptr and
 10    95*   added the resultant_in_pdir bit.
 10    96*
 10    97*   83-05-18 Davids: reduced the number of reserved bits to 14 (from 15) and
 10    98*   added the res_already_made element.
 10    99*
 10   100*   83-05-24 Mike Kubicar : Updated the relation manager calling sequences.
 10   101*
 10   102*   83-08-03 Mike Kubicar : Added the element_id_list_segment_ptr and removed
 10   103*   one of the unused pointers.
 10   104*
 10   105*   83-09-20 Ron Harvey: Added relmgr_entries.get_population.
 10   106*
 10   107*   84-08-27 John Hergert:  Created compiled_se_info_ptr from unused_ptrs(2)
 10   108*   leaving unused_ptrs(1).
 10   109*
 10   110*   85-01-15 Thanh Nguyen:  Added the work_area_ptr and removed the last
 10   111*   unused_ptrs (1).
 10   112*
 10   113*   85-04-12 Thanh Nguyen:  Added user_started_transaction and 
 10   114*   non_shared_to_shared flags.  Also added se_transaction_id and some more
 10   115*   spare ptrs, entries and reserved storages for future enhancement, since
 10   116*   we changed the saved_res_version from rslt0001 to rslt0002.
 10   117*
 10   118*   85-07-01 Thanh Nguyen:  Added scopes_changed flag.  This flag is set by
 10   119*   common routine of mrds_dsl_set_scope, reset by mrds_dsl_optimize and 
 10   120*   mrds_dsl_gen_srch_prog when building of a new search_vars.
 10   121**/
 10   122 
 10   123 
 10   124 /* this structure is based on the {unique_name}.mrds.dbcb segment
 10   125*   that constitutes the non-secure portion of the resultant model that is
 10   126*   created during the opening of a database. it contains variables that
 10   127*   are used during the runtime access of the database, and an area
 10   128*   for evaluation of requests. it points to four other
 10   129*   segments in the resultant model, {unique_name}.mrds.rdbi, the secure
 10   130*   portion of the resultant(see mdbm_rm_db_info.incl.pl1),
 10   131*   {unique_name}.mrds.select, an area for selection expression evaluation,
 10   132*   {unique_name}.mrds.curdat, and {unique_name}.mrds.stadat, two segments
 10   133*   used in the elimination of duplicate tuples during a retrieve.
 10   134*   the dbcb area holds the structure in mdbm_scope_info.incl.pl1
 10   135*   that is used when the database is using the file scope mechanism
 10   136*   for concurrency control over file readying. the segment overlayed via
 10   137*   mrds_dbc.incl.pl1 structure is pointed to and also handles concurrency control,
 10   138*   across database openings. the pointer to this dbcb structure is kept in a table
 10   139*   which associates database indexes(returned from a call to dsl_$open), with particular
 10   140*   opening instances of resultant models. (see mu_database_index routine) */
 10   141 
 10   142      dcl	   1 dbcb		      aligned based (dbcb_ptr), /* DBCB -- non-secure portion */
 10   143 	     2 data	      like dbcb_data,
 10   144 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (dbcb.static_area))));
 10   145 
 10   146      dcl	   dbcb_ptr	      ptr;
 10   147 
 10   148      declare 1 dbcb_data	      based,		/* info part of dbcb, separated out so that
 10   149*						   like references can avoid getting the area declaration */
 10   150 	     2 rdbi_ptr	      ptr,		/* pointer to write protected mdbm_util_ info. */
 10   151 	     2 range_ptr	      ptr,		/*  ptr to range structure, or null */
 10   152 	     2 select_ptr	      ptr,		/* ptr to select list, or null */
 10   153 	     2 sv_ptr	      ptr,		/* pointer to search variables */
 10   154 	     2 so_ptr	      ptr,		/* pointer to search operators */
 10   155 	     2 ti_ptr	      ptr,		/* pointer to tuple info */
 10   156 	     2 lit_ptr	      ptr,		/* pointer to the literal area, or null */
 10   157 	     2 current_ptr	      ptr,		/* ptr to select list resulting from -current clause */
 10   158 	     2 ss_ptr	      ptr,		/* ptr to select sets block if not simple s.e. */
 10   159 	     2 retr_info_ptr      ptr,		/* ptr to retrieve info area */
 10   160 	     2 trel_info_ptr      ptr,		/* ptr to retrieve info area */
 10   161 	     2 sti_ptr	      ptr,		/* pointer to store info */
 10   162 	     2 dbc_ptr	      ptr,		/*  pointer to the data base control segment */
 10   163 	     2 sfi_ptr	      ptr,		/* points to head of scalar function list */
 10   164 	     2 scope_ptr	      ptr,		/* points to array of scope tuples */
 10   165 	     2 select_area_ptr    ptr,		/* ptr to area for current selection expression allocations */
 10   166 	     2 current_data_ptr   ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
 10   167*						   for eliminating duplicate tuples. */
 10   168 	     2 static_data_ptr    ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
 10   169*						   for eliminating duplicate tuples. */
 10   170 	     2 store_area_ptr     ptr,		/* temp storage area for dsl_$store */
 10   171 	     2 retrieve_area_ptr  ptr,		/* temp storage for dsl_$retrieve */
 10   172 	     2 modify_area_ptr    ptr,		/* temp storage area for dsl_$modify */
 10   173 	     2 delete_area_ptr    ptr,		/* temp storage area for dsl_$delete */
 10   174 	     2 def_temp_rel_area_ptr ptr,		/* temp storage area for dsl_$define_temp_rel */
 10   175 	     2 pred_ptr	      ptr,		/* Pointer to pred_array */
 10   176 	     2 store_vector_ptr   ptr,		/* Vector structure used during store operations */
 10   177 	     2 modify_vector_ptr  ptr,		/* Used during modifies */
 10   178 	     2 element_id_list_segment_ptr ptr,		/* Points to the segment used to hold element_id_list structures */
 10   179                2 compiled_se_info_ptr ptr,                  /* points to the segment containing all info on compiled sexs */
 10   180 	     2 work_area_ptr        ptr,		/* Work area for encode/decode value allocations in mu_retrieve */
 10   181 	     2 se_info_ptr          ptr,                  /* Points to se_info struct. Primarily for error reports */
 10   182 	     2 parser_work_area_ptr ptr,		/*  work area for parser */
 10   183 	     2 reserved_ptrs      (4) ptr,		/* Reserved for future use */
 10   184 	     2 another_flag	      bit (1) unal,		/* on if predicate was -another */
 10   185 	     2 current_flag	      bit (1) unal,		/* on if predicate was -current clause */
 10   186 	     2 dbc_incr	      bit (1) unal,		/* on if dbc open mode has been incremented for this user */
 10   187 	     2 delete_flag	      bit (1) unal,		/* On if search was called from mrds_dsl_sec_delete */
 10   188 	     2 dup_retain	      bit (1) unaligned,	/* On if dup tuples allowed for retrieval */
 10   189 	     2 prev_select	      bit (1) unal,		/* on if prev. select block processed in this s.e. */
 10   190 	     2 possible_op	      bit (1) unal,		/* on of arith op. allowed */
 10   191 	     2 sel_clause	      bit (1) unal,		/* on if currently in select clause */
 10   192 	     2 dsm_sw	      bit (1) unal,		/* on if data base was opened via data submodel */
 10   193 	     2 val_rtrv	      bit (1) unal,		/* if s.e. valid for retrieve */
 10   194 	     2 val_mod	      bit (1) unal,		/* for modify */
 10   195 	     2 val_del	      bit (1) unal,		/* for delete */
 10   196 	     2 val_dtr	      bit (1) unal,		/* for define temp rel */
 10   197 	     2 transactions_needed bit (1) unal,	/* On => transaction must be started or in progress does
 10   198*                                                                     not imply that the database is of type page_file */
 10   199 	     2 open_mode	      bit (3) unal,		/* 0=>unknown, 1=>r, 2=>u, 3=>er, 4=>eu, >4=>bad */
 10   200 	     2 new_select_expr    bit (1) unal,		/* on => starting a new tid list management period */
 10   201 	     2 no_optimize	      bit (1) unal,		/* On => no optimize */
 10   202 	     2 print_search_order bit (1) unal,		/*  On => print the search order */
 10   203 	     2 resultant_in_pdir  bit (1) unal,		/* On => Temp segments are in the process dir */
 10   204 	     2 res_already_made   bit (1) unal,           /* On => resultant has been made based on a saved copy */
 10   205 	     2 user_started_transaction bit (1) unal,     /* On => user already started his own transaction. */
 10   206 	     2 non_shared_to_shared bit (1) unal,         /* On => user changed the scope from non shared to shared
 10   207*						   inside a sequence of -another selection expression. */
 10   208 	     2 scopes_changed     bit (1) unal,           /* On => scopes had been changed by set_scopes or delete_scopes */
 10   209 	     2 dont_check_txn_id  bit (1) unal,           /* On => cpmd needs same selection exp across multiple txns */
 10   210 	     2 reserved	      bit (10) unal,	/* reserved for future use */
 10   211 	     2 nseq_sch	      fixed bin (35),	/* no. tuples located via sequential search */
 10   212 	     2 nind_sch	      fixed bin (35),	/* no. tuples located via index search */
 10   213 	     2 nhash_sch	      fixed bin (35),	/* no. tuples located via hash search */
 10   214 	     2 nlk_sch	      fixed bin (35),	/* no tuples located via link search */
 10   215 	     2 cur_lit_offset     fixed bin (35),	/* current bit offset in literal string */
 10   216 	     2 dbi	      fixed bin (35),	/* database index for this opening */
 10   217 	     2 last_s_e_id_num    fixed bin (35),	/* identifying number for last selection expression seen */
 10   218 	     2 se_transaction_id  bit (36) aligned,       /* transaction id from beginning of select expression */
 10   219 	     2 last_store_rel_name char (32),		/* Name of relation last used  for store */
 10   220 	     2 cursor_ptrs_storage_ptr ptr,		/* pointer to space where cursor ptrs are stored */
 10   221 	     2 cursor_storage_area_ptr ptr,		/* pointer to area where the cursors are kept */
 10   222 	     2 reserved_words     (10) fixed bin (35),	/* Reserved for future use */
 10   223 	     2 relmgr_entries,			/* relation manager entries */
 10   224 	       3 open	      entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
 10   225 	       3 close	      entry (bit (36) aligned, fixed bin (35)),
 10   226 	       3 create_cursor    entry (bit (36) aligned, ptr, ptr, fixed bin (35)),
 10   227 	       3 destroy_cursor   entry (ptr, ptr, fixed bin (35)),
 10   228 	       3 set_scope	      entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35)),
 10   229 	       3 delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35)),
 10   230 	       3 modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35)),
 10   231 	       3 get_tuple_by_id  entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
 10   232 	       3 get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)),
 10   233 	       3 get_tuple_id     entry (ptr, ptr, ptr, ptr, fixed bin (35)),
 10   234 	       3 put_tuple	      entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
 10   235 	       3 get_count	      entry (ptr, ptr, fixed bin (35), fixed bin (35)),
 10   236 	       3 get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35)),
 10   237 	       3 get_population   entry (ptr, fixed bin (35), fixed bin (35)),
 10   238 	       3 create_relation  entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)),
 10   239 	       3 create_index     entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35)),
 10   240 	       3 destroy_relation_by_path entry (char (*), char (*), fixed bin (35)),
 10   241 	       3 reserved_entries (5) entry (),
 10   242 	     2 access_costs,			/* access costs for permute */
 10   243 	       3 total_primary_key_cost float bin,
 10   244 	       3 access_cost      float bin,
 10   245 	       3 access_overhead  float bin,
 10   246 	       3 us_access_cost   float bin,
 10   247 	       3 os_access_cost   float bin,
 10   248 	     2 dbc_uid	      bit (36) aligned,	/* uid of the segment containing the dbc structure */
 10   249 	     2 concurrency_on     bit (1) unal,		/* "1"b implies dmfile concurrency is being used */
 10   250 	     2 rollback_on	      bit (1) unal;		/* "1"b iomplies before journaling is to be done */
 10   251 
 10   252 /* END mrds_dbcb.incl.pl1 */
 10   253 
 10   254 
     1083 
     1084 
 11     1 /* BEGIN mdbm_rm_db_info.incl.pl1 -- jaw, 11/7/78 */
 11     2 
 11     3 
 11     4 
 11     5 /****^  HISTORY COMMENTS:
 11     6*  1) change(86-08-13,Hergert),, approve(88-06-28,MCR7903),
 11     7*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
 11     8*     Removed change of 84-11-02. i.e. replaced even_word_pad.
 11     9*                                                   END HISTORY COMMENTS */
 11    10 
 11    11 
 11    12 /* WARNING
 11    13*          If the rm_db_info structure is changed then the mrds_data_
 11    14*          item saved_res_version MUST be incremented to invalidate all
 11    15*          existing saved resultants
 11    16**/
 11    17 
 11    18 /*  DESCRIPTION:  This  structure   is   based   on   a   segment
 11    19*   {unique_name}.mrds.rdbi that represents the secure portion of the
 11    20*   resultant model that is created partially at database open  time,
 11    21*   (the rm_file_array, and rm_rel_array) and partially at ready_file
 11    22*   time,    (the    rm_file_info,     rm_rel_info,     rm_attr_info,
 11    23*   rm_domain_info, rm_plink_info and rm_clink_info). it's purpose is
 11    24*   to  provide  an  efficient  means  of  accessing  database  model
 11    25*   information, as seen from the possibly submodel view of the user,
 11    26*   and his current state of "files readied". it is the  secure  part
 11    27*   because  it  contains  the  model  information  which needs to be
 11    28*   protected  from  general  knowledge,  and   this   segment   will
 11    29*   eventually  be  capable  of  being in a lower ring. the structure
 11    30*   itself points to four arrays that are  allocated  in  it's  area,
 11    31*   that  in  turn point to the other structures mentions above, also
 11    32*   allocated in  the  rm_db_info.static_area.  the  arrays  are  the
 11    33*   rm_file_array,  and  rm_rel_array. their are a pair for temporary
 11    34*   relations,  initially  empty,  and  a  pair  for   normal   model
 11    35*   files/relations.  the  normal  rm_file_array  is initialized to a
 11    36*   list of all known file names, the rm_rel_array only gets relation
 11    37*   names   as   files  are  readied.  the  rm_file_array  points  to
 11    38*   rm_file_infos for each file (see mdbm_rm_file_info.incl.pl1)  and
 11    39*   the   rm_rel_array   points  to  rm_rel_info  for  each  relation
 11    40*   "readied". (see mdbm_rm_rel_info.incl.pl1). (the  arrays  are  in
 11    41*   mdbm_rm_file_array.incl.pl1  and mdbm_rm_rel_array.incl.pl1). the
 11    42*   file infos point to contained rel infos, the rel infos  point  to
 11    43*   contained  attr  infos,  and  those in turn to domain infos. (see
 11    44*   mdbm_rm_attr_info.incl.pl1   and    mdbm_rm_domain_info.incl.pl1)
 11    45*   foreign     keys    are    represented    by    the    structures
 11    46*   mdbm_rm_plink_info.incl.pl1, and mdbm_rm_clink_info.incl.pl1. the
 11    47*   pathnames  of the model and submodel, if any, are also maintained
 11    48*   in rm_db_info. the pointer to this rm_db_info segment is obtained
 11    49*   from  the  dbcb  segment tructure(see mrds_dbcb.incl.pl1) see the
 11    50*   individual include files for  further  organization  information,
 11    51*   and particular data structures.
 11    52*
 11    53*   HISTORY:
 11    54*
 11    55*   80-02-01 Jim Gray : Modified to put area on even  word  boundary,
 11    56*   so that define_area_ could be used to make it an extensible area
 11    57*
 11    58*   81-1-9 Jim  Gray  :  added  like  reference  to  make  the  phony
 11    59*   resultant in mu_database_index easier to keep, since no reference
 11    60*   to the area is needed.
 11    61*
 11    62*   81-1-12 Jim Gray : added version of submodel used in  opening  to
 11    63*   resultant.
 11    64*
 11    65*   81-05-13 Rickie E. Brinegar: added the administrator bit  to  the
 11    66*   structure.
 11    67*
 11    68*   81-05-28 Jim Gray : removed pointers to file_arrays,  since  they
 11    69*   are  now  combined  into  the rel_array. Removed the control file
 11    70*   info which was unused. Added pointer  to  head  of  domain  list,
 11    71*   which is to be used to insure only one copy of each domain info.
 11    72*
 11    73*   83-05-19 Davids: Added the  saved_res_version element.
 11    74*
 11    75*   84-11-02 Thanh Nguyen:   Replaced  the  even_word_pad   by   the 
 11    76*   ref_name_proc_ptr  to point  to list  of reference  name of  the
 11    77*   check, encode, or decode proc.
 11    78*
 11    79*   CAUTION: The structure entries from db_version to sm_path  should
 11    80*   not  be moved or have their declarations changed because they are
 11    81*   used in the handling of old version database openings.
 11    82*
 11    83*
 11    84**/
 11    85 
 11    86      dcl	   1 rm_db_info	      aligned based (rdbi_ptr), /* data base info, located at base of res. dm. seg. */
 11    87 	     2 data	      like rm_db_info_data,
 11    88 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (rm_db_info.static_area))));
 11    89 
 11    90      dcl	   rdbi_ptr	      ptr;
 11    91 
 11    92      declare 1 rm_db_info_data      based,		/* separate declaration of info, so others can use
 11    93*						   like reference to it without getting the area as well */
 11    94 	     2 db_version	      fixed bin,		/* version no. of db */
 11    95 	     2 sm_version	      fixed bin unal,	/* version of submodel used unal, 0 if model opening */
 11    96 	     2 val_level	      fixed bin unal,	/* validation level for this db. */
 11    97 	     2 db_path	      char (168),		/* abs. path of db. */
 11    98 	     2 sm_path	      char (168),		/* path of submodel or model */
 11    99 	     2 mdbm_secured	      bit (1) unal,		/* ON => database is secured */
 11   100 	     2 administrator      bit (1) unal,		/* ON => user is an administrator */
 11   101 	     2 pad	      bit (34) unal,	/* for future use */
 11   102 	     2 saved_res_version  char (8),		/* version of the saved resultant in the 
 11   103*                                                               dbcb and rdbi segments in the db dir */
 11   104 	     2 domain_list_ptr    ptr,		/* pointer to head of list of domain_info's */
 11   105 	     2 ra_ptr	      ptr,		/* pointer to rel. array */
 11   106 	     2 tra_ptr	      ptr,		/* to rel array for temp rels */
 11   107 	     2 even_word_pad      fixed bin (71) aligned; /* padding to put area on even word boundary */
 11   108 
 11   109 /* END mdbm_rm_db_info.incl.pl1 */
 11   110 
 11   111 
     1085 
     1086 
 12     1 /* BEGIN mrds_range.incl.pl1 -- jaw, 10/20/78 */
 12     2 
 12     3 /* Modified 83-04-22 by R. Harvey to add needed_bits */
 12     4 
 12     5 dcl 1 range aligned based (range_ptr),
 12     6     2 num_vars fixed bin,				/* number of tuple variables */
 12     7     2 tup_var (mrds_data_$max_tup_var refer (range.num_vars)), /* info for each tuple variable */
 12     8       3 name char (mrds_data_$max_id_len),		/* name of tuple variable */
 12     9       3 temp_rel bit (1) unal,			/* on if temporary relation */
 12    10       3 used bit (1) unal,				/* 1 => this tuple variable is referenced by
 12    11*						   a -select clause. */
 12    12       3 whole_tuple_selected bit (1) unal,		/* the whole tuple variable is referenced in the select clause */
 12    13       3 copy_for_current bit (1) unal,			/* -current requests attributes not previously retrieved */
 12    14       3 copied_for_current bit (1) unal,		/* tuple copied during previous -current */
 12    15       3 reserved bit (31) unal,			/* reserved for future use */
 12    16       3 rel_index fixed bin,				/* index to assoc. relation */
 12    17       3 stv_ptr ptr,				/* simple typed vector */
 12    18       3 idl_ptr ptr,				/* id_list ptr */
 12    19       3 needed_bits aligned,
 12    20         4 attr (mrds_data_$max_attributes) bit (1) unal,
 12    21       3 ri_ptr ptr;					/* pointer to rel info for assoc. relation */
 12    22 
 12    23 dcl  range_ptr ptr;
 12    24 
 12    25 /* END mrds_range.incl.pl1 */
 12    26 
     1087 
     1088 
 13     1 /* BEGIN mrds_select_sets.incl.pl1		rdl,	2/27/79			*/
 13     2 
 13     3 dcl 1 select_sets aligned based (ss_ptr),
 13     4     2 dup_retain bit (1) unal,			/* ON => duplicate selected tuples must be preserved */
 13     5     2 pad bit (35) unal,				/* Resevered for furture use */
 13     6     2 domains (mrds_data_$max_select_items) char (32),	/* domain name of each select item */
 13     7     2 nitems fixed bin,				/* Number of items in this structure */
 13     8     2 items (nitems_init refer (select_sets.nitems)),
 13     9       3 oper_flag bit (1) unal,			/* On => this item is an operator */
 13    10       3 pad bit (35) unal,				/* Reserved for future use */
 13    11       3 op_code fixed bin,				/* Valid only if oper_flag id on
 13    12*						   1 -> union
 13    13*						   2 => intersection
 13    14*						   3 => Difference 			*/
 13    15       3 range_ptr ptr,				/* Valid only if oper_flag  is OFF, these pointers are */
 13    16       3 select_ptr ptr,				/* used by  mrds_dsl_search */
 13    17       3 so_ptr ptr,
 13    18       3 ti_ptr ptr;					/* to tuple info structure for this block */
 13    19 
 13    20 
 13    21 dcl  ss_ptr ptr;					/* Pointer to the selected sets */
 13    22 dcl  nitems_init fixed bin;
 13    23 
 13    24 dcl  UNION fixed bin internal static options (constant) init (1);
 13    25 dcl  INTERSECTION fixed bin internal static options (constant) init (2);
 13    26 dcl  DIFFERENCE fixed bin internal static options (constant) init (3);
 13    27 
 13    28 /* END mrds_dsl_select_sets.incl.pl1					*/
 13    29 
     1089 
     1090 
 14     1 /* BEGIN mrds_select_list.incl.pl1 -- jaw 10/20/78 */
 14     2 
 14     3 /* HISTORY:
 14     4*
 14     5*   81-06-01 Jim Gray : removed user len and type elements,
 14     6*   since mu_convert rather than assign_ is now used.
 14     7*
 14     8*   84-11-22 John Hergert: added fr_ptr
 14     9*
 14    10*/****^  HISTORY COMMENTS:
 14    11*  1) change(86-07-17,Dupuis), approve(86-08-05,MCR7491), audit(86-08-08,Blair),
 14    12*     install(86-08-15,MR12.0-1127):
 14    13*     85-11-22 Hergert: Added variable var_exists so that it may be kept
 14    14*     around per select expression (in sets) and when compiling. (mrds #158)
 14    15*  2) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
 14    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
 14    17*     For new parser, (and general readability) renamed sel_ptr to
 14    18*     select_list_ptr.
 14    19*                                                   END HISTORY COMMENTS */
 14    20 
 14    21 
 14    22 dcl 1 select_list based (select_list_ptr),			/* tabular representation of -select clause */
 14    23     2 num_vars fixed bin,				/* number of free variables */
 14    24     2 mla_ptr ptr,					/* pointer to array of move list pointers */
 14    25     2 fr_ptr ptr,                                           /* pointer to free_raltions struct in mrds_dsl_select_clause */
 14    26     2 num_items fixed bin,				/* number of attributes specified in select list */
 14    27     2 var_exists (36) bit(1),
 14    28     2 item (mrds_data_$max_select_items refer (select_list.num_items)),
 14    29       3 must_convert bit (1) unal,			/* on if conversion required */
 14    30       3 key bit (1) unal,				/* on if to be key attr. in temp. rel. */
 14    31       3 index bit (1) unal,				/* on if index attribute in temp rel */
 14    32       3 reserved bit (33) unal,			/* reserved for future use */
 14    33       3 var_index fixed bin,				/*  index of assoc. tuple variable */
 14    34       3 ai_ptr ptr,					/* ptr to attr_info */
 14    35       3 user_desc_ptr ptr,				/* to descriptor for user value */
 14    36       3 user_ptr ptr ;				/* pointer to user's area */
 14    37 
 14    38 dcl  select_list_ptr ptr int automatic init (null ());
 14    39 
 14    40 dcl 1 move_list_array (select_list.num_vars) based (select_list.mla_ptr),
 14    41     2 var_index fixed bin,
 14    42     2 ml_ptr ptr;
 14    43 
 14    44 /* END mrds_select_list.incl.pl1 */
 14    45 
     1091 
     1092 
 15     1 /* BEGIN mrds_tuple_info.incl.pl1 -- jaw 11/2/78 */
 15     2 
 15     3 /* HISTORY:
 15     4*
 15     5*   Modified in March 1977 by O Friesen to hold allocated ptr and length
 15     6*   82-10-29 Mike Kubicar : Made tuple_id aligned
 15     7*
 15     8**/
 15     9  
 15    10 dcl 1 tuple_info aligned based (ti_ptr),
 15    11     2 num_tuples fixed bin,				/* no. of tuples for which info given */
 15    12     2 tuple (ti_ntuples_init refer (tuple_info.num_tuples)),
 15    13       3 tuple_ptr ptr,				/* pointer to found tuple */
 15    14       3 tuple_id bit (36) aligned,			/* tuple id for  found tuple */
 15    15       3 var_index fixed bin;				/* index to tuple variable  */
 15    16 
 15    17 dcl  ti_ptr ptr;
 15    18 dcl  ti_ntuples_init fixed bin;
 15    19 
 15    20 /* END mrds_tuple_info.incl.pl1 */
 15    21 
     1093 
     1094 
 16     1 /* BEGIN mdbm_rm_rel_array.incl.pl1 -- jaw, 8/9/78 */
 16     2 
 16     3 /* WARNING
 16     4*          If the rm_rel_array structure is changed then the mrds_data_
 16     5*          item saved_res_version MUST be incremented to invalidate all
 16     6*          existing saved resultants
 16     7**/
 16     8 
 16     9 /* HISTORY:
 16    10*
 16    11*   81-05-28 Jim Gray : added  model_name  and  file_id  as  part  of
 16    12*   combining   funtions   of   file_array  and  rel_array  into  one
 16    13*   structure. This will only allow 1 relation per file model now.
 16    14*   Also changed structure to allow more efficient searching
 16    15*   via and index builtin, rather than a programmed loop.
 16    16*   Search is now I = index(string(rm_rel_array.name), "!" || in_name)
 16    17*   with I = ((I - 1) / 33) + 1 to convert from a char to array index.
 16    18*
 16    19**/
 16    20 
 16    21 
 16    22 /* this structure is allocated in the static are of the structure
 16    23*   in  mdbm_rm_db_info.incl.pl1,  the secure portion of the database
 16    24*   resultant  model  upon  opening  the  database.  two  copies  are
 16    25*   allocated,  one for temporary relations, initially empty, and one
 16    26*   for relations known to the opener, which has a length  sufficient
 16    27*   for  all  relations known to the user, but whose names, etc. will
 16    28*   not be filled  in  until  the  file  containing  that  particular
 16    29*   relation  is readied. the rm_db_info structure contains a pointer
 16    30*   to the rel_arrays, and the array entries, when  "readied",  point
 16    31*   to  the  mdbm_rm_rel_info.incl.pl1  structures  containing  model
 16    32*   information about the relation, it's attributes, etc. */
 16    33 
 16    34 dcl 1 rm_rel_array aligned based (rmra_ptr),		/* array of open relations */
 16    35     2 num_rels fixed bin,				/* no. rels in db. */
 16    36     2 name (1:rm_num_rels_init refer (rm_rel_array.num_rels)) unal,
 16    37       3 mark char (1) unal,				/* separator character = "!" */
 16    38       3 submodel char (32) unal,			/* name of relation is submodel view, model opening => model name */
 16    39     2 rel_data (rm_num_rels_init refer (rm_rel_array.num_rels)),
 16    40       3 model_name char (30),				/* name of relation in model */
 16    41       3 ri_ptr ptr unal ;				/* pointer to rm_rel_info */
 16    42 
 16    43 dcl  rmra_ptr ptr;
 16    44 dcl  rm_num_rels_init fixed bin;
 16    45 
 16    46 /* END mdbm_rm_rel_array.incl.pl1 */
 16    47 
 16    48 
     1095 
     1096 
 17     1 /* BEGIN mdbm_rm_rel_info.incl.pl1 -- jaw, 11/16/78 */
 17     2 
 17     3 /* WARNING
 17     4*          If the rm_rel_info structure is changed then the mrds_data_
 17     5*          item saved_res_version MUST be incremented to invalidate all
 17     6*          existing saved resultants
 17     7**/
 17     8 
 17     9 /* HISTORY:
 17    10*
 17    11*   Modified by Jim Gray - - May 1980, to  include  model  number  of
 17    12*   attributes,   and   varying  attributes,  so  that  partial  view
 17    13*   submodels will have the  info  needed  to  properly  set  up  the
 17    14*   varying length array headers in the tuple structure.
 17    15*
 17    16*   Modified  by  Jim  Gray  -  -  80-11-06,  to  rename   r_perm   =
 17    17*   status_perm,     s_perm    =    append_tuple_perm,    d_perm    =
 17    18*   delete_tuple_perm, and make m_perm = unused_perm.
 17    19*
 17    20*   81-01-23 Jim Gray : added bit to indicate whether the last  model
 17    21*   view attribute was varying character or bit, since a partial view
 17    22*   submodel will not have this information in the resultant, and  it
 17    23*   is  needed for determining the new tuple length in mus_mod_ubtup,
 17    24*   since with exact length storage  of  varying  length  attributes,
 17    25*   each  tuple  can  be  a  different  length,  which is can only be
 17    26*   determined by examining the tuple itself.
 17    27*
 17    28*   81-01-29 Jim Gray : added curent  tuple  count,  to  provide  for
 17    29*   interface  to  allow  temp  rel  population  to  be known, and to
 17    30*   provide a more efficient means of finding an approx. current perm
 17    31*   relation population.
 17    32*
 17    33*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
 17    34*   blocked  files, foreign keys, and ids procedures. Also set number
 17    35*   of files per rel to a constant of 1.
 17    36*
 17    37*   81-05-28 Jim Gray : combined data  from  rm_file_info  into  this
 17    38*   structure so that only one structure per relation is needed.
 17    39*
 17    40*   81-07-02 Jim Gray : added total_key and dup_key vfile  statistics
 17    41*   counts.   Also  added  number  of  operations  count  since  last
 17    42*   statistics update, and a time  since  the  statistics  were  last
 17    43*   updated.
 17    44*
 17    45*   81-07-06 Jim Gray :  added  a  per  selection  expression  update
 17    46*   identifier so that small relations could be updated on a per S.E.
 17    47*   basis
 17    48*
 17    49*   82-04-21 R. Lackey : Added number_selected (ri_niocbs_init refer (rm_rel_info.niocbs)) fixed bin (35)
 17    50*   to end of structure   TR 12205 (Suggestion).
 17    51*   
 17    52*   82-08-19 D. Woodka :  Removed  rm_rel_info.max_data_len  field for
 17    53*   the DMS conversion. 
 17    54*
 17    55*   82-08-30 Davids: added the opening_id element and removed the iocb
 17    56*   array and the niocb element for DMS conversion. Also removed the
 17    57*   number_selected array (and ri_niocbs_init) since subsets are not
 17    58*   going to be used.
 17    59*
 17    60*   82-09-20 Mike Kubicar : changed rm_rel_info.rel_id to bit (36) aligned
 17    61*   so that it can be used with relation manager.  Also added
 17    62*   rm_rel_info.primary_key_index_id for relation manager.
 17    63*
 17    64*   82-09-22 Mike Kubicar : Removed the, now useless, fields var_attr_ptrs,
 17    65*   nvar_atts, model_nvar_atts.
 17    66*
 17    67*   82-09-24 Davids: Removed current_key_count and current_dup_key_count
 17    68*   since the duplicate key count for each secondary index is now being
 17    69*   kept in the attr_info structure and key_count was only needed to
 17    70*   help in calculating the average selectivity of each index which
 17    71*   can now be gotten directly from each index's dup key count. Also
 17    72*   removed the file_id element since it is no longer needed for
 17    73*   anything.
 17    74*
 17    75*   82-09-27 Mike Kubicar : removed file_id_len for the same reason file_id
 17    76*   was removed.
 17    77*
 17    78*   82-11-05 Mike Kubicar : added a pointer to an id_list structure to be
 17    79*   used when retrieving tuples from this relation.
 17    80*
 17    81*   83-04-06 Davids: Added the scope_flags_ptr which points to the scope_flags structure
 17    82*   for the relation. Note that this structure is part of the resultant NOT
 17    83*   part of the db.control structure. The scopes are duplicated in the resultant
 17    84*   to reduce contention for the db.control structure. Note also that the pointer
 17    85*   will always point to a scope_flags structure even if no scopes have been
 17    86*   set on the relation, the structure is allocated when the db is opened.
 17    87**/
 17    88 
 17    89 
 17    90 /* DESCRIPTION:
 17    91*
 17    92*   This structure is allocated in the area part of the structure  in
 17    93*   mdbm_rm_db_info.incl.pl1  as  part of the resultant model created
 17    94*   at open  time  for  a  database.  There  will  be  one  of  these
 17    95*   rm_rel_info   structures  for  each  relation  appearing  in  the
 17    96*   database view (there may be less than the total in  the  database
 17    97*   for  a  submodel  openings).  There  will  also  be  one for each
 17    98*   temporary relation currently defined for that opening.
 17    99*
 17   100*   The structure in mdbm_rm_rel_array.incl.pl1 contains pointers  to
 17   101*   all  rm_rel_info  structures  allocated. It is used for searching
 17   102*   for the appropriate  structure.  This  array  is  pointed  to  by
 17   103*   rm_db_info. There are two arrays, one for perm rels, one for temp
 17   104*   rels.
 17   105*
 17   106*   The      rm_rel_info      structure      points      to       the
 17   107*   mdbm_rm_attr_info.incl.pl1  structures,  one  for  each attribute
 17   108*   appearing in this view of the relation. Each  of  these  in  turn
 17   109*   point  to a mdbm_rm_domain_info.incl.pl1 structure for the domain
 17   110*   info for each attr.
 17   111*
 17   112*   Most of the other information here deals with  specifics  of  the
 17   113*   relation's  logical  definition,  such as key and secondary index
 17   114*   attribute inidicators, security permissions, and  tuple  physical
 17   115*   construction details.
 17   116*
 17   117**/
 17   118 
 17   119      dcl	   1 rm_rel_info	      aligned based (rmri_ptr), /* relation information */
 17   120 	     2 name	      char (32),		/* from submodel */
 17   121 	     2 model_name	      char (30),		/* from model */
 17   122 	     2 rel_id	      bit (36) aligned,	/* unique id. */
 17   123 	     2 retrieve	      bit (1) unal,		/* operations allowed by this view */
 17   124 	     2 modify	      bit (1) unal,
 17   125 	     2 delete	      bit (1) unal,
 17   126 	     2 store	      bit (1) unal,
 17   127 	     2 total_key	      bit (1) unal,		/* on if view includes full primary key */
 17   128 	     2 indexed	      bit (1) unal,		/* on if exists sec. index */
 17   129 	     2 mdbm_secured	      bit (1) unal,		/* on if mdbm must check security */
 17   130 	     2 status_perm	      bit (1) unal,		/* if user has status. perm. */
 17   131 	     2 append_tuple_perm  bit (1) unal,		/* if user has store perm. */
 17   132 	     2 delete_tuple_perm  bit (1) unal,		/* if user has del. perm. */
 17   133 	     2 unused_perm	      bit (1) unal,		/* for future use. */
 17   134 	     2 last_model_attr_char_var bit (1) unal,	/* on => last model varying attr is char */
 17   135 	     2 reserved	      bit (24) unal,	/* for future use */
 17   136 	     2 num_attr	      fixed bin,		/* total no. of attr. in rel. */
 17   137 	     2 model_num_attr     fixed bin,		/* total attrs in model relation */
 17   138 	     2 nkey_attr	      fixed bin,		/* no. of key attr. */
 17   139 	     2 model_nkey_attr    fixed bin,		/* total number of keys in model */
 17   140 	     2 primary_key_index_id bit (36) aligned,     /* Index id of relation's primary key */
 17   141 	     2 nsec_inds	      fixed bin,		/* no. sec. indexes */
 17   142 	     2 max_key_len	      fixed bin (35),	/* max length (chars) of primary key */
 17   143 	     2 current_tuple_population fixed bin (35),	/* last known total  tuple count for this relation */
 17   144 	     2 last_statistics_update_count fixed bin,	/* number of operations's, since this rels stats were updated */
 17   145 	     2 last_statistics_update_time fixed bin (71),/* last time this rels stats were updated */
 17   146 	     2 last_statistics_update_s_e_ref_num fixed bin (35), /* last select expr ID that updated this rels stats */
 17   147 	     2 ready_mode	      fixed bin,		/* 1 => r, 2 => mr, 3 => u, 4 => l, 5 => sr, 6 => su */
 17   148 	     2 file_type	      fixed bin,		/* 1 => unblocked, 2 => blocked, 3 => temporary */
 17   149 	     2 tuple_id_len	      fixed bin,		/* no. bits in local tuple id */
 17   150 	     2 opening_id	      bit (36) aligned,	/* relation manager opening is */
 17   151 	     2 key_attr_ptrs      (nkey_attr_init refer (rm_rel_info.nkey_attr)) ptr, /* ptrs to key attr. */
 17   152 	     2 attr_ptrs	      (natts_init refer (rm_rel_info.num_attr)) ptr, /* ptrs to all attr. */
 17   153 	     2 id_list_ptr        ptr,		/* Id list for retrieves from the relation */
 17   154                2 scope_flags_ptr    ptr;                    /* pointer to the scope_flags structure for the rel */
 17   155 
 17   156      dcl	   rmri_ptr	      ptr;
 17   157      dcl	   (nkey_attr_init,
 17   158 	   natts_init,
 17   159 	   nvar_atts_init)	      fixed bin;
 17   160 
 17   161 /* END mdbm_rm_rel_info.incl.pl1 */
 17   162 
 17   163 
     1097 
     1098 
 18     1 /*  BEGIN  mdbm_rm_attr_info.incl.pl1  --  jaw,  11/16/78  */
 18     2 
 18     3 /* WARNING
 18     4*          If the rm_attr_info structure is changed then the mrds_data_
 18     5*          item saved_res_version MUST be incremented to invalidate all
 18     6*          existing saved resultants
 18     7**/
 18     8 
 18     9 /*
 18    10*
 18    11*   Modified  by  Jim  Gray - - 80-11-05, to add mdbm_secured bit, so
 18    12*   that rm_rel_info does not have to be checked
 18    13*
 18    14*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
 18    15*   foreign keys.
 18    16*
 18    17*   82-08-19  D. Woodka : removed rm_attr_info.bit_offset for the DMS
 18    18*   conversion.
 18    19*
 18    20*   82-09-15 Davids: added the number_of_dups field.
 18    21*
 18    22*   82-09-20 Mike Kubicar : changed the index_id field to be bit (36)
 18    23*   aligned.  This is to conform with the new definition in the database
 18    24*   model.  Also removed the now useless field varying.
 18    25*
 18    26*   82-11-05 Davids: added the field model_defn_order and clarified the
 18    27*   comment for the field defn_order.
 18    28*
 18    29*   83-05-23 Mike Kubicar : changed number_of_dups to fixed bin (35) since
 18    30*   that's what relation manager returns.
 18    31*
 18    32**/
 18    33 
 18    34 
 18    35 /*
 18    36*   this   structure   is   allocated   in   the   static   area   of
 18    37*   mdbm_rm_db_info.incl.pl1  once for each attribute per relation in
 18    38*   a     readied     file.      it     in     turn     points     to
 18    39*   mdbm_rm_domain_info.incl.pl1  for  the  attributes  domain.   the
 18    40*   rm_attr_info  is  pointed  to  by mdbm_rm_rel_info.incl.pl1.  all
 18    41*   structures  are  in  the  rm_db_info  area.   the  attribute data
 18    42*   position  within  a  tuple as stored in the data file are kept in
 18    43*   this resultant model of the attribute.
 18    44* */
 18    45 
 18    46 dcl 1 rm_attr_info aligned based (rai_ptr),		/* resultant attr. info */
 18    47     2 name char (32),				/* from submodel */
 18    48     2 model_name char (32),				/* from model */
 18    49     2 key_attr bit (1) unal,				/* if key attribute */
 18    50     2 index_attr bit (1) unal,			/* if secondary index */
 18    51     2 read_perm bit (1) unal,				/* user has retr. permission */
 18    52     2 modify_perm bit (1) unal,			/* user has modify permission */
 18    53     2 mdbm_secured bit (1) unal,			/* on => database secured */
 18    54     2 reserved bit (30) unal,				/* for future use */
 18    55     2 index_id bit (36) aligned,			/* index id if index_attr */
 18    56     2 defn_order fixed bin,				/* relative order in which attr is defined in the view */
 18    57     2 key_order fixed bin,				/* relative order defined in prim. key */
 18    58     2 bit_length fixed bin (35),			/* length if fixed, max. len. if var. */
 18    59     2 domain_ptr ptr,				/* to domain info */
 18    60     2 number_of_dups fixed bin (35),                        /* if the attribute is indexed this will
 18    61*                                                               be the number of duplicate values, exact
 18    62*                                                               for a page_file database, an estimate for a vfile type */
 18    63     2 model_defn_order fixed bin;                           /* relative order in which attr is defined in the model */
 18    64 
 18    65 dcl  rai_ptr ptr int automatic init (null ());
 18    66 
 18    67 /* END mdbm_rm_attr_info.incl.pl1 */
 18    68 
 18    69 
     1099 
     1100 
 19     1 /* BEGIN mdbm_rm_domain_info.incl.pl1 -- jaw, 9/26/78 */
 19     2 
 19     3 /* WARNING
 19     4*          If the rm_domain_info structure is changed then the mrds_data_
 19     5*          item saved_res_version MUST be incremented to invalidate all
 19     6*          existing saved resultants
 19     7**/
 19     8 
 19     9 /* DESCRIPTION:
 19    10*
 19    11*   This  structure  is  allocated  in  the  mdbm_rm_db_info.incl.pl1
 19    12*   static  area,  once per attribute used in a relation in a readied
 19    13*   file. it is pointed to by the mdbm_rm_attr_info.incl.pl1, and may
 19    14*   point  to  mdbm_rm_ck_and_group.incl.pl1  if  a  "-check"  option
 19    15*   boolean expression was declared for this domain. it contains  the
 19    16*   descriptor  for  this domain data type, and other resultant model
 19    17*   information.
 19    18*
 19    19*
 19    20*   HISTORY:
 19    21*
 19    22*   81-05-06  Rickie  E.  Brinegar:  Modified  ck_proc,  encode_proc,
 19    23*   decode_proc to be entry variables instead of entry pointers. This
 19    24*   allows these programs to be written in languages other than pl1.
 19    25*
 19    26*   81-05-28 Jim Gray : removed unused procedure points,  and  unused
 19    27*   check  stack  structure  elements.  Also made the descriptors bit
 19    28*   (36) in this structure, rather than pointers to  the  descriptors
 19    29*   elsewhere.  Also  removed un-needed redundant assign_ parameters,
 19    30*   that are actually available in the descriptors.
 19    31*
 19    32*
 19    33**/
 19    34 
 19    35 dcl 1 rm_domain_info aligned based (rdi_ptr),		/* domain information */
 19    36     2 name char (32),				/* domain name */
 19    37     2 db_desc bit (36),				/*  to desc. for db. */
 19    38     2 user_desc bit (36),				/* desc for user visible data */
 19    39     2 user_bit_len fixed bin,				/* storage length of users data */
 19    40     2 ck_proc_entry entry variable,			/* to check proc. entry */
 19    41     2 encd_proc_entry entry variable,			/* to encode proc entry */
 19    42     2 decd_proc_entry entry variable,			/* to decode proc entry */
 19    43     2 ck_proc bit (1) unal,				/* Is there a check proc */
 19    44     2 encd_proc bit (1) unal,				/* Is there an encode proc */
 19    45     2 decd_proc bit (1) unal,				/* Is there a decode proc */
 19    46     2 pad bit (33) unal,
 19    47     2 next_domain_ptr ptr ;				/* to next domain, in list of all domains */
 19    48 						/* to check stack and groups */
 19    49 
 19    50 
 19    51 dcl  rdi_ptr ptr int automatic init (null ());
 19    52 
 19    53 /* END mdbm_rm_domain_info.incl.pl1 */
 19    54 
 19    55 
     1101 
     1102 
 20     1 /* BEGIN mdbm_arg_list.incl.pl1 -- jaw 5/31/78 */
 20     2 /* the duplicate mrds_arg_list.incl.pl1 was eliminated by Jim Gray, Nov. 1979 */
 20     3 
 20     4 /* layout of argument list for IDS and DBM entries with options (variable) */
 20     5 
 20     6 dcl 1 arg_list based (al_ptr),
 20     7     2 arg_count fixed bin (17) unal,			/* 2 * no. of args. */
 20     8     2 code fixed bin (17) unal,			/* 4 => normal, 8 => special */
 20     9     2 desc_count fixed bin (17) unal,			/* 2 * no. of descriptors */
 20    10     2 pad fixed bin (17) unal,			/* must be 0 */
 20    11     2 arg_des_ptr (num_ptrs) ptr;			/* argument/descriptor pointer */
 20    12 
 20    13 dcl  al_ptr ptr;
 20    14 dcl  num_ptrs fixed bin;
 20    15 
 20    16 /* END mdbm_arg_list.incl.pl1  */
 20    17 
     1103 
     1104 
 21     1 /* BEGIN mdbm_rs_info.incl.pl1 -- jaw, 6/15/78 (from mda, 6/15/77) */
 21     2 
 21     3 dcl 1 rs_info aligned,
 21     4     2 version fixed init (2),				/* must be set to 1 or 2 (Input) */
 21     5     2 flags aligned,
 21     6       3 lock_sw bit (1) unal,				/* Input -- if ="1"b  try to lock record */
 21     7       3 unlock_sw bit (1) unal,			/* Input -- if ="1"b try to unlock record */
 21     8       3 create_sw bit (1) unal,			/* Input--if set creat new record */
 21     9       3 locate_sw bit (1) unal,			/* Input--if set causes current rec to be
 21    10*						   located outside the index by descrip, or created without key */
 21    11       3 inc_ref_count bit (1) unal,			/* Input--bump reference count of record, if stationary */
 21    12       3 dec_ref_count bit (1) unal,			/* Input--decrement ref count if this flag set and
 21    13*						   record stationary */
 21    14       3 locate_pos_sw bit (1) unal,			/* Input--if set the record_length is taken
 21    15*						   as an input arg. spec. the abs. logical record position
 21    16*						   \	  to which both current and next will be set */
 21    17       3 mbz1 bit (29) unal,				/* must be set to "0"b, reserved for future use */
 21    18     2 record_length fixed (21),			/* length in bytes, Input if create_sw set */
 21    19     2 max_rec_len fixed (21),				/* max length of contained record
 21    20*						   Input if create_sw is set--overrides min_block_size */
 21    21     2 record_ptr ptr,				/* points to first byte of record--will be word aligned */
 21    22     2 descriptor fixed (35),				/* Input if locate_sw set and create_sw="0"b */
 21    23     2 ref_count fixed (34),				/* Output--should match number of keys on this record--
 21    24*						   = -1 if non-stationary record */
 21    25     2 time_last_modified fixed (71),			/* Output */
 21    26     2 modifier fixed (35),				/* Output--also Input when locking */
 21    27     2 block_ptr ptr unal,				/* Output */
 21    28     2 mbz2 (2) fixed init (0, 0);
 21    29 
 21    30 /* END mdbm_rs_info.incl.pl1 */
 21    31 
     1105 
     1106 
 22     1 /* BEGIN mdbm_descriptor.incl.pl1 -- jaw 5/31/78 */
 22     2 /* modified by Jim Gray - - Nov. 1979, to change type from fixed bin(5) to
 22     3*   unsigned fixed bin(6), so new packed decimal data types could be handled.
 22     4*   also the duplicate mrds_descriptor.incl.pl1 was eliminated. */
 22     5 
 22     6 dcl 1 descriptor based (desc_ptr),			/* map of Multics descriptor */
 22     7     2 version bit (1) unal,				/* DBM handles vers. 1 only */
 22     8     2 type unsigned fixed bin (6) unal,			/* data type */
 22     9     2 packed bit (1) unal,				/* on if data item is packed */
 22    10     2 number_dims bit (4) unal,			/* dimensions */
 22    11     2 size,					/* size for string data */
 22    12       3 scale bit (12) unal,				/* scale for num. data */
 22    13       3 precision bit (12) unal,			/* prec. for num. data */
 22    14     2 array_info (num_dims),
 22    15       3 lower_bound fixed bin (35),			/* lower bound of dimension */
 22    16       3 upper_bound fixed bin (35),			/* upper bound of dimension */
 22    17       3 multiplier fixed bin (35);			/*  element separation */
 22    18 
 22    19 dcl  desc_ptr ptr;
 22    20 dcl  num_dims fixed bin init (0) ;			/* more useful form of number_dims */
 22    21 
 22    22 /* END mdbm_descriptor.incl.pl1 */
 22    23 
 22    24 
     1107 
     1108 
 23     1 /* ***********************************************************
 23     2*   *                                                         *
 23     3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
 23     4*   *                                                         *
 23     5*   *********************************************************** */
 23     6 /* BEGIN INCLUDE FILE - vu_typed_vector.incl.pl1 */
 23     7 
 23     8 /* Written by Lindsey Spratt, 04/02/82.
 23     9*Modified:
 23    10*09/01/82 by Lindsey Spratt:  Changed value_ptr in simple_typed_vector to be
 23    11*	  unaligned.  Changed the type number of the simple_typed_vector to
 23    12*	  "3" from "1".  The OLD_SIMPLE_TYPED_VECTOR_TYPE is now an invalid
 23    13*	  type.
 23    14**/
 23    15 
 23    16 /* format: style2,ind3 */
 23    17      dcl	   1 simple_typed_vector  based (simple_typed_vector_ptr),
 23    18 	     2 type	      fixed bin (17) unal,
 23    19 	     2 number_of_dimensions
 23    20 			      fixed bin (17) unal,
 23    21 	     2 dimension	      (stv_number_of_dimensions refer (simple_typed_vector.number_of_dimensions)),
 23    22 	       3 value_ptr	      ptr unaligned;
 23    23 
 23    24      dcl	   1 general_typed_vector based (general_typed_vector_ptr),
 23    25 	     2 type	      fixed bin (17) unal,
 23    26 	     2 number_of_dimensions
 23    27 			      fixed bin (17) unal,
 23    28 	     2 dimension	      (gtv_number_of_dimensions refer (general_typed_vector.number_of_dimensions)),
 23    29 	       3 identifier	      fixed bin (17) unal,
 23    30 	       3 pad	      bit (18) unal,
 23    31 	       3 value_ptr	      ptr unal;
 23    32 
 23    33      dcl	   simple_typed_vector_ptr
 23    34 			      ptr;
 23    35      dcl	   stv_number_of_dimensions
 23    36 			      fixed bin (17);
 23    37 
 23    38      dcl	   general_typed_vector_ptr
 23    39 			      ptr;
 23    40      dcl	   gtv_number_of_dimensions
 23    41 			      fixed bin (17);
 23    42 
 23    43      dcl	   (
 23    44 	   OLD_SIMPLE_TYPED_VECTOR_TYPE
 23    45 			      init (1),		/* value_ptr was aligned. */
 23    46 	   GENERAL_TYPED_VECTOR_TYPE
 23    47 			      init (2),
 23    48 	   SIMPLE_TYPED_VECTOR_TYPE
 23    49 			      init (3)
 23    50 	   )		      fixed bin (17) internal static options (constant);
 23    51 
 23    52 /* END INCLUDE FILE - vu_typed_vector.incl.pl1 */
     1109 
     1110 
     1111 /* Multics subroutines */
     1112 
     1113 	dcl     cu_$arg_list_ptr	 entry (ptr);
     1114 	dcl     cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin, fixed bin (35));
     1115 	dcl     unique_chars_	 entry (bit (*)) returns (char (15));
     1116 	dcl     sys_info$max_seg_size	 ext fixed bin;
     1117 
     1118 
     1119 /*  DBM Routines */
     1120 
     1121 	dcl     mrds_dsl_delete_se	 entry (ptr, fixed bin (35), fixed bin (35));
     1122 	dcl     mrds_dsl_translate
     1123 				 entry (ptr, ptr, fixed bin, ptr, fixed bin, ptr, ptr, fixed bin,
     1124 				 fixed bin (35));
     1125 	dcl     mu_cursor_manager_$destroy_and_free_on_opening_id entry (bit (36) aligned, ptr, ptr, entry, entry,
     1126 				 fixed bin (35));
     1127 	dcl     mu_database_index$get_resultant_model_pointer entry (fixed bin (35), ptr);
     1128 	dcl     mu_store$store_direct	 entry (ptr, ptr, ptr, fixed bin (35));
     1129 
     1130 	dcl     (
     1131 	        mrds_data_$max_temp_rels,
     1132 	        mrds_data_$max_select_items,
     1133 	        mrds_data_$max_id_len
     1134 	        )			 fixed bin (35) ext;
     1135 
     1136 	dcl     mrds_data_$caller_define_temp_rel fixed bin (17) ext;
     1137 	dcl     mrds_data_$max_attributes fixed bin (35) ext static;
     1138           dcl     mrds_data_$relation_blocking_factor fixed bin (17) ext static;
     1139 
     1140 
     1141 	dcl     (
     1142 	        dm_error_$key_duplication,
     1143 	        mrds_error_$inval_dtr_expr,
     1144 	        mrds_error_$tuple_not_found,
     1145 	        mrds_error_$max_temp_rels,
     1146 	        mrds_error_$no_tr_keys,
     1147 	        mrds_error_$invalid_db_index
     1148 	        )			 ext fixed bin (35);
     1149 
     1150 /* Based variable */
     1151 
     1152 	dcl     code		 fixed bin (35) based (cd_ptr);
     1153 	dcl     database_index	 fixed bin (35) based (dbi_ptr);
     1154 	dcl     rel_index		 fixed bin (35) based (rel_index_ptr); /* Temp_rel index */
     1155 	dcl     work_area		 area based (area_ptr);
     1156 
     1157 /* Pointers */
     1158 
     1159 	dcl     (
     1160 	        se_ptr,				/* Points to the selection expression */
     1161 	        raip,				/* temp attr info ptr */
     1162 	        appl_ptr,				/* Points to the list of arg pointers for translate */
     1163 	        adpl_ptr,				/* Points to the list of arg descriptors for translate */
     1164 	        save_appl_ptr,			/* Copy of appl_ptr, in case of rollback */
     1165 	        save_adpl_ptr,			/* Copy of adpl_ptr, in case of rollback */
     1166 	        cd_ptr,				/* Points to callers return code */
     1167 	        rel_index_ptr,			/* Points to temp_relindex */
     1168 	        dbi_ptr
     1169 	        )			 ptr;		/* Points to the database index */
     1170 
     1171 
     1172 /* Others */
     1173 
     1174 	dcl     (
     1175 	        nargs,				/* Number of arguments passed to this proc */
     1176 	        arg_len,
     1177 	        se_len,				/* Selection expression length */
     1178 	        tri,				/* temp rel index */
     1179 	        key_order,				/* current key attr index */
     1180 	        num_args,
     1181 	        save_num_args			/* Copy of num_args, in case of rollback */
     1182 	        )			 fixed bin;	/* Number of args passed to translate */
     1183 
     1184 	dcl     icode		 fixed bin (35);	/* Internal error code */
     1185 	dcl     entry_point_name	 char (32);	/* What were we called as */
     1186 	dcl     tr_dir		 char (168);
     1187 	dcl     ntuples_retrieved	 fixed bin (35);	/* count of retrieved tuples */
     1188 
     1189 	dcl     SCOPE_UPDATE	 fixed bin int static options (constant) init (6);
     1190 	dcl     TEMPORARY		 fixed bin int static options (constant) init (3);
     1191 
     1192 	dcl     (any_other, cleanup, arg_error) condition;
     1193 
     1194 	dcl     mrds_error_$undefined_temp_rel_index fixed bin (35) ext;
     1195 						/* index not previously defined */
     1196 	dcl     mrds_error_$dup_temp_rel_attr fixed bin (35) ext; /* non-unique attr names in relation */
     1197 	dcl     x			 fixed bin;	/* loop index for dup attr name check */
     1198 	dcl     temp_rai_ptr	 ptr;		/* temporary pointer for rm_attr_info, during dup name check */
     1199 	dcl     i			 fixed bin;	/* index for finding temporary relation index slot */
     1200 	dcl     no_recurse		 bit (1) init ("0"b); /* prevent recursive error calls to tidy up if on */
     1201 	dcl     area_ptr		 ptr;
     1202 	dcl     mu_release_area	 entry (ptr);
     1203 	dcl     mu_define_area$define_temp_dir_area entry (ptr, fixed bin (35), fixed bin (18), char (11), bit (1) aligned,
     1204 				 bit (1) aligned, bit (1) aligned, bit (1) aligned, fixed bin (35));
     1205 	dcl     mu_define_area$define_spec_temp_dir_area entry (ptr, fixed bin (35), char (11), fixed bin (35));
     1206 	dcl     a_db_index		 fixed bin (35);	/* opening index for get pop entry  */
     1207 	dcl     a_error_code	 fixed bin (35);	/* error code for get pop entry */
     1208 	dcl     temporary_relation_index fixed bin (35);	/* temp rel index desired */
     1209 	dcl     tuple_count		 fixed bin (35);	/* number of tuples in temp rel */
     1210 	declare se_len_ptr		 ptr;		/* temp for getting varying se len */
     1211 	declare se_len_ovrly	 fixed bin (35) based;
     1212 	dcl     mu_get_tuple	 entry (ptr, ptr, ptr, ptr, fixed bin (35));
     1213 	dcl     (fixed, null, ceil, addrel, bin, abs, addr, rel, substr) builtin;
     1214 
     1215 	dcl     self_defined	 bit (1) init ("0"b); /* true if the temp_rel is defined in terms of itself */
     1216 	dcl     actual_rel_index	 fixed bin (35);	/* the index that the user actually supplied */
     1217 						/* This will not correspond to rel_index if the temp rel is defined in terms of itself */
     1218 	dcl     created_resultant	 bit (1);		/* During rollback, we must release a created resultant. This tells if one was made */
     1219 	dcl     dbi_pic		 picture "999";
     1220 
     1221      end mrds_dsl_define_temp_rel;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/18/00  1111.9  mrds_dsl_define_temp_rel.pl1      >udd>sm>ds>w>ml>mrds_dsl_define_temp_rel.pl1
466          1    02/05/86  1516.4  mrds_start_transaction.incl.pl1   >ldd>incl>mrds_start_transaction.incl.pl1
1-79         2    01/07/85  1000.0  dm_tm_modes.incl.pl1              >ldd>incl>dm_tm_modes.incl.pl1
1-81         3    06/28/79  1304.8  condition_info.incl.pl1           >ldd>incl>condition_info.incl.pl1
554          4    02/05/86  1516.4  mrds_finish_transaction.incl.pl1  >ldd>incl>mrds_finish_transaction.incl.pl1
1073         5    10/14/83  1709.1  dm_rel_creation_info.incl.pl1     >ldd>incl>dm_rel_creation_info.incl.pl1
1075         6    01/07/85  1001.1  dm_file_create_info.incl.pl1      >ldd>incl>dm_file_create_info.incl.pl1
1077         7    10/14/83  1709.1  vu_typed_vector_array.incl.pl1    >ldd>incl>vu_typed_vector_array.incl.pl1
1079         8    10/14/83  1709.1  dm_id_list.incl.pl1               >ldd>incl>dm_id_list.incl.pl1
1081         9    10/14/83  1709.1  dm_relation_index_flags.incl.pl1  >ldd>incl>dm_relation_index_flags.incl.pl1
1083        10    08/04/88  2143.3  mrds_dbcb.incl.pl1                >ldd>incl>mrds_dbcb.incl.pl1
1085        11    08/04/88  2143.3  mdbm_rm_db_info.incl.pl1          >ldd>incl>mdbm_rm_db_info.incl.pl1
1087        12    10/14/83  1709.1  mrds_range.incl.pl1               >ldd>incl>mrds_range.incl.pl1
1089        13    10/14/83  1708.4  mrds_select_sets.incl.pl1         >ldd>incl>mrds_select_sets.incl.pl1
1091        14    08/04/88  2143.3  mrds_select_list.incl.pl1         >ldd>incl>mrds_select_list.incl.pl1
1093        15    10/14/83  1709.0  mrds_tuple_info.incl.pl1          >ldd>incl>mrds_tuple_info.incl.pl1
1095        16    10/14/83  1709.1  mdbm_rm_rel_array.incl.pl1        >ldd>incl>mdbm_rm_rel_array.incl.pl1
1097        17    10/14/83  1709.1  mdbm_rm_rel_info.incl.pl1         >ldd>incl>mdbm_rm_rel_info.incl.pl1
1099        18    10/14/83  1709.1  mdbm_rm_attr_info.incl.pl1        >ldd>incl>mdbm_rm_attr_info.incl.pl1
1101        19    10/14/83  1709.1  mdbm_rm_domain_info.incl.pl1      >ldd>incl>mdbm_rm_domain_info.incl.pl1
1103        20    10/14/83  1709.0  mdbm_arg_list.incl.pl1            >ldd>incl>mdbm_arg_list.incl.pl1
1105        21    10/14/83  1709.0  mdbm_rs_info.incl.pl1             >ldd>incl>mdbm_rs_info.incl.pl1
1107        22    10/14/83  1708.6  mdbm_descriptor.incl.pl1          >ldd>incl>mdbm_descriptor.incl.pl1
1109        23    10/14/83  1709.1  vu_typed_vector.incl.pl1          >ldd>incl>vu_typed_vector.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
FILE_CREATE_INFO_VERSION_2      000000 constant        char(8)                  initial dcl 6-43 ref 865
ID_LIST_VERSION_1                      constant        fixed bin(17,0)          initial dcl 8-23 ref 777 783
REL_CREATION_INFO_VERSION_2     000150 automatic       fixed bin(35,0)          initial dcl 5-11 set ref 5-11* 875
SCOPE_UPDATE                           constant        fixed bin(17,0)          initial dcl 1189 ref 744
SIMPLE_TYPED_VECTOR_TYPE               constant        fixed bin(17,0)          initial dcl 23-43 ref 504
SORTING_STYLE                   000013 constant        fixed bin(17,0)          initial dcl 717 set ref 897* 910*
TEMPORARY                              constant        fixed bin(17,0)          initial dcl 1190 ref 745
TM_NORMAL_MODE                  000013 constant        fixed bin(17,0)          initial dcl 2-15 set ref 1-99*
TYPED_VECTOR_ARRAY_VERSION_2           constant        fixed bin(35,0)          initial dcl 7-50 ref 794
a_db_index                             parameter       fixed bin(35,0)          dcl 1206 set ref 564 577*
a_dbcb_ptr                             parameter       pointer                  dcl 611 ref 605 614
a_error_code                           parameter       fixed bin(35,0)          dcl 1207 set ref 564 573* 578* 585* 592*
abs                                                    builtin function         dcl 1213 ref 450 452
actual_rel_index                000425 automatic       fixed bin(35,0)          dcl 1216 set ref 509* 513* 723 966 1056
actual_rel_pic                  000524 automatic       picture(2)               packed unaligned dcl 706 set ref 723* 740
addr                                                   builtin function         dcl 1213 ref 391 397 411 1-123 1-123 833 894
addrel                                                 builtin function         dcl 1213 ref 402
adpl_ptr                        000260 automatic       pointer                  dcl 1159 set ref 391* 397* 458 474* 1059*
ai_ptr                   12            based           pointer                  array level 3 dcl 14-22 ref 727 798 803
al_ptr                          000220 automatic       pointer                  dcl 20-13 set ref 370* 371 373 389 390 391 393 396
                                                                                  397 398 411
another_flag            106            based           bit(1)                   level 3 packed packed unaligned dcl 10-142 set ref
                                                                                  532*
any_other                       000370 stack reference condition                dcl 1192 ref 465
append_tuple_perm        21(08)        based           bit(1)                   level 2 packed packed unaligned dcl 17-119 set ref
                                                                                  752*
appl_ptr                        000256 automatic       pointer                  dcl 1159 set ref 411* 457 474* 1058*
area_ptr                        000420 automatic       pointer                  dcl 1201 set ref 363* 431* 474* 502 523* 533* 617*
                                                                                  782 787 793 863 864
arg_count                              based           fixed bin(17,0)          level 2 packed packed unaligned dcl 20-6 ref 373 390
                                                                                  396
arg_des_ptr               2            based           pointer                  array level 2 dcl 20-6 set ref 391 393 397 398 411
arg_error                       000404 stack reference condition                dcl 1192 ref 371 374 378
arg_len                         000275 automatic       fixed bin(17,0)          dcl 1174 set ref 377* 381* 406*
arg_list                               based           structure                level 1 unaligned dcl 20-6
attr_ptrs                              based           pointer                  array level 2 dcl 17-119 set ref 685 689* 843* 910
                                                                                  1038
bin                                                    builtin function         dcl 1213 ref 944
bit_length               24            based           fixed bin(35,0)          level 2 dcl 18-46 set ref 819* 819 848
blocking_factor           3            based           fixed bin(17,0)          initial level 2 dcl 6-21 set ref 864* 867*
cd                                     parameter       fixed bin(35,0)          dcl 984 set ref 979 988 989* 992
cd_ptr                          000266 automatic       pointer                  dcl 1159 set ref 377* 550 551 4-115 988
ceil                                                   builtin function         dcl 1213 ref 854
ci_build_index                         based           structure                level 1 unaligned dcl 708 set ref 787
ci_size_in_bytes          2            based           fixed bin(35,0)          initial level 2 dcl 6-21 set ref 864* 866*
cibi_ptr                        000526 automatic       pointer                  dcl 707 set ref 787* 788 826 826 828 908 909 910
cism_info_ptr             6            based           pointer                  level 2 dcl 5-4 set ref 877*
cleanup                         000376 stack reference condition                dcl 1192 ref 460
close                   152            based           entry variable           level 4 dcl 10-142 set ref 668* 1044*
code                                   based           fixed bin(35,0)          dcl 1152 in procedure "define_temp_rel" set ref 550*
                                                                                  551 4-115* 988*
code                      0(18)        based           fixed bin(17,0)          level 2 in structure "arg_list" packed packed
                                                                                  unaligned dcl 20-6 in procedure "define_temp_rel"
                                                                                  ref 389
condition_info                         based           structure                level 1 dcl 3-14
condition_name            3     000110 automatic       varying char(32)         level 2 dcl 1-77 set ref 1-124 1-129 1-129
continue_to_signal_             000010 constant        entry                    external dcl 1-61 ref 1-137
create_index            242            based           entry variable           level 4 dcl 10-142 ref 897 910
create_index_flags              000530 automatic       bit(36)                  dcl 712 set ref 893* 894 897* 910*
create_relation         236            based           entry variable           level 4 dcl 10-142 ref 883
created_resultant               000426 automatic       bit(1)                   packed unaligned dcl 1218 set ref 366* 722* 1036
cu_$arg_list_ptr                000040 constant        entry                    external dcl 1113 ref 370
cu_$arg_ptr                     000042 constant        entry                    external dcl 1114 ref 377 381 385 406
current_tuple_population
                         31            based           fixed bin(35,0)          level 2 dcl 17-119 set ref 537* 597
cursor_ptrs_storage_ptr
                        130            based           pointer                  level 3 dcl 10-142 set ref 668* 1044*
cursor_storage_area_ptr
                        132            based           pointer                  level 3 dcl 10-142 set ref 668* 1044*
data                                   based           structure                level 2 in structure "rm_db_info" dcl 11-86
                                                                                  in procedure "define_temp_rel"
data                                   based           structure                level 2 in structure "dbcb" dcl 10-142 in procedure
                                                                                  "define_temp_rel"
database_index                         based           fixed bin(35,0)          dcl 1153 set ref 415* 423* 426* 436*
db_desc                  10            based           bit(36)                  level 2 dcl 19-35 set ref 833
db_index                               parameter       fixed bin(35,0)          dcl 637 set ref 631 644*
dbcb                                   based           structure                level 1 dcl 10-142
dbcb_data                              based           structure                level 1 unaligned dcl 10-148
dbcb_ptr                        000170 automatic       pointer                  dcl 10-146 set ref 363* 415* 418 421 425 426 431 436
                                                                                  456 470 474* 480 483 484 494 495 496 522 523* 525*
                                                                                  532 533* 558 560 560 577* 578 581 614* 615 622 668
                                                                                  668 668 668 674 687 693 883 897 910 1014 1014*
                                                                                  1044 1044 1044 1044
dbi                     114            based           fixed bin(35,0)          level 3 dcl 10-142 set ref 425 622*
dbi_pic                         000427 automatic       picture(3)               packed unaligned dcl 1219 set ref 425* 426 436
dbi_ptr                         000272 automatic       pointer                  dcl 1159 set ref 381* 415 423 426 436
def_temp_rel_area_ptr
                         54            based           pointer                  level 3 dcl 10-142 set ref 426* 431 560 560*
defn_order               22            based           fixed bin(17,0)          level 2 dcl 18-46 set ref 817*
delete                   21(02)        based           bit(1)                   level 2 packed packed unaligned dcl 17-119 set ref
                                                                                  747*
delete_tuple_perm        21(09)        based           bit(1)                   level 2 packed packed unaligned dcl 17-119 set ref
                                                                                  752*
desc_ptr                        000242 automatic       pointer                  dcl 22-19 set ref 393* 398* 401
descriptor                             based           structure                level 1 unaligned dcl 22-6
descriptor_ptr                         based           pointer                  array level 3 dcl 7-21 set ref 833*
destroy_cursor          162            based           entry variable           level 4 dcl 10-142 set ref 668* 1044*
destroy_relation_by_path
                        246            based           entry variable           level 4 dcl 10-142 ref 674
dimension_table           6            based           structure                array level 2 dcl 7-21
dm_error_$bj_journal_full       000030 external static fixed bin(35,0)          dcl 4-52 ref 1-132
dm_error_$key_duplication       000076 external static fixed bin(35,0)          dcl 1141 ref 528
dm_error_$lock_deadlock         000032 external static fixed bin(35,0)          dcl 4-53 ref 4-78 1-126
dm_error_$no_current_transaction
                                000012 external static fixed bin(35,0)          dcl 1-62 ref 1-90
domain_ptr               26            based           pointer                  level 2 dcl 18-46 set ref 833 841 841*
entry_point_name                000304 automatic       char(32)                 packed unaligned dcl 1185 set ref 368* 575* 619* 986
esm_info_ptr              4            based           pointer                  level 2 dcl 5-4 set ref 877*
file_create_info                       based           structure                level 1 dcl 6-21 set ref 864
file_create_info_ptr      2            based           pointer                  level 2 in structure "rel_creation_info" dcl 5-4
                                                                                  in procedure "define_temp_rel" set ref 876*
file_create_info_ptr            000152 automatic       pointer                  dcl 6-41 in procedure "define_temp_rel" set ref 864*
                                                                                  865 866 867 868 869 870 871 872 873 874 876
file_type                40            based           fixed bin(17,0)          level 2 dcl 17-119 set ref 745*
find_condition_info_            000014 constant        entry                    external dcl 1-64 ref 1-123
flags                     4            based           structure                level 2 packed packed unaligned dcl 6-21
i                               000554 automatic       fixed bin(17,0)          dcl 936 in procedure "check_self_definition" set ref
                                                                                  941* 942 944*
i                               000416 automatic       fixed bin(17,0)          dcl 1199 in procedure "define_temp_rel" set ref 442*
                                                                                  443 443* 489* 490* 1037* 1038*
i                               000531 automatic       fixed bin(17,0)          dcl 713 in procedure "create_temp_rel_file" set ref
                                                                                  726* 727* 730* 731* 796* 798 802 808 817 818 820
                                                                                  820 825 828 831 833 843 845 851*
icode                           000303 automatic       fixed bin(35,0)          dcl 1184 set ref 377* 378 381* 382 382* 385* 386
                                                                                  386* 406* 408 408* 426* 432 432* 436* 437 437*
                                                                                  474* 478 478* 523* 524 525* 528 528 530 533* 536
                                                                                  542* 644* 646 646* 668* 672 672* 674* 676 676*
                                                                                  804* 883* 888 888* 897* 900 900* 910* 914 914*
                                                                                  1014*
id                        2            based           fixed bin(17,0)          array level 2 dcl 8-16 set ref 820* 851* 909*
id_list                                based           structure                level 1 dcl 8-16 set ref 693 776 782
id_list_ptr                     000162 automatic       pointer                  initial dcl 8-21 in procedure "define_temp_rel" set
                                                                                  ref 8-21* 782* 783 784 850 851 897* 905 909 910*
id_list_ptr                            based           pointer                  level 2 in structure "rm_rel_info" dcl 17-119
                                                                                  in procedure "define_temp_rel" set ref 693 858*
ignore_icode                    000576 automatic       fixed bin(35,0)          dcl 1032 set ref 1044*
il_number_of_ids                000164 automatic       fixed bin(17,0)          initial dcl 8-22 set ref 8-22* 775* 776 776 782 782
index                    10(02)        based           bit(1)                   array level 3 packed packed unaligned dcl 14-22 ref
                                                                                  825
index_attr               20(01)        based           bit(1)                   level 2 packed packed unaligned dcl 18-46 set ref
                                                                                  809*
index_id                 21            based           bit(36)                  level 2 dcl 18-46 set ref 809* 815* 910*
index_is_unique           0(02)        based           bit(1)                   level 2 packed packed unaligned dcl 9-16 set ref
                                                                                  896* 906*
index_position            1            based           fixed bin(17,0)          array level 2 dcl 708 set ref 828* 909 910
indexed                  21(05)        based           bit(1)                   level 2 packed packed unaligned dcl 17-119 set ref
                                                                                  761*
item                     10            based           structure                array level 2 unaligned dcl 14-22
items                                  based           structure                array level 2 dcl 13-3
j                               000532 automatic       fixed bin(17,0)          dcl 714 in procedure "create_temp_rel_file" set ref
                                                                                  908* 909 910*
j                               000100 automatic       fixed bin(17,0)          dcl 660 in procedure "delete_temp_rel_file" set ref
                                                                                  684* 685 689*
key                      10(01)        based           bit(1)                   array level 3 packed packed unaligned dcl 14-22 ref
                                                                                  731 808 845
key_attr                 20            based           bit(1)                   level 2 packed packed unaligned dcl 18-46 set ref
                                                                                  808*
key_attr_ptrs            44            based           pointer                  array level 2 dcl 17-119 set ref 847*
key_order                       000300 automatic       fixed bin(17,0)          dcl 1174 in procedure "define_temp_rel" set ref 773*
                                                                                  846 846* 847 850 851
key_order                23            based           fixed bin(17,0)          level 2 in structure "rm_attr_info" dcl 18-46
                                                                                  in procedure "define_temp_rel" set ref 846*
last_model_attr_char_var
                         21(11)        based           bit(1)                   level 2 packed packed unaligned dcl 17-119 set ref
                                                                                  761*
last_statistics_update_s_e_ref_num
                         36            based           fixed bin(35,0)          level 2 dcl 17-119 set ref 539*
last_statistics_update_time
                         34            based           fixed bin(71,0)          level 2 dcl 17-119 set ref 539*
last_store_rel_name     117            based           char(32)                 level 3 dcl 10-142 set ref 522*
max_build_indices               000533 automatic       fixed bin(17,0)          dcl 715 set ref 786* 787 787
max_key_len              30            based           fixed bin(35,0)          level 2 dcl 17-119 set ref 765* 848* 848 854* 854
maximum_dimension_name_length
                          4            based           fixed bin(17,0)          level 2 dcl 7-21 set ref 793* 831 831 831 833 833
                                                                                  833
mbz2                     14     000224 automatic       fixed bin(17,0)          initial array level 2 dcl 21-3 set ref 21-3* 21-3*
mbz_1                     4(03)        based           bit(15)                  initial level 3 packed packed unaligned dcl 6-21 set
                                                                                  ref 864* 871*
mbz_2                     6            based           fixed bin(71,0)          array level 2 dcl 6-21 set ref 873*
mbz_3                     4(26)        based           bit(46)                  initial level 2 packed packed unaligned dcl 6-21 set
                                                                                  ref 864* 874*
mdbm_secured             20(04)        based           bit(1)                   level 2 in structure "rm_attr_info" packed packed
                                                                                  unaligned dcl 18-46 in procedure "define_temp_rel"
                                                                                  set ref 816*
mdbm_secured            126            based           bit(1)                   level 3 in structure "rm_db_info" packed packed
                                                                                  unaligned dcl 11-86 in procedure "define_temp_rel"
                                                                                  ref 759
mdbm_secured             21(06)        based           bit(1)                   level 2 in structure "rm_rel_info" packed packed
                                                                                  unaligned dcl 17-119 in procedure
                                                                                  "define_temp_rel" set ref 759* 816
mftxn_code                      000142 automatic       fixed bin(35,0)          dcl 4-54 set ref 551* 4-62* 4-65 4-68* 4-69 4-78
                                                                                  4-115 4-115 1-126* 1-132*
mftxn_temp_code                 000143 automatic       fixed bin(35,0)          dcl 4-55 set ref 4-71* 4-72 4-72* 4-82* 4-83 4-85*
                                                                                  4-86 4-86* 4-96* 4-97 4-99* 4-100 4-100* 4-109*
                                                                                  4-110 4-110*
model_defn_order         31            based           fixed bin(17,0)          level 2 dcl 18-46 set ref 818*
model_name               10            based           char(30)                 level 2 in structure "rm_rel_info" dcl 17-119
                                                                                  in procedure "define_temp_rel" set ref 740*
model_name                             based           char(30)                 array level 3 in structure "rm_rel_array" dcl 16-34
                                                                                  in procedure "define_temp_rel" set ref 679* 740*
                                                                                  971* 971
model_name               10            based           char(32)                 level 2 in structure "rm_attr_info" dcl 18-46
                                                                                  in procedure "define_temp_rel" set ref 800*
model_nkey_attr          25            based           fixed bin(17,0)          level 2 dcl 17-119 set ref 771*
model_num_attr           23            based           fixed bin(17,0)          level 2 dcl 17-119 set ref 769* 1037
modify                   21(01)        based           bit(1)                   level 2 packed packed unaligned dcl 17-119 set ref
                                                                                  747*
modify_perm              20(03)        based           bit(1)                   level 2 packed packed unaligned dcl 18-46 set ref
                                                                                  812*
mrds_data_$caller_define_temp_rel
                                000070 external static fixed bin(17,0)          dcl 1136 set ref 474* 1014
mrds_data_$max_attributes       000072 external static fixed bin(35,0)          dcl 1137 ref 501 942 942 944 944 944
mrds_data_$max_id_len           000066 external static fixed bin(35,0)          dcl 1130 ref 942 942 942 944 944 944
mrds_data_$max_select_items     000064 external static fixed bin(35,0)          dcl 1130 ref 485 486 487 489 490
mrds_data_$max_temp_rels        000062 external static fixed bin(35,0)          dcl 1130 ref 442 450 510 585 623 624 1010
mrds_data_$relation_blocking_factor
                                000074 external static fixed bin(17,0)          dcl 1138 ref 867
mrds_dsl_delete_se              000050 constant        entry                    external dcl 1121 ref 1014
mrds_dsl_resultant_storage$get_opening_temp_dir
                                000126 constant        entry                    external dcl 638 ref 644
mrds_dsl_translate              000052 constant        entry                    external dcl 1122 ref 474
mrds_error_$dup_temp_rel_attr   000114 external static fixed bin(35,0)          dcl 1196 ref 804
mrds_error_$inval_dtr_expr      000100 external static fixed bin(35,0)          dcl 1141 set ref 480*
mrds_error_$invalid_db_index    000110 external static fixed bin(35,0)          dcl 1141 set ref 418* 578
mrds_error_$max_temp_rels       000104 external static fixed bin(35,0)          dcl 1141 set ref 446*
mrds_error_$no_tr_keys          000106 external static fixed bin(35,0)          dcl 1141 set ref 734*
mrds_error_$tuple_not_found     000102 external static fixed bin(35,0)          dcl 1141 ref 536
mrds_error_$undefined_temp_rel_index
                                000112 external static fixed bin(35,0)          dcl 1194 set ref 450* 453* 585 592
mstxn_code                      000100 automatic       fixed bin(35,0)          dcl 1-65 set ref 1-83* 1-89* 1-90 1-99* 1-140 1-140*
                                                                                  4-90* 4-104* 1-137*
mstxn_condition_info            000110 automatic       structure                level 1 unaligned dcl 1-77 set ref 1-123 1-123
mstxn_retries                   000101 automatic       fixed bin(17,0)          dcl 1-66 set ref 1-88* 4-78 4-81* 4-81
mstxn_temp_code                 000102 automatic       fixed bin(35,0)          dcl 1-67 set ref 1-109* 1-110 1-110* 1-123*
mstxn_transactions_needed       000103 automatic       bit(1)                   dcl 1-68 set ref 456* 1-86
mstxn_txn_id                    000105 automatic       bit(36)                  dcl 1-70 set ref 367* 1-84* 1-89* 1-93 1-94* 1-99*
                                                                                  1-100 4-60 4-68* 4-71* 4-72* 4-82* 4-85* 4-86*
                                                                                  4-96* 4-99* 4-100* 4-109* 4-110* 4-114* 1-107
                                                                                  1-109* 1-110* 1-121
mu_cursor_manager_$destroy_and_free_on_opening_id
                                000054 constant        entry                    external dcl 1125 ref 668 1044
mu_database_index$get_resultant_model_pointer
                                000056 constant        entry                    external dcl 1127 ref 415 577
mu_define_area$define_spec_temp_dir_area
                                000122 constant        entry                    external dcl 1205 ref 436
mu_define_area$define_temp_dir_area
                                000120 constant        entry                    external dcl 1203 ref 426
mu_get_tuple                    000124 constant        entry                    external dcl 1212 ref 523 533
mu_release_area                 000116 constant        entry                    external dcl 1202 ref 560
mu_store$store_direct           000060 constant        entry                    external dcl 1128 ref 525
name                      1            based           structure                array level 2 in structure "rm_rel_array" packed
                                                                                  packed unaligned dcl 16-34 in procedure
                                                                                  "define_temp_rel"
name                                   based           char(32)                 level 2 in structure "rm_attr_info" dcl 18-46
                                                                                  in procedure "define_temp_rel" set ref 800 800*
                                                                                  804 804 831
name                      6            based           varying char             array level 3 in structure "typed_vector_array"
                                                                                  dcl 7-21 in procedure "define_temp_rel" set ref
                                                                                  831*
name                                   based           char(32)                 level 2 in structure "rm_rel_info" dcl 17-119
                                                                                  in procedure "define_temp_rel" set ref 674 740*
                                                                                  883 944
nargs                           000274 automatic       fixed bin(17,0)          dcl 1174 set ref 373* 374 377* 391 393 397 398 406
                                                                                  413
natts_init                      000211 automatic       fixed bin(17,0)          dcl 17-157 set ref 724* 737 737 768 769
nitems                                 based           fixed bin(17,0)          level 2 dcl 13-3 ref 489
nkey_attr                24            based           fixed bin(17,0)          level 2 dcl 17-119 set ref 685 689 693 694 737* 770*
                                                                                  772 843 858 910 1038 1053
nkey_attr_init                  000210 automatic       fixed bin(17,0)          dcl 17-157 set ref 729* 731* 731 734 737 737 770 771
no_concurrency            4(01)        based           bit(1)                   initial level 3 packed packed unaligned dcl 6-21 set
                                                                                  ref 864* 869*
no_recurse                      000417 automatic       bit(1)                   initial packed unaligned dcl 1200 set ref 365* 574*
                                                                                  618* 665* 695* 989 1200*
no_rollback               4(02)        based           bit(1)                   initial level 3 packed packed unaligned dcl 6-21 set
                                                                                  ref 864* 870*
nsec_inds                27            based           fixed bin(17,0)          level 2 dcl 17-119 set ref 765*
ntuples_retrieved               000366 automatic       fixed bin(35,0)          dcl 1187 set ref 521* 530* 530 537
null                                                   builtin function         dcl 1213 ref 363 371 418 443 453 483 558 560 578 592
                                                                                  617 621 8-21 9-24 14-38 18-65 19-51 1-123 1-123
                                                                                  662 681 683 686 688 689 721 772 877 973 1014 1036
                                                                                  1054
num_args                        000301 automatic       fixed bin(17,0)          dcl 1174 set ref 413* 459 474* 1060*
num_attr                 22            based           fixed bin(17,0)          level 2 dcl 17-119 set ref 684 693 694 737* 768* 772
                                                                                  858 1053
num_defined                     000144 automatic       fixed bin(17,0)          dcl 612 set ref 623*
num_dims                        000244 automatic       fixed bin(17,0)          initial dcl 22-20 set ref 22-20*
num_indices                            based           fixed bin(17,0)          level 2 dcl 708 set ref 787* 788* 826* 826 828 908
num_items                 6            based           fixed bin(17,0)          level 2 dcl 14-22 ref 724 726 730 775 778 786 791
                                                                                  796
num_ptrs                        000222 automatic       fixed bin(17,0)          dcl 20-14 set ref 390* 396*
num_rels                               based           fixed bin(17,0)          level 2 dcl 16-34 ref 443 453 589 592 662 663 679
                                                                                  681 739 740 971 971 972 972 973 1054
num_vars                               based           fixed bin(17,0)          level 2 dcl 12-5 ref 941
number_of_dimensions      0(18)        based           fixed bin(17,0)          level 2 in structure "simple_typed_vector" packed
                                                                                  packed unaligned dcl 23-17 in procedure
                                                                                  "define_temp_rel" set ref 502*
number_of_dimensions      1            based           fixed bin(17,0)          level 2 in structure "typed_vector_array" dcl 7-21
                                                                                  in procedure "define_temp_rel" set ref 793*
number_of_ids             1            based           fixed bin(17,0)          level 2 dcl 8-16 set ref 693 776* 778* 782* 784*
                                                                                  850* 905*
number_of_vector_slots
                          3            based           fixed bin(17,0)          level 2 dcl 7-21 set ref 793*
nvar_atts_init                  000212 automatic       fixed bin(17,0)          dcl 17-157 set ref 725*
opening_id               42            based           bit(36)                  level 2 dcl 17-119 set ref 667 668* 880* 883* 897*
                                                                                  910* 1044 1044*
original_cd                     000145 automatic       fixed bin(35,0)          dcl 999 set ref 989 992*
pathname                        000444 automatic       char(168)                packed unaligned dcl 636 set ref 644* 651
primary_key_index_id     26            based           bit(36)                  level 2 dcl 17-119 set ref 897*
protected                 4            based           bit(1)                   initial level 3 packed packed unaligned dcl 6-21 set
                                                                                  ref 864* 868*
rai_ptr                         000214 automatic       pointer                  initial dcl 18-65 set ref 18-65* 685* 686 687 688*
                                                                                  799* 800 800 804 808 809 809 809 812 812 815 816
                                                                                  817 818 819 841 843 846 847 848
raip                            000254 automatic       pointer                  dcl 1159 set ref 727* 798* 800 819 831 833 841
range                                  based           structure                level 1 dcl 12-5
range_ptr                       000174 automatic       pointer                  dcl 12-23 in procedure "define_temp_rel" set ref
                                                                                  486* 494* 498* 941 942 944
range_ptr                              based           pointer                  array level 3 in structure "select_sets" dcl 13-3
                                                                                  in procedure "define_temp_rel" set ref 486 490*
range_ptr                 2            based           pointer                  level 3 in structure "dbcb" dcl 10-142 in procedure
                                                                                  "define_temp_rel" ref 494
range_ptr                              parameter       pointer                  dcl 931 in procedure "check_self_definition" ref 920
rdbi_ptr                               based           pointer                  level 3 in structure "dbcb" dcl 10-142 in procedure
                                                                                  "define_temp_rel" ref 421 581 615
rdbi_ptr                        000172 automatic       pointer                  dcl 11-90 in procedure "define_temp_rel" set ref
                                                                                  421* 434 581* 583 615* 616 694 737 759 776 799
rdi_ptr                         000216 automatic       pointer                  initial dcl 19-51 set ref 19-51* 841*
read_perm                20(02)        based           bit(1)                   level 2 packed packed unaligned dcl 18-46 set ref
                                                                                  812*
ready_mode               37            based           fixed bin(17,0)          level 2 dcl 17-119 set ref 744*
rel_creation_info                      based           structure                level 1 dcl 5-4 set ref 863
rel_creation_info_ptr           000146 automatic       pointer                  dcl 5-10 set ref 863* 875 876 877 877 883*
rel_data                               based           structure                array level 2 dcl 16-34
rel_id                   20            based           bit(36)                  level 2 dcl 17-119 set ref 883*
rel_index                              parameter       fixed bin(35,0)          dcl 932 in procedure "check_self_definition" ref 920
                                                                                  944
rel_index                              based           fixed bin(35,0)          dcl 1154 in procedure "define_temp_rel" set ref 440
                                                                                  450 452 471 489 490* 498 498* 509 510* 511 515 517
                                                                                  517* 543 543* 965 966* 967 1056*
rel_index_ptr                   000270 automatic       pointer                  dcl 1159 set ref 406* 440 450 452 471 489 490 498
                                                                                  498 509 510 511 515 517 517 543 543 965 966 967
                                                                                  1056
relation_index_flags                   based           structure                level 1 dcl 9-16
relation_index_flags_ptr        000166 automatic       pointer                  initial dcl 9-24 set ref 9-24* 894* 895 896 906
relation_must_be_empty                 based           bit(1)                   level 2 packed packed unaligned dcl 9-16 set ref
                                                                                  895*
relmgr_entries          146            based           structure                level 3 dcl 10-142
reserved                 20(05)        based           bit(30)                  level 2 in structure "rm_attr_info" packed packed
                                                                                  unaligned dcl 18-46 in procedure "define_temp_rel"
                                                                                  set ref 809*
reserved                 21(12)        based           bit(24)                  level 2 in structure "rm_rel_info" packed packed
                                                                                  unaligned dcl 17-119 in procedure
                                                                                  "define_temp_rel" set ref 761*
retrieve                 21            based           bit(1)                   level 2 packed packed unaligned dcl 17-119 set ref
                                                                                  747*
retrieve_id_list_ptr            000534 automatic       pointer                  dcl 716 set ref 776* 777 778 820 858
ri_ptr                                 based           pointer                  array level 3 in structure "rm_rel_array" packed
                                                                                  packed unaligned dcl 16-34 in procedure
                                                                                  "define_temp_rel" set ref 443 453 589 592 662 663
                                                                                  681* 739* 972* 972 973* 1054*
ri_ptr                                 based           pointer                  array level 3 in structure "range" dcl 12-5
                                                                                  in procedure "define_temp_rel" ref 944
ring_brackets             4(18)        based           fixed bin(3,0)           initial array level 2 packed packed unaligned
                                                                                  dcl 6-21 set ref 864* 864* 872*
rm_attr_info                           based           structure                level 1 dcl 18-46 set ref 687 799 1038
rm_db_info                             based           structure                level 1 dcl 11-86
rm_db_info_data                        based           structure                level 1 unaligned dcl 11-92
rm_domain_info                         based           structure                level 1 dcl 19-35
rm_rel_array                           based           structure                level 1 dcl 16-34
rm_rel_info                            based           structure                level 1 dcl 17-119 set ref 694 737 1053
rmra_ptr                        000204 automatic       pointer                  dcl 16-43 set ref 434* 443 453 583* 589 592 616* 621
                                                                                  662 663 679 679 681 739 740 740 970 970 971 971
                                                                                  972 972 973 1054
rmri_ptr                        000206 automatic       pointer                  dcl 17-156 set ref 523* 525* 533* 537 539 539 589*
                                                                                  597 663* 667 668 674 683 684 685 689 693 694 721*
                                                                                  737* 739 740 740 744 745 746 747 747 747 747 752
                                                                                  752 752 752 757 759 761 761 761 765 765 768 769
                                                                                  770 771 772 816 843 847 848 848 854 854 858 880
                                                                                  883 883 883 897 897 910 910 1036 1037 1038 1044
                                                                                  1044 1053 1054*
rs_info                         000224 automatic       structure                level 1 dcl 21-3
save_adpl_ptr                   000264 automatic       pointer                  dcl 1159 set ref 458* 1059
save_appl_ptr                   000262 automatic       pointer                  dcl 1159 set ref 457* 1058
save_num_args                   000302 automatic       fixed bin(17,0)          dcl 1174 set ref 459* 1060
scope_flags_ptr                        based           pointer                  level 2 dcl 17-119 set ref 772*
se_len                          000276 automatic       fixed bin(17,0)          dcl 1174 set ref 385* 403* 474*
se_len_ovrly                           based           fixed bin(35,0)          dcl 1211 ref 403
se_len_ptr                      000422 automatic       pointer                  dcl 1210 set ref 402* 403
se_ptr                          000252 automatic       pointer                  dcl 1159 set ref 385* 402 474*
select_list                            based           structure                level 1 unaligned dcl 14-22
select_list_ptr                 000200 automatic       pointer                  initial dcl 14-38 set ref 485* 495* 14-38* 724 726
                                                                                  727 730 731 775 778 786 791 796 798 803 808 825
                                                                                  845
select_ptr                             based           pointer                  array level 3 in structure "select_sets" dcl 13-3
                                                                                  in procedure "define_temp_rel" ref 485
select_ptr                4            based           pointer                  level 3 in structure "dbcb" dcl 10-142 in procedure
                                                                                  "define_temp_rel" ref 495
select_sets                            based           structure                level 1 dcl 13-3
self_defined                    000424 automatic       bit(1)                   initial packed unaligned dcl 1215 set ref 488* 489
                                                                                  490* 497* 498* 507 546 1056 1215*
self_defined_flag               000555 automatic       bit(1)                   initial packed unaligned dcl 937 set ref 937* 941
                                                                                  944* 949
simple_typed_vector                    based           structure                level 1 packed packed unaligned dcl 23-17 set ref
                                                                                  502
simple_typed_vector_ptr         000246 automatic       pointer                  dcl 23-33 set ref 363* 502* 504 523* 525* 533*
ss_ptr                          000176 automatic       pointer                  dcl 13-21 in procedure "define_temp_rel" set ref
                                                                                  484* 485 486 487 489 490
ss_ptr                   20            based           pointer                  level 3 in structure "dbcb" dcl 10-142 in procedure
                                                                                  "define_temp_rel" ref 483 484
static_area             142            based           area                     level 2 in structure "rm_db_info" dcl 11-86
                                                                                  in procedure "define_temp_rel" ref 694 737 776 799
static_area             306            based           area                     level 2 in structure "dbcb" dcl 10-142 in procedure
                                                                                  "define_temp_rel" ref 687 693
status_perm              21(07)        based           bit(1)                   level 2 packed packed unaligned dcl 17-119 set ref
                                                                                  752*
store                    21(03)        based           bit(1)                   level 2 packed packed unaligned dcl 17-119 set ref
                                                                                  747*
stv_number_of_dimensions        000250 automatic       fixed bin(17,0)          dcl 23-35 set ref 501* 502 502
submodel                  1(09)        based           char(32)                 array level 3 packed packed unaligned dcl 16-34 set
                                                                                  ref 679* 740* 970* 970
substr                                                 builtin function         dcl 1213 ref 944
sys_info$max_seg_size           000046 external static fixed bin(17,0)          dcl 1116 ref 426
temp_rai_ptr                    000414 automatic       pointer                  dcl 1198 set ref 803* 804
temp_rel                               based           bit(1)                   array level 3 packed packed unaligned dcl 12-5 ref
                                                                                  942
temporary_index                 000566 automatic       fixed bin(35,0)          dcl 962 set ref 965* 970 971 972 973
temporary_relation_index               parameter       fixed bin(35,0)          dcl 1208 ref 564 585 585 589 592
ti_ptr                                 based           pointer                  array level 3 in structure "select_sets" dcl 13-3
                                                                                  in procedure "define_temp_rel" ref 487
ti_ptr                   12            based           pointer                  level 3 in structure "dbcb" dcl 10-142 in procedure
                                                                                  "define_temp_rel" ref 496
ti_ptr                          000202 automatic       pointer                  dcl 15-17 in procedure "define_temp_rel" set ref
                                                                                  487* 496*
total_key                21(04)        based           bit(1)                   level 2 packed packed unaligned dcl 17-119 set ref
                                                                                  757*
tr_dir                          000314 automatic       char(168)                packed unaligned dcl 1186 set ref 423* 622* 674*
                                                                                  883*
tra_ptr                 136            based           pointer                  level 3 dcl 11-86 ref 434 583 616
transaction_manager_$abandon_txn
                                000016 constant        entry                    external dcl 1-72 ref 4-72 4-86 4-100 4-110 1-110
transaction_manager_$abort_txn  000020 constant        entry                    external dcl 1-73 ref 4-71 4-85 4-99 4-109 1-109
transaction_manager_$begin_txn  000022 constant        entry                    external dcl 1-74 ref 1-99
transaction_manager_$commit_txn 000034 constant        entry                    external dcl 4-56 ref 4-68
transaction_manager_$get_current_txn_id
                                000024 constant        entry                    external dcl 1-75 ref 1-89
transaction_manager_$handle_conditions
                                000026 constant        entry                    external dcl 1-76 ref 1-135
transaction_manager_$rollback_txn
                                000036 constant        entry                    external dcl 4-57 ref 4-82 4-96
transactions_needed     106(13)        based           bit(1)                   level 3 packed packed unaligned dcl 10-142 ref 456
tri                             000277 automatic       fixed bin(17,0)          dcl 1174 set ref 364* 441* 443 443* 446 452* 453
                                                                                  511* 513 543 624* 662 663 679 679 681 739 740 740
                                                                                  967* 970 971 972 1010 1010 1012* 1054
tup_var                   2            based           structure                array level 2 dcl 12-5
tuple_count                            parameter       fixed bin(35,0)          dcl 1209 set ref 564 573* 597*
tuple_id_len             41            based           fixed bin(17,0)          level 2 dcl 17-119 set ref 746*
tva_maximum_dimension_name_length
                                000160 automatic       fixed bin(17,0)          dcl 7-48 set ref 792* 793 793
tva_number_of_dimensions        000157 automatic       fixed bin(17,0)          dcl 7-46 set ref 791* 793 793
tva_number_of_vector_slots      000156 automatic       fixed bin(17,0)          dcl 7-44 set ref 790* 793 793
type                                   based           fixed bin(17,0)          level 2 in structure "simple_typed_vector" packed
                                                                                  packed unaligned dcl 23-17 in procedure
                                                                                  "define_temp_rel" set ref 504*
type                      0(01)        based           fixed bin(6,0)           level 2 in structure "descriptor" packed packed
                                                                                  unsigned unaligned dcl 22-6 in procedure
                                                                                  "define_temp_rel" ref 401
typed_vector_array                     based           structure                level 1 dcl 7-21 set ref 793
typed_vector_array_ptr          000154 automatic       pointer                  dcl 7-43 set ref 793* 794 831 833 883*
unique_chars_                   000044 constant        entry                    external dcl 1115 ref 740
unused_perm              21(10)        based           bit(1)                   level 2 packed packed unaligned dcl 17-119 set ref
                                                                                  752*
user_started_transaction
                        106(22)        based           bit(1)                   level 3 in structure "dbcb" packed packed unaligned
                                                                                  dcl 10-142 in procedure "define_temp_rel" set ref
                                                                                  470*
user_started_transaction        000104 automatic       bit(1)                   dcl 1-69 in procedure "define_temp_rel" set ref
                                                                                  1-92* 1-98* 470 4-60
user_transaction_id             000106 automatic       bit(36)                  dcl 1-71 set ref 1-93* 1-100*
val_dtr                 106(12)        based           bit(1)                   level 3 packed packed unaligned dcl 10-142 ref 480
var_att_index                   000536 automatic       fixed bin(17,0)          dcl 719 set ref 773*
version                                based           char(8)                  level 2 in structure "file_create_info" dcl 6-21
                                                                                  in procedure "define_temp_rel" set ref 865*
version                                based           fixed bin(35,0)          level 2 in structure "id_list" dcl 8-16 in procedure
                                                                                  "define_temp_rel" set ref 777* 783*
version                                based           fixed bin(35,0)          level 2 in structure "rel_creation_info" dcl 5-4
                                                                                  in procedure "define_temp_rel" set ref 875*
version                         000224 automatic       fixed bin(17,0)          initial level 2 in structure "rs_info" dcl 21-3
                                                                                  in procedure "define_temp_rel" set ref 21-3*
version                                based           fixed bin(35,0)          level 2 in structure "typed_vector_array" dcl 7-21
                                                                                  in procedure "define_temp_rel" set ref 794*
work_area                              based           area(1024)               dcl 1155 ref 502 782 787 793 863 864
work_area_ptr            70            based           pointer                  level 3 dcl 10-142 set ref 436*
x                               000412 automatic       fixed bin(17,0)          dcl 1197 set ref 802* 803*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
DIFFERENCE                             internal static fixed bin(17,0)          initial dcl 13-26
FCI_READ_BRACKET_IDX                   internal static fixed bin(17,0)          initial dcl 6-45
FCI_WRITE_BRACKET_IDX                  internal static fixed bin(17,0)          initial dcl 6-45
GENERAL_TYPED_VECTOR_TYPE              internal static fixed bin(17,0)          initial dcl 23-43
HIGHEST_MODE                           internal static fixed bin(17,0)          initial dcl 2-12
INTERSECTION                           internal static fixed bin(17,0)          initial dcl 13-25
LOWEST_MODE                            internal static fixed bin(17,0)          initial dcl 2-12
OLD_SIMPLE_TYPED_VECTOR_TYPE           internal static fixed bin(17,0)          initial dcl 23-43
TM_NEVER_WRITE_MODE                    internal static fixed bin(17,0)          initial dcl 2-18
TM_READ_ONLY_MODE                      internal static fixed bin(17,0)          initial dcl 2-17
TM_STATISTICAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-16
TM_TEST_NEVER_WRITE_MODE               internal static fixed bin(17,0)          initial dcl 2-22
TM_TEST_NORMAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-19
TM_TEST_READ_ONLY_MODE                 internal static fixed bin(17,0)          initial dcl 2-21
TM_TEST_STATISTICAL_MODE               internal static fixed bin(17,0)          initial dcl 2-20
UNION                                  internal static fixed bin(17,0)          initial dcl 13-24
condition_info_ptr                     automatic       pointer                  dcl 3-10
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 3-30
error_table_$null_info_ptr             external static fixed bin(35,0)          dcl 1-63
fixed                                                  builtin function         dcl 1213
general_typed_vector                   based           structure                level 1 packed packed unaligned dcl 23-24
general_typed_vector_ptr               automatic       pointer                  dcl 23-38
gtv_number_of_dimensions               automatic       fixed bin(17,0)          dcl 23-40
move_list_array                        based           structure                array level 1 unaligned dcl 14-40
nitems_init                            automatic       fixed bin(17,0)          dcl 13-22
rel                                                    builtin function         dcl 1213
rm_num_rels_init                       automatic       fixed bin(17,0)          dcl 16-44
ti_ntuples_init                        automatic       fixed bin(17,0)          dcl 15-18
tuple_info                             based           structure                level 1 dcl 15-10

NAMES DECLARED BY EXPLICIT CONTEXT.
check_self_definition           004120 constant        entry                    internal dcl 920 ref 490 498
complete_definition             004236 constant        entry                    internal dcl 953 ref 546
create_temp_rel_file            002641 constant        entry                    internal dcl 701 ref 520
define_temp_rel                 000142 constant        entry                    external dcl 28
del_trels                       002103 constant        entry                    external dcl 605
delete_temp_rel_file            002352 constant        entry                    internal dcl 655 ref 515 625 968 1011
error                           004324 constant        entry                    internal dcl 979 ref 382 386 408 418 432 437 446 450
                                                                                  453 1-140 478 480 542 646 672 676 734 888 900 914
exit                            001512 constant        label                    dcl 551 set ref 986 995
get_resultant_dir               002311 constant        entry                    internal dcl 631 ref 423 622
get_temp_rel_population         001775 constant        entry                    external dcl 564
mftxn_check_code                001523 constant        label                    dcl 4-65 ref 1-127 1-133
mftxn_exit                      001743 constant        label                    dcl 4-115 ref 4-63
mrds_dsl_define_temp_rel        000152 constant        entry                    external dcl 28
mstxn_any_other                 002214 constant        entry                    internal dcl 1-116 ref 465
mstxn_cleanup                   002162 constant        entry                    internal dcl 1-102 ref 462
mstxn_exit                      001066 constant        label                    dcl 1-140 ref 1-86 1-95 4-91 4-105
restore_significant_data        004436 constant        entry                    internal dcl 1029 ref 4-77
should_rollback                 004563 constant        entry                    internal dcl 1066 ref 4-94
tidy_up                         004365 constant        entry                    internal dcl 1001 ref 463 993

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5466        5616    4620        5476
Length      6574    4620       130         742     646           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
define_temp_rel                     682 external procedure  is an external procedure.  
on unit on line 460                  76 on unit               
on unit on line 465                  82 on unit               
mstxn_cleanup                           internal procedure  shares stack frame of on unit on line 460.  
mstxn_any_other                         internal procedure  shares stack frame of on unit on line 465.  
get_resultant_dir                       internal procedure  shares stack frame of external procedure define_temp_rel.  
delete_temp_rel_file                 98 internal procedure  is called by several nonquick procedures.  
create_temp_rel_file                    internal procedure  shares stack frame of external procedure define_temp_rel.  
check_self_definition                   internal procedure  shares stack frame of external procedure define_temp_rel.  
complete_definition                     internal procedure  shares stack frame of external procedure define_temp_rel.  
error                                64 internal procedure  is called by several nonquick procedures.  
tidy_up                              76 internal procedure  is called by several nonquick procedures.  
restore_significant_data                internal procedure  shares stack frame of external procedure define_temp_rel.  
should_rollback                         internal procedure  shares stack frame of external procedure define_temp_rel.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
define_temp_rel          000100 mstxn_code                  define_temp_rel
                         000101 mstxn_retries               define_temp_rel
                         000102 mstxn_temp_code             define_temp_rel
                         000103 mstxn_transactions_needed   define_temp_rel
                         000104 user_started_transaction    define_temp_rel
                         000105 mstxn_txn_id                define_temp_rel
                         000106 user_transaction_id         define_temp_rel
                         000110 mstxn_condition_info        define_temp_rel
                         000142 mftxn_code                  define_temp_rel
                         000143 mftxn_temp_code             define_temp_rel
                         000144 num_defined                 define_temp_rel
                         000145 original_cd                 define_temp_rel
                         000146 rel_creation_info_ptr       define_temp_rel
                         000150 REL_CREATION_INFO_VERSION_2 define_temp_rel
                         000152 file_create_info_ptr        define_temp_rel
                         000154 typed_vector_array_ptr      define_temp_rel
                         000156 tva_number_of_vector_slots  define_temp_rel
                         000157 tva_number_of_dimensions    define_temp_rel
                         000160 tva_maximum_dimension_name_length
                                                            define_temp_rel
                         000162 id_list_ptr                 define_temp_rel
                         000164 il_number_of_ids            define_temp_rel
                         000166 relation_index_flags_ptr    define_temp_rel
                         000170 dbcb_ptr                    define_temp_rel
                         000172 rdbi_ptr                    define_temp_rel
                         000174 range_ptr                   define_temp_rel
                         000176 ss_ptr                      define_temp_rel
                         000200 select_list_ptr             define_temp_rel
                         000202 ti_ptr                      define_temp_rel
                         000204 rmra_ptr                    define_temp_rel
                         000206 rmri_ptr                    define_temp_rel
                         000210 nkey_attr_init              define_temp_rel
                         000211 natts_init                  define_temp_rel
                         000212 nvar_atts_init              define_temp_rel
                         000214 rai_ptr                     define_temp_rel
                         000216 rdi_ptr                     define_temp_rel
                         000220 al_ptr                      define_temp_rel
                         000222 num_ptrs                    define_temp_rel
                         000224 rs_info                     define_temp_rel
                         000242 desc_ptr                    define_temp_rel
                         000244 num_dims                    define_temp_rel
                         000246 simple_typed_vector_ptr     define_temp_rel
                         000250 stv_number_of_dimensions    define_temp_rel
                         000252 se_ptr                      define_temp_rel
                         000254 raip                        define_temp_rel
                         000256 appl_ptr                    define_temp_rel
                         000260 adpl_ptr                    define_temp_rel
                         000262 save_appl_ptr               define_temp_rel
                         000264 save_adpl_ptr               define_temp_rel
                         000266 cd_ptr                      define_temp_rel
                         000270 rel_index_ptr               define_temp_rel
                         000272 dbi_ptr                     define_temp_rel
                         000274 nargs                       define_temp_rel
                         000275 arg_len                     define_temp_rel
                         000276 se_len                      define_temp_rel
                         000277 tri                         define_temp_rel
                         000300 key_order                   define_temp_rel
                         000301 num_args                    define_temp_rel
                         000302 save_num_args               define_temp_rel
                         000303 icode                       define_temp_rel
                         000304 entry_point_name            define_temp_rel
                         000314 tr_dir                      define_temp_rel
                         000366 ntuples_retrieved           define_temp_rel
                         000412 x                           define_temp_rel
                         000414 temp_rai_ptr                define_temp_rel
                         000416 i                           define_temp_rel
                         000417 no_recurse                  define_temp_rel
                         000420 area_ptr                    define_temp_rel
                         000422 se_len_ptr                  define_temp_rel
                         000424 self_defined                define_temp_rel
                         000425 actual_rel_index            define_temp_rel
                         000426 created_resultant           define_temp_rel
                         000427 dbi_pic                     define_temp_rel
                         000444 pathname                    get_resultant_dir
                         000524 actual_rel_pic              create_temp_rel_file
                         000526 cibi_ptr                    create_temp_rel_file
                         000530 create_index_flags          create_temp_rel_file
                         000531 i                           create_temp_rel_file
                         000532 j                           create_temp_rel_file
                         000533 max_build_indices           create_temp_rel_file
                         000534 retrieve_id_list_ptr        create_temp_rel_file
                         000536 var_att_index               create_temp_rel_file
                         000554 i                           check_self_definition
                         000555 self_defined_flag           check_self_definition
                         000566 temporary_index             complete_definition
                         000576 ignore_icode                restore_significant_data
delete_temp_rel_file     000100 j                           delete_temp_rel_file

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ent_var_desc   call_ent_var        call_ext_out_desc   call_ext_out
call_int_this       call_int_other      return_mac          tra_ext_1           signal_op           enable_op
shorten_stack       ext_entry           int_entry           trunc_fx2           ceil_fx2            any_to_any_truncate_
divide_fx1          op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
continue_to_signal_           cu_$arg_list_ptr              cu_$arg_ptr                   find_condition_info_
mrds_dsl_delete_se            mrds_dsl_resultant_storage$get_opening_temp_dir             mrds_dsl_translate
mu_cursor_manager_$destroy_and_free_on_opening_id           mu_database_index$get_resultant_model_pointer
mu_define_area$define_spec_temp_dir_area                    mu_define_area$define_temp_dir_area
mu_get_tuple                  mu_release_area               mu_store$store_direct
transaction_manager_$abandon_txn                            transaction_manager_$abort_txn
transaction_manager_$begin_txn                              transaction_manager_$commit_txn
transaction_manager_$get_current_txn_id                     transaction_manager_$handle_conditions
transaction_manager_$rollback_txn                           unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bj_journal_full     dm_error_$key_duplication     dm_error_$lock_deadlock
dm_error_$no_current_transaction                            mrds_data_$caller_define_temp_rel
mrds_data_$max_attributes     mrds_data_$max_id_len         mrds_data_$max_select_items   mrds_data_$max_temp_rels
mrds_data_$relation_blocking_factor                         mrds_error_$dup_temp_rel_attr mrds_error_$inval_dtr_expr
mrds_error_$invalid_db_index  mrds_error_$max_temp_rels     mrds_error_$no_tr_keys        mrds_error_$tuple_not_found
mrds_error_$undefined_temp_rel_index                        sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 5   11 000110    8   21 000112    8   22 000114    9   24 000116   14   38 000120   18   65 000121   19   51 000122
21    3 000123   22   20 000134      1200 000135      1215 000136        28 000141       363 000160       364 000164
    365 000165       366 000166       367 000167       368 000170       370 000173       371 000202       373 000211
    374 000221       377 000226       378 000243       381 000250       382 000267       385 000277       386 000316
    389 000326       390 000333       391 000336       393 000343       394 000346       396 000347       397 000353
    398 000360       401 000363       402 000370       403 000373       406 000375       408 000415       411 000425
    413 000430       415 000433       418 000444       421 000457       423 000462       425 000472       426 000503
    431 000551       432 000554       434 000564       436 000567       437 000613       440 000623       441 000625
    442 000626       443 000637       445 000661       446 000663       448 000674       450 000675       452 000711
    453 000716       456 000742       457 000747       458 000751       459 000753       460 000755       462 000771
    463 000772       464 000777       465 001000    1   83 001016    1   84 001017    1   86 001020    1   88 001022
 1   89 001023    1   90 001034    1   92 001040    1   93 001042    1   94 001044    1   95 001045    1   98 001046
 1   99 001047    1  100 001064    1  140 001066       470 001076       471 001104       474 001107       478 001136
    480 001146       483 001161       484 001166       485 001170       486 001201       487 001203       488 001205
    489 001207       490 001226       491 001255       492 001257       494 001260       495 001262       496 001264
    497 001266       498 001270       501 001304       502 001307       504 001323       507 001326       509 001331
    510 001333       511 001340       512 001341       513 001342       515 001344       517 001352       520 001356
    521 001357       522 001360       523 001364       524 001403       525 001406       528 001423       530 001430
    532 001436       533 001441       535 001460       536 001461       537 001464       539 001467       541 001472
    542 001473       543 001501       546 001505       550 001511       551 001512    4   60 001514    4   62 001521
 4   63 001522    4   65 001523    4   68 001525    4   69 001536    4   71 001540    4   72 001551    4   75 001564
 4   77 001565    4   78 001566    4   81 001575    4   82 001576    4   83 001611    4   85 001613    4   86 001624
 4   88 001637    4   90 001640    4   91 001641    4   93 001642    4   94 001643    4   96 001650    4   97 001664
 4   99 001666    4  100 001677    4  102 001712    4  104 001713    4  105 001714    4  107 001715    4  109 001716
 4  110 001727    4  114 001742    4  115 001743       558 001746       560 001753       562 001767       564 001770
    573 002003       574 002006       575 002007       577 002012       578 002023       581 002034       583 002037
    585 002041       589 002053       592 002066       597 002075       603 002077       605 002100       614 002111
    615 002115       616 002117       617 002121       618 002123       619 002124       621 002127       622 002132
    623 002142       624 002145       625 002153       626 002157       629 002161    1  102 002162    1  107 002163
 1  109 002166    1  110 002177    1  114 002213    1  116 002214    1  121 002215    1  123 002220    1  124 002237
 1  126 002245    1  127 002250    1  129 002253    1  132 002265    1  133 002270    1  135 002273    1  136 002300
 1  137 002301    1  138 002310       631 002311       644 002313       646 002326       651 002337       653 002345
    655 002351       662 002357       663 002377       665 002402       667 002404       668 002406       672 002427
    674 002441       676 002467       679 002501       681 002526       683 002534       684 002540       685 002551
    686 002563       687 002570       688 002572       689 002575       691 002600       693 002602       694 002622
    695 002636       699 002640       701 002641       721 002642       722 002644       723 002646       724 002656
    725 002661       726 002662       727 002671       728 002675       729 002677       730 002700       731 002711
    733 002717       734 002721       737 002733       739 002754       740 002770       744 003064       745 003067
    746 003071       747 003073       752 003103       757 003113       759 003115       761 003123       765 003131
    768 003133       769 003135       770 003136       771 003140       772 003141       773 003153       775 003155
    776 003160       777 003171       778 003173       782 003176       783 003206       784 003210       786 003211
    787 003214       788 003224       790 003225       791 003226       792 003231       793 003233       794 003266
    796 003270       798 003301       799 003305       800 003313       802 003325       803 003335       804 003341
    806 003351       808 003353       809 003363       812 003370       816 003374       817 003402       818 003405
    819 003406       820 003411       825 003414       826 003420       828 003421       831 003433       833 003465
    841 003477       843 003503       845 003514       846 003520       847 003524       848 003527       850 003534
    851 003537       853 003542       854 003544       858 003555       863 003566       864 003573       865 003634
    867 003637       868 003642       869 003644       870 003646       871 003650       872 003652       873 003666
    874 003702       875 003705       876 003707       877 003711       880 003716       883 003720       888 003762
    893 003772       894 003773       895 003775       896 003777       897 004001       900 004023       905 004033
    906 004036       908 004040       909 004047       910 004052       914 004105       916 004115       918 004117
    920 004120       937 004122       941 004123       942 004135       944 004200       947 004226       949 004230
    953 004236       965 004237       966 004241       967 004243       968 004244       970 004250       971 004262
    972 004306       973 004320       975 004322       979 004323       986 004331       988 004341       989 004345
    992 004352       993 004354       995 004361      1001 004364      1010 004372      1011 004405      1012 004412
   1014 004414      1017 004435      1029 004436      1036 004437      1037 004445      1038 004455      1039 004467
   1044 004471      1053 004516      1054 004531      1056 004547      1058 004554      1059 004556      1060 004560
   1062 004562      1066 004563      1068 004565


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
