	COMPILATION LISTING OF SEGMENT probe_stack_trace_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/27/88  1235.1 mst Thu
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(88-09-07,WAAnderson), approve(88-09-30,MCR7952),
       16*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
       17*     Added format control comment to make the source more readable.
       18*                                                   END HISTORY COMMENTS */
       19 
       20 
       21 /* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       22 
       23 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       24 
       25 probe_stack_trace_:
       26   proc ();
       27 
       28   call probe_error_$malfunction ();	/* dummy entry */
       29 
       30   /* this module is the interface to the Multics stack - it is the only authorized caller of
       31*   probe_trace_a_stack_, and shares with it and only it the knowledge of the internal
       32*   probe stack.  We have a variety of entries to return information about the invocations of
       33*   entries on the stack
       34*
       35*
       36*   print_stack_history 	- dump the stack in nice format
       37*
       38*   find_previous_invocation	- ???
       39*   find_condition_frame	- find info for condition
       40*   get_level		- find info for frame N
       41*   find_frame		- find info for first frame with SP = x
       42*   find_block_frame		- find info for frame of given BP
       43*   find_proc_frame		 -find info for the N'th frame of given entry_ptr
       44*   condition_raised		- return name of condition raised in frame of given SP, or ""
       45*
       46*   where_source_info	-interprets a source_info, setting level number and block name for caller
       47*
       48*
       49*   Initial Version:  13 August 1974 by Jeffrey M. Broughton
       50*   Modified:  19 August 1975 by JMB to allocate level structures
       51*   Modified:   7 June 78 by James R. Davis fix TR1326
       52*   Modified:28 June 78 By JRD to not lose with new_fortran
       53*   Modified: 20 Sept 78 by JRDto not include find_physical_block
       54*   Converted to probe 4.0 05/19/79 WOS
       55*   yet more conversion JRD 1 July 79 */
       56   /* Added $current_level function entrypoint for use in "ps level +N" 10/09/81 S. Herbst */
       57   /* Changed to use level_frame.printed_number 12/10/81 S. Herbst */
       58   /* Fixed to call probe_block_name_ with "0"b (brief form) 08/26/83 S. Herbst */
       59 
       60   dcl (
       61       P_probe_info_ptr	pointer,
       62       P_entry_ptr		pointer,	/* (Input) pointer to desired procedure */
       63       P_invocation		fixed bin,/* what this number of levels back */
       64       P_level_number	fixed bin,/* (Input) desired level_number */
       65       P_level_decimal	fixed bin,/* (Input) support frame decimal M in N.M */
       66       P_block_name		char (*), /* name of a block found */
       67       P_cond_name		char (32),/* (output) name of the condition found */
       68       P_sourcep		ptr,	/* to callers source_info to be filled in or used as input */
       69       P_invoc_count		fixed bin,/* (input): number of invocations back to search for */
       70       P_stack_frame_ptr	pointer
       71       )			parameter;/* pointer to stack frame we are interested in */
       72 
       73 
       74   /* many of these entries take a source_info struc, using some of the values as input, or perhaps
       75*   filling the struc in as output.  All entries that need this struc have as parameter P_sourcep,
       76*   which is assigned to level_source_ptr, and the struc found_source_info is referenced */
       77   dcl 1 found_source_info	aligned like source_info
       78 			based (level_source_ptr);
       79   dcl level_source_ptr	ptr;
       80 
       81 
       82 
       83   dcl count		fixed bin;/* number of invocations found thus far */
       84   dcl last_invocation	pointer;	/* last invocation found */
       85   dcl saved_lfp		pointer;
       86   dcl i			fixed bin;
       87   dcl continue_tracing	bit (1) aligned;
       88   dcl code		fixed bin (35);
       89 
       90   dcl 1 cond_info		aligned like condition_info automatic;
       91 
       92   dcl find_condition_info_	entry (pointer, pointer, fixed bin (35));
       93 
       94   dcl probe_error_$malfunction
       95 			entry options (variable);
       96   dcl probe_block_name_	entry (ptr, ptr, bit (1) aligned)
       97 			returns (character (256) varying);
       98   dcl probe_trace_a_stack_	entry (ptr, ptr, bit (1) aligned);
       99 
      100   dcl (addr, max, null)
      101 			builtin;
      102 				/*  */
      103 MAIN_RETURN:
      104   return;
      105 				/*  */
      106 probe_stack_trace_$find_proc_frame:
      107   entry (P_probe_info_ptr, P_sourcep, P_entry_ptr, P_invoc_count);
      108 
      109 
      110   level_source_ptr = P_sourcep;
      111   call setup;
      112   count = 0;
      113   last_invocation = null ();
      114 
      115   lfp = stack_info.level_chain;
      116   continue_tracing = "1"b;		/* curse pl1, which lacks do ... until */
      117   do while (continue_tracing);
      118     if level_frame.entry_ptr = P_entry_ptr then do;
      119         last_invocation = lfp;	/* remember in case this is the last one found */
      120         count = count + 1;
      121       end;
      122 
      123     if (count >= P_invoc_count) | (level_frame.number >= stack_info.max_level)
      124       then
      125 	 continue_tracing = "0"b;
      126       else lfp = level_frame.next;	/* look at the next frame */
      127   end;
      128 
      129   if last_invocation = null () then do; /* didn't find any */
      130       found_source_info.entry_ptr,
      131 	 found_source_info.stack_ptr,
      132 	 found_source_info.block_ptr,
      133 	 found_source_info.instruction_ptr = null ();
      134       found_source_info.stmnt_map_entry_index = -1;
      135 
      136       /* the old code set the entry_ptr to that passed to us */
      137       goto MAIN_RETURN;
      138     end;
      139 
      140   lfp = last_invocation;
      141   found_source_info = level_frame.source_info;
      142 
      143   goto MAIN_RETURN;			/* end of code for $find_proc_frame entry point */
      144 
      145   /*  */
      146 
      147 
      148   /* used by get_invocation_level - whateverit is called now */
      149 
      150 probe_stack_trace_$find_previous_invocation:
      151   entry (P_probe_info_ptr, P_sourcep, P_invocation);
      152 
      153 
      154   call setup;
      155   level_source_ptr = P_sourcep;
      156 
      157   count = 0;
      158   last_invocation = null ();
      159 
      160   if found_source_info.stack_ptr ^= null & found_source_info.block_ptr ^= null
      161     then do;			/* look for it */
      162       lfp = stack_info.level_chain;
      163       continue_tracing = "1"b;	/* curse pl1, which lacks do ... until */
      164       do while (continue_tracing);	/* look for [invocation]th occurence of frame */
      165         if count <= 0 then do;
      166 	  if found_source_info.stack_ptr = level_frame.stack_ptr
      167 	    then /* look for starting level */
      168 	         if found_source_info.block_ptr = level_frame.block_ptr
      169 		 then do;		/* found */
      170 		   count = 1;
      171 		   last_invocation = lfp;
      172 		 end;
      173 	end;
      174 
      175         else if found_source_info.block_ptr = level_frame.block_ptr then do;
      176 	  count = count + 1;	/* found one, now look for previous */
      177 	  last_invocation = lfp;
      178 	end;
      179 
      180         if (count >= P_invocation)
      181 	   | (level_frame.number >= stack_info.max_level)
      182 	then
      183 	     continue_tracing = "0"b;
      184 	else lfp = level_frame.next;	/* consider the previous frame */
      185       end;
      186     end;
      187 
      188   if last_invocation = null () then do; /* not even one */
      189       found_source_info.stack_ptr, found_source_info.instruction_ptr = null;
      190       goto MAIN_RETURN;
      191     end;
      192 
      193   found_source_info = last_invocation -> level_frame.source_info;
      194 
      195   goto MAIN_RETURN;			/* end of code for $find_previous_invocation entry */
      196 
      197   /*  */
      198 probe_stack_trace_$condition_raised:
      199   entry (P_probe_info_ptr, P_sourcep, P_cond_name);
      200 
      201 
      202   call setup;
      203   level_source_ptr = P_sourcep;
      204 
      205   do lfp = stack_info.level_chain repeat level_frame.next
      206        while (level_frame.number <= stack_info.max_level);
      207     if level_frame.stack_ptr = found_source_info.stack_ptr
      208       then do;
      209         if level_frame.condition_frame_ptr = null () then do;
      210 				/* don't let f_c_i_ do this, it does it wrong */
      211 	  P_cond_name = "";		/* no condition */
      212 	  goto MAIN_RETURN;
      213 	end;
      214 
      215         call find_condition_info_ ((level_frame.condition_frame_ptr),
      216 	   addr (cond_info), (0));
      217         P_cond_name = cond_info.condition_name;
      218         goto MAIN_RETURN;
      219       end;
      220   end;				/* loop */
      221   P_cond_name = "";			/* not found ! unlikely */
      222   goto MAIN_RETURN;			/* end of code for condition_raised */
      223 
      224 probe_stack_trace_$find_condition_frame:
      225   entry (P_probe_info_ptr, P_sourcep, P_cond_name);
      226 
      227   call setup;
      228 
      229   level_source_ptr = P_sourcep;
      230 
      231   begin;
      232     dcl other_frame		  ptr;
      233     dcl error_frame		  ptr;
      234 
      235     other_frame, error_frame = null ();
      236     lfp = stack_info.level_chain;
      237     continue_tracing = "1"b;		/* curse pl1, which lacks do ... until */
      238     do while (continue_tracing);
      239       if level_frame.condition_frame_ptr ^= null
      240         then
      241 	   if level_frame.error_signalled
      242 				/* "error" is less interesting then others */
      243 	     then if error_frame = null
      244 		  then error_frame = lfp;
      245 				/* first instance of "error" */
      246 		  else ;		/* not the first, leave ptr alone */
      247 	     else other_frame = lfp;	/* more interesting error, search done */
      248 
      249       if (level_frame.number >= stack_info.max_level)
      250 	 | (other_frame ^= null ())
      251         then
      252 	   continue_tracing = "0"b;
      253         else lfp = level_frame.next;
      254     end;				/* loop through frames */
      255 
      256     if other_frame = null
      257       then /* got no interesting one? */
      258 	 other_frame = error_frame;	/* so use "error" */
      259 
      260     if other_frame = null then do;
      261         P_cond_name = "";
      262         found_source_info.stack_ptr,
      263 	   found_source_info.entry_ptr,
      264 	   found_source_info.block_ptr,
      265 	   found_source_info.instruction_ptr = null ();
      266       end;
      267       else do;
      268         call find_condition_info_
      269 	   ((other_frame -> level_frame.condition_frame_ptr),
      270 	   addr (cond_info), code);
      271         P_cond_name = cond_info.condition_name;
      272         found_source_info = other_frame -> level_frame.source_info;
      273       end;
      274   end;				/* begin block */
      275 
      276   goto MAIN_RETURN;			/* end of code for $find_condition_frame entry point */
      277 
      278   /*  */
      279 
      280 probe_stack_trace_$current_level:
      281   entry (P_probe_info_ptr) returns (fixed bin);
      282 
      283   /* Returns the number (as traced by "stack") of the current frame */
      284 
      285 
      286   call setup;
      287 
      288   lfp = stack_info.level_chain;
      289   return (level_frame.printed_number);
      290 
      291   /* end of code for $current_level entrypoint */
      292 
      293   /*  */
      294 
      295 probe_stack_trace_$get_level:
      296   entry (P_probe_info_ptr, P_sourcep, P_level_number, P_level_decimal);
      297 
      298 
      299   call setup;
      300   level_source_ptr = P_sourcep;
      301 
      302   i = max (1, P_level_number);	/* must be positive */
      303 
      304   lfp = stack_info.level_chain;
      305   continue_tracing = "1"b;		/* curse pl1, which lacks do ... until */
      306   do while (continue_tracing & lfp ^= null);
      307 				/* find indicated frame */
      308 
      309     saved_lfp = lfp;
      310 
      311     if level_frame.printed_number = i
      312          & level_frame.printed_decimal = P_level_decimal
      313       then
      314 	 continue_tracing = "0"b;
      315       else lfp = lfp -> level_frame.next;
      316   end;
      317 
      318   if lfp = null
      319     then lfp = saved_lfp;		/* asked for too high a number; give highest */
      320   P_sourcep -> source_info = level_frame.source_info;
      321 
      322   goto MAIN_RETURN;			/* end of code for $get_level entrypoint */
      323 
      324   /*  */
      325 
      326 probe_stack_trace_$find_frame:
      327   entry (P_probe_info_ptr, P_sourcep, P_stack_frame_ptr);
      328 
      329 
      330   call setup;
      331   level_source_ptr = P_sourcep;
      332 
      333   lfp = stack_info.level_chain;
      334   continue_tracing = "1"b;		/* curse pl1, which lacks do ... until */
      335   do while (continue_tracing);	/* search all frames for one that matches */
      336     if level_frame.stack_ptr = P_stack_frame_ptr then do;
      337 				/* found it */
      338         found_source_info = level_frame.source_info;
      339         goto MAIN_RETURN;
      340       end;
      341     if level_frame.number >= stack_info.max_level
      342       then
      343 	 continue_tracing = "0"b;
      344       else lfp = level_frame.next;
      345   end;
      346 
      347   found_source_info.stack_ptr,
      348        found_source_info.block_ptr,
      349        found_source_info.instruction_ptr,
      350        found_source_info.entry_ptr = null ();
      351   goto MAIN_RETURN;			/* end of code for $find_frame entrypoint */
      352 
      353   /*  */
      354 
      355 probe_stack_trace_$find_block_frame:
      356   entry (P_probe_info_ptr, P_sourcep);
      357 
      358   /* given a block pointer, search the stack for the first frame whose block is the given
      359*   block - if not found, then found_source_info.stack_ptr will be null () */
      360 
      361 
      362   call setup;
      363   level_source_ptr = P_sourcep;
      364 
      365   if found_source_info.block_ptr = null ()
      366     then call probe_error_$malfunction (probe_info_ptr, 0,
      367 	    "null block ptr in call to find_block_frame");
      368 
      369   continue_tracing = "1"b;		/* I wish we had do ... until */
      370   lfp = stack_info.level_chain;
      371   do while (continue_tracing);
      372     if level_frame.block_ptr = found_source_info.block_ptr then do;
      373         found_source_info = level_frame.source_info;
      374         goto MAIN_RETURN;
      375       end;
      376 
      377     if level_frame.number >= stack_info.max_level
      378       then
      379 	 continue_tracing = "0"b;
      380       else lfp = level_frame.next;
      381   end;				/* of loop through frames */
      382 
      383   found_source_info.stack_ptr = null ();
      384   goto MAIN_RETURN;
      385 				/* end of code for $find_block_frame entrypoint */
      386 
      387   /*  */
      388 
      389 probe_stack_trace_$where_source_info:
      390   entry (P_probe_info_ptr, P_sourcep, P_level_number, P_block_name);
      391 
      392 
      393   call setup;
      394   level_source_ptr = P_sourcep;
      395 
      396   continue_tracing = "1"b;		/* I wish we had do ... until */
      397   lfp = stack_info.level_chain;
      398   do while (continue_tracing);	/* look for the frame for the current block */
      399     if level_frame.stack_ptr = found_source_info.stack_ptr
      400          & level_frame.block_ptr = found_source_info.block_ptr then do;
      401         P_level_number = level_frame.printed_number;
      402         P_block_name =
      403 	   probe_block_name_ (probe_info_ptr,
      404 	   addr (level_frame.source_info), "0"b);
      405         goto MAIN_RETURN;
      406       end;
      407 
      408     if level_frame.number >= stack_info.max_level
      409       then
      410 	 continue_tracing = "0"b;
      411       else lfp = level_frame.next;
      412   end;
      413 
      414   /* not found, so make the name by using the input, and hope there's enough
      415*   information there to make a coherent name */
      416 
      417   P_block_name =
      418        probe_block_name_ (probe_info_ptr, addr (found_source_info), "0"b);
      419   P_level_number = -1;		/*  show failure */
      420 
      421   goto MAIN_RETURN;			/* no frame for block */
      422 
      423   /*  */
      424 setup:
      425   proc;
      426 
      427 
      428   probe_info_ptr = P_probe_info_ptr;
      429 
      430   call probe_trace_a_stack_ (probe_info_ptr,
      431        probe_info.current_stack_frame -> frame.back,
      432        (stack_info.traced_with_all));
      433   end setup;
      434 
      435 
      436   /*	INCLUDE FILES	*/
      437 
      438   /* ;;;;;;; */
      439 
  1     1 /*	BEGIN INCLUDE FILE probe_info.incl.pl1		*/
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(88-10-24,WAAnderson), approve(88-10-24,MCR7952),
  1     7*     audit(88-10-24,RWaters), install(88-10-27,MR12.2-1194):
  1     8*     Added field 'retry_using_main' to add new C feature.
  1     9*                                                   END HISTORY COMMENTS */
  1    10 
  1    11 
  1    12 /* Created: 04/22/79 W. Olin Sibert, from subsystem_info	
  1    13*   Modified: 22 Sept 79 JRd to remove: 	default (ptr & (auto|based)) init (null ());
  1    14*   Added flags.setting_break 08/22/83 Steve Herbst
  1    15*   Added flags.executing_quit_request 01/15/85 Steve Herbst
  1    16**/
  1    17 
  1    18 dcl 1 probe_info aligned based (probe_info_ptr),		/* standard data for a probe invocation */
  1    19     2 probe_info_version fixed bin,			/* version of this structure */
  1    20 
  1    21     2 static_info_ptr pointer unaligned,		/* pointer to static information structure */
  1    22     2 modes_ptr pointer unaligned,			/* pointer to probe_modes structure */
  1    23 
  1    24     2 ptr_to_current_source ptr,			/* current_source is based on this */
  1    25     2 ptr_to_initial_source ptr,			/* initial_source is based on this */
  1    26     2 machine_cond_ptr pointer,			/* pointer to machine conditions, if we faulted to get here */
  1    27 
  1    28     2 token_info aligned,				/* information about token chain currently being processed */
  1    29       3 first_token pointer unaligned,			/* first token in chain */
  1    30       3 ct pointer unaligned, 			/* pointer to current token; updated in MANY places */
  1    31       3 end_token bit (18) aligned,			/* token type at which to stop scanning token chain */
  1    32       3 buffer_ptr pointer unaligned,			/* pointer to input buffer */
  1    33       3 buffer_lth fixed bin (21),			/* and length */
  1    34 
  1    35     2 random_info aligned,
  1    36       3 current_stack_frame pointer unaligned,		/* stack frame pointer for frame in which probe was invoked */
  1    37       3 input_type fixed bin, 			/* current input type */
  1    38       3 language_type fixed bin,			/* current language being processed */
  1    39       3 return_method fixed bin,			/* how we should return after exiting probe */
  1    40       3 entry_method fixed bin,			/* how we got here in the first place */
  1    41       3 pad1 (19) bit (36) aligned,
  1    42 
  1    43     2 break_info,					/* break info -- only interesting if we got here via a break */
  1    44       3 break_slot_ptr pointer,			/* pointer to break slot -- non-null IFF at a break */
  1    45       3 last_break_slot_ptr pointer unaligned,		/* pointer to previous break slot, not presently used */
  1    46       3 break_reset bit (1) aligned,			/* this break has been reset by somebody further on */
  1    47       3 real_break_return_loc pointer,			/* where to REALLY return to, modulo previous bit */
  1    48 
  1    49     2 probe_area_info,				/* information about various probe areas */
  1    50       3 break_segment_ptr pointer unaligned,		/* pointer to Personid.probe */
  1    51       3 break_area_ptr pointer unaligned,		/* pointer to area in break segment */
  1    52       3 scratch_area_ptr pointer unaligned,		/* pointer to probe scratch seg in process dir */
  1    53       3 probe_area_ptr pointer unaligned,		/* This area lasts as long as an invocation of probe. */
  1    54       3 work_area_ptr pointer unaligned,		/* This area lasts as long as the current request line */
  1    55       3 expression_area_ptr pointer unaligned,		/* This area lasts as long as the current command */
  1    56 
  1    57     2 flags aligned,				/* this, in particular, should be saved and restored correctly */
  1    58      (3 execute,					/* "1"b => execute requests, "0"b => just check syntax */
  1    59       3 in_listener,				/* ON => in probe listener loop */
  1    60       3 executing_request,				/* ON => executing a request */
  1    61       3 in_interpret_line,				/* executing in probe_listen_$interpret_line */
  1    62       3 setting_break,				/* executing "after" or "before": check syntax of "if" */
  1    63       3 executing_quit_request,			/* to prevent error looping during "quit" request */
  1    64       3 pad (30)) bit (1) unaligned,
  1    65 
  1    66     2 io_switches,					/* switches probe will do normal I/O on */
  1    67       3 input_switch pointer,
  1    68       3 output_switch pointer,
  1    69 
  1    70     2 error_info,					/* information about the last error saved for later printing */
  1    71       3 error_code fixed bin (35),
  1    72       3 error_message char (300) varying,
  1    73 
  1    74     2 listener_info,				/* internal use by probe listener */
  1    75       3 request_name character (32) varying,		/* primary name of the request being processed */
  1    76       3 abort_probe_label label variable,
  1    77       3 abort_line_label label variable,
  1    78       3 depth fixed binary,				/* count of active invocations of probe */
  1    79       3 previous pointer unaligned,			/* -> previous invocation's info */
  1    80       3 next pointer unaligned,
  1    81 
  1    82     2 end_of_probe_info pointer aligned,
  1    83     2 retry_using_main fixed bin aligned;
  1    84    
  1    85 
  1    86 dcl  probe_info_ptr pointer;
  1    87 
  1    88 dcl  probe_info_version fixed bin static options (constant) initial (1);
  1    89 
  1    90 dcl  probe_info_version_1 fixed bin static options (constant) initial (1);
  1    91 
  1    92 dcl  scratch_area area based (probe_info.scratch_area_ptr);
  1    93 dcl  probe_area area based (probe_info.probe_area_ptr);
  1    94 dcl  work_area area based (probe_info.work_area_ptr);
  1    95 dcl  expression_area area based (probe_info.expression_area_ptr);
  1    96 
  1    97 /*	END INCLUDE FILE probe_info.incl.pl1		*/
      440 
      441 
      442   /* ;;;;;;; */
      443 
  2     1 /*	BEGIN INCLUDE FILE probe_static_info.incl.pl1	*/
  2     2 
  2     3 /* *	This include file describes per-process information about probe, such
  2     4*   *	as various options available and the info directories and modes.
  2     5*   *
  2     6*   *	Created: 06/06/79 W. Olin Sibert */
  2     7 
  2     8 dcl 1 probe_static_info aligned based (probe_info.static_info_ptr), /* per-process data about probe */
  2     9     2 probe_info_version fixed bin,			/* same as probe_info.probe_info_version */
  2    10 
  2    11     2 version aligned,
  2    12       3 major_version fixed bin,
  2    13       3 minor_version fixed bin,
  2    14       3 version_string char (32) unaligned,		/* like "4.3f, patch 1" */
  2    15 
  2    16     2 name char (32) unaligned,			/* "probe" */
  2    17     2 prompt character (40) varying,			/* prompt for reading requests */
  2    18     2 switches,
  2    19       3 brief_sw bit (1) unaligned,			/* briefer break messages, no header (default OFF) */
  2    20       3 no_handle_faults_sw bit (1) unaligned,		/* don't handle bad ptr faults (default OFF) */
  2    21       3 recursive_breaks_sw bit (1) unaligned,		/* don't ignore recursive breaks in probe */
  2    22       3 prompt_on_sw bit (1) unaligned,			/* prompt for request lines */
  2    23       3 switch_pad bit (32) unaligned,
  2    24 
  2    25     2 scratch_segment_ptr pointer,			/* pointer to probe_scratch_ -- always valid */
  2    26     2 break_segment_ptr pointer,			/* pointer to Person.breaks -- valid only if needed */
  2    27 
  2    28     2 seg_info_offset_ptr pointer,			/* pointer to seg_info_offset array */
  2    29 
  2    30     2 probe_segno bit (18),				/* segment number of probe itself */
  2    31    2 last_break_segno bit (18),			/* segment number of last interrupted program */
  2    32 
  2    33     2 stack_info aligned,				/* information about the stack trace in probe_scratch_ */
  2    34       3 level_chain pointer unaligned,			/* first level frame entry pointer */
  2    35       3 max_level fixed bin,				/* number of stack levels */
  2    36       3 flags aligned,
  2    37        (4 good_stack,
  2    38         4 traced_with_all,				/* whether the stack trace includes support frames */
  2    39         4 pad1 (34)) bit (1) unaligned,
  2    40 
  2    41     2 modes_ptr pointer unaligned,			/* pointer to modes -- same as probe_info.modes_ptr */
  2    42 
  2    43     2 request_table_info aligned,			/* info for request definitions */
  2    44       3 array_ptr pointer,				/* pointer to array of request table pointers */
  2    45       3 array_size fixed bin, 			/* number of elements in use */
  2    46       3 array_max_size fixed bin,			/* max number of elements in array */
  2    47       3 using_internal_array bit (1) aligned,		/* whether or not we are using the array in probe_static_info */
  2    48 
  2    49     2 io_switches,					/* switches probe does its I/O on */
  2    50       3 input_switch pointer,
  2    51       3 output_switch pointer,
  2    52       3 (private_input_sw, private_output_sw) bit (1) aligned,
  2    53 						/* created by ids, ods and should be destroyed */
  2    54 
  2    55     2 info_directory_info aligned,			/* info about info directories */
  2    56       3 array_ptr pointer,
  2    57       3 array_size fixed bin,
  2    58       3 array_max_size fixed bin,
  2    59       3 using_internal_array bit (1) aligned,
  2    60 
  2    61     2 exclude_name_info aligned,			/* info for exclude array used in printing values */
  2    62       3 array_ptr pointer,
  2    63       3 array_size fixed bin,
  2    64       3 array_max_size fixed bin,
  2    65       3 using_internal_array bit (1) aligned,
  2    66 
  2    67     2 null_seg_info_ptr pointer unaligned,		/* pointer to the "null" seg_info block */
  2    68 
  2    69     2 initial_arrays,				/* initial versions of various arrays */
  2    70       3 request_table_ptr_array (10) pointer aligned,
  2    71       3 info_directory_name_array (3) char (168) unaligned,
  2    72       3 exclude_name_array (6) char (32) unaligned,
  2    73 
  2    74     2 metering_info,					/* last values for "mode meter" */
  2    75       3 last_clock fixed bin (71),
  2    76       3 last_vclock fixed bin (71),
  2    77       3 last_page_faults fixed bin,
  2    78 
  2    79     2 end_of_probe_static_info fixed bin;
  2    80 
  2    81 
  2    82 dcl 1 probe_seg_info_array aligned based (probe_static_info.seg_info_offset_ptr),
  2    83     2 count fixed bin,				/* number of entries in seg_info_offset array */
  2    84     2 seg_info_offset (0 : seg_info_offset_count refer (probe_seg_info_array.count)) bit (18) aligned;
  2    85 
  2    86 dcl  seg_info_offset_count fixed bin;			/* one less than the number of info_offsets */
  2    87 
  2    88 dcl  probe_request_tables (probe_static_info.request_table_info.array_max_size) /* array of request table pointers */
  2    89      pointer aligned based (probe_static_info.request_table_info.array_ptr);
  2    90 
  2    91 dcl  probe_info_directories (probe_static_info.info_directory_info.array_max_size) /* array of info directories */
  2    92      char (168) unaligned based (probe_static_info.info_directory_info.array_ptr);
  2    93 
  2    94 dcl  probe_exclude_names (probe_static_info.exclude_name_info.array_max_size) /* array of exclude names */
  2    95      char (168) unaligned based (probe_static_info.exclude_name_info.array_ptr);
  2    96 
  2    97 /*	END INCLUDE FILE probe_static_info.incl.pl1	*/
      444 
      445 
      446   /* ;;;;;;; */
      447 
  3     1 /* BEGIN INCLUDE FILE ... probe_source_info.incl.pl1
  3     2*
  3     3*  James R. Davis 2 July 79 */
  3     4 
  3     5 dcl 1 source_info based aligned,
  3     6       2 stmnt_map_entry_index fixed bin,		/* index in stmnt map for this stmnt */
  3     7       2 instruction_ptr ptr,				/* to last instruction executed  */
  3     8       2 block_ptr ptr,				/* to runtime_block node */
  3     9       2 stack_ptr ptr,				/* to a stack frame */
  3    10       2 entry_ptr ptr,				/* to entry seq. for this proc */
  3    11       2 seg_info_ptr ptr;				/* to seg_info */
  3    12 
  3    13 dcl 1 current_source aligned like source_info based (probe_info.ptr_to_current_source);
  3    14 dcl 1 initial_source aligned like source_info based (probe_info.ptr_to_initial_source);
  3    15 
  3    16 /* END INCLUDE FILE ... probe_source_info.incl.pl1 */
      448 
      449 
      450   /* ;;;;;;; */
      451 
  4     1 /* BEGIN INCLUDE FILE ... probe_seg_info.incl.pl1
  4     2*
  4     3*   25 June 79 JRDavis
  4     4*
  4     5*   Modified  7 April 1983, TO - Add fields for character offset/line
  4     6*	correction per file.
  4     7**/
  4     8 
  4     9 dcl 1 seg_info based aligned,				/* place to remember information about object seg */
  4    10     2 language_type fixed bin,			/* language of source program */
  4    11     2 bits aligned,
  4    12       3 ignore_case bit (1) unal,
  4    13       3 bound_segment bit (1) unaligned,
  4    14       3 component bit (1) unaligned,
  4    15       3 pad bit (33) unal,
  4    16     2 names,					/* where to find it */
  4    17       3 directory_name character (168) unal,		/* what directory */
  4    18       3 entry_name character (32) unal,			/* what segment */
  4    19       3 segname character (32) unal,			/* procedure segname definition */
  4    20     2 identifier fixed bin (71),			/* time of object creation */
  4    21     2 pointers,					/* location of various parts of segment */
  4    22       3 symbol_header_ptr ptr unal,			/* to symbol section */
  4    23       3 original_source_ptr ptr unal,			/* to segment source map */
  4    24       3 statement_map_ptr ptr unal,			/* to segment statement map */
  4    25       3 break_info ptr unal,				/* for unbound segments, and start of chain for
  4    26*						   bound ones, -> break_map !obsolete, I think! */
  4    27       3 chain ptr unal,				/* to entry for next component if bound */
  4    28       3 linkage_ptr ptr unal,				/* to linkage section */
  4    29     2 bounds aligned,				/* structure of bounds information */
  4    30       3 text_bounds,
  4    31         4 start fixed bin (35),
  4    32         4 end fixed bin (35),
  4    33       3 symbol_bounds,
  4    34         4 start fixed bin (35),
  4    35         4 end fixed bin (35),
  4    36     2 map_size fixed bin,				/* size of statement map */
  4    37     2 error_code fixed bin (35),			/* errors encoutered while getting info, are recorded here */
  4    38     2 bound_create_time fixed bin (71),			/* time seg containing was bound or compiled. */
  4    39     2 bound_sym_header ptr unal,			/* to sym. section header for bound seg */
  4    40     2 pad (1) fixed bin (35),
  4    41 
  4    42     2 nfiles fixed bin,
  4    43     2 per_file (seg_info_nfiles refer (seg_info.nfiles)),
  4    44       3 file_pointers ptr unal,
  4    45       3 break_line (0:3) fixed bin (18) unsigned unaligned;
  4    46 
  4    47 dcl  seg_info_nfiles fixed bin;			/* for allocation purposes */
  4    48 
  4    49 
  4    50 /* END INCLUDE FILE ... probe_seg_info.incl.pl1 */
      452 
      453 
      454   /* ;;;;;;; */
      455 
  5     1 /* BEGIN INCLUDE FILE ... probe_level_frame.incl.pl1  */
  5     2 
  5     3 /* Modified 25 Aug 79 JRDavis */
  5     4 /* Added printed_(number decimal) for numbering support frames 12/10/81 S. Herbst */
  5     5 
  5     6 dcl 1 level_frame based (lfp) aligned,
  5     7       2 next ptr unal,
  5     8       2 prev ptr unal,
  5     9       2 number fixed bin,
  5    10       2 printed_number fixed bin,
  5    11       2 printed_decimal fixed bin,
  5    12       2 condition_frame_ptr ptr,
  5    13       2 flags unal,
  5    14         3 quick bit (1) unal,
  5    15         3 error_signalled bit (1) unal,
  5    16         3 support bit (1) unal,
  5    17         3 run_unit_manager bit (1) unal,
  5    18         3 pad bit (32) unal,
  5    19       2 source_info aligned like source_info,
  5    20       2 component_info aligned,
  5    21        3 component_name char (32),
  5    22        3 component_text_ptr ptr;
  5    23 
  5    24 dcl lfp ptr;
  5    25 
  5    26 /* END INCLUDE FILE ... probe_level_frame.incl.pl1 */
      456 
      457 
      458   /* ;;;;;;; */
      459 
  6     1 /* 	BEGIN INCLUDE FILE ... stack_frame.incl.pl1 ... */
  6     2 
  6     3 /* format: off */
  6     4 
  6     5 /* Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr and pl1_ps_ptr */
  6     6 /* Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager bit & main_proc bit */
  6     7 /* Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr */
  6     8 /* Modified: 03/01/84, S. Herbst - Added RETURN_PTR_MASK */
  6     9 
  6    10 
  6    11 /****^  HISTORY COMMENTS:
  6    12*  1) change(86-09-15,Kissel), approve(86-09-15,MCR7473),
  6    13*     audit(86-10-01,Fawcett), install(86-11-03,MR12.0-1206):
  6    14*     Modified to add constants for the translator_id field in the stack_frame
  6    15*     structure.
  6    16*                                                   END HISTORY COMMENTS */
  6    17 
  6    18 
  6    19 dcl RETURN_PTR_MASK bit (72) int static options (constant)  /* mask to be AND'd with stack_frame.return_ptr */
  6    20 	init ("777777777777777777000000"b3);		/* when copying, to ignore bits that a call fills */
  6    21 						/* with indicators (nonzero for Fortran hexfp caller) */
  6    22 			/* say: unspec(ptr) = unspec(stack_frame.return_ptr) & RETURN_PTR_MASK; */
  6    23 
  6    24 dcl TRANSLATOR_ID_PL1V2 bit (18) internal static options (constant) init ("000000"b3);
  6    25 dcl TRANSLATOR_ID_ALM bit (18) internal static options (constant) init ("000001"b3);
  6    26 dcl TRANSLATOR_ID_PL1V1 bit (18) internal static options (constant) init ("000002"b3);
  6    27 dcl TRANSLATOR_ID_SIGNAL_CALLER bit (18) internal static options (constant) init ("000003"b3);
  6    28 dcl TRANSLATOR_ID_SIGNALLER bit (18) internal static options (constant) init ("000004"b3);
  6    29 
  6    30 
  6    31 dcl  sp pointer;					/* pointer to beginning of stack frame */
  6    32 
  6    33 dcl  stack_frame_min_length fixed bin static init(48);
  6    34 
  6    35 
  6    36 dcl 1 stack_frame based(sp) aligned,
  6    37     2 pointer_registers(0 : 7) ptr,
  6    38     2 prev_sp pointer,
  6    39     2 next_sp pointer,
  6    40     2 return_ptr pointer,
  6    41     2 entry_ptr pointer,
  6    42     2 operator_and_lp_ptr ptr,			/* serves as both */
  6    43     2 arg_ptr pointer,
  6    44     2 static_ptr ptr unaligned,
  6    45     2 support_ptr ptr unal, /* only used by fortran I/O */
  6    46     2 on_unit_relp1 bit(18) unaligned,
  6    47     2 on_unit_relp2 bit(18) unaligned,
  6    48     2 translator_id bit(18) unaligned,			/* Translator ID (see constants above)
  6    49*						   0 => PL/I version II
  6    50*						   1 => ALM
  6    51*						   2 => PL/I version I   
  6    52*						   3 => signal caller frame
  6    53*						   4 => signaller frame */
  6    54     2 operator_return_offset bit(18) unaligned,
  6    55     2 x(0: 7) bit(18) unaligned,			/* index registers */
  6    56     2 a bit(36),					/* accumulator */
  6    57     2 q bit(36),					/* q-register */
  6    58     2 e bit(36),					/* exponent */
  6    59     2 timer bit(27) unaligned,				/* timer */
  6    60     2 pad bit(6) unaligned,
  6    61     2 ring_alarm_reg bit(3) unaligned;
  6    62 
  6    63 
  6    64 dcl 1 stack_frame_flags based(sp) aligned,
  6    65     2 pad(0 : 7) bit(72),				/* skip over prs */
  6    66     2 xx0 bit(22) unal,
  6    67     2 main_proc bit(1) unal,				/* on if frame belongs to a main procedure */
  6    68     2 run_unit_manager bit(1) unal,			/* on if frame belongs to run unit manager */
  6    69     2 signal bit(1) unal,				/* on if frame belongs to logical signal_ */
  6    70     2 crawl_out bit(1) unal,				/* on if this is a signal caller frame */
  6    71     2 signaller bit(1) unal,				/* on if next frame is signaller's */
  6    72     2 link_trap bit(1) unal,				/* on if this frame was made by the linker */
  6    73     2 support bit(1) unal,				/* on if frame belongs to a support proc */
  6    74     2 condition bit(1) unal,				/* on if condition established in this frame */
  6    75     2 xx0a bit(6) unal,
  6    76     2 xx1 fixed bin,
  6    77     2 xx2 fixed bin,
  6    78     2 xx3 bit(25) unal,
  6    79     2 old_crawl_out bit (1) unal,			/* on if this is a signal caller frame */
  6    80     2 old_signaller bit(1) unal,			/* on if next frame is signaller's */
  6    81     2 xx3a bit(9) unaligned,
  6    82     2 xx4(9) bit(72) aligned,
  6    83     2 v2_pl1_op_ret_base ptr,				/* When a V2 PL/I program calls an operator the
  6    84*						*  operator puts a pointer to the base of
  6    85*						*  the calling procedure here. (text base ptr)  */
  6    86     2 xx5 bit(72) aligned,
  6    87     2 pl1_ps_ptr ptr;				/* ptr to ps for this frame; also used by fio. */
  6    88 
  6    89 /* format: on */
  6    90 
  6    91 /* 	END INCLUDE FILE ... stack_frame.incl.pl1 */
      460 
      461 
      462   /* ;;;;;;; */
      463 
  7     1 /* 	BEGIN INCLUDE FILE ... stack_header.incl.pl1 .. 3/72 Bill Silver  */
  7     2 /*	modified 7/76 by M. Weaver for *system links and more system use of areas */
  7     3 /*	modified 3/77 by M. Weaver to add rnt_ptr */
  7     4 /*	Modified April 1983 by C. Hornig for tasking */
  7     5 
  7     6 /****^  HISTORY COMMENTS:
  7     7*  1) change(86-06-24,DGHowe), approve(86-06-24,MCR7396),
  7     8*     audit(86-08-05,Schroth), install(86-11-03,MR12.0-1206):
  7     9*     added the heap_header_ptr definition.
  7    10*  2) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  7    11*     audit(86-10-10,Fawcett), install(86-11-03,MR12.0-1206):
  7    12*     Modified to support control point management.  These changes were actually
  7    13*     made in February 1985 by G. Palter.
  7    14*  3) change(86-10-22,Fawcett), approve(86-10-22,MCR7473),
  7    15*     audit(86-10-22,Farley), install(86-11-03,MR12.0-1206):
  7    16*     Remove the old_lot pointer and replace it with cpm_data_ptr. Use the 18
  7    17*     bit pad after cur_lot_size for the cpm_enabled. This was done to save some
  7    18*     space int the stack header and change the cpd_ptr unal to cpm_data_ptr
  7    19*     (ITS pair).
  7    20*                                                   END HISTORY COMMENTS */
  7    21 
  7    22 /* format: style2 */
  7    23 
  7    24      dcl	   sb		      ptr;		/* the  main pointer to the stack header */
  7    25 
  7    26      dcl	   1 stack_header	      based (sb) aligned,
  7    27 	     2 pad1	      (4) fixed bin,	/*  (0) also used as arg list by outward_call_handler  */
  7    28 	     2 cpm_data_ptr	      ptr,		/*  (4)  pointer to control point which owns this stack */
  7    29 	     2 combined_stat_ptr  ptr,		/*  (6)  pointer to area containing separate static */
  7    30 	     2 clr_ptr	      ptr,		/*  (8)  pointer to area containing linkage sections */
  7    31 	     2 max_lot_size	      fixed bin (17) unal,	/*  (10) DU  number of words allowed in lot */
  7    32 	     2 main_proc_invoked  fixed bin (11) unal,	/*  (10) DL  nonzero if main procedure invoked in run unit */
  7    33 	     2 have_static_vlas   bit (1) unal,		/*  (10) DL  "1"b if (very) large arrays are being used in static */
  7    34 	     2 pad4	      bit (2) unal,
  7    35 	     2 run_unit_depth     fixed bin (2) unal,	/*  (10) DL  number of active run units stacked */
  7    36 	     2 cur_lot_size	      fixed bin (17) unal,	/*  (11) DU  number of words (entries) in lot */
  7    37 	     2 cpm_enabled	      bit (18) unal,	/*  (11) DL  non-zero if control point management is enabled */
  7    38 	     2 system_free_ptr    ptr,		/*  (12)  pointer to system storage area */
  7    39 	     2 user_free_ptr      ptr,		/*  (14)  pointer to user storage area */
  7    40 	     2 null_ptr	      ptr,		/*  (16)  */
  7    41 	     2 stack_begin_ptr    ptr,		/*  (18)  pointer to first stack frame on the stack */
  7    42 	     2 stack_end_ptr      ptr,		/*  (20)  pointer to next useable stack frame */
  7    43 	     2 lot_ptr	      ptr,		/*  (22)  pointer to the lot for the current ring */
  7    44 	     2 signal_ptr	      ptr,		/*  (24)  pointer to signal procedure for current ring */
  7    45 	     2 bar_mode_sp	      ptr,		/*  (26)  value of sp before entering bar mode */
  7    46 	     2 pl1_operators_ptr  ptr,		/*  (28)  pointer to pl1_operators_$operator_table */
  7    47 	     2 call_op_ptr	      ptr,		/*  (30)  pointer to standard call operator */
  7    48 	     2 push_op_ptr	      ptr,		/*  (32)  pointer to standard push operator */
  7    49 	     2 return_op_ptr      ptr,		/*  (34)  pointer to standard return operator */
  7    50 	     2 return_no_pop_op_ptr
  7    51 			      ptr,		/*  (36)  pointer to standard return / no pop operator */
  7    52 	     2 entry_op_ptr	      ptr,		/*  (38)  pointer to standard entry operator */
  7    53 	     2 trans_op_tv_ptr    ptr,		/*  (40)  pointer to translator operator ptrs */
  7    54 	     2 isot_ptr	      ptr,		/*  (42)  pointer to ISOT */
  7    55 	     2 sct_ptr	      ptr,		/*  (44)  pointer to System Condition Table */
  7    56 	     2 unwinder_ptr	      ptr,		/*  (46)  pointer to unwinder for current ring */
  7    57 	     2 sys_link_info_ptr  ptr,		/*  (48)  pointer to *system link name table */
  7    58 	     2 rnt_ptr	      ptr,		/*  (50)  pointer to Reference Name Table */
  7    59 	     2 ect_ptr	      ptr,		/*  (52)  pointer to event channel table */
  7    60 	     2 assign_linkage_ptr ptr,		/*  (54)  pointer to storage for (obsolete) hcs_$assign_linkage */
  7    61 	     2 heap_header_ptr     ptr,		/*  (56)  pointer to the heap header for this ring */
  7    62 	     2 trace,
  7    63 	       3 frames,
  7    64 	         4 count	      fixed bin,		/*  (58)  number of trace frames */
  7    65 	         4 top_ptr	      ptr unal,		/*  (59)  pointer to last trace frame */
  7    66 	       3 in_trace	      bit (36) aligned,	/*  (60)  trace antirecursion flag */
  7    67 	     2 pad2	      bit (36),		/*  (61) */
  7    68                2 pad5	      pointer;		/*  (62)  pointer to future stuff */
  7    69 
  7    70 /*	The following offset refers to a table within the  pl1  operator table.  */
  7    71 
  7    72      dcl	   tv_offset	      fixed bin init (361) internal static;
  7    73 						/* (551) octal */
  7    74 
  7    75 
  7    76 /*	The following constants are offsets within this transfer vector table.  */
  7    77 
  7    78      dcl	   (
  7    79 	   call_offset	      fixed bin init (271),
  7    80 	   push_offset	      fixed bin init (272),
  7    81 	   return_offset	      fixed bin init (273),
  7    82 	   return_no_pop_offset   fixed bin init (274),
  7    83 	   entry_offset	      fixed bin init (275)
  7    84 	   )		      internal static;
  7    85 
  7    86 
  7    87 
  7    88 
  7    89 
  7    90 /*	The following declaration  is an overlay of the whole stack header.   Procedures which
  7    91*	move the whole stack header should use this overlay.
  7    92**/
  7    93 
  7    94      dcl	   stack_header_overlay   (size (stack_header)) fixed bin based (sb);
  7    95 
  7    96 
  7    97 
  7    98 /* 	END INCLUDE FILE ... stack_header.incl.pl1 */
      464 
      465 
      466   /* ;;;;;;; */
      467 
  8     1 /* BEGIN INCLUDE FILE --  lot.incl.pl1   S.Webber 9/74, Modified by R. Bratt 04/76, modified by M. Weaver 7/76 */
  8     2 /* modified by M. Weaver 3/77 */
  8     3 
  8     4 dcl  lotp ptr;
  8     5 
  8     6 dcl 1 lot based (lotp) aligned,
  8     7     2 lp (0:9999) ptr unaligned;			/* array of packed pointers to linkage sections */
  8     8 
  8     9 dcl lot_fault bit (36) aligned static options (constant) init ("111000000000000000000000000000000000"b);
  8    10 						/* lot fault has fault code = 0 and offset = 0 */
  8    11 
  8    12 dcl  isotp ptr;
  8    13 dcl 1 isot based (isotp) aligned,
  8    14     2 isp (0:9999) ptr unaligned;
  8    15 
  8    16 dcl 1 isot1 (0 :9999) aligned based,
  8    17     2 flags unaligned,
  8    18       3 fault bit (2) unaligned,
  8    19       3 system bit (1) unaligned,
  8    20       3 mbz bit (6) unaligned,
  8    21     2 fault_code fixed bin (8) unaligned,
  8    22     2 static_offset bit (18) unaligned;
  8    23 
  8    24 
  8    25 /* END INCLUDE FILE  lot.incl.pl1 */
      468 
      469 
      470   /* ;;;;;;; */
      471 
  9     1 dcl	1 frame		aligned based,
  9     2 	2 pointers(0:7)	ptr,
  9     3 	2 back		ptr,
  9     4 	2 next		ptr,
  9     5 	2 return		ptr,
  9     6 	2 entry		ptr,
  9     7 	2 operator	ptr,
  9     8 	2 argptr		ptr,
  9     9 	2 skip1(2)	fixed bin,
  9    10 	2 on_unit_info(2)	bit(18) unaligned,
  9    11 	2 translator_id	bit(18) unaligned,
  9    12 	2 operator_return	bit(18) unaligned,
  9    13 	2 display		ptr,
  9    14 	2 skip2(2)	fixed bin,
  9    15 	2 linkage		ptr;
      472 
      473 
      474   /* ;;;;;;; */
      475 
 10     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
 10     2 
 10     3 /* Structure for find_condition_info_.
 10     4*
 10     5*   Written 1-Mar-79 by M. N. Davidoff.
 10     6**/
 10     7 
 10     8 /* automatic */
 10     9 
 10    10      declare condition_info_ptr     pointer;
 10    11 
 10    12 /* based */
 10    13 
 10    14      declare 1 condition_info	      aligned based (condition_info_ptr),
 10    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
 10    16 	     2 version	      fixed binary,		/* Must be 1 */
 10    17 	     2 condition_name     char (32) varying,	/* name of condition */
 10    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
 10    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
 10    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
 10    21 	     2 flags	      unaligned,
 10    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
 10    23 	       3 pad1	      bit (35),
 10    24 	     2 pad2	      bit (36),
 10    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
 10    26 	     2 pad3	      (4) bit (36);
 10    27 
 10    28 /* internal static */
 10    29 
 10    30      declare condition_info_version_1
 10    31 			      fixed binary internal static options (constant) initial (1);
 10    32 
 10    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
      476 
      477 
      478   /* ;;;;;;; */
      479 
 11     1 /*	BEGIN INCLUDE FILE ... runtime_symbol.incl.pl1 ... Modified 07/79 */
 11     2 
 11     3 dcl	1 runtime_symbol	aligned based,
 11     4 	2 flag		unal bit(1),	/* always "1"b for Version II */
 11     5 	2 use_digit	unal bit(1),	/* if "1"b and units are half words units are really digits */
 11     6 	2 array_units	unal bit(2),
 11     7 	2 units		unal bit(2),	/* addressing units */
 11     8 	2 type		unal bit(6),	/* data type */
 11     9 	2 level		unal bit(6),	/* structure level */
 11    10 	2 ndims		unal bit(6),	/* number of dimensions */
 11    11 	2 bits		unal,
 11    12 	  3 aligned	bit(1),
 11    13 	  3 packed	bit(1),
 11    14 	  3 simple	bit(1),
 11    15 	2 skip		unal bit(1),
 11    16 	2 scale		unal bit(8),	/* arithmetic scale factor */
 11    17 	2 name		unal bit(18),	/* rel ptr to acc name */
 11    18 	2 brother		unal bit(18),	/* rel ptr to brother entry */
 11    19 	2 father		unal bit(18),	/* rel ptr to father entry */
 11    20 	2 son		unal bit(18),	/* rel ptr to son entry */
 11    21 	2 address		unal,
 11    22 	  3 location	bit(18),		/* location in storage class */
 11    23 	  3 class		bit(4),		/* storage class */
 11    24 	  3 next		bit(14),		/* rel ptr to next of same class */
 11    25 	2 size		fixed bin(35),	/* encoded string|arith size */
 11    26 	2 offset		fixed bin(35),	/* encoded offset from address */
 11    27 	2 virtual_org	fixed bin(35),
 11    28 	2 bounds(1),
 11    29 	  3 lower		fixed bin(35),	/* encoded lower bound */
 11    30 	  3 upper		fixed bin(35),	/* encoded upper bound */
 11    31 	  3 multiplier	fixed bin(35);	/* encoded multiplier */
 11    32 
 11    33 dcl	1 runtime_bound	based,
 11    34 	2 lower		fixed bin(35),
 11    35 	2 upper		fixed bin(35),
 11    36 	2 multiplier	fixed bin(35);
 11    37 
 11    38 dcl	1 runtime_block	aligned based,
 11    39 	2 flag		unal bit(1),	/* always "1"b for Version II */
 11    40 	2 quick		unal bit(1),	/* "1"b if quick block */
 11    41 	2 fortran		unal bit(1),	/* "1"b if fortran program */
 11    42 	2 standard	unal bit(1),	/* "1"b if program has std obj segment */
 11    43 	2 owner_flag	unal bit(1),	/* "1"b if block has valid owner field */
 11    44 	2 skip		unal bit(1),
 11    45 	2 type		unal bit(6),	/* = 0 for a block node */
 11    46 	2 number		unal bit(6),	/* begin block number */
 11    47 	2 start		unal bit(18),	/* rel ptr to start of symbols */
 11    48 	2 name		unal bit(18),	/* rel ptr to name of proc */
 11    49 	2 brother		unal bit(18),	/* rel ptr to brother block */
 11    50 	2 father		unal bit(18),	/* rel ptr to father block */
 11    51 	2 son		unal bit(18),	/* rel ptr to son block */
 11    52 	2 map		unal,
 11    53 	  3 first		bit(18),		/* rel ptr to first word of map */
 11    54 	  3 last		bit(18),		/* rel ptr to last word of map */
 11    55 	2 entry_info	unal bit(18),	/* info about entry of quick block */
 11    56 	2 header		unal bit(18),	/* rel ptr to symbol header */
 11    57 	2 chain(4)	unal bit(18),	/* chain(i) is rel ptr to first symbol
 11    58*					   on start list with length >= 2**i */
 11    59 	2 token(0:5)	unal bit(18),	/* token(i) is rel ptr to first token
 11    60*					   on list with length >= 2 ** i */
 11    61 	2 owner		unal bit(18);	/* rel ptr to owner block */
 11    62 
 11    63 dcl	1 runtime_token	aligned based,
 11    64 	2 next		unal bit(18),	/* rel ptr to next token */
 11    65 	2 dcl		unal bit(18),	/* rel ptr to first dcl of this token */
 11    66 	2 name,				/* ACC */
 11    67 	  3 size		unal unsigned fixed bin (9), /* number of chars in token */
 11    68 	  3 string	unal char(n refer(runtime_token.size));
 11    69 
 11    70 dcl	1 encoded_value	aligned based,
 11    71 	2 flag		bit (2) unal,
 11    72 	2 code		bit (4) unal,
 11    73 	2 n1		bit (6) unal,
 11    74 	2 n2		bit (6) unal,
 11    75 	2 n3		bit (18) unal;
 11    76 
 11    77 /*	END INCLUDE FILE ... runtime_symbol.incl.pl1 */
      480 
      481 
      482   /* ;;;;;;; */
      483 
 12     1 dcl	1 std_symbol_header	based aligned,
 12     2 	2 dcl_version	fixed bin,
 12     3 	2 identifier	char(8),
 12     4 	2 gen_number	fixed bin,
 12     5 	2 gen_created	fixed bin(71),
 12     6 	2 object_created	fixed bin(71),
 12     7 	2 generator	char(8),
 12     8 	2 gen_version	unaligned,
 12     9 	  3 offset	bit(18),
 12    10 	  3 size		bit(18),
 12    11 	2 userid		unaligned,
 12    12 	  3 offset	bit(18),
 12    13 	  3 size		bit(18),
 12    14 	2 comment		unaligned,
 12    15 	  3 offset	bit(18),
 12    16 	  3 size		bit(18),
 12    17 	2 text_boundary	bit(18) unaligned,
 12    18 	2 stat_boundary	bit(18) unaligned,
 12    19 	2 source_map	bit(18) unaligned,
 12    20 	2 area_pointer	bit(18) unaligned,
 12    21 	2 backpointer	bit(18) unaligned,
 12    22 	2 block_size	bit(18) unaligned,
 12    23 	2 next_block	bit(18) unaligned,
 12    24 	2 rel_text	bit(18) unaligned,
 12    25 	2 rel_def		bit(18) unaligned,
 12    26 	2 rel_link	bit(18) unaligned,
 12    27 	2 rel_symbol	bit(18) unaligned,
 12    28 	2 mini_truncate	bit(18) unaligned,
 12    29 	2 maxi_truncate	bit(18) unaligned;
      484 
      485 
      486   /* ;;;;;;; */
      487 
 13     1 dcl	1 pl1_symbol_block	aligned based,
 13     2 	2 version		fixed bin,
 13     3 	2 identifier	char(8),		/* must be "pl1info" */
 13     4 	2 flags,
 13     5 	  3 profile	bit(1) unal,
 13     6 	  3 table		bit(1) unal,
 13     7 	  3 map		bit(1) unal,
 13     8 	  3 flow		bit(1) unal,
 13     9 	  3 io		bit(1) unal,
 13    10 	  3 table_removed	bit(1) unal,
 13    11 	  3 long_profile	bit(1) unal,
 13    12 	  3 pad		bit(29) unal,
 13    13 	2 greatest_severity	fixed bin,
 13    14 	2 root		unal bit(18),
 13    15 	2 profile		unal bit(18),
 13    16 	2 map		unal,
 13    17 	  3 first		bit(18),
 13    18 	  3 last		bit(18),
 13    19 	2 segname		unaligned,
 13    20 	  3 offset	bit(18),
 13    21 	  3 size		bit(18);
      488 
      489 
      490   /* ;;;;;;; */
      491 
 14     1 /* BEGIN INCLUDE FILE  ... probe_lang_types.incl.pl1
 14     2*
 14     3*   JRD 26 June 79
 14     4*   MBW 31 July 1981 to add algol68 */
 14     5 
 14     6 
 14     7 /****^  HISTORY COMMENTS:
 14     8*  1) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
 14     9*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
 14    10*     Added C Language type.
 14    11*                                                   END HISTORY COMMENTS */
 14    12 
 14    13 
 14    14 /*   Modified June 83 JMAthane to add PASCAL language type */
 14    15 /*   Modified April 88 Hinatsu to add C language type */
 14    16 
 14    17      dcl	   (UNKNOWN_lang_type     init (1),
 14    18 	   OTHER_lang_type	      init (2),
 14    19 	   PL1_lang_type	      init (3),
 14    20 	   FORTRAN_lang_type      init (4),
 14    21 	   COBOL_lang_type	      init (5),
 14    22 	   ALM_lang_type	      init (6),
 14    23 	   ALGOL68_lang_type      init (7),
 14    24 	   PASCAL_lang_type	      init (8),
 14    25 	   C_lang_type	      init (9)) fixed bin internal static options (constant);
 14    26 
 14    27      dcl	   official_language_names (9) char (32) internal static options (constant) init
 14    28 			      ("Unknown", "other", "PL/I", "FORTRAN", "COBOL", "ALM", "Algol 68", "Pascal", "C");
 14    29 
 14    30      dcl	   palatable_language_names (9) char (32) internal static options (constant) init
 14    31 			      ("Unknown", "Other", "pl1", "fortran", "cobol", "alm", "algol68", "pascal", "c");
 14    32 
 14    33 /* END INCLUDE FILE ... probe_lang_types.incl.pl1 */
      492 
      493 
      494   /* ;;;;;;; */
      495 
 15     1 dcl	1 statement_map	aligned based,
 15     2 	2 location	bit(18) unaligned,
 15     3 	2 source_id	unaligned,
 15     4 	  3 file		bit(8),
 15     5 	  3 line		bit(14),
 15     6 	  3 statement	bit(5),
 15     7 	2 source_info	unaligned,
 15     8 	  3 start		bit(18),
 15     9 	  3 length	bit(9);
      496 
      497 
      498   end;				/* probe_stack_trace_ external procedure */
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/27/88  1225.2  probe_stack_trace_.pl1            >spec>install>MR12.2-1194>probe_stack_trace_.pl1
440          1    10/27/88  1223.7  probe_info.incl.pl1               >spec>install>MR12.2-1194>probe_info.incl.pl1
444          2    11/12/82  1624.3  probe_static_info.incl.pl1        >ldd>include>probe_static_info.incl.pl1
448          3    11/26/79  1320.6  probe_source_info.incl.pl1        >ldd>include>probe_source_info.incl.pl1
452          4    11/02/83  1845.0  probe_seg_info.incl.pl1           >ldd>include>probe_seg_info.incl.pl1
456          5    05/17/82  1411.1  probe_level_frame.incl.pl1        >ldd>include>probe_level_frame.incl.pl1
460          6    11/07/86  1550.3  stack_frame.incl.pl1              >ldd>include>stack_frame.incl.pl1
464          7    11/07/86  1550.3  stack_header.incl.pl1             >ldd>include>stack_header.incl.pl1
468          8    08/05/77  1022.4  lot.incl.pl1                      >ldd>include>lot.incl.pl1
472          9    05/06/74  1752.6  stu_frame.incl.pl1                >ldd>include>stu_frame.incl.pl1
476         10    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
480         11    11/26/79  1320.6  runtime_symbol.incl.pl1           >ldd>include>runtime_symbol.incl.pl1
484         12    05/06/74  1751.6  std_symbol_header.incl.pl1        >ldd>include>std_symbol_header.incl.pl1
488         13    03/10/77  1345.4  pl1_symbol_block.incl.pl1         >ldd>include>pl1_symbol_block.incl.pl1
492         14    10/26/88  1255.5  probe_lang_types.incl.pl1         >ldd>include>probe_lang_types.incl.pl1
496         15    05/06/74  1751.6  statement_map.incl.pl1            >ldd>include>statement_map.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
P_block_name                           parameter       char                     packed unaligned dcl 60 set ref 389 402* 417*
P_cond_name                            parameter       char(32)                 packed unaligned dcl 60 set ref 198 211* 217* 221*
                                                                                  224 261* 271*
P_entry_ptr                            parameter       pointer                  dcl 60 ref 106 118
P_invoc_count                          parameter       fixed bin(17,0)          dcl 60 ref 106 123
P_invocation                           parameter       fixed bin(17,0)          dcl 60 ref 150 180
P_level_decimal                        parameter       fixed bin(17,0)          dcl 60 ref 295 311
P_level_number                         parameter       fixed bin(17,0)          dcl 60 set ref 295 302 389 401* 419*
P_probe_info_ptr                       parameter       pointer                  dcl 60 ref 106 150 198 224 280 295 326 355 389 428
P_sourcep                              parameter       pointer                  dcl 60 ref 106 110 150 155 198 203 224 229 295 300
                                                                                  320 326 331 355 363 389 394
P_stack_frame_ptr                      parameter       pointer                  dcl 60 ref 326 336
addr                                                   builtin function         dcl 100 ref 215 215 268 268 402 402 417 417
back                     20            based           pointer                  level 2 dcl 9-1 set ref 430*
block_ptr                16            based           pointer                  level 3 in structure "level_frame" dcl 5-6
                                                                                  in procedure "probe_stack_trace_" set ref 166 175
                                                                                  372 399
block_ptr                 4            based           pointer                  level 2 in structure "found_source_info" dcl 77
                                                                                  in procedure "probe_stack_trace_" set ref 130* 160
                                                                                  166 175 262* 347* 365 372 399
code                            000112 automatic       fixed bin(35,0)          dcl 88 set ref 268*
cond_info                       000114 automatic       structure                level 1 dcl 90 set ref 215 215 268 268
condition_frame_ptr       6            based           pointer                  level 2 dcl 5-6 ref 209 215 239 268
condition_info                         based           structure                level 1 dcl 10-14
condition_name            3     000114 automatic       varying char(32)         level 2 dcl 90 set ref 217 271
continue_tracing                000111 automatic       bit(1)                   dcl 87 set ref 116* 117 123* 163* 164 180* 237* 238
                                                                                  249* 305* 306 311* 334* 335 341* 369* 371 377*
                                                                                  396* 398 408*
count                           000102 automatic       fixed bin(17,0)          dcl 83 set ref 112* 120* 120 123 157* 165 170* 176*
                                                                                  176 180
current_stack_frame      17            based           pointer                  level 3 packed packed unaligned dcl 1-18 ref 430
entry_ptr                22            based           pointer                  level 3 in structure "level_frame" dcl 5-6
                                                                                  in procedure "probe_stack_trace_" set ref 118
entry_ptr                10            based           pointer                  level 2 in structure "found_source_info" dcl 77
                                                                                  in procedure "probe_stack_trace_" set ref 130*
                                                                                  262* 347*
error_frame                     000156 automatic       pointer                  dcl 233 set ref 235* 239 239* 256
error_signalled          10(01)        based           bit(1)                   level 3 packed packed unaligned dcl 5-6 ref 239
find_condition_info_            000010 constant        entry                    external dcl 92 ref 215 268
flags                    10            based           structure                level 2 in structure "level_frame" packed packed
                                                                                  unaligned dcl 5-6 in procedure
                                                                                  "probe_stack_trace_"
flags                    52            based           structure                level 3 in structure "probe_static_info" dcl 2-8
                                                                                  in procedure "probe_stack_trace_"
found_source_info                      based           structure                level 1 dcl 77 set ref 141* 193* 272* 338* 373* 417
                                                                                  417
frame                                  based           structure                level 1 dcl 9-1
i                               000110 automatic       fixed bin(17,0)          dcl 86 set ref 302* 311
instruction_ptr           2            based           pointer                  level 2 dcl 77 set ref 130* 189* 262* 347*
last_invocation                 000104 automatic       pointer                  dcl 84 set ref 113* 119* 129 140 158* 171* 177* 188
                                                                                  193
level_chain              50            based           pointer                  level 3 packed packed unaligned dcl 2-8 ref 115 162
                                                                                  205 236 288 304 333 370 397
level_frame                            based           structure                level 1 dcl 5-6
level_source_ptr                000100 automatic       pointer                  dcl 79 set ref 110* 130 130 130 130 134 141 155* 160
                                                                                  160 166 166 175 189 189 193 203* 207 229* 262 262
                                                                                  262 262 272 300* 331* 338 347 347 347 347 363* 365
                                                                                  372 373 383 394* 399 399 417 417
lfp                             000150 automatic       pointer                  dcl 5-24 set ref 115* 118 119 123 126* 126 140* 141
                                                                                  162* 166 166 171 175 177 180 184* 184 205* 205*
                                                                                  207 209 215* 220 236* 239 239 239 247 249 253* 253
                                                                                  288* 289 304* 306 309 311 311 315* 315 318 318*
                                                                                  320 333* 336 338 341 344* 344 370* 372 373 377
                                                                                  380* 380 397* 399 399 401 402 402 408 411* 411
max                                                    builtin function         dcl 100 ref 302
max_level                51            based           fixed bin(17,0)          level 3 dcl 2-8 ref 123 180 205 249 341 377 408
next                                   based           pointer                  level 2 packed packed unaligned dcl 5-6 ref 126 184
                                                                                  220 253 315 344 380 411
null                                                   builtin function         dcl 100 ref 113 129 130 158 160 160 188 189 209 235
                                                                                  239 239 249 256 260 262 306 318 347 365 383
number                    2            based           fixed bin(17,0)          level 2 dcl 5-6 ref 123 180 205 249 341 377 408
other_frame                     000154 automatic       pointer                  dcl 232 set ref 235* 247* 249 256 256* 260 268 272
printed_decimal           4            based           fixed bin(17,0)          level 2 dcl 5-6 ref 311
printed_number            3            based           fixed bin(17,0)          level 2 dcl 5-6 ref 289 311 401
probe_block_name_               000014 constant        entry                    external dcl 96 ref 402 417
probe_error_$malfunction        000012 constant        entry                    external dcl 94 ref 28 365
probe_info                             based           structure                level 1 dcl 1-18
probe_info_ptr                  000146 automatic       pointer                  dcl 1-86 set ref 115 123 162 180 205 205 236 249 288
                                                                                  304 333 341 365* 370 377 397 402* 408 417* 428*
                                                                                  430* 430 430
probe_static_info                      based           structure                level 1 dcl 2-8
probe_trace_a_stack_            000016 constant        entry                    external dcl 98 ref 430
random_info              17            based           structure                level 2 dcl 1-18
saved_lfp                       000106 automatic       pointer                  dcl 85 set ref 309* 318
source_info                            based           structure                level 1 dcl 3-5 in procedure "probe_stack_trace_"
                                                                                  set ref 320*
source_info              12            based           structure                level 2 in structure "level_frame" dcl 5-6
                                                                                  in procedure "probe_stack_trace_" set ref 141 193
                                                                                  272 320 338 373 402 402
stack_info               50            based           structure                level 2 dcl 2-8
stack_ptr                 6            based           pointer                  level 2 in structure "found_source_info" dcl 77
                                                                                  in procedure "probe_stack_trace_" set ref 130* 160
                                                                                  166 189* 207 262* 347* 383* 399
stack_ptr                20            based           pointer                  level 3 in structure "level_frame" dcl 5-6
                                                                                  in procedure "probe_stack_trace_" set ref 166 207
                                                                                  336 399
static_info_ptr           1            based           pointer                  level 2 packed packed unaligned dcl 1-18 ref 115 123
                                                                                  162 180 205 205 236 249 288 304 333 341 370 377
                                                                                  397 408 430
stmnt_map_entry_index                  based           fixed bin(17,0)          level 2 dcl 77 set ref 134*
traced_with_all          52(01)        based           bit(1)                   level 4 packed packed unaligned dcl 2-8 ref 430

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALGOL68_lang_type                      internal static fixed bin(17,0)          initial dcl 14-17
ALM_lang_type                          internal static fixed bin(17,0)          initial dcl 14-17
COBOL_lang_type                        internal static fixed bin(17,0)          initial dcl 14-17
C_lang_type                            internal static fixed bin(17,0)          initial dcl 14-17
FORTRAN_lang_type                      internal static fixed bin(17,0)          initial dcl 14-17
OTHER_lang_type                        internal static fixed bin(17,0)          initial dcl 14-17
PASCAL_lang_type                       internal static fixed bin(17,0)          initial dcl 14-17
PL1_lang_type                          internal static fixed bin(17,0)          initial dcl 14-17
RETURN_PTR_MASK                        internal static bit(72)                  initial packed unaligned dcl 6-19
TRANSLATOR_ID_ALM                      internal static bit(18)                  initial packed unaligned dcl 6-25
TRANSLATOR_ID_PL1V1                    internal static bit(18)                  initial packed unaligned dcl 6-26
TRANSLATOR_ID_PL1V2                    internal static bit(18)                  initial packed unaligned dcl 6-24
TRANSLATOR_ID_SIGNALLER                internal static bit(18)                  initial packed unaligned dcl 6-28
TRANSLATOR_ID_SIGNAL_CALLER            internal static bit(18)                  initial packed unaligned dcl 6-27
UNKNOWN_lang_type                      internal static fixed bin(17,0)          initial dcl 14-17
call_offset                            internal static fixed bin(17,0)          initial dcl 7-78
condition_info_ptr                     automatic       pointer                  dcl 10-10
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 10-30
current_source                         based           structure                level 1 dcl 3-13
encoded_value                          based           structure                level 1 dcl 11-70
entry_offset                           internal static fixed bin(17,0)          initial dcl 7-78
expression_area                        based           area(1024)               dcl 1-95
initial_source                         based           structure                level 1 dcl 3-14
isot                                   based           structure                level 1 dcl 8-13
isot1                                  based           structure                array level 1 dcl 8-16
isotp                                  automatic       pointer                  dcl 8-12
lot                                    based           structure                level 1 dcl 8-6
lot_fault                              internal static bit(36)                  initial dcl 8-9
lotp                                   automatic       pointer                  dcl 8-4
official_language_names                internal static char(32)                 initial array packed unaligned dcl 14-27
palatable_language_names               internal static char(32)                 initial array packed unaligned dcl 14-30
pl1_symbol_block                       based           structure                level 1 dcl 13-1
probe_area                             based           area(1024)               dcl 1-93
probe_exclude_names                    based           char(168)                array packed unaligned dcl 2-94
probe_info_directories                 based           char(168)                array packed unaligned dcl 2-91
probe_info_version                     internal static fixed bin(17,0)          initial dcl 1-88
probe_info_version_1                   internal static fixed bin(17,0)          initial dcl 1-90
probe_request_tables                   based           pointer                  array dcl 2-88
probe_seg_info_array                   based           structure                level 1 dcl 2-82
push_offset                            internal static fixed bin(17,0)          initial dcl 7-78
return_no_pop_offset                   internal static fixed bin(17,0)          initial dcl 7-78
return_offset                          internal static fixed bin(17,0)          initial dcl 7-78
runtime_block                          based           structure                level 1 dcl 11-38
runtime_bound                          based           structure                level 1 unaligned dcl 11-33
runtime_symbol                         based           structure                level 1 dcl 11-3
runtime_token                          based           structure                level 1 dcl 11-63
sb                                     automatic       pointer                  dcl 7-24
scratch_area                           based           area(1024)               dcl 1-92
seg_info                               based           structure                level 1 dcl 4-9
seg_info_nfiles                        automatic       fixed bin(17,0)          dcl 4-47
seg_info_offset_count                  automatic       fixed bin(17,0)          dcl 2-86
sp                                     automatic       pointer                  dcl 6-31
stack_frame                            based           structure                level 1 dcl 6-36
stack_frame_flags                      based           structure                level 1 dcl 6-64
stack_frame_min_length                 internal static fixed bin(17,0)          initial dcl 6-33
stack_header                           based           structure                level 1 dcl 7-26
stack_header_overlay                   based           fixed bin(17,0)          array dcl 7-94
statement_map                          based           structure                level 1 dcl 15-1
std_symbol_header                      based           structure                level 1 dcl 12-1
tv_offset                              internal static fixed bin(17,0)          initial dcl 7-72
work_area                              based           area(1024)               dcl 1-94

NAMES DECLARED BY EXPLICIT CONTEXT.
MAIN_RETURN                     000047 constant        label                    dcl 103 ref 137 143 190 195 212 218 222 276 322 339
                                                                                  351 374 384 405 421
probe_stack_trace_              000034 constant        entry                    external dcl 25
probe_stack_trace_$condition_raised
                                000317 constant        entry                    external dcl 198
probe_stack_trace_$current_level
                                000601 constant        entry                    external dcl 280
probe_stack_trace_$find_block_frame
                                001014 constant        entry                    external dcl 355
probe_stack_trace_$find_condition_frame
                                000427 constant        entry                    external dcl 224
probe_stack_trace_$find_frame   000730 constant        entry                    external dcl 326
probe_stack_trace_$find_previous_invocation
                                000170 constant        entry                    external dcl 150
probe_stack_trace_$find_proc_frame
                                000063 constant        entry                    external dcl 106
probe_stack_trace_$get_level    000633 constant        entry                    external dcl 295
probe_stack_trace_$where_source_info
                                001127 constant        entry                    external dcl 389
setup                           001275 constant        entry                    internal dcl 424 ref 111 154 202 227 286 299 330 362
                                                                                  393

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1702        1722    1324        1712
Length      2444    1324        20         506     355           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
probe_stack_trace_                  246 external procedure  is an external procedure.  
begin block on line 231                 begin block         shares stack frame of external procedure probe_stack_trace_.  
setup                                   internal procedure  shares stack frame of external procedure probe_stack_trace_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
probe_stack_trace_       000100 level_source_ptr            probe_stack_trace_
                         000102 count                       probe_stack_trace_
                         000104 last_invocation             probe_stack_trace_
                         000106 saved_lfp                   probe_stack_trace_
                         000110 i                           probe_stack_trace_
                         000111 continue_tracing            probe_stack_trace_
                         000112 code                        probe_stack_trace_
                         000114 cond_info                   probe_stack_trace_
                         000146 probe_info_ptr              probe_stack_trace_
                         000150 lfp                         probe_stack_trace_
                         000154 other_frame                 begin block on line 231
                         000156 error_frame                 begin block on line 231

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          signal_op           ext_entry           ext_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
find_condition_info_          probe_block_name_             probe_error_$malfunction      probe_trace_a_stack_

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     25 000033        28 000043       103 000047       106 000056       110 000072       111 000076       112 000077
    113 000100       115 000102       116 000106       117 000110       118 000112       119 000120       120 000121
    123 000122       126 000134       127 000136       129 000137       130 000143       134 000151       137 000153
    140 000154       141 000156       143 000163       150 000164       154 000177       155 000200       157 000204
    158 000205       160 000207       162 000216       163 000222       164 000224       165 000226       166 000230
    170 000242       171 000244       173 000245       175 000246       176 000254       177 000255       180 000256
    184 000271       185 000273       188 000274       189 000300       190 000304       193 000305       195 000312
    198 000313       202 000326       203 000327       205 000333       207 000346       209 000353       211 000357
    212 000364       215 000365       217 000405       218 000413       220 000414       221 000417       222 000424
    224 000425       227 000436       229 000437       235 000443       236 000446       237 000452       238 000454
    239 000456       246 000473       247 000474       249 000475       253 000510       254 000512       256 000513
    260 000521       261 000525       262 000532       266 000540       268 000541       271 000561       272 000567
    276 000574       280 000575       286 000607       288 000610       289 000614       295 000626       299 000642
    300 000643       302 000647       304 000654       305 000660       306 000662       309 000670       311 000672
    315 000703       316 000705       318 000706       320 000714       322 000723       326 000724       330 000737
    331 000740       333 000744       334 000750       335 000752       336 000754       338 000762       339 000766
    341 000767       344 000776       345 001000       347 001001       351 001007       355 001010       362 001023
    363 001024       365 001030       369 001061       370 001063       371 001067       372 001072       373 001100
    374 001103       377 001104       380 001113       381 001115       383 001116       384 001121       389 001122
    393 001144       394 001145       396 001151       397 001153       398 001157       399 001162       401 001174
    402 001177       405 001227       408 001230       411 001237       412 001241       417 001242       419 001272
    421 001274       424 001275       428 001276       430 001302       433 001323


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
