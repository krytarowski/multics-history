	COMPILATION LISTING OF SEGMENT display_mrds_db_population
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 10/16/86  1345.4 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1972 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 
       19 /****^  HISTORY COMMENTS:
       20*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
       21*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
       22*     This entry is being made to cover the change made on 85-04-19 by Thanh
       23*     Nguyen. (see mrds #136)
       24*                                                   END HISTORY COMMENTS */
       25 
       26 
       27 display_mrds_db_population:
       28 dmdbp:
       29 dmdp:
       30      procedure ();
       31 
       32 /* DESCRIPTION:
       33*
       34*   This is a utility routine for MRDS  databases,  it  displays  the
       35*   current  population  of  the relations in a database, and  in the
       36*   long version, a list of the indexed  attributes and the number of
       37*   tuples selected for each index.  It  can  not  display  secondary
       38*   index information for  version <= 3 databases. Also, version <= 3
       39*   databases  must  have been  opened  for exclusive update at least
       40*   once prior to calling  this routine. For version 4 databases that
       41*   are secured, the  path  must be to a secured submodel if the user
       42*   is not a DBA. Arguments may be given in any order, but  the  path
       43*   must come before the -relation argument.  Control   arguments can
       44*   be over-ridden, with the last taking effect.
       45*
       46*
       47*
       48*
       49*   PARAMETERS:
       50*
       51*   database_path - - (input) the relative pathname of  the  database
       52*   model  or  submodel  view  whose  population statistics are to be
       53*   displayed.
       54*
       55*   -brief, -bf - - (input) control argument,  to  limit  display  to
       56*   relation  names,  and  their  current  tuple  count.  This is the
       57*   default.
       58*
       59*   -long, -lg - - (input) control argument to cause the  display  to
       60*   contain  all  information  available  from vfile_status_ for each
       61*   relation in the view, or specified in the -relation option.
       62*
       63*   -relation rel_name 1 ... rel_nameN - - (input)  control  argument
       64*   to  cause  only  the specified relations to have their statistics
       65*   displayed according to the -long/-brief controls. The default  is
       66*   to display all relations in the view.
       67*
       68*
       69*
       70*
       71*   HISTORY:
       72*
       73*   80-05-15 Jim Gray : Originally written.
       74*
       75*   81-04-11 Jim Gray : modified for release in bound mrds as follows:
       76*   1) extended the interface to accept submodel views
       77*   2) added a -long option control arg
       78*   3) made the default -brief
       79*   4) added the -relation control arg
       80*   5) for a secured db, limited non-DBA to secured submodel
       81*   6) set needed access for a DBA
       82*   7) changed the output formating
       83*
       84*   81-06-04  Davids:  removed  references  to  the   user   external
       85*   interface  (both  the mrds_dsm_dsmd and associated include files)
       86*   and  replaced   them   with   mrds'   internal   interface.   The
       87*   model_relations         and        dsm_relation_names        (now
       88*   mrds_dsm_relation_names) were all being referenced by  overlaying
       89*   the model_relation structure. Since they all have the same format
       90*   this was working but it was changed so  that  each  structure  is
       91*   referenced separately to improve maintainability.
       92*   
       93*   81-09-15 Rickie E.  Brinegar: Added substr to the assignment of abs_path to
       94*   db_path  and  changed  action_type from char (12) to char (14) to avoid the
       95*   substring condition.
       96*
       97*   82-10-8 D. Woodka : Modified for DMS conversion. Changed to call 
       98*   mu_rel_statistics return_tuple_count and return_index_attr_dups.
       99*   Deleted the output of:  vfile version,  number of bytes in vfile
      100*   records, number of  vfile keys and their total bytes,  number of
      101*   duplicate keys  and their bytes,  tree height,  number of pages, 
      102*   amount of free  space and number of  updates.  Added output of a
      103*   list of the  indexed  attributes and  average  number  of tuples 
      104*   expected to be selected (for -long display,version 4 databases).
      105*
      106*   82-12-21  Roger Lackey : Added rtrim to several error messages and 
      107*   removed unused dcls added undefined builtin dcls.
      108*
      109*   83-02-04 Davids: Added transaction include files. Modified  the  internal
      110*   routine error  not to call the clean_up procedure but to just go to exit.
      111*   Changed the normal return sequence to  call  clean_up  after  the
      112*   exit   label   instead  of  before  and  added  the  mrds  finish
      113*   transaction include file after the call to clean_up. This made it
      114*   easier  to  add  the  finish  transaction  code and mstxn cleanup
      115*   condition handler. Note that there is only 1 transaction for  the
      116*   entire  database, this means that if the transaction dies for any
      117*   reason the rest of the relations will not be processed. It  would
      118*   be better to have a transaction for each relation but it would be
      119*   much slower.   
      120*
      121*   83-02-14 Davids: modified to use the new db_type_flags in the db_model
      122*   structure instead of the old numeric db_type.
      123*
      124*   83-05-24 Mike Kubicar : Modified to not call mu_rel_statistics to get
      125*   the tuple count.
      126**/
      127 
      128 /* initialize */
      129 
      130 	error_code = 0;
      131 	dbm_ptr = null ();				/* model not open yet */
      132 	submodel_open = "0"b;
      133 	area_ptr = null ();
      134 	long_format = "0"b;				/* default to -brief option */
      135 	all_relations = "1"b;			/* default to showing all relations in the view */
      136 	path_seen = "0"b;
      137 	mstxn_txn_id = "0"b;
      138 
      139 	call cu_$af_arg_count (nargs, error_code);	/* make sure we weren't called as an active function */
      140 	if error_code ^= error_table_$not_act_fnc then
      141 	     call error (error_code, "Command called as an active function,
      142                     or unable to obtain argument count.");
      143 	error_code = 0;
      144 
      145 	on cleanup begin;
      146 		call mstxn_cleanup;
      147 		call clean_up ();
      148 	     end;
      149 
      150 	on any_other call mstxn_any_other;
      151 
      152 /* check for a good call */
      153 
      154 	if nargs < 1 then do;
      155 		error_code = error_table_$wrong_no_of_args;
      156 		call error (error_code, "Usage:  dmdbp  path  {-brief|-long} {-relation rel_name1 ... rel_nameN}");
      157 
      158 	     end;
      159 
      160 /* get some work space */
      161 
      162 	call get_temp_segment_ (caller_name, temp_seg_ptr, error_code);
      163 	if error_code ^= 0 then
      164 	     call error (error_code, "Unable to get a temp segment.");
      165 	area_ptr = temp_seg_ptr;
      166 	area_ptr -> work_area = empty ();
      167 
      168 /* gather all the arguments */
      169 
      170 	arg_count = 1;
      171 	args_finished = "0"b;
      172 	do while (^args_finished);
      173 
      174 /* get this argument, and decide if it is a control argument or not */
      175 
      176 	     call cu_$arg_ptr (arg_count, arg_ptr, arg_len, error_code);
      177 	     if error_code ^= 0 then do;
      178 		     args_finished = "1"b;
      179 		     call error (error_code, "While getting argument.");
      180 		end;
      181 
      182 
      183 /* check for a null argument */
      184 
      185 	     if arg_len < 1 then do;
      186 		     args_finished = "1"b;
      187 		     error_code = error_table_$bad_arg;
      188 		     call error (error_code, "While getting argument.");
      189 		end;
      190 
      191 /* control arguments begin with a hyphen */
      192 
      193 	     if substr (arg, 1, 1) = "-" then
      194 		call process_control_arg ();
      195 	     else call process_path_arg ();
      196 
      197 /* advance to the next argument */
      198 
      199 	     if arg_count < nargs then
      200 		arg_count = arg_count + 1;
      201 	     else args_finished = "1"b;
      202 
      203 	end;
      204 
      205 /* check that we got a  pathname argument */
      206 
      207 	if error_code = 0 then do;
      208 
      209 		if ^path_seen then do;
      210 			error_code = error_table_$noarg;
      211 			call error (error_code, "No pathname argument was given.");
      212 		     end;
      213 
      214 		if mrds_path_info.mrds_version <= 3
      215 		then mstxn_transactions_needed = "0"b;
      216 		else mstxn_transactions_needed = db_model.db_type_flags.transactions_needed;
      217 
  1     1 /* ====== BEGIN INCLUDE FILE	          mrds_start_transaction.incl.pl1 =========================== */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  1     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  1     8*     This entry is being made to cover the changes made on 85-05-06 and
  1     9*     85-04-19 by Thanh Nguyen. The dependency on dbcb.user_started_transaction
  1    10*     was removed because not all modules need the dbcb, and the
  1    11*     user_transaction_id field was added for mrds_dsl_retrieve (mrds error
  1    12*     list #136).
  1    13*                                                   END HISTORY COMMENTS */
  1    14 
  1    15 
  1    16 /*
  1    17*                    BEGIN_DESCRIPTION
  1    18*
  1    19*   A generalized routine accessed by all MRDS modules (with the temporary 
  1    20*   (perhaps) exception of restructuring modules) that must start transactions 
  1    21*   if none are present.  The intent is that it be executed as inline code.
  1    22*   The variable mstxn_transactions_needed must be set prior to entering this
  1    23*   code.  In most cases a simple assignment from dbcb_data.transactions_needed
  1    24*   will suffice.  Included are procedures called mstxn_cleanup and 
  1    25*   mstxn_any_other.  These procedures must be called by cleanup and any_other 
  1    26*   handlers in the program.  Such handlers should be established just prior to
  1    27*   the inclusion of this code and disabled just following the inclusion of
  1    28*   mrds_finish_transaction.  Directly prior to establishing the handlers
  1    29*   mstxn_txn_id must be set to "0"b.  This must be done even though this 
  1    30*   include file does the same, because this code might not have been entered 
  1    31*   yet when the handler is invoked.  Directly following this include file the 
  1    32*   contents of mstxn_code should be examined.  If zero, then either the 
  1    33*   transaction was successfully started or no transaction was required.  If the
  1    34*   mrds_finish_transaction code is referenced in general error handling 
  1    35*   situations where the possibility exists that the code in this include file 
  1    36*   has not been executed, it is necessary to initialize mstxn_txn_id to "0"b at
  1    37*   the beginning of the program.
  1    38*
  1    39*                    END_DESCRIPTION
  1    40*
  1    41*   Written 82-09-28 by Paul W. Benjamin.
  1    42*   Modified 82-12-09 by PWB to include mstxn_any_other.
  1    43*   Modified 83-01-07 by PWB to not reference the dbcb.
  1    44*   Modified 83-01-10 by PWB to add a call to continue_to_signal_ to the
  1    45*		 any_other handler in situations where the module did
  1    46*		 not start the transaction.
  1    47*   Modified 83-05-05 by PWB to abandon when abort fails.
  1    48*   Modified 83-05-18 by PWB to use mstxn_temp_code in calls to abandon and
  1    49*		 and abort.
  1    50*   Modified 83-05-19 by PWB to handle transaction_deadlock and 
  1    51*		 transaction_bj_full conditions.
  1    52*   Modified 84-02-04 by PWB to add trailing underscores to the 2 conditions
  1    53*		 and to handle transaction_lock_timeout_.
  1    54*   Modified 85-04-14 by Thanh Nguyen: Added code to set the 
  1    55*                     dbcb.user_started_transaction flag.
  1    56*   Modified 85-04-19 by Thanh Nguyen to add user_started_transaction flag.
  1    57*   Modified 85-05-06 By Thanh Nguyen to synchronize this include file in the 
  1    58*                     directory >ldd>include and >exl>mrd>i
  1    59**/
  1    60 
  1    61 dcl continue_to_signal_ entry (fixed bin(35));
  1    62 dcl dm_error_$no_current_transaction fixed bin (35) ext static;
  1    63 dcl error_table_$null_info_ptr fixed bin(35) ext static;
  1    64 dcl find_condition_info_ entry (ptr, ptr, fixed bin(35));
  1    65 dcl mstxn_code fixed bin (35);
  1    66 dcl mstxn_retries fixed;
  1    67 dcl mstxn_temp_code fixed bin (35);
  1    68 dcl mstxn_transactions_needed bit (1) aligned;
  1    69 dcl user_started_transaction bit (1) aligned;
  1    70 dcl mstxn_txn_id bit (36) aligned;
  1    71 dcl user_transaction_id bit (36) aligned;
  1    72 dcl transaction_manager_$abandon_txn entry (bit (36) aligned, fixed bin (35));
  1    73 dcl transaction_manager_$abort_txn entry (bit (36) aligned, fixed bin (35));
  1    74 dcl transaction_manager_$begin_txn entry (fixed bin, fixed bin (35), bit (36) aligned, fixed bin (35));
  1    75 dcl transaction_manager_$get_current_txn_id entry (bit (36) aligned, fixed bin (35));
  1    76 dcl transaction_manager_$handle_conditions entry ();
  1    77 dcl 1 mstxn_condition_info like condition_info;
  1    78 
  2     1 /*  START OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 /* HISTORY:
  2     4*
  2     5*Designed by Matthew C. Pierret, 01/26/82.
  2     6*Coded by Jeffrey D. Ives, 04/30/82.
  2     7*Modified:
  2     8*10/18/82 by Steve Herbst: Names changed.
  2     9*01/19/83 by Steve Herbst: Added (LOWEST HIGHEST)_MODE.
  2    10**/
  2    11 
  2    12 dcl (LOWEST_MODE init (1),
  2    13      HIGHEST_MODE init (8)) fixed bin int static options (constant);
  2    14 
  2    15      dcl	   TM_NORMAL_MODE	      fixed bin static options (constant) init (1);
  2    16      dcl	   TM_STATISTICAL_MODE   fixed bin static options (constant) init (2);
  2    17      dcl	   TM_READ_ONLY_MODE     fixed bin static options (constant) init (3);
  2    18      dcl	   TM_NEVER_WRITE_MODE   fixed bin static options (constant) init (4);
  2    19      dcl	   TM_TEST_NORMAL_MODE   fixed bin static options (constant) init (5);
  2    20      dcl	   TM_TEST_STATISTICAL_MODE fixed bin static options (constant) init (6);
  2    21      dcl	   TM_TEST_READ_ONLY_MODE fixed bin static options (constant) init (7);
  2    22      dcl	   TM_TEST_NEVER_WRITE_MODE fixed bin static options (constant) init (8);
  2    23 
  2    24 /*  END OF:	dm_tm_modes.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1    79 

  1    80 
  3     1 /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  3     2 
  3     3 /* Structure for find_condition_info_.
  3     4*
  3     5*   Written 1-Mar-79 by M. N. Davidoff.
  3     6**/
  3     7 
  3     8 /* automatic */
  3     9 
  3    10      declare condition_info_ptr     pointer;
  3    11 
  3    12 /* based */
  3    13 
  3    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  3    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  3    16 	     2 version	      fixed binary,		/* Must be 1 */
  3    17 	     2 condition_name     char (32) varying,	/* name of condition */
  3    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  3    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  3    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  3    21 	     2 flags	      unaligned,
  3    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  3    23 	       3 pad1	      bit (35),
  3    24 	     2 pad2	      bit (36),
  3    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  3    26 	     2 pad3	      (4) bit (36);
  3    27 
  3    28 /* internal static */
  3    29 
  3    30      declare condition_info_version_1
  3    31 			      fixed binary internal static options (constant) initial (1);
  3    32 
  3    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
  1    81 
  1    82 
  1    83 	mstxn_code = 0;
  1    84 	mstxn_txn_id = "0"b;
  1    85 	
  1    86 	if ^mstxn_transactions_needed			/* only need transactions */
  1    87 	     then goto mstxn_exit;			/* for protected page files */
  1    88 	mstxn_retries = 0;
  1    89 	call transaction_manager_$get_current_txn_id (mstxn_txn_id, mstxn_code);
  1    90 	if mstxn_code ^= dm_error_$no_current_transaction	/* and if none already in progress */
  1    91 	     then do;				
  1    92 	     user_started_transaction = "1"b;
  1    93 	     user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  1    94 	     mstxn_txn_id = "0"b;			/* you didn't start it, it's none of your business */
  1    95 	     goto mstxn_exit;	
  1    96 	end;
  1    97 
  1    98 	user_started_transaction = "0"b;
  1    99 	call transaction_manager_$begin_txn (TM_NORMAL_MODE, 0, mstxn_txn_id, mstxn_code);
  1   100 	user_transaction_id = mstxn_txn_id;          /* better save it for mrds_dsl_retrieve */
  1   101 
  1   102 mstxn_cleanup:
  1   103 proc;
  1   104 
  1   105 /*  This procedure MUST be called by a cleanup handler. */
  1   106 
  1   107           if mstxn_txn_id ^= "0"b
  1   108           then do;
  1   109 	     call transaction_manager_$abort_txn (mstxn_txn_id, mstxn_temp_code);
  1   110 	     if mstxn_temp_code ^= 0
  1   111 		then call transaction_manager_$abandon_txn (mstxn_txn_id, mstxn_temp_code);
  1   112 	end;
  1   113 	
  1   114      end mstxn_cleanup;
  1   115 
  1   116 mstxn_any_other:
  1   117 proc;
  1   118 
  1   119 /*  This procedure MUST be called by an any_other handler. */
  1   120 
  1   121           if mstxn_txn_id ^= "0"b
  1   122           then do;
  1   123 	     call find_condition_info_ (null (), addr(mstxn_condition_info), mstxn_temp_code);
  1   124 	     if mstxn_condition_info.condition_name = "transaction_deadlock_"
  1   125 		then do;
  1   126 		mftxn_code = dm_error_$lock_deadlock;
  1   127 		goto mftxn_check_code;
  1   128 	     end;
  1   129 	     else if mstxn_condition_info.condition_name = "transaction_bj_full_"
  1   130 		| mstxn_condition_info.condition_name = "transaction_lock_timeout_"
  1   131 		then do;
  1   132 		mftxn_code = dm_error_$bj_journal_full;
  1   133 		goto mftxn_check_code;
  1   134 	     end;
  1   135 	     else call transaction_manager_$handle_conditions;
  1   136 	end;
  1   137 	else call continue_to_signal_ (mstxn_code);	/* code returned will always be zero */
  1   138      end mstxn_any_other;
  1   139      
  1   140 mstxn_exit:
  1   141      
  1   142 /* ------ END INCLUDE FILE	          mrds_start_transaction.incl.pl1 --------------------------- */
      218 
      219 
      220 		if mstxn_code ^= 0
      221 		then call error (mstxn_code, "Unable to start a transaction");
      222 
      223 /* go display the requested status */
      224 
      225 		call display_db_status ();
      226 
      227 	     end;
      228 
      229 exit:
      230 	call clean_up ();
      231 
      232 	mftxn_code = error_code;
      233 
  4     1 /* ====== BEGIN INCLUDE FILE           mrds_finish_transaction.incl.pl1 =========================== */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  4     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  4     8*     This entry is being made to cover the change made on 85-05-06 by Thanh
  4     9*     Nguyen. The code now checks a local flag. (mrds error list #136).
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 
  4    13 /*
  4    14*                    BEGIN_DESCRIPTION
  4    15*
  4    16*   A generalized routine accessed by all MRDS modules that begin and commit 
  4    17*   transactions.  The intent is that it be executed as inline code. It is 
  4    18*   assumed that mrds_start_transaction was executed previously in the 
  4    19*   procedure.  Prior to this include file the program should assign the value 
  4    20*   of its local error code to mftxn_code.  The program utilizing this
  4    21*   include file must supply a function labeled should_rollback that returns
  4    22*   bit (1).  This routine should examine the error code mftxn_code and whether
  4    23*   the transaction should be aborted or rolled back.  "0"b means abort and "1"b
  4    24*   means rollback.  This procedure may choose to simply return "0"b as it 
  4    25*   appears that MRDS will generally NOT rollback transactions.  This routine
  4    26*   does rollback and restart if the before journal is full but only attempts it
  4    27*   once.  A procedure labelled restore_significant_data must also be supplied, 
  4    28*   where any data that was saved prior to the transaction is restored.  A 
  4    29*   procedure consisting solely of a return statement can be supplied if 
  4    30*   necessary.  After execution of this include file, mftxn_code must be
  4    31*   examined.  If it was 0 before entering the code and is non-zero afterward,
  4    32*   then the commit has failed.  Otherwise it will be unchanged.
  4    33*
  4    34*                    END_DESCRIPTION
  4    35*
  4    36*   Written 82-09-30 by Paul W. Benjamin.
  4    37*   Modified 83-01-13 by PWB to add retry on deadlocks and to return a non-zero 
  4    38*                     error code only when the transaction is in an error state.
  4    39*   Modified 83-02-04 by PWB to reset transaction id to 0 upon completion.
  4    40*   Modified 83-05-05 by PWB to abort when rollback fails, abandon when abort
  4    41*		 fails, and to abort rather than rollback when bj is full.
  4    42*   Modified 83-05-18 by PWB to use mftxn_temp_code in calls to abandon, abort
  4    43*		 and rollback.
  4    44*   Modified 83-05-19 by PWB to add mftxn_check_code label.  It is transferred
  4    45*		 to by the mstxn_any_other procedure.
  4    46*   Modified 85-04-14 by Thanh Nguyen not to commit the transaction in case of
  4    47*                     the user already started his own transaction.
  4    48*   Modified 85-05-06 by Thanh Nguyen to synchronize this include file between
  4    49*                     the directory >ldd>include and >exl>mrd>i.
  4    50**/
  4    51 
  4    52 dcl dm_error_$bj_journal_full fixed bin(35) ext static;
  4    53 dcl dm_error_$lock_deadlock fixed bin(35) ext static;
  4    54 dcl mftxn_code fixed bin (35);
  4    55 dcl mftxn_temp_code fixed bin (35);
  4    56 dcl transaction_manager_$commit_txn entry (bit (36) aligned, fixed bin (35));
  4    57 dcl transaction_manager_$rollback_txn entry (bit (36) aligned, fixed bin (17), fixed bin (35));
  4    58 	
  4    59 
  4    60 	if mstxn_txn_id = "0"b | user_started_transaction = "1"b	/* No transaction or we did not started it */
  4    61 	     then do;
  4    62 	     mftxn_code = 0;
  4    63 	     goto mftxn_exit;
  4    64 	end;
  4    65 mftxn_check_code:
  4    66 	if mftxn_code = 0
  4    67 	     then do;
  4    68 	     call transaction_manager_$commit_txn (mstxn_txn_id, mftxn_code);
  4    69 	     if mftxn_code ^= 0
  4    70 		then do;
  4    71 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    72 		if mftxn_temp_code ^= 0
  4    73 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    74 	     end;
  4    75 	end;
  4    76 	else do;
  4    77 	     call restore_significant_data;
  4    78 	     if mftxn_code = dm_error_$lock_deadlock	/* retry just once if deadlock */
  4    79 		& mstxn_retries < 1		
  4    80 		then do;
  4    81 		     mstxn_retries = mstxn_retries + 1;
  4    82 		     call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    83 		     if mftxn_temp_code ^= 0
  4    84 			then do;
  4    85 			call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4    86 			if mftxn_temp_code ^= 0
  4    87 			     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4    88 		     end;
  4    89 		     else do;
  4    90 			mstxn_code = 0;
  4    91 			goto mstxn_exit;		/* go back and try again */
  4    92 		     end;
  4    93 		end;
  4    94 	     else if should_rollback ()		/* let the program decide */
  4    95 		then do;
  4    96 		call transaction_manager_$rollback_txn (mstxn_txn_id, 0, mftxn_temp_code);
  4    97 		if mftxn_temp_code ^= 0
  4    98 		     then do;
  4    99 		     call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   100 		     if mftxn_temp_code ^= 0
  4   101 			then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   102 		end;
  4   103 		else do;
  4   104 		     mstxn_code = 0;
  4   105 		     goto mstxn_exit;		/* go back and try again */
  4   106 		end;
  4   107 	     end;
  4   108 	     else do;
  4   109 		call transaction_manager_$abort_txn (mstxn_txn_id, mftxn_temp_code);
  4   110 		if mftxn_temp_code ^= 0
  4   111 		     then call transaction_manager_$abandon_txn (mstxn_txn_id, mftxn_temp_code);
  4   112 	     end;
  4   113 	end;
  4   114 	mstxn_txn_id = "0"b;			/* should never be nonzero unless there is a txn */
  4   115 mftxn_exit:
  4   116      
  4   117 /* ------ END INCLUDE FILE	          mrds_finish_transaction.incl.pl1 --------------------------- */
      234 
      235 
      236 	if mftxn_code ^= 0
      237 	then call com_err_ (mftxn_code, caller_name, "Unable to finish transaction");
      238 
      239 	return;
      240 
      241 should_rollback: proc () returns (bit (1));
      242 
      243 /* This routine is required by the transaction include files.  It is called
      244*   when a transaction is in an error state.  The convention is that returning
      245*   "0"b directs that the transaction be aborted and "1"b directs that the
      246*   transaction be rolled back.  At this point, the only reasonable action in
      247*   such situations seems to be to abort the transaction, so we always... */
      248 
      249 	return ("0"b);
      250 
      251      end should_rollback;
      252 
      253 restore_significant_data: proc ();
      254 
      255 /* This routine is required by the transaction include files.  It is called
      256*   when a transaction is aborted or rolled back.  The intent is to return
      257*   non-FAMIS storage to the appropriate state to reflect the backing out of 
      258*   whatever FAMIS changes were made. */
      259 
      260 	return;
      261 
      262      end restore_significant_data;
      263 
      264 process_control_arg:
      265      procedure ();
      266 
      267 /* routine to determine if user has given one of the legal
      268*   control arguments of brief, long, or relation REL_NAME
      269*   and to save the corresponding information.
      270*   The logic is such as to allow duplicate control arguments
      271*   to override each other, with the last given taking effect. */
      272 
      273 /* BRIEF */
      274 
      275 	if arg = "-brief" | arg = "-bf" then long_format = "0"b; /* use short display format */
      276 
      277 /* LONG */
      278 
      279 	else if arg = "-long" | arg = "-lg" then long_format = "1"b; /* use verbose display format */
      280 
      281 /* UNKNOWN */
      282 
      283 	else if arg ^= "-relation" then do;
      284 		args_finished = "1"b;
      285 		error_code = error_table_$badopt;
      286 		call error (error_code, "The control argument """ || arg ||
      287 		     """ is not supported by this command.");
      288 	     end;
      289 
      290 /* BAD ORDER */
      291 
      292 	else if ^path_seen then do;
      293 		args_finished = "1"b;
      294 		error_code = error_table_$noarg;
      295 		call error (error_code, "The pathname argument did not appear before the ""-relation"" option.");
      296 	     end;
      297 
      298 	else do;
      299 
      300 /* RELATION LIST */
      301 
      302 		last_relation_seen = "0"b;
      303 		some_relation_seen = "0"b;
      304 		all_relations = "0"b;		/* only do the given relations */
      305 		last_relation_ptr, relation_list_ptr = null ();
      306 		arg_count = arg_count + 1;
      307 		relation_list_length = 0;
      308 
      309 /* go through all relation names given */
      310 
      311 		do while (^last_relation_seen);
      312 
      313 		     call cu_$arg_ptr (arg_count, arg_ptr, arg_len, error_code);
      314 		     if error_code ^= 0 then do;
      315 			     args_finished, last_relation_seen = "1"b;
      316 			     call error (error_code, "While getting a relation name argument");
      317 			end;
      318 		     if arg_len < 1 then do;
      319 			     args_finished, last_relation_seen = "1"b;
      320 			     error_code = error_table_$bad_arg;
      321 			     call error (error_code, "While getting a relation name argument");
      322 			end;
      323 		     else if substr (arg, 1, 1) = "-" then do;
      324 			     last_relation_seen = "1"b; /* end of list of relation names */
      325 			     arg_count = arg_count - 1; /* reset for processining remaining args */
      326 			end;
      327 		     else do;
      328 
      329 /* first relation name seen */
      330 
      331 			     some_relation_seen = "1"b;
      332 
      333 /* gather this name for the list */
      334 
      335 			     relation_name_length_init = arg_len;
      336 			     allocate relation set (relation_ptr) in (work_area);
      337 			     relation.name_length = relation_name_length_init;
      338 			     relation.name = arg;	/* remember this relation's name */
      339 
      340 /* add the name at the end of the list to maintain order */
      341 
      342 			     relation.next = null ();
      343 			     if last_relation_ptr = null () then
      344 				relation_list_ptr = relation_ptr;
      345 			     else last_relation_ptr -> relation.next = relation_ptr;
      346 			     last_relation_ptr = relation_ptr;
      347 			     relation_list_length = relation_list_length + 1;
      348 
      349 /* advance to the next name given */
      350 
      351 			     if arg_count < nargs then
      352 				arg_count = arg_count + 1;
      353 			     else last_relation_seen = "1"b;
      354 
      355 			end;
      356 
      357 		end;
      358 
      359 /* check that at least one name was given */
      360 
      361 		if ^some_relation_seen & error_code = 0 then do;
      362 			args_finished = "1"b;
      363 			error_code = error_table_$noarg;
      364 			call error (error_code, "No relation name(s) given with the ""-relation"" control argument.");
      365 		     end;
      366 
      367 	     end;
      368 
      369      end process_control_arg;
      370 
      371 process_path_arg:
      372      procedure ();
      373 
      374 /* routine to verify the database model path or submodel path
      375*   argument, that supplies the view for status information.
      376*   Only one path argument is allowed */
      377 
      378 	if path_seen then do;
      379 
      380 /* duplicate path name arguments given */
      381 
      382 		args_finished = "1"b;
      383 		error_code = mrds_error_$duplicate_opt;
      384 		call error (error_code, "The pathname argument was given more than once: " || arg);
      385 	     end;
      386 	else do;
      387 
      388 /* first pathname seen */
      389 
      390 		path_seen = "1"b;
      391 
      392 /* check for a valid path to a model or submodel */
      393 
      394 		call mrds_dsl_get_version$get_path_info (arg, area_ptr,
      395 		     mrds_path_info_structure_version, mrds_path_info_ptr, error_code);
      396 		if mrds_path_info_ptr = null () then
      397 		     abs_path = arg;
      398 		else abs_path = mrds_path_info.absolute_path;
      399 		if error_code ^= 0 then do;
      400 			args_finished = "1"b;
      401 			call error (error_code, "Unable to find database information using the path """ || rtrim (abs_path) || """.");
      402 		     end;
      403 
      404 /* good path, if this is a submodel path, then get the
      405*   database path from the submodel header */
      406 
      407 		if mrds_path_info.type.model then
      408 		     db_path = substr (abs_path, 1, 168);
      409 		else do;				/* submodel view */
      410 
      411 /* open the specified submodel */
      412 
      413 			call mrds_dsm_open$read (rtrim (abs_path), submodel_iocb_ptr,
      414 			     error_code);
      415 			if error_code ^= 0 then do;
      416 				args_finished = "1"b;
      417 				call com_err_ (error_code, "Unable to open the submodel using the path """ || rtrim (abs_path) || """.");
      418 			     end;
      419 
      420 /* let them know we have the submodel open */
      421 
      422 			submodel_open = "1"b;
      423 			call ioa_ ("^/Displaying version ^d submodel:  ^a",
      424 			     mrds_path_info.mrds_version, abs_path);
      425 
      426 /* get the database path from the submodel header record */
      427 
      428 			call mrds_dsm_read_header$db_path (submodel_iocb_ptr, db_path,
      429 			     error_code);
      430 			if error_code ^= 0 then do;
      431 				args_finished = "1"b;
      432 				call error (error_code,
      433 				     "Unable to get the database path from the header for the submodel """ || rtrim (abs_path) || """.");
      434 			     end;
      435 
      436 		     end;
      437 
      438 	     end;
      439 
      440 /* for version 4 secured databases, make sure non-DBA's
      441*   are using a secured submodel view of the database */
      442 
      443 	if error_code = 0 then
      444 	     call check_secured_view ();
      445 
      446      end process_path_arg;
      447 
      448 check_secured_view:
      449      procedure ();
      450 
      451 /* routine to check for a version 4 database that has been secured,
      452*   and for a non-DBA user not looking through a secure submodel */
      453 
      454 	if mrds_path_info.type.model then
      455 	     db_info_ptr = mrds_path_info_ptr;
      456 	else do;
      457 
      458 		call mrds_dsl_get_version$get_path_info (rtrim (db_path), area_ptr,
      459 		     mrds_path_info_structure_version, db_info_ptr, error_code);
      460 		if error_code ^= 0 then do;
      461 			args_finished = "1"b;
      462 			call error (error_code,
      463 			     "Unable to get information about the database """
      464 			     || rtrim (db_path) || """ for the submodel """ || rtrim (abs_path) || """.");
      465 		     end;
      466 
      467 	     end;
      468 
      469 	if error_code = 0 then do;
      470 
      471 		if db_info_ptr -> mrds_path_info.mrds_version = 4 then do;
      472 
      473 			call mrds_dm_open (db_path, mode, dbm_ptr, error_code);
      474 			if error_code ^= 0 then do;
      475 				args_finished = "1"b;
      476 				call error (error_code, "Unable to open the data model for the database """ || rtrim (db_path) || """.");
      477 			     end;
      478 
      479 			call mrds_dm_db_secured$get_secured_status (dbm_ptr,
      480 			     area_ptr, database_state_structure_version,
      481 			     database_state_ptr, error_code);
      482 			if error_code ^= 0 then do;
      483 				args_finished = "1"b;
      484 				call error (error_code,
      485 				     "Unable to get the secured state for the database """ || rtrim (db_path) || """.");
      486 			     end;
      487 
      488 
      489 			if database_state.secured then do;
      490 
      491 				call mrds_dm_authorization$get_user_class (rtrim (db_path),
      492 				     area_ptr, mrds_authorization_structure_version,
      493 				     mrds_authorization_ptr, error_code);
      494 				if error_code ^= 0 then do;
      495 					args_finished = "1"b;
      496 					call error (error_code,
      497 					     "Unable to determine if the user is a DBA for the database """ || rtrim (db_path) || """.");
      498 				     end;
      499 
      500 
      501 				if ^mrds_authorization.administrator then do;
      502 
      503 					bad_path = "0"b;
      504 					if mrds_path_info.type.model then
      505 					     bad_path = "1"b;
      506 					else do;
      507 						call expand_pathname_ (abs_path, sm_dir, sm_name,
      508 						     error_code);
      509 						if error_code ^= 0 then do;
      510 							args_finished = "1"b;
      511 							call error (error_code,
      512 							     "Unable to expand the submodel path """ || rtrim (abs_path) || """.");
      513 						     end;
      514 						else do;
      515 
      516 							if ^mrds_dm_secured_submodel (rtrim (db_path),
      517 							     sm_dir, sm_name) then
      518 							     bad_path = "1"b;
      519 						     end;
      520 
      521 					     end;
      522 
      523 					if bad_path then do;
      524 						args_finished = "1"b;
      525 						error_code = mrds_error_$inc_secure_open;
      526 						call error (error_code,
      527 						     "The submodel """ || rtrim (abs_path) ||
      528 						     """ is not a secure submodel, but the database """ || rtrim (db_path) || """ has been secured.");
      529 					     end;
      530 
      531 				     end;
      532 
      533 			     end;
      534 
      535 		     end;
      536 
      537 	     end;
      538 
      539      end check_secured_view;
      540 
      541 display_db_status:
      542      procedure ();
      543 
      544 /* routine to output all requested database info */
      545 
      546 /* set up the path to the relation vfiles, based on database version */
      547 
      548 /* get the relations from the model or submodel   depending upon how we were called */
      549 
      550 	call get_relation_info ();
      551 
      552 
      553 /* gather the status information for each relation in the view specified by the user,
      554*   or only the subset in his relation list */
      555 
      556 	if all_relations then
      557 	     relation_count = number_of_relations;
      558 	else relation_count = relation_list_length;
      559 
      560 
      561 /* output a header for the long or short format */
      562 
      563 	if (^long_format | db_info_ptr -> mrds_path_info.mrds_version < 4) then
      564 	     call ioa_ ("^/RELATION^4-TUPLES^/");
      565 	else
      566 	     call ioa_ ("^/RELATION^-TUPLES^-INDEX^-AVE TUPLES SELECTED^/");
      567 
      568 	if mrds_path_info.mrds_version >= 4 then do;
      569 		if db_model.db_type_flags.vfile_type
      570 		then vfile = "1"b;			/* if this is a vfile database */
      571 		else vfile  Processed pub_02: 0 0 456 26 1 ¶ $’ 	Îd T¦@£ü ]   ÿÿvcons  purge_volume_log_: Volume log pub_02.volog purged. Entry count changed from 141 to 125   ¶ $’ 	Îe T¦@c E   ÿÿvcons  consolidated_volume_dump: Begin dump of physical volume pub_03   ¶ $’ 	Îf T¦xB ?   ÿÿvcons  consolidated_volume_dump: Processed pub_03: 0 0 337 36 0 ¶ $’ 	Îg T¦{dê ]   ÿÿvcons  purge_volume_log_: Volume log pub_03.volog purged. Entry count changed from 140 to 124   ¶ $’ 	Îh T¦{%î E   ÿÿvcons  consolidated_volume_dump: Begin dump of physical volume pub_04   ¶ $’ 	Îi T¦#C ?   ÿÿvcons  consolidated_volume_dump: Processed pub_04: 0 0 206 20 0 ¶ $’ 	Îj T¦Ÿµv ]   ÿÿvcons  purge_volume_log_: Volume log pub_04.volog purged. Entry count changed from 139 to 123   ¶ $’ 	Îk T¦ ˆ/ E   ÿÿvcons  consolidated_volume_dump: Begin dump of physical volume pub_05   ¶ $’ 	Îl T¦µÀÔ ?   ÿÿvcons  consolidated_volume_dump: Processed pub_05: 0 0 104 23 0 ¶ $’ 	Îm T¦¸P ]   ÿÿvcons  purge_volume_log_: Volume log pub_05.volog purged. Entry count changed from 140 to 124   ¶ $’ 	În T¦¸Î« E   ÿÿvcons  consolidated_volume_dump: Begin dump of physical volume pub_06   ¶ $’ 	Îo T¦Úyğ ?   ÿÿvcons  consolidated_volume_dump: Processed pub_06: 0 0 204 23 0 ¶ $’ 	Îp T¦ÜË- ]   ÿÿvcons  purge_volume_log_: Volume log pub_06.volog purged. Entry count changed from 140 to 124   ¶ $’ 	Îq T¦İ E   ÿÿvcons  consolidated_volume_dump: Begin dump of physical volume pub_07   ¶ $’ 	Îr T¦õ! ?   ÿÿvcons  consolidated_volume_dump: Processed pub_07: 0 0 149 13 0 ¶ $’ 	Îs T¦øùe ]   ÿÿvcons  purge_volume_log_: Volume log pub_07.volog purged. Entry count changed from 164 to 148   ¶ $’ 	Ît T¦ùÅğ E   ÿÿvcons  consolidated_volume_dump: Begin dump of physical volume pub_08   ¶ $’ 	Îu T¦(Å| ?   ÿÿvcons  consolidated_volume_dump: Processed pub_08: 0 0 296 29 0 ¶ $’ 	Îv T¦+Qk ]   ÿÿvcons  purge_volume_log_: Volume log pub_08.volog purged. Entry count changed from 144 to 128   ¶ $’ 	Îw T¦+ı D   ÿÿvcons  consolidated_volume_dump: Begin dump of physical volume abb01¶ $’ 	Îx T¦OÖ- ?   ÿÿvcons  consolidated_volume_dump: Processed abb01: 0 0 200 14 82 ¶ $’ 	Îy T¦Q¥¯ \   ÿÿvcons  purge_volume_log_: Volume log abb01.volog purged. Entry count changed from 117 to 101¶ $’ 	Îz T¦Q_â D   ÿÿvcons  consolidated_volume_dump: Begin dump of physical volume abb02¶ $’ 	Î{ T¦Â @   ÿÿvcons  consolidated_volume_dump: Processed abb02: 0 0 280 13 106¶ $’ 	Î| T¦ƒ	ë \   ÿÿvcons  purge_volume_log_: Volume log abb02.volog purged. Entry count changed from 120 to 104¶ $’ 	Î} T¦ƒ÷< D   ÿÿvcons  consolidated_volume_dump: Begin dump of physical volume abb03¶ $’ 	Î~ T¦Øßª @   ÿÿvcons  consolidated_volume_dump: Processed abb03: 0 0 668 21 119¶ $’ 	Î T¦Û` \   ÿÿvcons  purge_volume_log_: Volume log abb03.volog purged. Entry count changed from 124 to 108¶ $’ 	Î€ T¦ÛâË D   ÿÿvcons  consolidated_volume_dump: Begin dump of physical volume abb04¶ $’ 	Î T§uX ?   ÿÿvcons  consolidated_volume_dump: Processed abb04: 0 0 372 21 88 ¶ $’ 	Î‚ T§j> \   ÿÿvcons  purge_volume_log_: Volume log abb04.volog purged. Entry count changed from 120 to 104¶ $’ 	Îƒ T§7  D   ÿÿvcons  consolidated_volume_dump: Begin dump of physical volume abb05¶ $’ 	Î„ T§fĞd ?   ÿÿvcons  consolidated_volume_dump: Processed abb05: 0 0 503 23 95 ¶ $’ 	Î… T§hÛı \   ÿÿvcons  purge_volume_log_: Volume log abb05.volog purged. Entry count changed from 121 to 105¶ $’ 	Î† T§işÌ D   ÿÿvcons  consolidated_volume_dump: Begin dump of physical volume abb06¶ $’ 	Î‡ T§¢#ƒ ?   ÿÿvcons  consolidated_volume_dump: Processed abb06: 0 0 325 23 57 ¶ $’ 	Îˆ T§£ûÏ \   ÿÿvcons  purge_volume_log_: Volume log abb06.volog purged. Entry count changed from 118 to 102¶ $’ 	Î‰ T§¤°6 D   ÿÿvcons  consolidated_volume_dump: Begin dump of physical volume abb07¶ $’ 	ÎŠ T§üà @   ÿÿvcons  consolidated_volume_dump: Processed abb07: 0 0 631 42 105¶ $’ 	Î‹ T§şóó \   ÿÿvcons  purge_volume_log_: Volume log abb07.volog purged. Entry count changed from 119 to 103¶ $’ 	ÎŒ T§ÿ¸¯ D   ÿÿvcons  consolidated_volu were called with */
      669 
      670 	if mrds_path_info.type.model then do;
      671 
      672 /* open the data model for retrieval */
      673 
      674 		if dbm_ptr = null () then do;		/* not open yet */
      675 			call mrds_dm_open (db_path, mode, dbm_ptr, error_code);
      676 			if error_code ^= 0 then
      677 			     call error (error_code,
      678 				"Unable to open the data model for database """ ||
      679 				rtrim (db_path) || """.");
      680 		     end;
      681 
      682 /* let them know we got it open */
      683 
      684 		call ioa_ ("^/^a ^d ^a ^a", "Displaying version",
      685 		     db_info_ptr -> mrds_path_info.mrds_version, "data model:",
      686 		     db_path);
      687 
      688 /* get the names of all relations in the database */
      689 
      690 		call mrds_dm_get_relations (dbm_ptr, addr (work_area),
      691 		     mr_ptr, error_code);
      692 		if error_code ^= 0 then
      693 		     call error (error_code,
      694 			"Unable to get the relation names from the model for database """
      695 			|| rtrim (db_path) || """.");
      696 		else number_of_relations = mr_ptr -> model_relations.nrels;
      697 
      698 
      699 
      700 	     end;
      701 
      702 	else do;					/* submodel view given */
      703 
      704 /* get the submodel names in this view */
      705 
      706 		call mrds_dsm_get_relation_names (area_ptr, mrds_dsm_relation_names_ptr,
      707 		     submodel_iocb_ptr, error_code);
      708 		if error_code ^= 0 then
      709 		     call error (error_code,
      710 			"Unable to get the relations in the submodel """ ||
      711 			rtrim (abs_path) || """.");
      712 		else number_of_relations =
      713 			mrds_dsm_relation_names_ptr -> mrds_dsm_relation_names.nrels;
      714 
      715 	     end;
      716 
      717      end get_relation_info;
      718 
      719 display_relation_status:
      720      procedure ();
      721 
      722 	if mrds_path_info.mrds_version <= 3 then do;
      723 		info_ptr = addr (indx_info);
      724 		call vfile_status_ (rtrim (db_path) || ">rel_dir", model_rel_name, info_ptr, error_code);
      725 
      726 		if error_code ^= 0 then call error (error_code,
      727 			"Unable to get status information on relation """ || rtrim (rel_name) || """ in the database """ || rtrim (db_path) || """ . ");
      728 		num_tuples = indx_info.non_null_recs;
      729 	     end;
      730 	else do;
      731 		if vfile then do;
      732 			call vfile_relmgr_$open (db_path, model_rel_name,
      733 			     rel_opening_id, error_code);
      734 			if error_code ^= 0
      735 			then call error (error_code, "Could not open relation " || rtrim (model_rel_name) || ".");
      736 			call vfile_relmgr_$create_cursor (rel_opening_id,
      737 			     area_ptr, relation_cursor_ptr, error_code);
      738 			if error_code ^= 0
      739 			then call error (error_code, "Could not create a cursor for relation " || rtrim (model_rel_name) || ".");
      740 			call vfile_relmgr_$get_count (relation_cursor_ptr,
      741 			     null (), num_tuples, error_code);
      742 			if error_code ^= 0
      743 			then call error (error_code, "Could not get count of tuples for relation "
      744 				|| rtrim (model_rel_name) || ".");
      745 		     end;
      746 		else do;
      747 			call relation_manager_$open (db_path, model_rel_name,
      748 			     rel_opening_id, error_code);
      749 			if error_code ^= 0
      750 			then call error (error_code, "Could not open relation " || rtrim (model_rel_name) || ".");
      751 			call relation_manager_$create_cursor (rel_opening_id,
      752 			     area_ptr, relation_cursor_ptr, error_code);
      753 			if error_code ^= 0
      754 			then call error (error_code, "Could not create a cursor for relation " || rtrim (model_rel_name) || ".");
      755 			call relation_manager_$get_count (relation_cursor_ptr,
      756 			     null (), num_tuples, error_code);
      757 			if error_code ^= 0
      758 			then call error (error_code, "Could not get count of tuples for relation "
      759 				|| rtrim (model_rel_name) || ".");
      760 		     end;
      761 	     end;
      762 
      763 	if ^long_format then call ioa_ ("^40a^d", rel_name, num_tuples);
      764 
      765 	else do;					/* if this is the long version */
      766 
      767 		if db_info_ptr -> mrds_path_info.mrds_version < 4 then
      768 		     call ioa_ ("^40a^d", rel_name, num_tuples);
      769 
      770 		else do;
      771 
      772 			call ioa_ ("^a^-^d", rel_name, num_tuples);
      773 
      774 /* display attribute information */
      775 
      776 			do ai_ptr = ptr (fm_ptr, rel_info.attr_ptr)
      777 			     repeat ptr (fm_ptr, attr_info.fwd_thread)
      778 			     while (rel (ai_ptr) ^= NULL_OFFSET);
      779 
      780 			     if attr_info.index_attr then do;
      781 				     found = "0"b;
      782 				     if mrds_path_info.type.submodel then
      783 					do k = 1 to relation_block.no_rb_attributes while (^found);
      784 					     if attr_info.name = relation_block.attribute_info (k).dm_attr_name then do;
      785 						     found = "1"b;
      786 						     index_name = relation_block.attribute_info (k).dsm_attr_name;
      787 
      788 						end;
      789 					end;
      790 				     else do;
      791 					     found = "1"b;
      792 					     index_name = attr_info.name;
      793 
      794 					end;
      795 				     if found then do;
      796 					     if vfile then
      797 						call vfile_relmgr_$get_duplicate_key_count (relation_cursor_ptr,
      798 						     attr_info.index_id, ALL_THE_ATTRIBUTES, dup_count, error_code);
      799 					     else
      800 						call relation_manager_$get_duplicate_key_count (relation_cursor_ptr,
      801 						     attr_info.index_id, ALL_THE_ATTRIBUTES, dup_count, error_code);
      802 					     if error_code ^= 0
      803 					     then call error (error_code, "Could not get duplicate count for index "
      804 						     || rtrim (index_name) || ".");
      805 
      806 					     if dup_count = num_tuples then ave_tuples = num_tuples;
      807 					     else ave_tuples = num_tuples / (num_tuples - dup_count);
      808 					     call ioa_ ("^2-^a^-^d", index_name, ave_tuples);
      809 
      810 					end;
      811 				end;
      812 			end;
      813 		     end;
      814 	     end;
      815 
      816 	if db_info_ptr -> mrds_path_info.mrds_version = 4 then do;
      817 		if vfile then do;
      818 			call vfile_relmgr_$destroy_cursor (relation_cursor_ptr,
      819 			     area_ptr, error_code);
      820 			if error_code ^= 0
      821 			then call error (error_code, "Could not destroy a cursor for relation "
      822 				|| rtrim (rel_name) || ".");
      823 			call vfile_relmgr_$close (rel_opening_id, error_code);
      824 		     end;
      825 		else do;
      826 			call relation_manager_$destroy_cursor (relation_cursor_ptr,
      827 			     area_ptr, error_code);
      828 			if error_code ^= 0
      829 			then call error (error_code, "Could not destroy a cursor for relation "
      830 				|| rtrim (rel_name) || ".");
      831 			call relation_manager_$close (rel_opening_id, error_code);
      832 		     end;
      833 		if error_code ^= 0 then call error (error_code, "While closing the relation" || rel_name);
      834 	     end;
      835 
      836 
      837      end display_relation_status;
      838 
      839 error: proc (code, message);
      840 
      841 /* Parameters */
      842 
      843 	dcl     code		 fixed bin (35);
      844 	dcl     message		 char (*);
      845 
      846 	call com_err_ (code, caller_name, "^/^a", message);
      847 	go to exit;
      848 
      849      end error;
      850 
      851 clean_up:
      852      procedure ();
      853 
      854 /* close the data model, if open */
      855 
      856 	if dbm_ptr ^= null then do;
      857 		call mrds_dm_close (dbm_ptr, discard);
      858 		dbm_ptr = null ();
      859 	     end;
      860 
      861 	if submodel_open then do;
      862 		call mrds_dsm_close$force (submodel_iocb_ptr);
      863 		submodel_open = "0"b;
      864 	     end;
      865 
      866 	if area_ptr ^= null () then do;
      867 		call release_temp_segment_ (caller_name, area_ptr, discard);
      868 		area_ptr = null ();
      869 	     end;
      870      end;
      871 
      872 	dcl     abs_path		 char (200);	/* absolute pathname of model or submodel */
      873 	dcl     ALL_THE_ATTRIBUTES	 fixed bin int static options (constant)
      874 				 init (-1);	/* get_duplicate_key_count looks at all attributes in index */
      875 	dcl     all_relations	 bit (1);		/* on => do all rels in view */
      876 	dcl     area_ptr		 ptr;		/* points to work space */
      877 	dcl     arg		 char (arg_len) based (arg_ptr); /* input argument */
      878 	dcl     arg_count		 fixed bin;	/* current arg under inspection */
      879 	dcl     arg_len		 fixed bin (21);	/* lengh of input arg */
      880 	dcl     arg_ptr		 ptr;		/* points to input argument */
      881 	dcl     args_finished	 bit (1);		/* on => all args seen, or error */
      882 	dcl     ave_tuples		 fixed bin (35);
      883 	dcl     bad_path		 bit (1);		/* on => non-dba not using secure submodel on secured db */
      884 	dcl     caller_name		 char (32) init ("display_mrds_db_population") int
      885 				 static options (constant); /* calling routine */
      886 	dcl     cleanup		 condition;	/* signaled upon quit/release */
      887 	dcl     any_other		 condition;
      888 	dcl     com_err_		 entry options (variable); /* reports errors */
      889 	dcl     cu_$af_arg_count	 entry (fixed bin, fixed bin (35)); /* gets arg count/call type */
      890 	dcl     cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
      891 						/* gets Nth arg */
      892 	dcl     db_path		 char (168);	/* pathname of database */
      893 	dcl     discard		 fixed bin (35);	/* ignored error error_code */
      894 	dcl     mrds_dm_authorization$get_user_class
      895 				 entry (char (*), ptr, fixed bin, ptr, fixed bin (35));
      896 						/* detects DBA */
      897 	dcl     mrds_dm_db_secured$get_secured_status
      898 				 entry (ptr, ptr, fixed bin, ptr, fixed bin (35));
      899 						/* sets db secured state */
      900 	dcl     mrds_dm_close	 entry (ptr, fixed bin (35)); /* closes data model */
      901 	dcl     mrds_dm_get_relations	 entry (ptr, ptr, ptr, fixed bin (35));
      902 						/* gets relation names */
      903 	dcl     mrds_dm_open	 entry (char (168), fixed bin, ptr, fixed bin (35));
      904 						/* opens data model */
      905 	dcl     mrds_dm_secured_submodel entry (char (*), char (*), char (*))
      906 				 returns (bit (1)); /* checks for secured submodel */
      907 	dcl     done		 bit (1);		/* loop control for relation name search */
      908 	dcl     mrds_dsm_open$read	 entry (char (*), ptr, fixed bin (35));
      909 	dcl     mrds_dsm_read_header$db_path entry (ptr, char (168), fixed bin (35));
      910 	dcl     mrds_dsm_read_relation entry (char (*), ptr, ptr, ptr, fixed bin (35));
      911 	dcl     mrds_dsm_get_relation_names entry (ptr, ptr, ptr, fixed bin (35));
      912 	dcl     mrds_dsm_close$force	 entry (ptr);
      913 	dcl     submodel_iocb_ptr	 ptr init (null ());/* pointer to the submodel iocb */
      914 	dcl     dup_count		 fixed bin (35);
      915 	dcl     error_code		 fixed bin (35);	/* error status encoding */
      916 	dcl     error_table_$bad_arg	 fixed bin (35) ext;/* null input arg */
      917 	dcl     error_table_$badopt	 fixed bin (35) ext;/* unknown control arg */
      918 	dcl     error_table_$noarg	 fixed bin (35) ext;/* missing argument */
      919 	dcl     error_table_$not_act_fnc fixed bin (35) ext; /* should get this normally */
      920 	dcl     error_table_$wrong_no_of_args fixed bin (35) ext; /* not minimum of 1 arg */
      921 	dcl     expand_pathname_	 entry (char (*), char (*), char (*), fixed bin (35));
      922 	dcl     file_model_name	 char (32);
      923 	dcl     found		 bit (1);		/* on => known relation name supplied, and it's index found */
      924 	dcl     get_temp_segment_	 entry (char (*), ptr, fixed bin (35));
      925 						/* gets temp segs */
      926 	dcl     hcs_$initiate	 entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
      927 	dcl     i			 fixed bin;	/* current count of relations displayed */
      928 	dcl     index_name		 char (32);
      929 	dcl     1 indx_info,			/* info structure for vfile status */
      930 		2 info_version	 fixed bin init (1),
      931 		2 type		 fixed bin init (4),
      932 		2 records		 fixed bin (34),
      933 		2 flags		 aligned,
      934 		  3 lock_status	 bit (2) unal,
      935 		  3 pad		 bit (34) unal,
      936 		2 version		 aligned,
      937 		  3 file_version	 fixed bin (17) unal,
      938 		  3 program_version	 fixed bin (17) unal,
      939 		2 action		 fixed bin,
      940 		2 non_null_recs	 fixed bin (34),
      941 		2 record_bytes	 fixed bin (34),
      942 		2 free_blocks	 fixed bin,
      943 		2 index_height	 fixed bin,
      944 		2 nodes		 fixed bin,
      945 		2 key_bytes	 fixed bin (34),
      946 		2 change_count	 fixed bin (35),
      947 		2 num_keys	 fixed bin (34),
      948 		2 dup_keys	 fixed bin (34),
      949 		2 dup_key_bytes	 fixed bin (34),
      950 		2 reserved	 (1) fixed bin;
      951 	dcl     info_ptr		 ptr;
      952 	dcl     ioa_		 entry options (variable); /* does output display */
      953 	dcl     j			 fixed bin;	/* index into the relation_list structure */
      954 	dcl     k			 fixed bin;
      955 	dcl     last_relation_ptr	 ptr;		/* points to last relation in list */
      956 	dcl     last_relation_seen	 bit (1);		/* on => exit relation name loop */
      957 	dcl     long_format		 bit (1);		/* on => display all status info */
      958 	dcl     mode		 fixed bin init (2);/* retrieval */
      959 	dcl     model_rel_name	 char (32);	/* name of the relation in the data model */
      960 	dcl     mrds_dsl_get_version$get_path_info
      961 				 entry (char (*), ptr, fixed bin, ptr, fixed bin (35));
      962 	dcl     mrds_error_$duplicate_opt fixed bin (35) ext; /* path arg given > 1 time */
      963 	dcl     mrds_error_$inc_secure_open fixed bin (35) ext; /* non-dba, secured db, un-secure submodel */
      964 	dcl     mrds_error_$no_model_rel fixed bin (35) ext static;
      965 	dcl     nargs		 fixed bin;	/* number of arguments presented */
      966 	dcl     NULL_OFFSET		 int static bit (18) unal init ((18)"1"b) options (constant);
      967 	dcl     num_tuples		 fixed bin (35);	/* number of tuples in relations */
      968 	dcl     number_of_relations	 fixed bin;	/* number of relations in view */
      969 	dcl     path_seen		 bit (1);		/* on => path name argument given */
      970 	dcl     relation_id		 bit (36) aligned init ((36)"1"b);
      971 	dcl     relation_cursor_ptr	 ptr;		/* Cursor to gather statistics */
      972 	dcl     relation_manager_$create_cursor entry (bit (36) aligned, ptr, ptr, fixed bin (35));
      973 	dcl     relation_manager_$destroy_cursor entry (ptr, ptr, fixed bin (35));
      974 	dcl     relation_manager_$get_count entry (ptr, ptr, fixed bin (35), fixed bin (35));
      975 	dcl     relation_manager_$get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35));
      976 	dcl     relation_manager_$open entry (char (*), char (*), bit (36) aligned, fixed bin (35));
      977 	dcl     relation_manager_$close entry (bit (36) aligned, fixed bin (35));
      978 	dcl     rel_id		 bit (36) aligned;
      979 	dcl     rel_name		 char (64);	/* name of model or submodel relation */
      980 	dcl     rel_opening_id	 bit (36) aligned;	/* opening id of the relation */
      981 	dcl     relation_count	 fixed bin;	/* number of relations to be displayed */
      982 	dcl     relation_list_length	 fixed bin;	/* number of relations in -relation list  */
      983 	dcl     relation_list_ptr	 ptr;		/* points to head of relation list */
      984 	dcl     relation_name_length_init fixed bin (21); /* initial value for name length allocation */
      985 	dcl     relation_ptr	 ptr;		/* points to relation list element */
      986 	dcl     release_temp_segment_	 entry (char (*), ptr, fixed bin (35));
      987 						/* frees temp segs */
      988 	dcl     sm_dir		 char (168);	/* containing directory of submodel */
      989 	dcl     sm_name		 char (32);	/* name of submodel msf */
      990 	dcl     some_relation_seen	 bit (1);		/* on => at least one relation name given */
      991 	dcl     submodel_open	 bit (1);		/* on => submodel has been opened */
      992 	dcl     sys_info$max_seg_size	 fixed bin (35) ext;/* largest segment */
      993 	dcl     temp_seg_ptr	 ptr;
      994 	dcl     db_info_ptr		 ptr;		/* used to point to second copy of path info structure */
      995 	dcl     work_area		 area (sys_info$max_seg_size) based (area_ptr);
      996 						/* space for temp storage */
      997 	dcl     vfile		 bit (1);		/* set for a vfile database */
      998 	dcl     vfile_relmgr_$create_cursor entry (bit (36) aligned, ptr, ptr, fixed bin (35));
      999 	dcl     vfile_relmgr_$destroy_cursor entry (ptr, ptr, fixed bin (35));
     1000 	dcl     vfile_relmgr_$get_count entry (ptr, ptr, fixed bin (35), fixed bin (35));
     1001 	dcl     vfile_relmgr_$get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35));
     1002 	dcl     vfile_relmgr_$open	 entry (char (*), char (*), bit (36) aligned, fixed bin (35));
     1003 	dcl     vfile_relmgr_$close	 entry (bit (36) aligned, fixed bin (35));
     1004 	dcl     vfile_status_	 entry (char (*), char (*), ptr, fixed bin (35));
     1005 	dcl     (addr, empty, fixed, null, substr, ptr, rel, rtrim) builtin;
     1006 	dcl     1 relation		 based (relation_ptr), /* saved relation name for -relation options */
     1007 		2 next		 ptr,		/* points to next in list */
     1008 		2 name_length	 fixed bin (21),	/* length of the relation name */
     1009 		2 name		 char (relation_name_length_init refer (relation.name_length));
     1010 						/* relation's name */
     1011 
  5     1 /* BEGIN INCLUDE FILE mdbm_db_model.incl.pl1 -- jaw, 10/2/78 */
  5     2 
  5     3 
  5     4 /****^  HISTORY COMMENTS:
  5     5*  1) change(79-02-01,Gray), approve(), audit(), install():
  5     6*     modified to save space occupied by model
  5     7*  2) change(80-11-03,Gray), approve(), audit(), install():
  5     8*     to add mdbm_secured bit in db_model
  5     9*  3) change(82-04-09,Davids), approve(), audit(), install():
  5    10*     collapsed the following into an unused_offset array:
  5    11*       chng_before_path_ptr  chng_err_path_ptr  chng_after_path_ptr
  5    12*       copy_before_path_ptr  copy_err_path_ptr  copy_after_path_ptr
  5    13*       dsply_before_path_pt  dsply_err_path_pt  dsply_after_path_ptr
  5    14*       accs_before_path_ptr  accs_err_path_ptr  accs_after_path_ptr
  5    15*       unused_1
  5    16*     Also changed the name of unused_2 to restructuring_history_offset
  5    17*     and changed the comment on the changer structure to indicate
  5    18*     that it will contain on database creation information.
  5    19*  4) change(82-04-14,Davids), approve(), audit(), install():
  5    20*     used one of the unused_offsets to point to a message which indicates
  5    21*     why the db is inconsistent. The offset will be null when the db is created
  5    22*     and set the first time the message is used. this is so it will be
  5    23*     consistent with existing data bases. Also added the message structure.
  5    24*  5) change(82-04-28,Davids), approve(), audit(), install():
  5    25*     added the undo_request element to the message structure
  5    26*  6) change(82-05-04,Davids), approve(), audit(), install():
  5    27*     changed unused_offset (12) to last_restructruring_history_offset and
  5    28*     changed restructuring_history_offset to first_restructuring_history_offset
  5    29*  7) change(82-08-19,Davids), approve(), audit(), install():
  5    30*     changed the meaning of db_type from 1 => relational and 2 => CODASYL to
  5    31*     1 => vfile database and 2 => page_file database. Up to this point all
  5    32*     database types were equal to 1.
  5    33*  8) change(83-02-14,Davids), approve(), audit(), install():
  5    34*     changed db_type from a fixed bin unal to a substructure of 18 bit (1) unal
  5    35*     flags. This will allow information about transactions and dm_file
  5    36*     concurrency to be independent of the db_type, i.e. vfile or dm_file. The
  5    37*     change is compatable with all datamodels created by the released version
  5    38*     of mrds.
  5    39*  9) change(83-02-15,Davids), approve(), audit(), install():
  5    40*     added the rollback_on flag to the db_type_flags since it appears that you
  5    41*     can have a dmfile database that requires transactions but does not have any
  5    42*     journalizing. Also switched the order of the transactions_needed and
  5    43*     concurrency_on flags - this makes the change compatable with existing
  5    44*     dmfile databases except when displaying the model since concurrency_on and
  5    45*     rollback_on will be off in the model even though the dmfile relations had
  5    46*     them on during creation.
  5    47* 10) change(83-02-22,Kubicar), approve(), audit(), install():
  5    48*      Removed ctl_file_path_ptr.
  5    49* 11) change(85-11-08,Spitzer), approve(85-12-03,MCR7311),
  5    50*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  5    51*      used 1 unused offset for unreferenced attribute linked lists in db_model,
  5    52*      1 unused bit flag in domain_info to indicate an unreferenced domain, 1 bit
  5    53*      in the flag word for rmdb copying.
  5    54*                                                   END HISTORY COMMENTS */
  5    55 
  5    56 
  5    57 /* this include file contains the structures that go into the make up
  5    58*   of the "db_model" segment in the model for the database.
  5    59*   in addition there file_model.m segments, 1 for each database file(see mdbm_file_model.incl.pl1)
  5    60*
  5    61*   the db_model structure goes at the base of the segment, and contains items unique to
  5    62*   the whole databse. in addition, it has an area of size to fill the
  5    63*   rest of a segment, that holds the lists of files and domains in the database.
  5    64*   these lists are singly forward linked lists. all "pointers" in the database model
  5    65*   are maintained as offsets(bit (18)) from the base of the particular model segment
  5    66*   since actual pointers are process dependent on segment number.
  5    67*   the remaining structures are first a path_entry one to save pathnames in,
  5    68*   and the stack_item and constent structures, used to save a boolean
  5    69*   expression in polish form, with the stack represented by a linked list.
  5    70*   the final structure is one for identifying the status of version information */
  5    71 
  5    72      dcl	   1 db_model	      aligned based (dbm_ptr),/* base of db_model segment, allocated once per database */
  5    73 	     2 version	      unal fixed bin,	/* data base version, currently 4 */
  5    74 	     2 db_type_flags      unal,
  5    75 	       3 copy_good	      bit (1) unal,		/* "1"b => copy of the db_model is the valid copy */
  5    76 	       3 unused	      (13) bit (1) unal,
  5    77 	       3 rollback_on      bit (1) unal,		/* "1"b => before journaling is to be done */
  5    78 	       3 concurrency_on   bit (1) unal,		/* "1"b => dm_file concurrency is being used */
  5    79 	       3 transactions_needed bit (1) unal,	/* "1"b => transactions are needed to reference data */
  5    80 	       3 vfile_type	      bit (1) unal,		/* "1"b => vfile type relations, "0"b => dm_file type relations */
  5    81 	     2 uniq_sw_name	      char (32),		/* per database unique attach switch name for files */
  5    82 	     2 consistant	      bit (1) unal,		/* ON => correctly created/restructured database, ok to open */
  5    83 	     2 mdbm_secured	      bit (1) unal,		/* on => database has been secured */
  5    84 	     2 reserved	      bit (34) unal,	/* reserved for flags */
  5    85 	     2 blk_file_id_len    unal fixed bin,	/* no. bits required for blocked file id. */
  5    86 	     2 unblk_file_id_len  unal fixed bin,	/* number of file id bits, unblocked file */
  5    87 	     2 num_blk_files      unal fixed bin,	/* number of blocked files defined in db */
  5    88 	     2 num_unblk_files    unal fixed bin,	/* number of unblocked files defined in db */
  5    89 	     2 num_rels	      unal fixed bin,	/* number of relations defined in db. */
  5    90 	     2 num_domains	      unal fixed bin,	/* number of domains defined */
  5    91 	     2 num_dyn_links      unal fixed bin,	/* no. dynamic links defined */
  5    92 	     2 max_max_tuples     unal fixed bin (35),	/* maximum max_tuples across all files */
  5    93 	     2 pad_1	      unal fixed bin (35),	/* for future use */
  5    94 	     2 pad_2	      unal fixed bin (35),	/* for future use */
  5    95 	     2 version_ptr	      bit (18),		/* offset to version structure */
  5    96 	     2 file_ptr	      unal bit (18),	/* offset to first in threaded list of file_infos */
  5    97 	     2 domain_ptr	      unal bit (18),	/* offset to first in list of domain_infos */
  5    98 	     2 unreferenced_attribute_ptr unal bit (18),	/* offset to first in list of unreferenced attr_infos */
  5    99 	     2 unused_offsets     (11) unal bit (18),	/* extra offsets if needed */
  5   100 	     2 last_restructuring_history_offset unal bit (18), /* offset to last restructuring history entry */
  5   101 	     2 inconsistent_message_offset unal bit (18), /* offset to message indicating why db is inconsistent */
  5   102 	     2 first_restructuring_history_offset unal bit (18), /* offset to first restructuring history entry */
  5   103 	     2 changer_ptr	      unal bit (18),	/* offset to information about db creation */
  5   104 	     2 dbm_area	      area (sys_info$max_seg_size - fixed (rel (addr (db_model.dbm_area))) - 1);
  5   105 
  5   106      dcl	   dbm_ptr	      ptr;
  5   107 
  5   108 /* the files in the database each have a file_info containing
  5   109*   their name, the file_model for each file is found by initiating the
  5   110*   segment "file_name.m" (i.e. the file's name with suffix ".m")
  5   111*   the file_info list is a singly linked list in definition order */
  5   112 
  5   113      dcl	   1 file_info	      aligned based (fi_ptr), /* list of file names and numbers */
  5   114 	     2 file_name	      char (30),		/* name of file */
  5   115 	     2 file_id	      bit (36),		/* id number of file */
  5   116 	     2 fwd_ptr	      unal bit (18),	/* thread to next in list */
  5   117 	     2 unused	      unal bit (18);	/* for future expansion */
  5   118 
  5   119      dcl	   fi_ptr		      ptr;
  5   120 
  5   121 /* each domain used in the database will have a domain info saved in the db_model
  5   122*   segment. it describes the domain of the given name, and it's options.
  5   123*   the domain_info's form a singly linked list in definition order */
  5   124 
  5   125      dcl	   1 domain_info	      aligned based (di_ptr), /* one for each domain defined */
  5   126 	     2 name	      char (32),		/* name of domain */
  5   127 	     2 db_desc_is_ptr     bit (1) unal,		/* on if descriptor is pointer to real desc. */
  5   128 	     2 user_desc_is_ptr   bit (1) unal,		/* on if user desc is ptr */
  5   129 	     2 no_conversion      bit (1) unal,		/* if no conversion allowed */
  5   130 	     2 procedures_present bit (1) unal,		/* on => ids type procedures present */
  5   131 	     2 unreferenced	      bit (1) unal,		/* on => this domain is not used in any attribute */
  5   132 	     2 reserved	      bit (31) unal,
  5   133 	     2 db_desc	      bit (36),		/* desc. for item in db, or ptr to it */
  5   134 	     2 user_desc	      bit (36),		/* desc. for user-visible attr, or ptr */
  5   135 	     2 ave_len	      fixed bin (35),	/* average length of  varying string */
  5   136 	     2 nck_items	      unal fixed bin,	/* no. items in check stack */
  5   137 	     2 fwd_thread	      unal bit (18),	/* offset to next in list */
  5   138 	     2 check_path_ptr     unal bit (18),	/* integ. check proc. */
  5   139 	     2 ck_stack_ptr	      unal bit (18),	/* to check stack */
  5   140 	     2 encd_path_ptr      unal bit (18),	/* encode procedure */
  5   141 	     2 decd_path_ptr      unal bit (18),	/* decode procedure */
  5   142 	     2 str_before_path_ptr unal bit (18),	/* proc paths and entries */
  5   143 	     2 str_err_path_ptr   unal bit (18),
  5   144 	     2 str_after_path_ptr unal bit (18),
  5   145 	     2 get_before_path_ptr unal bit (18),
  5   146 	     2 get_err_path_ptr   unal bit (18),
  5   147 	     2 get_after_path_ptr unal bit (18),
  5   148 	     2 mod_before_path_ptr unal bit (18),
  5   149 	     2 mod_err_path_ptr   unal bit (18),
  5   150 	     2 mod_after_path_ptr unal bit (18),
  5   151 	     2 unused_1	      unal bit (18),	/* for future expansion */
  5   152 	     2 unused_2	      unal bit (18),
  5   153 	     2 changer_ptr	      unal bit (18);	/* pointer to change_id and chane_time structure */
  5   154 
  5   155      dcl	   di_ptr		      ptr;
  5   156 
  5   157 /* information necessary for attributes that are not used in any relation */
  5   158 
  5   159      dcl     1 unreferenced_attribute aligned based (ua_ptr),
  5   160 	     2 name char (32),			/* name of attribute */
  5   161 	     2 domain_ptr bit (18) unal,		/* to domain_info */
  5   162 	     2 fwd_thread bit (18) unal,		/* to next in list */
  5   163 	     2 unused (2) bit (18) unal;
  5   164 
  5   165      dcl     ua_ptr ptr;
  5   166 
  5   167 
  5   168 /* space saving pathname$entryname structure, to be allocated
  5   169*   only when a path$entry has to be saved, else only a bit(18)
  5   170*   offset takes up space in the main model structure */
  5   171 
  5   172      declare 1 path_entry	      based (path_entry_ptr),
  5   173 	     2 path	      char (168),		/* pathname portion of desired path$entry */
  5   174 	     2 entry	      char (32),		/* entryname portion of desired path$entry */
  5   175 	     2 reserved	      unal bit (36);	/* for future use */
  5   176 
  5   177      declare path_entry_ptr	      ptr;
  5   178 
  5   179 
  5   180 
  5   181 
  5   182 
  5   183 /* declarations for model of postfix stack holding the check option boolean expression
  5   184*   the following encoding values indicate the corresponding type of stack element
  5   185*
  5   186*   1  =
  5   187*   2  ^=
  5   188*   3  >
  5   189*   4  <
  5   190*   5  >=
  5   191*   6  <=
  5   192*
  5   193*   10  and
  5   194*   20  or
  5   195*   30  not
  5   196*
  5   197*   40  - (minus)
  5   198*
  5   199*   50  domain variable(same name as domain)
  5   200*
  5   201*   60  constant(number, bit string, or character string)
  5   202*
  5   203**/
  5   204 
  5   205 
  5   206      declare 1 stack_item	      based (stack_item_ptr), /* element of stack model list */
  5   207 	     2 next	      bit (18),		/* link to next in list */
  5   208 	     2 type	      fixed binary,		/* code for this element type */
  5   209 	     2 value_ptr	      bit (18);		/* pointer to variable holding value,
  5   210*						   if this is a constant element type */
  5   211 
  5   212      declare stack_item_ptr	      ptr;		/* pointer to a stack element */
  5   213 
  5   214 
  5   215 
  5   216      declare 1 constant	      based (constant_ptr),	/* variable size space for constant's value storage */
  5   217 	     2 length	      fixed bin (35),	/* length allocated to hold value */
  5   218 	     2 value	      bit (alloc_length refer (constant.length)) aligned; /* value for this constant */
  5   219 
  5   220      declare constant_ptr	      ptr;		/* pointer to constant's value space */
  5   221 
  5   222      declare alloc_length	      fixed binary (35) internal static; /* amount of space to allocate for constant's value */
  5   223 
  5   224 /* version structure, giving status of source for CMDB/RMDB,
  5   225*   status of model, and status of resultant */
  5   226 
  5   227 /* version number is in form MM.N.Y
  5   228*   where MM is the major version number, N is the minor version alteration,
  5   229*   and Y is the lastest modification to that alteration,
  5   230*   where M and N represent numbers 0-9, and Y is a letter */
  5   231 
  5   232      declare 1 version_status	      unal based (version_status_ptr),
  5   233 	     2 cmdb_rmdb,
  5   234 	       3 major	      fixed bin,
  5   235 	       3 minor	      fixed bin,
  5   236 	       3 modification     char (4),
  5   237 	     2 model,
  5   238 	       3 major	      fixed bin,
  5   239 	       3 minor	      fixed bin,
  5   240 	       3 modification     char (4),
  5   241 	     2 resultant,
  5   242 	       3 major	      fixed bin,
  5   243 	       3 minor	      fixed bin,
  5   244 	       3 modification     char (4);
  5   245 
  5   246      declare version_status_ptr     ptr;
  5   247 
  5   248 
  5   249 /* maintains information only about the db creation */
  5   250 
  5   251      declare 1 changer	      unal based (changer_ptr),
  5   252 	     2 id		      char (32),
  5   253 	     2 time	      fixed bin (71),
  5   254 	     2 next	      bit (18);		/* to next in the singly linked list */
  5   255 
  5   256      declare changer_ptr	      ptr;
  5   257 
  5   258 
  5   259      dcl	   01 message_str	      unal based (message_str_ptr), /* general purpose structure to hold messages */
  5   260 	     02 len	      fixed bin,		/* length of the message */
  5   261 	     02 text	      char (message_str_len refer (message_str.len)), /* actual message */
  5   262 	     02 name	      char (32),		/* name of thing that set the message */
  5   263 	     02 undo_request      char (100),		/* rmdb request that will undo the operation
  5   264*                                                               that caused the database to become inconsistent */
  5   265 	     02 mbz	      bit (36);		/* for possible extensions, like an offset to another message */
  5   266 
  5   267      dcl	   message_str_ptr	      ptr;		/* pointer to the message_str structure */
  5   268 
  5   269      dcl	   message_str_len	      fixed bin;		/* initail length of the text string in message_str */
  5   270 
  5   271 /* END INCLUDE FILE mdbm_db_model.incl.pl1 */
  5   272 
  5   273 
     1012 
     1013 
  6     1 /* BEGIN INCLUDE FILE mdbm_file_model.incl.pl1 -- jaw, 8/29/78 */
  6     2 
  6     3 
  6     4 /****^  HISTORY COMMENTS:
  6     5*  1) change(79-02-01,JGray), approve(), audit(), install():
  6     6*     modified to save space occupied by model
  6     7*  2) change(82-05-19,Davids), approve(), audit(), install():
  6     8*     renamed rel_info.nsec_inds to rel_info.unused_3 because it really wasn't
  6     9*     the number of secondary indices in the relation - it was always zero.
  6    10*  3) change(82-08-19,DWoodka), approve(), audit(), install():
  6    11*     changed rel_info.id and attr_info.index_id to bit (36) unaligned for the
  6    12*     DMS conversion.
  6    13*  4) change(82-09-20,MKubicar), approve(), audit(), install():
  6    14*     changed rel_info.id and attr_info.index_id to aligned; they are needed that
  6    15*     way for relmgr_ calls.  Also added rel_info.primary_key_index_id, needed
  6    16*     for relation manager changes.
  6    17*  5) change(85-12-02,Spitzer), approve(85-12-02,MCR7311),
  6    18*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  6    19*     used 2 reserved bits to indicate whether the copy of the <rel>.m and/or
  6    20*     <rel> files are good (for rmdb)
  6    21*                                                   END HISTORY COMMENTS */
  6    22 
  6    23 
  6    24 /* each file in the database will have a model segment with the name
  6    25*   file_name.m (i.e. the files name plus a suffix of ".m")
  6    26*   the file_model structure is allocated at the base of the segment for a given file.
  6    27*   it contains an area with which all other structures in this include file are allocated.
  6    28*   these structures contain the information about which relations, foreign keys,
  6    29*   and attributes are members of this file. all lists are singly linked lists in
  6    30*   definition order. pointers to these structures are obtained by using the "pointer"
  6    31*   builtin function with arguments of the segment base pointer, and the
  6    32*   offset (bit (18)) relative to that pointer that is actually stored in
  6    33*   the file model itself. this is because pointer segment numbers are
  6    34*   per process dependent. the major lists pointed to by the file_model structure
  6    35*   are the list of relations in this file(each with a contained attribute list),
  6    36*   and the list of foreign keys whose parent relation resides in this file
  6    37*   (along with a participating attribute sublist, and the child relation list,
  6    38*   if they are also in this file) */
  6    39 
  6    40 dcl 1 file_model aligned based (fm_ptr),		/* base of segment */
  6    41     2 temporary bit (1) unal,				/* on if file not part of db. */
  6    42     2 procedures_present bit (1) unal,			/* on => ids procedures present */
  6    43     2 file_model_copy_good bit (1) unaligned,		/* on => <rel>.m file is the good copy */
  6    44     2 relation_copy_good bit (1) unaligned,		/* on => <rel> file is the good copy */
  6    45     2 reserved bit (32) unal,				/* reserved for future flags */
  6    46     2 max_tuples fixed bin (35),			/* max no. of tuples in file */
  6    47     2 num_blocks fixed bin (35),			/* number of blocks in file */
  6    48     2 num_buckets fixed bin (35),			/* number of buckets in file */
  6    49     2 pad_1 fixed bin (35),				/* for future use */
  6    50     2 pad_2 fixed bin (35),
  6    51     2 ratd_len fixed bin (21),			/* length of above */
  6    52     2 mratd_len fixed bin (21),			/* length of above */
  6    53     2 uatd_len fixed bin (21),			/* char. length of update attach desc. */
  6    54     2 latd_len fixed bin (21),			/* char. len. of attach desc. */
  6    55     2 sratd_len fixed bin (21),			/* char. length of above attach desc. */
  6    56     2 suatd_len fixed bin (21),			/* char. length of attach desc. */
  6    57     2 file_type unal fixed bin,			/* 1 => unblocked, 2 => blocked */
  6    58     2 block_size unal fixed bin,			/* no. pages in block */
  6    59     2 block_factor unal fixed bin,			/* no. tuple slots per block */
  6    60     2 bucket_density unal fixed bin,			/* no. of bucket headers per block, neg. => blocks per header */
  6    61     2 tuple_id_len unal fixed bin,			/* no. bits needed for local tuple id */
  6    62     2 num_rels unal fixed bin,			/* number of relations in file */
  6    63     2 num_links unal fixed bin,			/* number of links in file */
  6    64     2 num_children unal fixed bin,			/* count of all child_link_infos in this file */
  6    65     2 default_rbs (3) unal fixed bin (8),		/* file ring brackets when not MDBM-secured */
  6    66     2 rel_ptr unal bit (18),				/* to first of list of rel_infos */
  6    67     2 link_ptr unal bit (18),				/* to first in list of parent link_infos */
  6    68     2 children_ptr unal bit (18),			/* to list of all child_link_infos in this file model */
  6    69     2 cno_array_ptr unal bit (18),			/* pointer to array of data component numbers */
  6    70     2 fi_ptr unal bit (18),				/* offset to file_info in db_model */
  6    71     2 suatd_ptr unal bit (18),			/* offset of scope_update attach desc. */
  6    72     2 sratd_ptr unal bit (18),			/* offset of scope_retrieve attach desc. */
  6    73     2 latd_ptr unal bit (18),				/* offset of load attach desc. */
  6    74     2 uatd_ptr unal bit (18),				/* offset of update attach description for file */
  6    75     2 mratd_ptr unal bit (18),			/* offset of moniter-retrieve attach desc. */
  6    76     2 ratd_ptr unal bit (18),				/* offset of retrieve attach desc. */
  6    77     2 open_eu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  6    78     2 open_eu_err_path_ptr unal bit (18),
  6    79     2 open_eu_after_path_ptr unal bit (18),
  6    80     2 open_er_before_path_ptr unal bit (18),
  6    81     2 open_er_err_path_ptr unal bit (18),
  6    82     2 open_er_after_path_ptr unal bit (18),
  6    83     2 open_neu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  6    84     2 open_neu_err_path_ptr unal bit (18),
  6    85     2 open_neu_after_path_ptr unal bit (18),
  6    86     2 open_ner_before_path_ptr unal bit (18),
  6    87     2 open_ner_err_path_ptr unal bit (18),
  6    88     2 open_ner_after_path_ptr unal bit (18),
  6    89     2 open_pu_before_path_ptr unal bit (18),
  6    90     2 open_pu_err_path_ptr unal bit (18),
  6    91     2 open_pu_after_path_ptr unal bit (18),
  6    92     2 open_pr_before_path_ptr unal bit (18),
  6    93     2 open_pr_err_path_ptr unal bit (18),
  6    94     2 open_pr_after_path_ptr unal bit (18),
  6    95     2 open_cu_before_path_ptr unal bit (18),
  6    96     2 open_cu_err_path_ptr unal bit (18),
  6    97     2 open_cu_after_path_ptr unal bit (18),
  6    98     2 open_cr_before_path_ptr unal bit (18),
  6    99     2 open_cr_err_path_ptr unal bit (18),
  6   100     2 open_cr_after_path_ptr unal bit (18),
  6   101     2 close_before_path_ptr unal bit (18),
  6   102     2 close_err_path_ptr unal bit (18),
  6   103     2 close_after_path_ptr unal bit (18),
  6   104     2 unused_1 unal bit (18),				/* for future expansion */
  6   105     2 unused_2 unal bit (18),
  6   106     2 changer_ptr unal bit (18),			/* pointer to changer_id, changer_time structure */
  6   107     2 fm_area area (sys_info$max_seg_size - fixed (rel (addr (file_model.fm_area))) - 1);
  6   108 dcl  fm_ptr ptr;
  6   109 dcl  atd char (atd_len) based (atd_ptr);		/* attach description for each file ready mode */
  6   110 dcl  atd_ptr ptr;
  6   111 dcl  atd_len fixed bin;
  6   112 dcl 1 comp_no_array unal based (cna_ptr),		/* ordered array of data comp. nos. */
  6   113     2 ncomponents fixed bin,
  6   114     2 comp_no (ncomp_init refer (comp_no_array.ncomponents)) fixed bin;
  6   115 dcl  cna_ptr ptr;
  6   116 dcl  ncomp_init fixed bin;
  6   117 
  6   118 /* a rel_info structure contains information describing a relation.
  6   119*   a relation may only occur in one file, thus there is one rel_info
  6   120*   per relation per database, each stored in the file_model area for
  6   121*   the file that contains it. the list of rel_info's in this file
  6   122*   form a singly linked list in definition order.
  6   123*   the rel_info itself points to a list of the attributes it contains,
  6   124*   and to any parent_link or child_link info's that involve it in a foreign key */
  6   125 
  6   126 dcl 1 rel_info aligned based (ri_ptr),
  6   127     2 name char (32),				/* relation name */
  6   128     2 id  bit (36) aligned,				/* relation id number */
  6   129     2 hashed bit (1) unal,				/* on if hashed */
  6   130     2 duplicates bit (1) unal,			/* on if allow dup. hash fields */
  6   131     2 via_link bit (1) unal,				/* on if to be stored by parent */
  6   132     2 system bit (1) unal,				/* on if dont care how stored */
  6   133     2 indexed bit (1) unal,				/* on if secondary index */
  6   134     2 mrds_update bit (1) unal,			/* on if updateable by MRDS */
  6   135     2 mrds_retrieve bit (1) unal,			/* on if retrievable by MRDS */
  6   136     2 virtual bit (1) unal,				/* if virtual relation, mapped on IDS records */
  6   137     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  6   138     2 reserved bit (27) unal,				/* for future flags */
  6   139     2 num_attr unal fixed bin,			/* number of attributes (all levels) defined */
  6   140     2 num_links_child unal fixed bin,			/* no. links in which child */
  6   141     2 num_links_par unal fixed bin,			/* no. links_in which parent */
  6   142     2 max_attr_index_id unal fixed bin,			/* max index id used by attr in this rel or PLI */
  6   143     2 num_key_attrs unal fixed bin,			/* number of attributes in primary key for this rel */
  6   144     2 nvar_atts unal fixed bin,			/* no. varying len. attributes */
  6   145     2 n36_thds unal fixed bin,			/* no. of 36-bit threads */
  6   146     2 n27_thds unal fixed bin,			/* no of 27-bit threads */
  6   147     2 n18_thds unal fixed bin,			/* no of 18-bit threads */
  6   148     2 unused_3 unal fixed bin,			/* element that was never used */
  6   149     2 max_data_len fixed bin (35),			/* max length of data portion of tuple */
  6   150     2 avg_data_len fixed bin (35),			/* average length of tuple data portion */
  6   151     2 max_key_len fixed bin (35),			/* max key length if not hashed */
  6   152     2 var_offset fixed bin (35),			/* position of first varying attr. */
  6   153     2 max_tuples fixed bin (35),			/* max no. tuples if blocked file */
  6   154     2 fwd_thread unal bit (18),			/* offsset to next rel. in file */
  6   155     2 attr_ptr unal bit (18),				/* to attr. info */
  6   156     2 primary_key_index_id bit (36) aligned,		/* index id of the relation's primary key */
  6   157     2 clink_ptr unal bit (18),			/* offset to child info of link determining location */
  6   158     2 map_ptr unal bit (18),				/* pointer to mapping info if virtual rel. */
  6   159     2 sec_ind_ptr unal bit (18),			/* ptr to list of sec. ind. infos, init. not used */
  6   160     2 locator_proc_path_ptr unal bit (18),		/* proc to determ. location */
  6   161     2 link_before_path_ptr unal bit (18),		/* op. proc. paths and entries */
  6   162     2 link_err_path_ptr unal bit (18),
  6   163     2 link_after_path_ptr unal bit (18),
  6   164     2 unlk_before_path_ptr unal bit (18),
  6   165     2 unlk_err_path_ptr unal bit (18),
  6   166     2 unlk_after_path_ptr unal bit (18),
  6   167     2 str_before_path_ptr unal bit (18),
  6   168     2 str_err_path_ptr unal bit (18),
  6   169     2 str_after_path_ptr unal bit (18),
  6   170     2 del_before_path_ptr unal bit (18),
  6   171     2 del_err_path_ptr unal bit (18),
  6   172     2 del_after_path_ptr unal bit (18),
  6   173     2 mod_before_path_ptr unal bit (18),
  6   174     2 mod_err_path_ptr unal bit (18),
  6   175     2 mod_after_path_ptr unal bit (18),
  6   176     2 find_before_path_ptr unal bit (18),
  6   177     2 find_err_path_ptr unal bit (18),
  6   178     2 find_after_path_ptr unal bit (18),
  6   179     2 retr_before_path_ptr unal bit (18),
  6   180     2 retr_err_path_ptr unal bit (18),
  6   181     2 retr_after_path_ptr unal bit (18),
  6   182     2 unused_1 unal bit (18),				/* for future expansion */
  6   183     2 unused_2 unal bit (18),
  6   184     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  6   185 dcl  ri_ptr ptr;
  6   186 
  6   187 /* a attr_info structure contains information about an attribute in a given relation.
  6   188*   since attributes may appear in more than one relation, each occurence of an attribute
  6   189*   means that an attr_info for it will be put in that relations sublist of attributes.
  6   190*   the list is singly linked in definition order. the attr_info describes
  6   191*   the data it represents, and how that data is used during a database search. */
  6   192 dcl 1 attr_info aligned based (ai_ptr),			/* info for a single attr. in attr. list */
  6   193     2 name char (32),				/* name of attribute */
  6   194     2 key_attr bit (1) unal,				/* on if part of primary or hash key */
  6   195     2 index_attr bit (1) unal,			/* on if a secondary index */
  6   196     2 link_attr bit (1) unal,				/* on if participates in link */
  6   197     2 reserved bit (33) unal,
  6   198     2 index_id bit (36) aligned,			/* id of index if index attr. */
  6   199     2 defn_order unal fixed bin,			/* relative posit. in which defined */
  6   200     2 key_order unal fixed bin,			/* relative posit. in key */
  6   201     2 bit_offset fixed bin (35),			/* position in tuple */
  6   202     2 bit_length fixed bin (35),			/* length if fixed */
  6   203     2 link_child_cnt fixed bin,			/* number of uses of attr in child rel of link */
  6   204     2 link_par_cnt fixed bin,				/* number of uses of attr in parent rel of link */
  6   205     2 domain_ptr unal bit (18),			/* to domain info */
  6   206     2 rslt_ptr unal bit (18),				/* ptr to info for "result" clause */
  6   207     2 fwd_thread unal bit (18),			/* to next in list */
  6   208     2 changer_ptr unal bit (18) ;			/* pointer to changer_id and changer_time */
  6   209 dcl  ai_ptr ptr;
  6   210 
  6   211 /* a parent_link_info structure is the carrier of foreign key definition info.
  6   212*   each time a foreign key definition indicates a relation as it's parent,
  6   213*   that relation will get a parent_link_info put in a list of associated parent_link_info's.
  6   214*   a relation can be parent and/or child in any number of foreign keys.
  6   215*   the parent_link_info structure describes the foreign key, and also points
  6   216*   to a list of the attributes that participate in this foreign key.
  6   217*   (this could be from 1 up to all attributes in the relation)
  6   218*   the attr_list structures are in a singly linked list in definition order
  6   219*   for this purpose. also pointed to is a list of child_link_info's
  6   220*   that describe the child relations in this foreign key. since foreign keys
  6   221*   may span files, not all related child_link_info's have to be in this file's
  6   222*   model area. */
  6   223 dcl 1 parent_link_info aligned based (pli_ptr),		/* gen'l link info, appears in each area spanned by link parent */
  6   224     2 name char (32),				/* name of link */
  6   225     2 singular bit (1) unal,				/* on if system owned link */
  6   226     2 temp bit (1) unal,				/* on if temp. order */
  6   227     2 first bit (1) unal,				/* insertion indicators */
  6   228     2 last bit (1) unal,
  6   229     2 next bit (1) unal,
  6   230     2 prior bit (1) unal,
  6   231     2 sort_rel_name bit (1) unal,			/* sort -- relation name */
  6   232     2 sort_keys bit (1) unal,				/* sort -- defined keys */
  6   233     2 dup_first bit (1) unal,				/* duplicates first */
  6   234     2 dup_last bit (1) unal,				/* duplicates last */
  6   235     2 indexed bit (1) unal,				/* locate parent via index */
  6   236     2 hashed bit (1) unal,				/* locate parent via hashed primary key */
  6   237     2 thread_36 bit (1) unal,				/* thread size indicators */
  6   238     2 thread_27 bit (1) unal,
  6   239     2 thread_18 bit (1) unal,
  6   240     2 clustered bit (1) unal,				/* ON => cluster option specified for this link */
  6   241     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  6   242     2 reserved bit (19) unal,				/* reserved for future flags */
  6   243     2 index_id aligned bit (8),			/* id of index if indexed */
  6   244     2 thread_index unal fixed bin,			/* index to threads in parent */
  6   245     2 nsel_attr unal fixed bin,			/* no. attr. determ. parent */
  6   246     2 n_children unal fixed bin,			/* no. children in link */
  6   247     2 child_fn char (30),				/* file name for first child in list */
  6   248     2 parent_ptr unal bit (18),			/* to parent relation info in file model */
  6   249     2 child_ptr unal bit (18),			/* to list of child info ptrs */
  6   250     2 sel_attr_ptr unal bit (18),			/* to first in list of attr. determ. parent */
  6   251     2 fwd_thread unal bit (18),			/* thread to next parent link info in file */
  6   252     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  6   253     2 sort_before_path_ptr unal bit (18),		/* proc. paths and entries */
  6   254     2 sort_err_path_ptr unal bit (18),
  6   255     2 sort_after_path_ptr unal bit (18),
  6   256     2 srch_before_path_ptr unal bit (18),
  6   257     2 srch_err_path_ptr unal bit (18),
  6   258     2 srch_after_path_ptr unal bit (18),
  6   259     2 link_before_path_ptr unal bit (18),
  6   260     2 link_err_path_ptr unal bit (18),
  6   261     2 link_after_path_ptr unal bit (18),
  6   262     2 unlk_before_path_ptr unal bit (18),
  6   263     2 unlk_err_path_ptr unal bit (18),
  6   264     2 unlk_after_path_ptr unal bit (18),
  6   265     2 unused_1 unal bit (18),				/* for future expansion */
  6   266     2 unused_2 unal bit (18),
  6   267     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  6   268 dcl  pli_ptr ptr;
  6   269 
  6   270 /* a child_link_info structure is the counter part of a parent_link_info
  6   271*   for foreign key child relations. each time a relation is defined to be
  6   272*   a child in a foreign key, it's list of child_link_infos will be added to.
  6   273*   this list is singly linked in foreign key definition order.
  6   274*   the child_link_info points to a list of participating attributes from the
  6   275*   child relation by means of a singly linked list of attr_list structures
  6   276*   in definition order. the number of attributes in the parent attr_list
  6   277*   and the child attr_list lists are the same with corresponding attr_list
  6   278*   attributes having the same domain. all child_link_infos in this file
  6   279*   are on a seperately linked list. this may not include all
  6   280*   child_link_infos for foreign keys whose parent relation resides in this file,
  6   281*   since foreign keys may span files, and the child_link_info will
  6   282*   reside in the file containing it's associated relation_info. */
  6   283 dcl 1 child_link_info aligned based (cli_ptr),		/* in same files as children */
  6   284     2 link_name char (32),				/* name of foreign key involving parent relation for this child */
  6   285     2 mandatory bit (1) unal,				/* on if membership mandatory */
  6   286     2 fixed bit (1) unal,				/* on if membership fixed */
  6   287     2 optional bit (1) unal,				/* on if membership optional */
  6   288     2 auto bit (1) unal,				/* on if insertion automatic */
  6   289     2 manual bit (1) unal,				/* on if insertion manual */
  6   290     2 struct_const bit (1) unal,			/* on if membership constrained by attr. comp. */
  6   291     2 range_sel bit (1) unal,				/* on if range type selection */
  6   292     2 key_dup_first bit (1) unal,			/* sort key flags */
  6   293     2 key_dup_last bit (1) unal,
  6   294     2 key_null bit (1) unal,				/* on if null allowed */
  6   295     2 sel_system bit (1) unal,			/* selection criteria flags */
  6   296     2 sel_current bit (1) unal,
  6   297     2 sel_key bit (1) unal,
  6   298     2 sel_proc bit (1) unal,
  6   299     2 no_null bit (1) unal,				/* if null key values not allowed */
  6   300     2 reserved bit (21) unal,
  6   301     2 thread_index unal fixed bin,			/* index to thread in tuple */
  6   302     2 chain_len unal fixed bin,			/* no. "then-thru's" in selction crit. */
  6   303     2 n_sort_keys unal fixed bin,			/* no. attr. in sort key */
  6   304     2 n_sel_items unal fixed bin,			/* no. items to sel for link sel. */
  6   305     2 n_dup_prevs unal fixed bin,			/* no. attr. for dup prev. */
  6   306     2 link_fwd_fn char (30),				/* file name for next child info in link */
  6   307     2 parent_fn char (30),				/* file name for parent info */
  6   308     2 parent_ptr unal bit (18),			/* offset to parent link info */
  6   309     2 link_fwd_thread unal bit (18),			/* offset for next child in link */
  6   310     2 rel_info_ptr unal bit (18),			/* to corresponding rel info */
  6   311     2 dup_prev_ptr unal bit (18),			/* list of attrs. for dup. prev. */
  6   312     2 sel_ptr unal bit (18),				/* list of attr. for link sel. */
  6   313     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  6   314     2 child_fwd_thread unal bit (18),			/* pointer to next in list of all child_link_infos in this file */
  6   315     2 sort_key_ptr unal bit (18),			/* list of sort keys */
  6   316     2 chain_ptr unal bit (18),			/* to "then thru" list */
  6   317     2 sel_proc_path_ptr unal bit (18),			/* link selection proc. */
  6   318     2 link_before_path_ptr unal bit (18),		/* proc. paths and entries */
  6   319     2 link_err_path_ptr unal bit (18),
  6   320     2 link_after_path_ptr unal bit (18),
  6   321     2 unlk_before_path_ptr unal bit (18),
  6   322     2 unlk_err_path_ptr unal bit (18),
  6   323     2 unlk_after_path_ptr unal bit (18),
  6   324     2 srch_before_path_ptr unal bit (18),
  6   325     2 srch_err_path_ptr unal bit (18),
  6   326     2 srch_after_path_ptr unal bit (18),
  6   327     2 unused_1 unal bit (18),				/* for future expansion */
  6   328     2 unused_2 unal bit (18) ;
  6   329 dcl  cli_ptr ptr;
  6   330 
  6   331 /* the attr_list structure is associated with the parent_link_info
  6   332*   and child_link_info structures to represent by means of a singly linked list
  6   333*   the participating attributes from relations in a foreign key.
  6   334*   the parent_link_info has a list for the parent relation,
  6   335*   and the child_link_info has a list for the child relation.
  6   336*   the participating attributes are a subset(not necessary proper) of
  6   337*   those attributes contained in a relation definition.
  6   338*   there are equal numbers of attr_list structures in the parent and
  6   339*   child lists of the same foreign key. the corresponding attributes in these
  6   340*   lists must have the same domain. */
  6   341 dcl 1 attr_list aligned based (al_ptr),			/* general attr. list */
  6   342     2 attr_fn char (30),				/* file name for attr. */
  6   343     2 attr_ptr unal bit (18),				/* to attr info block */
  6   344     2 fwd_thread unal bit (18);			/* to next in list */
  6   345 dcl  al_ptr ptr;
  6   346 dcl 1 sort_key aligned based (sk_ptr),			/* entry in sort key list */
  6   347     2 ascend bit (1) unal,				/* ascending order */
  6   348     2 descend bit (1) unal,				/* descending order */
  6   349     2 reserved bit (34) unal,
  6   350     2 attr_ptr unal bit (18),				/* to attr info */
  6   351     2 fwd_thread unal bit (18);			/* to next in list */
  6   352 dcl  sk_ptr ptr;
  6   353 dcl 1 dup_prev aligned based (dp_ptr),			/* dup. prevention list entry */
  6   354     2 attr_ptr unal bit (18),				/* to attr info */
  6   355     2 fwd_thread unal bit (18);			/* to next in list */
  6   356 dcl  dp_ptr ptr;
  6   357 dcl 1 select_chain aligned based (sc_ptr),		/* "then thru" list entry */
  6   358     2 link_fn char (30),				/* file name for thru link */
  6   359     2 link_ptr unal bit (18),				/* to parent link info */
  6   360     2 parent_attr_ptr unal bit (18),			/* to parent ident. attr. list */
  6   361     2 comp_proc_path_ptr unal bit (18),			/* comparison procedure */
  6   362     2 comp_attr_fn char (30),				/* file name for comparison attr. */
  6   363     2 comp_attr_ptr unal bit (18),			/* to comparison attr list */
  6   364     2 fwd_thread unal bit (18);			/* to next in chain */
  6   365 dcl  sc_ptr ptr;
  6   366 
  6   367 /* END INCLUDE FILE mdbm_file_model.incl.pl1 */
  6   368 
  6   369 
     1014 
     1015 
  7     1 /*	BEGIN INCLUDE FILE		mrds_dsm_rel_block.incl.pl1
  7     2*
  7     3*   Created October, 1975 for release in MR 4.0
  7     4*
  7     5*   The relation_block contains the relation name and  the  attribute
  7     6*   names and access information
  7     7*
  7     8*   HISTORY
  7     9*
  7    10*   80-04-10 Spratt: changed to have version  number,  be  explicitly
  7    11*   .        based, use an automatic variable in the refer for num of
  7    12*   .        attributes,  add access flags for rel and attr's, remove
  7    13*   .        attr key flags. This is for the  first  Attribute  Level
  7    14*   .        Security version of MRDS.
  7    15*
  7    16*   81-01-14 Davids: increased submodel rel  and  attr  names  to  64
  7    17*   .        characters and made dsm_rel_name char  varying.  changed
  7    18*   .        access  bits  from  a  bit  string to individually named
  7    19*   .        flags.
  7    20**/
  7    21 
  7    22 dcl  relation_block_ptr ptr;
  7    23 dcl  rb_number_of_attributes fixed bin (35);
  7    24 dcl  RELATION_BLOCK_VERSION_1 fixed bin (35) internal static options (constant) init (1);
  7    25 
  7    26 dcl 1 relation_block based (relation_block_ptr),
  7    27 						/* Relation block */
  7    28     2 version fixed bin (35),
  7    29     2 dsm_rel_name char (64) varying,			/* Data submodel relation name */
  7    30     2 dm_rel_name char (32),				/* Data model relation name */
  7    31     2 rel_access unal,
  7    32       3 append bit (1),
  7    33       3 delete bit (1),
  7    34       3 null bit (1),
  7    35       3 mbz1 bit (33),
  7    36     2 no_rb_attributes fixed bin,			/* The number of attributes in this relation */
  7    37     2 attribute_info (rb_number_of_attributes refer (relation_block.no_rb_attributes)),
  7    38       3 dsm_attr_name char (64) varying,		/* Data submodel attribute name */
  7    39       3 attr_access unal,				/* Data submodel attribute flags */
  7    40         4 read bit (1),
  7    41         4 modify bit (1),
  7    42         4 null bit (1),
  7    43         4 mbz2 bit (33),				/* For future use */
  7    44       3 dm_attr_name char (32) varying,			/* Data model attribute name */
  7    45       3 dm_attr_flags,				/* Data model attribute flags */
  7    46         4 mbz3 bit (36);				/* For future use */
  7    47 
  7    48 /* 	END INCLUDE FILE 		mrds_dsm_rel_block.incl.pl1  */
  7    49 
     1016 
     1017 
  8     1 /* BEGIN INCLUDE FILE mrds_dsm_relation_names.incl.pl1 -- nsd 81/01/12 */
  8     2 
  8     3 /*
  8     4*This include file is for internal mrds use only. It  is  used  to
  8     5*return an array of submodel relation names.
  8     6*
  8     7*HISTORY
  8     8*
  8     9*81-01-12 Davids: written
  8    10*
  8    11*81-09-14 Davids: changed relation to char (32) from char (64). 64
  8    12*was  a  proposed  maximum  but  could not be implemented. Several
  8    13*modules would not compile when compiled with  -prefix  stringsize
  8    14*becuase they made assignments of the form char (32) = char (64).
  8    15**/
  8    16 
  8    17 dcl 1 mrds_dsm_relation_names based (mrds_dsm_relation_names_ptr),
  8    18     2 nrels fixed bin,
  8    19     2 relation (mrds_dsm_relation_names_nrels_alloc refer (mrds_dsm_relation_names.nrels)) char (32);
  8    20 
  8    21 dcl  mrds_dsm_relation_names_nrels_alloc fixed bin;
  8    22 
  8    23 dcl  mrds_dsm_relation_names_ptr ptr;
  8    24 
  8    25 /* END INCLUDE FILE mrds_dsm_relation_names.incl.pl1 */
  8    26 
     1018 
     1019 
  9     1 /*	BEGIN INCLUDE FILE		mrds_model_relations.incl.pl1
  9     2*
  9     3*   Created October, 1975 for release in MR 4.0					*/
  9     4 
  9     5 dcl 1 model_relations based (mr_ptr),			/* structure to return names of all relations in a model */
  9     6     2 nrels fixed bin (10),				/* number of relations */
  9     7     2 relation_name (num_relations_alloc refer (model_relations.nrels)) char (32); /* relation names */
  9     8 
  9     9 dcl  num_relations_alloc fixed bin (10);		/* number of relations in model for allocation purposes */
  9    10 
  9    11 dcl  mr_ptr ptr;
  9    12 
  9    13 /*	END INCLUDE FILE		mrds_model_relations.incl.pl1				*/
  9    14 
     1020 
     1021 
 10     1 /* BEGIN INCLUDE FILE mrds_path_info.incl.pl1 - -  Jim Gray 81-01-22 */
 10     2 
 10     3 /* HISTORY:
 10     4*
 10     5*   81-01-22 Jim Gray : originaly created for the dsl_$get_path_info interface,
 10     6*   a slight extension to the undocumented mrds_dsl_get_version$header.
 10     7*
 10     8**/
 10     9 
 10    10 /* DESCRIPTION:
 10    11*
 10    12*   This structure returns information about a relative pathname, given
 10    13*   to a pathname accepting mrds interface. The information returned
 10    14*   is the absolute pathname, plus in the case that
 10    15*   the relative path points to a mrds database or submodel
 10    16*   whether it is a model or a submodel, the mrds version of
 10    17*   the model or submodel, it's creator, and the time of creation.
 10    18*
 10    19**/
 10    20 
 10    21 
 10    22 declare 1 mrds_path_info aligned based (mrds_path_info_ptr),
 10    23         2 version fixed bin,				/* version number for this structure */
 10    24         2 absolute_path char (168),			/* the absolute path from the input relative path */
 10    25         2 type,
 10    26 	3 not_mrds bit (1) unal,			/* on => path not to model or submodel */
 10    27 	3 model bit (1) unal,			/* on => path to database model, thus possible .db suffix */
 10    28 	3 submodel bit (1) unal,			/* on => path to submodel, thus possible .dsm suffix */
 10    29 	3 mbz1 bit (33) unal,
 10    30         2 mrds_version fixed bin,			/* the mrds version number of the model or submodel */
 10    31         2 creator_id char (32),			/* the person.project.tag of the creator */
 10    32         2 creation_time fixed bin (71),			/* convert date to binary form of time model/submodel created */
 10    33         2 mbz2 bit (36) unal ;
 10    34 
 10    35 
 10    36 declare  mrds_path_info_ptr ptr ;
 10    37 
 10    38 declare  mrds_path_info_structure_version fixed bin init (1) int static options (constant) ;
 10    39 
 10    40 /* END  INCLUDE FILE mrds_path_info.incl.pl1 */
     1022 
     1023 
 11     1 /* BEGIN INCLUDE FILE mrds_authorization.incl.pl1 - - 81-01-20 Jim Gray */
 11     2 
 11     3 /* HISTORY:
 11     4*
 11     5*   81-01-20 Jim Gray : original created for the mmi_$get_authorization interface
 11     6*
 11     7**/
 11     8 
 11     9 /* DESCRIPTION:
 11    10*
 11    11*   this structure returns the callers user_class
 11    12*   either database administrator or normal user.
 11    13*   Note that these separate classes were used to allow
 11    14*   future expansion to the user classes, rather than
 11    15*   make them logical "not"'s of one another.
 11    16*   NOTE: a DBA is always also a normal user, thus if the caller
 11    17*   is a DBA, his normal_user bit will be on also.
 11    18*
 11    19**/
 11    20 
 11    21 
 11    22 declare 1 mrds_authorization aligned based (mrds_authorization_ptr),
 11    23         2 version fixed bin,				/* version number of this structure */
 11    24         2 administrator bit (1) unal,			/* caller is a DBA */
 11    25         2 normal_user bit (1) unal,			/* caller has no special priviledges */
 11    26         2 mbz bit (34) unal ;
 11    27 
 11    28 
 11    29 declare  mrds_authorization_ptr ptr ;			/* pointer for referring to the structure */
 11    30 
 11    31 declare  mrds_authorization_structure_version fixed bin init (1) int static options (constant) ;
 11    32 
 11    33 /* END INCLUDE FILE mrds_authorization.incl.pl1 */
     1024 
     1025 
 12     1 /* BEGIN INCLUDE FILE mrds_database_state.incl.pl1 - - 81-01-20 Jim Gray */
 12     2 
 12     3 /* HISTORY:
 12     4*
 12     5*   81-01-20 Jim Gray : original created for the mmi_$get_secured_status interface
 12     6*
 12     7**/
 12     8 
 12     9 /* DESCRIPTION:
 12    10*
 12    11*   This structure returns the database state (secured or unsecured)
 12    12*   for determining how commands and subroutines will behave for each case.
 12    13*   The secured bit was kept separate from the unsecured,
 12    14*   rather than it's logical "not", to allow for future extensibility
 12    15*   of database secured states.
 12    16*
 12    17**/
 12    18 
 12    19 
 12    20 declare 1 database_state aligned based (database_state_ptr),
 12    21         2 version fixed bin,				/* version number of this structure */
 12    22         2 unsecured bit (1) unal,			/* database not secured */
 12    23         2 secured bit (1) unal,			/* database has been secured */
 12    24         2 mbz bit (34) unal ;
 12    25 
 12    26 
 12    27 declare  database_state_ptr ptr ;			/* pointer for referring to the structure */
 12    28 
 12    29 declare  database_state_structure_version fixed bin init (1) int static options (constant) ;
 12    30 
 12    31 /* END INCLUDE FILE mrds_database_state.incl.pl1 */
     1026 
     1027 
     1028      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/16/86  1143.7  display_mrds_db_population.pl1    >special_ldd>install>MR12.0-1187>display_mrds_db_population.pl1
218          1    02/05/86  1416.4  mrds_start_transaction.incl.pl1   >ldd>include>mrds_start_transaction.incl.pl1
1-79         2    01/07/85  0900.0  dm_tm_modes.incl.pl1              >ldd>include>dm_tm_modes.incl.pl1
1-81         3    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
234          4    02/05/86  1416.4  mrds_finish_transaction.incl.pl1  >ldd>include>mrds_finish_transaction.incl.pl1
1012         5    10/16/86  1139.3  mdbm_db_model.incl.pl1            >special_ldd>install>MR12.0-1187>mdbm_db_model.incl.pl1
1014         6    10/16/86  1139.9  mdbm_file_model.incl.pl1          >special_ldd>install>MR12.0-1187>mdbm_file_model.incl.pl1
1016         7    10/14/83  1608.7  mrds_dsm_rel_block.incl.pl1       >ldd>include>mrds_dsm_rel_block.incl.pl1
1018         8    10/14/83  1609.0  mrds_dsm_relation_names.incl.pl1  >ldd>include>mrds_dsm_relation_names.incl.pl1
1020         9    10/14/83  1608.4  mrds_model_relations.incl.pl1     >ldd>include>mrds_model_relations.incl.pl1
1022        10    10/14/83  1608.8  mrds_path_info.incl.pl1           >ldd>include>mrds_path_info.incl.pl1
1024        11    10/14/83  1608.8  mrds_authorization.incl.pl1       >ldd>include>mrds_authorization.incl.pl1
1026        12    10/14/83  1608.8  mrds_database_state.incl.pl1      >ldd>include>mrds_database_state.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ALL_THE_ATTRIBUTES              000045 constant        fixed bin(17,0)          initial dcl 873 set ref 796* 799*
NULL_OFFSET                            constant        bit(18)                  initial unaligned dcl 966 ref 776
TM_NORMAL_MODE                  000060 constant        fixed bin(17,0)          initial dcl 2-15 set ref 1-99*
abs_path                        000144 automatic       char(200)                unaligned dcl 872 set ref 396* 398* 401 407 413 413
                                                                                  417 423* 432 462 507* 511 526 708
absolute_path             1            based           char(168)                level 2 dcl 10-22 ref 398
addr                                                   builtin function         dcl 1005 ref 1-123 1-123 690 690 723
administrator             1            based           bit(1)                   level 2 packed unaligned dcl 11-22 ref 501
ai_ptr                          000564 automatic       pointer                  dcl 6-209 set ref 776* 776* 780 784 792 796 799* 812
all_relations                   000226 automatic       bit(1)                   unaligned dcl 875 set ref 135* 304* 556 577
any_other                       000250 stack reference condition                dcl 887 ref 150
area_ptr                        000230 automatic       pointer                  dcl 876 set ref 133* 165* 166 336 394* 458* 479*
                                                                                  491* 633* 690 690 706* 736* 751* 818* 826* 866
                                                                                  867* 868*
arg                                    based           char                     unaligned dcl 877 set ref 193 275 275 279 279 283
                                                                                  286 323 338 384 394* 396
arg_count                       000232 automatic       fixed bin(17,0)          dcl 878 set ref 170* 176* 199 199* 199 306* 306 313*
                                                                                  325* 325 351 351* 351
arg_len                         000233 automatic       fixed bin(21,0)          dcl 879 set ref 176* 185 193 275 275 279 279 283 286
                                                                                  313* 318 323 335 338 384 394 394 396
arg_ptr                         000234 automatic       pointer                  dcl 880 set ref 176* 193 275 275 279 279 283 286
                                                                                  313* 323 338 384 394 396
args_finished                   000236 automatic       bit(1)                   unaligned dcl 881 set ref 171* 172 178* 186* 201*
                                                                                  284* 293* 315* 319* 362* 382* 400* 416* 431* 461*
                                                                                  475* 483* 495* 510* 524*
attr_info                              based           structure                level 1 dcl 6-192
attr_ptr                 24(18)        based           bit(18)                  level 2 packed unaligned dcl 6-126 ref 776
attribute_info           34            based           structure                array level 2 unaligned dcl 7-26
ave_tuples                      000237 automatic       fixed bin(35,0)          dcl 882 set ref 806* 807* 808*
bad_path                        000240 automatic       bit(1)                   unaligned dcl 883 set ref 503* 504* 516* 523
caller_name                     000000 constant        char(32)                 initial unaligned dcl 884 set ref 162* 4-115* 846*
                                                                                  867*
cleanup                         000242 stack reference condition                dcl 886 ref 145
code                                   parameter       fixed bin(35,0)          dcl 843 set ref 839 846*
com_err_                        000040 constant        entry                    external dcl 888 ref 4-115 417 846
condition_info                         based           structure                level 1 dcl 3-14
condition_name            3     000110 automatic       varying char(32)         level 2 dcl 1-77 set ref 1-124 1-129 1-129
continue_to_signal_             000010 constant        entry                    external dcl 1-61 ref 1-137
cu_$af_arg_count                000042 constant        entry                    external dcl 889 ref 139
cu_$arg_ptr                     000044 constant        entry                    external dcl 890 ref 176 313
database_state                         based           structure                level 1 dcl 12-20
database_state_ptr              000600 automatic       pointer                  dcl 12-27 set ref 479* 489
database_state_structure_version
                                000060 constant        fixed bin(17,0)          initial dcl 12-29 set ref 479*
db_info_ptr                     000552 automatic       pointer                  dcl 994 set ref 454* 458* 471 563 619 640 684 767
                                                                                  816
db_model                               based           structure                level 1 dcl 5-72
db_path                         000256 automatic       char(168)                unaligned dcl 892 set ref 407* 428* 458 458 462 473*
                                                                                  476 484 491 491 496 516 516 526 621* 642* 675* 676
                                                                                  684* 692 724 726 732* 747*
db_type_flags             0(18)        based           structure                level 2 packed unaligned dcl 5-72
dbm_ptr                         000556 automatic       pointer                  dcl 5-106 set ref 131* 216 473* 479* 569 674 675*
                                                                                  690* 856 857* 858*
discard                         000330 automatic       fixed bin(35,0)          dcl 893 set ref 857* 867*
dm_attr_name             56            based           varying char(32)         array level 3 dcl 7-26 ref 784
dm_error_$bj_journal_full       000030 external static fixed bin(35,0)          dcl 4-52 ref 1-132
dm_error_$lock_deadlock         000032 external static fixed bin(35,0)          dcl 4-53 ref 4-78 1-126
dm_error_$no_current_transaction
                                000012 external static fixed bin(35,0)          dcl 1-62 ref 1-90
dm_rel_name              22            based           char(32)                 level 2 packed unaligned dcl 7-26 ref 641 649
done                            000331 automatic       bit(1)                   unaligned dcl 907 set ref 591* 593 598* 602*
dsm_attr_name            34            based           varying char(64)         array level 3 dcl 7-26 ref 786
dup_count                       000334 automatic       fixed bin(35,0)          dcl 914 set ref 796* 799* 806 807
empty                                                  builtin function         dcl 1005 ref 166
error_code                      000335 automatic       fixed bin(35,0)          dcl 915 set ref 130* 139* 140 140* 143* 155* 156*
                                                                                  162* 163 163* 176* 177 179* 187* 188* 207 210*
                                                                                  211* 232 285* 286* 294* 295* 313* 314 316* 320*
                                                                                  321* 361 363* 364* 383* 384* 394* 399 401* 413*
                                                                                  415 417* 428* 430 432* 443 458* 460 462* 469 473*
                                                                                  474 476* 479* 482 484* 491* 494 496* 507* 509 511*
                                                                                  525* 526* 575 621* 633* 635 635* 642* 675* 676
                                                                                  676* 690* 692 692* 706* 708 708* 724* 726 726*
                                                                                  732* 734 734* 736* 738 738* 740* 742 742* 747* 749
                                                                                  749* 751* 753 753* 755* 757 757* 796* 799* 802
                                                                                  802* 818* 820 820* 823* 826* 828 828* 831* 833
                                                                                  833*
error_table_$bad_arg            000074 external static fixed bin(35,0)          dcl 916 ref 187 320
error_table_$badopt             000076 external static fixed bin(35,0)          dcl 917 ref 285
error_table_$noarg              000100 external static fixed bin(35,0)          dcl 918 ref 210 294 363
error_table_$not_act_fnc        000102 external static fixed bin(35,0)          dcl 919 ref 140
error_table_$wrong_no_of_args   000104 external static fixed bin(35,0)          dcl 920 ref 155
expand_pathname_                000106 constant        entry                    external dcl 921 ref 507
file_model                             based           structure                level 1 dcl 6-40
file_model_name                 000336 automatic       char(32)                 unaligned dcl 922 set ref 620* 621* 641* 642*
find_condition_info_            000014 constant        entry                    external dcl 1-64 ref 1-123
fm_ptr                          000560 automatic       pointer                  dcl 6-108 set ref 621* 622 624 624 642* 643 645 645
                                                                                  776 812
found                           000346 automatic       bit(1)                   unaligned dcl 923 set ref 579* 590* 598* 605 611
                                                                                  781* 782 785* 791* 795
fwd_thread               20            based           bit(18)                  level 2 packed unaligned dcl 6-192 ref 812
get_temp_segment_               000110 constant        entry                    external dcl 924 ref 162
hcs_$initiate                   000112 constant        entry                    external dcl 926 ref 621 642
i                               000347 automatic       fixed bin(17,0)          dcl 927 set ref 575* 578 586 643 643*
id                       10            based           bit(36)                  level 2 dcl 6-126 ref 625 646
index_attr               10(01)        based           bit(1)                   level 2 packed unaligned dcl 6-192 ref 780
index_id                 11            based           bit(36)                  level 2 dcl 6-192 set ref 796* 799*
index_name                      000350 automatic       char(32)                 unaligned dcl 928 set ref 786* 792* 802 808*
indx_info                       000360 automatic       structure                level 1 unaligned dcl 929 set ref 723
info_ptr                        000402 automatic       pointer                  dcl 951 set ref 723* 724*
info_version                    000360 automatic       fixed bin(17,0)          initial level 2 dcl 929 set ref 929*
ioa_                            000114 constant        entry                    external dcl 952 ref 423 563 565 605 684 763 767 772
                                                                                  808
j                               000404 automatic       fixed bin(17,0)          dcl 953 set ref 578* 592* 595 597 600 600* 600 614
                                                                                  615 620 622 622 631 633 633 635
k                               000405 automatic       fixed bin(17,0)          dcl 954 set ref 782* 784 786*
last_relation_ptr               000406 automatic       pointer                  dcl 955 set ref 305* 343 345 346*
last_relation_seen              000410 automatic       bit(1)                   unaligned dcl 956 set ref 302* 311 315* 319* 324*
                                                                                  353*
long_format                     000411 automatic       bit(1)                   unaligned dcl 957 set ref 134* 275* 279* 563 763
message                                parameter       char                     unaligned dcl 844 set ref 839 846*
mftxn_code                      000142 automatic       fixed bin(35,0)          dcl 4-54 set ref 232* 4-62* 4-65 4-68* 4-69 4-78
                                                                                  4-115 4-115* 1-126* 1-132*
mftxn_temp_code                 000143 automatic       fixed bin(35,0)          dcl 4-55 set ref 4-71* 4-72 4-72* 4-82* 4-83 4-85*
                                                                                  4-86 4-86* 4-96* 4-97 4-99* 4-100 4-100* 4-109*
                                                                                  4-110 4-110*
mode                            000412 automatic       fixed bin(17,0)          initial dcl 958 set ref 473* 675* 958*
model                    53(01)        based           bit(1)                   level 3 packed unaligned dcl 10-22 ref 407 454 504
                                                                                  595 613 670
model_rel_name                  000413 automatic       char(32)                 unaligned dcl 959 set ref 615* 649* 724* 732* 734
                                                                                  738 742 747* 749 753 757
model_relations                        based           structure                level 1 unaligned dcl 9-5
mr_ptr                          000572 automatic       pointer                  dcl 9-11 set ref 595 614 615 620 622 622 643 643
                                                                                  690* 696
mrds_authorization                     based           structure                level 1 dcl 11-22
mrds_authorization_ptr          000576 automatic       pointer                  dcl 11-29 set ref 491* 501
mrds_authorization_structure_version
                                000060 constant        fixed bin(17,0)          initial dcl 11-31 set ref 491*
mrds_dm_authorization$get_user_class
                                000046 constant        entry                    external dcl 894 ref 491
mrds_dm_close                   000052 constant        entry                    external dcl 900 ref 857
mrds_dm_db_secured$get_secured_status
                                000050 constant        entry                    external dcl 897 ref 479
mrds_dm_get_relations           000054 constant        entry                    external dcl 901 ref 690
mrds_dm_open                    000056 constant        entry                    external dcl 903 ref 473 675
mrds_dm_secured_submodel        000060 constant        entry                    external dcl 905 ref 516
mrds_dsl_get_version$get_path_info
                                000116 constant        entry                    external dcl 960 ref 394 458
mrds_dsm_close$force            000072 constant        entry                    external dcl 912 ref 862
mrds_dsm_get_relation_names     000070 constant        entry                    external dcl 911 ref 706
mrds_dsm_open$read              000062 constant        entry                    external dcl 908 ref 413
mrds_dsm_read_header$db_path    000064 constant        entry                    external dcl 909 ref 428
mrds_dsm_read_relation          000066 constant        entry                    external dcl 910 ref 633
mrds_dsm_relation_names                based           structure                level 1 unaligned dcl 8-17
mrds_dsm_relation_names_ptr     000570 automatic       pointer                  dcl 8-23 set ref 597 631 633 633 635 706* 712
mrds_error_$duplicate_opt       000120 external static fixed bin(35,0)          dcl 962 ref 383
mrds_error_$inc_secure_open     000122 external static fixed bin(35,0)          dcl 963 ref 525
mrds_error_$no_model_rel        000124 external static fixed bin(35,0)          dcl 964 set ref 622* 643*
mrds_path_info                         based           structure                level 1 dcl 10-22
mrds_path_info_ptr              000574 automatic       pointer                  dcl 10-36 set ref 214 394* 396 398 407 423 454 454
                                                                                  504 568 595 613 670 722 782
mrds_path_info_structure_version
                                000060 constant        fixed bin(17,0)          initial dcl 10-38 set ref 394* 458*
mrds_version             54            based           fixed bin(17,0)          level 2 dcl 10-22 set ref 214 423* 471 563 568 619
                                                                                  640 684* 722 767 816
mstxn_code                      000100 automatic       fixed bin(35,0)          dcl 1-65 set ref 1-83* 1-89* 1-90 1-99* 1-140 1-140*
                                                                                  4-90* 4-104* 1-137*
mstxn_condition_info            000110 automatic       structure                level 1 unaligned dcl 1-77 set ref 1-123 1-123
mstxn_retries                   000101 automatic       fixed bin(17,0)          dcl 1-66 set ref 1-88* 4-78 4-81* 4-81
mstxn_temp_code                 000102 automatic       fixed bin(35,0)          dcl 1-67 set ref 1-109* 1-110 1-110* 1-123*
mstxn_transactions_needed       000103 automatic       bit(1)                   dcl 1-68 set ref 214* 216* 1-86
mstxn_txn_id                    000105 automatic       bit(36)                  dcl 1-70 set ref 137* 1-84* 1-89* 1-93 1-94* 1-99*
                                                                                  1-100 4-60 4-68* 4-71* 4-72* 4-82* 4-85* 4-86*
                                                                                  4-96* 4-99* 4-100* 4-109* 4-110* 4-114* 1-107
                                                                                  1-109* 1-110* 1-121
name                      3            based           char                     level 2 in structure "relation" packed unaligned
                                                                                  dcl 1006 in procedure "dmdp" set ref 338* 598 605*
name                                   based           char(32)                 level 2 in structure "attr_info" dcl 6-192
                                                                                  in procedure "dmdp" ref 784 792
name_length               2            based           fixed bin(21,0)          level 2 dcl 1006 set ref 336* 337* 338 598 605 605
nargs                           000423 automatic       fixed bin(17,0)          dcl 965 set ref 139* 154 199 351
next                                   based           pointer                  level 2 dcl 1006 set ref 342* 345* 588
no_rb_attributes         33            based           fixed bin(17,0)          level 2 dcl 7-26 ref 782
non_null_recs             6     000360 automatic       fixed bin(34,0)          level 2 dcl 929 set ref 728
nrels                                  based           fixed bin(10,0)          level 2 in structure "model_relations" dcl 9-5
                                                                                  in procedure "dmdp" ref 696
nrels                                  based           fixed bin(17,0)          level 2 in structure "mrds_dsm_relation_names"
                                                                                  dcl 8-17 in procedure "dmdp" ref 712
null                                                   builtin function         dcl 1005 ref 131 133 913 1-123 1-123 305 342 343 396
                                                                                  622 643 674 740 740 755 755 856 858 866 868
num_tuples                      000424 automatic       fixed bin(35,0)          dcl 967 set ref 728* 740* 755* 763* 767* 772* 806
                                                                                  806 807 807
number_of_relations             000425 automatic       fixed bin(17,0)          dcl 968 set ref 556 600 696* 712*
path_seen                       000426 automatic       bit(1)                   unaligned dcl 969 set ref 136* 209 292 378 390*
ptr                                                    builtin function         dcl 1005 ref 624 645 776 812
rel                                                    builtin function         dcl 1005 ref 776
rel_id                          000432 automatic       bit(36)                  dcl 978 set ref 625* 646*
rel_info                               based           structure                level 1 dcl 6-126
rel_name                        000433 automatic       char(64)                 unaligned dcl 979 set ref 595* 597* 598 614* 631*
                                                                                  726 763* 767* 772* 820 828 833
rel_opening_id                  000453 automatic       bit(36)                  dcl 980 set ref 732* 736* 747* 751* 823* 831*
rel_ptr                  20(27)        based           bit(18)                  level 2 packed unaligned dcl 6-40 ref 624 645
relation                               based           structure                level 1 unaligned dcl 1006 in procedure "dmdp" set
                                                                                  ref 336
relation                  1            based           char(32)                 array level 2 in structure "mrds_dsm_relation_names"
                                                                                  packed unaligned dcl 8-17 in procedure "dmdp" ref
                                                                                  597 631 633 633 635
relation_block                         based           structure                level 1 unaligned dcl 7-26
relation_block_ptr              000566 automatic       pointer                  dcl 7-22 set ref 633* 641 649 782 784 786
relation_count                  000454 automatic       fixed bin(17,0)          dcl 981 set ref 556* 558* 575
relation_cursor_ptr             000430 automatic       pointer                  dcl 971 set ref 736* 740* 751* 755* 796* 799* 818*
                                                                                  826*
relation_id                     000427 automatic       bit(36)                  initial dcl 970 set ref 970*
relation_list_length            000455 automatic       fixed bin(17,0)          dcl 982 set ref 307* 347* 347 558
relation_list_ptr               000456 automatic       pointer                  dcl 983 set ref 305* 343* 586
relation_manager_$close         000140 constant        entry                    external dcl 977 ref 831
relation_manager_$create_cursor 000126 constant        entry                    external dcl 972 ref 751
relation_manager_$destroy_cursor
                                000130 constant        entry                    external dcl 973 ref 826
relation_manager_$get_count     000132 constant        entry                    external dcl 974 ref 755
relation_manager_$get_duplicate_key_count
                                000134 constant        entry                    external dcl 975 ref 799
relation_manager_$open          000136 constant        entry                    external dcl 976 ref 747
relation_name             1            based           char(32)                 array level 2 packed unaligned dcl 9-5 ref 595 614
                                                                                  615 620 622 622 643 643
relation_name_length_init       000460 automatic       fixed bin(21,0)          dcl 984 set ref 335* 336 336 337
relation_ptr                    000462 automatic       pointer                  dcl 985 set ref 336* 337 338 342 343 345 346 586*
                                                                                  588* 588 598 605
release_temp_segment_           000142 constant        entry                    external dcl 986 ref 867
ri_ptr                          000562 automatic       pointer                  dcl 6-185 set ref 624* 625 645* 646 776
rtrim                                                  builtin function         dcl 1005 ref 401 413 413 417 432 458 458 462 462 476
                                                                                  484 491 491 496 511 516 516 526 526 620 622 622
                                                                                  633 633 641 643 643 676 692 708 724 726 726 734
                                                                                  738 742 749 753 757 802 820 828
secured                   1(01)        based           bit(1)                   level 2 packed unaligned dcl 12-20 ref 489
sm_dir                          000464 automatic       char(168)                unaligned dcl 988 set ref 507* 516*
sm_name                         000536 automatic       char(32)                 unaligned dcl 989 set ref 507* 516*
some_relation_seen              000546 automatic       bit(1)                   unaligned dcl 990 set ref 303* 331* 361
submodel                 53(02)        based           bit(1)                   level 3 packed unaligned dcl 10-22 ref 782
submodel_iocb_ptr               000332 automatic       pointer                  initial dcl 913 set ref 413* 428* 633* 706* 862*
                                                                                  913*
submodel_open                   000547 automatic       bit(1)                   unaligned dcl 991 set ref 132* 422* 861 863*
substr                                                 builtin function         dcl 1005 ref 193 323 407
sys_info$max_seg_size           000144 external static fixed bin(35,0)          dcl 992 ref 166
temp_seg_ptr                    000550 automatic       pointer                  dcl 993 set ref 162* 165
transaction_manager_$abandon_txn
                                000016 constant        entry                    external dcl 1-72 ref 4-72 4-86 4-100 4-110 1-110
transaction_manager_$abort_txn  000020 constant        entry                    external dcl 1-73 ref 4-71 4-85 4-99 4-109 1-109
transaction_manager_$begin_txn  000022 constant        entry                    external dcl 1-74 ref 1-99
transaction_manager_$commit_txn 000034 constant        entry                    external dcl 4-56 ref 4-68
transaction_manager_$get_current_txn_id
                                000024 constant        entry                    external dcl 1-75 ref 1-89
transaction_manager_$handle_conditions
                                000026 constant        entry                    external dcl 1-76 ref 1-135
transaction_manager_$rollback_txn
                                000036 constant        entry                    external dcl 4-57 ref 4-82 4-96
transactions_needed       0(34)        based           bit(1)                   level 3 packed unaligned dcl 5-72 ref 216
type                     53            based           structure                level 2 in structure "mrds_path_info" dcl 10-22
                                                                                  in procedure "dmdp"
type                      1     000360 automatic       fixed bin(17,0)          initial level 2 in structure "indx_info" dcl 929
                                                                                  in procedure "dmdp" set ref 929*
user_started_transaction        000104 automatic       bit(1)                   dcl 1-69 set ref 1-92* 1-98* 4-60
user_transaction_id             000106 automatic       bit(36)                  dcl 1-71 set ref 1-93* 1-100*
vfile                           000554 automatic       bit(1)                   unaligned dcl 997 set ref 569* 571* 731 796 817
vfile_relmgr_$close             000160 constant        entry                    external dcl 1003 ref 823
vfile_relmgr_$create_cursor     000146 constant        entry                    external dcl 998 ref 736
vfile_relmgr_$destroy_cursor    000150 constant        entry                    external dcl 999 ref 818
vfile_relmgr_$get_count         000152 constant        entry                    external dcl 1000 ref 740
vfile_relmgr_$get_duplicate_key_count
                                000154 constant        entry                    external dcl 1001 ref 796
vfile_relmgr_$open              000156 constant        entry                    external dcl 1002 ref 732
vfile_status_                   000162 constant        entry                    external dcl 1004 ref 724
vfile_type                0(35)        based           bit(1)                   level 3 packed unaligned dcl 5-72 ref 569
work_area                              based           area                     dcl 995 set ref 166* 336 690 690

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
HIGHEST_MODE                           internal static fixed bin(17,0)          initial dcl 2-12
LOWEST_MODE                            internal static fixed bin(17,0)          initial dcl 2-12
RELATION_BLOCK_VERSION_1               internal static fixed bin(35,0)          initial dcl 7-24
TM_NEVER_WRITE_MODE                    internal static fixed bin(17,0)          initial dcl 2-18
TM_READ_ONLY_MODE                      internal static fixed bin(17,0)          initial dcl 2-17
TM_STATISTICAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-16
TM_TEST_NEVER_WRITE_MODE               internal static fixed bin(17,0)          initial dcl 2-22
TM_TEST_NORMAL_MODE                    internal static fixed bin(17,0)          initial dcl 2-19
TM_TEST_READ_ONLY_MODE                 internal static fixed bin(17,0)          initial dcl 2-21
TM_TEST_STATISTICAL_MODE               internal static fixed bin(17,0)          initial dcl 2-20
al_ptr                                 automatic       pointer                  dcl 6-345
alloc_length                           internal static fixed bin(35,0)          dcl 5-222
atd                                    based           char                     unaligned dcl 6-109
atd_len                                automatic       fixed bin(17,0)          dcl 6-111
atd_ptr                                automatic       pointer                  dcl 6-110
attr_list                              based           structure                level 1 dcl 6-341
changer                                based           structure                level 1 packed unaligned dcl 5-251
changer_ptr                            automatic       pointer                  dcl 5-256
child_link_info                        based           structure                level 1 dcl 6-283
cli_ptr                                automatic       pointer                  dcl 6-329
cna_ptr                                automatic       pointer                  dcl 6-115
comp_no_array                          based           structure                level 1 packed unaligned dcl 6-112
condition_info_ptr                     automatic       pointer                  dcl 3-10
condition_info_version_1               internal static fixed bin(17,0)          initial dcl 3-30
constant                               based           structure                level 1 unaligned dcl 5-216
constant_ptr                           automatic       pointer                  dcl 5-220
di_ptr                                 automatic       pointer                  dcl 5-155
domain_info                            based           structure                level 1 dcl 5-125
dp_ptr                                 automatic       pointer                  dcl 6-356
dup_prev                               based           structure                level 1 dcl 6-353
error_table_$null_info_ptr             external static fixed bin(35,0)          dcl 1-63
fi_ptr                                 automatic       pointer                  dcl 5-119
file_info                              based           structure                level 1 dcl 5-113
fixed                                                  builtin function         dcl 1005
message_str                            based           structure                level 1 packed unaligned dcl 5-259
message_str_len                        automatic       fixed bin(17,0)          dcl 5-269
message_str_ptr                        automatic       pointer                  dcl 5-267
mrds_dsm_relation_names_nrels_alloc    automatic       fixed bin(17,0)          dcl 8-21
ncomp_init                             automatic       fixed bin(17,0)          dcl 6-116
num_relations_alloc                    automatic       fixed bin(10,0)          dcl 9-9
parent_link_info                       based           structure                level 1 dcl 6-223
path_entry                             based           structure                level 1 packed unaligned dcl 5-172
path_entry_ptr                         automatic       pointer                  dcl 5-177
pli_ptr                                automatic       pointer                  dcl 6-268
rb_number_of_attributes                automatic       fixed bin(35,0)          dcl 7-23
sc_ptr                                 automatic       pointer                  dcl 6-365
select_chain                           based           structure                level 1 dcl 6-357
sk_ptr                                 automatic       pointer                  dcl 6-352
sort_key                               based           structure                level 1 dcl 6-346
stack_item                             based           structure                level 1 unaligned dcl 5-206
stack_item_ptr                         automatic       pointer                  dcl 5-212
ua_ptr                                 automatic       pointer                  dcl 5-165
unreferenced_attribute                 based           structure                level 1 dcl 5-159
version_status                         based           structure                level 1 packed unaligned dcl 5-232
version_status_ptr                     automatic       pointer                  dcl 5-246

NAMES DECLARED BY EXPLICIT CONTEXT.
check_secured_view              003242 constant        entry                    internal dcl 448 ref 443
clean_up                        007545 constant        entry                    internal dcl 851 ref 147 229
display_db_status               004302 constant        entry                    internal dcl 541 ref 225
display_mrds_db_population      001104 constant        entry                    external dcl 27
display_relation_status         005665 constant        entry                    internal dcl 719 ref 656
dmdbp                           001074 constant        entry                    external dcl 27
dmdp                            001064 constant        entry                    external dcl 27
error                           007477 constant        entry                    internal dcl 839 ref 140 156 163 179 188 211 1-140
                                                                                  286 295 316 321 364 384 401 432 462 476 484 496
                                                                                  511 526 622 635 643 676 692 708 726 734 738 742
                                                                                  749 753 757 802 820 828 833
exit                            001573 constant        label                    dcl 229 set ref 847
get_relation_info               005316 constant        entry                    internal dcl 664 ref 550
mftxn_check_code                001610 constant        label                    dcl 4-65 ref 1-127 1-133
mftxn_exit                      002030 constant        label                    dcl 4-115 ref 4-63
mstxn_any_other                 002111 constant        entry                    internal dcl 1-116 ref 150
mstxn_cleanup                   002057 constant        entry                    internal dcl 1-102 ref 146
mstxn_exit                      001551 constant        label                    dcl 1-140 ref 1-86 1-95 4-91 4-105
process_control_arg             002217 constant        entry                    internal dcl 264 ref 193
process_path_arg                002565 constant        entry                    internal dcl 371 ref 195
restore_significant_data        002215 constant        entry                    internal dcl 253 ref 4-77
should_rollback                 002206 constant        entry                    internal dcl 241 ref 4-94

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     10574       10760    7646       10604
Length     11574    7646       164         600     726           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
dmdp                                783 external procedure  is an external procedure.  
on unit on line 145                  76 on unit               
on unit on line 150                  82 on unit               
mstxn_cleanup                           internal procedure  shares stack frame of on unit on line 145.  
mstxn_any_other                         internal procedure  shares stack frame of on unit on line 150.  
should_rollback                         internal procedure  shares stack frame of external procedure dmdp.  
restore_significant_data                internal procedure  shares stack frame of external procedure dmdp.  
process_control_arg                     internal procedure  shares stack frame of external procedure dmdp.  
process_path_arg                        internal procedure  shares stack frame of external procedure dmdp.  
check_secured_view                      internal procedure  shares stack frame of external procedure dmdp.  
display_db_status                       internal procedure  shares stack frame of external procedure dmdp.  
get_relation_info                       internal procedure  shares stack frame of external procedure dmdp.  
display_relation_status                 internal procedure  shares stack frame of external procedure dmdp.  
error                                84 internal procedure  is called during a stack extension.  
clean_up                             84 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
dmdp                     000100 mstxn_code                  dmdp
                         000101 mstxn_retries               dmdp
                         000102 mstxn_temp_code             dmdp
                         000103 mstxn_transactions_needed   dmdp
                         000104 user_started_transaction    dmdp
                         000105 mstxn_txn_id                dmdp
                         000106 user_transaction_id         dmdp
                         000110 mstxn_condition_info        dmdp
                         000142 mftxn_code                  dmdp
                         000143 mftxn_temp_code             dmdp
                         000144 abs_path                    dmdp
                         000226 all_relations               dmdp
                         000230 area_ptr                    dmdp
                         000232 arg_count                   dmdp
                         000233 arg_len                     dmdp
                         000234 arg_ptr                     dmdp
                         000236 args_finished               dmdp
                         000237 ave_tuples                  dmdp
                         000240 bad_path                    dmdp
                         000256 db_path                     dmdp
                         000330 discard                     dmdp
                         000331 done                        dmdp
                         000332 submodel_iocb_ptr           dmdp
                         000334 dup_count                   dmdp
                         000335 error_code                  dmdp
                         000336 file_model_name             dmdp
                         000346 found                       dmdp
                         000347 i                           dmdp
                         000350 index_name                  dmdp
                         000360 indx_info                   dmdp
                         000402 info_ptr                    dmdp
                         000404 j                           dmdp
                         000405 k                           dmdp
                         000406 last_relation_ptr           dmdp
                         000410 last_relation_seen          dmdp
                         000411 long_format                 dmdp
                         000412 mode                        dmdp
                         000413 model_rel_name              dmdp
                         000423 nargs                       dmdp
                         000424 num_tuples                  dmdp
                         000425 number_of_relations         dmdp
                         000426 path_seen                   dmdp
                         000427 relation_id                 dmdp
                         000430 relation_cursor_ptr         dmdp
                         000432 rel_id                      dmdp
                         000433 rel_name                    dmdp
                         000453 rel_opening_id              dmdp
                         000454 relation_count              dmdp
                         000455 relation_list_length        dmdp
                         000456 relation_list_ptr           dmdp
                         000460 relation_name_length_init   dmdp
                         000462 relation_ptr                dmdp
                         000464 sm_dir                      dmdp
                         000536 sm_name                     dmdp
                         000546 some_relation_seen          dmdp
                         000547 submodel_open               dmdp
                         000550 temp_seg_ptr                dmdp
                         000552 db_info_ptr                 dmdp
                         000554 vfile                       dmdp
                         000556 dbm_ptr                     dmdp
                         000560 fm_ptr                      dmdp
                         000562 ri_ptr                      dmdp
                         000564 ai_ptr                      dmdp
                         000566 relation_block_ptr          dmdp
                         000570 mrds_dsm_relation_names_ptr dmdp
                         000572 mr_ptr                      dmdp
                         000574 mrds_path_info_ptr          dmdp
                         000576 mrds_authorization_ptr      dmdp
                         000600 database_state_ptr          dmdp

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this
call_int_other      return_mac          tra_ext_1           enable_op           shorten_stack       ext_entry
int_entry           int_entry_desc      trunc_fx2           divide_fx2          op_alloc_           op_empty_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      continue_to_signal_           cu_$af_arg_count              cu_$arg_ptr
expand_pathname_              find_condition_info_          get_temp_segment_             hcs_$initiate
ioa_                          mrds_dm_authorization$get_user_class                        mrds_dm_close
mrds_dm_db_secured$get_secured_status                       mrds_dm_get_relations         mrds_dm_open
mrds_dm_secured_submodel      mrds_dsl_get_version$get_path_info                          mrds_dsm_close$force
mrds_dsm_get_relation_names   mrds_dsm_open$read            mrds_dsm_read_header$db_path  mrds_dsm_read_relation
relation_manager_$close       relation_manager_$create_cursor
relation_manager_$destroy_cursor                            relation_manager_$get_count
relation_manager_$get_duplicate_key_count                   relation_manager_$open        release_temp_segment_
transaction_manager_$abandon_txn                            transaction_manager_$abort_txn
transaction_manager_$begin_txn                              transaction_manager_$commit_txn
transaction_manager_$get_current_txn_id                     transaction_manager_$handle_conditions
transaction_manager_$rollback_txn                           vfile_relmgr_$close           vfile_relmgr_$create_cursor
vfile_relmgr_$destroy_cursor  vfile_relmgr_$get_count       vfile_relmgr_$get_duplicate_key_count
vfile_relmgr_$open            vfile_status_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$bj_journal_full     dm_error_$lock_deadlock       dm_error_$no_current_transaction
error_table_$bad_arg          error_table_$badopt           error_table_$noarg            error_table_$not_act_fnc
error_table_$wrong_no_of_args mrds_error_$duplicate_opt     mrds_error_$inc_secure_open   mrds_error_$no_model_rel
sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    913 001047       929 001051       958 001055       970 001057        27 001063       130 001112       131 001113
    132 001115       133 001116       134 001117       135 001120       136 001122       137 001123       139 001124
    140 001135       143 001160       145 001161       146 001175       147 001176       148 001203       150 001204
    154 001222       155 001225       156 001230       162 001247       163 001270       165 001311       166 001313
    170 001317       171 001321       172 001322       176 001324       177 001341       178 001343       179 001345
    185 001367       186 001372       187 001374       188 001377       193 001421       195 001430       199 001431
    201 001436       203 001440       207 001441       209 001443       210 001445       211 001450       214 001467
    216 001475    1   83 001501    1   84 001502    1   86 001503    1   88 001505    1   89 001506    1   90 001517
 1   92 001523    1   93 001525    1   94 001527    1   95 001530    1   98 001531    1   99 001532    1  100 001547
 1  140 001551       225 001572       229 001573       232 001577    4   60 001601    4   62 001606    4   63 001607
 4   65 001610    4   68 001612    4   69 001623    4   71 001625    4   72 001636    4   75 001651    4   77 001652
 4   78 001653    4   81 001662    4   82 001663    4   83 001676    4   85 001700    4   86 001711    4   88 001724
 4   90 001725    4   91 001726    4   93 001727    4   94 001730    4   96 001735    4   97 001751    4   99 001753
 4  100 001764    4  102 001777    4  104 002000    4  105 002001    4  107 002002    4  109 002003    4  110 002014
 4  114 002027    4  115 002030       239 002056    1  102 002057    1  107 002060    1  109 002063    1  110 002074
 1  114 002110    1  116 002111    1  121 002112    1  123 002115    1  124 002134    1  126 002142    1  127 002145
 1  129 002150    1  132 002162    1  133 002165    1  135 002170    1  136 002175    1  137 002176    1  138 002205
    241 002206       249 002210       253 002215       260 002216       264 002217       275 002220       279 002234
    283 002247       284 002253       285 002255       286 002260       288 002321       292 002323       293 002325
    294 002327       295 002332       296 002351       302 002352       303 002353       304 002354       305 002355
    306 002360       307 002361       311 002362       313 002364       314 002401       315 002403       316 002406
    318 002425       319 002430       320 002433       321 002436       322 002455       323 002456       324 002463
    325 002465       326 002467       331 002470       335 002472       336 002473       338 002505       342 002512
    343 002514       345 002521       346 002522       347 002523       351 002524       353 002531       357 002533
    361 002534       362 002540       363 002542       364 002545       369 002564       371 002565       378 002566
    382 002570       383 002572       384 002575       385 002627       390 002631       394 002633       396 002666
    398 002700       399 002704       400 002706       401 002710       402 002762       407 002763       413 002773
    415 003034       416 003037       417 003041       418 003114       422 003115       423 003117       428 003144
    430 003157       431 003161       432 003163       434 003235       443 003236       446 003241       448 003242
    454 003243       458 003251       460 003321       461 003324       462 003326       465 003433       469 003434
    471 003436       473 003442       474 003457       475 003461       476 003463       477 003535       479 003536
    482 003555       483 003557       484 003561       486 003633       489 003634       491 003640       494 003710
    495 003713       496 003715       498 003767       501 003770       503 003774       504 003775       507 004004
    509 004031       510 004033       511 004035       513 004107       516 004111       519 004163       523 004164
    524 004166       525 004170       526 004173       529 004300       539 004301       541 004302       550 004303
    556 004304       558 004311       563 004313       565 004341       568 004355       569 004361       571 004367
    575 004370       577 004401       578 004403       579 004405       580 004407       586 004410       588 004416
    590 004421       591 004422       592 004423       593 004425       595 004430       597 004444       598 004453
    600 004465       602 004472       603 004474       605 004475       611 004543       613 004545       614 004551
    615 004560       619 004565       620 004571       621 004633       622 004677       624 004752       625 004763
    628 004765       631 004766       633 004775       635 005056       640 005120       641 005125       642 005154
    643 005220       645 005273       646 005304       649 005306       656 005312       660 005313       662 005315
    664 005316       670 005317       674 005323       675 005327       676 005344       680 005420       684 005421
    690 005467       692 005506       696 005563       700 005566       706 005567       708 005604       712 005661
    717 005664       719 005665       722 005666       723 005672       724 005674       726 005747       728 006057
    729 006062       731 006063       732 006065       734 006112       736 006166       738 006204       740 006260
    742 006300       745 006354       747 006356       749 006403       751 006457       753 006475       755 006551
    757 006571       760 006645       763 006646       767 006674       772 006724       776 006747       780 006761
    781 006765       782 006766       784 007005       785 007017       786 007021       789 007027       791 007032
    792 007034       795 007037       796 007041       799 007064       802 007104       806 007160       807 007167
    808 007204       812 007231       816 007240       817 007244       818 007246       820 007261       823 007335
    824 007347       826 007350       828 007363       831 007437       833 007451       837 007475       839 007476
    846 007512       847 007541       851 007544       856 007552       857 007557       858 007567       861 007572
    862 007574       863 007603       866 007605       867 007611       868 007632       870 007635


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
