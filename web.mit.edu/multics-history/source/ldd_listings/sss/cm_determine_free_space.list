	COMPILATION LISTING OF SEGMENT cm_determine_free_space
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 01/03/85  1634.6 mst Thu
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /* DESCRIPTION:
        9*
       10*         This  routine determines the number of bytes in a control interval
       11*     available for use (free).  Contral intervals are laid out conceptually
       12*     from left to right as follow: fixed size bci_header, an array of datum
       13*     slots, a pool of free space, and the used portion, which may contain
       14*     scattered bytes of free storage.
       15*
       16*       ------------------------------------------------------------
       17*       |        | | |   | |            |      |//|       |////|   |
       18*       | Header |1|2|...|N|   Pool     |      |//|       |////|   |
       19*       |        | | |   | |            |      |//|       |////|   |
       20*       ------------------------------------------------------------
       21*                ^         ^            ^       ^           ^
       22*                |         |            |       |           |
       23*                start     start        |       scattered_free_space
       24*                of slots  of pool      start 
       25*                                       of used space
       26*     The four entries work as follows:
       27*     
       28*       $all - returns the number of bytes in the pool (p_free_bytes_in_pool)
       29*     and the number of free bytes in the control (p_free_bytes_in_ci), which
       30*     includes the bytes in the pool and the scattered free bytes and a caller
       31*     suppied number of bytes currently in use but to be reclaimed
       32*     (p_old_datum_length).
       33*     
       34*       $effective - returns the same information as $all including space
       35*     required for a datum header, i.e., space required for the datum header is
       36*     not considered free. There are three possible datum_header sizes, the
       37*     proper type of datum_header is determined by the p_is_continued and
       38*     p_is_continuation flags input by the caller.
       39*     
       40*       $does_new_datum_fit - returns two flags indicating whether a new datum
       41*     of the size p_new_datum_contents_length will fit in the control interval
       42*     (p_fits_in_ci) or in the pool (p_fits_in_pool).  This entry takes header
       43*     space into consideration, as in $effective, and the amount of space
       44*     necessary for the new datum slot.  The datum slot of the new datum is
       45*     supplied (p_new_datum_slot_idx) by Ordered ESM callers; this is because
       46*     the new slot can be beyond the end of the old datum slot table, requiring
       47*     more than one new slot. Basic ESM callers supply a value of 0; if there
       48*     is a free slot then no extra space is used, else space for one extra slot
       49*     must be accounted.
       50*       This routine returns the amount of free space left in the control
       51*     interval after accounting for the new datum (p_free_bytes_in_ci), if the
       52*     datum fits.  If the datum does not fit, p_free_bytes_in_ci is a 
       53*     non-positive interger with absolute value of the number of bytes in the 
       54*     datum over what would fit.
       55*     
       56*       ** Not yet used **
       57*       $does_replacement_fit - returns two flags indicating whether a
       58*     replacement for a datum will fit in the control interval (p_fits_in_ci)
       59*     or in the pool (p_fits_in_pool).  The size of the old datum (including
       60*     header) (p_old_datum_length) and the length of the new datum contents
       61*     (p_new_datum_contents_length).  Header space for the value of the datum
       62*     is taken into consideration as in $effective.  The caller also supplies
       63*     the offset of the old datum (p_old_datum_offset), and that offset
       64*     indicates that the datum is the first datum in the used space, the pool
       65*     is extended to include the old datum.
       66*       This routine returns the amount of free space left in the control
       67*     interval after accounting for the new datum (p_free_bytes_in_ci), if the
       68*     datum fits.  If the datum does not fit, p_free_bytes_in_ci is a 
       69*     non-positive interger with absolute value of the number of bytes in the 
       70*     datum over what would fit.
       71**/
       72 
       73 /* HISTORY:
       74*
       75*Written by Matthew Pierret, 10/27/82.
       76*Modified:
       77*02/03/83 by Matthew Pierret: Fixed bug which subtracted header_space_required
       78*            twice. Changed to check bci_header version.
       79*08/08/83 by Matthew Pierret: Added the $does_new_datum_fit and
       80*            $does_replacement_fit entries.
       81*09/26/84 by Matthew Pierret: Added declaration of max and size.  Changed
       82*            CHECK_VERSION_CHAR_4 to CHECK_CI_VERSION.  Moved procedure and
       83*            format statements to standard location.
       84**/
       85 
       86 /* format: style2,ind3 */
       87 
       88 cm_determine_free_space:
       89    proc ();
       90 
       91       return;
       92 
       93 /* START OF DECLARATIONS */
       94 /* Parameter */
       95 
       96       dcl	    p_bci_header_ptr       ptr parameter;
       97       dcl	    p_is_continued	       bit (1) aligned parameter;
       98       dcl	    p_is_continuation      bit (1) aligned parameter;
       99       dcl	    p_old_datum_offset     fixed bin (35) parameter;
      100       dcl	    p_old_datum_length     fixed bin (35) parameter;
      101       dcl	    p_new_datum_contents_length
      102 			       fixed bin (35) parameter;
      103       dcl	    p_free_bytes_in_ci     fixed bin (35) parameter;
      104       dcl	    p_free_bytes_in_pool   fixed bin (35) parameter;
      105       dcl	    p_new_datum_slot_idx   fixed bin (35) parameter;
      106       dcl	    p_fits_in_pool	       bit (1) aligned;
      107       dcl	    p_fits_in_ci	       bit (1) aligned;
      108 
      109 /* Automatic */
      110 
      111       dcl	    (first_byte_in_pool, free_bytes_in_pool, free_bytes_in_ci, number_of_slots, required_header_space)
      112 			       fixed bin (35) init (0);
      113       dcl	    (determine_if_datum_fits, for_new_datum, for_replacement)
      114 			       bit (1) aligned init ("0"b);
      115 
      116 /* Based */
      117 /* Builtin */
      118 
      119       dcl	    (max, null, size)      builtin;
      120 
      121 /* Constant */
      122 
      123       dcl	    myname	       init ("cm_determine_free_space") char (32) varying internal static
      124 			       options (constant);
      125       dcl	    BYTES_PER_WORD	       init (4) fixed bin internal static options (constant);
      126 
      127 /* Entry */
      128 
      129       dcl	    sub_err_	       entry () options (variable);
      130 
      131 /* External */
      132 
      133       dcl	    dm_error_$unimplemented_ci_version
      134 			       ext fixed bin (35);
      135 
      136 /* END OF DECLARATIONS */
      137 
      138 effective:
      139    entry (p_bci_header_ptr, p_old_datum_length, p_is_continued, p_is_continuation, p_free_bytes_in_ci,
      140         p_free_bytes_in_pool);
      141 
      142       goto INCLUDE_DATUM_HEADER;
      143 
      144 does_replacement_fit:
      145    entry (p_bci_header_ptr, p_old_datum_offset, p_old_datum_length, p_new_datum_contents_length, p_is_continued,
      146         p_is_continuation, p_fits_in_ci, p_fits_in_pool, p_free_bytes_in_ci);
      147 
      148       determine_if_datum_fits = "1"b;
      149       for_replacement = "1"b;
      150       goto INCLUDE_DATUM_HEADER;
      151 
      152 does_new_datum_fit:
      153    entry (p_bci_header_ptr, p_new_datum_contents_length, p_new_datum_slot_idx, p_is_continued, p_is_continuation,
      154         p_fits_in_ci, p_fits_in_pool, p_free_bytes_in_ci);
      155 
      156       determine_if_datum_fits = "1"b;
      157       for_new_datum = "1"b;
      158       goto INCLUDE_DATUM_HEADER;
      159 
      160 INCLUDE_DATUM_HEADER:
      161       if p_is_continued & p_is_continuation
      162       then required_header_space = CDCN_DATUM_HEADER_LENGTH_IN_BYTES;
      163       else if p_is_continued
      164       then required_header_space = CD_DATUM_HEADER_LENGTH_IN_BYTES;
      165       else required_header_space = 0;
      166 
      167       goto JOIN;
      168 
      169 
      170 all:
      171    entry (p_bci_header_ptr, p_old_datum_length, p_free_bytes_in_ci, p_free_bytes_in_pool);
      172 
      173       goto JOIN;
      174 
      175 JOIN:
      176       bci_header_ptr = p_bci_header_ptr;
      177 
      178       call CHECK_CI_VERSION (bci_header.layout_type);
      179 
      180       if for_new_datum
      181       then if p_new_datum_slot_idx > 0
      182 	 then number_of_slots = max (bci_header.number_of_datums + 1, p_new_datum_slot_idx);
      183 	 else if bci_header.flags.free_slot_is_present
      184 	 then number_of_slots = bci_header.number_of_datums;
      185 	 else number_of_slots = bci_header.number_of_datums + 1;
      186       else number_of_slots = bci_header.number_of_datums;
      187 
      188       first_byte_in_pool = BYTES_PER_WORD * (size (bci_header) + number_of_slots + 1);
      189 
      190       free_bytes_in_pool = bci_header.start_of_used_space - first_byte_in_pool - required_header_space;
      191       free_bytes_in_ci = free_bytes_in_pool + bci_header.scattered_free_space;
      192 
      193       if for_replacement
      194       then if p_old_datum_offset = bci_header.start_of_used_space
      195 	 then free_bytes_in_pool = free_bytes_in_pool + p_old_datum_length;
      196 
      197       if ^for_new_datum
      198       then free_bytes_in_ci = free_bytes_in_ci + p_old_datum_length;
      199 
      200       if determine_if_datum_fits
      201       then
      202          do;
      203 	  p_fits_in_ci = (p_new_datum_contents_length <= free_bytes_in_ci);
      204 	  p_fits_in_pool = (p_new_datum_contents_length <= free_bytes_in_pool);
      205 	  p_free_bytes_in_ci = free_bytes_in_ci - p_new_datum_contents_length;
      206 						/* If ^p_fits_in_ci, this will be non-positive, */
      207 						/* indicating how much smaller the datum must be to fit. */
      208          end;
      209       else
      210          do;
      211 	  p_free_bytes_in_ci = free_bytes_in_ci;
      212 	  p_free_bytes_in_pool = free_bytes_in_pool;
      213          end;
      214 
      215       return;
      216 
      217 CHECK_CI_VERSION:
      218    proc (ccv_p_given_version);
      219 
      220       dcl	    ccv_p_given_version    char (4) aligned;
      221 
      222       if ccv_p_given_version ^= BASIC_CI_LAYOUT_1
      223       then call sub_err_ (dm_error_$unimplemented_ci_version, myname, ACTION_CANT_RESTART, null, 0,
      224 	      "^/Expected version ^a control interval; received ^a.", BASIC_CI_LAYOUT_1, ccv_p_given_version);
      225       else return;
      226 
      227    end CHECK_CI_VERSION;
      228 
  1     1 /* BEGIN INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*
  1     5*        The collection_manager_ manages the structure of the addressable
  1     6*   portion of a control interval.  The addressable portion is that portion of
  1     7*   a control interval which the file_manager_ will allow the
  1     8*   collection_manager_ to address.  In this description control interval will
  1     9*   be used to mean the addressable portion of a control interval.
  1    10*   
  1    11*        A control interval is divided into four parts: the header, the datum
  1    12*   position table (also known as the slot table or slots), un-used space and
  1    13*   used space.  The beginning of the header is at offset 0, and the end of the
  1    14*   used space is at the end of the control interval (curently offset 4072).
  1    15*   Pictoriarly, a control interval is structured as follows:
  1    16*   
  1    17*   ----------------------------------------------------------------------
  1    18*   |        || | | | | | ||               ||   | / / |       |/|   |    |
  1    19*   | Header || | slot  | || un-used space ||   |/ / /|       |/|   |    |
  1    20*   |        || | table | ||               ||   | / / |       |/|   |    |
  1    21*   |        || | | | | | ||               ||   |/ / /|       |/|   |    |
  1    22*   ----------------------------------------------------------------------
  1    23*                                           ^ ^    ^      ^    ^  ^   ^
  1    24*                                           | |    |      |    |  |   |
  1    25*                                           | |...........|.......|...|
  1    26*                        start of used space|      |           |      |
  1    27*                                                  |           |  each|
  1    28*                                          scattered free space|  is a used
  1    29*                                                                 datum
  1    30*   
  1    31*      The basic_control_interval structure describes the header
  1    32*   (basic_control_interval.header, bci_header) and the slots
  1    33*   (basic_control_interval.datum_position_table, datum_slot for one only).
  1    34*   Each datum_slot contains the offset (in bytes) and the length (in bits) of
  1    35*   a datum in the used space.  If the offset is equal to FREE_SLOT (declared
  1    36*   in dm_cm_basic_ci_const.incl.pl1), the slot is un-used.  The slot also
  1    37*   contains flags describing the type of datum (see dm_cm_datum.incl.pl1).
  1    38**/
  1    39 
  1    40 /* HISTORY:
  1    41*Written by Matthew Pierret, 02/07/82.
  1    42*Modified:
  1    43*03/25/82 by Matthew Pierret: Fixed alignment differences basic_control_interval
  1    44*            and its sub-structures.
  1    45*06/14/82 by Matthew Pierret: Removed common header and buffers. Changed
  1    46*            basic_ci_header to bci_header. Added previous_control_interval.
  1    47*07/12/82 by Matthew Pierret: Changed collection_id to be bit (36) aligned.
  1    48*10/29/82 by Matthew Pierret: Added flags to datum slots. 
  1    49*11/10/82 by Matthew Pierret: Removed continued_datum_is_present flag, as it
  1    50*            is not used.
  1    51*03/28/84 by Matthew Pierret: Added the constants BCI_HEADER_LENGTH_IN_BYTES
  1    52*            and DATUM_POSITION_TABLE_OFFSET_IN_BYTES.
  1    53**/
  1    54 
  1    55 /* format: style2 */
  1    56      dcl	   1 basic_control_interval
  1    57 			      aligned based (basic_control_interval_ptr),
  1    58 	     2 header	      like bci_header,
  1    59 	     2 datum_position_table
  1    60 			      (0 refer (basic_control_interval.number_of_datums)) like datum_slot;
  1    61 
  1    62 
  1    63      dcl	   1 bci_header	      aligned based (bci_header_ptr),
  1    64 	     2 layout_type	      char (4) aligned,
  1    65 	     2 collection_id      bit (36) aligned,
  1    66 	     2 next_control_interval
  1    67 			      fixed bin (24) uns unal,
  1    68 	     2 previous_control_interval
  1    69 			      fixed bin (24) uns unal,
  1    70 	     2 flags	      unal,
  1    71 	       3 continuation_datum_is_present
  1    72 			      bit (1) unal,
  1    73 	       3 free_slot_is_present
  1    74 			      bit (1) unal,
  1    75 	       3 must_be_zero     bit (4) unal,		/* reserved */
  1    76 	     2 scattered_free_space
  1    77 			      fixed bin (17) unal,
  1    78 	     2 start_of_used_space
  1    79 			      fixed bin (17) unal,
  1    80 	     2 number_of_datums   fixed bin (17) unal;
  1    81 
  1    82      dcl	   1 datum_slot	      aligned based (datum_slot_ptr),
  1    83 	     2 flags	      unal,
  1    84 	       3 special_format_datum
  1    85 			      bit (1) unal,		/* reserved */
  1    86 	       3 is_continued     bit (1) unal,
  1    87 	       3 is_continuation  bit (1) unal,
  1    88 	       3 mbz	      bit (1) unal,		/* reserved */
  1    89 	     2 offset_in_bytes    fixed bin (15) uns unal,
  1    90 	     2 length_in_bits     fixed bin (17) uns unal;
  1    91 
  1    92      dcl	   basic_control_interval_ptr
  1    93 			      ptr;
  1    94      dcl	   bci_header_ptr	      ptr;
  1    95      dcl	   datum_slot_ptr	      ptr;
  1    96 
  1    97      dcl	   BASIC_CI_LAYOUT_1      char (4) aligned init ("bci1") internal static options (constant);
  1    98 
  1    99 /* END INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
      229 
      230 
  2     1 /* BEGIN INCLUDE FILE dm_cm_datum_constants.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*        Contains constants describing the extents of datums and datum
  2     5*   headers.  The datum headers are described in dm_cm_datum.incl.pl1.
  2     6*   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES is the byte length of the largest
  2     7*   datum that can be stored in a control interval, allowing for the largest
  2     8*   possibledatum header. MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS is the same
  2     9*   in bits instead of bytes.  MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
  2    10*   is the smallest length in bits which requires 
  2    11*   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES bytes to store.
  2    12**/
  2    13 
  2    14 /*
  2    15*HISTORY:
  2    16*Written by Matthew Pierret, 02/07/82.
  2    17*Modified:
  2    18*10/29/82 by Matthew Pierret:  Removed DATUM_HEADER*.
  2    19*11/02/82 by Matthew Pierret:  Added maximum datum contents lengths.
  2    20*12/01/82 by Lindsey Spratt:   Corrected values for datum header lengths.
  2    21*09/18/84 by Matthew Pierret:  Corrected values for maximum lengths. Added
  2    22*            MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS.  Added
  2    23*            DESCRIPTION section.
  2    24**/
  2    25 
  2    26 /* format: style2,ind3,ll79 */
  2    27      dcl	   CD_DATUM_HEADER_LENGTH_IN_BYTES
  2    28 			      fixed bin init (8) internal static
  2    29 			      options (constant);
  2    30 
  2    31      dcl	   CD_DATUM_HEADER_LENGTH_IN_BITS
  2    32 			      fixed bin init (72) internal static
  2    33 			      options (constant);
  2    34 
  2    35      dcl	   CDCN_DATUM_HEADER_LENGTH_IN_BYTES
  2    36 			      init (4) fixed bin int static
  2    37 			      options (constant);
  2    38 
  2    39      dcl	   CDCN_DATUM_HEADER_LENGTH_IN_BITS
  2    40 			      init (36) fixed bin int static
  2    41 			      options (constant);
  2    42 
  2    43      dcl	   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
  2    44 			      init (36360) fixed bin (35) internal
  2    45 			      static options (constant);
  2    46 
  2    47      dcl	   MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES
  2    48 			      init (4040) fixed bin (35) internal
  2    49 			      static options (constant);
  2    50 
  2    51      dcl	   MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
  2    52 			      init (36352) fixed bin (35) internal
  2    53 			      static options (constant);
  2    54 
  2    55 /* END INCLUDE FILE dm_cm_datum.incl.pl1 */
      231 
      232 
  3     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  3     2 /* format: style3 */
  3     3 
  3     4 /* These constants are to be used for the flags argument of sub_err_ */
  3     5 /* They are just "string (condition_info_header.action_flags)" */
  3     6 
  3     7 declare	(
  3     8 	ACTION_CAN_RESTART	init (""b),
  3     9 	ACTION_CANT_RESTART init ("1"b),
  3    10 	ACTION_DEFAULT_RESTART
  3    11 			init ("01"b),
  3    12 	ACTION_QUIET_RESTART
  3    13 			init ("001"b),
  3    14 	ACTION_SUPPORT_SIGNAL
  3    15 			init ("0001"b)
  3    16 	)		bit (36) aligned internal static options (constant);
  3    17 
  3    18 /* End include file */
      233 
      234 
      235    end cm_determine_free_space;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/03/85  1148.4  cm_determine_free_space.pl1       >spec>temp>famis1>cm_determine_free_space.pl1
229          1    01/03/85  1003.0  dm_cm_basic_ci.incl.pl1           >spec>temp>famis1>dm_cm_basic_ci.incl.pl1
231          2    01/03/85  1003.1  dm_cm_datum_constants.incl.pl1    >spec>temp>famis1>dm_cm_datum_constants.incl.pl1
233          3    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000017 constant        bit(36)                  initial dcl 3-7 set ref 222*
BASIC_CI_LAYOUT_1               000000 constant        char(4)                  initial dcl 1-97 set ref 222 222*
BYTES_PER_WORD                         constant        fixed bin(17,0)          initial dcl 125 ref 188
CDCN_DATUM_HEADER_LENGTH_IN_BYTES      constant        fixed bin(17,0)          initial dcl 2-35 ref 160
CD_DATUM_HEADER_LENGTH_IN_BYTES        constant        fixed bin(17,0)          initial dcl 2-27 ref 163
bci_header                             based           structure                level 1 dcl 1-63 set ref 188
bci_header_ptr                  000110 automatic       pointer                  dcl 1-94 set ref 175* 178 180 183 183 185 186 188
                                                                                  190 191 193
ccv_p_given_version                    parameter       char(4)                  dcl 220 set ref 217 222 222*
datum_slot                             based           structure                level 1 dcl 1-82
determine_if_datum_fits         000105 automatic       bit(1)                   initial dcl 113 set ref 113* 148* 156* 200
dm_error_$unimplemented_ci_version
                                000012 external static fixed bin(35,0)          dcl 133 set ref 222*
first_byte_in_pool              000100 automatic       fixed bin(35,0)          initial dcl 111 set ref 111* 188* 190
flags                     3(12)        based           structure                level 2 packed unaligned dcl 1-63
for_new_datum                   000106 automatic       bit(1)                   initial dcl 113 set ref 113* 157* 180 197
for_replacement                 000107 automatic       bit(1)                   initial dcl 113 set ref 113* 149* 193
free_bytes_in_ci                000102 automatic       fixed bin(35,0)          initial dcl 111 set ref 111* 191* 197* 197 203 205
                                                                                  211
free_bytes_in_pool              000101 automatic       fixed bin(35,0)          initial dcl 111 set ref 111* 190* 191 193* 193 204
                                                                                  212
free_slot_is_present      3(13)        based           bit(1)                   level 3 packed unaligned dcl 1-63 ref 183
layout_type                            based           char(4)                  level 2 dcl 1-63 set ref 178*
max                                                    builtin function         dcl 119 ref 180
myname                          000001 constant        varying char(32)         initial dcl 123 set ref 222*
null                                                   builtin function         dcl 119 ref 222 222
number_of_datums          4(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 1-63 ref 180 183 185
                                                                                  186
number_of_slots                 000103 automatic       fixed bin(35,0)          initial dcl 111 set ref 111* 180* 183* 185* 186* 188
p_bci_header_ptr                       parameter       pointer                  dcl 96 ref 138 144 152 170 175
p_fits_in_ci                           parameter       bit(1)                   dcl 107 set ref 144 152 203*
p_fits_in_pool                         parameter       bit(1)                   dcl 106 set ref 144 152 204*
p_free_bytes_in_ci                     parameter       fixed bin(35,0)          dcl 103 set ref 138 144 152 170 205* 211*
p_free_bytes_in_pool                   parameter       fixed bin(35,0)          dcl 104 set ref 138 170 212*
p_is_continuation                      parameter       bit(1)                   dcl 98 ref 138 144 152 160
p_is_continued                         parameter       bit(1)                   dcl 97 ref 138 144 152 160 163
p_new_datum_contents_length            parameter       fixed bin(35,0)          dcl 101 ref 144 152 203 204 205
p_new_datum_slot_idx                   parameter       fixed bin(35,0)          dcl 105 ref 152 180 180
p_old_datum_length                     parameter       fixed bin(35,0)          dcl 100 ref 138 144 170 193 197
p_old_datum_offset                     parameter       fixed bin(35,0)          dcl 99 ref 144 193
required_header_space           000104 automatic       fixed bin(35,0)          initial dcl 111 set ref 111* 160* 163* 165* 190
scattered_free_space      3(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 1-63 ref 191
size                                                   builtin function         dcl 119 ref 188
start_of_used_space       4            based           fixed bin(17,0)          level 2 packed unaligned dcl 1-63 ref 190 193
sub_err_                        000010 constant        entry                    external dcl 129 ref 222

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 3-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 3-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 3-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 3-7
CDCN_DATUM_HEADER_LENGTH_IN_BITS       internal static fixed bin(17,0)          initial dcl 2-39
CD_DATUM_HEADER_LENGTH_IN_BITS         internal static fixed bin(17,0)          initial dcl 2-31
MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS  internal static fixed bin(35,0)          initial dcl 2-43
MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BYTES internal static fixed bin(35,0)          initial dcl 2-47
MINIMUM_MAXIMUM_DATUM_CONTENTS_LENGTH_IN_BITS
                                       internal static fixed bin(35,0)          initial dcl 2-51
basic_control_interval                 based           structure                level 1 dcl 1-56
basic_control_interval_ptr             automatic       pointer                  dcl 1-92
datum_slot_ptr                         automatic       pointer                  dcl 1-95

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_CI_VERSION                000440 constant        entry                    internal dcl 217 ref 178
INCLUDE_DATUM_HEADER            000214 constant        label                    dcl 160 ref 142 150 158
JOIN                            000260 constant        label                    dcl 175 ref 167 173
all                             000242 constant        entry                    external dcl 170
cm_determine_free_space         000057 constant        entry                    external dcl 88
does_new_datum_fit              000165 constant        entry                    external dcl 152
does_replacement_fit            000125 constant        entry                    external dcl 144
effective                       000074 constant        entry                    external dcl 138

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       630         644     523         640
Length      1106     523        14         225     105           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cm_determine_free_space             158 external procedure  is an external procedure.  
CHECK_CI_VERSION                        internal procedure  shares stack frame of external procedure cm_determine_free_space.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cm_determine_free_space  000100 first_byte_in_pool          cm_determine_free_space
                         000101 free_bytes_in_pool          cm_determine_free_space
                         000102 free_bytes_in_ci            cm_determine_free_space
                         000103 number_of_slots             cm_determine_free_space
                         000104 required_header_space       cm_determine_free_space
                         000105 determine_if_datum_fits     cm_determine_free_space
                         000106 for_new_datum               cm_determine_free_space
                         000107 for_replacement             cm_determine_free_space
                         000110 bci_header_ptr              cm_determine_free_space

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_le_a              call_ext_out_desc   return              mpfx2               ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$unimplemented_ci_version


CONSTANTS
000000  aa  142 143 151 061	bci1

000001  aa     000000000027
000002  aa  143 155 137 144	cm_d
000003  aa  145 164 145 162	eter
000004  aa  155 151 156 145	mine
000005  aa  137 146 162 145	_fre
000006  aa  145 137 163 160	e_sp
000007  aa  141 143 145 040	ace 
000010  aa  040 040 040 040	    
000011  aa  040 040 040 040	    

000012  aa     524000000064

000013  aa     404000000005

000014  aa     514000000044

000015  aa     530000000040

000016  aa     524000000004

000017  aa     400000000000

000020  aa     404000000043

000021  aa     514000000001

000022  aa     464000000000

000024  aa     077777000043
000025  aa     000001000000

000026  aa  136 057 105 170	^/Ex
000027  aa  160 145 143 164	pect
000030  aa  145 144 040 166	ed v
000031  aa  145 162 163 151	ersi
000032  aa  157 156 040 136	on ^
000033  aa  141 040 143 157	a co
000034  aa  156 164 162 157	ntro
000035  aa  154 040 151 156	l in
000036  aa  164 145 162 166	terv
000037  aa  141 154 073 040	al; 
000040  aa  162 145 143 145	rece
000041  aa  151 166 145 144	ived
000042  aa  040 136 141 056	 ^a.

BEGIN PROCEDURE cm_determine_free_space
PROLOGUE SEQUENCE
000043  aa  6 00140 4401 00	sxl0 	pr6|96
						STATEMENT 1 ON LINE 111
000044  aa  6 00100 4501 00	stz  	pr6|64		first_byte_in_pool
000045  aa  6 00101 4501 00	stz  	pr6|65		free_bytes_in_pool
000046  aa  6 00102 4501 00	stz  	pr6|66		free_bytes_in_ci
000047  aa  6 00103 4501 00	stz  	pr6|67		number_of_slots
000050  aa  6 00104 4501 00	stz  	pr6|68		required_header_space
						STATEMENT 1 ON LINE 113
000051  aa  6 00105 4501 00	stz  	pr6|69		determine_if_datum_fits
000052  aa  6 00106 4501 00	stz  	pr6|70		for_new_datum
000053  aa  6 00107 4501 00	stz  	pr6|71		for_replacement
000054  aa  6 00140 7201 00	lxl0 	pr6|96
000055  aa   000000 7100 10	tra  	0,0
MAIN SEQUENCE
ENTRY TO cm_determine_free_space                            STATEMENT 1 ON LINE 88
cm_determine_free_space:
   proc ();

000056  da     000046200000
000057  aa   000240 6270 00	eax7 	160
000060  aa  7 00034 3521 20	epp2 	pr7|28,*
000061  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000062  aa     000000000000
000063  aa     000000000000
000064  aa   777757 7000 04	tsx0 	-17,ic		000043
						STATEMENT 1 ON LINE 91
      return;

000065  aa  0 00631 7101 00	tra  	pr0|409		return
ENTRY TO effective                                          STATEMENT 1 ON LINE 138
effective:
   entry (p_bci_header_ptr, p_old_datum_length, p_is_continued, p_is_continuation, p_free_bytes_in_ci,
        p_free_bytes_in_pool);

000066  at     000006000022
000067  tt     000020000021
000070  tt     000021000020
000071  ta     000020000000
000072  ta     000066000000
000073  da     000054300000
000074  aa   000240 6270 00	eax7 	160
000075  aa  7 00034 3521 20	epp2 	pr7|28,*
000076  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000077  aa     000014000000
000100  aa     000000000000
000101  aa  6 00032 3735 20	epp7 	pr6|26,*
000102  aa  7 00004 3715 20	epp5 	pr7|4,*
000103  aa  6 00116 6515 00	spri5	pr6|78
000104  aa  7 00006 3535 20	epp3 	pr7|6,*
000105  aa  6 00112 2535 00	spri3	pr6|74
000106  aa  7 00010 3515 20	epp1 	pr7|8,*
000107  aa  6 00114 2515 00	spri1	pr6|76
000110  aa  7 00012 3715 20	epp5 	pr7|10,*
000111  aa  6 00122 6515 00	spri5	pr6|82
000112  aa  7 00014 3535 20	epp3 	pr7|12,*
000113  aa  6 00124 2535 00	spri3	pr6|84
000114  aa   777727 7000 04	tsx0 	-41,ic		000043
						STATEMENT 1 ON LINE 142
      goto INCLUDE_DATUM_HEADER;

000115  aa   000077 7100 04	tra  	63,ic		000214
ENTRY TO does_replacement_fit                               STATEMENT 1 ON LINE 144
does_replacement_fit:
   entry (p_bci_header_ptr, p_old_datum_offset, p_old_datum_length, p_new_datum_contents_length, p_is_continued,
        p_is_continuation, p_fits_in_ci, p_fits_in_pool, p_free_bytes_in_ci);

000116  at     000011000022
000117  tt     000020000020
000120  tt     000020000021
000121  tt     000021000021
000122  tt     000021000020
000123  ta     000116000000
000124  da     000065300000
000125  aa   000240 6270 00	eax7 	160
000126  aa  7 00034 3521 20	epp2 	pr7|28,*
000127  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000130  aa     000022000000
000131  aa     000000000000
000132  aa  6 00032 3735 20	epp7 	pr6|26,*
000133  aa  7 00006 3715 20	epp5 	pr7|6,*
000134  aa  6 00116 6515 00	spri5	pr6|78
000135  aa  7 00010 3535 20	epp3 	pr7|8,*
000136  aa  6 00120 2535 00	spri3	pr6|80
000137  aa  7 00012 3515 20	epp1 	pr7|10,*
000140  aa  6 00112 2515 00	spri1	pr6|74
000141  aa  7 00014 3715 20	epp5 	pr7|12,*
000142  aa  6 00114 6515 00	spri5	pr6|76
000143  aa  7 00016 3535 20	epp3 	pr7|14,*
000144  aa  6 00130 2535 00	spri3	pr6|88
000145  aa  7 00020 3515 20	epp1 	pr7|16,*
000146  aa  6 00126 2515 00	spri1	pr6|86
000147  aa  7 00022 3715 20	epp5 	pr7|18,*
000150  aa  6 00122 6515 00	spri5	pr6|82
000151  aa   777672 7000 04	tsx0 	-70,ic		000043
						STATEMENT 1 ON LINE 148
      determine_if_datum_fits = "1"b;

000152  aa   400000 2350 03	lda  	131072,du
000153  aa  6 00105 7551 00	sta  	pr6|69		determine_if_datum_fits
						STATEMENT 1 ON LINE 149
      for_replacement = "1"b;

000154  aa  6 00107 7551 00	sta  	pr6|71		for_replacement
						STATEMENT 1 ON LINE 150
      goto INCLUDE_DATUM_HEADER;

000155  aa   000037 7100 04	tra  	31,ic		000214
ENTRY TO does_new_datum_fit                                 STATEMENT 1 ON LINE 152
does_new_datum_fit:
   entry (p_bci_header_ptr, p_new_datum_contents_length, p_new_datum_slot_idx, p_is_continued, p_is_continuation,
        p_fits_in_ci, p_fits_in_pool, p_free_bytes_in_ci);

000156  at     000010000022
000157  tt     000020000020
000160  tt     000021000021
000161  tt     000021000021
000162  ta     000020000000
000163  ta     000156000000
000164  da     000075300000
000165  aa   000240 6270 00	eax7 	160
000166  aa  7 00034 3521 20	epp2 	pr7|28,*
000167  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000170  aa     000020000000
000171  aa     000000000000
000172  aa  6 00032 3735 20	epp7 	pr6|26,*
000173  aa  7 00004 3715 20	epp5 	pr7|4,*
000174  aa  6 00120 6515 00	spri5	pr6|80
000175  aa  7 00010 3535 20	epp3 	pr7|8,*
000176  aa  6 00112 2535 00	spri3	pr6|74
000177  aa  7 00012 3515 20	epp1 	pr7|10,*
000200  aa  6 00114 2515 00	spri1	pr6|76
000201  aa  7 00014 3715 20	epp5 	pr7|12,*
000202  aa  6 00130 6515 00	spri5	pr6|88
000203  aa  7 00016 3535 20	epp3 	pr7|14,*
000204  aa  6 00126 2535 00	spri3	pr6|86
000205  aa  7 00020 3515 20	epp1 	pr7|16,*
000206  aa  6 00122 2515 00	spri1	pr6|82
000207  aa   777634 7000 04	tsx0 	-100,ic		000043
						STATEMENT 1 ON LINE 156
      determine_if_datum_fits = "1"b;

000210  aa   400000 2350 03	lda  	131072,du
000211  aa  6 00105 7551 00	sta  	pr6|69		determine_if_datum_fits
						STATEMENT 1 ON LINE 157
      for_new_datum = "1"b;

000212  aa  6 00106 7551 00	sta  	pr6|70		for_new_datum
						STATEMENT 1 ON LINE 158
      goto INCLUDE_DATUM_HEADER;

000213  aa   000001 7100 04	tra  	1,ic		000214
						STATEMENT 1 ON LINE 160
INCLUDE_DATUM_HEADER:
      if p_is_continued & p_is_continuation
      then required_header_space = CDCN_DATUM_HEADER_LENGTH_IN_BYTES;

000214  aa  6 00112 2351 20	lda  	pr6|74,*		p_is_continued
000215  aa  0 00002 3771 00	anaq 	pr0|2		= 400000000000 000000000000
000216  aa  6 00141 7551 00	sta  	pr6|97		p_is_continued
000217  aa   000007 6000 04	tze  	7,ic		000226
000220  aa  6 00114 2351 20	lda  	pr6|76,*		p_is_continuation
000221  aa   400000 3150 03	cana 	131072,du
000222  aa   000004 6000 04	tze  	4,ic		000226
000223  aa   000004 2360 07	ldq  	4,dl
000224  aa  6 00104 7561 00	stq  	pr6|68		required_header_space
000225  aa   000033 7100 04	tra  	27,ic		000260
						STATEMENT 1 ON LINE 163
      else if p_is_continued
      then required_header_space = CD_DATUM_HEADER_LENGTH_IN_BYTES;

000226  aa  6 00141 2351 00	lda  	pr6|97		p_is_continued
000227  aa   000004 6000 04	tze  	4,ic		000233
000230  aa   000010 2360 07	ldq  	8,dl
000231  aa  6 00104 7561 00	stq  	pr6|68		required_header_space
000232  aa   000026 7100 04	tra  	22,ic		000260
						STATEMENT 1 ON LINE 165
      else required_header_space = 0;

000233  aa  6 00104 4501 00	stz  	pr6|68		required_header_space
						STATEMENT 1 ON LINE 167
      goto JOIN;

000234  aa   000024 7100 04	tra  	20,ic		000260
ENTRY TO all                                                STATEMENT 1 ON LINE 170
all:
   entry (p_bci_header_ptr, p_old_datum_length, p_free_bytes_in_ci, p_free_bytes_in_pool);

000235  at     000004000022
000236  tt     000020000020
000237  ta     000020000000
000240  ta     000235000000
000241  da     000101300000
000242  aa   000240 6270 00	eax7 	160
000243  aa  7 00034 3521 20	epp2 	pr7|28,*
000244  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000245  aa     000010000000
000246  aa     000000000000
000247  aa  6 00032 3735 20	epp7 	pr6|26,*
000250  aa  7 00004 3715 20	epp5 	pr7|4,*
000251  aa  6 00116 6515 00	spri5	pr6|78
000252  aa  7 00006 3535 20	epp3 	pr7|6,*
000253  aa  6 00122 2535 00	spri3	pr6|82
000254  aa  7 00010 3515 20	epp1 	pr7|8,*
000255  aa  6 00124 2515 00	spri1	pr6|84
000256  aa   777565 7000 04	tsx0 	-139,ic		000043
						STATEMENT 1 ON LINE 173
      goto JOIN;

000257  aa   000001 7100 04	tra  	1,ic		000260
						STATEMENT 1 ON LINE 175
JOIN:
      bci_header_ptr = p_bci_header_ptr;

000260  aa  6 00032 3735 20	epp7 	pr6|26,*
000261  aa  7 00002 3715 20	epp5 	pr7|2,*		p_bci_header_ptr
000262  aa  5 00000 3715 20	epp5 	pr5|0,*		p_bci_header_ptr
000263  aa  6 00110 6515 00	spri5	pr6|72		bci_header_ptr
						STATEMENT 1 ON LINE 178
      call CHECK_CI_VERSION (bci_header.layout_type);

000264  aa  5 00000 3521 00	epp2 	pr5|0		bci_header.layout_type
000265  aa  6 00144 2521 00	spri2	pr6|100
000266  aa  6 00142 3521 00	epp2 	pr6|98
000267  aa   004000 4310 07	fld  	2048,dl
000270  aa  2 00000 7571 00	staq 	pr2|0
000271  aa   000147 6700 04	tsp4 	103,ic		000440
						STATEMENT 1 ON LINE 180
      if for_new_datum
      then if p_new_datum_slot_idx > 0
	 then number_of_slots = max (bci_header.number_of_datums + 1, p_new_datum_slot_idx);

000272  aa  6 00106 2351 00	lda  	pr6|70		for_new_datum
000273  aa   000035 6000 04	tze  	29,ic		000330
000274  aa  6 00032 3735 20	epp7 	pr6|26,*
000275  aa  7 00006 2361 20	ldq  	pr7|6,*		p_new_datum_slot_idx
000276  aa   000013 6044 04	tmoz 	11,ic		000311
000277  aa  6 00110 3715 20	epp5 	pr6|72,*		bci_header_ptr
000300  aa  5 00004 2351 00	lda  	pr5|4		bci_header.number_of_datums
000301  aa   000022 7350 00	als  	18
000302  aa   000066 7330 00	lrs  	54
000303  aa   000001 0760 07	adq  	1,dl
000304  aa  7 00006 1161 20	cmpq 	pr7|6,*		p_new_datum_slot_idx
000305  aa   000002 6050 04	tpl  	2,ic		000307
000306  aa  7 00006 2361 20	ldq  	pr7|6,*		p_new_datum_slot_idx
000307  aa  6 00103 7561 00	stq  	pr6|67		number_of_slots
000310  aa   000025 7100 04	tra  	21,ic		000335
						STATEMENT 1 ON LINE 183
	 else if bci_header.flags.free_slot_is_present
	 then number_of_slots = bci_header.number_of_datums;

000311  aa  6 00110 3715 20	epp5 	pr6|72,*		bci_header_ptr
000312  aa  5 00003 2351 00	lda  	pr5|3		bci_header.free_slot_is_present
000313  aa   000020 3150 03	cana 	16,du
000314  aa   000006 6000 04	tze  	6,ic		000322
000315  aa  5 00004 2351 00	lda  	pr5|4		bci_header.number_of_datums
000316  aa   000022 7350 00	als  	18
000317  aa   000066 7330 00	lrs  	54
000320  aa  6 00103 7561 00	stq  	pr6|67		number_of_slots
000321  aa   000014 7100 04	tra  	12,ic		000335
						STATEMENT 1 ON LINE 185
	 else number_of_slots = bci_header.number_of_datums + 1;

000322  aa  5 00004 2351 00	lda  	pr5|4		bci_header.number_of_datums
000323  aa   000022 7350 00	als  	18
000324  aa   000066 7330 00	lrs  	54
000325  aa   000001 0760 07	adq  	1,dl
000326  aa  6 00103 7561 00	stq  	pr6|67		number_of_slots
000327  aa   000006 7100 04	tra  	6,ic		000335
						STATEMENT 1 ON LINE 186
      else number_of_slots = bci_header.number_of_datums;

000330  aa  6 00110 3735 20	epp7 	pr6|72,*		bci_header_ptr
000331  aa  7 00004 2351 00	lda  	pr7|4		bci_header.number_of_datums
000332  aa   000022 7350 00	als  	18
000333  aa   000066 7330 00	lrs  	54
000334  aa  6 00103 7561 00	stq  	pr6|67		number_of_slots
						STATEMENT 1 ON LINE 188
      first_byte_in_pool = BYTES_PER_WORD * (size (bci_header) + number_of_slots + 1);

000335  aa   000044 7770 00	llr  	36
000336  aa   000044 7330 00	lrs  	36
000337  aa   000005 0330 07	adl  	5,dl
000340  aa   000001 0330 07	adl  	1,dl
000341  aa  6 00150 7571 00	staq 	pr6|104
000342  aa   000004 2360 07	ldq  	4,dl
000343  aa  6 00150 3521 00	epp2 	pr6|104
000344  aa  0 00671 7001 00	tsx0 	pr0|441		mpfx2
000345  aa  6 00100 7561 00	stq  	pr6|64		first_byte_in_pool
						STATEMENT 1 ON LINE 190
      free_bytes_in_pool = bci_header.start_of_used_space - first_byte_in_pool - required_header_space;

000346  aa  6 00110 3735 20	epp7 	pr6|72,*		bci_header_ptr
000347  aa  7 00004 2351 00	lda  	pr7|4		bci_header.start_of_used_space
000350  aa   000066 7330 00	lrs  	54
000351  aa  6 00141 7561 00	stq  	pr6|97		bci_header.start_of_used_space
000352  aa  0 00110 6761 00	erq  	pr0|72		= 777777777777
000353  aa   000001 0760 07	adq  	1,dl
000354  aa   000044 7770 00	llr  	36
000355  aa   000044 7330 00	lrs  	36
000356  aa  6 00100 0331 00	adl  	pr6|64		first_byte_in_pool
000357  aa   000000 5330 00	negl 	0
000360  aa   000000 5330 00	negl 	0
000361  aa  6 00104 0331 00	adl  	pr6|68		required_header_space
000362  aa   000000 5330 00	negl 	0
000363  aa  6 00101 7561 00	stq  	pr6|65		free_bytes_in_pool
						STATEMENT 1 ON LINE 191
      free_bytes_in_ci = free_bytes_in_pool + bci_header.scattered_free_space;

000364  aa  7 00003 2351 00	lda  	pr7|3		bci_header.scattered_free_space
000365  aa   000022 7350 00	als  	18
000366  aa   000066 7330 00	lrs  	54
000367  aa   000044 7770 00	llr  	36
000370  aa   000044 7330 00	lrs  	36
000371  aa  6 00101 0331 00	adl  	pr6|65		free_bytes_in_pool
000372  aa  6 00102 7561 00	stq  	pr6|66		free_bytes_in_ci
						STATEMENT 1 ON LINE 193
      if for_replacement
      then if p_old_datum_offset = bci_header.start_of_used_space
	 then free_bytes_in_pool = free_bytes_in_pool + p_old_datum_length;

000373  aa  6 00107 2351 00	lda  	pr6|71		for_replacement
000374  aa   000011 6000 04	tze  	9,ic		000405
000375  aa  6 00032 3715 20	epp5 	pr6|26,*
000376  aa  5 00004 2361 20	ldq  	pr5|4,*		p_old_datum_offset
000377  aa  6 00141 1161 00	cmpq 	pr6|97		bci_header.start_of_used_space
000400  aa   000005 6010 04	tnz  	5,ic		000405
000401  aa  6 00101 2351 00	lda  	pr6|65		free_bytes_in_pool
000402  aa   000044 7330 00	lrs  	36
000403  aa  6 00116 0331 20	adl  	pr6|78,*		p_old_datum_length
000404  aa  6 00101 7561 00	stq  	pr6|65		free_bytes_in_pool
						STATEMENT 1 ON LINE 197
      if ^for_new_datum
      then free_bytes_in_ci = free_bytes_in_ci + p_old_datum_length;

000405  aa  6 00106 2351 00	lda  	pr6|70		for_new_datum
000406  aa   000005 6010 04	tnz  	5,ic		000413
000407  aa  6 00102 2351 00	lda  	pr6|66		free_bytes_in_ci
000410  aa   000044 7330 00	lrs  	36
000411  aa  6 00116 0331 20	adl  	pr6|78,*		p_old_datum_length
000412  aa  6 00102 7561 00	stq  	pr6|66		free_bytes_in_ci
						STATEMENT 1 ON LINE 200
      if determine_if_datum_fits
      then
         do;

000413  aa  6 00105 2351 00	lda  	pr6|69		determine_if_datum_fits
000414  aa   000017 6000 04	tze  	15,ic		000433
						STATEMENT 1 ON LINE 203
	  p_fits_in_ci = (p_new_datum_contents_length <= free_bytes_in_ci);

000415  aa  6 00120 2361 20	ldq  	pr6|80,*		p_new_datum_contents_length
000416  aa  6 00102 1161 00	cmpq 	pr6|66		free_bytes_in_ci
000417  aa  0 00520 7001 00	tsx0 	pr0|336		r_le_a
000420  aa  6 00130 7551 20	sta  	pr6|88,*		p_fits_in_ci
						STATEMENT 1 ON LINE 204
	  p_fits_in_pool = (p_new_datum_contents_length <= free_bytes_in_pool);

000421  aa  6 00101 1161 00	cmpq 	pr6|65		free_bytes_in_pool
000422  aa  0 00520 7001 00	tsx0 	pr0|336		r_le_a
000423  aa  6 00126 7551 20	sta  	pr6|86,*		p_fits_in_pool
						STATEMENT 1 ON LINE 205
	  p_free_bytes_in_ci = free_bytes_in_ci - p_new_datum_contents_length;

000424  aa  6 00102 3361 00	lcq  	pr6|66		free_bytes_in_ci
000425  aa   000044 7770 00	llr  	36
000426  aa   000044 7330 00	lrs  	36
000427  aa  6 00120 0331 20	adl  	pr6|80,*		p_new_datum_contents_length
000430  aa   000000 5330 00	negl 	0
000431  aa  6 00122 7561 20	stq  	pr6|82,*		p_free_bytes_in_ci
						STATEMENT 1 ON LINE 208
         end;

000432  aa   000005 7100 04	tra  	5,ic		000437
						STATEMENT 1 ON LINE 209
      else
         do;

						STATEMENT 1 ON LINE 211
	  p_free_bytes_in_ci = free_bytes_in_ci;

000433  aa  6 00102 2361 00	ldq  	pr6|66		free_bytes_in_ci
000434  aa  6 00122 7561 20	stq  	pr6|82,*		p_free_bytes_in_ci
						STATEMENT 1 ON LINE 212
	  p_free_bytes_in_pool = free_bytes_in_pool;

000435  aa  6 00101 2361 00	ldq  	pr6|65		free_bytes_in_pool
000436  aa  6 00124 7561 20	stq  	pr6|84,*		p_free_bytes_in_pool
						STATEMENT 1 ON LINE 213
         end;

						STATEMENT 1 ON LINE 215
      return;

000437  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 235
   end cm_determine_free_space;

BEGIN PROCEDURE CHECK_CI_VERSION
ENTRY TO CHECK_CI_VERSION                                   STATEMENT 1 ON LINE 217
CHECK_CI_VERSION:
   proc (ccv_p_given_version);

000440  aa  6 00132 6501 00	spri4	pr6|90
000441  aa  6 00134 2521 00	spri2	pr6|92
						STATEMENT 1 ON LINE 222
      if ccv_p_given_version ^= BASIC_CI_LAYOUT_1
      then call sub_err_ (dm_error_$unimplemented_ci_version, myname, ACTION_CANT_RESTART, null, 0,
	      "^/Expected version ^a control interval; received ^a.", BASIC_CI_LAYOUT_1, ccv_p_given_version);

000442  aa  2 00002 2351 20	lda  	pr2|2,*		ccv_p_given_version
000443  aa   777335 1150 04	cmpa 	-291,ic		000000 = 142143151061
000444  aa   000055 6000 04	tze  	45,ic		000521
000445  aa   777357 3734 24	epp7 	-273,ic*
000446  aa  6 00152 6535 00	spri7	pr6|106
000447  aa  6 00154 4501 00	stz  	pr6|108
000450  aa  000 100 100 404	mlr  	(ic),(pr),fill(000)
000451  aa   777356 00 0064	desc9a	-274,52		000026 = 136057105170
000452  aa  6 00156 00 0064	desc9a	pr6|110,52
000453  aa  6 00044 3701 20	epp4 	pr6|36,*
000454  la  4 00012 3521 20	epp2 	pr4|10,*		dm_error_$unimplemented_ci_version
000455  aa  6 00176 2521 00	spri2	pr6|126
000456  aa   777324 3520 04	epp2 	-300,ic		000002 = 143155137144
000457  aa  6 00200 2521 00	spri2	pr6|128
000460  aa   777337 3520 04	epp2 	-289,ic		000017 = 400000000000
000461  aa  6 00202 2521 00	spri2	pr6|130
000462  aa  6 00152 3521 00	epp2 	pr6|106
000463  aa  6 00204 2521 00	spri2	pr6|132
000464  aa  6 00154 3521 00	epp2 	pr6|108
000465  aa  6 00206 2521 00	spri2	pr6|134
000466  aa  6 00156 3521 00	epp2 	pr6|110
000467  aa  6 00210 2521 00	spri2	pr6|136
000470  aa   777310 3520 04	epp2 	-312,ic		000000 = 142143151061
000471  aa  6 00212 2521 00	spri2	pr6|138
000472  aa  6 00134 3715 20	epp5 	pr6|92,*
000473  aa  5 00002 3521 20	epp2 	pr5|2,*		ccv_p_given_version
000474  aa  6 00214 2521 00	spri2	pr6|140
000475  aa   777323 3520 04	epp2 	-301,ic		000020 = 404000000043
000476  aa  6 00216 2521 00	spri2	pr6|142
000477  aa   777316 3520 04	epp2 	-306,ic		000015 = 530000000040
000500  aa  6 00220 2521 00	spri2	pr6|144
000501  aa   777313 3520 04	epp2 	-309,ic		000014 = 514000000044
000502  aa  6 00222 2521 00	spri2	pr6|146
000503  aa   777317 3520 04	epp2 	-305,ic		000022 = 464000000000
000504  aa  6 00224 2521 00	spri2	pr6|148
000505  aa   777306 3520 04	epp2 	-314,ic		000013 = 404000000005
000506  aa  6 00226 2521 00	spri2	pr6|150
000507  aa   777303 3520 04	epp2 	-317,ic		000012 = 524000000064
000510  aa  6 00230 2521 00	spri2	pr6|152
000511  aa   777305 3520 04	epp2 	-315,ic		000016 = 524000000004
000512  aa  6 00232 2521 00	spri2	pr6|154
000513  aa  6 00234 2521 00	spri2	pr6|156
000514  aa  6 00174 6211 00	eax1 	pr6|124
000515  aa   040000 4310 07	fld  	16384,dl
000516  la  4 00010 3521 20	epp2 	pr4|8,*		sub_err_
000517  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
000520  aa   000002 7100 04	tra  	2,ic		000522
						STATEMENT 1 ON LINE 225
      else return;

000521  aa  6 00132 6101 00	rtcd 	pr6|90
						STATEMENT 1 ON LINE 227
   end CHECK_CI_VERSION;

000522  aa  6 00132 6101 00	rtcd 	pr6|90
  END PROCEDURE CHECK_CI_VERSION
  END PROCEDURE cm_determine_free_space


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
