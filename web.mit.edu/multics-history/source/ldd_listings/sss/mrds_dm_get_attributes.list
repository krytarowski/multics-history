	COMPILATION LISTING OF SEGMENT mrds_dm_get_attributes
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 10/16/86  1344.7 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 /* ******************************************************
       10*   *                                                    *
       11*   *                                                    *
       12*   * Copyright (c) 1976 by Massachusetts Institute of   *
       13*   * Technology and Honeywell Information Systems, Inc. *
       14*   *                                                    *
       15*   *                                                    *
       16*   ****************************************************** */
       17 
       18 
       19 /* BEGIN DESCRIPTION:
       20*
       21*   This routine  returns  info  about  the  attributes  of  a  given
       22*   relation   in  the  database  model.  There  are  three  entries.
       23*   mrd_dm_get_attributes is internal for use by mrds.  get_relations
       24*   is external for use by dmd_, and get_model_attributes is external
       25*   for use by mmi_. The external entries check for a non-dba  trying
       26*   to use this interface on a secured db.
       27*   
       28*   END DESCRIPTION
       29**/
       30 
       31 /* PARAMETERS:
       32*
       33*   ======= get_model_attributes entry
       34*
       35*   open_name - -  (input)  char(*),  the  opening  name  supplie  to
       36*   mmi_$open_model
       37*
       38*   relation_name - - (input) char(*), the relation  for  which  attr
       39*   info is desired
       40*
       41*   area_ptr - - (input) ptr, pointer to an area in which  to  return
       42*   info
       43*
       44*   structure_version - - (input) fixed bin,  the  desired  structure
       45*   version
       46*
       47*   mrds_db_model_rel_attrs_ptr -  -  (output)  ptr,  points  to  the
       48*   attribute      information      in      the      structure     in
       49*   mrd_db_model_rel_attrs.incl.pl1
       50*
       51*   code - - (output) fixed bin(35), the error status encoding
       52*
       53*   ======= get_attributes and mrds_dm_get_attributes entries
       54*
       55*   data_model_ptr - - (input) ptr, pointer returned from a  call  to
       56*   dmd_$open_dm
       57*
       58*   relation_name - - (input) char(32), the relation for  which  attr
       59*   info is desired
       60*
       61*   area_ptr - - (input) ptr, points to an area in  which  to  return
       62*   info
       63*
       64*   rd_ptr - - (output) ptr, points to the rel_desc  structure  given
       65*   in mrds_rel_desc.incl.pl1
       66*
       67*   code - - (output) fixed bin(35), the error status encoding
       68*
       69**/
       70 
       71 /* HISTORY:
       72*
       73*   Modified by Oris Friesen to accomodate new version data bases  --
       74*   October 1978
       75*
       76*   Modified by Jim Gray - - Feb. 1980, to correctly determine  which
       77*   version database data_model_ptr refers to.
       78*
       79*   Modified by Jim Gray - - April 1980,  to  correctly  handle  case
       80*   when unknown relation name is given.
       81*
       82*   Modified by Jim Gray - - 80-9-23, to add entries for setting type
       83*   of  descriptor,  user  or  db  view,  wanted in the returned info
       84*   structure
       85*
       86*   81-01-31 Jim Gray : added setting of needed access for DBA types,
       87*   if access violation occurred.
       88*
       89*   81-02-12 Jim Gray : added check  for  user  being  a  DBA  if  db
       90*   secured,  and  external  dmd_  entry  called, this get_attributes
       91*   entry should not be called by  mrds,  use  mrds_dm_get_attributes
       92*   instead.
       93*
       94*   81-04-23 Jim Gray : changed the method of  getting  the  relation
       95*   model  pointer.  Now  the  assumption  is  made that there is one
       96*   relation per file,  and  the  file  has  the  same  name  as  the
       97*   relation.  This  was  done on the premise that blocked files will
       98*   not be implemented.
       99*
      100*   81-04-23 Jim Gray : added get_model_attributes entry for mmi_
      101*
      102*   82-08-20 D. Woodka deleted reference to rel_desc.attributes.bit_offset
      103*   for DMS conversion.
      104*
      105*   82-11-24 Davids: modified to convert from rel_desc_v3 which is
      106*   returned from the call to dmd_v1_$get_attributes to the new
      107*   rel_desc structure.
      108*
      109*   83-06-21 Davids: Removed check for old version database and the call
      110*   to v1 code if it was an old version db (old version dbs can no longer
      111*   be opened)
      112**/
      113 
      114 /* BEGIN CHANGE 81-02-12 ********************************************* */
      115 
      116 mrds_dm_get_attributes: procedure (data_model_ptr_a, relation_name_a, area_ptr_a, rd_ptr_a, code_a);
      117 
      118 /* entry to be used internally by mrds, no access checking */
      119 
      120 	internal_call = "1"b;
      121 
      122 	data_model_ptr = data_model_ptr_a;
      123 	relation_name = relation_name_a;
      124 	area_ptr = area_ptr_a;
      125 
      126 	call common ();
      127 
      128 	code_a = code;
      129 	rd_ptr_a = rd_ptr;
      130 
      131 	return;
      132 
      133 
      134 
      135 get_attributes: entry (data_model_ptr_b, relation_name_b, area_ptr_b, rd_ptr_b, code_b);
      136 
      137 /* entry to be used by external calls, not mrds,
      138*   if the db is secured, then the caller must be a DBA */
      139 
      140 	internal_call = "0"b;
      141 
      142 	data_model_ptr = data_model_ptr_b;
      143 	relation_name = relation_name_b;
      144 	area_ptr = area_ptr_b;
      145 
      146 	call common ();
      147 
      148 	code_b = code;
      149 	rd_ptr_b = rd_ptr;
      150 
      151 	return;
      152 
      153 /* END CHANGE 81-02-12 ************************************************ */
      154 
      155 /* BEGIN CHANGE 81-04-23 B ***************************************** */
      156 
      157 get_model_attributes: entry (open_name, relation_name_c, area_ptr_c, structure_version,
      158 	mrds_db_model_rel_attrs_ptr, code_c);
      159 
      160 /* this entry is used by the mmi_ interface.
      161*   it calls get_attributes to handle both old and new version models,
      162*   and to have secured database non-dba user checks made. */
      163 
      164 	code_c = 0;
      165 	mrds_db_model_rel_attrs_ptr = null ();
      166 
      167 /* get a model pointer from the open name */
      168 
      169 	call mu_open_name_manager$get_model_pointer (open_name, model_type, model_ptr, code_c);
      170 	if code_c = 0 then do;
      171 
      172 /* get the attribute information */
      173 
      174 		call get_attributes (model_ptr, (relation_name_c), addr (local_area), rd_ptr_c, code_c);
      175 		if code_c = 0 then do;
      176 
      177 			rd_ptr = rd_ptr_c;
      178 			area_ptr = area_ptr_c;
      179 
      180 /* check the users arguments */
      181 
      182 			if area_ptr = null () then
      183 			     code_c = error_table_$badcall;
      184 			else do;
      185 				unspec (my_area_info) = "0"b;
      186 				my_area_info.version = 1;
      187 				my_area_info.areap = area_ptr;
      188 
      189 				call area_info_ (addr (my_area_info), code_c);
      190 				if code_c ^= 0 then ;
      191 				else if my_area_info.no_freeing then
      192 				     code_c = mrds_error_$not_freeing_area;
      193 				else do;
      194 
      195 					if structure_version ^= mrds_db_model_rel_attrs_structure_version then
      196 					     code_c = error_table_$unimplemented_version;
      197 					else do;
      198 
      199 
      200 /* fill in the users attribute structure */
      201 
      202 						on area begin;
      203 							code_c = error_table_$area_too_small;
      204 							goto skip_allocate;
      205 						     end;
      206 
      207 						on cleanup begin;
      208 							if mrds_db_model_rel_attrs_ptr ^= null () then do;
      209 								free mrds_db_model_rel_attrs in (return_area);
      210 								mrds_db_model_rel_attrs_ptr = null ();
      211 							     end;
      212 						     end;
      213 
      214 						mrds_db_model_rel_attrs_count_init = rel_desc.num_attr;
      215 						allocate mrds_db_model_rel_attrs set (mrds_db_model_rel_attrs_ptr) in (return_area);
      216 						revert area;
      217 
      218 						unspec (mrds_db_model_rel_attrs) = "0"b;
      219 						mrds_db_model_rel_attrs.version = mrds_db_model_rel_attrs_structure_version;
      220 						mrds_db_model_rel_attrs.attribute_count = mrds_db_model_rel_attrs_count_init;
      221 
      222 /* do all the attributes in this relation */
      223 
      224 						do i = 1 to mrds_db_model_rel_attrs_count_init;
      225 
      226 						     mrds_db_model_rel_attrs.attribute (i).name = rel_desc.attributes (i).attribute_name;
      227 						     mrds_db_model_rel_attrs.attribute (i).domain = rel_desc.attributes (i).domain_name;
      228 						     mrds_db_model_rel_attrs.attribute (i).user_data_type =
      229 							rel_desc.attributes (i).descriptor;
      230 						     if rel_desc.attributes (i).key_attr_order = 1 |
      231 							rel_desc.attributes (i).inver_flag then
      232 							mrds_db_model_rel_attrs.attribute (i).indexed = "1"b;
      233 
      234 						end;
      235 
      236 					     end;
      237 				     end;
      238 			     end;
      239 		     end;
      240 	     end;
      241 skip_allocate:
      242 
      243 	return;
      244 
      245 /* END CHANGE 81-04-23 B ***************************************** */
      246 
      247 /* entries to set wether the user or database view data type descriptor is to be returned */
      248 
      249 set_user_view: entry ();
      250 	user_data_type_wanted = "1"b;
      251 	return;
      252 
      253 set_db_view: entry ();
      254 	user_data_type_wanted = "0"b;
      255 	return;
      256 
      257 common: procedure ();
      258 	code = 0;
      259 	rd_ptr = null;
      260 
      261 /* check for which mrds version to call   based on which version of the model we have */
      262 
      263 	call hcs_$fs_get_path_name (data_model_ptr, db_path, ldn, model_name, code);
      264 	if code = 0 then do;
      265 
      266 /* check for the database being secured, but the user not being a DBA */
      267 
      268 		dbm_ptr = data_model_ptr;
      269 		if ^internal_call then
      270 		     call secured_db_check ();
      271 
      272 /* BEGIN CHANGE 81-04-23 A ********************************************** */
      273 
      274 		if code = 0 then do;
      275 
      276 /* check for a good relation name given   this search assumes that there is one relation per file,
      277*   and that the relation name is the same as the file name */
      278 
      279 			on no_read_permission begin;
      280 				code = mrds_error_$no_model_access;
      281 				rd_ptr = null ();
      282 				goto exit;
      283 			     end;
      284 
      285 			done, rel_found = "0"b;
      286 			fi_ptr = ptr (dbm_ptr, db_model.file_ptr);
      287 			do while (^done);
      288 			     if relation_name = file_info.file_name then
      289 				done, rel_found = "1"b;
      290 			     else if file_info.fwd_ptr ^= NULL_OFS then
      291 				fi_ptr = ptr (dbm_ptr, file_info.fwd_ptr);
      292 			     else done = "1"b;
      293 			end;
      294 			if ^rel_found then
      295 			     code = mrds_error_$no_model_rel;
      296 			else do;
      297 
      298 
      299 /* BEGIN CHANGE 81-01-31 ********************************************* */
      300 
      301 				call hcs_$initiate (db_path, rtrim (file_info.file_name) || ".m", "", 0, 1, fm_ptr, code);
      302 				if code = error_table_$moderr | code = error_table_$no_info then do;
      303 					call mrds_dm_authorization$set_needed_access
      304 					     (rtrim (db_path), code); /* fails if not DBA */
      305 					if code ^= 0 then
      306 					     code = mrds_error_$no_model_access;
      307 					else call hcs_$initiate (db_path, rtrim (file_info.file_name) || ".m", "", 0, 1,
      308 						fm_ptr, code);
      309 				     end;
      310 
      311 /* END CHANGE 81-01-31 *********************************************** */
      312 
      313 /* get the attribute information */
      314 
      315 				if fm_ptr ^= null () then do;
      316 					code = 0;
      317 					on cleanup begin;
      318 						if rd_ptr ^= null () then do;
      319 							free rel_desc in (return_area);
      320 							rd_ptr = null ();
      321 						     end;
      322 					     end;
      323 
      324 					ri_ptr = ptr (fm_ptr, file_model.rel_ptr); /* this assumes one relation per file */
      325 
      326 /* END CHANGE 81-04-23 A ************************************************* */
      327 
      328 					num_attr_alloc = rel_info.num_attr;
      329 					allocate rel_desc in (return_area);
      330 					unspec (rel_desc) = "0"b;
      331 					rel_desc.num_attr = num_attr_alloc;
      332 					rel_desc.key_length = rel_info.max_key_len;
      333 					rel_desc.data_length = rel_info.max_data_len;
      334 					rel_desc.num_keys = 0;
      335 					rel_desc.inversion = rel_info.indexed;
      336 
      337 /* go through all attributes in this relation */
      338 
      339 					cnt = 1;
      340 					do ai_ptr = ptr (fm_ptr, rel_info.attr_ptr)
      341 					     repeat ptr (fm_ptr, attr_info.fwd_thread)
      342 					     while (rel (ai_ptr) ^= NULL_OFS);
      343 					     rel_desc.attributes.attribute_name (cnt) = attr_info.name;
      344 					     di_ptr = ptr (dbm_ptr, attr_info.domain_ptr);
      345 					     rel_desc.attributes.domain_name (cnt) = domain_info.name;
      346 
      347 					     rel_desc.attributes.bit_length (cnt) = bit (fixed (attr_info.bit_length, 18));
      348 					     rel_desc.attributes.key_flag (cnt) = attr_info.key_attr;
      349 					     rel_desc.attributes.inver_flag (cnt) = attr_info.index_attr;
      350 					     rel_desc.attributes.key_attr_order (cnt) = attr_info.key_order;
      351 					     if user_data_type_wanted | ^internal_call then
      352 						rel_desc.attributes.descriptor (cnt) = domain_info.user_desc;
      353 					     else rel_desc.attributes.descriptor (cnt) = domain_info.db_desc;
      354 					     if attr_info.key_attr then rel_desc.num_keys = rel_desc.num_keys + 1;
      355 					     cnt = cnt + 1;
      356 					end;
      357 				     end;
      358 			     end;
      359 		     end;
      360 	     end;
      361 exit:
      362 	return;
      363      end;
      364 
      365 /* BEGIN CHANGE 81-02-12 ********************************************* */
      366 
      367 secured_db_check: procedure ();
      368 
      369 /* routine to check for the database being is a secured state,
      370*   and if so, that the user is a DBA, and thus may use the external entry */
      371 
      372 	if code ^= 0 then ;
      373 	else if internal_call then ;
      374 	else do;
      375 
      376 /* get the secured state of the dataabase */
      377 
      378 		call mrds_dm_db_secured$get_secured_status (dbm_ptr, addr (local_area),
      379 		     database_state_structure_version, database_state_ptr, code);
      380 		if code ^= 0 then
      381 
      382 		     call sub_err_ (code, caller_name, continue, info_ptr, return_value, "^/^a^a^a",
      383 			"Unable to get the secured state of database """, db_path, """.");
      384 
      385 		else if ^database_state.secured then ;
      386 		else do;
      387 
      388 /* database secured, see if the user is a DBA */
      389 
      390 			call mrds_dm_authorization$get_user_class (rtrim (db_path), addr (local_area),
      391 			     mrds_authorization_structure_version, mrds_authorization_ptr, code);
      392 			if code ^= 0 then
      393 
      394 			     call sub_err_ (code, caller_name, continue, info_ptr, return_value, "^/^a^a^a",
      395 				"Unable to get user class for database """, db_path, """.");
      396 
      397 			else if mrds_authorization.administrator then ;
      398 			else do;
      399 
      400 /* not DBA on secured db, issue error */
      401 
      402 				code = error_table_$insufficient_access;
      403 				call sub_err_ (code, caller_name, continue, info_ptr, return_value, "^/^a^a^a ^a",
      404 				     "The database """, db_path, """ has been secured,",
      405 				     "so the caller must be a DBA to use direct model access.");
      406 
      407 			     end;
      408 
      409 		     end;
      410 
      411 	     end;
      412 
      413 	if code ^= 0 then
      414 	     data_model_ptr, dbm_ptr = null ();
      415 
      416      end;
      417 
      418 /* END CHANGE 81-02-12 ************************************************ */
      419 
      420 	declare NULL_OFS		 int static bit (18) unal init ("111111111111111111"b) options (constant);
      421 	declare area		 condition;	/* if area too small */
      422 	declare area_info_		 entry (ptr, fixed bin (35)); /* gets area details */
      423 	declare area_ptr		 ptr;		/* pointer to area in which information is returned */
      424 	declare area_ptr_a		 ptr;		/* temp for mrds_dm_get_attributes entry */
      425 	declare area_ptr_b		 ptr;		/* temp for get_attributes entry */
      426 	declare area_ptr_c		 ptr;		/* temp for get_model_attributes entry */
      427 	declare caller_name		 char (32) init ("dmd_$open_dm"); /* name of calling routine */
      428 	declare cleanup		 condition;
      429 	declare cnt		 fixed bin;
      430 	declare code		 fixed bin (35);	/* a standard Multics system status code */
      431 	declare code_a		 fixed bin (35);	/* temp for mrds_dm_get_attributes entry */
      432 	declare code_b		 fixed bin (35);	/* temp for get_attributes entry */
      433 	declare code_c		 fixed bin (35);	/* temp for get_model_attributes entry */
      434 	declare continue		 char (1) init ("c"); /* dont stop after print mesg */
      435 	declare data_model_ptr	 ptr;		/* pointer to data model to be searched (Input) */
      436 	declare data_model_ptr_a	 ptr;		/* temp for mrds_dm_get_attributes entry */
      437 	declare data_model_ptr_b	 ptr;		/* temp for get_attributes entry */
      438 	declare db_path		 char (168);
      439 	declare done		 bit (1);		/* on => get out of loop */
      440 	declare error_table_$area_too_small fixed bin (35) ext; /* area not big enough */
      441 	declare error_table_$badcall	 fixed bin (35) ext;/* null area ptr */
      442 	declare error_table_$insufficient_access fixed bin (35) ext; /* not DBA and db secured */
      443 	declare error_table_$moderr	 fixed bin (35) ext;/* incorrect access */
      444 	declare error_table_$no_info	 fixed bin (35) ext;/* no db dir acl, and no rel model acl */
      445 	declare error_table_$unimplemented_version fixed bin (35) ext; /* unknown structure version */
      446 	declare hcs_$fs_get_path_name	 entry (ptr, char (*), fixed bin, char (*), fixed bin (35));
      447 	declare hcs_$initiate	 entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
      448 	declare i			 fixed bin;	/* loop index */
      449 	declare info_ptr		 ptr init (null ());/* unused */
      450 	declare internal_call	 bit (1);		/* on => called from mrds, not by dmd_ */
      451 	declare ldn		 fixed bin;
      452 	declare local_area		 area (8192);	/* space for db state, and user class info */
      453 	declare mu_open_name_manager$get_model_pointer entry (char (*), char (1), ptr, fixed bin (35)); /* gets ptr from name */
      454 	declare model_name		 char (32);
      455 	declare model_ptr		 ptr;
      456 	declare model_type		 char (1);	/* type of model opening */
      457 	declare mrds_dm_authorization$get_user_class entry (char (*), ptr, fixed bin, ptr, fixed bin (35)); /* finds if DBA */
      458 	declare mrds_dm_authorization$set_needed_access entry (char (*), fixed bin (35)); /* sets access for DBA types */
      459 	declare mrds_dm_db_secured$get_secured_status entry (ptr, ptr, fixed bin, ptr, fixed bin (35)); /* gets secured bit */
      460 	declare mrds_error_$no_model_access fixed bin (35) ext; /* no r acl to model */
      461 	declare mrds_error_$no_model_rel fixed bin (35) ext; /* rel name not known in model */
      462 	declare mrds_error_$not_freeing_area fixed bin (35) ext; /* no freeing attr for area */
      463 	declare no_read_permission	 condition;	/* no r acl to model */
      464 	declare open_name		 char (*);	/* name associated with this model opening */
      465 	declare rd_ptr_a		 ptr;		/* temp for mrds_dm_get_attributes entry */
      466 	declare rd_ptr_b		 ptr;		/* temp for get_attributes entry */
      467 	declare rd_ptr_c		 ptr;		/* temp for get_model_attributes entry */
      468 	declare rel_found		 bit (1);		/* on => good rel name given */
      469 	declare relation_name	 char (32);	/* name of relation for which attribute information is desired */
      470 	declare relation_name_a	 char (32);	/* temp for mrds_dm_get_attributes entry */
      471 	declare relation_name_b	 char (32);	/* temp for get_attributes entry */
      472 	declare relation_name_c	 char (*);	/* temp for get_model_attributes entry */
      473 	declare return_area		 area (sys_info$max_seg_size) based (area_ptr);
      474 	declare return_value	 fixed bin (35) init (0); /* unused */
      475 	declare structure_version	 fixed bin;	/* desired structure version */
      476 	declare sub_err_		 entry options (variable); /* reports errors */
      477 	declare sys_info$max_seg_size	 fixed bin (35) external;
      478 	declare user_data_type_wanted	 bit (1) init ("0"b) int static; /* on => user descr, else db descr */
      479 	declare (addr, bit, empty, fixed, null, ptr, rel, rtrim, unspec) builtin;
      480 	declare 1 my_area_info	 like area_info;	/* local copy */
      481 
  1     1 /* BEGIN INCLUDE FILE mdbm_db_model.incl.pl1 -- jaw, 10/2/78 */
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(79-02-01,Gray), approve(), audit(), install():
  1     6*     modified to save space occupied by model
  1     7*  2) change(80-11-03,Gray), approve(), audit(), install():
  1     8*     to add mdbm_secured bit in db_model
  1     9*  3) change(82-04-09,Davids), approve(), audit(), install():
  1    10*     collapsed the following into an unused_offset array:
  1    11*       chng_before_path_ptr  chng_err_path_ptr  chng_after_path_ptr
  1    12*       copy_before_path_ptr  copy_err_path_ptr  copy_after_path_ptr
  1    13*       dsply_before_path_pt  dsply_err_path_pt  dsply_after_path_ptr
  1    14*       accs_before_path_ptr  accs_err_path_ptr  accs_after_path_ptr
  1    15*       unused_1
  1    16*     Also changed the name of unused_2 to restructuring_history_offset
  1    17*     and changed the comment on the changer structure to indicate
  1    18*     that it will contain on database creation information.
  1    19*  4) change(82-04-14,Davids), approve(), audit(), install():
  1    20*     used one of the unused_offsets to point to a message which indicates
  1    21*     why the db is inconsistent. The offset will be null when the db is created
  1    22*     and set the first time the message is used. this is so it will be
  1    23*     consistent with existing data bases. Also added the message structure.
  1    24*  5) change(82-04-28,Davids), approve(), audit(), install():
  1    25*     added the undo_request element to the message structure
  1    26*  6) change(82-05-04,Davids), approve(), audit(), install():
  1    27*     changed unused_offset (12) to last_restructruring_history_offset and
  1    28*     changed restructuring_history_offset to first_restructuring_history_offset
  1    29*  7) change(82-08-19,Davids), approve(), audit(), install():
  1    30*     changed the meaning of db_type from 1 => relational and 2 => CODASYL to
  1    31*     1 => vfile database and 2 => page_file database. Up to this point all
  1    32*     database types were equal to 1.
  1    33*  8) change(83-02-14,Davids), approve(), audit(), install():
  1    34*     changed db_type from a fixed bin unal to a substructure of 18 bit (1) unal
  1    35*     flags. This will allow information about transactions and dm_file
  1    36*     concurrency to be independent of the db_type, i.e. vfile or dm_file. The
  1    37*     change is compatable with all datamodels created by the released version
  1    38*     of mrds.
  1    39*  9) change(83-02-15,Davids), approve(), audit(), install():
  1    40*     added the rollback_on flag to the db_type_flags since it appears that you
  1    41*     can have a dmfile database that requires transactions but does not have any
  1    42*     journalizing. Also switched the order of the transactions_needed and
  1    43*     concurrency_on flags - this makes the change compatable with existing
  1    44*     dmfile databases except when displaying the model since concurrency_on and
  1    45*     rollback_on will be off in the model even though the dmfile relations had
  1    46*     them on during creation.
  1    47* 10) change(83-02-22,Kubicar), approve(), audit(), install():
  1    48*      Removed ctl_file_path_ptr.
  1    49* 11) change(85-11-08,Spitzer), approve(85-12-03,MCR7311),
  1    50*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  1    51*      used 1 unused offset for unreferenced attribute linked lists in db_model,
  1    52*      1 unused bit flag in domain_info to indicate an unreferenced domain, 1 bit
  1    53*      in the flag word for rmdb copying.
  1    54*                                                   END HISTORY COMMENTS */
  1    55 
  1    56 
  1    57 /* this include file contains the structures that go into the make up
  1    58*   of the "db_model" segment in the model for the database.
  1    59*   in addition there file_model.m segments, 1 for each database file(see mdbm_file_model.incl.pl1)
  1    60*
  1    61*   the db_model structure goes at the base of the segment, and contains items unique to
  1    62*   the whole databse. in addition, it has an area of size to fill the
  1    63*   rest of a segment, that holds the lists of files and domains in the database.
  1    64*   these lists are singly forward linked lists. all "pointers" in the database model
  1    65*   are maintained as offsets(bit (18)) from the base of the particular model segment
  1    66*   since actual pointers are process dependent on segment number.
  1    67*   the remaining structures are first a path_entry one to save pathnames in,
  1    68*   and the stack_item and constent structures, used to save a boolean
  1    69*   expression in polish form, with the stack represented by a linked list.
  1    70*   the final structure is one for identifying the status of version information */
  1    71 
  1    72      dcl	   1 db_model	      aligned based (dbm_ptr),/* base of db_model segment, allocated once per database */
  1    73 	     2 version	      unal fixed bin,	/* data base version, currently 4 */
  1    74 	     2 db_type_flags      unal,
  1    75 	       3 copy_good	      bit (1) unal,		/* "1"b => copy of the db_model is the valid copy */
  1    76 	       3 unused	      (13) bit (1) unal,
  1    77 	       3 rollback_on      bit (1) unal,		/* "1"b => before journaling is to be done */
  1    78 	       3 concurrency_on   bit (1) unal,		/* "1"b => dm_file concurrency is being used */
  1    79 	       3 transactions_needed bit (1) unal,	/* "1"b => transactions are needed to reference data */
  1    80 	       3 vfile_type	      bit (1) unal,		/* "1"b => vfile type relations, "0"b => dm_file type relations */
  1    81 	     2 uniq_sw_name	      char (32),		/* per database unique attach switch name for files */
  1    82 	     2 consistant	      bit (1) unal,		/* ON => correctly created/restructured database, ok to open */
  1    83 	     2 mdbm_secured	      bit (1) unal,		/* on => database has been secured */
  1    84 	     2 reserved	      bit (34) unal,	/* reserved for flags */
  1    85 	     2 blk_file_id_len    unal fixed bin,	/* no. bits required for blocked file id. */
  1    86 	     2 unblk_file_id_len  unal fixed bin,	/* number of file id bits, unblocked file */
  1    87 	     2 num_blk_files      unal fixed bin,	/* number of blocked files defined in db */
  1    88 	     2 num_unblk_files    unal fixed bin,	/* number of unblocked files defined in db */
  1    89 	     2 num_rels	      unal fixed bin,	/* number of relations defined in db. */
  1    90 	     2 num_domains	      unal fixed bin,	/* number of domains defined */
  1    91 	     2 num_dyn_links      unal fixed bin,	/* no. dynamic links defined */
  1    92 	     2 max_max_tuples     unal fixed bin (35),	/* maximum max_tuples across all files */
  1    93 	     2 pad_1	      unal fixed bin (35),	/* for future use */
  1    94 	     2 pad_2	      unal fixed bin (35),	/* for future use */
  1    95 	     2 version_ptr	      bit (18),		/* offset to version structure */
  1    96 	     2 file_ptr	      unal bit (18),	/* offset to first in threaded list of file_infos */
  1    97 	     2 domain_ptr	      unal bit (18),	/* offset to first in list of domain_infos */
  1    98 	     2 unreferenced_attribute_ptr unal bit (18),	/* offset to first in list of unreferenced attr_infos */
  1    99 	     2 unused_offsets     (11) unal bit (18),	/* extra offsets if needed */
  1   100 	     2 last_restructuring_history_offset unal bit (18), /* offset to last restructuring history entry */
  1   101 	     2 inconsistent_message_offset unal bit (18), /* offset to message indicating why db is inconsistent */
  1   102 	     2 first_restructuring_history_offset unal bit (18), /* offset to first restructuring history entry */
  1   103 	     2 changer_ptr	      unal bit (18),	/* offset to information about db creation */
  1   104 	     2 dbm_area	      area (sys_info$max_seg_size - fixed (rel (addr (db_model.dbm_area))) - 1);
  1   105 
  1   106      dcl	   dbm_ptr	      ptr;
  1   107 
  1   108 /* the files in the database each have a file_info containing
  1   109*   their name, the file_model for each file is found by initiating the
  1   110*   segment "file_name.m" (i.e. the file's name with suffix ".m")
  1   111*   the file_info list is a singly linked list in definition order */
  1   112 
  1   113      dcl	   1 file_info	      aligned based (fi_ptr), /* list of file names and numbers */
  1   114 	     2 file_name	      char (30),		/* name of file */
  1   115 	     2 file_id	      bit (36),		/* id number of file */
  1   116 	     2 fwd_ptr	      unal bit (18),	/* thread to next in list */
  1   117 	     2 unused	      unal bit (18);	/* for future expansion */
  1   118 
  1   119      dcl	   fi_ptr		      ptr;
  1   120 
  1   121 /* each domain used in the database will have a domain info saved in the db_model
  1   122*   segment. it describes the domain of the given name, and it's options.
  1   123*   the domain_info's form a singly linked list in definition order */
  1   124 
  1   125      dcl	   1 domain_info	      aligned based (di_ptr), /* one for each domain defined */
  1   126 	     2 name	      char (32),		/* name of domain */
  1   127 	     2 db_desc_is_ptr     bit (1) unal,		/* on if descriptor is pointer to real desc. */
  1   128 	     2 user_desc_is_ptr   bit (1) unal,		/* on if user desc is ptr */
  1   129 	     2 no_conversion      bit (1) unal,		/* if no conversion allowed */
  1   130 	     2 procedures_present bit (1) unal,		/* on => ids type procedures present */
  1   131 	     2 unreferenced	      bit (1) unal,		/* on => this domain is not used in any attribute */
  1   132 	     2 reserved	      bit (31) unal,
  1   133 	     2 db_desc	      bit (36),		/* desc. for item in db, or ptr to it */
  1   134 	     2 user_desc	      bit (36),		/* desc. for user-visible attr, or ptr */
  1   135 	     2 ave_len	      fixed bin (35),	/* average length of  varying string */
  1   136 	     2 nck_items	      unal fixed bin,	/* no. items in check stack */
  1   137 	     2 fwd_thread	      unal bit (18),	/* offset to next in list */
  1   138 	     2 check_path_ptr     unal bit (18),	/* integ. check proc. */
  1   139 	     2 ck_stack_ptr	      unal bit (18),	/* to check stack */
  1   140 	     2 encd_path_ptr      unal bit (18),	/* encode procedure */
  1   141 	     2 decd_path_ptr      unal bit (18),	/* decode procedure */
  1   142 	     2 str_before_path_ptr unal bit (18),	/* proc paths and entries */
  1   143 	     2 str_err_path_ptr   unal bit (18),
  1   144 	     2 str_after_path_ptr unal bit (18),
  1   145 	     2 get_before_path_ptr unal bit (18),
  1   146 	     2 get_err_path_ptr   unal bit (18),
  1   147 	     2 get_after_path_ptr unal bit (18),
  1   148 	     2 mod_before_path_ptr unal bit (18),
  1   149 	     2 mod_err_path_ptr   unal bit (18),
  1   150 	     2 mod_after_path_ptr unal bit (18),
  1   151 	     2 unused_1	      unal bit (18),	/* for future expansion */
  1   152 	     2 unused_2	      unal bit (18),
  1   153 	     2 changer_ptr	      unal bit (18);	/* pointer to change_id and chane_time structure */
  1   154 
  1   155      dcl	   di_ptr		      ptr;
  1   156 
  1   157 /* information necessary for attributes that are not used in any relation */
  1   158 
  1   159      dcl     1 unreferenced_attribute aligned based (ua_ptr),
  1   160 	     2 name char (32),			/* name of attribute */
  1   161 	     2 domain_ptr bit (18) unal,		/* to domain_info */
  1   162 	     2 fwd_thread bit (18) unal,		/* to next in list */
  1   163 	     2 unused (2) bit (18) unal;
  1   164 
  1   165      dcl     ua_ptr ptr;
  1   166 
  1   167 
  1   168 /* space saving pathname$entryname structure, to be allocated
  1   169*   only when a path$entry has to be saved, else only a bit(18)
  1   170*   offset takes up space in the main model structure */
  1   171 
  1   172      declare 1 path_entry	      based (path_entry_ptr),
  1   173 	     2 path	      char (168),		/* pathname portion of desired path$entry */
  1   174 	     2 entry	      char (32),		/* entryname portion of desired path$entry */
  1   175 	     2 reserved	      unal bit (36);	/* for future use */
  1   176 
  1   177      declare path_entry_ptr	      ptr;
  1   178 
  1   179 
  1   180 
  1   181 
  1   182 
  1   183 /* declarations for model of postfix stack holding the check option boolean expression
  1   184*   the following encoding values indicate the corresponding type of stack element
  1   185*
  1   186*   1  =
  1   187*   2  ^=
  1   188*   3  >
  1   189*   4  <
  1   190*   5  >=
  1   191*   6  <=
  1   192*
  1   193*   10  and
  1   194*   20  or
  1   195*   30  not
  1   196*
  1   197*   40  - (minus)
  1   198*
  1   199*   50  domain variable(same name as domain)
  1   200*
  1   201*   60  constant(number, bit string, or character string)
  1   202*
  1   203**/
  1   204 
  1   205 
  1   206      declare 1 stack_item	      based (stack_item_ptr), /* element of stack model list */
  1   207 	     2 next	      bit (18),		/* link to next in list */
  1   208 	     2 type	      fixed binary,		/* code for this element type */
  1   209 	     2 value_ptr	      bit (18);		/* pointer to variable holding value,
  1   210*						   if this is a constant element type */
  1   211 
  1   212      declare stack_item_ptr	      ptr;		/* pointer to a stack element */
  1   213 
  1   214 
  1   215 
  1   216      declare 1 constant	      based (constant_ptr),	/* variable size space for constant's value storage */
  1   217 	     2 length	      fixed bin (35),	/* length allocated to hold value */
  1   218 	     2 value	      bit (alloc_length refer (constant.length)) aligned; /* value for this constant */
  1   219 
  1   220      declare constant_ptr	      ptr;		/* pointer to constant's value space */
  1   221 
  1   222      declare alloc_length	      fixed binary (35) internal static; /* amount of space to allocate for constant's value */
  1   223 
  1   224 /* version structure, giving status of source for CMDB/RMDB,
  1   225*   status of model, and status of resultant */
  1   226 
  1   227 /* version number is in form MM.N.Y
  1   228*   where MM is the major version number, N is the minor version alteration,
  1   229*   and Y is the lastest modification to that alteration,
  1   230*   where M and N represent numbers 0-9, and Y is a letter */
  1   231 
  1   232      declare 1 version_status	      unal based (version_status_ptr),
  1   233 	     2 cmdb_rmdb,
  1   234 	       3 major	      fixed bin,
  1   235 	       3 minor	      fixed bin,
  1   236 	       3 modification     char (4),
  1   237 	     2 model,
  1   238 	       3 major	      fixed bin,
  1   239 	       3 minor	      fixed bin,
  1   240 	       3 modification     char (4),
  1   241 	     2 resultant,
  1   242 	       3 major	      fixed bin,
  1   243 	       3 minor	      fixed bin,
  1   244 	       3 modification     char (4);
  1   245 
  1   246      declare version_status_ptr     ptr;
  1   247 
  1   248 
  1   249 /* maintains information only about the db creation */
  1   250 
  1   251      declare 1 changer	      unal based (changer_ptr),
  1   252 	     2 id		      char (32),
  1   253 	     2 time	      fixed bin (71),
  1   254 	     2 next	      bit (18);		/* to next in the singly linked list */
  1   255 
  1   256      declare changer_ptr	      ptr;
  1   257 
  1   258 
  1   259      dcl	   01 message_str	      unal based (message_str_ptr), /* general purpose structure to hold messages */
  1   260 	     02 len	      fixed bin,		/* length of the message */
  1   261 	     02 text	      char (message_str_len refer (message_str.len)), /* actual message */
  1   262 	     02 name	      char (32),		/* name of thing that set the message */
  1   263 	     02 undo_request      char (100),		/* rmdb request that will undo the operation
  1   264*                                                               that caused the database to become inconsistent */
  1   265 	     02 mbz	      bit (36);		/* for possible extensions, like an offset to another message */
  1   266 
  1   267      dcl	   message_str_ptr	      ptr;		/* pointer to the message_str structure */
  1   268 
  1   269      dcl	   message_str_len	      fixed bin;		/* initail length of the text string in message_str */
  1   270 
  1   271 /* END INCLUDE FILE mdbm_db_model.incl.pl1 */
  1   272 
  1   273 
      482 
      483 
  2     1 /* BEGIN INCLUDE FILE mdbm_file_model.incl.pl1 -- jaw, 8/29/78 */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(79-02-01,JGray), approve(), audit(), install():
  2     6*     modified to save space occupied by model
  2     7*  2) change(82-05-19,Davids), approve(), audit(), install():
  2     8*     renamed rel_info.nsec_inds to rel_info.unused_3 because it really wasn't
  2     9*     the number of secondary indices in the relation - it was always zero.
  2    10*  3) change(82-08-19,DWoodka), approve(), audit(), install():
  2    11*     changed rel_info.id and attr_info.index_id to bit (36) unaligned for the
  2    12*     DMS conversion.
  2    13*  4) change(82-09-20,MKubicar), approve(), audit(), install():
  2    14*     changed rel_info.id and attr_info.index_id to aligned; they are needed that
  2    15*     way for relmgr_ calls.  Also added rel_info.primary_key_index_id, needed
  2    16*     for relation manager changes.
  2    17*  5) change(85-12-02,Spitzer), approve(85-12-02,MCR7311),
  2    18*     audit(86-09-02,Blair), install(86-10-16,MR12.0-1187):
  2    19*     used 2 reserved bits to indicate whether the copy of the <rel>.m and/or
  2    20*     <rel> files are good (for rmdb)
  2    21*                                                   END HISTORY COMMENTS */
  2    22 
  2    23 
  2    24 /* each file in the database will have a model segment with the name
  2    25*   file_name.m (i.e. the files name plus a suffix of ".m")
  2    26*   the file_model structure is allocated at the base of the segment for a given file.
  2    27*   it contains an area with which all other structures in this include file are allocated.
  2    28*   these structures contain the information about which relations, foreign keys,
  2    29*   and attributes are members of this file. all lists are singly linked lists in
  2    30*   definition order. pointers to these structures are obtained by using the "pointer"
  2    31*   builtin function with arguments of the segment base pointer, and the
  2    32*   offset (bit (18)) relative to that pointer that is actually stored in
  2    33*   the file model itself. this is because pointer segment numbers are
  2    34*   per process dependent. the major lists pointed to by the file_model structure
  2    35*   are the list of relations in this file(each with a contained attribute list),
  2    36*   and the list of foreign keys whose parent relation resides in this file
  2    37*   (along with a participating attribute sublist, and the child relation list,
  2    38*   if they are also in this file) */
  2    39 
  2    40 dcl 1 file_model aligned based (fm_ptr),		/* base of segment */
  2    41     2 temporary bit (1) unal,				/* on if file not part of db. */
  2    42     2 procedures_present bit (1) unal,			/* on => ids procedures present */
  2    43     2 file_model_copy_good bit (1) unaligned,		/* on => <rel>.m file is the good copy */
  2    44     2 relation_copy_good bit (1) unaligned,		/* on => <rel> file is the good copy */
  2    45     2 reserved bit (32) unal,				/* reserved for future flags */
  2    46     2 max_tuples fixed bin (35),			/* max no. of tuples in file */
  2    47     2 num_blocks fixed bin (35),			/* number of blocks in file */
  2    48     2 num_buckets fixed bin (35),			/* number of buckets in file */
  2    49     2 pad_1 fixed bin (35),				/* for future use */
  2    50     2 pad_2 fixed bin (35),
  2    51     2 ratd_len fixed bin (21),			/* length of above */
  2    52     2 mratd_len fixed bin (21),			/* length of above */
  2    53     2 uatd_len fixed bin (21),			/* char. length of update attach desc. */
  2    54     2 latd_len fixed bin (21),			/* char. len. of attach desc. */
  2    55     2 sratd_len fixed bin (21),			/* char. length of above attach desc. */
  2    56     2 suatd_len fixed bin (21),			/* char. length of attach desc. */
  2    57     2 file_type unal fixed bin,			/* 1 => unblocked, 2 => blocked */
  2    58     2 block_size unal fixed bin,			/* no. pages in block */
  2    59     2 block_factor unal fixed bin,			/* no. tuple slots per block */
  2    60     2 bucket_density unal fixed bin,			/* no. of bucket headers per block, neg. => blocks per header */
  2    61     2 tuple_id_len unal fixed bin,			/* no. bits needed for local tuple id */
  2    62     2 num_rels unal fixed bin,			/* number of relations in file */
  2    63     2 num_links unal fixed bin,			/* number of links in file */
  2    64     2 num_children unal fixed bin,			/* count of all child_link_infos in this file */
  2    65     2 default_rbs (3) unal fixed bin (8),		/* file ring brackets when not MDBM-secured */
  2    66     2 rel_ptr unal bit (18),				/* to first of list of rel_infos */
  2    67     2 link_ptr unal bit (18),				/* to first in list of parent link_infos */
  2    68     2 children_ptr unal bit (18),			/* to list of all child_link_infos in this file model */
  2    69     2 cno_array_ptr unal bit (18),			/* pointer to array of data component numbers */
  2    70     2 fi_ptr unal bit (18),				/* offset to file_info in db_model */
  2    71     2 suatd_ptr unal bit (18),			/* offset of scope_update attach desc. */
  2    72     2 sratd_ptr unal bit (18),			/* offset of scope_retrieve attach desc. */
  2    73     2 latd_ptr unal bit (18),				/* offset of load attach desc. */
  2    74     2 uatd_ptr unal bit (18),				/* offset of update attach description for file */
  2    75     2 mratd_ptr unal bit (18),			/* offset of moniter-retrieve attach desc. */
  2    76     2 ratd_ptr unal bit (18),				/* offset of retrieve attach desc. */
  2    77     2 open_eu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  2    78     2 open_eu_err_path_ptr unal bit (18),
  2    79     2 open_eu_after_path_ptr unal bit (18),
  2    80     2 open_er_before_path_ptr unal bit (18),
  2    81     2 open_er_err_path_ptr unal bit (18),
  2    82     2 open_er_after_path_ptr unal bit (18),
  2    83     2 open_neu_before_path_ptr unal bit (18),		/* paths and ents of file procs. */
  2    84     2 open_neu_err_path_ptr unal bit (18),
  2    85     2 open_neu_after_path_ptr unal bit (18),
  2    86     2 open_ner_before_path_ptr unal bit (18),
  2    87     2 open_ner_err_path_ptr unal bit (18),
  2    88     2 open_ner_after_path_ptr unal bit (18),
  2    89     2 open_pu_before_path_ptr unal bit (18),
  2    90     2 open_pu_err_path_ptr unal bit (18),
  2    91     2 open_pu_after_path_ptr unal bit (18),
  2    92     2 open_pr_before_path_ptr unal bit (18),
  2    93     2 open_pr_err_path_ptr unal bit (18),
  2    94     2 open_pr_after_path_ptr unal bit (18),
  2    95     2 open_cu_before_path_ptr unal bit (18),
  2    96     2 open_cu_err_path_ptr unal bit (18),
  2    97     2 open_cu_after_path_ptr unal bit (18),
  2    98     2 open_cr_before_path_ptr unal bit (18),
  2    99     2 open_cr_err_path_ptr unal bit (18),
  2   100     2 open_cr_after_path_ptr unal bit (18),
  2   101     2 close_before_path_ptr unal bit (18),
  2   102     2 close_err_path_ptr unal bit (18),
  2   103     2 close_after_path_ptr unal bit (18),
  2   104     2 unused_1 unal bit (18),				/* for future expansion */
  2   105     2 unused_2 unal bit (18),
  2   106     2 changer_ptr unal bit (18),			/* pointer to changer_id, changer_time structure */
  2   107     2 fm_area area (sys_info$max_seg_size - fixed (rel (addr (file_model.fm_area))) - 1);
  2   108 dcl  fm_ptr ptr;
  2   109 dcl  atd char (atd_len) based (atd_ptr);		/* attach description for each file ready mode */
  2   110 dcl  atd_ptr ptr;
  2   111 dcl  atd_len fixed bin;
  2   112 dcl 1 comp_no_array unal based (cna_ptr),		/* ordered array of data comp. nos. */
  2   113     2 ncomponents fixed bin,
  2   114     2 comp_no (ncomp_init refer (comp_no_array.ncomponents)) fixed bin;
  2   115 dcl  cna_ptr ptr;
  2   116 dcl  ncomp_init fixed bin;
  2   117 
  2   118 /* a rel_info structure contains information describing a relation.
  2   119*   a relation may only occur in one file, thus there is one rel_info
  2   120*   per relation per database, each stored in the file_model area for
  2   121*   the file that contains it. the list of rel_info's in this file
  2   122*   form a singly linked list in definition order.
  2   123*   the rel_info itself points to a list of the attributes it contains,
  2   124*   and to any parent_link or child_link info's that involve it in a foreign key */
  2   125 
  2   126 dcl 1 rel_info aligned based (ri_ptr),
  2   127     2 name char (32),				/* relation name */
  2   128     2 id  bit (36) aligned,				/* relation id number */
  2   129     2 hashed bit (1) unal,				/* on if hashed */
  2   130     2 duplicates bit (1) unal,			/* on if allow dup. hash fields */
  2   131     2 via_link bit (1) unal,				/* on if to be stored by parent */
  2   132     2 system bit (1) unal,				/* on if dont care how stored */
  2   133     2 indexed bit (1) unal,				/* on if secondary index */
  2   134     2 mrds_update bit (1) unal,			/* on if updateable by MRDS */
  2   135     2 mrds_retrieve bit (1) unal,			/* on if retrievable by MRDS */
  2   136     2 virtual bit (1) unal,				/* if virtual relation, mapped on IDS records */
  2   137     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  2   138     2 reserved bit (27) unal,				/* for future flags */
  2   139     2 num_attr unal fixed bin,			/* number of attributes (all levels) defined */
  2   140     2 num_links_child unal fixed bin,			/* no. links in which child */
  2   141     2 num_links_par unal fixed bin,			/* no. links_in which parent */
  2   142     2 max_attr_index_id unal fixed bin,			/* max index id used by attr in this rel or PLI */
  2   143     2 num_key_attrs unal fixed bin,			/* number of attributes in primary key for this rel */
  2   144     2 nvar_atts unal fixed bin,			/* no. varying len. attributes */
  2   145     2 n36_thds unal fixed bin,			/* no. of 36-bit threads */
  2   146     2 n27_thds unal fixed bin,			/* no of 27-bit threads */
  2   147     2 n18_thds unal fixed bin,			/* no of 18-bit threads */
  2   148     2 unused_3 unal fixed bin,			/* element that was never used */
  2   149     2 max_data_len fixed bin (35),			/* max length of data portion of tuple */
  2   150     2 avg_data_len fixed bin (35),			/* average length of tuple data portion */
  2   151     2 max_key_len fixed bin (35),			/* max key length if not hashed */
  2   152     2 var_offset fixed bin (35),			/* position of first varying attr. */
  2   153     2 max_tuples fixed bin (35),			/* max no. tuples if blocked file */
  2   154     2 fwd_thread unal bit (18),			/* offsset to next rel. in file */
  2   155     2 attr_ptr unal bit (18),				/* to attr. info */
  2   156     2 primary_key_index_id bit (36) aligned,		/* index id of the relation's primary key */
  2   157     2 clink_ptr unal bit (18),			/* offset to child info of link determining location */
  2   158     2 map_ptr unal bit (18),				/* pointer to mapping info if virtual rel. */
  2   159     2 sec_ind_ptr unal bit (18),			/* ptr to list of sec. ind. infos, init. not used */
  2   160     2 locator_proc_path_ptr unal bit (18),		/* proc to determ. location */
  2   161     2 link_before_path_ptr unal bit (18),		/* op. proc. paths and entries */
  2   162     2 link_err_path_ptr unal bit (18),
  2   163     2 link_after_path_ptr unal bit (18),
  2   164     2 unlk_before_path_ptr unal bit (18),
  2   165     2 unlk_err_path_ptr unal bit (18),
  2   166     2 unlk_after_path_ptr unal bit (18),
  2   167     2 str_before_path_ptr unal bit (18),
  2   168     2 str_err_path_ptr unal bit (18),
  2   169     2 str_after_path_ptr unal bit (18),
  2   170     2 del_before_path_ptr unal bit (18),
  2   171     2 del_err_path_ptr unal bit (18),
  2   172     2 del_after_path_ptr unal bit (18),
  2   173     2 mod_before_path_ptr unal bit (18),
  2   174     2 mod_err_path_ptr unal bit (18),
  2   175     2 mod_after_path_ptr unal bit (18),
  2   176     2 find_before_path_ptr unal bit (18),
  2   177     2 find_err_path_ptr unal bit (18),
  2   178     2 find_after_path_ptr unal bit (18),
  2   179     2 retr_before_path_ptr unal bit (18),
  2   180     2 retr_err_path_ptr unal bit (18),
  2   181     2 retr_after_path_ptr unal bit (18),
  2   182     2 unused_1 unal bit (18),				/* for future expansion */
  2   183     2 unused_2 unal bit (18),
  2   184     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  2   185 dcl  ri_ptr ptr;
  2   186 
  2   187 /* a attr_info structure contains information about an attribute in a given relation.
  2   188*   since attributes may appear in more than one relation, each occurence of an attribute
  2   189*   means that an attr_info for it will be put in that relations sublist of attributes.
  2   190*   the list is singly linked in definition order. the attr_info describes
  2   191*   the data it represents, and how that data is used during a database search. */
  2   192 dcl 1 attr_info aligned based (ai_ptr),			/* info for a single attr. in attr. list */
  2   193     2 name char (32),				/* name of attribute */
  2   194     2 key_attr bit (1) unal,				/* on if part of primary or hash key */
  2   195     2 index_attr bit (1) unal,			/* on if a secondary index */
  2   196     2 link_attr bit (1) unal,				/* on if participates in link */
  2   197     2 reserved bit (33) unal,
  2   198     2 index_id bit (36) aligned,			/* id of index if index attr. */
  2   199     2 defn_order unal fixed bin,			/* relative posit. in which defined */
  2   200     2 key_order unal fixed bin,			/* relative posit. in key */
  2   201     2 bit_offset fixed bin (35),			/* position in tuple */
  2   202     2 bit_length fixed bin (35),			/* length if fixed */
  2   203     2 link_child_cnt fixed bin,			/* number of uses of attr in child rel of link */
  2   204     2 link_par_cnt fixed bin,				/* number of uses of attr in parent rel of link */
  2   205     2 domain_ptr unal bit (18),			/* to domain info */
  2   206     2 rslt_ptr unal bit (18),				/* ptr to info for "result" clause */
  2   207     2 fwd_thread unal bit (18),			/* to next in list */
  2   208     2 changer_ptr unal bit (18) ;			/* pointer to changer_id and changer_time */
  2   209 dcl  ai_ptr ptr;
  2   210 
  2   211 /* a parent_link_info structure is the carrier of foreign key definition info.
  2   212*   each time a foreign key definition indicates a relation as it's parent,
  2   213*   that relation will get a parent_link_info put in a list of associated parent_link_info's.
  2   214*   a relation can be parent and/or child in any number of foreign keys.
  2   215*   the parent_link_info structure describes the foreign key, and also points
  2   216*   to a list of the attributes that participate in this foreign key.
  2   217*   (this could be from 1 up to all attributes in the relation)
  2   218*   the attr_list structures are in a singly linked list in definition order
  2   219*   for this purpose. also pointed to is a list of child_link_info's
  2   220*   that describe the child relations in this foreign key. since foreign keys
  2   221*   may span files, not all related child_link_info's have to be in this file's
  2   222*   model area. */
  2   223 dcl 1 parent_link_info aligned based (pli_ptr),		/* gen'l link info, appears in each area spanned by link parent */
  2   224     2 name char (32),				/* name of link */
  2   225     2 singular bit (1) unal,				/* on if system owned link */
  2   226     2 temp bit (1) unal,				/* on if temp. order */
  2   227     2 first bit (1) unal,				/* insertion indicators */
  2   228     2 last bit (1) unal,
  2   229     2 next bit (1) unal,
  2   230     2 prior bit (1) unal,
  2   231     2 sort_rel_name bit (1) unal,			/* sort -- relation name */
  2   232     2 sort_keys bit (1) unal,				/* sort -- defined keys */
  2   233     2 dup_first bit (1) unal,				/* duplicates first */
  2   234     2 dup_last bit (1) unal,				/* duplicates last */
  2   235     2 indexed bit (1) unal,				/* locate parent via index */
  2   236     2 hashed bit (1) unal,				/* locate parent via hashed primary key */
  2   237     2 thread_36 bit (1) unal,				/* thread size indicators */
  2   238     2 thread_27 bit (1) unal,
  2   239     2 thread_18 bit (1) unal,
  2   240     2 clustered bit (1) unal,				/* ON => cluster option specified for this link */
  2   241     2 procedures_present bit (1) unal,			/* on => ids type procedures present */
  2   242     2 reserved bit (19) unal,				/* reserved for future flags */
  2   243     2 index_id aligned bit (8),			/* id of index if indexed */
  2   244     2 thread_index unal fixed bin,			/* index to threads in parent */
  2   245     2 nsel_attr unal fixed bin,			/* no. attr. determ. parent */
  2   246     2 n_children unal fixed bin,			/* no. children in link */
  2   247     2 child_fn char (30),				/* file name for first child in list */
  2   248     2 parent_ptr unal bit (18),			/* to parent relation info in file model */
  2   249     2 child_ptr unal bit (18),			/* to list of child info ptrs */
  2   250     2 sel_attr_ptr unal bit (18),			/* to first in list of attr. determ. parent */
  2   251     2 fwd_thread unal bit (18),			/* thread to next parent link info in file */
  2   252     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  2   253     2 sort_before_path_ptr unal bit (18),		/* proc. paths and entries */
  2   254     2 sort_err_path_ptr unal bit (18),
  2   255     2 sort_after_path_ptr unal bit (18),
  2   256     2 srch_before_path_ptr unal bit (18),
  2   257     2 srch_err_path_ptr unal bit (18),
  2   258     2 srch_after_path_ptr unal bit (18),
  2   259     2 link_before_path_ptr unal bit (18),
  2   260     2 link_err_path_ptr unal bit (18),
  2   261     2 link_after_path_ptr unal bit (18),
  2   262     2 unlk_before_path_ptr unal bit (18),
  2   263     2 unlk_err_path_ptr unal bit (18),
  2   264     2 unlk_after_path_ptr unal bit (18),
  2   265     2 unused_1 unal bit (18),				/* for future expansion */
  2   266     2 unused_2 unal bit (18),
  2   267     2 changer_ptr unal bit (18) ;			/* pointer to changer_id, changer_time structure */
  2   268 dcl  pli_ptr ptr;
  2   269 
  2   270 /* a child_link_info structure is the counter part of a parent_link_info
  2   271*   for foreign key child relations. each time a relation is defined to be
  2   272*   a child in a foreign key, it's list of child_link_infos will be added to.
  2   273*   this list is singly linked in foreign key definition order.
  2   274*   the child_link_info points to a list of participating attributes from the
  2   275*   child relation by means of a singly linked list of attr_list structures
  2   276*   in definition order. the number of attributes in the parent attr_list
  2   277*   and the child attr_list lists are the same with corresponding attr_list
  2   278*   attributes having the same domain. all child_link_infos in this file
  2   279*   are on a seperately linked list. this may not include all
  2   280*   child_link_infos for foreign keys whose parent relation resides in this file,
  2   281*   since foreign keys may span files, and the child_link_info will
  2   282*   reside in the file containing it's associated relation_info. */
  2   283 dcl 1 child_link_info aligned based (cli_ptr),		/* in same files as children */
  2   284     2 link_name char (32),				/* name of foreign key involving parent relation for this child */
  2   285     2 mandatory bit (1) unal,				/* on if membership mandatory */
  2   286     2 fixed bit (1) unal,				/* on if membership fixed */
  2   287     2 optional bit (1) unal,				/* on if membership optional */
  2   288     2 auto bit (1) unal,				/* on if insertion automatic */
  2   289     2 manual bit (1) unal,				/* on if insertion manual */
  2   290     2 struct_const bit (1) unal,			/* on if membership constrained by attr. comp. */
  2   291     2 range_sel bit (1) unal,				/* on if range type selection */
  2   292     2 key_dup_first bit (1) unal,			/* sort key flags */
  2   293     2 key_dup_last bit (1) unal,
  2   294     2 key_null bit (1) unal,				/* on if null allowed */
  2   295     2 sel_system bit (1) unal,			/* selection criteria flags */
  2   296     2 sel_current bit (1) unal,
  2   297     2 sel_key bit (1) unal,
  2   298     2 sel_proc bit (1) unal,
  2   299     2 no_null bit (1) unal,				/* if null key values not allowed */
  2   300     2 reserved bit (21) unal,
  2   301     2 thread_index unal fixed bin,			/* index to thread in tuple */
  2   302     2 chain_len unal fixed bin,			/* no. "then-thru's" in selction crit. */
  2   303     2 n_sort_keys unal fixed bin,			/* no. attr. in sort key */
  2   304     2 n_sel_items unal fixed bin,			/* no. items to sel for link sel. */
  2   305     2 n_dup_prevs unal fixed bin,			/* no. attr. for dup prev. */
  2   306     2 link_fwd_fn char (30),				/* file name for next child info in link */
  2   307     2 parent_fn char (30),				/* file name for parent info */
  2   308     2 parent_ptr unal bit (18),			/* offset to parent link info */
  2   309     2 link_fwd_thread unal bit (18),			/* offset for next child in link */
  2   310     2 rel_info_ptr unal bit (18),			/* to corresponding rel info */
  2   311     2 dup_prev_ptr unal bit (18),			/* list of attrs. for dup. prev. */
  2   312     2 sel_ptr unal bit (18),				/* list of attr. for link sel. */
  2   313     2 rel_fwd_thread unal bit (18),			/* for multiple links within a relation */
  2   314     2 child_fwd_thread unal bit (18),			/* pointer to next in list of all child_link_infos in this file */
  2   315     2 sort_key_ptr unal bit (18),			/* list of sort keys */
  2   316     2 chain_ptr unal bit (18),			/* to "then thru" list */
  2   317     2 sel_proc_path_ptr unal bit (18),			/* link selection proc. */
  2   318     2 link_before_path_ptr unal bit (18),		/* proc. paths and entries */
  2   319     2 link_err_path_ptr unal bit (18),
  2   320     2 link_after_path_ptr unal bit (18),
  2   321     2 unlk_before_path_ptr unal bit (18),
  2   322     2 unlk_err_path_ptr unal bit (18),
  2   323     2 unlk_after_path_ptr unal bit (18),
  2   324     2 srch_before_path_ptr unal bit (18),
  2   325     2 srch_err_path_ptr unal bit (18),
  2   326     2 srch_after_path_ptr unal bit (18),
  2   327     2 unused_1 unal bit (18),				/* for future expansion */
  2   328     2 unused_2 unal bit (18) ;
  2   329 dcl  cli_ptr ptr;
  2   330 
  2   331 /* the attr_list structure is associated with the parent_link_info
  2   332*   and child_link_info structures to represent by means of a singly linked list
  2   333*   the participating attributes from relations in a foreign key.
  2   334*   the parent_link_info has a list for the parent relation,
  2   335*   and the child_link_info has a list for the child relation.
  2   336*   the participating attributes are a subset(not necessary proper) of
  2   337*   those attributes contained in a relation definition.
  2   338*   there are equal numbers of attr_list structures in the parent and
  2   339*   child lists of the same foreign key. the corresponding attributes in these
  2   340*   lists must have the same domain. */
  2   341 dcl 1 attr_list aligned based (al_ptr),			/* general attr. list */
  2   342     2 attr_fn char (30),				/* file name for attr. */
  2   343     2 attr_ptr unal bit (18),				/* to attr info block */
  2   344     2 fwd_thread unal bit (18);			/* to next in list */
  2   345 dcl  al_ptr ptr;
  2   346 dcl 1 sort_key aligned based (sk_ptr),			/* entry in sort key list */
  2   347     2 ascend bit (1) unal,				/* ascending order */
  2   348     2 descend bit (1) unal,				/* descending order */
  2   349     2 reserved bit (34) unal,
  2   350     2 attr_ptr unal bit (18),				/* to attr info */
  2   351     2 fwd_thread unal bit (18);			/* to next in list */
  2   352 dcl  sk_ptr ptr;
  2   353 dcl 1 dup_prev aligned based (dp_ptr),			/* dup. prevention list entry */
  2   354     2 attr_ptr unal bit (18),				/* to attr info */
  2   355     2 fwd_thread unal bit (18);			/* to next in list */
  2   356 dcl  dp_ptr ptr;
  2   357 dcl 1 select_chain aligned based (sc_ptr),		/* "then thru" list entry */
  2   358     2 link_fn char (30),				/* file name for thru link */
  2   359     2 link_ptr unal bit (18),				/* to parent link info */
  2   360     2 parent_attr_ptr unal bit (18),			/* to parent ident. attr. list */
  2   361     2 comp_proc_path_ptr unal bit (18),			/* comparison procedure */
  2   362     2 comp_attr_fn char (30),				/* file name for comparison attr. */
  2   363     2 comp_attr_ptr unal bit (18),			/* to comparison attr list */
  2   364     2 fwd_thread unal bit (18);			/* to next in chain */
  2   365 dcl  sc_ptr ptr;
  2   366 
  2   367 /* END INCLUDE FILE mdbm_file_model.incl.pl1 */
  2   368 
  2   369 
      484 
      485 
  3     1 /*	BEGIN INCLUDE FILE		mrds_rel_desc.incl.pl1	rgl, 03/31/76		*/
  3     2 
  3     3 /* 76-09-20 R. Lackey : modified to handle inverted attributes	
  3     4*
  3     5*   76-11-16 J. A. Weeldreyer : modified to add domain name 
  3     6*
  3     7*   82-08-19 D. Woodka : deleted rel_desc.attributes.bit_offset field
  3     8*   for the DMS conversion
  3     9*
  3    10**/
  3    11 
  3    12 dcl 1 rel_desc based (rd_ptr),			/* record description of relation records */
  3    13     2 num_attr fixed bin,				/* number of attributes in the model */
  3    14     2 key_length fixed bin (35),			/* length in bits of data portion of tuple */
  3    15     2 data_length fixed bin (35),			/* length in bits of data portion of tuple */
  3    16     2 num_keys fixed bin,				/* number of key attributes */
  3    17     2 inversion bit (1) unal,				/* On if this relation contains any inverted  attributes */
  3    18     2 reserved bit (35) unal,				/* Reserved for future use */
  3    19     2 attributes (num_attr_alloc refer (rel_desc.num_attr)),
  3    20       3 attribute_name char (32),			/* name of attribute  */
  3    21       3 domain_name char (32),			/* name of underlying domain */
  3    22       3 bit_length bit (18) unaligned,			/* length of data item in bits */
  3    23       3 key_flag bit (1) unaligned,			/* indicates whether attribute is part of primary key */
  3    24       3 inver_flag bit (1) unaligned,			/* On if this attribute is inverted */
  3    25       3 unused bit (34) unaligned,			/* reserved for expansion */
  3    26       3 key_attr_order fixed bin,			/* order num of this key attr */
  3    27       3 descriptor bit (36);				/* Multics descriptor for attribute */
  3    28 
  3    29 dcl  num_attr_alloc fixed bin (10);			/* Number of attributes in relation for allocation purposes */
  3    30 
  3    31 dcl  rd_ptr ptr;
  3    32 
  3    33 /*	END INCLUDE FILE		mrds_rel_desc.incl.pl1				*/
  3    34 
      486 
      487 
  4     1 /* BEGIN INCLUDE FILE mrds_authorization.incl.pl1 - - 81-01-20 Jim Gray */
  4     2 
  4     3 /* HISTORY:
  4     4*
  4     5*   81-01-20 Jim Gray : original created for the mmi_$get_authorization interface
  4     6*
  4     7**/
  4     8 
  4     9 /* DESCRIPTION:
  4    10*
  4    11*   this structure returns the callers user_class
  4    12*   either database administrator or normal user.
  4    13*   Note that these separate classes were used to allow
  4    14*   future expansion to the user classes, rather than
  4    15*   make them logical "not"'s of one another.
  4    16*   NOTE: a DBA is always also a normal user, thus if the caller
  4    17*   is a DBA, his normal_user bit will be on also.
  4    18*
  4    19**/
  4    20 
  4    21 
  4    22 declare 1 mrds_authorization aligned based (mrds_authorization_ptr),
  4    23         2 version fixed bin,				/* version number of this structure */
  4    24         2 administrator bit (1) unal,			/* caller is a DBA */
  4    25         2 normal_user bit (1) unal,			/* caller has no special priviledges */
  4    26         2 mbz bit (34) unal ;
  4    27 
  4    28 
  4    29 declare  mrds_authorization_ptr ptr ;			/* pointer for referring to the structure */
  4    30 
  4    31 declare  mrds_authorization_structure_version fixed bin init (1) int static options (constant) ;
  4    32 
  4    33 /* END INCLUDE FILE mrds_authorization.incl.pl1 */
      488 
      489 
  5     1 /* BEGIN INCLUDE FILE mrds_database_state.incl.pl1 - - 81-01-20 Jim Gray */
  5     2 
  5     3 /* HISTORY:
  5     4*
  5     5*   81-01-20 Jim Gray : original created for the mmi_$get_secured_status interface
  5     6*
  5     7**/
  5     8 
  5     9 /* DESCRIPTION:
  5    10*
  5    11*   This structure returns the database state (secured or unsecured)
  5    12*   for determining how commands and subroutines will behave for each case.
  5    13*   The secured bit was kept separate from the unsecured,
  5    14*   rather than it's logical "not", to allow for future extensibility
  5    15*   of database secured states.
  5    16*
  5    17**/
  5    18 
  5    19 
  5    20 declare 1 database_state aligned based (database_state_ptr),
  5    21         2 version fixed bin,				/* version number of this structure */
  5    22         2 unsecured bit (1) unal,			/* database not secured */
  5    23         2 secured bit (1) unal,			/* database has been secured */
  5    24         2 mbz bit (34) unal ;
  5    25 
  5    26 
  5    27 declare  database_state_ptr ptr ;			/* pointer for referring to the structure */
  5    28 
  5    29 declare  database_state_structure_version fixed bin init (1) int static options (constant) ;
  5    30 
  5    31 /* END INCLUDE FILE mrds_database_state.incl.pl1 */
      490 
      491 
  6     1 /* BEGIN INCLUDE FILE area_info.incl.pl1  12/75 */
  6     2 
  6     3 dcl  area_info_version_1 fixed bin static init (1) options (constant);
  6     4 
  6     5 dcl  area_infop ptr;
  6     6 
  6     7 dcl 1 area_info aligned based (area_infop),
  6     8     2 version fixed bin,				/* version number for this structure is 1 */
  6     9     2 control aligned like area_control,		/* control bits for the area */
  6    10     2 owner char (32) unal,				/* creator of the area */
  6    11     2 n_components fixed bin,				/* number of components in the area (returned only) */
  6    12     2 size fixed bin (18),				/* size of the area in words */
  6    13     2 version_of_area fixed bin,			/* version of area (returned only) */
  6    14     2 areap ptr,					/* pointer to the area (first component on multisegment area) */
  6    15     2 allocated_blocks fixed bin,			/* number of blocks allocated */
  6    16     2 free_blocks fixed bin,				/* number of free blocks not in virgin */
  6    17     2 allocated_words fixed bin (30),			/* number of words allocated in the area */
  6    18     2 free_words fixed bin (30);			/* number of words free in area not in virgin */
  6    19 
  6    20 dcl 1 area_control aligned based,
  6    21     2 extend bit (1) unal,				/* says area is extensible */
  6    22     2 zero_on_alloc bit (1) unal,			/* says block gets zerod at allocation time */
  6    23     2 zero_on_free bit (1) unal,			/* says block gets zerod at free time */
  6    24     2 dont_free bit (1) unal,			/* debugging aid, turns off free requests */
  6    25     2 no_freeing bit (1) unal,			/* for allocation method without freeing */
  6    26     2 system bit (1) unal,				/* says area is managed by system */
  6    27     2 pad bit (30) unal;
  6    28 
  6    29 /* END INCLUDE FILE area_info.incl.pl1 */
      492 
      493 
  7     1 /* BEGIN INCLUDE FILE mrds_db_model_rel_attrs.incl.pl1 - - Jim Gray 81-01-28 */
  7     2 
  7     3 /* HISTORY:
  7     4*
  7     5*   81-01-28 Jim Gray : originally created for the mmi_$get_model_attributes interface.
  7     6*
  7     7*
  7     8**/
  7     9 
  7    10 /* DESCRIPTION:
  7    11*
  7    12*   This structure returns, for a given relation, the list of all attribute names in
  7    13*   the database model. A count of the number of names present is included.
  7    14*   No submodel alias names for the attributes are involved.
  7    15*   Also, the domain name, and the users view descriptor for the data type
  7    16*   is returned, as well as a bit indicating whether the attribute
  7    17*   can be used as if it were indexed or not.
  7    18*   This structure is to be used externaly, not internal to MRDS.
  7    19*
  7    20**/
  7    21 
  7    22 
  7    23 declare 1 mrds_db_model_rel_attrs aligned based (mrds_db_model_rel_attrs_ptr),
  7    24         2 version fixed bin,				/* version number for this structure */
  7    25         2 attribute_count fixed bin,			/* total number of attributes in this model */
  7    26         2 mbz1 bit (36) unal,
  7    27         2 attribute (mrds_db_model_rel_attrs_count_init refer (mrds_db_model_rel_attrs.attribute_count)),
  7    28 	3 name char (32),				/* name of the attribute in the model */
  7    29 	3 domain char (32),				/* the name of the underlying domain for this attribute */
  7    30 	3 user_data_type bit (36),			/* standard multics descriptor for
  7    31*						   the users view of the data storage layout */
  7    32 	3 indexed bit (1) unal,			/* on => key head or secondarily indexed attribute */
  7    33 	3 mbz2 bit (35) unal ;
  7    34 
  7    35 declare  mrds_db_model_rel_attrs_ptr ptr ;
  7    36 
  7    37 declare  mrds_db_model_rel_attrs_count_init fixed bin ;
  7    38 
  7    39 declare  mrds_db_model_rel_attrs_structure_version fixed bin int static init (1) options (constant) ;
  7    40 
  7    41 /* END INCLUDE FILE mrds_db_model_rel_attrs.incl.pl1 */
      494 
      495 
  8     1 /* BEGIN INCLUDE FILE ... arg_list.incl.pl1
  8     2*
  8     3*   James R. Davis 10 May 79 */
  8     4 
  8     5 
  8     6      
  8     7 /****^  HISTORY COMMENTS:
  8     8*  1) change(86-05-15,DGHowe), approve(86-05-15,MCR7375),
  8     9*     audit(86-07-15,Schroth):
  8    10*     added command_name_arglist declaration to allow the storage of the
  8    11*     command name given to the command processor
  8    12*                                                   END HISTORY COMMENTS */
  8    13 
  8    14      dcl	   1 arg_list	      aligned based,
  8    15 	     2 header,
  8    16 	       3 arg_count	      fixed bin (17) unsigned unal,
  8    17 	       3 pad1	      bit (1) unal,
  8    18 	       3 call_type	      fixed bin (18) unsigned unal,
  8    19 	       3 desc_count	      fixed bin (17) unsigned unal,
  8    20 	       3 pad2	      bit (19) unal,
  8    21 	     2 arg_ptrs	      (arg_list_arg_count refer (arg_list.arg_count)) ptr,
  8    22 	     2 desc_ptrs	      (arg_list_arg_count refer (arg_list.arg_count)) ptr;
  8    23 
  8    24 
  8    25      dcl	   1 command_name_arglist	      aligned based,
  8    26 	     2 header,
  8    27 	       3 arg_count	      fixed bin (17) unsigned unal,
  8    28 	       3 pad1	      bit (1) unal,
  8    29 	       3 call_type	      fixed bin (18) unsigned unal,
  8    30 	       3 desc_count	      fixed bin (17) unsigned unal,
  8    31 	       3 mbz              bit(1) unal,
  8    32                  3 has_command_name bit(1) unal,
  8    33 	       3 pad2	      bit (17) unal,
  8    34 	     2 arg_ptrs	      (arg_list_arg_count refer (command_name_arglist.arg_count)) ptr,
  8    35 	     2 desc_ptrs	      (arg_list_arg_count refer (command_name_arglist.arg_count)) ptr,
  8    36 	     2 name,
  8    37                  3 command_name_ptr         pointer,
  8    38                  3 command_name_length      fixed bin (21);
  8    39 	
  8    40 
  8    41 
  8    42      dcl	   1 arg_list_with_envptr aligned based,	/* used with non-quick int and entry-var calls */
  8    43 	     2 header,
  8    44 	       3 arg_count	      fixed bin (17) unsigned unal,
  8    45 	       3 pad1	      bit (1) unal,
  8    46 	       3 call_type	      fixed bin (18) unsigned unal,
  8    47 	       3 desc_count	      fixed bin (17) unsigned unal,
  8    48 	       3 pad2	      bit (19) unal,
  8    49 	     2 arg_ptrs	      (arg_list_arg_count refer (arg_list_with_envptr.arg_count)) ptr,
  8    50 	     2 envptr	      ptr,
  8    51 	     2 desc_ptrs	      (arg_list_arg_count refer (arg_list_with_envptr.arg_count)) ptr;
  8    52 
  8    53 
  8    54      dcl	   (
  8    55 	   Quick_call_type	      init (0),
  8    56 	   Interseg_call_type     init (4),
  8    57 	   Envptr_supplied_call_type
  8    58 			      init (8)
  8    59 	   )		      fixed bin (18) unsigned unal int static options (constant);
  8    60 
  8    61 /* The user must declare arg_list_arg_count - if an adjustable automatic structure
  8    62*   is being "liked" then arg_list_arg_count may be a parameter, in order to allocate
  8    63*   an argument list of the proper size in the user's stack
  8    64*
  8    65**/
  8    66 /* END INCLUDE FILE ... arg_list.incl.pl1 */
      496 
      497 
      498      end mrds_dm_get_attributes;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/16/86  1143.7  mrds_dm_get_attributes.pl1        >special_ldd>install>MR12.0-1187>mrds_dm_get_attributes.pl1
482          1    10/16/86  1139.3  mdbm_db_model.incl.pl1            >special_ldd>install>MR12.0-1187>mdbm_db_model.incl.pl1
484          2    10/16/86  1139.9  mdbm_file_model.incl.pl1          >special_ldd>install>MR12.0-1187>mdbm_file_model.incl.pl1
486          3    10/14/83  1609.0  mrds_rel_desc.incl.pl1            >ldd>include>mrds_rel_desc.incl.pl1
488          4    10/14/83  1608.8  mrds_authorization.incl.pl1       >ldd>include>mrds_authorization.incl.pl1
490          5    10/14/83  1608.8  mrds_database_state.incl.pl1      >ldd>include>mrds_database_state.incl.pl1
492          6    06/11/76  1043.4  area_info.incl.pl1                >ldd>include>area_info.incl.pl1
494          7    10/14/83  1608.8  mrds_db_model_rel_attrs.incl.pl1  >ldd>include>mrds_db_model_rel_attrs.incl.pl1
496          8    08/05/86  0856.8  arg_list.incl.pl1                 >ldd>include>arg_list.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
NULL_OFS                               constant        bit(18)                  initial unaligned dcl 420 ref 290 340
addr                                                   builtin function         dcl 479 ref 174 174 189 189 378 378 390 390
administrator             1            based           bit(1)                   level 2 packed unaligned dcl 4-22 ref 397
ai_ptr                          020302 automatic       pointer                  dcl 2-209 set ref 340* 340* 343 344 347 348 349 350
                                                                                  354* 356
area                            000100 stack reference condition                dcl 421 ref 202 216
area_control                           based           structure                level 1 dcl 6-20
area_info                              based           structure                level 1 dcl 6-7
area_info_                      000012 constant        entry                    external dcl 422 ref 189
area_ptr                        000106 automatic       pointer                  dcl 423 set ref 124* 144* 178* 182 187 209 215 319
                                                                                  329
area_ptr_a                             parameter       pointer                  dcl 424 ref 116 124
area_ptr_b                             parameter       pointer                  dcl 425 ref 135 144
area_ptr_c                             parameter       pointer                  dcl 426 ref 157 178
areap                    16     020244 automatic       pointer                  level 2 dcl 480 set ref 187*
attr_info                              based           structure                level 1 dcl 2-192
attr_ptr                 24(18)        based           bit(18)                  level 2 packed unaligned dcl 2-126 ref 340
attribute                 3            based           structure                array level 2 dcl 7-23
attribute_count           1            based           fixed bin(17,0)          level 2 dcl 7-23 set ref 209 215* 218 220*
attribute_name            5            based           char(32)                 array level 3 packed unaligned dcl 3-12 set ref 226
                                                                                  343*
attributes                5            based           structure                array level 2 unaligned dcl 3-12
bit                                                    builtin function         dcl 479 ref 347
bit_length               14            based           fixed bin(35,0)          level 2 in structure "attr_info" dcl 2-192
                                                                                  in procedure "mrds_dm_get_attributes" ref 347
bit_length               25            based           bit(18)                  array level 3 in structure "rel_desc" packed
                                                                                  unaligned dcl 3-12 in procedure
                                                                                  "mrds_dm_get_attributes" set ref 347*
caller_name                     000110 automatic       char(32)                 initial unaligned dcl 427 set ref 380* 392* 403*
                                                                                  427*
cleanup                         000120 stack reference condition                dcl 428 ref 207 317
cnt                             000126 automatic       fixed bin(17,0)          dcl 429 set ref 339* 343 345 347 348 349 350 351 353
                                                                                  355* 355
code                            000127 automatic       fixed bin(35,0)          dcl 430 set ref 128 148 258* 263* 264 274 (  *@         qF    d     *@          qF         *@          qF         *@          qF            *@          qF    N.  V  *@         qF    &6     *@         qF    .n     *@         qF    dF     *@          qF    >N     *@          qF    F     *@          qF    ^       *@         qF    fV     *@         qF    n^   |  *@         qF    6f     *@         qF        &|+>   ~~ ra         v     Transactions                        |+D    G`H                 ra               |+              *@          |+    v  &|+>    ra          .    Proceedings.1                       |+D    Gw;                 ra               |+              *@          |+             Mulhaupt                            |+         Oke                                 |+    *@         qF             PANakaska                           |+    *@         qF    "         Polischuk                           |+0    *@         qF    8         RWaters                             |+F    *@         qF    V"         Rohs                                |+0N  "  *@         qF    F&  8  *@         qF     8         Smith                               |+>     *@          qF                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        dcl 445 ref 195
fi_ptr                          020272 automatic       pointer                  dcl 1-119 set ref 286* 288 290 290* 290 301 307
file_info                              based           structure                level 1 dcl 1-113
file_model                             based           structure                level 1 dcl 2-40
file_name                              based           char(30)                 level 2 dcl 1-113 ref 288 301 307
file_ptr                 22            based           bit(18)                  level 2 packed unaligned dcl 1-72 ref 286
fixed                                                  builtin function         dcl 479 ref 347
fm_ptr                          020276 automatic       pointer                  dcl 2-108 set ref 301* 307* 315 324 324 340 356
fwd_ptr                  11            based           bit(18)                  level 2 packed unaligned dcl 1-113 ref 290 290
fwd_thread               20            based           bit(18)                  level 2 packed unaligned dcl 2-192 ref 356
hcs_$fs_get_path_name           000030 constant        entry                    external dcl 446 ref 263
hcs_$initiate                   000032 constant        entry                    external dcl 447 ref 301 307
i                               000207 automatic       fixed bin(17,0)          dcl 448 set ref 224* 226 226 227 227 228 228 230 230
                                                                                  230*
index_attr               10(01)        based           bit(1)                   level 2 packed unaligned dcl 2-192 ref 349
indexed                  24            based           bit(1)                   array level 3 in structure "mrds_db_model_rel_attrs"
                                                                                  packed unaligned dcl 7-23 in procedure
                                                                                  "mrds_dm_get_attributes" set ref 230*
indexed                  11(04)        based           bit(1)                   level 2 in structure "rel_info" packed unaligned
                                                                                  dcl 2-126 in procedure "mrds_dm_get_attributes"
                                                                                  ref 335
info_ptr                        000210 automatic       pointer                  initial dcl 449 set ref 380* 392* 403* 449*
internal_call                   000212 automatic       bit(1)                   unaligned dcl 450 set ref 120* 140* 269 351 373
inver_flag               25(19)        based           bit(1)                   array level 3 packed unaligned dcl 3-12 set ref 230
                                                                                  349*
inversion                 4            based           bit(1)                   level 2 packed unaligned dcl 3-12 set ref 335*
key_attr                 10            based           bit(1)                   level 2 packed unaligned dcl 2-192 ref 348 354
key_attr_order           27            based           fixed bin(17,0)          array level 3 dcl 3-12 set ref 230 350*
key_flag                 25(18)        based           bit(1)                   array level 3 packed unaligned dcl 3-12 set ref 348*
key_length                1            based           fixed bin(35,0)          level 2 dcl 3-12 set ref 332*
key_order                12(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 2-192 ref 350
ldn                             000213 automatic       fixed bin(17,0)          dcl 451 set ref 263*
local_area                      000214 automatic       area(8192)               dcl 452 set ref 174 174 378 378 390 390 452*
max_data_len             17            based           fixed bin(35,0)          level 2 dcl 2-126 ref 333
max_key_len              21            based           fixed bin(35,0)          level 2 dcl 2-126 ref 332
model_name                      020214 automatic       char(32)                 unaligned dcl 454 set ref 263*
model_ptr                       020224 automatic       pointer                  dcl 455 set ref 169* 174*
model_type                      020226 automatic       char(1)                  unaligned dcl 456 set ref 169*
mrds_authorization                     based           structure                level 1 dcl 4-22
mrds_authorization_ptr          020310 automatic       pointer                  dcl 4-29 set ref 390* 397
mrds_authorization_structure_version
                                000021 constant        fixed bin(17,0)          initial dcl 4-31 set ref 390*
mrds_db_model_rel_attrs                based           structure                level 1 dcl 7-23 set ref 209 215 218*
mrds_db_model_rel_attrs_count_init
                                020314 automatic       fixed bin(17,0)          dcl 7-37 set ref 214* 215 215 220 224
mrds_db_model_rel_attrs_ptr            parameter       pointer                  dcl 7-35 set ref 157 165* 208 209 210* 215* 218 219
                                                                                  220 226 227 228 230
mrds_db_model_rel_attrs_structure_version
                                       constant        fixed bin(17,0)          initial dcl 7-39 ref 195 219
mrds_dm_authorization$get_user_class
                                000036 constant        entry                    external dcl 457 ref 390
mrds_dm_authorization$set_needed_access
                                000040 constant        entry                    external dcl 458 ref 303
mrds_dm_db_secured$get_secured_status
                                000042 constant        entry                    external dcl 459 ref 378
mrds_error_$no_model_access     000044 external static fixed bin(35,0)          dcl 460 ref 280 305
mrds_error_$no_model_rel        000046 external static fixed bin(35,0)          dcl 461 ref 294
mrds_error_$not_freeing_area    000050 external static fixed bin(35,0)          dcl 462 ref 191
mu_open_name_manager$get_model_pointer
                                000034 constant        entry                    external dcl 453 ref 169
my_area_info                    020244 automatic       structure                level 1 unaligned dcl 480 set ref 185* 189 189
name                                   based           char(32)                 level 2 in structure "attr_info" dcl 2-192
                                                                                  in procedure "mrds_dm_get_attributes" ref 343
name                                   based           char(32)                 level 2 in structure "domain_info" dcl 1-125
                                                                                  in procedure "mrds_dm_get_attributes" ref 345
name                      3            based           char(32)                 array level 3 in structure "mrds_db_model_rel_attrs"
                                                                                  dcl 7-23 in procedure "mrds_dm_get_attributes" set
                                                                                  ref 226*
no_freeing                1(04) 020244 automatic       bit(1)                   level 3 packed unaligned dcl 480 set ref 191
no_read_permission              000000 stack reference condition                dcl 463 ref 279
null                                                   builtin function         dcl 479 ref 165 182 208 210 259 281 315 318 320 413
                                                                                  449
num_attr                 12            based           fixed bin(17,0)          level 2 in structure "rel_info" packed unaligned
                                                                                  dcl 2-126 in procedure "mrds_dm_get_attributes"
                                                                                  ref 328
num_attr                               based           fixed bin(17,0)          level 2 in structure "rel_desc" dcl 3-12
                                                                                  in procedure "mrds_dm_get_attributes" set ref 214
                                                                                  319 329* 330 331*
num_attr_alloc                  020304 automatic       fixed bin(10,0)          dcl 3-29 set ref 328* 329 329 331
num_keys                  3            based           fixed bin(17,0)          level 2 dcl 3-12 set ref 334* 354* 354
open_name                              parameter       char                     unaligned dcl 464 set ref 157 169*
ptr                                                    builtin function         dcl 479 ref 286 290 324 340 344 356
rd_ptr                          020306 automatic       pointer                  dcl 3-31 set ref 129 149 177* 214 226 227 228 230
                                                                                  230 259* 281* 318 319 320* 329* 330 331 332 333
                                                                                  334 335 343 345 347 348 349 350 351 353 354 354
rd_ptr_a                               parameter       pointer                  dcl 465 set ref 116 129*
rd_ptr_b                               parameter       pointer                  dcl 466 set ref 135 149*
rd_ptr_c                        020230 automatic       pointer                  dcl 467 set ref 174* 177
rel                                                    builtin function         dcl 479 ref 340
rel_desc                               based           structure                level 1 unaligned dcl 3-12 set ref 319 329 330*
rel_found                       020232 automatic       bit(1)                   unaligned dcl 468 set ref 285* 288* 294
rel_info                               based           structure                level 1 dcl 2-126
rel_ptr                  20(27)        based           bit(18)                  level 2 packed unaligned dcl 2-40 ref 324
relation_name                   020233 automatic       char(32)                 unaligned dcl 469 set ref 123* 143* 288
relation_name_a                        parameter       char(32)                 unaligned dcl 470 ref 116 123
relation_name_b                        parameter       char(32)                 unaligned dcl 471 ref 135 143
relation_name_c                        parameter       char                     unaligned dcl 472 ref 157 174
return_area                            based           area                     dcl 473 ref 209 215 319 329
return_value                    020243 automatic       fixed bin(35,0)          initial dcl 474 set ref 380* 392* 403* 474*
ri_ptr                          020300 automatic       pointer                  dcl 2-185 set ref 324* 328 332 333 335 340
rtrim                                                  builtin function         dcl 479 ref 301 303 303 307 390 390
secured                   1(01)        based           bit(1)                   level 2 packed unaligned dcl 5-20 ref 385
structure_version                      parameter       fixed bin(17,0)          dcl 475 ref 157 195
sub_err_                        000052 constant        entry                    external dcl 476 ref 380 392 403
unspec                                                 builtin function         dcl 479 set ref 185* 218* 330*
user_data_type           23            based           bit(36)                  array level 3 dcl 7-23 set ref 228*
user_data_type_wanted           000010 internal static bit(1)                   initial unaligned dcl 478 set ref 250* 254* 351
user_desc                12            based           bit(36)                  level 2 dcl 1-125 ref 351
version                                based           fixed bin(17,0)          level 2 in structure "mrds_db_model_rel_attrs"
                                                                                  dcl 7-23 in procedure "mrds_dm_get_attributes" set
                                                                                  ref 219*
version                         020244 automatic       fixed bin(17,0)          level 2 in structure "my_area_info" dcl 480
                                                                                  in procedure "mrds_dm_get_attributes" set ref 186*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Envptr_supplied_call_type              internal static fixed bin(18,0)          initial unsigned unaligned dcl 8-54
Interseg_call_type                     internal static fixed bin(18,0)          initial unsigned unaligned dcl 8-54
Quick_call_type                        internal static fixed bin(18,0)          initial unsigned unaligned dcl 8-54
al_ptr                                 automatic       pointer                  dcl 2-345
alloc_length                           internal static fixed bin(35,0)          dcl 1-222
area_info_version_1                    internal static fixed bin(17,0)          initial dcl 6-3
area_infop                             automatic       pointer                  dcl 6-5
arg_list                               based           structure                level 1 dcl 8-14
arg_list_with_envptr                   based           structure                level 1 dcl 8-42
atd                                    based           char                     unaligned dcl 2-109
atd_len                                automatic       fixed bin(17,0)          dcl 2-111
atd_ptr                                automatic       pointer                  dcl 2-110
attr_list                              based           structure                level 1 dcl 2-341
changer                                based           structure                level 1 packed unaligned dcl 1-251
changer_ptr                            automatic       pointer                  dcl 1-256
child_link_info                        based           structure                level 1 dcl 2-283
cli_ptr                                automatic       pointer                  dcl 2-329
cna_ptr                                automatic       pointer                  dcl 2-115
command_name_arglist                   based           structure                level 1 dcl 8-25
comp_no_array                          based           structure                level 1 packed unaligned dcl 2-112
constant                               based           structure                level 1 unaligned dcl 1-216
constant_ptr                           automatic       pointer                  dcl 1-220
dp_ptr                                 automatic       pointer                  dcl 2-356
dup_prev                               based           structure                level 1 dcl 2-353
message_str                            based           structure                level 1 packed unaligned dcl 1-259
message_str_len                        automatic       fixed bin(17,0)          dcl 1-269
message_str_ptr                        automatic       pointer                  dcl 1-267
ncomp_init                             automatic       fixed bin(17,0)          dcl 2-116
parent_link_info                       based           structure                level 1 dcl 2-223
path_entry                             based           structure                level 1 packed unaligned dcl 1-172
path_entry_ptr                         automatic       pointer                  dcl 1-177
pli_ptr                                automatic       pointer                  dcl 2-268
sc_ptr                                 automatic       pointer                  dcl 2-365
select_chain                           based           structure                level 1 dcl 2-357
sk_ptr                                 automatic       pointer                  dcl 2-352
sort_key                               based           structure                level 1 dcl 2-346
stack_item                             based           structure                level 1 unaligned dcl 1-206
stack_item_ptr                         automatic       pointer                  dcl 1-212
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 477
ua_ptr                                 automatic       pointer                  dcl 1-165
unreferenced_attribute                 based           structure                level 1 dcl 1-159
version_status                         based           structure                level 1 packed unaligned dcl 1-232
version_status_ptr                     automatic       pointer                  dcl 1-246

NAMES DECLARED BY EXPLICIT CONTEXT.
common                          000647 constant        entry                    internal dcl 257 ref 126 146
exit                            001512 constant        label                    dcl 361 ref 282
get_attributes                  000204 constant        entry                    external dcl 135 ref 174
get_model_attributes            000246 constant        entry                    external dcl 157
mrds_dm_get_attributes          000145 constant        entry                    external dcl 116
secured_db_check                001513 constant        entry                    internal dcl 367 ref 269
set_db_view                     000635 constant        entry                    external dcl 253
set_user_view                   000622 constant        entry                    external dcl 249
skip_allocate                   000620 constant        label                    dcl 241 ref 204

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2452        2526    2106        2462
Length      3142    2106        54         377     343           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_dm_get_attributes             8435 external procedure  is an external procedure.  
on unit on line 202                  64 on unit               
on unit on line 207                  64 on unit               
common                              260 internal procedure  enables or reverts conditions.  
on unit on line 279                  64 on unit               
on unit on line 317                  64 on unit               
secured_db_check                        internal procedure  shares stack frame of internal procedure common.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 user_data_type_wanted       mrds_dm_get_attributes

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mrds_dm_get_attributes   000106 area_ptr                    mrds_dm_get_attributes
                         000110 caller_name                 mrds_dm_get_attributes
                         000126 cnt                         mrds_dm_get_attributes
                         000127 code                        mrds_dm_get_attributes
                         000130 continue                    mrds_dm_get_attributes
                         000132 data_model_ptr              mrds_dm_get_attributes
                         000134 db_path                     mrds_dm_get_attributes
                         000206 done                        mrds_dm_get_attributes
                         000207 i                           mrds_dm_get_attributes
                         000210 info_ptr                    mrds_dm_get_attributes
                         000212 internal_call               mrds_dm_get_attributes
                         000213 ldn                         mrds_dm_get_attributes
                         000214 local_area                  mrds_dm_get_attributes
                         020214 model_name                  mrds_dm_get_attributes
                         020224 model_ptr                   mrds_dm_get_attributes
                         020226 model_type                  mrds_dm_get_attributes
                         020230 rd_ptr_c                    mrds_dm_get_attributes
                         020232 rel_found                   mrds_dm_get_attributes
                         020233 relation_name               mrds_dm_get_attributes
                         020243 return_value                mrds_dm_get_attributes
                         020244 my_area_info                mrds_dm_get_attributes
                         020270 dbm_ptr                     mrds_dm_get_attributes
                         020272 fi_ptr                      mrds_dm_get_attributes
                         020274 di_ptr                      mrds_dm_get_attributes
                         020276 fm_ptr                      mrds_dm_get_attributes
                         020300 ri_ptr                      mrds_dm_get_attributes
                         020302 ai_ptr                      mrds_dm_get_attributes
                         020304 num_attr_alloc              mrds_dm_get_attributes
                         020306 rd_ptr                      mrds_dm_get_attributes
                         020310 mrds_authorization_ptr      mrds_dm_get_attributes
                         020312 database_state_ptr          mrds_dm_get_attributes
                         020314 mrds_db_model_rel_attrs_count_init
                                                            mrds_dm_get_attributes

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_in         call_ext_out_desc   call_ext_out        call_int_this       return_mac
tra_ext_1           enable_op           shorten_stack       ext_entry           ext_entry_desc      int_entry
op_alloc_           op_freen_           op_empty_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
area_info_                    hcs_$fs_get_path_name         hcs_$initiate
mrds_dm_authorization$get_user_class                        mrds_dm_authorization$set_needed_access
mrds_dm_db_secured$get_secured_status                       mu_open_name_manager$get_model_pointer
sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$area_too_small   error_table_$badcall          error_table_$insufficient_access
error_table_$moderr           error_table_$no_info          error_table_$unimplemented_version
mrds_error_$no_model_access   mrds_error_$no_model_rel      mrds_error_$not_freeing_area




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    427 000123       434 000126       449 000130       452 000132       474 000135       116 000140       120 000153
    122 000155       123 000161       124 000165       126 000170       128 000174       129 000177       131 000201
    135 000202       140 000212       142 000213       143 000217       144 000223       146 000226       148 000232
    149 000235       151 000237       157 000240       164 000267       165 000271       169 000273       170 000321
    174 000324       175 000351       177 000354       178 000356       182 000361       185 000371       186 000374
    187 000376       189 000377       190 000412       191 000416       195 000425       202 000434       203 000450
    204 000454       207 000457       208 000473       209 000501       210 000510       212 000514       214 000515
    215 000517       216 000531       218 000532       219 000542       220 000544       224 000546       226 000555
    227 000572       228 000600       230 000603       234 000616       241 000620       249 000621       250 000630
    251 000633       253 000634       254 000643       255 000645       257 000646       258 000654       259 000656
    263 000660       264 000710       268 000713       269 000715       274 000720       279 000723       280 000737
    281 000743       282 000745       285 000750       286 000753       287 000761       288 000765       290 000776
    292 001007       293 001011       294 001012       301 001020       302 001113       303 001123       305 001157
    307 001167       309 001262       315 001263       316 001270       317 001271       318 001305       319 001313
    320 001320       322 001324       324 001325       328 001336       329 001341       330 001354       331 001364
    332 001366       333 001371       334 001373       335 001374       339 001401       340 001403       343 001414
    344 001424       345 001432       347 001437       348 001446       349 001453       350 001460       351 001464
    353 001475       354 001477       355 001503       356 001504       361 001512       367 001513       372 001514
    373 001520       378 001523       380 001544       385 001627       390 001634       392 001706       397 001772
    402 001777       403 002002       413 002076       416 002104


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
