	COMPILATION LISTING OF SEGMENT probe_get_line_
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-05-05_1828.53_Fri_mdt
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(88-09-07,WAAnderson), approve(88-09-30,MCR7952),
       16*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
       17*     Added format control comment to make the source more readable.
       18*                                                   END HISTORY COMMENTS */
       19 
       20 
       21 /* format: style1,insnl,ifthendo,indthenelse,^indnoniterdo,^inditerdo,indcom,^indthenbegin,^indprocbody,ind2,ll78,initcol0,dclind4,idind24,struclvlind1,comcol41 */
       22 
       23 /****  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       24 
       25 probe_get_line_:
       26   proc (P_probe_info_ptr, P_new_source_info_ptr, P_invocation, P_switches,
       27        P_data_type, P_code);
       28 
       29   /* parse a LINE
       30*
       31*   that can be
       32*   $b			current breakpint line
       33*   $c			current_source_ptr
       34*   NN			line NN current proc
       35*   MM-NN			line NN in file MM
       36*   $label			a label that resembles a number
       37*   label(x)		label variable or constant, may be subscripted
       38*
       39*   any of these may be followed by an optional ,s
       40*   which is a relative displacement in statements
       41*
       42*   james R. Davis  25 June 79
       43*   modified last on 2 Oct 79 */
       44   /* Fixed to use line number in an active frame if any 08/27/81 S. Herbst */
       45   /* Fixed to use first instruction in component if no entrypoint 09/22/81 S. Herbst */
       46   /* Modified June 83 JMAthane to replace references to "runtime_symbol" structure
       47*   by calls to "runtime_symbol_info_" subroutine. */
       48   /* Added version strings to runtime_symbol_info_ structures 10/06/83 S. Herbst */
       49   /* Fixed references of the form LINE,N (N'th stmt on line) 03/12/84 S. Herbst */
       50 
       51 
       52   dcl (
       53       P_probe_info_ptr	pointer,
       54       P_new_source_info_ptr	ptr,
       55       P_invocation		fixed bin,
       56       P_switches		bit (36) aligned,
       57       P_data_type		fixed bin,/* output: data type found */
       58       P_code		fixed bin (35)
       59       )			parameter;
       60 
       61   dcl switches		bit (36) unaligned;
       62 
       63   dcl 1 new_source_info	aligned like source_info
       64 			based (new_source_info_ptr);
       65   dcl new_source_info_ptr	ptr;
       66   dcl first_instr_ptr	ptr;
       67   dcl stmt		fixed bin;
       68   dcl code		fixed bin (35);
       69   dcl saved_ct		ptr;	/* so we can restore if error */
       70 
       71   dcl stu_$get_map_index	entry (ptr, fixed bin (18) unsigned, fixed bin,
       72 			ptr);
       73   dcl stu_$get_statement_map	entry (ptr, ptr, ptr, fixed bin);
       74 
       75   dcl probe_get_$integer	entry (ptr, fixed bin, fixed bin (35));
       76 
       77   dcl probe_error_$record	entry options (variable);
       78 
       79   dcl (
       80       probe_et_$none_active,
       81       probe_et_$bad_line,
       82       probe_et_$bad_line_syntax,
       83       probe_et_$recorded_message
       84       )			fixed bin (35) external static;
       85 
       86   dcl (addr, addrel, after, binary, null, rel, substr, unspec, verify)
       87 			builtin;
       88 
       89 
       90   probe_info_ptr = P_probe_info_ptr;
       91   new_source_info_ptr = P_new_source_info_ptr;
       92   switches = P_switches;
       93   P_data_type = label_constant_runtime_dtype;
       94 				/* true for most */
       95   P_code = 0;
       96   code = 0;
       97 
       98   saved_ct = probe_info.ct;		/* in case of error */
       99 
      100   if probe_info.ct -> token.type = CONSTANT_TYPE
      101     then
      102       begin;
      103       dcl file		    fixed bin;
      104       dcl line		    fixed bin;
      105       dcl probe_find_location_    entry (ptr, ptr, fixed bin, fixed bin,
      106 			    fixed bin, bit (36) aligned, ptr, fixed bin)
      107 			    ;
      108 
      109       call probe_get_$integer (probe_info_ptr, line, code);
      110       if code ^= 0
      111         then goto BAD_LINE;
      112       if probe_info.ct -> token.type = MINUS &
      113 	 ^probe_info.ct -> token.leading_whitespace then do;
      114 				/* avoid LL -bf, accept FF-LL */
      115 	file = line;		/* FF-LL */
      116 	call bump_ct ();
      117 	if probe_info.ct -> token.type ^= CONSTANT_TYPE
      118 	  then goto BAD_LINE;
      119 	call probe_get_$integer (probe_info_ptr, line, code);
      120 	if code ^= 0
      121 	  then goto BAD_LINE;
      122         end;
      123         else file = 0;
      124 
      125       if probe_info.execute then do;
      126 	new_source_info = current_source;
      127 	call probe_find_location_ (probe_info_ptr,
      128 	     (new_source_info.seg_info_ptr),
      129 	     (file), (line), 1, (switches), (null),
      130 	     new_source_info.stmnt_map_entry_index);
      131 	if new_source_info.stmnt_map_entry_index = -1
      132 	  then go to BAD_LINE_NUMBER;
      133         end;			/* execute */
      134     end;				/* LINE CASE */
      135   else if probe_info.ct -> token.type = NAME_TYPE then do;
      136       if substr (current_identifier_name, 1, 1) = "$" then do;
      137 	if current_identifier_name = "$c"
      138 	  then
      139 	       if probe_info.execute
      140 	         then new_source_info = current_source;
      141 	         else ;		/* not executing */
      142 	else if current_identifier_name = "$b"
      143 	  then
      144 	       if probe_info.execute
      145 	         then if probe_info.break_slot_ptr = null ()
      146 		      then do;
      147 		        code = probe_et_$none_active;
      148 		        goto SOME_ERROR;
      149 		      end;
      150 		      else new_source_info = initial_source;
      151 				/* what caused the break */
      152 	         else ;		/* not executing */
      153 	else
      154 	  begin;			/* must be $NNN FORTRAN line number */
      155 	  dcl stu_$find_runtime_symbol
      156 				entry (ptr, char (*), ptr,
      157 				fixed bin (35)) returns (ptr);
      158 	  dcl probe_cv_stu_code_	entry (fixed bin (35));
      159 	  dcl symbp		ptr;
      160 				/* to the symbol found */
      161 	  dcl label_name		char (64) varying;
      162 	  dcl DIGITS		char (10) aligned internal
      163 				static options (constant)
      164 				init ("0123456789");
      165 	  dcl 1 type_info		like runtime_type_info;
      166 	  dcl 1 address_info	like runtime_address_info;
      167 
      168 	  label_name = after (current_identifier_name, "$");
      169 	  if label_name = ""
      170 	    then goto BAD_LINE;
      171 	  if verify (label_name, DIGITS) ^= 0
      172 	    then goto BAD_LINE;
      173 
      174 	  if probe_info.execute then do;
      175 	      new_source_info = current_source;
      176 	      symbp =
      177 		 stu_$find_runtime_symbol ((current_source.block_ptr),
      178 		 (label_name),
      179 		 new_source_info.block_ptr, code);
      180 	      if symbp = null () then do;
      181 		call probe_cv_stu_code_ (code);
      182 		call probe_error_$record (probe_info_ptr, code,
      183 		     label_name);
      184 		goto RECORDED_MESSAGE;
      185 	        end;
      186 
      187 	      type_info.version = RUNTIME_TYPE_INFO_VERSION_1;
      188 
      189 	      call runtime_symbol_info_$type (symbp, addr (type_info), code)
      190 		 ;
      191 	      if code ^= 0
      192 	        then go to SOME_ERROR;
      193 
      194 	      P_data_type = type_info.type;
      195 
      196 	      if P_data_type ^= label_constant_runtime_dtype then do;
      197 		call probe_error_$record (probe_info_ptr, 0,
      198 		     """^a"" is not a statement label", label_name);
      199 		goto RECORDED_MESSAGE;
      200 	        end;
      201 
      202 	      address_info.version = RUNTIME_ADDRESS_INFO_VERSION_1;
      203 
      204 	      call runtime_symbol_info_$address (symbp, addr (address_info),
      205 		 code);
      206 	      if code ^= 0
      207 	        then go to SOME_ERROR;
      208 
      209 	      call stu_$get_map_index
      210 		 ((current_source.seg_info_ptr
      211 		 -> seg_info.symbol_header_ptr),
      212 		 (address_info.location),
      213 		 new_source_info.stmnt_map_entry_index, (null));
      214 
      215 	      if new_source_info.stmnt_map_entry_index = -1 then do;
      216 		call probe_error_$record (probe_info_ptr, 0,
      217 		     "Could not find location for $^a", label_name);
      218 		goto RECORDED_MESSAGE;
      219 	        end;
      220 	    end;			/* execute */
      221 	end;			/* $NNN CASE */
      222 
      223 	call bump_ct ();		/* past the $thing */
      224         end;			/* $ hackers */
      225         else
      226 	begin;			/* some other name type - a real name */
      227 
      228 	dcl where		        ptr;
      229 				/* to the code referenced */
      230 	dcl based_label	        label variable based;
      231 	dcl 1 label_var	        aligned,
      232 	     2 place	        ptr,
      233 	     2 frame	        ptr;
      234 	dcl label_vector_tv	        bit (18) aligned based;
      235 				/* for label array */
      236 
      237 	dcl probe_create_reference_ entry (ptr, ptr);
      238 	dcl probe_get_$value        entry (ptr,
      239 			        1 aligned like reference_node,
      240 			        bit (36) aligned, fixed bin (35));
      241 	dcl probe_seg_info_	        entry (ptr, ptr, fixed bin (35))
      242 			        returns (ptr);
      243 
      244 
      245 	call probe_create_reference_ (probe_info_ptr, ref_block_ptr);
      246 	ref_block.source_info_ptr = new_source_info_ptr;
      247 
      248 	call probe_get_$value (probe_info_ptr, ref_block.ref_node,
      249 	     (switches), code);
      250 	if code ^= 0
      251 	  then goto BAD_LOCATION;
      252 
      253 	if probe_info.execute then do;/* must get location */
      254 
      255 	    P_data_type = ref_block.ref_node.type;
      256 
      257 	    if ref_block.ref_node.type = label_constant_runtime_dtype
      258 	      then do;
      259 	        where = ref_block.ref_node.address_ptr;
      260 
      261 	        /* label array constants are implemented as an array of tra LOC,ic  */
      262 
      263 	        if runtime_symbol_info_$array_dims (ref_block.ref_node
      264 		   .symbol_ptr) ^= 0
      265 		then where = addrel (where, where -> label_vector_tv);
      266 	      end;		/* label constant */
      267 
      268 	    else if new_source_info.stmnt_map_entry_index > 0
      269 	      then
      270 		 go to GET_INVOCATION;
      271 				/* already have line number from an active frame */
      272 
      273 	    else if ref_block.ref_node.type = label_dtype |
      274 	         ref_block.ref_node.type = entry_dtype then do;
      275 
      276 	        unspec (label_var) =
      277 		   unspec (ref_block.ref_node.address_ptr -> based_label);
      278 	        where = label_var.place;
      279 
      280 	        /* this could be in another segment, so must get info */
      281 
      282 	        new_source_info.seg_info_ptr =
      283 		   probe_seg_info_ (probe_info_ptr, where, code);
      284 	        if code ^= 0
      285 		then goto SOME_ERROR;
      286 	      end;		/* label variable */
      287 	    else if ref_block.ref_node.type = int_entry_runtime_dtype |
      288 	         ref_block.ref_node.type = ext_entry_runtime_dtype |
      289 	         ref_block.ref_node.type = ext_procedure_runtime_dtype
      290 	      then
      291 		 where = ref_block.ref_node.address_ptr;
      292 	    else do;		/* some other dtype */
      293 	      call probe_error_$record (probe_info_ptr, 0,
      294 		 """^a"" is not a label or entry value",
      295 		 ref_block.ref_node.name);
      296 	      goto RECORDED_MESSAGE;
      297 	    end;
      298 
      299 	    /* now where is set up */
      300 
      301 	    call stu_$get_map_index
      302 	         ((new_source_info.seg_info_ptr
      303 	         -> seg_info.symbol_header_ptr),
      304 	         binary (rel (where)),
      305 	         new_source_info.stmnt_map_entry_index, (null));
      306 	    if new_source_info.stmnt_map_entry_index = -1 then do;
      307 	        call stu_$get_statement_map
      308 		   /* use first instruction in the component instead */
      309 		   ((new_source_info.seg_info_ptr
      310 		   -> seg_info.symbol_header_ptr),
      311 		   first_instr_ptr, (null), (0));
      312 	        if first_instr_ptr ^= null
      313 		then new_source_info.stmnt_map_entry_index = 1;
      314 		else do;
      315 		  call probe_error_$record (probe_info_ptr, 0,
      316 		       "Can't get statement map of ^a",
      317 		       ref_block.ref_node.name);
      318 		  goto RECORDED_MESSAGE;
      319 		end;
      320 	      end;
      321 GET_INVOCATION:
      322 	    if ref_block.ref_node.invocation_level ^= 0
      323 				/* we were presumably called from get_generation_ */
      324 	      then P_invocation = ref_block.ref_node.invocation_level;
      325 
      326 	  end;			/* executeing NAME */
      327         end;			/* trying to get value */
      328     end;				/* NAME TYPE CASE */
      329   else goto BAD_LINE;
      330 
      331   /* now source_info.seg_info_ptr and stmnt_map_entry_ptr are set */
      332 
      333   stmt = 0;
      334   if probe_info.ct -> token.type = COMMA then do;
      335 
      336 
      337       call bump_ct ();
      338 
      339       /* Want the N'th statement starting at the specified line */
      340 
      341       if probe_info.ct -> token.type ^= CONSTANT_TYPE
      342         then goto BAD_LINE;
      343       call probe_get_$integer (probe_info_ptr, stmt, code);
      344       if code ^= 0 then do;
      345 	call probe_error_$record (probe_info_ptr, 0,
      346 	     "A relative statement number must follow the comma in a LINE. Type ""help LINE""."
      347 	     );
      348 	goto RECORDED_MESSAGE;
      349         end;
      350       stmt = stmt - 1;		/* convert to relative position, eg. N,1 = N */
      351     end;				/* COMMA hacking */
      352 
      353   if probe_info.ct -> token.type < OPERATOR_TYPE
      354     then goto BAD_LINE;
      355 
      356   /* now find block, stack, etc. given the above info */
      357 
      358 
      359   dcl probe_source_segment_$position_source
      360 			entry (ptr, ptr, fixed bin, fixed bin (35));
      361 
      362   if probe_info.execute
      363     then call probe_source_segment_$position_source
      364 	    (probe_info_ptr, new_source_info_ptr, stmt, code);
      365 
      366 MAIN_RETURN:
      367   P_code = code;
      368   return;
      369 
      370 
      371   /* HERE ARE ERROR LABELS */
      372 
      373 BAD_LINE:
      374   call probe_error_$record (probe_info_ptr, probe_et_$bad_line_syntax);
      375   goto RECORDED_MESSAGE;
      376 
      377 BAD_LINE_NUMBER:
      378   call probe_error_$record (probe_info_ptr, probe_et_$bad_line);
      379   go to RECORDED_MESSAGE;
      380 
      381 BAD_LOCATION:
      382   call probe_error_$record (probe_info_ptr, 0,
      383        "Can't get location of ^a", ref_block.ref_node.name);
      384   go to RECORDED_MESSAGE;
      385 
      386 RECORDED_MESSAGE:
      387   code = probe_et_$recorded_message;
      388   goto SOME_ERROR;
      389 
      390 SOME_ERROR:
      391   P_code = code;
      392 
      393   probe_info.ct = saved_ct;		/* restore, cause we  failed */
      394   return;
      395 
      396 
      397 
      398 
      399 
      400 bump_ct:
      401   proc;
      402   probe_info.ct = probe_info.ct -> token.next;
      403   end bump_ct;
      404 
  1     1 /*	BEGIN INCLUDE FILE probe_info.incl.pl1		*/
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(88-10-24,WAAnderson), approve(88-10-24,MCR7952),
  1     7*     audit(88-10-24,RWaters), install(88-10-27,MR12.2-1194):
  1     8*     Added field 'retry_using_main' to add new C feature.
  1     9*                                                   END HISTORY COMMENTS */
  1    10 
  1    11 
  1    12 /* Created: 04/22/79 W. Olin Sibert, from subsystem_info	
  1    13*   Modified: 22 Sept 79 JRd to remove: 	default (ptr & (auto|based)) init (null ());
  1    14*   Added flags.setting_break 08/22/83 Steve Herbst
  1    15*   Added flags.executing_quit_request 01/15/85 Steve Herbst
  1    16**/
  1    17 
  1    18 dcl 1 probe_info aligned based (probe_info_ptr),		/* standard data for a probe invocation */
  1    19     2 probe_info_version fixed bin,			/* version of this structure */
  1    20 
  1    21     2 static_info_ptr pointer unaligned,		/* pointer to static information structure */
  1    22     2 modes_ptr pointer unaligned,			/* pointer to probe_modes structure */
  1    23 
  1    24     2 ptr_to_current_source ptr,			/* current_source is based on this */
  1    25     2 ptr_to_initial_source ptr,			/* initial_source is based on this */
  1    26     2 machine_cond_ptr pointer,			/* pointer to machine conditions, if we faulted to get here */
  1    27 
  1    28     2 token_info aligned,				/* information about token chain currently being processed */
  1    29       3 first_token pointer unaligned,			/* first token in chain */
  1    30       3 ct pointer unaligned, 			/* pointer to current token; updated in MANY places */
  1    31       3 end_token bit (18) aligned,			/* token type at which to stop scanning token chain */
  1    32       3 buffer_ptr pointer unaligned,			/* pointer to input buffer */
  1    33       3 buffer_lth fixed bin (21),			/* and length */
  1    34 
  1    35     2 random_info aligned,
  1    36       3 current_stack_frame pointer unaligned,		/* stack frame pointer for frame in which probe was invoked */
  1    37       3 input_type fixed bin, 			/* current input type */
  1    38       3 language_type fixed bin,			/* current language being processed */
  1    39       3 return_method fixed bin,			/* how we should return after exiting probe */
  1    40       3 entry_method fixed bin,			/* how we got here in the first place */
  1    41       3 pad1 (19) bit (36) aligned,
  1    42 
  1    43     2 break_info,					/* break info -- only interesting if we got here via a break */
  1    44       3 break_slot_ptr pointer,			/* pointer to break slot -- non-null IFF at a break */
  1    45       3 last_break_slot_ptr pointer unaligned,		/* pointer to previous break slot, not presently used */
  1    46       3 break_reset bit (1) aligned,			/* this break has been reset by somebody further on */
  1    47       3 real_break_return_loc pointer,			/* where to REALLY return to, modulo previous bit */
  1    48 
  1    49     2 probe_area_info,				/* information about various probe areas */
  1    50       3 break_segment_ptr pointer unaligned,		/* pointer to Personid.probe */
  1    51       3 break_area_ptr pointer unaligned,		/* pointer to area in break segment */
  1    52       3 scratch_area_ptr pointer unaligned,		/* pointer to probe scratch seg in process dir */
  1    53       3 probe_area_ptr pointer unaligned,		/* This area lasts as long as an invocation of probe. */
  1    54       3 work_area_ptr pointer unaligned,		/* This area lasts as long as the current request line */
  1    55       3 expression_area_ptr pointer unaligned,		/* This area lasts as long as the current command */
  1    56 
  1    57     2 flags aligned,				/* this, in particular, should be saved and restored correctly */
  1    58      (3 execute,					/* "1"b => execute requests, "0"b => just check syntax */
  1    59       3 in_listener,				/* ON => in probe listener loop */
  1    60       3 executing_request,				/* ON => executing a request */
  1    61       3 in_interpret_line,				/* executing in probe_listen_$interpret_line */
  1    62       3 setting_break,				/* executing "after" or "before": check syntax of "if" */
  1    63       3 executing_quit_request,			/* to prevent error looping during "quit" request */
  1    64       3 pad (30)) bit (1) unaligned,
  1    65 
  1    66     2 io_switches,					/* switches probe will do normal I/O on */
  1    67       3 input_switch pointer,
  1    68       3 output_switch pointer,
  1    69 
  1    70     2 error_info,					/* information about the last error saved for later printing */
  1    71       3 error_code fixed bin (35),
  1    72       3 error_message char (300) varying,
  1    73 
  1    74     2 listener_info,				/* internal use by probe listener */
  1    75       3 request_name character (32) varying,		/* primary name of the request being processed */
  1    76       3 abort_probe_label label variable,
  1    77       3 abort_line_label label variable,
  1    78       3 depth fixed binary,				/* count of active invocations of probe */
  1    79       3 previous pointer unaligned,			/* -> previous invocation's info */
  1    80       3 next pointer unaligned,
  1    81 
  1    82     2 end_of_probe_info pointer aligned,
  1    83     2 retry_using_main fixed bin aligned;
  1    84    
  1    85 
  1    86 dcl  probe_info_ptr pointer;
  1    87 
  1    88 dcl  probe_info_version fixed bin static options (constant) initial (1);
  1    89 
  1    90 dcl  probe_info_version_1 fixed bin static options (constant) initial (1);
  1    91 
  1    92 dcl  scratch_area area based (probe_info.scratch_area_ptr);
  1    93 dcl  probe_area area based (probe_info.probe_area_ptr);
  1    94 dcl  work_area area based (probe_info.work_area_ptr);
  1    95 dcl  expression_area area based (probe_info.expression_area_ptr);
  1    96 
  1    97 /*	END INCLUDE FILE probe_info.incl.pl1		*/
      405 
      406 
  2     1 /* BEGIN INCLUDE FILE ... probe_operators.incl.pl1 */
  2     2 
  2     3 
  2     4 
  2     5 /****^  HISTORY COMMENTS:
  2     6*  1) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  2     7*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  2     8*     Added new C operators.
  2     9*                                                   END HISTORY COMMENTS */
  2    10 
  2    11 
  2    12 /* These are the operator.types for each defined operator */
  2    13 /* Modified June 83 JMAthane for PASCAL_ARROW new operator */
  2    14 /* Added PASCAL_RANGE and PASCAL_ASSIGN 07/26/83 S. Herbst */
  2    15 /* Modified April 88 Hinatsu Addition of C types */
  2    16 
  2    17      dcl	   (PLUS		      init ("400001"b3), MINUS init ("400002"b3),
  2    18 	   TIMES		      init ("400003"b3), SLASH init ("400004"b3),
  2    19 	   OR_BAR		      init ("400005"b3), NOT_SIGN init ("400006"b3),
  2    20 	   LESS_THAN	      init ("400007"b3), GREATER_THAN init ("400010"b3),
  2    21 	   EQUALS		      init ("400011"b3), NOT_EQUALS init ("400012"b3),
  2    22 	   NOT_GREATER_THAN	      init ("400013"b3), NOT_LESS_THAN init ("400014"b3),
  2    23 	   PERIOD		      init ("400015"b3), COLON init ("400016"b3),
  2    24 	   AMPERSAND	      init ("400017"b3), PERCENT init ("400020"b3),
  2    25 	   DOLLAR_SIGN	      init ("400021"b3), LEFT_BRACKET init ("400022"b3),
  2    26 	   RIGHT_BRACKET	      init ("400023"b3), ARROW init ("400024"b3),
  2    27 	   COMMA		      init ("400025"b3), QUESTION_MARK init ("400026"b3),
  2    28 	   PASCAL_ARROW	      init ("400027"b3), PASCAL_RANGE init ("400030"b3),
  2    29 	   PASCAL_ASSIGN	      init ("400031"b3),
  2    30 
  2    31 /* Additons to support C types */
  2    32 	   C_LEFT_SHIFT           init ("400032"b3), C_RIGHT_SHIFT init ("400033"b3),
  2    33 
  2    34 /* operator 28 are left for future expansion */
  2    35 
  2    36 	   LEFT_PAREN	      init ("400035"b3), RIGHT_PAREN init ("400036"b3),
  2    37              C_EQUAL                init ("400037"b3), C_NOT_EQUAL init ("400040"b3),
  2    38 	   SEMI_COLON	      init ("400041"b3), NEW_LINE init ("400042"b3),
  2    39 	   C_INDIRECTION          init ("400034"b3)
  2    40 
  2    41 	   )		      bit (18) aligned internal static options (constant);
  2    42 
  2    43      dcl	   OPERATOR_VALUES	      (0:34) char (4) varying internal static options (constant) init
  2    44 			      ("????", "+", "-", "*", "/", "|", "^", "<",
  2    45 			      ">", "=", "^=", "<=", ">=", ".", ":", "&",
  2    46 			      "%", "$", "[", "]", "->", ",", "?", "^",
  2    47 			      "..", ":=", "<<", ">>", "*", "(", ")",
  2    48 			      "==", "!=", ";","
  2    49 ");
  2    50 
  2    51 /* END INCLUDE FILE ... probe_operators.incl.pl1 */
      407 
      408 
  3     1 /*	BEGIN INCLUDE FILE probe_ref_block.incl.pl1	*/
  3     2 
  3     3 /* *	This declares all the necessary storage for a reference node and the
  3     4*   *	things it points to. Programs which create reference nodes should either
  3     5*   *	declare automatic ref_blocks like ref_block, and call probe_create_reference_$init
  3     6*   *	to initialize the automatic copies, or call probe_create_reference_ directly
  3     7*   *	to allocate them in expression_area and initialize the, returning a pointer
  3     8*   *	which will be valid for the duration of the request. */
  3     9 
  3    10 dcl  ref_block_ptr pointer;
  3    11 
  3    12 dcl 1 ref_block aligned based (ref_block_ptr),		/* we allocate this in the area and fill it in */
  3    13     2 ref_node aligned like reference_node,
  3    14     2 subscripts aligned like reference_subscripts,
  3    15     2 arglist aligned like reference_arg_list,
  3    16     2 source_info aligned like source_info,
  3    17     2 sub_refs aligned like subscript_reference_ptrs;
  3    18 
  3    19 /*	END INCLUDE FILE probe_ref_block.incl.pl1	*/
      409 
      410 
  4     1 /*	BEGIN INCLUDE FILE probe_references.incl.pl1	*/
  4     2 
  4     3 /****^  HISTORY COMMENTS:
  4     4*  1) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  4     5*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  4     6*     Added new field (c_symbol) for C-Probe support.
  4     7*  2) change(88-10-28,WAAnderson), approve(88-10-28,MCR7952),
  4     8*     audit(88-10-31,RWaters), install(88-11-11,MR12.2-1210):
  4     9*     Added new field (c_sub_c_ptr) for C-Probe_support.
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 /*	Split out of probe_tokens, 04/22/79 WOS 	*/
  4    13 /*       modified for probe variables Feb 19 80 JRD         */
  4    14 /*   Modified June 83 JMAthane to add "type_ptr" and "builtin" fields */
  4    15 
  4    16      dcl	   1 reference_node	      aligned based,	/* information about a reference */
  4    17 	     2 symbol_ptr	      pointer aligned,	/* to symbol table entry for reference */
  4    18 	     2 type_ptr	      pointer aligned,	/* to symbol table entry for type (null if none) */
  4    19 	     2 address_ptr	      pointer aligned,	/* to location of variable */
  4    20 	     2 base_addr	      pointer aligned,	/* pointer on which whole symbol is based */
  4    21 	     2 source_info_ptr    pointer aligned,	/* to symbol structure for reference */
  4    22 
  4    23 	     2 name	      char (256) unaligned varying, /* symbol name */
  4    24 
  4    25 	     2 type	      fixed bin (35),	/* data type */
  4    26 	     2 descriptor	      fixed bin (35),	/* type || packed */
  4    27 	     2 precision	      fixed bin (35),	/* scale and precision */
  4    28 	     2 flags,
  4    29 	       3 packed	      bit (1) unal,		/* data is in packed format */
  4    30 	       3 constant	      bit (1) unal,		/* data is really a constant */
  4    31 	       3 cross_section    bit (1) unal,		/* reference is an array cross-section */
  4    32 	       3 function	      bit (1) unal,		/* reference is function value */
  4    33 	       3 octal	      bit (1) unal,		/* indicates that this is the octal bif */
  4    34 	       3 star_extent      bit (1) unal,		/* reference is a star subscript for father */
  4    35 	       3 have_generation  bit (1) unal,		/* this reference has an explicitly specified generation */
  4    36 	       3 pseudo_var	      bit (1) unal,		/* it is ok to assign to it */
  4    37 	       3 probe_variable   bit (1) unal,
  4    38 	       3 path	      bit (1) unal,		/* it's a pathname/virtual entry */
  4    39 	       3 builtin	      bit (1) unal,		/* probe builtinvalue */
  4    40 	       3 c_ptr_to_char    bit (1)  unal,
  4    41                  3 c_sub_c_ptr      bit (1)  unal,
  4    42 	       3 pad2	      bit (23) unal,
  4    43 
  4    44 	     2 optional_info,			/* information which may or may not be present */
  4    45 	       3 argument_list    pointer unaligned,	/* pointer to reference_arg_list */
  4    46 	       3 subscript_ptr    pointer unaligned,	/* pointer to reference_subscripts */
  4    47 	       3 n_arguments      fixed bin,		/* number of arguments in argument list */
  4    48 	       3 n_subscripts     fixed bin,		/* number of subscripts present */
  4    49 
  4    50 	     2 constant_token_ptr pointer unaligned,	/* pointer to constant token if this is a constant */
  4    51 	     2 subscript_refs_ptr pointer unaligned,	/* pointer to array of subscript reference node pointers */
  4    52 	     2 invocation_level   fixed bin,		/* invocation level number ("[-17]") for this reference */
  4    53 	     2 probe_var_info_ptr ptr unal,		/* only if flags.probe_variable */
  4    54                2 c_symbol_ptr  ptr unal,
  4    55 	     2 pad1	      (9) pointer unaligned,
  4    56 	     2 end_of_reference_node pointer aligned;
  4    57 
  4    58 
  4    59      dcl	   1 reference_arg_list   aligned based,	/* argument list; based on reference.argument_list */
  4    60 	     2 number	      fixed bin,		/* number of arguments actually present */
  4    61 	     2 node	      (16) pointer aligned;	/* reference node pointers for each argument */
  4    62 
  4    63 
  4    64      dcl	   1 reference_subscripts aligned based,	/* subscript array; based on reference.subscript_ptr */
  4    65 	     2 number	      fixed bin,		/* number actually present */
  4    66 	     2 value	      (2, 16) fixed bin (24); /* values for lower and upper bound for each */
  4    67 
  4    68 
  4    69      dcl	   1 subscript_reference_ptrs aligned based,	/* array of pointers to subscript reference nodes */
  4    70 	     2 ptr	      (2, 16) pointer aligned;
  4    71 
  4    72 /*	END INCLUDE FILE probe_references.incl.pl1	*/
      411 
      412 
  5     1 /* BEGIN INCLUDE FILE ... probe_seg_info.incl.pl1
  5     2*
  5     3*   25 June 79 JRDavis
  5     4*
  5     5*   Modified  7 April 1983, TO - Add fields for character offset/line
  5     6*	correction per file.
  5     7**/
  5     8 
  5     9 dcl 1 seg_info based aligned,				/* place to remember information about object seg */
  5    10     2 language_type fixed bin,			/* language of source program */
  5    11     2 bits aligned,
  5    12       3 ignore_case bit (1) unal,
  5    13       3 bound_segment bit (1) unaligned,
  5    14       3 component bit (1) unaligned,
  5    15       3 pad bit (33) unal,
  5    16     2 names,					/* where to find it */
  5    17       3 directory_name character (168) unal,		/* what directory */
  5    18       3 entry_name character (32) unal,			/* what segment */
  5    19       3 segname character (32) unal,			/* procedure segname definition */
  5    20     2 identifier fixed bin (71),			/* time of object creation */
  5    21     2 pointers,					/* location of various parts of segment */
  5    22       3 symbol_header_ptr ptr unal,			/* to symbol section */
  5    23       3 original_source_ptr ptr unal,			/* to segment source map */
  5    24       3 statement_map_ptr ptr unal,			/* to segment statement map */
  5    25       3 break_info ptr unal,				/* for unbound segments, and start of chain for
  5    26*						   bound ones, -> break_map !obsolete, I think! */
  5    27       3 chain ptr unal,				/* to entry for next component if bound */
  5    28       3 linkage_ptr ptr unal,				/* to linkage section */
  5    29     2 bounds aligned,				/* structure of bounds information */
  5    30       3 text_bounds,
  5    31         4 start fixed bin (35),
  5    32         4 end fixed bin (35),
  5    33       3 symbol_bounds,
  5    34         4 start fixed bin (35),
  5    35         4 end fixed bin (35),
  5    36     2 map_size fixed bin,				/* size of statement map */
  5    37     2 error_code fixed bin (35),			/* errors encoutered while getting info, are recorded here */
  5    38     2 bound_create_time fixed bin (71),			/* time seg containing was bound or compiled. */
  5    39     2 bound_sym_header ptr unal,			/* to sym. section header for bound seg */
  5    40     2 pad (1) fixed bin (35),
  5    41 
  5    42     2 nfiles fixed bin,
  5    43     2 per_file (seg_info_nfiles refer (seg_info.nfiles)),
  5    44       3 file_pointers ptr unal,
  5    45       3 break_line (0:3) fixed bin (18) unsigned unaligned;
  5    46 
  5    47 dcl  seg_info_nfiles fixed bin;			/* for allocation purposes */
  5    48 
  5    49 
  5    50 /* END INCLUDE FILE ... probe_seg_info.incl.pl1 */
      413 
      414 
  6     1 /* BEGIN INCLUDE FILE ... probe_source_info.incl.pl1
  6     2*
  6     3*  James R. Davis 2 July 79 */
  6     4 
  6     5 dcl 1 source_info based aligned,
  6     6       2 stmnt_map_entry_index fixed bin,		/* index in stmnt map for this stmnt */
  6     7       2 instruction_ptr ptr,				/* to last instruction executed  */
  6     8       2 block_ptr ptr,				/* to runtime_block node */
  6     9       2 stack_ptr ptr,				/* to a stack frame */
  6    10       2 entry_ptr ptr,				/* to entry seq. for this proc */
  6    11       2 seg_info_ptr ptr;				/* to seg_info */
  6    12 
  6    13 dcl 1 current_source aligned like source_info based (probe_info.ptr_to_current_source);
  6    14 dcl 1 initial_source aligned like source_info based (probe_info.ptr_to_initial_source);
  6    15 
  6    16 /* END INCLUDE FILE ... probe_source_info.incl.pl1 */
      415 
      416 
  7     1 /*	BEGIN INCLUDE FILE probe_tokens.incl.pl1	*/
  7     2 /*	Split up into probe_tokens and probe_references, 04/22/79 WOS */
  7     3 
  7     4 dcl 1 token_header aligned based,			/* header information common to all tokens */
  7     5     2 next pointer unaligned,				/* pointer to next token in chain */
  7     6     2 prev pointer unaligned,				/* same for previous token */
  7     7     2 type bit (18) aligned,
  7     8     2 buffer_ptr pointer unaligned,			/* pointer to beginning of input buffer */
  7     9     2 location fixed bin (17) unal,			/* offset in input buffer */
  7    10     2 length fixed bin (17) unal,
  7    11     2 flags aligned,
  7    12      (3 leading_whitespace,				/* there is whitespace before thios token */
  7    13       3 trailing_whitespace) bit (1) unaligned,		/* and same for after */
  7    14       3 pad1 bit (34) unaligned;
  7    15 
  7    16 dcl 1 token aligned based,				/* produced by scan_probe_input_ */
  7    17     2 header aligned like token_header;			/* that's all there is */
  7    18 
  7    19 dcl 1 identifier aligned based,			/* keyword or identifier token */
  7    20     2 header aligned like token_header,
  7    21     2 length fixed bin,				/* length of name */
  7    22     2 name pointer unaligned;				/* to string in buffer containing name */
  7    23 
  7    24 dcl 1 operator aligned based,				/* for punctuation */
  7    25     2 header aligned like token_header;			/* nothing but a header here */
  7    26 
  7    27 dcl 1 constant aligned based,				/* for strings pointers numbers etc */
  7    28     2 header aligned like token_header,
  7    29     2 encoded_precision aligned,			/* encoded precision kludge for assign_ */
  7    30       3 scale fixed bin (17) unaligned,			/* arithmetic scale */
  7    31       3 precision fixed bin (17) unaligned,		/* arithmetic precision or other size */
  7    32     2 scale_and_precision fixed bin (35),		/* An identical copy of the two values above */
  7    33     2 data_type fixed bin,				/* standard data type code + packed bit */
  7    34     2 data_ptr pointer unaligned;
  7    35 
  7    36 
  7    37 dcl (OPERATOR_TYPE init ("100"b),			/* types for above */
  7    38      NAME_TYPE init ("010"b),
  7    39      CONSTANT_TYPE init ("001"b)) bit (18) internal static options (constant);
  7    40 
  7    41 
  7    42 dcl  current_identifier_name				/* Overlays for looking at the current tokens */
  7    43      char (probe_info.ct -> identifier.length) based (probe_info.ct -> identifier.name);
  7    44 dcl 1 current_constant aligned like constant based (probe_info.ct);
  7    45 dcl 1 current_token aligned like token based (probe_info.ct);
  7    46 
  7    47 /*	END INCLUDE FILE probe_tokens.incl.pl1		*/
      417 
      418 
  8     1 /*	BEGIN INCLUDE FILE ... runtime_symbol.incl.pl1 ... Modified 07/79 */
  8     2 
  8     3 dcl	1 runtime_symbol	aligned based,
  8     4 	2 flag		unal bit(1),	/* always "1"b for Version II */
  8     5 	2 use_digit	unal bit(1),	/* if "1"b and units are half words units are really digits */
  8     6 	2 array_units	unal bit(2),
  8     7 	2 units		unal bit(2),	/* addressing units */
  8     8 	2 type		unal bit(6),	/* data type */
  8     9 	2 level		unal bit(6),	/* structure level */
  8    10 	2 ndims		unal bit(6),	/* number of dimensions */
  8    11 	2 bits		unal,
  8    12 	  3 aligned	bit(1),
  8    13 	  3 packed	bit(1),
  8    14 	  3 simple	bit(1),
  8    15 	2 skip		unal bit(1),
  8    16 	2 scale		unal bit(8),	/* arithmetic scale factor */
  8    17 	2 name		unal bit(18),	/* rel ptr to acc name */
  8    18 	2 brother		unal bit(18),	/* rel ptr to brother entry */
  8    19 	2 father		unal bit(18),	/* rel ptr to father entry */
  8    20 	2 son		unal bit(18),	/* rel ptr to son entry */
  8    21 	2 address		unal,
  8    22 	  3 location	bit(18),		/* location in storage class */
  8    23 	  3 class		bit(4),		/* storage class */
  8    24 	  3 next		bit(14),		/* rel ptr to next of same class */
  8    25 	2 size		fixed bin(35),	/* encoded string|arith size */
  8    26 	2 offset		fixed bin(35),	/* encoded offset from address */
  8    27 	2 virtual_org	fixed bin(35),
  8    28 	2 bounds(1),
  8    29 	  3 lower		fixed bin(35),	/* encoded lower bound */
  8    30 	  3 upper		fixed bin(35),	/* encoded upper bound */
  8    31 	  3 multiplier	fixed bin(35);	/* encoded multiplier */
  8    32 
  8    33 dcl	1 runtime_bound	based,
  8    34 	2 lower		fixed bin(35),
  8    35 	2 upper		fixed bin(35),
  8    36 	2 multiplier	fixed bin(35);
  8    37 
  8    38 dcl	1 runtime_block	aligned based,
  8    39 	2 flag		unal bit(1),	/* always "1"b for Version II */
  8    40 	2 quick		unal bit(1),	/* "1"b if quick block */
  8    41 	2 fortran		unal bit(1),	/* "1"b if fortran program */
  8    42 	2 standard	unal bit(1),	/* "1"b if program has std obj segment */
  8    43 	2 owner_flag	unal bit(1),	/* "1"b if block has valid owner field */
  8    44 	2 skip		unal bit(1),
  8    45 	2 type		unal bit(6),	/* = 0 for a block node */
  8    46 	2 number		unal bit(6),	/* begin block number */
  8    47 	2 start		unal bit(18),	/* rel ptr to start of symbols */
  8    48 	2 name		unal bit(18),	/* rel ptr to name of proc */
  8    49 	2 brother		unal bit(18),	/* rel ptr to brother block */
  8    50 	2 father		unal bit(18),	/* rel ptr to father block */
  8    51 	2 son		unal bit(18),	/* rel ptr to son block */
  8    52 	2 map		unal,
  8    53 	  3 first		bit(18),		/* rel ptr to first word of map */
  8    54 	  3 last		bit(18),		/* rel ptr to last word of map */
  8    55 	2 entry_info	unal bit(18),	/* info about entry of quick block */
  8    56 	2 header		unal bit(18),	/* rel ptr to symbol header */
  8    57 	2 chain(4)	unal bit(18),	/* chain(i) is rel ptr to first symbol
  8    58*					   on start list with length >= 2**i */
  8    59 	2 token(0:5)	unal bit(18),	/* token(i) is rel ptr to first token
  8    60*					   on list with length >= 2 ** i */
  8    61 	2 owner		unal bit(18);	/* rel ptr to owner block */
  8    62 
  8    63 dcl	1 runtime_token	aligned based,
  8    64 	2 next		unal bit(18),	/* rel ptr to next token */
  8    65 	2 dcl		unal bit(18),	/* rel ptr to first dcl of this token */
  8    66 	2 name,				/* ACC */
  8    67 	  3 size		unal unsigned fixed bin (9), /* number of chars in token */
  8    68 	  3 string	unal char(n refer(runtime_token.size));
  8    69 
  8    70 dcl	1 encoded_value	aligned based,
  8    71 	2 flag		bit (2) unal,
  8    72 	2 code		bit (4) unal,
  8    73 	2 n1		bit (6) unal,
  8    74 	2 n2		bit (6) unal,
  8    75 	2 n3		bit (18) unal;
  8    76 
  8    77 /*	END INCLUDE FILE ... runtime_symbol.incl.pl1 */
      419 
      420 
  9     1 /*  BEGIN INCLUDE FILE runtime_symbol_info_.incl.pl1 */
  9     2 
  9     3 
  9     4 /****^  HISTORY COMMENTS:
  9     5*  1) change(86-09-05,JMAthane), approve(86-09-05,MCR7525),
  9     6*     audit(86-09-11,Martinson), install(86-11-12,MR12.0-1208):
  9     7*     Added runtime_symbol_info_$subrange entry which was missing.  Added
  9     8*     has_dimensions and has subrange_limits fields in type_info record.
  9     9*     Structure version numbers have not been changed since this change does not
  9    10*     affect existing programs.
  9    11*                                                   END HISTORY COMMENTS */
  9    12 
  9    13 /* Declarations for using the various entry points in runtime_symbol_info_ */
  9    14 /* NOTE: These entries do not support PL/1 version 1. */
  9    15 
  9    16 /* Made structures aligned, removed variable extent from runtime_array_info.bounds 08/25/83 S. Herbst */
  9    17 /* Added version strings to structures 10/05/83 S. Herbst */
  9    18 /* Added has_dimensions and has_subrange_limits bits in type_info
  9    19*Added subrange entry. JMAthane 08/31/84 */
  9    20 
  9    21 
  9    22      dcl	   runtime_symbol_info_$type entry (ptr, ptr, fixed bin (35));
  9    23 
  9    24      dcl	   1 runtime_type_info    aligned based,
  9    25 	     2 version	      char (8),		/* = "RUNTYP_1" */
  9    26 	     2 flags,
  9    27 	       3 aligned	      bit (1) unal,
  9    28 	       3 packed	      bit (1) unal,
  9    29 	       3 size_is_encoded  bit (1) unal,
  9    30 	       3 has_dimensions   bit (1) unal,
  9    31 	       3 has_subrange_limits bit (1) unal,
  9    32 	       3 pad	      bit (23) unal,
  9    33 	     2 scale	      fixed bin (7) unal,
  9    34 	     2 (type, base_type)  fixed bin (18) unsigned unal,
  9    35 	     2 (type_addr, base_type_addr) ptr,
  9    36 	     2 size	      fixed bin (35);
  9    37 
  9    38      dcl	   runtime_symbol_info_$father entry (ptr) returns (ptr);
  9    39 
  9    40      dcl	   runtime_symbol_info_$brother entry (ptr) returns (ptr);
  9    41 
  9    42      dcl	   runtime_symbol_info_$father_type entry (ptr) returns (ptr);
  9    43 
  9    44      dcl	   runtime_symbol_info_$son entry (ptr) returns (ptr);
  9    45 
  9    46      dcl	   runtime_symbol_info_$successor entry (ptr) returns (ptr);
  9    47 
  9    48      dcl	   runtime_symbol_info_$name entry (ptr) returns (ptr);
  9    49 
  9    50      dcl	   runtime_symbol_info_$level entry (ptr) returns (fixed bin);
  9    51 
  9    52      dcl	   runtime_symbol_info_$next entry (ptr) returns (ptr);
  9    53 
  9    54      dcl	   runtime_symbol_info_$address entry (ptr, ptr, fixed bin (35));
  9    55 
  9    56      dcl	   1 runtime_address_info aligned based,
  9    57 	     2 version	      char (8),		/* = "RUNADR_1" */
  9    58 	     2 location	      fixed bin (18) unsigned unal,
  9    59 	     2 class	      fixed bin (6) unsigned unal,
  9    60 	     2 use_digit	      fixed bin (1) unsigned unal,
  9    61 	     2 units	      fixed bin (2) unsigned unal,
  9    62 	     2 offset_is_encoded  bit (1) unal,
  9    63 	     2 pad	      bit (8) unal,
  9    64 	     2 offset	      fixed bin (35);
  9    65 
  9    66      dcl	   runtime_symbol_info_$array_dims entry (ptr) returns (fixed bin);
  9    67 
  9    68      dcl	   runtime_symbol_info_$array entry (ptr, ptr, fixed bin (35));
  9    69 
  9    70      dcl	   1 runtime_array_info   aligned based,
  9    71 	     2 version	      char (8),		/* = "RUNARY_1" */
  9    72 	     2 access_info	      aligned,
  9    73 	       3 ndims	      fixed bin (6) unsigned unaligned, /* number of dimensions */
  9    74 	       3 use_digit	      fixed bin (1) unsigned unaligned, /* if "1"b and units are half words,
  9    75*						      units are really digits */
  9    76 	       3 array_units      fixed bin (2) unsigned unaligned,
  9    77 	       3 virtual_origin_is_encoded
  9    78 			      bit (1) unaligned,
  9    79 	       3 pad	      bit (26) unaligned,
  9    80 	     2 virtual_origin     fixed bin (35),
  9    81 	     2 bounds	      (16)
  9    82 			      aligned,
  9    83 	       3 flags	      aligned,
  9    84 	         4 lower_is_encoded
  9    85 			      bit (1) unaligned,
  9    86 	         4 upper_is_encoded
  9    87 			      bit (1) unaligned,
  9    88 	         4 multiplier_is_encoded
  9    89 			      bit (1) unaligned,
  9    90 	         4 pad	      bit (33) unaligned,
  9    91 	       3 lower	      fixed bin (35),
  9    92 	       3 upper	      fixed bin (35),
  9    93 	       3 multiplier	      fixed bin (35),
  9    94 	       3 subscript_type   fixed bin (35),
  9    95 	       3 subscript_type_addr ptr;
  9    96 
  9    97      dcl	   n_dims		      fixed bin;
  9    98 
  9    99      dcl	   runtime_symbol_info_$n_variants entry (ptr) returns (fixed bin (35));
  9   100 
  9   101      dcl	   runtime_symbol_info_$variant entry (ptr, ptr, fixed bin (35));
  9   102 
  9   103      dcl	   1 runtime_variant_info aligned based,
  9   104 	     2 version	      char (8),		/* = "RUNVAR_1" */
  9   105 	     2 number_of_variants fixed bin,
  9   106 	     2 first_value_in_set fixed bin (35),	/* value corresponding to the first bit in set stings  */
  9   107 	     2 case	      (n_variants),
  9   108 	       3 set_addr	      ptr,		/* bit string specifies cases;
  9   109*						       set's base type is this node's type */
  9   110 	       3 brother_addr     ptr;		/* ptr to brother for this variant */
  9   111 
  9   112      dcl	   n_variants	      fixed bin (35);
  9   113 
  9   114      dcl	   runtime_symbol_info_$subrange entry (ptr, ptr, fixed bin (35));
  9   115 
  9   116      dcl	   1 runtime_subrange_info based,
  9   117 	     2 version	      char (8),		/* = "RUNSUB_1" */
  9   118 	     2 flags	      aligned,
  9   119 	       3 has_subrange_limits bit (1) unal,
  9   120 	       3 lower_bound_is_encoded bit (1) unal,
  9   121 	       3 upper_bound_is_encoded bit (1) unal,
  9   122 	       3 pad	      bit (33) unal,
  9   123 	     2 subrange_lower_bound fixed bin (35),
  9   124 	     2 subrange_upper_bound fixed bin (35);
  9   125 
  9   126 
  9   127      dcl	   RUNTIME_TYPE_INFO_VERSION_1 char (8) int static options (constant) init ("RUNTYP_1");
  9   128      dcl	   RUNTIME_ADDRESS_INFO_VERSION_1 char (8) int static options (constant) init ("RUNADR_1");
  9   129      dcl	   RUNTIME_ARRAY_INFO_VERSION_1 char (8) int static options (constant) init ("RUNARY_1");
  9   130      dcl	   RUNTIME_VARIANT_INFO_VERSION_1 char (8) int static options (constant) init ("RUNVAR_1");
  9   131      dcl	   RUNTIME_SUBRANGE_INFO_VERSION_1 char (8) int static options (constant) init ("RUNSUB_1");
  9   132 
  9   133 
  9   134 /* END INCLUDE FILE runtime_symbol_info_.incl.pl1 */
      421 
      422 
 10     1 dcl	1 statement_map	aligned based,
 10     2 	2 location	bit(18) unaligned,
 10     3 	2 source_id	unaligned,
 10     4 	  3 file		bit(8),
 10     5 	  3 line		bit(14),
 10     6 	  3 statement	bit(5),
 10     7 	2 source_info	unaligned,
 10     8 	  3 start		bit(18),
 10     9 	  3 length	bit(9);
      423 
      424 
 11     1 /* BEGIN INCLUDE FILE ... std_descriptor_types.incl.pl1 */
 11     2 
 11     3 
 11     4 /****^  HISTORY COMMENTS:
 11     5*  1) change(86-09-05,JMAthane), approve(86-09-05,MCR7525),
 11     6*     audit(86-09-11,Martinson), install(86-11-12,MR12.0-1208):
 11     7*     Added pascal_string_type_dtype descriptor type.  Its number is 87.
 11     8*     Objects of this type are PASCAL string types.
 11     9*  2) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
 11    10*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
 11    11*     Added the new C types.
 11    12*                                                   END HISTORY COMMENTS */
 11    13 
 11    14 /* This include file defines mnemonic names for the Multics
 11    15*   standard descriptor types, using both pl1 and cobol terminology.
 11    16*   PG 780613
 11    17*   JRD 790530
 11    18*   JRD 791016
 11    19*   MBW 810731
 11    20*   TGO 830614 Add hex types.
 11    21*   Modified June 83 JMAthane to add PASCAL data types
 11    22*   TGO 840120 Add float dec extended and generic, float binary generic
 11    23**/
 11    24 
 11    25      dcl	   (real_fix_bin_1_dtype  init (1),
 11    26 	   real_fix_bin_2_dtype   init (2),
 11    27 	   real_flt_bin_1_dtype   init (3),
 11    28 	   real_flt_bin_2_dtype   init (4),
 11    29 	   cplx_fix_bin_1_dtype   init (5),
 11    30 	   cplx_fix_bin_2_dtype   init (6),
 11    31 	   cplx_flt_bin_1_dtype   init (7),
 11    32 	   cplx_flt_bin_2_dtype   init (8),
 11    33 	   real_fix_dec_9bit_ls_dtype init (9),
 11    34 	   real_flt_dec_9bit_dtype init (10),
 11    35 	   cplx_fix_dec_9bit_ls_dtype init (11),
 11    36 	   cplx_flt_dec_9bit_dtype init (12),
 11    37 	   pointer_dtype	      init (13),
 11    38 	   offset_dtype	      init (14),
 11    39 	   label_dtype	      init (15),
 11    40 	   entry_dtype	      init (16),
 11    41 	   structure_dtype	      init (17),
 11    42 	   area_dtype	      init (18),
 11    43 	   bit_dtype	      init (19),
 11    44 	   varying_bit_dtype      init (20),
 11    45 	   char_dtype	      init (21),
 11    46 	   varying_char_dtype     init (22),
 11    47 	   file_dtype	      init (23),
 11    48 	   real_fix_dec_9bit_ls_overp_dtype init (29),
 11    49 	   real_fix_dec_9bit_ts_overp_dtype init (30),
 11    50 	   real_fix_bin_1_uns_dtype init (33),
 11    51 	   real_fix_bin_2_uns_dtype init (34),
 11    52 	   real_fix_dec_9bit_uns_dtype init (35),
 11    53 	   real_fix_dec_9bit_ts_dtype init (36),
 11    54 	   real_fix_dec_4bit_uns_dtype init (38),	/* digit-aligned */
 11    55 	   real_fix_dec_4bit_ts_dtype init (39),	/* byte-aligned */
 11    56 	   real_fix_dec_4bit_bytealigned_uns_dtype init (40), /* COBOL */
 11    57 	   real_fix_dec_4bit_ls_dtype init (41),	/* digit-aligned */
 11    58 	   real_flt_dec_4bit_dtype init (42),		/* digit-aligned */
 11    59 	   real_fix_dec_4bit_bytealigned_ls_dtype init (43),
 11    60 	   real_flt_dec_4bit_bytealigned_dtype init (44),
 11    61 	   cplx_fix_dec_4bit_bytealigned_ls_dtype init (45),
 11    62 	   cplx_flt_dec_4bit_bytealigned_dtype init (46),
 11    63 	   real_flt_hex_1_dtype   init (47),
 11    64 	   real_flt_hex_2_dtype   init (48),
 11    65 	   cplx_flt_hex_1_dtype   init (49),
 11    66 	   cplx_flt_hex_2_dtype   init (50),
 11    67 	   c_typeref_dtype        init (54),
 11    68 	   c_enum_dtype           init (55),
 11    69              c_enum_const_dtype     init (56),
 11    70 	   c_union_dtype          init (57),
 11    71 	   algol68_straight_dtype init (59),
 11    72 	   algol68_format_dtype   init (60),
 11    73 	   algol68_array_descriptor_dtype init (61),
 11    74 	   algol68_union_dtype    init (62),
 11    75 
 11    76 	   cobol_comp_6_dtype     init (1),
 11    77 	   cobol_comp_7_dtype     init (1),
 11    78 	   cobol_display_ls_dtype init (9),
 11    79 	   cobol_structure_dtype  init (17),
 11    80 	   cobol_char_string_dtype init (21),
 11    81 	   cobol_display_ls_overp_dtype init (29),
 11    82 	   cobol_display_ts_overp_dtype init (30),
 11    83 	   cobol_display_uns_dtype init (35),
 11    84 	   cobol_display_ts_dtype init (36),
 11    85 	   cobol_comp_8_uns_dtype init (38),		/* digit aligned */
 11    86 	   cobol_comp_5_ts_dtype  init (39),		/* byte aligned */
 11    87 	   cobol_comp_5_uns_dtype init (40),
 11    88 	   cobol_comp_8_ls_dtype  init (41),		/* digit aligned */
 11    89 	   real_flt_dec_extended_dtype init (81),	/* 9-bit exponent */
 11    90 	   cplx_flt_dec_extended_dtype init (82),	/* 9-bit exponent */
 11    91 	   real_flt_dec_generic_dtype init (83),	/* generic float decimal */
 11    92 	   cplx_flt_dec_generic_dtype init (84),
 11    93 	   real_flt_bin_generic_dtype init (85),	/* generic float binary */
 11    94 	   cplx_flt_bin_generic_dtype init (86)) fixed bin internal static options (constant);
 11    95 
 11    96      dcl	   (ft_integer_dtype      init (1),
 11    97 	   ft_real_dtype	      init (3),
 11    98 	   ft_double_dtype	      init (4),
 11    99 	   ft_complex_dtype	      init (7),
 11   100 	   ft_complex_double_dtype init (8),
 11   101 	   ft_external_dtype      init (16),
 11   102 	   ft_logical_dtype	      init (19),
 11   103 	   ft_char_dtype	      init (21),
 11   104 	   ft_hex_real_dtype      init (47),
 11   105 	   ft_hex_double_dtype    init (48),
 11   106 	   ft_hex_complex_dtype   init (49),
 11   107 	   ft_hex_complex_double_dtype init (50)
 11   108 	   )		      fixed bin internal static options (constant);
 11   109 
 11   110      dcl	   (algol68_short_int_dtype init (1),
 11   111 	   algol68_int_dtype      init (1),
 11   112 	   algol68_long_int_dtype init (2),
 11   113 	   algol68_real_dtype     init (3),
 11   114 	   algol68_long_real_dtype init (4),
 11   115 	   algol68_compl_dtype    init (7),
 11   116 	   algol68_long_compl_dtype init (8),
 11   117 	   algol68_bits_dtype     init (19),
 11   118 	   algol68_bool_dtype     init (19),
 11   119 	   algol68_char_dtype     init (21),
 11   120 	   algol68_byte_dtype     init (21),
 11   121 	   algol68_struct_struct_char_dtype init (22),
 11   122 	   algol68_struct_struct_bool_dtype init (20)
 11   123 	   )		      fixed bin internal static options (constant);
 11   124 
 11   125      dcl	   (label_constant_runtime_dtype init (24),
 11   126 	   int_entry_runtime_dtype init (25),
 11   127 	   ext_entry_runtime_dtype init (26),
 11   128 	   ext_procedure_runtime_dtype init (27),
 11   129 	   picture_runtime_dtype  init (63)
 11   130 	   )		      fixed bin internal static options (constant);
 11   131 
 11   132      dcl	   (pascal_integer_dtype  init (1),
 11   133 	   pascal_real_dtype      init (4),
 11   134 	   pascal_label_dtype     init (24),
 11   135 	   pascal_internal_procedure_dtype init (25),
 11   136 	   pascal_exportable_procedure_dtype init (26),
 11   137 	   pascal_imported_procedure_dtype init (27),
 11   138 	   pascal_typed_pointer_type_dtype init (64),
 11   139 	   pascal_char_dtype      init (65),
 11   140 	   pascal_boolean_dtype   init (66),
 11   141 	   pascal_record_file_type_dtype init (67),
 11   142 	   pascal_record_type_dtype init (68),
 11   143 	   pascal_set_dtype	      init (69),
 11   144 	   pascal_enumerated_type_dtype init (70),
 11   145 	   pascal_enumerated_type_element_dtype init (71),
 11   146 	   pascal_enumerated_type_instance_dtype init (72),
 11   147 	   pascal_user_defined_type_dtype init (73),
 11   148 	   pascal_user_defined_type_instance_dtype init (74),
 11   149 	   pascal_text_file_dtype init (75),
 11   150 	   pascal_procedure_type_dtype init (76),
 11   151 	   pascal_variable_formal_parameter_dtype init (77),
 11   152 	   pascal_value_formal_parameter_dtype init (78),
 11   153 	   pascal_entry_formal_parameter_dtype init (79),
 11   154 	   pascal_parameter_procedure_dtype init (80),
 11   155 	   pascal_string_type_dtype init (87)) fixed bin int static options (constant);
 11   156 
 11   157 
 11   158 /* END INCLUDE FILE ... std_descriptor_types.incl.pl1 */
      425 
      426 
      427 
      428   end probe_get_line_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/05/00  1828.5  probe_get_line_.pl1               >udd>sm>ds>w>ml>probe_get_line_.pl1
405          1    10/27/88  1439.2  probe_info.incl.pl1               >ldd>incl>probe_info.incl.pl1
407          2    10/26/88  1355.5  probe_operators.incl.pl1          >ldd>incl>probe_operators.incl.pl1
409          3    11/26/79  1420.7  probe_ref_block.incl.pl1          >ldd>incl>probe_ref_block.incl.pl1
411          4    11/11/88  1701.5  probe_references.incl.pl1         >ldd>incl>probe_references.incl.pl1
413          5    11/02/83  1945.0  probe_seg_info.incl.pl1           >ldd>incl>probe_seg_info.incl.pl1
415          6    11/26/79  1420.6  probe_source_info.incl.pl1        >ldd>incl>probe_source_info.incl.pl1
417          7    11/26/79  1420.6  probe_tokens.incl.pl1             >ldd>incl>probe_tokens.incl.pl1
419          8    11/26/79  1420.6  runtime_symbol.incl.pl1           >ldd>incl>runtime_symbol.incl.pl1
421          9    11/12/86  1848.0  runtime_symbol_info_.incl.pl1     >ldd>incl>runtime_symbol_info_.incl.pl1
423         10    05/06/74  1851.6  statement_map.incl.pl1            >ldd>incl>statement_map.incl.pl1
425         11    10/26/88  1355.5  std_descriptor_types.incl.pl1     >ldd>incl>std_descriptor_types.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
COMMA                                  constant        bit(18)                  initial dcl 2-17 ref 334
CONSTANT_TYPE                          constant        bit(18)                  initial packed unaligned dcl 7-37 ref 100 117 341
DIGITS                          000000 constant        char(10)                 initial dcl 162 ref 171
MINUS                                  constant        bit(18)                  initial dcl 2-17 ref 112
NAME_TYPE                              constant        bit(18)                  initial packed unaligned dcl 7-37 ref 135
OPERATOR_TYPE                          constant        bit(18)                  initial packed unaligned dcl 7-37 ref 353
P_code                                 parameter       fixed bin(35,0)          dcl 52 set ref 25 95* 366* 390*
P_data_type                            parameter       fixed bin(17,0)          dcl 52 set ref 25 93* 194* 196 255*
P_invocation                           parameter       fixed bin(17,0)          dcl 52 set ref 25 321*
P_new_source_info_ptr                  parameter       pointer                  dcl 52 ref 25 91
P_probe_info_ptr                       parameter       pointer                  dcl 52 ref 25 90
P_switches                             parameter       bit(36)                  dcl 52 ref 25 92
RUNTIME_ADDRESS_INFO_VERSION_1  000004 constant        char(8)                  initial packed unaligned dcl 9-128 ref 202
RUNTIME_TYPE_INFO_VERSION_1     000006 constant        char(8)                  initial packed unaligned dcl 9-127 ref 187
addr                                                   builtin function         dcl 86 ref 189 189 204 204
addrel                                                 builtin function         dcl 86 ref 263
address_info                    000155 automatic       structure                level 1 unaligned dcl 166 set ref 204 204
address_ptr               4            based           pointer                  level 3 dcl 3-12 set ref 259 276 287
after                                                  builtin function         dcl 86 ref 168
based_label                            based           label variable           dcl 230 ref 276
binary                                                 builtin function         dcl 86 ref 301 301
block_ptr                 4            based           pointer                  level 2 in structure "new_source_info" dcl 63
                                                                                  in procedure "probe_get_line_" set ref 176*
block_ptr                 4            based           pointer                  level 2 in structure "current_source" dcl 6-13
                                                                                  in procedure "probe_get_line_" ref 176
break_info               50            based           structure                level 2 dcl 1-18
break_slot_ptr           50            based           pointer                  level 3 dcl 1-18 ref 142
code                            000107 automatic       fixed bin(35,0)          dcl 68 set ref 96* 109* 110 119* 120 147* 176* 181*
                                                                                  182* 189* 191 204* 206 248* 250 282* 284 343* 344
                                                                                  362* 366 386* 390
constant                               based           structure                level 1 dcl 7-27
ct                       13            based           pointer                  level 3 packed packed unaligned dcl 1-18 set ref 98
                                                                                  100 112 112 117 135 136 136 137 137 142 142 168
                                                                                  168 334 341 353 393* 402* 402
current_identifier_name                based           char                     packed unaligned dcl 7-42 ref 136 137 142 168
current_source                         based           structure                level 1 dcl 6-13 ref 126 137 175
entry_dtype                            constant        fixed bin(17,0)          initial dcl 11-25 ref 273
execute                  64            based           bit(1)                   level 3 packed packed unaligned dcl 1-18 ref 125 137
                                                                                  142 174 253 362
ext_entry_runtime_dtype                constant        fixed bin(17,0)          initial dcl 11-125 ref 287
ext_procedure_runtime_dtype            constant        fixed bin(17,0)          initial dcl 11-125 ref 287
file                            000116 automatic       fixed bin(17,0)          dcl 103 set ref 115* 123* 127
first_instr_ptr                 000104 automatic       pointer                  dcl 66 set ref 307* 312
flags                     5            based           structure                level 3 in structure "token" dcl 7-16 in procedure
                                                                                  "probe_get_line_"
flags                    64            based           structure                level 2 in structure "probe_info" dcl 1-18
                                                                                  in procedure "probe_get_line_"
header                                 based           structure                level 2 dcl 7-16
identifier                             based           structure                level 1 dcl 7-19
initial_source                         based           structure                level 1 dcl 6-14 ref 150
int_entry_runtime_dtype                constant        fixed bin(17,0)          initial dcl 11-125 ref 287
invocation_level        125            based           fixed bin(17,0)          level 3 dcl 3-12 set ref 321 321
label_constant_runtime_dtype           constant        fixed bin(17,0)          initial dcl 11-125 ref 93 196 257
label_dtype                            constant        fixed bin(17,0)          initial dcl 11-25 ref 273
label_name                      000122 automatic       varying char(64)         dcl 161 set ref 168* 169 171 176 182* 197* 216*
label_var                       000164 automatic       structure                level 1 dcl 231 set ref 276*
label_vector_tv                        based           bit(18)                  dcl 234 ref 263
leading_whitespace        5            based           bit(1)                   level 4 packed packed unaligned dcl 7-16 ref 112
length                    6            based           fixed bin(17,0)          level 2 dcl 7-19 ref 136 137 142 168
line                            000117 automatic       fixed bin(17,0)          dcl 104 set ref 109* 115 119* 127
location                  2     000155 automatic       fixed bin(18,0)          level 2 packed packed unsigned unaligned dcl 166 set
                                                                                  ref 209
name                     12            based           varying char(256)        level 3 in structure "ref_block" dcl 3-12
                                                                                  in procedure "probe_get_line_" set ref 293* 315*
                                                                                  381*
name                      7            based           pointer                  level 2 in structure "identifier" packed packed
                                                                                  unaligned dcl 7-19 in procedure "probe_get_line_"
                                                                                  ref 136 137 142 168
new_source_info                        based           structure                level 1 dcl 63 set ref 126* 137* 150* 175*
new_source_info_ptr             000102 automatic       pointer                  dcl 65 set ref 91* 126 127 127 131 137 150 175 176
                                                                                  209 215 246 268 282 301 301 306 307 312 362*
next                                   based           pointer                  level 3 packed packed unaligned dcl 7-16 ref 402
null                                                   builtin function         dcl 86 ref 127 142 180 209 301 307 312
place                           000164 automatic       pointer                  level 2 dcl 231 set ref 278
pointers                 76            based           structure                level 2 dcl 5-9
probe_create_reference_         000046 constant        entry                    external dcl 237 ref 245
probe_cv_stu_code_              000044 constant        entry                    external dcl 158 ref 181
probe_error_$record             000016 constant        entry                    external dcl 77 ref 182 197 216 293 315 345 373 377
                                                                                  381
probe_et_$bad_line              000022 external static fixed bin(35,0)          dcl 79 set ref 377*
probe_et_$bad_line_syntax       000024 external static fixed bin(35,0)          dcl 79 set ref 373*
probe_et_$none_active           000020 external static fixed bin(35,0)          dcl 79 ref 147
probe_et_$recorded_message      000026 external static fixed bin(35,0)          dcl 79 ref 386
probe_find_location_            000040 constant        entry                    external dcl 105 ref 127
probe_get_$integer              000014 constant        entry                    external dcl 75 ref 109 119 343
probe_get_$value                000050 constant        entry                    external dcl 238 ref 248
probe_info                             based           structure                level 1 dcl 1-18
probe_info_ptr                  000112 automatic       pointer                  dcl 1-86 set ref 90* 98 100 109* 112 112 117 119*
                                                                                  125 126 127* 135 136 136 137 137 137 137 142 142
                                                                                  142 142 150 168 168 174 175 176 182* 197* 209 216*
                                                                                  245* 248* 253 282* 293* 315* 334 341 343* 345* 353
                                                                                  362 362* 373* 377* 381* 393 402 402
probe_seg_info_                 000052 constant        entry                    external dcl 241 ref 282
probe_source_segment_$position_source
                                000030 constant        entry                    external dcl 359 ref 362
ptr_to_current_source
                          4            based           pointer                  level 2 dcl 1-18 ref 126 137 175 176 209
ptr_to_initial_source
                          6            based           pointer                  level 2 dcl 1-18 ref 150
ref_block                              based           structure                level 1 dcl 3-12
ref_block_ptr                   000114 automatic       pointer                  dcl 3-10 set ref 245* 246 248 255 257 259 263 273
                                                                                  273 276 287 287 287 287 293 315 321 321 381
ref_node                               based           structure                level 2 dcl 3-12 set ref 248*
reference_arg_list                     based           structure                level 1 dcl 4-59
reference_node                         based           structure                level 1 dcl 4-16
reference_subscripts                   based           structure                level 1 dcl 4-64
rel                                                    builtin function         dcl 86 ref 301 301
runtime_address_info                   based           structure                level 1 dcl 9-56
runtime_symbol_info_$address    000034 constant        entry                    external dcl 9-54 ref 204
runtime_symbol_info_$array_dims 000036 constant        entry                    external dcl 9-66 ref 263
runtime_symbol_info_$type       000032 constant        entry                    external dcl 9-22 ref 189
runtime_type_info                      based           structure                level 1 dcl 9-24
saved_ct                        000110 automatic       pointer                  dcl 69 set ref 98* 393
seg_info                               based           structure                level 1 dcl 5-9
seg_info_ptr             12            based           pointer                  level 2 in structure "current_source" dcl 6-13
                                                                                  in procedure "probe_get_line_" ref 209
seg_info_ptr             12            based           pointer                  level 2 in structure "new_source_info" dcl 63
                                                                                  in procedure "probe_get_line_" set ref 127 282*
                                                                                  301 307
source_info                            based           structure                level 1 dcl 6-5
source_info_ptr          10            based           pointer                  level 3 dcl 3-12 set ref 246*
stmnt_map_entry_index                  based           fixed bin(17,0)          level 2 dcl 63 set ref 127* 131 209* 215 268 301*
                                                                                  306 312*
stmt                            000106 automatic       fixed bin(17,0)          dcl 67 set ref 333* 343* 350* 350 362*
stu_$find_runtime_symbol        000042 constant        entry                    external dcl 155 ref 176
stu_$get_map_index              000010 constant        entry                    external dcl 71 ref 209 301
stu_$get_statement_map          000012 constant        entry                    external dcl 73 ref 307
subscript_reference_ptrs               based           structure                level 1 dcl 4-69
substr                                                 builtin function         dcl 86 ref 136
switches                        000100 automatic       bit(36)                  packed unaligned dcl 61 set ref 92* 127 248
symbol_header_ptr        76            based           pointer                  level 3 packed packed unaligned dcl 5-9 ref 209 301
                                                                                  307
symbol_ptr                             based           pointer                  level 3 dcl 3-12 set ref 263*
symbp                           000120 automatic       pointer                  dcl 159 set ref 176* 180 189* 204*
token                                  based           structure                level 1 dcl 7-16
token_header                           based           structure                level 1 dcl 7-4
token_info               12            based           structure                level 2 dcl 1-18
type                    113            based           fixed bin(35,0)          level 3 in structure "ref_block" dcl 3-12
                                                                                  in procedure "probe_get_line_" set ref 255 257 273
                                                                                  273 287 287 287
type                      2            based           bit(18)                  level 3 in structure "token" dcl 7-16 in procedure
                                                                                  "probe_get_line_" ref 100 112 117 135 334 341 353
type                      3     000144 automatic       fixed bin(18,0)          level 2 in structure "type_info" packed packed
                                                                                  unsigned unaligned dcl 165
                                                                                  in begin block on line 153 set ref 194
type_info                       000144 automatic       structure                level 1 unaligned dcl 165 set ref 189 189
unspec                                                 builtin function         dcl 86 set ref 276* 276
verify                                                 builtin function         dcl 86 ref 171
version                         000144 automatic       char(8)                  level 2 in structure "type_info" packed packed
                                                                                  unaligned dcl 165 in begin block on line 153 set
                                                                                  ref 187*
version                         000155 automatic       char(8)                  level 2 in structure "address_info" packed packed
                                                                                  unaligned dcl 166 in begin block on line 153 set
                                                                                  ref 202*
where                           000162 automatic       pointer                  dcl 228 set ref 259* 263* 263 263 278* 282* 287* 301
                                                                                  301

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
AMPERSAND                              internal static bit(18)                  initial dcl 2-17
ARROW                                  internal static bit(18)                  initial dcl 2-17
COLON                                  internal static bit(18)                  initial dcl 2-17
C_EQUAL                                internal static bit(18)                  initial dcl 2-17
C_INDIRECTION                          internal static bit(18)                  initial dcl 2-17
C_LEFT_SHIFT                           internal static bit(18)                  initial dcl 2-17
C_NOT_EQUAL                            internal static bit(18)                  initial dcl 2-17
C_RIGHT_SHIFT                          internal static bit(18)                  initial dcl 2-17
DOLLAR_SIGN                            internal static bit(18)                  initial dcl 2-17
EQUALS                                 internal static bit(18)                  initial dcl 2-17
GREATER_THAN                           internal static bit(18)                  initial dcl 2-17
LEFT_BRACKET                           internal static bit(18)                  initial dcl 2-17
LEFT_PAREN                             internal static bit(18)                  initial dcl 2-17
LESS_THAN                              internal static bit(18)                  initial dcl 2-17
NEW_LINE                               internal static bit(18)                  initial dcl 2-17
NOT_EQUALS                             internal static bit(18)                  initial dcl 2-17
NOT_GREATER_THAN                       internal static bit(18)                  initial dcl 2-17
NOT_LESS_THAN                          internal static bit(18)                  initial dcl 2-17
NOT_SIGN                               internal static bit(18)                  initial dcl 2-17
OPERATOR_VALUES                        internal static varying char(4)          initial array dcl 2-43
OR_BAR                                 internal static bit(18)                  initial dcl 2-17
PASCAL_ARROW                           internal static bit(18)                  initial dcl 2-17
PASCAL_ASSIGN                          internal static bit(18)                  initial dcl 2-17
PASCAL_RANGE                           internal static bit(18)                  initial dcl 2-17
PERCENT                                internal static bit(18)                  initial dcl 2-17
PERIOD                                 internal static bit(18)                  initial dcl 2-17
PLUS                                   internal static bit(18)                  initial dcl 2-17
QUESTION_MARK                          internal static bit(18)                  initial dcl 2-17
RIGHT_BRACKET                          internal static bit(18)                  initial dcl 2-17
RIGHT_PAREN                            internal static bit(18)                  initial dcl 2-17
RUNTIME_ARRAY_INFO_VERSION_1           internal static char(8)                  initial packed unaligned dcl 9-129
RUNTIME_SUBRANGE_INFO_VERSION_1        internal static char(8)                  initial packed unaligned dcl 9-131
RUNTIME_VARIANT_INFO_VERSION_1         internal static char(8)                  initial packed unaligned dcl 9-130
SEMI_COLON                             internal static bit(18)                  initial dcl 2-17
SLASH                                  internal static bit(18)                  initial dcl 2-17
TIMES                                  internal static bit(18)                  initial dcl 2-17
algol68_array_descriptor_dtype         internal static fixed bin(17,0)          initial dcl 11-25
algol68_bits_dtype                     internal static fixed bin(17,0)          initial dcl 11-110
algol68_bool_dtype                     internal static fixed bin(17,0)          initial dcl 11-110
algol68_byte_dtype                     internal static fixed bin(17,0)          initial dcl 11-110
algol68_char_dtype                     internal static fixed bin(17,0)          initial dcl 11-110
algol68_compl_dtype                    internal static fixed bin(17,0)          initial dcl 11-110
algol68_format_dtype                   internal static fixed bin(17,0)          initial dcl 11-25
algol68_int_dtype                      internal static fixed bin(17,0)          initial dcl 11-110
algol68_long_compl_dtype               internal static fixed bin(17,0)          initial dcl 11-110
algol68_long_int_dtype                 internal static fixed bin(17,0)          initial dcl 11-110
algol68_long_real_dtype                internal static fixed bin(17,0)          initial dcl 11-110
algol68_real_dtype                     internal static fixed bin(17,0)          initial dcl 11-110
algol68_short_int_dtype                internal static fixed bin(17,0)          initial dcl 11-110
algol68_straight_dtype                 internal static fixed bin(17,0)          initial dcl 11-25
algol68_struct_struct_bool_dtype       internal static fixed bin(17,0)          initial dcl 11-110
algol68_struct_struct_char_dtype       internal static fixed bin(17,0)          initial dcl 11-110
algol68_union_dtype                    internal static fixed bin(17,0)          initial dcl 11-25
area_dtype                             internal static fixed bin(17,0)          initial dcl 11-25
bit_dtype                              internal static fixed bin(17,0)          initial dcl 11-25
c_enum_const_dtype                     internal static fixed bin(17,0)          initial dcl 11-25
c_enum_dtype                           internal static fixed bin(17,0)          initial dcl 11-25
c_typeref_dtype                        internal static fixed bin(17,0)          initial dcl 11-25
c_union_dtype                          internal static fixed bin(17,0)          initial dcl 11-25
char_dtype                             internal static fixed bin(17,0)          initial dcl 11-25
cobol_char_string_dtype                internal static fixed bin(17,0)          initial dcl 11-25
cobol_comp_5_ts_dtype                  internal static fixed bin(17,0)          initial dcl 11-25
cobol_comp_5_uns_dtype                 internal static fixed bin(17,0)          initial dcl 11-25
cobol_comp_6_dtype                     internal static fixed bin(17,0)          initial dcl 11-25
cobol_comp_7_dtype                     internal static fixed bin(17,0)          initial dcl 11-25
cobol_comp_8_ls_dtype                  internal static fixed bin(17,0)          initial dcl 11-25
cobol_comp_8_uns_dtype                 internal static fixed bin(17,0)          initial dcl 11-25
cobol_display_ls_dtype                 internal static fixed bin(17,0)          initial dcl 11-25
cobol_display_ls_overp_dtype           internal static fixed bin(17,0)          initial dcl 11-25
cobol_display_ts_dtype                 internal static fixed bin(17,0)          initial dcl 11-25
cobol_display_ts_overp_dtype           internal static fixed bin(17,0)          initial dcl 11-25
cobol_display_uns_dtype                internal static fixed bin(17,0)          initial dcl 11-25
cobol_structure_dtype                  internal static fixed bin(17,0)          initial dcl 11-25
cplx_fix_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 11-25
cplx_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 11-25
cplx_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 11-25
cplx_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 11-25
cplx_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 11-25
cplx_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 11-25
cplx_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 11-25
cplx_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 11-25
cplx_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 11-25
cplx_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 11-25
cplx_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 11-25
cplx_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 11-25
cplx_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 11-25
current_constant                       based           structure                level 1 dcl 7-44
current_token                          based           structure                level 1 dcl 7-45
encoded_value                          based           structure                level 1 dcl 8-70
expression_area                        based           area(1024)               dcl 1-95
file_dtype                             internal static fixed bin(17,0)          initial dcl 11-25
ft_char_dtype                          internal static fixed bin(17,0)          initial dcl 11-96
ft_complex_double_dtype                internal static fixed bin(17,0)          initial dcl 11-96
ft_complex_dtype                       internal static fixed bin(17,0)          initial dcl 11-96
ft_double_dtype                        internal static fixed bin(17,0)          initial dcl 11-96
ft_external_dtype                      internal static fixed bin(17,0)          initial dcl 11-96
ft_hex_complex_double_dtype            internal static fixed bin(17,0)          initial dcl 11-96
ft_hex_complex_dtype                   internal static fixed bin(17,0)          initial dcl 11-96
ft_hex_double_dtype                    internal static fixed bin(17,0)          initial dcl 11-96
ft_hex_real_dtype                      internal static fixed bin(17,0)          initial dcl 11-96
ft_integer_dtype                       internal static fixed bin(17,0)          initial dcl 11-96
ft_logical_dtype                       internal static fixed bin(17,0)          initial dcl 11-96
ft_real_dtype                          internal static fixed bin(17,0)          initial dcl 11-96
n_dims                                 automatic       fixed bin(17,0)          dcl 9-97
n_variants                             automatic       fixed bin(35,0)          dcl 9-112
offset_dtype                           internal static fixed bin(17,0)          initial dcl 11-25
operator                               based           structure                level 1 dcl 7-24
pascal_boolean_dtype                   internal static fixed bin(17,0)          initial dcl 11-132
pascal_char_dtype                      internal static fixed bin(17,0)          initial dcl 11-132
pascal_entry_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 11-132
pascal_enumerated_type_dtype           internal static fixed bin(17,0)          initial dcl 11-132
pascal_enumerated_type_element_dtype   internal static fixed bin(17,0)          initial dcl 11-132
pascal_enumerated_type_instance_dtype  internal static fixed bin(17,0)          initial dcl 11-132
pascal_exportable_procedure_dtype      internal static fixed bin(17,0)          initial dcl 11-132
pascal_imported_procedure_dtype        internal static fixed bin(17,0)          initial dcl 11-132
pascal_integer_dtype                   internal static fixed bin(17,0)          initial dcl 11-132
pascal_internal_procedure_dtype        internal static fixed bin(17,0)          initial dcl 11-132
pascal_label_dtype                     internal static fixed bin(17,0)          initial dcl 11-132
pascal_parameter_procedure_dtype       internal static fixed bin(17,0)          initial dcl 11-132
pascal_procedure_type_dtype            internal static fixed bin(17,0)          initial dcl 11-132
pascal_real_dtype                      internal static fixed bin(17,0)          initial dcl 11-132
pascal_record_file_type_dtype          internal static fixed bin(17,0)          initial dcl 11-132
pascal_record_type_dtype               internal static fixed bin(17,0)          initial dcl 11-132
pascal_set_dtype                       internal static fixed bin(17,0)          initial dcl 11-132
pascal_string_type_dtype               internal static fixed bin(17,0)          initial dcl 11-132
pascal_text_file_dtype                 internal static fixed bin(17,0)          initial dcl 11-132
pascal_typed_pointer_type_dtype        internal static fixed bin(17,0)          initial dcl 11-132
pascal_user_defined_type_dtype         internal static fixed bin(17,0)          initial dcl 11-132
pascal_user_defined_type_instance_dtype
                                       internal static fixed bin(17,0)          initial dcl 11-132
pascal_value_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 11-132
pascal_variable_formal_parameter_dtype internal static fixed bin(17,0)          initial dcl 11-132
picture_runtime_dtype                  internal static fixed bin(17,0)          initial dcl 11-125
pointer_dtype                          internal static fixed bin(17,0)          initial dcl 11-25
probe_area                             based           area(1024)               dcl 1-93
probe_info_version                     internal static fixed bin(17,0)          initial dcl 1-88
probe_info_version_1                   internal static fixed bin(17,0)          initial dcl 1-90
real_fix_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 11-25
real_fix_bin_1_uns_dtype               internal static fixed bin(17,0)          initial dcl 11-25
real_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 11-25
real_fix_bin_2_uns_dtype               internal static fixed bin(17,0)          initial dcl 11-25
real_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 11-25
real_fix_dec_4bit_bytealigned_uns_dtype
                                       internal static fixed bin(17,0)          initial dcl 11-25
real_fix_dec_4bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 11-25
real_fix_dec_4bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 11-25
real_fix_dec_4bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 11-25
real_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 11-25
real_fix_dec_9bit_ls_overp_dtype       internal static fixed bin(17,0)          initial dcl 11-25
real_fix_dec_9bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 11-25
real_fix_dec_9bit_ts_overp_dtype       internal static fixed bin(17,0)          initial dcl 11-25
real_fix_dec_9bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 11-25
real_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 11-25
real_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 11-25
real_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 11-25
real_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 11-25
real_flt_dec_4bit_dtype                internal static fixed bin(17,0)          initial dcl 11-25
real_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 11-25
real_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 11-25
real_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 11-25
real_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 11-25
real_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 11-25
runtime_array_info                     based           structure                level 1 dcl 9-70
runtime_block                          based           structure                level 1 dcl 8-38
runtime_bound                          based           structure                level 1 unaligned dcl 8-33
runtime_subrange_info                  based           structure                level 1 unaligned dcl 9-116
runtime_symbol                         based           structure                level 1 dcl 8-3
runtime_symbol_info_$array      000000 constant        entry                    external dcl 9-68
runtime_symbol_info_$brother    000000 constant        entry                    external dcl 9-40
runtime_symbol_info_$father     000000 constant        entry                    external dcl 9-38
runtime_symbol_info_$father_type
                                000000 constant        entry                    external dcl 9-42
runtime_symbol_info_$level      000000 constant        entry                    external dcl 9-50
runtime_symbol_info_$n_variants 000000 constant        entry                    external dcl 9-99
runtime_symbol_info_$name       000000 constant        entry                    external dcl 9-48
runtime_symbol_info_$next       000000 constant        entry                    external dcl 9-52
runtime_symbol_info_$son        000000 constant        entry                    external dcl 9-44
runtime_symbol_info_$subrange   000000 constant        entry                    external dcl 9-114
runtime_symbol_info_$successor  000000 constant        entry                    external dcl 9-46
runtime_symbol_info_$variant    000000 constant        entry                    external dcl 9-101
runtime_token                          based           structure                level 1 dcl 8-63
runtime_variant_info                   based           structure                level 1 dcl 9-103
scratch_area                           based           area(1024)               dcl 1-92
seg_info_nfiles                        automatic       fixed bin(17,0)          dcl 5-47
statement_map                          based           structure                level 1 dcl 10-1
structure_dtype                        internal static fixed bin(17,0)          initial dcl 11-25
varying_bit_dtype                      internal static fixed bin(17,0)          initial dcl 11-25
varying_char_dtype                     internal static fixed bin(17,0)          initial dcl 11-25
work_area                              based           area(1024)               dcl 1-94

NAMES DECLARED BY EXPLICIT CONTEXT.
BAD_LINE                        001375 constant        label                    dcl 373 set ref 110 117 120 135 169 171 341 353
BAD_LINE_NUMBER                 001413 constant        label                    dcl 377 ref 131
BAD_LOCATION                    001431 constant        label                    dcl 381 ref 250
GET_INVOCATION                  001255 constant        label                    dcl 321 ref 268
MAIN_RETURN                     001371 constant        label                    dcl 366
RECORDED_MESSAGE                001467 constant        label                    dcl 386 ref 184 199 218 296 318 348 375 379 384
SOME_ERROR                      001473 constant        label                    dcl 390 ref 148 191 206 284 388
bump_ct                         001501 constant        entry                    internal dcl 400 ref 116 223 337
probe_get_line_                 000131 constant        entry                    external dcl 25

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2162        2236    1714        2172
Length      2660    1714        54         406     246           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
probe_get_line_                     294 external procedure  is an external procedure.  
begin block on line 100                 begin block         shares stack frame of external procedure probe_get_line_.  
begin block on line 153                 begin block         shares stack frame of external procedure probe_get_line_.  
begin block on line 225                 begin block         shares stack frame of external procedure probe_get_line_.  
bump_ct                                 internal procedure  shares stack frame of external procedure probe_get_line_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
probe_get_line_          000100 switches                    probe_get_line_
                         000102 new_source_info_ptr         probe_get_line_
                         000104 first_instr_ptr             probe_get_line_
                         000106 stmt                        probe_get_line_
                         000107 code                        probe_get_line_
                         000110 saved_ct                    probe_get_line_
                         000112 probe_info_ptr              probe_get_line_
                         000114 ref_block_ptr               probe_get_line_
                         000116 file                        begin block on line 100
                         000117 line                        begin block on line 100
                         000120 symbp                       begin block on line 153
                         000122 label_name                  begin block on line 153
                         000144 type_info                   begin block on line 153
                         000155 address_info                begin block on line 153
                         000162 where                       begin block on line 225
                         000164 label_var                   begin block on line 225

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        return_mac          shorten_stack       ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
probe_create_reference_       probe_cv_stu_code_            probe_error_$record           probe_find_location_
probe_get_$integer            probe_get_$value              probe_seg_info_
probe_source_segment_$position_source                       runtime_symbol_info_$address
runtime_symbol_info_$array_dims                             runtime_symbol_info_$type     stu_$find_runtime_symbol
stu_$get_map_index            stu_$get_statement_map

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
probe_et_$bad_line            probe_et_$bad_line_syntax     probe_et_$none_active         probe_et_$recorded_message




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     25 000123        90 000136        91 000142        92 000145        93 000147        95 000151        96 000152
     98 000153       100 000155       109 000162       110 000175       112 000177       115 000210       116 000212
    117 000213       119 000220       120 000233       122 000235       123 000236       125 000237       126 000243
    127 000250       131 000312       100 000315       135 000316       136 000320       137 000326       141 000344
    142 000345       147 000360       148 000362       150 000363       152 000370       168 000371       169 000417
    171 000424       174 000437       175 000443       176 000450       180 000512       181 000517       182 000526
    184 000547       187 000550       189 000552       191 000567       194 000571       196 000575       197 000577
    199 000630       202 000631       204 000634       206 000651       209 000653       215 000702       216 000705
    218 000736       223 000737       224 000740       245 000741       246 000752       248 000755       250 000774
    253 000776       255 001002       257 001006       259 001010       263 001012       266 001031       268 001032
    273 001034       276 001041       278 001050       282 001052       284 001070       286 001072       287 001073
    293 001104       296 001135       301 001136       306 001164       307 001167       312 001213       315 001222
    318 001254       321 001255       333 001262       334 001263       337 001270       341 001271       343 001276
    344 001311       345 001313       348 001340       350 001341       353 001343       362 001350       366 001371
    368 001374       373 001375       375 001412       377 001413       379 001430       381 001431       384 001466
    386 001467       388 001472       390 001473       393 001475       394 001500       400 001501       402 001502
    403 001507


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
