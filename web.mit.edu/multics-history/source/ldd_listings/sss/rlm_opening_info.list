	COMPILATION LISTING OF SEGMENT rlm_opening_info
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/04/85  0928.7 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 
        8 /* DESCRIPTION:
        9*
       10*     $get:
       11*         Gets a pointer to the relation_opening_info structure associated with
       12*     the current opening of the specified relation.  If the relation is not 
       13*     open, dm_error_$relation_not_open is returned. If this is the first "get"
       14*     for a transaction, "refresh" also. 
       15*
       16*     $get_dont_refresh:
       17*          Same as above, but never "refresh."
       18*
       19*     $refresh:
       20*          Re-read the opening information out of the file. If the 
       21*     header_info_update_count is unchanged, the attribute_info and
       22*     index_attribute_map have not been changed, so need not be read again.
       23*
       24*     $init:
       25*          Allocate a relation_opening_info structure in the dm free area
       26*     and record a pointer to it in the opening table.
       27*     
       28*     $free:
       29*          Free the relation_opening_info structure and remove the entry
       30*     in the opening table.
       31*     
       32*         The  opening_manager_  is  used  to  keep  a  table of openings.  The
       33*     pointer   to   that   table   is    kept    in    a    static    variable
       34*     (static_opening_table_ptr).
       35*          NOTE: p_file_opening_id is the same as the file_opening_id for the page
       36*     file in which the relation resides.
       37**/
       38 
       39 /* HISTORY:
       40*
       41*Written by Matthew Pierret, 07/27/82.
       42*Modified:
       43*10/12/82 by Matthew Pierret:  Changed $set to interpret a non-null p_opening_info_ptr
       44*            to be a pointer to an old relation_info_ptr that must be freed.
       45*            Fixed subscript range bug encountered when index_attribute_map.index
       46*            and relation_info.index are of different extent.
       47*02/25/83 by Matthew Pierret: Changed to use relatin_opening_info instead of
       48*            relation_info. Removed $set; added $free. This module now deals
       49*            only with the relation_opening_info structure and interactions
       50*            with opening_manager_.
       51*03/10/83 by Matthew Pierret: Fixed $free to use roi.pp.file_opening_id
       52*            instead of p_file_opening_id.
       53*            Fixed attempts to do "currentsize (XXX)" when XXX_ptr was null.
       54*            Changed to correctly set roi.pp.index_cursor_array_ptr after
       55*            allocating an index_cursor_array for the first time.
       56*            Changed to refresh whenever any roi pointers are null.
       57*03/14/83 by Matthew Pierret: Changed CURRENT_TRANSACTION_ID to use a local
       58*            variable (cti_code) instead of p_code, so that the non-error
       59*            dm_error_$no_current_transaction is not reported.
       60*03/16/83 by Matthew Pierret: Added $get_dont_refresh. This entry is used by
       61*            rlm_$close and rlm_$set_scope to get only the 
       62*            relation_opening_info structure. No refreshing is done because
       63*            these operations are defined to work outside of transactions.
       64*03/21/83 by Matthew Pierret: Changed to always create a record cursor if
       65*            none exists (in $get, $refresh).
       66*03/24/83 by Matthew Pierret: Moved creation of record cursor ($get, $refresh)
       67*            after retrieval of relation_header, because the relation_header
       68*            is needed to create the cursor. Removed maintenance of 
       69*            old_relation_header_ptr: there should never be an "old" 
       70*            relation_header. Changed FINISH to free old_XXX_ptr->XXX
       71*            instead of XXX.
       72*03/24/83 by Jeffrey D. Ives for Matthew Pierret: changed the logic following
       73*            the call to opening_manager_$get_opening after "GET:" to return
       74*            an error code when the relation is not open instead of falling
       75*            through with a null relation_opening_info_ptr.
       76*04/11/83 by Lindsey L. Spratt:  Changed to return immediately after
       77*            determining that the static_opening_table_ptr is null (and,
       78*            therefore, the desired opening can't exist).
       79*04/19/84 by Lindsey L. Spratt:  Fixed $free to also close the DM file.  Fixed
       80*            $init to signal a sub_err_ when the relation_opening_info to be
       81*            initialized already exists.
       82*           Changed to use transaction_manager_$get_current_ids to get both
       83*            the transaction_id and the rollback_count.
       84*05/29/84 by Matthew Pierret:  Changed to use RELATION_HEADER_VERSION_3.
       85*06/07/84 by Matthew Pierret:  Re-named cm_$get_element to cm_$get.
       86*
       87*10/25/84 by Stanford S.  Cox:  REFRESH - Changed call to rm_$create_cursor to use 
       88*	  local variable instead of record_cursor_ptr, added asgn. of
       89*	  index_cursor_array.version.  $init - Added cleanup handler, asgmt.
       90*	  of p_relation_opening_info_ptr to null, asgn. of
       91*	  relation_opening_info.version.  $free - Moved call to fm_$close to
       92*	  rlm_open 
       93*03/17/85 by Lindsey L. Spratt:  Fixed setting of
       94*            roi.per_process.record_cursor_ptr to use local_record_cursor_ptr.
       95*            Was mistakenly using "record_cursor_ptr", which turned into a
       96*            reference to relation_opening_info.per_process.record_cursor_ptr,
       97*            which was null, so the record_cursor_ptr would always be null.
       98**/
       99 
      100 /* format: style2,ind3 */
      101 
      102 rlm_opening_info:
      103    proc ();
      104 
      105       call sub_err_ (dm_error_$programming_error, myname, ACTION_CANT_RESTART, null, 0,
      106 	 "^/^a$^a is not a valid entrypoint", myname, myname);
      107 
      108 
      109 /* START OF DECLARATIONS */
      110 /* Parameter */
      111 
      112       dcl	    p_file_opening_id      bit (36) aligned parameter;
      113       dcl	    p_relation_opening_info_ptr
      114 			       ptr parameter;
      115       dcl	    p_code	       fixed bin (35) parameter;
      116 
      117 /* Automatic */
      118 
      119       dcl	    (attribute_info_buffer_length, index_attribute_map_buffer_length)
      120 			       fixed bin (35) init (0);
      121       dcl	    header_info_update_count
      122 			       fixed bin (17) init (-1);
      123       dcl	    index_idx	       fixed bin (17);
      124       dcl	    current_rollback_count fixed bin (35);
      125       dcl	    (get, dont_refresh, init, refresh)
      126 			       bit (1) aligned init ("0"b);
      127       dcl	    current_transaction_id bit (36) aligned;
      128       dcl	    om_file_opening_id     bit (72) aligned;
      129       dcl	    (local_record_cursor_ptr, old_attribute_info_ptr, old_index_attribute_map_ptr, old_index_cursor_array_ptr)
      130 			       ptr init (null);
      131 
      132 /* Based */
      133 
      134       dcl	    dm_area	       area (sys_info$max_seg_size) based (static_dm_area_ptr);
      135 
      136 /* Builtin */
      137 
      138       dcl	    (currentsize, hbound, length, null, unspec)
      139 			       builtin;
      140 
      141 /* Condition */
      142 
      143       dcl	    cleanup	       condition;
      144 
      145 /* Constant */
      146 
      147       dcl	    myname	       init ("rlm_opening_info") char (32) varying internal static options (constant);
      148       dcl	    BITS_PER_WORD	       init (36) fixed bin internal static options (constant);
      149       dcl	    NUMBER_OF_BUCKETS      init (20) fixed bin internal static options (constant);
      150       dcl	    CANONICAL_SECOND_WORD_OF_RELATION_OPENING_ID
      151 			       init ("0"b) bit (36) aligned internal static options (constant);
      152 
      153 /* Entry */
      154 
      155       dcl	    get_dm_free_area_      entry () returns (ptr);
      156       dcl	    opening_manager_$get_opening
      157 			       entry (ptr, bit (72) aligned, ptr, fixed bin (35));
      158       dcl	    opening_manager_$put_opening
      159 			       entry (ptr, bit (72) aligned, ptr, fixed bin (35));
      160       dcl	    opening_manager_$init  entry (fixed bin, ptr, fixed bin (35));
      161       dcl	    opening_manager_$free_opening
      162 			       entry (ptr, bit (72) aligned, fixed bin (35));
      163       dcl	    record_manager_$create_cursor
      164 			       entry (bit (36) aligned, bit (36) aligned, ptr, ptr, fixed bin (35));
      165       dcl	    sub_err_	       entry () options (variable);
      166       dcl	    transaction_manager_$get_current_ids
      167 			       entry (bit (36) aligned, fixed bin, fixed bin, fixed bin (35));
      168 
      169 /* External */
      170 
      171       dcl	    dm_error_$no_opening   ext fixed bin (35);
      172       dcl	    dm_error_$programming_error
      173 			       ext fixed bin (35);
      174       dcl	    dm_error_$relation_not_open
      175 			       ext fixed bin (35);
      176       dcl	    error_table_$fatal_error
      177 			       fixed bin (35) ext;
      178       dcl	    sys_info$max_seg_size  ext fixed bin (35);
      179 
      180 /* Static */
      181 
      182       dcl	    (static_opening_table_ptr, static_dm_area_ptr)
      183 			       ptr init (null) internal static;
      184 
      185 /* END OF DECLARATIONS */
      186 
      187 /* format: ^indblkcom,indcomtxt */
      188 
      189 get:
      190    entry (p_file_opening_id, p_relation_opening_info_ptr, p_code);
      191 
      192       get = "1"b;
      193       p_relation_opening_info_ptr = null;
      194       goto GET_REFRESH_JOIN;
      195 
      196 get_dont_refresh:
      197    entry (p_file_opening_id, p_relation_opening_info_ptr, p_code);
      198 
      199       get, dont_refresh = "1"b;
      200       p_relation_opening_info_ptr = null;
      201       goto GET_REFRESH_JOIN;
      202 
      203 refresh:
      204    entry (p_relation_opening_info_ptr, p_code);
      205 
      206       refresh = "1"b;
      207       relation_opening_info_ptr = p_relation_opening_info_ptr;
      208       call CHECK_VERSION ("relation_opening_info", (relation_opening_info.version), (RELATION_OPENING_INFO_VERSION_2));
      209 
      210       call CURRENT_TRANSACTION_ID (current_transaction_id, current_rollback_count);
      211       goto GET_REFRESH_JOIN;
      212 
      213 GET_REFRESH_JOIN:
      214       p_code = 0;
      215 
      216       if get
      217       then
      218 GET:
      219          do;
      220 	  om_file_opening_id = p_file_opening_id || CANONICAL_SECOND_WORD_OF_RELATION_OPENING_ID;
      221 
      222 	  if static_opening_table_ptr = null
      223 	  then
      224 	     do;
      225 	        p_code = dm_error_$relation_not_open;
      226 	        return;
      227 	     end;
      228 	  else
      229 	     do;
      230 	        call opening_manager_$get_opening (static_opening_table_ptr, om_file_opening_id,
      231 		   relation_opening_info_ptr, p_code);
      232 	        if p_code ^= 0
      233 	        then
      234 		 do;
      235 		    if p_code = dm_error_$no_opening
      236 		    then p_code = dm_error_$relation_not_open;
      237 		    return;
      238 		 end;
      239 	        else /* p_code = 0 */
      240 		   if relation_opening_info_ptr = null
      241 	        then
      242 		 do;
      243 		    p_code = dm_error_$relation_not_open;
      244 		    return;
      245 		 end;
      246 	        else
      247 		 do;
      248 		    call CHECK_VERSION ("relation_opening_info", (relation_opening_info.version),
      249 		         (RELATION_OPENING_INFO_VERSION_2));
      250 
      251 		    if ^dont_refresh
      252 		    then
      253 		       do;
      254 
      255 		       /*** See if the opening info needs to be refreshed. */
      256 
      257 			call CURRENT_TRANSACTION_ID (current_transaction_id, current_rollback_count);
      258 
      259 			if relation_opening_info.per_process.current_transaction_id ^= current_transaction_id
      260 			then refresh = "1"b;
      261 			else if relation_opening_info.per_process.current_rollback_count ^= current_rollback_count
      262 			then refresh = "1"b;
      263 		       end;
      264 		 end;
      265 	     end;
      266          end GET;
      267 
      268       if refresh
      269       then
      270 REFRESH:
      271          do;
      272 	  if static_dm_area_ptr = null
      273 	  then static_dm_area_ptr = get_dm_free_area_ ();
      274 
      275 
      276 	  on cleanup call FINISH ();
      277 
      278 	  if relation_opening_info.relation_header_ptr = null
      279 	  then header_info_update_count = -1;
      280 	  else header_info_update_count =
      281 		  relation_opening_info.relation_header_ptr -> relation_header.header_info_update_count;
      282 
      283          /*** Get the relation_header structure. */
      284 
      285 	  call collection_manager_$get (relation_opening_info.per_process.file_opening_id, HEADER_COLLECTION_ID,
      286 	       CALLER_HEADER_ELEMENT_ID, 0, relation_opening_info.relation_header_ptr,
      287 	       length (unspec (relation_header)), static_dm_area_ptr, ("0"b), relation_header_ptr, (0), p_code);
      288 	  if p_code ^= 0
      289 	  then return;
      290 
      291 	  call CHECK_VERSION ("relation_header", (relation_header.version), (RELATION_HEADER_VERSION_3));
      292 
      293 	  if relation_opening_info.per_process.record_cursor_ptr = null
      294 	  then
      295 	     do;
      296 
      297 	     /*** No record cursor exists for this process, so create one. */
      298 
      299 	        call record_manager_$create_cursor (relation_opening_info.per_process.file_opening_id,
      300 		   relation_header.record_collection_id, static_dm_area_ptr, local_record_cursor_ptr, p_code);
      301 	        if p_code ^= 0
      302 	        then return;
      303 	        else relation_opening_info.per_process.record_cursor_ptr = local_record_cursor_ptr;
      304 	     end;
      305 
      306 	  if relation_header.header_info_update_count ^= header_info_update_count
      307 	  then
      308 REFRESH_UPDATED_HEADER_INFO:
      309 	     do;
      310 
      311 	     /*** Either some header information has been updated since the last time the
      312*		information was retrieved or this is the first retrieval of the header
      313*		information. First, get the attribute_info structure. */
      314 
      315 	        if relation_opening_info.attribute_info_ptr ^= null
      316 	        then attribute_info_buffer_length =
      317 		        currentsize (relation_opening_info.attribute_info_ptr -> attribute_info) * BITS_PER_WORD;
      318 	        call collection_manager_$get (relation_opening_info.per_process.file_opening_id, HEADER_COLLECTION_ID,
      319 		   relation_header.attribute_info_element_id, 0, relation_opening_info.attribute_info_ptr,
      320 		   attribute_info_buffer_length, static_dm_area_ptr, ("0"b), attribute_info_ptr, (0), p_code);
      321 	        if p_code ^= 0
      322 	        then return;
      323 
      324 	        call CHECK_VERSION ("attribute_info", (attribute_info.version), (ATTRIBUTE_INFO_VERSION_1));
      325 
      326 	     /*** Get index_attribute_map. */
      327 
      328 	        if relation_opening_info.index_attribute_map_ptr ^= null
      329 	        then index_attribute_map_buffer_length =
      330 		        currentsize (relation_opening_info.index_attribute_map_ptr -> index_attribute_map)
      331 		        * BITS_PER_WORD;
      332 
      333 	        call collection_manager_$get (relation_opening_info.per_process.file_opening_id, HEADER_COLLECTION_ID,
      334 		   relation_header.index_attribute_map_element_id, 0, relation_opening_info.index_attribute_map_ptr,
      335 		   index_attribute_map_buffer_length, static_dm_area_ptr, ("0"b), index_attribute_map_ptr, (0),
      336 		   p_code);
      337 	        if p_code ^= 0
      338 	        then return;
      339 
      340 	        call CHECK_VERSION ("index_attribute_map", (index_attribute_map.version),
      341 		   (INDEX_ATTRIBUTE_MAP_VERSION_2));
      342 
      343 	        if relation_opening_info.per_process.index_cursor_array_ptr = null
      344 	        then
      345 		 do;
      346 
      347 		 /*** No index_cursor_array exists, so set one up with a null cursor_ptr for each index. */
      348 
      349 		    ica_number_of_indices = hbound (index_attribute_map.index, 1);
      350 		    alloc index_cursor_array in (dm_area);
      351 		    index_cursor_array.version = INDEX_CURSOR_ARRAY_VERSION_1;
      352 		    index_cursor_array.cursor_ptr (*) = null;
      353 		    relation_opening_info.per_process.index_cursor_array_ptr = index_cursor_array_ptr;
      354 		 end;
      355 	        else
      356 INDEX_CURSOR_ARRAY_EXISTS:
      357 		 do;
      358 
      359 		 /*** An index_cursor_array already exists, but since the index_attribute_map
      360*		      may have been changed, update index_cursor_array to match the current
      361*		      state of the index_attribute_map. */
      362 
      363 		    call CHECK_VERSION ("index_attribute_map", index_attribute_map.version,
      364 		         INDEX_ATTRIBUTE_MAP_VERSION_2);
      365 
      366 		    index_cursor_array_ptr = relation_opening_info.per_process.index_cursor_array_ptr;
      367 		    call CHECK_VERSION ("index_cursor_array", index_cursor_array.version,
      368 		         INDEX_CURSOR_ARRAY_VERSION_1);
      369 
      370 		    if hbound (index_cursor_array.cursor_ptr, 1) >= hbound (index_attribute_map.index, 1)
      371 		    then
      372 REMOVE_CURSORS_FOR_DELETED_INDICES:
      373 		       do;
      374 
      375 		       /*** Indices for which cursors are stored in index_cursor_array may have been
      376*			  deleted. Destroy the cursors for any such index. */
      377 
      378 			do index_idx = 1 to hbound (index_attribute_map.index, 1);
      379 			   if index_cursor_array.cursor_ptr (index_idx) ^= null
      380 			   then if index_attribute_map.index (index_idx).number_of_attributes <= 0
      381 			        then
      382 				 do;
      383 				 /***			              call index_manager_$destroy_cursor (index_cursor_array.cursor_ptr(index_idx), (0)); */
      384 				    index_cursor_array.cursor_ptr (index_idx) = null;
      385 				 end;
      386 			end;
      387 		       end REMOVE_CURSORS_FOR_DELETED_INDICES;
      388 		    else
      389 EXTEND_INDEX_CURSOR_ARRAY:
      390 		       do;
      391 
      392 		       /*** The index_attribute_map has been extended to contain more indices than
      393*			  index_cursor_array components, so index_cursor_array must likewise be
      394*			  extended. Allocate a new one, and copy over the old cursor_ptr values.
      395*			  If a non-null cursor_ptr exists for an index which no longer exists,
      396*			  destroy the cursor. */
      397 
      398 			old_index_cursor_array_ptr = index_cursor_array_ptr;
      399 			ica_number_of_indices = hbound (index_attribute_map.index, 1);
      400 
      401 			alloc index_cursor_array in (dm_area);
      402 			index_cursor_array.version = INDEX_CURSOR_ARRAY_VERSION_1;
      403 
      404 			if old_index_cursor_array_ptr ^= null
      405 			then relation_opening_info.per_process.index_cursor_array_ptr = index_cursor_array_ptr;
      406 
      407 			index_cursor_array.cursor_ptr (*) = null;
      408 
      409 			do index_idx = 1 to hbound (old_index_cursor_array_ptr -> index_cursor_array.cursor_ptr, 1);
      410 			   if old_index_cursor_array_ptr -> index_cursor_array.cursor_ptr (index_idx) ^= null
      411 			   then if index_attribute_map.index (index_idx).number_of_attributes > 0
      412 			        then index_cursor_array.cursor_ptr (index_idx) =
      413 				        old_index_cursor_array_ptr -> index_cursor_array.cursor_ptr (index_idx);
      414 			/***			        else call index_manager_$destroy_cursor (old_index_cursor_array_ptr->index_cursor_array.cursor_ptr(index_idx), (0)); */
      415 			end;
      416 		       end EXTEND_INDEX_CURSOR_ARRAY;
      417 		 end INDEX_CURSOR_ARRAY_EXISTS;
      418 
      419 	     /*** Reset relation_opening_info values. */
      420 
      421 	        if attribute_info_ptr ^= relation_opening_info.attribute_info_ptr
      422 	        then
      423 		 do;
      424 		    old_attribute_info_ptr = relation_opening_info.attribute_info_ptr;
      425 		    relation_opening_info.attribute_info_ptr = attribute_info_ptr;
      426 		 end;
      427 
      428 	        if index_attribute_map_ptr ^= relation_opening_info.index_attribute_map_ptr
      429 	        then
      430 		 do;
      431 		    old_index_attribute_map_ptr = relation_opening_info.index_attribute_map_ptr;
      432 		    relation_opening_info.index_attribute_map_ptr = index_attribute_map_ptr;
      433 		 end;
      434 
      435 
      436 	     end REFRESH_UPDATED_HEADER_INFO;
      437 
      438 	  if relation_header_ptr ^= relation_opening_info.relation_header_ptr
      439 	  then relation_opening_info.relation_header_ptr = relation_header_ptr;
      440 
      441 	  relation_opening_info.per_process.current_transaction_id = current_transaction_id;
      442 	  relation_opening_info.per_process.current_rollback_count = current_rollback_count;
      443 
      444 	  call FINISH ();
      445 
      446          end REFRESH;
      447 
      448       if get
      449       then p_relation_opening_info_ptr = relation_opening_info_ptr;
      450 
      451       return;					/* Effective end of $get, $refresh, $get_dont_refresh. */
      452 
      453 init:
      454    entry (p_file_opening_id, p_relation_opening_info_ptr, p_code);
      455 
      456       init = "1"b;
      457       p_code = 0;
      458       om_file_opening_id = p_file_opening_id || CANONICAL_SECOND_WORD_OF_RELATION_OPENING_ID;
      459       p_relation_opening_info_ptr = null ();
      460 
      461       on cleanup call FINISH ();
      462       if static_dm_area_ptr = null
      463       then static_dm_area_ptr = get_dm_free_area_ ();
      464 
      465       if static_opening_table_ptr = null
      466       then
      467          do;
      468 	  call opening_manager_$init (NUMBER_OF_BUCKETS, static_opening_table_ptr, p_code);
      469 	  if p_code ^= 0
      470 	  then return;
      471          end;
      472       else
      473          do;
      474 	  call opening_manager_$get_opening (static_opening_table_ptr, om_file_opening_id, (null), p_code);
      475 	  if p_code = 0
      476 	  then call sub_err_ (error_table_$fatal_error, myname, ACTION_CANT_RESTART, null, 0,
      477 		  "^/Unable to initialize the relation opening info for the file with opening id
      478 ^.3b.  There is already an opening for a relation with this file_opening_id,"
      479 		  || "but there should not be.  This indicates either a damaged per-process relation
      480 opening info table or a programming error in the relation_manager_.", p_file_opening_id);
      481 	  else p_code = 0;
      482          end;
      483 
      484       alloc relation_opening_info in (dm_area);
      485       relation_opening_info.version = RELATION_OPENING_INFO_VERSION_2;
      486 
      487       relation_opening_info.per_process.file_opening_id = p_file_opening_id;
      488       call CURRENT_TRANSACTION_ID (relation_opening_info.per_process.current_transaction_id,
      489 	 relation_opening_info.per_process.current_rollback_count);
      490 
      491       call opening_manager_$put_opening (static_opening_table_ptr, om_file_opening_id, relation_opening_info_ptr, p_code);
      492       if p_code = 0
      493       then p_relation_opening_info_ptr = relation_opening_info_ptr;
      494       else call FINISH ();
      495 
      496       return;					/* End of rlm_opening_info$init */
      497 
      498 free:
      499    entry (p_relation_opening_info_ptr, p_code);
      500 
      501       if static_opening_table_ptr = null
      502       then return;
      503 
      504       relation_opening_info_ptr = p_relation_opening_info_ptr;
      505       call CHECK_VERSION ("relation_opening_info", (relation_opening_info.version), (RELATION_OPENING_INFO_VERSION_2));
      506 
      507 
      508 
      509       om_file_opening_id =
      510 	 relation_opening_info.per_process.file_opening_id || CANONICAL_SECOND_WORD_OF_RELATION_OPENING_ID;
      511 
      512       call opening_manager_$free_opening (static_opening_table_ptr, om_file_opening_id, p_code);
      513       if p_code ^= 0
      514       then return;
      515 
      516       if relation_opening_info.relation_header_ptr ^= null
      517       then free relation_opening_info.relation_header_ptr -> relation_header in (dm_area);
      518       if relation_opening_info.attribute_info_ptr ^= null
      519       then free relation_opening_info.attribute_info_ptr -> attribute_info in (dm_area);
      520       if relation_opening_info.index_attribute_map_ptr ^= null
      521       then free relation_opening_info.index_attribute_map_ptr -> index_attribute_map in (dm_area);
      522 
      523       free relation_opening_info in (dm_area);
      524 
      525       p_relation_opening_info_ptr = null;
      526 
      527       return;					/* End of rlm_opening_info$free */
      528 
      529 FINISH:
      530    proc ();
      531 
      532       if relation_opening_info_ptr ^= null
      533       then
      534          do;
      535 
      536 	  if old_attribute_info_ptr ^= null & old_attribute_info_ptr ^= relation_opening_info.attribute_info_ptr
      537 	  then free old_attribute_info_ptr -> attribute_info in (dm_area);
      538 	  if attribute_info_ptr ^= null & attribute_info_ptr ^= relation_opening_info.attribute_info_ptr
      539 	  then free attribute_info in (dm_area);
      540 	  if old_index_attribute_map_ptr ^= null
      541 	       & old_index_attribute_map_ptr ^= relation_opening_info.index_attribute_map_ptr
      542 	  then free old_index_attribute_map_ptr -> index_attribute_map in (dm_area);
      543 	  if index_attribute_map_ptr ^= null & index_attribute_map_ptr ^= relation_opening_info.index_attribute_map_ptr
      544 	  then free index_attribute_map in (dm_area);
      545 	  if relation_header_ptr ^= null & relation_header_ptr ^= relation_opening_info.relation_header_ptr
      546 	  then free relation_header in (dm_area);
      547 	  if old_index_cursor_array_ptr ^= null
      548 	       & old_index_cursor_array_ptr ^= relation_opening_info.per_process.index_cursor_array_ptr
      549 	  then free old_index_cursor_array_ptr -> index_cursor_array in (dm_area);
      550 	  if index_cursor_array_ptr ^= null
      551 	       & index_cursor_array_ptr ^= relation_opening_info.per_process.index_cursor_array_ptr
      552 	  then free index_cursor_array in (dm_area);
      553 
      554 	  if init
      555 	  then if relation_opening_info_ptr ^= p_relation_opening_info_ptr
      556 	       then free relation_opening_info in (dm_area);
      557          end;
      558 
      559       return;
      560 
      561    end FINISH;
      562 
      563 CHECK_VERSION:
      564    proc (cv_p_structure_name, cv_p_given_version, cv_p_correct_version);
      565 
      566       dcl	    cv_p_structure_name    char (*);
      567       dcl	    cv_p_given_version     char (8) aligned;
      568       dcl	    cv_p_correct_version   char (8) aligned;
      569       dcl	    sub_err_	       entry () options (variable);
      570       dcl	    error_table_$unimplemented_version
      571 			       ext fixed bin (35);
      572 
      573       if cv_p_given_version ^= cv_p_correct_version
      574       then call sub_err_ (error_table_$unimplemented_version, myname, "s", null, 0,
      575 	      "^/Expected version ""^8a"" of ^a structure; received ""^8a"".", cv_p_correct_version,
      576 	      cv_p_structure_name, cv_p_given_version);
      577 
      578       return;
      579 
      580    end CHECK_VERSION;
      581 
      582 CURRENT_TRANSACTION_ID:
      583    proc (cti_p_txn_id, cti_p_rollback_count);
      584 
      585       dcl	    cti_p_txn_id	       bit (36) aligned;
      586       dcl	    cti_p_rollback_count   fixed bin (35);
      587       dcl	    cti_rollback_count     fixed bin;
      588       dcl	    cti_code	       fixed bin (35) init (0);
      589 
      590       call transaction_manager_$get_current_ids (cti_p_txn_id, (0), cti_rollback_count, cti_code);
      591       if cti_code ^= 0
      592       then cti_p_txn_id = "0"b;
      593       cti_p_rollback_count = cti_rollback_count;
      594 
      595    end CURRENT_TRANSACTION_ID;
      596 
      597 
  1     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  1     2 /* format: style3 */
  1     3 
  1     4 /* These constants are to be used for the flags argument of sub_err_ */
  1     5 /* They are just "string (condition_info_header.action_flags)" */
  1     6 
  1     7 declare	(
  1     8 	ACTION_CAN_RESTART	init (""b),
  1     9 	ACTION_CANT_RESTART init ("1"b),
  1    10 	ACTION_DEFAULT_RESTART
  1    11 			init ("01"b),
  1    12 	ACTION_QUIET_RESTART
  1    13 			init ("001"b),
  1    14 	ACTION_SUPPORT_SIGNAL
  1    15 			init ("0001"b)
  1    16 	)		bit (36) aligned internal static options (constant);
  1    17 
  1    18 /* End include file */
      598 
      599 
  2     1 /* BEGIN INCLUDE FILE - dm_rlm_opening_info.incl.pl1 */
  2     2 
  2     3 /* Written by Matthew Pierret, 09/08/82. 
  2     4*Modified:
  2     5*01/18/83 by Matthew Pierret:  Changed version to be char (8). Added 
  2     6*            transaction_id.
  2     7*02/25/83 by Matthew Pierret:  Changed to relation_opening_info (from
  2     8*            relation_info).
  2     9*10/29/84 by Stanford S. Cox:  Changed to not init version.
  2    10**/
  2    11 
  2    12 
  2    13 /* format: style2,ind3 */
  2    14 
  2    15      dcl	   1 relation_opening_info
  2    16 			      aligned based (relation_opening_info_ptr),
  2    17 	     2 version	      char (8),
  2    18 	     2 per_process,
  2    19 	       3 current_transaction_id
  2    20 			      bit (36) aligned init ("0"b),
  2    21 	       3 current_rollback_count
  2    22 			      fixed bin (35) init (0),
  2    23 	       3 file_opening_id  bit (36) aligned init ("0"b),
  2    24 	       3 number_of_openings
  2    25 			      fixed bin (17) aligned init (0),
  2    26 	       3 lock_advice      aligned,
  2    27 	         4 this_process   bit (2) unaligned init ("0"b),
  2    28 	         4 other_processes
  2    29 			      bit (2) unaligned init ("0"b),
  2    30 	         4 mbz1	      bit (32) unaligned init ("0"b),
  2    31 	       3 record_cursor_ptr
  2    32 			      ptr init (null),
  2    33 	       3 index_cursor_array_ptr
  2    34 			      ptr init (null),
  2    35 	     2 relation_header_ptr
  2    36 			      ptr init (null),
  2    37 	     2 attribute_info_ptr ptr init (null),
  2    38 	     2 index_attribute_map_ptr
  2    39 			      ptr init (null);
  2    40 
  2    41      dcl	   relation_opening_info_ptr
  2    42 			      ptr;
  2    43      dcl	   RELATION_OPENING_INFO_VERSION_2
  2    44 			      init ("rlmopen2") char (8) aligned internal static options (constant);
  2    45 
  2    46 
  2    47 /* END INCLUDE FILE - dm_rlm_opening_info.incl.pl1 */
      600 
      601 
  3     1 /* BEGIN INCLUDE FILE - dm_rlm_header.incl.pl1 */
  3     2 
  3     3 /* HISTORY:
  3     4*Written by Matthew Pierret, 1982.
  3     5*Modified:
  3     6*02/25/83 by Matthew Pierret: Added attribute_info_element_id, 
  3     7*            header_info_update_count, RELATION_HEADER_VERSION_2.
  3     8*05/29/84 by Matthew Pierret: Added caller_header_element_id, 
  3     9*            RELATION_HEADER_VERSION_3.
  3    10*10/29/84 by Stanford S. Cox:  Changed to not init version.
  3    11**/
  3    12 
  3    13 /* format: style2,ind3 */
  3    14 
  3    15      dcl	   1 relation_header      aligned based (relation_header_ptr),
  3    16 	     2 version	      char (8),
  3    17 	     2 header_info_update_count
  3    18 			      fixed bin (35) aligned init (0),
  3    19 	     2 record_collection_id
  3    20 			      bit (36) aligned init ("0"b),
  3    21 	     2 cluster_index_id   bit (36) aligned init ("0"b),
  3    22 	     2 attribute_info_element_id
  3    23 			      bit (36) aligned init ("0"b),
  3    24 	     2 index_attribute_map_element_id
  3    25 			      bit (36) aligned init ("0"b),
  3    26 	     2 caller_header_element_id
  3    27 			      bit (36) aligned init ("0"b);
  3    28 
  3    29      dcl	   relation_header_ptr    ptr init (null);
  3    30      dcl	   RELATION_HEADER_VERSION_3
  3    31 			      init ("RelHdr 3") char (8) aligned internal static options (constant);
  3    32 
  3    33 /* END INCLUDE FILE - dm_rlm_header.incl.pl1 */
      602 
      603 
  4     1 /* BEGIN INCLUDE FILE dm_rlm_attribute_info.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION
  4     4*        
  4     5*   Relation attributes descriptor and name.  This info is kept in the header
  4     6*   collection of existing files, therefore this incl should not be changed.
  4     7**/
  4     8 
  4     9 /* HISTORY:
  4    10*Written by Matthew Pierret, 02/25/83.
  4    11*Modified:
  4    12*10/29/84 by Stanford S. Cox:  Changed to not init version.
  4    13*12/14/84 by Stanford S. Cox:  Backed out previous structure alignment changes
  4    14*   which were incompatible with existing DM files.        
  4    15**/
  4    16 
  4    17 /* format: style2,ind3 */
  4    18      dcl	   1 attribute_info	      aligned based (attribute_info_ptr),
  4    19 	     2 version	      char (8),
  4    20 	     2 number_of_attributes
  4    21 			      fixed bin (17) unal,
  4    22 	     2 maximum_attribute_name_length
  4    23 			      fixed bin (17) unal,
  4    24 	     2 attribute	      (ai_number_of_attributes refer (attribute_info.number_of_attributes)),
  4    25 	       3 descriptor	      bit (36) aligned,
  4    26 	       3 name	      char (ai_maximum_attribute_name_length
  4    27 			      refer (attribute_info.maximum_attribute_name_length)) varying;
  4    28 
  4    29      dcl	   attribute_info_ptr     ptr init (null);
  4    30      dcl	   ai_maximum_attribute_name_length
  4    31 			      fixed bin (17);
  4    32      dcl	   ai_number_of_attributes
  4    33 			      fixed bin (17);
  4    34      dcl	   ATTRIBUTE_INFO_VERSION_1
  4    35 			      init ("attrinf1") char (8) aligned internal static options (constant);
  4    36 
  4    37 /* END INCLUDE FILE dm_rlm_attribute_info.incl.pl1 */
  4    38 
      604 
      605 
  5     1 /* BEGIN INCLUDE FILE - dm_rlm_index_attr_map.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION
  5     4*        
  5     5*   Relation index components.  This info is kept in the header
  5     6*   collection of existing files, therefore this incl should not be changed.
  5     7**/
  5     8 
  5     9 /* HISTORY:
  5    10*Written by Matthew Pierret, 01/15/83.
  5    11*Modified:
  5    12*10/29/84 by Stanford S. Cox: Changed to not init version.
  5    13*12/14/84 by Stanford S. Cox:  Backed out previous structure alignment changes
  5    14*   which were incompatible with existing DM files.        
  5    15**/
  5    16 
  5    17 /* format: style2,ind3 */
  5    18      dcl	   1 index_attribute_map  aligned based (index_attribute_map_ptr),
  5    19 	     2 version	      char (8),
  5    20 	     2 number_of_indices  fixed bin (17) unal init (0),
  5    21 	     2 maximum_number_of_indices
  5    22 			      fixed bin (17) unal,
  5    23 	     2 maximum_number_of_attributes_per_index
  5    24 			      fixed bin (17) unal,
  5    25 	     2 mbz	      fixed bin (17) unal,
  5    26 	     2 index	      (iam_maximum_number_of_indices refer (index_attribute_map.maximum_number_of_indices)),
  5    27 	       3 collection_id    bit (36) aligned,
  5    28 	       3 style	      fixed bin (17) unal,
  5    29 	       3 number_of_duplication_fields
  5    30 			      fixed bin (17) unal,
  5    31 	       3 number_of_attributes
  5    32 			      fixed bin (17) unal,
  5    33 	       3 attribute_id     (iam_maximum_number_of_attributes_per_index
  5    34 			      refer (index_attribute_map.maximum_number_of_attributes_per_index)) fixed
  5    35 			      bin (17) unal;
  5    36 
  5    37      dcl	   index_attribute_map_ptr
  5    38 			      ptr init (null);
  5    39      dcl	   iam_maximum_number_of_indices
  5    40 			      fixed bin (17);
  5    41      dcl	   iam_maximum_number_of_attributes_per_index
  5    42 			      fixed bin (17);
  5    43      dcl	   INDEX_ATTRIBUTE_MAP_VERSION_2
  5    44 			      init ("idx_map2") char (8) aligned internal static options (constant);
  5    45      dcl	   INITIAL_NUMBER_OF_INDICES
  5    46 			      init (5) fixed bin (17);
  5    47      dcl	   UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY
  5    48 			      init (0) fixed bin (17);
  5    49 
  5    50 /* END INCLUDE FILE - dm_rlm_index_attr_map.incl.pl1 */
      606 
      607 
  6     1 /* BEGIN INCLUDE FILE dm_rlm_idx_cursor_array.incl.pl1 */
  6     2 
  6     3 /* HISTORY:
  6     4*Written by Matthew Pierret, 03/02/83. 
  6     5*Modified:
  6     6*10/30/84 by Stanford S. Cox: Changed to not init version.
  6     7**/
  6     8 
  6     9 /* format: style2,ind3 */
  6    10 
  6    11      dcl	   1 index_cursor_array   aligned based (index_cursor_array_ptr),
  6    12 	     2 version	      char (8),
  6    13 	     2 number_of_indices  fixed bin (35),
  6    14 	     2 mbz	      fixed bin (35) init (0),
  6    15 	     2 cursor_ptr	      (ica_number_of_indices refer (index_cursor_array.number_of_indices)) ptr;
  6    16 
  6    17      dcl	   index_cursor_array_ptr ptr init (null);
  6    18      dcl	   ica_number_of_indices  fixed bin (35) init (0);
  6    19      dcl	   INDEX_CURSOR_ARRAY_VERSION_1
  6    20 			      init ("ixcrsra1") char (8) aligned internal static options (constant);
  6    21 
  6    22 
  6    23 /* END INCLUDE FILE dm_rlm_idx_cursor_array.incl.pl1 */
      608 
      609 
  7     1 /* BEGIN INCLUDE FILE - dm_hdr_collection_id.incl.pl1 */
  7     2 
  7     3 /* DESCRIPTION:
  7     4*
  7     5*        Contains the identifier of the Header Collection for a file
  7     6*   managed by the collection_manager_.  This is used by callers of 
  7     7*   collection_manager who wish to maintain their own file header or who wish
  7     8*   to maintain their own collection header information beyond the caller
  7     9*   collection header provided by colleciton_manager_$(get put)_header.
  7    10**/
  7    11 
  7    12 /* HISTORY:
  7    13*Written by Matthew Pierret, 09/24/84.
  7    14*Modified:
  7    15**/
  7    16 
  7    17 /* format: style2,ind3,ll79 */
  7    18 
  7    19      dcl	   HEADER_COLLECTION_ID   init ("000000000001"b3) bit (36)
  7    20 			      aligned internal static options (constant);
  7    21 
  7    22 /* END INCLUDE FILE - dm_hdr_collection_id.incl.pl1 */
      610 
      611 
  8     1 /* BEGIN INCLUDE FILE dm_cm_hdr_col_ids.incl.pl1 */
  8     2 
  8     3 /* DESCRIPTION:
  8     4*
  8     5*   Contains element identifiers of some elements in the Header Collection.
  8     6*   HEADER_COLLECTION_HEADER_ELEMENT_ID is the identifier of the element in
  8     7*   which the collection_header for the Header Collection is stored (see
  8     8*   dm_cm_collection_header.incl.pl1).
  8     9*   CALLER_HEADER_ELEMENT_ID is the identifier of the element in which the
  8    10*   caller's file header is stored.
  8    11*   CM_FILE_HEADER_ELEMENT_ID is the identifier of the element in which the
  8    12*   cm_file_header structure is stored (see dm_cm_file_header.incl.pl1).
  8    13**/
  8    14 
  8    15 /* HISTORY:
  8    16*Written by Matthew Pierret, 09/24/84.
  8    17*Modified:
  8    18**/
  8    19 
  8    20 /* format: style2,ind3,ll79 */
  8    21      dcl	   (
  8    22 	   HEADER_COLLECTION_HEADER_ELEMENT_ID
  8    23 			      init ("000000000001"b3),
  8    24 	   CM_FILE_HEADER_ELEMENT_ID
  8    25 			      init ("000000000002"b3),
  8    26 	   CALLER_HEADER_ELEMENT_ID
  8    27 			      init ("000000000003"b3)
  8    28 	   )		      bit (36) aligned int static
  8    29 			      options (constant);
  8    30 
  8    31 /* END INCLUDE FILE  dm_cm_hdr_col_ids.incl.pl1 */
      612 
      613 
  9     1 /* BEGIN INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
  9     2 
  9     3 /* DESCRIPTION:
  9     4*     This include file contains declarations of all collection_manager_ 
  9     5*     entrypoints.
  9     6**/
  9     7 
  9     8 /* HISTORY:
  9     9*Written by Matthew Pierret 
  9    10*Modified:
  9    11*04/14/82 by Lindsey Spratt: Changed the control_interval_id parameter of the
  9    12*	  allocate_control_interval operation to be unaligned, as well as
  9    13*	  unsigned.
  9    14*06/17/82 by Matthew Pierret: Added the put_element_portion opertion and
  9    15*            removed the beginning_location parameter from the put_element
  9    16*            operation. Added the create_page_file_operation.
  9    17*08/09/82 by Matthew Pierret: Changed "fixed bin (17)"s to "bit (36) aligned"s
  9    18*            wherever collection_id was required.
  9    19*            Also changed the control_interval_id parameter of the 
  9    20*            allocate_control_interval operation back to be aligned. So there.
  9    21*10/20/82 by Matthew Pierret: Changed $create_page_file to $create_file,
  9    22*            added the argument file_create_info_ptr to $create_file.
  9    23*12/13/82 by Lindsey Spratt:  Corrected $free_control_interval to
  9    24*	  include the zero_on_free bit.
  9    25*12/17/82 by Matthew Pierret: Added cm_$get_id.
  9    26*01/07/83 by Matthew Pierret: Added cm_$put_element_buffered, 
  9    27*            cm_$allocate_element_buffered, cm_$free_element_buffered.
  9    28*04/27/83 by Matthew Pierret: Added cm_$put_unprotected_element,
  9    29*            cm_$put_unprotected_header.
  9    30*11/07/83 by Matthew Pierret: Added $get_element_portion_buffered,
  9    31*             $simple_get_buffered_element.
  9    32*02/08/84 by Matthew Pierret:  Changed $get_id to have only one bit(1)aligned
  9    33*            parameter for specifying absolute/relative nature of search.
  9    34*03/16/84 by Matthew Pierret:  Added cm_$get_control_interval_ptr,
  9    35*            $get_element_ptr, $get_element_portion_ptr, $simple_get_element_ptr
  9    36*04/03/84 by Matthew Pierret:  Added cm_$compact_control_interval.
  9    37*06/06/84 by Matthew Pierret:  Re-named free_element* to delete and
  9    38*            delete_from_ci_buffer.
  9    39*            Re-named *_buffered_ci to =_ci_buffer.
  9    40*            get entries.
  9    41*            modify entries.
  9    42*            Changed calling sequence of modify entries to have a ptr/length
  9    43*            instead of length/ptr parameter pair.
  9    44*03/11/85 by R. Michael Tague:  Added $postcommit_increments.
  9    45**/
  9    46 
  9    47 /* This include file contains declarations of collection_manager_ entrypoints */
  9    48 
  9    49 /* format: style2,ind3 */
  9    50      dcl	   collection_manager_$allocate_control_interval
  9    51 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
  9    52      dcl	   collection_manager_$compact_control_interval
  9    53 			      entry (bit (36) aligned, fixed bin (24) uns, fixed bin (35));
  9    54      dcl	   collection_manager_$create_collection
  9    55 			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  9    56      dcl	   collection_manager_$create_file
  9    57 			      entry (char (*), char (*), ptr, bit (36) aligned, fixed bin (35));
  9    58      dcl	   collection_manager_$destroy_collection
  9    59 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  9    60      dcl	   collection_manager_$free_control_interval
  9    61 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, bit (1) aligned,
  9    62 			      fixed bin (35));
  9    63 
  9    64      dcl	   collection_manager_$delete
  9    65 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  9    66 			      fixed bin (35));
  9    67      dcl	   collection_manager_$delete_from_ci_buffer
  9    68 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  9    69 			      fixed bin (35));
  9    70 
  9    71      dcl	   collection_manager_$get
  9    72 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  9    73 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  9    74      dcl	   collection_manager_$get_control_interval_ptr
  9    75 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, ptr,
  9    76 			      fixed bin (35));
  9    77      dcl	   collection_manager_$get_from_ci_buffer
  9    78 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  9    79 			      ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  9    80      dcl	   collection_manager_$get_by_ci_ptr
  9    81 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  9    82 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), ptr, fixed bin (35));
  9    83      dcl	   collection_manager_$get_header
  9    84 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (17), ptr, bit (1) aligned,
  9    85 			      ptr, fixed bin (35), fixed bin (35));
  9    86      dcl	   collection_manager_$get_id
  9    87 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17),
  9    88 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  9    89      dcl	   collection_manager_$get_portion
  9    90 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  9    91 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  9    92 			      fixed bin (35), fixed bin (35));
  9    93      dcl	   collection_manager_$get_portion_from_ci_buffer
  9    94 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  9    95 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  9    96 			      fixed bin (35));
  9    97      dcl	   collection_manager_$get_portion_by_ci_ptr
  9    98 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  9    99 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  9   100 			      fixed bin (35));
  9   101      dcl	   collection_manager_$modify
  9   102 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  9   103 			      fixed bin (35), fixed bin (35));
  9   104      dcl	   collection_manager_$modify_unprotected
  9   105 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  9   106 			      fixed bin (35), fixed bin (35));
  9   107      dcl	   collection_manager_$modify_in_ci_buffer
  9   108 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  9   109 			      fixed bin (35), fixed bin (35));
  9   110      dcl	   collection_manager_$modify_portion
  9   111 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35), ptr,
  9   112 			      fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  9   113      dcl	   collection_manager_$postcommit_increments
  9   114 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  9   115      dcl	   collection_manager_$put
  9   116 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  9   117 			      fixed bin (35), fixed bin (35));
  9   118      dcl	   collection_manager_$put_in_ci_buffer
  9   119 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  9   120 			      fixed bin (35), fixed bin (35));
  9   121      dcl	   collection_manager_$put_header
  9   122 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  9   123      dcl	   collection_manager_$put_unprotected_header
  9   124 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  9   125 
  9   126      dcl	   collection_manager_$replace_ci_buffer
  9   127 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  9   128 			      fixed bin (35));
  9   129      dcl	   collection_manager_$setup_ci_buffer
  9   130 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  9   131 			      fixed bin (35));
  9   132      dcl	   collection_manager_$simple_get_by_ci_ptr
  9   133 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  9   134 			      fixed bin (35));
  9   135      dcl	   collection_manager_$simple_get_from_ci_buffer
  9   136 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  9   137 			      fixed bin (35));
  9   138 
  9   139 /* END INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
      614 
      615 
      616    end rlm_opening_info;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/04/85  0823.6  rlm_opening_info.pl1              >spec>on>7192.pbf-04/04/85>rlm_opening_info.pl1
598          1    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
600          2    01/07/85  0859.6  dm_rlm_opening_info.incl.pl1      >ldd>include>dm_rlm_opening_info.incl.pl1
602          3    01/07/85  0859.4  dm_rlm_header.incl.pl1            >ldd>include>dm_rlm_header.incl.pl1
604          4    01/07/85  0901.7  dm_rlm_attribute_info.incl.pl1    >ldd>include>dm_rlm_attribute_info.incl.pl1
606          5    01/07/85  0901.7  dm_rlm_index_attr_map.incl.pl1    >ldd>include>dm_rlm_index_attr_map.incl.pl1
608          6    01/07/85  0859.5  dm_rlm_idx_cursor_array.incl.pl1  >ldd>include>dm_rlm_idx_cursor_array.incl.pl1
610          7    01/07/85  0858.8  dm_hdr_collection_id.incl.pl1     >ldd>include>dm_hdr_collection_id.incl.pl1
612          8    01/07/85  0858.4  dm_cm_hdr_col_ids.incl.pl1        >ldd>include>dm_cm_hdr_col_ids.incl.pl1
614          9    04/04/85  0819.0  dm_collmgr_entry_dcls.incl.pl1    >spec>on>7192.pbf-04/04/85>dm_collmgr_entry_dcls.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000036 constant        bit(36)                  initial dcl 1-7 set ref 105* 475*
ATTRIBUTE_INFO_VERSION_1        000004 constant        char(8)                  initial dcl 4-34 ref 324
BITS_PER_WORD                          constant        fixed bin(17,0)          initial dcl 148 ref 315 328
CALLER_HEADER_ELEMENT_ID        000042 constant        bit(36)                  initial dcl 8-21 set ref 285*
CANONICAL_SECOND_WORD_OF_RELATION_OPENING_ID
                                       constant        bit(36)                  initial dcl 150 ref 220 458 509
HEADER_COLLECTION_ID            000045 constant        bit(36)                  initial dcl 7-19 set ref 285* 318* 333*
INDEX_ATTRIBUTE_MAP_VERSION_2   000002 constant        char(8)                  initial dcl 5-43 set ref 340 363*
INDEX_CURSOR_ARRAY_VERSION_1    000000 constant        char(8)                  initial dcl 6-19 set ref 351 367* 402
INITIAL_NUMBER_OF_INDICES       000142 automatic       fixed bin(17,0)          initial dcl 5-45 set ref 5-45*
NUMBER_OF_BUCKETS               000012 constant        fixed bin(17,0)          initial dcl 149 set ref 468*
RELATION_HEADER_VERSION_3       000006 constant        char(8)                  initial dcl 3-30 ref 291
RELATION_OPENING_INFO_VERSION_2 000010 constant        char(8)                  initial dcl 2-43 ref 208 248 485 505
UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY
                                000143 automatic       fixed bin(17,0)          initial dcl 5-47 set ref 5-47*
attribute_info                         based           structure                level 1 dcl 4-18 ref 315 518 536 538
attribute_info_buffer_length    000100 automatic       fixed bin(35,0)          initial dcl 119 set ref 119* 315* 318*
attribute_info_element_id
                          5            based           bit(36)                  initial level 2 dcl 3-15 set ref 318*
attribute_info_ptr       16            based           pointer                  initial level 2 in structure "relation_opening_info"
                                                                                  dcl 2-15 in procedure "rlm_opening_info" set ref
                                                                                  315 315 318* 421 424 425* 484* 518 518 536 538
attribute_info_ptr              000136 automatic       pointer                  initial dcl 4-29 in procedure "rlm_opening_info" set
                                                                                  ref 318* 324 421 425 4-29* 538 538 538
cleanup                         000124 stack reference condition                dcl 143 ref 276 461
collection_manager_$get         000044 constant        entry                    external dcl 9-71 ref 285 318 333
cti_code                        000175 automatic       fixed bin(35,0)          initial dcl 588 set ref 588* 590* 591
cti_p_rollback_count                   parameter       fixed bin(35,0)          dcl 586 set ref 582 593*
cti_p_txn_id                           parameter       bit(36)                  dcl 585 set ref 582 590* 591*
cti_rollback_count              000174 automatic       fixed bin(17,0)          dcl 587 set ref 590* 593
current_rollback_count          000104 automatic       fixed bin(35,0)          dcl 124 in procedure "rlm_opening_info" set ref 210*
                                                                                  257* 261 442
current_rollback_count
                          3            based           fixed bin(35,0)          initial level 3 in structure "relation_opening_info"
                                                                                  dcl 2-15 in procedure "rlm_opening_info" set ref
                                                                                  261 442* 484* 488*
current_transaction_id
                          2            based           bit(36)                  initial level 3 in structure "relation_opening_info"
                                                                                  dcl 2-15 in procedure "rlm_opening_info" set ref
                                                                                  259 441* 484* 488*
current_transaction_id          000111 automatic       bit(36)                  dcl 127 in procedure "rlm_opening_info" set ref 210*
                                                                                  257* 259 441
currentsize                                            builtin function         dcl 138 ref 315 328
cursor_ptr                4            based           pointer                  array level 2 dcl 6-11 set ref 352* 370 379 384*
                                                                                  407* 409 410 410* 410
cv_p_correct_version                   parameter       char(8)                  dcl 568 set ref 563 573 573*
cv_p_given_version                     parameter       char(8)                  dcl 567 set ref 563 573 573*
cv_p_structure_name                    parameter       char                     unaligned dcl 566 set ref 563 573*
dm_area                                based           area                     dcl 134 ref 350 401 484 516 518 520 523 536 538 540
                                                                                  543 545 547 550 554
dm_error_$no_opening            000034 external static fixed bin(35,0)          dcl 171 ref 235
dm_error_$programming_error     000036 external static fixed bin(35,0)          dcl 172 set ref 105*
dm_error_$relation_not_open     000040 external static fixed bin(35,0)          dcl 174 ref 225 235 243
dont_refresh                    000106 automatic       bit(1)                   initial dcl 125 set ref 125* 199* 251
error_table_$fatal_error        000042 external static fixed bin(35,0)          dcl 176 set ref 475*
error_table_$unimplemented_version
                                000050 external static fixed bin(35,0)          dcl 570 set ref 573*
file_opening_id           4            based           bit(36)                  initial level 3 dcl 2-15 set ref 285* 299* 318* 333*
                                                                                  484* 487* 509
get                             000105 automatic       bit(1)                   initial dcl 125 set ref 125* 192* 199* 216 448
get_dm_free_area_               000014 constant        entry                    external dcl 155 ref 272 462
hbound                                                 builtin function         dcl 138 ref 349 370 370 378 399 409
header_info_update_count        000102 automatic       fixed bin(17,0)          initial dcl 121 in procedure "rlm_opening_info" set
                                                                                  ref 121* 278* 280* 306
header_info_update_count
                          2            based           fixed bin(35,0)          initial level 2 in structure "relation_header"
                                                                                  dcl 3-15 in procedure "rlm_opening_info" ref 280
                                                                                  306
ica_number_of_indices           000146 automatic       fixed bin(35,0)          initial dcl 6-18 set ref 349* 350 350 399* 401 401
                                                                                  6-18*
index                     4            based           structure                array level 2 dcl 5-18 ref 349 370 378 399
index_attribute_map                    based           structure                level 1 dcl 5-18 set ref 328 520 540 543
index_attribute_map_buffer_length
                                000101 automatic       fixed bin(35,0)          initial dcl 119 set ref 119* 328* 333*
index_attribute_map_element_id
                          6            based           bit(36)                  initial level 2 dcl 3-15 set ref 333*
index_attribute_map_ptr         000140 automatic       pointer                  initial dcl 5-37 in procedure "rlm_opening_info" set
                                                                                  ref 333* 340 349 363 370 378 379 399 410 428 432
                                                                                  5-37* 543 543 543
index_attribute_map_ptr
                         20            based           pointer                  initial level 2 in structure "relation_opening_info"
                                                                                  dcl 2-15 in procedure "rlm_opening_info" set ref
                                                                                  328 328 333* 428 431 432* 484* 520 520 540 543
index_cursor_array                     based           structure                level 1 dcl 6-11 set ref 350 401 547 550
index_cursor_array_ptr          000144 automatic       pointer                  initial dcl 6-17 in procedure "rlm_opening_info" set
                                                                                  ref 350* 351 352 353 366* 367 370 379 384 398 401*
                                                                                  402 404 407 410 6-17* 550 550 550
index_cursor_array_ptr
                         12            based           pointer                  initial level 3 in structure "relation_opening_info"
                                                                                  dcl 2-15 in procedure "rlm_opening_info" set ref
                                                                                  343 353* 366 404* 484* 547 550
index_idx                       000103 automatic       fixed bin(17,0)          dcl 123 set ref 378* 379 379 384* 409* 410 410 410
                                                                                  410*
init                            000107 automatic       bit(1)                   initial dcl 125 set ref 125* 456* 554
length                                                 builtin function         dcl 138 ref 285 285
local_record_cursor_ptr         000114 automatic       pointer                  initial dcl 129 set ref 129* 299* 303
lock_advice               6            based           structure                level 3 dcl 2-15
maximum_attribute_name_length
                          2(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 4-18 ref 315 518 536
                                                                                  538
maximum_number_of_attributes_per_index
                          3            based           fixed bin(17,0)          level 2 packed unaligned dcl 5-18 ref 328 379 379
                                                                                  410 410 520 540 543
maximum_number_of_indices
                          2(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 5-18 ref 328 349 370
                                                                                  378 399 520 540 543
mbz                       3            based           fixed bin(35,0)          initial level 2 dcl 6-11 set ref 350* 401*
mbz1                      6(04)        based           bit(32)                  initial level 4 packed unaligned dcl 2-15 set ref
                                                                                  484*
myname                          000013 constant        varying char(32)         initial dcl 147 set ref 105* 105* 105* 475* 573*
null                                                   builtin function         dcl 138 ref 105 105 129 129 129 129 193 200 222 239
                                                                                  272 278 293 315 328 343 352 379 384 404 407 410
                                                                                  459 462 465 474 475 475 484 484 484 484 484 501
                                                                                  516 518 520 525 3-29 4-29 5-37 6-17 532 536 538
                                                                                  540 543 545 547 550 573 573
number_of_attributes      6            based           fixed bin(17,0)          array level 3 in structure "index_attribute_map"
                                                                                  packed unaligned dcl 5-18 in procedure
                                                                                  "rlm_opening_info" ref 379 410
number_of_attributes      2            based           fixed bin(17,0)          level 2 in structure "attribute_info" packed
                                                                                  unaligned dcl 4-18 in procedure "rlm_opening_info"
                                                                                  ref 315 518 536 538
number_of_indices         2            based           fixed bin(35,0)          level 2 dcl 6-11 set ref 350* 352 370 401* 407 409
                                                                                  547 550
number_of_openings        5            based           fixed bin(17,0)          initial level 3 dcl 2-15 set ref 484*
old_attribute_info_ptr          000116 automatic       pointer                  initial dcl 129 set ref 129* 424* 536 536 536
old_index_attribute_map_ptr     000120 automatic       pointer                  initial dcl 129 set ref 129* 431* 540 540 540
old_index_cursor_array_ptr      000122 automatic       pointer                  initial dcl 129 set ref 129* 398* 404 409 410 410
                                                                                  547 547 547
om_file_opening_id              000112 automatic       bit(72)                  dcl 128 set ref 220* 230* 458* 474* 491* 509* 512*
opening_manager_$free_opening   000024 constant        entry                    external dcl 161 ref 512
opening_manager_$get_opening    000016 constant        entry                    external dcl 156 ref 230 474
opening_manager_$init           000022 constant        entry                    external dcl 160 ref 468
opening_manager_$put_opening    000020 constant        entry                    external dcl 158 ref 491
other_processes           6(02)        based           bit(2)                   initial level 4 packed unaligned dcl 2-15 set ref
                                                                                  484*
p_code                                 parameter       fixed bin(35,0)          dcl 115 set ref 189 196 203 213* 225* 230* 232 235
                                                                                  235* 243* 285* 288 299* 301 318* 321 333* 337 453
                                                                                  457* 468* 469 474* 475 481* 491* 492 498 512* 513
p_file_opening_id                      parameter       bit(36)                  dcl 112 set ref 189 196 220 453 458 475* 487
p_relation_opening_info_ptr            parameter       pointer                  dcl 113 set ref 189 193* 196 200* 203 207 448* 453
                                                                                  459* 492* 498 504 525* 554
per_process               2            based           structure                level 2 dcl 2-15
record_collection_id      3            based           bit(36)                  initial level 2 dcl 3-15 set ref 299*
record_cursor_ptr        10            based           pointer                  initial level 3 dcl 2-15 set ref 293 303* 484*
record_manager_$create_cursor   000026 constant        entry                    external dcl 163 ref 299
refresh                         000110 automatic       bit(1)                   initial dcl 125 set ref 125* 206* 259* 261* 268
relation_header                        based           structure                level 1 dcl 3-15 set ref 285 285 516 545
relation_header_ptr      14            based           pointer                  initial level 2 in structure "relation_opening_info"
                                                                                  dcl 2-15 in procedure "rlm_opening_info" set ref
                                                                                  278 280 285* 438 438* 484* 516 516 545
relation_header_ptr             000134 automatic       pointer                  initial dcl 3-29 in procedure "rlm_opening_info" set
                                                                                  ref 285 285 285* 291 299 306 318 333 438 438 3-29*
                                                                                  545 545 545
relation_opening_info                  based           structure                level 1 dcl 2-15 set ref 484 523 554
relation_opening_info_ptr       000132 automatic       pointer                  dcl 2-41 set ref 207* 208 230* 239 248 259 261 278
                                                                                  280 285 285 293 299 303 315 315 318 318 328 328
                                                                                  333 333 343 353 366 404 421 424 425 428 431 432
                                                                                  438 438 441 442 448 484* 485 487 488 488 491* 492
                                                                                  504* 505 509 516 516 518 518 520 520 523 532 536
                                                                                  538 540 543 545 547 550 554 554
static_dm_area_ptr              000012 internal static pointer                  initial dcl 182 set ref 272 272* 285* 299* 318* 333*
                                                                                  350 401 462 462* 484 516 518 520 523 536 538 540
                                                                                  543 545 547 550 554
static_opening_table_ptr        000010 internal static pointer                  initial dcl 182 set ref 222 230* 465 468* 474* 491*
                                                                                  501 512*
sub_err_                        000046 constant        entry                    external dcl 569 in procedure "CHECK_VERSION" ref
                                                                                  573
sub_err_                        000030 constant        entry                    external dcl 165 in procedure "rlm_opening_info" ref
                                                                                  105 475
this_process              6            based           bit(2)                   initial level 4 packed unaligned dcl 2-15 set ref
                                                                                  484*
transaction_manager_$get_current_ids
                                000032 constant        entry                    external dcl 166 ref 590
unspec                                                 builtin function         dcl 138 ref 285 285
version                                based           char(8)                  level 2 in structure "relation_header" dcl 3-15
                                                                                  in procedure "rlm_opening_info" ref 291
version                                based           char(8)                  level 2 in structure "relation_opening_info"
                                                                                  dcl 2-15 in procedure "rlm_opening_info" set ref
                                                                                  208 248 485* 505
version                                based           char(8)                  level 2 in structure "index_attribute_map" dcl 5-18
                                                                                  in procedure "rlm_opening_info" set ref 340 363*
version                                based           char(8)                  level 2 in structure "index_cursor_array" dcl 6-11
                                                                                  in procedure "rlm_opening_info" set ref 351* 367*
                                                                                  402*
version                                based           char(8)                  level 2 in structure "attribute_info" dcl 4-18
                                                                                  in procedure "rlm_opening_info" ref 324

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 1-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 1-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 1-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 1-7
CM_FILE_HEADER_ELEMENT_ID              internal static bit(36)                  initial dcl 8-21
HEADER_COLLECTION_HEADER_ELEMENT_ID    internal static bit(36)                  initial dcl 8-21
ai_maximum_attribute_name_length       automatic       fixed bin(17,0)          dcl 4-30
ai_number_of_attributes                automatic       fixed bin(17,0)          dcl 4-32
collection_manager_$allocate_control_interval
                                000000 constant        entry                    external dcl 9-50
collection_manager_$compact_control_interval
                                000000 constant        entry                    external dcl 9-52
collection_manager_$create_collection
                                000000 constant        entry                    external dcl 9-54
collection_manager_$create_file 000000 constant        entry                    external dcl 9-56
collection_manager_$delete      000000 constant        entry                    external dcl 9-64
collection_manager_$delete_from_ci_buffer
                                000000 constant        entry                    external dcl 9-67
collection_manager_$destroy_collection
                                000000 constant        entry                    external dcl 9-58
collection_manager_$free_control_interval
                                000000 constant        entry                    external dcl 9-60
collection_manager_$get_by_ci_ptr
                                000000 constant        entry                    external dcl 9-80
collection_manager_$get_control_interval_ptr
                                000000 constant        entry                    external dcl 9-74
collection_manager_$get_from_ci_buffer
                                000000 constant        entry                    external dcl 9-77
collection_manager_$get_header  000000 constant        entry                    external dcl 9-83
collection_manager_$get_id      000000 constant        entry                    external dcl 9-86
collection_manager_$get_portion 000000 constant        entry                    external dcl 9-89
collection_manager_$get_portion_by_ci_ptr
                                000000 constant        entry                    external dcl 9-97
collection_manager_$get_portion_from_ci_buffer
                                000000 constant        entry                    external dcl 9-93
collection_manager_$modify      000000 constant        entry                    external dcl 9-101
collection_manager_$modify_in_ci_buffer
                                000000 constant        entry                    external dcl 9-107
collection_manager_$modify_portion
                                000000 constant        entry                    external dcl 9-110
collection_manager_$modify_unprotected
                                000000 constant        entry                    external dcl 9-104
collection_manager_$postcommit_increments
                                000000 constant        entry                    external dcl 9-113
collection_manager_$put         000000 constant        entry                    external dcl 9-115
collection_manager_$put_header  000000 constant        entry                    external dcl 9-121
collection_manager_$put_in_ci_buffer
                                000000 constant        entry                    external dcl 9-118
collection_manager_$put_unprotected_header
                                000000 constant        entry                    external dcl 9-123
collection_manager_$replace_ci_buffer
                                000000 constant        entry                    external dcl 9-126
collection_manager_$setup_ci_buffer
                                000000 constant        entry                    external dcl 9-129
collection_manager_$simple_get_by_ci_ptr
                                000000 constant        entry                    external dcl 9-132
collection_manager_$simple_get_from_ci_buffer
                                000000 constant        entry                    external dcl 9-135
iam_maximum_number_of_attributes_per_index
                                       automatic       fixed bin(17,0)          dcl 5-41
iam_maximum_number_of_indices          automatic       fixed bin(17,0)          dcl 5-39
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 178

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_VERSION                   002473 constant        entry                    internal dcl 563 ref 208 248 291 324 340 363 367 505
CURRENT_TRANSACTION_ID          002577 constant        entry                    internal dcl 582 ref 210 257 488
EXTEND_INDEX_CURSOR_ARRAY       001402 constant        label                    dcl 388
FINISH                          002226 constant        entry                    internal dcl 529 ref 276 444 461 494
GET                             000500 constant        label                    dcl 216
GET_REFRESH_JOIN                000475 constant        label                    dcl 213 ref 194 201 211
INDEX_CURSOR_ARRAY_EXISTS       001253 constant        label                    dcl 355
REFRESH                         000611 constant        label                    dcl 268
REFRESH_UPDATED_HEADER_INFO     000777 constant        label                    dcl 306
REMOVE_CURSORS_FOR_DELETED_INDICES
                                001337 constant        label                    dcl 370
free                            002056 constant        entry                    external dcl 498
get                             000365 constant        entry                    external dcl 189
get_dont_refresh                000407 constant        entry                    external dcl 196
init                            001561 constant        entry                    external dcl 453
refresh                         000434 constant        entry                    external dcl 203
rlm_opening_info                000302 constant        entry                    external dcl 102

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3240        3312    2746        3250
Length      3752    2746        52         424     272           4

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
rlm_opening_info                    324 external procedure  is an external procedure.  
on unit on line 276                  64 on unit               
on unit on line 461                  64 on unit               
FINISH                               65 internal procedure  is called by several nonquick procedures.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure rlm_opening_info.  
CURRENT_TRANSACTION_ID                  internal procedure  shares stack frame of external procedure rlm_opening_info.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 static_opening_table_ptr    rlm_opening_info
000012 static_dm_area_ptr          rlm_opening_info

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
rlm_opening_info         000100 attribute_info_buffer_length
                                                            rlm_opening_info
                         000101 index_attribute_map_buffer_length
                                                            rlm_opening_info
                         000102 header_info_update_count    rlm_opening_info
                         000103 index_idx                   rlm_opening_info
                         000104 current_rollback_count      rlm_opening_info
                         000105 get                         rlm_opening_info
                         000106 dont_refresh                rlm_opening_info
                         000107 init                        rlm_opening_info
                         000110 refresh                     rlm_opening_info
                         000111 current_transaction_id      rlm_opening_info
                         000112 om_file_opening_id          rlm_opening_info
                         000114 local_record_cursor_ptr     rlm_opening_info
                         000116 old_attribute_info_ptr      rlm_opening_info
                         000120 old_index_attribute_map_ptr rlm_opening_info
                         000122 old_index_cursor_array_ptr  rlm_opening_info
                         000132 relation_opening_info_ptr   rlm_opening_info
                         000134 relation_header_ptr         rlm_opening_info
                         000136 attribute_info_ptr          rlm_opening_info
                         000140 index_attribute_map_ptr     rlm_opening_info
                         000142 INITIAL_NUMBER_OF_INDICES   rlm_opening_info
                         000143 UNUSED_INDEX_ATTRIBUTE_MAP_ENTRY
                                                            rlm_opening_info
                         000144 index_cursor_array_ptr      rlm_opening_info
                         000146 ica_number_of_indices       rlm_opening_info
                         000174 cti_rollback_count          CURRENT_TRANSACTION_ID
                         000175 cti_code                    CURRENT_TRANSACTION_ID

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return              enable
ext_entry           int_entry           alloc_based         free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
collection_manager_$get       get_dm_free_area_             opening_manager_$free_opening opening_manager_$get_opening
opening_manager_$init         opening_manager_$put_opening  record_manager_$create_cursor sub_err_
sub_err_                      transaction_manager_$get_current_ids

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$no_opening          dm_error_$programming_error   dm_error_$relation_not_open   error_table_$fatal_error
error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    119 000251       121 000253       125 000255       129 000261    3   29 000266    4   29 000267    5   37 000270
 5   45 000271    5   47 000273    6   17 000274    6   18 000276       102 000301       105 000310       189 000360
    192 000400       193 000402       194 000404       196 000405       199 000422       200 000425       201 000427
    203 000430       206 000447       207 000451       208 000454       210 000472       211 000474       213 000475
    216 000476       220 000500       222 000504       225 000511       226 000513       230 000514       232 000530
    235 000532       237 000537       239 000540       243 000544       244 000547       248 000550       251 000567
    257 000571       259 000573       261 000602       268 000607       272 000611       276 000624       278 000646
    280 000656       285 000661       288 000722       291 000724       293 000741       299 000746       301 000766
    303 000770       306 000773       315 000777       318 001022       321 001061       324 001063       328 001100
    333 001126       337 001166       340 001170       343 001204       349 001211       350 001216       351 001231
    352 001234       353 001250       354 001252       363 001253       366 001275       367 001300       370 001325
    378 001337       379 001347       384 001374       386 001377       387 001401       398 001402       399 001403
    401 001405       402 001420       404 001423       407 001431       409 001446       410 001457       415 001510
    421 001512       424 001517       425 001521       428 001523       431 001527       432 001531       438 001533
    441 001542       442 001544       444 001546       448 001552       451 001556       453 001557       456 001574
    457 001576       458 001577       459 001603       461 001605       462 001627       465 001642       468 001647
    469 001661       471 001663       474 001664       475 001702       481 001757       484 001760       485 002006
    487 002011       488 002014       491 002025       492 002042       494 002047       496 002053       498 002054
    501 002071       504 002076       505 002101       509 002117       512 002123       513 002136       516 002140
    518 002147       520 002172       523 002220       525 002222       527 002224       529 002225       532 002233
    536 002240       538 002267       540 002317       543 002352       545 002405       547 002421       550 002441
    554 002461       559 002472       563 002473       573 002504       578 002576       582 002577       588 002601
    590 002602       591 002620       593 002624       595 002627


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
