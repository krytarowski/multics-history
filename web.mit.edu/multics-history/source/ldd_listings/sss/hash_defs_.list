	COMPILATION LISTING OF SEGMENT hash_defs_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/20/86  1203.2 mst Thu
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 /****^  HISTORY COMMENTS:
        8*  1) change(85-09-24,Elhard), approve(85-09-24,MCR7198),
        9*     audit(86-06-30,Weaver), install(86-07-16,MR12.0-1094):
       10*     Improved documentation.
       11*                                                   END HISTORY COMMENTS */
       12 
       13 /* HASH_DEFS - Program to Convert Object Segments for Definition Hashing.
       14*	12/2/76 by Noel I. Morris	*/
       15 
       16 /* ******************************************************
       17*   *                                                    *
       18*   *                                                    *
       19*   * Copyright (c) 1972 by Massachusetts Institute of   *
       20*   * Technology and Honeywell Information Systems, Inc. *
       21*   *                                                    *
       22*   *                                                    *
       23*   ****************************************************** */
       24 
       25 /**********************************************************************/
       26 /*							*/
       27 /*	Name:	hash_defs_				*/
       28 /*	Input:	component_table				*/
       29 /*	Function:	given the component_table and associated insym	*/
       30 /*		tables, builds a definition_hash_table for the	*/
       31 /*		new bound object segment.  Creation of the hash	*/
       32 /*		table occcurs in three stages:		*/
       33 /*		  -- scanning of the definitions for duplicate	*/
       34 /*		     definition names to create the duplicate	*/
       35 /*		     tables, mark the duplicate definitions as	*/
       36 /*		     duplicates, and to redefine the location of	*/
       37 /*		     the definition to point to the duplicate	*/
       38 /*		     table.				*/
       39 /*		  -- hashing the non-duplicate symbols into the	*/
       40 /*		     definition hash table.			*/
       41 /*		  -- if there were duplicates in the definition	*/
       42 /*		     hash table, hashing the segname definitions	*/
       43 /*		     into the component hash table.		*/
       44 /*	Output:	none					*/
       45 /*							*/
       46 /**********************************************************************/
       47 
       48 /* format: style3,^indnoniterdo */
       49 hash_defs_:
       50      proc;
       51 
       52 dcl	(sp, sp1)		ptr,			/* pointers to insym entries */
       53 	ctep1		ptr,			/* pointer to component table entry */
       54 	(ip, ip1)		ptr,			/* pointers to insym table entries */
       55 	(sytp, sgtp)	ptr,			/* pointers to seg/sym hash tables */
       56 	(symx, segx, cx, cx1, sx, sx1)
       57 			fixed bin,		/* table indices */
       58 	defrel		bit (18) aligned,		/* rel ptr to definition */
       59 	defp		ptr,			/* ITS pointer to definition */
       60 	namep		ptr,			/* pointer to symbol */
       61 	axtp		ptr,			/* pointer to auxiliary table */
       62 	axx		fixed bin,		/* aux table index */
       63 	dupn		fixed bin,		/* duplicate symbol counter */
       64 	htsize		fixed bin (17);		/* size of hash table */
       65 
       66 
       67 dcl	(addr, addrel, bin, bit, hbound, mod, substr, unspec)
       68 			builtin;
       69 
       70 dcl	1 symht		based aligned,		/* def symbol hash table */
       71 	  2 size		fixed bin,
       72 	  2 table		(0 refer (symht.size)),
       73 	  ( 3 defp	bit (18),
       74 	    3 pad		bit (18)
       75 	    )		unal;
       76 
       77 dcl	1 seght		based aligned,		/* segment name def hash table */
       78 	  2 size		fixed bin,
       79 	  2 table		(0 refer (seght.size)),
       80 	  ( 3 defp	bit (18),
       81 	    3 headp	bit (18)
       82 	    )		unal;
       83 
       84 dcl	1 auxt		based aligned,		/* auxiliary symbol table */
       85 	  2 size		fixed bin,
       86 	  2 table		(0 refer (auxt.size)),
       87 	  ( 3 defp	bit (18),
       88 	    3 headp	bit (18)
       89 	    )		unal;
       90 
       91 dcl	1 accname		based aligned,
       92 	( 2 lth		fixed bin (8),
       93 	  2 chr		char (0 refer (accname.lth))
       94 	  )		unal;
       95 
       96 dcl	1 bound_seg_comp	aligned like comp auto;	/* dummy comp table entry for bound segment */
       97 
       98 dcl	1 bound_seg_seg	aligned like seg auto;	/* dummy seg table entry for bound segment */
       99 
      100 dcl	1 symbol_table_is	aligned like is auto;	/* dummy is entry for symbol_table */
      101 
      102 dcl	1 bind_map_is	aligned like is auto;	/* dummy insym entry for bind_map */
      103 
      104 
  1     1 /****  START OF:	bindext.incl.pl1			 *  *  *  *  *  */
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(86-06-14,Elhard), approve(86-06-14,MCR7198),
  1     6*     audit(86-06-30,Weaver):
  1     7*     Added declarations for bx_$caller and bx_$temp_bsegp.
  1     8*                                                   END HISTORY COMMENTS */
  1     9 
  1    10 /* DECLARATION OF BINDER'S MAIN DATABASE */
  1    11 
  1    12 /* include file bindext.incl.pl1 */
  1    13 
  1    14 /* Modified Sept 1978 by David Spector for using "get_temp_segment_" in temp_mgr_ */
  1    15 /* Modified Dec 1978 by David Spector for making repatch table automatically extensible */
  1    16 /* Modified 01/15/81 W. Olin Sibert for new options */
  1    17 
  1    18 declare  bx_$vers_name char (168) aligned external;	/* ASCII version name, in ACC form */
  1    19 declare  bx_$vers_number fixed bin external;		/* integer part of version number */
  1    20 declare  bx_$size fixed bin external;			/* size of main data base, for resetting */
  1    21 declare  bx_$snt_limit fixed bin external;		/* preset limit for segname table */
  1    22 declare  bx_$oddname_limit fixed bin external;		/* preset limit for oddname table */
  1    23 declare  bx_$stringmap_limit fixed bin external;		/* preset limit for stringmap table */
  1    24 declare  bx_$addname_limit fixed bin external;		/* preset limit for addname table */
  1    25 declare  bx_$area_begin fixed bin (18) external;		/* beginning of main data base */
  1    26 declare  bx_$ctp pointer external;			/* pointer to component table */
  1    27 declare  bx_$freep pointer external;			/* pointer to beginning of free area */
  1    28 declare  bx_$isp pointer external;			/* pointer to first insym table */
  1    29 declare  bx_$inpp pointer external;			/* pointer to binder's input structure */
  1    30 declare  bx_$bsegp pointer external;			/* pointer to base of new object segment */
  1    31 declare  bx_$temp pointer external;			/* pointer to threaded list of temp segments */
  1    32 declare  bx_$optp pointer external;			/* pointer to options table */
  1    33 declare  bx_$odnp pointer external;			/* pointer to oddname table */
  1    34 declare  bx_$first_rptp pointer external;		/* pointer to first chunk of repatch table */
  1    35 declare  bx_$last_rptp pointer external;		/* pointer to current chunk of threaded repatch table */
  1    36 declare  bx_$adnp pointer external;			/* pointer to addname table */
  1    37 declare  bx_$bindmap_def pointer external;		/* pointer to new object's "bind_map" definition */
  1    38 declare  bx_$bdefp pointer external;			/* pointer to new object's definition section */
  1    39 declare  bx_$bstatp pointer external;			/* pointer to new object's static section */
  1    40 declare  bx_$blnkp pointer external;			/* pointer to new object's linkage section */
  1    41 declare  bx_$bsymp pointer external;			/* pointer to new object's symbol section */
  1    42 declare  bx_$sntp pointer external;			/* pointer to segname table */
  1    43 declare  bx_$tdefp pointer external;			/* pointer to temporary new definition section */
  1    44 declare  bx_$tintp pointer external;			/* pointer to temporary new internal static */
  1    45 declare  bx_$tlinkp pointer external;			/* pointer to temporary new linkage section */
  1    46 declare  bx_$strmp pointer external;			/*  pointer to stringmap table */
  1    47 declare  bx_$n_firstrefs fixed bin external;		/* count of components with firstref traps */
  1    48 declare  bx_$bound_segname char (32) aligned external;	/* name of new bound object */
  1    49 declare  bx_$fatal_error fixed bin external;		/* 1 -> fatal error was detected */
  1    50 declare  bx_$bseg_acinfop pointer external;		/* new object's acinfop for "tssi_" */
  1    51 declare  bx_$bseg_bitcount fixed bin (24) external;	/* new object's bitcount */
  1    52 declare  bx_$o_lng fixed bin (19) external;		/* length of new bound object */
  1    53 declare  bx_$t_lng fixed bin (18) external;		/* length of new text section */
  1    54 declare  bx_$d_lng fixed bin (18) external;		/* length of new definition section */
  1    55 declare  bx_$i_lng fixed bin external;			/* length of new static section */
  1    56 declare  bx_$l_lng fixed bin external;			/* length of new linkage section */
  1    57 declare  bx_$s_lng fixed bin (18) external;		/* length of new symbol section */
  1    58 declare  bx_$addname fixed bin external;		/* 1 -> addname option specified */
  1    59 declare  bx_$debug fixed bin external;			/* 1 -> debug option was specified */
  1    60 declare  bx_$brief fixed bin external;			/* 1 -> brief option was specified */
  1    61 declare  bx_$force_order fixed bin external;		/* 1 -> -force_order specified on command line */
  1    62 declare  bx_$has_sep_stat fixed bin external;		/* 1 -> a comp has nonzero sep static */
  1    63 declare  bx_$has_comb_stat fixed bin external;		/* 1 -> a comp has nonzero combined static */
  1    64 declare  bx_$bound_sep_stat fixed bin external;		/* 1 -> bound segment has separate static */
  1    65 declare  bx_$perprocess_static fixed bin external;	/* 1 -> bound segment has perprocess static switch on */
  1    66 declare  bx_$standard fixed bin external;		/* 1 -> bound seg is in standard format */
  1    67 declare  bx_$bproc fixed bin external;			/* 1 -> at least one component is a procedure */
  1    68 declare  bx_$textlng fixed bin (18) external;		/* length of new pure text portion */
  1    69 declare  bx_$curdeflng fixed bin (18) external;		/* current length of new definition section */
  1    70 declare  bx_$tintlng fixed bin external;		/* current length of new internal static */
  1    71 declare  bx_$maxlinklng fixed bin external;		/* maximum size linkage section may attain */
  1    72 declare  bx_$maxdeflng fixed bin (18) external;		/* maximum size definition section may attain */
  1    73 declare  bx_$tlinklng fixed bin external;		/* current size of linkage section */
  1    74 declare  bx_$ncomp fixed bin external;			/* number of component objects to be bound */
  1    75 declare  bx_$v_lng fixed bin external;			/* length of version name string */
  1    76 declare  bx_$n_lng fixed bin external;			/* length of bound segment name string */
  1    77 declare  bx_$nsymdefs fixed bin external;		/* count of non-null symbol definitions */
  1    78 declare  bx_$nsegdefs fixed bin external;		/* count of non-null segment name definitions */
  1    79 declare  bx_$temp_bsegp ptr external;			/* pointer to the temporary bound seg in the process dir */
  1    80 declare  bx_$caller char (32) aligned external;		/* name of the caller of bind_ for error messages */
  1    81 
  1    82 /****  END OF:	bindext.incl.pl1			 *  *  *  *  *  */
      105 
      106 
      107 
  2     1 	/* Include file comptbl.incl.pl1 */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(85-09-24,Elhard), approve(85-09-24,MCR7198),
  2     6*     audit(86-06-30,Weaver), install(86-07-16,MR12.0-1094):
  2     7*     added link_regeneration_table pointer (clrtp) to component structure.
  2     8*                                                   END HISTORY COMMENTS */
  2     9 
  2    10 declare	(ctp, ctep) pointer;
  2    11 
  2    12 declare	comp_tbl(1000) pointer based(ctp);
  2    13 
  2    14 
  2    15 
  2    16 declare	1 comp aligned based(ctep),		/* declaration of a component entry */
  2    17 	2 filename char(32) aligned,		/* object segment's file name */
  2    18 	2 compiler char(8) aligned,		/* name of compiler which produced this object */
  2    19 	2 format char(8) aligned,		/* format of object code (PL/1, ALM etc.)  */
  2    20 
  2    21 	2 ctxtp pointer,			/* pointer to base of text section */
  2    22 	2 cdefp pointer,			/* pointer to definitions */
  2    23 	2 cstatp pointer,			/* pointer to static section */
  2    24 	2 clnkp pointer,			/* pointer to head of linkage section */
  2    25 	2 csymp pointer,			/* pointer to symbol table */
  2    26 	2 cfrtp pointer,			/* pointer to first ref trap array */
  2    27 	2 crltp pointer,			/* pointer to rel-text */
  2    28 	2 crllp pointer,			/* pointer to rel-link */
  2    29 	2 crlsp pointer,			/* pointer to rel-symb */
  2    30 	2 insymentp pointer,		/* pointer to this component's insym table entry */
  2    31 	2 clrtp pointer,			/* pointer to link_regeneration_table */
  2    32 	2 unused_1 pointer,			/* reserve */
  2    33 	2 unused_2 pointer,			/* reserve */
  2    34 	2 unused_3 fixed bin,		/* reserve */
  2    35 	2 cindex fixed bin,			/* this entry's index in table */
  2    36 	2 standard_object fixed bin,		/* 1 -> this object has standard format */
  2    37 	2 defthread fixed bin,		/* beginning of comp's definition block */
  2    38 	2 fn_lng fixed bin,			/* length of filename string */
  2    39 	2 ignore fixed bin,			/* 1->ignore erroneous entry */
  2    40 	2 io_table fixed bin,		/* 1 -> symbol table needed for io */
  2    41 	2 table_deleted fixed bin,		/* 1 -> symbol table is being deleted */
  2    42 	2 separate_static fixed bin,		/* 1 -> component has nonzero separate static */
  2    43          (2 defblockp,			/* rel pointer to component's definition block */
  2    44 	2 current_def) bit(18) unaligned,	/* rel pointer to component's current def */
  2    45 	2 cbitcount fixed bin(24),		/* bitcount of component segment */
  2    46 	2 clngt fixed bin(18),		/* length of pure text section */
  2    47 	2 cpadt fixed bin,			/* number of added padwords for text */
  2    48 	2 clngd fixed bin(18),		/* length of definition section */
  2    49 	2 clngi fixed bin,			/* length of internal static */
  2    50 	2 cpadi fixed bin,			/* number of added padwords for internal static  */
  2    51 	2 clngs fixed bin(18),		/* length of original symbol table */
  2    52 	2 clngns fixed bin(18),		/* length of new symb section stripped of relbits */
  2    53 	2 clngss fixed bin(18),		/* length of symbol section minus relbits and table */
  2    54 	2 cpads fixed bin,			/* padding length if section length is odd */
  2    55 	2 n_sym_blks fixed bin,		/* number of symbol blocks */
  2    56 
  2    57 	2 crelt fixed bin,			/* relocation value for text */
  2    58 	2 creli fixed bin,			/* relocation value for internal static */
  2    59 	2 crels fixed bin,			/* relocation value for symbol section */
  2    60 	2 last_item fixed bin;		/*** MUST ALWAYS BE LAST IN STRUCTURE ***/
  2    61  
  2    62 
  2    63 
      108 
      109 
      110 
  3     1 	/* Include file bndtbl.incl.pl1 */
  3     2 
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(85-09-24,Elhard), approve(85-09-24,MCR7198),
  3     6*     audit(86-06-30,Weaver), install(86-07-16,MR12.0-1094):
  3     7*     Added link_regeneration_table and eliminated the use of "p" as a pointer
  3     8*     to base structures on..
  3     9*                                                   END HISTORY COMMENTS */
  3    10 
  3    11 	/* DIVERSE BINDER TABLES */
  3    12 
  3    13 	/* Modified Oct 1978 by David Spector for hash coding snt and strm */
  3    14 	/* Modified Dec 1978 by David Spector for making repatch table
  3    15*	   automatically extensible */
  3    16 	
  3    17 declare	(sntp, adnp, odnp, rptp, rptep, strmp, lrtp) pointer;
  3    18 
  3    19 	/* The SEGNAME table  -  segnames and synonyms of all components */
  3    20 
  3    21 declare	1 snt aligned based(sntp),
  3    22 	2 hash_table (0:210) unaligned ptr,	/* prime length */
  3    23 	2 max_size fixed bin,		/* size limit of allocated segname table */
  3    24 	2 n_names fixed bin,		/* number of segname-table entries used */
  3    25 	2 entry(1000) like seg;
  3    26 
  3    27 	/* declaration of a SEGNAME entry */
  3    28 
  3    29 declare	1 seg aligned based,		/* redeclaration of a single segname */
  3    30 	  2 name char(33) aligned,		/* segname in ACC string format */
  3    31 	  2 lng fixed bin,			/* length of segname, incl ACC count */
  3    32 	  2 addname fixed bin,		/* 1-> add name to bound segment */
  3    33 	  2 defrel bit(18),			/* offset in defs of new definition */
  3    34 	  2 comp pointer,			/* pointer to associated component table */
  3    35 	  2 hash_thread ptr;		/* thread to next "seg" in bucket */
  3    36 
  3    37 
  3    38 	/* the ADDNAME table  - list of names specified by "Addname" statement */
  3    39 
  3    40 declare	1 an aligned based(adnp),
  3    41 	2 max_size fixed bin,		/* size limit of addname table */
  3    42 	2 n_an fixed bin,			/* number of names to add */
  3    43 	2 syn(1000) char(32) aligned;		/* contains the names to be added */
  3    44 
  3    45 
  3    46 	/* The ODDNAME table  -  scratchpad memory to suppress redundant error messages */
  3    47 
  3    48 declare	1 od aligned based(odnp),
  3    49 	2 max_size fixed bin,		/* max size of table */
  3    50 	2 n_odds fixed bin,			/* current size of table */
  3    51 	2 entry(1000),
  3    52 	  3 name char(289) aligned;
  3    53 
  3    54 
  3    55 	/* The REPATCH table  -  of halfwords to be relocated at a later time */
  3    56 
  3    57 declare	1 rpt aligned based(rptp),
  3    58 	2 thread unaligned ptr,			/* To next rpt (null at end) */
  3    59 	2 npt fixed bin,
  3    60 	2 entry(1000) like rpte aligned;
  3    61 
  3    62 
  3    63 declare	1 rpte aligned based(rptep),		/* declaration of single repatch table entry */
  3    64 	2 poffset bit(18) unaligned,		/* offset into text of word to be patched */
  3    65 	2 pexpr bit(18) unaligned,		/* value to add to patched halfword */
  3    66 	2 halfword char(3) aligned,		/* designates wordhalf to be patched */
  3    67 	2 pbase char(1) unaligned,		/* section designator of word to be patched */
  3    68 	2 code char(1) unaligned;		/* code of section base to be used as patch value */
  3    69 
  3    70 
  3    71 	/* The STRINGMAP table - to avoid redundant strings in definition section */
  3    72 
  3    73 declare	1 strm aligned based(strmp),
  3    74 	2 hash_table (0:862) fixed bin(17),	/* prime length */
  3    75 	2 max_size fixed bin,
  3    76 	2 nstr fixed bin,
  3    77 	2 entry(2048) unaligned,
  3    78 	  3 map bit(18),			/* rel pointer to string in def section */
  3    79 	  3 hash_thread fixed bin(17);	/* index of next strm.entry in hash bucket */
  3    80 
  3    81 	/* The LINK_REGENERATION table - to flag links which have and  */
  3    82 	/* have not been regenerated to insure generation of all links */
  3    83 	
  3    84 declare	1 lrt		aligned based (lrtp),
  3    85 	  2 count		fixed bin,
  3    86 	  2 start_offset	fixed bin (18) unsigned,
  3    87 	  2 regenerated (0 refer (lrt.count))
  3    88 			bit (18) unaligned;
  3    89 
  3    90 declare	UNRESOLVED	bit (18) static options (constant) init ("000000"b3);
  3    91 declare	INTERNALLY_RESOLVED	bit (18) static options (constant) init ("777777"b3);
      111 
      112 
      113 
  4     1 	/* Include file insym.incl.pl1 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(86-06-14,Elhard), approve(86-06-14,MCR7198),
  4     6*     audit(86-06-30,Weaver), install(86-07-16,MR12.0-1094):
  4     7*     Changed to eliminate the use of "p" as a pointer to base the structures
  4     8*     on.
  4     9*                                                   END HISTORY COMMENTS */
  4    10 
  4    11 
  4    12 declare	1 insym aligned based,		/* declaration of the INSYM structure */
  4    13 
  4    14 	2 thread pointer,			/* pointer to the next insym structure */
  4    15 	2 n_insyms fixed bin,		/* number of insym entries */
  4    16 	(2 retained,			/* def(s) have been retained for this component */
  4    17 	2 global_nolink) bit(1) unaligned,	/* don't prelink any reference to/from this object */
  4    18 	2 entry(1000) like is;
  4    19 
  4    20 declare	1 is aligned based,
  4    21          (2 next_ext_ptr bit(18),		/* thread to next def */
  4    22 	2 trap_ptr bit(18),			/* trap pointer */
  4    23 	2 value bit(18),			/* symbol's offset value */
  4    24 	2 class bit(18)) unaligned,		/* corresponding section of the object */
  4    25 	2 def_offset fixed bin(18),		/* offset of def in original def section */
  4    26 	2 symbol char(257) aligned,		/* the symbol in ACC string form */
  4    27 	2 lng fixed bin,			/* length in chars of ACC string (incl. ACC count) */
  4    28 	2 nargs fixed bin,			/* # of args expected by entry */
  4    29 	2 descr_ptr pointer,		/* ptr to descriptor ptr array */
  4    30          (2 null_entry,			/* 1->type 3 (seg|expr) entry, no insym symbol */
  4    31 	2 snapped,			/* 0->not referenced, 1->link snapped */
  4    32 	2 has_descr,			/* 1->entry has valid descriptors */
  4    33 	2 entrypoint,			/* 0->segdef, 1->entrypoint; meaningful only for standard */
  4    34 	2 retain_flag,			/* 1->turn on retain flag; was on in original */
  4    35 	2 delete,				/* 1->don't regenerate this def in any case */
  4    36 	2 ignore,				/* 1->regenerate but ignore */
  4    37 	2 regenerated,			/* this definition already regenerated */
  4    38 	2 retain,				/* 0->don't regenerate, 1->retain definition */
  4    39 	2 no_link,			/* don't prelink to this symbol */
  4    40 	2 duplicate) bit(1) unaligned,	/* this symbol name duplicated in another block */
  4    41 	2 defrel bit (18);			/* offset in defs of regenerated definition */
  4    42 
  4    43 
  4    44 
      114 
      115 
      116 
  5     1 /* BEGIN INCLUDE FILE definition.incl.pl1 */
  5     2 
  5     3 
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  5     7*     audit(86-07-18,DGHowe), install(86-11-20,MR12.0-1222):
  5     8*     Modified to add indirect bit to definition flags.
  5     9*                                                   END HISTORY COMMENTS */
  5    10 
  5    11 
  5    12 dcl	1 definition	aligned based,
  5    13 	2 forward		unal bit(18),	/* offset of next def */
  5    14 	2 backward	unal bit(18),	/* offset of previous def */
  5    15 	2 value		unal bit(18),
  5    16 	2 flags		unal,
  5    17 	  3 new		bit(1),
  5    18 	  3 ignore	bit(1),
  5    19 	  3 entry		bit(1),
  5    20 	  3 retain	bit(1),
  5    21 	  3 argcount	bit(1),
  5    22 	  3 descriptors	bit(1),
  5    23 	  3 indirect	bit(1),
  5    24 	  3 unused	bit(8),
  5    25 	2 class		unal bit(3),
  5    26 	2 symbol		unal bit(18),	/* offset of ACC for symbol */
  5    27 	2 segname		unal bit(18);	/* offset of segname def */
  5    28 
  5    29 /* END INCLUDE FILE definition.incl.pl1 */
      117 
      118 
      119 
      120 /* first we generate a dummy component entry for the bound segment	*/
      121 /* table as well as dummy insym entries for the bind map and symbol	*/
      122 /* table.						*/
      123 
      124 
      125 	ctp = bx_$ctp;				/* Get pointer to component table. */
      126 
      127 	unspec (bound_seg_comp) = "0"b;		/* Prepare to make dummy comp table entry. */
      128 	defrel = bx_$tdefp -> definition.forward;	/* Get rel ptr to seg def for bound segment. */
      129 	bound_seg_comp.defthread = bin (defrel, 18);	/* Place in dummy comp table entry. */
      130 
      131 	unspec (bound_seg_seg) = "0"b;		/* Prepare to make dummy segname table entry. */
      132 	bound_seg_seg.comp = addr (bound_seg_comp);
      133 	defp = addrel (bx_$tdefp, defrel);		/* Get pointer to definition. */
      134 	bound_seg_seg.defrel = defrel;
      135 	namep = addrel (bx_$tdefp, defp -> definition.symbol);
      136 						/* Get pointer to name. */
      137 	unspec (substr (bound_seg_seg.name, 1, namep -> accname.lth + 1)) = unspec (namep -> accname);
      138 	bound_seg_seg.lng = namep -> accname.lth + 1;	/* Copy the segment name. */
      139 
      140 	unspec (symbol_table_is) = "0"b;		/* Prepare dummy insym entry for symbol_table. */
      141 	defrel = defp -> definition.forward;		/* Get rel ptr to def for symbol_table. */
      142 	symbol_table_is.defrel = defrel;
      143 	defp = addrel (bx_$tdefp, defrel);
      144 	namep = addrel (bx_$tdefp, defp -> definition.symbol);
      145 	unspec (substr (symbol_table_is.symbol, 1, namep -> accname.lth + 1)) = unspec (namep -> accname);
      146 	symbol_table_is.lng = namep -> accname.lth + 1;	/* Copy the symbol name. */
      147 
      148 	unspec (bind_map_is) = "0"b;			/* Prepare dummy insym entry for bind_map. */
      149 	defrel = defp -> definition.forward;		/* Get rel ptr to def for bind_map. */
      150 	bind_map_is.defrel = defrel;
      151 	defp = addrel (bx_$tdefp, defrel);
      152 	namep = addrel (bx_$tdefp, defp -> definition.symbol);
      153 	unspec (substr (bind_map_is.symbol, 1, namep -> accname.lth + 1)) = unspec (namep -> accname);
      154 	bind_map_is.lng = namep -> accname.lth + 1;	/* Copy the symbol name. */
      155 
      156 
      157 /* now we scan through the component table and check each insym	*/
      158 /* to see if it is a duplicate.  If it is a duplicate, then create	*/
      159 /* a duplicate table for the symbol if necessary and then add the	*/
      160 /* duplicate to the table.					*/
      161 
      162 	axtp = addrel (bx_$tdefp, bx_$curdeflng);	/* Get pointer to end of defs. */
      163 	dupn = 0;					/* Initialize duplicate counters. */
      164 
      165 	cx = 0;					/* Start with zeroth component. */
      166 	ctep = addr (bound_seg_comp);			/* Point to fake comp for bound segment. */
      167 	sp = addr (bind_map_is);			/* Point to fake insym entry for bind_map. */
      168 	call dup_search;				/* Search for duplicate name. */
      169 	sp = addr (symbol_table_is);			/* Point to fake insym entry for symbol_table. */
      170 	call dup_search;				/* Search for duplicate name. */
      171 
      172 	do cx = 1 to bx_$ncomp;			/* Iterate through components. */
      173 	     ctep = comp_tbl (cx);			/* Get pointer to component table entry. */
      174 	     ip = comp.insymentp;			/* Get pointer to syms for this component. */
      175 
      176 	     do sx = 1 to ip -> insym.n_insyms - 1;	/* Look through the symbols. */
      177 		sp = addr (ip -> insym.entry (sx));	/* Get pointer to symbol table entry. */
      178 
      179 		if ^(sp -> is.ignore | sp -> is.delete | sp -> is.duplicate)
      180 		then call dup_search;		/* Search for duplicate name. */
      181 	     end;
      182 	end;
      183 
      184 
      185 /* now we take all of the definitions that are not duplicates and	*/
      186 /* hash them into the definition has table.			*/
      187 
      188 	sytp = axtp;				/* Get pointer for sym hash table. */
      189 
      190 	bx_$tdefp -> definition.value = bit (bx_$curdeflng);
      191 						/* Set pointer to hash table. */
      192 
      193 	htsize = hlen (bx_$nsymdefs + 2);		/* Compute size of hash table. */
      194 	sytp -> symht.size = htsize;			/* Set size of hash table. */
      195 
      196 	sp = addr (bind_map_is);			/* Point to fake insym entry for bind_map. */
      197 	call hash_sym;				/* Make hash table entry for it. */
      198 
      199 	sp = addr (symbol_table_is);			/* Point to fake insym entry for symbol_table. */
      200 	call hash_sym;				/* Make hash table entry for it. */
      201 
      202 	do cx = 1 to bx_$ncomp;			/* Through the components again. */
      203 	     ctep = comp_tbl (cx);
      204 	     ip = comp.insymentp;
      205 
      206 	     do sx = 1 to ip -> insym.n_insyms - 1;	/* Through the symbols again. */
      207 		sp = addr (ip -> insym.entry (sx));
      208 
      209 		if ^(sp -> is.ignore | sp -> is.delete | sp -> is.duplicate)
      210 		then call hash_sym;			/* Enter symbol in hash table, if desired. */
      211 	     end;
      212 	end;
      213 
      214 	bx_$curdeflng = bx_$curdeflng + sytp -> symht.size + 1;
      215 						/* Increase size of defs. */
      216 
      217 
      218 /* if there were no duplicates, we return now, otherwise we create	*/
      219 /* a component hash table from the segment name table.		*/
      220 
      221 	if dupn = 0
      222 	then /* If no duplicated names ... */
      223 	     return;				/* No need for seg name hash table. */
      224 
      225 	sgtp = addrel (bx_$tdefp, bx_$curdeflng);	/* Get pointer to seg name hash table. */
      226 
      227 	htsize = hlen (bx_$nsegdefs + 1);		/* Compute size of seg name hash table. */
      228 	sgtp -> seght.size = htsize;			/* Fill in size of table. */
      229 
      230 	sp = addr (bound_seg_seg);			/* Point to fake seg entry for bound segment. */
      231 	call hash_seg;				/* Insert in hash table. */
      232 
      233 	sntp = bx_$sntp;				/* Get pointer to segment name table. */
      234 	do sx = 1 to sntp -> snt.n_names;		/* Go through the segment name table. */
      235 	     sp = addr (sntp -> snt.entry (sx));	/* Get pointer to segment name table entry. */
      236 
      237 	     if sp -> seg.defrel
      238 	     then /* If this is a real name ... */
      239 		call hash_seg;			/* Insert seg name in hash table. */
      240 	end;
      241 
      242 	bx_$curdeflng = bx_$curdeflng + sgtp -> seght.size + 1;
      243 						/* Compute final size of defs. */
      244 
      245 
      246 	return;					/* All finished. */
      247 
      248 
      249 dup_search:
      250      proc;
      251 
      252 /**********************************************************************/
      253 /*							*/
      254 /*	Name:	dup_search				*/
      255 /*	Input:	cx, sp					*/
      256 /*	Function:	given a component table index (cx) and a pointer	*/
      257 /*		to an insym entry (sp), scan all of the later	*/
      258 /*		components insym lists for another definition	*/
      259 /*		with the same name.  If duplicate definitions are	*/
      260 /*		found, create a duplicate table, add all of the	*/
      261 /*		duplicates to it, flag that the duplicates are	*/
      262 /*		duplicates, and change the rel_ptr in the insym	*/
      263 /*		for the original to point to the duplicate table	*/
      264 /*		rather than the definition itself.		*/
      265 /*	Output:	duplicate table, dupn			*/
      266 /*							*/
      267 /**********************************************************************/
      268 
      269 	axx = 0;					/* Initialize auxiliary table index. */
      270 	do cx1 = cx + 1 to bx_$ncomp;			/* Look at the rest of the components. */
      271 	     ctep1 = comp_tbl (cx1);
      272 	     ip1 = ctep1 -> comp.insymentp;
      273 
      274 	     do sx1 = 1 to ip1 -> insym.n_insyms - 1;
      275 		sp1 = addr (ip1 -> insym.entry (sx1));
      276 
      277 		if ^(sp1 -> is.ignore | sp1 -> is.delete)
      278 		then if substr (sp -> is.symbol, 1, sp -> is.lng) = substr (sp1 -> is.symbol, 1, sp1 -> is.lng)
      279 		     then do;
      280 			if axx = 0
      281 			then do;			/* If this is first occurrence of duplicate ... */
      282 			     axx = 1;		/* Initialize index. */
      283 			     axtp -> auxt.defp (1) = sp -> is.defrel;
      284 						/* Fill in first entry. */
      285 			     axtp -> auxt.headp (1) = bit (bin (comp.defthread, 18));
      286 			     sp -> is.defrel = bit (bx_$curdeflng, 18);
      287 			end;			/* Save rel ptr to aux table instead of def. */
      288 
      289 			axx = axx + 1;		/* Step index. */
      290 			axtp -> auxt.defp (axx) = sp1 -> is.defrel;
      291 						/* Fill in another entry. */
      292 			axtp -> auxt.headp (axx) = bit (bin (ctep1 -> comp.defthread, 18));
      293 			sp1 -> is.duplicate = "1"b;	/* Indicate symbol was a duplicate. */
      294 		     end;
      295 
      296 
      297 	     end;
      298 	end;
      299 
      300 	if axx ^= 0
      301 	then do;					/* If we found a dup ... */
      302 	     axtp -> auxt.size = axx;			/* Fill in size of aux table. */
      303 	     bx_$curdeflng = bx_$curdeflng + axx + 1;	/* Increase length of defs. */
      304 	     axtp = addrel (axtp, axx + 1);		/* Get new aux table pointer. */
      305 	     dupn = dupn + 1;			/* Count another duplicated name. */
      306 	end;
      307 
      308 
      309      end dup_search;
      310 
      311 
      312 hash_sym:
      313      proc;
      314 
      315 
      316 /**********************************************************************/
      317 /*							*/
      318 /*	Name:	hash_sym					*/
      319 /*	Input:	sp					*/
      320 /*	Function:	inserts the relp for the specified definition	*/
      321 /*		into the definition hash table.  The entry is	*/
      322 /*		inserted into the first empty slot at of after	*/
      323 /*		the index calculated by the hash function.	*/
      324 /*	Output:	none					*/
      325 /*							*/
      326 /**********************************************************************/
      327 
      328 	namep = addr (sp -> is.symbol);		/* Get pointer to first word of ACC string. */
      329 	symx = hash ();				/* Hash the name. */
      330 
      331 	do while (sytp -> symht.defp (symx));		/* Find empty slot in hash table. */
      332 	     symx = mod (symx, htsize) + 1;
      333 	end;
      334 
      335 	sytp -> symht.defp (symx) = sp -> is.defrel;	/* Set pointer in hash table entry. */
      336 
      337 
      338 
      339      end hash_sym;
      340 
      341 
      342 hash_seg:
      343      proc;
      344 
      345 /**********************************************************************/
      346 /*							*/
      347 /*	Name:	hash_seg					*/
      348 /*	Input:	sp					*/
      349 /*	Function:	given a pointer to an insym entry, inserts a relp	*/
      350 /*		for that definition into the first empty slot in	*/
      351 /*		the component hash table at of after the index	*/
      352 /*		generated by the hashing function.		*/
      353 /*	Output:	none					*/
      354 /*							*/
      355 /**********************************************************************/
      356 
      357 	namep = addr (sp -> seg.name);
      358 	segx = hash ();
      359 
      360 	do while (sgtp -> seght.defp (segx));		/* Find an empty slot in the hash table. */
      361 	     segx = mod (segx, htsize) + 1;
      362 	end;
      363 
      364 	sgtp -> seght.defp (segx) = sp -> seg.defrel;	/* Set def pointer in hash table entry. */
      365 	ctep = sp -> seg.comp;			/* Get address of component table entry. */
      366 	sgtp -> seght.headp (segx) = bit (bin (ctep -> comp.defthread, 18));
      367 						/* Set pointer to first segname def. */
      368 
      369 
      370      end hash_seg;
      371 
      372 
      373 hash:
      374      proc returns (fixed bin);
      375 
      376 /**********************************************************************/
      377 /*							*/
      378 /*	Name:	hash					*/
      379 /*	Input:	namep, htsize				*/
      380 /*	Function:	given a pointer to an acc string, calculates the	*/
      381 /*		hash function on it and returns the index.  The	*/
      382 /*		hash function used is the remainder of the first	*/
      383 /*		word of the acc string (count and first three	*/
      384 /*		characters) divided by the size of the hash table	*/
      385 /*	Output:	hash_index				*/
      386 /*							*/
      387 /**********************************************************************/
      388 
      389 dcl	word		fixed bin (35) based;	/* first word of name */
      390 
      391 
      392 	return (mod (namep -> word, htsize) + 1);
      393 
      394 
      395      end hash;
      396 
      397 
      398 
      399 hlen:
      400      proc (s) returns (fixed bin);
      401 
      402 /**********************************************************************/
      403 /*							*/
      404 /*	Name:	hlen					*/
      405 /*	Input:	s					*/
      406 /*	Function:	given the number of definitions to be placed into	*/
      407 /*		a hash table, returns the size of the hash table	*/
      408 /*		The hash table is sized such that it is not more	*/
      409 /*		than 80% full.				*/
      410 /*	Output:	htsize					*/
      411 /*							*/
      412 /**********************************************************************/
      413 
      414 dcl	s		fixed bin;		/* required hash buckets */
      415 
      416 dcl	s1		fixed bin,		/* minimum hash table size desired */
      417 	i		fixed bin;		/* iteration variable */
      418 
      419 dcl	sizes		(11) fixed bin static options (constant)
      420 			init (13, 27, 53, 89, 157, 307, 503, 733, 1009, 1451, 2003);
      421 
      422 
      423 	s1 = s * 1.25e0;				/* Allow for 20% of buckets to be empty. */
      424 	do i = 1 to hbound (sizes, 1);		/* Pick an appropriate sizes. */
      425 	     if s1 <= sizes (i)
      426 	     then return (sizes (i));
      427 	end;
      428 	return (s1);				/* Default for very large hash tables. */
      429 
      430 
      431      end hlen;
      432 
      433 
      434 
      435 
      436      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/20/86  1145.0  hash_defs_.pl1                    >special_ldd>install>MR12.0-1222>hash_defs_.pl1
105          1    07/16/86  1222.1  bindext.incl.pl1                  >ldd>include>bindext.incl.pl1
108          2    07/16/86  1222.1  comptbl.incl.pl1                  >ldd>include>comptbl.incl.pl1
111          3    07/16/86  1222.1  bndtbl.incl.pl1                   >ldd>include>bndtbl.incl.pl1
114          4    07/16/86  1222.1  insym.incl.pl1                    >ldd>include>insym.incl.pl1
117          5    11/20/86  1035.2  definition.incl.pl1               >special_ldd>install>MR12.0-1222>definition.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
accname                                based           structure                level 1 dcl 91 ref 137 145 153
addr                                                   builtin function         dcl 67 ref 132 166 167 169 177 196 199 207 230 235
                                                                                  275 328 357
addrel                                                 builtin function         dcl 67 ref 133 135 143 144 151 152 162 225 304
auxt                                   based           structure                level 1 dcl 84
axtp                            000132 automatic       pointer                  dcl 52 set ref 162* 188 283 285 290 292 302 304* 304
axx                             000134 automatic       fixed bin(17,0)          dcl 52 set ref 269* 280 282* 289* 289 290 292 300
                                                                                  302 303 304
bin                                                    builtin function         dcl 67 ref 129 285 292 366
bind_map_is                     000372 automatic       structure                level 1 dcl 102 set ref 148* 167 196
bit                                                    builtin function         dcl 67 ref 190 285 286 292 366
bound_seg_comp                  000140 automatic       structure                level 1 dcl 96 set ref 127* 132 166
bound_seg_seg                   000240 automatic       structure                level 1 dcl 98 set ref 131* 230
bx_$ctp                         000010 external static pointer                  dcl 1-26 ref 125
bx_$curdeflng                   000016 external static fixed bin(18,0)          dcl 1-69 set ref 162 190 214* 214 225 242* 242 286
                                                                                  303* 303
bx_$ncomp                       000020 external static fixed bin(17,0)          dcl 1-74 ref 172 202 270
bx_$nsegdefs                    000024 external static fixed bin(17,0)          dcl 1-78 ref 227
bx_$nsymdefs                    000022 external static fixed bin(17,0)          dcl 1-77 ref 193
bx_$sntp                        000012 external static pointer                  dcl 1-42 ref 233
bx_$tdefp                       000014 external static pointer                  dcl 1-43 ref 128 133 135 143 144 151 152 162 190 225
comp                                   based           structure                level 1 dcl 2-16 in procedure "hash_defs_"
comp                     14     000240 automatic       pointer                  level 2 in structure "bound_seg_seg" dcl 98
                                                                                  in procedure "hash_defs_" set ref 132*
comp                     14            based           pointer                  level 2 in structure "seg" dcl 3-29 in procedure
                                                                                  "hash_defs_" ref 365
comp_tbl                               based           pointer                  array dcl 2-12 ref 173 203 271
ctep                            000506 automatic       pointer                  dcl 2-10 set ref 166* 173* 174 203* 204 285 365* 366
ctep1                           000104 automatic       pointer                  dcl 52 set ref 271* 272 292
ctp                             000504 automatic       pointer                  dcl 2-10 set ref 125* 173 203 271
cx                              000120 automatic       fixed bin(17,0)          dcl 52 set ref 165* 172* 173* 202* 203* 270
cx1                             000121 automatic       fixed bin(17,0)          dcl 52 set ref 270* 271*
definition                             based           structure                level 1 dcl 5-12
defp                            000126 automatic       pointer                  dcl 52 in procedure "hash_defs_" set ref 133* 135
                                                                                  141 143* 144 149 151* 152
defp                      1            based           bit(18)                  array level 3 in structure "symht" packed unaligned
                                                                                  dcl 70 in procedure "hash_defs_" set ref 331 335*
defp                      1            based           bit(18)                  array level 3 in structure "seght" packed unaligned
                                                                                  dcl 77 in procedure "hash_defs_" set ref 360 364*
defp                      1            based           bit(18)                  array level 3 in structure "auxt" packed unaligned
                                                                                  dcl 84 in procedure "hash_defs_" set ref 283* 290*
defrel                   13            based           bit(18)                  level 2 in structure "seg" dcl 3-29 in procedure
                                                                                  "hash_defs_" ref 237 364
defrel                  111     000372 automatic       bit(18)                  level 2 in structure "bind_map_is" dcl 102
                                                                                  in procedure "hash_defs_" set ref 150*
defrel                   13     000240 automatic       bit(18)                  level 2 in structure "bound_seg_seg" dcl 98
                                                                                  in procedure "hash_defs_" set ref 134*
defrel                  111            based           bit(18)                  level 2 in structure "is" dcl 4-20 in procedure
                                                                                  "hash_defs_" set ref 283 286* 290 335
defrel                  111     000260 automatic       bit(18)                  level 2 in structure "symbol_table_is" dcl 100
                                                                                  in procedure "hash_defs_" set ref 142*
defrel                          000124 automatic       bit(18)                  dcl 52 in procedure "hash_defs_" set ref 128* 129
                                                                                  133 134 141* 142 143 149* 150 151
defthread                51     000140 automatic       fixed bin(17,0)          level 2 in structure "bound_seg_comp" dcl 96
                                                                                  in procedure "hash_defs_" set ref 129*
defthread                51            based           fixed bin(17,0)          level 2 in structure "comp" dcl 2-16 in procedure
                                                                                  "hash_defs_" ref 285 292 366
delete                  110(05)        based           bit(1)                   level 2 packed unaligned dcl 4-20 ref 179 209 277
duplicate               110(10)        based           bit(1)                   level 2 packed unaligned dcl 4-20 set ref 179 209
                                                                                  293*
dupn                            000135 automatic       fixed bin(17,0)          dcl 52 set ref 163* 221 305* 305
entry                   326            based           structure                array level 2 in structure "snt" dcl 3-21
                                                                                  in procedure "hash_defs_" set ref 235
entry                     4            based           structure                array level 2 in structure "insym" dcl 4-12
                                                                                  in procedure "hash_defs_" set ref 177 207 275
forward                                based           bit(18)                  level 2 packed unaligned dcl 5-12 ref 128 141 149
hbound                                                 builtin function         dcl 67 ref 424
headp                     1(18)        based           bit(18)                  array level 3 in structure "auxt" packed unaligned
                                                                                  dcl 84 in procedure "hash_defs_" set ref 285* 292*
headp                     1(18)        based           bit(18)                  array level 3 in structure "seght" packed unaligned
                                                                                  dcl 77 in procedure "hash_defs_" set ref 366*
htsize                          000136 automatic       fixed bin(17,0)          dcl 52 set ref 193* 194 227* 228 332 361 392
i                               000561 automatic       fixed bin(17,0)          dcl 416 set ref 424* 425 425*
ignore                  110(06)        based           bit(1)                   level 2 packed unaligned dcl 4-20 ref 179 209 277
insym                                  based           structure                level 1 dcl 4-12
insymentp                36            based           pointer                  level 2 dcl 2-16 ref 174 204 272
ip                              000106 automatic       pointer                  dcl 52 set ref 174* 176 177 204* 206 207
ip1                             000110 automatic       pointer                  dcl 52 set ref 272* 274 275
is                                     based           structure                level 1 dcl 4-20
lng                     104            based           fixed bin(17,0)          level 2 in structure "is" dcl 4-20 in procedure
                                                                                  "hash_defs_" ref 277 277
lng                      11     000240 automatic       fixed bin(17,0)          level 2 in structure "bound_seg_seg" dcl 98
                                                                                  in procedure "hash_defs_" set ref 138*
lng                     104     000260 automatic       fixed bin(17,0)          level 2 in structure "symbol_table_is" dcl 100
                                                                                  in procedure "hash_defs_" set ref 146*
lng                     104     000372 automatic       fixed bin(17,0)          level 2 in structure "bind_map_is" dcl 102
                                                                                  in procedure "hash_defs_" set ref 154*
lth                                    based           fixed bin(8,0)           level 2 packed unaligned dcl 91 ref 137 137 138 145
                                                                                  145 146 153 153 154
mod                                                    builtin function         dcl 67 ref 332 361 392
n_insyms                  2            based           fixed bin(17,0)          level 2 dcl 4-12 ref 176 206 274
n_names                 324            based           fixed bin(17,0)          level 2 dcl 3-21 ref 234
name                            000240 automatic       char(33)                 level 2 in structure "bound_seg_seg" dcl 98
                                                                                  in procedure "hash_defs_" set ref 137*
name                                   based           char(33)                 level 2 in structure "seg" dcl 3-29 in procedure
                                                                                  "hash_defs_" set ref 357
namep                           000130 automatic       pointer                  dcl 52 set ref 135* 137 137 138 144* 145 145 146
                                                                                  152* 153 153 154 328* 357* 392
rpte                                   based           structure                level 1 dcl 3-63
s                                      parameter       fixed bin(17,0)          dcl 414 ref 399 423
s1                              000560 automatic       fixed bin(17,0)          dcl 416 set ref 423* 425 428
seg                                    based           structure                level 1 dcl 3-29
seght                                  based           structure                level 1 dcl 77
segx                            000117 automatic       fixed bin(17,0)          dcl 52 set ref 358* 360 361* 361 364 366
sgtp                            000114 automatic       pointer                  dcl 52 set ref 225* 228 242 360 364 366
size                                   based           fixed bin(17,0)          level 2 in structure "symht" dcl 70 in procedure
                                                                                  "hash_defs_" set ref 194* 214
size                                   based           fixed bin(17,0)          level 2 in structure "auxt" dcl 84 in procedure
                                                                                  "hash_defs_" set ref 302*
size                                   based           fixed bin(17,0)          level 2 in structure "seght" dcl 77 in procedure
                                                                                  "hash_defs_" set ref 228* 242
sizes                           000000 constant        fixed bin(17,0)          initial array dcl 419 ref 424 425 425
snt                                    based           structure                level 1 dcl 3-21
sntp                            000510 automatic       pointer                  dcl 3-17 set ref 233* 234 235
sp                              000100 automatic       pointer                  dcl 52 set ref 167* 169* 177* 179 179 179 196* 199*
                                                                                  207* 209 209 209 230* 235* 237 277 277 283 286 328
                                                                                  335 357 364 365
sp1                             000102 automatic       pointer                  dcl 52 set ref 275* 277 277 277 277 290 293
substr                                                 builtin function         dcl 67 ref 137 145 153 277 277
sx                              000122 automatic       fixed bin(17,0)          dcl 52 set ref 176* 177* 206* 207* 234* 235*
sx1                             000123 automatic       fixed bin(17,0)          dcl 52 set ref 274* 275*
symbol                    3            based           char(257)                level 2 in structure "is" dcl 4-20 in procedure
                                                                                  "hash_defs_" set ref 277 277 328
symbol                    3     000372 automatic       char(257)                level 2 in structure "bind_map_is" dcl 102
                                                                                  in procedure "hash_defs_" set ref 153*
symbol                    3     000260 automatic       char(257)                level 2 in structure "symbol_table_is" dcl 100
                                                                                  in procedure "hash_defs_" set ref 145*
symbol                    2            based           bit(18)                  level 2 in structure "definition" packed unaligned
                                                                                  dcl 5-12 in procedure "hash_defs_" ref 135 144 152
symbol_table_is                 000260 automatic       structure                level 1 dcl 100 set ref 140* 169 199
symht                                  based           structure                level 1 dcl 70
symx                            000116 automatic       fixed bin(17,0)          dcl 52 set ref 329* 331 332* 332 335
sytp                            000112 automatic       pointer                  dcl 52 set ref 188* 194 214 331 335
table                     1            based           structure                array level 2 in structure "symht" dcl 70
                                                                                  in procedure "hash_defs_"
table                     1            based           structure                array level 2 in structure "seght" dcl 77
                                                                                  in procedure "hash_defs_"
table                     1            based           structure                array level 2 in structure "auxt" dcl 84
                                                                                  in procedure "hash_defs_"
unspec                                                 builtin function         dcl 67 set ref 127* 131* 137* 137 140* 145* 145 148*
                                                                                  153* 153
value                     1            based           bit(18)                  level 2 packed unaligned dcl 5-12 set ref 190*
word                                   based           fixed bin(35,0)          dcl 389 ref 392

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
INTERNALLY_RESOLVED                    internal static bit(18)                  initial unaligned dcl 3-91
UNRESOLVED                             internal static bit(18)                  initial unaligned dcl 3-90
adnp                                   automatic       pointer                  dcl 3-17
an                                     based           structure                level 1 dcl 3-40
bx_$addname                            external static fixed bin(17,0)          dcl 1-58
bx_$addname_limit                      external static fixed bin(17,0)          dcl 1-24
bx_$adnp                               external static pointer                  dcl 1-36
bx_$area_begin                         external static fixed bin(18,0)          dcl 1-25
bx_$bdefp                              external static pointer                  dcl 1-38
bx_$bindmap_def                        external static pointer                  dcl 1-37
bx_$blnkp                              external static pointer                  dcl 1-40
bx_$bound_segname                      external static char(32)                 dcl 1-48
bx_$bound_sep_stat                     external static fixed bin(17,0)          dcl 1-64
bx_$bproc                              external static fixed bin(17,0)          dcl 1-67
bx_$brief                              external static fixed bin(17,0)          dcl 1-60
bx_$bseg_acinfop                       external static pointer                  dcl 1-50
bx_$bseg_bitcount                      external static fixed bin(24,0)          dcl 1-51
bx_$bsegp                              external static pointer                  dcl 1-30
bx_$bstatp                             external static pointer                  dcl 1-39
bx_$bsymp                              external static pointer                  dcl 1-41
bx_$caller                             external static char(32)                 dcl 1-80
bx_$d_lng                              external static fixed bin(18,0)          dcl 1-54
bx_$debug                              external static fixed bin(17,0)          dcl 1-59
bx_$fatal_error                        external static fixed bin(17,0)          dcl 1-49
bx_$first_rptp                         external static pointer                  dcl 1-34
bx_$force_order                        external static fixed bin(17,0)          dcl 1-61
bx_$freep                              external static pointer                  dcl 1-27
bx_$has_comb_stat                      external static fixed bin(17,0)          dcl 1-63
bx_$has_sep_stat                       external static fixed bin(17,0)          dcl 1-62
bx_$i_lng                              external static fixed bin(17,0)          dcl 1-55
bx_$inpp                               external static pointer                  dcl 1-29
bx_$isp                                external static pointer                  dcl 1-28
bx_$l_lng                              external static fixed bin(17,0)          dcl 1-56
bx_$last_rptp                          external static pointer                  dcl 1-35
bx_$maxdeflng                          external static fixed bin(18,0)          dcl 1-72
bx_$maxlinklng                         external static fixed bin(17,0)          dcl 1-71
bx_$n_firstrefs                        external static fixed bin(17,0)          dcl 1-47
bx_$n_lng                              external static fixed bin(17,0)          dcl 1-76
bx_$o_lng                              external static fixed bin(19,0)          dcl 1-52
bx_$oddname_limit                      external static fixed bin(17,0)          dcl 1-22
bx_$odnp                               external static pointer                  dcl 1-33
bx_$optp                               external static pointer                  dcl 1-32
bx_$perprocess_static                  external static fixed bin(17,0)          dcl 1-65
bx_$s_lng                              external static fixed bin(18,0)          dcl 1-57
bx_$size                               external static fixed bin(17,0)          dcl 1-20
bx_$snt_limit                          external static fixed bin(17,0)          dcl 1-21
bx_$standard                           external static fixed bin(17,0)          dcl 1-66
bx_$stringmap_limit                    external static fixed bin(17,0)          dcl 1-23
bx_$strmp                              external static pointer                  dcl 1-46
bx_$t_lng                              external static fixed bin(18,0)          dcl 1-53
bx_$temp                               external static pointer                  dcl 1-31
bx_$temp_bsegp                         external static pointer                  dcl 1-79
bx_$textlng                            external static fixed bin(18,0)          dcl 1-68
bx_$tintlng                            external static fixed bin(17,0)          dcl 1-70
bx_$tintp                              external static pointer                  dcl 1-44
bx_$tlinklng                           external static fixed bin(17,0)          dcl 1-73
bx_$tlinkp                             external static pointer                  dcl 1-45
bx_$v_lng                              external static fixed bin(17,0)          dcl 1-75
bx_$vers_name                          external static char(168)                dcl 1-18
bx_$vers_number                        external static fixed bin(17,0)          dcl 1-19
lrt                                    based           structure                level 1 dcl 3-84
lrtp                                   automatic       pointer                  dcl 3-17
od                                     based           structure                level 1 dcl 3-48
odnp                                   automatic       pointer                  dcl 3-17
rpt                                    based           structure                level 1 dcl 3-57
rptep                                  automatic       pointer                  dcl 3-17
rptp                                   automatic       pointer                  dcl 3-17
strm                                   based           structure                level 1 dcl 3-73
strmp                                  automatic       pointer                  dcl 3-17

NAMES DECLARED BY EXPLICIT CONTEXT.
dup_search                      000416 constant        entry                    internal dcl 249 ref 168 170 179
hash                            000631 constant        entry                    internal dcl 373 ref 329 358
hash_defs_                      000015 constant        entry                    external dcl 49
hash_seg                        000575 constant        entry                    internal dcl 342 ref 231 237
hash_sym                        000550 constant        entry                    internal dcl 312 ref 197 200 209
hlen                            000642 constant        entry                    internal dcl 399 ref 193 227

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1006        1034     714        1016
Length      1316     714        26         245      72           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
hash_defs_                          371 external procedure  is an external procedure.  
dup_search                              internal procedure  shares stack frame of external procedure hash_defs_.  
hash_sym                                internal procedure  shares stack frame of external procedure hash_defs_.  
hash_seg                                internal procedure  shares stack frame of external procedure hash_defs_.  
hash                                    internal procedure  shares stack frame of external procedure hash_defs_.  
hlen                                    internal procedure  shares stack frame of external procedure hash_defs_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
hash_defs_               000100 sp                          hash_defs_
                         000102 sp1                         hash_defs_
                         000104 ctep1                       hash_defs_
                         000106 ip                          hash_defs_
                         000110 ip1                         hash_defs_
                         000112 sytp                        hash_defs_
                         000114 sgtp                        hash_defs_
                         000116 symx                        hash_defs_
                         000117 segx                        hash_defs_
                         000120 cx                          hash_defs_
                         000121 cx1                         hash_defs_
                         000122 sx                          hash_defs_
                         000123 sx1                         hash_defs_
                         000124 defrel                      hash_defs_
                         000126 defp                        hash_defs_
                         000130 namep                       hash_defs_
                         000132 axtp                        hash_defs_
                         000134 axx                         hash_defs_
                         000135 dupn                        hash_defs_
                         000136 htsize                      hash_defs_
                         000140 bound_seg_comp              hash_defs_
                         000240 bound_seg_seg               hash_defs_
                         000260 symbol_table_is             hash_defs_
                         000372 bind_map_is                 hash_defs_
                         000504 ctp                         hash_defs_
                         000506 ctep                        hash_defs_
                         000510 sntp                        hash_defs_
                         000560 s1                          hlen
                         000561 i                           hlen

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
fx1_to_fl2          return_mac          fl2_to_fx1          mdfx1               ext_entry

NO EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
bx_$ctp                       bx_$curdeflng                 bx_$ncomp                     bx_$nsegdefs
bx_$nsymdefs                  bx_$sntp                      bx_$tdefp


CONSTANTS
000676  aa     000002000000
000677  aa     000000000000
000700  aa     600000000041
000701  aa     000117000000

000702  aa     000002000000
000703  aa     000000000000
000704  aa     600000000041
000705  aa     000116000000

000706  aa     000004000000
000707  aa     000000000000
000710  aa     600000000041
000711  aa     000562000000
000712  aa     600000000041
000713  aa     000136000000

000000  aa     000000000015
000001  aa     000000000033
000002  aa     000000000065
000003  aa     000000000131
000004  aa     000000000235
000005  aa     000000000463
000006  aa     000000000767
000007  aa     000000001335
000010  aa     000000001761
000011  aa     000000002653
000012  aa     000000003723

000013  aa     404000000021

BEGIN PROCEDURE hash_defs_
ENTRY TO hash_defs_                                         STATEMENT 1 ON LINE 49
hash_defs_:
     proc;

000014  da     000066200000
000015  aa   000600 6270 00	eax7 	384
000016  aa  7 00034 3521 20	epp2 	pr7|28,*
000017  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000020  aa     000000000000
000021  aa     000000000000
						STATEMENT 1 ON LINE 125
	ctp = bx_$ctp;

000022  la  4 00010 3735 20	epp7 	pr4|8,*		bx_$ctp
000023  aa  7 00000 3735 20	epp7 	pr7|0,*		bx_$ctp
000024  aa  6 00504 6535 00	spri7	pr6|324		ctp
						STATEMENT 1 ON LINE 127
	unspec (bound_seg_comp) = "0"b;

000025  aa  000 100 100 400	mlr  	(),(pr),fill(000)
000026  aa   000000 00 0000	desc9a	0,0
000027  aa  6 00140 00 0374	desc9a	pr6|96,252
						STATEMENT 1 ON LINE 128
	defrel = bx_$tdefp -> definition.forward;

000030  la  4 00014 3735 20	epp7 	pr4|12,*		bx_$tdefp
000031  aa  7 00000 2351 20	lda  	pr7|0,*		definition.forward
000032  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
000033  aa  6 00124 7551 00	sta  	pr6|84		defrel
						STATEMENT 1 ON LINE 129
	bound_seg_comp.defthread = bin (defrel, 18);

000034  aa   000066 7730 00	lrl  	54
000035  aa  6 00211 7561 00	stq  	pr6|137		bound_seg_comp.defthread
						STATEMENT 1 ON LINE 131
	unspec (bound_seg_seg) = "0"b;

000036  aa  000 100 100 400	mlr  	(),(pr),fill(000)
000037  aa   000000 00 0000	desc9a	0,0
000040  aa  6 00240 00 0100	desc9a	pr6|160,64
						STATEMENT 1 ON LINE 132
	bound_seg_seg.comp = addr (bound_seg_comp);

000041  aa  6 00140 3715 00	epp5 	pr6|96		bound_seg_comp
000042  aa  6 00254 6515 00	spri5	pr6|172		bound_seg_seg.comp
						STATEMENT 1 ON LINE 133
	defp = addrel (bx_$tdefp, defrel);

000043  aa   000066 7370 00	lls  	54
000044  aa  7 00000 3521 61	epp2 	pr7|0,*au		bx_$tdefp
000045  aa   000000 0520 03	adwp2	0,du
000046  aa  6 00126 2521 00	spri2	pr6|86		defp
						STATEMENT 1 ON LINE 134
	bound_seg_seg.defrel = defrel;

000047  aa  6 00253 7551 00	sta  	pr6|171		bound_seg_seg.defrel
						STATEMENT 1 ON LINE 135
	namep = addrel (bx_$tdefp, defp -> definition.symbol);

000050  aa  2 00002 2351 00	lda  	pr2|2		definition.symbol
000051  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
000052  aa  7 00000 3515 61	epp1 	pr7|0,*au		bx_$tdefp
000053  aa   000000 0510 03	adwp1	0,du
000054  aa  6 00130 2515 00	spri1	pr6|88		namep
						STATEMENT 1 ON LINE 137
	unspec (substr (bound_seg_seg.name, 1, namep -> accname.lth + 1)) = unspec (namep -> accname);

000055  aa  1 00000 2351 00	lda  	pr1|0		accname.lth
000056  aa   000077 7330 00	lrs  	63
000057  aa  6 00562 7561 00	stq  	pr6|370		accname.lth
000060  aa   000001 0760 07	adq  	1,dl
000061  aa   000011 4020 07	mpy  	9,dl
000062  aa  003 140 060 540	csl  	(pr,rl),(pr,rl),fill(0),bool(move)
000063  aa  1 00000 00 0006	descb	pr1|0,ql
000064  aa  6 00240 00 0006	descb	pr6|160,ql
						STATEMENT 1 ON LINE 138
	bound_seg_seg.lng = namep -> accname.lth + 1;

000065  aa  6 00562 2361 00	ldq  	pr6|370		accname.lth
000066  aa   000001 0760 07	adq  	1,dl
000067  aa  6 00251 7561 00	stq  	pr6|169		bound_seg_seg.lng
						STATEMENT 1 ON LINE 140
	unspec (symbol_table_is) = "0"b;

000070  aa  000 100 100 400	mlr  	(),(pr),fill(000)
000071  aa   000000 00 0000	desc9a	0,0
000072  aa  6 00260 00 0450	desc9a	pr6|176,296
						STATEMENT 1 ON LINE 141
	defrel = defp -> definition.forward;

000073  aa  2 00000 2351 00	lda  	pr2|0		definition.forward
000074  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
000075  aa  6 00124 7551 00	sta  	pr6|84		defrel
						STATEMENT 1 ON LINE 142
	symbol_table_is.defrel = defrel;

000076  aa  6 00371 7551 00	sta  	pr6|249		symbol_table_is.defrel
						STATEMENT 1 ON LINE 143
	defp = addrel (bx_$tdefp, defrel);

000077  aa  7 00000 3535 61	epp3 	pr7|0,*au		bx_$tdefp
000100  aa   000000 0530 03	adwp3	0,du
000101  aa  6 00126 2535 00	spri3	pr6|86		defp
						STATEMENT 1 ON LINE 144
	namep = addrel (bx_$tdefp, defp -> definition.symbol);

000102  aa  3 00002 2351 00	lda  	pr3|2		definition.symbol
000103  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
000104  aa  7 00000 3521 61	epp2 	pr7|0,*au		bx_$tdefp
000105  aa   000000 0520 03	adwp2	0,du
000106  aa  6 00130 2521 00	spri2	pr6|88		namep
						STATEMENT 1 ON LINE 145
	unspec (substr (symbol_table_is.symbol, 1, namep -> accname.lth + 1)) = unspec (namep -> accname);

000107  aa  2 00000 2351 00	lda  	pr2|0		accname.lth
000110  aa   000077 7330 00	lrs  	63
000111  aa  6 00562 7561 00	stq  	pr6|370		accname.lth
000112  aa   000001 0760 07	adq  	1,dl
000113  aa   000011 4020 07	mpy  	9,dl
000114  aa  003 140 060 540	csl  	(pr,rl),(pr,rl),fill(0),bool(move)
000115  aa  2 00000 00 0006	descb	pr2|0,ql
000116  aa  6 00263 00 0006	descb	pr6|179,ql
						STATEMENT 1 ON LINE 146
	symbol_table_is.lng = namep -> accname.lth + 1;

000117  aa  6 00562 2361 00	ldq  	pr6|370		accname.lth
000120  aa   000001 0760 07	adq  	1,dl
000121  aa  6 00364 7561 00	stq  	pr6|244		symbol_table_is.lng
						STATEMENT 1 ON LINE 148
	unspec (bind_map_is) = "0"b;

000122  aa  000 100 100 400	mlr  	(),(pr),fill(000)
000123  aa   000000 00 0000	desc9a	0,0
000124  aa  6 00372 00 0450	desc9a	pr6|250,296
						STATEMENT 1 ON LINE 149
	defrel = defp -> definition.forward;

000125  aa  3 00000 2351 00	lda  	pr3|0		definition.forward
000126  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
000127  aa  6 00124 7551 00	sta  	pr6|84		defrel
						STATEMENT 1 ON LINE 150
	bind_map_is.defrel = defrel;

000130  aa  6 00503 7551 00	sta  	pr6|323		bind_map_is.defrel
						STATEMENT 1 ON LINE 151
	defp = addrel (bx_$tdefp, defrel);

000131  aa  7 00000 3515 61	epp1 	pr7|0,*au		bx_$tdefp
000132  aa   000000 0510 03	adwp1	0,du
000133  aa  6 00126 2515 00	spri1	pr6|86		defp
						STATEMENT 1 ON LINE 152
	namep = addrel (bx_$tdefp, defp -> definition.symbol);

000134  aa  1 00002 2351 00	lda  	pr1|2		definition.symbol
000135  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
000136  aa  7 00000 3535 61	epp3 	pr7|0,*au		bx_$tdefp
000137  aa   000000 0530 03	adwp3	0,du
000140  aa  6 00130 2535 00	spri3	pr6|88		namep
						STATEMENT 1 ON LINE 153
	unspec (substr (bind_map_is.symbol, 1, namep -> accname.lth + 1)) = unspec (namep -> accname);

000141  aa  3 00000 2351 00	lda  	pr3|0		accname.lth
000142  aa   000077 7330 00	lrs  	63
000143  aa  6 00562 7561 00	stq  	pr6|370		accname.lth
000144  aa   000001 0760 07	adq  	1,dl
000145  aa   000011 4020 07	mpy  	9,dl
000146  aa  003 140 060 540	csl  	(pr,rl),(pr,rl),fill(0),bool(move)
000147  aa  3 00000 00 0006	descb	pr3|0,ql
000150  aa  6 00375 00 0006	descb	pr6|253,ql
						STATEMENT 1 ON LINE 154
	bind_map_is.lng = namep -> accname.lth + 1;

000151  aa  6 00562 2361 00	ldq  	pr6|370		accname.lth
000152  aa   000001 0760 07	adq  	1,dl
000153  aa  6 00476 7561 00	stq  	pr6|318		bind_map_is.lng
						STATEMENT 1 ON LINE 162
	axtp = addrel (bx_$tdefp, bx_$curdeflng);

000154  la  4 00016 2361 20	ldq  	pr4|14,*		bx_$curdeflng
000155  aa  7 00000 3521 66	epp2 	pr7|0,*ql		bx_$tdefp
000156  aa   000000 0520 03	adwp2	0,du
000157  aa  6 00132 2521 00	spri2	pr6|90		axtp
						STATEMENT 1 ON LINE 163
	dupn = 0;

000160  aa  6 00135 4501 00	stz  	pr6|93		dupn
						STATEMENT 1 ON LINE 165
	cx = 0;

000161  aa  6 00120 4501 00	stz  	pr6|80		cx
						STATEMENT 1 ON LINE 166
	ctep = addr (bound_seg_comp);

000162  aa  6 00140 3715 00	epp5 	pr6|96		bound_seg_comp
000163  aa  6 00506 6515 00	spri5	pr6|326		ctep
						STATEMENT 1 ON LINE 167
	sp = addr (bind_map_is);

000164  aa  6 00372 3515 00	epp1 	pr6|250		bind_map_is
000165  aa  6 00100 2515 00	spri1	pr6|64		sp
						STATEMENT 1 ON LINE 168
	call dup_search;

000166  aa   000230 6700 04	tsp4 	152,ic		000416
						STATEMENT 1 ON LINE 169
	sp = addr (symbol_table_is);

000167  aa  6 00260 3735 00	epp7 	pr6|176		symbol_table_is
000170  aa  6 00100 6535 00	spri7	pr6|64		sp
						STATEMENT 1 ON LINE 170
	call dup_search;

000171  aa   000225 6700 04	tsp4 	149,ic		000416
						STATEMENT 1 ON LINE 172
	do cx = 1 to bx_$ncomp;

000172  aa  6 00044 3701 20	epp4 	pr6|36,*
000173  la  4 00020 2361 20	ldq  	pr4|16,*		bx_$ncomp
000174  aa  6 00512 7561 00	stq  	pr6|330
000175  aa   000001 2360 07	ldq  	1,dl
000176  aa  6 00120 7561 00	stq  	pr6|80		cx
000177  aa   000000 0110 03	nop  	0,du
000200  aa  6 00120 2361 00	ldq  	pr6|80		cx
000201  aa  6 00512 1161 00	cmpq 	pr6|330
000202  aa   000036 6054 04	tpnz 	30,ic		000240
						STATEMENT 1 ON LINE 173
	     ctep = comp_tbl (cx);

000203  aa   000001 7360 00	qls  	1
000204  aa  6 00504 3735 20	epp7 	pr6|324,*		ctp
000205  aa  7 77776 3735 26	epp7 	pr7|-2,ql*	comp_tbl
000206  aa  6 00506 6535 00	spri7	pr6|326		ctep
						STATEMENT 1 ON LINE 174
	     ip = comp.insymentp;

000207  aa  7 00036 3715 20	epp5 	pr7|30,*		comp.insymentp
000210  aa  6 00106 6515 00	spri5	pr6|70		ip
						STATEMENT 1 ON LINE 176
	     do sx = 1 to ip -> insym.n_insyms - 1;

000211  aa  5 00002 2361 00	ldq  	pr5|2		insym.n_insyms
000212  aa   000001 1760 07	sbq  	1,dl
000213  aa  6 00513 7561 00	stq  	pr6|331
000214  aa   000001 2360 07	ldq  	1,dl
000215  aa  6 00122 7561 00	stq  	pr6|82		sx
000216  aa  6 00122 2361 00	ldq  	pr6|82		sx
000217  aa  6 00513 1161 00	cmpq 	pr6|331
000220  aa   000016 6054 04	tpnz 	14,ic		000236
						STATEMENT 1 ON LINE 177
		sp = addr (ip -> insym.entry (sx));

000221  aa   000112 4020 07	mpy  	74,dl
000222  aa  6 00106 3735 20	epp7 	pr6|70,*		ip
000223  aa  7 77672 3735 06	epp7 	pr7|-70,ql	insym.entry
000224  aa  6 00100 6535 00	spri7	pr6|64		sp
						STATEMENT 1 ON LINE 179
		if ^(sp -> is.ignore | sp -> is.delete | sp -> is.duplicate)
		then call dup_search;

000225  aa  7 00110 2351 00	lda  	pr7|72		is.delete
000226  aa   014000 3150 03	cana 	6144,du
000227  aa   000005 6010 04	tnz  	5,ic		000234
000230  aa  7 00110 2351 00	lda  	pr7|72		is.duplicate
000231  aa   000200 3150 03	cana 	128,du
000232  aa   000002 6010 04	tnz  	2,ic		000234
000233  aa   000163 6700 04	tsp4 	115,ic		000416
						STATEMENT 1 ON LINE 181
	     end;

000234  aa  6 00122 0541 00	aos  	pr6|82		sx
000235  aa   777761 7100 04	tra  	-15,ic		000216
						STATEMENT 1 ON LINE 182
	end;

000236  aa  6 00120 0541 00	aos  	pr6|80		cx
000237  aa   777741 7100 04	tra  	-31,ic		000200
						STATEMENT 1 ON LINE 188
	sytp = axtp;

000240  aa  6 00132 3735 20	epp7 	pr6|90,*		axtp
000241  aa  6 00112 6535 00	spri7	pr6|74		sytp
						STATEMENT 1 ON LINE 190
	bx_$tdefp -> definition.value = bit (bx_$curdeflng);

000242  aa  6 00044 3701 20	epp4 	pr6|36,*
000243  la  4 00016 2351 20	lda  	pr4|14,*		bx_$curdeflng
000244  aa   000002 6050 04	tpl  	2,ic		000246
000245  aa   000000 5310 00	neg  	0
000246  aa   000022 7350 00	als  	18
000247  la  4 00014 3715 20	epp5 	pr4|12,*		bx_$tdefp
000250  aa  5 00000 3715 20	epp5 	pr5|0,*		bx_$tdefp
000251  aa  5 00001 5511 60	stba 	pr5|1,60		definition.value
						STATEMENT 1 ON LINE 193
	htsize = hlen (bx_$nsymdefs + 2);

000252  la  4 00022 2361 20	ldq  	pr4|18,*		bx_$nsymdefs
000253  aa   000002 0760 07	adq  	2,dl
000254  aa  6 00562 7561 00	stq  	pr6|370
000255  aa   000431 3520 04	epp2 	281,ic		000706 = 000004000000
000256  aa   000364 6700 04	tsp4 	244,ic		000642
						STATEMENT 1 ON LINE 194
	sytp -> symht.size = htsize;

000257  aa  6 00136 2361 00	ldq  	pr6|94		htsize
000260  aa  6 00112 7561 20	stq  	pr6|74,*		symht.size
						STATEMENT 1 ON LINE 196
	sp = addr (bind_map_is);

000261  aa  6 00372 3735 00	epp7 	pr6|250		bind_map_is
000262  aa  6 00100 6535 00	spri7	pr6|64		sp
						STATEMENT 1 ON LINE 197
	call hash_sym;

000263  aa   000265 6700 04	tsp4 	181,ic		000550
						STATEMENT 1 ON LINE 199
	sp = addr (symbol_table_is);

000264  aa  6 00260 3735 00	epp7 	pr6|176		symbol_table_is
000265  aa  6 00100 6535 00	spri7	pr6|64		sp
						STATEMENT 1 ON LINE 200
	call hash_sym;

000266  aa   000262 6700 04	tsp4 	178,ic		000550
						STATEMENT 1 ON LINE 202
	do cx = 1 to bx_$ncomp;

000267  aa  6 00044 3701 20	epp4 	pr6|36,*
000270  la  4 00020 2361 20	ldq  	pr4|16,*		bx_$ncomp
000271  aa  6 00514 7561 00	stq  	pr6|332
000272  aa   000001 2360 07	ldq  	1,dl
000273  aa  6 00120 7561 00	stq  	pr6|80		cx
000274  aa  6 00120 2361 00	ldq  	pr6|80		cx
000275  aa  6 00514 1161 00	cmpq 	pr6|332
000276  aa   000036 6054 04	tpnz 	30,ic		000334
						STATEMENT 1 ON LINE 203
	     ctep = comp_tbl (cx);

000277  aa   000001 7360 00	qls  	1
000300  aa  6 00504 3735 20	epp7 	pr6|324,*		ctp
000301  aa  7 77776 3735 26	epp7 	pr7|-2,ql*	comp_tbl
000302  aa  6 00506 6535 00	spri7	pr6|326		ctep
						STATEMENT 1 ON LINE 204
	     ip = comp.insymentp;

000303  aa  7 00036 3715 20	epp5 	pr7|30,*		comp.insymentp
000304  aa  6 00106 6515 00	spri5	pr6|70		ip
						STATEMENT 1 ON LINE 206
	     do sx = 1 to ip -> insym.n_insyms - 1;

000305  aa  5 00002 2361 00	ldq  	pr5|2		insym.n_insyms
000306  aa   000001 1760 07	sbq  	1,dl
000307  aa  6 00515 7561 00	stq  	pr6|333
000310  aa   000001 2360 07	ldq  	1,dl
000311  aa  6 00122 7561 00	stq  	pr6|82		sx
000312  aa  6 00122 2361 00	ldq  	pr6|82		sx
000313  aa  6 00515 1161 00	cmpq 	pr6|333
000314  aa   000016 6054 04	tpnz 	14,ic		000332
						STATEMENT 1 ON LINE 207
		sp = addr (ip -> insym.entry (sx));

000315  aa   000112 4020 07	mpy  	74,dl
000316  aa  6 00106 3735 20	epp7 	pr6|70,*		ip
000317  aa  7 77672 3735 06	epp7 	pr7|-70,ql	insym.entry
000320  aa  6 00100 6535 00	spri7	pr6|64		sp
						STATEMENT 1 ON LINE 209
		if ^(sp -> is.ignore | sp -> is.delete | sp -> is.duplicate)
		then call hash_sym;

000321  aa  7 00110 2351 00	lda  	pr7|72		is.delete
000322  aa   014000 3150 03	cana 	6144,du
000323  aa   000005 6010 04	tnz  	5,ic		000330
000324  aa  7 00110 2351 00	lda  	pr7|72		is.duplicate
000325  aa   000200 3150 03	cana 	128,du
000326  aa   000002 6010 04	tnz  	2,ic		000330
000327  aa   000221 6700 04	tsp4 	145,ic		000550
						STATEMENT 1 ON LINE 211
	     end;

000330  aa  6 00122 0541 00	aos  	pr6|82		sx
000331  aa   777761 7100 04	tra  	-15,ic		000312
						STATEMENT 1 ON LINE 212
	end;

000332  aa  6 00120 0541 00	aos  	pr6|80		cx
000333  aa   777741 7100 04	tra  	-31,ic		000274
						STATEMENT 1 ON LINE 214
	bx_$curdeflng = bx_$curdeflng + sytp -> symht.size + 1;

000334  aa  6 00044 3701 20	epp4 	pr6|36,*
000335  la  4 00016 2361 20	ldq  	pr4|14,*		bx_$curdeflng
000336  aa  6 00112 0761 20	adq  	pr6|74,*		symht.size
000337  aa   000001 0760 07	adq  	1,dl
000340  la  4 00016 7561 20	stq  	pr4|14,*		bx_$curdeflng
						STATEMENT 1 ON LINE 221
	if dupn = 0
	then /* If no duplicated names ... */
	     return;

000341  aa  6 00135 2361 00	ldq  	pr6|93		dupn
000342  aa  0 00631 6001 00	tze  	pr0|409		return_mac
						STATEMENT 1 ON LINE 225
	sgtp = addrel (bx_$tdefp, bx_$curdeflng);

000343  la  4 00016 2361 20	ldq  	pr4|14,*		bx_$curdeflng
000344  la  4 00014 3521 20	epp2 	pr4|12,*		bx_$tdefp
000345  aa  2 00000 3521 66	epp2 	pr2|0,*ql		bx_$tdefp
000346  aa   000000 0520 03	adwp2	0,du
000347  aa  6 00114 2521 00	spri2	pr6|76		sgtp
						STATEMENT 1 ON LINE 227
	htsize = hlen (bx_$nsegdefs + 1);

000350  la  4 00024 2361 20	ldq  	pr4|20,*		bx_$nsegdefs
000351  aa   000001 0760 07	adq  	1,dl
000352  aa  6 00562 7561 00	stq  	pr6|370
000353  aa   000333 3520 04	epp2 	219,ic		000706 = 000004000000
000354  aa   000266 6700 04	tsp4 	182,ic		000642
						STATEMENT 1 ON LINE 228
	sgtp -> seght.size = htsize;

000355  aa  6 00136 2361 00	ldq  	pr6|94		htsize
000356  aa  6 00114 7561 20	stq  	pr6|76,*		seght.size
						STATEMENT 1 ON LINE 230
	sp = addr (bound_seg_seg);

000357  aa  6 00240 3735 00	epp7 	pr6|160		bound_seg_seg
000360  aa  6 00100 6535 00	spri7	pr6|64		sp
						STATEMENT 1 ON LINE 231
	call hash_seg;

000361  aa   000214 6700 04	tsp4 	140,ic		000575
						STATEMENT 1 ON LINE 233
	sntp = bx_$sntp;

000362  aa  6 00044 3701 20	epp4 	pr6|36,*
000363  la  4 00012 3735 20	epp7 	pr4|10,*		bx_$sntp
000364  aa  7 00000 3735 20	epp7 	pr7|0,*		bx_$sntp
000365  aa  6 00510 6535 00	spri7	pr6|328		sntp
						STATEMENT 1 ON LINE 234
	do sx = 1 to sntp -> snt.n_names;

000366  aa  6 00510 3715 20	epp5 	pr6|328,*		sntp
000367  aa  5 00324 2361 00	ldq  	pr5|212		snt.n_names
000370  aa  6 00516 7561 00	stq  	pr6|334
000371  aa   000001 2360 07	ldq  	1,dl
000372  aa  6 00122 7561 00	stq  	pr6|82		sx
000373  aa   000000 0110 03	nop  	0,du
000374  aa  6 00122 2361 00	ldq  	pr6|82		sx
000375  aa  6 00516 1161 00	cmpq 	pr6|334
000376  aa   000012 6054 04	tpnz 	10,ic		000410
						STATEMENT 1 ON LINE 235
	     sp = addr (sntp -> snt.entry (sx));

000377  aa   000004 7360 00	qls  	4
000400  aa  6 00510 3735 20	epp7 	pr6|328,*		sntp
000401  aa  7 00306 3735 06	epp7 	pr7|198,ql	snt.entry
000402  aa  6 00100 6535 00	spri7	pr6|64		sp
						STATEMENT 1 ON LINE 237
	     if sp -> seg.defrel
	     then /* If this is a real name ... */
		call hash_seg;

000403  aa  7 00013 2351 00	lda  	pr7|11		seg.defrel
000404  aa   000002 6000 04	tze  	2,ic		000406
000405  aa   000170 6700 04	tsp4 	120,ic		000575
						STATEMENT 1 ON LINE 240
	end;

000406  aa  6 00122 0541 00	aos  	pr6|82		sx
000407  aa   777765 7100 04	tra  	-11,ic		000374
						STATEMENT 1 ON LINE 242
	bx_$curdeflng = bx_$curdeflng + sgtp -> seght.size + 1;

000410  aa  6 00044 3701 20	epp4 	pr6|36,*
000411  la  4 00016 2361 20	ldq  	pr4|14,*		bx_$curdeflng
000412  aa  6 00114 0761 20	adq  	pr6|76,*		seght.size
000413  aa   000001 0760 07	adq  	1,dl
000414  la  4 00016 7561 20	stq  	pr4|14,*		bx_$curdeflng
						STATEMENT 1 ON LINE 246
	return;

000415  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 436
     end;

BEGIN PROCEDURE dup_search
ENTRY TO dup_search                                         STATEMENT 1 ON LINE 249
dup_search:
     proc;

000416  aa  6 00520 6501 00	spri4	pr6|336
						STATEMENT 1 ON LINE 269
	axx = 0;

000417  aa  6 00134 4501 00	stz  	pr6|92		axx
						STATEMENT 1 ON LINE 270
	do cx1 = cx + 1 to bx_$ncomp;

000420  aa  6 00044 3701 20	epp4 	pr6|36,*
000421  la  4 00020 2361 20	ldq  	pr4|16,*		bx_$ncomp
000422  aa  6 00526 7561 00	stq  	pr6|342
000423  aa  6 00120 2361 00	ldq  	pr6|80		cx
000424  aa   000001 0760 07	adq  	1,dl
000425  aa  6 00121 7561 00	stq  	pr6|81		cx1
000426  aa  6 00121 2361 00	ldq  	pr6|81		cx1
000427  aa  6 00526 1161 00	cmpq 	pr6|342
000430  aa   000102 6054 04	tpnz 	66,ic		000532
						STATEMENT 1 ON LINE 271
	     ctep1 = comp_tbl (cx1);

000431  aa   000001 7360 00	qls  	1
000432  aa  6 00504 3735 20	epp7 	pr6|324,*		ctp
000433  aa  7 77776 3735 26	epp7 	pr7|-2,ql*	comp_tbl
000434  aa  6 00104 6535 00	spri7	pr6|68		ctep1
						STATEMENT 1 ON LINE 272
	     ip1 = ctep1 -> comp.insymentp;

000435  aa  7 00036 3715 20	epp5 	pr7|30,*		comp.insymentp
000436  aa  6 00110 6515 00	spri5	pr6|72		ip1
						STATEMENT 1 ON LINE 274
	     do sx1 = 1 to ip1 -> insym.n_insyms - 1;

000437  aa  5 00002 2361 00	ldq  	pr5|2		insym.n_insyms
000440  aa   000001 1760 07	sbq  	1,dl
000441  aa  6 00527 7561 00	stq  	pr6|343
000442  aa   000001 2360 07	ldq  	1,dl
000443  aa  6 00123 7561 00	stq  	pr6|83		sx1
000444  aa  6 00123 2361 00	ldq  	pr6|83		sx1
000445  aa  6 00527 1161 00	cmpq 	pr6|343
000446  aa   000062 6054 04	tpnz 	50,ic		000530
						STATEMENT 1 ON LINE 275
		sp1 = addr (ip1 -> insym.entry (sx1));

000447  aa   000112 4020 07	mpy  	74,dl
000450  aa  6 00110 3735 20	epp7 	pr6|72,*		ip1
000451  aa  7 77672 3735 06	epp7 	pr7|-70,ql	insym.entry
000452  aa  6 00102 6535 00	spri7	pr6|66		sp1
						STATEMENT 1 ON LINE 277
		if ^(sp1 -> is.ignore | sp1 -> is.delete)
		then if substr (sp -> is.symbol, 1, sp -> is.lng) = substr (sp1 -> is.symbol, 1, sp1 -> is.lng)
		     then do;

000453  aa  7 00110 2351 00	lda  	pr7|72		is.delete
000454  aa   014000 3150 03	cana 	6144,du
000455  aa   000051 6010 04	tnz  	41,ic		000526
000456  aa  6 00100 3715 20	epp5 	pr6|64,*		sp
000457  aa  5 00104 7271 00	lxl7 	pr5|68		is.lng
000460  aa  7 00104 7261 00	lxl6 	pr7|68		is.lng
000461  aa  040 140 106 540	cmpc 	(pr,rl),(pr,rl),fill(040)
000462  aa  5 00003 00 0017	desc9a	pr5|3,x7		is.symbol
000463  aa  7 00003 00 0016	desc9a	pr7|3,x6		is.symbol
000464  aa   000042 6010 04	tnz  	34,ic		000526
						STATEMENT 1 ON LINE 280
			if axx = 0
			then do;

000465  aa  6 00134 2361 00	ldq  	pr6|92		axx
000466  aa   000022 6010 04	tnz  	18,ic		000510
						STATEMENT 1 ON LINE 282
			     axx = 1;

000467  aa   000001 2360 07	ldq  	1,dl
000470  aa  6 00134 7561 00	stq  	pr6|92		axx
						STATEMENT 1 ON LINE 283
			     axtp -> auxt.defp (1) = sp -> is.defrel;

000471  aa  5 00111 2351 00	lda  	pr5|73		is.defrel
000472  aa  6 00132 3535 20	epp3 	pr6|90,*		axtp
000473  aa  3 00001 5511 60	stba 	pr3|1,60		auxt.defp
						STATEMENT 1 ON LINE 285
			     axtp -> auxt.headp (1) = bit (bin (comp.defthread, 18));

000474  aa  6 00506 3515 20	epp1 	pr6|326,*		ctep
000475  aa  1 00051 2351 00	lda  	pr1|41		comp.defthread
000476  aa   000002 6050 04	tpl  	2,ic		000500
000477  aa   000000 5310 00	neg  	0
000500  aa  0 00264 3771 00	anaq 	pr0|180		= 000000777777 777777777777
000501  aa  3 00001 5511 14	stba 	pr3|1,14		auxt.headp
						STATEMENT 1 ON LINE 286
			     sp -> is.defrel = bit (bx_$curdeflng, 18);

000502  aa  6 00044 3701 20	epp4 	pr6|36,*
000503  la  4 00016 2351 20	lda  	pr4|14,*		bx_$curdeflng
000504  aa   000002 6050 04	tpl  	2,ic		000506
000505  aa   000000 5310 00	neg  	0
000506  aa   000022 7350 00	als  	18
000507  aa  5 00111 7551 00	sta  	pr5|73		is.defrel
						STATEMENT 1 ON LINE 287
			end;

						STATEMENT 1 ON LINE 289
			axx = axx + 1;

000510  aa  6 00134 0541 00	aos  	pr6|92		axx
						STATEMENT 1 ON LINE 290
			axtp -> auxt.defp (axx) = sp1 -> is.defrel;

000511  aa  7 00111 2351 00	lda  	pr7|73		is.defrel
000512  aa  6 00134 7251 00	lxl5 	pr6|92		axx
000513  aa  6 00132 3535 75	epp3 	pr6|90,*5		auxt.defp
000514  aa  3 00000 5511 60	stba 	pr3|0,60		auxt.defp
						STATEMENT 1 ON LINE 292
			axtp -> auxt.headp (axx) = bit (bin (ctep1 -> comp.defthread, 18));

000515  aa  6 00104 3515 20	epp1 	pr6|68,*		ctep1
000516  aa  1 00051 2351 00	lda  	pr1|41		comp.defthread
000517  aa   000002 6050 04	tpl  	2,ic		000521
000520  aa   000000 5310 00	neg  	0
000521  aa  0 00264 3771 00	anaq 	pr0|180		= 000000777777 777777777777
000522  aa  6 00132 3535 75	epp3 	pr6|90,*5		auxt.headp
000523  aa  3 00000 5511 14	stba 	pr3|0,14		auxt.headp
						STATEMENT 1 ON LINE 293
			sp1 -> is.duplicate = "1"b;

000524  aa   000200 2350 03	lda  	128,du
000525  aa  7 00110 2551 00	orsa 	pr7|72		is.duplicate
						STATEMENT 1 ON LINE 294
		     end;

						STATEMENT 1 ON LINE 297
	     end;

000526  aa  6 00123 0541 00	aos  	pr6|83		sx1
000527  aa   777715 7100 04	tra  	-51,ic		000444
						STATEMENT 1 ON LINE 298
	end;

000530  aa  6 00121 0541 00	aos  	pr6|81		cx1
000531  aa   777675 7100 04	tra  	-67,ic		000426
						STATEMENT 1 ON LINE 300
	if axx ^= 0
	then do;

000532  aa  6 00134 2361 00	ldq  	pr6|92		axx
000533  aa   000014 6000 04	tze  	12,ic		000547
						STATEMENT 1 ON LINE 302
	     axtp -> auxt.size = axx;

000534  aa  6 00132 7561 20	stq  	pr6|90,*		auxt.size
						STATEMENT 1 ON LINE 303
	     bx_$curdeflng = bx_$curdeflng + axx + 1;

000535  aa  6 00044 3701 20	epp4 	pr6|36,*
000536  la  4 00016 0761 20	adq  	pr4|14,*		bx_$curdeflng
000537  aa   000001 0760 07	adq  	1,dl
000540  la  4 00016 7561 20	stq  	pr4|14,*		bx_$curdeflng
						STATEMENT 1 ON LINE 304
	     axtp = addrel (axtp, axx + 1);

000541  aa  6 00134 2361 00	ldq  	pr6|92		axx
000542  aa   000001 0760 07	adq  	1,dl
000543  aa  6 00132 3521 66	epp2 	pr6|90,*ql	axtp
000544  aa   000000 0520 03	adwp2	0,du
000545  aa  6 00132 2521 00	spri2	pr6|90		axtp
						STATEMENT 1 ON LINE 305
	     dupn = dupn + 1;

000546  aa  6 00135 0541 00	aos  	pr6|93		dupn
						STATEMENT 1 ON LINE 306
	end;

						STATEMENT 1 ON LINE 309
     end dup_search;

000547  aa  6 00520 6101 00	rtcd 	pr6|336
  END PROCEDURE dup_search
BEGIN PROCEDURE hash_sym
ENTRY TO hash_sym                                           STATEMENT 1 ON LINE 312
hash_sym:
     proc;

000550  aa  6 00530 6501 00	spri4	pr6|344
						STATEMENT 1 ON LINE 328
	namep = addr (sp -> is.symbol);

000551  aa  6 00100 3735 20	epp7 	pr6|64,*		sp
000552  aa  7 00003 3735 00	epp7 	pr7|3		is.symbol
000553  aa  6 00130 6535 00	spri7	pr6|88		namep
						STATEMENT 1 ON LINE 329
	symx = hash ();

000554  aa   000126 3520 04	epp2 	86,ic		000702 = 000002000000
000555  aa   000054 6700 04	tsp4 	44,ic		000631
						STATEMENT 1 ON LINE 331
	do while (sytp -> symht.defp (symx));

000556  aa  6 00116 7271 00	lxl7 	pr6|78		symx
000557  aa  6 00112 2351 77	lda  	pr6|74,*7		symht.defp
000560  aa   777777 3150 03	cana 	262143,du
000561  aa   000007 6000 04	tze  	7,ic		000570
						STATEMENT 1 ON LINE 332
	     symx = mod (symx, htsize) + 1;

000562  aa  6 00116 2361 00	ldq  	pr6|78		symx
000563  aa  6 00136 3521 00	epp2 	pr6|94		htsize
000564  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
000565  aa   000001 0760 07	adq  	1,dl
000566  aa  6 00116 7561 00	stq  	pr6|78		symx
						STATEMENT 1 ON LINE 333
	end;

000567  aa   777767 7100 04	tra  	-9,ic		000556
						STATEMENT 1 ON LINE 335
	sytp -> symht.defp (symx) = sp -> is.defrel;

000570  aa  6 00100 3735 20	epp7 	pr6|64,*		sp
000571  aa  7 00111 2351 00	lda  	pr7|73		is.defrel
000572  aa  6 00112 3715 77	epp5 	pr6|74,*7		symht.defp
000573  aa  5 00000 5511 60	stba 	pr5|0,60		symht.defp
						STATEMENT 1 ON LINE 339
     end hash_sym;

000574  aa  6 00530 6101 00	rtcd 	pr6|344
  END PROCEDURE hash_sym
BEGIN PROCEDURE hash_seg
ENTRY TO hash_seg                                           STATEMENT 1 ON LINE 342
hash_seg:
     proc;

000575  aa  6 00536 6501 00	spri4	pr6|350
						STATEMENT 1 ON LINE 357
	namep = addr (sp -> seg.name);

000576  aa  6 00100 3735 20	epp7 	pr6|64,*		seg.name
000577  aa  6 00130 6535 00	spri7	pr6|88		namep
						STATEMENT 1 ON LINE 358
	segx = hash ();

000600  aa   000076 3520 04	epp2 	62,ic		000676 = 000002000000
000601  aa   000030 6700 04	tsp4 	24,ic		000631
						STATEMENT 1 ON LINE 360
	do while (sgtp -> seght.defp (segx));

000602  aa  6 00117 7271 00	lxl7 	pr6|79		segx
000603  aa  6 00114 2351 77	lda  	pr6|76,*7		seght.defp
000604  aa   777777 3150 03	cana 	262143,du
000605  aa   000007 6000 04	tze  	7,ic		000614
						STATEMENT 1 ON LINE 361
	     segx = mod (segx, htsize) + 1;

000606  aa  6 00117 2361 00	ldq  	pr6|79		segx
000607  aa  6 00136 3521 00	epp2 	pr6|94		htsize
000610  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
000611  aa   000001 0760 07	adq  	1,dl
000612  aa  6 00117 7561 00	stq  	pr6|79		segx
						STATEMENT 1 ON LINE 362
	end;

000613  aa   777767 7100 04	tra  	-9,ic		000602
						STATEMENT 1 ON LINE 364
	sgtp -> seght.defp (segx) = sp -> seg.defrel;

000614  aa  6 00100 3735 20	epp7 	pr6|64,*		sp
000615  aa  7 00013 2351 00	lda  	pr7|11		seg.defrel
000616  aa  6 00114 3715 77	epp5 	pr6|76,*7		seght.defp
000617  aa  5 00000 5511 60	stba 	pr5|0,60		seght.defp
						STATEMENT 1 ON LINE 365
	ctep = sp -> seg.comp;

000620  aa  7 00014 3535 20	epp3 	pr7|12,*		seg.comp
000621  aa  6 00506 2535 00	spri3	pr6|326		ctep
						STATEMENT 1 ON LINE 366
	sgtp -> seght.headp (segx) = bit (bin (ctep -> comp.defthread, 18));

000622  aa  3 00051 2351 00	lda  	pr3|41		comp.defthread
000623  aa   000002 6050 04	tpl  	2,ic		000625
000624  aa   000000 5310 00	neg  	0
000625  aa  0 00264 3771 00	anaq 	pr0|180		= 000000777777 777777777777
000626  aa  6 00114 3515 77	epp1 	pr6|76,*7		seght.headp
000627  aa  1 00000 5511 14	stba 	pr1|0,14		seght.headp
						STATEMENT 1 ON LINE 370
     end hash_seg;

000630  aa  6 00536 6101 00	rtcd 	pr6|350
  END PROCEDURE hash_seg
BEGIN PROCEDURE hash
ENTRY TO hash                                               STATEMENT 1 ON LINE 373
hash:
     proc returns (fixed bin);

000631  aa  6 00544 6501 00	spri4	pr6|356
000632  aa  6 00546 2521 00	spri2	pr6|358
						STATEMENT 1 ON LINE 392
	return (mod (namep -> word, htsize) + 1);

000633  aa  6 00130 2361 20	ldq  	pr6|88,*		word
000634  aa  6 00136 3521 00	epp2 	pr6|94		htsize
000635  aa  0 00704 7001 00	tsx0 	pr0|452		mdfx1
000636  aa   000001 0760 07	adq  	1,dl
000637  aa  6 00546 3735 20	epp7 	pr6|358,*
000640  aa  7 00002 7561 20	stq  	pr7|2,*
000641  aa  6 00544 6101 00	rtcd 	pr6|356
						STATEMENT 1 ON LINE 395
     end hash;

  END PROCEDURE hash
BEGIN PROCEDURE hlen
ENTRY TO hlen                                               STATEMENT 1 ON LINE 399
hlen:
     proc (s) returns (fixed bin);

000642  aa  6 00552 6501 00	spri4	pr6|362
000643  aa  6 00554 2521 00	spri2	pr6|364
						STATEMENT 1 ON LINE 423
	s1 = s * 1.25e0;

000644  aa  2 00002 2361 20	ldq  	pr2|2,*		s
000645  aa  0 00465 7001 00	tsx0 	pr0|309		fx1_to_fl2
000646  aa   002500 4610 03	fmp  	1344,du
000647  aa  0 00654 7001 00	tsx0 	pr0|428		fl2_to_fx1
000650  aa  6 00560 7561 00	stq  	pr6|368		s1
						STATEMENT 1 ON LINE 424
	do i = 1 to hbound (sizes, 1);

000651  aa   000001 2360 07	ldq  	1,dl
000652  aa  6 00561 7561 00	stq  	pr6|369		i
000653  aa   000000 0110 03	nop  	0,du
000654  aa  6 00561 2361 00	ldq  	pr6|369		i
000655  aa   000013 1160 07	cmpq 	11,dl
000656  aa   000013 6054 04	tpnz 	11,ic		000671
						STATEMENT 1 ON LINE 425
	     if s1 <= sizes (i)
	     then return (sizes (i));

000657  aa  6 00560 2361 00	ldq  	pr6|368		s1
000660  aa  6 00561 7271 00	lxl7 	pr6|369		i
000661  ta   777777 1160 17	cmpq 	-1,7
000662  aa   000005 6054 04	tpnz 	5,ic		000667
000663  ta   777777 2360 17	ldq  	-1,7
000664  aa  6 00554 3735 20	epp7 	pr6|364,*
000665  aa  7 00004 7561 20	stq  	pr7|4,*
000666  aa  6 00552 6101 00	rtcd 	pr6|362
						STATEMENT 1 ON LINE 427
	end;

000667  aa  6 00561 0541 00	aos  	pr6|369		i
000670  aa   777764 7100 04	tra  	-12,ic		000654
						STATEMENT 1 ON LINE 428
	return (s1);

000671  aa  6 00560 2361 00	ldq  	pr6|368		s1
000672  aa  6 00554 3735 20	epp7 	pr6|364,*
000673  aa  7 00004 7561 20	stq  	pr7|4,*
000674  aa  6 00552 6101 00	rtcd 	pr6|362
						STATEMENT 1 ON LINE 431
     end hlen;

  END PROCEDURE hlen
  END PROCEDURE hash_defs_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
