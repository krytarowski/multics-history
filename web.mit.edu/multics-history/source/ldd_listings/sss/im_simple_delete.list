	COMPILATION LISTING OF SEGMENT im_simple_delete
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/04/85  0957.4 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 /* DESCRIPTION:
        8*
        9*         This  module  frees  a single key from a node of the index.  It also
       10*     updates the key_tail_space_used_since_last_prefix_compaction and
       11*     key_range.last is decremented by 1.  If the node is a branch node, the
       12*     nodes pointed to by the keys between the one freed and the high end of
       13*     node have their parent_id_strings updated to point to the new locations
       14*     of the keys (which slide over one to close up the gap left by the freed
       15*     key).
       16*
       17*          This module does all of the modification to the control interval
       18*     (node) in which the key to be deleted exists necessary to delete it.
       19*     For reasons of efficiency, it makes these modifications by bypassing
       20*     the collection_manager_ and calling file_manager_ directly.  Again for
       21*     reasons of efficiency, it does so in one call to file_manager_ by 
       22*     consolidating all of the modifications in one ci_parts structure.
       23*
       24*          Because this module bypasses the collection_manager_, it must
       25*     understand the format of the control interval.  The format is described
       26*     by the basic_control_interval structure (dm_cm_basic_ci.incl.pl1).
       27*     Following is a diagram of a control interval accompanied with the names
       28*     of some of the structures which overlay it:
       29*     
       30*     basic_control_interval.header, bci_header
       31*     |          basic_control_interval.datum_position_table, slots
       32*     |          |
       33*     v          v
       34*      ------------------------------------------------------------------
       35*     |          | | | | | | | | |               |    | / / |    | / |   |
       36*     | 20 bytes | | four bytes| | un-used space |    |/ / /|    |/ /|   |
       37*     |          | | per  slot | |               |    | / / |    | / |   |
       38*      ------------------------------------------------------------------
       39*                                                  ^     ^         ^   ^
       40*                                                  |     |         |   |
       41*                                                  |     free space    |
       42*                                                  |                   |
       43*                                                  stored data - keys and
       44*                                                     index CI header
       45*     
       46*     This control interval is not modified in place. New values for parts
       47*     of the control interval are kept in local buffers.  Four modifications
       48*     are made: the bci_header is updated, part of the slots are shifted one
       49*     slot to the left, the last slot is made to zero and the element which
       50*     holds the index CI header is updated.  To make the first modification, a
       51*     local copy of bci_header is made, modified and identified as a new value
       52*     to be placed where the old bci_header was.  The shift is accomplished by
       53*     identifiying the slots to the right of the slot of the key being deleted
       54*     as a new part to be placed starting at the slot of the old key. Since the
       55*     values of the slots are not actually change, just moved, a local copy is
       56*     not necessary.  A one-word constant is used as the new value to be placed
       57*     on top of the last slot.  An automatic copy of the index CI header is
       58*     passed to this procedure, is updated and placed over its old location in
       59*     the control interval.
       60*     
       61*     The parameter p_node_ptr must point to a control interval in a file.
       62*     This pointer should have been set by calling
       63*     collection_manager_$get_control_interval_ptr or file_manager_$get_ci_ptr.
       64*     
       65*     The parameter p_common_ci_header_ptr points to the index CI header
       66*     (the structure common_ci_header and one of leaf_ci_header or
       67*     branch_ci_header).  This must not point directly into the control
       68*     interval but point to some local copy of the index CI header.  The index
       69*     CI header is stored as the first element in the control interval.
       70*     
       71*     The parameter p_key_id_string consists of two parts, the control interval
       72*     id of the control interval to which p_node_ptr points and the index in
       73*     the slot table (datum_position_table) of the key to be deleted.
       74*     
       75*     The parameter p_index_cursor_ptr points to an index cursor.
       76**/
       77 
       78 /* HISTORY:
       79*
       80*Written by Lindsey L. Spratt, 08/06/82.
       81*Modified:
       82*10/18/82 by Matthew Pierret:  Corrected cm_$get_element calling sequence by
       83*            removing offset/length arguments.  Fixed call to sub_err_ in
       84*            check_version by adding '"s", null, 0' arguments.
       85*12/10/82 by Lindsey Spratt:  Fixed to leave the the key_range.first and
       86*	  key_range.last equal to 0 after deleting the last key in the
       87*	  control interval.
       88*02/28/83 by Lindsey Spratt:  Updated to use version 3 of the index_cursor.
       89*04/27/83 by Lindsey L. Spratt:  Fixed to update the parent_id_strings of the
       90*            branch nodes pointed to by keys which are moved as a result of the
       91*            deletion.
       92*11/08/83 by Lindsey L. Spratt:  Changed to use the "buffered" access method.
       93*            ALso changed to use the "call ERROR_RETURN (code)" protocol.
       94*03/28/84 by Matthew Pierret:  Changed to modify the control interval without
       95*            calling collection_manager_, but by setting up a ci_parts structure
       96*            on its own and calling file_manager_$put. p_node_ptr must now point
       97*            directly to the CI in the file instead of to a buffer because a
       98*            CI buffer would not be updated when the actual CI is updated by
       99*            file_manager_$put.
      100*10/12/84 by Matthew Pierret:  Changed to use the new dm_cm_basic_ci and
      101*            dm_cm_basic_ci_const include files.
      102**/
      103 
      104 /* format: style2,ind3 */
      105 
      106 im_simple_delete:
      107    proc (p_node_ptr, p_index_cursor_ptr, p_common_ci_header_ptr, p_key_id_string, p_code);
      108 
      109 /* START OF DECLARATIONS */
      110 /* Parameter */
      111 
      112       dcl	    p_node_ptr	       ptr parameter;
      113       dcl	    p_index_cursor_ptr     ptr parameter;
      114       dcl	    p_common_ci_header_ptr ptr parameter;
      115       dcl	    p_key_id_string	       bit (36) aligned parameter;
      116       dcl	    p_code	       fixed bin (35) parameter;
      117 
      118 /* Automatic */
      119 
      120       dcl	    code		       fixed bin (35) init (0);
      121       dcl	    file_opening_id	       bit (36) aligned;
      122       dcl	    index_ci_header_slot_ptr
      123 			       ptr init (null);
      124       dcl	    key_ci_id	       fixed bin (24) unsigned;
      125       dcl	    key_index	       fixed bin (12) unsigned;
      126       dcl	    key_length_in_bits     fixed bin (35);
      127       dcl	    key_length_in_bytes    fixed bin;
      128       dcl	    key_offset_in_bytes    fixed bin;
      129       dcl	    key_slot_offset_in_bytes
      130 			       fixed bin;
      131       dcl	    key_slot_ptr	       ptr init (null);
      132       dcl	    1 local_bci_header     aligned like bci_header;
      133       dcl	    local_ci_parts_buffer  (10) fixed bin (71) init ((10) 0);
      134 						/* Four parts */
      135       dcl	    node_ptr	       ptr init (null);
      136 
      137 /* Based */
      138 
      139       dcl	    1 p_key_id	       aligned like element_id based (addr (p_key_id_string));
      140       dcl	    1 index_ci_header_slot aligned like datum_slot based (index_ci_header_slot_ptr);
      141       dcl	    1 key_slot	       aligned like datum_slot based (key_slot_ptr);
      142 
      143 /* Builtin */
      144 
      145       dcl	    (addcharno, addr, ceil, divide, max, null, size, unspec)
      146 			       builtin;
      147 
      148 /* Constant */
      149 
      150       dcl	    myname	       init ("im_simple_delete") char (16) internal static options (constant);
      151       dcl	    (
      152 	    BYTES_PER_WORD	       init (4),
      153 	    BITS_PER_BYTE	       init (9)
      154 	    )		       fixed bin internal static options (constant);
      155       dcl	    ZERO_SLOT	       init (0) fixed bin (35) internal static options (constant);
      156 
      157       dcl	    (
      158 	    BCI_HEADER_PART_IDX    init (1),
      159 	    INDEX_CI_HEADER_PART_IDX
      160 			       init (2),
      161 	    TRAILING_SLOTS_PART_IDX
      162 			       init (3),
      163 	    LAST_SLOT_PART_IDX     init (4),
      164 	    NUMBER_OF_PARTS	       init (4)
      165 	    )		       fixed bin internal static options (constant);
      166 
      167 /* Entry */
      168 
      169       dcl	    file_manager_$put      entry (bit (36) aligned, fixed bin (27), ptr, fixed bin (35));
      170       dcl	    im_update_branches     entry (ptr, bit (36) aligned, bit (36) aligned, ptr, uns fixed bin (24) unal,
      171 			       uns fixed bin (12) unal, fixed bin (35));
      172       dcl	    sub_err_	       entry () options (variable);
      173 
      174 /* External */
      175 
      176       dcl	    (
      177 	    error_table_$unimplemented_version,
      178 	    dm_error_$wrong_cursor_type
      179 	    )		       fixed bin (35) ext;
      180 
      181 /* END OF DECLARATIONS */
      182 
      183 /* format: indcomtxt,^indblkcom */
      184 
      185       code = 0;
      186 
      187 /**** Copy paramters into local storage for efficiency. */
      188 
      189       node_ptr = p_node_ptr;
      190 
      191       index_cursor_ptr = p_index_cursor_ptr;
      192       if index_cursor.type ^= INDEX_CURSOR_TYPE
      193       then call sub_err_ (dm_error_$wrong_cursor_type, myname, "s", null, 0,
      194 	      "^/Expected an ""index"" type cursor (type ^d).^/Received a cursor of type ^d instead.",
      195 	      INDEX_CURSOR_TYPE, index_cursor.type);
      196       call CHECK_VERSION ((index_cursor.version), (INDEX_CURSOR_VERSION_3), "index_cursor");
      197       file_opening_id = index_cursor.file_opening_id;
      198 
      199       common_ci_header_ptr, leaf_ci_header_ptr, branch_ci_header_ptr = p_common_ci_header_ptr;
      200 
      201       key_ci_id = p_key_id.control_interval_id;
      202       key_index = p_key_id.index;
      203 
      204 /**** Init local buffers. */
      205 
      206       unspec (local_bci_header) = unspec (node_ptr -> bci_header);
      207       ci_parts_ptr = addr (local_ci_parts_buffer);
      208       ci_parts.number_of_parts = NUMBER_OF_PARTS;
      209 
      210 /**** Get length of key to be deleted. */
      211 
      212       key_slot_offset_in_bytes = DATUM_POSITION_TABLE_OFFSET_IN_BYTES + (key_index - 1) * BYTES_PER_WORD;
      213       key_slot_ptr = addcharno (node_ptr, key_slot_offset_in_bytes);
      214 
      215       key_offset_in_bytes = key_slot.offset_in_bytes;
      216       key_length_in_bits = key_slot.length_in_bits;
      217 
      218       if common_ci_header.is_leaf
      219       then common_ci_header.key_tail_space_used_since_last_prefix_compaction =
      220 	      max (common_ci_header.key_tail_space_used_since_last_prefix_compaction - key_length_in_bits, 0);
      221       else common_ci_header.key_tail_space_used_since_last_prefix_compaction =
      222 	      max (common_ci_header.key_tail_space_used_since_last_prefix_compaction
      223 	      - (key_length_in_bits - BRANCH_KEY_HEADER_LENGTH_IN_BITS), 0);
      224 
      225 /**** Setup to free the key by setting the ci parts to trailing shift the
      226*      slots to the left (if there are any) and to zero out the last slot. */
      227 
      228       if key_index >= local_bci_header.number_of_datums
      229       then ci_parts.part (TRAILING_SLOTS_PART_IDX).length_in_bytes = 0;
      230 						/* No trailing slots. Skip this part. */
      231       else
      232          do;					/* Shift trailing slots */
      233 	  ci_parts.part (TRAILING_SLOTS_PART_IDX).offset_in_bytes = key_slot_offset_in_bytes;
      234 	  ci_parts.part (TRAILING_SLOTS_PART_IDX).length_in_bytes =
      235 	       BYTES_PER_WORD * (local_bci_header.number_of_datums - key_index);
      236 	  ci_parts.part (TRAILING_SLOTS_PART_IDX).local_ptr =
      237 	       addcharno (node_ptr, key_slot_offset_in_bytes + BYTES_PER_WORD);
      238 						/* Points to slot after slot being freed.  */
      239          end;
      240 
      241       ci_parts.part (LAST_SLOT_PART_IDX).offset_in_bytes =
      242 	 DATUM_POSITION_TABLE_OFFSET_IN_BYTES + BYTES_PER_WORD * (local_bci_header.number_of_datums - 1);
      243       ci_parts.part (LAST_SLOT_PART_IDX).length_in_bytes = BYTES_PER_WORD;
      244       ci_parts.part (LAST_SLOT_PART_IDX).local_ptr = addr (ZERO_SLOT);
      245 
      246 /**** Update the bci_header.  This includes decrementing the number of
      247*      datums (slots) in the control interval, adding the space taken up by
      248*      the key to be deleted to the count of scattered free bytes, and, if the
      249*      contents of the key was at the beginning of the used space, change the
      250*      value of the start of used space. */
      251 
      252       local_bci_header.number_of_datums = local_bci_header.number_of_datums - 1;
      253       key_length_in_bytes = ceil (divide (key_length_in_bits, BITS_PER_BYTE, 35, 18));
      254 
      255       if local_bci_header.start_of_used_space = key_offset_in_bytes
      256       then local_bci_header.start_of_used_space = local_bci_header.start_of_used_space + key_length_in_bytes;
      257 						/* The deletion increased the size of the un-used portion */
      258       else local_bci_header.scattered_free_space = local_bci_header.scattered_free_space + key_length_in_bytes;
      259 						/* The deletion created more scattered free space */
      260 
      261       ci_parts.part (BCI_HEADER_PART_IDX).offset_in_bytes = 0;
      262 						/* bci_header is at beginning of control interval */
      263       ci_parts.part (BCI_HEADER_PART_IDX).length_in_bytes = BCI_HEADER_LENGTH_IN_BYTES;
      264       ci_parts.part (BCI_HEADER_PART_IDX).local_ptr = addr (local_bci_header);
      265 
      266 /**** Update key range in common_ci_header to reflect fact that there is one less key. */
      267 
      268       if common_ci_header.key_range.last = common_ci_header.key_range.first
      269       then common_ci_header.key_range.last, common_ci_header.key_range.first = 0;
      270       else common_ci_header.key_range.last = common_ci_header.key_range.last - 1;
      271 
      272 /**** Replace common_ci_header.  It is the datum described by the slot
      273*      with the index DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT.  The slot does
      274*      not change so is not replaced. */
      275 
      276       index_ci_header_slot_ptr =
      277 	 addcharno (node_ptr,
      278 	 DATUM_POSITION_TABLE_OFFSET_IN_BYTES + (DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT - 1) * BYTES_PER_WORD);
      279 
      280       ci_parts.part (INDEX_CI_HEADER_PART_IDX).offset_in_bytes = index_ci_header_slot.offset_in_bytes;
      281       ci_parts.part (INDEX_CI_HEADER_PART_IDX).length_in_bytes =
      282 	 divide (index_ci_header_slot.length_in_bits, BITS_PER_BYTE, 17, 0);
      283 						/* The index ci header is always an integral number of bytes long. */
      284       ci_parts.part (INDEX_CI_HEADER_PART_IDX).local_ptr = common_ci_header_ptr;
      285 
      286 /**** Actually modify the control interval in the file. */
      287 
      288       call file_manager_$put (file_opening_id, (key_ci_id), ci_parts_ptr, code);
      289       if code ^= 0
      290       then call ERROR_RETURN (code);
      291 
      292 
      293       if ^common_ci_header.is_leaf
      294       then if common_ci_header.key_range.last >= key_index
      295 	 then
      296 	    do;
      297 
      298 	    /*** There are keys higher than the one deleted,
      299*	         whose branch nodes need to have their
      300*	         parent_id_strings updated. Note that the key at
      301*	         key_index is now the one which was next higher
      302*	         than the deleted key, hence the check is for ">="
      303*	         instead of just ">". */
      304 
      305 	       call im_update_branches (node_ptr, file_opening_id, index_cursor.collection_id, common_ci_header_ptr,
      306 		  (key_ci_id), (key_index), code);
      307 	       if code ^= 0
      308 	       then call ERROR_RETURN (code);
      309 	    end;
      310 
      311       p_code = 0;
      312 MAIN_RETURN:
      313       return;
      314 
      315 
      316 FINISH:
      317    proc ();
      318    end FINISH;
      319 
      320 
      321 ERROR_RETURN:
      322    proc (er_p_code);
      323       dcl	    er_p_code	       fixed bin (35);
      324       call FINISH;
      325       p_code = er_p_code;
      326       goto MAIN_RETURN;
      327    end ERROR_RETURN;
      328 
      329 CHECK_VERSION:
      330    proc (p_received_version, p_expected_version, p_structure_name);
      331       dcl	    p_received_version     fixed bin (35);
      332       dcl	    p_expected_version     fixed bin (35);
      333       dcl	    p_structure_name       char (*);
      334 
      335       if p_expected_version ^= p_received_version
      336       then call sub_err_ (error_table_$unimplemented_version, myname, "s", null, 0,
      337 	      "^/Expected version ^d of the ^a structure. Received version ^d instead.", p_expected_version,
      338 	      p_structure_name, p_received_version);
      339 
      340    end CHECK_VERSION;
      341 
  1     1 /* BEGIN INCLUDE FILE - dm_im_cursor.incl.pl1 */
  1     2 
  1     3 /* DESCRIPTION:
  1     4*
  1     5*          This structure specifies a DM file, an index collection in that DM
  1     6*file, and a position (key) in that index collection.
  1     7*
  1     8**/
  1     9 
  1    10 /* HISTORY:
  1    11*
  1    12*Written by Lindsey Spratt, 03/29/82
  1    13*Modified:
  1    14*08/09/82 by Matthew Pierret: Changed collection_id from "fixed bin (17)" to
  1    15*            "bit (35) aligned".
  1    16*08/26/82 by Lindsey Spratt:  Changed to version 2.  Added the is_valid and
  1    17*	  is_at_end_of_index flags.  Changed the key_check_value to fixed
  1    18*	  bin (35).  Added the IM_HASH_BIAS, which is used to increment the
  1    19*	  value developed by hash_index_, and IM_HASH_NUMBER_OF_BUCKETS,
  1    20*	  which is a unique number used by hash_index_ to develop the
  1    21*	  key_check_value.
  1    22*02/23/83 by Lindsey Spratt: Changed to keep the current key value in the
  1    23*	  cursor.  Also, implemented the ability to have the cursor
  1    24*	  positioned before or after the index.  
  1    25*10/23/84 by Lindsey L. Spratt:  Added a description section.
  1    26**/
  1    27 
  1    28 /* format: style2,ind3 */
  1    29      dcl	   1 index_cursor	      based (index_cursor_ptr),
  1    30 	     2 type	      fixed bin (17) unaligned,
  1    31 	     2 version	      fixed bin (17) unaligned,
  1    32 	     2 file_opening_id    bit (36) aligned,
  1    33 	     2 collection_id      bit (36) aligned,
  1    34 	     2 key_id_string      bit (36) aligned,	/* Is the location of the current key, */
  1    35 						/* if flags.current_key_exists is on. Is the location */
  1    36 						/* of the end of the index if flags.is_at_end_of_index */
  1    37 						/* is on, which is only available via an operation */
  1    38 						/* requiring the "previous" key.  Is the location of */
  1    39 						/* the "next" key, otherwise. */
  1    40 	     2 area_ptr	      ptr,		/* Area in which the cursor and key_string area allocated. */
  1    41 						/* Must be a freeing area. */
  1    42 	     2 current_key_string_ptr
  1    43 			      ptr,		/* Points to the value of the current key. */
  1    44 	     2 current_key_string_length
  1    45 			      fixed bin (24) unal,	/* Is the length of the current key in bits. */
  1    46 	     2 pad	      bit (12) unal,
  1    47 	     2 flags	      aligned,
  1    48 	       3 is_at_beginning_of_index
  1    49 			      bit (1) unaligned,	/* Only the "next" key is defined. */
  1    50 	       3 is_at_end_of_index
  1    51 			      bit (1) unaligned,	/* Only the "previous" key is defined. */
  1    52 	       3 current_key_exists
  1    53 			      bit (1) unaligned,	/* If on, indicates that the "current" key is identified */
  1    54 						/* by the key_id_string.  If off, the "current" position */
  1    55 						/* is undefined, and the key_id_string identifies the */
  1    56 						/* previous or next key, depending on whether */
  1    57 						/* flags.is_at_end_of_index is off or on, respectively. */
  1    58 	       3 is_valid	      bit (1) unaligned,	/* If off, the index_manager_ was interrupted while */
  1    59 						/* setting the cursor position and the cursor is not */
  1    60 						/* to be trusted for relative position operations. */
  1    61 	       3 pad	      bit (32) unal;
  1    62 
  1    63 
  1    64      dcl	   index_cursor_ptr	      ptr;
  1    65 
  1    66      dcl	   INDEX_CURSOR_VERSION_3 fixed bin (17) init (3) internal static options (constant);
  1    67      dcl	   INDEX_CURSOR_TYPE      init (2) fixed bin (17) internal static options (constant);
  1    68 
  1    69 /* END INCLUDE FILE - dm_im_cursor.incl.pl1 */
      342 
      343 
  2     1 /* BEGIN INCLUDE FILE - dm_im_key.incl.pl1 */
  2     2 
  2     3 /* DESCRIPTION:
  2     4*
  2     5*          There are two formats for keys, the leaf_key structure and the
  2     6*     branch_key structure. The branch_key has two more pieces of information
  2     7*     than the leaf_key. One is the control interval id of the
  2     8*     node for all keys greater than the value of the branch key.  The other is
  2     9*     the number of fields for which there are values in the "string" portion
  2    10*     of the key.  This allows for the storing of only as much data as is needed
  2    11*     to discriminate between the children being split by the branch key.
  2    12**/
  2    13 
  2    14 /* HISTORY:
  2    15*
  2    16*Written by Lindsey Spratt, 03/29/82.
  2    17*Modified:
  2    18*10/25/84 by Lindsey L. Spratt:  Added history and description sections.
  2    19**/
  2    20 
  2    21 /* format: style2,ind3 */
  2    22      dcl	   key_string	      bit (key_string_length) based (key_string_ptr);
  2    23      dcl	   key_string_length      fixed bin (35);
  2    24      dcl	   key_string_ptr	      ptr;
  2    25 
  2    26      dcl	   1 leaf_key	      based (leaf_key_ptr) unaligned,
  2    27 	     2 string	      bit (lk_string_length) unal;
  2    28 
  2    29      dcl	   lk_string_length	      fixed bin (35);
  2    30      dcl	   leaf_key_ptr	      ptr;
  2    31 
  2    32      dcl	   1 branch_key	      based (branch_key_ptr) unaligned,
  2    33 	     2 branch_id	      fixed bin (24) unsigned unaligned,
  2    34 	     2 last_field_idx     fixed bin (12) unaligned unsigned,
  2    35 	     2 string	      bit (bk_string_length) unal;
  2    36 
  2    37      dcl	   BRANCH_KEY_HEADER_LENGTH_IN_BITS
  2    38 			      init (36) fixed bin (35) internal static options (constant);
  2    39      dcl	   bk_string_length	      fixed bin (35);
  2    40      dcl	   branch_key_ptr	      ptr;
  2    41 
  2    42 /* END INCLUDE FILE - dm_im_key.incl.pl1 */
      344 
      345 
  3     1 /* BEGIN INCLUDE FILE - dm_im_ci_header.incl.pl1 */
  3     2 
  3     3 /* DESCRIPTION:
  3     4*
  3     5*          Each node (control interval) in the index has a header which
  3     6*     describes the contents of that node.  Although there are two different
  3     7*     kinds of headers, leaf and branch, they have a great deal in common, the
  3     8*     common_ci_header.  The common_ci_header states which slots are used by
  3     9*     the keys (leaf or branch) in the key_range substructure.  There is an
  3    10*     "upward pointer" to the node's parent branch key (parent_id_string).
  3    11*     There are pointers to the previous and next nodes (previous_id and
  3    12*     next_id) on the same level to facilitate rotation of keys, and sequential
  3    13*     searching.  There is also a count of how much space is in use by the keys.
  3    14*
  3    15**/
  3    16 
  3    17 /* HISTORY:
  3    18*
  3    19*Written by Lindsey Spratt, 03/29/82.
  3    20*Modified:
  3    21*10/25/84 by Lindsey L. Spratt:  Added a description and fixed the history
  3    22*            section format.
  3    23**/
  3    24 
  3    25 /* format: style2,ind3 */
  3    26      dcl	   1 common_ci_header     based (common_ci_header_ptr),
  3    27 	     2 flags	      unaligned,
  3    28 	       3 is_leaf	      bit (1) unaligned,	/* ON for leaf_ci, OFF for branch_ci. */
  3    29 	       3 pad	      bit (17) unaligned,	/* Must be zero. */
  3    30 	     2 key_tail_space_used_since_last_prefix_compaction
  3    31 			      fixed bin (18) unsigned unal,
  3    32 	     2 key_range	      unaligned,
  3    33 	       3 first	      fixed bin (18) unsigned,
  3    34 	       3 last	      fixed bin (18) unsigned,
  3    35 	     2 parent_id_string   bit (36) aligned,
  3    36 	     2 previous_id	      fixed bin (24) unsigned unaligned,
  3    37 	     2 next_id	      fixed bin (24) unsigned unaligned,
  3    38 	     2 pad	      bit (24) unaligned;
  3    39 
  3    40 
  3    41      dcl	   common_ci_header_ptr   ptr;
  3    42 
  3    43      dcl	   1 leaf_ci_header	      based (leaf_ci_header_ptr),
  3    44 	     2 common	      like common_ci_header;
  3    45 
  3    46      dcl	   leaf_ci_header_ptr     ptr;
  3    47 
  3    48      dcl	   1 branch_ci_header     based (branch_ci_header_ptr),
  3    49 	     2 common	      like common_ci_header,
  3    50 	     2 low_branch_id      fixed bin (24) unsigned unaligned,
  3    51 	     2 pad	      bit (12) unaligned;
  3    52 
  3    53      dcl	   branch_ci_header_ptr   ptr;
  3    54 
  3    55 
  3    56      dcl	   (
  3    57 	   DEFAULT_INITIAL_KEY_SLOT
  3    58 			      init (2),
  3    59 	   DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT
  3    60 			      init (1),
  3    61 	   LEAF_CI_HEADER_LENGTH_IN_BITS
  3    62 			      init (180),
  3    63 	   BRANCH_CI_HEADER_LENGTH_IN_BITS
  3    64 			      init (216)
  3    65 	   )		      internal static options (constant) fixed bin;
  3    66 
  3    67 /* END INCLUDE FILE - dm_im_ci_header.incl.pl1 */
      346 
      347 
  4     1 /* BEGIN INCLUDE FILE dm_element_id.incl.pl1 */
  4     2 
  4     3 /* DESCRIPTION:
  4     4*
  4     5*        Contains the declaration of an element identifier.  Element
  4     6*   identifiers consist of two parts, the id (number) of the control interval
  4     7*   in which the element resides, and the index into the slot table of
  4     8*   the element in the control interval.  The declaration of the element_id 
  4     9*   structure reflects this division of the element identifier.  The structure 
  4    10*   is based on the automatic bit string element_id_string because programs
  4    11*   generally pass bit strings (element_id_string) to each other, then 
  4    12*   interpret the bit string by overlaying the element_id structure ony if
  4    13*   it is necessary to access the parts of the id.  Basing element_id on
  4    14*   addr(element_id_string) instead of on a pointer removes the necessity
  4    15*   for always setting that pointer explicitly and guarantees that changes
  4    16*   made to the string or structure do not get inconsistent.
  4    17*
  4    18*   Changes made to element_id must also be made to datum_id, declared in 
  4    19*   dm_cm_datum.incl.pl1.
  4    20**/
  4    21 
  4    22 /* HISTORY:
  4    23*Written by Matthew Pierret, 04/01/82.
  4    24*Modified:
  4    25*09/24/84 by Matthew Pierret: Added DESCRIPTION section.
  4    26**/
  4    27 
  4    28 /* format: style2,ind3,ll79 */
  4    29 
  4    30      dcl	   element_id_string      bit (36) aligned;
  4    31 
  4    32      dcl	   1 element_id	      aligned based (addr (element_id_string)),
  4    33 	     2 control_interval_id
  4    34 			      fixed bin (24) unal unsigned,
  4    35 	     2 index	      fixed bin (12) unal unsigned;
  4    36 
  4    37 
  4    38 /* END INCLUDE FILE dm_element_id.incl.pl1 */
      348 
      349 
  5     1 /* BEGIN INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
  5     2 
  5     3 /* DESCRIPTION:
  5     4*
  5     5*        The collection_manager_ manages the structure of the addressable
  5     6*   portion of a control interval.  The addressable portion is that portion of
  5     7*   a control interval which the file_manager_ will allow the
  5     8*   collection_manager_ to address.  In this description control interval will
  5     9*   be used to mean the addressable portion of a control interval.
  5    10*   
  5    11*        A control interval is divided into four parts: the header, the datum
  5    12*   position table (also known as the slot table or slots), un-used space and
  5    13*   used space.  The beginning of the header is at offset 0, and the end of the
  5    14*   used space is at the end of the control interval (curently offset 4072).
  5    15*   Pictoriarly, a control interval is structured as follows:
  5    16*   
  5    17*   ----------------------------------------------------------------------
  5    18*   |        || | | | | | ||               ||   | / / |       |/|   |    |
  5    19*   | Header || | slot  | || un-used space ||   |/ / /|       |/|   |    |
  5    20*   |        || | table | ||               ||   | / / |       |/|   |    |
  5    21*   |        || | | | | | ||               ||   |/ / /|       |/|   |    |
  5    22*   ----------------------------------------------------------------------
  5    23*                                           ^ ^    ^      ^    ^  ^   ^
  5    24*                                           | |    |      |    |  |   |
  5    25*                                           | |...........|.......|...|
  5    26*                        start of used space|      |           |      |
  5    27*                                                  |           |  each|
  5    28*                                          scattered free space|  is a used
  5    29*                                                                 datum
  5    30*   
  5    31*      The basic_control_interval structure describes the header
  5    32*   (basic_control_interval.header, bci_header) and the slots
  5    33*   (basic_control_interval.datum_position_table, datum_slot for one only).
  5    34*   Each datum_slot contains the offset (in bytes) and the length (in bits) of
  5    35*   a datum in the used space.  If the offset is equal to FREE_SLOT (declared
  5    36*   in dm_cm_basic_ci_const.incl.pl1), the slot is un-used.  The slot also
  5    37*   contains flags describing the type of datum (see dm_cm_datum.incl.pl1).
  5    38**/
  5    39 
  5    40 /* HISTORY:
  5    41*Written by Matthew Pierret, 02/07/82.
  5    42*Modified:
  5    43*03/25/82 by Matthew Pierret: Fixed alignment differences basic_control_interval
  5    44*            and its sub-structures.
  5    45*06/14/82 by Matthew Pierret: Removed common header and buffers. Changed
  5    46*            basic_ci_header to bci_header. Added previous_control_interval.
  5    47*07/12/82 by Matthew Pierret: Changed collection_id to be bit (36) aligned.
  5    48*10/29/82 by Matthew Pierret: Added flags to datum slots. 
  5    49*11/10/82 by Matthew Pierret: Removed continued_datum_is_present flag, as it
  5    50*            is not used.
  5    51*03/28/84 by Matthew Pierret: Added the constants BCI_HEADER_LENGTH_IN_BYTES
  5    52*            and DATUM_POSITION_TABLE_OFFSET_IN_BYTES.
  5    53**/
  5    54 
  5    55 /* format: style2 */
  5    56      dcl	   1 basic_control_interval
  5    57 			      aligned based (basic_control_interval_ptr),
  5    58 	     2 header	      like bci_header,
  5    59 	     2 datum_position_table
  5    60 			      (0 refer (basic_control_interval.number_of_datums)) like datum_slot;
  5    61 
  5    62 
  5    63      dcl	   1 bci_header	      aligned based (bci_header_ptr),
  5    64 	     2 layout_type	      char (4) aligned,
  5    65 	     2 collection_id      bit (36) aligned,
  5    66 	     2 next_control_interval
  5    67 			      fixed bin (24) uns unal,
  5    68 	     2 previous_control_interval
  5    69 			      fixed bin (24) uns unal,
  5    70 	     2 flags	      unal,
  5    71 	       3 continuation_datum_is_present
  5    72 			      bit (1) unal,
  5    73 	       3 free_slot_is_present
  5    74 			      bit (1) unal,
  5    75 	       3 must_be_zero     bit (4) unal,		/* reserved */
  5    76 	     2 scattered_free_space
  5    77 			      fixed bin (17) unal,
  5    78 	     2 start_of_used_space
  5    79 			      fixed bin (17) unal,
  5    80 	     2 number_of_datums   fixed bin (17) unal;
  5    81 
  5    82      dcl	   1 datum_slot	      aligned based (datum_slot_ptr),
  5    83 	     2 flags	      unal,
  5    84 	       3 special_format_datum
  5    85 			      bit (1) unal,		/* reserved */
  5    86 	       3 is_continued     bit (1) unal,
  5    87 	       3 is_continuation  bit (1) unal,
  5    88 	       3 mbz	      bit (1) unal,		/* reserved */
  5    89 	     2 offset_in_bytes    fixed bin (15) uns unal,
  5    90 	     2 length_in_bits     fixed bin (17) uns unal;
  5    91 
  5    92      dcl	   basic_control_interval_ptr
  5    93 			      ptr;
  5    94      dcl	   bci_header_ptr	      ptr;
  5    95      dcl	   datum_slot_ptr	      ptr;
  5    96 
  5    97      dcl	   BASIC_CI_LAYOUT_1      char (4) aligned init ("bci1") internal static options (constant);
  5    98 
  5    99 /* END INCLUDE FILE dm_cm_basic_ci.incl.pl1 */
      350 
      351 
  6     1 /* BEGIN INCLUDE FILE dm_cm_basic_ci_const.incl.pl1 */
  6     2 
  6     3 /* DESCRIPTION:
  6     4*
  6     5*   Contains constants useful in describing parts of a basic control interval.
  6     6**/
  6     7 
  6     8 /* HISTORY:
  6     9*Written by Matthew Pierret, 09/20/84.
  6    10*Modified:
  6    11**/
  6    12 
  6    13      dcl	   FREE_SLOT	      init (0) fixed bin (15) uns internal static options (constant);
  6    14      dcl	   BCI_HEADER_LENGTH_IN_BYTES
  6    15 			      init (20) fixed bin internal static options (constant);
  6    16      dcl	   DATUM_POSITION_TABLE_OFFSET_IN_BYTES
  6    17 			      init (20) fixed bin internal static options (constant);
  6    18 
  6    19 
  6    20 /* END INCLUDE FILE dm_cm_basic_ci_const.incl.pl1 */
      352 
      353 
  7     1 /*  BEGIN INCLUDE FILE:  dm_ci_parts.incl.pl1  */
  7     2 
  7     3 /* DESCRIPTION:
  7     4*
  7     5*        This include file contains the ci_parts structure.  This structure
  7     6*   is used across the file_manager_ interface to specify the parts of a
  7     7*   control interval to get or put.  If the number_of parts is equal to 0,
  7     8*   modules which take ci_parts interpret this case to mean to do everything
  7     9*   except the actual requested operation, i.e., lock the control interval
  7    10*   but don't get anything.  offset_in_bytes is the 0-originned offset in
  7    11*   bytes from the beginning of the addressable portion of the control interval.
  7    12*   An offset_in_bytes which is in the addressable portion is in error.
  7    13*   Likewise, if offset_in_bytes + length_in_bytes is outside of the addressable
  7    14*   portion, it is in error.
  7    15**/
  7    16 
  7    17 /* HISTORY:
  7    18*Written by Matthew Pierret, 01/28/82.
  7    19*  (01/28/82 Andre Bensoussan, Design.)
  7    20*Modified:
  7    21*11/07/84 by Matthew Pierret:  To add must_be_zero, initial attributes on
  7    22*            automatic storge.
  7    23**/
  7    24 
  7    25 /* format: style2,ind3 */
  7    26 
  7    27      dcl	   1 ci_parts	      aligned based (ci_parts_ptr),
  7    28 	     2 number_of_parts    fixed bin (17),
  7    29 	     2 must_be_zero	      fixed bin,
  7    30 	     2 part	      (cip_number_of_parts refer (ci_parts.number_of_parts)),
  7    31 	       3 offset_in_bytes  fixed bin (17),
  7    32 	       3 length_in_bytes  fixed bin (17),
  7    33 	       3 local_ptr	      ptr;
  7    34 
  7    35      dcl	   ci_parts_ptr	      ptr init (null ());
  7    36      dcl	   cip_number_of_parts    fixed bin (17) init (0);
  7    37 
  7    38 
  7    39 /*  BEGIN INCLUDE FILE:   dm_ci_parts.incl.pl1   */
      354 
      355 
  8     1 /* BEGIN INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
  8     2 
  8     3 /* DESCRIPTION:
  8     4*     This include file contains declarations of all collection_manager_ 
  8     5*     entrypoints.
  8     6**/
  8     7 
  8     8 /* HISTORY:
  8     9*Written by Matthew Pierret 
  8    10*Modified:
  8    11*04/14/82 by Lindsey Spratt: Changed the control_interval_id parameter of the
  8    12*	  allocate_control_interval operation to be unaligned, as well as
  8    13*	  unsigned.
  8    14*06/17/82 by Matthew Pierret: Added the put_element_portion opertion and
  8    15*            removed the beginning_location parameter from the put_element
  8    16*            operation. Added the create_page_file_operation.
  8    17*08/09/82 by Matthew Pierret: Changed "fixed bin (17)"s to "bit (36) aligned"s
  8    18*            wherever collection_id was required.
  8    19*            Also changed the control_interval_id parameter of the 
  8    20*            allocate_control_interval operation back to be aligned. So there.
  8    21*10/20/82 by Matthew Pierret: Changed $create_page_file to $create_file,
  8    22*            added the argument file_create_info_ptr to $create_file.
  8    23*12/13/82 by Lindsey Spratt:  Corrected $free_control_interval to
  8    24*	  include the zero_on_free bit.
  8    25*12/17/82 by Matthew Pierret: Added cm_$get_id.
  8    26*01/07/83 by Matthew Pierret: Added cm_$put_element_buffered, 
  8    27*            cm_$allocate_element_buffered, cm_$free_element_buffered.
  8    28*04/27/83 by Matthew Pierret: Added cm_$put_unprotected_element,
  8    29*            cm_$put_unprotected_header.
  8    30*11/07/83 by Matthew Pierret: Added $get_element_portion_buffered,
  8    31*             $simple_get_buffered_element.
  8    32*02/08/84 by Matthew Pierret:  Changed $get_id to have only one bit(1)aligned
  8    33*            parameter for specifying absolute/relative nature of search.
  8    34*03/16/84 by Matthew Pierret:  Added cm_$get_control_interval_ptr,
  8    35*            $get_element_ptr, $get_element_portion_ptr, $simple_get_element_ptr
  8    36*04/03/84 by Matthew Pierret:  Added cm_$compact_control_interval.
  8    37*06/06/84 by Matthew Pierret:  Re-named free_element* to delete and
  8    38*            delete_from_ci_buffer.
  8    39*            Re-named *_buffered_ci to =_ci_buffer.
  8    40*            get entries.
  8    41*            modify entries.
  8    42*            Changed calling sequence of modify entries to have a ptr/length
  8    43*            instead of length/ptr parameter pair.
  8    44*03/11/85 by R. Michael Tague:  Added $postcommit_increments.
  8    45**/
  8    46 
  8    47 /* This include file contains declarations of collection_manager_ entrypoints */
  8    48 
  8    49 /* format: style2,ind3 */
  8    50      dcl	   collection_manager_$allocate_control_interval
  8    51 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, fixed bin (35));
  8    52      dcl	   collection_manager_$compact_control_interval
  8    53 			      entry (bit (36) aligned, fixed bin (24) uns, fixed bin (35));
  8    54      dcl	   collection_manager_$create_collection
  8    55 			      entry (bit (36) aligned, ptr, ptr, bit (36) aligned, fixed bin (35));
  8    56      dcl	   collection_manager_$create_file
  8    57 			      entry (char (*), char (*), ptr, bit (36) aligned, fixed bin (35));
  8    58      dcl	   collection_manager_$destroy_collection
  8    59 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35));
  8    60      dcl	   collection_manager_$free_control_interval
  8    61 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, bit (1) aligned,
  8    62 			      fixed bin (35));
  8    63 
  8    64      dcl	   collection_manager_$delete
  8    65 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  8    66 			      fixed bin (35));
  8    67      dcl	   collection_manager_$delete_from_ci_buffer
  8    68 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, bit (1) aligned,
  8    69 			      fixed bin (35));
  8    70 
  8    71      dcl	   collection_manager_$get
  8    72 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17), ptr,
  8    73 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  8    74      dcl	   collection_manager_$get_control_interval_ptr
  8    75 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) unsigned, ptr,
  8    76 			      fixed bin (35));
  8    77      dcl	   collection_manager_$get_from_ci_buffer
  8    78 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  8    79 			      ptr, bit (1) aligned, ptr, fixed bin (35), fixed bin (35));
  8    80      dcl	   collection_manager_$get_by_ci_ptr
  8    81 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  8    82 			      fixed bin (35), ptr, bit (1) aligned, ptr, fixed bin (35), ptr, fixed bin (35));
  8    83      dcl	   collection_manager_$get_header
  8    84 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (17), ptr, bit (1) aligned,
  8    85 			      ptr, fixed bin (35), fixed bin (35));
  8    86      dcl	   collection_manager_$get_id
  8    87 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin (17),
  8    88 			      bit (1) aligned, bit (36) aligned, fixed bin (35));
  8    89      dcl	   collection_manager_$get_portion
  8    90 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, fixed bin, ptr,
  8    91 			      fixed bin (35), ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr,
  8    92 			      fixed bin (35), fixed bin (35));
  8    93      dcl	   collection_manager_$get_portion_from_ci_buffer
  8    94 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  8    95 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  8    96 			      fixed bin (35));
  8    97      dcl	   collection_manager_$get_portion_by_ci_ptr
  8    98 			      entry (ptr, bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35),
  8    99 			      ptr, fixed bin (35), fixed bin (35), bit (1) aligned, ptr, fixed bin (35),
  8   100 			      fixed bin (35));
  8   101      dcl	   collection_manager_$modify
  8   102 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  8   103 			      fixed bin (35), fixed bin (35));
  8   104      dcl	   collection_manager_$modify_unprotected
  8   105 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  8   106 			      fixed bin (35), fixed bin (35));
  8   107      dcl	   collection_manager_$modify_in_ci_buffer
  8   108 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  8   109 			      fixed bin (35), fixed bin (35));
  8   110      dcl	   collection_manager_$modify_portion
  8   111 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (35), fixed bin (35), ptr,
  8   112 			      fixed bin (35), bit (36) aligned, fixed bin (35), fixed bin (35));
  8   113      dcl	   collection_manager_$postcommit_increments
  8   114 			      entry (bit (36) aligned, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35));
  8   115      dcl	   collection_manager_$put
  8   116 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  8   117 			      fixed bin (35), fixed bin (35));
  8   118      dcl	   collection_manager_$put_in_ci_buffer
  8   119 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), bit (36) aligned,
  8   120 			      fixed bin (35), fixed bin (35));
  8   121      dcl	   collection_manager_$put_header
  8   122 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  8   123      dcl	   collection_manager_$put_unprotected_header
  8   124 			      entry (bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35));
  8   125 
  8   126      dcl	   collection_manager_$replace_ci_buffer
  8   127 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  8   128 			      fixed bin (35));
  8   129      dcl	   collection_manager_$setup_ci_buffer
  8   130 			      entry (bit (36) aligned, bit (36) aligned, fixed bin (24) uns, ptr, fixed bin (35),
  8   131 			      fixed bin (35));
  8   132      dcl	   collection_manager_$simple_get_by_ci_ptr
  8   133 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  8   134 			      fixed bin (35));
  8   135      dcl	   collection_manager_$simple_get_from_ci_buffer
  8   136 			      entry (ptr, bit (36) aligned, bit (36) aligned, ptr, fixed bin (35), fixed bin (35),
  8   137 			      fixed bin (35));
  8   138 
  8   139 /* END INCLUDE FILE dm_collmgr_entry_dcls.incl.pl1 */
      356 
      357    end im_simple_delete;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/04/85  0913.4  im_simple_delete.pl1              >spec>on>7192.pbf-04/04/85>im_simple_delete.pl1
342          1    01/07/85  0858.9  dm_im_cursor.incl.pl1             >ldd>include>dm_im_cursor.incl.pl1
344          2    01/07/85  0858.9  dm_im_key.incl.pl1                >ldd>include>dm_im_key.incl.pl1
346          3    01/07/85  0858.8  dm_im_ci_header.incl.pl1          >ldd>include>dm_im_ci_header.incl.pl1
348          4    01/07/85  0858.5  dm_element_id.incl.pl1            >ldd>include>dm_element_id.incl.pl1
350          5    01/07/85  0858.0  dm_cm_basic_ci.incl.pl1           >ldd>include>dm_cm_basic_ci.incl.pl1
352          6    01/07/85  0858.1  dm_cm_basic_ci_const.incl.pl1     >ldd>include>dm_cm_basic_ci_const.incl.pl1
354          7    01/07/85  0900.8  dm_ci_parts.incl.pl1              >ldd>include>dm_ci_parts.incl.pl1
356          8    04/04/85  0819.0  dm_collmgr_entry_dcls.incl.pl1    >spec>on>7192.pbf-04/04/85>dm_collmgr_entry_dcls.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BCI_HEADER_LENGTH_IN_BYTES             constant        fixed bin(17,0)          initial dcl 6-14 ref 263
BCI_HEADER_PART_IDX                    constant        fixed bin(17,0)          initial dcl 157 ref 261 263 264
BITS_PER_BYTE                   000752 constant        fixed bin(17,0)          initial dcl 151 ref 253 281
BRANCH_KEY_HEADER_LENGTH_IN_BITS       constant        fixed bin(35,0)          initial dcl 2-37 ref 221
BYTES_PER_WORD                         constant        fixed bin(17,0)          initial dcl 151 ref 212 234 236 241 243 276
DATUM_POSITION_TABLE_OFFSET_IN_BYTES   constant        fixed bin(17,0)          initial dcl 6-16 ref 212 241 276
DEFAULT_INDEX_CONTROL_INTERVAL_HEADER_SLOT
                                       constant        fixed bin(17,0)          initial dcl 3-56 ref 276
INDEX_CI_HEADER_PART_IDX               constant        fixed bin(17,0)          initial dcl 157 ref 280 281 284
INDEX_CURSOR_TYPE               000020 constant        fixed bin(17,0)          initial dcl 1-67 set ref 192 192*
INDEX_CURSOR_VERSION_3                 constant        fixed bin(17,0)          initial dcl 1-66 ref 196
LAST_SLOT_PART_IDX                     constant        fixed bin(17,0)          initial dcl 157 ref 241 243 244
NUMBER_OF_PARTS                        constant        fixed bin(17,0)          initial dcl 157 ref 208
TRAILING_SLOTS_PART_IDX                constant        fixed bin(17,0)          initial dcl 157 ref 228 233 234 236
ZERO_SLOT                       000015 constant        fixed bin(35,0)          initial dcl 155 set ref 244
addcharno                                              builtin function         dcl 145 ref 213 236 276
addr                                                   builtin function         dcl 145 ref 201 202 207 244 264
bci_header                             based           structure                level 1 dcl 5-63 ref 206
branch_ci_header_ptr            000156 automatic       pointer                  dcl 3-53 set ref 199*
ceil                                                   builtin function         dcl 145 ref 253
ci_parts                               based           structure                level 1 dcl 7-27
ci_parts_ptr                    000160 automatic       pointer                  initial dcl 7-35 set ref 207* 208 228 233 234 236
                                                                                  241 243 244 261 263 264 280 281 284 288* 7-35*
cip_number_of_parts             000162 automatic       fixed bin(17,0)          initial dcl 7-36 set ref 7-36*
code                            000100 automatic       fixed bin(35,0)          initial dcl 120 set ref 120* 185* 288* 289 289* 305*
                                                                                  307 307*
collection_id             2            based           bit(36)                  level 2 dcl 1-29 set ref 305*
common_ci_header                       based           structure                level 1 unaligned dcl 3-26
common_ci_header_ptr            000152 automatic       pointer                  dcl 3-41 set ref 199* 218 218 218 221 221 268 268
                                                                                  268 268 270 270 284 293 293 305*
control_interval_id                    based           fixed bin(24,0)          level 2 packed unsigned unaligned dcl 139 ref 201
datum_slot                             based           structure                level 1 dcl 5-82
divide                                                 builtin function         dcl 145 ref 253 281
dm_error_$wrong_cursor_type     000020 external static fixed bin(35,0)          dcl 176 set ref 192*
element_id                             based           structure                level 1 dcl 4-32
er_p_code                              parameter       fixed bin(35,0)          dcl 323 ref 321 325
error_table_$unimplemented_version
                                000016 external static fixed bin(35,0)          dcl 176 set ref 335*
file_manager_$put               000010 constant        entry                    external dcl 169 ref 288
file_opening_id                 000101 automatic       bit(36)                  dcl 121 in procedure "im_simple_delete" set ref 197*
                                                                                  288* 305*
file_opening_id           1            based           bit(36)                  level 2 in structure "index_cursor" dcl 1-29
                                                                                  in procedure "im_simple_delete" ref 197
first                     1            based           fixed bin(18,0)          level 3 packed unsigned unaligned dcl 3-26 set ref
                                                                                  268 268*
flags                                  based           structure                level 2 packed unaligned dcl 3-26
im_update_branches              000012 constant        entry                    external dcl 170 ref 305
index                     0(24)        based           fixed bin(12,0)          level 2 packed unsigned unaligned dcl 139 ref 202
index_ci_header_slot                   based           structure                level 1 dcl 140
index_ci_header_slot_ptr        000102 automatic       pointer                  initial dcl 122 set ref 122* 276* 280 281
index_cursor                           based           structure                level 1 unaligned dcl 1-29
index_cursor_ptr                000150 automatic       pointer                  dcl 1-64 set ref 191* 192 192 196 197 305
is_leaf                                based           bit(1)                   level 3 packed unaligned dcl 3-26 ref 218 293
key_ci_id                       000104 automatic       fixed bin(24,0)          unsigned dcl 124 set ref 201* 288 305
key_index                       000105 automatic       fixed bin(12,0)          unsigned dcl 125 set ref 202* 212 228 234 293 305
key_length_in_bits              000106 automatic       fixed bin(35,0)          dcl 126 set ref 216* 218 221 253
key_length_in_bytes             000107 automatic       fixed bin(17,0)          dcl 127 set ref 253* 255 258
key_offset_in_bytes             000110 automatic       fixed bin(17,0)          dcl 128 set ref 215* 255
key_range                 1            based           structure                level 2 packed unaligned dcl 3-26
key_slot                               based           structure                level 1 dcl 141
key_slot_offset_in_bytes        000111 automatic       fixed bin(17,0)          dcl 129 set ref 212* 213 233 236
key_slot_ptr                    000112 automatic       pointer                  initial dcl 131 set ref 131* 213* 215 216
key_tail_space_used_since_last_prefix_compaction
                          0(18)        based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 3-26 set ref
                                                                                  218* 218 221* 221
last                      1(18)        based           fixed bin(18,0)          level 3 packed unsigned unaligned dcl 3-26 set ref
                                                                                  268 268* 270* 270 293
leaf_ci_header_ptr              000154 automatic       pointer                  dcl 3-46 set ref 199*
length_in_bits            0(19)        based           fixed bin(17,0)          level 2 in structure "key_slot" packed unsigned
                                                                                  unaligned dcl 141 in procedure "im_simple_delete"
                                                                                  ref 216
length_in_bits            0(19)        based           fixed bin(17,0)          level 2 in structure "index_ci_header_slot" packed
                                                                                  unsigned unaligned dcl 140 in procedure
                                                                                  "im_simple_delete" ref 281
length_in_bytes           3            based           fixed bin(17,0)          array level 3 dcl 7-27 set ref 228* 234* 243* 263*
                                                                                  281*
local_bci_header                000114 automatic       structure                level 1 dcl 132 set ref 206* 264
local_ci_parts_buffer           000122 automatic       fixed bin(71,0)          initial array dcl 133 set ref 133* 207
local_ptr                 4            based           pointer                  array level 3 dcl 7-27 set ref 236* 244* 264* 284*
max                                                    builtin function         dcl 145 ref 218 221
myname                          000000 constant        char(16)                 initial unaligned dcl 150 set ref 192* 335*
node_ptr                        000146 automatic       pointer                  initial dcl 135 set ref 135* 189* 206 213 236 276
                                                                                  305*
null                                                   builtin function         dcl 145 ref 122 131 135 192 192 7-35 335 335
number_of_datums          4(18) 000114 automatic       fixed bin(17,0)          level 2 packed unaligned dcl 132 set ref 228 234 241
                                                                                  252* 252
number_of_parts                        based           fixed bin(17,0)          level 2 dcl 7-27 set ref 208*
offset_in_bytes           0(04)        based           fixed bin(15,0)          level 2 in structure "index_ci_header_slot" packed
                                                                                  unsigned unaligned dcl 140 in procedure
                                                                                  "im_simple_delete" ref 280
offset_in_bytes           0(04)        based           fixed bin(15,0)          level 2 in structure "key_slot" packed unsigned
                                                                                  unaligned dcl 141 in procedure "im_simple_delete"
                                                                                  ref 215
offset_in_bytes           2            based           fixed bin(17,0)          array level 3 in structure "ci_parts" dcl 7-27
                                                                                  in procedure "im_simple_delete" set ref 233* 241*
                                                                                  261* 280*
p_code                                 parameter       fixed bin(35,0)          dcl 116 set ref 106 311* 325*
p_common_ci_header_ptr                 parameter       pointer                  dcl 114 ref 106 199
p_expected_version                     parameter       fixed bin(35,0)          dcl 332 set ref 329 335 335*
p_index_cursor_ptr                     parameter       pointer                  dcl 113 ref 106 191
p_key_id                               based           structure                level 1 dcl 139
p_key_id_string                        parameter       bit(36)                  dcl 115 set ref 106 201 202
p_node_ptr                             parameter       pointer                  dcl 112 ref 106 189
p_received_version                     parameter       fixed bin(35,0)          dcl 331 set ref 329 335 335*
p_structure_name                       parameter       char                     unaligned dcl 333 set ref 329 335*
part                      2            based           structure                array level 2 dcl 7-27
scattered_free_space      3(18) 000114 automatic       fixed bin(17,0)          level 2 packed unaligned dcl 132 set ref 258* 258
start_of_used_space       4     000114 automatic       fixed bin(17,0)          level 2 packed unaligned dcl 132 set ref 255 255*
                                                                                  255
sub_err_                        000014 constant        entry                    external dcl 172 ref 192 335
type                                   based           fixed bin(17,0)          level 2 packed unaligned dcl 1-29 set ref 192 192*
unspec                                                 builtin function         dcl 145 set ref 206* 206
version                   0(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 1-29 ref 196

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BASIC_CI_LAYOUT_1                      internal static char(4)                  initial dcl 5-97
BRANCH_CI_HEADER_LENGTH_IN_BITS        internal static fixed bin(17,0)          initial dcl 3-56
DEFAULT_INITIAL_KEY_SLOT               internal static fixed bin(17,0)          initial dcl 3-56
FREE_SLOT                              internal static fixed bin(15,0)          initial unsigned dcl 6-13
LEAF_CI_HEADER_LENGTH_IN_BITS          internal static fixed bin(17,0)          initial dcl 3-56
basic_control_interval                 based           structure                level 1 dcl 5-56
basic_control_interval_ptr             automatic       pointer                  dcl 5-92
bci_header_ptr                         automatic       pointer                  dcl 5-94
bk_string_length                       automatic       fixed bin(35,0)          dcl 2-39
branch_ci_header                       based           structure                level 1 unaligned dcl 3-48
branch_key                             based           structure                level 1 packed unaligned dcl 2-32
branch_key_ptr                         automatic       pointer                  dcl 2-40
collection_manager_$allocate_control_interval
                                000000 constant        entry                    external dcl 8-50
collection_manager_$compact_control_interval
                                000000 constant        entry                    external dcl 8-52
collection_manager_$create_collection
                                000000 constant        entry                    external dcl 8-54
collection_manager_$create_file 000000 constant        entry                    external dcl 8-56
collection_manager_$delete      000000 constant        entry                    external dcl 8-64
collection_manager_$delete_from_ci_buffer
                                000000 constant        entry                    external dcl 8-67
collection_manager_$destroy_collection
                                000000 constant        entry                    external dcl 8-58
collection_manager_$free_control_interval
                                000000 constant        entry                    external dcl 8-60
collection_manager_$get         000000 constant        entry                    external dcl 8-71
collection_manager_$get_by_ci_ptr
                                000000 constant        entry                    external dcl 8-80
collection_manager_$get_control_interval_ptr
                                000000 constant        entry                    external dcl 8-74
collection_manager_$get_from_ci_buffer
                                000000 constant        entry                    external dcl 8-77
collection_manager_$get_header  000000 constant        entry                    external dcl 8-83
collection_manager_$get_id      000000 constant        entry                    external dcl 8-86
collection_manager_$get_portion 000000 constant        entry                    external dcl 8-89
collection_manager_$get_portion_by_ci_ptr
                                000000 constant        entry                    external dcl 8-97
collection_manager_$get_portion_from_ci_buffer
                                000000 constant        entry                    external dcl 8-93
collection_manager_$modify      000000 constant        entry                    external dcl 8-101
collection_manager_$modify_in_ci_buffer
                                000000 constant        entry                    external dcl 8-107
collection_manager_$modify_portion
                                000000 constant        entry                    external dcl 8-110
collection_manager_$modify_unprotected
                                000000 constant        entry                    external dcl 8-104
collection_manager_$postcommit_increments
                                000000 constant        entry                    external dcl 8-113
collection_manager_$put         000000 constant        entry                    external dcl 8-115
collection_manager_$put_header  000000 constant        entry                    external dcl 8-121
collection_manager_$put_in_ci_buffer
                                000000 constant        entry                    external dcl 8-118
collection_manager_$put_unprotected_header
                                000000 constant        entry                    external dcl 8-123
collection_manager_$replace_ci_buffer
                                000000 constant        entry                    external dcl 8-126
collection_manager_$setup_ci_buffer
                                000000 constant        entry                    external dcl 8-129
collection_manager_$simple_get_by_ci_ptr
                                000000 constant        entry                    external dcl 8-132
collection_manager_$simple_get_from_ci_buffer
                                000000 constant        entry                    external dcl 8-135
datum_slot_ptr                         automatic       pointer                  dcl 5-95
element_id_string                      automatic       bit(36)                  dcl 4-30
key_string                             based           bit                      unaligned dcl 2-22
key_string_length                      automatic       fixed bin(35,0)          dcl 2-23
key_string_ptr                         automatic       pointer                  dcl 2-24
leaf_ci_header                         based           structure                level 1 unaligned dcl 3-43
leaf_key                               based           structure                level 1 packed unaligned dcl 2-26
leaf_key_ptr                           automatic       pointer                  dcl 2-30
lk_string_length                       automatic       fixed bin(35,0)          dcl 2-29
size                                                   builtin function         dcl 145

NAMES DECLARED BY EXPLICIT CONTEXT.
CHECK_VERSION                   000631 constant        entry                    internal dcl 329 ref 196
ERROR_RETURN                    000621 constant        entry                    internal dcl 321 ref 289 307
FINISH                          000617 constant        entry                    internal dcl 316 ref 324
MAIN_RETURN                     000616 constant        label                    dcl 312 ref 326
im_simple_delete                000105 constant        entry                    external dcl 106

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1060        1102     753        1070
Length      1440     753        22         321     104           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
im_simple_delete                    258 external procedure  is an external procedure.  
FINISH                                  internal procedure  shares stack frame of external procedure im_simple_delete.  
ERROR_RETURN                            internal procedure  shares stack frame of external procedure im_simple_delete.  
CHECK_VERSION                           internal procedure  shares stack frame of external procedure im_simple_delete.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
im_simple_delete         000100 code                        im_simple_delete
                         000101 file_opening_id             im_simple_delete
                         000102 index_ci_header_slot_ptr    im_simple_delete
                         000104 key_ci_id                   im_simple_delete
                         000105 key_index                   im_simple_delete
                         000106 key_length_in_bits          im_simple_delete
                         000107 key_length_in_bytes         im_simple_delete
                         000110 key_offset_in_bytes         im_simple_delete
                         000111 key_slot_offset_in_bytes    im_simple_delete
                         000112 key_slot_ptr                im_simple_delete
                         000114 local_bci_header            im_simple_delete
                         000122 local_ci_parts_buffer       im_simple_delete
                         000146 node_ptr                    im_simple_delete
                         000150 index_cursor_ptr            im_simple_delete
                         000152 common_ci_header_ptr        im_simple_delete
                         000154 leaf_ci_header_ptr          im_simple_delete
                         000156 branch_ci_header_ptr        im_simple_delete
                         000160 ci_parts_ptr                im_simple_delete
                         000162 cip_number_of_parts         im_simple_delete

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              ext_entry           ceil_fx1            divide_fx1

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
file_manager_$put             im_update_branches            sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dm_error_$wrong_cursor_type   error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    106 000100       120 000112       122 000113       131 000115       133 000116       135 000134    7   35 000136
 7   36 000137       185 000140       189 000141       191 000145       192 000150       196 000231       197 000246
    199 000251       201 000257       202 000262       206 000265       207 000271       208 000273       212 000275
    213 000302       215 000305       216 000311       218 000314       221 000340       228 000362       233 000373
    234 000377       236 000403       241 000410       243 000417       244 000421       252 000423       253 000426
    255 000435       258 000446       261 000453       263 000455       264 000460       268 000462       270 000477
    276 000502       280 000510       281 000516       284 000522       288 000523       289 000542       293 000546
    305 000556       307 000610       311 000614       312 000616       316 000617       318 000620       321 000621
    324 000623       325 000624       326 000630       329 000631       335 000642       340 000726


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
