	COMPILATION LISTING OF SEGMENT pfm_utils_
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: CGI                             
	Compiled on: 2000-01-27_1813.74_Thu_mst
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 /****^  HISTORY COMMENTS:
       11*  1) change(82-11-29,Bush), approve(), audit(), install():
       12*     Created.
       13*  2) change(83-11-06,Bush), approve(), audit(), install():
       14*     Modified to fix bug causing repeatative opening of same file to not
       15*     position to correct file.
       16*  3) change(85-06-07,GWMay), approve(85-06-07,MECR0125),
       17*     audit(85-06-07,GDixon), install():
       18*     Changed arrays IFH_BKS_CNT and NLB_BKS_CNT to position to proper place on
       19*     the tape in routine FILE_POSITION(1).
       20*  4) change(85-10-24,GWMay), approve(85-10-24,MCR7256), audit(85-12-16,GDixon),
       21*     install(85-12-17,MR12.0-1001):
       22*     Formally install changes in MECR0125.
       23*  5) change(87-08-17,GWMay), approve(87-09-09,MECR0006),
       24*     audit(87-09-04,Farley), install(87-09-09,MR12.1-1101):
       25*     Initialized pointers were needed and moved checks for pointers from a
       26*     location where the pointer may not be set to a correct location.
       27*  6) change(87-10-19,GWMay), approve(87-10-19,MCR7779), audit(87-11-02,Farley),
       28*     install(87-11-30,MR12.2-1006):
       29*     Formally install MECR0006.
       30*  7) change(88-02-03,GWMay), approve(88-02-03,MCR7837), audit(88-04-12,Farley),
       31*     install(88-04-19,MR12.2-1039):
       32*     Fixed bug to allow unlabeled tapes to be read.
       33*  8) change(00-01-26,Schroth), approve(00-01-26,MECR-Y2K):
       34*     Change julian_date to use "0" prefix for dates after 1999-12-31.
       35*     Added label_unexpired entry to check if a date recorded in a label
       36*     has expired.
       37*                                                   END HISTORY COMMENTS */
       38 
       39 
       40 /* 	This procedure embodies a group of utility subroutines for the     */
       41 /*	mtape_ per-format modules.			                 */
       42 
       43 
       44 pfm_utils_: procedure;
       45 
       46 /* format: style4 */
       47 
       48 
       49 /*		ARGUMENT DATA		*/
       50 
       51 dcl  arg_mtdp ptr;					/* Pointer to the mtape_ data structure */
       52 dcl  link_head ptr;					/* Pointer to the head of a linked list of structures */
       53 dcl  link_tail ptr;					/* Pointer to the tail of a linked list of structures */
       54 dcl  arg_length fixed bin (21);			/* length of label record in bytes */
       55 dcl  arg_lr_ptr ptr;				/* Pointer to allocated label record structure */
       56 dcl  arg_code fixed bin (35);				/* return error code */
       57 dcl  arg_ltype fixed bin;				/* 1 => BOF; 2 => EOV; 3 => EOF */
       58 dcl  arg_fi_ptr ptr;				/* Callers file info structure ptr */
       59 dcl  arg_vs_ptr ptr;				/* Callers volume info structure */
       60 dcl  desired_position fixed bin;			/* To position within file */
       61 dcl  new_section bit (1) aligned;			/* "0"b =>  new file; "1"b => new file section */
       62 
       63 /*		AUTOMATIC DATA		*/
       64 
       65 dcl  (code, rfl_code, wfl_code) fixed bin (35);
       66 dcl  (ver_ptr, nvp, nfip, nlp, pp) ptr;
       67 dcl  (ltype, lab_num, bks_file_cnt, fwd_file_cnt, neofs, space_files, htype,
       68      target_position, convert, prev_seq) fixed bin;
       69 dcl  (term, term1, term2, found, forward) bit (1) aligned;
       70 dcl  pic4 picture "9999";
       71 
       72 /*		CONSTANT DATA	*/
       73 
       74 dcl  IFH_BKS_CNT (0:5) fixed bin int static options (constant) init
       75 	(0, 0, 1, 2, 2, 2);				/* files to bks to position to file hdr */
       76 dcl  NLB_BKS_CNT (0:5) fixed bin int static options (constant) init
       77 	(0, 0, 0, 0, 1, 1);				/* files to bks to position to BOF for unlabeled file */
       78 dcl  LC char (26) int static options (constant) init
       79 	("abcdefghijklmnopqrstuvwxyz");
       80 dcl  UC char (26) int static options (constant) init
       81 	("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
       82 
       83 /*		EXTERNAL STATIC DATA	*/
       84 
       85 dcl  error_table_$lost_device_position fixed bin (35) ext static;
       86 dcl  error_table_$end_of_info fixed bin (35) ext static;
       87 dcl  error_table_$eov_on_write fixed bin (35) ext static;
       88 dcl  error_table_$invalid_label_format fixed bin (35) ext static;
       89 dcl  error_table_$invalid_file_set_format fixed bin (35) ext static;
       90 dcl  error_table_$file_aborted fixed bin (35) ext static;
       91 dcl  error_table_$uninitialized_volume fixed bin (35) ext static;
       92 dcl  error_table_$no_file fixed bin (35) ext static;
       93 dcl  error_table_$no_next_volume fixed bin (35) ext static;
       94 
       95 /*		BUILTIN FUNCTIONS		*/
       96 
       97 dcl  (clock, mod, null, substr, translate) builtin;
       98 
       99 /*		EXTERNAL ENTRIES		*/
      100 
      101 dcl  mtape_$alloc entry (ptr, fixed bin, ptr, fixed bin (21), ptr);
      102 dcl  mtape_$error entry options (variable);
      103 dcl  mtape_$volume_switch entry (ptr, ptr, fixed bin (35));
      104 dcl  mtape_$order entry (ptr, char (*), fixed bin, ptr, fixed bin (35));
      105 dcl  mtape_$read_label entry (ptr, ptr, fixed bin (35));
      106 dcl  mtape_$user_query entry (ptr, fixed bin, fixed bin (35));
      107 dcl  mtape_$write_label entry (ptr, ptr, fixed bin (35));
      108 dcl  convert_date_to_binary_ entry (char (*), fixed bin (71), fixed bin (35));
      109 dcl  datebin_ entry (fixed bin (71), fixed bin, fixed bin, fixed bin, fixed bin, fixed bin, fixed bin,
      110 	fixed bin, fixed bin, fixed bin);
      111 dcl  datebin_$dayr_clk entry (fixed bin (71), fixed bin);
      112 
      113 /*		BASED DATA		*/
      114 
      115 dcl  based_label_record char (mtape_label_record.lab_length) based (mtape_label_record.lab_ptr);
      116 dcl  based_area area based (mtape_data.areap);
      117 
      118 /* init_label_record - entry to allocate label record structure and storage for
      119*   label record and link them in */
      120 
      121 init_label_record: entry (arg_mtdp, link_tail, link_head, arg_lr_ptr, arg_length);
      122 
      123 	mtdp = arg_mtdp;				/* copy mtape_ data pointer */
      124 	call mtape_$alloc (mtdp, MTAPE_ALLOC_LR, link_tail, 0, lr_ptr);
      125 	link_tail = lr_ptr;				/* Link this label record in */
      126 	if link_head = null then			/* if this is first time through */
      127 	     link_head = lr_ptr;			/* set link head also */
      128 	mtape_label_record.lab_length = arg_length;	/* initialize the LR structure */
      129 	mtape_label_record.mode = MTAPE_HWM_NINE;	/* ANSI labels are always nine track mode */
      130 	mtape_label_record.conversion = MTAPE_CV_UC_ASCII;/* convert to upper case for writting */
      131 	call mtape_$alloc (mtdp, MTAPE_ALLOC_STR, null, arg_length, mtape_label_record.lab_ptr);
      132 	based_label_record = "";			/* initialize to all blanks */
      133 	arg_lr_ptr = lr_ptr;			/* copy return argument */
      134 	return;					/* and return to caller */
      135 
      136 
      137 /* julian_date - entry to format date in form " yyddd" */
      138 
      139 julian_date: entry (date_time) returns (char (6) unaligned);
      140 
      141 dcl  date_time char (*);
      142 dcl  clock_value fixed bin (71);
      143 dcl  ddd picture "999";				/* day of year */
      144 dcl  yy picture "99";				/* year */
      145 dcl  temp fixed bin;				/* temporary */
      146 
      147 	/* This entry formats a date string into julian date suitable for use in a tape label.
      148*	   The format of the label date is "cyyddd", where:
      149*	     c is a century indicator
      150*	      - " " --> 1900's
      151*	      - "0" --> 2000's.  (We don't care about other centuries!)
      152*	   A label of "x99365" is a special flag date meaning forever. */
      153 
      154 	clock_value = clock ();			/* Use todays date as default */
      155 	if date_time ^= "" then			/* if date time given. */
      156 	     call convert_date_to_binary_ (date_time, clock_value, code); /* Use that instead of today */
      157 	call datebin_$dayr_clk (clock_value, temp);	/* get day of year */
      158 	ddd = temp;				/* convert to characters */
      159 	call datebin_ (clock_value, 0, 0, 0, temp, 0, 0, 0, 0, 0); /* get year */
      160 	yy = mod (temp, 100);			/* drop century and convert to characters */
      161 	if temp < 2000 then
      162 	     return (" " || yy || ddd);		/* return formatted date */
      163 	else return ("0" || yy || ddd);		/* return formatted date in 21st century */
      164 
      165 
      166 /* label_unexpired - entry to check if expiry date still holds */
      167 
      168 label_unexpired: entry (label_date) returns (bit (1) aligned);
      169 
      170 dcl  label_date char (*);
      171 dcl  today char (6);
      172 dcl  EXPIRED bit (1) internal static options (constant) init ("0"b);
      173 dcl  UNEXPIRED bit (1) internal static options (constant) init ("1"b);
      174 
      175 	if label_date = " 00000" then			/* " 00000" means no expiry set, i.e. expired */
      176 	     return (EXPIRED);
      177 	else if substr (label_date, 2, 5) = "99365" then	/* "99365" is a keep forever date */
      178 	     return (UNEXPIRED);
      179 	else do;
      180 	     today = julian_date ("");
      181 	     if label_date > today then		/* not expired yet */
      182 		return (UNEXPIRED);
      183 	     else return (EXPIRED);
      184          end;
      185 
      186 
      187 /* position_in_file - entry to position tape to indicated position within file */
      188 
      189 position_in_file: entry (arg_mtdp, arg_fi_ptr, arg_vs_ptr, desired_position, arg_code);
      190 
      191 	mtdp = arg_mtdp;				/* copy arg */
      192 	vs_ptr = arg_vs_ptr;
      193 	fi_ptr = arg_fi_ptr;
      194 	maip = mtape_data.attach_info_ptr;
      195 	moip = mtape_data.open_info_ptr;
      196 	mpfmip = mtape_data.pfm_info_ptr;
      197 	code = 0;
      198 	if mtape_file_info.position_within_file = NOT_POSITIONED_IN_FILE then do;
      199 	     code = error_table_$lost_device_position;	/* set appropriate error code */
      200 	     call mtape_$error (mtdp, code,
      201 		"^/^a ^a is not positioned within the file boundaries for file ^a",
      202 		"Attempting to position within file and history indicates that tape volume",
      203 		mtape_vol_set.volume_id, mtape_file_info.file_id);
      204 	     go to PIF_RETURN;
      205 	end;
      206 	fwd_file_cnt = 0;
      207 	go to FILE_POSITION (desired_position);		/* take apropriate action */
      208 
      209 FILE_POSITION (1):					/* position to beginning of data file */
      210 	if mtape_file_info.first_file_section_ptr ^= fi_ptr then do; /* we have to do volume switch */
      211 	     fi_ptr = mtape_file_info.first_file_section_ptr; /* go to first file section */
      212 	     vs_ptr = mtape_file_info.begin_vs_ptr;	/* get ptr to VS structure of new volume */
      213 	     call mtape_$volume_switch (mtdp, vs_ptr, code); /* do the switch */
      214 	     if code ^= 0 then do;			/* if some problem */
      215 		call mtape_$error (mtdp, code,	/* report it */
      216 		     "^/Attempting to mount volume ""^a"" on which the beginning of file ""^a"" is located.",
      217 		     mtape_vol_set.volume_id, mtape_file_info.file_id);
      218 		return;				/* and get out */
      219 	     end;
      220 	     fwd_file_cnt = (mtape_file_info.phy_file - mtape_data.phy_file) + 1; /* files to forward space */
      221 	end;
      222 
      223 FILE_POSITION (3):					/* position to beginning of file section */
      224 	if mtape_file_info.first_file_on_volume then do;	/* if this is true, can rewind */
      225 	     call REWIND_TO_BOF;			/* go rewind the volume and space over vol labels */
      226 	     if code ^= 0 then
      227 		go to PIF_RETURN;
      228 	     fwd_file_cnt = 0;			/* zero it out so we don't go forward */
      229 	end;
      230 	else if fwd_file_cnt = 0 then do;		/* not 1st file on vol, must bks */
      231 	     fwd_file_cnt = 1;			/* must also forward space 1 file */
      232 	     if mtape_attach_info.labeled then		/* if labeled tape */
      233 		bks_file_cnt = IFH_BKS_CNT (mtape_file_info.position_within_file);
      234 	     else bks_file_cnt = NLB_BKS_CNT (mtape_file_info.position_within_file);
      235 	     call mtape_$order (mtdp, "bsf", bks_file_cnt, null, code); /* backup desired files */
      236 	     if code ^= 0 then do;
      237 		call mtape_$error (mtdp, code,
      238 		     "^/^a ^[headers^;^;^;section^] for file ^a on volume ^a",
      239 		     "Attempting to backspace to the beginning of file", desired_position + 1,
      240 		     mtape_file_info.file_id, mtape_vol_set.volume_id);
      241 		go to PIF_RETURN;
      242 	     end;
      243 	end;
      244 	if fwd_file_cnt > 0 then do;
      245 	     call mtape_$order (mtdp, "fsf", fwd_file_cnt, null, code); /* forward required files */
      246 	     if code ^= 0 then do;
      247 		call mtape_$error (mtdp, code,
      248 		     "^/^a ^[headers^;^;^;section^] for file ^a on volume ^a",
      249 		     "Attempting to forward space to the beginning of file", desired_position + 1,
      250 		     mtape_file_info.file_id, mtape_vol_set.volume_id);
      251 		go to PIF_RETURN;
      252 	     end;
      253 	end;
      254 	if mtape_attach_info.labeled then		/* if labeled volume */
      255 	     mtape_file_info.position_within_file = AT_BOFH; /* set position indicator */
      256 	else mtape_file_info.position_within_file = AT_BOFD; /* set position indicator */
      257 	go to PIF_RETURN;
      258 
      259 FILE_POSITION (2):					/* position to end of file */
      260 	if mtape_file_info.position_within_file = AT_EOF then /* if we are already there, forget it */
      261 	     go to PIF_RETURN;
      262 	htype = EOV_LABEL;				/* preset to loop for EOV/BOF seq */
      263 	do while (htype ^= EOF_LABEL);		/* loop until we reach EOF */
      264 	     call mtape_$order (mtdp, "fsf", 1, null, code); /* go to end of current phy file */
      265 	     if code ^= 0 then do;			/* we loose */
      266 		call mtape_$error (mtdp, code,
      267 		     "^/While forward spacing to end of file ""^a"".", mtape_file_info.file_id);
      268 		go to PIF_RETURN;
      269 	     end;
      270 	     htype = EOV_LABEL;			/* preset to loop for EOV/BOF seq */
      271 	     do while (htype = EOV_LABEL);		/* loop on EOV */
      272 		call read_file_labels (mtdp, fi_ptr, vs_ptr, htype, code);
      273 		if code ^= 0 then
      274 		     go to PIF_RETURN;
      275 		if htype = EOV_LABEL then		/* if new file section to be read */
      276 		     fi_ptr = mtape_file_info.next_fi_ptr; /* set up for new section */
      277 	     end;
      278 	end;
      279 	go to PIF_RETURN;
      280 FILE_POSITION (4):					/* Position to end of file section */
      281 	if mtape_file_info.position_within_file = AT_EOF then /* if we have just written file, we are at EOF */
      282 	     go to PIF_RETURN;
      283 	fwd_file_cnt = (mtape_file_info.phy_file + FILES_PER_FILE_GRP) - mtape_data.phy_file;
      284 	call mtape_$order (mtdp, "fsf", fwd_file_cnt, null, code); /* fwd space required files */
      285 	if code ^= 0 then do;			/* if some problem */
      286 	     call mtape_$error (mtdp, code,		/* report it */
      287 		"^/While forward spacing to end of file section ""^a"".", mtape_file_info.file_id);
      288 	     go to PIF_RETURN;
      289 	end;
      290 	if mtape_file_info.next_fi_ptr ^= null then	/* if another file info exists */
      291 	     if mtape_file_info.next_fi_ptr -> mtape_file_info.first_file_section_ptr ^=
      292 		mtape_file_info.first_file_section_ptr then /* not part of this file */
      293 		mtape_file_info.position_within_file = AT_EOF; /* reflect current position */
      294 	     else mtape_file_info.position_within_file = AT_IFD;
      295 
      296 PIF_RETURN:
      297 	arg_code = code;
      298 	arg_vs_ptr = vs_ptr;
      299 	arg_fi_ptr = fi_ptr;
      300 	return;
      301 
      302 /* truncate_file_set - entry to free file_info structures from structure tail backwards to current file_info structure */
      303 
      304 truncate_file_set: entry (arg_mtdp);
      305 
      306 	mtdp = arg_mtdp;
      307 	maip = mtape_data.attach_info_ptr;
      308 	moip = mtape_data.open_info_ptr;
      309 	mpfmip = mtape_data.pfm_info_ptr;
      310 	term, term1, term2 = "0"b;			/* reset terminate conditions */
      311 	do fi_ptr = mtape_data.fi_tail repeat mtape_file_info.prev_fi_ptr while (^term);
      312 	     if mtape_file_info.next_fi_ptr ^= null then do; /* if not last file info */
      313 		free mtape_file_info.next_fi_ptr -> mtape_file_info in (based_area); /* free it */
      314 		mtape_file_info.next_fi_ptr = null;
      315 	     end;
      316 	     if mtape_open_info.extend then do;		/* if extending file, special case */
      317 		do lr_ptr = mtape_file_info.last_file_trail_ptr repeat mtape_label_record.prev_lab_ptr
      318 		     while (lr_ptr ^= null & ^term2);
      319 		     if term1 &			/* already read 1st eof label */
      320 			substr (based_label_record, 1, 3) ^= mtape_pfm_info.eof_prefix then
      321 			term2 = "1"b;		/* if now past first eof label */
      322 		     else do;			/* get rid of these labels */
      323 			if substr (based_label_record, 1, 3) = mtape_pfm_info.eof_prefix then /* first eof label? */
      324 			     term1 = "1"b;
      325 			if mtape_label_record.next_lab_ptr ^= null then /* if not last label record */
      326 			     free mtape_label_record.next_lab_ptr -> mtape_label_record in (based_area);
      327 			free based_label_record in (based_area); /* free label contents */
      328 		     end;
      329 		end;
      330 		if lr_ptr = null then		/* if eof label was first trailer label.. */
      331 		     mtape_file_info.first_file_trail_ptr, mtape_file_info.last_file_trail_ptr = null;
      332 		else mtape_file_info.last_file_trail_ptr = lr_ptr; /* this is now the tail */
      333 	     end;
      334 	     else do;				/* not extending file, get rid of all trailer labels */
      335 		do lr_ptr = mtape_file_info.last_file_trail_ptr repeat mtape_label_record.prev_lab_ptr
      336 		     while (lr_ptr ^= null);
      337 		     if mtape_label_record.next_lab_ptr ^= null then /* if not last label record */
      338 			free mtape_label_record.next_lab_ptr -> mtape_label_record in (based_area);
      339 		     free based_label_record in (based_area); /* free label contents */
      340 		end;
      341 		if mtape_file_info.first_file_trail_ptr ^= null then /* if not unlabeled volume set */
      342 		     free mtape_file_info.first_file_trail_ptr -> mtape_label_record in (based_area);
      343 		mtape_file_info.first_file_trail_ptr, mtape_file_info.last_file_trail_ptr = null;
      344 	     end;
      345 	     if fi_ptr = mtape_data.fi_current then	/* are we done? */
      346 		term = "1"b;			/* yes, set terminate condition */
      347 	     else do;				/* no, free somemore */
      348 		do lr_ptr = mtape_file_info.last_file_lab_ptr repeat mtape_label_record.prev_lab_ptr
      349 		     while (lr_ptr ^= null);
      350 		     if mtape_label_record.next_lab_ptr ^= null then /* if not last label record */
      351 			free mtape_label_record.next_lab_ptr -> mtape_label_record in (based_area);
      352 		     free based_label_record in (based_area); /* free label contents */
      353 		end;
      354 		if mtape_file_info.first_file_lab_ptr ^= null then
      355 		     free mtape_file_info.first_file_lab_ptr -> mtape_label_record in (based_area);
      356 	     end;
      357 	end;
      358 	mtape_data.fi_current -> mtape_file_info.end_of_file_set = "1"b; /* this is end of file set now */
      359 	mtape_data.fi_tail = mtape_data.fi_current;	/* truncate this chain also */
      360 	return;
      361 
      362 /* read_file_labels - external entry to read and decode beginning and end of file labels */
      363 
      364 read_file_labels: entry (arg_mtdp, arg_fi_ptr, arg_vs_ptr, arg_ltype, arg_code);
      365 
      366 	mtdp = arg_mtdp;				/* copy args */
      367 	fi_ptr = arg_fi_ptr;
      368 	vs_ptr = arg_vs_ptr;
      369 	maip = mtape_data.attach_info_ptr;
      370 	moip = mtape_data.open_info_ptr;
      371 	mpfmip = mtape_data.pfm_info_ptr;
      372 	ltype, rfl_code = 0;			/* start out with good rfl_code */
      373 	ver_ptr = null;
      374 
      375 	if mtape_attach_info.labeled then		/* if a labeled volume set */
      376 	     do lab_num = 1 by 1 while (rfl_code ^= error_table_$end_of_info);
      377 	     lr_ptr = mtape_data.tlb;			/* set label record pointer */
      378 	     call mtape_$read_label (mtdp, lr_ptr, rfl_code); /* read the label */
      379 	     if rfl_code ^= 0 then do;		/* some error lets check for EOF */
      380 		if rfl_code = error_table_$end_of_info then /* end of file set? */
      381 		     if lab_num = 1 then do;		/* yes, if first read (2 consecutive EOFs) */
      382 			fi_ptr = mtape_data.fi_tail;	/* set for last file */
      383 			mtape_file_info.end_of_file_set = "1"b; /* Set marker */
      384 			call mtape_$order (mtdp, "bsf", 1, null, rfl_code); /* backspace 1 file mark */
      385 			if rfl_code ^= 0 then
      386 			     call mtape_$error (mtdp, rfl_code,
      387 				"^/Positioning to tape mark prior to end of file set.");
      388 			rfl_code = error_table_$end_of_info; /* reset EOF code */
      389 			go to RFL_RETURN;		/* return with EOF code */
      390 		     end;
      391 		     else ;
      392 		else do;
      393 		     call mtape_$error (mtdp, rfl_code,
      394 			"^/Attempting to read file labels on volume ^a", mtape_vol_set.volume_id);
      395 		     go to RFL_RETURN;
      396 		end;
      397 	     end;
      398 	     else do;				/* No error, check labels */
      399 		if lab_num = 1 then			/* first file label of group */
      400 		     if substr (based_label_record, 1, 3) = mtape_pfm_info.bof_prefix then do; /* if bof label */
      401 			ltype = BOF_LABEL;		/* set label type */
      402 			if fi_ptr = null then	/* does file exist? */
      403 			     call CREATE_FILE_LINK;
      404 			if mtape_file_info.prev_fi_ptr ^= null then
      405 			     mtape_file_info.prev_fi_ptr -> mtape_file_info.position_within_file =
      406 				NOT_POSITIONED_IN_FILE;
      407 			mtape_data.fi_current = fi_ptr; /* this is now current file */
      408 			ver_ptr = mtape_file_info.first_file_lab_ptr; /* set verify ptr */
      409 		     end;
      410 		     else do;			/* must be EOV or EOF label group */
      411 			if substr (based_label_record, 1, 3) = mtape_pfm_info.eov_prefix then do;
      412 			     ltype = EOV_LABEL;	/* is it an EOV label group */
      413 			     ver_ptr = mtape_file_info.first_file_trail_ptr; /* set verify ptr to look at trailers */
      414 			end;
      415 			else
      416 			     if substr (based_label_record, 1, 3) = mtape_pfm_info.eof_prefix then do;
      417 			     ltype = EOF_LABEL;	/* or an EOF label group */
      418 			     ver_ptr = mtape_file_info.first_file_trail_ptr; /* set verify ptr to look at trailers */
      419 			end;
      420 			else do;			/* bad label */
      421 			     rfl_code = error_table_$invalid_label_format; /* set appropriate error code */
      422 			     call mtape_$error (mtdp, rfl_code,
      423 				"^/Unrecognizable file label, reading file labels on volume ^a. Label contents:^/""^a""",
      424 				mtape_vol_set.volume_id, based_label_record);
      425 			     go to RFL_RETURN;
      426 			end;
      427 		     end;
      428 		if ver_ptr = null then do;		/* if label not stored, let PFM decode it */
      429 		     call mtape_data.decode_file_labels (mtdp, lr_ptr, lab_num, ltype, rfl_code);
      430 		     if rfl_code ^= 0 then		/* if conversion error */
      431 			go to RFL_RETURN;
      432 		     if ltype > BOF_LABEL then	/* if EOF/EOV sequence */
      433 			call init_label_record (mtdp, mtape_file_info.last_file_trail_ptr,
      434 			     mtape_file_info.first_file_trail_ptr, lr_ptr, mtape_data.lab_buf_len);
      435 		     else do;			/* bof label group */
      436 			call init_label_record (mtdp, mtape_file_info.last_file_lab_ptr,
      437 			     mtape_file_info.first_file_lab_ptr, lr_ptr, mtape_data.lab_buf_len);
      438 			if lab_num = 1 then do;	/* complete position info */
      439 			     mtape_file_info.phy_file = mtape_data.position.phy_file; /* copy file number */
      440 			     if mtape_file_info.section > 1 & mtape_file_info.prev_fi_ptr = null then
      441 				mtape_file_info.section = 1; /* must be old section we are overwriting */
      442 			     if mtape_file_info.section > 1 then do; /* not 1st file section, must be new vol */
      443 				mtape_file_info.first_file_on_volume = "1"b; /* set for later positioning */
      444 				mtape_file_info.first_file_section_ptr =
      445 				     mtape_file_info.prev_fi_ptr -> mtape_file_info.first_file_section_ptr;
      446 
      447 				mtape_file_info.begin_vs_ptr =
      448 				     mtape_file_info.prev_fi_ptr -> mtape_file_info.begin_vs_ptr;
      449 			     end;
      450 			     else do;
      451 				mtape_file_info.begin_vs_ptr = vs_ptr; /* beginning of new file */
      452 				mtape_file_info.first_file_section_ptr = fi_ptr;
      453 			     end;
      454 			     call LINK_VS_END;	/* link in the end vol set ptr */
      455 			end;
      456 		     end;
      457 		     based_label_record = mtape_data.tlb -> mtape_label_record.lab_ptr -> based_label_record;
      458 		     ver_ptr = lr_ptr;		/* set for compatibility */
      459 		end;
      460 		else do;				/* label already exists, compare it */
      461 		     if based_label_record ^= ver_ptr -> mtape_label_record.lab_ptr -> based_label_record then do;
      462 			rfl_code = error_table_$invalid_label_format;
      463 			call mtape_$error (mtdp, rfl_code,
      464 			     "^/^a ^a ^a, physical file ^d, ^a^/""^a""^/New value:^/""^a""",
      465 			     mtape_pfm_info.module_id, "label record read from volume",
      466 			     mtape_vol_set.volume_id, mtape_data.phy_file,
      467 			     "does not agree with safe stored contents of same. Safe stored value:",
      468 			     ver_ptr -> mtape_label_record.lab_ptr -> based_label_record, based_label_record);
      469 			go to RFL_RETURN;
      470 		     end;
      471 		end;
      472 		ver_ptr = ver_ptr -> mtape_label_record.next_lab_ptr; /* update for next compare */
      473 	     end;
      474 	end;
      475 	else do;					/* an unlabeled volume set */
      476 	     call DECODE_UNLABELED_FILE;		/* determine what and where of file */
      477 	     if rfl_code ^= 0 then			/* if some error */
      478 		go to RFL_RETURN;			/* bail out */
      479 	end;
      480 	if ltype = EOV_LABEL then do;			/* if a volume switch is necessary, do it now */
      481 	     mtape_file_info.position_within_file = NOT_POSITIONED_IN_FILE;
      482 	     nvp = mtape_vol_set.next_vs_ptr;		/* copy pointer, in case its null */
      483 	     call mtape_$volume_switch (mtdp, nvp, rfl_code); /* do the magic */
      484 	     if rfl_code ^= 0 then do;		/* could'nt do the switch */
      485 		call mtape_$error (mtdp, rfl_code,
      486 		     "^/Could not mount new volume at volume switch time");
      487 		go to RFL_RETURN;
      488 	     end;
      489 	     vs_ptr = mtape_data.vs_current;		/* point to new volume */
      490 	end;
      491 	else if ltype = EOF_LABEL then		/* if reading EOF label group */
      492 	     mtape_file_info.position_within_file = AT_EOF;
      493 	else mtape_file_info.position_within_file = AT_BOFD; /* Header label group */
      494 	rfl_code = 0;				/* reset code to not reflect EOF */
      495 RFL_RETURN:
      496 	arg_code = rfl_code;
      497 	arg_ltype = ltype;				/* return label group type */
      498 	arg_fi_ptr = fi_ptr;			/* and file info ptr to caller */
      499 	arg_vs_ptr = mtape_data.vs_current;		/* return possibly updated vs_ptr */
      500 	arg_mtdp = mtdp;				/* in case of volume switch */
      501 	return;
      502 
      503 /* write_file_labels - external entry to encode and write beginning and end of file labels */
      504 
      505 write_file_labels: entry (arg_mtdp, arg_ltype, arg_code);
      506 
      507 	mtdp = arg_mtdp;
      508 	ltype = arg_ltype;
      509 	vs_ptr = mtape_data.vs_current;
      510 	fi_ptr = mtape_data.fi_current;
      511 	maip = mtape_data.attach_info_ptr;
      512 	moip = mtape_data.open_info_ptr;
      513 	mpfmip = mtape_data.pfm_info_ptr;
      514 	arg_code, wfl_code = 0;
      515 
      516 	if ltype > BOF_LABEL then do;			/* if writing EOV/EOF, write file mark first */
      517 	     mtape_file_info.block_count = mtape_data.phy_block; /* unload block count */
      518 	     if mtape_attach_info.labeled then do;	/* only if labeled tape */
      519 		call mtape_$order (mtdp, "eof", 1, null, wfl_code);
      520 		if wfl_code ^= 0 then do;		/* can't even write eof */
      521 		     call mtape_$error (mtdp, wfl_code, "^/While writing an End of File mark.");
      522 		     call ABORT_FILE (wfl_code);	/* ask user what to do */
      523 		     go to WFL_RETURN;		/* quit now */
      524 		end;
      525 	     end;
      526 	     mtape_file_info.position_within_file = AT_BOFT; /* reflect current file position */
      527 	     neofs = 2;				/* write 2 file marks after labels */
      528 	     nlp = mtape_file_info.first_file_trail_ptr;	/* init label structure ptr */
      529 	end;
      530 	else do;					/* Header label */
      531 	     if ^mtape_attach_info.labeled then		/* if unlabeled, don't write file mark */
      532 		neofs = 0;
      533 	     else neofs = 1;			/* write only 1 eof after labels */
      534 	     if mtape_file_info.position_within_file ^= AT_BOFH then do; /* not positioned to header */
      535 		call position_in_file (mtdp, fi_ptr, vs_ptr, AT_BOFH, wfl_code); /* do the positioning */
      536 		if wfl_code ^= 0 then		/* return if error */
      537 		     go to WFL_RETURN;
      538 	     end;
      539 	     nlp = mtape_file_info.first_file_lab_ptr;	/* init label structure ptr */
      540 	end;
      541 	call WRITE_LABEL_RECORDS (ltype, wfl_code);	/* do the actual writing of labels */
      542 	if wfl_code ^= 0 then do;			/* this is serious */
      543 	     call ABORT_FILE (wfl_code);		/* ask user what to do */
      544 	     go to WFL_RETURN;
      545 	end;
      546 	if neofs > 0 then do;			/* if we have some eofs to write */
      547 	     call mtape_$order (mtdp, "eof", neofs, null, wfl_code); /* Now write  file mark(s) */
      548 	     if wfl_code ^= 0 then do;
      549 		call mtape_$error (mtdp, wfl_code, "^/While writing an End of File mark.");
      550 		call ABORT_FILE (wfl_code);		/* ask user what to do */
      551 		go to WFL_RETURN;			/* quit now if we can't write eof */
      552 	     end;
      553 	end;
      554 	if ltype = EOF_LABEL then do;			/* if writing EOF labels, position before last EOF */
      555 	     mtape_file_info.end_of_file_set = "1"b;	/* Set marker, this is end of file set */
      556 	     call mtape_$order (mtdp, "bsf", 1, null, wfl_code);
      557 	     mtape_file_info.position_within_file = AT_EOF; /* we are positioned at EOF */
      558 	end;
      559 WFL_RETURN:
      560 	if wfl_code = 0 then			/* if no other error */
      561 	     if arg_ltype ^= ltype then		/* but we wrote EOF instead of EOV label */
      562 		wfl_code = error_table_$no_next_volume; /* tell user he is done */
      563 	arg_code = wfl_code;
      564 	return;
      565 
      566 /* file_search - external entry to search for desired file in file history, and/or on tape */
      567 
      568 file_search: entry (arg_mtdp, arg_fi_ptr, arg_vs_ptr, arg_code);
      569 
      570 	mtdp = arg_mtdp;				/* copy args */
      571 	fi_ptr = arg_fi_ptr;
      572 	vs_ptr = arg_vs_ptr;
      573 	maip = mtape_data.attach_info_ptr;
      574 	moip = mtape_data.open_info_ptr;
      575 	mpfmip = mtape_data.pfm_info_ptr;
      576 	arg_code, code = 0;
      577 
      578 	if mtape_attach_info.labeled then
      579 	     if mtape_vol_set.volume_check > NON_MULT_VOLUME then do; /* can't read this one */
      580 		code = error_table_$uninitialized_volume; /* Give caller an appropriate code */
      581 		go to FS_RETURN;
      582 	     end;
      583 
      584 	if mtape_open_info.append then		/* if appending file to end of FS */
      585 	     target_position = AT_EOF;		/* final position must be EOF of last file */
      586 	else if mtape_open_info.extend then		/* if extending existing file */
      587 	     target_position = AT_EOFD;		/* final position must be prior to end of data file */
      588 	else if mtape_open_info.modify then		/* if modifying existing file */
      589 	     target_position = AT_BOFD;		/* go directly to beginning of data */
      590 	else target_position = AT_BOFH;		/* otherwise position to file hdr */
      591 	found = "0"b;
      592 	fi_ptr = mtape_data.fi_head;			/* start at first file */
      593 	do while (fi_ptr ^= null & ^found);
      594 	     found = DESIRED_FILE (0);		/* check each file found for match */
      595 	     if ^found then				/* if no match, advance to next file */
      596 		fi_ptr = mtape_file_info.next_fi_ptr;
      597 	end;
      598 	if found then do;				/* if we found the file in history */
      599 	     call POSITION_TO_FILE (target_position);	/* position to appropriate place */
      600 	     if code ^= 0 then go to FS_RETURN;		/* if error, quit now */
      601 	     if target_position = AT_BOFH then do;	/* if positioned to hdrs, read them */
      602 		call read_file_labels (mtdp, fi_ptr, vs_ptr, htype, code);
      603 		if code ^= 0 then go to FS_RETURN;	/* if error, quit now */
      604 		if htype ^= BOF_LABEL then do;	/* if we found the wrong typw of label */
      605 		     code = error_table_$invalid_file_set_format; /* set code */
      606 		     call mtape_$error (mtdp, code,
      607 			"^/^[EOV^;EOF^] ^a, for file ^d (physical file ^d) on volume ^a",
      608 			htype, "file label found where BOF label expected",
      609 			mtape_file_info.seq_number, mtape_file_info.phy_file + 1, mtape_vol_set.volume_id);
      610 		end;
      611 	     end;
      612 	     if mtape_open_info.append then		/* if appending file.. */
      613 		fi_ptr = mtape_file_info.next_fi_ptr;	/* go to next file_info (should be null) */
      614 	end;
      615 	else do;					/* didn't find file in history, search tape */
      616 	     fi_ptr = mtape_data.fi_tail;		/* start at last known file */
      617 	     if fi_ptr ^= mtape_data.fi_current then do;	/* last file beyond current position? */
      618 		call POSITION_TO_FILE (AT_BOFH);	/* position to beginning of last file */
      619 		if code ^= 0 then go to FS_RETURN;	/* bail out if problems */
      620 	     end;
      621 	     if fi_ptr ^= null then			/* not first search? */
      622 		if mtape_file_info.position_within_file = AT_EOF then do;
      623 		     if mtape_file_info.end_of_file_set then /* and this is last file */
      624 			go to NF_RETURN;		/* return file not found */
      625 		     else fi_ptr = mtape_file_info.next_fi_ptr; /* At EOF, advance to next file */
      626 		end;
      627 		else if mtape_file_info.position_within_file = AT_BOFH & /* if in hdr file */
      628 		     mtape_data.phy_block ^= 0 then do; /* but not beginning */
      629 		     call POSITION_TO_FILE (AT_BOFH);	/* position to re-read hdr */
      630 		     if code ^= 0 then go to FS_RETURN;
      631 		end;
      632 		else if mtape_file_info.position_within_file = AT_BOFD | /* read trailer if */
      633 		     mtape_file_info.position_within_file = AT_IFD | /* one of these */
      634 		     mtape_file_info.position_within_file = AT_EOFD |
      635 		     mtape_file_info.position_within_file = AT_EOFT |
      636 		     (mtape_file_info.position_within_file = AT_BOFT &
      637 		     mtape_data.phy_block ^= 0) then do;
      638 		     call POSITION_TO_FILE (AT_BOFT);	/* position to read trailer label */
      639 		     if code ^= 0 then go to FS_RETURN;
      640 		end;
      641 	     do while (^found & code = 0);		/* search until found it or end of file set */
      642 
      643 		call read_file_labels (mtdp, fi_ptr, vs_ptr, htype, code); /* read the label group */
      644 		if code = 0 | code = error_table_$end_of_info then do; /* if no error.. */
      645 		     found = DESIRED_FILE (htype);	/* is this the right file? */
      646 		     if (found & code = error_table_$end_of_info & mtape_open_info.append) | /* if EOFS */
      647 			(^found & code = 0 & htype > BOF_LABEL) then /* or at end of file (section) */
      648 			fi_ptr = mtape_file_info.next_fi_ptr; /* advance the file pointer */
      649 		     if ^found & code = 0 & htype = BOF_LABEL then do; /* No, forward space to trailer label group */
      650 			call POSITION_TO_FILE (AT_BOFT);
      651 			if code ^= 0 then go to FS_RETURN;
      652 		     end;
      653 		end;
      654 	     end;
      655 	     if ^found then do;			/* could not find file on file set */
      656 NF_RETURN:
      657 		code = error_table_$no_file;
      658 		fi_ptr = null;			/* force file info ptr to null */
      659 		go to FS_RETURN;
      660 	     end;
      661 	     code = 0;				/* reset possible EOF status */
      662 	     if mtape_open_info.extend then		/* if extending this file.. */
      663 		call POSITION_TO_FILE (AT_EOFD);	/* position prior to file mark */
      664 	     else if mtape_open_info.last_file |	/* if not extending the last file */
      665 		mtape_open_info.modify then		/* or modifying this file */
      666 		call POSITION_TO_FILE (AT_BOFD);	/* position to beginning of file data  */
      667 	end;
      668 FS_RETURN:
      669 	arg_mtdp = mtdp;				/* copy arguments back in case of volume switch */
      670 	arg_fi_ptr = fi_ptr;
      671 	arg_vs_ptr = vs_ptr;
      672 	arg_code = code;
      673 	return;
      674 
      675 /* setup_file - entry to create and setup the common attributes of a file from the open options */
      676 
      677 setup_file: entry (arg_mtdp, arg_fi_ptr, new_section);
      678 
      679 	mtdp = arg_mtdp;				/* copy arguments */
      680 	fi_ptr = arg_fi_ptr;
      681 	vs_ptr = mtape_data.vs_current;
      682 	maip = mtape_data.attach_info_ptr;
      683 	moip = mtape_data.open_info_ptr;
      684 	mpfmip = mtape_data.pfm_info_ptr;
      685 
      686 	if fi_ptr = null then			/* are we creating new file, or replacing old */
      687 	     call CREATE_FILE_LINK;
      688 	else call truncate_file_set (mtdp);		/* get ride of file history from this point */
      689 	pp = mtape_file_info.prev_fi_ptr;		/* set for previous file */
      690 	if new_section then do;			/* if adding new file section... */
      691 	     mtape_file_info.per_file_info = pp -> mtape_file_info.per_file_info; /* copy per-file info directly */
      692 	     mtape_file_info.section = pp -> mtape_file_info.section + 1; /* increment section */
      693 	     mtape_file_info.first_file_on_volume = "1"b; /* new sections are always 1st */
      694 	     mtape_file_info.end_of_file_set = "1"b;	/* currently is so */
      695 	     pp -> mtape_file_info.end_of_file_set = "0"b;/* previous section is not end */
      696 	     mtape_file_info.first_file_section_ptr = pp -> mtape_file_info.first_file_section_ptr;
      697 	     mtape_file_info.begin_vs_ptr = pp -> mtape_file_info.begin_vs_ptr;
      698 	     pp -> mtape_file_info.position_within_file = NOT_POSITIONED_IN_FILE;
      699 	     call LINK_VS_END;			/* link in the end vs structture */
      700 	end;
      701 	else do;					/* An entirely new file */
      702 	     if pp = null then do;			/* if this is first file.. */
      703 		mtape_file_info.file_set_id = translate (mtape_vol_set.volume_id, UC, LC); /* use 1st volume name */
      704 		prev_seq = 0;			/* set to zero */
      705 	     end;
      706 	     else do;				/* otherwise, get from last file */
      707 		mtape_file_info.file_set_id = pp -> mtape_file_info.file_set_id;
      708 		pp -> mtape_file_info.end_of_file_set = "0"b; /* previous file no longer end */
      709 		prev_seq = pp -> mtape_file_info.seq_number;
      710 	     end;
      711 	     if mtape_open_info.seq_number ^= 0 then	/* if sequence number was specified.. */
      712 		mtape_file_info.seq_number = mtape_open_info.seq_number; /* use it */
      713 	     else mtape_file_info.seq_number = prev_seq + 1; /* otherwise use prev + 1 */
      714 	     if mtape_open_info.file_name ^= "" then	/* if file name specified.. */
      715 		mtape_file_info.file_id = mtape_open_info.file_name; /* use it */
      716 	     else do;				/* must fabricate it */
      717 		pic4 = mtape_file_info.seq_number;	/* convert seq number */
      718 		mtape_file_info.file_id = "FILE" || pic4;
      719 	     end;
      720 	     mtape_file_info.section = 1;
      721 	     mtape_file_info.begin_vs_ptr, mtape_file_info.end_vs_ptr = mtape_data.vs_current;
      722 	     mtape_file_info.first_file_section_ptr = fi_ptr;
      723 	     mtape_file_info.block_size = mtape_open_info.block_length;
      724 	     mtape_file_info.record_size = mtape_open_info.record_length;
      725 	     mtape_file_info.end_of_file_set = "1"b;	/* file set ends with this file */
      726 	     mtape_file_info.native_file = "1"b;	/* file recorded by this PFM */
      727 	     mtape_file_info.unlabeled_file = ^mtape_attach_info.labeled; /* invert labeled flag */
      728 	end;
      729 	arg_fi_ptr = fi_ptr;			/* set file_info ptr for caller */
      730 	return;
      731 
      732 /* ABORT_FILE - int procedure to handle errors when writing file labels and TMs */
      733 
      734 ABORT_FILE: proc (acode);
      735 
      736 dcl  acode fixed bin (35);
      737 
      738 	acode = error_table_$invalid_file_set_format;	/* set default return code */
      739 	call mtape_$user_query (mtdp, Q_ABORT_FILE, code);/* ask user what to do */
      740 	if code ^= 0 then do;			/* user answered no */
      741 	     call mtape_$order (mtdp, "eof", 2, null, code); /* try to write 2 EOFs anyway */
      742 	     return;
      743 	end;
      744 
      745 /* user wants to truncate current file section (yes answer) */
      746 
      747 	if mtape_file_info.section > 1 then do;		/* case 1: truncate to end of previous section */
      748 	     mtape_data.fi_current = mtape_file_info.prev_fi_ptr; /* point to previous section */
      749 	     call truncate_file_set (mtdp);		/* truncate to this section */
      750 	     call CK_VOL_SWITCH (mtape_vol_set.prev_vs_ptr, "0"b); /* switch volumes */
      751 	     if code ^= 0 then return;		/* return if error */
      752 	     fi_ptr = mtape_data.fi_current;		/* reset file_info ptr */
      753 	     mtape_file_info.end_vs_ptr = vs_ptr;	/* reflect that this is last volume */
      754 	     call POSITION_TO_FILE (AT_BOFT);		/* position before EOV labels */
      755 	     if code ^= 0 then return;		/* return if error */
      756 	     nlp = mtape_file_info.first_file_trail_ptr;	/* init label structure ptr */
      757 	     call WRITE_LABEL_RECORDS (EOF_LABEL, code);	/* write out the EOF sequence */
      758 	     if code ^= 0 then return;		/* return if error */
      759 	     call mtape_$order (mtdp, "eof", 2, null, code); /* write 2 EOF marks */
      760 	     if code = 0 then			/* if no errors.. */
      761 		acode = error_table_$file_aborted;	/* set appropriate return code now */
      762 	     return;				/* and return */
      763 	end;
      764 	else do;					/* case 2: file on one volume */
      765 	     call truncate_file_set (mtdp);		/* truncate and trailers */
      766 	     call POSITION_TO_FILE (AT_BOFH);		/* position to BOF */
      767 	     if code ^= 0 then return;		/* bail out on error */
      768 	     call mtape_$order (mtdp, "eof", 2, null, code); /* write 2 eofs */
      769 	     if code ^= 0 then return;		/* bail out on error */
      770 	     acode = error_table_$file_aborted;		/* can now safely change return code */
      771 	     do lr_ptr = mtape_file_info.last_file_lab_ptr repeat mtape_label_record.prev_lab_ptr
      772 		while (lr_ptr ^= null);
      773 		if mtape_label_record.next_lab_ptr ^= null then /* if not last label record */
      774 		     free mtape_label_record.next_lab_ptr -> mtape_label_record in (based_area);
      775 		free based_label_record in (based_area);/* free label contents */
      776 	     end;
      777 	     if mtape_file_info.first_file_lab_ptr ^= null then
      778 		free mtape_file_info.first_file_lab_ptr -> mtape_label_record in (based_area);
      779 	     if mtape_file_info.prev_fi_ptr = null then do; /* first and only file? */
      780 		free mtape_file_info in (based_area);	/* free up area storage */
      781 		mtape_data.fi_current, mtape_data.fi_head, mtape_data.fi_tail = null; /* wipe out all traces */
      782 		call mtape_$order (mtdp, "rew", 0, null, code); /* rewind to BOT */
      783 	     end;
      784 	     else do;				/* not first file */
      785 		fi_ptr, mtape_data.fi_current, mtape_data.fi_tail = mtape_file_info.prev_fi_ptr;
      786 		free mtape_file_info.next_fi_ptr -> mtape_file_info in (based_area);
      787 		mtape_file_info.next_fi_ptr = null;	/* no next file structure */
      788 		mtape_file_info.end_of_file_set = "1"b; /* this is now end of FS */
      789 		call POSITION_TO_FILE (AT_EOF);	/* position to the end of current file */
      790 	     end;
      791 	end;
      792 
      793      end ABORT_FILE;
      794 
      795 
      796 /* DESIRED_FILE - procedure to check if current file is the one we are looking for */
      797 
      798 DESIRED_FILE: proc (htype) returns (bit (1) aligned);
      799 
      800 dcl  htype fixed bin;
      801 
      802 	if htype ^= 0 then				/* if called when searching tape.. */
      803 	     if mtape_open_info.extend |		/* and we want to extend a file */
      804 		mtape_open_info.append |		/* or append a file */
      805 		mtape_open_info.modify |		/* or modify a file */
      806 		mtape_open_info.last_file then	/* or position to last file */
      807 		if htype ^= EOF_LABEL then		/* but are not at end of file */
      808 		     return ("0"b);			/* force read of end of file labels first */
      809 	if (mtape_open_info.append | mtape_open_info.last_file) & /* if need to be at */
      810 	     mtape_file_info.end_of_file_set then	/* end of file set and we are there */
      811 	     return ("1"b);				/* We have found desired file */
      812 	else if mtape_open_info.seq_number ^= 0 |	/* looking for sequence number? */
      813 	     mtape_open_info.file_name ^= "" |		/* looking for file name? */
      814 	     mtape_open_info.replace_id ^= "" then do;	/* looking for file name to replace? */
      815 	     if mtape_file_info.seq_number = mtape_open_info.seq_number then
      816 		return ("1"b);			/* if they match, we have found desired file */
      817 	     if mtape_file_info.file_id = mtape_open_info.file_name then
      818 		return ("1"b);			/* if they match, we have found desired file */
      819 	     if mtape_file_info.file_id = mtape_open_info.replace_id then
      820 		return ("1"b);			/* if they match, we have found desired file */
      821 	end;
      822 	else if mtape_open_info.next_file then do;	/* if looking for next file.. */
      823 	     if htype = BOF_LABEL then		/* if searching tape, make sure we are looking at HDR GRP */
      824 		return ("1"b);			/* We have found it */
      825 	     if mtape_data.fi_current ^= null then	/* if not first file */
      826 		if mtape_file_info.prev_fi_ptr = mtape_data.fi_current then
      827 		     return ("1"b);			/* we have found it */
      828 	end;
      829 	return ("0"b);				/* No match, did not find desired file */
      830 
      831      end DESIRED_FILE;
      832 
      833 /* POSITION_TO_FILE - internal subroutine to position to a particular existing file (defined by mtape_file_info structure),
      834*   and to the desired position within that file */
      835 
      836 /* *	Each logical file is made up of 3 physical files. The model
      837*   *	used in determining position within each file is shown below:
      838*   *
      839*   *	----------------------------------------------------
      840*   *	|   FILE    |        FILE    	         |  FILE     |
      841*   *	|           |                          |           |
      842*   *	|  HEADER   |        DATA              | TRAILER   |
      843*   *	|           |                          |           |
      844*   *	|           |                          |           |
      845*   *	----------------------------------------------------
      846*   *	 /\        /\/\          /\           /\/\        /\/\
      847*   *	 |         | |           |            | |         | |
      848*   *	 |__AT_BOFH | |__AT_BOFD   |__AT_IFD     | |__AT_BOFT | |__AT_EOF
      849*   *	 |         |                          |           |
      850*   *	           |__AT_EOFH                  |__AT_EOFD   |__AT_EOFT
      851**/
      852 
      853 POSITION_TO_FILE: proc (target_position);
      854 
      855 dcl  target_position fixed bin;
      856 
      857 	go to PTF (target_position);			/* do the proper processing */
      858 
      859 PTF (1):						/* Position to Beginning of File Header (AT_BOFH) */
      860 	call CK_VOL_SWITCH (mtape_file_info.begin_vs_ptr, "0"b); /* Use 1st file section */
      861 	if code ^= 0 then return;
      862 PTF (9):						/* Position to Beginning of File Section */
      863 	call FILE_RIGHT_POSITION (mtape_file_info.phy_file); /* position to right of file mark */
      864 	if code = 0 then				/* if no error, set final position */
      865 	     mtape_file_info.position_within_file = AT_BOFH;
      866 	return;
      867 
      868 PTF (2):						/* Position to End of File Header (AT_EOFH) */
      869 	call CK_VOL_SWITCH (mtape_file_info.begin_vs_ptr, "0"b); /* Use 1st file section */
      870 	if code ^= 0 then return;
      871 	call FILE_LEFT_POSITION (mtape_file_info.phy_file + 1); /* position to left of file mark */
      872 	if code = 0 then				/* if no error, set final position */
      873 	     mtape_file_info.position_within_file = AT_EOFH;
      874 	return;
      875 
      876 PTF (3):						/* Position to Beginning of File Data (AT_BOFD) */
      877 PTF (4):						/* Position within file data, not beginning (AT_IFD) */
      878 	call CK_VOL_SWITCH (mtape_file_info.begin_vs_ptr, "0"b); /* Use 1st file section */
      879 	if code ^= 0 then return;
      880 	call FILE_RIGHT_POSITION (mtape_file_info.phy_file + 1); /* position to right of file mark */
      881 	if code = 0 then				/* if no error, set final position */
      882 	     mtape_file_info.position_within_file = AT_BOFD;
      883 	return;
      884 
      885 PTF (5):						/* Position to End of File Data (AT_EOFD) */
      886 	call CK_VOL_SWITCH (mtape_file_info.end_vs_ptr, "1"b); /* Use last file section (if > 1) */
      887 	if code ^= 0 then return;
      888 	call FILE_LEFT_POSITION (mtape_file_info.phy_file + 2); /* position to left of file mark */
      889 	if code = 0 then				/* if no error, set final position */
      890 	     mtape_file_info.position_within_file = AT_EOFD;
      891 	return;
      892 
      893 PTF (6):						/* Position to Beginning of file trailer (AT_BOFT) */
      894 	call CK_VOL_SWITCH (mtape_file_info.end_vs_ptr, "1"b); /* Use last file section (if > 1) */
      895 	if code ^= 0 then return;
      896 	call FILE_RIGHT_POSITION (mtape_file_info.phy_file + 2); /* position to right of file mark */
      897 	if code = 0 then				/* if no error, set final position */
      898 	     mtape_file_info.position_within_file = AT_BOFT;
      899 	return;
      900 
      901 PTF (7):						/* Position to End of file trailer (AT_EOFT) */
      902 	call CK_VOL_SWITCH (mtape_file_info.end_vs_ptr, "1"b); /* Use last file section (if > 1) */
      903 	if code ^= 0 then return;
      904 	call FILE_LEFT_POSITION (mtape_file_info.phy_file + 3); /* position to left of file mark */
      905 	if code = 0 then				/* if no error, set final position */
      906 	     mtape_file_info.position_within_file = AT_EOFT;
      907 	return;
      908 
      909 PTF (8):						/* Position to End of file (AT_EOF) */
      910 	call CK_VOL_SWITCH (mtape_file_info.end_vs_ptr, "1"b); /* Use last file section (if > 1) */
      911 	if code ^= 0 then return;
      912 PTF (10):						/* Position to End of File Section */
      913 	call FILE_RIGHT_POSITION (mtape_file_info.phy_file + 3); /* position to right of file mark */
      914 	if code = 0 then				/* if no error, set final position */
      915 	     mtape_file_info.position_within_file = AT_EOF;
      916 
      917 
      918      end POSITION_TO_FILE;
      919 
      920 /* CK_VOL_SWITCH - internal subroutine to check if a volume switch is necessary to get to
      921*   desired position within file and adjust fi_ptr for proper file section */
      922 
      923 CK_VOL_SWITCH: proc (nvp, last_file_section);
      924 
      925 dcl  nvp ptr;
      926 dcl  last_file_section bit (1) aligned;
      927 
      928 	if nvp ^= mtape_data.vs_current then do;	/* volume switch required? */
      929 	     call mtape_$volume_switch (mtdp, nvp, code); /* yes, do it */
      930 	     if code ^= 0 then do;			/* no go? */
      931 		call mtape_$error (mtdp, code,
      932 		     "^/Could not switch to volume ""^a"" at volume switch time",
      933 		     nvp -> mtape_vol_set.volume_name);
      934 		return;
      935 	     end;
      936 	     vs_ptr = mtape_data.vs_current;		/* set vol ptr for new vol */
      937 	     if ^last_file_section then		/* if we went to BOF */
      938 		fi_ptr = mtape_file_info.first_file_section_ptr; /* set file ptr to first section */
      939 	     else do;				/* we went to EOF */
      940 		term = "0"b;
      941 		do nfip = fi_ptr repeat nfip -> mtape_file_info.next_fi_ptr while (^term);
      942 		     if nfip -> mtape_file_info.first_file_section_ptr ^=
      943 			mtape_file_info.first_file_section_ptr then do;
      944 			term = "1"b;		/* found it, it is last file info */
      945 			fi_ptr = nfip -> mtape_file_info.prev_fi_ptr;
      946 		     end;
      947 		     else if nfip -> mtape_file_info.next_fi_ptr = null then do; /* last file */
      948 			term = "1"b;
      949 			fi_ptr = nfip;		/* this is it */
      950 		     end;
      951 		end;
      952 	     end;
      953 	end;
      954 
      955      end CK_VOL_SWITCH;
      956 
      957 /* FILE_LEFT_POSITION - internal procedure to position to left of desired file mark */
      958 
      959 FILE_LEFT_POSITION: proc (target_file);
      960 
      961 dcl  target_file fixed bin;
      962 
      963 	call FILE_RIGHT_POSITION (target_file);		/* first position to right of file */
      964 	if code = 0 then
      965 	     call mtape_$order (mtdp, "bsf", 1, null, code); /* now backspace 1 file to desired position */
      966 
      967      end FILE_LEFT_POSITION;
      968 
      969 /* FILE_RIGHT_POSITION - internal subroutine to position to the right of the specified file mark */
      970 
      971 FILE_RIGHT_POSITION: proc (target_file);
      972 
      973 dcl  target_file fixed bin;
      974 
      975 	if target_file >= mtape_data.phy_file then do;	/* Positioned before desired file? */
      976 	     space_files = target_file - mtape_data.phy_file; /* yes, must position forward */
      977 	     forward = "1"b;
      978 	end;
      979 	else do;					/* No, Positioned past desired file */
      980 	     if mtape_file_info.first_file_on_volume then do; /* if this is true, can rewind */
      981 		call REWIND_TO_BOF;			/* rewind tape */
      982 		if code ^= 0 then return;
      983 		space_files = target_file;
      984 	     end;
      985 	     else do;				/* no must backspace */
      986 		space_files = mtape_data.phy_file - target_file; /* position backward */
      987 		if space_files ^= 0 then		/* only back up if not at right position */
      988 		     space_files = space_files + 1;
      989 
      990 /* must back up 1 more and fwd space 1 file to get to beginning of desired file */
      991 
      992 		forward = "0"b;
      993 	     end;
      994 	end;
      995 	if space_files ^= 0 then do;			/* if we have to position.. */
      996 	     if ^forward then do;			/* go backward n files? */
      997 		call mtape_$order (mtdp, "bsf", space_files, null, code);
      998 		if code = 0 then do;
      999 		     space_files = 1;		/* must now forward space 1 file */
     1000 		     forward = "1"b;		/* set switch for error message */
     1001 		end;
     1002 	     end;
     1003 	     if code = 0 & space_files ^= 0 then
     1004 		call mtape_$order (mtdp, "fsf", space_files, null, code);
     1005 	     if code ^= 0 then do;
     1006 		call mtape_$error (mtdp, code,
     1007 		     "^/While ^[forward ^;back^]spacing ^d files to position to file ""^a"".",
     1008 		     forward, space_files, mtape_file_info.file_id);
     1009 		return;
     1010 	     end;
     1011 	end;
     1012 	mtape_data.fi_current = fi_ptr;		/* reset external position indicator */
     1013 
     1014      end FILE_RIGHT_POSITION;
     1015 
     1016 /* REWIND_TO_BOF - internal procedure to rewind volume and forward space over volume labels */
     1017 
     1018 REWIND_TO_BOF: proc;
     1019 
     1020 	call mtape_$order (mtdp, "rew", 0, null, code);
     1021 	if code ^= 0 then do;
     1022 	     call mtape_$error (mtdp, code,
     1023 		"^/Attempting to rewind volume ^a to position to beginning of file ^a",
     1024 		mtape_vol_set.volume_id, mtape_file_info.file_id);
     1025 	     return;
     1026 	end;
     1027 
     1028 /* now space over volume labels */
     1029 
     1030 	if mtape_vol_set.number_of_vol_labels > 0 then do;/* only if a labeled volume */
     1031 	     call mtape_$order (mtdp, "fsr", mtape_vol_set.number_of_vol_labels, null, code);
     1032 	     if code ^= 0 then
     1033 		call mtape_$error (mtdp, code,
     1034 		     "^/Attempting to forward space over volume labels on volume ^a, to position to beginning of file ^a",
     1035 		     mtape_vol_set.volume_id, mtape_file_info.file_id);
     1036 	end;
     1037 
     1038      end REWIND_TO_BOF;
     1039 
     1040 /* CREATE_FILE_LINK - internal procedure to create a file info structure and link it in */
     1041 
     1042 CREATE_FILE_LINK: proc;
     1043 
     1044 	call mtape_$alloc (mtdp, MTAPE_ALLOC_FI, mtape_data.fi_tail, 0, fi_ptr);
     1045 	mtape_data.fi_current, mtape_data.fi_tail = fi_ptr; /* Link this file info structure in */
     1046 	if mtape_data.fi_head = null then do;		/* if this is first file */
     1047 	     mtape_data.fi_head = fi_ptr;		/* Set link head also */
     1048 	     mtape_file_info.first_file_on_volume = "1"b; /* set indicator for later positioning */
     1049 	end;
     1050 	mtape_file_info.position_within_file = AT_BOFH;	/* set initial position to hdr file */
     1051 	mtape_file_info.phy_file = mtape_data.phy_file;	/* and set file number of header */
     1052 
     1053      end CREATE_FILE_LINK;
     1054 
     1055 /* LINK_VS_END - internal procedure to link in the file_info.vs_end ptr */
     1056 
     1057 LINK_VS_END: proc;
     1058 
     1059 dcl  prevp ptr;
     1060 dcl  term bit (1) aligned;
     1061 
     1062 	term = "0"b;
     1063 	do prevp = fi_ptr repeat prevp -> mtape_file_info.prev_fi_ptr while (prevp ^= null & ^term);
     1064 	     if prevp -> mtape_file_info.first_file_section_ptr ^= mtape_file_info.first_file_section_ptr then
     1065 		term = "1"b;
     1066 	     else prevp -> mtape_file_info.end_vs_ptr = mtape_data.vs_current;
     1067 	end;
     1068 
     1069      end LINK_VS_END;
     1070 						/* WRITE_LABEL_RECORDS - int procedure to write out label records as specified by PFM */
     1071 
     1072 WRITE_LABEL_RECORDS: proc (ltype, acode);
     1073 
     1074 dcl  ltype fixed bin;
     1075 dcl  (acode, code) fixed bin (35);
     1076 
     1077 	acode = 0;				/* reset return code */
     1078 	if mtape_attach_info.labeled then do;		/* if a labeled tape */
     1079 RECODE_LABELS:					/* target to change EOV to EOF labels */
     1080 	     code = 0;				/* reset error code */
     1081 	     do lab_num = 1 by 1 while (code ^= error_table_$end_of_info); /* write until told to quit */
     1082 		call mtape_data.encode_file_labels (mtdp, mtape_data.tlb, lab_num, ltype, convert, code);
     1083 		if code ^= 0 then			/* if error from encode routine */
     1084 		     if code = error_table_$no_next_volume then /* user does not have another volume */
     1085 			if ltype = EOV_LABEL then do; /* and it is for end of volume */
     1086 			     ltype = EOF_LABEL;	/* then write EOF label */
     1087 			     go to RECODE_LABELS;	/* instead */
     1088 			end;
     1089 		if code = 0 then do;
     1090 		     if nlp = null then do;		/* if no previous label structure, allocate it */
     1091 			if ltype > BOF_LABEL then	/* if EOF or EOV labels.. */
     1092 			     call init_label_record (mtdp, mtape_file_info.last_file_trail_ptr,
     1093 				mtape_file_info.first_file_trail_ptr, lr_ptr, mtape_data.lab_buf_len);
     1094 			else call init_label_record (mtdp, mtape_file_info.last_file_lab_ptr,
     1095 				mtape_file_info.first_file_lab_ptr, lr_ptr, mtape_data.lab_buf_len);
     1096 		     end;
     1097 		     else lr_ptr = nlp;		/* it does exist, use it */
     1098 		     nlp = mtape_label_record.next_lab_ptr; /* update ptr for next label */
     1099 		     mtape_label_record.conversion = convert; /* set conversion indicator & copy label */
     1100 		     based_label_record = mtape_data.tlb -> mtape_label_record.lab_ptr -> based_label_record;
     1101 		     call mtape_$write_label (mtdp, lr_ptr, code); /* write it out */
     1102 		     if code ^= 0 then		/* if unrecoverable error */
     1103 			if code ^= error_table_$eov_on_write then do; /* but not EOV */
     1104 			     call mtape_$error (mtdp, code,
     1105 				"^/Attempting to write ^[BOF^;EOV^;EOF^] file label ^d on volume ^a.",
     1106 				ltype, lab_num, mtape_vol_set.volume_id);
     1107 			     acode = code;		/* report error to caller */
     1108 			     return;
     1109 			end;
     1110 			else code = 0;		/* ignore EOV status for now */
     1111 		end;
     1112 	     end;
     1113 	end;
     1114 
     1115      end WRITE_LABEL_RECORDS;
     1116 
     1117 /* DECODE_UNLABELED_FILE - internal procedure to determine file position and file in file info  */
     1118 
     1119 DECODE_UNLABELED_FILE: proc;
     1120 
     1121 	if fi_ptr = null then do;			/* if file_info does not exist.. */
     1122 	     ltype = BOF_LABEL;			/* must be BOF */
     1123 	     call CREATE_FILE_LINK;			/* create the file info structure */
     1124 	     mtape_file_info.phy_file = mtape_data.position.phy_file; /* copy file number */
     1125 	     pp = mtape_file_info.prev_fi_ptr;		/* make lines shorter */
     1126 	     if pp ^= null then			/* if there was a previous file */
     1127 		if pp -> mtape_file_info.begin_vs_ptr ^= mtape_data.vs_current then do; /* new section */
     1128 		     mtape_file_info.section = pp -> mtape_file_info.section + 1; /* increment */
     1129 		     mtape_file_info.per_file_info = pp -> mtape_file_info.per_file_info;
     1130 		     mtape_file_info.first_file_on_volume = "1"b; /* set for later positioning */
     1131 		     mtape_file_info.first_file_section_ptr = pp -> mtape_file_info.first_file_section_ptr;
     1132 		     mtape_file_info.begin_vs_ptr = pp -> mtape_file_info.begin_vs_ptr;
     1133 		end;
     1134 		else ;
     1135 	     else do;
     1136 		mtape_file_info.section = 1;		/* beginning of new file */
     1137 		if pp = null then do;		/* first file? */
     1138 		     mtape_file_info.seq_number = 1;	/* yes, init seq number */
     1139 		     mtape_file_info.first_file_on_volume = "1"b; /* set for more efficient positioning */
     1140 		end;
     1141 		else mtape_file_info.seq_number = pp -> mtape_file_info.seq_number + 1;
     1142 		mtape_file_info.unlabeled_file = "1"b;	/* set this indicator */
     1143 		mtape_file_info.begin_vs_ptr = vs_ptr;
     1144 		mtape_file_info.first_file_section_ptr = fi_ptr;
     1145 	     end;
     1146 	     call LINK_VS_END;			/* link in the end vol ptr */
     1147 	end;
     1148 	else if mtape_data.phy_file = mtape_file_info.phy_file then do; /* currently positioned */
     1149 	     ltype = BOF_LABEL;			/* within file, its beginning */
     1150 	     if mtape_file_info.prev_fi_ptr ^= null then
     1151 		mtape_file_info.prev_fi_ptr -> mtape_file_info.position_within_file =
     1152 		     NOT_POSITIONED_IN_FILE;
     1153 	     mtape_data.fi_current = fi_ptr;		/* this is now current file */
     1154 	end;
     1155 	else do;					/* either EOF, EOV, or EOFS */
     1156 	     call mtape_$order (mtdp, "fsr", 1, null, rfl_code); /* forward space & ck for EOF status */
     1157 	     if rfl_code ^= 0 & rfl_code ^= error_table_$end_of_info then do; /* a real error */
     1158 		call mtape_$error (mtdp, rfl_code, "^/^a ^a, file ^d to test for EOV",
     1159 		     "Attempting to forward space a block on Unlabeled volume",
     1160 		     mtape_vol_set.volume_name, mtape_data.phy_file);
     1161 		return;
     1162 	     end;
     1163 	     if rfl_code = 0 then do;			/* if no eof status, we were at eof */
     1164 		ltype = EOF_LABEL;
     1165 		call mtape_$order (mtdp, "bsr", 1, null, rfl_code); /* backspace 1 file mark */
     1166 		if rfl_code ^= 0 then
     1167 		     call mtape_$error (mtdp, rfl_code,
     1168 			"^/Positioning to the end of an unlabeled file");
     1169 	     end;
     1170 	     else do;				/* 2 consecutive EOF statuses; EOV or EOFS? */
     1171 		if mtape_vol_set.next_vs_ptr ^= null then do; /*  next volume defined? */
     1172 		     ltype = EOV_LABEL;		/* yes, by definition, this is EOV */
     1173 		     rfl_code = 0;			/* reset EOF status code */
     1174 		end;
     1175 		else do;				/* end of file set */
     1176 		     mtape_file_info.end_of_file_set = "1"b; /* Set marker */
     1177 		     call mtape_$order (mtdp, "bsf", 1, null, rfl_code); /* backspace 1 file mark */
     1178 		     if rfl_code ^= 0 then
     1179 			call mtape_$error (mtdp, rfl_code,
     1180 			     "^/Positioning to the tape mark prior to the end of file set.");
     1181 		     rfl_code = error_table_$end_of_info; /* reset EOF code */
     1182 		end;
     1183 	     end;
     1184 	end;
     1185 
     1186      end DECODE_UNLABELED_FILE;
     1187 
  1     1 /* BEGIN INCLUDE FILE mtape_data.incl.pl1. Created by J. A. Bush 10/06/82  */
  1     2 /* format: style4 */
  1     3 
  1     4 dcl  mtdp ptr;
  1     5 
  1     6 dcl  mtape_data_version_1 char (8) int static options (constant) init ("mtdv0001");
  1     7 
  1     8 dcl  1 mtape_data aligned based (mtdp),
  1     9        2 version char (8),				/* Current structure version */
  1    10        2 areap ptr,					/* Pointer to an allocation area  */
  1    11        2 iocb_ptr ptr,				/* Pointer to our IO control block */
  1    12        2 atdp ptr,					/* Pointer to the attach description string  */
  1    13        2 opdp ptr,					/* Pointer to the open description string */
  1    14        2 cldp ptr,					/* Pointer to close description string */
  1    15        2 dtdp ptr,					/* Pointer to detach description string */
  1    16        2 cmtdp ptr,					/* If non-null, Ptr to allocated copy of mtape_data */
  1    17        2 vs_head ptr,				/* Pointer to the first volume_set structure  */
  1    18        2 vs_tail ptr,				/* Pointer to the last volume_set structure  */
  1    19        2 vs_current ptr,				/* Pointer to the current volume_set structure  */
  1    20        2 vs_mounted_tail ptr,				/* Pointer to MRM volume_set member */
  1    21        2 fi_head ptr,				/* Pointer to the first file_info structure  */
  1    22        2 fi_tail ptr,				/* Pointer to the last file_info structure  */
  1    23        2 fi_current ptr,				/* Pointer to the current file_info structure  */
  1    24        2 tape_infop ptr,				/* Pointer to rcp tape info structure */
  1    25        2 last_ur_status_ptr ptr,			/* If non-null, Ptr to last unrecoverable status */
  1    26        2 io_echan fixed bin (71),			/* Fast wait channel for I/O interrupts */
  1    27        2 mount_echan fixed bin (71),			/* Regular wait channel for mount requests */
  1    28        2 data_xfer_args,				/* Arguments for time critical (read/write) calls */
  1    29          3 arg_buf_ptr ptr,				/* Pointer to users buffer */
  1    30          3 arg_buf_len fixed bin (21),			/* Length of users buffer in bytes */
  1    31          3 arg_rec_len fixed bin (21),			/* Length of record read in bytes */
  1    32        2 error_lock fixed bin (35),			/* if ^= 0 = file locked error code */
  1    33        2 abs_ans char (3),				/* Query answer (yes or no) for abs user */
  1    34        2 user_type bit (1),				/* "1"b => interactive; "0"b => absentee */
  1    35        2 display_errors bit (1),			/* "1"b => display verbose error messages */
  1    36        2 force_end_of_volume bit (1),			/* "1"b => simulate EOV on next write */
  1    37        2 opd_len fixed bin (21),			/* Allocated length of open description */
  1    38        2 drives_in_use fixed bin,			/* Number of tape drives currently in use */
  1    39        2 data_buffers,				/* Info about data buffers */
  1    40          3 buf_ptrs (8) ptr,				/* Pointers to a subset of ioi buffers */
  1    41          3 blind_buf_ptrs (8) ptr,			/* Pointers to other subset of buffers */
  1    42          3 buf_len (8) fixed bin (21),			/* Length of buffers in 9 bit bytes */
  1    43          3 blind_buf_len (8) fixed bin (21),		/* Lengths of other subset of buffers */
  1    44          3 nbufs fixed bin,				/* Number of data buffers currently in use */
  1    45          3 buf_size fixed bin (21),			/* Allocated size of data buffers in bytes */
  1    46          3 bufs_per_subset fixed bin,			/* Number of buffers to write/read per I/O */
  1    47          3 cur_buf_idx fixed bin,			/* Index into subset of current buffer */
  1    48          3 run bit (1),				/* "1"b => wrt I/O queued thru tape_ioi_; "0"b => ^Queued */
  1    49        2 label_buffer,				/* Info about label record buffer */
  1    50          3 lab_bufp ptr,				/* Pointer to label I/O buffer */
  1    51          3 lab_buf_len fixed bin (21),			/* Length of label buffer in 9 bit bytes */
  1    52        2 tlb ptr,					/* Pointer to a temp label record structure */
  1    53        2 position,					/* Position on current volume */
  1    54          3 phy_file fixed bin,			/* physical file number */
  1    55          3 phy_block fixed bin,			/* physical block within physical file */
  1    56        2 current_file,				/* instantanious info about current file */
  1    57          3 cur_block,				/* info about current block */
  1    58 	 4 cur_buf_ptr ptr,				/* Pointer to the current data buffer */
  1    59 	 4 log_record_ptr ptr,			/* Pointer to current logical record */
  1    60 	 4 length fixed bin (21),			/* Length of current block in bytes */
  1    61 	 4 processed fixed bin (21),			/* Number of chars processed already */
  1    62 	 4 remain fixed bin (21),			/* Number of chars remaining to be processed */
  1    63 	 4 log_record fixed bin (21),			/* Log. record within the current block */
  1    64          3 char_size fixed bin,			/* Size in bits of the data chars of this file */
  1    65          3 padding_char char (1),			/* To pad blocks to mod 4 on binary writes */
  1    66          3 length_mode fixed bin,			/* 0 => W/R mod 4 blocks; 1 => W/R non-mod 4 blocks */
  1    67          3 hdw_mode fixed bin,			/* Hardware recording mode:
  1    68*						   1 = binary; 2 = nine track; 3 = BCD */
  1    69          3 conversion fixed bin,			/* File data conversion:
  1    70*						   0 = no conversion; 1 = ASCII<->EBCDIC; 2 = ASCII<->BCD */
  1    71          3 buffer_offset fixed bin,			/* Number of bytes prior to data */
  1    72          3 block_size fixed bin (21),			/* Maximum block size for this file */
  1    73          3 record_size fixed bin (21),			/* Maximum record size for this file */
  1    74          3 prev_block_no fixed bin (21),		/* Number of previous block read */
  1    75          3 ad_file_format fixed bin,			/* 1 = U; 2 = F; 3 = D or V; 4 = S or VS */
  1    76          3 file_blocked bit (1),			/* "1"b => file is blocked */
  1    77          3 native_file bit (1),			/* "1"b => current file written by mtape_ PFM */
  1    78          3 write_after_read bit (1),			/* "1"b => truncate file (and file_set) at this record */
  1    79          3 first_file bit (1),			/* "1"b => first file has been processed */
  1    80          3 tot_bytes_processed fixed bin (35),		/* total bytes in this file section */
  1    81          3 last_io fixed bin,				/* Last I/O operation (1 = read; 2 = write) */
  1    82          3 lrec_rrcx fixed bin,			/* current index of the lrec round robin counter */
  1    83          3 lrec_rrc,				/* history of last n logical records */
  1    84 	 4 block_no (0:7) fixed bin (35),		/* block (within file section) where lrec starts */
  1    85 	 4 block_len (0:7) fixed bin (35),		/* block len of current block */
  1    86 	 4 lrec_no (0:7) fixed bin (35),		/* logical record within currnt block */
  1    87 	 4 abs_byte (0:7) fixed bin (35),		/* byte (within file section) where lrec starts */
  1    88 	 4 byte_offset (0:7) fixed bin,		/* offset of 1st byte of lrec (within block) */
  1    89          3 blk_rrcx fixed bin,			/* index into blk_rrrc array of last block */
  1    90          3 blk_rrrc (0:7) fixed bin (35),		/* contains Lrec count of last n blocks */
  1    91          3 tot_lrec fixed bin (35),			/* Total logical records processed in current file */
  1    92        2 tioi_id bit (36),				/* Identifier used for calls to tape_ioi_ */
  1    93        2 attach_info_ptr ptr,				/* Pointer to attach option info */
  1    94        2 open_info_ptr ptr,				/* Pointer to open option info */
  1    95        2 close_info_ptr ptr,				/* Pointer to close option info */
  1    96        2 detach_info_ptr ptr,				/* Pointer to detach option info */
  1    97        2 pfm_info_ptr ptr,				/* Pointer to PFM info block */
  1    98        2 saved_pfm_info_ptr ptr,			/* Pointer to info for "change_module" control OP */
  1    99        2 pfm_name char (32),				/* Name of Per-Format module */
  1   100        2 pfm_required_entries like pfm_entries,		/* Required entry point declarations in PFM */
  1   101        2 pfm_work_area (32) fixed bin (35);		/* PFM work buffer */
  1   102 
  1   103 dcl  1 pfm_entries based aligned,			/* Entry declarations for PFM entries */
  1   104        2 pfm_init entry (ptr, fixed bin (35)),		/* PFM initialization entry */
  1   105        2 file_open entry (ptr, fixed bin (35)),		/* PFM file_open entry */
  1   106        2 file_close entry (ptr, fixed bin (35)),		/* PFM file_close entry */
  1   107        2 read entry (ptr, fixed bin (35)),		/* PFM read entry */
  1   108        2 write entry (ptr, fixed bin (35)),		/* PFM write entry */
  1   109        2 order entry (ptr, char (*), ptr, ptr, fixed bin (35)), /* PFM control order entry */
  1   110        2 decode_file_labels entry (ptr, ptr, fixed bin, fixed bin, fixed bin (35)),
  1   111        2 encode_file_labels entry (ptr, ptr, fixed bin, fixed bin, fixed bin, fixed bin (35));
  1   112 
  1   113 dcl  all_buf_ptrs (16) ptr based (addr (mtape_data.buf_ptrs));
  1   114 dcl  all_buf_lens (16) fixed bin (21) based (addr (mtape_data.buf_len));
  1   115 dcl  tape_blk (mtape_data.length) char (1) unaligned based (mtape_data.cur_buf_ptr); /* template for a tape block */
  1   116 
  1   117 /* END INCLUDE FILE mtape_data.incl.pl1 */
     1188 
     1189 
  2     1 /* BEGIN INCLUDE FILE mtape_label_record.incl.pl1. Created by J. A. Bush 10/13/82 */
  2     2 /* format: style4 */
  2     3 
  2     4 dcl  lr_ptr ptr;
  2     5 
  2     6 dcl  mtape_lr_version_1 char (8) int static options (constant) init ("mtlrv001");
  2     7 
  2     8 dcl  1 mtape_label_record aligned based (lr_ptr),
  2     9        2 version char (8),				/* Current version */
  2    10        2 prev_lab_ptr ptr,				/* Pointer to previous label record structure */
  2    11        2 next_lab_ptr ptr,				/* Pointer to next label record structure */
  2    12        2 lab_ptr ptr,				/* Pointer to the actual format specific label record */
  2    13        2 lab_length fixed bin,			/* Length in 9 bit bytes of the label record */
  2    14        2 mode fixed bin,				/* Hardware recording mode:
  2    15*						   1 = binary
  2    16*						   2 = nine
  2    17*						   3 = bcd */
  2    18        2 conversion fixed bin;			/* Character set conversion required:
  2    19*						   1 = no conversion
  2    20*						   2 = ASCII <==> EBCDIC (any case)
  2    21*						   3 = ASCII <==> BCD
  2    22*						   4 = ASCII ==> Upper case ASCII
  2    23*						   5 = ASCII ==> Upper case EBCDIC */
  2    24 
  2    25 /* END INCLUDE FILE mtape_label_record.incl.pl1 */
     1190 
     1191 
  3     1 /* BEGIN INCLUDE FILE mtape_err_stats.incl.pl1. Created by J. A. Bush 07/22/83. */
  3     2 /* format: style4 */
  3     3 
  3     4 dcl  es_ptr ptr;
  3     5 
  3     6 dcl  1 mtape_err_stats aligned based (es_ptr),		/* Error statistics block */
  3     7        2 read like err_entry,				/* For read operations */
  3     8        2 write like err_entry,			/* For write operations */
  3     9        2 orders like err_entry,			/* For non-data xfer operations */
  3    10        2 successful_retry (7) fixed bin (35);		/* retrys that succeeded after 1-7 trys */
  3    11 
  3    12 dcl  1 err_entry aligned based,
  3    13        2 errors fixed bin (35),
  3    14        2 operations fixed bin (35);
  3    15 
  3    16 /* END INCLUDE FILE mtape_err_stats.incl.pl1 */
     1192 
     1193 
  4     1 /* BEGIN INCLUDE FILE mtape_vol_set.incl.pl1. Created by J. A. Bush 10/13/82 */
  4     2 /* The include file mtape_err_stats.incl.pl1 is referenced by this include file */
  4     3 /* format: style4 */
  4     4 
  4     5 dcl  vs_ptr ptr;
  4     6 
  4     7 dcl  mtape_vs_version_1 char (8) int static options (constant) init ("mtvsv001");
  4     8 
  4     9 dcl  1 mtape_vol_set aligned based (vs_ptr),
  4    10        2 version char (8),				/* Current version */
  4    11        2 prev_vs_ptr ptr,				/* Pointer to previous volume set entry */
  4    12        2 next_vs_ptr ptr,				/* Pointer to next volume set entry */
  4    13        2 mrm_vs_ptr ptr,				/* Pointer to Most Recently Mounted VS member */
  4    14        2 lrm_vs_ptr ptr,				/* Pointer to Least Recently Mounted VS member */
  4    15        2 first_vl_ptr ptr,				/* Pointer to the first volume label record structure */
  4    16        2 last_vl_ptr ptr,				/* Pointer to the last volume label record structure */
  4    17        2 volume_name char (32),			/* Name specified in the attach description */
  4    18        2 volume_id char (32),				/* Name as recorded in the volume label */
  4    19        2 mount_comment char (64),			/* Mount comment from attach description */
  4    20        2 demount_comment char (64),			/* Demount comment from detach description */
  4    21        2 device_name char (8),			/* Device volume is currently or last mounted on */
  4    22        2 rcp_id bit (36),				/* RCP activation for this volume */
  4    23        2 tioi_id bit (36),				/* tape_ioi_ activation for this volume */
  4    24        2 volume_index fixed bin,			/* Volume sequence number within volume set */
  4    25        2 volume_density fixed bin,			/* Actual volume density determined by RCP */
  4    26        2 volume_type fixed bin,			/* Use rcp_volume_formats.incl.pl1 for decode */
  4    27        2 volume_check fixed bin,			/* Refer to named constants below for values */
  4    28        2 number_of_vol_labels fixed bin,		/* # of volume label records on this volume */
  4    29        2 auth_required bit (1),			/* "1"b => Operator authentication was required */
  4    30        2 mounted bit (1),				/* "1"b => volume currently mounted */
  4    31        2 ever_mounted bit (1),			/* "1"b => volume has been mounted */
  4    32        2 volume_end bit (1),				/* "1"b => reached end of volume (EOT foil) on write */
  4    33        2 first_file_unexpired bit (1),			/* "1"b => first file of volume is unexpired */
  4    34        2 dev_att_retry bit (1),			/* "1"b => DEVICE ATTENTION recovery in progress */
  4    35        2 pwr_off_retry bit (1),			/* "1"b => POWER OFF recovery in progress */
  4    36        2 mounts fixed bin,				/* Number of times volume mounted during attachment */
  4    37        2 tot_error_stats like mtape_err_stats,		/* Summation of error statistics for all mounts */
  4    38        2 rel_error_stats like mtape_err_stats;		/* Summation of error statistics, this mount */
  4    39 
  4    40 /* Named constants applied to volume_check variable, when volume label read by PFMs pfm_init entry */
  4    41 
  4    42 dcl  (MTAPE_VOLUME init (1),				/* Volume recorded by mtape_ (desired type) */
  4    43      MULT_PRIOR_VOLUME init (2),			/* Volume recorded by prior Multics software
  4    44*						   (desired type) */
  4    45      NON_MULT_VOLUME init (3),			/* Volume recorded by other vendor (desired type) */
  4    46      BLANK_VOLUME init (4),				/* Volume is blank/unreadable */
  4    47      UNLABELED_VOLUME init (5),			/* Volume is unlabeled or has unrecognized label */
  4    48      RECOG_FORMAT_VOLUME init (6)			/* Volume has label of other recognized format */
  4    49      ) fixed bin int static options (constant);
  4    50 
  4    51 /* END INCLUDE FILE mtape_vol_set.incl.pl1 */
     1194 
     1195 
  5     1 /* BEGIN INCLUDE FILE mtape_file_info.incl.pl1. Created by J. A. Bush 10/13/82 */
  5     2 /* format: style4 */
  5     3 
  5     4 dcl  fi_ptr ptr;
  5     5 
  5     6 dcl  mtape_fi_version_1 char (8) int static options (constant) init ("mtfiv001");
  5     7 
  5     8 dcl  1 mtape_file_info aligned based (fi_ptr),
  5     9        2 version char (8),				/* Current version */
  5    10        2 prev_fi_ptr ptr,				/* Pointer to the previous file info structure */
  5    11        2 next_fi_ptr ptr,				/* Pointer to the next file info structure */
  5    12        2 first_file_lab_ptr ptr,			/* Pointer to 1st label record struc. */
  5    13        2 last_file_lab_ptr ptr,			/* Pointer to last label record struc. */
  5    14        2 first_file_trail_ptr ptr,			/* Pointer to 1st trailer record struc. */
  5    15        2 last_file_trail_ptr ptr,			/* Pointer to last trailer record struc. */
  5    16        2 first_file_section_ptr ptr,			/* Pointer to file_info struct. of 1st file section */
  5    17        2 begin_vs_ptr ptr,				/* Pointer to 1st volume set struct. containing this file */
  5    18        2 end_vs_ptr ptr,				/* Pointer to last volume set struct. containing this file */
  5    19        2 position_within_file fixed bin,		/* 0 = In HDR; 1 = In data file; 2 = In trailer;
  5    20*						   3 = Not positioned within this file
  5    21*						   4 = At beginning of data file; 5 = At EOF */
  5    22        2 per_file_info,				/* Information pertaining to entire file */
  5    23          3 file_id char (32),				/* File identifier or name */
  5    24          3 file_set_id char (32),			/* Identifies the file set */
  5    25          3 creation_date char (6),			/* File creation date in form " yyddd" */
  5    26          3 expiration_date char (6),			/* File expiration date in form " yyddd" */
  5    27          3 file_code char (3),			/* Printable file code */
  5    28          3 file_format fixed bin,			/* Current file format:
  5    29*						   0 = unspecified; 1 = U; 2 = F; 3 = D or V;
  5    30*						   4 = S or VS; 5 = FB;
  5    31*						   6 = DB or VB; 7 = SB or VBS; */
  5    32          3 seq_number fixed bin,			/* File sequence number */
  5    33          3 generation fixed bin,			/* File generation number, if supported */
  5    34          3 gen_version fixed bin,			/* File generation version number, if supported */
  5    35          3 char_size fixed bin,			/* Size in bits of the data chars of this file */
  5    36          3 hdw_mode fixed bin,			/* Hardware mode: 1 = binary; 2 = nine; 3 = BCD */
  5    37          3 conversion fixed bin,			/* File data conversion:
  5    38*						   1 = no conversion; 2 = ASCII<->EBCDIC; 3 = ASCII<->BCD */
  5    39          3 buffer_offset fixed bin,			/* Number of bytes prior to data */
  5    40          3 length_mode fixed bin,			/* 0 => W/R mod 4 blocks; 1 => W/R non-mod 4 blocks */
  5    41          3 block_size fixed bin (21),			/* Maximum block size for this file */
  5    42          3 record_size fixed bin (21),			/* Maximum record size for this file */
  5    43          3 native_file bit (1),			/* "1"b => current file written by mtape_ PFM */
  5    44          3 user_labels_present bit (1),			/* "1"b => UHL<n>/UTL<n> are present */
  5    45          3 unlabeled_file bit (1),			/* "1"b => this is unlabeled file */
  5    46          3 pfm_opt_sw (5) bit (1),			/* PFM dependent */
  5    47          3 pfm_opt_value (5) fixed bin (35),		/* PFM dependent */
  5    48          3 pfm_opt_str (5) char (32),			/* PFM dependent */
  5    49        2 per_section_info,				/* Information pertaining only to this file section */
  5    50          3 section fixed bin,				/* File section number for multi-volume files */
  5    51          3 phy_file fixed bin,			/* Phy. file of HDR label GRP, on the current volume */
  5    52          3 first_file_on_volume bit (1),		/* "1"b => First file or file section on this volume */
  5    53          3 end_of_file_set bit (1),			/* "1"b => This is last file of file set */
  5    54          3 block_count fixed bin (35),			/* Number of blocks in this file section */
  5    55          3 read_errors fixed bin (35),			/* of errors encountered reading this file */
  5    56          3 write_errors fixed bin (35);			/* of errors encountered writing this file */
  5    57 
  5    58 /* END INCLUDE FILE mtape_file_info.incl.pl1 */
     1196 
     1197 
  6     1 /* BEGIN INCLUDE FILE mtape_attach_info.incl.pl1. Created by J. A. Bush 06/13/83 */
  6     2 /* format: style4 */
  6     3 
  6     4 dcl  maip ptr;
  6     5 
  6     6 dcl  mtape_attach_info_version_1 char (8) int static options (constant) init ("maiv0001");
  6     7 
  6     8 dcl  1 mtape_attach_info aligned based (maip),
  6     9        2 version char (8),				/* Current structure version */
  6    10        2 density fixed bin (35),			/* 200, 556, 800, 1600, 6250 BPI */
  6    11        2 tracks fixed bin (35),			/* Number of tracks, 7 or 9 */
  6    12        2 speed bit (36),				/* "000"b = any speed; "1xx"b = 75 IPS;
  6    13*						   "x1x"b = 125 IPS; "xx1"b = 200 IPS */
  6    14        2 ndrives fixed bin (35),			/* 0 = unspecified; 1 - 63 devices to be used */
  6    15        2 wait_time fixed bin (35),			/* time to wait in minutes for available device */
  6    16        2 pfm_prefix char (21),			/* if "-volume_type" was specified */
  6    17        2 default_pfm_prefix char (21),			/* if no "-vt" specified and blank volume */
  6    18        2 display bit (1),				/* Display attach description on user_output */
  6    19        2 labeled bit (1),				/* "1"b => labeled; "0"b => unlabeled volume set */
  6    20        2 wait bit (1),				/* "1"b => wait for available devices; "0"b => don't wait */
  6    21        2 system bit (1),				/* "1"b => User wants to be a "system" process */
  6    22        2 ring bit (1);				/* "1"b => write ring in; "0"b => no write ring */
  6    23 
  6    24 /* END INCLUDE FILE mtape_attach_info.incl.pl1 */
     1198 
     1199 
  7     1 /*  BEGIN INCLUDE FILE mtape_pfm_info.incl.pl1. Created by J. A. Bush 06/16/83 */
  7     2 /* format: style4 */
  7     3 
  7     4 dcl  mpfmip ptr;
  7     5 
  7     6 dcl  mtape_pfm_info_version_1 char (8) int static options (constant) init ("mpiv0001");
  7     7 
  7     8 dcl  1 mtape_pfm_info aligned based (mpfmip),		/* PFM information block */
  7     9        2 version char (8),				/* Current structure version */
  7    10        2 module_id char (21),				/* For identification of PFM. (e.g. ANSI, IBM, GCOS) */
  7    11        2 open_modes_allowed (3) fixed bin,		/* Allowable open modes for this PFM */
  7    12        2 bof_prefix char (3),				/* For identification of BOF labels */
  7    13        2 eov_prefix char (3),				/* For identification of EOV labels */
  7    14        2 eof_prefix char (3),				/* For identification of EOF labels */
  7    15        2 no_labels_ok bit (1),			/* "1"b => PFM processes unlabeled volumes */
  7    16        2 multi_volumes_ok bit (1),			/* "1"b => PFM processes multi-volume sets */
  7    17        2 extended_error_recovery bit (1),		/* "1"b => PFM will do error recovery after mtape_ gives up */
  7    18        2 pfm_open_options like pfm_options,		/* open options common to this PFM */
  7    19        2 pfm_close_options like pfm_options;		/* close options common to this PFM */
  7    20 
  7    21 dcl  1 pfm_options aligned based,			/* common to open and close pfm options */
  7    22        2 pfm_opt_flags (5),				/* identifies use of "pfm_opt_sw (1-5)" close flags */
  7    23          3 flag_name char (32),			/* name of flag */
  7    24          3 flag_ant_name char (32),			/* antonym name */
  7    25        2 pfm_opt_value_name (5) char (32),		/* identifies use of "pfm_opt_value (1-5)" */
  7    26        2 pfm_opt_str_name (5) char (32);		/* identifies use of "pfm_opt_str (1-5)" */
  7    27 
  7    28 /*  END INCLUDE FILE mtape_pfm_info.incl.pl1 */
     1200 
     1201 
  8     1 /* BEGIN INCLUDE FILE mtape_open_close_info.incl.pl1. Created by J. A. Bush 06/13/83 */
  8     2 /* format: style4 */
  8     3 
  8     4 dcl  moip ptr;					/* Pointer to mtape_open_info structure */
  8     5 dcl  mcip ptr;					/* Pointer to mtape_close_info structure */
  8     6 
  8     7 dcl  mtape_open_info_version_1 char (8) int static options (constant) init ("moiv0001");
  8     8 dcl  mtape_close_info_version_1 char (8) int static options (constant) init ("mciv0001");
  8     9 
  8    10 dcl  1 mtape_open_info aligned based (moip),
  8    11        2 version char (8),				/* Current structure version */
  8    12        2 cs_ptr ptr,				/* Pointer to arg processing control structure */
  8    13        2 cal_ptr ptr,				/* Pointer to arg processing ctl arg list */
  8    14        2 so_ptr ptr,				/* Pointer to last saved iox_ options */
  8    15        2 open_mode fixed bin,				/* iox_ opening mode */
  8    16        2 comment char (80),				/* Display on user_output after open */
  8    17        2 expiration char (24),			/* File expiration date */
  8    18        2 file_format char (3),			/* File format code */
  8    19        2 recording_mode char (6),			/* Ascii, ebcdic, or binary */
  8    20        2 file_name char (32),				/* Name of file to be recorded */
  8    21        2 replace_id char (32),			/* Name of file to replace */
  8    22        2 init_to_zero,				/* Enables clearing rest of structure */
  8    23          3 block_length fixed bin (35),			/* Block size in bytes */
  8    24          3 record_length fixed bin (35),		/* Record length specified by user */
  8    25          3 default_span_rlen fixed bin (35),		/* Default record length for spanned records */
  8    26          3 default_var_rlen fixed bin (35),		/* Default record length for variable records */
  8    27          3 default_fix_rlen fixed bin (35),		/* Default record length for fixed records */
  8    28          3 seq_number fixed bin (35),			/* File sequence number */
  8    29          3 append bit (1),				/* "1"b => append file to end of file set */
  8    30          3 create bit (1),				/* "1"b => create this file */
  8    31          3 display bit (1),				/* "1"b => display the open description */
  8    32          3 extend bit (1),				/* "1"b => extend the current file */
  8    33          3 force bit (1),				/* "1"b => disregard file expiration when creating */
  8    34          3 last_file bit (1),				/* "1"b => position to last file of file set */
  8    35          3 next_file bit (1),				/* "1"b => position to next file of file set */
  8    36          3 modify bit (1),				/* "1"b => modify the current file */
  8    37          3 label_entry_present bit (1),			/* "1"b => user label entry is valid */
  8    38          3 user_label entry (ptr, char (*), fixed bin, fixed bin, fixed bin, fixed bin (35)),
  8    39          3 pfm_args like pfm_arg_values;		/* see structure below */
  8    40 
  8    41 dcl  1 mtape_close_info aligned based (mcip),
  8    42        2 version char (8),				/* Current structure version */
  8    43        2 cs_ptr ptr,				/* Pointer to arg processing control structure */
  8    44        2 cal_ptr ptr,				/* Pointer to arg processing ctl arg list */
  8    45        2 so_ptr ptr,				/* Pointer to last saved iox_ options */
  8    46        2 comment char (80),				/* Display on user_output after open */
  8    47        2 init_to_zero,				/* Enables clearing rest of structure */
  8    48          3 display bit (1),				/* Display open description for user */
  8    49          3 position fixed bin,			/* For positioning on file closing:
  8    50*						   0 = Leave at current position;
  8    51*						   1 = Position to beginning of file;
  8    52*						   2 = Position to end of file;
  8    53*						   3 = Position to beginning of file section;
  8    54*						   4 = Position to end of file section */
  8    55          3 pfm_args like pfm_arg_values;		/* see structure below */
  8    56 
  8    57 dcl  1 pfm_arg_values aligned based,			/* Common to open and close_info */
  8    58        2 pfm_opt_sw (5) bit (1),			/* PFM dependent */
  8    59        2 pfm_opt_value (5) fixed bin (35),		/* PFM dependent */
  8    60        2 pfm_opt_str (5) char (32);			/* PFM dependent */
  8    61 
  8    62 /* END INCLUDE FILE mtape_open_close_info.incl.pl1 */
     1202 
     1203 
  9     1 /* BEGIN INCLUDE FILE mtape_constants.incl.pl1. Created by J. A. Bush 10/07/82 */
  9     2 /* format: style4 */
  9     3 
  9     4 /* This include file defines various named constants used throughout mtape_
  9     5*   and its associated Per-Format modules */
  9     6 
  9     7 /* Storage allocation constants, used to denote what type of storage to allocate */
  9     8 
  9     9 dcl  (MTAPE_ALLOC_VS init (1),			/* to allocate a volume_set structure */
  9    10      MTAPE_ALLOC_LR init (2),				/* to allocate a label record structure */
  9    11      MTAPE_ALLOC_FI init (3),				/* to allocate a file_info structure */
  9    12      MTAPE_ALLOC_STR init (4)				/* to allocate a character string, or undefined block */
  9    13      ) fixed bin int static options (constant);
  9    14 
  9    15 /* Volume density constants */
  9    16 
  9    17 dcl  MTAPE_VALID_DENSITIES (5) init (200, 556, 800, 1600, 6250)
  9    18 	fixed bin int static options (constant);
  9    19 
  9    20 /* Device speed constants */
  9    21 
  9    22 dcl  MTAPE_SPEED_VALUES (4) init (0, 75, 125, 200)	/* 0 is any speed device */
  9    23 	fixed bin int static options (constant);
  9    24 
  9    25 /* Hardware Mode constants */
  9    26 
  9    27 dcl  (MTAPE_HWM_BIN init (1),				/* For binary hardware mode */
  9    28      MTAPE_HWM_NINE init (2),				/* For nine hardware mode */
  9    29      MTAPE_HWM_BCD init (3)				/* For BCD hardware mode */
  9    30      ) fixed bin int static options (constant);
  9    31 
  9    32 /* Data conversion constants */
  9    33 
  9    34 dcl  (MTAPE_UNSPECIFIED init (0),			/* attribute not specified */
  9    35      MTAPE_NO_CONVERSION init (1),			/* No conversion on input or output */
  9    36      MTAPE_CV_EBCDIC init (2),			/* Convert to/from EBCDIC (from/to ASCII) */
  9    37      MTAPE_CV_BCD init (3),				/* Convert to/from BCD (from/to ASCII) */
  9    38      MTAPE_CV_UC_ASCII init (4),			/* Convert to Upper case ASCII (from any case ASCII) */
  9    39      MTAPE_CV_UC_EBCDIC init (5)			/* Convert to Upper case EBCDIC (from any case ASCII) */
  9    40      ) fixed bin int static options (constant);
  9    41 
  9    42 /* File positioning constants */
  9    43 
  9    44 dcl  (NOT_POSITIONED_IN_FILE init (0),			/* Not currently positioned within this file */
  9    45      AT_BOFH init (1),				/* Positioned at beginning of file hdr */
  9    46      AT_EOFH init (2),				/* Positioned at end of file hdr */
  9    47      AT_BOFD init (3),				/* Positioned at beginning of file data */
  9    48      AT_IFD init (4),				/* Positioned in file data, not beginning */
  9    49      AT_EOFD init (5),				/* Positioned prior to end of data file */
  9    50      AT_BOFT init (6),				/* Positioned at beginning of trailer label file */
  9    51      AT_EOFT init (7),				/* Positioned at end of trailer label file */
  9    52      AT_EOF init (8),				/* Positioned after trailer labels at EOF */
  9    53      FILES_PER_FILE_GRP init (3)			/* # of physical files per file (section) group */
  9    54      ) fixed bin int static options (constant);
  9    55 
  9    56 dcl  (BOF_LABEL init (1),				/* indicates beginning of file label */
  9    57      EOV_LABEL init (2),				/* indicates end of volume label */
  9    58      EOF_LABEL init (3)				/* indicates end of file label */
  9    59      ) fixed bin int static options (constant);
  9    60 
  9    61 /* user query constant codes */
  9    62 
  9    63 dcl  (Q_NO_NEXT_VOLUME init (1),
  9    64      Q_LABELED_VOLUME init (2),
  9    65      Q_UNEXPIRED_VOLUME init (3),
  9    66      Q_INCORRECT_VOLUME init (4),
  9    67      Q_UNEXPIRED_FILE init (5),
  9    68      Q_ABORT_FILE init (6)
  9    69      ) fixed bin int static options (constant);
  9    70 
  9    71 /* END INCLUDE FILE mtape_constants.incl.pl1 */
     1204 
     1205 
     1206      end pfm_utils_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/27/00  1800.3  pfm_utils_.pl1                    >udd>sm>ds>y2k>update>pfm_utils_.pl1
1188         1    02/16/84  1452.3  mtape_data.incl.pl1               >ldd>incl>mtape_data.incl.pl1
1190         2    02/16/84  1452.3  mtape_label_record.incl.pl1       >ldd>incl>mtape_label_record.incl.pl1
1192         3    02/16/84  1452.3  mtape_err_stats.incl.pl1          >ldd>incl>mtape_err_stats.incl.pl1
1194         4    02/16/84  1452.4  mtape_vol_set.incl.pl1            >ldd>incl>mtape_vol_set.incl.pl1
1196         5    02/16/84  1452.3  mtape_file_info.incl.pl1          >ldd>incl>mtape_file_info.incl.pl1
1198         6    02/16/84  1452.3  mtape_attach_info.incl.pl1        >ldd>incl>mtape_attach_info.incl.pl1
1200         7    02/16/84  1452.4  mtape_pfm_info.incl.pl1           >ldd>incl>mtape_pfm_info.incl.pl1
1202         8    06/11/85  1429.6  mtape_open_close_info.incl.pl1    >ldd>incl>mtape_open_close_info.incl.pl1
1204         9    02/16/84  1452.3  mtape_constants.incl.pl1          >ldd>incl>mtape_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
AT_BOFD                                constant        fixed bin(17,0)          initial dcl 9-44 set ref 256 493 588 632 664* 881
AT_BOFH                         000124 constant        fixed bin(17,0)          initial dcl 9-44 set ref 254 534 535* 590 601 618*
                                                                                  627 629* 766* 864 1050
AT_BOFT                         000016 constant        fixed bin(17,0)          initial dcl 9-44 set ref 526 632 638* 650* 754* 897
AT_EOF                                 constant        fixed bin(17,0)          initial dcl 9-44 set ref 259 280 290 491 557 584 621
                                                                                  789* 914
AT_EOFD                                constant        fixed bin(17,0)          initial dcl 9-44 set ref 586 632 662* 889
AT_EOFH                                constant        fixed bin(17,0)          initial dcl 9-44 ref 872
AT_EOFT                                constant        fixed bin(17,0)          initial dcl 9-44 ref 632 905
AT_IFD                                 constant        fixed bin(17,0)          initial dcl 9-44 ref 294 632
BOF_LABEL                              constant        fixed bin(17,0)          initial dcl 9-56 ref 401 432 516 604 646 649 823
                                                                                  1091 1122 1149
EOF_LABEL                              constant        fixed bin(17,0)          initial dcl 9-56 set ref 263 417 491 554 757* 802
                                                                                  1086 1164
EOV_LABEL                              constant        fixed bin(17,0)          initial dcl 9-56 ref 262 270 271 275 412 480 1083
                                                                                  1172
EXPIRED                         000035 constant        bit(1)                   initial packed unaligned dcl 172 ref 175 183
FILES_PER_FILE_GRP                     constant        fixed bin(17,0)          initial dcl 9-44 ref 283
IFH_BKS_CNT                     000043 constant        fixed bin(17,0)          initial array dcl 74 ref 232
LC                              000026 constant        char(26)                 initial packed unaligned dcl 78 ref 703
MTAPE_ALLOC_FI                  000123 constant        fixed bin(17,0)          initial dcl 9-9 set ref 1044*
MTAPE_ALLOC_LR                  000122 constant        fixed bin(17,0)          initial dcl 9-9 set ref 124*
MTAPE_ALLOC_STR                 000117 constant        fixed bin(17,0)          initial dcl 9-9 set ref 131*
MTAPE_CV_UC_ASCII                      constant        fixed bin(17,0)          initial dcl 9-34 ref 130
MTAPE_HWM_NINE                         constant        fixed bin(17,0)          initial dcl 9-27 ref 129
NLB_BKS_CNT                     000035 constant        fixed bin(17,0)          initial array dcl 76 ref 234
NON_MULT_VOLUME                        constant        fixed bin(17,0)          initial dcl 4-42 ref 578
NOT_POSITIONED_IN_FILE                 constant        fixed bin(17,0)          initial dcl 9-44 ref 198 404 481 698 1150
Q_ABORT_FILE                    000016 constant        fixed bin(17,0)          initial dcl 9-63 set ref 739*
UC                              000017 constant        char(26)                 initial packed unaligned dcl 80 ref 703
UNEXPIRED                       010524 constant        bit(1)                   initial packed unaligned dcl 173 ref 177 181
acode                                  parameter       fixed bin(35,0)          dcl 1075 in procedure "WRITE_LABEL_RECORDS" set ref
                                                                                  1072 1077* 1107*
acode                                  parameter       fixed bin(35,0)          dcl 736 in procedure "ABORT_FILE" set ref 734 738*
                                                                                  760* 770*
append                   74            based           bit(1)                   level 3 dcl 8-10 ref 584 612 646 802 809
areap                     2            based           pointer                  level 2 dcl 1-8 ref 313 325 327 337 339 341 350 352
                                                                                  354 773 775 777 780 786
arg_code                               parameter       fixed bin(35,0)          dcl 56 set ref 189 296* 364 495* 505 514* 563* 568
                                                                                  576* 672*
arg_fi_ptr                             parameter       pointer                  dcl 58 set ref 189 193 299* 364 367 498* 568 571
                                                                                  670* 677 680 729*
arg_length                             parameter       fixed bin(21,0)          dcl 54 set ref 121 128 131*
arg_lr_ptr                             parameter       pointer                  dcl 55 set ref 121 133*
arg_ltype                              parameter       fixed bin(17,0)          dcl 57 set ref 364 497* 505 508 559
arg_mtdp                               parameter       pointer                  dcl 51 set ref 121 123 189 191 304 306 364 366 500*
                                                                                  505 507 568 570 668* 677 679
arg_vs_ptr                             parameter       pointer                  dcl 59 set ref 189 192 298* 364 368 499* 568 572
                                                                                  671*
attach_info_ptr         274            based           pointer                  level 2 dcl 1-8 ref 194 307 369 511 573 682
based_area                             based           area(1024)               dcl 116 ref 313 325 327 337 339 341 350 352 354 773
                                                                                  775 777 780 786
based_label_record                     based           char                     packed unaligned dcl 115 set ref 132* 319 323 327
                                                                                  339 352 399 411 415 422* 457* 457 461 461 463*
                                                                                  463* 775 1100* 1100
begin_vs_ptr             20            based           pointer                  level 2 dcl 5-8 set ref 212 447* 447 451* 697* 697
                                                                                  721* 859* 868* 876* 1126 1132* 1132 1143*
bks_file_cnt                    000120 automatic       fixed bin(17,0)          dcl 67 set ref 232* 234* 235*
block_count             156            based           fixed bin(35,0)          level 3 dcl 5-8 set ref 517*
block_length             66            based           fixed bin(35,0)          level 3 dcl 8-10 ref 723
block_size               63            based           fixed bin(21,0)          level 3 dcl 5-8 set ref 723*
bof_prefix               13            based           char(3)                  level 2 dcl 7-8 ref 399
clock                                                  builtin function         dcl 97 ref 154
clock_value                     000136 automatic       fixed bin(71,0)          dcl 142 set ref 154* 155* 157* 159*
code                            000272 automatic       fixed bin(35,0)          dcl 1075 in procedure "WRITE_LABEL_RECORDS" set ref
                                                                                  1079* 1081 1082* 1083 1083 1089 1101* 1102 1102
                                                                                  1104* 1107 1110*
code                            000100 automatic       fixed bin(35,0)          dcl 65 in procedure "pfm_utils_" set ref 155* 197*
                                                                                  199* 200* 213* 214 215* 226 235* 236 237* 245* 246
                                                                                  247* 264* 265 266* 272* 273 284* 285 286* 296 576*
                                                                                  580* 600 602* 603 605* 606* 619 630 639 641 643*
                                                                                  644 644 646 646 649 651 656* 661* 672 739* 740
                                                                                  741* 751 755 757* 758 759* 760 767 768* 769 782*
                                                                                  861 864 870 872 879 881 887 889 895 897 903 905
                                                                                  911 914 929* 930 931* 964 964* 982 997* 998 1003
                                                                                  1003* 1005 1006* 1020* 1021 1022* 1031* 1032 1032*
conversion               12            based           fixed bin(17,0)          level 2 dcl 2-8 set ref 130* 1099*
convert                         000126 automatic       fixed bin(17,0)          dcl 67 set ref 1082* 1099
convert_date_to_binary_         000050 constant        entry                    external dcl 108 ref 155
date_time                              parameter       char                     packed unaligned dcl 141 set ref 139 155 155*
datebin_                        000052 constant        entry                    external dcl 109 ref 159
datebin_$dayr_clk               000054 constant        entry                    external dcl 111 ref 157
ddd                             000140 automatic       picture(3)               packed unaligned dcl 143 set ref 158* 161 163
decode_file_labels      350            based           entry variable           level 3 dcl 1-8 ref 429
desired_position                       parameter       fixed bin(17,0)          dcl 60 ref 189 207 237 247
encode_file_labels      354            based           entry variable           level 3 dcl 1-8 ref 1082
end_of_file_set         155            based           bit(1)                   level 3 dcl 5-8 set ref 358* 383* 555* 623 694* 695*
                                                                                  708* 725* 788* 809 1176*
end_vs_ptr               22            based           pointer                  level 2 dcl 5-8 set ref 721* 753* 885* 893* 901*
                                                                                  909* 1066*
eof_prefix               15            based           char(3)                  level 2 dcl 7-8 ref 319 323 415
eov_prefix               14            based           char(3)                  level 2 dcl 7-8 ref 411
err_entry                              based           structure                level 1 dcl 3-12
error_table_$end_of_info        000012 external static fixed bin(35,0)          dcl 86 ref 375 380 388 644 646 1081 1157 1181
error_table_$eov_on_write       000014 external static fixed bin(35,0)          dcl 87 ref 1102
error_table_$file_aborted       000022 external static fixed bin(35,0)          dcl 90 ref 760 770
error_table_$invalid_file_set_format
                                000020 external static fixed bin(35,0)          dcl 89 ref 605 738
error_table_$invalid_label_format
                                000016 external static fixed bin(35,0)          dcl 88 ref 421 462
error_table_$lost_device_position
                                000010 external static fixed bin(35,0)          dcl 85 ref 199
error_table_$no_file            000026 external static fixed bin(35,0)          dcl 92 ref 656
error_table_$no_next_volume     000030 external static fixed bin(35,0)          dcl 93 ref 559 1083
error_table_$uninitialized_volume
                                000024 external static fixed bin(35,0)          dcl 91 ref 580
extend                   77            based           bit(1)                   level 3 dcl 8-10 ref 316 586 662 802
fi_current               34            based           pointer                  level 2 dcl 1-8 set ref 345 358 359 407* 510 617
                                                                                  748* 752 781* 785* 825 825 1012* 1045* 1153*
fi_head                  30            based           pointer                  level 2 dcl 1-8 set ref 592 781* 1046 1047*
fi_ptr                          000154 automatic       pointer                  dcl 5-4 set ref 193* 198 200 209 209 211* 211 212
                                                                                  215 220 223 232 234 237 247 254 256 259 266 272*
                                                                                  275* 275 280 283 286 290 290 290 290 294 299 311*
                                                                                  312 313 314 317 330 330 332 335 341 341 343 343
                                                                                  345 348 354 354* 357* 367* 382* 383 402 404 404
                                                                                  407 408 413 418 432 432 436 436 439 440 440 440
                                                                                  442 443 444 444 447 447 451 452 452 481 491 493
                                                                                  498 510* 517 526 528 534 535* 539 555 557 571*
                                                                                  592* 593 595* 595 602* 606 606 612* 612 616* 617
                                                                                  621 621 623 625* 625 627 632 632 632 632 632 643*
                                                                                  646* 646 658* 670 680* 686 689 691 692 693 694 696
                                                                                  697 703 707 711 713 714 717 718 720 721 721 722
                                                                                  722 723 724 725 726 727 729 747 748 752* 753 756
                                                                                  771 777 777 779 780 785 785* 786 787 788 809 815
                                                                                  817 819 825 859 862 864 868 871 872 876 880 881
                                                                                  885 888 889 893 896 897 901 904 905 909 912 914
                                                                                  937* 937 941 942 945* 949* 980 1006 1012 1022 1032
                                                                                  1044* 1045 1047 1048 1050 1051 1063 1064 1091 1091
                                                                                  1094 1094 1121 1124 1125 1128 1129 1130 1131 1132
                                                                                  1136 1138 1139 1141 1142 1143 1144 1144 1148 1150
                                                                                  1150 1153 1176
fi_tail                  32            based           pointer                  level 2 dcl 1-8 set ref 311 359* 382 616 781* 785*
                                                                                  1044* 1045*
file_id                  25            based           char(32)                 level 3 dcl 5-8 set ref 200* 215* 237* 247* 266*
                                                                                  286* 714* 718* 817 819 1006* 1022* 1032*
file_name                46            based           char(32)                 level 2 dcl 8-10 ref 714 714 812 817
file_set_id              35            based           char(32)                 level 3 dcl 5-8 set ref 703* 707* 707
first_file_lab_ptr        6            based           pointer                  level 2 dcl 5-8 set ref 354 354 408 436* 539 777 777
                                                                                  1094*
first_file_on_volume    154            based           bit(1)                   level 3 dcl 5-8 set ref 223 443* 693* 980 1048*
                                                                                  1130* 1139*
first_file_section_ptr
                         16            based           pointer                  level 2 dcl 5-8 set ref 209 211 290 290 444* 444
                                                                                  452* 696* 696 722* 937 942 942 1064 1064 1131*
                                                                                  1131 1144*
first_file_trail_ptr     12            based           pointer                  level 2 dcl 5-8 set ref 330* 341 341 343* 413 418
                                                                                  432* 528 756 1091*
forward                         000134 automatic       bit(1)                   dcl 69 set ref 977* 992* 996 1000* 1006*
found                           000133 automatic       bit(1)                   dcl 69 set ref 591* 593 594* 595 598 641 645* 646
                                                                                  646 649 655
fwd_file_cnt                    000121 automatic       fixed bin(17,0)          dcl 67 set ref 206* 220* 228* 230 231* 244 245* 283*
                                                                                  284*
htype                                  parameter       fixed bin(17,0)          dcl 800 in procedure "DESIRED_FILE" ref 798 802 802
                                                                                  823
htype                           000124 automatic       fixed bin(17,0)          dcl 67 in procedure "pfm_utils_" set ref 262* 263
                                                                                  270* 271 272* 275 602* 604 606* 643* 645* 646 649
init_to_zero             66            based           structure                level 2 dcl 8-10
lab_buf_len             152            based           fixed bin(21,0)          level 3 dcl 1-8 set ref 432* 436* 1091* 1094*
lab_length               10            based           fixed bin(17,0)          level 2 dcl 2-8 set ref 128* 132 319 323 327 327 339
                                                                                  339 352 352 399 411 415 422 422 457 457 461 461
                                                                                  463 463 463 463 775 775 1100 1100
lab_num                         000117 automatic       fixed bin(17,0)          dcl 67 set ref 375* 380 399 429* 438* 1081* 1082*
                                                                                  1104*
lab_ptr                   6            based           pointer                  level 2 dcl 2-8 set ref 131* 132 319 323 327 339 352
                                                                                  399 411 415 422 457 457 461 461 463 463 775 1100
                                                                                  1100
label_buffer            150            based           structure                level 2 dcl 1-8
label_date                             parameter       char                     packed unaligned dcl 170 ref 168 175 177 181
labeled                  24            based           bit(1)                   level 2 dcl 6-8 ref 232 254 375 518 531 578 727 1078
last_file               101            based           bit(1)                   level 3 dcl 8-10 ref 664 802 809
last_file_lab_ptr        10            based           pointer                  level 2 dcl 5-8 set ref 348 436* 771 1094*
last_file_section                      parameter       bit(1)                   dcl 926 ref 923 937
last_file_trail_ptr      14            based           pointer                  level 2 dcl 5-8 set ref 317 330* 332* 335 343* 432*
                                                                                  1091*
link_head                              parameter       pointer                  dcl 52 set ref 121 126 126*
link_tail                              parameter       pointer                  dcl 53 set ref 121 124* 125*
lr_ptr                          000150 automatic       pointer                  dcl 2-4 set ref 124* 125 126 128 129 130 131 132 132
                                                                                  133 317* 317* 319 319 323 323 325 325 327 327 327*
                                                                                  329 330 332 335* 335* 337 337 339 339 339* 340
                                                                                  348* 348* 350 350 352 352 352* 353 377* 378* 399
                                                                                  399 411 411 415 415 422 422 422 429* 432* 436* 457
                                                                                  457 457 458 461 461 461 463 463 463 463 463 771*
                                                                                  771* 773 773 775 775 775* 776 1091* 1094* 1097*
                                                                                  1098 1099 1100 1100 1100 1101*
ltype                           000116 automatic       fixed bin(17,0)          dcl 67 in procedure "pfm_utils_" set ref 372* 401*
                                                                                  412* 417* 429* 432 480 491 497 508* 516 541* 554
                                                                                  559 1122* 1149* 1164* 1172*
ltype                                  parameter       fixed bin(17,0)          dcl 1074 in procedure "WRITE_LABEL_RECORDS" set ref
                                                                                  1072 1082* 1083 1086* 1091 1104*
maip                            000156 automatic       pointer                  dcl 6-4 set ref 194* 232 254 307* 369* 375 511* 518
                                                                                  531 573* 578 682* 727 1078
mod                                                    builtin function         dcl 97 ref 160
mode                     11            based           fixed bin(17,0)          level 2 dcl 2-8 set ref 129*
modify                  103            based           bit(1)                   level 3 dcl 8-10 ref 588 664 802
module_id                 2            based           char(21)                 level 2 dcl 7-8 set ref 463*
moip                            000162 automatic       pointer                  dcl 8-4 set ref 195* 308* 316 370* 512* 574* 584 586
                                                                                  588 612 646 662 664 664 683* 711 711 714 714 723
                                                                                  724 802 802 802 802 809 809 812 812 812 815 817
                                                                                  819 822
mpfmip                          000160 automatic       pointer                  dcl 7-4 set ref 196* 309* 319 323 371* 399 411 415
                                                                                  463 513* 575* 684*
mtape_$alloc                    000032 constant        entry                    external dcl 101 ref 124 131 1044
mtape_$error                    000034 constant        entry                    external dcl 102 ref 200 215 237 247 266 286 385 393
                                                                                  422 463 485 521 549 606 931 1006 1022 1032 1104
                                                                                  1158 1166 1178
mtape_$order                    000040 constant        entry                    external dcl 104 ref 235 245 264 284 384 519 547 556
                                                                                  741 759 768 782 964 997 1003 1020 1031 1156 1165
                                                                                  1177
mtape_$read_label               000042 constant        entry                    external dcl 105 ref 378
mtape_$user_query               000044 constant        entry                    external dcl 106 ref 739
mtape_$volume_switch            000036 constant        entry                    external dcl 103 ref 213 483 929
mtape_$write_label              000046 constant        entry                    external dcl 107 ref 1101
mtape_attach_info                      based           structure                level 1 dcl 6-8
mtape_data                             based           structure                level 1 dcl 1-8
mtape_err_stats                        based           structure                level 1 dcl 3-6
mtape_file_info                        based           structure                level 1 dcl 5-8 set ref 313 780 786
mtape_label_record                     based           structure                level 1 dcl 2-8 set ref 325 337 341 350 354 773 777
mtape_open_info                        based           structure                level 1 dcl 8-10
mtape_pfm_info                         based           structure                level 1 dcl 7-8
mtape_vol_set                          based           structure                level 1 dcl 4-9
mtdp                            000146 automatic       pointer                  dcl 1-4 set ref 123* 124* 131* 191* 194 195 196 200*
                                                                                  213* 215* 220 235* 237* 245* 247* 264* 266* 272*
                                                                                  283 284* 286* 306* 307 308 309 311 313 325 327 337
                                                                                  339 341 345 350 352 354 358 359 359 366* 369 370
                                                                                  371 377 378* 382 384* 385* 393* 407 422* 429 429*
                                                                                  432* 432 436* 436 439 457 463* 463 483* 485* 489
                                                                                  499 500 507* 509 510 511 512 513 517 519* 521*
                                                                                  535* 547* 549* 556* 570* 573 574 575 592 602* 606*
                                                                                  616 617 627 632 643* 668 679* 681 682 683 684 688*
                                                                                  721 739* 741* 748 749* 752 759* 765* 768* 773 775
                                                                                  777 780 781 781 781 782* 785 785 786 825 825 928
                                                                                  929* 931* 936 964* 975 976 986 997* 1003* 1006*
                                                                                  1012 1020* 1022* 1031* 1032* 1044* 1044 1045 1045
                                                                                  1046 1047 1051 1066 1082 1082* 1082 1091* 1091
                                                                                  1094* 1094 1100 1101* 1104* 1124 1126 1148 1153
                                                                                  1156* 1158* 1158 1165* 1166* 1177* 1178*
native_file              65            based           bit(1)                   level 3 dcl 5-8 set ref 726*
neofs                           000122 automatic       fixed bin(17,0)          dcl 67 set ref 527* 531* 533* 546 547*
new_section                            parameter       bit(1)                   dcl 61 ref 677 690
next_fi_ptr               4            based           pointer                  level 2 dcl 5-8 set ref 275 290 290 312 313 314* 595
                                                                                  612 625 646 786 787* 947 951
next_file               102            based           bit(1)                   level 3 dcl 8-10 ref 822
next_lab_ptr              4            based           pointer                  level 2 dcl 2-8 ref 325 325 337 337 350 350 472 773
                                                                                  773 1098
next_vs_ptr               4            based           pointer                  level 2 dcl 4-9 ref 482 1171
nfip                            000110 automatic       pointer                  dcl 66 set ref 941* 942 945 947 949* 951*
nlp                             000112 automatic       pointer                  dcl 66 set ref 528* 539* 756* 1090 1097 1098*
null                                                   builtin function         dcl 97 ref 126 131 131 235 235 245 245 264 264 284
                                                                                  284 290 312 314 317 325 330 330 335 337 341 343
                                                                                  348 350 354 373 384 384 402 404 428 440 519 519
                                                                                  547 547 556 556 593 621 658 686 702 741 741 759
                                                                                  759 768 768 771 773 777 779 781 782 782 787 825
                                                                                  947 964 964 997 997 1003 1003 1020 1020 1031 1031
                                                                                  1046 1063 1090 1121 1126 1137 1150 1156 1156 1165
                                                                                  1165 1171 1177 1177
number_of_vol_labels    106            based           fixed bin(17,0)          level 2 dcl 4-9 set ref 1030 1031*
nvp                             000106 automatic       pointer                  dcl 66 in procedure "pfm_utils_" set ref 482* 483*
nvp                                    parameter       pointer                  dcl 925 in procedure "CK_VOL_SWITCH" set ref 923 928
                                                                                  929* 931
open_info_ptr           276            based           pointer                  level 2 dcl 1-8 ref 195 308 370 512 574 683
per_file_info            25            based           structure                level 2 dcl 5-8 set ref 691* 691 1129* 1129
per_section_info        152            based           structure                level 2 dcl 5-8
pfm_arg_values                         based           structure                level 1 dcl 8-57
pfm_entries                            based           structure                level 1 dcl 1-103
pfm_info_ptr            304            based           pointer                  level 2 dcl 1-8 ref 196 309 371 513 575 684
pfm_options                            based           structure                level 1 dcl 7-21
pfm_required_entries    320            based           structure                level 2 dcl 1-8
phy_block               157            based           fixed bin(17,0)          level 3 dcl 1-8 ref 517 627 632
phy_file                153            based           fixed bin(17,0)          level 3 in structure "mtape_file_info" dcl 5-8
                                                                                  in procedure "pfm_utils_" set ref 220 283 439* 606
                                                                                  862* 871 880 888 896 904 912 1051* 1124* 1148
phy_file                156            based           fixed bin(17,0)          level 3 in structure "mtape_data" dcl 1-8
                                                                                  in procedure "pfm_utils_" set ref 220 283 439 463*
                                                                                  975 976 986 1051 1124 1148 1158*
pic4                            000135 automatic       picture(4)               packed unaligned dcl 70 set ref 717* 718
position                156            based           structure                level 2 dcl 1-8
position_within_file     24            based           fixed bin(17,0)          level 2 dcl 5-8 set ref 198 232 234 254* 256* 259
                                                                                  280 290* 294* 404* 481* 491* 493* 526* 534 557*
                                                                                  621 627 632 632 632 632 632 698* 864* 872* 881*
                                                                                  889* 897* 905* 914* 1050* 1150*
pp                              000114 automatic       pointer                  dcl 66 set ref 689* 691 692 695 696 697 698 702 707
                                                                                  708 709 1125* 1126 1126 1128 1129 1131 1132 1137
                                                                                  1141
prev_fi_ptr               2            based           pointer                  level 2 dcl 5-8 ref 357 404 404 440 444 447 689 748
                                                                                  779 785 825 945 1067 1125 1150 1150
prev_lab_ptr              2            based           pointer                  level 2 dcl 2-8 ref 329 340 353 776
prev_seq                        000127 automatic       fixed bin(17,0)          dcl 67 set ref 704* 709* 713
prev_vs_ptr               2            based           pointer                  level 2 dcl 4-9 set ref 750*
prevp                           000260 automatic       pointer                  dcl 1059 set ref 1063* 1063* 1064 1066* 1067
record_length            67            based           fixed bin(35,0)          level 3 dcl 8-10 ref 724
record_size              64            based           fixed bin(21,0)          level 3 dcl 5-8 set ref 724*
replace_id               56            based           char(32)                 level 2 dcl 8-10 ref 812 819
rfl_code                        000101 automatic       fixed bin(35,0)          dcl 65 set ref 372* 375 378* 379 380 384* 385 385*
                                                                                  388* 393* 421* 422* 429* 430 462* 463* 477 483*
                                                                                  484 485* 494* 495 1156* 1157 1157 1158* 1163 1165*
                                                                                  1166 1166* 1173* 1177* 1178 1178* 1181*
section                 152            based           fixed bin(17,0)          level 3 dcl 5-8 set ref 440 440* 442 692* 692 720*
                                                                                  747 1128* 1128 1136*
seq_number               73            based           fixed bin(35,0)          level 3 in structure "mtape_open_info" dcl 8-10
                                                                                  in procedure "pfm_utils_" ref 711 711 812 815
seq_number               53            based           fixed bin(17,0)          level 3 in structure "mtape_file_info" dcl 5-8
                                                                                  in procedure "pfm_utils_" set ref 606* 709 711*
                                                                                  713* 717 815 1138* 1141* 1141
space_files                     000123 automatic       fixed bin(17,0)          dcl 67 set ref 976* 983* 986* 987 987* 987 995 997*
                                                                                  999* 1003 1003* 1006*
substr                                                 builtin function         dcl 97 ref 177 319 323 399 411 415
target_file                            parameter       fixed bin(17,0)          dcl 973 in procedure "FILE_RIGHT_POSITION" ref 971
                                                                                  975 976 983 986
target_file                            parameter       fixed bin(17,0)          dcl 961 in procedure "FILE_LEFT_POSITION" set ref
                                                                                  959 963*
target_position                        parameter       fixed bin(17,0)          dcl 855 in procedure "POSITION_TO_FILE" ref 853 857
target_position                 000125 automatic       fixed bin(17,0)          dcl 67 in procedure "pfm_utils_" set ref 584* 586*
                                                                                  588* 590* 599* 601
temp                            000142 automatic       fixed bin(17,0)          dcl 145 set ref 157* 158 159* 160 161
term                            000130 automatic       bit(1)                   dcl 69 in procedure "pfm_utils_" set ref 310* 311
                                                                                  345* 940* 941 944* 948*
term                            000262 automatic       bit(1)                   dcl 1060 in procedure "LINK_VS_END" set ref 1062*
                                                                                  1063 1064*
term1                           000131 automatic       bit(1)                   dcl 69 set ref 310* 319 323*
term2                           000132 automatic       bit(1)                   dcl 69 set ref 310* 317 319*
tlb                     154            based           pointer                  level 2 dcl 1-8 set ref 377 457 1082* 1100
today                           000144 automatic       char(6)                  packed unaligned dcl 171 set ref 180* 181
translate                                              builtin function         dcl 97 ref 703
unlabeled_file           67            based           bit(1)                   level 3 dcl 5-8 set ref 727* 1142*
ver_ptr                         000104 automatic       pointer                  dcl 66 set ref 373* 408* 413* 418* 428 458* 461 463
                                                                                  472* 472
volume_check            105            based           fixed bin(17,0)          level 2 dcl 4-9 ref 578
volume_id                26            based           char(32)                 level 2 dcl 4-9 set ref 200* 215* 237* 247* 393*
                                                                                  422* 463* 606* 703 1022* 1032* 1104*
volume_name              16            based           char(32)                 level 2 dcl 4-9 set ref 931* 1158*
vs_current               24            based           pointer                  level 2 dcl 1-8 ref 489 499 509 681 721 928 936 1066
                                                                                  1126
vs_ptr                          000152 automatic       pointer                  dcl 4-5 set ref 192* 200 212* 213* 215 237 247 272*
                                                                                  298 368* 393 422 451 463 482 489* 509* 535* 572*
                                                                                  578 602* 606 643* 671 681* 703 750 753 936* 1022
                                                                                  1030 1031 1032 1104 1143 1158 1171
wfl_code                        000102 automatic       fixed bin(35,0)          dcl 65 set ref 514* 519* 520 521* 522* 535* 536 541*
                                                                                  542 543* 547* 548 549* 550* 556* 559 559* 563
yy                              000141 automatic       picture(2)               packed unaligned dcl 144 set ref 160* 161 163

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BLANK_VOLUME                           internal static fixed bin(17,0)          initial dcl 4-42
MTAPE_ALLOC_VS                         internal static fixed bin(17,0)          initial dcl 9-9
MTAPE_CV_BCD                           internal static fixed bin(17,0)          initial dcl 9-34
MTAPE_CV_EBCDIC                        internal static fixed bin(17,0)          initial dcl 9-34
MTAPE_CV_UC_EBCDIC                     internal static fixed bin(17,0)          initial dcl 9-34
MTAPE_HWM_BCD                          internal static fixed bin(17,0)          initial dcl 9-27
MTAPE_HWM_BIN                          internal static fixed bin(17,0)          initial dcl 9-27
MTAPE_NO_CONVERSION                    internal static fixed bin(17,0)          initial dcl 9-34
MTAPE_SPEED_VALUES                     internal static fixed bin(17,0)          initial array dcl 9-22
MTAPE_UNSPECIFIED                      internal static fixed bin(17,0)          initial dcl 9-34
MTAPE_VALID_DENSITIES                  internal static fixed bin(17,0)          initial array dcl 9-17
MTAPE_VOLUME                           internal static fixed bin(17,0)          initial dcl 4-42
MULT_PRIOR_VOLUME                      internal static fixed bin(17,0)          initial dcl 4-42
Q_INCORRECT_VOLUME                     internal static fixed bin(17,0)          initial dcl 9-63
Q_LABELED_VOLUME                       internal static fixed bin(17,0)          initial dcl 9-63
Q_NO_NEXT_VOLUME                       internal static fixed bin(17,0)          initial dcl 9-63
Q_UNEXPIRED_FILE                       internal static fixed bin(17,0)          initial dcl 9-63
Q_UNEXPIRED_VOLUME                     internal static fixed bin(17,0)          initial dcl 9-63
RECOG_FORMAT_VOLUME                    internal static fixed bin(17,0)          initial dcl 4-42
UNLABELED_VOLUME                       internal static fixed bin(17,0)          initial dcl 4-42
all_buf_lens                           based           fixed bin(21,0)          array dcl 1-114
all_buf_ptrs                           based           pointer                  array dcl 1-113
es_ptr                                 automatic       pointer                  dcl 3-4
mcip                                   automatic       pointer                  dcl 8-5
mtape_attach_info_version_1            internal static char(8)                  initial packed unaligned dcl 6-6
mtape_close_info                       based           structure                level 1 dcl 8-41
mtape_close_info_version_1             internal static char(8)                  initial packed unaligned dcl 8-8
mtape_data_version_1                   internal static char(8)                  initial packed unaligned dcl 1-6
mtape_fi_version_1                     internal static char(8)                  initial packed unaligned dcl 5-6
mtape_lr_version_1                     internal static char(8)                  initial packed unaligned dcl 2-6
mtape_open_info_version_1              internal static char(8)                  initial packed unaligned dcl 8-7
mtape_pfm_info_version_1               internal static char(8)                  initial packed unaligned dcl 7-6
mtape_vs_version_1                     internal static char(8)                  initial packed unaligned dcl 4-7
tape_blk                               based           char(1)                  array packed unaligned dcl 1-115

NAMES DECLARED BY EXPLICIT CONTEXT.
ABORT_FILE                      005377 constant        entry                    internal dcl 734 ref 522 543 550
CK_VOL_SWITCH                   006434 constant        entry                    internal dcl 923 ref 750 859 868 876 885 893 901 909
CREATE_FILE_LINK                007245 constant        entry                    internal dcl 1042 ref 402 686 1123
DECODE_UNLABELED_FILE           007611 constant        entry                    internal dcl 1119 ref 476
DESIRED_FILE                    006016 constant        entry                    internal dcl 798 ref 594 645
FILE_LEFT_POSITION              006564 constant        entry                    internal dcl 959 ref 871 888 904
FILE_POSITION                   000000 constant        label                    array(4) dcl 209 ref 207
FILE_RIGHT_POSITION             006635 constant        entry                    internal dcl 971 ref 862 880 896 912 963
FS_RETURN                       005135 constant        label                    dcl 668 ref 581 600 603 619 630 639 651 659
LINK_VS_END                     007315 constant        entry                    internal dcl 1057 ref 454 699 1146
NF_RETURN                       005112 constant        label                    dcl 656 ref 623
PIF_RETURN                      002545 constant        label                    dcl 296 ref 204 226 241 251 257 259 268 273 279 280
                                                                                  288
POSITION_TO_FILE                006141 constant        entry                    internal dcl 853 ref 599 618 629 638 650 662 664 754
                                                                                  766 789
PTF                             000004 constant        label                    array(10) dcl 859 ref 857
RECODE_LABELS                   007356 constant        label                    dcl 1079 ref 1087
REWIND_TO_BOF                   007050 constant        entry                    internal dcl 1018 ref 225 981
RFL_RETURN                      004021 constant        label                    dcl 495 ref 389 395 425 430 469 477 487
WFL_RETURN                      004423 constant        label                    dcl 559 ref 523 536 544 551
WRITE_LABEL_RECORDS             007350 constant        entry                    internal dcl 1072 ref 541 757
file_search                     004454 constant        entry                    external dcl 568
init_label_record               000772 constant        entry                    external dcl 121 ref 432 436 1091 1094
julian_date                     001111 constant        entry                    external dcl 139 ref 180
label_unexpired                 001370 constant        entry                    external dcl 168
pfm_utils_                      000755 constant        entry                    external dcl 44
position_in_file                001565 constant        entry                    external dcl 189 ref 535
read_file_labels                003067 constant        entry                    external dcl 364 ref 272 602 643
setup_file                      005164 constant        entry                    external dcl 677
truncate_file_set               002571 constant        entry                    external dcl 304 ref 688 749 765
write_file_labels               004053 constant        entry                    external dcl 505

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     11062       11140   10526       11072
Length     11610   10526        56         433     334           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
pfm_utils_                          820 external procedure  is an external procedure.  
ABORT_FILE                              internal procedure  shares stack frame of external procedure pfm_utils_.  
DESIRED_FILE                            internal procedure  shares stack frame of external procedure pfm_utils_.  
POSITION_TO_FILE                        internal procedure  shares stack frame of external procedure pfm_utils_.  
CK_VOL_SWITCH                           internal procedure  shares stack frame of external procedure pfm_utils_.  
FILE_LEFT_POSITION                      internal procedure  shares stack frame of external procedure pfm_utils_.  
FILE_RIGHT_POSITION                     internal procedure  shares stack frame of external procedure pfm_utils_.  
REWIND_TO_BOF                           internal procedure  shares stack frame of external procedure pfm_utils_.  
CREATE_FILE_LINK                        internal procedure  shares stack frame of external procedure pfm_utils_.  
LINK_VS_END                             internal procedure  shares stack frame of external procedure pfm_utils_.  
WRITE_LABEL_RECORDS                     internal procedure  shares stack frame of external procedure pfm_utils_.  
DECODE_UNLABELED_FILE                   internal procedure  shares stack frame of external procedure pfm_utils_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
pfm_utils_               000100 code                        pfm_utils_
                         000101 rfl_code                    pfm_utils_
                         000102 wfl_code                    pfm_utils_
                         000104 ver_ptr                     pfm_utils_
                         000106 nvp                         pfm_utils_
                         000110 nfip                        pfm_utils_
                         000112 nlp                         pfm_utils_
                         000114 pp                          pfm_utils_
                         000116 ltype                       pfm_utils_
                         000117 lab_num                     pfm_utils_
                         000120 bks_file_cnt                pfm_utils_
                         000121 fwd_file_cnt                pfm_utils_
                         000122 neofs                       pfm_utils_
                         000123 space_files                 pfm_utils_
                         000124 htype                       pfm_utils_
                         000125 target_position             pfm_utils_
                         000126 convert                     pfm_utils_
                         000127 prev_seq                    pfm_utils_
                         000130 term                        pfm_utils_
                         000131 term1                       pfm_utils_
                         000132 term2                       pfm_utils_
                         000133 found                       pfm_utils_
                         000134 forward                     pfm_utils_
                         000135 pic4                        pfm_utils_
                         000136 clock_value                 pfm_utils_
                         000140 ddd                         pfm_utils_
                         000141 yy                          pfm_utils_
                         000142 temp                        pfm_utils_
                         000144 today                       pfm_utils_
                         000146 mtdp                        pfm_utils_
                         000150 lr_ptr                      pfm_utils_
                         000152 vs_ptr                      pfm_utils_
                         000154 fi_ptr                      pfm_utils_
                         000156 maip                        pfm_utils_
                         000160 mpfmip                      pfm_utils_
                         000162 moip                        pfm_utils_
                         000260 prevp                       LINK_VS_END
                         000262 term                        LINK_VS_END
                         000272 code                        WRITE_LABEL_RECORDS

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             call_ent_var        call_ext_in_desc    call_ext_in         call_ext_out_desc
call_ext_out        return_mac          mdfx1               signal_op           ext_entry           ext_entry_desc
any_to_any_truncate_op_freen_           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
convert_date_to_binary_       datebin_                      datebin_$dayr_clk             mtape_$alloc
mtape_$error                  mtape_$order                  mtape_$read_label             mtape_$user_query
mtape_$volume_switch          mtape_$write_label

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$end_of_info      error_table_$eov_on_write     error_table_$file_aborted
error_table_$invalid_file_set_format                        error_table_$invalid_label_format
error_table_$lost_device_position                           error_table_$no_file          error_table_$no_next_volume
error_table_$uninitialized_volume




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     44 000754       121 000764       123 001001       124 001005       125 001024       126 001027       128 001034
    129 001036       130 001040       131 001042       132 001063       133 001071       134 001073       139 001105
    154 001126       155 001130       157 001161       158 001172       159 001202       160 001243       161 001257
    163 001323       168 001364       175 001404       177 001436       180 001466       181 001502       183 001535
    189 001560       191 001577       192 001603       193 001606       194 001611       195 001613       196 001615
    197 001617       198 001620       199 001623       200 001626       204 001670       206 001671       207 001672
    209 001674       211 001700       212 001702       213 001704       214 001717       215 001721       218 001756
    220 001770       223 001776       225 002001       226 002002       228 002004       229 002005       230 002006
    231 002010       232 002012       234 002021       235 002024       236 002060       237 002062       241 002136
    244 002137       245 002141       246 002175       247 002177       251 002253       254 002254       256 002263
    257 002266       259 002267       262 002271       263 002273       264 002277       265 002335       266 002337
    268 002370       270 002371       271 002373       272 002377       273 002415       275 002417       277 002425
    278 002426       279 002427       280 002430       283 002432       284 002436       285 002472       286 002474
    288 002525       290 002526       294 002543       296 002545       298 002547       299 002552       300 002554
    304 002566       306 002600       307 002604       308 002606       309 002610       310 002612       311 002615
    312 002622       313 002627       314 002631       316 002634       317 002637       319 002650       323 002666
    325 002674       327 002702       329 002710       330 002714       332 002725       333 002730       335 002731
    337 002740       339 002747       340 002755       341 002761       343 002770       345 002774       348 003004
    350 003012       352 003021       353 003027       354 003033       357 003042       358 003046       359 003052
    360 003053       364 003065       366 003103       367 003107       368 003112       369 003115       370 003117
    371 003121       372 003123       373 003125       375 003127       377 003140       378 003143       379 003155
    380 003157       382 003165       383 003170       384 003172       385 003227       388 003255       389 003260
    391 003261       393 003262       395 003312       397 003313       399 003314       401 003330       402 003332
    404 003337       407 003347       408 003351       409 003353       411 003354       412 003356       413 003360
    414 003363       415 003364       417 003366       418 003370       419 003373       421 003374       422 003377
    425 003436       428 003437       429 003443       430 003462       432 003464       436 003510       438 003530
    439 003533       440 003537       442 003550       443 003553       444 003555       447 003560       449 003563
    451 003564       452 003566       454 003567       457 003570       458 003602       459 003603       461 003604
    462 003615       463 003620       469 003716       472 003717       474 003722       476 003725       477 003726
    480 003730       481 003733       482 003736       483 003741       484 003754       485 003756       487 004002
    489 004003       490 004006       491 004007       493 004015       494 004020       495 004021       497 004023
    498 004025       499 004030       500 004033       501 004035       505 004047       507 004067       508 004073
    509 004075       510 004077       511 004101       512 004103       513 004105       514 004107       516 004111
    517 004113       518 004116       519 004121       520 004157       521 004161       522 004205       523 004207
    526 004210       527 004213       528 004215       529 004217       531 004220       533 004225       534 004227
    535 004233       536 004251       539 004253       541 004256       542 004260       543 004262       544 004264
    546 004265       547 004267       548 004323       549 004325       550 004351       551 004353       554 004354
    555 004357       556 004362       557 004420       559 004423       563 004433       564 004435       568 004447
    570 004466       571 004472       572 004475       573 004500       574 004502       575 004504       576 004506
    578 004510       580 004517       581 004522       584 004523       586 004531       588 004536       590 004543
    591 004545       592 004546       593 004551       594 004561       595 004564       597 004572       598 004573
    599 004576       600 004600       601 004602       602 004605       603 004623       604 004625       605 004630
    606 004633       612 004711       614 004717       616 004720       617 004723       618 004730       619 004732
    621 004734       623 004744       625 004746       626 004750       627 004751       629 004761       630 004763
    631 004765       632 004766       638 005003       639 005005       641 005007       643 005017       644 005035
    645 005042       646 005044       649 005076       650 005103       651 005105       654 005107       655 005110
    656 005112       658 005115       659 005117       661 005120       662 005121       664 005127       668 005135
    670 005140       671 005142       672 005144       673 005146       677 005160       679 005173       680 005177
    681 005202       682 005204       683 005206       684 005210       686 005212       688 005220       689 005226
    690 005231       691 005235       692 005241       693 005244       694 005246       695 005247       696 005250
    697 005252       698 005254       699 005256       700 005257       702 005260       703 005264       704 005272
    705 005273       707 005274       708 005300       709 005301       711 005303       713 005310       714 005313
    717 005323       718 005332       720 005340       721 005342       722 005346       723 005347       724 005351
    725 005353       726 005355       727 005356       729 005362       730 005365       734 005377       738 005401
    739 005404       740 005416       741 005420       742 005456       747 005457       748 005463       749 005466
    750 005474       751 005507       752 005512       753 005515       754 005517       755 005521       756 005524
    757 005527       758 005531       759 005534       760 005572       762 005600       765 005601       766 005607
    767 005611       768 005614       769 005652       770 005655       771 005661       773 005670       775 005677
    776 005705       777 005711       779 005720       780 005725       781 005727       782 005736       783 005773
    785 005774       786 006002       787 006005       788 006010       789 006013       793 006015       798 006016
    802 006020       809 006037       812 006052       815 006064       817 006072       819 006101       821 006110
    822 006111       823 006113       825 006121       829 006136       853 006141       857 006143       859 006145
    861 006160       862 006163       864 006172       866 006177       868 006200       870 006213       871 006216
    872 006224       874 006231       876 006232       879 006245       880 006250       881 006256       883 006263
    885 006264       887 006277       888 006302       889 006310       891 006315       893 006316       895 006331
    896 006334       897 006342       899 006347       901 006350       903 006363       904 006366       905 006374
    907 006401       909 006402       911 006415       912 006420       914 006426       918 006433       923 006434
    928 006436       929 006443       930 006457       931 006461       934 006514       936 006515       937 006520
    940 006530       941 006531       942 006536       944 006544       945 006546       946 006550       947 006551
    948 006555       949 006557       951 006560       955 006563       959 006564       963 006566       964 006574
    967 006634       971 006635       975 006637       976 006643       977 006645       978 006647       980 006650
    981 006653       982 006654       983 006657       984 006662       986 006663       987 006666       992 006670
    995 006671       996 006673       997 006676       998 006732       999 006734      1000 006736      1003 006740
   1005 007000      1006 007002      1009 007043      1012 007044      1014 007047      1018 007050      1020 007051
   1021 007106      1022 007110      1025 007145      1030 007146      1031 007151      1032 007205      1038 007244
   1042 007245      1044 007246      1045 007267      1046 007274      1047 007301      1048 007303      1050 007306
   1051 007311      1053 007314      1057 007315      1062 007316      1063 007317      1064 007330      1066 007341
   1067 007344      1069 007347      1072 007350      1077 007352      1078 007353      1079 007356      1081 007357
   1082 007366      1083 007410      1086 007421      1087 007423      1089 007424      1090 007426      1091 007432
   1094 007457      1096 007477      1097 007500      1098 007502      1099 007505      1100 007510      1101 007521
   1102 007534      1104 007541      1107 007601      1108 007604      1110 007605      1112 007606      1115 007610
   1119 007611      1121 007612      1122 007616      1123 007620      1124 007621      1125 007625      1126 007627
   1128 007637      1129 007642      1130 007645      1131 007647      1132 007651      1134 007654      1136 007655
   1137 007657      1138 007663      1139 007665      1140 007667      1141 007670      1142 007673      1143 007675
   1144 007677      1146 007701      1147 007702      1148 007703      1149 007710      1150 007712      1153 007721
   1154 007722      1156 007723      1157 007761      1158 007766      1161 010031      1163 010032      1164 010034
   1165 010036      1166 010074      1169 010122      1171 010123      1172 010130      1173 010132      1174 010133
   1176 010134      1177 010137      1178 010175      1181 010223      1186 010226


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
