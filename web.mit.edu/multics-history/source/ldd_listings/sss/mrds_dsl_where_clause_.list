	COMPILATION LISTING OF SEGMENT mrds_dsl_where_clause_
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/01/88  1334.1 mst Mon
	    Options: optimize map

        1 /****^  ********************************************
        2*        *                                          *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988 *
        4*        *                                          *
        5*        ******************************************** */
        6 
        7 
        8 
        9 /****^  HISTORY COMMENTS:
       10*  1) change(87-01-22,Hergert), approve(88-07-11,MCR7903),
       11*     audit(88-07-08,Dupuis), install(88-08-01,MR12.2-1073):
       12*     Written.
       13*                                                   END HISTORY COMMENTS */
       14 
       15 
       16 mrds_dsl_where_clause_:
       17     proc ();
       18 
       19 /* NOTES:
       20*
       21*   This  procedure  translates  the  -where  clause  within  a  DSL  selection
       22*   expression  into  a  tabular form which cam be efficiently processed by the
       23*   data base search procedures.
       24*
       25*
       26*   INPUT CONDITIONS:
       27*
       28*   dbcb_ptr points to a valid DBCB which contains the -range clause tables and
       29*   the -select clause tables for the current selection expression.
       30*
       31*   se_ptr points to the beginning of the selection expression.
       32*
       33*   se_len is the number of characters in the selection expression.
       34*
       35*   start_pos  is  the  index of the character immediately following the -where
       36*   keyword.
       37*
       38*   argp_ptr points to the next in a list of argument pointers for values to be
       39*   pluffed into the selection expression.
       40*
       41*   descp_ptr  points  to  the  next  in  the  list of corresponding descriptor
       42*   pointers.
       43*
       44*   num_args is the number of unused values.
       45*
       46*   OUTPUT DEFINITIONS:
       47*
       48*   output_pred_ptr - - (output) ptr, to root of predicate tree
       49*
       50*
       51*   start_pos, argp_ptr, descp_ptr, and num_args are undefined.
       52*
       53*   code = 0;  if there are no errors.
       54*
       55*   code = mrds_error_$where_syntax; if a syntax error occurs within the -where
       56*   clause.
       57*
       58*   code  =  mrds_error_$unbal_parens;  if the number of right parentheses does
       59*   not match the number of left parentheses.
       60*
       61*   code = mrds_error_$op_stack_ovfl;  if the operator stack has overflowed.
       62*
       63*   code = mrds_error_$node_stack_ovfl;  if the node stack has overflowed.
       64*
       65*   code  =  mrds_error_$undef_quant;  if  a  tuple variable is neither free no
       66*   quantified.
       67*
       68*   code =  mrds_error_$empty where;  if nothing followed the -where keyword.
       69*
       70*   code  =  mrds_error_$not_leaf;  if  a  "not"  operation  is specified for a
       71*   constant or a tuple attribute.
       72*
       73*   code  =  mrds_error_$bool_leaf;  if an "and" of "or" operation is specified
       74*   for a constant of tuple attribute.
       75*
       76*   code  =  mrds_error_$rel_node;  if a relational operator has been specified
       77*   for a term or group of terms.
       78*
       79*   code   =   mrds_error_$quant_stack_ovfl;   if   the  quantifier  stack  has
       80*   overflowed.
       81*
       82*   code = mrds_error_$mult_quant; if a quantification has been specified for a
       83*   tuple  variable  within  the  scope of another quantification for that same
       84*   variable.
       85*
       86*   code   =   mrds_error_$quant_free_conflict;   if  quantification  has  been
       87*   specified for a typle variable which also appears in the select list.
       88*
       89*   code  =  mrds_error_$ill_constant_occur;  if  a  literal  constant has been
       90*   designated for comparison to a term or group of terms.
       91*
       92*   code  = mrds_error_$inv_literal_type; if a literal value is not a string or
       93*   arithmetic data type.
       94*
       95*   code = mrds_error_$lit_string_ovfl;  if the literal area has overflowed.
       96*
       97*   code = something else;  if another error is detected by a subroutine.
       98*
       99*   HISTORY:
      100*
      101*   76-02-01 J. A. Weeldreyer : Initially written.
      102*
      103*   76-11-01 J. A. Weeldreyer: Modified to incorporate inverted attributes.
      104*
      105*   77-04-01 J. A. Weeldreyer: Modified to catch undetected illegal terms.
      106*
      107*   77-04-02  J.  A.  Weeldreyer: Modified to handle expressions, and to remove
      108*   explicit quantification.
      109*
      110*   77-11-01  J.   A.   Weeldreyer:  Modified  to  eliminate  concept  of bound
      111*   variables.
      112*
      113*   78-01-01  J.   A.   Weeldreyer:  Modified  to zero pad bits when allocating
      114*   literals.
      115*
      116*   78-02-01  J.   A.   Weeldreyer: Modified to properly handle exprs.  without
      117*   variables.
      118*
      119*   78-07-01 J. A. Weeldreyer: Modified to fix error in cleanup handler.
      120*
      121*   79-02-01 J. A. Weeldreyer for MR7.0.
      122*
      123*   79-06-01 Al Kepner: Modified to use select_area.
      124*
      125*   79-08-28  NSDavids:  Modified  to  skip evaluation of the expression if the
      126*   pointer  to  the  expreession  structure  is  null (hopefully that means we
      127*   already have the expression value.) Exactly how all the modules communicate
      128*   i don't know - i doubt if god does !
      129*
      130*   79-11-01  Jim  Gray  : Modified to make comparisons of attrs from different
      131*   domains  a  warning  error  message,  instead  of  a fatal error.  However,
      132*   comparison  of  different  data types is still a fatal error(see comment in
      133*   code).
      134*
      135*   80-02-01  Jim  Gray  :  Modified  to  add  area_ptr parameter, passed on to
      136*   mrds_dsl_eval_expr.
      137*
      138*   80-09-24  Davids: added to the code that processes ATTR type tokens a check
      139*   to  be  sure the user has r_perm on the attribute.  if he/she does not then
      140*   processing  can  stop  with  an  incorrect  access error.  Also removed the
      141*   include files mrds_expressions and mdbm_arg_list which were not used.  this
      142*   will  improved  performance  slightly  since variables were initialized but
      143*   never  referenced.   also removed a couple of declared but never referenced
      144*   variables  that  were  not  in  include  files.
      145*
      146*   80-11-05  Jim Gray : Modified to "and" the mdbm_secured bit with the r_perm
      147*   bit in rm_attr_info so that secure_mrds_db turns this check on.
      148*
      149*   81-05-06  Rickie  E.   Brinegar:  Modified  to  make  use  of  the  changed
      150*   rm_domain_info structure.
      151*
      152*   81-05-19  Jim  Gray  :  changed comparing of different domain data types to
      153*   non-fatal  error,  leaving  in  the  sub_err_ message, for test purposes in
      154*   working  on  the  domain_compare  proposal,  that will allow any two domain
      155*   types to be used in where clause comparisons.
      156*
      157*
      158*   81-05-20  Jim  Gray  :  changed  where clause domain comparison error to be
      159*   controlable by a mrds debug switch bit 1 for this routine.
      160*
      161*   81-05-20  Rickie  E.   Brinegar: Added to the code to reset the encode proc
      162*   switch in the li structure for each attribute.
      163*
      164*   81-06-23 Jim Gray : changed where clause to not call optimize,
      165*   but to return pred tree root pointer instead. translate now calls optimize
      166*   whether there is a where clause or not.
      167*
      168*   81-09-21 Davids: modified an if statement so that the index value
      169*   was  checked  before  the  index  was used as a subscript into an
      170*   array. This prevents a subscriptrange condition.
      171*
      172*   83-02-28 Moberg: made comparsions of different domains illegal if one of
      173*   the domains has an encode proc.  This is because the compare code has no
      174*   idea of how to deal with this case.  When compare is fixed, this check
      175*   should be removed, but until then this is better than giving the wrong
      176*   answer.
      177*
      178*   83-04-04 Davids increased the length of difference_mesg from 10 to 11
      179*   to accommodate "encode proc" and prevent a stringsize condition from
      180*   occuring. deleted declarations to so_ptr and descr_overly which were
      181*   never referenced
      182*
      183*   84-09-13 Hergert: added check for -compiled keyword and code to handle
      184*   new substituion argmunet .X. Basically a call to mrds_dsl_make_literal$alloc
      185*   instead of mrds_dsl_make_literal, because we dont have a value for .x.
      186*   at this time.
      187*
      188*   84-11-01 Hergert: added call to mu_print_error for reporting errors.
      189*
      190*   85-08-22 Hergert Turned off error printing when in domain procs.
      191**/
      192 
      193 build_attribute:
      194     entry (psi_ptr,dbcb_ptr, a_select_area_ptr, rel_index, ai_ptr, code);
      195 						/* tuple attribute */
      196 
      197 dcl     rel_index		 fixed bin;		/* relation index */
      198 dcl     ai_ptr		 ptr;			/* attribute_info ptr */
      199 
      200         if parser_static_info.ns_ptr = null then do;
      201 	   allocate ns in (parser_work_area);
      202 	   top_node = 0;
      203         end;
      204 
      205         code = 0;
      206         select_area_ptr = a_select_area_ptr;
      207         if top_node >= mrds_data_$max_pred_nodes
      208         then					/* if node stack overflow */
      209 	   call error (mrds_error_$node_stack_ovfl, LOUD, 0, WC_TYPE,
      210 	        "Too many items have been specified in the where clause.");
      211 
      212         else do;					/* if still room,  build tuple attr. leaf */
      213 
      214 	  allocate pred_leaf in (select_area);		/* make a place for it */
      215 						/* Allocations in select_area are never freed.
      216*						   This area is reinitialized
      217*						   at the beginning of each new selection expression. */
      218 	  rai_ptr = ai_ptr;				/* for rm_attr_info */
      219 	  if rm_attr_info.mdbm_secured & ^(rm_attr_info.read_perm)
      220 						/* if you don't have read access to an attribute */
      221 	  then call error (mrds_error_$inc_attr_acc, LOUD, 0, AV_TYPE,
      222 		  "You must have read permission on this attribute to use it as a qualifier."
      223 		  );
      224 						/* it shouldn't be in the where clause */
      225 
      226 	  pred_leaf.id.var_id = "0"b || bit (rel_index);
      227 						/* fill in data */
      228 	  pred_leaf.id.attr_id = "0"b || bit (rm_attr_info.defn_order);
      229 	  pred_leaf.type = LEAF;
      230 	  pred_leaf.ai_ptr = ai_ptr;
      231 	  pred_leaf.lit_offset,
      232 	       pred_leaf.lit_length = 0;
      233 	  pred_leaf.dummy,
      234 	       pred_leaf.rslt_desc = "0"b;
      235 	  pred_leaf.lit_desc_ptr,
      236 	       pred_leaf.lit_ptr,
      237 	       pred_leaf.expr_ptr,
      238 	       pred_leaf.parent = null;
      239 
      240 	  pred_leaf.data_type = ATTR;
      241 
      242 	  top_node = top_node + 1;			/* increment node counter */
      243 	  node_stack (top_node) = pl_ptr;		/* add leaf to node stack */
      244         end;					/* if room in stack */
      245 
      246         return;
      247 
      248 build_expr:
      249     entry (psi_ptr,efd_ptr, a_select_area_ptr, code);
      250 
      251         if parser_static_info.ns_ptr = null then do;
      252 	   allocate ns in (parser_work_area);
      253 	   top_node = 0;
      254         end;
      255 
      256         code = 0;
      257         select_area_ptr = a_select_area_ptr;
      258         if top_node >= mrds_data_$max_pred_nodes
      259         then					/* if node stack overflow */
      260 	   call error (mrds_error_$node_stack_ovfl, LOUD, 0, WC_TYPE,
      261 	        "Too many items have been specified in the where clause.");
      262 
      263 
      264         allocate pred_leaf in (select_area);		/* Allocations in select_area are never freed.
      265*						   This area is reinitialized
      266*						   at the beginning of each new selection expression. */
      267         pred_leaf.id.var_id = "0"b || bit (exp_fun_data.var_index);
      268 						/* fill in the pred_leaf */
      269         pred_leaf.type = LEAF;
      270         pred_leaf.data_type = EXPRES;
      271         pred_leaf.dummy,
      272 	   pred_leaf.id.attr_id = "0"b;
      273         pred_leaf.lit_offset = exp_fun_data.loc_index;
      274         pred_leaf.lit_length = exp_fun_data.bit_length;
      275         pred_leaf.rslt_desc = exp_fun_data.descriptor;
      276         pred_leaf.lit_ptr = exp_fun_data.assn_ptr;
      277         pred_leaf.lit_desc_ptr = addr (pred_leaf.rslt_desc);
      278         pred_leaf.expr_ptr = exp_fun_data.ef_ptr;
      279         pred_leaf.ai_ptr,
      280 	   pred_leaf.parent = null;
      281 
      282         top_node = top_node + 1;
      283         node_stack (top_node) = pl_ptr;			/* add to stack */
      284 
      285 
      286         return;
      287 
      288 finish:
      289     entry (psi_ptr,output_pred_ptr);
      290 
      291         node_stack (top_node) -> pred_node.root = "1"b;	/* set root flag in top node */
      292         output_pred_ptr = node_stack (top_node);
      293         top_node = 0;
      294 
      295         return;
      296 
      297 build_node:
      298     entry (psi_ptr,dbcb_ptr, a_select_area_ptr, operator_id, logical_node, not_node,
      299          code);
      300 
      301 /* Build a node from the top one or two items in the node stack,
      302*   Pop them from the stack and replace them with it. */
      303 
      304 dcl     operator_id		 fixed bin;
      305 dcl     logical_node	 bit (1) aligned;
      306 dcl     not_node		 bit (1) aligned;
      307 
      308         code = 0;
      309         select_area_ptr = a_select_area_ptr;
      310 
      311         allocate pred_node in (select_area);		/* make place for new node */
      312 
      313         pred_node.parent = null;
      314         pred_node.type = NODE;
      315         pred_node.id.op_code = op_array (operator_id);
      316         pred_node.determined, pred_node.root = "0"b;
      317 
      318         if logical_node then do;			/* if node is logical operator & | ^ */
      319 
      320 	  string (pred_node.id.lleaf_id),
      321 	       string (pred_node.id.rleaf_id),
      322 	       pred_node.term = "0"b;
      323 	  pred_node.term_type = 0;
      324 
      325 	  if not_node then do;
      326 
      327 	      pred_node.rbr = null;			/* if only one branch, the right will be null */
      328 	      pred_node.lbr = node_stack (top_node);	/* existing node placed under new one */
      329 
      330 	      node_stack (top_node) -> pred_node.parent = pn_ptr;
      331 						/* fill in parent pointer for child */
      332 
      333 	  end;					/* if not_node */
      334 
      335 	  else do;				/* node will have two branches & or | */
      336 
      337 	      pred_node.lbr = node_stack (top_node - 1);
      338 	      pred_node.rbr = node_stack (top_node);
      339 
      340 	      node_stack (top_node) -> pred_node.parent,	/* let the bastards know who their father is */
      341 		 node_stack (top_node - 1) -> pred_node.parent = pn_ptr;
      342 
      343 	      top_node = top_node - 1;		/* replace top 2 nodes with new one */
      344 
      345 	  end;					/* else & or | */
      346         end;					/* if logical_node */
      347 
      348         else do;					/* if not logical, must be relational = < > ...  */
      349 
      350 	  pred_node.term = "1"b;
      351 
      352 	  pred_node.lbr = node_stack (top_node - 1);
      353 	  pred_node.rbr = node_stack (top_node);
      354 
      355 	  pred_node.id.lleaf_id = pred_node.lbr -> pred_leaf.id;
      356 	  pred_node.id.rleaf_id = pred_node.rbr -> pred_leaf.id;
      357 
      358 	  pred_node.term_type =
      359 	       term_type_array (node_stack (top_node - 1)
      360 	       -> pred_leaf.data_type,
      361 	       node_stack (top_node) -> pred_leaf.data_type);
      362 
      363 	  if pred_node.term_type = 0
      364 	  then					/* cant have a constant as first leaf for some odd reason */
      365 	       call error (mrds_error_$ill_term, LOUD, 2, WC_TYPE,
      366 		  "A constant is not allowed as the first item in a qualifier."
      367 		  );
      368 
      369 	  if pred_node.lbr -> pred_leaf.data_type = ATTR
      370 	       & pred_node.rbr -> pred_leaf.data_type = ATTR
      371 	  then					/* if both leaves are attrs */
      372 
      373 	       if substr (db_mrds_dsl_where_clause, 1, 1)
      374 						/* debug bit 1 on => give details of cross domain compare */
      375 						/* cannot do cross domain compares when encode procs are involved */
      376 		  | pred_node.rbr -> pred_leaf.ai_ptr ->
      377 		  rm_attr_info.domain_ptr -> rm_domain_info.encd_proc
      378 		  | pred_node.lbr -> pred_leaf.ai_ptr ->
      379 		  rm_attr_info.domain_ptr -> rm_domain_info.encd_proc
      380 	       then do;
      381 
      382 /*  check for a comparison of non-comparable domains, a possible
      383*   semantic oversight(e.g.  age char(6) shouldn't be compared to
      384*   employee_num char(6) ) or an invalid use of comparisons, since
      385*   comparing of different data types can not be allowed in general, due
      386*   to the "non-conversion of keys" prior to compares.  (e.g.  a fixed
      387*   dec(4) compared to a char(6) in a vfile_ key will not work) this is
      388*   due to the use of select/exclude in the new architecture note: it
      389*   would be possible to allow comparing of differing data types, if the
      390*   types were not keys or secondary indexes or involved in a link.  this
      391*   is because the vanilla attributes left would not(in the new
      392*   architecture) be involved in any use of vfile_ keys, and thus not use
      393*   key comparisons, instead mu_comapre_values would be invoked, which
      394*   does conversions prior to comparing values.  it still
      395*   limits(currently) the comparisons to 1) real to real, 2) complex to
      396*   complex, 3) bit to bit, and 4) char to char data types, but at least
      397*   a fixed bin (17) unal could be compared to a fixed dec(5) However
      398*   allowing these comparisons would essentially be encouraging an
      399*   inappropriate use of a relational interface, and been decided
      400*   against.
      401**/
      402 
      403 		 if pred_node.rbr -> pred_leaf.ai_ptr ->
      404 		      rm_attr_info.domain_ptr -> rm_domain_info.name ^=
      405 		      pred_node.lbr -> pred_leaf.ai_ptr ->
      406 		      rm_attr_info.domain_ptr -> rm_domain_info.name
      407 		 then do;
      408 
      409 /* domains are different, check for different data types */
      410 
      411 		     if pred_node.rbr -> pred_leaf.ai_ptr
      412 			-> rm_attr_info.domain_ptr ->
      413 			rm_domain_info.encd_proc
      414 			| pred_node.lbr -> pred_leaf.ai_ptr
      415 			-> rm_attr_info.domain_ptr ->
      416 			rm_domain_info.encd_proc then do;
      417 		         fatal_flag = "1"b;
      418 		         difference_mesg = "encode proc";
      419 		         reason_mesg =
      420 			    """, comparing of different encode procs is not allowed."
      421 			    ;
      422 		     end;
      423 		     else if pred_node.rbr -> pred_leaf.ai_ptr
      424 			     -> rm_attr_info.domain_ptr ->
      425 			     rm_domain_info.db_desc ^=
      426 			     pred_node.lbr -> pred_leaf.ai_ptr
      427 			     -> rm_attr_info.domain_ptr ->
      428 			     rm_domain_info.db_desc then do;
      429 			    fatal_flag = "1"b;
      430 			    difference_mesg = "data type";
      431 			    reason_mesg =
      432 			         """, comparing of different data types is not allowed."
      433 			         ;
      434 			end;
      435 			else do;
      436 			    fatal_flag = "0"b;
      437 			    difference_mesg = "domain";
      438 			    reason_mesg =
      439 			         """, this may be an invalid comparison of semantically different domains."
      440 			         ;
      441 			end;
      442 
      443 /* issue the warning or error */
      444 
      445 		     call sub_err_ (mrds_error_$diff_comp_domain,
      446 			caller_name,
      447 			continue, info_ptr, return_value,
      448 			"^/^a^a^a ^a ^a^a^a^/",
      449 			"The attribute """,
      450 			pred_node.rbr -> pred_leaf.ai_ptr
      451 			-> rm_attr_info.name,
      452 			""" does not have the same", difference_mesg,
      453 			"as the attribute """,
      454 			pred_node.lbr -> pred_leaf.ai_ptr
      455 			-> rm_attr_info.name,
      456 			reason_mesg);
      457 
      458 
      459 		     if fatal_flag
      460 		     then
      461 			call error (mrds_error_$diff_comp_domain,
      462 			     ^LOUD, 0, "", "");
      463 
      464 		 end;
      465 
      466 	       end;
      467 
      468 
      469 	  node_stack (top_node) -> pred_leaf.parent,
      470 	       node_stack (top_node - 1) -> pred_leaf.parent = pn_ptr;
      471 						/* set parent ptrs in leaves */
      472 
      473 	  top_node = top_node - 1;			/* replace top two nodes with new node */
      474 
      475         end;					/* if relat. op. */
      476 
      477         node_stack (top_node) = pn_ptr;
      478 
      479         return;					/* build_node */
      480 
      481 build_literal:
      482     entry (psi_ptr,dbcb_ptr, a_select_area_ptr, a_ptr, d_ptr, x_pred_leaf_ptr,
      483          dot_x_dot, code);
      484 
      485 /* Build a pred leaf for any literal we have found. These are .V., .X.,
      486*   and any actual literal constant found in the where clause */
      487 
      488 
      489 dcl     (
      490         a_ptr,					/* Input -- pointer to literal value */
      491         d_ptr
      492         )			 ptr;			/* Input -- pointer to literal descriptor */
      493 dcl     dot_x_dot		 bit (1) aligned;		/* literal is a .X. */
      494 
      495         if parser_static_info.ns_ptr = null then do;
      496 	   allocate ns in (parser_work_area);
      497 	   top_node = 0;
      498         end;
      499 
      500         code = 0;
      501         select_area_ptr = a_select_area_ptr;
      502         if top_node >= mrds_data_$max_pred_nodes		/* if about to overflow the node stack */
      503         then call error (mrds_error_$node_stack_ovfl, LOUD, 0, WC_TYPE,
      504 	        "Too many items have been specified in the where clause.");
      505 
      506         if top_node < 1
      507         then call error (mrds_error_$ill_term, LOUD, 0, WC_TYPE, "");
      508 						/* if no prev leaf */
      509 
      510         allocate pred_leaf in (select_area);		/* make place for leaf */
      511 						/* Allocations in select_area are never freed.
      512*						   This area is reinitialized
      513*						   at the beginning of each new selection expression. */
      514 
      515         pred_leaf.expr_ptr,
      516 	   pred_leaf.ai_ptr,
      517 	   pred_leaf.parent = null;			/* fill it in */
      518         pred_leaf.type = LEAF;
      519         pred_leaf.data_type = CONST;
      520         pred_leaf.dummy,
      521 	   pred_leaf.rslt_desc,
      522 	   pred_leaf.id.var_id = "0"b;
      523 
      524         go to set_li (node_stack (top_node) -> pred_leaf.data_type);
      525 set_li (1):					/* constant */
      526         call error (mrds_error_$ill_term, LOUD, 0, WC_TYPE,
      527 	   "Two constants cannot be compared.");	/* cant compare two constants */
      528 
      529 set_li (2):					/* db. attr. */
      530         rai_ptr = node_stack (top_node) -> pred_leaf.ai_ptr;/* pick up attr info ptr */
      531         rdi_ptr = rm_attr_info.domain_ptr;
      532 
      533         if rm_domain_info.encd_proc then do;
      534 	  li.encd_entry = rm_domain_info.encd_proc_entry;
      535 	  li.encd_proc = "1"b;
      536         end;
      537         else li.encd_proc = "0"b;
      538 
      539         li.encdd_ptr = addr (rm_domain_info.user_desc);
      540         li.litd_ptr = addr (rm_domain_info.db_desc);
      541         li.encd_blen = rm_domain_info.user_bit_len;
      542         li.lit_blen = rm_attr_info.bit_length;
      543         go to set_done;
      544 
      545 set_li (3):					/* expr */
      546         li.encd_proc = "0"b;
      547         li.encdd_ptr = null;
      548         li.litd_ptr = node_stack (top_node) -> pred_leaf.lit_desc_ptr;
      549         li.encd_blen,
      550 	   li.lit_blen = 0;
      551 
      552 set_done:
      553         li.src_ptr = a_ptr;				/* fill in info for make_literal */
      554         li.srcd_ptr = d_ptr;
      555 
      556         if dot_x_dot then do;				/* since this is a .x. we need to save the place where we
      557*						   have to plug in the  proper value when we finally know it later */
      558 	  if x_pred_leaf_ptr = null then do;
      559 	      allocate x_pred_leaf in (select_area);
      560 	      x_pred_leaf.number_of_x = 0;
      561 	  end;
      562 	  x_pred_leaf.number_of_x = x_pred_leaf.number_of_x + 1;
      563 
      564 	  call mrds_dsl_make_literal$alloc (dbcb_ptr, addr (li), code);
      565 	  if code ^= 0 then call error (code, LOUD, 0, WC_TYPE, "");
      566 
      567 	  x_pred_leaf.info.encode_bit_len (x_pred_leaf.number_of_x) =
      568 	       li.encd_blen;
      569 	  x_pred_leaf.info.lit_val_ptr (x_pred_leaf.number_of_x) =
      570 	       li.lit_ptr;
      571 	  x_pred_leaf.info.lit_val_len (x_pred_leaf.number_of_x) =
      572 	       li.lit_blen;
      573 	  x_pred_leaf.info.encode_in_desc_ptr (x_pred_leaf.number_of_x) =
      574 	       li.encdd_ptr;
      575 	  x_pred_leaf.info.encode_out_desc_ptr (x_pred_leaf.number_of_x) =
      576 	       li.litd_ptr;
      577 	  if li.encd_proc then do;
      578 	      x_pred_leaf.info.encode_proc (x_pred_leaf.number_of_x) = "1"b;
      579 	      x_pred_leaf.info.encode_entry (x_pred_leaf.number_of_x) =
      580 		 li.encd_entry;
      581 	  end;
      582 	  else x_pred_leaf.info.encode_proc (x_pred_leaf.number_of_x) = "0"b;
      583 
      584         end;
      585         else do;
      586 	  call mrds_dsl_make_literal (dbcb_ptr, addr (li), code);
      587 	  if code ^= 0
      588 	  then call error (code, ^LOUD, 0, WC_TYPE,
      589 		  "The data type of the supplied constant can not be converted to that of the attribute."
      590 		  );
      591         end;
      592 
      593         pred_leaf.lit_offset = li.lit_offset;
      594         pred_leaf.lit_length = li.lit_blen;
      595         pred_leaf.lit_ptr = li.lit_ptr;
      596         pred_leaf.lit_desc_ptr = li.litd_ptr;
      597         pred_leaf.id.attr_id = substr (bit (li.lit_offset), 18);
      598 
      599         top_node = top_node + 1;			/* add new leaf to stack */
      600         node_stack (top_node) = pl_ptr;
      601 
      602         return;					/* build_literal */
      603 
      604 error:
      605     proc (cd, loud, stack_offset, error_type, message);
      606 
      607 dcl     cd		 fixed bin (35);		/* standard error code */
      608 dcl     loud		 bit (1) aligned;		/* OFF => dont print or signal error */
      609 dcl     stack_offset	 fixed bin;		/* offset from ls_top of where token is in lex stack */
      610 dcl     error_type		 char (*);
      611 dcl     message		 char (*);
      612 
      613         se_info_ptr = dbcb.se_info_ptr;
      614 
      615         code = cd;
      616 
      617         se_info.loud = loud;
      618         se_info.error_type = error_type;
      619         se_info.token_start = 0;
      620         se_info.stack_offset = stack_offset;		/* save this for semantics */
      621         se_info.error_msg = message;
      622         se_info.error_info_supplied = "1"b;		/* so no one else handles it */
      623 
      624         goto exit;
      625 
      626     end error;
      627 
  1     1 /* BEGIN mrds_dbcb.incl.pl1 -- jaw, 11/7/78 */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(85-11-17,Dupuis), approve(85-12-16,MCR7314),
  1     7*     audit(86-02-04,Brunelle), install(86-02-05,MR12.0-1013):
  1     8*     This entry is being made to cover the change made on 85-07-01 by Thanh
  1     9*     Nguyen. The scopes_changed flag was added to make checking for this
  1    10*     more efficient (mrds error list #137).
  1    11*  2) change(86-06-10,Blair), approve(86-08-07,MCR7491),
  1    12*     audit(86-08-07,Gilcrease), install(86-08-15,MR12.0-1127):
  1    13*     Add a bit called dont_check_txn_id to indicate whether or not we should
  1    14*     care if multiple txns use the same selection_expression. (mrds #156)
  1    15*  3) change(87-11-23,Hergert), approve(88-06-28,MCR7903),
  1    16*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  1    17*     Added parser_work_area_ptr and mrds_se_info_ptr for new parser.
  1    18*                                                   END HISTORY COMMENTS */
  1    19 
  1    20 
  1    21 /* WARNING
  1    22*          If the dbcb structure is changed then the mrds_data_
  1    23*          item saved_res_version MUST be incremented to invalidate all
  1    24*          existing saved resultants
  1    25**/
  1    26 
  1    27 /* HISTORY :
  1    28*
  1    29*   modified by Jim Gray - - 80-10-24, to add new_select_expr bit for
  1    30*   tid_list management
  1    31*
  1    32*   81-1-9 Jim Gray : added like reference for  ease  in  making  the
  1    33*   phony resultant in mu_database_index, without having the area dcl
  1    34*   included.
  1    35*
  1    36*   81-06-17 Roger Lackey :  added  last_store_rel_name  for  use  by
  1    37*   mrds_dsl_store
  1    38*
  1    39*   81-06-26 Roger Lackey : Added no_optimize and  print_search_order
  1    40*   switches
  1    41*
  1    42*   81-07-06 Jim Gray : added identifier for  the  current  selection
  1    43*   expression,  so  that relation statistics can be updated relative
  1    44*   to number of selection expressions seem. Also  removed  init  for
  1    45*   last_store_rel_name,   as   this   iw   now   properly   done  in
  1    46*   mrds_dsl_init_res.
  1    47*
  1    48*   81-07-17  Roger Lackey : added pred_ptr and unused_ptrs.
  1    49*
  1    50*   82-08-19  Mike Kubicar : added store_vector field.  This is needed
  1    51*   for the conversion to the relation manager.
  1    52*
  1    53*   82-08-23 Davids: added the relmgr_entries and access_costs
  1    54*   substructures so that the entries and costs can change
  1    55*   depending on the type of database that is opened.
  1    56*
  1    57*   82-09-09 Mike Kubicar : added modify_vector field.  This is needed
  1    58*   since modify uses a different vector type (general) than does store.
  1    59*
  1    60*   82-09-20 Davids: changed names of (store modify)_vector to
  1    61*   (store modify)_vector_ptr. Also (delete modify)_tuple_by_id to
  1    62*   (delete modify)_tuples_by_id. added the element cursor_storage_ptr
  1    63*   which should be inited to null and will be set by mu_cursor_manager_$get
  1    64*   during the first call.
  1    65*
  1    66*   82-09-21 Davids: renamed cursor_storage_ptr to cursor_ptrs_storage_ptr
  1    67*   since it deals with the pointers to the cursors and not the cursors
  1    68*   themelves and added the element cursor_storage_area_ptr which points
  1    69*   to the area where the cursors are kept.
  1    70*
  1    71*   82-09-22 Davids: renamed the transact_ctl_seg to transactions_needed.
  1    72*   the transact_ctl_seg always had a value of 0 and really didn't mean
  1    73*   anything.
  1    74*
  1    75*   82-09-22 Mike Kubicar : added create_relation, create_index and
  1    76*   destroy_relation_by_opening to relmgr_entries.  They are needed
  1    77*   by mrds_dsl_define_temp_rel.
  1    78*
  1    79*   82-09-24 Donna Woodka : added  put_tuple to  relmgr_entries. It
  1    80*   is needed by mu_store.
  1    81*
  1    82*   82-11-12 Davids: changed the declaration of the access_costs from fixed
  1    83*   bin to float bin since the values are not integers.
  1    84*
  1    85*   83-02-02 Davids: added the dbc_uid element. This will allow mrds to make
  1    86*   sure that the dbc_ptr still points to the correct segment. Element was 
  1    87*   added to the end of the structure to allow modules that don't use
  1    88*   the element to continue to reference the dbcb structure without recompiling.
  1    89*
  1    90*   83-02-25 Davids: added the concurrency_on and rollback_on elements. These
  1    91*   are needed so that temp rels can be created with the same file attributes
  1    92*   as the permanent relations.
  1    93*
  1    94*   83-05-02 Mike Kubicar : Deleted get_next_search_specification_ptr and
  1    95*   added the resultant_in_pdir bit.
  1    96*
  1    97*   83-05-18 Davids: reduced the number of reserved bits to 14 (from 15) and
  1    98*   added the res_already_made element.
  1    99*
  1   100*   83-05-24 Mike Kubicar : Updated the relation manager calling sequences.
  1   101*
  1   102*   83-08-03 Mike Kubicar : Added the element_id_list_segment_ptr and removed
  1   103*   one of the unused pointers.
  1   104*
  1   105*   83-09-20 Ron Harvey: Added relmgr_entries.get_population.
  1   106*
  1   107*   84-08-27 John Hergert:  Created compiled_se_info_ptr from unused_ptrs(2)
  1   108*   leaving unused_ptrs(1).
  1   109*
  1   110*   85-01-15 Thanh Nguyen:  Added the work_area_ptr and removed the last
  1   111*   unused_ptrs (1).
  1   112*
  1   113*   85-04-12 Thanh Nguyen:  Added user_started_transaction and 
  1   114*   non_shared_to_shared flags.  Also added se_transaction_id and some more
  1   115*   spare ptrs, entries and reserved storages for future enhancement, since
  1   116*   we changed the saved_res_version from rslt0001 to rslt0002.
  1   117*
  1   118*   85-07-01 Thanh Nguyen:  Added scopes_changed flag.  This flag is set by
  1   119*   common routine of mrds_dsl_set_scope, reset by mrds_dsl_optimize and 
  1   120*   mrds_dsl_gen_srch_prog when building of a new search_vars.
  1   121**/
  1   122 
  1   123 
  1   124 /* this structure is based on the {unique_name}.mrds.dbcb segment
  1   125*   that constitutes the non-secure portion of the resultant model that is
  1   126*   created during the opening of a database. it contains variables that
  1   127*   are used during the runtime access of the database, and an area
  1   128*   for evaluation of requests. it points to four other
  1   129*   segments in the resultant model, {unique_name}.mrds.rdbi, the secure
  1   130*   portion of the resultant(see mdbm_rm_db_info.incl.pl1),
  1   131*   {unique_name}.mrds.select, an area for selection expression evaluation,
  1   132*   {unique_name}.mrds.curdat, and {unique_name}.mrds.stadat, two segments
  1   133*   used in the elimination of duplicate tuples during a retrieve.
  1   134*   the dbcb area holds the structure in mdbm_scope_info.incl.pl1
  1   135*   that is used when the database is using the file scope mechanism
  1   136*   for concurrency control over file readying. the segment overlayed via
  1   137*   mrds_dbc.incl.pl1 structure is pointed to and also handles concurrency control,
  1   138*   across database openings. the pointer to this dbcb structure is kept in a table
  1   139*   which associates database indexes(returned from a call to dsl_$open), with particular
  1   140*   opening instances of resultant models. (see mu_database_index routine) */
  1   141 
  1   142      dcl	   1 dbcb		      aligned based (dbcb_ptr), /* DBCB -- non-secure portion */
  1   143 	     2 data	      like dbcb_data,
  1   144 	     2 static_area	      area (sys_info$max_seg_size - fixed (rel (addr (dbcb.static_area))));
  1   145 
  1   146      dcl	   dbcb_ptr	      ptr;
  1   147 
  1   148      declare 1 dbcb_data	      based,		/* info part of dbcb, separated out so that
  1   149*						   like references can avoid getting the area declaration */
  1   150 	     2 rdbi_ptr	      ptr,		/* pointer to write protected mdbm_util_ info. */
  1   151 	     2 range_ptr	      ptr,		/*  ptr to range structure, or null */
  1   152 	     2 select_ptr	      ptr,		/* ptr to select list, or null */
  1   153 	     2 sv_ptr	      ptr,		/* pointer to search variables */
  1   154 	     2 so_ptr	      ptr,		/* pointer to search operators */
  1   155 	     2 ti_ptr	      ptr,		/* pointer to tuple info */
  1   156 	     2 lit_ptr	      ptr,		/* pointer to the literal area, or null */
  1   157 	     2 current_ptr	      ptr,		/* ptr to select list resulting from -current clause */
  1   158 	     2 ss_ptr	      ptr,		/* ptr to select sets block if not simple s.e. */
  1   159 	     2 retr_info_ptr      ptr,		/* ptr to retrieve info area */
  1   160 	     2 trel_info_ptr      ptr,		/* ptr to retrieve info area */
  1   161 	     2 sti_ptr	      ptr,		/* pointer to store info */
  1   162 	     2 dbc_ptr	      ptr,		/*  pointer to the data base control segment */
  1   163 	     2 sfi_ptr	      ptr,		/* points to head of scalar function list */
  1   164 	     2 scope_ptr	      ptr,		/* points to array of scope tuples */
  1   165 	     2 select_area_ptr    ptr,		/* ptr to area for current selection expression allocations */
  1   166 	     2 current_data_ptr   ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  1   167*						   for eliminating duplicate tuples. */
  1   168 	     2 static_data_ptr    ptr,		/* ptr to one of 2 segments used by mrds_dsl_retrieve
  1   169*						   for eliminating duplicate tuples. */
  1   170 	     2 store_area_ptr     ptr,		/* temp storage area for dsl_$store */
  1   171 	     2 retrieve_area_ptr  ptr,		/* temp storage for dsl_$retrieve */
  1   172 	     2 modify_area_ptr    ptr,		/* temp storage area for dsl_$modify */
  1   173 	     2 delete_area_ptr    ptr,		/* temp storage area for dsl_$delete */
  1   174 	     2 def_temp_rel_area_ptr ptr,		/* temp storage area for dsl_$define_temp_rel */
  1   175 	     2 pred_ptr	      ptr,		/* Pointer to pred_array */
  1   176 	     2 store_vector_ptr   ptr,		/* Vector structure used during store operations */
  1   177 	     2 modify_vector_ptr  ptr,		/* Used during modifies */
  1   178 	     2 element_id_list_segment_ptr ptr,		/* Points to the segment used to hold element_id_list structures */
  1   179                2 compiled_se_info_ptr ptr,                  /* points to the segment containing all info on compiled sexs */
  1   180 	     2 work_area_ptr        ptr,		/* Work area for encode/decode value allocations in mu_retrieve */
  1   181 	     2 se_info_ptr          ptr,                  /* Points to se_info struct. Primarily for error reports */
  1   182 	     2 parser_work_area_ptr ptr,		/*  work area for parser */
  1   183 	     2 reserved_ptrs      (4) ptr,		/* Reserved for future use */
  1   184 	     2 another_flag	      bit (1) unal,		/* on if predicate was -another */
  1   185 	     2 current_flag	      bit (1) unal,		/* on if predicate was -current clause */
  1   186 	     2 dbc_incr	      bit (1) unal,		/* on if dbc open mode has been incremented for this user */
  1   187 	     2 delete_flag	      bit (1) unal,		/* On if search was called from mrds_dsl_sec_delete */
  1   188 	     2 dup_retain	      bit (1) unaligned,	/* On if dup tuples allowed for retrieval */
  1   189 	     2 prev_select	      bit (1) unal,		/* on if prev. select block processed in this s.e. */
  1   190 	     2 possible_op	      bit (1) unal,		/* on of arith op. allowed */
  1   191 	     2 sel_clause	      bit (1) unal,		/* on if currently in select clause */
  1   192 	     2 dsm_sw	      bit (1) unal,		/* on if data base was opened via data submodel */
  1   193 	     2 val_rtrv	      bit (1) unal,		/* if s.e. valid for retrieve */
  1   194 	     2 val_mod	      bit (1) unal,		/* for modify */
  1   195 	     2 val_del	      bit (1) unal,		/* for delete */
  1   196 	     2 val_dtr	      bit (1) unal,		/* for define temp rel */
  1   197 	     2 transactions_needed bit (1) unal,	/* On => transaction must be started or in progress does
  1   198*                                                                     not imply that the database is of type page_file */
  1   199 	     2 open_mode	      bit (3) unal,		/* 0=>unknown, 1=>r, 2=>u, 3=>er, 4=>eu, >4=>bad */
  1   200 	     2 new_select_expr    bit (1) unal,		/* on => starting a new tid list management period */
  1   201 	     2 no_optimize	      bit (1) unal,		/* On => no optimize */
  1   202 	     2 print_search_order bit (1) unal,		/*  On => print the search order */
  1   203 	     2 resultant_in_pdir  bit (1) unal,		/* On => Temp segments are in the process dir */
  1   204 	     2 res_already_made   bit (1) unal,           /* On => resultant has been made based on a saved copy */
  1   205 	     2 user_started_transaction bit (1) unal,     /* On => user already started his own transaction. */
  1   206 	     2 non_shared_to_shared bit (1) unal,         /* On => user changed the scope from non shared to shared
  1   207*						   inside a sequence of -another selection expression. */
  1   208 	     2 scopes_changed     bit (1) unal,           /* On => scopes had been changed by set_scopes or delete_scopes */
  1   209 	     2 dont_check_txn_id  bit (1) unal,           /* On => cpmd needs same selection exp across multiple txns */
  1   210 	     2 reserved	      bit (10) unal,	/* reserved for future use */
  1   211 	     2 nseq_sch	      fixed bin (35),	/* no. tuples located via sequential search */
  1   212 	     2 nind_sch	      fixed bin (35),	/* no. tuples located via index search */
  1   213 	     2 nhash_sch	      fixed bin (35),	/* no. tuples located via hash search */
  1   214 	     2 nlk_sch	      fixed bin (35),	/* no tuples located via link search */
  1   215 	     2 cur_lit_offset     fixed bin (35),	/* current bit offset in literal string */
  1   216 	     2 dbi	      fixed bin (35),	/* database index for this opening */
  1   217 	     2 last_s_e_id_num    fixed bin (35),	/* identifying number for last selection expression seen */
  1   218 	     2 se_transaction_id  bit (36) aligned,       /* transaction id from beginning of select expression */
  1   219 	     2 last_store_rel_name char (32),		/* Name of relation last used  for store */
  1   220 	     2 cursor_ptrs_storage_ptr ptr,		/* pointer to space where cursor ptrs are stored */
  1   221 	     2 cursor_storage_area_ptr ptr,		/* pointer to area where the cursors are kept */
  1   222 	     2 reserved_words     (10) fixed bin (35),	/* Reserved for future use */
  1   223 	     2 relmgr_entries,			/* relation manager entries */
  1   224 	       3 open	      entry (char (*), char (*), bit (36) aligned, fixed bin (35)),
  1   225 	       3 close	      entry (bit (36) aligned, fixed bin (35)),
  1   226 	       3 create_cursor    entry (bit (36) aligned, ptr, ptr, fixed bin (35)),
  1   227 	       3 destroy_cursor   entry (ptr, ptr, fixed bin (35)),
  1   228 	       3 set_scope	      entry (bit (36) aligned, bit (2) aligned, bit (2) aligned, fixed bin (35)),
  1   229 	       3 delete_tuples_by_id entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  1   230 	       3 modify_tuples_by_id entry (ptr, ptr, ptr, fixed bin (35), fixed bin (35)),
  1   231 	       3 get_tuple_by_id  entry (ptr, bit (36) aligned, ptr, ptr, ptr, fixed bin (35)),
  1   232 	       3 get_tuples_by_spec entry (ptr, ptr, ptr, ptr, ptr, fixed bin (35)),
  1   233 	       3 get_tuple_id     entry (ptr, ptr, ptr, ptr, fixed bin (35)),
  1   234 	       3 put_tuple	      entry (ptr, ptr, bit (36) aligned, fixed bin (35)),
  1   235 	       3 get_count	      entry (ptr, ptr, fixed bin (35), fixed bin (35)),
  1   236 	       3 get_duplicate_key_count entry (ptr, bit (36) aligned, fixed bin (17), fixed bin (35), fixed bin (35)),
  1   237 	       3 get_population   entry (ptr, fixed bin (35), fixed bin (35)),
  1   238 	       3 create_relation  entry (char (*), char (*), ptr, ptr, bit (36) aligned, bit (36) aligned, fixed bin (35)),
  1   239 	       3 create_index     entry (bit (36) aligned, ptr, bit (36) aligned, fixed bin (17), bit (36) aligned, fixed bin (35)),
  1   240 	       3 destroy_relation_by_path entry (char (*), char (*), fixed bin (35)),
  1   241 	       3 reserved_entries (5) entry (),
  1   242 	     2 access_costs,			/* access costs for permute */
  1   243 	       3 total_primary_key_cost float bin,
  1   244 	       3 access_cost      float bin,
  1   245 	       3 access_overhead  float bin,
  1   246 	       3 us_access_cost   float bin,
  1   247 	       3 os_access_cost   float bin,
  1   248 	     2 dbc_uid	      bit (36) aligned,	/* uid of the segment containing the dbc structure */
  1   249 	     2 concurrency_on     bit (1) unal,		/* "1"b implies dmfile concurrency is being used */
  1   250 	     2 rollback_on	      bit (1) unal;		/* "1"b iomplies before journaling is to be done */
  1   251 
  1   252 /* END mrds_dbcb.incl.pl1 */
  1   253 
  1   254 
      628 
      629 
  2     1 /* BEGIN mrds_predicate_tree.incl.pl1 -- jaw, 2/14/79 */
  2     2 
  2     3 /* HISTORY:
  2     4*
  2     5*   81-06-01 Jim Gray : removed assn type and len, now that
  2     6*   mu_convert is being used.
  2     7*
  2     8*
  2     9**/
  2    10 
  2    11 
  2    12 dcl 1 pred_node based (pn_ptr),			/*  structure of predicate tree node */
  2    13     2 type fixed bin,				/*  indicates if node or leaf */
  2    14     2 id unal,					/* id for node */
  2    15       3 lleaf_id like pred_leaf.id,			/* id for left leaf */
  2    16       3 op_code bit (6) unal,				/* operator code for this node */
  2    17       3 rleaf_id like pred_leaf.id,			/* id for right leaf */
  2    18     2 term_type fixed bin (5) unal,			/* if term, indicates type of term */
  2    19     2 root bit (1) unal,				/* on if root node */
  2    20     2 term bit (1) unal,				/* on if node is term */
  2    21     2 determined bit (1) unal,			/* on if term is "determined" independent of other terms */
  2    22     2 reserved bit (21) unal,				/* reserved for future use */
  2    23     2 parent ptr,					/* pointer to parent node */
  2    24     2 lbr ptr,					/* pointer to left branch */
  2    25     2 rbr ptr;					/* pointer to right branch */
  2    26 
  2    27 dcl  pn_ptr ptr;
  2    28 
  2    29 dcl 1 pred_array based (pred_ptr),			/* list representation of pred. */
  2    30     2 type fixed bin,				/*  indicates array, rather than node or leaf */
  2    31     2 num_ands fixed bin,				/* is the number of and groups */
  2    32     2 and_ptr (num_ands_init refer (pred_array.num_ands)) ptr; /* pointers to the and groups */
  2    33 
  2    34 dcl  pred_ptr ptr;
  2    35 
  2    36 dcl 1 and_group based (ag_ptr),			/* list of pointers to all terms in and group */
  2    37     2 num_terms fixed bin,				/* number of terms in list */
  2    38     2 term_ptr (num_terms_init refer (and_group.num_terms)) ptr; /* point to terms in this and group */
  2    39 
  2    40 dcl  ag_ptr ptr;
  2    41 dcl (num_ands_init,
  2    42      num_terms_init) fixed bin;
  2    43 
  2    44 dcl ((CURRENT_OP init ("000001"b)),			/* pred_node op_codes */
  2    45     (AND_OP init ("000010"b)),
  2    46     (OR_OP init ("000011"b)),
  2    47     (NOT_OP init ("000100"b)),
  2    48     (EQ_OP init ("000101"b)),
  2    49     (NE_OP init ("000110"b)),
  2    50     (LT_OP init ("000111"b)),
  2    51     (GT_OP init ("001000"b)),
  2    52     (LE_OP init ("001001"b)),
  2    53     (GE_OP init ("001010"b)),
  2    54     (ALL_OP init ("001011"b))) bit (6) int static options (constant);
  2    55 
  2    56 dcl ((CONST init (1)),				/* pred leaf data types */
  2    57     (ATTR init (2)),
  2    58     (EXPRES init (3))) fixed bin int static options (constant);
  2    59 
  2    60 dcl ((NODE init (0)),				/* type indicators */
  2    61     (LEAF init (1)),
  2    62     (ARRAY init (2))) fixed bin int static options (constant);
  2    63 
  2    64 dcl ((V_C init (1)),				/* pred_node term_types */
  2    65     (V_V init (2))) fixed bin (5) int static options (constant);
  2    66 
  2    67 dcl 1 pred_leaf based (pl_ptr),			/* structure for a predicate tree leaf */
  2    68     2 type fixed bin,				/* indicates if node or leaf */
  2    69     2 id,						/* leaf id */
  2    70       3 var_id bit (18) unal,				/* index of tuple var. */
  2    71       3 attr_id bit (18) unal,			/* defn order of attr. */
  2    72     2 dummy bit (1) unal,				/* on if dummy leaf for ALL_OP */
  2    73     2 reserved bit (35) unal,				/* reserved for future use */
  2    74     2 data_type fixed bin,				/* whether const, attr, or expr */
  2    75     2 lit_offset fixed bin (35),			/* bit offset of literal or expr. result */
  2    76     2 lit_length fixed bin (35),			/* bit length of literal or expr. result */
  2    77     2 rslt_desc bit (36),				/* descriptor of expr. result */
  2    78     2 lit_ptr ptr,					/* ptr to literal or expr. result value */
  2    79     2 lit_desc_ptr ptr,				/* ptr to literal or expr. result desc. */
  2    80     2 ai_ptr ptr,					/* to rm_attr_info for attribute */
  2    81     2 expr_ptr ptr,					/* pointer to expr. structure if expr. leaf */
  2    82     2 parent ptr;					/* pointer to parent node */
  2    83 
  2    84 dcl  pl_ptr ptr;
  2    85 
  2    86 /* END mrds_predicate_tree.incl.pl1 */
  2    87 
      630 
      631 
  3     1 /* BEGIN INCLUDE FILE  mrds_se_info.incl.pl1 
  3     2*
  3     3*   These contains information relating to the selection expression.
  3     4*
  3     5**/
  3     6 
  3     7 /****^  HISTORY COMMENTS:
  3     8*  1) change(85-08-05,Hergert), approve(88-06-28,MCR7903),
  3     9*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  3    10*     Created for for new parser.
  3    11*                                                   END HISTORY COMMENTS */
  3    12 
  3    13 dcl     1 se_info		 aligned based (se_info_ptr),
  3    14 	2 se_ptr		 ptr,			/* points to the beginning of the selection expression */
  3    15 	2 se_length	 fixed bin,		/* length of the selection expression */
  3    16 	2 se_cursor	 fixed bin,		/* current place in se */
  3    17 	2 flags,
  3    18 	  3 pso_seen	 bit,			/* -pso supplied in se */
  3    19 	  3 no_ot_seen	 bit,			/* -no_ot supplied in se */
  3    20           2 error_report,
  3    21 	  3 error_info_supplied bit aligned,              /* ON -> structure already filled in */
  3    22 	  3 loud             bit aligned,                	/* ON -> call mu_print_error */
  3    23             3 token_start      fixed bin,                   /* position in se where token starts */
  3    24             3 token_length     fixed bin,                   /* length of token in se */
  3    25 	  3 error_code       fixed bin(35),               /* system error code */
  3    26             3 stack_offset     fixed bin,                   /* how far down the token is in the lex stack */
  3    27             3 error_type       char(24),                    /* type of error. ie range, select where... */
  3    28 	  3 error_msg        char(256);         	/* message to explain problem */
  3    29 
  3    30 
  3    31 /* various types of errors. actually the string that is reported in the
  3    32*   error message. */
  3    33 dcl     RC_TYPE		 char (12) internal static
  3    34 			 options (constant) init ("Range Clause");
  3    35 dcl     SE_TYPE		 char (20) internal static
  3    36 			 options (constant)
  3    37 			 init ("Selection Expression");
  3    38 dcl     SC_TYPE		 char (13) internal static
  3    39 			 options (constant)
  3    40 			 init ("Select Clause");
  3    41 dcl     WC_TYPE		 char (12) internal static
  3    42 			 options (constant)
  3    43 			 init ("Where Clause");
  3    44 dcl     WCE_TYPE		 char (23) internal static
  3    45 			 options (constant)
  3    46 			 init ("Where Clause Expression");
  3    47 dcl     WCF_TYPE		 char (21) internal static
  3    48 			 options (constant)
  3    49 			 init ("Where Clause Function");
  3    50 dcl     AV_TYPE		 char (16) internal static
  3    51 			 options (constant)
  3    52 			 init ("Access Violation");
  3    53 dcl     IL_TYPE		 char (14) internal static
  3    54 			 options (constant)
  3    55 			 init ("Internal Logic");
  3    56 
  3    57 /* parser_work_area is used to hold all static data for an invocation
  3    58*   of the parser. parser_static_info holds ptrs to all of these relevant
  3    59*   data and also a ptr back to the area it is allocated in. 
  3    60*   parser_work_area.
  3    61**/
  3    62 
  3    63 dcl parser_work_area aligned area (sys_info$max_seg_size) based (parser_static_info.pwa_ptr);
  3    64 
  3    65 dcl psi_ptr ptr;
  3    66 dcl 1 parser_static_info aligned based (psi_ptr),
  3    67       2 pwa_ptr ptr,
  3    68       2 semantics, /* for mrds_dsl_semantics */
  3    69         3 static_data_ptr ptr,
  3    70       2 expr, /* for mrds_dsl_expr_ */
  3    71         3 data_stacks_ptr ptr,
  3    72       2 func, /* for mrds_dsl_func_ */
  3    73         3 sfptrs_ptr ptr,
  3    74       2 where_clause, /* for mrds_dsl_where_clause_ */
  3    75         3 ns_ptr ptr;
  3    76 
  3    77 
  3    78 /* END INCLUDE FILE  mrds_se_info.incl.pl1 */
      632 
      633 
  4     1 /* BEGIN INCLUDE FILE mrds_exp_fun_data.incl.pl1 -- jaw 5/20/77 */
  4     2 
  4     3 /* HISTORY:
  4     4*
  4     5*   81-06-01 Jim Gray : removed assn len and type entries,
  4     6*   now that mu_convert is being used.
  4     7*
  4     8**/
  4     9 
  4    10 
  4    11 dcl 1 exp_fun_data based (efd_ptr),			/* data for expression or function */
  4    12     2 var_index fixed bin,				/* index of assoc. tuple variable */
  4    13     2 loc_index fixed bin (18),			/* bit offset within literal pool for result */
  4    14     2 bit_length fixed bin (18),			/* bit length of expr. result */
  4    15     2 descriptor bit (36),				/* descriptor of expr. result */
  4    16     2 assn_ptr ptr,					/* pointer to storage location */
  4    17     2 ef_ptr ptr;					/* pointer to expression structure */
  4    18 
  4    19 dcl  efd_ptr ptr;
  4    20 
  4    21 /* END INCLUDE FILE mrds_exp_fun_data.incl.pl1 */
  4    22 
      634 
      635 
  5     1 /* Begin mrds_compiled_se_info.incl.pl1 -- John Hergert 09/01/84
  5     2*   Data structure to hold all pertinent information regarding compiled
  5     3*   selection expressions. Most of this information is put into the dbcb
  5     4*   variables having the same names when the compiled selection is referenced.
  5     5**/
  5     6 
  5     7 
  5     8 /****^  HISTORY COMMENTS:
  5     9*  1) change(87-01-22,Hergert), approve(88-05-19,MCR7903),
  5    10*     audit(88-06-28,Dupuis), install(88-08-01,MR12.2-1073):
  5    11*     Removed all references to var_exists_ptr.
  5    12*                                                   END HISTORY COMMENTS */
  5    13 
  5    14 
  5    15 dcl     1 compiled_se_info	 aligned based (compiled_se_info_ptr),
  5    16           2 real_select_area_ptr ptr,                       /* the real one assigned at open time */
  5    17 	2 compile_area_ptr	 ptr,			/* run time work area */
  5    18           2 temp_x_leaf_ptr    ptr,                         /* temp place to hold ptr to pred_leaf_list of .x.'s */
  5    19           2 temp_temp_rel_list_ptr ptr,                     /* temporary holding spot for list of temp rels */
  5    20 	2 number_of_compiled_se                           /* count of number of cse's weve had in this opening */
  5    21 			 fixed bin (35),
  5    22 
  5    23 
  5    24 	2 se_info		 (1                           /* various peices of information needed to describe the se */
  5    25 			 refer (compiled_se_info.number_of_compiled_se)),
  5    26             3 free             bit(1) unal,                 /* indicates whether this se is being used or not */
  5    27             3 dup_retain       bit(1) unal,                 /* se had a -dup in it */
  5    28             3 reserved         bit(34) unal,                /* a few spares */
  5    29             3 se_id_num        fixed bin(35),               /* the unique id num for the se */
  5    30 	  3 seg_ptr	 ptr,			/* points to seg that has compiled se */
  5    31 	  3 saved_ptrs,				/* these point to the various tables in the seg */
  5    32 	    5 select_area_ptr
  5    33 			 ptr,
  5    34 	    5 range_ptr	 ptr,
  5    35 	    5 select_ptr	 ptr,
  5    36 	    5 ti_ptr	 ptr,
  5    37 	    5 ss_ptr	 ptr,
  5    38               5 so_ptr         ptr,
  5    39               5 temp_rel_list_ptr ptr,
  5    40               5 x_leaf_ptr     ptr,                         /* ptr to list of ptrs to pred leaves for .x.'s */
  5    41               5 lit_ptr        ptr,
  5    42               5 reserved       (5) ptr;
  5    43 
  5    44 dcl     compiled_se_info_ptr	 ptr;
  5    45 
  5    46 
  5    47 
  5    48 /* info relating to the attributes and the literal for filling .X.'s */
  5    49 
  5    50 dcl  1 x_pred_leaf  based (x_pred_leaf_ptr) aligned,
  5    51        2 number_of_x fixed bin (35),                       /* number of .x. specified in this selection expr */
  5    52        2 lit_arg_ptr ptr,                                  /* temp pointer to literal arg */
  5    53        2 lit_desc_ptr ptr,                                  /* temp pointer to literal desc */
  5    54        2 info (mrds_data_$max_pred_nodes refer (x_pred_leaf.number_of_x)), /* this should be big enough */
  5    55          3 encode_proc bit unal,                            /* does this .x. have to be encoded */
  5    56          3 pad bit(35) unal,
  5    57          3 encode_entry entry,                              /* encode proc */
  5    58          3 encode_in_desc_ptr ptr,                          /* ptr to input to encode descrptior */
  5    59          3 encode_out_desc_ptr ptr,                         /* ptr to encoded descrptior */
  5    60          3 encode_bit_len fixed bin(35),                    /* length in bits of encoded value */
  5    61          3 lit_val_len fixed bin(35),                       /* length of value in bits to go in lit pool */
  5    62          3 lit_val_ptr ptr;                                 /* ptr to value in lit pool */
  5    63  
  5    64 
  5    65 dcl     x_pred_leaf_ptr     ptr;
  5    66 
  5    67 
  5    68 /* array of names for the temp rels used in a cse */
  5    69 /* these are used to make sure the temp isnt redefined on us after the se is compiled */
  5    70 dcl  1 temp_rel_list based (trl_ptr) aligned,   
  5    71        2 number_of_temp_rels fixed bin(35),  /* total number of temp rels in se including sets */
  5    72        2 temp_rel_info (mrds_data_$max_temp_rels) ,
  5    73          3 name char(32),                    /* model name */
  5    74          3 index fixed bin(35);              /* temp rel index */
  5    75 
  5    76 
  5    77 dcl trl_ptr ptr;
      636 
      637 
  6     1 /* BEGIN mrds_lit_info.incl.pl1 -- jaw, 2/13/79 */
  6     2 
  6     3 /* HISTORY:
  6     4*
  6     5*   81-05-06  Rickie  E.  Brinegar: The declaration encd_ptr ptr was changed to
  6     6*   encd_entry  entry  and encd_proc bit (1) and pad bit (35) were added.  This
  6     7*   was  done  inoder to permit make use of cu_$generate call and eliminate the
  6     8*   use of cv_ptr_ to generate entry pointers.
  6     9*
  6    10*   81-06-01 Jim Gray : removed assn_len and ass_len structure elements,
  6    11*   as these are not used, with the advent of mu_convert.
  6    12*
  6    13**/
  6    14 
  6    15 dcl 1 lit_info aligned based (lip),			/* info for make literal call */
  6    16     2 src_ptr ptr,					/* to literal source data */
  6    17     2 srcd_ptr ptr,					/* to literal source descr. */
  6    18     2 encd_entry entry,				/* to encode proc. entry */
  6    19     2 encd_proc bit (1) unal,				/* does an encode proc exist? */
  6    20     2 pad bit (35) unal,
  6    21     2 encdd_ptr ptr,				/* to descr. for input to encode proc */
  6    22     2 litd_ptr ptr,					/* to descr. to final liter. val. */
  6    23     2 lit_ptr ptr,					/* to final literal value */
  6    24     2 encd_blen fixed bin (35),			/* to bit length for encode proc input */
  6    25     2 lit_blen fixed bin (35),			/* to bit length for final literal */
  6    26     2 lit_offset fixed bin (35);			/* to offset for final literal in lit. pool */
  6    27 
  6    28 dcl  lip ptr;
  6    29 
  6    30 /* END mrds_lit_info.incl.pl1 */
  6    31 
      638 
      639 
  7     1 /*  BEGIN  mdbm_rm_attr_info.incl.pl1  --  jaw,  11/16/78  */
  7     2 
  7     3 /* WARNING
  7     4*          If the rm_attr_info structure is changed then the mrds_data_
  7     5*          item saved_res_version MUST be incremented to invalidate all
  7     6*          existing saved resultants
  7     7**/
  7     8 
  7     9 /*
  7    10*
  7    11*   Modified  by  Jim  Gray - - 80-11-05, to add mdbm_secured bit, so
  7    12*   that rm_rel_info does not have to be checked
  7    13*
  7    14*   81-05-28 Jim Gray  :  removed  structure  elements  referring  to
  7    15*   foreign keys.
  7    16*
  7    17*   82-08-19  D. Woodka : removed rm_attr_info.bit_offset for the DMS
  7    18*   conversion.
  7    19*
  7    20*   82-09-15 Davids: added the number_of_dups field.
  7    21*
  7    22*   82-09-20 Mike Kubicar : changed the index_id field to be bit (36)
  7    23*   aligned.  This is to conform with the new definition in the database
  7    24*   model.  Also removed the now useless field varying.
  7    25*
  7    26*   82-11-05 Davids: added the field model_defn_order and clarified the
  7    27*   comment for the field defn_order.
  7    28*
  7    29*   83-05-23 Mike Kubicar : changed number_of_dups to fixed bin (35) since
  7    30*   that's what relation manager returns.
  7    31*
  7    32**/
  7    33 
  7    34 
  7    35 /*
  7    36*   this   structure   is   allocated   in   the   static   area   of
  7    37*   mdbm_rm_db_info.incl.pl1  once for each attribute per relation in
  7    38*   a     readied     file.      it     in     turn     points     to
  7    39*   mdbm_rm_domain_info.incl.pl1  for  the  attributes  domain.   the
  7    40*   rm_attr_info  is  pointed  to  by mdbm_rm_rel_info.incl.pl1.  all
  7    41*   structures  are  in  the  rm_db_info  area.   the  attribute data
  7    42*   position  within  a  tuple as stored in the data file are kept in
  7    43*   this resultant model of the attribute.
  7    44* */
  7    45 
  7    46 dcl 1 rm_attr_info aligned based (rai_ptr),		/* resultant attr. info */
  7    47     2 name char (32),				/* from submodel */
  7    48     2 model_name char (32),				/* from model */
  7    49     2 key_attr bit (1) unal,				/* if key attribute */
  7    50     2 index_attr bit (1) unal,			/* if secondary index */
  7    51     2 read_perm bit (1) unal,				/* user has retr. permission */
  7    52     2 modify_perm bit (1) unal,			/* user has modify permission */
  7    53     2 mdbm_secured bit (1) unal,			/* on => database secured */
  7    54     2 reserved bit (30) unal,				/* for future use */
  7    55     2 index_id bit (36) aligned,			/* index id if index_attr */
  7    56     2 defn_order fixed bin,				/* relative order in which attr is defined in the view */
  7    57     2 key_order fixed bin,				/* relative order defined in prim. key */
  7    58     2 bit_length fixed bin (35),			/* length if fixed, max. len. if var. */
  7    59     2 domain_ptr ptr,				/* to domain info */
  7    60     2 number_of_dups fixed bin (35),                        /* if the attribute is indexed this will
  7    61*                                                               be the number of duplicate values, exact
  7    62*                                                               for a page_file database, an estimate for a vfile type */
  7    63     2 model_defn_order fixed bin;                           /* relative order in which attr is defined in the model */
  7    64 
  7    65 dcl  rai_ptr ptr int automatic init (null ());
  7    66 
  7    67 /* END mdbm_rm_attr_info.incl.pl1 */
  7    68 
  7    69 
      640 
      641 
  8     1 /* BEGIN mdbm_rm_domain_info.incl.pl1 -- jaw, 9/26/78 */
  8     2 
  8     3 /* WARNING
  8     4*          If the rm_domain_info structure is changed then the mrds_data_
  8     5*          item saved_res_version MUST be incremented to invalidate all
  8     6*          existing saved resultants
  8     7**/
  8     8 
  8     9 /* DESCRIPTION:
  8    10*
  8    11*   This  structure  is  allocated  in  the  mdbm_rm_db_info.incl.pl1
  8    12*   static  area,  once per attribute used in a relation in a readied
  8    13*   file. it is pointed to by the mdbm_rm_attr_info.incl.pl1, and may
  8    14*   point  to  mdbm_rm_ck_and_group.incl.pl1  if  a  "-check"  option
  8    15*   boolean expression was declared for this domain. it contains  the
  8    16*   descriptor  for  this domain data type, and other resultant model
  8    17*   information.
  8    18*
  8    19*
  8    20*   HISTORY:
  8    21*
  8    22*   81-05-06  Rickie  E.  Brinegar:  Modified  ck_proc,  encode_proc,
  8    23*   decode_proc to be entry variables instead of entry pointers. This
  8    24*   allows these programs to be written in languages other than pl1.
  8    25*
  8    26*   81-05-28 Jim Gray : removed unused procedure points,  and  unused
  8    27*   check  stack  structure  elements.  Also made the descriptors bit
  8    28*   (36) in this structure, rather than pointers to  the  descriptors
  8    29*   elsewhere.  Also  removed un-needed redundant assign_ parameters,
  8    30*   that are actually available in the descriptors.
  8    31*
  8    32*
  8    33**/
  8    34 
  8    35 dcl 1 rm_domain_info aligned based (rdi_ptr),		/* domain information */
  8    36     2 name char (32),				/* domain name */
  8    37     2 db_desc bit (36),				/*  to desc. for db. */
  8    38     2 user_desc bit (36),				/* desc for user visible data */
  8    39     2 user_bit_len fixed bin,				/* storage length of users data */
  8    40     2 ck_proc_entry entry variable,			/* to check proc. entry */
  8    41     2 encd_proc_entry entry variable,			/* to encode proc entry */
  8    42     2 decd_proc_entry entry variable,			/* to decode proc entry */
  8    43     2 ck_proc bit (1) unal,				/* Is there a check proc */
  8    44     2 encd_proc bit (1) unal,				/* Is there an encode proc */
  8    45     2 decd_proc bit (1) unal,				/* Is there a decode proc */
  8    46     2 pad bit (33) unal,
  8    47     2 next_domain_ptr ptr ;				/* to next domain, in list of all domains */
  8    48 						/* to check stack and groups */
  8    49 
  8    50 
  8    51 dcl  rdi_ptr ptr int automatic init (null ());
  8    52 
  8    53 /* END mdbm_rm_domain_info.incl.pl1 */
  8    54 
  8    55 
      642 
      643 
  9     1 /* BEGIN mrds_range.incl.pl1 -- jaw, 10/20/78 */
  9     2 
  9     3 /* Modified 83-04-22 by R. Harvey to add needed_bits */
  9     4 
  9     5 dcl 1 range aligned based (range_ptr),
  9     6     2 num_vars fixed bin,				/* number of tuple variables */
  9     7     2 tup_var (mrds_data_$max_tup_var refer (range.num_vars)), /* info for each tuple variable */
  9     8       3 name char (mrds_data_$max_id_len),		/* name of tuple variable */
  9     9       3 temp_rel bit (1) unal,			/* on if temporary relation */
  9    10       3 used bit (1) unal,				/* 1 => this tuple variable is referenced by
  9    11*						   a -select clause. */
  9    12       3 whole_tuple_selected bit (1) unal,		/* the whole tuple variable is referenced in the select clause */
  9    13       3 copy_for_current bit (1) unal,			/* -current requests attributes not previously retrieved */
  9    14       3 copied_for_current bit (1) unal,		/* tuple copied during previous -current */
  9    15       3 reserved bit (31) unal,			/* reserved for future use */
  9    16       3 rel_index fixed bin,				/* index to assoc. relation */
  9    17       3 stv_ptr ptr,				/* simple typed vector */
  9    18       3 idl_ptr ptr,				/* id_list ptr */
  9    19       3 needed_bits aligned,
  9    20         4 attr (mrds_data_$max_attributes) bit (1) unal,
  9    21       3 ri_ptr ptr;					/* pointer to rel info for assoc. relation */
  9    22 
  9    23 dcl  range_ptr ptr;
  9    24 
  9    25 /* END mrds_range.incl.pl1 */
  9    26 
      644 
      645 
 10     1 /* BEGIN INCLUDE FILE mdbm_seg_area.incl.pl1 - - Jim Gray 2/19/79 */
 10     2 
 10     3 /* these structures provide a standard for
 10     4*   1) using an entire segment as an area, managed by the area manager
 10     5*   2) a constant header, that has an offset to the major common structure in the area
 10     6*   the pointer to that structure is obtained via pointer(model_seg_ptr, model_seg.offset)
 10     7*   the model_area_ptr is obtained via pointer(model_seg_ptr, size(model_seg)) */
 10     8 
 10     9 declare 1 model_seg aligned based (model_seg_ptr),	/* segment header, not to be changed */
 10    10         2 struct_offset bit (18),			/* offset to major structure allocated in area */
 10    11         2 padding (3) fixed bin ;			/* to set up four word boundary */
 10    12 
 10    13 declare  model_seg_ptr ptr int automatic init (null ());
 10    14 
 10    15 
 10    16 declare  model_area area (sys_info$max_seg_size - size (model_seg)) based (model_area_ptr) ; /* segment area */
 10    17 
 10    18 declare  model_area_ptr ptr int automatic init (null ());
 10    19 
 10    20 dcl size builtin;
 10    21 
 10    22 /* END INCLUDE FILE mdbm_seg_area.incl.pl1 */
 10    23 
      646 
      647 
 11     1 /* BEGIN INCLUDE FILE mrds_select_area.incl.pl1   (Kepner Multics)  05/29/79 1736.1 mst Tue */
 11     2 dcl 1 select_area_struct aligned based (select_area_struct_ptr), /* major structure in segment for current selection expression allocations */
 11     3     2 version fixed bin,
 11     4     2 dbcb_ptr ptr;					/* ptr ptr to dbcb */
 11     5 
 11     6 dcl  select_area_struct_ptr ptr int automatic init (null ());
 11     7 
 11     8 dcl  select_area area (sys_info$max_seg_size - size(model_seg)) based (select_area_ptr);
 11     9 
 11    10 dcl  select_area_ptr ptr int automatic init (null ());
 11    11 						/*   END INCLUDE FILE mrds_select_area.incl.pl1 */
 11    12 
      648 
      649 
 12     1 /* BEGIN INCLUDE FILE mrds_debug_names.incl.pl1     Jim Gray 8/7/79 */
 12     2 
 12     3 /* this include file associates module names with debug switches
 12     4*   that are stored in the data segment mrds_debug_
 12     5*   each module has it's own bit(9) debug switch, to define for various
 12     6*   debug actions, with new module names to be added to the end
 12     7*   of this list using the next in order array index in mrds_debug_
 12     8*   the convention for naming is db_{module's full name}
 12     9*   for the defined declaration over mrds_debug_$switch.
 12    10*   module.name array is then changed to reflect the new
 12    11*   number of modules, with the full module name added to the bottom
 12    12*   of the initialize list for the name array.
 12    13*   the module name array is used by the command level interface that sets/resets
 12    14*   the current status of the debug switches for each module.
 12    15*   the modules themselves use the db_{module name} declared variable for
 12    16*   that module to interagate the bits for proper debug action to take.
 12    17*   the definition of the meaning of the 9-bits is up to each individual module's
 12    18*   designer. */
 12    19 
 12    20 
 12    21 /*
 12    22*   HISTORY
 12    23*
 12    24*   80-11-12 Davids: added db_mus_mod_ubtup
 12    25*
 12    26*   80-11-13 Davids: added db_mu_sec_get_tuple and db_mu_sec_get_tid
 12    27*
 12    28*   80-12-15 Jim Gray :  added  mrds_dsl_set_fscope  to  display  non
 12    29*   error  info  about  being queued, and request being granted after
 12    30*   being queued.
 12    31*
 12    32*   81-01-15 Jim Gray : added  mu_concurrency_control  bit  to  allow
 12    33*   running  MR8  and  MR9 mrds against the same database at the same
 12    34*   time.
 12    35*
 12    36*   81-02-02  Jim  Gray  :  added  bit  for  mrds_rst_dmdm  to  allow
 12    37*   displaying internal tuple format bit offset, rather than the user
 12    38*   view.
 12    39*
 12    40*   81-02-06 Jim Gray : added bit for  new  mu_open_name_manager,  to
 12    41*   dump  an  element  from  the  list, when display_open_names entry
 12    42*   called with switch set.
 12    43*
 12    44*   81-05-20 Jim Gray : added bit for  mrds_dsl_where_clause  display
 12    45*   of sub_err_ messages, when cross domain compare occurs.
 12    46*
 12    47*   81-06-17 Jim Gray : added bit for mu_open_iocb_manager to display
 12    48*   iocb slot and rel name.
 12    49*
 12    50*   81-07-08 Jim Gray : added comment for bit 4 in mrds_dsl_permute
 12    51*
 12    52*   81-07-17 Jim Gray : added comment for bit 5 in mrds_dsl_permute
 12    53*
 12    54*   81-07-18 Jim Gray : added bit 1 for  mrds_dsl_gen_srch_prog  that
 12    55*   allows  key  searches, other than than specified by permute to be
 12    56*   done as comparisons instead.
 12    57*
 12    58*   81-07-22  Jim   Gray   :   added   comment   about   bit   2   in
 12    59*   mrds_dsl_gen_srch_prog
 12    60**/
 12    61 
 12    62 declare (
 12    63          db_mrds_dsl_eval_expr bit (9) unal defined (mrds_debug_$switch (1)),
 12    64          db_mrds_dsl_get_token bit (9) unal defined (mrds_debug_$switch (2)),
 12    65          db_mrds_dsl_permute bit (9) unal defined (mrds_debug_$switch (3)),
 12    66          db_mrds_dsl_optimize bit (9) unal defined (mrds_debug_$switch (4)),
 12    67          db_mrds_dsl_search bit (9) unal defined (mrds_debug_$switch (5)),
 12    68          db_mrds_dsl_translate bit (9) unal defined (mrds_debug_$switch (6)),
 12    69          db_mu_retrieve bit (9) unal defined (mrds_debug_$switch (7)),
 12    70          db_mrds_dsl_open bit (9) unal defined (mrds_debug_$switch (8)),
 12    71          db_mrds_dsl_close bit (9) unal defined (mrds_debug_$switch (9)),
 12    72          db_mrds_dsl_init_res bit (9) unal defined (mrds_debug_$switch (10)),
 12    73          db_mu_sec_init_res bit (9) unal defined (mrds_debug_$switch (11)),
 12    74          db_mus_mod_ubtup bit (9) unal defined (mrds_debug_$switch (12)),
 12    75          db_mu_sec_get_tuple bit (9) unal defined (mrds_debug_$switch (13)),
 12    76          db_mu_sec_get_tid bit (9) unal defined (mrds_debug_$switch (14)),
 12    77          db_mrds_dsl_set_fscope bit (9) unal defined (mrds_debug_$switch (15)),
 12    78          db_mu_concurrency_control bit (9) unal defined (mrds_debug_$switch (16)),
 12    79          db_mrds_rst_dmdm bit (9) unal defined (mrds_debug_$switch (17)),
 12    80          db_mu_open_name_manager bit (9) unal defined (mrds_debug_$switch (18)),
 12    81          db_mrds_dsl_where_clause bit (9) unal defined (mrds_debug_$switch (19)),
 12    82          db_mu_open_iocb_manager bit (9) unal defined (mrds_debug_$switch (20)),
 12    83          db_mrds_dsl_gen_srch_prog bit (9) unal defined (mrds_debug_$switch (21))
 12    84          ) ;
 12    85 
 12    86 /* list of known module names, with index into name array
 12    87*   the same as that into mrds_debug_$switch,
 12    88*   number is the current count of defined module names,
 12    89*   name is the modules full name. */
 12    90 
 12    91 declare 1 module options (constant) internal static,
 12    92         2 number fixed bin init (21),
 12    93         2 name char (32) dimension (21) init (
 12    94          "mrds_dsl_eval_expr",			/* 1 => display value of each expression */
 12    95          "mrds_dsl_get_token",			/* 1 => display the current token */
 12    96          "mrds_dsl_permute",				/* each 1 => lost cost path found,
 12    97*						   2 => reverse partial path
 12    98*						   3 => use range order for path
 12    99*						   4 => display access method costs
 12   100*						   5 => display details of final low cost path */
 12   101          "mrds_dsl_optimize",				/* 1 => pred tree,
 12   102*						   2 => paths to consider, 3 => calc_cost on */
 12   103          "mrds_dsl_search",				/* 1 => display each tuple located */
 12   104          "mrds_dsl_translate",			/* 1 => display the search program */
 12   105          "mu_retrieve",				/* 1 => display values compared, 2 => display tuple data */
 12   106          "mrds_dsl_open",				/* 1 => allow cleanup sub_error_ */
 12   107          "mrds_dsl_close",				/* 1 => allow cleanup sub_error_ */
 12   108          "mrds_dsl_init_res",				/* 1 => allow cleanup sub_error_ */
 12   109          "mu_sec_init_res",				/* 1 => allow cleanup sub_error_ */
 12   110          "mus_mod_ubtup",				/* 1 => consistency checking between the old
 12   111*						   and new tuple during modifies will be done */
 12   112          "mu_sec_get_tuple",				/* 1 => attribute values
 12   113*						   will be zeroed in the tuple structure
 12   114*						   is don't have read permission. */
 12   115          "mu_sec_get_tid",				/* 1 => read permission to the key
 12   116*						   is checked (if db is secured) */
 12   117          "mrds_dsl_set_fscope",			/* 1 => display being queued,
 12   118*						   and request granted from queue messages */
 12   119          "mu_concurrency_control",			/* 1 => allow both dbc and db.control segs under db
 12   120*						   so can test both MR8 and MR9 mrds
 12   121*						   against the same database at the same time */
 12   122          "mrds_rst_dmdm",				/* 1 => allow internal form of bit offset value
 12   123*						   for attributes to be displayed, rather than user view */
 12   124          "mu_open_name_manager",			/* 1 => dump mrds_open_name tree node structure,
 12   125*						   when display_open_names entry called */
 12   126          "mrds_dsl_where_clause",			/* 1 => display details of cross domain compares */
 12   127          "mu_open_iocb_manager",			/* 1 => display relation and slot getting iocb for */
 12   128          "mrds_dsl_gen_srch_prog"			/* 1 => do additional conditions as sequential, not key searches
 12   129*						   when the original access was a key,
 12   130*						   and the additional conditions can be done as key also
 12   131*						   2 => force key searches, regardless of strategy
 12   132*						   used to decide between compare or key search */
 12   133          ) ;
 12   134 
 12   135 declare  mrds_debug_$switch (1:400) bit (9) unal ext ;	/* data segment debug array */
 12   136 
 12   137 /* END INCLUDE FILE mrds_debug_names.incl.pl1 */
 12   138 
      650 
      651 
      652 dcl     LOUD		 bit init ("1"b) aligned internal static
      653 			 options (constant);
      654 dcl     a_select_area_ptr	 ptr;
      655 dcl     addr		 builtin;
      656 dcl     bit		 builtin;
      657 dcl     caller_name		 char (21) init ("mrds_dsl_where_clause")
      658 			 int static options (constant);
      659 dcl     code		 fixed bin (35);		/* Output -- return code */
      660 dcl     continue		 char (1) init ("c") int static
      661 			 options (constant);	/* don't stop after printing error */
      662 dcl     difference_mesg	 char (11) varying;		/* either "domain" or "datr type" differs */
      663 dcl     fatal_flag		 bit (1);			/* on => fatal non-comparable domain comparison attempt */
      664 dcl     fixed		 builtin;
      665 dcl     info_ptr		 ptr init (null ());	/* unused */
      666 dcl     1 li		 aligned like lit_info;
      667 dcl     mrds_data_$max_pred_nodes
      668 			 fixed bin (35) external static;
      669 dcl     mrds_dsl_make_literal	 entry (ptr, ptr, fixed bin (35));
      670 dcl     mrds_dsl_make_literal$alloc
      671 			 entry (ptr, ptr, fixed bin (35));
      672 dcl     mrds_error_$diff_comp_domain
      673 			 fixed bin (35) external static;
      674 dcl     mrds_error_$ill_term	 fixed bin (35) external static;
      675 dcl     mrds_error_$inc_attr_acc
      676 			 fixed bin (35) external static;
      677 dcl     mrds_error_$node_stack_ovfl
      678 			 fixed bin (35) external static;
      679 dcl    1 ns aligned based (parser_static_info.ns_ptr),
      680          2 top_node fixed bin(35),
      681          2 node_stack (mrds_data_$max_pred_nodes) ptr; /* stack of pending nodes;  */
      682 dcl     null		 builtin;
      683 dcl     op_array		 (1:55) bit (6) unal int static
      684 			 options (constant) init (
      685 			 "02"b3,			/* 1 and */
      686 			 "00"b3, "00"b3, "00"b3, "00"b3, "00"b3, "00"b3,
      687 			 "00"b3, "00"b3, "00"b3, "00"b3, "00"b3, "00"b3,
      688 			 "00"b3, "00"b3, "00"b3, "00"b3, "00"b3, "00"b3,
      689 			 "00"b3, "00"b3, "00"b3, "00"b3, "00"b3, "00"b3,
      690 			 "00"b3, "00"b3, "00"b3, "00"b3, "00"b3, "00"b3,
      691 			 "00"b3, "00"b3, "00"b3, "00"b3, "00"b3, "00"b3,
      692 			 "00"b3, "00"b3, "00"b3, "00"b3,
      693 			 "07"b3,			/* 42 lt */
      694 			 "11"b3,			/* 43 le */
      695 			 "00"b3, "00"b3, "00"b3, "00"b3,
      696 			 "05"b3,			/* 48 eq */
      697 			 "10"b3,			/* 49 gt */
      698 			 "12"b3,			/* 50 ge */
      699 			 "00"b3, "00"b3,
      700 			 "04"b3,			/* 53 not */
      701 			 "06"b3,			/* 54 ne */
      702 			 "03"b3);			/* 55 or */
      703 dcl     output_pred_ptr	 ptr;			/* to root of pred tree */
      704 dcl     reason_mesg		 char (80) varying;		/* reason for warning/error */
      705 dcl     rel		 builtin;
      706 dcl     return_value	 fixed bin (35) init (0);	/* unused */
      707 dcl     se_info_ptr		 ptr;
      708 dcl     string		 builtin;
      709 dcl     sub_err_		 entry options (variable);	/* reports specifics of subroutine error */
      710 dcl     substr		 builtin;
      711 dcl     sys_info$max_seg_size	 fixed bin (35) external static;
      712 dcl     term_type_array	 (3, 3) fixed bin int static
      713 			 options (constant) init (
      714 			 0, 0, 0,			/* const <op> * */
      715 			 1, 2, 2,			/* var <op> * */
      716 			 1, 2, 2);		/* expr <op> * */
      717 
      718 exit:
      719     end mrds_dsl_where_clause_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/01/88  1300.0  mrds_dsl_where_clause_.pl1        >special_ldd>install>MR12.2-1073>mrds_dsl_where_clause_.pl1
628          1    08/01/88  1300.0  mrds_dbcb.incl.pl1                >special_ldd>install>MR12.2-1073>mrds_dbcb.incl.pl1
630          2    10/14/83  1608.9  mrds_predicate_tree.incl.pl1      >ldd>include>mrds_predicate_tree.incl.pl1
632          3    08/01/88  1300.0  mrds_se_info.incl.pl1             >special_ldd>install>MR12.2-1073>mrds_se_info.incl.pl1
634          4    10/14/83  1608.9  mrds_exp_fun_data.incl.pl1        >ldd>include>mrds_exp_fun_data.incl.pl1
636          5    08/01/88  1300.0  mrds_compiled_se_info.incl.pl1    >special_ldd>install>MR12.2-1073>mrds_compiled_se_info.incl.pl1
638          6    10/14/83  1609.1  mrds_lit_info.incl.pl1            >ldd>include>mrds_lit_info.incl.pl1
640          7    10/14/83  1609.1  mdbm_rm_attr_info.incl.pl1        >ldd>include>mdbm_rm_attr_info.incl.pl1
642          8    10/14/83  1609.1  mdbm_rm_domain_info.incl.pl1      >ldd>include>mdbm_rm_domain_info.incl.pl1
644          9    10/14/83  1609.1  mrds_range.incl.pl1               >ldd>include>mrds_range.incl.pl1
646         10    10/14/83  1608.6  mdbm_seg_area.incl.pl1            >ldd>include>mdbm_seg_area.incl.pl1
648         11    10/14/83  1608.6  mrds_select_area.incl.pl1         >ldd>include>mrds_select_area.incl.pl1
650         12    10/14/83  1609.0  mrds_debug_names.incl.pl1         >ldd>include>mrds_debug_names.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ATTR                                   constant        fixed bin(17,0)          initial dcl 2-56 ref 240 369 369
AV_TYPE                         000035 constant        char(16)                 initial packed unaligned dcl 3-50 set ref 219*
CONST                                  constant        fixed bin(17,0)          initial dcl 2-56 ref 519
EXPRES                                 constant        fixed bin(17,0)          initial dcl 2-56 ref 270
LEAF                                   constant        fixed bin(17,0)          initial dcl 2-60 ref 229 269 518
LOUD                            000062 constant        bit(1)                   initial dcl 652 set ref 207* 219* 258* 363* 459 502*
                                                                                  506* 525* 565* 587
NODE                                   constant        fixed bin(17,0)          initial dcl 2-60 ref 314
WC_TYPE                         000041 constant        char(12)                 initial packed unaligned dcl 3-41 set ref 207* 258*
                                                                                  363* 502* 506* 525* 565* 587*
a_ptr                                  parameter       pointer                  dcl 489 ref 481 552
a_select_area_ptr                      parameter       pointer                  dcl 654 ref 193 206 248 257 297 309 481 501
addr                                                   builtin function         dcl 655 ref 277 539 540 564 564 586 586
ai_ptr                                 parameter       pointer                  dcl 198 in procedure "mrds_dsl_where_clause_" ref
                                                                                  193 218 230
ai_ptr                   14            based           pointer                  level 2 in structure "pred_leaf" dcl 2-67
                                                                                  in procedure "mrds_dsl_where_clause_" set ref 230*
                                                                                  279* 369 369 403 403 411 411 423 423 445 445 515*
                                                                                  529
assn_ptr                  4            based           pointer                  level 2 dcl 4-11 ref 276
attr_id                   1(18)        based           bit(18)                  level 3 packed packed unaligned dcl 2-67 set ref
                                                                                  228* 271* 597*
bit                                                    builtin function         dcl 656 ref 226 228 267 597
bit_length                2            based           fixed bin(18,0)          level 2 in structure "exp_fun_data" dcl 4-11
                                                                                  in procedure "mrds_dsl_where_clause_" ref 274
bit_length               24            based           fixed bin(35,0)          level 2 in structure "rm_attr_info" dcl 7-46
                                                                                  in procedure "mrds_dsl_where_clause_" ref 542
caller_name                     000027 constant        char(21)                 initial packed unaligned dcl 657 set ref 445*
cd                                     parameter       fixed bin(35,0)          dcl 607 ref 604 615
code                                   parameter       fixed bin(35,0)          dcl 659 set ref 193 205* 248 256* 297 308* 481 500*
                                                                                  564* 565 565* 586* 587 587* 615*
continue                        000026 constant        char(1)                  initial packed unaligned dcl 660 set ref 445*
d_ptr                                  parameter       pointer                  dcl 489 ref 481 554
data                                   based           structure                level 2 dcl 1-142
data_type                 3            based           fixed bin(17,0)          level 2 dcl 2-67 set ref 240* 270* 358 358 369 369
                                                                                  519* 524
db_desc                  10            based           bit(36)                  level 2 dcl 8-35 set ref 423 423 540
db_mrds_dsl_where_clause               defined         bit(9)                   packed unaligned dcl 12-62 ref 369
dbcb                                   based           structure                level 1 dcl 1-142
dbcb_data                              based           structure                level 1 unaligned dcl 1-148
dbcb_ptr                               parameter       pointer                  dcl 1-146 set ref 193 297 481 564* 586* 613
defn_order               22            based           fixed bin(17,0)          level 2 dcl 7-46 ref 228
descriptor                3            based           bit(36)                  level 2 packed packed unaligned dcl 4-11 ref 275
determined                3(14)        based           bit(1)                   level 2 packed packed unaligned dcl 2-12 set ref
                                                                                  316*
difference_mesg                 000120 automatic       varying char(11)         dcl 662 set ref 418* 430* 437* 445*
domain_ptr               26            based           pointer                  level 2 dcl 7-46 ref 369 369 403 403 411 411 423 423
                                                                                  531
dot_x_dot                              parameter       bit(1)                   dcl 493 ref 481 556
dummy                     2            based           bit(1)                   level 2 packed packed unaligned dcl 2-67 set ref
                                                                                  233* 271* 520*
ef_ptr                    6            based           pointer                  level 2 dcl 4-11 ref 278
efd_ptr                                parameter       pointer                  dcl 4-19 ref 248 267 273 274 275 276 278
encd_blen                20     000130 automatic       fixed bin(35,0)          level 2 dcl 666 set ref 541* 549* 567
encd_entry                4     000130 automatic       entry variable           level 2 dcl 666 set ref 534* 579
encd_proc                10     000130 automatic       bit(1)                   level 2 in structure "li" packed packed unaligned
                                                                                  dcl 666 in procedure "mrds_dsl_where_clause_" set
                                                                                  ref 535* 537* 545* 577
encd_proc                30(01)        based           bit(1)                   level 2 in structure "rm_domain_info" packed packed
                                                                                  unaligned dcl 8-35 in procedure
                                                                                  "mrds_dsl_where_clause_" ref 369 369 411 411 533
encd_proc_entry          20            based           entry variable           level 2 dcl 8-35 ref 534
encdd_ptr                12     000130 automatic       pointer                  level 2 dcl 666 set ref 539* 547* 573
encode_bit_len           20            based           fixed bin(35,0)          array level 3 dcl 5-50 set ref 567*
encode_entry             10            based           entry variable           array level 3 dcl 5-50 set ref 579*
encode_in_desc_ptr       14            based           pointer                  array level 3 dcl 5-50 set ref 573*
encode_out_desc_ptr      16            based           pointer                  array level 3 dcl 5-50 set ref 575*
encode_proc               6            based           bit(1)                   array level 3 packed packed unaligned dcl 5-50 set
                                                                                  ref 578* 582*
error_info_supplied       6            based           bit(1)                   level 3 dcl 3-13 set ref 622*
error_msg                22            based           char(256)                level 3 dcl 3-13 set ref 621*
error_report              6            based           structure                level 2 dcl 3-13
error_type               14            based           char(24)                 level 3 in structure "se_info" dcl 3-13 in procedure
                                                                                  "mrds_dsl_where_clause_" set ref 618*
error_type                             parameter       char                     packed unaligned dcl 610 in procedure "error" ref
                                                                                  604 618
exp_fun_data                           based           structure                level 1 unaligned dcl 4-11
expr_ptr                 16            based           pointer                  level 2 dcl 2-67 set ref 235* 278* 515*
fatal_flag                      000124 automatic       bit(1)                   packed unaligned dcl 663 set ref 417* 429* 436* 459
id                        1            based           structure                level 2 in structure "pred_node" packed packed
                                                                                  unaligned dcl 2-12 in procedure
                                                                                  "mrds_dsl_where_clause_"
id                        1            based           structure                level 2 in structure "pred_leaf" packed packed
                                                                                  unaligned dcl 2-67 in procedure
                                                                                  "mrds_dsl_where_clause_" set ref 355 356
info                      6            based           structure                array level 2 dcl 5-50
info_ptr                        000126 automatic       pointer                  initial dcl 665 set ref 445* 665*
lbr                       6            based           pointer                  level 2 dcl 2-12 set ref 328* 337* 352* 355 369 369
                                                                                  403 411 423 445
li                              000130 automatic       structure                level 1 dcl 666 set ref 564 564 586 586
lit_blen                 21     000130 automatic       fixed bin(35,0)          level 2 dcl 666 set ref 542* 549* 571 594
lit_desc_ptr             12            based           pointer                  level 2 dcl 2-67 set ref 235* 277* 548 596*
lit_info                               based           structure                level 1 dcl 6-15
lit_length                5            based           fixed bin(35,0)          level 2 dcl 2-67 set ref 231* 274* 594*
lit_offset               22     000130 automatic       fixed bin(35,0)          level 2 in structure "li" dcl 666 in procedure
                                                                                  "mrds_dsl_where_clause_" set ref 593 597
lit_offset                4            based           fixed bin(35,0)          level 2 in structure "pred_leaf" dcl 2-67
                                                                                  in procedure "mrds_dsl_where_clause_" set ref 231*
                                                                                  273* 593*
lit_ptr                  16     000130 automatic       pointer                  level 2 in structure "li" dcl 666 in procedure
                                                                                  "mrds_dsl_where_clause_" set ref 569 595
lit_ptr                  10            based           pointer                  level 2 in structure "pred_leaf" dcl 2-67
                                                                                  in procedure "mrds_dsl_where_clause_" set ref 235*
                                                                                  276* 595*
lit_val_len              21            based           fixed bin(35,0)          array level 3 dcl 5-50 set ref 571*
lit_val_ptr              22            based           pointer                  array level 3 dcl 5-50 set ref 569*
litd_ptr                 14     000130 automatic       pointer                  level 2 dcl 666 set ref 540* 548* 575 596
lleaf_id                  1            based           structure                level 3 packed packed unaligned dcl 2-12 set ref
                                                                                  320* 355*
loc_index                 1            based           fixed bin(18,0)          level 2 dcl 4-11 ref 273
logical_node                           parameter       bit(1)                   dcl 305 ref 297 318
loud                                   parameter       bit(1)                   dcl 608 in procedure "error" ref 604 617
loud                      7            based           bit(1)                   level 3 in structure "se_info" dcl 3-13 in procedure
                                                                                  "mrds_dsl_where_clause_" set ref 617*
mdbm_secured             20(04)        based           bit(1)                   level 2 packed packed unaligned dcl 7-46 ref 219
message                                parameter       char                     packed unaligned dcl 611 ref 604 621
model_area_ptr                  000112 automatic       pointer                  initial dcl 10-18 set ref 10-18*
model_seg_ptr                   000110 automatic       pointer                  initial dcl 10-13 set ref 10-13*
mrds_data_$max_pred_nodes       000012 external static fixed bin(35,0)          dcl 667 ref 201 207 252 258 496 502 559 559
mrds_debug_$switch              000010 external static bit(9)                   array packed unaligned dcl 12-135 ref 369 369
mrds_dsl_make_literal           000014 constant        entry                    external dcl 669 ref 586
mrds_dsl_make_literal$alloc     000016 constant        entry                    external dcl 670 ref 564
mrds_error_$diff_comp_domain    000020 external static fixed bin(35,0)          dcl 672 set ref 445* 459*
mrds_error_$ill_term            000022 external static fixed bin(35,0)          dcl 674 set ref 363* 506* 525*
mrds_error_$inc_attr_acc        000024 external static fixed bin(35,0)          dcl 675 set ref 219*
mrds_error_$node_stack_ovfl     000026 external static fixed bin(35,0)          dcl 677 set ref 207* 258* 502*
name                                   based           char(32)                 level 2 in structure "rm_attr_info" dcl 7-46
                                                                                  in procedure "mrds_dsl_where_clause_" set ref 445*
                                                                                  445*
name                                   based           char(32)                 level 2 in structure "rm_domain_info" dcl 8-35
                                                                                  in procedure "mrds_dsl_where_clause_" ref 403 403
node_stack                2            based           pointer                  array level 2 dcl 679 set ref 243* 283* 291 292 328
                                                                                  330 337 338 340 340 352 353 358 358 469 469 477*
                                                                                  524 529 548 600*
not_node                               parameter       bit(1)                   dcl 306 ref 297 325
ns                                     based           structure                level 1 dcl 679 set ref 201 252 496
ns_ptr                   10            based           pointer                  level 3 dcl 3-66 set ref 200 201* 202 207 242 242
                                                                                  243 243 251 252* 253 258 282 282 283 283 291 291
                                                                                  292 292 293 328 328 330 330 337 337 338 338 340
                                                                                  340 340 340 343 343 352 352 353 353 358 358 358
                                                                                  358 469 469 469 469 473 473 477 477 495 496* 497
                                                                                  502 506 524 524 529 529 548 548 599 599 600 600
null                                                   builtin function         dcl 682 ref 200 235 251 279 313 327 495 515 547 558
                                                                                  7-65 8-51 10-13 10-18 11-6 11-10 665
number_of_x                            based           fixed bin(35,0)          level 2 dcl 5-50 set ref 559* 560* 562* 562 567 569
                                                                                  571 573 575 578 579 582
op_array                        000014 constant        bit(6)                   initial array packed unaligned dcl 683 ref 315
op_code                   2            based           bit(6)                   level 3 packed packed unaligned dcl 2-12 set ref
                                                                                  315*
operator_id                            parameter       fixed bin(17,0)          dcl 304 ref 297 315
output_pred_ptr                        parameter       pointer                  dcl 703 set ref 288 292*
parent                   20            based           pointer                  level 2 in structure "pred_leaf" dcl 2-67
                                                                                  in procedure "mrds_dsl_where_clause_" set ref 235*
                                                                                  279* 469* 469* 515*
parent                    4            based           pointer                  level 2 in structure "pred_node" dcl 2-12
                                                                                  in procedure "mrds_dsl_where_clause_" set ref 313*
                                                                                  330* 340* 340*
parser_static_info                     based           structure                level 1 dcl 3-66
parser_work_area                       based           area                     dcl 3-63 ref 201 252 496
pl_ptr                          000102 automatic       pointer                  dcl 2-84 set ref 214* 226 228 229 230 231 231 233
                                                                                  233 235 235 235 235 240 243 264* 267 269 270 271
                                                                                  271 273 274 275 276 277 277 278 279 279 283 510*
                                                                                  515 515 515 518 519 520 520 520 593 594 595 596
                                                                                  597 600
pn_ptr                          000100 automatic       pointer                  dcl 2-27 set ref 311* 313 314 315 316 316 320 320
                                                                                  320 323 327 328 330 337 338 340 350 352 353 355
                                                                                  355 356 356 358 363 369 369 369 369 403 403 411
                                                                                  411 423 423 445 445 469 477
pred_leaf                              based           structure                level 1 unaligned dcl 2-67 set ref 214 264 510
pred_node                              based           structure                level 1 unaligned dcl 2-12 set ref 311
psi_ptr                                parameter       pointer                  dcl 3-65 ref 193 200 201 201 202 207 242 242 243 243
                                                                                  248 251 252 252 253 258 282 282 283 283 288 291
                                                                                  291 292 292 293 297 328 328 330 330 337 337 338
                                                                                  338 340 340 340 340 343 343 352 352 353 353 358
                                                                                  358 358 358 469 469 469 469 473 473 477 477 481
                                                                                  495 496 496 497 502 506 524 524 529 529 548 548
                                                                                  599 599 600 600
pwa_ptr                                based           pointer                  level 2 dcl 3-66 ref 201 252 496
rai_ptr                         000104 automatic       pointer                  initial dcl 7-65 set ref 218* 219 219 228 529* 531
                                                                                  542 7-65*
rbr                      10            based           pointer                  level 2 dcl 2-12 set ref 327* 338* 353* 356 369 369
                                                                                  403 411 423 445
rdi_ptr                         000106 automatic       pointer                  initial dcl 8-51 set ref 531* 533 534 539 540 541
                                                                                  8-51*
read_perm                20(02)        based           bit(1)                   level 2 packed packed unaligned dcl 7-46 ref 219
reason_mesg                     000153 automatic       varying char(80)         dcl 704 set ref 419* 431* 438* 445*
rel_index                              parameter       fixed bin(17,0)          dcl 197 ref 193 226
return_value                    000200 automatic       fixed bin(35,0)          initial dcl 706 set ref 445* 706*
rleaf_id                  2(06)        based           structure                level 3 packed packed unaligned dcl 2-12 set ref
                                                                                  320* 356*
rm_attr_info                           based           structure                level 1 dcl 7-46
rm_domain_info                         based           structure                level 1 dcl 8-35
root                      3(12)        based           bit(1)                   level 2 packed packed unaligned dcl 2-12 set ref
                                                                                  291* 316*
rslt_desc                 6            based           bit(36)                  level 2 packed packed unaligned dcl 2-67 set ref
                                                                                  233* 275* 277 520*
se_info                                based           structure                level 1 dcl 3-13
se_info_ptr              72            based           pointer                  level 3 in structure "dbcb" dcl 1-142 in procedure
                                                                                  "mrds_dsl_where_clause_" ref 613
se_info_ptr                     000202 automatic       pointer                  dcl 707 in procedure "mrds_dsl_where_clause_" set
                                                                                  ref 613* 617 618 619 620 621 622
select_area                            based           area                     dcl 11-8 ref 214 264 311 510 559
select_area_ptr                 000116 automatic       pointer                  initial dcl 11-10 set ref 206* 214 257* 264 309* 311
                                                                                  501* 510 559 11-10*
select_area_struct_ptr          000114 automatic       pointer                  initial dcl 11-6 set ref 11-6*
src_ptr                         000130 automatic       pointer                  level 2 dcl 666 set ref 552*
srcd_ptr                  2     000130 automatic       pointer                  level 2 dcl 666 set ref 554*
stack_offset             13            based           fixed bin(17,0)          level 3 in structure "se_info" dcl 3-13 in procedure
                                                                                  "mrds_dsl_where_clause_" set ref 620*
stack_offset                           parameter       fixed bin(17,0)          dcl 609 in procedure "error" ref 604 620
string                                                 builtin function         dcl 708 set ref 320* 320*
sub_err_                        000030 constant        entry                    external dcl 709 ref 445
substr                                                 builtin function         dcl 710 ref 369 597
term                      3(13)        based           bit(1)                   level 2 packed packed unaligned dcl 2-12 set ref
                                                                                  320* 350*
term_type                 3(06)        based           fixed bin(5,0)           level 2 packed packed unaligned dcl 2-12 set ref
                                                                                  323* 358* 363
term_type_array                 000003 constant        fixed bin(17,0)          initial array dcl 712 ref 358
token_start              10            based           fixed bin(17,0)          level 3 dcl 3-13 set ref 619*
top_node                               based           fixed bin(35,0)          level 2 dcl 679 set ref 202* 207 242* 242 243 253*
                                                                                  258 282* 282 283 291 292 293* 328 330 337 338 340
                                                                                  340 343* 343 352 353 358 358 469 469 473* 473 477
                                                                                  497* 502 506 524 529 548 599* 599 600
type                                   based           fixed bin(17,0)          level 2 in structure "pred_leaf" dcl 2-67
                                                                                  in procedure "mrds_dsl_where_clause_" set ref 229*
                                                                                  269* 518*
type                                   based           fixed bin(17,0)          level 2 in structure "pred_node" dcl 2-12
                                                                                  in procedure "mrds_dsl_where_clause_" set ref 314*
user_bit_len             12            based           fixed bin(17,0)          level 2 dcl 8-35 ref 541
user_desc                11            based           bit(36)                  level 2 dcl 8-35 set ref 539
var_id                    1            based           bit(18)                  level 3 packed packed unaligned dcl 2-67 set ref
                                                                                  226* 267* 520*
var_index                              based           fixed bin(17,0)          level 2 dcl 4-11 ref 267
where_clause             10            based           structure                level 2 dcl 3-66
x_pred_leaf                            based           structure                level 1 dcl 5-50 set ref 559
x_pred_leaf_ptr                        parameter       pointer                  dcl 5-65 set ref 481 558 559* 560 562 562 567 567
                                                                                  569 569 571 571 573 573 575 575 578 578 579 579
                                                                                  582 582

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALL_OP                                 internal static bit(6)                   initial packed unaligned dcl 2-44
AND_OP                                 internal static bit(6)                   initial packed unaligned dcl 2-44
ARRAY                                  internal static fixed bin(17,0)          initial dcl 2-60
CURRENT_OP                             internal static bit(6)                   initial packed unaligned dcl 2-44
EQ_OP                                  internal static bit(6)                   initial packed unaligned dcl 2-44
GE_OP                                  internal static bit(6)                   initial packed unaligned dcl 2-44
GT_OP                                  internal static bit(6)                   initial packed unaligned dcl 2-44
IL_TYPE                                internal static char(14)                 initial packed unaligned dcl 3-53
LE_OP                                  internal static bit(6)                   initial packed unaligned dcl 2-44
LT_OP                                  internal static bit(6)                   initial packed unaligned dcl 2-44
NE_OP                                  internal static bit(6)                   initial packed unaligned dcl 2-44
NOT_OP                                 internal static bit(6)                   initial packed unaligned dcl 2-44
OR_OP                                  internal static bit(6)                   initial packed unaligned dcl 2-44
RC_TYPE                                internal static char(12)                 initial packed unaligned dcl 3-33
SC_TYPE                                internal static char(13)                 initial packed unaligned dcl 3-38
SE_TYPE                                internal static char(20)                 initial packed unaligned dcl 3-35
V_C                                    internal static fixed bin(5,0)           initial dcl 2-64
V_V                                    internal static fixed bin(5,0)           initial dcl 2-64
WCE_TYPE                               internal static char(23)                 initial packed unaligned dcl 3-44
WCF_TYPE                               internal static char(21)                 initial packed unaligned dcl 3-47
ag_ptr                                 automatic       pointer                  dcl 2-40
and_group                              based           structure                level 1 unaligned dcl 2-36
compiled_se_info                       based           structure                level 1 dcl 5-15
compiled_se_info_ptr                   automatic       pointer                  dcl 5-44
db_mrds_dsl_close                      defined         bit(9)                   packed unaligned dcl 12-62
db_mrds_dsl_eval_expr                  defined         bit(9)                   packed unaligned dcl 12-62
db_mrds_dsl_gen_srch_prog              defined         bit(9)                   packed unaligned dcl 12-62
db_mrds_dsl_get_token                  defined         bit(9)                   packed unaligned dcl 12-62
db_mrds_dsl_init_res                   defined         bit(9)                   packed unaligned dcl 12-62
db_mrds_dsl_open                       defined         bit(9)                   packed unaligned dcl 12-62
db_mrds_dsl_optimize                   defined         bit(9)                   packed unaligned dcl 12-62
db_mrds_dsl_permute                    defined         bit(9)                   packed unaligned dcl 12-62
db_mrds_dsl_search                     defined         bit(9)                   packed unaligned dcl 12-62
db_mrds_dsl_set_fscope                 defined         bit(9)                   packed unaligned dcl 12-62
db_mrds_dsl_translate                  defined         bit(9)                   packed unaligned dcl 12-62
db_mrds_rst_dmdm                       defined         bit(9)                   packed unaligned dcl 12-62
db_mu_concurrency_control              defined         bit(9)                   packed unaligned dcl 12-62
db_mu_open_iocb_manager                defined         bit(9)                   packed unaligned dcl 12-62
db_mu_open_name_manager                defined         bit(9)                   packed unaligned dcl 12-62
db_mu_retrieve                         defined         bit(9)                   packed unaligned dcl 12-62
db_mu_sec_get_tid                      defined         bit(9)                   packed unaligned dcl 12-62
db_mu_sec_get_tuple                    defined         bit(9)                   packed unaligned dcl 12-62
db_mu_sec_init_res                     defined         bit(9)                   packed unaligned dcl 12-62
db_mus_mod_ubtup                       defined         bit(9)                   packed unaligned dcl 12-62
fixed                                                  builtin function         dcl 664
lip                                    automatic       pointer                  dcl 6-28
model_area                             based           area                     dcl 10-16
model_seg                              based           structure                level 1 dcl 10-9
module                                 internal static structure                level 1 unaligned dcl 12-91
num_ands_init                          automatic       fixed bin(17,0)          dcl 2-41
num_terms_init                         automatic       fixed bin(17,0)          dcl 2-41
pred_array                             based           structure                level 1 unaligned dcl 2-29
pred_ptr                               automatic       pointer                  dcl 2-34
range                                  based           structure                level 1 dcl 9-5
range_ptr                              automatic       pointer                  dcl 9-23
rel                                                    builtin function         dcl 705
select_area_struct                     based           structure                level 1 dcl 11-2
size                                                   builtin function         dcl 10-20
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 711
temp_rel_list                          based           structure                level 1 dcl 5-70
trl_ptr                                automatic       pointer                  dcl 5-77

NAMES DECLARED BY EXPLICIT CONTEXT.
build_attribute                 000360 constant        entry                    external dcl 193
build_expr                      000623 constant        entry                    external dcl 248
build_literal                   001666 constant        entry                    external dcl 481
build_node                      001050 constant        entry                    external dcl 297
error                           002506 constant        entry                    internal dcl 604 ref 207 219 258 363 459 502 506 525
                                                                                  565 587
exit                            002505 constant        label                    dcl 718 ref 624
finish                          001016 constant        entry                    external dcl 288
mrds_dsl_where_clause_          000343 constant        entry                    external dcl 16
set_done                        002204 constant        label                    dcl 552 ref 543
set_li                          000000 constant        label                    array(3) dcl 525 ref 524

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2760        3012    2565        2770
Length      3510    2565        32         462     173           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mrds_dsl_where_clause_              270 external procedure  is an external procedure.  
error                                   internal procedure  shares stack frame of external procedure mrds_dsl_where_clause_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mrds_dsl_where_clause_   000100 pn_ptr                      mrds_dsl_where_clause_
                         000102 pl_ptr                      mrds_dsl_where_clause_
                         000104 rai_ptr                     mrds_dsl_where_clause_
                         000106 rdi_ptr                     mrds_dsl_where_clause_
                         000110 model_seg_ptr               mrds_dsl_where_clause_
                         000112 model_area_ptr              mrds_dsl_where_clause_
                         000114 select_area_struct_ptr      mrds_dsl_where_clause_
                         000116 select_area_ptr             mrds_dsl_where_clause_
                         000120 difference_mesg             mrds_dsl_where_clause_
                         000124 fatal_flag                  mrds_dsl_where_clause_
                         000126 info_ptr                    mrds_dsl_where_clause_
                         000130 li                          mrds_dsl_where_clause_
                         000153 reason_mesg                 mrds_dsl_where_clause_
                         000200 return_value                mrds_dsl_where_clause_
                         000202 se_info_ptr                 mrds_dsl_where_clause_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          ext_entry           op_alloc_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
mrds_dsl_make_literal         mrds_dsl_make_literal$alloc   sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
mrds_data_$max_pred_nodes     mrds_debug_$switch            mrds_error_$diff_comp_domain  mrds_error_$ill_term
mrds_error_$inc_attr_acc      mrds_error_$node_stack_ovfl




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 7   65 000327    8   51 000331   10   13 000332   10   18 000333   11    6 000334   11   10 000335       665 000336
    706 000337        16 000342       193 000351       200 000371       201 000400       202 000416       205 000421
    206 000422       207 000425       214 000470       218 000475       219 000501       226 000544       228 000554
    229 000564       230 000566       231 000571       233 000573       235 000576       240 000603       242 000605
    243 000613       246 000615       248 000616       251 000634       252 000643       253 000661       256 000664
    257 000665       258 000670       264 000732       267 000737       269 000747       270 000751       271 000753
    273 000757       274 000762       275 000764       276 000766       277 000770       278 000772       279 000776
    282 001001       283 001007       286 001011       288 001012       291 001024       292 001035       293 001036
    295 001041       297 001042       308 001061       309 001062       311 001066       313 001073       314 001075
    315 001077       316 001105       318 001111       320 001114       323 001122       325 001124       327 001127
    328 001131       330 001140       333 001147       337 001150       338 001157       340 001166       343 001204
    346 001214       350 001215       352 001217       353 001226       355 001235       356 001242       358 001250
    363 001266       369 001330       403 001365       411 001371       417 001375       418 001377       419 001404
    422 001411       423 001412       429 001415       430 001417       431 001424       434 001431       436 001432
    437 001433       438 001440       445 001445       459 001561       469 001617       473 001637       477 001650
    479 001656       481 001657       495 001677       496 001706       497 001724       500 001727       501 001730
    502 001733       506 001775       510 002035       515 002042       518 002046       519 002050       520 002052
    524 002057       525 002070       529 002125       531 002136       533 002140       534 002143       535 002147
    536 002151       537 002152       539 002154       540 002156       541 002160       542 002162       543 002165
    545 002166       547 002170       548 002172       549 002202       552 002204       554 002210       556 002213
    558 002216       559 002222       560 002236       562 002237       564 002244       565 002261       567 002314
    569 002324       571 002330       573 002337       575 002343       577 002350       578 002353       579 002361
    581 002365       582 002366       584 002374       586 002375       587 002412       593 002453       594 002456
    595 002460       596 002462       597 002464       599 002473       600 002502       602 002504       718 002505
    604 002506       613 002524       615 002531       617 002534       618 002537       619 002544       620 002545
    621 002547       622 002554       624 002556


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
