	COMPILATION LISTING OF SEGMENT truncate
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 05/17/85  1507.9 mst Fri
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
       11 
       12 truncate$trfile: proc (a_dirname, a_ename, a_addrs, a_code);
       13 
       14 /* 	Date last modified and reasons:
       15*   11/84 by Keith Loepere for terminate_.
       16*   7/84 by Keith Loepere to use the new dc_find.
       17*   1/82 BIM to lock dir for write to protect truncate_vtoce from activations.
       18*   11/2/78 by B. Greenberg for raw/effective mode problem (not checking priv_init).
       19*   760630 by L. Scheffler to not audit truncates on copy-on-write segs
       20*   05/31/76 by R. Bratt to call find_$finished
       21*   04/20/76 by R.  Bratt to  check mountedness before truncate
       22*   760309 by L. Scheffler to use info-only entries in dir_control_error
       23*   04/28/75 by Greenberg for NSS
       24*   10/10/74 by Kobziar to call new access_mode entry
       25*   08/24/71 by RHG for page multi-level and to clean up the overlay for zeroing
       26*   07/27/71 by David Vinograd
       27*   06/13/71 by R. Gumpertz to check for negative addrs
       28*   06/12/71 by R. Gumpertz to add zeroing of last page after addrs
       29*   and to check fpage properly against seg length
       30*   and to eliminate accessing of a_addrs while
       31*   a directory is locked
       32* */
       33 
       34 
       35 /* Parameters */
       36 
       37 dcl  a_addrs			fixed bin (17) parameter;
       38 dcl  a_code			fixed bin (35) parameter;
       39 dcl  a_dirname			char (*) parameter;
       40 dcl  a_ename			char (*) parameter;
       41 dcl  a_ep				ptr parameter;
       42 dcl  a_segptr			ptr parameter;
       43 
       44 /* Variables */
       45 
       46 dcl  addrs			fixed bin (17);
       47 dcl  by_name			bit (1) aligned init ("0"b);
       48 dcl  code				fixed bin (35);
       49 dcl  ename			char (32);
       50 dcl  esw				fixed bin (17);
       51 dcl  fpage			fixed bin (17);
       52 dcl  overlay_size			fixed bin;
       53 dcl  parent			char (168);
       54 dcl  segptr			ptr;
       55 dcl  write_lock			bit (36) aligned init ((36)"1"b);
       56 
       57 /* Based */
       58 
       59 dcl  overlay			bit (overlay_size) based aligned; /* This is used to get at the words to be zeroed */
       60 
       61 /* External */
       62 
       63 dcl  error_table_$argerr		fixed bin (35) external;
       64 dcl  error_table_$boundviol		fixed bin (35) external;
       65 dcl  error_table_$dirseg		fixed bin (35) external;
       66 dcl  error_table_$rqover		fixed bin (35) external;
       67 dcl  pds$processid			bit (36) aligned ext;
       68 
       69 /* Entries */
       70 
       71 dcl  get_kstep			entry (fixed bin (18), ptr, fixed bin (35));
       72 dcl  initiate			entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
       73 dcl  lock$dir_unlock		entry (ptr);
       74 dcl  mountedp			entry (bit (36) aligned) returns (fixed bin (35));
       75 dcl  sum$dirmod			entry (ptr);
       76 dcl  terminate_$noname		entry (ptr, fixed bin (35));
       77 dcl  truncate_vtoce			entry (ptr, fixed bin, fixed bin (35));
       78 
       79 /* Misc */
       80 
       81 dcl  (addrel, baseno, divide, fixed, null, ptr) builtin;
       82 
       83 dcl  out_of_bounds			condition;
       84 
       85 	esw = 0;					/* set entry point switch */
       86 	code = 0;
       87 	addrs = a_addrs;				/* copy the args */
       88 	parent = a_dirname;				/* copy directory name */
       89 	ename = a_ename;				/* copy entry name */
       90 	call dc_find$obj_truncate (parent, ename, ep, code); /* get pointer to branch + lock directory */
       91 	dp = ptr (ep, 0);
       92 	if code ^= 0 then go to finale;
       93 	by_name = "1"b;
       94 	go to join;				/* transfer to common code */
       95 
       96 trseg: entry (a_segptr, a_addrs, a_code);
       97 
       98 	esw = 1;					/* set entry point switch */
       99 	code = 0;
      100 	addrs = a_addrs;				/* copy the addrs given */
      101 	segptr = ptr (a_segptr, 0);			/* copy argument */
      102 
      103 	call get_kstep (fixed (baseno (segptr)), kstep, code);
      104 	if code ^= 0 then go to finale;
      105 
      106 	if kste.priv_init then call dc_find$obj_truncate_raw_ptr (segptr, ep, code); /* get pointer to branch + lock directory */
      107 	else call dc_find$obj_truncate_ptr (segptr, ep, code); /* get pointer to branch + lock directory */
      108 	if code ^= 0 then go to finale;
      109 	dp = ptr (ep, 0);
      110 
      111 join:	if ep -> entry.dirsw then do;			/* truncating directories not allowed */
      112 	     code = error_table_$dirseg;
      113 	     go to unlock;
      114 	end;
      115 
      116 	if addrs < 0 then do;			/* check for negative length specified */
      117 	     code = error_table_$argerr;
      118 	     go to unlock;
      119 	end;
      120 						/* check for length too big */
      121 
      122 	fpage = divide (addrs + 1023, 1024, 17, 0);	/* get number of first page to be truncated */
      123 
      124 	go to join1;
      125 
      126 trentry: entry (a_ep);
      127 
      128 	esw = 2;
      129 	fpage = 0;
      130 	ep = a_ep;
      131 	code = 0;
      132 	dp = ptr (ep, 0);
      133 join1:
      134 
      135 	code = mountedp (dir.sons_lvid);
      136 	if code = 0
      137 	then do;
      138 	     dir.modify = pds$processid;		/* Mark dir inconsistent */
      139 
      140 	     call truncate_vtoce (ep, fpage, code);	/* Truncate the vtoce/aste */
      141 
      142 	     if code ^= 0 then if code = error_table_$rqover then code = 0; /* ignore rqo */
      143 	end;
      144 	if esw = 2 then return;			/* if deleting, return */
      145 
      146 
      147 	dir.modify = "0"b;
      148 	call sum$dirmod (dp);
      149 	if by_name
      150 	then call dc_find$finished (dp, "1"b);
      151 	else call lock$dir_unlock (dp);		/* unlock the directory */
      152 
      153 /* 	The following code zeros out the last page of the segment starting
      154*   at addrs. This is so that truncating will be to the word, rather than
      155*   to the page.
      156*   */
      157 
      158 	if code ^= 0 then go to finale;
      159 
      160 	on condition (out_of_bounds) go to boundviol;	/* Attempt to trunc beyond current length
      161*						   may cause oob here */
      162 	overlay_size = (fpage * 1024 - addrs) * 36;	/* compute n bits to zero */
      163 	if overlay_size ^= 0 then do;			/* dont bother if none to zero */
      164 	     if esw = 0 then do;			/* if entered without ptr, we must get one */
      165 		call initiate (parent, ename, "", 0, 1, segptr, code);
      166 		if segptr = null then goto finale;
      167 		code = 0;				/* forget any segknowns */
      168 	     end;
      169 	     addrel (segptr, addrs) -> overlay = ""b;	/* clear the words */
      170 	     if esw = 0 then call terminate_$noname (segptr, code); /* terminate the pointer if we had to get one */
      171 	end;
      172 
      173 finale:	a_code = code;
      174 	return;
      175 
      176 unlock:	if dir.modify then dir.modify = "0"b;
      177 	if by_name
      178 	then call dc_find$finished (dp, "1"b);
      179 	else call lock$dir_unlock (dp);
      180 	go to finale;
      181 
      182 boundviol:
      183 	a_code = error_table_$boundviol;
      184 	return;
      185 
      186  /* BEGIN include file dc_find_dcls.incl.pl1 */
  1     2 
  1     3 /* Calling sequences for dc_find.  Keith Loepere, June 1984. */
  1     4 /* Added a few more, October 1984. */
  1     5 /* 85-05-08, EJ Sharpe: added obj_delete_uid, obj_status_read_uid, and obj_status_read_raw_uid */
  1     6 /* 85-05-15, EJ Sharpe: changed dir_write_raw_uid to mdir_set_quota_uid */
  1     7 
  1     8 /* format: style4,indattr,ifthenstmt,ifthen,idind35,^indcomtxt */
  1     9 
  1    10 dcl  DC_FIND_CHASE			fixed bin (1) static options (constant) init (1);
  1    11 dcl  DC_FIND_NO_CHASE		fixed bin (1) static options (constant) init (0);
  1    12 dcl  DC_FIND_NO_UNLOCK_DIR		bit (1) aligned static options (constant) init ("0"b);
  1    13 dcl  DC_FIND_UNLOCK_DIR		bit (1) aligned static options (constant) init ("1"b);
  1    14 
  1    15 dcl  dc_find$dir_for_append		entry (char (168), char (32), fixed bin (1), ptr, ptr, fixed bin (35));
  1    16 dcl  dc_find$dir_for_append_raw	entry (char (168), char (32), fixed bin (1), ptr, ptr, fixed bin (35));
  1    17 dcl  dc_find$dir_for_retrieve_append	entry (char (168), char (32), fixed bin (1), ptr, ptr, ptr, fixed bin (35));
  1    18 
  1    19 dcl  dc_find$dir_initiate		entry (char (168), ptr, fixed bin (35));
  1    20 
  1    21 dcl  dc_find$dir_move_quota		entry (char (168), ptr, ptr, fixed bin (35));
  1    22 
  1    23 dcl  dc_find$dir_read		entry (char (168), ptr, fixed bin (35));
  1    24 dcl  dc_find$dir_read_priv		entry (char (168), ptr, fixed bin (35));
  1    25 
  1    26 dcl  dc_find$dir_reclassify		entry (char (168), ptr, ptr, ptr, fixed bin (35));
  1    27 
  1    28 dcl  dc_find$dir_salvage		entry (char (168), bit (36) aligned, ptr, fixed bin (35));
  1    29 
  1    30 dcl  dc_find$dir_write		entry (char (168), fixed bin (18) uns, ptr, fixed bin (35));
  1    31 dcl  dc_find$dir_write_priv		entry (char (168), fixed bin (18) uns, ptr, fixed bin (35));
  1    32 
  1    33 dcl  dc_find$finished		entry (ptr, bit (1) aligned);
  1    34 
  1    35 dcl  dc_find$link_target		entry (char (168), char (32), fixed bin (35));
  1    36 
  1    37 dcl  dc_find$mdir_set_quota_uid	entry ((0:15) bit (36) aligned, char (168), fixed bin (18) uns, ptr, ptr, fixed bin (35));
  1    38 
  1    39 dcl  dc_find$obj_access_write		entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  1    40 dcl  dc_find$obj_access_write_priv	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  1    41 
  1    42 dcl  dc_find$obj_attributes_read	entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    43 dcl  dc_find$obj_attributes_read_ptr	entry (ptr, ptr, fixed bin (35));
  1    44 
  1    45 dcl  dc_find$obj_attributes_write	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  1    46 dcl  dc_find$obj_attributes_write_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  1    47 
  1    48 dcl  dc_find$obj_bc_delta_write	entry (char (168), char (32), fixed bin (24), ptr, fixed bin (35));
  1    49 dcl  dc_find$obj_bc_delta_write_ptr	entry (ptr, fixed bin (24), ptr, fixed bin (35));
  1    50 dcl  dc_find$obj_bc_write		entry (char (168), char (32), fixed bin (24), ptr, fixed bin (35));
  1    51 dcl  dc_find$obj_bc_write_ptr		entry (ptr, fixed bin (24), ptr, fixed bin (35));
  1    52 
  1    53 dcl  dc_find$obj_delete		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    54 dcl  dc_find$obj_delete_priv		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    55 dcl  dc_find$obj_delete_uid		entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  1    56 dcl  dc_find$obj_delete_priv_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  1    57 dcl  dc_find$obj_delete_ptr		entry (ptr, ptr, fixed bin (35));
  1    58 
  1    59 dcl  dc_find$obj_existence_ptr	entry (ptr, ptr, fixed bin (35));
  1    60 
  1    61 dcl  dc_find$obj_for_audit		entry (char (168), char (32), ptr, fixed bin (35));
  1    62 
  1    63 dcl  dc_find$obj_initiate		entry (char (168), char (32), ptr, fixed bin (35));
  1    64 dcl  dc_find$obj_initiate_for_linker_dp entry (ptr, char (32), ptr, fixed bin (35));
  1    65 dcl  dc_find$obj_initiate_raw		entry (char (168), char (32), ptr, fixed bin (35));
  1    66 
  1    67 dcl  dc_find$obj_linkage_ring_ptr	entry (ptr, fixed bin (35));
  1    68 
  1    69 dcl  dc_find$obj_modes_ptr		entry (ptr, bit (36) aligned, bit (36) aligned, (3) fixed bin (3), fixed bin (35));
  1    70 
  1    71 dcl  dc_find$obj_reclassify		entry (char (168), char (32), ptr, ptr, fixed bin (35));
  1    72 
  1    73 dcl  dc_find$obj_status_attributes_read entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    74 
  1    75 dcl  dc_find$obj_status_read		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    76 dcl  dc_find$obj_status_read_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  1    77 dcl  dc_find$obj_status_read_priv	entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    78 dcl  dc_find$obj_status_read_priv_ptr	entry (ptr, ptr, fixed bin (35));
  1    79 dcl  dc_find$obj_status_read_priv_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  1    80 dcl  dc_find$obj_status_read_raw_uid	entry ((0:15) bit (36) aligned, char (168), char (32), ptr, fixed bin (35));
  1    81 dcl  dc_find$obj_status_read_ptr	entry (ptr, ptr, fixed bin (35));
  1    82 
  1    83 dcl  dc_find$obj_status_write		entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  1    84 dcl  dc_find$obj_status_write_priv	entry (char (168), char (32), fixed bin (1), fixed bin (18) uns, ptr, fixed bin (35));
  1    85 dcl  dc_find$obj_status_write_priv_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  1    86 dcl  dc_find$obj_status_write_ptr	entry (ptr, fixed bin (18) uns, ptr, fixed bin (35));
  1    87 
  1    88 dcl  dc_find$obj_terminate		entry (char (168), char (32), fixed bin (1), ptr, fixed bin (35));
  1    89 dcl  dc_find$obj_terminate_ptr	entry (ptr, ptr, fixed bin (35));
  1    90 
  1    91 dcl  dc_find$obj_truncate		entry (char (168), char (32), ptr, fixed bin (35));
  1    92 dcl  dc_find$obj_truncate_ptr		entry (ptr, ptr, fixed bin (35));
  1    93 dcl  dc_find$obj_truncate_raw_ptr	entry (ptr, ptr, fixed bin (35));
  1    94 
  1    95 dcl  dc_find$obj_volume_retrieve	entry (char (168), char (32), ptr, ptr, fixed bin (35));
  1    96 
  1    97 dcl  dc_find$seg_fault		entry (ptr, ptr, fixed bin (35));
  1    98 
  1    99 /* END include file dc_find_dcls.incl.pl1 */
      186 
      187  /*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
  2     2 
  2     3 
  2     4 /* Template for an entry. Length = 38 words */
  2     5 
  2     6 dcl  ep ptr;
  2     7 
  2     8 dcl 1 entry based (ep) aligned,
  2     9 
  2    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
  2    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
  2    12 
  2    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
  2    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
  2    15 
  2    16     2 uid bit (36),					/* unique id of entry */
  2    17 
  2    18     2 dtem bit (36),				/* date-time entry modified */
  2    19 
  2    20     (2 bs bit (1),					/* branch switch = 1 if branch */
  2    21     2 pad0 bit (17),
  2    22     2 nnames fixed bin (17),				/* number of names for this entry */
  2    23 
  2    24     2 name_frp bit (18),				/* rel pointer to start of name list */
  2    25     2 name_brp bit (18),				/* rel pointer to end of name list */
  2    26 
  2    27     2 author,					/* user who created branch */
  2    28       3 pers_rp bit (18),				/* name of user who created branch */
  2    29       3 proj_rp bit (18),				/* project of user who created branch */
  2    30 
  2    31       3 tag char (1),				/* tag of user who created branch */
  2    32       3 pad1 char (3),
  2    33 
  2    34     2 primary_name bit (504),				/* first name on name list */
  2    35 
  2    36     2 dtd bit (36),					/* date time dumped */
  2    37 
  2    38     2 pad2 bit (36),
  2    39 
  2    40 
  2    41 /* the declarations below are for branch only */
  2    42 
  2    43 
  2    44     2 pvid bit (36),				/* physical volume id */
  2    45 
  2    46     2 vtocx fixed bin (17),				/* vtoc entry index */
  2    47     2 pad3 bit (18),
  2    48 
  2    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
  2    50     2 oosw bit (1),					/* out of service switch  on = 1 */
  2    51     2 per_process_sw bit (1),				/* indicates segment is per process */
  2    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
  2    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
  2    54     2 multiple_class bit (1),				/* segment has multiple security classes */
  2    55     2 audit_flag bit (1),				/* segment must be audited for security */
  2    56     2 security_oosw bit (1),				/* security out of service switch */
  2    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
  2    58     2 master_dir bit (1),				/* TRUE for master directory */
  2    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
  2    60     2 pad4 bit (11),
  2    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
  2    62 
  2    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
  2    64 
  2    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
  2    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
  2    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
  2    68 
  2    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
  2    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
  2    71 
  2    72     2 bc_author,					/* user who last set the bit count */
  2    73       3 pers_rp bit (18),				/* name of user who set the bit count */
  2    74       3 proj_rp bit (18),				/* project of user who set the bit count */
  2    75 
  2    76       3 tag char (1),				/* tag of user who set the bit count */
  2    77       3 pad5 bit (2),
  2    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
  2    79 
  2    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
  2    81 
  2    82     2 pad6 bit (36),
  2    83 
  2    84     2 checksum bit (36),				/* checksum from dtd */
  2    85 
  2    86     2 owner bit (36);				/* uid of containing directory */
  2    87 
  2    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
      187 
      188  /*	BEGIN INCLUDE FILE ... dir_header.incl.pl1 */
  3     2 /* Modified 8/74 for NSS */
  3     3 /* Modified 8/76 to add version number and hash table rel pointer for variable hash table sizes */
  3     4 /* Modified 3/82 BIM for change pclock */
  3     5 /* format: style3 */
  3     6 
  3     7 /* Template for the directory header. Length = 64 words. */
  3     8 
  3     9 dcl  dp ptr;
  3    10 
  3    11 dcl 1 dir based (dp) aligned,
  3    12 
  3    13    2 modify bit (36),				/* Process ID of last modifier */
  3    14    2 type bit (18) unaligned,			/* type of object = dir header */
  3    15    2 size fixed bin (17) unaligned,			/* size of header in words */
  3    16     2 dtc (3),					/* date-time checked by salvager array */
  3    17       3 date bit (36),				/* the date */
  3    18       3 error bit (36),				/* what errors were discovered */
  3    19 
  3    20     2 uid bit (36),					/* uid of the directory           - copied from branch */
  3    21 
  3    22     2 pvid bit (36),				/* phys vol id of the dir         - copied from branch */
  3    23 
  3    24     2 sons_lvid bit (36),				/* log vol id for inf non dir seg - copied from branch */
  3    25 
  3    26     2 access_class bit (72),				/* security attributes of dir     - copied from branch */
  3    27 
  3    28     (2 vtocx fixed bin (17),				/* vtoc entry index of the dir    - copied from branch */
  3    29     2 version_number fixed bin (17),			/* version number of header */
  3    30 
  3    31     2 entryfrp bit (18),				/* rel ptr to beginning of entry list */
  3    32     2 pad2 bit (18),
  3    33 
  3    34     2 entrybrp bit (18),				/* rel ptr to end of entry list */
  3    35     2 pad3 bit (18),
  3    36 
  3    37     2 pers_frp bit (18),				/* rel ptr to start of person name list */
  3    38     2 proj_frp bit (18),				/* rel ptr to start of project name list */
  3    39 
  3    40     2 pers_brp bit (18),				/* rel ptr to end of person name list */
  3    41     2 proj_brp bit (18),				/* rel ptr to end of project name list */
  3    42 
  3    43     2 seg_count fixed bin (17),			/* number of non-directory branches */
  3    44     2 dir_count fixed bin (17),			/* number of directory branches */
  3    45 
  3    46     2 lcount fixed bin (17),				/* number of links */
  3    47     2 acle_total fixed bin (17),			/* total number of ACL entries in directory */
  3    48 
  3    49     2 arearp bit (18),				/* relative pointer to beginning of allocation area */
  3    50     2 per_process_sw bit (1),				/* indicates dir contains per process segments */
  3    51     2 master_dir bit (1),				/* TRUE if this is a master dir */
  3    52     2 force_rpv bit (1),				/* TRUE if segs must be on RPV */
  3    53     2 rehashing bit (1),				/* TRUE if hash table is being constructed */
  3    54     2 pad4 bit (14),
  3    55 
  3    56     2 iacl_count (0:7),
  3    57       3 seg fixed bin (17),				/* number of initial acl entries for segs */
  3    58       3 dir fixed bin (17),				/* number of initial acl entries for dir */
  3    59 
  3    60     2 iacl (0:7),					/* pointer to initial ACLs for each ring */
  3    61       3 seg_frp bit (18),				/* rel ptr to start of initial ACL for segs */
  3    62       3 seg_brp bit (18),				/* rel ptr to end of initial ACL for segs */
  3    63 
  3    64       3 dir_frp bit (18),				/* rel ptr to start of initial for dirs */
  3    65       3 dir_brp bit (18),				/* rel ptr to end of initial ACL for dirs */
  3    66 
  3    67     2 htsize fixed bin (17),				/* size of hash table */
  3    68     2 hash_table_rp bit (18),				/* rel ptr to start of hash table */
  3    69 
  3    70     2 htused fixed bin (17),				/* no. of used places in hash table */
  3    71     2 pad6 fixed bin (17),
  3    72 
  3    73     2 tree_depth fixed bin (17),			/* number of levels from root of this dir */
  3    74     2 pad7 bit (18)) unaligned,
  3    75 
  3    76     2 dts bit (36),					/* date-time directory last salvaged */
  3    77 
  3    78     2 master_dir_uid bit (36),			/* uid of superior master dir */
  3    79     2 change_pclock fixed bin (35),			/* up one each call to sum$dirmod */
  3    80     2 pad8 (11) bit (36),				/* pad to make it a 64 word header */
  3    81     2 checksum bit (36),				/* checksummed from uid on */
  3    82     2 owner bit (36);				/* uid of parent dir */
  3    83 
  3    84 dcl version_number_2 fixed bin int static options (constant) init (2);
  3    85 
  3    86 /*	END INCLUDE FILE ... dir_header.incl.pl1 */
      188 
      189  /*  BEGIN INCLUDE FILE  - - - kst.incl.pl1 - - - 
  4     2*
  4     3*Modified March 1976 by R. Bratt 
  4     4*Modified November 1984 to remove hdr, Keith Loepere. */
  4     5 
  4     6 dcl  pds$kstp ext ptr,
  4     7     (kstp, kstep) ptr;
  4     8 
  4     9 dcl 1 kst aligned based (kstp),			/* KST header declaration */
  4    10     2 lowseg fixed bin (17),				/* lowest segment number described by kst */
  4    11     2 highseg fixed bin (17),				/* highest segment number described by kst */
  4    12     2 highest_used_segno fixed bin (17),		/* highest segment number yet used  */
  4    13     2 lvs fixed bin (8),				/* number of private LVs this process is connected to */
  4    14     2 time_of_bootload fixed bin (71),			/* bootload time during prelinking */
  4    15     2 garbage_collections fixed bin (17) unaligned,	/* KST garbage collections */
  4    16     2 entries_collected fixed bin (17) unaligned,		/* KST entries recovered by garbage collection */
  4    17     2 free_list bit (18) unaligned,			/* relative pointer to first free kste */
  4    18     2 prelinked_ring (7) bit (1) unaligned,		/* rings prelinked in process */
  4    19     2 template bit (1) unaligned,			/* this is a template kst if set */
  4    20     2 allow_256K_connect bit (1) unaligned,		/* can use 256K segments */
  4    21     2 unused_2 bit (9) unaligned,
  4    22     2 uid_hash_bucket (0 : 127) bit (18) unaligned,	/* hash buckets */
  4    23     2 kst_entry (0 refer (kst.lowseg):0 refer (kst.highseg)) aligned like kste, /* kst entries */
  4    24     2 lv (1:256) bit (36),				/* private logical volume connection list */
  4    25     2 end_of_kst bit (36);
  4    26 
  4    27 dcl 1 kste based (kstep) aligned,			/* KST entry declaration */
  4    28     2 fp bit (18) unaligned,				/* forward rel pointer */
  4    29     2 segno fixed bin (17) unaligned,			/* segment number of this kste */
  4    30     2 usage_count (0:7) fixed bin (8) unaligned,		/* outstanding initiates/ring */
  4    31     2 entryp ptr unaligned,				/* branch pointer */
  4    32     2 uid bit (36) aligned,				/* unique identifier */
  4    33     2 access_information unaligned,
  4    34       3 dtbm bit (36),				/* date time branch modified */
  4    35       3 extended_access bit (33),			/* extended access from the branch */
  4    36       3 access bit (3),				/* rew */
  4    37       3 ex_rb (3) bit (3),				/* ring brackets from branch */
  4    38     2 pad1 bit (3) unaligned,
  4    39     2 flags unaligned,
  4    40       3 dirsw bit (1),				/* directory switch */
  4    41       3 allow_write bit (1),				/* set if initiated with write permission */
  4    42       3 priv_init bit (1),				/* privileged initiation */
  4    43       3 tms bit (1),				/* transparent modification switch */
  4    44       3 tus bit (1),				/* transparent usage switch */
  4    45       3 tpd bit (1),				/* transparent paging device switch */
  4    46       3 audit bit (1),				/* audit switch */
  4    47       3 explicit_deact_ok bit (1),			/* set if I am willing to have a user force deactivate */
  4    48       3 pad bit (3),
  4    49     2 infcount fixed bin (12) unaligned;		/* _i_f dirsw _t_h_e_n inferior count _e_l_s_e lv index */
  4    50 
  4    51 /*  END INCLUDE FILE - - - - - - - - - - - - kst.incl.pl1 - - - - - - - - - - - - */
      189 
      190      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/17/85  1456.7  truncate.pl1                      >spec>hard>41-27>truncate.pl1
186          1    05/17/85  1437.3  dc_find_dcls.incl.pl1             >spec>hard>41-27>dc_find_dcls.incl.pl1
187          2    04/29/76  1100.6  dir_entry.incl.pl1                >ldd>include>dir_entry.incl.pl1
188          3    05/24/82  1005.0  dir_header.incl.pl1               >ldd>include>dir_header.incl.pl1
189          4    01/30/85  1523.9  kst.incl.pl1                      >ldd>include>kst.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_addrs                                parameter       fixed bin(17,0)          dcl 37 ref 12 87 96 100
a_code                                 parameter       fixed bin(35,0)          dcl 38 set ref 12 96 173* 182*
a_dirname                              parameter       char                     unaligned dcl 39 ref 12 88
a_ename                                parameter       char                     unaligned dcl 40 ref 12 89
a_ep                                   parameter       pointer                  dcl 41 ref 126 130
a_segptr                               parameter       pointer                  dcl 42 ref 96 101
addrel                                                 builtin function         dcl 81 ref 169
addrs                           000100 automatic       fixed bin(17,0)          dcl 46 set ref 87* 100* 116 122 162 169
baseno                                                 builtin function         dcl 81 ref 103 103
by_name                         000101 automatic       bit(1)                   initial dcl 47 set ref 47* 93* 149 177
code                            000102 automatic       fixed bin(35,0)          dcl 48 set ref 86* 90* 92 99* 103* 104 106* 107* 108
                                                                                  112* 117* 131* 133* 136 140* 142 142 142* 158 165*
                                                                                  167* 170* 173
dc_find$finished                000040 constant        entry                    external dcl 1-33 ref 149 177
dc_find$obj_truncate            000042 constant        entry                    external dcl 1-91 ref 90
dc_find$obj_truncate_ptr        000044 constant        entry                    external dcl 1-92 ref 107
dc_find$obj_truncate_raw_ptr    000046 constant        entry                    external dcl 1-93 ref 106
dir                                    based           structure                level 1 dcl 3-11
dirsw                    32            based           bit(1)                   level 2 packed unaligned dcl 2-8 ref 111
divide                                                 builtin function         dcl 81 ref 122
dp                              000204 automatic       pointer                  dcl 3-9 set ref 91* 109* 132* 133 138 147 148* 149*
                                                                                  151* 176 176 177* 179*
ename                           000103 automatic       char(32)                 unaligned dcl 49 set ref 89* 90* 165*
entry                                  based           structure                level 1 dcl 2-8
ep                              000202 automatic       pointer                  dcl 2-6 set ref 90* 91 106* 107* 109 111 130* 132
                                                                                  140*
error_table_$argerr             000010 external static fixed bin(35,0)          dcl 63 ref 117
error_table_$boundviol          000012 external static fixed bin(35,0)          dcl 64 ref 182
error_table_$dirseg             000014 external static fixed bin(35,0)          dcl 65 ref 112
error_table_$rqover             000016 external static fixed bin(35,0)          dcl 66 ref 142
esw                             000113 automatic       fixed bin(17,0)          dcl 50 set ref 85* 98* 128* 144 164 170
fixed                                                  builtin function         dcl 81 ref 103 103
flags                     7(12)        based           structure                level 2 packed unaligned dcl 4-27
fpage                           000114 automatic       fixed bin(17,0)          dcl 51 set ref 122* 129* 140* 162
get_kstep                       000022 constant        entry                    external dcl 71 ref 103
initiate                        000024 constant        entry                    external dcl 72 ref 165
kste                                   based           structure                level 1 dcl 4-27
kstep                           000206 automatic       pointer                  dcl 4-6 set ref 103* 106
lock$dir_unlock                 000026 constant        entry                    external dcl 73 ref 151 179
modify                                 based           bit(36)                  level 2 dcl 3-11 set ref 138* 147* 176 176*
mountedp                        000030 constant        entry                    external dcl 74 ref 133
null                                                   builtin function         dcl 81 ref 166
out_of_bounds                   000174 stack reference condition                dcl 83 ref 160
overlay                                based           bit                      dcl 59 set ref 169*
overlay_size                    000115 automatic       fixed bin(17,0)          dcl 52 set ref 162* 163 169
parent                          000116 automatic       char(168)                unaligned dcl 53 set ref 88* 90* 165*
pds$processid                   000020 external static bit(36)                  dcl 67 ref 138
priv_init                 7(14)        based           bit(1)                   level 3 packed unaligned dcl 4-27 ref 106
ptr                                                    builtin function         dcl 81 ref 91 101 109 132
segptr                          000170 automatic       pointer                  dcl 54 set ref 101* 103 103 106* 107* 165* 166 169
                                                                                  170*
sons_lvid                12            based           bit(36)                  level 2 dcl 3-11 set ref 133*
sum$dirmod                      000032 constant        entry                    external dcl 75 ref 148
terminate_$noname               000034 constant        entry                    external dcl 76 ref 170
truncate_vtoce                  000036 constant        entry                    external dcl 77 ref 140
write_lock                      000172 automatic       bit(36)                  initial dcl 55 set ref 55*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
DC_FIND_CHASE                          internal static fixed bin(1,0)           initial dcl 1-10
DC_FIND_NO_CHASE                       internal static fixed bin(1,0)           initial dcl 1-11
DC_FIND_NO_UNLOCK_DIR                  internal static bit(1)                   initial dcl 1-12
DC_FIND_UNLOCK_DIR                     internal static bit(1)                   initial dcl 1-13
dc_find$dir_for_append          000000 constant        entry                    external dcl 1-15
dc_find$dir_for_append_raw      000000 constant        entry                    external dcl 1-16
dc_find$dir_for_retrieve_append 000000 constant        entry                    external dcl 1-17
dc_find$dir_initiate            000000 constant        entry                    external dcl 1-19
dc_find$dir_move_quota          000000 constant        entry                    external dcl 1-21
dc_find$dir_read                000000 constant        entry                    external dcl 1-23
dc_find$dir_read_priv           000000 constant        entry                    external dcl 1-24
dc_find$dir_reclassify          000000 constant        entry                    external dcl 1-26
dc_find$dir_salvage             000000 constant        entry                    external dcl 1-28
dc_find$dir_write               000000 constant        entry                    external dcl 1-30
dc_find$dir_write_priv          000000 constant        entry                    external dcl 1-31
dc_find$link_target             000000 constant        entry                    external dcl 1-35
dc_find$mdir_set_quota_uid      000000 constant        entry                    external dcl 1-37
dc_find$obj_access_write        000000 constant        entry                    external dcl 1-39
dc_find$obj_access_write_priv   000000 constant        entry                    external dcl 1-40
dc_find$obj_attributes_read     000000 constant        entry                    external dcl 1-42
dc_find$obj_attributes_read_ptr 000000 constant        entry                    external dcl 1-43
dc_find$obj_attributes_write    000000 constant        entry                    external dcl 1-45
dc_find$obj_attributes_write_ptr
                                000000 constant        entry                    external dcl 1-46
dc_find$obj_bc_delta_write      000000 constant        entry                    external dcl 1-48
dc_find$obj_bc_delta_write_ptr  000000 constant        entry                    external dcl 1-49
dc_find$obj_bc_write            000000 constant        entry                    external dcl 1-50
dc_find$obj_bc_write_ptr        000000 constant        entry                    external dcl 1-51
dc_find$obj_delete              000000 constant        entry                    external dcl 1-53
dc_find$obj_delete_priv         000000 constant        entry                    external dcl 1-54
dc_find$obj_delete_priv_uid     000000 constant        entry                    external dcl 1-56
dc_find$obj_delete_ptr          000000 constant        entry                    external dcl 1-57
dc_find$obj_delete_uid          000000 constant        entry                    external dcl 1-55
dc_find$obj_existence_ptr       000000 constant        entry                    external dcl 1-59
dc_find$obj_for_audit           000000 constant        entry                    external dcl 1-61
dc_find$obj_initiate            000000 constant        entry                    external dcl 1-63
dc_find$obj_initiate_for_linker_dp
                                000000 constant        entry                    external dcl 1-64
dc_find$obj_initiate_raw        000000 constant        entry                    external dcl 1-65
dc_find$obj_linkage_ring_ptr    000000 constant        entry                    external dcl 1-67
dc_find$obj_modes_ptr           000000 constant        entry                    external dcl 1-69
dc_find$obj_reclassify          000000 constant        entry                    external dcl 1-71
dc_find$obj_status_attributes_read
                                000000 constant        entry                    external dcl 1-73
dc_find$obj_status_read         000000 constant        entry                    external dcl 1-75
dc_find$obj_status_read_priv    000000 constant        entry                    external dcl 1-77
dc_find$obj_status_read_priv_ptr
                                000000 constant        entry                    external dcl 1-78
dc_find$obj_status_read_priv_uid
                                000000 constant        entry                    external dcl 1-79
dc_find$obj_status_read_ptr     000000 constant        entry                    external dcl 1-81
dc_find$obj_status_read_raw_uid 000000 constant        entry                    external dcl 1-80
dc_find$obj_status_read_uid     000000 constant        entry                    external dcl 1-76
dc_find$obj_status_write        000000 constant        entry                    external dcl 1-83
dc_find$obj_status_write_priv   000000 constant        entry                    external dcl 1-84
dc_find$obj_status_write_priv_ptr
                                000000 constant        entry                    external dcl 1-85
dc_find$obj_status_write_ptr    000000 constant        entry                    external dcl 1-86
dc_find$obj_terminate           000000 constant        entry                    external dcl 1-88
dc_find$obj_terminate_ptr       000000 constant        entry                    external dcl 1-89
dc_find$obj_volume_retrieve     000000 constant        entry                    external dcl 1-95
dc_find$seg_fault               000000 constant        entry                    external dcl 1-97
kst                                    based           structure                level 1 dcl 4-9
kstp                                   automatic       pointer                  dcl 4-6
pds$kstp                               external static pointer                  dcl 4-6
version_number_2                       internal static fixed bin(17,0)          initial dcl 3-84

NAMES DECLARED BY EXPLICIT CONTEXT.
boundviol                       000557 constant        label                    dcl 182 ref 160
finale                          000525 constant        label                    dcl 173 ref 92 104 108 158 166 180
join                            000234 constant        label                    dcl 111 ref 94
join1                           000301 constant        label                    dcl 133 ref 124
trentry                         000261 constant        entry                    external dcl 126
trseg                           000130 constant        entry                    external dcl 96
truncate$trfile                 000033 constant        entry                    external dcl 12
unlock                          000530 constant        label                    dcl 176 ref 113 118

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1022        1072     564        1032
Length      1354     564        50         245     235           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
truncate$trfile                     186 external procedure  is an external procedure.  
on unit on line 160                  64 on unit               

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
truncate$trfile          000100 addrs                       truncate$trfile
                         000101 by_name                     truncate$trfile
                         000102 code                        truncate$trfile
                         000103 ename                       truncate$trfile
                         000113 esw                         truncate$trfile
                         000114 fpage                       truncate$trfile
                         000115 overlay_size                truncate$trfile
                         000116 parent                      truncate$trfile
                         000170 segptr                      truncate$trfile
                         000172 write_lock                  truncate$trfile
                         000202 ep                          truncate$trfile
                         000204 dp                          truncate$trfile
                         000206 kstep                       truncate$trfile

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              tra_ext             enable              ext_entry
ext_entry_desc      int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
dc_find$finished              dc_find$obj_truncate          dc_find$obj_truncate_ptr      dc_find$obj_truncate_raw_ptr
get_kstep                     initiate                      lock$dir_unlock               mountedp
sum$dirmod                    terminate_$noname             truncate_vtoce

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$argerr           error_table_$boundviol        error_table_$dirseg           error_table_$rqover
pds$processid


CONSTANTS
000563  aa     777777777777

000000  aa     404000000002

000001  aa     404000000001

000002  aa     524000000000

000003  aa     526000000040

000004  aa     526000000250

000005  aa     464000000000

000006  aa     526077777777

000007  aa     404000000043

000010  aa     404000000021

000012  aa     077777000043
000013  aa     000001000000

000014  aa  157 165 164 137	out_
000015  aa  157 146 137 142	of_b
000016  aa  157 165 156 144	ound
000017  aa  163 000 000 000	s

BEGIN PROCEDURE truncate$trfile
PROLOGUE SEQUENCE
000020  aa  6 00214 4401 00	sxl0 	pr6|140
						STATEMENT 1 ON LINE 47
000021  aa  6 00101 4501 00	stz  	pr6|65		by_name
						STATEMENT 1 ON LINE 55
000022  aa   000541 2350 04	lda  	353,ic		000563 = 777777777777
000023  aa  6 00172 7551 00	sta  	pr6|122		write_lock
000024  aa  6 00214 7201 00	lxl0 	pr6|140
000025  aa   000000 7100 10	tra  	0,0
MAIN SEQUENCE
ENTRY TO truncate$trfile                                    STATEMENT 1 ON LINE 12
truncate$trfile: proc (a_dirname, a_ename, a_addrs, a_code);

000026  at     000004000006
000027  tt     000006000010
000030  ta     000007000000
000031  ta     000026000000
000032  da     000210300000
000033  aa   000300 6270 00	eax7 	192
000034  aa  7 00034 3521 20	epp2 	pr7|28,*
000035  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
000036  aa     000010000000
000037  aa     000000000000
000040  aa  6 00042 3735 20	epp7 	pr6|34,*
000041  aa  7 00000 2361 20	ldq  	pr7|0,*
000042  aa   000002 6040 04	tmi  	2,ic		000044
000043  aa   777777 3760 07	anq  	262143,dl
000044  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000045  aa  6 00215 7561 00	stq  	pr6|141
000046  aa  7 00002 2361 20	ldq  	pr7|2,*
000047  aa   000002 6040 04	tmi  	2,ic		000051
000050  aa   777777 3760 07	anq  	262143,dl
000051  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
000052  aa  6 00216 7561 00	stq  	pr6|142
000053  aa  6 00032 3715 20	epp5 	pr6|26,*
000054  aa  5 00006 3535 20	epp3 	pr5|6,*
000055  aa  6 00210 2535 00	spri3	pr6|136
000056  aa  5 00010 3515 20	epp1 	pr5|8,*
000057  aa  6 00212 2515 00	spri1	pr6|138
000060  aa   777740 7000 04	tsx0 	-32,ic		000020
						STATEMENT 1 ON LINE 85
	esw = 0;

000061  aa  6 00113 4501 00	stz  	pr6|75		esw
						STATEMENT 1 ON LINE 86
	code = 0;

000062  aa  6 00102 4501 00	stz  	pr6|66		code
						STATEMENT 1 ON LINE 87
	addrs = a_addrs;

000063  aa  6 00210 2361 20	ldq  	pr6|136,*		a_addrs
000064  aa  6 00100 7561 00	stq  	pr6|64		addrs
						STATEMENT 1 ON LINE 88
	parent = a_dirname;

000065  aa  6 00032 3735 20	epp7 	pr6|26,*
000066  aa  7 00002 3715 20	epp5 	pr7|2,*
000067  aa  6 00215 2351 00	lda  	pr6|141
000070  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
000071  aa  5 00000 00 0005	desc9a	pr5|0,al		a_dirname
000072  aa  6 00116 00 0250	desc9a	pr6|78,168	parent
						STATEMENT 1 ON LINE 89
	ename = a_ename;

000073  aa  7 00004 3535 20	epp3 	pr7|4,*
000074  aa  6 00216 2361 00	ldq  	pr6|142
000075  aa  040 100 100 540	mlr  	(pr,rl),(pr),fill(040)
000076  aa  3 00000 00 0006	desc9a	pr3|0,ql		a_ename
000077  aa  6 00103 00 0040	desc9a	pr6|67,32		ename
						STATEMENT 1 ON LINE 90
	call dc_find$obj_truncate (parent, ename, ep, code);

000100  aa  6 00116 3521 00	epp2 	pr6|78		parent
000101  aa  6 00222 2521 00	spri2	pr6|146
000102  aa  6 00103 3521 00	epp2 	pr6|67		ename
000103  aa  6 00224 2521 00	spri2	pr6|148
000104  aa  6 00202 3521 00	epp2 	pr6|130		ep
000105  aa  6 00226 2521 00	spri2	pr6|150
000106  aa  6 00102 3521 00	epp2 	pr6|66		code
000107  aa  6 00230 2521 00	spri2	pr6|152
000110  aa  6 00220 6211 00	eax1 	pr6|144
000111  aa   020000 4310 07	fld  	8192,dl
000112  aa  6 00044 3701 20	epp4 	pr6|36,*
000113  la  4 00042 3521 20	epp2 	pr4|34,*		dc_find$obj_truncate
000114  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 91
	dp = ptr (ep, 0);

000115  aa  6 00202 3525 20	epbp2	pr6|130,*		ep
000116  aa  6 00204 2521 00	spri2	pr6|132		dp
						STATEMENT 1 ON LINE 92
	if code ^= 0 then go to finale;

000117  aa  6 00102 2361 00	ldq  	pr6|66		code
000120  aa   000405 6010 04	tnz  	261,ic		000525
						STATEMENT 1 ON LINE 93
	by_name = "1"b;

000121  aa   400000 2350 03	lda  	131072,du
000122  aa  6 00101 7551 00	sta  	pr6|65		by_name
						STATEMENT 1 ON LINE 94
	go to join;

000123  aa   000111 7100 04	tra  	73,ic		000234
ENTRY TO trseg                                              STATEMENT 1 ON LINE 96
trseg: entry (a_segptr, a_addrs, a_code);

000124  at     000003000005
000125  tt     000010000007
000126  ta     000124000000
000127  da     000215300000
000130  aa   000300 6270 00	eax7 	192
000131  aa  7 00034 3521 20	epp2 	pr7|28,*
000132  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000133  aa     000006000000
000134  aa     000000000000
000135  aa  6 00032 3735 20	epp7 	pr6|26,*
000136  aa  7 00004 3715 20	epp5 	pr7|4,*
000137  aa  6 00210 6515 00	spri5	pr6|136
000140  aa  7 00006 3535 20	epp3 	pr7|6,*
000141  aa  6 00212 2535 00	spri3	pr6|138
000142  aa   777656 7000 04	tsx0 	-82,ic		000020
						STATEMENT 1 ON LINE 98
	esw = 1;

000143  aa   000001 2360 07	ldq  	1,dl
000144  aa  6 00113 7561 00	stq  	pr6|75		esw
						STATEMENT 1 ON LINE 99
	code = 0;

000145  aa  6 00102 4501 00	stz  	pr6|66		code
						STATEMENT 1 ON LINE 100
	addrs = a_addrs;

000146  aa  6 00210 2361 20	ldq  	pr6|136,*		a_addrs
000147  aa  6 00100 7561 00	stq  	pr6|64		addrs
						STATEMENT 1 ON LINE 101
	segptr = ptr (a_segptr, 0);

000150  aa  6 00032 3735 20	epp7 	pr6|26,*
000151  aa  7 00002 3521 20	epp2 	pr7|2,*		a_segptr
000152  aa  2 00000 3525 20	epbp2	pr2|0,*		a_segptr
000153  aa  6 00170 2521 00	spri2	pr6|120		segptr
						STATEMENT 1 ON LINE 103
	call get_kstep (fixed (baseno (segptr)), kstep, code);

000154  aa  2 00000 2131 00	epaq 	pr2|0		segptr
000155  aa   077777 3750 03	ana  	32767,du
000156  aa   000066 7730 00	lrl  	54
000157  aa  6 00217 7561 00	stq  	pr6|143
000160  aa  6 00217 3521 00	epp2 	pr6|143
000161  aa  6 00222 2521 00	spri2	pr6|146
000162  aa  6 00206 3521 00	epp2 	pr6|134		kstep
000163  aa  6 00224 2521 00	spri2	pr6|148
000164  aa  6 00102 3521 00	epp2 	pr6|66		code
000165  aa  6 00226 2521 00	spri2	pr6|150
000166  aa  6 00220 6211 00	eax1 	pr6|144
000167  aa   014000 4310 07	fld  	6144,dl
000170  aa  6 00044 3701 20	epp4 	pr6|36,*
000171  la  4 00022 3521 20	epp2 	pr4|18,*		get_kstep
000172  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 104
	if code ^= 0 then go to finale;

000173  aa  6 00102 2361 00	ldq  	pr6|66		code
000174  aa   000331 6010 04	tnz  	217,ic		000525
						STATEMENT 1 ON LINE 106
	if kste.priv_init then call dc_find$obj_truncate_raw_ptr (segptr, ep, code);

000175  aa  6 00206 3735 20	epp7 	pr6|134,*		kstep
000176  aa  7 00007 2351 00	lda  	pr7|7		kste.priv_init
000177  aa   000010 3150 03	cana 	8,du
000200  aa   000015 6000 04	tze  	13,ic		000215
000201  aa  6 00170 3521 00	epp2 	pr6|120		segptr
000202  aa  6 00222 2521 00	spri2	pr6|146
000203  aa  6 00202 3521 00	epp2 	pr6|130		ep
000204  aa  6 00224 2521 00	spri2	pr6|148
000205  aa  6 00102 3521 00	epp2 	pr6|66		code
000206  aa  6 00226 2521 00	spri2	pr6|150
000207  aa  6 00220 6211 00	eax1 	pr6|144
000210  aa   014000 4310 07	fld  	6144,dl
000211  aa  6 00044 3701 20	epp4 	pr6|36,*
000212  la  4 00046 3521 20	epp2 	pr4|38,*		dc_find$obj_truncate_raw_ptr
000213  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000214  aa   000014 7100 04	tra  	12,ic		000230
						STATEMENT 1 ON LINE 107
	else call dc_find$obj_truncate_ptr (segptr, ep, code);

000215  aa  6 00170 3521 00	epp2 	pr6|120		segptr
000216  aa  6 00222 2521 00	spri2	pr6|146
000217  aa  6 00202 3521 00	epp2 	pr6|130		ep
000220  aa  6 00224 2521 00	spri2	pr6|148
000221  aa  6 00102 3521 00	epp2 	pr6|66		code
000222  aa  6 00226 2521 00	spri2	pr6|150
000223  aa  6 00220 6211 00	eax1 	pr6|144
000224  aa   014000 4310 07	fld  	6144,dl
000225  aa  6 00044 3701 20	epp4 	pr6|36,*
000226  la  4 00044 3521 20	epp2 	pr4|36,*		dc_find$obj_truncate_ptr
000227  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 108
	if code ^= 0 then go to finale;

000230  aa  6 00102 2361 00	ldq  	pr6|66		code
000231  aa   000274 6010 04	tnz  	188,ic		000525
						STATEMENT 1 ON LINE 109
	dp = ptr (ep, 0);

000232  aa  6 00202 3525 20	epbp2	pr6|130,*		ep
000233  aa  6 00204 2521 00	spri2	pr6|132		dp
						STATEMENT 1 ON LINE 111
join:	if ep -> entry.dirsw then do;

000234  aa  6 00202 3735 20	epp7 	pr6|130,*		ep
000235  aa  7 00032 2351 00	lda  	pr7|26		entry.dirsw
000236  aa   400000 3150 03	cana 	131072,du
000237  aa   000005 6000 04	tze  	5,ic		000244
						STATEMENT 1 ON LINE 112
	     code = error_table_$dirseg;

000240  aa  6 00044 3701 20	epp4 	pr6|36,*
000241  la  4 00014 2361 20	ldq  	pr4|12,*		error_table_$dirseg
000242  aa  6 00102 7561 00	stq  	pr6|66		code
						STATEMENT 1 ON LINE 113
	     go to unlock;

000243  aa   000265 7100 04	tra  	181,ic		000530
						STATEMENT 1 ON LINE 114
	end;

						STATEMENT 1 ON LINE 116
	if addrs < 0 then do;

000244  aa  6 00100 2361 00	ldq  	pr6|64		addrs
000245  aa   000005 6050 04	tpl  	5,ic		000252
						STATEMENT 1 ON LINE 117
	     code = error_table_$argerr;

000246  aa  6 00044 3701 20	epp4 	pr6|36,*
000247  la  4 00010 2361 20	ldq  	pr4|8,*		error_table_$argerr
000250  aa  6 00102 7561 00	stq  	pr6|66		code
						STATEMENT 1 ON LINE 118
	     go to unlock;

000251  aa   000257 7100 04	tra  	175,ic		000530
						STATEMENT 1 ON LINE 119
	end;

						STATEMENT 1 ON LINE 122
	fpage = divide (addrs + 1023, 1024, 17, 0);

000252  aa   001777 0760 07	adq  	1023,dl
000253  aa   002000 5060 07	div  	1024,dl
000254  aa  6 00114 7561 00	stq  	pr6|76		fpage
						STATEMENT 1 ON LINE 124
	go to join1;

000255  aa   000024 7100 04	tra  	20,ic		000301
ENTRY TO trentry                                            STATEMENT 1 ON LINE 126
trentry: entry (a_ep);

000256  at     000001000005
000257  ta     000256000000
000260  da     000222300000
000261  aa   000300 6270 00	eax7 	192
000262  aa  7 00034 3521 20	epp2 	pr7|28,*
000263  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000264  aa     000002000000
000265  aa     000000000000
000266  aa   777532 7000 04	tsx0 	-166,ic		000020
						STATEMENT 1 ON LINE 128
	esw = 2;

000267  aa   000002 2360 07	ldq  	2,dl
000270  aa  6 00113 7561 00	stq  	pr6|75		esw
						STATEMENT 1 ON LINE 129
	fpage = 0;

000271  aa  6 00114 4501 00	stz  	pr6|76		fpage
						STATEMENT 1 ON LINE 130
	ep = a_ep;

000272  aa  6 00032 3735 20	epp7 	pr6|26,*
000273  aa  7 00002 3715 20	epp5 	pr7|2,*		a_ep
000274  aa  5 00000 3715 20	epp5 	pr5|0,*		a_ep
000275  aa  6 00202 6515 00	spri5	pr6|130		ep
						STATEMENT 1 ON LINE 131
	code = 0;

000276  aa  6 00102 4501 00	stz  	pr6|66		code
						STATEMENT 1 ON LINE 132
	dp = ptr (ep, 0);

000277  aa  5 00000 3525 00	epbp2	pr5|0
000300  aa  6 00204 2521 00	spri2	pr6|132		dp
						STATEMENT 1 ON LINE 133
join1:

	code = mountedp (dir.sons_lvid);

000301  aa  2 00012 3521 00	epp2 	pr2|10		dir.sons_lvid
000302  aa  6 00222 2521 00	spri2	pr6|146
000303  aa  6 00102 3521 00	epp2 	pr6|66		code
000304  aa  6 00224 2521 00	spri2	pr6|148
000305  aa  6 00220 6211 00	eax1 	pr6|144
000306  aa   010000 4310 07	fld  	4096,dl
000307  aa  6 00044 3701 20	epp4 	pr6|36,*
000310  la  4 00030 3521 20	epp2 	pr4|24,*		mountedp
000311  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 136
	if code = 0
	then do;

000312  aa  6 00102 2361 00	ldq  	pr6|66		code
000313  aa   000024 6010 04	tnz  	20,ic		000337
						STATEMENT 1 ON LINE 138
	     dir.modify = pds$processid;

000314  aa  6 00044 3701 20	epp4 	pr6|36,*
000315  la  4 00020 2351 20	lda  	pr4|16,*		pds$processid
000316  aa  6 00204 7551 20	sta  	pr6|132,*		dir.modify
						STATEMENT 1 ON LINE 140
	     call truncate_vtoce (ep, fpage, code);

000317  aa  6 00202 3521 00	epp2 	pr6|130		ep
000320  aa  6 00222 2521 00	spri2	pr6|146
000321  aa  6 00114 3521 00	epp2 	pr6|76		fpage
000322  aa  6 00224 2521 00	spri2	pr6|148
000323  aa  6 00102 3521 00	epp2 	pr6|66		code
000324  aa  6 00226 2521 00	spri2	pr6|150
000325  aa  6 00220 6211 00	eax1 	pr6|144
000326  aa   014000 4310 07	fld  	6144,dl
000327  la  4 00036 3521 20	epp2 	pr4|30,*		truncate_vtoce
000330  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 142
	     if code ^= 0 then if code = error_table_$rqover then code = 0;

000331  aa  6 00102 2361 00	ldq  	pr6|66		code
000332  aa   000005 6000 04	tze  	5,ic		000337
000333  aa  6 00044 3701 20	epp4 	pr6|36,*
000334  la  4 00016 1161 20	cmpq 	pr4|14,*		error_table_$rqover
000335  aa   000002 6010 04	tnz  	2,ic		000337
000336  aa  6 00102 4501 00	stz  	pr6|66		code
						STATEMENT 1 ON LINE 143
	end;

						STATEMENT 1 ON LINE 144
	if esw = 2 then return;

000337  aa  6 00113 2361 00	ldq  	pr6|75		esw
000340  aa   000002 1160 07	cmpq 	2,dl
000341  aa  0 00631 6001 00	tze  	pr0|409		return
						STATEMENT 1 ON LINE 147
	dir.modify = "0"b;

000342  aa  6 00204 4501 20	stz  	pr6|132,*		dir.modify
						STATEMENT 1 ON LINE 148
	call sum$dirmod (dp);

000343  aa  6 00204 3521 00	epp2 	pr6|132		dp
000344  aa  6 00222 2521 00	spri2	pr6|146
000345  aa  6 00220 6211 00	eax1 	pr6|144
000346  aa   004000 4310 07	fld  	2048,dl
000347  aa  6 00044 3701 20	epp4 	pr6|36,*
000350  la  4 00032 3521 20	epp2 	pr4|26,*		sum$dirmod
000351  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 149
	if by_name
	then call dc_find$finished (dp, "1"b);

000352  aa  6 00101 2351 00	lda  	pr6|65		by_name
000353  aa   000015 6000 04	tze  	13,ic		000370
000354  aa   400000 2350 03	lda  	131072,du
000355  aa  6 00217 7551 00	sta  	pr6|143
000356  aa  6 00204 3521 00	epp2 	pr6|132		dp
000357  aa  6 00222 2521 00	spri2	pr6|146
000360  aa  6 00217 3521 00	epp2 	pr6|143
000361  aa  6 00224 2521 00	spri2	pr6|148
000362  aa  6 00220 6211 00	eax1 	pr6|144
000363  aa   010000 4310 07	fld  	4096,dl
000364  aa  6 00044 3701 20	epp4 	pr6|36,*
000365  la  4 00040 3521 20	epp2 	pr4|32,*		dc_find$finished
000366  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000367  aa   000010 7100 04	tra  	8,ic		000377
						STATEMENT 1 ON LINE 151
	else call lock$dir_unlock (dp);

000370  aa  6 00204 3521 00	epp2 	pr6|132		dp
000371  aa  6 00222 2521 00	spri2	pr6|146
000372  aa  6 00220 6211 00	eax1 	pr6|144
000373  aa   004000 4310 07	fld  	2048,dl
000374  aa  6 00044 3701 20	epp4 	pr6|36,*
000375  la  4 00026 3521 20	epp2 	pr4|22,*		lock$dir_unlock
000376  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 158
	if code ^= 0 then go to finale;

000377  aa  6 00102 2361 00	ldq  	pr6|66		code
000400  aa   000125 6010 04	tnz  	85,ic		000525
						STATEMENT 1 ON LINE 160
	on condition (out_of_bounds) go to boundviol;

000401  aa   000015 7260 07	lxl6 	13,dl
000402  aa   777412 3520 04	epp2 	-246,ic		000014 = 157165164137
000403  aa  0 00717 7001 00	tsx0 	pr0|463		enable
000404  aa   000004 7100 04	tra  	4,ic		000410
000405  aa     000174000000
000406  aa   000012 7100 04	tra  	10,ic		000420
BEGIN CONDITION out_of_bounds.1
ENTRY TO out_of_bounds.1                                    STATEMENT 1 ON LINE 160
	on condition (out_of_bounds) go to boundviol;

000407  da     000231200000
000410  aa   000100 6270 00	eax7 	64
000411  aa  7 00034 3521 20	epp2 	pr7|28,*
000412  aa  2 01047 2721 00	tsp2 	pr2|551		int_entry
000413  aa     000000000000
000414  aa     000000000000
000415  aa   000142 3520 04	epp2 	98,ic		000557 = 600044370120
000416  aa   000001 7270 07	lxl7 	1,dl
000417  aa  0 00657 7101 00	tra  	pr0|431		tra_ext
  END CONDITION out_of_bounds.1
						STATEMENT 1 ON LINE 162
	overlay_size = (fpage * 1024 - addrs) * 36;

000420  aa  6 00114 2361 00	ldq  	pr6|76		fpage
000421  aa   000012 7360 00	qls  	10
000422  aa  6 00100 1761 00	sbq  	pr6|64		addrs
000423  aa   000044 4020 07	mpy  	36,dl
000424  aa  6 00115 7561 00	stq  	pr6|77		overlay_size
						STATEMENT 1 ON LINE 163
	if overlay_size ^= 0 then do;

000425  aa   000100 6000 04	tze  	64,ic		000525
						STATEMENT 1 ON LINE 164
	     if esw = 0 then do;

000426  aa  6 00113 2361 00	ldq  	pr6|75		esw
000427  aa   000052 6010 04	tnz  	42,ic		000501
						STATEMENT 1 ON LINE 165
		call initiate (parent, ename, "", 0, 1, segptr, code);

000430  aa  6 00232 4501 00	stz  	pr6|154
000431  aa   000001 2360 07	ldq  	1,dl
000432  aa  6 00233 7561 00	stq  	pr6|155
000433  aa  6 00116 3521 00	epp2 	pr6|78		parent
000434  aa  6 00236 2521 00	spri2	pr6|158
000435  aa  6 00103 3521 00	epp2 	pr6|67		ename
000436  aa  6 00240 2521 00	spri2	pr6|160
000437  aa  6 00217 3521 00	epp2 	pr6|143
000440  aa  6 00242 2521 00	spri2	pr6|162
000441  aa  6 00232 3521 00	epp2 	pr6|154
000442  aa  6 00244 2521 00	spri2	pr6|164
000443  aa  6 00233 3521 00	epp2 	pr6|155
000444  aa  6 00246 2521 00	spri2	pr6|166
000445  aa  6 00170 3521 00	epp2 	pr6|120		segptr
000446  aa  6 00250 2521 00	spri2	pr6|168
000447  aa  6 00102 3521 00	epp2 	pr6|66		code
000450  aa  6 00252 2521 00	spri2	pr6|170
000451  aa   777333 3520 04	epp2 	-293,ic		000004 = 526000000250
000452  aa  6 00254 2521 00	spri2	pr6|172
000453  aa   777330 3520 04	epp2 	-296,ic		000003 = 526000000040
000454  aa  6 00256 2521 00	spri2	pr6|174
000455  aa   777325 3520 04	epp2 	-299,ic		000002 = 524000000000
000456  aa  6 00260 2521 00	spri2	pr6|176
000457  aa   777322 3520 04	epp2 	-302,ic		000001 = 404000000001
000460  aa  6 00262 2521 00	spri2	pr6|178
000461  aa   777317 3520 04	epp2 	-305,ic		000000 = 404000000002
000462  aa  6 00264 2521 00	spri2	pr6|180
000463  aa   777322 3520 04	epp2 	-302,ic		000005 = 464000000000
000464  aa  6 00266 2521 00	spri2	pr6|182
000465  aa   777322 3520 04	epp2 	-302,ic		000007 = 404000000043
000466  aa  6 00270 2521 00	spri2	pr6|184
000467  aa  6 00234 6211 00	eax1 	pr6|156
000470  aa   034000 4310 07	fld  	14336,dl
000471  aa  6 00044 3701 20	epp4 	pr6|36,*
000472  la  4 00024 3521 20	epp2 	pr4|20,*		initiate
000473  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 166
		if segptr = null then goto finale;

000474  aa  6 00170 2371 00	ldaq 	pr6|120		segptr
000475  aa   777315 6770 04	eraq 	-307,ic		000012 = 077777000043 000001000000
000476  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000477  aa   000026 6000 04	tze  	22,ic		000525
						STATEMENT 1 ON LINE 167
		code = 0;

000500  aa  6 00102 4501 00	stz  	pr6|66		code
						STATEMENT 1 ON LINE 168
	     end;

						STATEMENT 1 ON LINE 169
	     addrel (segptr, addrs) -> overlay = ""b;

000501  aa  6 00100 2361 00	ldq  	pr6|64		addrs
000502  aa  6 00170 3521 66	epp2 	pr6|120,*ql	segptr
000503  aa   000000 0520 03	adwp2	0,du
000504  aa  6 00115 2361 00	ldq  	pr6|77		overlay_size
000505  aa   000010 0760 07	adq  	8,dl
000506  aa   000011 5060 07	div  	9,dl
000507  aa  000 140 100 400	mlr  	(),(pr,rl),fill(000)
000510  aa   000000 00 0000	desc9a	0,0
000511  aa  2 00000 00 0006	desc9a	pr2|0,ql		overlay
						STATEMENT 1 ON LINE 170
	     if esw = 0 then call terminate_$noname (segptr, code);

000512  aa  6 00113 2361 00	ldq  	pr6|75		esw
000513  aa   000012 6010 04	tnz  	10,ic		000525
000514  aa  6 00170 3521 00	epp2 	pr6|120		segptr
000515  aa  6 00222 2521 00	spri2	pr6|146
000516  aa  6 00102 3521 00	epp2 	pr6|66		code
000517  aa  6 00224 2521 00	spri2	pr6|148
000520  aa  6 00220 6211 00	eax1 	pr6|144
000521  aa   010000 4310 07	fld  	4096,dl
000522  aa  6 00044 3701 20	epp4 	pr6|36,*
000523  la  4 00034 3521 20	epp2 	pr4|28,*		terminate_$noname
000524  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 171
	end;

						STATEMENT 1 ON LINE 173
finale:	a_code = code;

000525  aa  6 00102 2361 00	ldq  	pr6|66		code
000526  aa  6 00212 7561 20	stq  	pr6|138,*		a_code
						STATEMENT 1 ON LINE 174
	return;

000527  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 176
unlock:	if dir.modify then dir.modify = "0"b;

000530  aa  2 00000 2351 00	lda  	pr2|0		dir.modify
000531  aa   000002 6000 04	tze  	2,ic		000533
000532  aa  2 00000 4501 00	stz  	pr2|0		dir.modify
						STATEMENT 1 ON LINE 177
	if by_name
	then call dc_find$finished (dp, "1"b);

000533  aa  6 00101 2351 00	lda  	pr6|65		by_name
000534  aa   000014 6000 04	tze  	12,ic		000550
000535  aa   400000 2350 03	lda  	131072,du
000536  aa  6 00233 7551 00	sta  	pr6|155
000537  aa  6 00204 3521 00	epp2 	pr6|132		dp
000540  aa  6 00222 2521 00	spri2	pr6|146
000541  aa  6 00233 3521 00	epp2 	pr6|155
000542  aa  6 00224 2521 00	spri2	pr6|148
000543  aa  6 00220 6211 00	eax1 	pr6|144
000544  aa   010000 4310 07	fld  	4096,dl
000545  la  4 00040 3521 20	epp2 	pr4|32,*		dc_find$finished
000546  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
000547  aa   777756 7100 04	tra  	-18,ic		000525
						STATEMENT 1 ON LINE 179
	else call lock$dir_unlock (dp);

000550  aa  6 00204 3521 00	epp2 	pr6|132		dp
000551  aa  6 00222 2521 00	spri2	pr6|146
000552  aa  6 00220 6211 00	eax1 	pr6|144
000553  aa   004000 4310 07	fld  	2048,dl
000554  la  4 00026 3521 20	epp2 	pr4|22,*		lock$dir_unlock
000555  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 180
	go to finale;

000556  aa   777747 7100 04	tra  	-25,ic		000525
						STATEMENT 1 ON LINE 182
boundviol:
	a_code = error_table_$boundviol;

000557  aa  6 00044 3701 20	epp4 	pr6|36,*
000560  la  4 00012 2361 20	ldq  	pr4|10,*		error_table_$boundviol
000561  aa  6 00212 7561 20	stq  	pr6|138,*		a_code
						STATEMENT 1 ON LINE 184
	return;

000562  aa  0 00631 7101 00	tra  	pr0|409		return
						STATEMENT 1 ON LINE 190
     end;

  END PROCEDURE truncate$trfile


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
