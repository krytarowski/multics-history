	COMPILATION LISTING OF SEGMENT suffix_ms_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 05/09/85  1109.0 mst Thu
	    Options: optimize map

        1 /* **************************************************************
        2*   *                                                            *
        3*   * Copyright, (C) Massachusetts Institute of Technology, 1983 *
        4*   *                                                            *
        5*   * Copyright, (C) Honeywell Information Systems Inc., 1983    *
        6*   *                                                            *
        7*   ************************************************************** */
        8 
        9 
       10 
       11 /* format: style2,idind30,indcomtxt */
       12 
       13 /* Typed-segment primitives for message segments */
       14 
       15 /* Created:  January 1983 by G. Palter */
       16 /* Modified: 2/20/83 Jay Pattin to add lots more entries */
       17 /* 830922 BIM for new calling sequences for acls */
       18 /* 1984.08.28 MAP to set user_area_ptr when list_acl is invoked */
       19 /* 1985-05-02, BIM: remove unneeded include of access_mode_values */
       20 /* 1985-05-06, BIM: check code on exit from message_segment_$acl_list */
       21 
       22 suffix_ms_:
       23      procedure ();
       24 
       25 
       26 /* Common Parameters */
       27 
       28           dcl     P_desired_version             character (*) parameter;
       29           dcl     P_dirname                     character (*) parameter;
       30                                                             /* directory containing the message segment */
       31           dcl     P_ename                       character (*) parameter;
       32                                                             /* name of the message segment */
       33           dcl     P_code                        fixed binary (35) parameter;
       34 
       35 /* suffix_info and list_switches Parameters */
       36 
       37           dcl     P_suffix_info_ptr             ptr parameter;
       38           dcl     P_switch_list_ptr             ptr parameter;
       39 
       40 /* chname_file Parameters */
       41 
       42           dcl     P_old_name                    character (*) parameter;
       43                                                             /* name to be deleted */
       44           dcl     P_new_name                    character (*) parameter;
       45                                                             /* name to be added */
       46 
       47 /* copy parameters */
       48 
       49           dcl     P_copy_options_ptr            ptr parameter;
       50 
       51 /* Parameters used by most ACL entries */
       52 
       53           dcl     P_acl_ptr                     pointer parameter;
       54                                                             /* -> an ACL array structure */
       55 
       56 
       57 /* list_acl Parameters */
       58 
       59           dcl     P_user_area_ptr               pointer parameter;
       60                                                             /* -> area where to allocate listed_acl if non-null */
       61 
       62 
       63 /* replace_acl Parameters */
       64 
       65           dcl     P_no_sysdaemon                bit (1) parameter;
       66                                                             /* ON => do not add explicit *.SysDaemon.* term */
       67 
       68 /* switch Parameters */
       69 
       70           dcl     P_switch_name                 char (*) parameter;
       71           dcl     P_value                       bit (1) aligned parameter;
       72 
       73 /* (get set)_max_length and bit_count parameters */
       74 
       75           dcl     P_max_length                  fixed bin (19) parameter;
       76 
       77 /* get_user_access_modes parameters */
       78 
       79           dcl     (P_modes, P_exmodes)          bit (36) aligned;
       80           dcl     P_ring                        fixed bin;
       81           dcl     P_user_name                   char (*);
       82 
       83 /* Remaining declarations */
       84 
       85           dcl     old_acl_ptr                   pointer;
       86 
       87           dcl     user_area_ptr                 pointer;
       88           dcl     user_area                     area based (user_area_ptr);
       89           dcl     system_free_area              area based (get_system_free_area_ ());
       90 
       91           dcl     idx                           fixed binary;
       92           dcl     rings                         (3) fixed bin (3);
       93           dcl     value                         bit (1);
       94           dcl     err_switch                    bit (1) aligned;
       95 
       96           dcl     error_table_$argerr           fixed binary (35) external;
       97           dcl     error_table_$unsupported_operation
       98                                                 fixed binary (35) external;
       99           dcl     error_table_$unimplemented_version
      100                                                 fixed bin (35) ext static;
      101 
      102           dcl     (get_system_free_area_, get_user_free_area_)
      103                                                 entry () returns (pointer);
      104           dcl     hcs_$get_max_length           entry (char (*), char (*), fixed bin (19), fixed bin (35));
      105           dcl     hcs_$get_safety_sw            entry (char (*), char (*), bit (1), fixed bin (35));
      106           dcl     hcs_$get_user_access_modes    entry (char (*), char (*), char (*), fixed bin, bit (36) aligned,
      107                                                 bit (36) aligned, fixed bin (35));
      108           dcl     message_segment_$copy         entry (character (*), character (*), character (*), character (*),
      109                                                 bit (1) aligned, fixed binary (35));
      110           dcl     message_segment_$chname_file  entry (character (*), character (*), character (*), character (*),
      111                                                 fixed binary (35));
      112           dcl     message_segment_$delete       entry (character (*), character (*), fixed binary (35));
      113           dcl     message_segment_$ms_acl_add   entry (character (*), character (*), pointer, fixed binary,
      114                                                 fixed binary (35));
      115           dcl     message_segment_$ms_acl_delete
      116                                                 entry (character (*), character (*), pointer, fixed binary, pointer,
      117                                                 fixed binary (35));
      118           dcl     message_segment_$ms_acl_list  entry (character (*), character (*), pointer, fixed binary, pointer,
      119                                                 fixed binary (35));
      120           dcl     message_segment_$ms_acl_replace
      121                                                 entry (character (*), character (*), pointer, fixed binary,
      122                                                 fixed binary (35));
      123           dcl     message_segment_$set_max_length_file
      124                                                 entry (char (*), char (*), fixed bin (19), fixed bin (35));
      125           dcl     message_segment_$set_safety_switch
      126                                                 entry (char (*), char (*), bit (1) aligned, fixed bin (35));
      127           dcl     message_segment_$validate     entry (character (*), character (*), fixed binary (35));
      128           dcl     sub_err_                      entry () options (variable);
      129 
      130           dcl     cleanup                       condition;
      131 
      132           dcl     null                          builtin;    /* format: off */
      133  /* BEGIN INCLUDE FILE: suffix_info.incl.pl1 */
  1     2 /* format: style3,indcomtxt,idind30 */
  1     3 /**** Jay Pattin 2/13/83
  1     4*      M. Pandolf 1984.11.30 to set FS_OBJECT_TYPE_MSF to -multisegment_file
  1     5*
  1     6*      The include file copy_flags.incl.pl1 must be included in any program using this include file.
  1     7*
  1     8*      This structure is returned by the suffix_XXX_$suffix_info subroutines */
  1     9 
  1    10 declare   suffix_info_ptr               ptr;
  1    11 
  1    12 declare   1 suffix_info                 aligned based (suffix_info_ptr),
  1    13             2 version                   char (8),
  1    14             2 type                      char (32) unaligned,
  1    15             2 type_name                 char (32) unaligned,          /* Singular name of the object type, e.g. "mailbox" */
  1    16             2 plural_name               char (32) unaligned,          /* Plural of above, e.g. "mailboxes" */
  1    17             2 flags                     unaligned,
  1    18               3 standard_object         bit (1) unaligned,  /* ON if not an extended object (no suffix_XXX_) */
  1    19               3 extended_acl            bit (1) unaligned,  /* ON if uses extended ACLs, off if regular ACLs */
  1    20               3 has_switches            bit (1) unaligned,  /* ON if supports switches for objects */
  1    21               3 mbz1                    bit (33) unaligned,
  1    22             2 modes                     char (36),          /* correspondence between bits and chars for extended modes */
  1    23             2 max_mode_len              fixed bin,          /* maximum number of modes on an object */
  1    24             2 num_ring_brackets         fixed bin,          /* number of ring brackets on object */
  1    25             2 copy_flags                like copy_flags,    /* See copy_flags.incl.pl1 */
  1    26             2 info_pathname             char (168) unaligned;
  1    27                                                             /* pathname of info segment containing more info */
  1    28 
  1    29 declare   SUFFIX_INFO_VERSION_1         char (8) static options (constant) init ("SUFFIX01");
  1    30 
  1    31 /* This information is returned by the suffix_XXX_$list_switches subroutines */
  1    32 
  1    33 declare   switch_list_ptr               ptr,
  1    34           alloc_switch_count            fixed bin,
  1    35           alloc_switch_name_count       fixed bin;
  1    36 
  1    37 declare   1 switch_list                 aligned based (switch_list_ptr),
  1    38             2 version                   char (8),           /* SWITCH_LIST_VERSION_1 */
  1    39             2 switch_count              fixed bin,          /* total number of switches */
  1    40             2 switch_name_count         fixed bin,          /* total number of names */
  1    41             2 switches                  (alloc_switch_count refer (switch_list.switch_count)),
  1    42               3 name_index              fixed bin,          /* index of first name for this switch */
  1    43               3 name_count              fixed bin,          /* number of names for this switch */
  1    44               3 default_value           bit (1) aligned,    /* default setting for this switch */
  1    45               3 mbz1                    bit (36) aligned,   /* reserved for future use */
  1    46             2 names                     (alloc_switch_name_count refer (switch_list.switch_name_count)) char (32);
  1    47 
  1    48 declare   SWITCH_LIST_VERSION_1         char (8) static options (constant) init ("SWLIST01");
  1    49 
  1    50 declare   (
  1    51           FS_OBJECT_TYPE_SEGMENT        init ("-segment"),
  1    52           FS_OBJECT_TYPE_DIRECTORY      init ("-directory"),
  1    53           FS_OBJECT_TYPE_MSF            init ("-multisegment_file"),
  1    54           FS_OBJECT_TYPE_DM_FILE        init ("-dm_file"),
  1    55           FS_OBJECT_TYPE_LINK           init ("-link")
  1    56           )                             char (32) unaligned int static options (constant);
  1    57 
  1    58 /* END INCLUDE FILE: suffix_info.incl.pl1 */
      133 
      134  /* BEGIN INCLUDE FILE: copy_options.incl.pl1 */
  2     2 
  2     3 /* This structure declares the input structure used by the copy_ subroutine.
  2     4*
  2     5*   NOTE: This include file depends on declarations in the include file
  2     6*   copy_flags.incl.pl1.
  2     7*
  2     8*   Jay Pattin 6/1/83 */
  2     9 
  2    10 declare   copy_options_ptr              ptr;
  2    11 
  2    12 declare   1 copy_options                aligned based (copy_options_ptr),
  2    13           2 version                     char (8),           /* currently COPY_OPTIONS_VERSION_1 */
  2    14           2 caller_name                 char (32) unal,     /* Used in nd_handler_ call */
  2    15           2 source_dir                  char (168) unal,
  2    16           2 source_name                 char (32) unal,
  2    17           2 target_dir                  char (168) unal,
  2    18           2 target_name                 char (32) unal,
  2    19           2 flags,
  2    20             3 no_name_dup               bit (1) unaligned,  /* ON = don't call nd_handler_ */
  2    21             3 raw                       bit (1) unaligned,  /* ON = don't call object_type_, use hcs_ */
  2    22             3 force                     bit (1) unaligned,  /* ON = delete or force access to target */
  2    23             3 delete                    bit (1) unaligned,  /* ON = delete original after copy (for move) */
  2    24             3 target_err_switch         bit (1) unaligned,
  2    25             3 mbz                       bit (31) unaligned,
  2    26           2 copy_items                  like copy_flags;    /* see copy_flags.incl.pl1 */
  2    27 
  2    28 declare   COPY_OPTIONS_VERSION_1        char (8) static options (constant) init ("CPOPT001");
  2    29 
  2    30 /* END INCLUDE FILE: copy_options.incl.pl1 */
      134 
      135  /* BEGIN INCLUDE FILE:  copy_flags.incl.pl1 */
  3     2 
  3     3 /* Flags for attributes that should/may be copied by the copy_ subroutine. This include file is
  3     4*   required by suffix_info.incl.pl1 and copy_options.incl.pl1
  3     5*
  3     6*   Jay Pattin 6/23/83 */
  3     7 
  3     8 declare   1 copy_flags                  aligned based,      /* ON means that this attribute may be copied by copy_ */
  3     9           2 names                       bit (1) unaligned,
  3    10           2 acl                         bit (1) unaligned,
  3    11           2 ring_brackets               bit (1) unaligned,
  3    12           2 max_length                  bit (1) unaligned,
  3    13           2 copy_switch                 bit (1) unaligned,
  3    14           2 safety_switch               bit (1) unaligned,
  3    15           2 dumper_switches             bit (1) unaligned,
  3    16           2 entry_bound                 bit (1) unaligned,  /* only for vanilla object segments */
  3    17           2 extend                      bit (1) unaligned,  /* copy_ may append to end of existing object */
  3    18           2 update                      bit (1) unaligned,  /* copy_ may replace contents of existing object */
  3    19           2 mbz                         bit (26) unaligned;
  3    20 
  3    21 /* END INCLUDE FILE:  copy_flags.incl.pl1 */
      135 
      136  /* Begin include file -- acl_structures.incl.pl1 BIM 3/82 */
  4     2 /* format: style3,indcomtxt,idind30 */
  4     3 
  4     4 declare   acl_ptr                       pointer;
  4     5 declare   acl_count                     fixed bin;
  4     6 
  4     7 declare 1 general_acl                   aligned based (acl_ptr), /* for fs_util_ */
  4     8           2 version                     char (8) aligned,
  4     9           2 count                       fixed bin,
  4    10           2 entries                     (acl_count refer (general_acl.count)) aligned like general_acl_entry;
  4    11 
  4    12 declare 1 general_acl_entry             based,
  4    13           2 access_name                 character (32) unaligned,
  4    14           2 mode                        bit (36) aligned,
  4    15           2 status_code                 fixed bin (35);
  4    16 
  4    17 
  4    18 declare 1 general_extended_acl          aligned based (acl_ptr), /* for fs_util_ */
  4    19           2 version                     char (8) aligned,
  4    20           2 count                       fixed bin,
  4    21           2 entries                     (acl_count refer (general_extended_acl.count)) aligned like general_extended_acl_entry;
  4    22 
  4    23 declare 1 general_extended_acl_entry    aligned based,
  4    24           2 access_name                 character (32) unaligned,
  4    25           2 mode                        bit (36) aligned,
  4    26           2 extended_mode               bit (36) aligned,
  4    27           2 status_code                 fixed bin (35);
  4    28 
  4    29 
  4    30 declare 1 general_delete_acl            aligned based (acl_ptr), /* for file_system_ */
  4    31           2 version                     char (8) aligned,
  4    32           2 count                       fixed bin,
  4    33           2 entries                     (acl_count refer (general_delete_acl.count)) aligned like delete_acl_entry;
  4    34 
  4    35 declare 1 general_delete_acl_entry      aligned based,
  4    36           2 access_name                 character (32) unaligned,
  4    37           2 status_code                 fixed bin (35);
  4    38 
  4    39 
  4    40 declare 1 segment_acl                   aligned based (acl_ptr),
  4    41           2 version                     fixed bin,
  4    42           2 count                       fixed bin,
  4    43           2 entries                     (acl_count refer (segment_acl.count)) aligned like segment_acl_entry;
  4    44 
  4    45 declare 1 segment_acl_entry             like general_extended_acl_entry aligned based;
  4    46 declare 1 segment_acl_array             (acl_count) aligned like segment_acl_entry based (acl_ptr);
  4    47 
  4    48 
  4    49 declare 1 directory_acl                 aligned based (acl_ptr),
  4    50           2 version                     fixed bin,
  4    51           2 count                       fixed bin,
  4    52           2 entries                     (acl_count refer (directory_acl.count)) aligned like directory_acl_entry;
  4    53 
  4    54 declare 1 directory_acl_entry           like general_acl_entry aligned based;
  4    55 declare 1 directory_acl_array           (acl_count) aligned like directory_acl_entry based (acl_ptr);
  4    56 
  4    57 
  4    58 declare 1 delete_acl                    based (acl_ptr) aligned,
  4    59           2 version                     fixed bin,
  4    60           2 count                       fixed bin,
  4    61           2 entries                     (acl_count refer (delete_acl.count)) aligned like delete_acl_entry;
  4    62 
  4    63 declare 1 delete_acl_entry              like general_delete_acl_entry aligned based;
  4    64 declare 1 delete_acl_array              (acl_count) aligned like delete_acl_entry based (acl_ptr);
  4    65 
  4    66 
  4    67 declare  (SEG_ACL_VERSION_1             init ("sga1"),
  4    68           DIR_ACL_VERSION_1             init ("dra1"),
  4    69           DELETE_ACL_VERSION_1          init ("dla1"))
  4    70                                         char (4) int static options (constant);
  4    71 
  4    72 declare  (GENERAL_ACL_VERSION_1         init ("gacl001"),
  4    73           GENERAL_EXTENDED_ACL_VERSION_1 init ("gxacl001"),
  4    74           GENERAL_DELETE_ACL_VERSION_1  init ("gdacl001"))
  4    75                                         char (8) internal static options (constant);
  4    76 
  4    77 declare   ACL_VERSION_1                 fixed bin init (1) int static options (constant);
  4    78 
  4    79 /* End include file acl_structures.incl.pl1 */
      136 
  5     1 /* BEGIN INCLUDE FILE sub_err_flags.incl.pl1 BIM 11/81 */
  5     2 /* format: style3 */
  5     3 
  5     4 /* These constants are to be used for the flags argument of sub_err_ */
  5     5 /* They are just "string (condition_info_header.action_flags)" */
  5     6 
  5     7 declare	(
  5     8 	ACTION_CAN_RESTART	init (""b),
  5     9 	ACTION_CANT_RESTART init ("1"b),
  5    10 	ACTION_DEFAULT_RESTART
  5    11 			init ("01"b),
  5    12 	ACTION_QUIET_RESTART
  5    13 			init ("001"b),
  5    14 	ACTION_SUPPORT_SIGNAL
  5    15 			init ("0001"b)
  5    16 	)		bit (36) aligned internal static options (constant);
  5    17 
  5    18 /* End include file */
      137 
      138 /* format: on */
      139 
      140 
      141 
      142 /* Deletes a message segment */
      143 
      144 delentry_file:
      145      entry (P_dirname, P_ename, P_code);
      146 
      147           call message_segment_$delete (P_dirname, P_ename, P_code);
      148           return;
      149 
      150 
      151 
      152 /* Changes the names on a message segment */
      153 
      154 chname_file:
      155      entry (P_dirname, P_ename, P_old_name, P_new_name, P_code);
      156 
      157           call message_segment_$chname_file (P_dirname, P_ename, P_old_name, P_new_name, P_code);
      158           return;
      159 
      160 /* copies a message segment */
      161 
      162 copy:
      163      entry (P_copy_options_ptr, P_code);
      164 
      165           copy_options_ptr = P_copy_options_ptr;
      166           if copy_options.extend | copy_options.update
      167           then do;
      168                     P_code = error_table_$unsupported_operation;
      169                     return;
      170                end;
      171 
      172           call message_segment_$copy (copy_options.source_dir, copy_options.source_name, copy_options.target_dir,
      173                copy_options.target_name, err_switch, P_code);
      174 
      175           copy_options.target_err_switch = err_switch;
      176           return;
      177 
      178 
      179 /* validates that an entry is a message segment */
      180 
      181 validate:
      182      entry (P_dirname, P_ename, P_code);
      183 
      184           call message_segment_$validate (P_dirname, P_ename, P_code);
      185           return;
      186 
      187 
      188 /* Returns information about message segments */
      189 
      190 suffix_info:
      191      entry (P_suffix_info_ptr);
      192 
      193           suffix_info_ptr = P_suffix_info_ptr;
      194 
      195           if suffix_info.version ^= SUFFIX_INFO_VERSION_1
      196           then call sub_err_ (error_table_$unimplemented_version, "bad suffix info version", ACTION_CANT_RESTART, null (),
      197                     (0), "Invalid version ^a in call to suffix_ms_$suffix_info.", suffix_info.version);
      198           suffix_info.type = "ms";
      199           suffix_info.type_name = "message segment";
      200           suffix_info.plural_name = "message segments";
      201           string (suffix_info.flags) = ""b;
      202           suffix_info.extended_acl = "0"b;
      203           suffix_info.has_switches = "1"b;
      204           suffix_info.modes = "adros";
      205           suffix_info.max_mode_len = 5;
      206           suffix_info.num_ring_brackets = 0;                /* Don't display them */
      207           string (suffix_info.copy_flags) = ""b;
      208           suffix_info.copy_flags.names, suffix_info.copy_flags.acl, suffix_info.copy_flags.max_length,
      209                suffix_info.copy_flags.safety_switch = "1"b;
      210 
      211           suffix_info.info_pathname = "extended_access.gi.info";
      212 
      213           return;
      214 
      215 /* returns names of non-standard switches */
      216 
      217 list_switches:
      218      entry (P_desired_version, P_user_area_ptr, P_switch_list_ptr, P_code);
      219 
      220           if P_desired_version ^= SWITCH_LIST_VERSION_1
      221           then do;
      222                     P_code = error_table_$unimplemented_version;
      223                     return;
      224                end;
      225           alloc_switch_count, alloc_switch_name_count = 1;
      226           user_area_ptr = P_user_area_ptr;
      227           if user_area_ptr = null ()
      228           then user_area_ptr = get_user_free_area_ ();
      229 
      230           allocate switch_list in (user_area);
      231 
      232           switch_list.version = SWITCH_LIST_VERSION_1;
      233           switch_list.switches (1).name_index = 1;
      234           switch_list.switches (1).name_count = 1;
      235           switch_list.switches (1).default_value = "0"b;
      236           switch_list.names (1) = "safety";
      237 
      238           P_switch_list_ptr = switch_list_ptr;
      239           return;
      240 
      241 /* Adds ACL entries to a message segment */
      242 /**** This has to convert structures from the new interface to the old one. */
      243 
      244 add_acl_entries:
      245      entry (P_dirname, P_ename, P_acl_ptr, P_code);
      246 
      247           old_acl_ptr = null ();
      248 
      249           on cleanup
      250                begin;
      251                     if old_acl_ptr ^= null ()
      252                     then do;
      253                               free old_acl_ptr -> segment_acl_array;
      254                               old_acl_ptr = null ();
      255                          end;
      256                end;
      257 
      258           acl_ptr = P_acl_ptr;
      259           acl_count = general_acl.count;
      260           allocate segment_acl_array in (system_free_area) set (old_acl_ptr);
      261           do idx = 1 to acl_count;                          /* no aggregate, since we rearrange */
      262                old_acl_ptr -> segment_acl_array (idx).access_name = general_acl.entries (idx).access_name;
      263                old_acl_ptr -> segment_acl_array (idx).mode = ""b;
      264                old_acl_ptr -> segment_acl_array (idx).extended_mode = general_acl.entries (idx).mode;
      265                old_acl_ptr -> segment_acl_array (idx).status_code = 0;
      266           end;
      267 
      268           call message_segment_$ms_acl_add (P_dirname, P_ename, old_acl_ptr, acl_count, P_code);
      269           general_acl.entries (*).status_code = old_acl_ptr -> segment_acl_array (*).status_code;
      270           free old_acl_ptr -> segment_acl_array;
      271           return;
      272 
      273 
      274 
      275 /* Lists ACL entries on a message segment */
      276 
      277 list_acl:
      278      entry (P_dirname, P_ename, P_desired_version, P_user_area_ptr, P_acl_ptr, P_code);
      279 
      280           old_acl_ptr = null ();
      281 
      282           on cleanup
      283                begin;
      284                     if old_acl_ptr ^= null ()
      285                     then do;
      286                               free old_acl_ptr -> segment_acl_array;
      287                               old_acl_ptr = null ();
      288                          end;
      289                end;
      290 
      291 	user_area_ptr = P_user_area_ptr;
      292           acl_ptr = P_acl_ptr;
      293 
      294           if acl_ptr ^= null ()
      295           then do;                                          /* wants to list specific entries */
      296                     if general_acl.version ^= GENERAL_ACL_VERSION_1
      297                     then do;
      298                               P_code = error_table_$unimplemented_version;
      299                               return;
      300                          end;
      301                     acl_count = general_acl.count;
      302                     allocate segment_acl_array in (system_free_area) set (old_acl_ptr);
      303                                                             /* only access_name is interesting */
      304                     old_acl_ptr -> segment_acl_array (*).access_name = general_acl.entries (*).access_name;
      305 
      306                     call message_segment_$ms_acl_list (P_dirname, P_ename, old_acl_ptr, acl_count, null (), P_code);
      307                     general_acl.entries (*).mode = old_acl_ptr -> segment_acl_array (*).extended_mode;
      308                     general_acl.entries (*).status_code = old_acl_ptr -> segment_acl_array (*).status_code;
      309                     free old_acl_ptr -> segment_acl_array;
      310 
      311                end;
      312 
      313 
      314           else do;                                          /* wants to list an acl entirely */
      315                     if P_desired_version ^= GENERAL_ACL_VERSION_1
      316                     then do;
      317                               P_code = error_table_$unimplemented_version;
      318                               return;
      319                          end;
      320                     if user_area_ptr = null ()
      321                     then user_area_ptr = get_user_free_area_ ();
      322                     call message_segment_$ms_acl_list (P_dirname, P_ename, old_acl_ptr, acl_count,
      323                          get_system_free_area_ (), P_code); /* caller wants the entire ACL */
      324 		if P_code ^= 0 then return;
      325                     if acl_count = 0
      326                     then do;
      327                               P_acl_ptr = null ();
      328                               return;
      329                          end;
      330 
      331                     allocate general_acl in (user_area);
      332                     P_acl_ptr = acl_ptr;
      333                     general_acl.version = GENERAL_ACL_VERSION_1;
      334                     do idx = 1 to acl_count;
      335                          general_acl.entries (idx).access_name = old_acl_ptr -> segment_acl_array (idx).access_name;
      336                          general_acl.entries (idx).mode = old_acl_ptr -> segment_acl_array (idx).extended_mode;
      337                          general_acl.entries (*).status_code = 0;
      338                     end;
      339                     free old_acl_ptr -> segment_acl_array;
      340                     P_acl_ptr = acl_ptr;
      341                end;
      342 
      343           return;
      344 
      345 /* Deletes ACL entries from a message segment */
      346 
      347 delete_acl_entries:
      348      entry (P_dirname, P_ename, P_acl_ptr, P_code);
      349 
      350           old_acl_ptr = null ();
      351 
      352           on cleanup
      353                begin;
      354                     if old_acl_ptr ^= null ()
      355                     then do;
      356                               free old_acl_ptr -> segment_acl_array;
      357                               old_acl_ptr = null ();
      358                          end;
      359                end;
      360 
      361           acl_ptr = P_acl_ptr;
      362           acl_count = general_delete_acl.count;
      363 
      364           allocate segment_acl_array in (system_free_area) set (old_acl_ptr);
      365           segment_acl_array (*).access_name = general_delete_acl.entries (*).access_name;
      366 
      367           call message_segment_$ms_acl_delete (P_dirname, P_ename, old_acl_ptr, acl_count, null (), P_code);
      368 
      369           general_delete_acl.entries (*).status_code = old_acl_ptr -> segment_acl_array (*).status_code;
      370           free old_acl_ptr -> segment_acl_array;
      371 
      372           return;
      373 
      374 /* Replaces the ACL of a message segment */
      375 
      376 /**** NOTE -- the default SysDaemon access for an mseg is NULL.
      377*      Therefore, the no_sysdaemon switch is a noop. */
      378 
      379 replace_acl:
      380      entry (P_dirname, P_ename, P_acl_ptr, P_no_sysdaemon, P_code);
      381 
      382           old_acl_ptr = null ();
      383 
      384           on cleanup
      385                begin;
      386                     if old_acl_ptr ^= null ()
      387                     then do;
      388                               free old_acl_ptr -> segment_acl_array;
      389                               old_acl_ptr = null ();
      390                          end;
      391                end;
      392 
      393           acl_ptr = P_acl_ptr;
      394           acl_count = general_acl.count;
      395 
      396           if acl_count = 0                                  /* cannot have no_sysdaemon */
      397           then do;
      398                     call message_segment_$ms_acl_replace (P_dirname, P_ename, null (), -1, P_code);
      399                     return;
      400                end;
      401 
      402           allocate segment_acl_array in (system_free_area) set (old_acl_ptr);
      403 
      404           do idx = 1 to acl_count;                          /* no need to splice in funny acl */
      405                old_acl_ptr -> segment_acl_array (idx).access_name = general_acl.entries (idx).access_name;
      406                old_acl_ptr -> segment_acl_array (idx).extended_mode = general_acl.entries (idx).mode;
      407                old_acl_ptr -> segment_acl_array (idx).mode = ""b;
      408                old_acl_ptr -> segment_acl_array (idx).status_code = 0;
      409 
      410           end;
      411 
      412           call message_segment_$ms_acl_replace (P_dirname, P_ename, old_acl_ptr, acl_count, P_code);
      413 
      414           general_acl.entries (*).status_code = old_acl_ptr -> segment_acl_array (*).status_code;
      415           free old_acl_ptr -> segment_acl_array;
      416 
      417           return;
      418 
      419 get_switch:
      420      entry (P_dirname, P_ename, P_switch_name, P_value, P_code);
      421 
      422           call message_segment_$validate (P_dirname, P_ename, P_code);
      423           if P_code = 0
      424           then do;
      425                     if P_switch_name = "safety"
      426                     then do;
      427                               call hcs_$get_safety_sw (P_dirname, P_ename, value, P_code);
      428                               P_value = value;
      429                          end;
      430                     else P_code = error_table_$argerr;
      431                end;
      432 
      433           return;
      434 
      435 set_switch:
      436      entry (P_dirname, P_ename, P_switch_name, P_value, P_code);
      437 
      438           call message_segment_$validate (P_dirname, P_ename, P_code);
      439           if P_code = 0
      440           then do;
      441                     if P_switch_name = "safety"
      442                     then call message_segment_$set_safety_switch (P_dirname, P_ename, P_value, P_code);
      443                     else P_code = error_table_$argerr;
      444                end;
      445 
      446           return;
      447 
      448 get_max_length:
      449      entry (P_dirname, P_ename, P_max_length, P_code);
      450 
      451           call message_segment_$validate (P_dirname, P_ename, P_code);
      452           if P_code = 0
      453           then call hcs_$get_max_length (P_dirname, P_ename, P_max_length, P_code);
      454           return;
      455 
      456 set_max_length:
      457      entry (P_dirname, P_ename, P_max_length, P_code);
      458 
      459           call message_segment_$set_max_length_file (P_dirname, P_ename, P_max_length, P_code);
      460           return;
      461 
      462 
      463 get_user_access_modes:
      464      entry (P_dirname, P_ename, P_user_name, P_ring, P_modes, P_exmodes, P_code);
      465 
      466           P_exmodes = ""b;                                  /* msegs, like dirs, have only modes, no exmodes */
      467           call message_segment_$validate (P_dirname, P_ename, P_code);
      468           if P_code = 0
      469           then call hcs_$get_user_access_modes (P_dirname, P_ename, P_user_name, P_ring, ((36)"0"b), P_modes, P_code);
      470           return;
      471 
      472      end suffix_ms_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    05/06/85  1617.7  suffix_ms_.pl1                    >spec>on>mseg>suffix_ms_.pl1
133          1    03/05/85  1807.3  suffix_info.incl.pl1              >ldd>include>suffix_info.incl.pl1
134          2    10/14/83  1606.7  copy_options.incl.pl1             >ldd>include>copy_options.incl.pl1
135          3    10/14/83  1606.7  copy_flags.incl.pl1               >ldd>include>copy_flags.incl.pl1
136          4    10/14/83  1606.6  acl_structures.incl.pl1           >ldd>include>acl_structures.incl.pl1
137          5    04/16/82  0958.1  sub_err_flags.incl.pl1            >ldd>include>sub_err_flags.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ACTION_CANT_RESTART             000006 constant        bit(36)                  initial dcl 5-7 set ref 195*
GENERAL_ACL_VERSION_1           000000 constant        char(8)                  initial unaligned dcl 4-72 ref 296 315 333
P_acl_ptr                              parameter       pointer                  dcl 53 set ref 244 258 277 292 327* 332* 340* 347
                                                                                  361 379 393
P_code                                 parameter       fixed bin(35,0)          dcl 33 set ref 144 147* 154 157* 162 168* 172* 181
                                                                                  184* 217 222* 244 268* 277 298* 306* 317* 322* 324
                                                                                  347 367* 379 398* 412* 419 422* 423 427* 430* 435
                                                                                  438* 439 441* 443* 448 451* 452 452* 456 459* 463
                                                                                  467* 468 468*
P_copy_options_ptr                     parameter       pointer                  dcl 49 ref 162 165
P_desired_version                      parameter       char                     unaligned dcl 28 ref 217 220 277 315
P_dirname                              parameter       char                     unaligned dcl 29 set ref 144 147* 154 157* 181 184*
                                                                                  244 268* 277 306* 322* 347 367* 379 398* 412* 419
                                                                                  422* 427* 435 438* 441* 448 451* 452* 456 459* 463
                                                                                  467* 468*
P_ename                                parameter       char                     unaligned dcl 31 set ref 144 147* 154 157* 181 184*
                                                                                  244 268* 277 306* 322* 347 367* 379 398* 412* 419
                                                                                  422* 427* 435 438* 441* 448 451* 452* 456 459* 463
                                                                                  467* 468*
P_exmodes                              parameter       bit(36)                  dcl 79 set ref 463 466*
P_max_length                           parameter       fixed bin(19,0)          dcl 75 set ref 448 452* 456 459*
P_modes                                parameter       bit(36)                  dcl 79 set ref 463 468*
P_new_name                             parameter       char                     unaligned dcl 44 set ref 154 157*
P_no_sysdaemon                         parameter       bit(1)                   unaligned dcl 65 ref 379
P_old_name                             parameter       char                     unaligned dcl 42 set ref 154 157*
P_ring                                 parameter       fixed bin(17,0)          dcl 80 set ref 463 468*
P_suffix_info_ptr                      parameter       pointer                  dcl 37 ref 190 193
P_switch_list_ptr                      parameter       pointer                  dcl 38 set ref 217 238*
P_switch_name                          parameter       char                     unaligned dcl 70 ref 419 425 435 441
P_user_area_ptr                        parameter       pointer                  dcl 59 ref 217 226 277 291
P_user_name                            parameter       char                     unaligned dcl 81 set ref 463 468*
P_value                                parameter       bit(1)                   dcl 71 set ref 419 428* 435 441*
SUFFIX_INFO_VERSION_1           000004 constant        char(8)                  initial unaligned dcl 1-29 ref 195
SWITCH_LIST_VERSION_1           000002 constant        char(8)                  initial unaligned dcl 1-48 ref 220 232
access_name               3            based           char(32)                 array level 3 in structure "general_acl" packed
                                                                                  unaligned dcl 4-7 in procedure "suffix_ms_" set
                                                                                  ref 262 304 335* 405
access_name                            based           char(32)                 array level 2 in structure "segment_acl_array"
                                                                                  packed unaligned dcl 4-46 in procedure
                                                                                  "suffix_ms_" set ref 262* 304* 335 365* 405*
access_name               3            based           char(32)                 array level 3 in structure "general_delete_acl"
                                                                                  packed unaligned dcl 4-30 in procedure
                                                                                  "suffix_ms_" ref 365
acl                      46(01)        based           bit(1)                   level 3 packed unaligned dcl 1-12 set ref 208*
acl_count                       000130 automatic       fixed bin(17,0)          dcl 4-5 set ref 253 259* 260 261 268* 269 270 286
                                                                                  301* 302 304 306* 307 308 309 322* 325 331 331 334
                                                                                  339 356 362* 364 365 367* 369 370 388 394* 396 402
                                                                                  404 412* 414 415
acl_ptr                         000126 automatic       pointer                  dcl 4-4 set ref 258* 259 262 264 269 292* 294 296
                                                                                  301 304 307 308 331* 332 333 335 336 337 340 361*
                                                                                  362 365 365 369 393* 394 405 406 414
alloc_switch_count              000122 automatic       fixed bin(17,0)          dcl 1-33 set ref 225* 230 230
alloc_switch_name_count         000123 automatic       fixed bin(17,0)          dcl 1-33 set ref 225* 230 230
cleanup                         000110 stack reference condition                dcl 130 ref 249 282 352 384
copy_flags               46            based           structure                level 2 in structure "suffix_info" dcl 1-12
                                                                                  in procedure "suffix_ms_" set ref 207*
copy_flags                             based           structure                level 1 dcl 3-8 in procedure "suffix_ms_"
copy_items              157            based           structure                level 2 dcl 2-12
copy_options                           based           structure                level 1 dcl 2-12
copy_options_ptr                000124 automatic       pointer                  dcl 2-10 set ref 165* 166 166 172 172 172 172 175
count                     2            based           fixed bin(17,0)          level 2 in structure "general_delete_acl" dcl 4-30
                                                                                  in procedure "suffix_ms_" ref 362 365 365 365 365
                                                                                  369
count                     2            based           fixed bin(17,0)          level 2 in structure "general_acl" dcl 4-7
                                                                                  in procedure "suffix_ms_" set ref 259 269 301 304
                                                                                  304 304 304 307 308 331* 337 394 414
default_value             6            based           bit(1)                   array level 3 dcl 1-37 set ref 235*
delete_acl_entry                       based           structure                level 1 dcl 4-63
directory_acl_entry                    based           structure                level 1 dcl 4-54
entries                   3            based           structure                array level 2 in structure "general_acl" dcl 4-7
                                                                                  in procedure "suffix_ms_"
entries                   3            based           structure                array level 2 in structure "general_delete_acl"
                                                                                  dcl 4-30 in procedure "suffix_ms_"
err_switch                      000106 automatic       bit(1)                   dcl 94 set ref 172* 175
error_table_$argerr             000010 external static fixed bin(35,0)          dcl 96 ref 430 443
error_table_$unimplemented_version
                                000014 external static fixed bin(35,0)          dcl 99 set ref 195* 222 298 317
error_table_$unsupported_operation
                                000012 external static fixed bin(35,0)          dcl 97 ref 168
extend                  157(08)        based           bit(1)                   level 3 packed unaligned dcl 2-12 ref 166
extended_acl             32(01)        based           bit(1)                   level 3 packed unaligned dcl 1-12 set ref 202*
extended_mode            11            based           bit(36)                  array level 2 dcl 4-46 set ref 264* 307 336 406*
flags                    32            based           structure                level 2 in structure "suffix_info" packed unaligned
                                                                                  dcl 1-12 in procedure "suffix_ms_" set ref 201*
flags                   156            based           structure                level 2 in structure "copy_options" dcl 2-12
                                                                                  in procedure "suffix_ms_"
general_acl                            based           structure                level 1 dcl 4-7 set ref 331
general_acl_entry                      based           structure                level 1 unaligned dcl 4-12
general_delete_acl                     based           structure                level 1 dcl 4-30
general_delete_acl_entry               based           structure                level 1 dcl 4-35
general_extended_acl_entry             based           structure                level 1 dcl 4-23
get_system_free_area_           000016 constant        entry                    external dcl 102 ref 260 302 322 322 364 402
get_user_free_area_             000020 constant        entry                    external dcl 102 ref 227 320
has_switches             32(02)        based           bit(1)                   level 3 packed unaligned dcl 1-12 set ref 203*
hcs_$get_max_length             000022 constant        entry                    external dcl 104 ref 452
hcs_$get_safety_sw              000024 constant        entry                    external dcl 105 ref 427
hcs_$get_user_access_modes      000026 constant        entry                    external dcl 106 ref 468
idx                             000104 automatic       fixed bin(17,0)          dcl 91 set ref 261* 262 262 263 264 264 265* 334*
                                                                                  335 335 336 336* 404* 405 405 406 406 407 408*
info_pathname            47            based           char(168)                level 2 packed unaligned dcl 1-12 set ref 211*
max_length               46(03)        based           bit(1)                   level 3 packed unaligned dcl 1-12 set ref 208*
max_mode_len             44            based           fixed bin(17,0)          level 2 dcl 1-12 set ref 205*
message_segment_$chname_file    000032 constant        entry                    external dcl 110 ref 157
message_segment_$copy           000030 constant        entry                    external dcl 108 ref 172
message_segment_$delete         000034 constant        entry                    external dcl 112 ref 147
message_segment_$ms_acl_add     000036 constant        entry                    external dcl 113 ref 268
message_segment_$ms_acl_delete  000040 constant        entry                    external dcl 115 ref 367
message_segment_$ms_acl_list    000042 constant        entry                    external dcl 118 ref 306 322
message_segment_$ms_acl_replace 000044 constant        entry                    external dcl 120 ref 398 412
message_segment_$set_max_length_file
                                000046 constant        entry                    external dcl 123 ref 459
message_segment_$set_safety_switch
                                000050 constant        entry                    external dcl 125 ref 441
message_segment_$validate       000052 constant        entry                    external dcl 127 ref 184 422 438 451 467
mode                     13            based           bit(36)                  array level 3 in structure "general_acl" dcl 4-7
                                                                                  in procedure "suffix_ms_" set ref 264 307* 336*
                                                                                  406
mode                     10            based           bit(36)                  array level 2 in structure "segment_acl_array"
                                                                                  dcl 4-46 in procedure "suffix_ms_" set ref 263*
                                                                                  407*
modes                    33            based           char(36)                 level 2 dcl 1-12 set ref 204*
name_count                5            based           fixed bin(17,0)          array level 3 dcl 1-37 set ref 234*
name_index                4            based           fixed bin(17,0)          array level 3 dcl 1-37 set ref 233*
names                                  based           char(32)                 array level 2 in structure "switch_list" dcl 1-37
                                                                                  in procedure "suffix_ms_" set ref 236*
names                    46            based           bit(1)                   level 3 in structure "suffix_info" packed unaligned
                                                                                  dcl 1-12 in procedure "suffix_ms_" set ref 208*
null                                                   builtin function         dcl 132 ref 195 195 227 247 251 254 280 284 287 294
                                                                                  306 306 320 327 350 354 357 367 367 382 386 389
                                                                                  398 398
num_ring_brackets        45            based           fixed bin(17,0)          level 2 dcl 1-12 set ref 206*
old_acl_ptr                     000100 automatic       pointer                  dcl 85 set ref 247* 251 253 254* 260* 262 263 264
                                                                                  265 268* 269 270 280* 284 286 287* 302* 304 306*
                                                                                  307 308 309 322* 335 336 339 350* 354 356 357*
                                                                                  364* 367* 369 370 382* 386 388 389* 402* 405 406
                                                                                  407 408 412* 414 415
plural_name              22            based           char(32)                 level 2 packed unaligned dcl 1-12 set ref 200*
safety_switch            46(05)        based           bit(1)                   level 3 packed unaligned dcl 1-12 set ref 208*
segment_acl_array                      based           structure                array level 1 dcl 4-46 set ref 253 260 270 286 302
                                                                                  309 339 356 364 370 388 402 415
segment_acl_entry                      based           structure                level 1 dcl 4-45
source_dir               12            based           char(168)                level 2 packed unaligned dcl 2-12 set ref 172*
source_name              64            based           char(32)                 level 2 packed unaligned dcl 2-12 set ref 172*
status_code              13            based           fixed bin(35,0)          array level 3 in structure "general_delete_acl"
                                                                                  dcl 4-30 in procedure "suffix_ms_" set ref 369*
status_code              12            based           fixed bin(35,0)          array level 2 in structure "segment_acl_array"
                                                                                  dcl 4-46 in procedure "suffix_ms_" set ref 265*
                                                                                  269 308 369 408* 414
status_code              14            based           fixed bin(35,0)          array level 3 in structure "general_acl" dcl 4-7
                                                                                  in procedure "suffix_ms_" set ref 269* 308* 337*
                                                                                  414*
sub_err_                        000054 constant        entry                    external dcl 128 ref 195
suffix_info                            based           structure                level 1 dcl 1-12
suffix_info_ptr                 000116 automatic       pointer                  dcl 1-10 set ref 193* 195 195 198 199 200 201 202
                                                                                  203 204 205 206 207 208 208 208 208 211
switch_count              2            based           fixed bin(17,0)          level 2 dcl 1-37 set ref 230* 236
switch_list                            based           structure                level 1 dcl 1-37 set ref 230
switch_list_ptr                 000120 automatic       pointer                  dcl 1-33 set ref 230* 232 233 234 235 236 238
switch_name_count         3            based           fixed bin(17,0)          level 2 dcl 1-37 set ref 230*
switches                  4            based           structure                array level 2 dcl 1-37
system_free_area                       based           area(1024)               dcl 89 ref 260 302 364 402
target_dir               74            based           char(168)                level 2 packed unaligned dcl 2-12 set ref 172*
target_err_switch       156(04)        based           bit(1)                   level 3 packed unaligned dcl 2-12 set ref 175*
target_name             146            based           char(32)                 level 2 packed unaligned dcl 2-12 set ref 172*
type                      2            based           char(32)                 level 2 packed unaligned dcl 1-12 set ref 198*
type_name                12            based           char(32)                 level 2 packed unaligned dcl 1-12 set ref 199*
update                  157(09)        based           bit(1)                   level 3 packed unaligned dcl 2-12 ref 166
user_area                              based           area(1024)               dcl 88 ref 230 331
user_area_ptr                   000102 automatic       pointer                  dcl 87 set ref 226* 227 227* 230 291* 320 320* 331
value                           000105 automatic       bit(1)                   unaligned dcl 93 set ref 427* 428
version                                based           char(8)                  level 2 in structure "switch_list" dcl 1-37
                                                                                  in procedure "suffix_ms_" set ref 232*
version                                based           char(8)                  level 2 in structure "suffix_info" dcl 1-12
                                                                                  in procedure "suffix_ms_" set ref 195 195*
version                                based           char(8)                  level 2 in structure "general_acl" dcl 4-7
                                                                                  in procedure "suffix_ms_" set ref 296 333*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ACL_VERSION_1                          internal static fixed bin(17,0)          initial dcl 4-77
ACTION_CAN_RESTART                     internal static bit(36)                  initial dcl 5-7
ACTION_DEFAULT_RESTART                 internal static bit(36)                  initial dcl 5-7
ACTION_QUIET_RESTART                   internal static bit(36)                  initial dcl 5-7
ACTION_SUPPORT_SIGNAL                  internal static bit(36)                  initial dcl 5-7
COPY_OPTIONS_VERSION_1                 internal static char(8)                  initial unaligned dcl 2-28
DELETE_ACL_VERSION_1                   internal static char(4)                  initial unaligned dcl 4-67
DIR_ACL_VERSION_1                      internal static char(4)                  initial unaligned dcl 4-67
FS_OBJECT_TYPE_DIRECTORY               internal static char(32)                 initial unaligned dcl 1-50
FS_OBJECT_TYPE_DM_FILE                 internal static char(32)                 initial unaligned dcl 1-50
FS_OBJECT_TYPE_LINK                    internal static char(32)                 initial unaligned dcl 1-50
FS_OBJECT_TYPE_MSF                     internal static char(32)                 initial unaligned dcl 1-50
FS_OBJECT_TYPE_SEGMENT                 internal static char(32)                 initial unaligned dcl 1-50
GENERAL_DELETE_ACL_VERSION_1           internal static char(8)                  initial unaligned dcl 4-72
GENERAL_EXTENDED_ACL_VERSION_1         internal static char(8)                  initial unaligned dcl 4-72
SEG_ACL_VERSION_1                      internal static char(4)                  initial unaligned dcl 4-67
delete_acl                             based           structure                level 1 dcl 4-58
delete_acl_array                       based           structure                array level 1 dcl 4-64
directory_acl                          based           structure                level 1 dcl 4-49
directory_acl_array                    based           structure                array level 1 dcl 4-55
general_extended_acl                   based           structure                level 1 dcl 4-18
rings                                  automatic       fixed bin(3,0)           array dcl 92
segment_acl                            based           structure                level 1 dcl 4-40

NAMES DECLARED BY EXPLICIT CONTEXT.
add_acl_entries                 000706 constant        entry                    external dcl 244
chname_file                     000166 constant        entry                    external dcl 154
copy                            000263 constant        entry                    external dcl 162
delentry_file                   000113 constant        entry                    external dcl 144
delete_acl_entries              001663 constant        entry                    external dcl 347
get_max_length                  002714 constant        entry                    external dcl 448
get_switch                      002443 constant        entry                    external dcl 419
get_user_access_modes           003077 constant        entry                    external dcl 463
list_acl                        001140 constant        entry                    external dcl 277
list_switches                   000565 constant        entry                    external dcl 217
replace_acl                     002151 constant        entry                    external dcl 379
set_max_length                  003016 constant        entry                    external dcl 456
set_switch                      002570 constant        entry                    external dcl 435
suffix_info                     000424 constant        entry                    external dcl 190
suffix_ms_                      000101 constant        entry                    external dcl 22
validate                        000352 constant        entry                    external dcl 181

NAME DECLARED BY CONTEXT OR IMPLICATION.
string                                                 builtin function         set ref 201 207*

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3642        3720    3224        3652
Length      4266    3224        56         332     415           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
suffix_ms_                          204 external procedure  is an external procedure.  
on unit on line 249                  64 on unit               
on unit on line 282                  64 on unit               
on unit on line 352                  64 on unit               
on unit on line 384                  64 on unit               

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
suffix_ms_               000100 old_acl_ptr                 suffix_ms_
                         000102 user_area_ptr               suffix_ms_
                         000104 idx                         suffix_ms_
                         000105 value                       suffix_ms_
                         000106 err_switch                  suffix_ms_
                         000116 suffix_info_ptr             suffix_ms_
                         000120 switch_list_ptr             suffix_ms_
                         000122 alloc_switch_count          suffix_ms_
                         000123 alloc_switch_name_count     suffix_ms_
                         000124 copy_options_ptr            suffix_ms_
                         000126 acl_ptr                     suffix_ms_
                         000130 acl_count                   suffix_ms_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_temp          call_ext_out_desc   call_ext_out        return              bound_check_signal  enable
shorten_stack       ext_entry           ext_entry_desc      int_entry           alloc_based         free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_system_free_area_         get_user_free_area_           hcs_$get_max_length           hcs_$get_safety_sw
hcs_$get_user_access_modes    message_segment_$chname_file  message_segment_$copy         message_segment_$delete
message_segment_$ms_acl_add   message_segment_$ms_acl_delete                              message_segment_$ms_acl_list
message_segment_$ms_acl_replace                             message_segment_$set_max_length_file
message_segment_$set_safety_switch                          message_segment_$validate     sub_err_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$argerr           error_table_$unimplemented_version
error_table_$unsupported_operation




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     22 000100       144 000106       147 000136       148 000160       154 000161       157 000223       158 000256
    162 000257       165 000273       166 000277       168 000302       169 000305       172 000306       175 000341
    176 000347       181 000350       184 000375       185 000420       190 000421       193 000431       195 000435
    198 000516       199 000522       200 000525       201 000530       202 000531       203 000533       204 000535
    205 000540       206 000542       207 000543       208 000544       211 000554       213 000557       217 000560
    220 000604       222 000615       223 000620       225 000621       226 000624       227 000627       230 000642
    232 000661       233 000664       234 000666       235 000667       236 000670       238 000676       239 000700
    244 000701       247 000733       249 000735       251 000751       253 000756       254 000762       256 000765
    258 000766       259 000771       260 000773       261 001010       262 001017       263 001032       264 001034
    265 001037       266 001040       268 001042       269 001075       270 001125       271 001131       277 001132
    280 001173       282 001175       284 001211       286 001216       287 001222       289 001225       291 001226
    292 001231       294 001234       296 001240       298 001244       299 001247       301 001250       302 001252
    304 001267       306 001350       307 001411       308 001441       309 001461       311 001465       315 001466
    317 001477       318 001502       320 001503       322 001516       324 001563       325 001565       327 001567
    328 001571       331 001572       332 001603       333 001604       334 001607       335 001617       336 001632
    337 001636       338 001650       339 001652       340 001656       343 001660       347 001661       350 001710
    352 001712       354 001726       356 001733       357 001737       359 001742       361 001743       362 001746
    364 001750       365 001765       367 002046       369 002107       370 002137       372 002143       379 002144
    382 002176       384 002200       386 002214       388 002221       389 002225       391 002230       393 002231
    394 002234       396 002236       398 002237       399 002276       402 002277       404 002314       405 002323
    406 002336       407 002342       408 002343       410 002344       412 002346       414 002401       415 002431
    417 002435       419 002436       422 002473       423 002516       425 002520       427 002527       428 002555
    429 002561       430 002562       433 002565       435 002566       438 002620       439 002643       441 002645
    443 002703       446 002706       448 002707       451 002737       452 002762       454 003013       456 003014
    459 003041       460 003070       463 003071       466 003127       467 003131       468 003153       470 003221


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
