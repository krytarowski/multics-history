	COMPILATION LISTING OF SEGMENT change_index
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/04/82  1731.0 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 change_index:
       12      proc (iocb_ptr, abort_exit);
       13 	indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
       14 	f_b_ptr = file_base_ptr;
       15 	fs_ptr = indx_cb.file_state_ptr;
       16 	is_ptr = indx_cb.index_state_ptr;
       17 	call initialize_substate;
       18 	do while (index_action ^= 0);			/* the change cycle */
       19 	     pos_ptr = change_position_ptr;
       20 	     call prepare_next_state;
       21 	     call save_node_head;
       22 	     if index_action = insert_action
       23 	     then do;
       24 		     if last_branch_num = 1
       25 		     then call insert_at_root;
       26 		     else do;
       27 			     call set_new_cont_space;
       28 			     space = scat_space + new_cont_space;
       29 			     if space < 0
       30 			     then call overflow;
       31 			     else do;
       32 				     call simple_insert (branch_num);
       33 				     call adjust_branch_num;
       34 				end;
       35 			end;
       36 		end;				/* end insert action */
       37 	     else do;
       38 		     call set_old_key_info;
       39 		     if index_action = delete_action
       40 		     then do;
       41 			     call simple_delete;
       42 			     space = cont_space (node_ptr) + scat_space;
       43 			     if space > half_node_length
       44 			     then call underflow;
       45 			     else call adjust_branch_num;
       46 			end;			/* end delete action */
       47 		     else do;			/* replace action */
       48 			     x = old_key_length - new_key_length;
       49 			     if x = 0
       50 			     then do;
       51 				     record_designator (branch_num) = new_record_designator;
       52 						/* should use record_descrip, but compiler problems */
       53 				     substr (keys, key_pos (branch_num), new_key_length) =
       54 					substr (new_key_string, 1, new_key_length);
       55 				     call adjust_branch_num;
       56 				end;
       57 			     else do;
       58 				     y = cont_space (node_ptr);
       59 				     space = y + scat_space + x;
       60 				     if space >= 0
       61 				     then do;	/* key will fit */
       62 					     call replace_key;
       63 					     if space > half_node_length
       64 					     then call underflow;
       65 					     else call adjust_branch_num;
       66 					end;
       67 				     else do;	/* key won't fit, turn into overflow-insert */
       68 					     call set_new_branch;
       69 					     call simple_delete;
       70 					     call overflow;
       71 					end;
       72 				end;
       73 			end;			/* end replace action */
       74 		end;
       75 	     call switch_index_state;
       76 	end;					/* end change cycle */
       77 	return;					/* end change_index routine */
       78 
       79 prepare_next_state:
       80      proc;					/* sets up alternate index state variables */
       81 	a_s_ptr = addr (index_state_blocks (1 - index_state));
       82 	a_s_ptr -> index_action = 0;
       83 	a_s_ptr -> index_substate = 0;
       84 	a_s_ptr -> branch_num_adjust = 0;
       85 	a_s_ptr -> index_height = index_height;
       86 	a_s_ptr -> current_node = file_position_ptr -> node;
       87 	a_s_ptr -> number_of_nodes = number_of_nodes;
       88 	a_s_ptr -> index_tail_comp_num = index_tail_comp_num;
       89 	a_s_ptr -> free_node_designator = free_node_designator;
       90      end prepare_next_state;
       91 
       92 initialize_substate:
       93      proc;
       94 	if repeating
       95 	then do;
       96 		if index_substate = 0
       97 		then repeating = "0"b;
       98 		else next_substate = 0;
       99 		return;				/* don't alter permanent substate vars */
      100 	     end;
      101 	branch_num_adjust = 0;
      102 	index_substate = 0;
      103 	file_substate = file_substate + 1;
      104      end initialize_substate;
      105 
      106 save_node_head:
      107      proc;
      108 	if repeating
      109 	then do;					/* restore header variables */
      110 		call check_index_substate;
      111 		last_branch_num = old_last_branch_num;
      112 		low_key_pos = old_low_key_pos;
      113 		scat_space = old_scat_space;
      114 		return;
      115 	     end;
      116 	old_last_branch_num = last_branch_num;
      117 	old_low_key_pos = low_key_pos;
      118 	old_scat_space = scat_space;
      119 	index_substate = index_substate + 1;
      120      end save_node_head;
      121 
      122 switch_index_state:
      123      proc;
      124 	if a_s_ptr -> index_action = 0
      125 	then if new_desc_val = 0			/* not replacing non-leaf key */
      126 	     then go to switch;
      127 	change_position_ptr = parent_position_ptr;	/* pop change position */
      128 	a_s_ptr -> change_node = node;
      129 	call save_position_stack;
      130 switch:
      131 	index_state = 1 - index_state;		/* switch states */
      132 	index_state_ptr = a_s_ptr;
      133 	is_ptr = index_state_ptr;
      134 	return;					/* end of switch_state routine */
      135 
      136 save_position_stack:
      137      proc;
      138 	p = root_position_ptr;
      139 
      140 	do i = 1 to a_s_ptr -> index_height;
      141 	     p = p -> son_position_ptr;
      142 	     a_s_ptr -> saved_node (i) = p -> node;
      143 	     a_s_ptr -> saved_branch_num (i) = p -> branch_num;
      144 	end;
      145 
      146 	dcl     p			 ptr;
      147 	dcl     i			 fixed;
      148      end save_position_stack;
      149 
      150      end switch_index_state;
      151 
      152 simple_insert:
      153      proc (b_num);
      154 	if new_cont_space < 0
      155 	then call compact_node (node_ptr);
      156 	if b_num < last_branch_num
      157 	then call move_bytes (node_ptr, 5 + bd_len * b_num, bd_len, bd_len * (last_branch_num - b_num));
      158 	call insert_key (b_num);
      159 	last_branch_num = last_branch_num + 1;
      160 	branch (b_num + 1) = new_branch;
      161 	return;
      162 	dcl     i			 fixed;
      163 	dcl     b_num		 fixed;
      164      end;						/* end simple insert */
      165 
      166 insert_key:
      167      proc (br_num);
      168 	low_key_pos = low_key_pos - new_key_length;
      169 	if repeating
      170 	then do;
      171 		call check_index_substate;
      172 		return;
      173 	     end;
      174 	record_designator (br_num) = new_record_designator;
      175 						/* should use record_descrip, but compiler problems */
      176 	key_length (br_num) = new_key_length;
      177 	key_pos (br_num) = low_key_pos;
      178 	substr (keys, low_key_pos, new_key_length) = substr (new_key_string, 1, new_key_length);
      179 	index_substate = index_substate + 1;
      180 	dcl     br_num		 fixed;
      181      end insert_key;
      182 
      183 simple_delete:
      184      proc;
      185 	call free_key_space;
      186 	last_branch_num = last_branch_num - 1;
      187 	if branch_num < last_branch_num
      188 	then call move_bytes (node_ptr, 5 + bd_len * (branch_num + 1), -bd_len, bd_len * (last_branch_num - branch_num));
      189 	return;
      190 
      191 	dcl     len		 fixed;
      192      end;						/* end simple delete */
      193 
      194 adjust_branch_num:
      195      proc;
      196 	branch_num = branch_num + branch_num_adjust;
      197      end;
      198 
      199 move_bytes:
      200      proc (np, source_offset, displacement, n_bytes);
      201 	dest_offset = source_offset + displacement;
      202 	call save_new_string;
      203 	call set_new_string;
      204 	return;					/* end move_bytes main routine */
      205 
      206 save_new_string:
      207      proc;
      208 	if repeating
      209 	then do;
      210 		call check_index_substate;
      211 		return;
      212 	     end;
      213 	substr (spare_node, dest_offset, n_bytes) = substr (np -> keys, source_offset, n_bytes);
      214 	index_substate = index_substate + 1;
      215      end;
      216 
      217 set_new_string:
      218      proc;
      219 	if repeating
      220 	then do;
      221 		call check_index_substate;
      222 		return;
      223 	     end;
      224 	substr (np -> keys, dest_offset, n_bytes) = substr (spare_node, dest_offset, n_bytes);
      225 	index_substate = index_substate + 1;
      226      end;
      227 
      228 	dcl     np		 ptr;
      229 	dcl     (source_offset, displacement, n_bytes, dest_offset)
      230 				 fixed;
      231      end move_bytes;
      232 
      233 set_new_branch:
      234      proc;
      235 	if repeating
      236 	then do;
      237 		call check_index_substate;
      238 		return;
      239 	     end;
      240 	new_branch = branch (branch_num + 1);
      241 	index_substate = index_substate + 1;
      242      end;
      243 
      244 set_old_key_info:
      245      proc;
      246 	if repeating
      247 	then do;
      248 		call check_index_substate;
      249 		return;
      250 	     end;
      251 	old_key_pos = key_pos (branch_num);
      252 	old_key_length = key_length (branch_num);
      253 	index_substate = index_substate + 1;
      254      end;
      255 
      256 free_key_space:
      257      proc;
      258 	if old_key_pos = low_key_pos
      259 	then low_key_pos = low_key_pos + old_key_length;
      260 	else scat_space = scat_space + old_key_length;
      261      end;
      262 
      263 replace_key:
      264      proc;
      265 	call free_key_space;
      266 	if new_key_length > y
      267 	then do;					/* make room for larger key */
      268 		call zero_key;
      269 		call compact_node (node_ptr);
      270 	     end;
      271 	call insert_key (branch_num);
      272 	return;					/* end of replace_key routine */
      273 
      274 zero_key:
      275      proc;
      276 	if repeating
      277 	then do;
      278 		call check_index_substate;
      279 		return;
      280 	     end;
      281 	key_length (branch_num) = 0;
      282 	index_substate = index_substate + 1;
      283      end zero_key;
      284 
      285      end replace_key;
      286 
      287 compact_node:
      288      proc (n_ptr);
      289 	np = n_ptr;
      290 	call make_compact_copy;
      291 	call set_compacted_node;
      292 	np -> low_key_pos = new_low_key_pos;
      293 	np -> scat_space = 0;
      294 	return;					/* end of compaction routine */
      295 
      296 make_compact_copy:
      297      proc;
      298 	if repeating
      299 	then do;
      300 		call check_index_substate;
      301 		return;
      302 	     end;
      303 	n_keys = np -> last_branch_num - 1;
      304 	len = n_keys * bd_len + node_head_length;
      305 	substr (spare_node, 1, len) = substr (np -> keys, 1, len);
      306 	k = node_length + 1;
      307 
      308 	do i = 1 to n_keys;
      309 	     m = np -> key_length (i);
      310 	     if m > 0
      311 	     then do;
      312 		     k = k - m;
      313 		     substr (spare_node, k, m) = substr (np -> keys, np -> key_pos (i), m);
      314 		     addr (spare_node) -> key_pos (i) = k;
      315 		end;
      316 	end;
      317 
      318 	new_low_key_pos = k;
      319 	index_substate = index_substate + 1;
      320 	dcl     (n_keys, len)	 fixed;
      321      end make_compact_copy;
      322 
      323 set_compacted_node:
      324      proc;
      325 	if repeating
      326 	then do;
      327 		call check_index_substate;
      328 		return;
      329 	     end;
      330 	substr (np -> keys, 1, node_length) = substr (spare_node, 1, node_length);
      331 	index_substate = index_substate + 1;
      332      end;
      333 
      334 	dcl     (np, n_ptr)		 ptr;
      335 	dcl     (i, k, m)		 fixed;
      336      end;						/* end compact node */
      337 
      338 set_new_cont_space:
      339      proc;
      340 	new_cont_space = cont_space (node_ptr) - new_key_length - bd_len;
      341      end set_new_cont_space;
      342 
      343 cont_space:
      344      proc (np) returns (fixed);
      345 	return (np -> low_key_pos - 1 - node_head_length + bd_len - np -> last_branch_num * bd_len);
      346 	dcl     np		 ptr;
      347      end cont_space;
      348 
      349 insert_at_root:
      350      proc;
      351 	call extend_position_stack (indx_cb_ptr);	/* sets change position to new frame */
      352 	pos_ptr = change_position_ptr;
      353 	call create_node (node, node_ptr);
      354 	call set_first_branch;
      355 	only_branch_in_root = node;
      356 	a_s_ptr -> index_height = index_height + 1;
      357 	a_s_ptr -> current_node = file_position_ptr -> node;
      358 	old_index_height = a_s_ptr -> index_height;
      359 	branch_num = 1;
      360 	new_cont_space = 0;				/* avoids unnecessary compaction */
      361 	call simple_insert (1);
      362 	call adjust_branch_num;
      363 	return;
      364 
      365 set_first_branch:
      366      proc;
      367 	if repeating
      368 	then do;
      369 		call check_index_substate;
      370 		return;
      371 	     end;
      372 	branch (1) = only_branch_in_root;
      373 	index_substate = index_substate + 1;
      374      end;
      375      end;						/* end insert_at_root */
      376 
      377 overflow:
      378      proc;
      379 	is_overflow = "1"b;
      380 	num_of_keys = last_branch_num;		/* num of keys in node + 1 for inserted key */
      381 	call get_parent;
      382 	if is_ks_out
      383 	then do;					/* create right brother but don't balance */
      384 		call split (num_of_keys - 1);
      385 		call adjust_position_right;
      386 		return;
      387 	     end;
      388 	if p_b_num < p_n_ptr -> last_branch_num
      389 	then do;					/* try rotate right */
      390 		call get_right_brother;
      391 		call rotate_right;			/* sets count */
      392 		if first_count > 0
      393 		then do;
      394 			call adjust_position_right;
      395 			return;
      396 		     end;
      397 	     end;
      398 						/* rotate left or split */
      399 	if p_b_num > 1
      400 	then do;					/* try left brother */
      401 		call get_left_brother;
      402 		call rotate_left;			/* sets count */
      403 		if second_count > 0
      404 		then do;
      405 			call adjust_position_left;
      406 			return;
      407 		     end;
      408 	     end;
      409 						/* must split node, p_b_num irrelevant(no pivot),split sets b_n_ptr */
      410 	call find_split_num;
      411 	call split (split_num);			/* split_num is num of key after last included in space */
      412 	call adjust_position_right;
      413 	return;					/* end overflow code */
      414 
      415 get_parent:
      416      proc;
      417 	p_n_ptr = parent_position_ptr -> node_ptr;
      418 	p_b_num = parent_position_ptr -> branch_num;
      419      end;
      420 
      421 get_right_brother:
      422      proc;
      423 	b_node = p_n_ptr -> branch (p_b_num + 1);
      424 	b_n_ptr = get_ptr (b_node);
      425 	call set_b_vars;
      426 	return;					/* end of get_right_brother routine */
      427 
      428 get_left_brother:
      429      entry;
      430 	p_b_num = p_b_num - 1;
      431 	b_node = p_n_ptr -> branch (p_b_num);
      432 	b_n_ptr = get_ptr (b_node);
      433 	call set_b_vars;
      434 	return;					/* end of get_left_brother routine */
      435 
      436 set_b_vars:
      437      proc;
      438 	if repeating
      439 	then do;
      440 		call check_index_substate;
      441 		return;
      442 	     end;
      443 	b_space = cont_space (b_n_ptr) + b_n_ptr -> scat_space;
      444 	last_b_num = b_n_ptr -> last_branch_num;
      445 	index_substate = index_substate + 1;
      446      end set_b_vars;
      447 
      448      end get_right_brother;
      449 
      450 find_split_num:
      451      proc;
      452 	if repeating
      453 	then do;
      454 		call check_index_substate;
      455 		return;
      456 	     end;
      457 	space = node_head_length;
      458 
      459 	do split_num = 1 repeat (split_num + 1) while (space < half_node_length);
      460 	     space = space + bd_len + key_length (split_num);
      461 	end;
      462 
      463 	index_substate = index_substate + 1;
      464      end find_split_num;
      465 
      466 underflow:
      467      entry;
      468 	is_overflow = "0"b;
      469 	call get_parent;
      470 	if p_b_num < p_n_ptr -> last_branch_num
      471 	then do;					/*
      472*						   balance or combine with right brother */
      473 		call get_right_brother;
      474 		num_of_keys = last_b_num - 1;
      475 		dest_np = node_ptr;
      476 		if is_combination_possible ()
      477 		then call combine (node_ptr, b_n_ptr);
      478 		else call rotate_left;
      479 		call adjust_branch_num;
      480 	     end;
      481 	else if p_b_num > 1
      482 	then do;					/* balance or combine with left brother */
      483 		call get_left_brother;
      484 		num_of_keys = last_b_num - 1;
      485 		parent_position_ptr -> branch_num = p_b_num;
      486 		dest_np = b_n_ptr;
      487 		if is_combination_possible ()
      488 		then do;
      489 			call combine (b_n_ptr, node_ptr);
      490 			call set_node_to_brother;
      491 			branch_num = last_b_num + branch_num + branch_num_adjust;
      492 		     end;
      493 		else do;
      494 			call rotate_right;
      495 			branch_num = branch_num + branch_num_adjust + count;
      496 			a_s_ptr -> branch_num_adjust = 1;
      497 		     end;
      498 	     end;
      499 	else /* the parent node is the root node */
      500 	     if last_branch_num = 1			/* height of tree decreases */
      501 	then call underflow_to_root;
      502 	else call adjust_branch_num;
      503 	return;					/* end of underflow code */
      504 
      505 underflow_to_root:
      506      proc;
      507 	call set_root_branch;
      508 	call free_node (node, node_ptr);
      509 	a_s_ptr -> index_height = index_height - 1;
      510 	old_index_height = a_s_ptr -> index_height;
      511 	node_ptr = parent_position_ptr -> node_ptr;
      512 	node = parent_position_ptr -> node;
      513 	a_s_ptr -> current_node = file_position_ptr -> node;
      514 	branch_num = 1;
      515 	root_position_ptr = pos_ptr;
      516 	return;					/* end of underflow_to_root routine */
      517 
      518 set_root_branch:
      519      proc;
      520 	if repeating
      521 	then do;
      522 		call check_index_substate;
      523 		return;
      524 	     end;
      525 	only_branch_in_root = branch (1);
      526 	index_substate = index_substate + 1;
      527      end;
      528 
      529      end underflow_to_root;
      530 
      531 /* Declarations */
      532 	dcl     is_new_key		 bit (1) aligned;
      533 	dcl     is_overflow		 bit (1) aligned;
      534 	dcl     (p_n_ptr, b_n_ptr)	 ptr;		/* parent,brother nodes */
      535 	dcl     b_node		 fixed (35);	/* brother node designator */
      536 	dcl     last_b_num_left	 fixed;		/* used in combining node with left brother */
      537 	dcl     p_b_num		 fixed;		/* branch num for pivot kay is parent */
      538 	dcl     n_ptr		 ptr;
      539 	dcl     (dest_np, np1, np2)	 ptr;
      540 	dcl     i			 fixed;
      541 	dcl     num_of_keys		 fixed;		/* number of keys available for rotation,
      542*						   includes new key in overflow case */
      543 
      544 get_key:
      545      proc (i, p, k);				/* locates the node(p)and branch_num(k)for the ith key"in"
      546*						   the source node. Allows for new key. This routine is used in rotate_x and
      547*						   split */
      548 	p = np1;
      549 	k = i;
      550 	if is_overflow
      551 	then if i >= branch_num
      552 	     then if i = branch_num
      553 		then do;				/* use new key */
      554 			p = addr (fake_node);
      555 			k = 1;
      556 			is_new_key = "1"b;
      557 			return;
      558 		     end;
      559 		else k = k - 1;
      560 	is_new_key = "0"b;
      561 	return;
      562 
      563 	dcl     i			 fixed;		/* 1<=i<=num_of_keys */
      564 	dcl     k			 fixed;
      565 	dcl     p			 ptr;
      566      end;						/* end get_key */
      567 
      568 split:
      569      proc (n);					/* creates new right brother */
      570 	count = num_of_keys - n + 1;
      571 	call create_node (b_node, b_n_ptr);
      572 	a_s_ptr -> new_branch = b_node;
      573 	a_s_ptr -> index_action = insert_action;
      574 	call set_nps;
      575 	call split_keys;
      576 	np2 -> last_branch_num = 0;
      577 	call finish_dest_node;
      578 	call finish_left_node;
      579 	return;					/* end of split routine */
      580 
      581 split_keys:
      582      proc;
      583 	if repeating
      584 	then do;
      585 		call check_index_substate;
      586 		return;
      587 	     end;
      588 	call get_key (n, p, k);
      589 	call set_upbound_key;
      590 	np2 -> branch (1) = first_branch;
      591 	call set_dest_node_info;
      592 	dest_b_num = num_of_keys - n;
      593 
      594 	do i = num_of_keys to n + 1 by -1;
      595 	     call get_key (i, source_n_ptr, source_b_num);
      596 	     call move_adjust;
      597 	     dest_b_num = dest_b_num - 1;
      598 	end;
      599 
      600 	index_substate = index_substate + 1;
      601      end split_keys;
      602 
      603 	dcl     n			 fixed;		/* index of first key to be moved */
      604 	dcl     b_num		 fixed;
      605 	dcl     n_ptr		 ptr;
      606      end;						/* end split */
      607 
      608 move_adjust:
      609      proc;					/* adjust low_key_pos and free space count in source */
      610 	source_key_pos = source_n_ptr -> key_pos (source_b_num);
      611 	source_key_len = source_n_ptr -> key_length (source_b_num);
      612 	if source_key_pos > min_source_key_pos
      613 	then new_scat_space = new_scat_space + source_key_len;
      614 	else if ^is_new_key
      615 	then min_source_key_pos = min_source_key_pos + source_key_len;
      616 move:
      617      entry;					/* moves key and bd_words from source node to dest node */
      618 	dest_bd_words = source_bd_words;
      619 	min_dest_key_pos = min_dest_key_pos - source_key_len;
      620 	dest_n_ptr -> key_pos (dest_b_num) = min_dest_key_pos;
      621 	substr (dest_n_ptr -> keys, min_dest_key_pos, source_key_len) =
      622 	     substr (source_n_ptr -> keys, source_key_pos, source_key_len);
      623 	dcl     source_bd_words	 (branch_and_descrip_size) based (addr (source_n_ptr -> descrip (source_b_num)))
      624 				 fixed;
      625 	dcl     dest_bd_words	 (branch_and_descrip_size) based (addr (dest_n_ptr -> descrip (dest_b_num))) fixed;
      626      end move_adjust;
      627 
      628 set_new_key_and_descrip:
      629      proc (n_ptr, b_num);
      630 	a_s_ptr -> new_key_length = n_ptr -> key_length (b_num);
      631 	substr (a_s_ptr -> new_key_string, 1, a_s_ptr -> new_key_length) =
      632 	     substr (n_ptr -> keys, n_ptr -> key_pos (b_num), a_s_ptr -> new_key_length);
      633 	a_s_ptr -> new_record_designator = n_ptr -> record_designator (b_num);
      634 	return;
      635 
      636 	dcl     n_ptr		 ptr;
      637 	dcl     b_num		 fixed;
      638      end;						/* end set-new_key */
      639 
      640 compact_if_nec:
      641      proc;
      642 	b_n_ptr -> last_branch_num = last_b_num;
      643 	if must_compact_dest
      644 	then call compact_node (np2);
      645      end;
      646 
      647 rotate_right:
      648      proc;
      649 	i = num_of_keys;				/* defines first key to be moved */
      650 	di = -1;
      651 	call compute_count;
      652 	call set_first_count;
      653 	if first_count ^= 0
      654 	then do;					/* rotation is possible */
      655 		a_s_ptr -> index_action = replace_action;
      656 		call compact_if_nec;
      657 		call move_bytes (np2, bd_len + 1, count * bd_len, bd_len * (np2 -> last_branch_num - 1) + 4);
      658 		call rotate_keys_right;
      659 		np2 -> branch (1) = first_branch;
      660 		call finish_dest_node;
      661 		call finish_left_node;
      662 	     end;
      663 	return;					/* end rotate_right code */
      664 
      665 rotate_keys_right:
      666      proc;
      667 	if repeating
      668 	then do;
      669 		call check_index_substate;
      670 		return;
      671 	     end;
      672 	call set_dest_node_info;
      673 	dest_b_num = count;
      674 	call move_key_down;
      675 	np2 -> branch (count + 1) = np2 -> branch (1);
      676 	call get_key (num_of_keys + 1 - count, p, k);
      677 	call set_upbound_key;
      678 
      679 	do i = 1 to count - 1;
      680 	     call get_key (num_of_keys + 1 - i, source_n_ptr, source_b_num);
      681 	     dest_b_num = dest_b_num - 1;
      682 	     call move_adjust;
      683 	end;
      684 
      685 	index_substate = index_substate + 1;
      686      end rotate_keys_right;
      687 
      688 set_first_count:
      689      proc;
      690 	if repeating
      691 	then do;
      692 		call check_index_substate;
      693 		return;
      694 	     end;
      695 	first_count = count;
      696 	index_substate = index_substate + 1;
      697      end;
      698 
      699 set_second_count:
      700      proc;
      701 	if repeating
      702 	then do;
      703 		call check_index_substate;
      704 		return;
      705 	     end;
      706 	second_count = count;
      707 	index_substate = index_substate + 1;
      708      end;
      709 
      710 rotate_left:
      711      entry;
      712 	i = 1;					/* defines first key to be moved */
      713 	di = 1;
      714 	call compute_count;
      715 	call set_second_count;
      716 	if second_count ^= 0
      717 	then do;					/* rotation is possible */
      718 		a_s_ptr -> index_action = replace_action;
      719 		call compact_if_nec;
      720 		call rotate_keys_left;
      721 		np1 -> branch (1) = first_branch;
      722 		call finish_dest_node;
      723 		call finish_right_node;
      724 	     end;
      725 	return;					/* end rotate_left */
      726 
      727 rotate_keys_left:
      728      proc;
      729 	if repeating
      730 	then do;
      731 		call check_index_substate;
      732 		return;
      733 	     end;
      734 	call set_dest_node_info;
      735 	call move_key_down;
      736 	call get_key (count, p, k);
      737 	call set_upbound_key;
      738 
      739 	do i = 1 to count - 1;
      740 	     call get_key (i, source_n_ptr, source_b_num);
      741 	     dest_b_num = dest_b_num + 1;
      742 	     call move_adjust;
      743 	end;
      744 
      745 	index_substate = index_substate + 1;
      746      end rotate_keys_left;
      747 
      748 	dcl     i			 fixed;		/* indexes keys "in" source node-including inserted keys */
      749 	dcl     di		 fixed;		/* defines order to take keys from source node */
      750 
      751 compute_count:
      752      proc;
      753 	call set_nps;
      754 	if repeating
      755 	then do;
      756 		call check_index_substate;
      757 		return;
      758 	     end;
      759 	if is_overflow
      760 	then do;
      761 		x = space;
      762 		y = b_space;
      763 	     end;
      764 	else do;
      765 		x = b_space;
      766 		y = space;
      767 	     end;
      768 	dy = bd_len + p_n_ptr -> key_length (p_b_num);	/* parent key is first to be moved */
      769 	count = 0;
      770 	call get_key (i, p, k);
      771 	dx = bd_len + p -> key_length (k);
      772 	do while (i > 0);				/* i=0 just a convienient stop flag */
      773 	     if dy > y
      774 	     then i = 0;
      775 	     else do;				/* key will fit */
      776 		     count = count + 1;
      777 		     y = y - dy;
      778 		     x = x + dx;
      779 		     if x >= y
      780 		     then i = 0;			/* nodes are more or less balanced */
      781 		     else do;
      782 			     dy = dx;
      783 			     i = i + di;
      784 			     call get_key (i, p, k);
      785 			     dx = bd_len + p -> key_length (k);
      786 			end;
      787 		end;
      788 	end;
      789 	if x < 0
      790 	then count = 0;				/* can not move enough keys to correct overflow */
      791 	else if count > 0
      792 	then if y < np2 -> scat_space
      793 	     then must_compact_dest = "1"b;
      794 	     else must_compact_dest = "0"b;
      795 	index_substate = index_substate + 1;
      796 	return;
      797 
      798 	dcl     (x, y)		 fixed;		/* x is space in source node,y in target node.
      799*						   Initially x<y. Indeed, is overflow case x<o. routine finds count
      800*
      801*						   of keys to be moved such that x>=y if possible. Constraint is y>=o */
      802 	dcl     (dx, dy)		 fixed;
      803      end;						/* end compute_count_set_nps */
      804 
      805      end;						/* end rotate_right */
      806 
      807 set_dest_node_info:
      808      proc;
      809 	dest_n_ptr = np2;
      810 	dest_b_num = np2 -> last_branch_num;
      811 	min_dest_key_pos = np2 -> low_key_pos;
      812      end;
      813 
      814 move_key_down:
      815      proc;
      816 	source_n_ptr = p_n_ptr;
      817 	source_b_num = p_b_num;
      818 	source_key_pos = source_n_ptr -> key_pos (source_b_num);
      819 	source_key_len = source_n_ptr -> key_length (source_b_num);
      820 	call move;
      821 	np2 -> branch (dest_b_num + 1) = np1 -> branch (1);
      822      end move_key_down;
      823 
      824 set_upbound_key:
      825      proc;
      826 	call set_new_key_and_descrip (p, k);
      827 	first_branch = p -> branch (k + 1);
      828 	min_source_key_pos = np1 -> low_key_pos;
      829 	new_scat_space = np1 -> scat_space;
      830 	key_len = p -> key_length (k);
      831 	if p -> key_pos (k) > min_source_key_pos
      832 	then new_scat_space = new_scat_space + key_len;
      833 	else if ^is_new_key
      834 	then min_source_key_pos = min_source_key_pos + key_len;
      835 	dcl     key_len		 fixed;
      836      end;
      837 
      838 finish_dest_node:
      839      proc;
      840 	np2 -> low_key_pos = min_dest_key_pos;
      841 	np2 -> last_branch_num = np2 -> last_branch_num + count;
      842      end;
      843 
      844 set_nps:
      845      proc;
      846 	if is_overflow
      847 	then do;
      848 		np1 = node_ptr;
      849 		np2 = b_n_ptr;
      850 	     end;
      851 	else do;
      852 		np1 = b_n_ptr;
      853 		np2 = node_ptr;
      854 	     end;
      855      end set_nps;
      856 
      857 finish_left_node:
      858      proc;					/* called after split or right rotate */
      859 	call set_source_vars;
      860 	if is_overflow
      861 	then /* main node is left one */
      862 	     if branch_num <= last_branch_num
      863 	     then do;				/* new key must be inserted */
      864 		     call set_new_cont_space;
      865 		     call simple_insert (branch_num);
      866 		end;
      867 	     else /* new key was moved */
      868 		np1 -> last_branch_num = np1 -> last_branch_num + 1;
      869      end;						/* end finish_left_node */
      870 
      871 finish_right_node:
      872      proc;					/* called after left rotate */
      873 	call set_source_vars;
      874 	if is_overflow
      875 	then do;					/* main node is right one */
      876 		if branch_num <= count
      877 		then do;				/* new key was moved */
      878 			np1 -> last_branch_num = np1 -> last_branch_num + 1;
      879 			call left_shift (count - 1);
      880 		     end;
      881 		else do;				/* new key must be inserted */
      882 			call left_shift (count);
      883 			call set_new_cont_space;
      884 			call simple_insert (branch_num - count);
      885 		     end;
      886 	     end;
      887 	else /* underflow case,brother node is right one */
      888 	     call left_shift (count);
      889      end;						/* end finish_right_node */
      890 
      891 set_source_vars:
      892      proc;
      893 	np1 -> last_branch_num = np1 -> last_branch_num - count;
      894 	np1 -> low_key_pos = min_source_key_pos;
      895 	np1 -> scat_space = new_scat_space;
      896      end;
      897 
      898 left_shift:
      899      proc (n);					/* shifts descriptors n places left within node */
      900 	disp = n * bd_len;
      901 	call move_bytes (np1, 1 + node_head_length + disp, -disp, bd_len * (np1 -> last_branch_num - 1));
      902 	dcl     (disp, n)		 fixed;
      903      end;						/* end left_shift */
      904 
      905 is_combination_possible:
      906      proc returns (bit (1));
      907 	spare_space = space + b_space + node_head_length - node_length - p_n_ptr -> key_length (p_b_num) - bd_len;
      908 	if spare_space >= 0
      909 	then do;
      910 		if spare_space < dest_np -> scat_space
      911 		then must_compact_dest = "1"b;
      912 		else must_compact_dest = "0"b;
      913 		return ("1"b);
      914 	     end;
      915 	return ("0"b);
      916      end is_combination_possible;
      917 
      918 combine:
      919      proc (n_ptr_1, n_ptr_2);				/* moves key  in parent and all keys in node 2 (the right node)
      920*						   into node 1 (movement to left), deletes node 2 */
      921 	a_s_ptr -> index_action = delete_action;
      922 	np1 = n_ptr_2;
      923 	np2 = n_ptr_1;
      924 	call compact_if_nec;
      925 	call combine_keys;
      926 	call finish_dest_node;
      927 	call free_node (p_n_ptr -> branch (p_b_num + 1), np1);
      928 						/* delete right node */
      929 	return;					/* end of combine routine */
      930 
      931 combine_keys:
      932      proc;
      933 	if repeating
      934 	then do;
      935 		call check_index_substate;
      936 		return;
      937 	     end;
      938 	call set_dest_node_info;
      939 	call move_key_down;
      940 	count = np1 -> last_branch_num;
      941 	source_n_ptr = np1;
      942 
      943 	do source_b_num = 1 to count - 1;
      944 	     dest_b_num = dest_b_num + 1;
      945 	     source_key_pos = source_n_ptr -> key_pos (source_b_num);
      946 	     source_key_len = source_n_ptr -> key_length (source_b_num);
      947 	     call move;
      948 	end;
      949 
      950 	index_substate = index_substate + 1;
      951      end combine_keys;
      952 
      953 	dcl     (n_ptr_1, n_ptr_2)	 ptr;
      954      end;						/* end combine */
      955 
      956 adjust_position_right:
      957      proc;					/* used after split or right rotation for overflow */
      958 	call adjust_branch_num;
      959 	if branch_num > last_branch_num
      960 	then do;
      961 		branch_num = branch_num - last_branch_num;
      962 		call set_node_to_brother;
      963 		a_s_ptr -> branch_num_adjust = 1;
      964 	     end;
      965 	else if branch_num = last_branch_num
      966 	then if file_position_ptr = pos_ptr
      967 	     then call set_current_node_to_parent;
      968 	return;
      969      end;						/* end adjust_position_right */
      970 
      971 adjust_position_left:
      972      proc;					/* used after left rotation for overflow */
      973 	parent_position_ptr -> branch_num = p_b_num;
      974 	branch_num = branch_num + branch_num_adjust - count;
      975 	if branch_num = 0
      976 	then if file_position_ptr = pos_ptr		/* position moves to parent */
      977 	     then do;
      978 		     call set_current_node_to_parent;
      979 		     return;
      980 		end;
      981 	if branch_num <= 0				/* position is in left node */
      982 	then do;
      983 		call set_node_to_brother;
      984 		branch_num = last_branch_num + branch_num;
      985 	     end;
      986 	else a_s_ptr -> branch_num_adjust = 1;		/* position is in right node */
      987 	return;
      988      end;						/* end adjust_position_left */
      989 
      990 set_node_to_brother:
      991      proc;
      992 	node = b_node;
      993 	node_ptr = b_n_ptr;
      994 	a_s_ptr -> current_node = file_position_ptr -> node;
      995      end;
      996 
      997 set_current_node_to_parent:
      998      proc;
      999 	file_position_ptr = parent_position_ptr;
     1000 	a_s_ptr -> current_node = parent_position_ptr -> node;
     1001      end;
     1002 
     1003 	dcl     p			 ptr;
     1004 	dcl     k			 fixed;
     1005      end;						/* end overflow_underflow */
     1006 
     1007 create_node:
     1008      proc (designator, node_ptr_arg);			/* ref17 */
     1009 	a_s_ptr -> number_of_nodes = number_of_nodes + 1;
     1010 	free_node_ptr = get_ptr (free_node_designator);
     1011 	call save_create_free_info;
     1012 	if free_node_designator ^= 0
     1013 	then if old_number_of_free_nodes > 0
     1014 	     then do;				/* grab a free node from the list */
     1015 		     designator = nodes (old_number_of_free_nodes);
     1016 		     number_of_free_nodes = old_number_of_free_nodes - 1;
     1017 		     node_ptr_arg = get_ptr (designator);
     1018 		end;
     1019 	     else do;				/* use this free node */
     1020 		     designator = free_node_designator;
     1021 		     node_ptr_arg = free_node_ptr;
     1022 		     a_s_ptr -> free_node_designator = old_next_node_designator;
     1023 		end;
     1024 	else if old_seg_lim + node_size <= max_seg_limit
     1025 	then do;					/* use next available page of index tail */
     1026 		call make_designator (index_tail_comp_num, (old_seg_lim), designator);
     1027 		node_ptr_arg = get_ptr (designator);
     1028 		seg_limit (index_tail_comp_num) = old_seg_lim + node_size;
     1029 	     end;
     1030 	else do;					/* get a new index file component */
     1031 		a_s_ptr -> index_tail_comp_num = new_index_comp_num;
     1032 		call get_new_seg (iocb_ptr, a_s_ptr -> index_tail_comp_num, node_ptr_arg, index_substate, abort_exit);
     1033 		comp_link (a_s_ptr -> index_tail_comp_num) = index_tail_comp_num;
     1034 		call make_designator (a_s_ptr -> index_tail_comp_num, 0, designator);
     1035 		seg_limit (a_s_ptr -> index_tail_comp_num) = node_size;
     1036 	     end;
     1037 	node_ptr_arg -> last_branch_num = 1;
     1038 	node_ptr_arg -> low_key_pos = node_length + 1;
     1039 	node_ptr_arg -> scat_space = 0;
     1040 	return;					/* end create node code */
     1041 
     1042 save_create_free_info:
     1043      proc;
     1044 	if repeating
     1045 	then do;
     1046 		call check_index_substate;
     1047 		return;
     1048 	     end;
     1049 	old_seg_lim = abs (seg_limit (index_tail_comp_num));
     1050 	old_number_of_free_nodes = number_of_free_nodes;
     1051 	old_next_node_designator = next_node_designator;
     1052 	new_index_comp_num = last_comp_num + 1;
     1053 	index_substate = index_substate + 1;
     1054      end save_create_free_info;
     1055 
     1056 free_node:
     1057      entry (designator, node_ptr_arg);
     1058 	a_s_ptr -> number_of_nodes = number_of_nodes - 1;
     1059 	if free_node_designator ^= 0
     1060 	then do;					/* at least one free node exists */
     1061 		free_node_ptr = get_ptr (free_node_designator);
     1062 		call save_create_free_info;
     1063 		if old_number_of_free_nodes < (node_size - 2)
     1064 		then do;				/* add new entry to free list */
     1065 			number_of_free_nodes = old_number_of_free_nodes + 1;
     1066 			nodes (number_of_free_nodes) = designator;
     1067 			unspec (node_words) = "0"b;
     1068 			return;
     1069 		     end;
     1070 	     end;
     1071 	free_node_ptr = node_ptr_arg;
     1072 	number_of_free_nodes = 0;
     1073 	next_node_designator = free_node_designator;
     1074 	a_s_ptr -> free_node_designator = designator;
     1075 	return;					/* end of free_node routine */
     1076 
     1077 	dcl     1 free_node		 based (free_node_ptr),
     1078 		2 number_of_free_nodes
     1079 				 fixed,
     1080 		2 next_node_designator
     1081 				 fixed (35),
     1082 		2 nodes		 (1 /* really node-size-2 */) fixed (35);
     1083 	dcl     designator		 fixed (35);
     1084 	dcl     node_ptr_arg	 ptr;
     1085 	dcl     node_words		 (node_size) fixed based (node_ptr_arg);
     1086 	dcl     free_node_ptr	 ptr;
     1087      end create_node;
     1088 
     1089 check_index_substate:
     1090      proc;
     1091 	next_substate = next_substate + 1;
     1092 	if index_substate = next_substate
     1093 	then repeating = "0"b;			/* execution resumes normally */
     1094      end check_index_substate;
     1095 
     1096 get_ptr:
     1097      proc (descriptor) returns (ptr);
     1098 	return (addr (seg_ptr_array (desc.comp_num) -> seg_array (fixed (desc.offset))));
     1099 	dcl     descriptor		 fixed (35);
     1100 	dcl     1 desc		 like designator_struct aligned based (addr (descriptor));
     1101      end get_ptr;
     1102 
     1103 /* Arguments */
     1104 	dcl     iocb_ptr		 ptr;
     1105 	dcl     abort_exit		 label;
     1106 
     1107 /* Local Variables */
     1108 	dcl     (source_n_ptr, dest_n_ptr)
     1109 				 ptr;
     1110 	dcl     (source_b_num, source_key_pos, source_key_len, dest_b_num)
     1111 				 fixed;
     1112 	dcl     pos_ptr		 ptr;
     1113 	dcl     spare_space		 fixed;
     1114 	dcl     new_cont_space	 fixed;
     1115 	dcl     space		 fixed;
     1116 	dcl     (x, y)		 fixed;
     1117 	dcl     a_s_ptr		 ptr;
     1118 
     1119 /* Constants Depending on Node Structure */
     1120 	dcl     bd_len		 static options (constant) fixed init (12);
     1121 	dcl     branch_and_descrip_size
     1122 				 static options (constant) fixed init (3);
     1123 	dcl     node_head_length	 static options (constant) fixed init (16);
     1124 						/* includes first branch */
     1125 
  1     1 /* the control block */
  1     2      dcl	   indx_cb_ptr	      ptr;
  1     3      dcl	   1 indx_cb	      based (indx_cb_ptr),	/* except as noted, init by create cb */
  1     4 	     2 fcb_ptr	      ptr,
  1     5 	     2 file_base_ptr      ptr,
  1     6 	     2 node_length	      fixed,		/* number of bytes in node, init by create_seg_ptrs */
  1     7 	     2 half_node_length   fixed,		/* init by create_seg_ptrs */
  1     8 	     2 max_record_size    fixed (21),		/* init by create_seg_ptrs */
  1     9 	     2 seg_ptr_array_ptr  ptr,		/* init by create seg_ptrs */
  1    10 	     2 seg_ptr_array_limit
  1    11 			      fixed,		/* init by create seg_ptrs */
  1    12 	     2 mode	      fixed,
  1    13 	     2 is_sequential_open bit (1) aligned,
  1    14 	     2 is_read_only	      bit (1) aligned,
  1    15 	     2 is_ks_out	      bit (1) aligned,	/* position info */
  1    16 	     2 position_stack_ptr ptr,		/* init by create_position stack */
  1    17 	     2 position_stack_height
  1    18 			      fixed,		/* init by create position stack */
  1    19 	     2 root_position_ptr  ptr,		/* init by create_position_stack */
  1    20 	     2 file_position_ptr  ptr,		/* not init */
  1    21 	     2 change_position_ptr
  1    22 			      ptr,		/* not init */
  1    23 						/* auxiliary variables  */
  1    24 	     2 rover_seg_ptr      ptr,		/* init by create_seg_ptrs */
  1    25 	     2 index_state_ptr    ptr,		/* init by create_seg_ptrs */
  1    26 	     2 old_index_height   fixed,
  1    27 	     2 old_last_comp_num  fixed,
  1    28 	     2 last_change_count  fixed (35),
  1    29 	     2 wait_time	      fixed (35),
  1    30 	     2 old_rover_comp_num fixed,
  1    31 	     2 file_state_ptr     ptr,
  1    32 	     2 o_s_ptr	      ptr,
  1    33 	     2 repeating	      bit (1) aligned,
  1    34 	     2 next_substate      fixed,
  1    35 	     2 file_program_version
  1    36 			      fixed,		/* used for record_lock compatibility */
  1    37 	     2 leave_locked	      bit (1) aligned,	/* indicates use of set_file_lock order */
  1    38 	     2 dup_ok	      bit (1) aligned,	/* if set, duplicate keys may occur */
  1    39 	     2 read_exclu	      bit (1) aligned,	/* set when lock excludes readers */
  1    40 	     2 pos_incorrect      bit (1) aligned,	/* indicates index position is not current */
  1    41 	     2 saved_lock_copy    bit (36) aligned,	/* copy of process lock_id */
  1    42 	     2 min_key_len	      fixed,		/* non-zero only in old programs */
  1    43 	     2 stat	      bit (1) aligned,	/* causes write_record to create stationary records */
  1    44 	     2 current_subset     fixed (34),		/* used with select order */
  1    45 	     2 last_subset	      fixed (34),
  1    46 	     2 subset_count	      fixed (34),		/* count of descriptors in current subset */
  1    47 	     2 temp_iocbp	      ptr,		/* temporary file used to implement select order */
  1    48 	     2 trans	      bit (1) aligned,	/* set if -transaction attachment */
  1    49 	     2 transaction_code   fixed (35),		/* set for control switch only */
  1    50 	     2 tcfp	      ptr,		/* ptr to iocb for transaction control switch--if applicable */
  1    51 	     2 reflp	      ptr,		/* ptr to ref list file, set only in transaction control file */
  1    52 	     2 uid	      bit (36) aligned,	/* used under -transaction */
  1    53 	     2 collection_delay_time
  1    54 			      fixed (35),		/* microseconds to wait before garbage removal */
  1    55 	     2 min_res	      fixed (21),		/* for min_block_size order */
  1    56 	     2 min_cap	      fixed (21),		/* also for min_block_size order */
  1    57 	     2 subset_selected    bit (2) aligned,	/* first bit for select, second
  1    58*						   bit is for exclude */
  1    59 	     2 error,				/* for error_status order */
  1    60 	       3 type	      fixed,		/* only one error type supported now */
  1    61 	       3 requested	      fixed (34),		/* skip arg given to position entry */
  1    62 	       3 received	      fixed (34),		/* actual successful skips */
  1    63 	     2 state_vars,
  1    64 	       3 fixed_state_part,
  1    65 	         4 shared	      bit (1) aligned,
  1    66 	         4 next_record_position
  1    67 			      fixed,		/* 0, 1, or 2 */
  1    68 	         4 current_record_is_valid
  1    69 			      bit (1) aligned,
  1    70 	         4 ready_to_write bit (1) aligned,
  1    71 	         4 at_eof_or_bof,
  1    72 		 5 at_bof	      bit (1) unal,
  1    73 		 5 at_eof	      bit (1) unal,
  1    74 		 5 pad	      bit (36) unal,
  1    75 	         4 outside_index  bit (1) aligned,	/* set after deleting current key or after use of record_status with locate switch */
  1    76 	         4 current_descrip
  1    77 			      fixed (35),		/* needed when outside index */
  1    78 	         4 saved_descrip  fixed (35),		/* for restoring index position */
  1    79 	         4 skip_state     fixed,		/* controls scanning of deleted entries */
  1    80 	       3 new_key	      char (256) var;
  1    81 
  1    82      dcl	   current_t_code	      fixed (35) based (addr (indx_cb.tcfp -> iocb.open_data_ptr -> indx_cb.transaction_code));
  1    83 
  1    84 /* component locator structures */
  1    85      dcl	   seg_ptr_array	      (0:seg_ptr_array_limit) ptr based (seg_ptr_array_ptr);
  1    86      dcl	   seg_ptr	      ptr;
  1    87      dcl	   seg_array	      (0:262143) fixed (19) based (seg_ptr) aligned;
  1    88      dcl	   designator	      fixed (35);
  1    89      dcl	   1 ind_des_structure    based,
  1    90 	     2 comp	      fixed (17) unal,
  1    91 	     2 offset	      bit (18) unal;
  1    92      dcl	   1 stat_structure	      based,
  1    93 	     2 pad	      bit (26) unal,
  1    94 	     2 ref_count_after    fixed (16) unsigned unal,
  1    95 	     2 ind_comp	      fixed (13) unal,
  1    96 	     2 ref_count	      fixed (16) unsigned unal,
  1    97 	     2 record_lock	      bit (36) aligned,
  1    98 	     2 modifier	      fixed (35),
  1    99 	     2 time_stamp_words   fixed (71) aligned,
  1   100 	     2 prev_mod	      fixed (35),
  1   101 	     2 record	      char (1000000) var;
  1   102      dcl	   1 ind_structure	      based,
  1   103 	     2 pad	      bit (26) unal,
  1   104 	     2 ref_count_after    fixed (16) unsigned unal,
  1   105 	     2 ind_comp	      fixed (13) unal,
  1   106 	     2 ref_count	      fixed (16) unsigned unal,
  1   107 	     2 record_lock	      bit (36) aligned,
  1   108 	     2 modifier	      fixed (35),
  1   109 	     2 time_stamp_words   fixed (71) aligned,
  1   110 	     2 prev_mod	      fixed (35),
  1   111 	     2 prev_desc	      fixed (35);
  1   112      dcl	   1 time_stamp_structure based,
  1   113 	     2 ind_offset	      bit (18) unal,
  1   114 	     2 time_last_modified fixed (54) unsigned unal;
  1   115      dcl	   1 record_block_structure
  1   116 			      based,
  1   117 	     2 reserved	      aligned,		/* data used by change_record_list */
  1   118 	       3 pad	      bit (2) unal,
  1   119 	       3 block_size	      fixed (19) unal,
  1   120 	       3 lock_flag	      bit (1) unal,		/* record lock flag */
  1   121 	       3 stationary	      bit (1) unal,
  1   122 	       3 indirect	      bit (1) unal,
  1   123 	       3 after_applies    bit (1) unal,
  1   124 	       3 mbz	      bit (10) unal,
  1   125 	     2 block_tail,				/* structure varies with record type */
  1   126 	       3 record	      char (1000000) var;	/* non-stat record location */
  1   127      dcl	   1 designator_struct    aligned based (addr (designator)),
  1   128 	     2 comp_num	      fixed (17) unal,
  1   129 	     2 offset	      bit (18) unal;
  1   130 
  1   131 /* position and node templates */
  1   132      dcl	   1 position_frame	      based (pos_ptr),	/* ref8 */
  1   133 	     2 parent_position_ptr
  1   134 			      ptr,
  1   135 	     2 son_position_ptr   ptr,
  1   136 	     2 node_ptr	      ptr,
  1   137 	     2 node	      fixed (35),
  1   138 	     2 branch_num	      fixed;
  1   139      dcl	   1 node_block	      based (node_ptr),	/* ref9) */
  1   140 	     2 last_branch_num    fixed,
  1   141 	     2 low_key_pos	      fixed,
  1   142 	     2 scat_space	      fixed,
  1   143 	     2 branch_and_descrip (1 refer (node_block.last_branch_num)),
  1   144 						/* in last element only branch is used */
  1   145 	       3 branch	      fixed (35),
  1   146 	       3 descrip,
  1   147 	         4 key_descrip,
  1   148 		 5 key_pos      fixed (17) unal,
  1   149 		 5 key_length   fixed (17) unal,
  1   150 	         4 record_descrip,
  1   151 		 5 record_designator
  1   152 			      fixed (35);
  1   153      dcl	   keys		      char (4096 /* 4*node_size */) based (node_ptr);
  1   154 
  1   155 /* file base and states */
  1   156      dcl	   f_b_ptr	      ptr;
  1   157      dcl	   1 file_base	      based (f_b_ptr),	/* ref10 */
  1   158 	     2 common_header,
  1   159 	       3 file_code	      fixed (35),
  1   160 	       3 lock_word	      bit (36) aligned,
  1   161 	       3 words	      (2) fixed,
  1   162 	     2 file_version	      fixed,
  1   163 	     2 program_version    fixed,
  1   164 	     2 node_size	      fixed (19),
  1   165 	     2 minimum_key_length fixed,
  1   166 	     2 minimum_block_size fixed (19),
  1   167 	     2 max_seg_limit      fixed (19),
  1   168 	     2 root_node_block,
  1   169 	       3 last_branch_num_root
  1   170 			      fixed,		/* =1 */
  1   171 	       3 word	      fixed,
  1   172 	       3 reserved	      fixed,
  1   173 	       3 only_branch_in_root
  1   174 			      fixed (35),
  1   175 	     2 file_state	      fixed,
  1   176 	     2 change_count	      fixed (34),		/* record state info, ref12 */
  1   177 	     2 old_number_of_free_blocks
  1   178 			      fixed (34),
  1   179 	     2 prior_block_size   fixed (19),
  1   180 	     2 old_record_length  fixed (21),
  1   181 	     2 need_new_seg	      bit (1) aligned,
  1   182 	     2 old_residue	      fixed,
  1   183 	     2 new_last_comp_num  fixed,
  1   184 	     2 old_prev_free_block
  1   185 			      fixed (18),
  1   186 	     2 old_next_free_block
  1   187 			      fixed (18),
  1   188 	     2 new_record_length  fixed (21),
  1   189 	     2 old_record_designator
  1   190 			      fixed (35),
  1   191 	     2 prec_block_was_free
  1   192 			      bit (1) aligned,
  1   193 	     2 next_block_was_free
  1   194 			      bit (1) aligned,
  1   195 	     2 former_block_size  fixed (19),
  1   196 	     2 old_init_offset    fixed (18),
  1   197 	     2 old_block_size     fixed (19),
  1   198 	     2 prev_block_size    fixed (19),
  1   199 	     2 former_rover_comp_num
  1   200 			      fixed,
  1   201 	     2 former_rover_offset
  1   202 			      fixed (18),
  1   203 	     2 next_block_size    fixed (19),
  1   204 	     2 next_prev_free_block
  1   205 			      fixed (18),
  1   206 	     2 next_next_free_block
  1   207 			      fixed (18),
  1   208 	     2 saved_ks_out	      bit (1) aligned,
  1   209 	     2 new_descriptor     fixed (35),
  1   210 	     2 old_last_branch_num
  1   211 			      fixed,
  1   212 	     2 old_low_key_pos    fixed,
  1   213 	     2 old_scat_space     fixed,
  1   214 	     2 old_key_pos	      fixed,
  1   215 	     2 rover_comp_num     fixed,
  1   216 	     2 rover_offset	      fixed (18),
  1   217 	     2 old_key_length     fixed,
  1   218 	     2 b_space	      fixed,
  1   219 	     2 last_b_num	      fixed,
  1   220 	     2 count	      fixed,
  1   221 	     2 first_count	      fixed,
  1   222 	     2 second_count	      fixed,
  1   223 	     2 split_num	      fixed,
  1   224 	     2 must_compact_dest  bit (1) aligned,
  1   225 	     2 first_branch	      fixed (35),
  1   226 	     2 min_source_key_pos fixed,
  1   227 	     2 min_dest_key_pos   fixed,
  1   228 	     2 new_low_key_pos    fixed,
  1   229 	     2 new_scat_space     fixed,
  1   230 	     2 old_seg_lim	      fixed (19),
  1   231 	     2 old_number_of_free_nodes
  1   232 			      fixed,
  1   233 	     2 old_next_node_designator
  1   234 			      fixed (35),
  1   235 	     2 new_index_comp_num fixed,
  1   236 	     2 out_of_index	      bit (1) aligned,
  1   237 	     2 saved_min_res      fixed (21),
  1   238 	     2 saved_min_cap      fixed (21),
  1   239 	     2 was_stat	      bit (1) aligned,
  1   240 	     2 was_ind	      bit (1) aligned,
  1   241 	     2 old_ind_desc	      fixed (35),
  1   242 	     2 after_desc	      fixed (35),
  1   243 	     2 old_ref_count      fixed (34),
  1   244 	     2 new_ref_count      fixed (34),
  1   245 	     2 old_num_free	      fixed (34),
  1   246 	     2 old_file_ch_count  fixed (35),
  1   247 	     2 y_count,				/* for conversion of pre-MR6.9 files */
  1   248 	     2 old_modifier	      fixed (35),
  1   249 	     2 was_transaction    bit (1) aligned,	/* state blocks */
  1   250 	     2 index_state	      fixed,
  1   251 	     2 index_state_blocks (0:1),
  1   252 	       3 words	      (104),
  1   253 	     2 reserved	      (30),		/* this free space might come in handy */
  1   254 	     2 old_prev_mod	      fixed (35),
  1   255 	     2 needed_blksz	      fixed (35),
  1   256 	     2 new_desc_val	      fixed (35),
  1   257 	     2 is_partial_deletion
  1   258 			      bit (1) aligned,
  1   259 	     2 reserved2	      (42),
  1   260 	     2 file_state_blocks  (0:1),
  1   261 	       3 words	      (size (file_state_block)) fixed,
  1   262 						/* component info */
  1   263 	     2 max_comp_num	      fixed,
  1   264 	     2 last_comp_num      fixed,
  1   265 	     2 first_free_comp_num,			/* not yet supported */
  1   266 	     2 comp_table_start   (size (comp_table));	/* start of comp_array */
  1   267 
  1   268      dcl	   1 comp_table	      (0:true_max_comp_num) based (addr (file_base.comp_table_start)) aligned,
  1   269 	     2 seg_limit	      fixed (19),		/* abs value is offset of first free word in seg, max val=max
  1   270*						   seg_limit and this indicates full seg */
  1   271 	     2 comp_link	      fixed (17) unal,
  1   272 	     2 init_offset	      fixed (18) unsigned unal;
  1   273 
  1   274      dcl	   1 file_header	      based (f_b_ptr),
  1   275 	     2 first_three_pages  (3, 1024) fixed,
  1   276 	     2 spare_node	      char (4096) aligned;
  1   277 
  1   278 /* The File State */
  1   279      dcl	   fs_ptr		      ptr;
  1   280      dcl	   1 file_state_block     based (fs_ptr),
  1   281 	     2 file_action	      fixed,
  1   282 	     2 file_substate      fixed,
  1   283 	     2 number_of_keys     fixed (34),
  1   284 	     2 duplicate_keys     fixed (34),		/* 0 if no duplications */
  1   285 	     2 dup_key_bytes      fixed (34),
  1   286 	     2 total_key_length   fixed (34),
  1   287 	     2 number_of_records  fixed (34),
  1   288 	     2 total_record_length
  1   289 			      fixed (34),
  1   290 	     2 number_of_allocated_records
  1   291 			      fixed (34),
  1   292 	     2 number_of_free_blocks
  1   293 			      fixed (34),
  1   294 	     2 words	      (2) fixed;
  1   295 
  1   296 /* The Index State */
  1   297      dcl	   is_ptr		      ptr;
  1   298      dcl	   1 index_state_block    based (is_ptr),	/* if this declaration is changed,
  1   299*						   index_state_blocks must be adjusted */
  1   300 	     2 number_of_nodes    fixed (34),
  1   301 	     2 free_node_designator
  1   302 			      fixed (35),
  1   303 	     2 index_tail_comp_num
  1   304 			      fixed,
  1   305 	     2 index_height	      fixed,
  1   306 	     2 index_action	      fixed,
  1   307 	     2 index_substate     fixed,
  1   308 	     2 current_node	      fixed (35),
  1   309 	     2 change_node	      fixed (35),
  1   310 	     2 fake_node,				/* equivalent to a short node because of storage map. It holds
  1   311*						   the new key, new record descrip, and new branch in a fashion
  1   312*						   convenient for overflow-underflow in change_index. */
  1   313 	       3 fake_head_and_descrip,
  1   314 	         4 word1	      fixed,		/* last_branch_num in real node */
  1   315 	         4 word2	      fixed,		/* low_key_pos in real node */
  1   316 	         4 word3	      fixed,		/* normally scat_space */
  1   317 	         4 word4	      fixed,		/* first branch in real node */
  1   318 	         4 new_key_pos    fixed (17) unal,	/* set by initializefile to denote first char
  1   319*						   in new_key_string, never changed */
  1   320 	         4 new_key_length fixed (17) unal,
  1   321 	         4 new_record_descrip,
  1   322 		 5 new_record_designator
  1   323 			      fixed (35),
  1   324 	         4 new_branch     fixed (35),
  1   325 	       3 new_key_string   char (256),
  1   326 	     2 branch_num_adjust  fixed,
  1   327 	     2 pos_array	      (10),
  1   328 	       3 saved_node	      fixed (35),
  1   329 	       3 saved_branch_num fixed;
  1   330 
  1   331      dcl	   1 old_file_base	      based (f_b_ptr),
  1   332 	     2 words1	      (15) fixed,		/* same in both file versions */
  1   333 	     2 old_file_state_blocks
  1   334 			      (0:1),
  1   335 	       3 words	      (5) fixed,
  1   336 	     2 words2	      (7) fixed,
  1   337 	     2 record_state	      fixed,
  1   338 	     2 record_state_blocks
  1   339 			      (0:1),
  1   340 	       3 words	      (4) fixed,
  1   341 	     2 words3	      (14) fixed,		/* rover info same in both versions */
  1   342 	     2 old_version_index_height
  1   343 			      fixed,
  1   344 	     2 old_version_number_of_nodes
  1   345 			      fixed (34),
  1   346 	     2 words4	      (157) fixed,
  1   347 	     2 old_version_index_tail_comp_num
  1   348 			      fixed,
  1   349 	     2 old_version_free_node_designator
  1   350 			      fixed (35),
  1   351 	     2 words5	      (10) fixed,
  1   352 	     2 old_version_comp_info
  1   353 			      fixed,
  1   354 	     2 word,
  1   355 	     2 x_count	      fixed;		/* always zero in old version files */
  1   356 
  1   357 /* External Procedures */
  1   358      dcl	   clock_		      entry returns (fixed (71));
  1   359      dcl	   alloc_cb_file	      entry (fixed,		/* size of block in words */
  1   360 			      ptr);		/* ptr to block */
  1   361      dcl	   free_cb_file	      entry (fixed, ptr);
  1   362      dcl	   get_seg_ptr	      entry (ptr, fixed) returns (ptr);
  1   363      dcl	   make_designator	      entry (fixed, fixed (18), fixed (35));
  1   364      dcl	   create_seg_ptrs	      entry (ptr);
  1   365      dcl	   free_seg_ptrs	      entry (ptr);
  1   366      dcl	   get_new_seg	      entry (ptr, fixed, ptr, fixed, label);
  1   367      dcl	   free_seg	      entry (ptr, fixed, ptr);
  1   368      dcl	   set_bitcounts	      entry (ptr);
  1   369      dcl	   create_position_stack  entry (ptr);
  1   370      dcl	   extend_position_stack  entry (ptr);
  1   371      dcl	   free_position_stack    entry (ptr);
  1   372      dcl	   change_index	      entry (ptr, label);
  1   373      dcl	   change_record_list     entry (ptr, fixed, ptr, label);
  1   374 
  1   375 /* State Constants */
  2     1      dcl	   bumping_count	      static internal options (constant) init (-14);
  2     2      dcl	   rollback_action	      static options (constant) init (-13);
  2     3      dcl	   adjust_action	      static options (constant) init (-12);
  2     4      dcl	   unshared_opening	      static internal fixed options (constant) init (-11);
  2     5      dcl	   non_eof_delete	      static internal fixed options (constant) init (-10);
  2     6      dcl	   free_action	      static options (constant) init (-10);
  2     7      dcl	   write_trunc	      static internal fixed options (constant) init (-9);
  2     8      dcl	   allocate_action	      static options (constant) init (-9);
  2     9      dcl	   reassigning_key	      static options (constant) init (-8);
  2    10      dcl	   read_exclude	      static options (constant) init (-7);
  2    11      dcl	   adding_record	      static options (constant) init (-6);
  2    12      dcl	   deleting_key	      static options (constant) init (-5);
  2    13      dcl	   adding_key	      static options (constant) init (-4);
  2    14      dcl	   delete_action	      static options (constant) init (-3);
  2    15      dcl	   eof_delete	      static internal fixed options (constant) init (-3);
  2    16      dcl	   replace_action	      static options (constant) init (-2);
  2    17      dcl	   rewrite_action	      static internal fixed options (constant) init (-2);
  2    18      dcl	   insert_action	      static options (constant) init (-1);
  2    19      dcl	   append_action	      static internal fixed options (constant) init (-1);
  2    20      dcl	   truncate_action	      static internal fixed options (constant) init (1);
  2    21      dcl	   must_adjust	      static internal fixed options (constant) init (2);
  2    22      dcl	   must_rollback	      static internal fixed options (constant) init (3);
  1   376 
  1   377 
  1   378 /* Other constants */
  1   379      dcl	   true_max_comp_num      static options (constant) init (1250);
  1   380      dcl	   stat_header_size	      static internal fixed options (constant) init (8);
  1   381 
  1   382 /* builtins */
  1   383      dcl	   (verify, reverse)      builtin;
  1   384      dcl	   addr		      builtin;
  1   385      dcl	   divide		      builtin;
  1   386      dcl	   length		      builtin;
  1   387      dcl	   null		      builtin;
  1   388      dcl	   substr		      builtin;
  1   389      dcl	   size		      builtin;
  1   390      dcl	   abs		      builtin;
  1   391      dcl	   unspec		      builtin;
  1   392      dcl	   fixed		      builtin;
  1   393      dcl	   bit		      builtin;
  1   394      dcl	   max		      builtin;
  1   395      dcl	   min		      builtin;
  1   396      dcl	   rel		      builtin;
  1   397 
     1126 
  3     1 
  3     2      dcl	   1 iocb		      aligned based (iocb_ptr),
  3     3 						/* I/O control block. */
  3     4 	     2 iocb_version	      fixed init (1),	/* Version number of structure. */
  3     5 	     2 name	      char (32),		/* I/O name of this block. */
  3     6 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  3     7 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  3     8 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  3     9 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  3    10 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  3    11 	     2 reserved	      bit (72),		/* Reserved for future use. */
  3    12 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  3    13 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  3    14 						/* open(p,mode,not_used,s) */
  3    15 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  3    16 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  3    17 						/* get_line(p,bufptr,buflen,actlen,s) */
  3    18 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  3    19 						/* get_chars(p,bufptr,buflen,actlen,s) */
  3    20 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  3    21 						/* put_chars(p,bufptr,buflen,s) */
  3    22 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  3    23 						/* modes(p,newmode,oldmode,s) */
  3    24 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  3    25 						/* position(p,u1,u2,s) */
  3    26 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  3    27 						/* control(p,order,infptr,s) */
  3    28 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  3    29 						/* read_record(p,bufptr,buflen,actlen,s) */
  3    30 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  3    31 						/* write_record(p,bufptr,buflen,s) */
  3    32 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  3    33 						/* rewrite_record(p,bufptr,buflen,s) */
  3    34 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  3    35 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  3    36 						/* seek_key(p,key,len,s) */
  3    37 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  3    38 						/* read_key(p,key,len,s) */
  3    39 	     2 read_length	      entry (ptr, fixed (21), fixed (35));
  3    40 						/* read_length(p,len,s) */
  3    41 
     1127 
     1128      end change_index;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/04/82  1619.7  change_index.pl1                  >dumps>old>recomp>change_index.pl1
1126         1    07/19/79  1547.0  vfile_indx.incl.pl1               >ldd>include>vfile_indx.incl.pl1
1-376        2    07/19/79  1547.0  vfile_action_codes.incl.pl1       >ldd>include>vfile_action_codes.incl.pl1
1127         3    07/02/81  1905.0  iocbv.incl.pl1                    >ldd>include>iocbv.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_s_ptr                         000120 automatic       pointer                  dcl 1117 set ref 81* 82 83 84 85 86 87 88 89 124 128
                                                                                  132 140 142 143 356 357 358 496 509 510 513 572
                                                                                  573 630 631 631 631 633 655 718 921 963 986 994
                                                                                  1000 1009 1022 1031 1032 1033 1034 1035 1058 1074
abort_exit                             parameter       label variable           dcl 1105 set ref 11 1032*
abs                                                    builtin function         dcl 1-390 ref 1049
addr                                                   builtin function         dcl 1-384 ref 81 314 554 618 618 1028 1033 1035 1049
                                                                                  1098 1098 1098
b_n_ptr                         000404 automatic       pointer                  dcl 534 set ref 424* 432* 443* 443 444 476* 486 489*
                                                                                  571* 642 849 852 993
b_node                          000406 automatic       fixed bin(35,0)          dcl 535 set ref 423* 424* 431* 432* 571* 572 992
b_num                                  parameter       fixed bin(17,0)          dcl 163 in procedure "simple_insert" set ref 152 156
                                                                                  156 156 158* 160
b_num                                  parameter       fixed bin(17,0)          dcl 637 in procedure "set_new_key_and_descrip" ref
                                                                                  628 630 631 633
b_space                  56            based           fixed bin(17,0)          level 2 dcl 1-157 set ref 443* 762 765 907
bd_len                          000000 constant        fixed bin(17,0)          initial dcl 1120 set ref 156 156* 156 187 187 187
                                                                                  304 340 345 345 460 657 657 657 768 771 785 900
                                                                                  901 907
br_num                                 parameter       fixed bin(17,0)          dcl 180 ref 166 174 176 177
branch                    3            based           fixed bin(35,0)          array level 3 dcl 1-139 set ref 160* 240 372* 423
                                                                                  431 525 590* 659* 675* 675 721* 821* 821 827 927*
branch_and_descrip        3            based           structure                array level 2 unaligned dcl 1-139
branch_and_descrip_size                constant        fixed bin(17,0)          initial dcl 1121 ref 618
branch_num                7            based           fixed bin(17,0)          level 2 dcl 1-132 set ref 32* 51 53 143 187 187 187
                                                                                  196* 196 240 251 252 271* 281 359* 418 485* 491*
                                                                                  491 495* 495 514* 550 550 860 865* 876 884 959
                                                                                  961* 961 965 973* 974* 974 975 981 984* 984
branch_num_adjust       117            based           fixed bin(17,0)          level 2 dcl 1-298 set ref 84* 101* 196 491 495 496*
                                                                                  963* 974 986*
change_node               7            based           fixed bin(35,0)          level 2 dcl 1-298 set ref 128*
change_position_ptr      30            based           pointer                  level 2 dcl 1-3 set ref 19 127* 352
comp_link                 1            based           fixed bin(17,0)          array level 2 packed unaligned dcl 1-268 set ref
                                                                                  1033*
comp_num                               based           fixed bin(17,0)          level 2 packed unaligned dcl 1100 ref 1098
comp_table                             based           structure                array level 1 dcl 1-268
comp_table_start                       based           fixed bin(17,0)          array level 2 dcl 1-157 set ref 1028 1033 1035 1049
count                    60            based           fixed bin(17,0)          level 2 dcl 1-157 set ref 495 570* 657 673 675 676
                                                                                  679 695 706 736* 739 769* 776* 776 789* 791 841
                                                                                  876 879 882* 884 887* 893 940* 943 974
current_node              6            based           fixed bin(35,0)          level 2 dcl 1-298 set ref 86* 357* 513* 994* 1000*
delete_action                   004061 constant        fixed bin(17,0)          initial dcl 2-14 ref 39 921
desc                                   based           structure                level 1 dcl 1100
descrip                   4            based           structure                array level 3 unaligned dcl 1-139 set ref 618 618
descriptor                             parameter       fixed bin(35,0)          dcl 1099 set ref 1096 1098 1098
designator                             parameter       fixed bin(35,0)          dcl 1083 set ref 1007 1015* 1017* 1020* 1026* 1027*
                                                                                  1034* 1056 1066 1074
designator_struct                      based           structure                level 1 dcl 1-127
dest_b_num                      000107 automatic       fixed bin(17,0)          dcl 1110 set ref 592* 597* 597 618 620 673* 681* 681
                                                                                  741* 741 810* 821 944* 944
dest_bd_words                          based           fixed bin(17,0)          array dcl 625 set ref 618*
dest_n_ptr                      000102 automatic       pointer                  dcl 1108 set ref 618 620 621 809*
dest_np                         000410 automatic       pointer                  dcl 539 set ref 475* 486* 910
dest_offset                     000232 automatic       fixed bin(17,0)          dcl 229 set ref 201* 213 224 224
di                              000547 automatic       fixed bin(17,0)          dcl 749 set ref 650* 713* 783
disp                            000706 automatic       fixed bin(17,0)          dcl 902 set ref 900* 901 901
displacement                           parameter       fixed bin(17,0)          dcl 229 ref 199 201
dx                              000614 automatic       fixed bin(17,0)          dcl 802 set ref 771* 778 782 785*
dy                              000615 automatic       fixed bin(17,0)          dcl 802 set ref 768* 773 777 782*
extend_position_stack           000014 constant        entry                    external dcl 1-370 ref 351
f_b_ptr                         000124 automatic       pointer                  dcl 1-156 set ref 14* 48 81 81 111 112 113 116 117
                                                                                  118 124 130 130 213 224 251 252 258 258 260 292
                                                                                  305 313 314 318 330 355 372 392 403 411 443 444
                                                                                  459 460 461 474 484 491 495 525 570 590 612 612
                                                                                  612 614 614 619 619 620 621 642 643 653 657 659
                                                                                  673 675 676 679 695 695 706 706 716 721 736 739
                                                                                  762 765 769 776 776 789 791 791 794 811 827 828
                                                                                  829 831 831 831 833 833 840 841 876 879 882 884
                                                                                  887 893 894 895 907 910 912 940 943 974 1012 1015
                                                                                  1016 1022 1024 1024 1024 1026 1028 1028 1028 1031
                                                                                  1033 1035 1035 1049 1049 1050 1051 1052 1052 1063
                                                                                  1063 1065 1067
fake_head_and_descrip
                         10            based           structure                level 3 unaligned dcl 1-298
fake_node                10            based           structure                level 2 unaligned dcl 1-298 set ref 554
file_base                              based           structure                level 1 unaligned dcl 1-157
file_base_ptr             2            based           pointer                  level 2 dcl 1-3 ref 14
file_header                            based           structure                level 1 unaligned dcl 1-274
file_position_ptr        26            based           pointer                  level 2 dcl 1-3 set ref 86 357 513 965 975 994 999*
file_state_block                       based           structure                level 1 unaligned dcl 1-280 set ref 1028 1033 1035
                                                                                  1049 1052
file_state_ptr           44            based           pointer                  level 2 dcl 1-3 ref 15
file_substate             1            based           fixed bin(17,0)          level 2 dcl 1-280 set ref 103* 103
first_branch             65            based           fixed bin(35,0)          level 2 dcl 1-157 set ref 590 659 721 827*
first_count              61            based           fixed bin(17,0)          level 2 dcl 1-157 set ref 392 653 695*
fixed                                                  builtin function         dcl 1-392 ref 1098
free_node                              based           structure                level 1 unaligned dcl 1077
free_node_designator      1            based           fixed bin(35,0)          level 2 dcl 1-298 set ref 89* 89 1010* 1012 1020
                                                                                  1022* 1059 1061* 1073 1074*
free_node_ptr                   000772 automatic       pointer                  dcl 1086 set ref 1010* 1015 1016 1021 1050 1051
                                                                                  1061* 1065 1066 1066 1071* 1072 1073
fs_ptr                          000126 automatic       pointer                  dcl 1-279 set ref 15* 103 103 1028 1033 1035 1049
                                                                                  1052
get_new_seg                     000012 constant        entry                    external dcl 1-366 ref 1032
half_node_length          5            based           fixed bin(17,0)          level 2 dcl 1-3 ref 43 63 459
i                               000416 automatic       fixed bin(17,0)          dcl 540 in procedure "overflow" set ref 594* 595*
i                               000172 automatic       fixed bin(17,0)          dcl 147 in procedure "save_position_stack" set ref
                                                                                  140* 142 143*
i                                      parameter       fixed bin(17,0)          dcl 563 in procedure "get_key" ref 544 549 550 550
i                               000546 automatic       fixed bin(17,0)          dcl 748 in procedure "rotate_right" set ref 649*
                                                                                  679* 680* 712* 739* 740* 770* 772 773* 779* 783*
                                                                                  783 784*
i                               000316 automatic       fixed bin(17,0)          dcl 335 in procedure "compact_node" set ref 308* 309
                                                                                  313 314*
index_action              4            based           fixed bin(17,0)          level 2 dcl 1-298 set ref 18 22 39 82* 124 573* 655*
                                                                                  718* 921*
index_height              3            based           fixed bin(17,0)          level 2 dcl 1-298 set ref 85* 85 140 356* 356 358
                                                                                  509* 509 510
index_state             114            based           fixed bin(17,0)          level 2 dcl 1-157 set ref 81 130* 130
index_state_block                      based           structure                level 1 unaligned dcl 1-298
index_state_blocks      115            based           structure                array level 2 unaligned dcl 1-157 set ref 81
index_state_ptr          34            based           pointer                  level 2 dcl 1-3 set ref 16 132* 133
index_substate            5            based           fixed bin(17,0)          level 2 dcl 1-298 set ref 83* 96 102* 119* 119 179*
                                                                                  179 214* 214 225* 225 241* 241 253* 253 282* 282
                                                                                  319* 319 331* 331 373* 373 445* 445 463* 463 526*
                                                                                  526 600* 600 685* 685 696* 696 707* 707 745* 745
                                                                                  795* 795 950* 950 1032* 1053* 1053 1092
index_tail_comp_num       2            based           fixed bin(17,0)          level 2 dcl 1-298 set ref 88* 88 1026* 1028 1031*
                                                                                  1032* 1033 1033 1034* 1035 1049
indx_cb                                based           structure                level 1 unaligned dcl 1-3
indx_cb_ptr                     000122 automatic       pointer                  dcl 1-2 set ref 13* 14 15 16 19 43 63 86 94 96 98
                                                                                  108 127 132 133 138 169 208 219 235 246 276 298
                                                                                  306 325 330 330 351* 352 357 358 367 382 438 452
                                                                                  459 510 513 515 520 583 667 690 701 729 754 907
                                                                                  933 965 975 994 999 1038 1044 1091 1091 1092 1092
                                                                                  1098
insert_action                   004060 constant        fixed bin(17,0)          initial dcl 2-18 ref 22 573
iocb                                   based           structure                level 1 dcl 3-2
iocb_ptr                               parameter       pointer                  dcl 1104 set ref 11 13 1032*
is_ks_out                16            based           bit(1)                   level 2 dcl 1-3 ref 382
is_new_key                      000400 automatic       bit(1)                   dcl 532 set ref 556* 560* 614 833
is_overflow                     000401 automatic       bit(1)                   dcl 533 set ref 379* 468* 550 759 846 860 874
is_ptr                          000130 automatic       pointer                  dcl 1-297 set ref 16* 18 22 39 48 51 53 53 53 85 87
                                                                                  88 89 96 101 102 119 119 133* 160 168 174 176 178
                                                                                  178 178 179 179 196 214 214 225 225 240 241 241
                                                                                  253 253 266 282 282 319 319 331 331 340 356 373
                                                                                  373 445 445 463 463 491 495 509 526 526 554 600
                                                                                  600 685 685 696 696 707 707 745 745 795 795 950
                                                                                  950 974 1009 1010 1012 1020 1026 1028 1032 1033
                                                                                  1049 1053 1053 1058 1059 1061 1073 1092
k                               000422 automatic       fixed bin(17,0)          dcl 1004 in procedure "overflow" set ref 588* 676*
                                                                                  736* 770* 771 784* 785 826* 827 830 831
k                               000317 automatic       fixed bin(17,0)          dcl 335 in procedure "compact_node" set ref 306*
                                                                                  312* 312 313 314 318
k                                      parameter       fixed bin(17,0)          dcl 564 in procedure "get_key" set ref 544 549* 555*
                                                                                  559* 559
key_descrip               4            based           structure                array level 4 packed unaligned dcl 1-139
key_len                         000640 automatic       fixed bin(17,0)          dcl 835 set ref 830* 831 833
key_length                4(18)        based           fixed bin(17,0)          array level 5 packed unaligned dcl 1-139 set ref
                                                                                  176* 252 281* 309 460 611 630 768 771 785 819 830
                                                                                  907 946
key_pos                   4            based           fixed bin(17,0)          array level 5 packed unaligned dcl 1-139 set ref 53
                                                                                  177* 251 313 314* 610 620* 631 818 831 945
keys                                   based           char(4096)               unaligned dcl 1-153 set ref 53* 178* 213 224* 305
                                                                                  313 330* 621* 621 631
last_b_num               57            based           fixed bin(17,0)          level 2 dcl 1-157 set ref 444* 474 484 491 642
last_branch_num                        based           fixed bin(17,0)          level 2 dcl 1-139 set ref 24 111* 116 156 156 159*
                                                                                  159 186* 186 187 187 303 345 380 388 444 470 499
                                                                                  576* 642* 657 810 841* 841 860 867* 867 878* 878
                                                                                  893* 893 901 940 959 961 965 984 1037*
last_comp_num                          based           fixed bin(17,0)          level 2 dcl 1-157 ref 1052
len                             000331 automatic       fixed bin(17,0)          dcl 320 set ref 304* 305 305
low_key_pos               1            based           fixed bin(17,0)          level 2 dcl 1-139 set ref 112* 117 168* 168 177 178
                                                                                  258 258* 258 292* 345 811 828 840* 894* 1038*
m                               000320 automatic       fixed bin(17,0)          dcl 335 set ref 309* 310 312 313 313
make_designator                 000010 constant        entry                    external dcl 1-363 ref 1026 1034
max_seg_limit            11            based           fixed bin(19,0)          level 2 dcl 1-157 ref 1024
min_dest_key_pos         67            based           fixed bin(17,0)          level 2 dcl 1-157 set ref 619* 619 620 621 811* 840
min_source_key_pos       66            based           fixed bin(17,0)          level 2 dcl 1-157 set ref 612 614* 614 828* 831 833*
                                                                                  833 894
must_compact_dest        64            based           bit(1)                   level 2 dcl 1-157 set ref 643 791* 794* 910* 912*
n                                      parameter       fixed bin(17,0)          dcl 902 in procedure "left_shift" ref 898 900
n                                      parameter       fixed bin(17,0)          dcl 603 in procedure "split" set ref 568 570 588*
                                                                                  592 594
n_bytes                                parameter       fixed bin(17,0)          dcl 229 ref 199 213 213 224 224
n_keys                          000330 automatic       fixed bin(17,0)          dcl 320 set ref 303* 304 308
n_ptr                                  parameter       pointer                  dcl 334 in procedure "compact_node" ref 287 289
n_ptr                                  parameter       pointer                  dcl 636 in procedure "set_new_key_and_descrip" ref
                                                                                  628 630 631 631 633
n_ptr_1                                parameter       pointer                  dcl 953 ref 918 923
n_ptr_2                                parameter       pointer                  dcl 953 ref 918 922
new_branch               16            based           fixed bin(35,0)          level 4 dcl 1-298 set ref 160 240* 572*
new_cont_space                  000113 automatic       fixed bin(17,0)          dcl 1114 set ref 28 154 340* 360*
new_desc_val            475            based           fixed bin(35,0)          level 2 dcl 1-157 ref 124
new_index_comp_num       75            based           fixed bin(17,0)          level 2 dcl 1-157 set ref 1031 1052*
new_key_length           14(18)        based           fixed bin(17,0)          level 4 packed unaligned dcl 1-298 set ref 48 53 53
                                                                                  168 176 178 178 266 340 630* 631 631
new_key_string           17            based           char(256)                level 3 packed unaligned dcl 1-298 set ref 53 178
                                                                                  631*
new_low_key_pos          70            based           fixed bin(17,0)          level 2 dcl 1-157 set ref 292 318*
new_record_descrip       15            based           structure                level 4 unaligned dcl 1-298
new_record_designator
                         15            based           fixed bin(35,0)          level 5 dcl 1-298 set ref 51 174 633*
new_scat_space           71            based           fixed bin(17,0)          level 2 dcl 1-157 set ref 612* 612 829* 831* 831 895
next_node_designator      1            based           fixed bin(35,0)          level 2 dcl 1077 set ref 1051 1073*
next_substate            51            based           fixed bin(17,0)          level 2 dcl 1-3 set ref 98* 1091* 1091 1092
node                      6            based           fixed bin(35,0)          level 2 dcl 1-132 set ref 86 128 142 353* 355 357
                                                                                  508* 512* 512 513 992* 994 1000
node_block                             based           structure                level 1 unaligned dcl 1-139
node_head_length                       constant        fixed bin(17,0)          initial dcl 1123 ref 304 345 457 901 907
node_length               4            based           fixed bin(17,0)          level 2 dcl 1-3 ref 306 330 330 907 1038
node_ptr                  4            based           pointer                  level 2 dcl 1-132 set ref 24 28 42* 42 51 53 53 58*
                                                                                  59 111 112 113 116 117 118 154* 156 156* 156 159
                                                                                  159 160 168 168 174 176 177 177 178 178 186 186
                                                                                  187 187* 187 240 251 252 258 258 258 260 260 269*
                                                                                  281 340* 353* 372 380 417 460 475 476* 489* 499
                                                                                  508* 511* 511 525 848 853 860 959 961 965 984 993*
node_ptr_arg                           parameter       pointer                  dcl 1084 set ref 1007 1017* 1021* 1027* 1032* 1037
                                                                                  1038 1039 1056 1067 1071
node_size                 6            based           fixed bin(19,0)          level 2 dcl 1-157 ref 1024 1028 1035 1063 1067
node_words                             based           fixed bin(17,0)          array dcl 1085 set ref 1067*
nodes                     2            based           fixed bin(35,0)          array level 2 dcl 1077 set ref 1015 1066*
np                                     parameter       pointer                  dcl 346 in procedure "cont_space" ref 343 345 345
np                              000314 automatic       pointer                  dcl 334 in procedure "compact_node" set ref 289* 292
                                                                                  293 303 305 309 313 313 330
np                                     parameter       pointer                  dcl 228 in procedure "move_bytes" ref 199 213 224
np1                             000412 automatic       pointer                  dcl 539 set ref 548 721 821 828 829 848* 852* 867
                                                                                  867 878 878 893 893 894 895 901* 901 922* 927* 940
                                                                                  941
np2                             000414 automatic       pointer                  dcl 539 set ref 576 590 643* 657* 657 659 675 675
                                                                                  791 809 810 811 821 840 841 841 849* 853* 923*
num_of_keys                     000417 automatic       fixed bin(17,0)          dcl 541 set ref 380* 384 474* 484* 570 592 594 649
                                                                                  676 680
number_of_free_nodes                   based           fixed bin(17,0)          level 2 dcl 1077 set ref 1016* 1050 1065* 1066 1072*
number_of_nodes                        based           fixed bin(34,0)          level 2 dcl 1-298 set ref 87* 87 1009* 1009 1058*
                                                                                  1058
offset                    0(18)        based           bit(18)                  level 2 packed unaligned dcl 1100 ref 1098
old_index_height         36            based           fixed bin(17,0)          level 2 dcl 1-3 set ref 358* 510*
old_key_length           55            based           fixed bin(17,0)          level 2 dcl 1-157 set ref 48 252* 258 260
old_key_pos              52            based           fixed bin(17,0)          level 2 dcl 1-157 set ref 251* 258
old_last_branch_num      47            based           fixed bin(17,0)          level 2 dcl 1-157 set ref 111 116*
old_low_key_pos          50            based           fixed bin(17,0)          level 2 dcl 1-157 set ref 112 117*
old_next_node_designator
                         74            based           fixed bin(35,0)          level 2 dcl 1-157 set ref 1022 1051*
old_number_of_free_nodes
                         73            based           fixed bin(17,0)          level 2 dcl 1-157 set ref 1012 1015 1016 1050* 1063
                                                                                  1065
old_scat_space           51            based           fixed bin(17,0)          level 2 dcl 1-157 set ref 113 118*
old_seg_lim              72            based           fixed bin(19,0)          level 2 dcl 1-157 set ref 1024 1026 1028 1049*
only_branch_in_root      15            based           fixed bin(35,0)          level 3 dcl 1-157 set ref 355* 372 525*
open_data_ptr            22            based           pointer                  level 2 dcl 3-2 ref 13
p                                      parameter       pointer                  dcl 565 in procedure "get_key" set ref 544 548* 554*
p                               000420 automatic       pointer                  dcl 1003 in procedure "overflow" set ref 588* 676*
                                                                                  736* 770* 771 784* 785 826* 827 830 831
p                               000170 automatic       pointer                  dcl 146 in procedure "save_position_stack" set ref
                                                                                  138* 141* 141 142 143
p_b_num                         000407 automatic       fixed bin(17,0)          dcl 537 set ref 388 399 418* 423 430* 430 431 470
                                                                                  481 485 768 817 907 927 973
p_n_ptr                         000402 automatic       pointer                  dcl 534 set ref 388 417* 423 431 470 768 816 907 927
parent_position_ptr                    based           pointer                  level 2 dcl 1-132 ref 127 417 418 485 511 512 973
                                                                                  999 1000
pos_array               120            based           structure                array level 2 unaligned dcl 1-298
pos_ptr                         000110 automatic       pointer                  dcl 1112 set ref 19* 24 28 32 42 42 51 51 53 53 53
                                                                                  58 59 111 112 113 116 117 118 127 128 154 156 156
                                                                                  156 159 159 160 168 168 174 176 177 177 178 178
                                                                                  186 186 187 187 187 187 187 187 196 196 240 240
                                                                                  251 251 252 252 258 258 258 260 260 269 271 281
                                                                                  281 340 352* 353 353 355 359 372 380 417 418 460
                                                                                  475 476 485 489 491 491 495 495 499 508 508 511
                                                                                  511 512 512 514 515 525 550 550 848 853 860 860
                                                                                  865 876 884 959 959 961 961 961 965 965 965 973
                                                                                  974 974 975 975 981 984 984 984 992 993 999 1000
position_frame                         based           structure                level 1 unaligned dcl 1-132
record_descrip            5            based           structure                array level 4 unaligned dcl 1-139
record_designator         5            based           fixed bin(35,0)          array level 5 dcl 1-139 set ref 51* 174* 633
repeating                50            based           bit(1)                   level 2 dcl 1-3 set ref 94 96* 108 169 208 219 235
                                                                                  246 276 298 325 367 438 452 520 583 667 690 701
                                                                                  729 754 933 1044 1092*
replace_action                         constant        fixed bin(17,0)          initial dcl 2-16 ref 655 718
root_node_block          12            based           structure                level 2 unaligned dcl 1-157
root_position_ptr        24            based           pointer                  level 2 dcl 1-3 set ref 138 515*
saved_branch_num        121            based           fixed bin(17,0)          array level 3 dcl 1-298 set ref 143*
saved_node              120            based           fixed bin(35,0)          array level 3 dcl 1-298 set ref 142*
scat_space                2            based           fixed bin(17,0)          level 2 dcl 1-139 set ref 28 42 59 113* 118 260* 260
                                                                                  293* 443 791 829 895* 910 1039*
second_count             62            based           fixed bin(17,0)          level 2 dcl 1-157 set ref 403 706* 716
seg_array                              based           fixed bin(19,0)          array dcl 1-87 set ref 1098
seg_limit                              based           fixed bin(19,0)          array level 2 dcl 1-268 set ref 1028* 1035* 1049
seg_ptr_array                          based           pointer                  array dcl 1-85 ref 1098
seg_ptr_array_ptr        10            based           pointer                  level 2 dcl 1-3 ref 1098
size                                                   builtin function         dcl 1-389 ref 1028 1033 1035 1049 1052
son_position_ptr          2            based           pointer                  level 2 dcl 1-132 ref 141
source_b_num                    000104 automatic       fixed bin(17,0)          dcl 1110 set ref 595* 610 611 618 680* 740* 817* 818
                                                                                  819 943* 945 946*
source_bd_words                        based           fixed bin(17,0)          array dcl 623 ref 618
source_key_len                  000106 automatic       fixed bin(17,0)          dcl 1110 set ref 611* 612 614 619 621 621 819* 946*
source_key_pos                  000105 automatic       fixed bin(17,0)          dcl 1110 set ref 610* 612 621 818* 945*
source_n_ptr                    000100 automatic       pointer                  dcl 1108 set ref 595* 610 611 618 621 680* 740* 816*
                                                                                  818 819 941* 945 946
source_offset                          parameter       fixed bin(17,0)          dcl 229 ref 199 201 213
space                           000114 automatic       fixed bin(17,0)          dcl 1115 set ref 28* 29 42* 43 59* 60 63 457* 459
                                                                                  460* 460 761 766 907
spare_node             6000            based           char(4096)               level 2 dcl 1-274 set ref 213* 224 305* 313* 314 330
spare_space                     000112 automatic       fixed bin(17,0)          dcl 1113 set ref 907* 908 910
split_num                63            based           fixed bin(17,0)          level 2 dcl 1-157 set ref 411* 459* 460* 461*
substr                                                 builtin function         dcl 1-388 set ref 53* 53 178* 178 213* 213 224* 224
                                                                                  305* 305 313* 313 330* 330 621* 621 631* 631
unspec                                                 builtin function         dcl 1-391 set ref 1067*
x                               000115 automatic       fixed bin(17,0)          dcl 1116 in procedure "change_index" set ref 48* 49
                                                                                  59
x                               000612 automatic       fixed bin(17,0)          dcl 798 in procedure "compute_count" set ref 761*
                                                                                  765* 778* 778 779 789
y                               000613 automatic       fixed bin(17,0)          dcl 798 in procedure "compute_count" set ref 762*
                                                                                  766* 773 777* 777 779 791
y                               000116 automatic       fixed bin(17,0)          dcl 1116 in procedure "change_index" set ref 58* 59
                                                                                  266

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
adding_key                             internal static fixed bin(17,0)          initial dcl 2-13
adding_record                          internal static fixed bin(17,0)          initial dcl 2-11
adjust_action                          internal static fixed bin(17,0)          initial dcl 2-3
alloc_cb_file                   000000 constant        entry                    external dcl 1-359
allocate_action                        internal static fixed bin(17,0)          initial dcl 2-8
append_action                          internal static fixed bin(17,0)          initial dcl 2-19
b_num                                  automatic       fixed bin(17,0)          dcl 604
bit                                                    builtin function         dcl 1-393
bumping_count                          internal static fixed bin(17,0)          initial dcl 2-1
change_index                    000000 constant        entry                    external dcl 1-372
change_record_list              000000 constant        entry                    external dcl 1-373
clock_                          000000 constant        entry                    external dcl 1-358
create_position_stack           000000 constant        entry                    external dcl 1-369
create_seg_ptrs                 000000 constant        entry                    external dcl 1-364
current_t_code                         based           fixed bin(35,0)          dcl 1-82
deleting_key                           internal static fixed bin(17,0)          initial dcl 2-12
designator                             automatic       fixed bin(35,0)          dcl 1-88
divide                                                 builtin function         dcl 1-385
eof_delete                             internal static fixed bin(17,0)          initial dcl 2-15
free_action                            internal static fixed bin(17,0)          initial dcl 2-6
free_cb_file                    000000 constant        entry                    external dcl 1-361
free_position_stack             000000 constant        entry                    external dcl 1-371
free_seg                        000000 constant        entry                    external dcl 1-367
free_seg_ptrs                   000000 constant        entry                    external dcl 1-365
get_seg_ptr                     000000 constant        entry                    external dcl 1-362
i                                      automatic       fixed bin(17,0)          dcl 162
ind_des_structure                      based           structure                level 1 packed unaligned dcl 1-89
ind_structure                          based           structure                level 1 unaligned dcl 1-102
last_b_num_left                        automatic       fixed bin(17,0)          dcl 536
len                                    automatic       fixed bin(17,0)          dcl 191
length                                                 builtin function         dcl 1-386
max                                                    builtin function         dcl 1-394
min                                                    builtin function         dcl 1-395
must_adjust                            internal static fixed bin(17,0)          initial dcl 2-21
must_rollback                          internal static fixed bin(17,0)          initial dcl 2-22
n_ptr                                  automatic       pointer                  dcl 605 in procedure "split"
n_ptr                                  automatic       pointer                  dcl 538 in procedure "overflow"
non_eof_delete                         internal static fixed bin(17,0)          initial dcl 2-5
null                                                   builtin function         dcl 1-387
old_file_base                          based           structure                level 1 unaligned dcl 1-331
read_exclude                           internal static fixed bin(17,0)          initial dcl 2-10
reassigning_key                        internal static fixed bin(17,0)          initial dcl 2-9
record_block_structure                 based           structure                level 1 unaligned dcl 1-115
rel                                                    builtin function         dcl 1-396
reverse                                                builtin function         dcl 1-383
rewrite_action                         internal static fixed bin(17,0)          initial dcl 2-17
rollback_action                        internal static fixed bin(17,0)          initial dcl 2-2
seg_ptr                                automatic       pointer                  dcl 1-86
set_bitcounts                   000000 constant        entry                    external dcl 1-368
stat_header_size                       internal static fixed bin(17,0)          initial dcl 1-380
stat_structure                         based           structure                level 1 unaligned dcl 1-92
time_stamp_structure                   based           structure                level 1 packed unaligned dcl 1-112
true_max_comp_num                      internal static fixed bin(17,0)          initial dcl 1-379
truncate_action                        internal static fixed bin(17,0)          initial dcl 2-20
unshared_opening                       internal static fixed bin(17,0)          initial dcl 2-4
verify                                                 builtin function         dcl 1-383
write_trunc                            internal static fixed bin(17,0)          initial dcl 2-7

NAMES DECLARED BY EXPLICIT CONTEXT.
adjust_branch_num               000577 constant        entry                    internal dcl 194 ref 33 45 55 65 362 479 502 958
adjust_position_left            003242 constant        entry                    internal dcl 971 ref 405
adjust_position_right           003215 constant        entry                    internal dcl 956 ref 385 394 412
change_index                    000013 constant        entry                    external dcl 11
check_index_substate            003666 constant        entry                    internal dcl 1089 ref 110 171 210 221 237 248 278
                                                                                  300 327 369 440 454 522 585 669 692 703 731 756
                                                                                  935 1046
combine                         003116 constant        entry                    internal dcl 918 ref 476 489
combine_keys                    003150 constant        entry                    internal dcl 931 ref 925
compact_if_nec                  002162 constant        entry                    internal dcl 640 ref 656 719 924
compact_node                    001015 constant        entry                    internal dcl 287 ref 154 269 643
compute_count                   002441 constant        entry                    internal dcl 751 ref 651 714
cont_space                      001170 constant        entry                    internal dcl 343 ref 42 58 340 443
create_node                     003330 constant        entry                    internal dcl 1007 ref 353 571
find_split_num                  001571 constant        entry                    internal dcl 450 ref 410
finish_dest_node                002676 constant        entry                    internal dcl 838 ref 577 660 722 926
finish_left_node                002725 constant        entry                    internal dcl 857 ref 578 661
finish_right_node               002750 constant        entry                    internal dcl 871 ref 723
free_key_space                  000730 constant        entry                    internal dcl 256 ref 185 265
free_node                       003551 constant        entry                    internal dcl 1056 ref 508 927
get_key                         001717 constant        entry                    internal dcl 544 ref 588 595 676 680 736 740 770 784
get_left_brother                001534 constant        entry                    internal dcl 428 ref 401 483
get_parent                      001512 constant        entry                    internal dcl 415 ref 381 469
get_ptr                         003677 constant        entry                    internal dcl 1096 ref 424 432 1010 1017 1027 1061
get_right_brother               001522 constant        entry                    internal dcl 421 ref 390 473
initialize_substate             000250 constant        entry                    internal dcl 92 ref 17
insert_at_root                  001211 constant        entry                    internal dcl 349 ref 24
insert_key                      000475 constant        entry                    internal dcl 166 ref 158 271
is_combination_possible         003052 constant        entry                    internal dcl 905 ref 476 487
left_shift                      003031 constant        entry                    internal dcl 898 ref 879 882 887
make_compact_copy               001032 constant        entry                    internal dcl 296 ref 290
move                            002102 constant        entry                    internal dcl 616 ref 820 947
move_adjust                     002052 constant        entry                    internal dcl 608 ref 596 682 742
move_bytes                      000605 constant        entry                    internal dcl 199 ref 156 187 657 901
move_key_down                   002605 constant        entry                    internal dcl 814 ref 674 735 939
overflow                        001303 constant        entry                    internal dcl 377 ref 29 70
prepare_next_state              000220 constant        entry                    internal dcl 79 ref 20
replace_key                     000745 constant        entry                    internal dcl 263 ref 62
rotate_keys_left                002373 constant        entry                    internal dcl 727 ref 720
rotate_keys_right               002263 constant        entry                    internal dcl 665 ref 658
rotate_left                     002236 constant        entry                    internal dcl 710 ref 402 478
rotate_right                    002173 constant        entry                    internal dcl 647 ref 391 494
save_create_free_info           003635 constant        entry                    internal dcl 1042 ref 1011 1062
save_new_string                 000615 constant        entry                    internal dcl 206 ref 202
save_node_head                  000271 constant        entry                    internal dcl 106 ref 21
save_position_stack             000355 constant        entry                    internal dcl 136 ref 129
set_b_vars                      001547 constant        entry                    internal dcl 436 ref 425 433
set_compacted_node              001125 constant        entry                    internal dcl 323 ref 291
set_current_node_to_parent      003315 constant        entry                    internal dcl 997 ref 965 978
set_dest_node_info              002574 constant        entry                    internal dcl 807 ref 591 672 734 938
set_first_branch                001265 constant        entry                    internal dcl 365 ref 354
set_first_count                 002343 constant        entry                    internal dcl 688 ref 652
set_new_branch                  000662 constant        entry                    internal dcl 233 ref 68
set_new_cont_space              001144 constant        entry                    internal dcl 338 ref 27 864 883
set_new_key_and_descrip         002141 constant        entry                    internal dcl 628 ref 826
set_new_string                  000640 constant        entry                    internal dcl 217 ref 203
set_node_to_brother             003301 constant        entry                    internal dcl 990 ref 490 962 983
set_nps                         002706 constant        entry                    internal dcl 844 ref 574 753
set_old_key_info                000701 constant        entry                    internal dcl 244 ref 38
set_root_branch                 001701 constant        entry                    internal dcl 518 ref 507
set_second_count                002357 constant        entry                    internal dcl 699 ref 715
set_source_vars                 003017 constant        entry                    internal dcl 891 ref 859 873
set_upbound_key                 002635 constant        entry                    internal dcl 824 ref 589 677 737
simple_delete                   000540 constant        entry                    internal dcl 183 ref 41 69
simple_insert                   000406 constant        entry                    internal dcl 152 ref 32 361 865 884
split                           001750 constant        entry                    internal dcl 568 ref 384 411
split_keys                      001774 constant        entry                    internal dcl 581 ref 575
switch                          000343 constant        label                    dcl 130 ref 124
switch_index_state              000324 constant        entry                    internal dcl 122 ref 75
underflow                       001362 constant        entry                    internal dcl 466 ref 43 63
underflow_to_root               001637 constant        entry                    internal dcl 505 ref 499
zero_key                        000775 constant        entry                    internal dcl 274 ref 268

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4136        4154    4062        4146
Length      4370    4062        16         177      53           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
change_index                        719 external procedure  is an external procedure.  
prepare_next_state                      internal procedure  shares stack frame of external procedure change_index.  
initialize_substate                     internal procedure  shares stack frame of external procedure change_index.  
save_node_head                          internal procedure  shares stack frame of external procedure change_index.  
switch_index_state                      internal procedure  shares stack frame of external procedure change_index.  
save_position_stack                     internal procedure  shares stack frame of external procedure change_index.  
simple_insert                           internal procedure  shares stack frame of external procedure change_index.  
insert_key                              internal procedure  shares stack frame of external procedure change_index.  
simple_delete                           internal procedure  shares stack frame of external procedure change_index.  
adjust_branch_num                       internal procedure  shares stack frame of external procedure change_index.  
move_bytes                              internal procedure  shares stack frame of external procedure change_index.  
save_new_string                         internal procedure  shares stack frame of external procedure change_index.  
set_new_string                          internal procedure  shares stack frame of external procedure change_index.  
set_new_branch                          internal procedure  shares stack frame of external procedure change_index.  
set_old_key_info                        internal procedure  shares stack frame of external procedure change_index.  
free_key_space                          internal procedure  shares stack frame of external procedure change_index.  
replace_key                             internal procedure  shares stack frame of external procedure change_index.  
zero_key                                internal procedure  shares stack frame of external procedure change_index.  
compact_node                            internal procedure  shares stack frame of external procedure change_index.  
make_compact_copy                       internal procedure  shares stack frame of external procedure change_index.  
set_compacted_node                      internal procedure  shares stack frame of external procedure change_index.  
set_new_cont_space                      internal procedure  shares stack frame of external procedure change_index.  
cont_space                              internal procedure  shares stack frame of external procedure change_index.  
insert_at_root                          internal procedure  shares stack frame of external procedure change_index.  
set_first_branch                        internal procedure  shares stack frame of external procedure change_index.  
overflow                                internal procedure  shares stack frame of external procedure change_index.  
get_parent                              internal procedure  shares stack frame of external procedure change_index.  
get_right_brother                       internal procedure  shares stack frame of external procedure change_index.  
set_b_vars                              internal procedure  shares stack frame of external procedure change_index.  
find_split_num                          internal procedure  shares stack frame of external procedure change_index.  
underflow_to_root                       internal procedure  shares stack frame of external procedure change_index.  
set_root_branch                         internal procedure  shares stack frame of external procedure change_index.  
get_key                                 internal procedure  shares stack frame of external procedure change_index.  
split                                   internal procedure  shares stack frame of external procedure change_index.  
split_keys                              internal procedure  shares stack frame of external procedure change_index.  
move_adjust                             internal procedure  shares stack frame of external procedure change_index.  
set_new_key_and_descrip                 internal procedure  shares stack frame of external procedure change_index.  
compact_if_nec                          internal procedure  shares stack frame of external procedure change_index.  
rotate_right                            internal procedure  shares stack frame of external procedure change_index.  
rotate_keys_right                       internal procedure  shares stack frame of external procedure change_index.  
set_first_count                         internal procedure  shares stack frame of external procedure change_index.  
set_second_count                        internal procedure  shares stack frame of external procedure change_index.  
rotate_keys_left                        internal procedure  shares stack frame of external procedure change_index.  
compute_count                           internal procedure  shares stack frame of external procedure change_index.  
set_dest_node_info                      internal procedure  shares stack frame of external procedure change_index.  
move_key_down                           internal procedure  shares stack frame of external procedure change_index.  
set_upbound_key                         internal procedure  shares stack frame of external procedure change_index.  
finish_dest_node                        internal procedure  shares stack frame of external procedure change_index.  
set_nps                                 internal procedure  shares stack frame of external procedure change_index.  
finish_left_node                        internal procedure  shares stack frame of external procedure change_index.  
finish_right_node                       internal procedure  shares stack frame of external procedure change_index.  
set_source_vars                         internal procedure  shares stack frame of external procedure change_index.  
left_shift                              internal procedure  shares stack frame of external procedure change_index.  
is_combination_possible                 internal procedure  shares stack frame of external procedure change_index.  
combine                                 internal procedure  shares stack frame of external procedure change_index.  
combine_keys                            internal procedure  shares stack frame of external procedure change_index.  
adjust_position_right                   internal procedure  shares stack frame of external procedure change_index.  
adjust_position_left                    internal procedure  shares stack frame of external procedure change_index.  
set_node_to_brother                     internal procedure  shares stack frame of external procedure change_index.  
set_current_node_to_parent              internal procedure  shares stack frame of external procedure change_index.  
create_node                             internal procedure  shares stack frame of external procedure change_index.  
save_create_free_info                   internal procedure  shares stack frame of external procedure change_index.  
check_index_substate                    internal procedure  shares stack frame of external procedure change_index.  
get_ptr                                 internal procedure  shares stack frame of external procedure change_index.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
change_index             000100 source_n_ptr                change_index
                         000102 dest_n_ptr                  change_index
                         000104 source_b_num                change_index
                         000105 source_key_pos              change_index
                         000106 source_key_len              change_index
                         000107 dest_b_num                  change_index
                         000110 pos_ptr                     change_index
                         000112 spare_space                 change_index
                         000113 new_cont_space              change_index
                         000114 space                       change_index
                         000115 x                           change_index
                         000116 y                           change_index
                         000120 a_s_ptr                     change_index
                         000122 indx_cb_ptr                 change_index
                         000124 f_b_ptr                     change_index
                         000126 fs_ptr                      change_index
                         000130 is_ptr                      change_index
                         000170 p                           save_position_stack
                         000172 i                           save_position_stack
                         000232 dest_offset                 move_bytes
                         000314 np                          compact_node
                         000316 i                           compact_node
                         000317 k                           compact_node
                         000320 m                           compact_node
                         000330 n_keys                      make_compact_copy
                         000331 len                         make_compact_copy
                         000400 is_new_key                  overflow
                         000401 is_overflow                 overflow
                         000402 p_n_ptr                     overflow
                         000404 b_n_ptr                     overflow
                         000406 b_node                      overflow
                         000407 p_b_num                     overflow
                         000410 dest_np                     overflow
                         000412 np1                         overflow
                         000414 np2                         overflow
                         000416 i                           overflow
                         000417 num_of_keys                 overflow
                         000420 p                           overflow
                         000422 k                           overflow
                         000546 i                           rotate_right
                         000547 di                          rotate_right
                         000612 x                           compute_count
                         000613 y                           compute_count
                         000614 dx                          compute_count
                         000615 dy                          compute_count
                         000640 key_len                     set_upbound_key
                         000706 disp                        left_shift
                         000772 free_node_ptr               create_node

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return              ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
extend_position_stack         get_new_seg                   make_designator

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000007        13 000020        14 000025        15 000027        16 000031        17 000033        18 000034
     19 000037        20 000042        21 000043        22 000044        24 000050        27 000056        28 000057
     29 000064        32 000067        33 000075        36 000076        38 000077        39 000100        41 000104
     42 000105        43 000123        45 000130        46 000131        48 000132        49 000142        51 000143
     53 000152        55 000157        56 000160        58 000161        59 000172        60 000200        62 000201
     63 000202        65 000210        66 000211        68 000212        69 000213        70 000214        75 000215
     76 000216        77 000217        79 000220        81 000221        82 000227        83 000230        84 000231
     85 000232        86 000235        87 000241        88 000243        89 000245        90 000247        92 000250
     94 000251        96 000254        98 000261        99 000262       101 000263       102 000265       103 000266
    104 000270       106 000271       108 000272       110 000275       111 000276       112 000302       113 000305
    114 000307       116 000310       117 000314       118 000317       119 000321       120 000323       122 000324
    124 000325       127 000333       128 000337       129 000342       130 000343       132 000346       133 000351
    134 000354       136 000355       138 000356       140 000361       141 000371       142 000374       143 000401
    144 000403       148 000405       152 000406       154 000410       156 000421       158 000453       159 000462
    160 000464       161 000474       166 000475       168 000477       169 000510       171 000513       172 000514
    174 000515       176 000522       177 000525       178 000531       179 000536       181 000537       183 000540
    185 000541       186 000542       187 000545       189 000576       194 000577       196 000600       197 000604
    199 000605       201 000607       202 000612       203 000613       204 000614       206 000615       208 000616
    210 000621       211 000622       213 000623       214 000635       215 000637       217 000640       219 000641
    221 000644       222 000645       224 000646       225 000657       226 000661       233 000662       235 000663
    237 000666       238 000667       240 000670       241 000677       242 000700       244 000701       246 000702
    248 000705       249 000706       251 000707       252 000717       253 000725       254 000727       256 000730
    258 000731       260 000742       261 000744       263 000745       265 000746       266 000747       268 000755
    269 000756       271 000765       272 000774       274 000775       276 000776       278 001001       279 001002
    281 001003       282 001012       283 001014       287 001015       289 001017       290 001022       291 001023
    292 001024       293 001030       294 001031       296 001032       298 001033       300 001036       301 001037
    303 001040       304 001043       305 001050       306 001055       308 001060       309 001067       310 001076
    312 001077       313 001101       314 001111       316 001115       318 001117       319 001122       321 001124
    323 001125       325 001126       327 001131       328 001132       330 001133       331 001141       332 001143
    338 001144       340 001145       341 001167       343 001170       345 001172       349 001211       351 001212
    352 001221       353 001224       354 001234       355 001235       356 001241       357 001246       358 001252
    359 001254       360 001257       361 001260       362 001263       363 001264       365 001265       367 001266
    369 001271       370 001272       372 001273       373 001300       374 001302       377 001303       379 001304
    380 001306       381 001311       382 001312       384 001315       385 001322       386 001323       388 001324
    390 001327       391 001330       392 001331       394 001334       395 001335       399 001336       401 001341
    402 001342       403 001343       405 001346       406 001347       410 001350       411 001351       412 001360
    413 001361       466 001362       468 001363       469 001364       470 001365       473 001370       474 001371
    475 001375       476 001400       478 001417       479 001420       480 001421       481 001422       483 001424
    484 001425       485 001431       486 001435       487 001437       489 001444       490 001455       491 001456
    492 001465       494 001466       495 001467       496 001476       498 001501       499 001502       502 001510
    503 001511       415 001512       417 001513       418 001517       419 001521       421 001522       423 001523
    424 001530       425 001532       426 001533       428 001534       430 001535       431 001537       432 001543
    433 001545       434 001546       436 001547       438 001550       440 001553       441 001554       443 001555
    444 001564       445 001566       446 001570       450 001571       452 001572       454 001575       455 001576
    457 001577       459 001601       460 001612       461 001627       463 001634       464 001636       505 001637
    507 001640       508 001641       509 001652       510 001657       511 001661       512 001666       513 001671
    514 001675       515 001677       516 001700       518 001701       520 001702       522 001705       523 001706
    525 001707       526 001714       527 001716       544 001717       548 001721       549 001723       550 001725
    554 001734       555 001737       556 001741       557 001743       559 001744       560 001746       561 001747
    568 001750       570 001752       571 001757       572 001761       573 001764       574 001766       575 001767
    576 001770       577 001771       578 001772       579 001773       581 001774       583 001775       585 002000
    586 002001       588 002002       589 002015       590 002016       591 002022       592 002023       594 002027
    595 002037       596 002041       597 002042       598 002044       600 002047       601 002051       608 002052
    610 002053       611 002062       612 002066       614 002075       616 002101       618 002103       619 002121
    620 002124       621 002130       626 002136       628 002141       630 002143       631 002152       633 002157
    634 002161       640 002162       642 002163       643 002166       645 002172       647 002173       649 002174
    650 002176       651 002200       652 002201       653 002202       655 002205       656 002210       657 002211
    658 002226       659 002227       660 002233       661 002234       663 002235       710 002236       712 002237
    713 002241       714 002242       715 002243       716 002244       718 002247       719 002252       720 002253
    721 002254       722 002260       723 002261       725 002262       665 002263       667 002264       669 002267
    670 002270       672 002271       673 002272       674 002275       675 002276       676 002305       677 002313
    679 002314       680 002325       681 002333       682 002335       683 002336       685 002340       686 002342
    688 002343       690 002344       692 002347       693 002350       695 002351       696 002354       697 002356
    699 002357       701 002360       703 002363       704 002364       706 002365       707 002370       708 002372
    727 002373       729 002374       731 002377       732 002400       734 002401       735 002402       736 002403
    737 002416       739 002417       740 002430       741 002432       742 002433       743 002434       745 002436
    746 002440       751 002441       753 002442       754 002443       756 002446       757 002447       759 002450
    761 002452       762 002454       763 002457       765 002460       766 002463       768 002465       769 002475
    770 002476       771 002500       772 002510       773 002512       776 002517       777 002521       778 002523
    779 002525       782 002532       783 002534       784 002536       785 002540       788 002550       789 002551
    791 002556       794 002570       795 002571       796 002573       807 002574       809 002575       810 002577
    811 002601       812 002604       814 002605       816 002606       817 002610       818 002612       819 002620
    820 002624       821 002625       822 002634       824 002635       826 002636       827 002640       828 002646
    829 002651       830 002653       831 002662       833 002671       836 002675       838 002676       840 002677
    841 002703       842 002705       844 002706       846 002707       848 002711       849 002714       850 002716
    852 002717       853 002721       855 002724       857 002725       859 002726       860 002727       864 002735
    865 002736       866 002745       867 002746       869 002747       871 002750       873 002751       874 002752
    876 002754       878 002761       879 002762       880 002767       882 002770       883 002776       884 002777
    886 003006       887 003007       889 003016       891 003017       893 003020       894 003023       895 003026
    896 003030       898 003031       900 003033       901 003036       903 003051       905 003052       907 003054
    908 003074       910 003075       912 003103       913 003104       915 003111       918 003116       921 003120
    922 003123       923 003126       924 003131       925 003132       926 003133       927 003134       929 003147
    931 003150       933 003151       935 003154       936 003155       938 003156       939 003157       940 003160
    941 003163       943 003165       944 003174       945 003175       946 003203       947 003207       948 003210
    950 003212       951 003214       956 003215       958 003216       959 003217       961 003223       962 003225
    963 003226       964 003231       965 003232       968 003241       971 003242       973 003243       974 003247
    975 003256       978 003264       979 003265       981 003266       983 003270       984 003271       985 003274
    986 003275       987 003300       990 003301       992 003302       993 003305       994 003307       995 003314
    997 003315       999 003316      1000 003322      1001 003327      1007 003330      1009 003332      1010 003335
   1011 003346      1012 003347      1015 003355      1016 003361      1017 003364      1018 003374      1020 003375
   1021 003400      1022 003402      1023 003405      1024 003406      1026 003413      1027 003431      1028 003442
   1029 003452      1031 003453      1032 003456      1033 003500      1034 003512      1035 003527      1037 003536
   1038 003542      1039 003547      1040 003550      1056 003551      1058 003553      1059 003556      1061 003561
   1062 003571      1063 003572      1065 003577      1066 003602      1067 003607      1068 003620      1071 003621
   1072 003625      1073 003626      1074 003631      1075 003634      1042 003635      1044 003636      1046 003641
   1047 003642      1049 003643      1050 003654      1051 003656      1052 003661      1053 003664      1054 003665
   1089 003666      1091 003667      1092 003671      1094 003676      1096 003677      1098 003701


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
