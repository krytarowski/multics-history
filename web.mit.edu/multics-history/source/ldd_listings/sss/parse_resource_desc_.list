	COMPILATION LISTING OF SEGMENT parse_resource_desc_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phx. Az., Sys-M 
	Compiled on: 07/16/87  1328.7 mst Thu
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(86-07-28,Hartogs), approve(86-07-28,MCR7463),
       16*     audit(86-08-06,Lippard), install(86-08-14,MR12.0-1123):
       17*     Make changes to disallow specifying less than 1 resource for reservation.
       18*  2) change(87-06-08,Rauschelbach), approve(87-07-07,MCR7728),
       19*     audit(87-07-08,Farley), install(87-07-15,MR12.1-1040):
       20*     Changed to set the variable err_msg only when this segment is called
       21*     throught the check entry point.
       22*                                                   END HISTORY COMMENTS */
       23 
       24 /* format: off */
       25 
       26 parse_resource_desc_:
       27      proc (desc_str, area_ptr, resource_desc_ptr, resource_res_ptr, code);
       28 
       29 /*
       30*   This subroutine takes a reservation description string as input and
       31*   returns pointers to two structures containing the necessary information to
       32*   make a reservation of the described resources.  It calls
       33*   cv_rcp_attributes_$from_string_rel to convert the attributes character
       34*   string to a bit string if necessary.
       35**/
       36 
       37 /*
       38*   Written by R.J.C. Kissel 3/78.
       39*   Modified by R.J.C. Kissel 1/79 to handle the new resource description in a compatible fashion.
       40*   Modified by R.J.C. Kissel 3/79 to communicate in a kludgey way with build_resource_desc_.
       41**/
       42 
       43 /* Arguments */
       44 
       45 dcl  desc_str char (*);				/* The reservation description string. */
       46 dcl  area_ptr ptr;					/* Area in which to allocate structures. */
       47 						/* See the resource_control_desc.incl.pl1 for ptr declarations. */
       48 
       49 dcl  code fixed bin (35);				/* Standard system status code. */
       50 
       51 /* Local Variables */
       52 
       53 dcl  check bit (1);					/* Syntax checking flag. */
       54 dcl  arg_string char (256) varying;
       55 						/* To hold individual arguments. */
       56 dcl  volume bit (1);				/* Resource type is device or volume. */
       57 dcl  count fixed bin;				/* Count of allocations. */
       58 dcl  cur_pos fixed bin;				/* Current position in desc_str. */
       59 dcl  i fixed bin;					/* Index for accessing structures. */
       60 dcl  junk_bit bit (1);
       61 dcl  rsc_type char (32);				/* primary resource type */
       62 
       63 dcl  new ptr;					/* Pointer to a new parse_info structure. */
       64 dcl  head ptr;					/* Pointer to the head of the parse_info list. */
       65 dcl  tail ptr;					/* Pointer to the tail of the parse_info list. */
       66 
       67 dcl 1 parse_info based,				/* Structure to save info from each resource description. */
       68     2 next ptr,					/* Next structure in the list. */
       69     2 rsc_type char (32),				/* The resource type. */
       70     2 rsc_name char (32),				/* The resource name. */
       71     2 attr bit (72) dim (4),				/* The resource attributes. */
       72     2 number fixed bin;				/* How many of this resource to get. */
       73 
       74 /* Local Constants */
       75 
       76 /* Local Overlays */
       77 
       78 dcl  based_area area (261129) based;
       79 						/* Area overlay. */
       80 
       81 /* Include Files */
       82 
  1     1 /* --------------- BEGIN include file resource_control_desc.incl.pl1 --------------- */
  1     2 
  1     3 /* Written by R.J.C. Kissel 3/78. */
  1     4 /* Modified 09/28/78 by C. D. Tavares */
  1     5 
  1     6 dcl 1 resource_descriptions based (resource_desc_ptr) aligned,
  1     7     2 version_no fixed bin,				/* caller must set this to resource_desc_version_1 */
  1     8     2 n_items fixed bin,				/* Number of resources described by this structure. */
  1     9     2 item (Resource_count refer (resource_descriptions.n_items)) aligned,
  1    10       3 type char (32),				/* e.g., "tape_drive" */
  1    11       3 name char (32),				/* e.g., "tapa_03" */
  1    12       3 uid bit (36),				/* The resource unique id. */
  1    13       3 potential_attributes bit (72),			/* resource's permissible attributes */
  1    14       3 attributes (2) bit (72),			/* RCP attribute description (output) */
  1    15       3 desired_attributes (4) bit (72),		/* desired attributes (input) */
  1    16       3 potential_aim_range (2) bit (72),		/* Lowest and highest possible AIM bounds for resource */
  1    17       3 aim_range (2) bit (72),			/* Current AIM range */
  1    18       3 owner char (32),				/* e.g., "Smith.Project" */
  1    19       3 acs_path char (168),				/* Access control segment pathname. */
  1    20       3 location char (168),				/* String describing location in unusual cases */
  1    21       3 comment char (168),				/* User-settable comment string */
  1    22       3 charge_type char (32),			/* accounting identifier for this resource */
  1    23       3 rew bit (3) unaligned,			/* user's effective access to resource */
  1    24       3 (usage_lock,				/* This resource may not be acquired or used. */
  1    25          release_lock,				/* The owner is not allowed to release the resource. */
  1    26          awaiting_clear,				/* Resource awaiting manual clear */
  1    27          user_alloc) bit (1) unaligned,			/* User claims volume contains useful data */
  1    28       3 pad2 bit (29) unaligned,			/* Ignored field. */
  1    29       3 given aligned,				/* each of these bits says the corresponding */
  1    30 						/* item is significant on input */
  1    31        (4 (name,
  1    32 	 uid,
  1    33 	 potential_attributes,
  1    34 	 desired_attributes,
  1    35 	 potential_aim_range,
  1    36 	 aim_range,
  1    37 	 owner,
  1    38 	 acs_path,
  1    39 	 location,
  1    40 	 comment,
  1    41 	 charge_type,
  1    42 	 usage_lock,
  1    43 	 release_lock,
  1    44 	 user_alloc) bit (1),
  1    45         4 pad1 bit (22)) unaligned,
  1    46       3 state bit (36) aligned,			/* For use of resource_control_ only */
  1    47       3 status_code fixed bin (35);			/* Standard system status code for this resource. */
  1    48 
  1    49 
  1    50 /* Note that the reservation description must always be used with a resource
  1    51*   description structure.  When they are used together the two structures must
  1    52*   have the same number of entries, i.e. Resource_count is the same for both. */
  1    53 
  1    54 
  1    55 dcl 1 reservation_description based (resource_res_ptr) aligned,
  1    56     2 version_no fixed bin,				/* The version number for this structure. */
  1    57     2 reserved_for char (32),				/* Group id of reserved for process. */
  1    58     2 reserved_by char (32),				/* Group id of reserved by process. */
  1    59     2 reservation_id fixed bin (71),			/* Reservation id of this reservation group. */
  1    60     2 group_starting_time fixed bin (71),		/* Starting time for this reservation group. */
  1    61     2 asap_duration fixed bin (71),			/* Duration after which as soon as possible is no longer good. */
  1    62     2 flags aligned,
  1    63      (3 auto_expire bit (1),				/* Should reservation expire when this process terminates. */
  1    64       3 asap bit (1),				/* Make this reservation group as soon as possible. */
  1    65       3 rel bit (1),				/* Times are relative/absolute. */
  1    66       3 sec bit (1)) unaligned,			/* Times are in sec/microsec. */
  1    67     2 n_items fixed bin,				/* Number of resources reserved in this group. */
  1    68     2 reservation_group (Resource_count refer (reservation_description.n_items)),
  1    69       3 starting_time fixed bin (71),			/* When this resource res. starts in the group. */
  1    70       3 duration fixed bin (71);			/* Duration of this resource res. in the group. */
  1    71 
  1    72 dcl (resource_desc_ptr,
  1    73      resource_res_ptr) pointer;
  1    74 
  1    75 dcl (resource_desc_version_1 initial (1),
  1    76      resource_res_version_1 initial (1)) internal static options (constant);
  1    77 
  1    78 dcl  Resource_count fixed bin;			/* The number of resources described in the structures. */
  1    79 
  1    80 /* ---------------- END include file resource_control_desc.incl.pl1 ---------------- */
       83 
       84 
  2     1 /*	Begin include file ... rcp_resource_types.incl.pl1
  2     2*   *
  2     3*   *	Created 3/79 by Michael R. Jordan for MR7.0R
  2     4*   *
  2     5*   *	This include file defines the official RCP resource types.
  2     6*   *	The array of names is indexed by the corresponding device type.
  2     7*   *      MOD by RAF for MCA
  2     8**/
  2     9 
  2    10 
  2    11 
  2    12 /****^  HISTORY COMMENTS:
  2    13*  1) change(85-09-09,Fawcett), approve(85-09-09,MCR6979),
  2    14*     audit(85-12-09,CLJones), install(86-03-21,MR12.0-1033):
  2    15*     Support of MCA.
  2    16*                                                   END HISTORY COMMENTS */
  2    17 
  2    18 dcl  DEVICE_TYPE (8) char (32)
  2    19 	internal static options (constant)
  2    20 	init ("tape_drive", "disk_drive", "console", "printer", "punch", "reader", "special", "mca");
  2    21 
  2    22 dcl  NUM_QUALIFIERS (8) fixed bin			/* Number of qualifiers for each device type. */
  2    23 	internal static init (3, 0, 0, 2, 0, 0, 0, 0);
  2    24 
  2    25 dcl  VOLUME_TYPE (8) char (32)
  2    26 	internal static options (constant)
  2    27 	init ("tape_vol", "disk_vol", "", "", "", "", "", "");
  2    28 
  2    29 dcl  TAPE_DRIVE_DTYPEX fixed bin static internal options (constant) init (1);
  2    30 dcl  DISK_DRIVE_DTYPEX fixed bin static internal options (constant) init (2);
  2    31 dcl  CONSOLE_DTYPEX fixed bin static internal options (constant) init (3);
  2    32 dcl  PRINTER_DTYPEX fixed bin static internal options (constant) init (4);
  2    33 dcl  PUNCH_DTYPEX fixed bin static internal options (constant) init (5);
  2    34 dcl  READER_DTYPEX fixed bin static internal options (constant) init (6);
  2    35 dcl  SPECIAL_DTYPEX fixed bin static internal options (constant) init (7);
  2    36 dcl  MCA_DTYPEX fixed bin static internal options (constant) init (8);
  2    37 dcl  TAPE_VOL_VTYPEX fixed bin static internal options (constant) init (1);
  2    38 dcl  DISK_VOL_VTYPEX fixed bin static internal options (constant) init (2);
  2    39 
  2    40 
  2    41 /*	End include file ... rcp_resource_types.incl.pl1 */
       85 
       86 
       87 /* External Entries */
       88 
       89 dcl  cv_rcp_attributes_$from_string_rel
       90      entry (char (*), bit (72) dim (4), char (*) varying, fixed bin (35));
       91 dcl  get_system_free_area_
       92      entry returns (ptr);
       93 dcl  resource_info_$get_primary_type
       94      entry (char (*), char (*), fixed bin (35));
       95 dcl  resource_info_$get_type
       96      entry (char (*), bit (1), fixed bin (35));
       97 dcl  get_group_id_ entry returns (char (32));
       98 dcl  build_resource_desc_$reserve
       99      entry ((*) char (*) varying, ptr, ptr, ptr, ptr, ptr, char (*) varying, fixed bin (35));
      100 
      101 /* External Constants */
      102 
      103 dcl  error_table_$badcall
      104      fixed bin (35) external;
      105 dcl  error_table_$noarg fixed bin (35) external;
      106 dcl  error_table_$name_not_found
      107      fixed bin (35) external;
      108 dcl  error_table_$bad_conversion
      109      fixed bin (35) external;
      110 dcl  error_table_$bad_index
      111      fixed bin (35) external;
      112 dcl  error_table_$badopt fixed bin (35) external;
      113 dcl  error_table_$inconsistent
      114      fixed bin (35) external;
      115 dcl  error_table_$unbalanced_quotes
      116      fixed bin (35) external;
      117 dcl  error_table_$resource_type_unknown
      118      fixed bin (35) external;
      119 dcl  error_table_$resource_spec_ambiguous
      120      fixed bin (35) external;
      121 dcl  error_table_$area_too_small
      122      fixed bin (35) external;
      123 
      124 /* Builtin Functions and Conditions */
      125 
      126 dcl (lbound, hbound, unspec, length, null, convert, substr, ltrim, rtrim)
      127      builtin;
      128 dcl (cleanup, conversion, area)
      129      condition;
      130 
      131 	check = "0"b;
      132 
      133 	if area_ptr = null
      134 	then area_ptr = get_system_free_area_ ();	/* Default area for this entry. */
      135 
      136 	goto START;				/* This is the only reference to this label. */
      137 
      138 check:
      139 	entry (desc_str, area_ptr, resource_desc_ptr, resource_res_ptr, err_msg, code);
      140 
      141 /* *
      142*   This entry takes the same inputs and returns the same outputs as
      143*   parse_resource_desc_.  However, more complete diagnostics are available
      144*   in case an error is detected.
      145**/
      146 
      147 /* Arguments */
      148 
      149 dcl  err_msg char (*) varying;			/* A description of an error if one occurs. */
      150 
      151 	err_msg = "";
      152 	check = "1"b;
      153 
      154 START:						/* There is only one reference to this label. */
      155 dcl 1 token based aligned,
      156     2 next ptr,
      157     2 index fixed bin (24),
      158     2 length fixed bin (24);
      159 
      160 dcl  tp ptr;					/* Token pointer. */
      161 dcl  outidx fixed bin (24);
      162 dcl  inidx fixed bin (24);
      163 dcl  token_head_ptr ptr;				/* Start of token list. */
      164 dcl  num_of_tokens fixed bin;
      165 dcl  max_token_length fixed bin (24);
      166 dcl  token_array dim (num_of_tokens) char (max_token_length) varying based;
      167 dcl  tap ptr;					/* Token array pointer. */
      168 dcl  aidx fixed bin;				/* Token array index. */
      169 dcl  token_string char (string_length) based;
      170 dcl  tsp ptr;					/* Token string pointer. */
      171 dcl  string_length fixed bin (24);
      172 dcl  token_index fixed bin (24);
      173 dcl  token_length fixed bin (24);
      174 dcl  token_exists bit (1);
      175 dcl  error_msg char (256) varying;
      176 dcl  new_code fixed bin (35);
      177 dcl  ridx fixed bin;				/* Resource description index. */
      178 
      179 	num_of_tokens = 0;
      180 	max_token_length = 0;
      181 	token_head_ptr = null ();
      182 	tap = null ();
      183 	tsp = null ();
      184 	tp = null ();
      185 
      186 	on cleanup
      187 	     call Cleanup_Handler;
      188 
      189 	string_length = length (desc_str);
      190 	on area
      191 	     goto ERROR_area;
      192 	allocate token_string set (tsp);
      193 	revert area;
      194 
      195 	inidx = 1;
      196 	outidx = 1;
      197 	tsp -> token_string = "";
      198 
      199 	call Get_Next_Token (desc_str, tsp -> token_string, inidx, outidx, token_index, token_length, token_exists);
      200 
      201 	on area
      202 	     goto ERROR_area;
      203 
      204 /*
      205*   Push tokens onto a LIFO stack, keeping track of how many there are
      206*   and the length of the longest one.
      207**/
      208 
      209 	do while (token_exists);
      210 
      211 	     allocate token set (tp);
      212 
      213 	     tp -> token.index = token_index;
      214 	     tp -> token.length = token_length;
      215 	     tp -> token.next = token_head_ptr;
      216 
      217 	     token_head_ptr = tp;
      218 	     num_of_tokens = num_of_tokens + 1;
      219 
      220 	     if token_length > max_token_length
      221 	     then max_token_length = token_length;
      222 
      223 	     call Get_Next_Token (desc_str, tsp -> token_string, inidx, outidx, token_index, token_length, token_exists);
      224 	end;
      225 
      226 	if num_of_tokens > 0
      227 	then allocate token_array set (tap);
      228 	else goto ERROR_notype;
      229 
      230 	revert area;
      231 
      232 /*
      233*   Now fill in the token_array from the end so that the tokens
      234*   will be in their original order.
      235**/
      236 
      237 	do aidx = hbound (tap -> token_array, 1) to lbound (tap -> token_array, 1) by -1;
      238 
      239 	     tp = token_head_ptr;
      240 	     if tp = null ()
      241 	     then goto ERROR_internal;
      242 
      243 	     tap -> token_array (aidx) = substr (tsp -> token_string, tp -> token.index, tp -> token.length);
      244 
      245 	     token_head_ptr = tp -> token.next;
      246 	     free tp -> token;			/* Clean up as we go. */
      247 	end;
      248 
      249 	free tsp -> token_string;			/* This is no longer needed. */
      250 
      251 /*
      252*   Now call build_resource_desc_$reserve to do the real parsing work
      253*   and error checking.
      254*   Note that for now, build_resource_desc_ can return a zero error
      255*   code and a non-null error message of "User speicfied attributes.".
      256*   This will be used as explained in a comment below.
      257**/
      258 
      259 	call build_resource_desc_$reserve (tap -> token_array, area_ptr, null (), resource_desc_ptr, resource_res_ptr,
      260 	     null (), error_msg, new_code);
      261 	if new_code ^= 0
      262 	then goto ERROR_rdesc;
      263 
      264 /*
      265*   Now check the resource description structures to make sure they
      266*   adhere to the very limited rules currently allowed.
      267**/
      268 
      269 	if resource_desc_ptr ^= null ()
      270 	then do;
      271 	     Resource_count = resource_descriptions.n_items;
      272 
      273 	     do ridx = 1 to Resource_count by 1;
      274 
      275 /*
      276*   Check for possible old description which would be parsed correctly.
      277**/
      278 
      279 		if resource_descriptions.item (ridx).name = VOLUME_TYPE (TAPE_VOL_VTYPEX)
      280 		| resource_descriptions.item (ridx).name = DEVICE_TYPE (TAPE_DRIVE_DTYPEX)
      281 		| resource_descriptions.item (ridx).name = VOLUME_TYPE (DISK_VOL_VTYPEX)
      282 		| resource_descriptions.item (ridx).name = DEVICE_TYPE (DISK_DRIVE_DTYPEX)
      283 		then do;
      284 		     new_code = 0;
      285 		     error_msg = "";
      286 		     call Cleanup_Handler ();
      287 		     revert cleanup;
      288 		     goto OLD_DESCRIPTION_PARSER;
      289 		end;
      290 
      291 		call resource_info_$get_primary_type ((resource_descriptions.item (ridx).type), rsc_type, code);
      292 		if code ^= 0 then goto ERROR_type;
      293 		if rsc_type ^= VOLUME_TYPE (TAPE_VOL_VTYPEX)
      294 		& rsc_type ^= DEVICE_TYPE (TAPE_DRIVE_DTYPEX)
      295 		& rsc_type ^= VOLUME_TYPE (DISK_VOL_VTYPEX)
      296 		& rsc_type ^= DEVICE_TYPE (DISK_DRIVE_DTYPEX)
      297 		then goto ERROR_type;
      298 
      299 		if (unspec (resource_descriptions.item (ridx).given) & "337777777777"b3) ^= "0"b
      300 		then goto ERROR_carg;
      301 
      302 /*
      303*   The following is a kludge agreed upon by parse_resource_desc_ and
      304*   build_resource_desc_.  It allows build_resource_desc_ to pass back information
      305*   about what the user really specified so that parse_resource_desc_ can use it
      306*   here to restrict the acceptable syntax of  a resource description.  This
      307*   must be done because when build_resource_desc_ sets defaults
      308*   the attributes given bit will always be set so that rcp_reserve_ can use
      309*   the defaults even if the user didn't specify any attributes.  This destroys
      310*   any information that build_resource_desc_ could return about what the
      311*   user really said on his command line which is the information that parse_resource_desc_
      312*   currently needs.
      313**/
      314 
      315 		if resource_descriptions.item (ridx).given.name & resource_descriptions.item (ridx).status_code = 1
      316 		then goto ERROR_nmattr;
      317 
      318 		if (resource_descriptions.item (ridx).type = VOLUME_TYPE (TAPE_VOL_VTYPEX)
      319 		| resource_descriptions.item (ridx).type = VOLUME_TYPE (DISK_VOL_VTYPEX))
      320 		& ^resource_descriptions.item (ridx).given.name
      321 		then goto ERROR_volnm;
      322 	     end;
      323 	end;
      324 
      325 /*
      326*   Done with the extra checks for MR7.0.
      327**/
      328 
      329 	free tap -> token_array;			/* Finish freeing everything. */
      330 
      331 	if check
      332 	then err_msg = "";
      333 	code = 0;
      334 	revert cleanup;
      335 
      336 	return;
      337 
      338 ERROR_type:
      339 	code = error_table_$resource_type_unknown;
      340 	if check
      341 	then err_msg = resource_descriptions.item (ridx).type;
      342 	call Cleanup_Handler ();
      343 	revert cleanup;
      344 	return;
      345 
      346 ERROR_carg:
      347 	code = error_table_$badopt;
      348 	if check
      349 	then err_msg = "A control arg other than -attributes or -number was given.";
      350 	call Cleanup_Handler ();
      351 	revert cleanup;
      352 	return;
      353 
      354 ERROR_volnm:
      355 	code = error_table_$resource_spec_ambiguous;
      356 	if check
      357 	then err_msg = "Names must be given for volume resource types.";
      358 	call Cleanup_Handler ();
      359 	revert cleanup;
      360 	return;
      361 
      362 ERROR_nmattr:
      363 	code = error_table_$inconsistent;
      364 	if check
      365 	then err_msg = "If a name is given then attributes may not be given.";
      366 	call Cleanup_Handler ();
      367 	revert cleanup;
      368 	return;
      369 
      370 ERROR_noroom:
      371 	code = error_table_$bad_index;
      372 	if check
      373 	then err_msg = "Internal error in parse_resource_desc_.";
      374 	call Cleanup_Handler ();
      375 	revert cleanup;
      376 	return;
      377 
      378 ERROR_noquote:
      379 	code = error_table_$unbalanced_quotes;
      380 	if check
      381 	then err_msg = "Rest of string is: " || substr (desc_str, inidx);
      382 	call Cleanup_Handler ();
      383 	revert cleanup;
      384 	return;
      385 
      386 ERROR_internal:
      387 	code = error_table_$bad_index;
      388 	if check
      389 	then err_msg = "Internal indexing error in parse_resource_desc_.";
      390 	call Cleanup_Handler ();
      391 	revert cleanup;
      392 	return;
      393 
      394 ERROR_notype:
      395 	code = error_table_$resource_spec_ambiguous;
      396 	if check
      397 	then err_msg = "At least a resource type must be specified.";
      398 	call Cleanup_Handler ();
      399 	revert cleanup;
      400 	return;
      401 
      402 ERROR_area:
      403 	code = error_table_$area_too_small;
      404 	if check
      405 	then err_msg = "Not enough area storage to allocate internal structures.";
      406 	call Cleanup_Handler ();
      407 	revert cleanup;
      408 	return;
      409 
      410 ERROR_rdesc:					/*
      411*						   For now we have the new error code and the error message, so we will
      412*						   let the old parser have a chance.  If it works, then we will be happy
      413*						   and report no errors.  If it fails then we will report the code and
      414*						   error found here.
      415*						   */
      416 	call Cleanup_Handler ();
      417 	revert cleanup;
      418 	goto OLD_DESCRIPTION_PARSER;
      419 
      420 Get_Next_Token:
      421 	proc (P_instr, P_outstr, P_inidx, P_outidx, P_tidx, P_tlen, P_texists);
      422 
      423 dcl (
      424      P_instr char (*),				/* Input  -- string of tokens. */
      425      P_outstr char (*),				/* Input/Output -- string into which tokens are copied. */
      426      P_inidx fixed bin (24),				/* Input/Output -- index into P_instr. */
      427      P_outidx fixed bin (24),				/* Input/Output -- index into P_outstr. */
      428      P_tidx fixed bin (24),				/* Output -- index in P_outstr of the current token. */
      429      P_tlen fixed bin (24),				/* Output -- length of the current token. */
      430      P_texists bit (1)				/* Output -- true if the current token exists. */
      431      ) parameter;
      432 
      433 /*
      434*   D_E_S_C_R_I_P_T_I_O_N_
      435*
      436*   This subroutine takes a character string and parses it into
      437*   tokens.  A token is delimited by white space (space, horizontal tab,
      438*   vertical tab, form feed, carrige return, or new line).
      439*   Quoted tokens are handled correctly and are returned with one
      440*   level of quotes stripped.  The token is returned by giving its index
      441*   and length in P_outstr.
      442*   Notice that P_outstr need be no longer than P_instr (because
      443*   quotes and white space are only removed, never added).
      444*   Also, the caller should never modify the Input/Output parameters:
      445*   P_inidx, P_outidx, and P_outstr.  However, on the first call both
      446*   P_inidx and P_outidx should be initialized to 1, and P_outstr should
      447*   be initailized to the null string.  P_instr is never modified by
      448*   this subroutine.
      449*
      450*
      451*   J_O_U_R_N_A_L_I_Z_A_T_I_O_N_
      452*
      453*   1) Written 11/78 by R.J.C. Kissel.
      454**/
      455 
      456 /* Local Variables */
      457 
      458 dcl  start_of_token fixed bin (24);
      459 dcl  length_of_token fixed bin (24);
      460 dcl  subtoken_len fixed bin (24);
      461 dcl  subtoken_idx fixed bin (24);
      462 dcl  outidx fixed bin (24);
      463 dcl  more_string bit (1);
      464 
      465 
      466 /* Local Constants */
      467 
      468 dcl  C_true bit (1) init ("1"b);
      469 dcl  C_false bit (1) init ("0"b);
      470 dcl  C_quote char (1) init ("""");
      471 dcl  C_white_space char (6) init (" 	
      472 ");
      473 						/* SP, HT, VT, FF, CR, NL */
      474 
      475 /* Builtin Fucntions and Conditions */
      476 
      477 dcl (length, substr, search, verify)
      478      builtin;
      479 
      480 	     if P_inidx = length (P_instr) + 1
      481 	     then do;				/* The input string is already processed. */
      482 		P_tidx = 0;
      483 		P_tlen = 0;
      484 		P_texists = C_false;
      485 		return;
      486 	     end;					/* The input string is already processed. */
      487 
      488 	     length_of_token = 0;
      489 	     start_of_token = verify (substr (P_instr, P_inidx), C_white_space) + P_inidx - 1;
      490 
      491 	     if start_of_token = P_inidx - 1
      492 	     then do;				/* There is no token, only white space. */
      493 		P_inidx = length (P_instr) + 1;	/* Last character index + one. */
      494 		P_tidx = 0;
      495 		P_tlen = 0;
      496 		P_texists = C_false;
      497 	     end;					/* There is no token, only white space. */
      498 
      499 	     else do;				/* There is a token to process. */
      500 		if substr (P_instr, start_of_token, 1) ^= C_quote
      501 		then do;				/* Process a regular token. */
      502 		     length_of_token = search (substr (P_instr, start_of_token), C_white_space) - 1;
      503 		     if length_of_token = -1
      504 		     then length_of_token = length (substr (P_instr, start_of_token));
      505 
      506 		     if search (substr (P_instr, start_of_token, length_of_token), C_quote) ^= 0
      507 		     then goto ERROR_noquote;		/* Don't allow embedded quotes. */
      508 
      509 		     if P_outidx + length_of_token - 1 > length (P_outstr)
      510 		     then goto ERROR_noroom;
      511 		     substr (P_outstr, P_outidx, length_of_token) = substr (P_instr, start_of_token, length_of_token);
      512 						/* copy the token. */
      513 
      514 		     P_tidx = P_outidx;
      515 		     P_tlen = length_of_token;
      516 		     P_texists = C_true;
      517 
      518 		     P_inidx = start_of_token + length_of_token;
      519 		     P_outidx = P_outidx + length_of_token;
      520 		end;				/* Process a regular token. */
      521 
      522 		else do;				/* Process a quoted string token. */
      523 		     outidx = P_outidx;
      524 		     subtoken_idx = start_of_token;
      525 		     more_string = C_true;
      526 
      527 		     do while (more_string);
      528 			subtoken_idx = subtoken_idx + 1;
      529 						/* Skip the initial quote. */
      530 			subtoken_len = search (substr (P_instr, subtoken_idx), C_quote) - 1;
      531 						/* Look for the next quote. */
      532 			if subtoken_len = -1
      533 			then goto ERROR_noquote;
      534 
      535 /*
      536*   Now copy the subtoken we just found without the final quote and
      537*   checking for the null string.
      538**/
      539 
      540 			if subtoken_len > 0
      541 			then do;			/* There is something to copy. */
      542 			     if outidx + subtoken_len - 1 > length (P_outstr)
      543 			     then goto ERROR_noroom;
      544 			     substr (P_outstr, outidx, subtoken_len) =
      545 				substr (P_instr, subtoken_idx, subtoken_len);
      546 						/* copy the token. */
      547 			     outidx = outidx + subtoken_len;
      548 						/* Move the index in P_outstr to the next available position. */
      549 			end;			/* There is something to copy. */
      550 
      551 			length_of_token = length_of_token + subtoken_len;
      552 						/* Keep track of the total length of the token. */
      553 
      554 			subtoken_idx = subtoken_idx + subtoken_len + 1;
      555 						/* Skip the final quote in the subtoken. */
      556 
      557 			if substr (P_instr, subtoken_idx, 1) = C_quote
      558 			then do;			/* Take care of a doubled quote. */
      559 			     if outidx + 1 - 1 > length (P_outstr)
      560 			     then goto ERROR_noroom;
      561 
      562 			     substr (P_outstr, outidx, 1) = C_quote;
      563 						/* Copy the quote. */
      564 			     outidx = outidx + 1;
      565 						/* Move the index in P_outstr to the next available position. */
      566 			     length_of_token = length_of_token + 1;
      567 						/* Keep track of the total length of the token. */
      568 			end;			/* Take care of a doubled quote. */
      569 
      570 			else if verify (substr (P_instr, subtoken_idx, 1), C_white_space) ^= 0
      571 			then goto ERROR_noquote;
      572 
      573 			else more_string = C_false;
      574 						/* Done with the quoted token. */
      575 		     end;
      576 
      577 		     P_tidx = P_outidx;
      578 		     P_tlen = length_of_token;
      579 		     P_texists = C_true;
      580 
      581 		     P_inidx = subtoken_idx;
      582 		     P_outidx = P_outidx + length_of_token;
      583 		end;				/* Process a quoted string token. */
      584 	     end;					/* There is a token to process. */
      585 
      586 	end Get_Next_Token;
      587 
      588 Cleanup_Handler:
      589 	proc ();
      590 
      591 	     if tap ^= null ()
      592 	     then free tap -> token_array;
      593 
      594 	     if tsp ^= null ()
      595 	     then free tsp -> token_string;
      596 
      597 	     if tp ^= null () & tp ^= token_head_ptr
      598 	     then free tp -> token;			/* A small window. */
      599 
      600 	     do while (token_head_ptr ^= null ());
      601 		tp = token_head_ptr;
      602 		token_head_ptr = tp -> token.next;
      603 		free tp -> token;
      604 	     end;
      605 
      606 	     if area_ptr ^= null ()
      607 	     then do;
      608 		if resource_desc_ptr ^= null ()
      609 		then do;
      610 		     free resource_descriptions in (area_ptr -> based_area);
      611 		     resource_desc_ptr = null ();
      612 		end;
      613 
      614 		if resource_res_ptr ^= null ()
      615 		then do;
      616 		     free reservation_description in (area_ptr -> based_area);
      617 		     resource_res_ptr = null ();
      618 		end;
      619 	     end;
      620 	end Cleanup_Handler;
      621 
      622 OLD_DESCRIPTION_PARSER:				/* Initialize pointers and local variables. */
      623 	resource_desc_ptr = null;
      624 	resource_res_ptr = null;
      625 	code = 0;
      626 
      627 	arg_string = "";
      628 	volume = "0"b;
      629 	count = 0;
      630 	cur_pos = 0;
      631 
      632 	new = null;
      633 	head = null;
      634 	tail = null;
      635 
      636 
      637 	on cleanup
      638 	     call cleanup_handler;
      639 
      640 	arg_string = get_next_arg (desc_str, cur_pos);
      641 
      642 	if arg_string = ""
      643 	then goto BAD_DESC;
      644 
      645 	do while (arg_string ^= "");			/* Process one resource description at a time. */
      646 
      647 /* Check the validity of the resource type argument. */
      648 
      649 	     call resource_info_$get_type ((arg_string), volume, code);
      650 
      651 	     if code ^= 0
      652 	     then goto BAD_TYPE;
      653 
      654 /* Process all the arguments for one resource description. */
      655 
      656 	     allocate parse_info set (new);
      657 	     new -> parse_info.next = null;
      658 	     new -> parse_info.rsc_type = arg_string;
      659 	     new -> parse_info.rsc_name = "";
      660 	     new -> parse_info.attr = "0"b;
      661 	     new -> parse_info.number = 1;		/* There is at least one. */
      662 
      663 	     if head = null
      664 	     then head = new;
      665 
      666 	     if tail ^= null
      667 	     then tail -> parse_info.next = new;
      668 
      669 	     tail = new;
      670 
      671 	     if ^volume
      672 	     then do;				/* This is a device type resource. */
      673 		arg_string = get_next_arg (desc_str, cur_pos);
      674 
      675 		if arg_string = ""
      676 		then do;				/* All defaults apply and we are done. */
      677 		     call cv_rcp_attributes_$from_string_rel (new -> parse_info.rsc_type,
      678 			new -> parse_info.attr, "", code);
      679 
      680 		     if code ^= 0
      681 		     then goto BAD_DEFAULT;
      682 		end;				/* All defaults apply and we are done. */
      683 
      684 		else if arg_string = "-name" | arg_string = "-nm"
      685 		then do;				/* A strange name argument. */
      686 		     arg_string = get_next_arg (desc_str, cur_pos);
      687 
      688 		     if arg_string = ""
      689 		     then goto BAD_NAME_ARG;
      690 
      691 		     new -> parse_info.rsc_name = arg_string;
      692 		     arg_string = get_next_arg (desc_str, cur_pos);
      693 		end;				/* A strange name argument. */
      694 
      695 		else if arg_string = "-attributes" | arg_string = "-attr"
      696 		then do;				/* Attributes argument. */
      697 		     arg_string = get_next_arg (desc_str, cur_pos);
      698 
      699 		     if arg_string = ""
      700 		     then goto BAD_ATTR_ARG;
      701 
      702 		     call cv_rcp_attributes_$from_string_rel (new -> parse_info.rsc_type,
      703 			new -> parse_info.attr, arg_string, code);
      704 
      705 		     if code ^= 0
      706 		     then goto BAD_ATTR;
      707 
      708 		     arg_string = get_next_arg (desc_str, cur_pos);
      709 
      710 		     if arg_string = "-number" | arg_string = "-nb"
      711 		     then do;			/* We can have a number in this case. */
      712 			arg_string = get_next_arg (desc_str, cur_pos);
      713 
      714 			if arg_string = ""
      715 			then goto BAD_NUM_ARG;
      716 
      717 			on conversion
      718 			     goto BAD_NUMBER;
      719 
      720 			new -> parse_info.number = convert (new -> parse_info.number, arg_string);
      721 			revert conversion;
      722 
      723 			if new -> parse_info.number <= 0 then
      724 			   goto BAD_NUMBER;
      725 
      726 			arg_string = get_next_arg (desc_str, cur_pos);
      727 
      728 		     end;				/* We can have a number in this case. */
      729 		end;				/* Attributes argument. */
      730 
      731 		else if arg_string = "-number" | arg_string = "-nb"
      732 		then do;				/* Number argument. */
      733 		     arg_string = get_next_arg (desc_str, cur_pos);
      734 
      735 		     if arg_string = ""
      736 		     then goto BAD_NUM_ARG;
      737 
      738 		     on conversion
      739 			goto BAD_NUMBER;
      740 
      741 		     new -> parse_info.number = convert (new -> parse_info.number, arg_string);
      742 		     revert conversion;
      743 
      744 		     if new -> parse_info.number <= 0 then
      745 		        goto BAD_NUMBER;
      746 
      747 		     arg_string = get_next_arg (desc_str, cur_pos);
      748 
      749 		     if arg_string ^= "-attributes" & arg_string ^= "-attr"
      750 		     then do;			/* Get default attributes. */
      751 			call cv_rcp_attributes_$from_string_rel (new -> parse_info.rsc_type,
      752 			     new -> parse_info.attr, "", code);
      753 
      754 			if code ^= 0
      755 			then goto BAD_DEFAULT;
      756 
      757 		     end;				/* Get default attributes. */
      758 
      759 		     else do;			/* Attributes argument. */
      760 			arg_string = get_next_arg (desc_str, cur_pos);
      761 
      762 			if arg_string = ""
      763 			then goto BAD_ATTR_ARG;
      764 
      765 			call cv_rcp_attributes_$from_string_rel (new -> parse_info.rsc_type,
      766 			     new -> parse_info.attr, arg_string, code);
      767 
      768 			if code ^= 0
      769 			then goto BAD_ATTR;
      770 
      771 			arg_string = get_next_arg (desc_str, cur_pos);
      772 		     end;				/* Attributes argument. */
      773 		end;				/* Number argument. */
      774 
      775 		else do;				/* A device name may have been given. */
      776 
      777 		     call resource_info_$get_type ((arg_string), junk_bit, code);
      778 						/* Just want the code. */
      779 
      780 		     if code ^= 0
      781 		     then do;			/* A device name. */
      782 			if code = error_table_$name_not_found
      783 			then do;
      784 			     code = 0;
      785 			     new -> parse_info.rsc_name = arg_string;
      786 			     arg_string = get_next_arg (desc_str, cur_pos);
      787 			end;
      788 
      789 			else goto BAD_ERROR;
      790 		     end;				/* A device name. */
      791 		end;				/* A device name may have been given. */
      792 	     end;					/* This is a device type resource. */
      793 
      794 	     else do;				/* This is a volume type resource. */
      795 		arg_string = get_next_arg (desc_str, cur_pos);
      796 
      797 		if arg_string = ""
      798 		then goto BAD_VOL_NAME;
      799 
      800 		if arg_string = "-name" | arg_string = "-nm"
      801 		then do;				/* Strange name argument. */
      802 		     arg_string = get_next_arg (desc_str, cur_pos);
      803 
      804 		     if arg_string = ""
      805 		     then goto BAD_NAME_ARG;
      806 
      807 		     new -> parse_info.rsc_name = arg_string;
      808 		end;				/* Strange name argument. */
      809 
      810 		else if substr (arg_string, 1, 1) = "-"
      811 		then goto BAD_VOL_NAME;
      812 
      813 		else new -> parse_info.rsc_name = arg_string;
      814 
      815 		arg_string = get_next_arg (desc_str, cur_pos);
      816 	     end;					/* This is a volume type resource. */
      817 
      818 	     count = count + tail -> parse_info.number;
      819 
      820 	end;					/* Process one resource description at a time. */
      821 
      822 /* Now build the structures to return in the appropriate area. */
      823 
      824 	if area_ptr = null
      825 	then do;					/* We are done. */
      826 	     code = 0;
      827 	     call cleanup_handler;
      828 	     return;
      829 	end;					/* We are done. */
      830 
      831 	Resource_count = count;			/* Need this to allocate the structures. */
      832 
      833 	on area
      834 	     goto BAD_AREA;
      835 	allocate resource_descriptions in (area_ptr -> based_area) set (resource_desc_ptr);
      836 	allocate reservation_description in (area_ptr -> based_area) set (resource_res_ptr);
      837 	revert area;
      838 
      839 /* Fill in the constant parts of the structures with the given information and defaults. */
      840 
      841 	resource_descriptions.version_no = resource_desc_version_1;
      842 	resource_descriptions.n_items = Resource_count;
      843 
      844 	reservation_description.version_no = resource_res_version_1;
      845 	reservation_description.reserved_for = get_group_id_ ();
      846 	reservation_description.reserved_by = get_group_id_ ();
      847 	reservation_description.group_starting_time = 0;
      848 	reservation_description.asap_duration = 0;
      849 	reservation_description.auto_expire = "0"b;
      850 	reservation_description.asap = "0"b;
      851 	reservation_description.rel = "1"b;
      852 	reservation_description.sec = "0"b;
      853 	reservation_description.n_items = Resource_count;
      854 
      855 /* Fill in the variable parts of the structures with the given information and defaults. */
      856 
      857 	new = head;
      858 
      859 	do i = 1 to Resource_count by 1;
      860 	     resource_descriptions.item (i).type = new -> parse_info.rsc_type;
      861 	     resource_descriptions.item (i).name = new -> parse_info.rsc_name;
      862 	     resource_descriptions.item (i).uid = "0"b;
      863 	     resource_descriptions.item (i).potential_attributes = "0"b;
      864 	     resource_descriptions.item (i).desired_attributes (*) = new -> parse_info.attr (*);
      865 	     resource_descriptions.item (i).owner = "";
      866 	     resource_descriptions.item (i).acs_path = "";
      867 	     resource_descriptions.item (i).aim_range (*) = "0"b;
      868 	     resource_descriptions.item (i).potential_aim_range (*) = "0"b;
      869 	     resource_descriptions.item (i).location = "";
      870 	     resource_descriptions.item (i).comment = "";
      871 	     resource_descriptions.item (i).charge_type = "";
      872 
      873 	     unspec (resource_descriptions.item (i).given) = "0"b;
      874 						/* Set everything off to start. */
      875 	     resource_descriptions.item (i).given.name = (resource_descriptions.item (i).name ^= "");
      876 	     resource_descriptions.item (i).given.uid = (resource_descriptions.item (i).uid ^= "0"b);
      877 
      878 	     if (resource_descriptions.item (i).desired_attributes (1)
      879 	     | resource_descriptions.item (i).desired_attributes (2)
      880 	     | resource_descriptions.item (i).desired_attributes (3)
      881 	     | resource_descriptions.item (i).desired_attributes (4)) = "0"b
      882 	     then resource_descriptions.item (i).given.desired_attributes = "0"b;
      883 	     else resource_descriptions.item (i).given.desired_attributes = "1"b;
      884 
      885 	     resource_descriptions.item (i).given.owner = (resource_descriptions.item (i).owner ^= "");
      886 
      887 	     if (resource_descriptions.item (i).aim_range (1) | resource_descriptions.item (i).aim_range (2)) = "0"b
      888 	     then resource_descriptions.item (i).given.aim_range = "0"b;
      889 	     else resource_descriptions.item (i).given.aim_range = "1"b;
      890 
      891 	     resource_descriptions.item (i).rew = "0"b;
      892 	     resource_descriptions.item (i).usage_lock = "0"b;
      893 	     resource_descriptions.item (i).release_lock = "0"b;
      894 	     resource_descriptions.item (i).awaiting_clear = "0"b;
      895 	     resource_descriptions.item (i).user_alloc = "0"b;
      896 	     resource_descriptions.item (i).pad2 = "0"b;
      897 	     resource_descriptions.item (i).state = "0"b;
      898 	     resource_descriptions.item (i).status_code = 0;
      899 
      900 	     reservation_description.reservation_group (i).starting_time = 0;
      901 	     reservation_description.reservation_group (i).duration = 0;
      902 
      903 	     if new -> parse_info.number = 1
      904 	     then new = new -> parse_info.next;
      905 	     else new -> parse_info.number = new -> parse_info.number - 1;
      906 	end;					/* Fill in variable parts. */
      907 
      908 	if check
      909 	then err_msg =
      910 	     "Warning: the old format resource description """ || ltrim (rtrim (desc_str))
      911 	     || """ should be converted to the new format.";
      912 
      913 	code = 0;
      914 	return;
      915 
      916 /* Error handling section */
      917 
      918 BAD_ERROR:
      919 	if new_code = 0
      920 	then do;
      921 	     if check
      922 	     then err_msg = "An error occurred in RCP, contact a systems programmer.";
      923 	end;
      924 
      925 	else do;
      926 	     code = new_code;
      927 	     if check 
      928 	        then err_msg = error_msg;
      929 	end;
      930 
      931 	call cleanup_handler;
      932 	return;
      933 
      934 BAD_DESC:
      935 	if new_code = 0
      936 	then do;
      937 	     code = error_table_$noarg;
      938 	     if check
      939 	     then err_msg = "At least one resource type must be given in the resource description.";
      940 	end;
      941 
      942 	else do;
      943 	     code = new_code;
      944 	     if check
      945 	        then err_msg = error_msg;
      946 	end;
      947 
      948 	call cleanup_handler;
      949 	return;
      950 
      951 BAD_NUMBER:
      952 	if new_code = 0
      953 	then do;
      954 	     code = error_table_$bad_conversion;
      955 	     if check
      956 	     then err_msg = "Invalid number: " || arg_string;
      957 	end;
      958 
      959 	else do;
      960 	     code = new_code;
      961 	     if check 
      962 	        then err_msg = error_msg;
      963 	end;
      964 
      965 	call cleanup_handler;
      966 	return;
      967 
      968 BAD_TYPE:
      969 	if new_code = 0
      970 	then do;
      971 	     code = error_table_$badcall;
      972 	     if check
      973 	        then err_msg = "The specified resource type is not valid: " || arg_string;
      974 	end;
      975 
      976 	else do;
      977 	     code = new_code;
      978 	     if check
      979 	        then err_msg = error_msg;
      980 	end;
      981 
      982 	call cleanup_handler;
      983 	return;
      984 
      985 BAD_DEFAULT:
      986 	if new_code = 0
      987 	then do;
      988 	     if check
      989 	        then err_msg = "An error occurred setting default attributes for " || new -> parse_info.rsc_type;
      990 	end;
      991 
      992 	else do;
      993 	     code = new_code;
      994 	     if check
      995 	        then err_msg = error_msg;
      996 	end;
      997 
      998 	call cleanup_handler;
      999 	return;
     1000 
     1001 BAD_NAME_ARG:
     1002 	if new_code = 0
     1003 	then do;
     1004 	     code = error_table_$noarg;
     1005 	     if check
     1006 	        then err_msg = "Name argument missing for resource type " || new -> parse_info.rsc_type;
     1007 	end;
     1008 
     1009 	else do;
     1010 	     code = new_code;
     1011 	     if check
     1012 	        then err_msg = error_msg;
     1013 	end;
     1014 
     1015 	call cleanup_handler;
     1016 	return;
     1017 
     1018 BAD_ATTR_ARG:
     1019 	if new_code = 0
     1020 	then do;
     1021 	     code = error_table_$noarg;
     1022 	     if check
     1023 	     then err_msg = "Attribute argument missing for resource type " || new -> parse_info.rsc_type;
     1024 	end;
     1025 
     1026 	else do;
     1027 	     code = new_code;
     1028 	     if check
     1029 	        then err_msg = error_msg;
     1030 	end;
     1031 
     1032 	call cleanup_handler;
     1033 	return;
     1034 
     1035 BAD_ATTR:
     1036 	if new_code = 0
     1037 	then do;
     1038 	     if check
     1039 	     then err_msg = "Error converting attribute string: " || arg_string;
     1040 	end;
     1041 
     1042 	else do;
     1043 	     code = new_code;
     1044 	     if check 
     1045 	        then err_msg = error_msg;
     1046 	end;
     1047 
     1048 	call cleanup_handler;
     1049 	return;
     1050 
     1051 BAD_NUM_ARG:
     1052 	if new_code = 0
     1053 	then do;
     1054 	     code = error_table_$noarg;
     1055 	     if check
     1056 	     then err_msg = "Number argument missing for resource type " || new -> parse_info.rsc_type;
     1057 	end;
     1058 
     1059 	else do;
     1060 	     code = new_code;
     1061 	     if check 
     1062 	        then err_msg = error_msg;
     1063 	end;
     1064 
     1065 	call cleanup_handler;
     1066 	return;
     1067 
     1068 BAD_VOL_NAME:
     1069 	if new_code = 0
     1070 	then do;
     1071 	     code = error_table_$noarg;
     1072 	     if check
     1073 	     then err_msg = "The volume name must be specified for resource type " || new -> parse_info.rsc_type;
     1074 	end;
     1075 
     1076 	else do;
     1077 	     code = new_code;
     1078 	     if check 
     1079 	        then err_msg = error_msg;
     1080 	end;
     1081 
     1082 	call cleanup_handler;
     1083 	return;
     1084 
     1085 BAD_AREA:
     1086 	if new_code = 0
     1087 	then do;
     1088 	     code = error_table_$badcall;
     1089 	     if check
     1090 	     then err_msg = "The specified area is not big enough to hold the necessary structures.";
     1091 	end;
     1092 
     1093 	else do;
     1094 	     code = new_code;
     1095 	     if check 
     1096 	        then err_msg = error_msg;
     1097 	end;
     1098 
     1099 	call cleanup_handler;
     1100 	return;
     1101 
     1102 get_next_arg:
     1103 	proc (in_string, position) returns (char (256) varying);
     1104 
     1105 /*
     1106*   This subroutine takes a character string as input and picks out the next
     1107*   argument delimited by blanks.  It returns the null string if there are no
     1108*   more arguments.
     1109**/
     1110 
     1111 /* Arguments */
     1112 
     1113 dcl  in_string char (*);				/* Input string. */
     1114 dcl  position fixed bin;				/* An index always left pointing just after the arg */
     1115 						/* returned in in_string. */
     1116 dcl  arg char (256) varying;
     1117 						/* The returned argument. */
     1118 
     1119 /* Local Variables */
     1120 
     1121 dcl  pos1 fixed bin;				/* Start of string. */
     1122 dcl  pos2 fixed bin;				/* End of string. */
     1123 
     1124 /* Builtin Functions and Conditions */
     1125 
     1126 dcl (substr, verify, search, length)
     1127      builtin;
     1128 
     1129 	     if position = length (in_string)
     1130 	     then do;				/* No more args left. */
     1131 		arg = "";
     1132 		return (arg);
     1133 	     end;					/* No more args left. */
     1134 
     1135 	     if position = 0
     1136 	     then position = 1;			/* Ready for use in substr. */
     1137 
     1138 	     pos1 = verify (substr (in_string, position), " ");
     1139 
     1140 	     if pos1 = 0
     1141 	     then do;				/* String is all blanks. */
     1142 		arg = "";
     1143 		position = length (in_string);
     1144 		return (arg);
     1145 	     end;					/* String is all blanks. */
     1146 
     1147 	     pos1 = pos1 + position - 1;		/* Get index in the whole string. */
     1148 	     pos2 = search (substr (in_string, pos1), " ");
     1149 
     1150 	     if pos2 = 0
     1151 	     then do;				/* Last arg in string. */
     1152 		arg = substr (in_string, pos1);
     1153 		position = length (in_string);
     1154 		return (arg);
     1155 	     end;					/* Last arg in string. */
     1156 
     1157 	     else do;				/* Some middle arg in the string. */
     1158 		pos2 = pos2 + pos1 - 1;		/* Get index in the whole string. */
     1159 		arg = substr (in_string, pos1, pos2 - pos1);
     1160 		position = pos2;
     1161 		return (arg);
     1162 	     end;					/* Some middle arg in the string. */
     1163 
     1164 	end get_next_arg;
     1165 
     1166 cleanup_handler:
     1167 	proc;
     1168 
     1169 	     if head ^= null | tail ^= null | new ^= null
     1170 	     then do;				/* Free the parse_info list. */
     1171 
     1172 		if tail ^= new
     1173 		then do;
     1174 		     if new ^= null
     1175 		     then free new -> parse_info;
     1176 		     if tail ^= null
     1177 		     then tail -> parse_info.next = null;
     1178 						/* Make sure the list ends. */
     1179 		end;
     1180 
     1181 		if head ^= null
     1182 		then do;				/* Free the list from head to tail. */
     1183 
     1184 		     do while (head ^= null);
     1185 			new = head -> parse_info.next;
     1186 			free head -> parse_info;
     1187 			head = new;
     1188 		     end;
     1189 		end;				/* Free the list from head to tail. */
     1190 	     end;					/* Free the parse_info list. */
     1191 
     1192 	     if area_ptr ^= null
     1193 	     then do;				/* Free the output structures. */
     1194 
     1195 		if resource_desc_ptr ^= null
     1196 		then do;
     1197 		     free resource_descriptions in (area_ptr -> based_area);
     1198 		     resource_desc_ptr = null;
     1199 		end;
     1200 
     1201 		if resource_res_ptr ^= null
     1202 		then do;
     1203 		     free reservation_description in (area_ptr -> based_area);
     1204 		     resource_res_ptr = null;
     1205 		end;
     1206 	     end;					/* Free the output structures. */
     1207 
     1208 	     call Cleanup_Handler ();
     1209 
     1210 	end cleanup_handler;
     1211      end parse_resource_desc_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/15/87  1548.7  parse_resource_desc_.pl1          >special_ldd>install>MR12.1-1040>parse_resource_desc_.pl1
83           1    02/13/79  1715.0  resource_control_desc.incl.pl1    >ldd>include>resource_control_desc.incl.pl1
85           2    03/27/86  1120.0  rcp_resource_types.incl.pl1       >ldd>include>rcp_resource_types.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
C_false                         000423 automatic       bit(1)                   initial unaligned dcl 469 set ref 469* 484 496 573
C_quote                         000424 automatic       char(1)                  initial unaligned dcl 470 set ref 470* 500 506 530
                                                                                  557 562
C_true                          000422 automatic       bit(1)                   initial unaligned dcl 468 set ref 468* 516 525 579
C_white_space                   000426 automatic       char(6)                  initial unaligned dcl 471 set ref 471* 489 502 570
DEVICE_TYPE                     000100 constant        char(32)                 initial array unaligned dcl 2-18 ref 279 279 293 293
DISK_DRIVE_DTYPEX                      constant        fixed bin(17,0)          initial dcl 2-30 ref 279 293
DISK_VOL_VTYPEX                        constant        fixed bin(17,0)          initial dcl 2-38 ref 279 293 318
P_inidx                                parameter       fixed bin(24,0)          dcl 423 set ref 420 480 489 489 491 493* 518* 581*
P_instr                                parameter       char                     unaligned dcl 423 ref 420 480 489 493 500 502 503
                                                                                  506 511 530 544 557 570
P_outidx                               parameter       fixed bin(24,0)          dcl 423 set ref 420 509 511 514 519* 519 523 577
                                                                                  582* 582
P_outstr                               parameter       char                     unaligned dcl 423 set ref 420 509 511* 542 544* 559
                                                                                  562*
P_texists                              parameter       bit(1)                   unaligned dcl 423 set ref 420 484* 496* 516* 579*
P_tidx                                 parameter       fixed bin(24,0)          dcl 423 set ref 420 482* 494* 514* 577*
P_tlen                                 parameter       fixed bin(24,0)          dcl 423 set ref 420 483* 495* 515* 578*
Resource_count                  000226 automatic       fixed bin(17,0)          dcl 1-78 set ref 271* 273 831* 835 835 836 836 842
                                                                                  853 859
TAPE_DRIVE_DTYPEX                      constant        fixed bin(17,0)          initial dcl 2-29 ref 279 293
TAPE_VOL_VTYPEX                        constant        fixed bin(17,0)          initial dcl 2-37 ref 279 293 318
VOLUME_TYPE                     000000 constant        char(32)                 initial array unaligned dcl 2-25 ref 279 279 293 293
                                                                                  318 318
acs_path                 61            based           char(168)                array level 3 dcl 1-6 set ref 866*
aidx                            000264 automatic       fixed bin(17,0)          dcl 168 set ref 237* 243*
aim_range                45            based           bit(72)                  array level 3 in structure "resource_descriptions"
                                                                                  dcl 1-6 in procedure "parse_resource_desc_" set
                                                                                  ref 867* 887 887
aim_range               270(05)        based           bit(1)                   array level 4 in structure "resource_descriptions"
                                                                                  packed unaligned dcl 1-6 in procedure
                                                                                  "parse_resource_desc_" set ref 887* 889*
area                            000244 stack reference condition                dcl 128 ref 190 193 201 230 833 837
area_ptr                               parameter       pointer                  dcl 46 set ref 26 133 133* 138 259* 606 610 616 824
                                                                                  835 836 1192 1197 1203
arg                             000436 automatic       varying char(256)        dcl 1116 set ref 1131* 1132 1142* 1144 1152* 1154
                                                                                  1159* 1161
arg_string                      000101 automatic       varying char(256)        dcl 54 set ref 627* 640* 642 645 649 658 673* 675
                                                                                  684 684 686* 688 691 692* 695 695 697* 699 702*
                                                                                  708* 710 710 712* 714 720 726* 731 731 733* 735
                                                                                  741 747* 749 749 760* 762 765* 771* 777 785 786*
                                                                                  795* 797 800 800 802* 804 807 810 813 815* 955 972
                                                                                  1038
asap                     30(01)        based           bit(1)                   level 3 packed unaligned dcl 1-55 set ref 850*
asap_duration            26            based           fixed bin(71,0)          level 2 dcl 1-55 set ref 848*
attr                     22            based           bit(72)                  array level 2 packed unaligned dcl 67 set ref 660*
                                                                                  677* 702* 751* 765* 864
auto_expire              30            based           bit(1)                   level 3 packed unaligned dcl 1-55 set ref 849*
awaiting_clear          267(05)        based           bit(1)                   array level 3 packed unaligned dcl 1-6 set ref 894*
based_area                             based           area(261129)             dcl 78 ref 610 616 835 836 1197 1203
build_resource_desc_$reserve    000022 constant        entry                    external dcl 98 ref 259
charge_type             257            based           char(32)                 array level 3 dcl 1-6 set ref 871*
check                           000100 automatic       bit(1)                   unaligned dcl 53 set ref 131* 152* 331 340 348 356
                                                                                  364 372 380 388 396 404 908 921 927 938 944 955
                                                                                  961 972 978 988 994 1005 1011 1022 1028 1038 1044
                                                                                  1055 1061 1072 1078 1089 1095
cleanup                         000230 stack reference condition                dcl 128 ref 186 287 334 343 351 359 367 375 383 391
                                                                                  399 407 417 637
code                                   parameter       fixed bin(35,0)          dcl 49 set ref 26 138 291* 292 333* 338* 346* 354*
                                                                                  362* 370* 378* 386* 394* 402* 625* 649* 651 677*
                                                                                  680 702* 705 751* 754 765* 768 777* 780 782 784*
                                                                                  826* 913* 926* 937* 943* 954* 960* 971* 977* 993*
                                                                                  1004* 1010* 1021* 1027* 1043* 1054* 1060* 1071*
                                                                                  1077* 1088* 1094*
comment                 205            based           char(168)                array level 3 dcl 1-6 set ref 870*
conversion                      000236 stack reference condition                dcl 128 ref 717 721 738 742
convert                                                builtin function         dcl 126 ref 720 741
count                           000203 automatic       fixed bin(17,0)          dcl 57 set ref 629* 818* 818 831
cur_pos                         000204 automatic       fixed bin(17,0)          dcl 58 set ref 630* 640* 673* 686* 692* 697* 708*
                                                                                  712* 726* 733* 747* 760* 771* 786* 795* 802* 815*
cv_rcp_attributes_$from_string_rel
                                000010 constant        entry                    external dcl 89 ref 677 702 751 765
desc_str                               parameter       char                     unaligned dcl 45 set ref 26 138 189 199* 223* 380
                                                                                  640* 673* 686* 692* 697* 708* 712* 726* 733* 747*
                                                                                  760* 771* 786* 795* 802* 815* 908
desired_attributes       31            based           bit(72)                  array level 3 in structure "resource_descriptions"
                                                                                  dcl 1-6 in procedure "parse_resource_desc_" set
                                                                                  ref 864* 878 878 878 878
desired_attributes      270(03)        based           bit(1)                   array level 4 in structure "resource_descriptions"
                                                                                  packed unaligned dcl 1-6 in procedure
                                                                                  "parse_resource_desc_" set ref 878* 883*
duration                 34            based           fixed bin(71,0)          array level 3 dcl 1-55 set ref 901*
err_msg                                parameter       varying char             dcl 149 set ref 138 151* 331* 340* 348* 356* 364*
                                                                                  372* 380* 388* 396* 404* 908* 921* 927* 938* 944*
                                                                                  955* 961* 972* 978* 988* 994* 1005* 1011* 1022*
                                                                                  1028* 1038* 1044* 1055* 1061* 1072* 1078* 1089*
                                                                                  1095*
error_msg                       000274 automatic       varying char(256)        dcl 175 set ref 259* 285* 927 944 961 978 994 1011
                                                                                  1028 1044 1061 1078 1095
error_table_$area_too_small     000050 external static fixed bin(35,0)          dcl 121 ref 402
error_table_$bad_conversion     000032 external static fixed bin(35,0)          dcl 108 ref 954
error_table_$bad_index          000034 external static fixed bin(35,0)          dcl 110 ref 370 386
error_table_$badcall            000024 external static fixed bin(35,0)          dcl 103 ref 971 1088
error_table_$badopt             000036 external static fixed bin(35,0)          dcl 112 ref 346
error_table_$inconsistent       000040 external static fixed bin(35,0)          dcl 113 ref 362
error_table_$name_not_found     000030 external static fixed bin(35,0)          dcl 106 ref 782
error_table_$noarg              000026 external static fixed bin(35,0)          dcl 105 ref 937 1004 1021 1054 1071
error_table_$resource_spec_ambiguous
                                000046 external static fixed bin(35,0)          dcl 119 ref 354 394
error_table_$resource_type_unknown
                                000044 external static fixed bin(35,0)          dcl 117 ref 338
error_table_$unbalanced_quotes  000042 external static fixed bin(35,0)          dcl 115 ref 378
flags                    30            based           structure                level 2 dcl 1-55
get_group_id_                   000020 constant        entry                    external dcl 97 ref 845 846
get_system_free_area_           000012 constant        entry                    external dcl 91 ref 133
given                   270            based           structure                array level 3 dcl 1-6 set ref 299 873*
group_starting_time      24            based           fixed bin(71,0)          level 2 dcl 1-55 set ref 847*
hbound                                                 builtin function         dcl 126 ref 237
head                            000222 automatic       pointer                  dcl 64 set ref 633* 663 663* 857 1169 1181 1184 1185
                                                                                  1186 1187*
i                               000205 automatic       fixed bin(17,0)          dcl 59 set ref 859* 860 861 862 863 864 865 866 867
                                                                                  868 869 870 871 873 875 875 876 876 878 878 878
                                                                                  878 878 883 885 885 887 887 887 889 891 892 893
                                                                                  894 895 896 897 898 900 901*
in_string                              parameter       char                     unaligned dcl 1113 ref 1102 1129 1138 1143 1148 1152
                                                                                  1153 1159
index                     2            based           fixed bin(24,0)          level 2 dcl 154 set ref 213* 243
inidx                           000255 automatic       fixed bin(24,0)          dcl 162 set ref 195* 199* 223* 380
item                      2            based           structure                array level 2 dcl 1-6
junk_bit                        000206 automatic       bit(1)                   unaligned dcl 60 set ref 777*
lbound                                                 builtin function         dcl 126 ref 237
length                                                 builtin function         dcl 477 in procedure "Get_Next_Token" ref 480 493
                                                                                  503 509 542 559
length                    3            based           fixed bin(24,0)          level 2 in structure "token" dcl 154 in procedure
                                                                                  "parse_resource_desc_" set ref 214* 243
length                                                 builtin function         dcl 1126 in procedure "get_next_arg" ref 1129 1143
                                                                                  1153
length                                                 builtin function         dcl 126 in procedure "parse_resource_desc_" ref 189
length_of_token                 000415 automatic       fixed bin(24,0)          dcl 459 set ref 488* 502* 503 503* 506 509 511 511
                                                                                  515 518 519 551* 551 566* 566 578 582
location                133            based           char(168)                array level 3 dcl 1-6 set ref 869*
ltrim                                                  builtin function         dcl 126 ref 908
max_token_length                000261 automatic       fixed bin(24,0)          dcl 165 set ref 180* 220 220* 226 243 243 243 259
                                                                                  259 329 591
more_string                     000421 automatic       bit(1)                   unaligned dcl 463 set ref 525* 527 573*
n_items                  31            based           fixed bin(17,0)          level 2 in structure "reservation_description"
                                                                                  dcl 1-55 in procedure "parse_resource_desc_" set
                                                                                  ref 616 836* 853* 1203
n_items                   1            based           fixed bin(17,0)          level 2 in structure "resource_descriptions" dcl 1-6
                                                                                  in procedure "parse_resource_desc_" set ref 271
                                                                                  610 835* 842* 1197
name                     12            based           char(32)                 array level 3 in structure "resource_descriptions"
                                                                                  dcl 1-6 in procedure "parse_resource_desc_" set
                                                                                  ref 279 279 279 279 861* 875
name                    270            based           bit(1)                   array level 4 in structure "resource_descriptions"
                                                                                  packed unaligned dcl 1-6 in procedure
                                                                                  "parse_resource_desc_" set ref 315 318 875*
new                             000220 automatic       pointer                  dcl 63 set ref 632* 656* 657 658 659 660 661 663 666
                                                                                  669 677 677 691 702 702 720 720 723 741 741 744
                                                                                  751 751 765 765 785 807 813 857* 860 861 864 903
                                                                                  903* 903 905 905 988 1005 1022 1055 1072 1169 1172
                                                                                  1174 1174 1185* 1187
new_code                        000375 automatic       fixed bin(35,0)          dcl 176 set ref 259* 261 284* 918 926 934 943 951
                                                                                  960 968 977 985 993 1001 1010 1018 1027 1035 1043
                                                                                  1051 1060 1068 1077 1085 1094
next                                   based           pointer                  level 2 in structure "token" dcl 154 in procedure
                                                                                  "parse_resource_desc_" set ref 215* 245 602
next                                   based           pointer                  level 2 in structure "parse_info" dcl 67
                                                                                  in procedure "parse_resource_desc_" set ref 657*
                                                                                  666* 903 1176* 1185
null                                                   builtin function         dcl 126 ref 133 181 182 183 184 240 259 259 259 259
                                                                                  269 591 594 597 600 606 608 611 614 617 622 624
                                                                                  632 633 634 657 663 666 824 1169 1169 1169 1174
                                                                                  1176 1176 1181 1184 1192 1195 1198 1201 1204
num_of_tokens                   000260 automatic       fixed bin(17,0)          dcl 164 set ref 179* 218* 218 226 226 237 259 329
                                                                                  591
number                   32            based           fixed bin(17,0)          level 2 dcl 67 set ref 661* 720* 720 723 741* 741
                                                                                  744 818 903 905* 905
outidx                          000254 automatic       fixed bin(24,0)          dcl 161 in procedure "parse_resource_desc_" set ref
                                                                                  196* 199* 223*
outidx                          000420 automatic       fixed bin(24,0)          dcl 462 in procedure "Get_Next_Token" set ref 523*
                                                                                  542 544 547* 547 559 562 564* 564
owner                    51            based           char(32)                 array level 3 in structure "resource_descriptions"
                                                                                  dcl 1-6 in procedure "parse_resource_desc_" set
                                                                                  ref 865* 885
owner                   270(06)        based           bit(1)                   array level 4 in structure "resource_descriptions"
                                                                                  packed unaligned dcl 1-6 in procedure
                                                                                  "parse_resource_desc_" set ref 885*
pad2                    267(07)        based           bit(29)                  array level 3 packed unaligned dcl 1-6 set ref 896*
parse_info                             based           structure                level 1 unaligned dcl 67 set ref 656 1174 1186
pos1                            000537 automatic       fixed bin(17,0)          dcl 1121 set ref 1138* 1140 1147* 1147 1148 1152
                                                                                  1158 1159 1159
pos2                            000540 automatic       fixed bin(17,0)          dcl 1122 set ref 1148* 1150 1158* 1158 1159 1160
position                               parameter       fixed bin(17,0)          dcl 1114 set ref 1102 1129 1135 1135* 1138 1143*
                                                                                  1147 1153* 1160*
potential_aim_range      41            based           bit(72)                  array level 3 dcl 1-6 set ref 868*
potential_attributes     23            based           bit(72)                  array level 3 dcl 1-6 set ref 863*
rel                      30(02)        based           bit(1)                   level 3 packed unaligned dcl 1-55 set ref 851*
release_lock            267(04)        based           bit(1)                   array level 3 packed unaligned dcl 1-6 set ref 893*
reservation_description                based           structure                level 1 dcl 1-55 set ref 616 836 1203
reservation_group        32            based           structure                array level 2 dcl 1-55
reserved_by              11            based           char(32)                 level 2 dcl 1-55 set ref 846*
reserved_for              1            based           char(32)                 level 2 dcl 1-55 set ref 845*
resource_desc_ptr                      parameter       pointer                  dcl 1-72 set ref 26 138 259* 269 271 279 279 279 279
                                                                                  291 299 315 315 318 318 318 340 608 610 611* 622*
                                                                                  835* 841 842 860 861 862 863 864 865 866 867 868
                                                                                  869 870 871 873 875 875 876 876 878 878 878 878
                                                                                  878 883 885 885 887 887 887 889 891 892 893 894
                                                                                  895 896 897 898 1195 1197 1198*
resource_desc_version_1                constant        fixed bin(17,0)          initial dcl 1-75 ref 841
resource_descriptions                  based           structure                level 1 dcl 1-6 set ref 610 835 1197
resource_info_$get_primary_type 000014 constant        entry                    external dcl 93 ref 291
resource_info_$get_type         000016 constant        entry                    external dcl 95 ref 649 777
resource_res_ptr                       parameter       pointer                  dcl 1-72 set ref 26 138 259* 614 616 617* 624* 836*
                                                                                  844 845 846 847 848 849 850 851 852 853 900 901
                                                                                  1201 1203 1204*
resource_res_version_1                 constant        fixed bin(17,0)          initial dcl 1-75 ref 844
rew                     267            based           bit(3)                   array level 3 packed unaligned dcl 1-6 set ref 891*
ridx                            000376 automatic       fixed bin(17,0)          dcl 177 set ref 273* 279 279 279 279 291 299 315 315
                                                                                  318 318 318* 340
rsc_name                 12            based           char(32)                 level 2 packed unaligned dcl 67 set ref 659* 691*
                                                                                  785* 807* 813* 861
rsc_type                        000207 automatic       char(32)                 unaligned dcl 61 in procedure "parse_resource_desc_"
                                                                                  set ref 291* 293 293 293 293
rsc_type                  2            based           char(32)                 level 2 in structure "parse_info" packed unaligned
                                                                                  dcl 67 in procedure "parse_resource_desc_" set ref
                                                                                  658* 677* 702* 751* 765* 860 988 1005 1022 1055
                                                                                  1072
rtrim                                                  builtin function         dcl 126 ref 908
search                                                 builtin function         dcl 1126 in procedure "get_next_arg" ref 1148
search                                                 builtin function         dcl 477 in procedure "Get_Next_Token" ref 502 506
                                                                                  530
sec                      30(03)        based           bit(1)                   level 3 packed unaligned dcl 1-55 set ref 852*
start_of_token                  000414 automatic       fixed bin(24,0)          dcl 458 set ref 489* 491 500 502 503 506 511 518 524
starting_time            32            based           fixed bin(71,0)          array level 3 dcl 1-55 set ref 900*
state                   271            based           bit(36)                  array level 3 dcl 1-6 set ref 897*
status_code             272            based           fixed bin(35,0)          array level 3 dcl 1-6 set ref 315 898*
string_length                   000270 automatic       fixed bin(24,0)          dcl 171 set ref 189* 192 192 197 199 199 223 223 243
                                                                                  249 249 594 594
substr                                                 builtin function         dcl 126 in procedure "parse_resource_desc_" ref 243
                                                                                  380 810
substr                                                 builtin function         dcl 1126 in procedure "get_next_arg" ref 1138 1148
                                                                                  1152 1159
substr                                                 builtin function         dcl 477 in procedure "Get_Next_Token" set ref 489
                                                                                  500 502 503 506 511* 511 530 544* 544 557 562* 570
subtoken_idx                    000417 automatic       fixed bin(24,0)          dcl 461 set ref 524* 528* 528 530 544 554* 554 557
                                                                                  570 581
subtoken_len                    000416 automatic       fixed bin(24,0)          dcl 460 set ref 530* 532 540 542 544 544 547 551 554
tail                            000224 automatic       pointer                  dcl 65 set ref 634* 666 666 669* 818 1169 1172 1176
                                                                                  1176
tap                             000262 automatic       pointer                  dcl 167 set ref 182* 226* 237 237 243 259 329 591
                                                                                  591
token                                  based           structure                level 1 dcl 154 set ref 211 246 597 603
token_array                            based           varying char             array dcl 166 set ref 226 237 237 243* 259* 329 591
token_exists                    000273 automatic       bit(1)                   unaligned dcl 174 set ref 199* 209 223*
token_head_ptr                  000256 automatic       pointer                  dcl 163 set ref 181* 215 217* 239 245* 597 600 601
                                                                                  602*
token_index                     000271 automatic       fixed bin(24,0)          dcl 172 set ref 199* 213 223*
token_length                    000272 automatic       fixed bin(24,0)          dcl 173 set ref 199* 214 220 220 223*
token_string                           based           char                     unaligned dcl 169 set ref 192 197* 199* 223* 243 249
                                                                                  594
tp                              000252 automatic       pointer                  dcl 160 set ref 184* 211* 213 214 215 217 239* 240
                                                                                  243 243 245 246 597 597 597 601* 602 603
tsp                             000266 automatic       pointer                  dcl 170 set ref 183* 192* 197 199 223 243 249 594
                                                                                  594
type                      2            based           char(32)                 array level 3 dcl 1-6 set ref 291 318 318 340 860*
uid                     270(01)        based           bit(1)                   array level 4 in structure "resource_descriptions"
                                                                                  packed unaligned dcl 1-6 in procedure
                                                                                  "parse_resource_desc_" set ref 876*
uid                      22            based           bit(36)                  array level 3 in structure "resource_descriptions"
                                                                                  dcl 1-6 in procedure "parse_resource_desc_" set
                                                                                  ref 862* 876
unspec                                                 builtin function         dcl 126 set ref 299 873*
usage_lock              267(03)        based           bit(1)                   array level 3 packed unaligned dcl 1-6 set ref 892*
user_alloc              267(06)        based           bit(1)                   array level 3 packed unaligned dcl 1-6 set ref 895*
verify                                                 builtin function         dcl 477 in procedure "Get_Next_Token" ref 489 570
verify                                                 builtin function         dcl 1126 in procedure "get_next_arg" ref 1138
version_no                             based           fixed bin(17,0)          level 2 in structure "reservation_description"
                                                                                  dcl 1-55 in procedure "parse_resource_desc_" set
                                                                                  ref 844*
version_no                             based           fixed bin(17,0)          level 2 in structure "resource_descriptions" dcl 1-6
                                                                                  in procedure "parse_resource_desc_" set ref 841*
volume                          000202 automatic       bit(1)                   unaligned dcl 56 set ref 628* 649* 671

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
CONSOLE_DTYPEX                         internal static fixed bin(17,0)          initial dcl 2-31
MCA_DTYPEX                             internal static fixed bin(17,0)          initial dcl 2-36
NUM_QUALIFIERS                         internal static fixed bin(17,0)          initial array dcl 2-22
PRINTER_DTYPEX                         internal static fixed bin(17,0)          initial dcl 2-32
PUNCH_DTYPEX                           internal static fixed bin(17,0)          initial dcl 2-33
READER_DTYPEX                          internal static fixed bin(17,0)          initial dcl 2-34
SPECIAL_DTYPEX                         internal static fixed bin(17,0)          initial dcl 2-35

NAMES DECLARED BY EXPLICIT CONTEXT.
BAD_AREA                        005101 constant        label                    dcl 1085 ref 833
BAD_ATTR                        004674 constant        label                    dcl 1035 ref 705 768
BAD_ATTR_ARG                    004617 constant        label                    dcl 1018 ref 699 762
BAD_DEFAULT                     004470 constant        label                    dcl 985 ref 680 754
BAD_DESC                        004270 constant        label                    dcl 934 ref 642
BAD_ERROR                       004227 constant        label                    dcl 918 ref 782
BAD_NAME_ARG                    004542 constant        label                    dcl 1001 ref 688 804
BAD_NUMBER                      004334 constant        label                    dcl 951 ref 717 723 738 744
BAD_NUM_ARG                     004747 constant        label                    dcl 1051 ref 714 735
BAD_TYPE                        004412 constant        label                    dcl 968 ref 651
BAD_VOL_NAME                    005024 constant        label                    dcl 1068 ref 797 810
Cleanup_Handler                 005464 constant        entry                    internal dcl 588 ref 186 286 342 350 358 366 374 382
                                                                                  390 398 406 410 1208
ERROR_area                      002112 constant        label                    dcl 402 set ref 190 201
ERROR_carg                      001647 constant        label                    dcl 346 set ref 299
ERROR_internal                  002040 constant        label                    dcl 386 ref 240
ERROR_nmattr                    001717 constant        label                    dcl 362 ref 315
ERROR_noquote                   001770 constant        label                    dcl 378 ref 506 532 570
ERROR_noroom                    001743 constant        label                    dcl 370 ref 509 542 559
ERROR_notype                    002065 constant        label                    dcl 394 ref 226
ERROR_rdesc                     002137 constant        label                    dcl 410 set ref 261
ERROR_type                      001614 constant        label                    dcl 338 ref 292 293
ERROR_volnm                     001673 constant        label                    dcl 354 ref 318
Get_Next_Token                  005145 constant        entry                    internal dcl 420 ref 199 223
OLD_DESCRIPTION_PARSER          002145 constant        label                    dcl 622 ref 288 418
START                           000744 constant        label                    dcl 154 ref 136
check                           000714 constant        entry                    external dcl 138
cleanup_handler                 005771 constant        entry                    internal dcl 1166 ref 637 827 931 948 965 982 998
                                                                                  1015 1032 1048 1065 1082 1099
get_next_arg                    005613 constant        entry                    internal dcl 1102 ref 640 673 686 692 697 708 712
                                                                                  726 733 747 760 771 786 795 802 815
parse_resource_desc_            000654 constant        entry                    external dcl 26

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6674        6746    6340        6704
Length      7242    6340        52         257     333           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
parse_resource_desc_                597 external procedure  is an external procedure.  
on unit on line 186                  64 on unit               
on unit on line 190                  64 on unit               
on unit on line 201                  64 on unit               
Get_Next_Token                          internal procedure  shares stack frame of external procedure parse_resource_desc_.  
Cleanup_Handler                      64 internal procedure  is called by several nonquick procedures.  
on unit on line 637                  64 on unit               
on unit on line 717                  64 on unit               
on unit on line 738                  64 on unit               
on unit on line 833                  64 on unit               
get_next_arg                            internal procedure  shares stack frame of external procedure parse_resource_desc_.  
cleanup_handler                      64 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
parse_resource_desc_     000100 check                       parse_resource_desc_
                         000101 arg_string                  parse_resource_desc_
                         000202 volume                      parse_resource_desc_
                         000203 count                       parse_resource_desc_
                         000204 cur_pos                     parse_resource_desc_
                         000205 i                           parse_resource_desc_
                         000206 junk_bit                    parse_resource_desc_
                         000207 rsc_type                    parse_resource_desc_
                         000220 new                         parse_resource_desc_
                         000222 head                        parse_resource_desc_
                         000224 tail                        parse_resource_desc_
                         000226 Resource_count              parse_resource_desc_
                         000252 tp                          parse_resource_desc_
                         000254 outidx                      parse_resource_desc_
                         000255 inidx                       parse_resource_desc_
                         000256 token_head_ptr              parse_resource_desc_
                         000260 num_of_tokens               parse_resource_desc_
                         000261 max_token_length            parse_resource_desc_
                         000262 tap                         parse_resource_desc_
                         000264 aidx                        parse_resource_desc_
                         000266 tsp                         parse_resource_desc_
                         000270 string_length               parse_resource_desc_
                         000271 token_index                 parse_resource_desc_
                         000272 token_length                parse_resource_desc_
                         000273 token_exists                parse_resource_desc_
                         000274 error_msg                   parse_resource_desc_
                         000375 new_code                    parse_resource_desc_
                         000376 ridx                        parse_resource_desc_
                         000414 start_of_token              Get_Next_Token
                         000415 length_of_token             Get_Next_Token
                         000416 subtoken_len                Get_Next_Token
                         000417 subtoken_idx                Get_Next_Token
                         000420 outidx                      Get_Next_Token
                         000421 more_string                 Get_Next_Token
                         000422 C_true                      Get_Next_Token
                         000423 C_false                     Get_Next_Token
                         000424 C_quote                     Get_Next_Token
                         000426 C_white_space               Get_Next_Token
                         000436 arg                         get_next_arg
                         000537 pos1                        get_next_arg
                         000540 pos2                        get_next_arg

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this
call_int_other      return_mac          tra_ext_1           enable_op           shorten_stack       ext_entry_desc
int_entry           verify_eis          search_eis          any_to_any_truncate_op_alloc_           alloc_storage
op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
build_resource_desc_$reserve  cv_rcp_attributes_$from_string_rel                          get_group_id_
get_system_free_area_         resource_info_$get_primary_type                             resource_info_$get_type

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$area_too_small   error_table_$bad_conversion   error_table_$bad_index        error_table_$badcall
error_table_$badopt           error_table_$inconsistent     error_table_$name_not_found   error_table_$noarg
error_table_$resource_spec_ambiguous                        error_table_$resource_type_unknown
error_table_$unbalanced_quotes




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     26 000647       131 000672       133 000673       136 000705       138 000706       151 000737       152 000742
    179 000744       180 000745       181 000746       182 000750       183 000751       184 000752       186 000753
    189 000775       190 001003       192 001022       193 001030       195 001031       196 001033       197 001034
    199 001040       201 001102       209 001121       211 001125       213 001131       214 001133       215 001135
    217 001137       218 001140       220 001141       223 001144       224 001206       226 001207       230 001221
    237 001222       239 001227       240 001231       243 001235       245 001263       246 001265       247 001267
    249 001272       259 001277       261 001361       269 001363       271 001370       273 001374       279 001403
    284 001442       285 001443       286 001444       287 001450       288 001451       291 001452       292 001477
    293 001501       299 001534       315 001545       318 001555       322 001573       329 001575       331 001604
    333 001611       334 001612       336 001613       338 001614       340 001617       342 001641       343 001645
    344 001646       346 001647       348 001652       350 001665       351 001671       352 001672       354 001673
    356 001676       358 001711       359 001715       360 001716       362 001717       364 001722       366 001735
    367 001741       368 001742       370 001743       372 001746       374 001762       375 001766       376 001767
    378 001770       380 001773       382 002031       383 002036       384 002037       386 002040       388 002043
    390 002057       391 002063       392 002064       394 002065       396 002070       398 002104       399 002110
    400 002111       402 002112       404 002115       406 002131       407 002135       408 002136       410 002137
    417 002143       418 002144       622 002145       624 002150       625 002151       627 002152       628 002153
    629 002154       630 002155       632 002156       633 002157       634 002160       637 002161       640 002203
    642 002225       645 002232       649 002237       651 002270       656 002273       657 002277       658 002301
    659 002305       660 002310       661 002325       663 002327       666 002334       669 002341       671 002342
    673 002345       675 002367       677 002374       680 002423       682 002425       684 002426       686 002440
    688 002462       691 002467       692 002474       693 002516       695 002517       697 002531       699 002553
    702 002560       705 002606       708 002610       710 002632       712 002644       714 002666       717 002673
    720 002712       721 002723       723 002724       726 002727       729 002751       731 002752       733 002764
    735 003006       738 003013       741 003032       742 003043       744 003044       747 003047       749 003071
    751 003103       754 003132       757 003134       760 003135       762 003157       765 003164       768 003212
    771 003214       773 003236       777 003237       780 003270       782 003273       784 003276       785 003277
    786 003304       792 003326       795 003327       797 003351       800 003356       802 003370       804 003412
    807 003417       808 003424       810 003425       813 003431       815 003436       818 003460       820 003463
    824 003464       826 003471       827 003472       828 003476       831 003477       833 003501       835 003520
    836 003534       837 003550       841 003551       842 003554       844 003557       845 003561       846 003576
    847 003613       848 003615       849 003616       850 003620       851 003622       852 003624       853 003626
    857 003630       859 003632       860 003641       861 003652       862 003656       863 003657       864 003663
    865 003712       866 003721       867 003725       868 003751       869 003775       870 004004       871 004010
    873 004014       875 004015       876 004025       878 004033       883 004050       885 004052       887 004063
    889 004074       891 004076       892 004100       893 004102       894 004104       895 004106       896 004110
    897 004112       898 004113       900 004114       901 004123       903 004124       905 004133       906 004135
    908 004137       913 004224       914 004226       918 004227       921 004231       923 004245       926 004246
    927 004247       931 004263       932 004267       934 004270       937 004272       938 004275       940 004311
    943 004312       944 004313       948 004327       949 004333       951 004334       954 004336       955 004341
    957 004366       960 004370       961 004371       965 004405       966 004411       968 004412       971 004414
    972 004417       974 004444       977 004446       978 004447       982 004463       983 004467       985 004470
    988 004472       990 004516       993 004520       994 004521       998 004535       999 004541      1001 004542
   1004 004544      1005 004547      1007 004573      1010 004575      1011 004576      1015 004612      1016 004616
   1018 004617      1021 004621      1022 004624      1024 004650      1027 004652      1028 004653      1032 004667
   1033 004673      1035 004674      1038 004676      1040 004723      1043 004725      1044 004726      1048 004742
   1049 004746      1051 004747      1054 004751      1055 004754      1057 005000      1060 005002      1061 005003
   1065 005017      1066 005023      1068 005024      1071 005026      1072 005031      1074 005055      1077 005057
   1078 005060      1082 005074      1083 005100      1085 005101      1088 005103      1089 005106      1091 005122
   1094 005123      1095 005124      1099 005140      1100 005144       420 005145       468 005163       469 005165
    470 005166       471 005170       480 005172       482 005177       483 005200       484 005201       485 005205
    488 005206       489 005207       491 005227       493 005231       494 005234       495 005235       496 005236
    497 005242       500 005243       502 005247       503 005263       506 005270       509 005300       511 005305
    514 005313       515 005315       516 005317       518 005323       519 005325       520 005327       523 005330
    524 005332       525 005334       527 005336       528 005340       530 005341       532 005361       540 005363
    542 005365       544 005371       547 005403       551 005405       554 005406       557 005411       559 005417
    562 005422       564 005427       566 005430       568 005431       570 005432       573 005442       575 005444
    577 005445       578 005450       579 005452       581 005456       582 005460       586 005462       588 005463
    591 005471       594 005505       597 005517       600 005532       601 005537       602 005541       603 005544
    604 005546       606 005547       608 005554       610 005560       611 005567       614 005573       616 005577
    617 005606       620 005612      1102 005613      1129 005624      1131 005627      1132 005630      1135 005637
   1138 005643      1140 005664      1142 005665      1143 005666      1144 005670      1147 005677      1148 005702
   1150 005722      1152 005723      1153 005733      1154 005735      1158 005744      1159 005747      1160 005757
   1161 005761      1166 005770      1169 005776      1172 006013      1174 006017      1176 006025      1181 006034
   1184 006040      1185 006045      1186 006050      1187 006052      1188 006056      1192 006057      1195 006064
   1197 006070      1198 006077      1201 006103      1203 006107      1204 006116      1208 006122      1210 006127


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
