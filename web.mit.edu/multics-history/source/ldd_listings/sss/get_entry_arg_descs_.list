	COMPILATION LISTING OF SEGMENT get_entry_arg_descs_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/20/86  1203.6 mst Thu
	    Options: optimize list

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 
       11 
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(84-11-29,Ranzenbach), approve(86-03-12,MCR7144),
       15*     audit(86-03-12,GWMay), install(86-05-01,MR12.0-1051):
       16*     added version 2 entry_desc_info, allowing the processing of
       17*     archive components.
       18*                                                   END HISTORY COMMENTS */
       19 
       20 
       21 get_entry_arg_descs_$info:
       22 	proc (entry_ptr, nargs, descps, entry_desc_info_ptr, code);
       23 
       24  	ret_info = "1"b;
       25 	if entry_desc_info.version ^= entry_desc_info_version_1 &
       26 	   entry_desc_info.version ^= entry_desc_info_version_2  then do;
       27 	     code = error_table_$unimplemented_version;
       28 	     return;
       29 	     end;
       30 	entry_desc_info.flags = "0"b;
       31 	
       32 	
       33 get_entry_arg_descs_:
       34 	entry (entry_ptr, nargs, descps, code);
       35 
       36 /* GET_ENTRY_ARG_DESCS_ - Extract descriptors for procedure parameters.
       37*
       38*   If entry_ptr points to an entry sequence or to a segdef, this procedure will
       39*   attempt to extract a list of pointers to parameter descriptors for the entrypoint.
       40*   The expected number of arguments and pointers to descriptors for the arguments will be returned.
       41*   This only works for standard object segments.
       42*
       43*   based on "get_entry_name_" by Melanie Weaver
       44*   THVV 1/74
       45*   modified 75-08-04 by M. Weaver to handle descriptor pointers in text
       46*   modified 79-05-09 by J. Falksen and G. Dixon to add the two "info" entries
       47*   */
       48 
       49 dcl  entry_ptr ptr;					/* ptr to entry sequence (input)		*/
       50 dcl  nargs fixed bin;				/* Number of arguments.			*/
       51 dcl  descps (*) ptr;				/* array of ptrs to descriptors.		*/
       52 dcl  code fixed bin (35);				/* status code (output)			*/
       53 	
       54 dcl (addwordno, addr, addrel, bin, min, null, ptr, rel, hbound, size) builtin;
       55 
       56 dcl (i, j) fixed bin;
       57 dcl  type fixed bin (2);
       58 dcl  mode fixed bin (5);
       59 dcl  bitcnt fixed bin (24);
       60 dcl  no_descrs bit(1);
       61 dcl  ret_info bit(1) init("0"b);			/* Off by default.  Turned on for $info entries.	*/
       62 	
       63 dcl (error_table_$nodescr,
       64      error_table_$moderr,
       65      error_table_$dirseg,
       66      error_table_$unimplemented_version) fixed bin (35) ext;
       67 
       68 dcl (segptr, np, defp, def_ptr, txp,  descpp) ptr;
       69 
       70 dcl  hcs_$status_mins entry (ptr, fixed bin (2), fixed bin (24), fixed bin (35));
       71 dcl  hcs_$fs_get_mode entry (ptr, fixed bin (5), fixed bin (35));
       72 dcl  object_info_$display ext entry (ptr, fixed bin (24), ptr, fixed bin (35));
       73 dcl  component_info_$offset ext entry (ptr, fixed bin (18), ptr, fixed bin (35));
       74 dcl  condition_ entry (char (*), entry);
       75 
       76 dcl  entry_desc_info_version_1	fixed bin int static options(constant) init(1);
       77 
  1     1 /* BEGIN INCLUDE FILE ... entry_sequence_info.incl.pl1 */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(86-04-16,GWMay), approve(86-04-16,MCR7373),
  1     7*     audit(86-04-29,LJAdams), install(86-05-01,MR12.0-1051):
  1     8*     reformatted.
  1     9*                                                   END HISTORY COMMENTS */
  1    10 
  1    11 
  1    12 /* coded 5/75 by M. Weaver */
  1    13 /* changed 5/79 by G. Dixon to include entry_desc_info */
  1    14 
  1    15        dcl  1 parm_desc_ptrs		aligned based,
  1    16 	    2 n_args		fixed bin(18) unsigned unaligned,
  1    17 	    2 descriptor_relp (num_descs refer(parm_desc_ptrs.n_args))
  1    18 				bit(18) unaligned;
  1    19 
  1    20        dcl  num_descs		fixed bin(18);
  1    21 
  1    22        dcl  1 entry_sequence		aligned based,
  1    23 	  2 word1,
  1    24 	    3 descr_relp_offset	bit(18) unaligned,	/* offset of parm_desc_ptrs structure */
  1    25 	    3 reserved		bit(18) unaligned,
  1    26 	  2 word2,		
  1    27 	    3 def_relp		bit(18) unaligned,  /* offset of entry's definition       */
  1    28 	    3 flags		unaligned like entry_desc_info.flags,
  1    29 	  2 code_sequence		bit(36) aligned;
  1    30 
  2     1 /* START OF:	entry_desc_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 	
  2     4 
  2     5 /****^  HISTORY COMMENTS:
  2     6*  1) change(84-11-29,Ranzenbach), approve(86-03-12,MCR7144),
  2     7*     audit(86-03-12,GWMay), install(86-05-01,MR12.0-1051):
  2     8*     for version 2. This version allows the caller to specify a pointer to
  2     9*     the beginning of the offset and its bit count. This allows the
  2    10*     processing of archive components.
  2    11*     
  2    12*     NOTICE:
  2    13*        All applications which use this structure should be converted to
  2    14*        use version 2.  Version 1 can be retained by setting the version to
  2    15*        a value of 1. The constant entry_desc_info_version_1 has been
  2    16*        removed from the file.
  2    17*                                                   END HISTORY COMMENTS */
  2    18 
  2    19 
  2    20 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    21 	/* 									*/
  2    22 	/* Name:  entry_desc_info.incl.pl1						*/
  2    23 	/* 									*/
  2    24 	/* This include file is used by get_entry_arg_desc_$info, $text_only_info and their	*/
  2    25 	/* callers.  It declares the flag bits obtained from the entry sequence of a procedure	*/
  2    26 	/* entry point.								*/
  2    27 	/* 									*/
  2    28 	/* Status									*/
  2    29 	/* 									*/
  2    30 	/* 0)  Created in May, 1979  by  G. C. Dixon					*/
  2    31 	/*									*/
  2    32 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    33 
  2    34      dcl	1 entry_desc_info		aligned based(entry_desc_info_ptr),
  2    35 	  2 version		fixed bin,	/* version number of this structure (= 2)	*/
  2    36 	  2 flags,
  2    37 
  2    38 	   (3 basic_indicator,			/* on if this is a BASIC program.		*/
  2    39 	    3 revision_1,				/* on if program entry has stuff added after 5/75 */
  2    40 	    3 has_descriptors,			/* on if entry point had valid parm. descriptors	*/
  2    41 	    3 variable,				/* on if entry point takes undefined no. of args	*/
  2    42 	    3 function)				/* on if entry point is a function		*/
  2    43 				bit(1) unaligned,
  2    44 	    3 pad			bit(13) unaligned,
  2    45 				                    /* version 2 fields follow                        */
  2    46 	  2 object_ptr		ptr,		/* -> beginning of object segment... (INPUT)	*/
  2    47 	  2 bit_count		fixed bin (24);	/* bit count of object... (INPUT)		*/
  2    48 
  2    49      dcl	entry_desc_info_version_2	fixed bin int static options(constant) init(2),
  2    50 	entry_desc_info_ptr		ptr;
  2    51 
  2    52 /* END OF:	entry_desc_info.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1    31 
  1    32 	
  1    33 /* END INCLUDE FILE ... entry_sequence_info.incl.pl1 */
       78 
       79 
       80 dcl 1 entry_sequence_w2 aligned like entry_sequence.word2 based (entry_sequence_w2p);
       81 dcl entry_sequence_w2p ptr;
       82 
       83 /* declaration of non class 3 definition (new format) in definition.incl.pl1 */
  3     1 /* BEGIN INCLUDE FILE definition.incl.pl1 */
  3     2 
  3     3 
  3     4 
  3     5 /****^  HISTORY COMMENTS:
  3     6*  1) change(86-05-02,Elhard), approve(86-05-02,MCR7391),
  3     7*     audit(86-07-18,DGHowe), install(86-11-20,MR12.0-1222):
  3     8*     Modified to add indirect bit to definition flags.
  3     9*                                                   END HISTORY COMMENTS */
  3    10 
  3    11 
  3    12 dcl	1 definition	aligned based,
  3    13 	2 forward		unal bit(18),	/* offset of next def */
  3    14 	2 backward	unal bit(18),	/* offset of previous def */
  3    15 	2 value		unal bit(18),
  3    16 	2 flags		unal,
  3    17 	  3 new		bit(1),
  3    18 	  3 ignore	bit(1),
  3    19 	  3 entry		bit(1),
  3    20 	  3 retain	bit(1),
  3    21 	  3 argcount	bit(1),
  3    22 	  3 descriptors	bit(1),
  3    23 	  3 indirect	bit(1),
  3    24 	  3 unused	bit(8),
  3    25 	2 class		unal bit(3),
  3    26 	2 symbol		unal bit(18),	/* offset of ACC for symbol */
  3    27 	2 segname		unal bit(18);	/* offset of segname def */
  3    28 
  3    29 /* END INCLUDE FILE definition.incl.pl1 */
       84 
       85 
       86 dcl 1 oi aligned like  object_info;
       87 
  4     1 /* BEGIN INCLUDE FILE ... object_info.incl.pl1
  4     2*coded February 8, 1972 by Michael J. Spier	*/
  4     3 /* modified May 26, 1972 by M. Weaver */
  4     4 /* modified 15 April, 1975 by M. Weaver */
  4     5 
  4     6 declare	1 object_info aligned based,		/* structure containing object info based, returned by object_info_ */
  4     7 	2 version_number fixed bin,		/* version number of current structure format (=2) */
  4     8 	2 textp pointer,			/* pointer to beginning of text section */
  4     9 	2 defp pointer,			/* pointer to beginning of definition section */
  4    10 	2 linkp pointer,			/* pointer to beginning of linkage section */
  4    11 	2 statp pointer,			/* pointer to beginning of static section */
  4    12 	2 symbp pointer,			/* pointer to beginning of symbol section */
  4    13 	2 bmapp pointer,			/* pointer to beginning of break map (may be null) */
  4    14 	2 tlng fixed bin,			/* length in words of text section */
  4    15 	2 dlng fixed bin,			/* length in words of definition section */
  4    16 	2 llng fixed bin,			/* length in words of linkage section */
  4    17 	2 ilng fixed bin,			/* length in words of static section */
  4    18 	2 slng fixed bin,			/* length in words of symbol section */
  4    19 	2 blng fixed bin,			/* length in words of break map */
  4    20 	2 format,				/* word containing bit flags about object type */
  4    21 	  3 old_format bit(1) unaligned,	/* on if segment isn't in new format, i.e. has old style object map */
  4    22 	  3 bound bit(1) unaligned,		/* on if segment is bound */
  4    23 	  3 relocatable bit(1) unaligned,	/* on if seg has relocation info in its first symbol block */
  4    24 	  3 procedure bit(1) unaligned,	/* on if segment is an executable object program */
  4    25 	  3 standard bit(1) unaligned,	/* on if seg is in standard format (more than just standard map) */
  4    26 	  3 gate bit(1) unaligned,		/* on if segment is a gate */
  4    27 	  3 separate_static bit(1) unaligned,	/* on if static not in linkage */
  4    28 	  3 links_in_text bit(1) unaligned,	/* on if there are threaded links in text */
  4    29 	  3 perprocess_static bit (1) unaligned, /* on if static is not to be per run unit */
  4    30 	  3 pad bit(27) unaligned,
  4    31 	2 entry_bound fixed bin,		/* entry bound if segment is a gate */
  4    32 	2 textlinkp pointer,		/* ptr to first link in text */
  4    33 
  4    34 	/* LIMIT OF BRIEF STRUCTURE */
  4    35 
  4    36 	2 compiler char(8) aligned,		/* name of processor which generated segment */
  4    37 	2 compile_time fixed bin(71),		/* clock reading of date/time object was generated */
  4    38 	2 userid char(32) aligned,		/* standard Multics id of creator of object segment */
  4    39 	2 cvers aligned,			/* generator version name in printable char string form */
  4    40 	  3 offset bit(18) unaligned,		/* offset of name in words relative to base of symbol section */
  4    41 	  3 length bit(18) unaligned,		/* length of name in characters */
  4    42 	2 comment aligned,			/* printable comment concerning generator or generation of segment */
  4    43 	  3 offset bit(18) unaligned,		/* offset of comment in words relative to base of symbol section */
  4    44 	  3 length bit(18) unaligned,		/* length of comment in characters */
  4    45 	2 source_map fixed bin,		/* offset, relative to base of symbol section, of source map structure */
  4    46 
  4    47 	/* LIMIT OF DISPLAY STRUCTURE */
  4    48 
  4    49 	2 rel_text pointer,			/* pointer to text section relocation info */
  4    50 	2 rel_def pointer,			/* pointer to definition section relocation info */
  4    51 	2 rel_link pointer,			/* pointer to linkage section relocation info */
  4    52 	2 rel_static pointer,		/* pointer to static section relocation info */
  4    53 	2 rel_symbol pointer,		/* pointer to symbol section relocation info */
  4    54 	2 text_boundary fixed bin,		/* specifies mod  of text section base boundary */
  4    55 	2 static_boundary fixed bin,		/* specifies mod of internal static base boundary */
  4    56 					/* currently not used by system */
  4    57 	2 default_truncate fixed bin,		/* offset rel to symbp for binder to automatically trunc. symb sect. */
  4    58 	2 optional_truncate fixed bin;	/* offset rel to symbp for binder to optionally trunc. symb sect. */
  4    59 
  4    60 declare	object_info_version_2 fixed bin int static init(2);
  4    61 
  4    62 /* END INCLUDE FILE ... object_info.incl.pl1 */
       88 
  5     1 	/* BEGIN INCLUDE SEGMENT ...  component_info.incl.pl1   M. Weaver  4/26/72  */
  5     2 
  5     3 declare	1 ci aligned,
  5     4 	2 dcl_version fixed bin,		/* version number of this structure */
  5     5 	2 name char(32) aligned,		/* objectname of component segment */
  5     6 	2 text_start pointer,		/* ptr to component's section of text */
  5     7 	2 stat_start pointer,		/* pointer to component's section of internal static */
  5     8 	2 symb_start pointer,		/* pointer to component's first symbol block */
  5     9 	2 defblock_ptr pointer,		/* ptr to component's definition block */
  5    10 	2 text_lng fixed bin,		/* length of text section */
  5    11 	2 stat_lng fixed bin,		/* length of internal static */
  5    12 	2 symb_lng fixed bin,		/* length of symbol section */
  5    13 	2 n_blocks fixed bin,		/* number of symbol blocks in component's symbol section */
  5    14 	2 standard bit(1) aligned,		/* indicates whether component is in standard (new) format */
  5    15 	2 compiler char(8) aligned,		/* name of component's compiler */
  5    16 	2 compile_time fixed bin(71),		/* time component was compiled */
  5    17 	2 userid char(32) aligned,		/* id of creator of component */
  5    18 	2 cvers aligned,			/* version of component's compiler in printable form */
  5    19 	  3 offset bit(18) unaligned,		/* offset in words relative to symb_start */
  5    20 	  3 length bit(18) unaligned,		/* length of name in characters */
  5    21 	2 comment aligned,			/* component's comment */
  5    22 	  3 offset bit(18) unaligned,		/* offset in words relative to symb_start */
  5    23 	  3 length bit(18) unaligned,		/* length of comment in characters */
  5    24 	2 source_map fixed bin;		/* offset, rel to beg of symbol block, of component's source map */
  5    25 
  5    26 	/* END INCLUDE SEGMENT ... component_info.incl.pl1 */
       89 
       90 
       91 /* ====================================================== */
       92 
       93 /* initialize some stuff */
       94 
       95 	nargs = -1;
       96 
       97 OLD_ENTRY_SEQUENCE:
       98 	if bin (rel (entry_ptr), 18) = 0 then go to no_defs;
       99 						/* Entry point at seg|0 is not preceded		*/
      100 						/*   by a standard entry sequence.		*/
      101 						/* Entry point at seg|1 is preceded by entry flags*/
      102 						/*   but has no descriptors.			*/
      103 	segptr = ptr (entry_ptr, 0);			/* get ptr to base of seg */
      104 	def_ptr = segptr;				/* till we get something better */
      105 	call hcs_$status_mins (segptr, type, bitcnt, code); /* get type and bitcnt */
      106 	if code ^= 0 then return;
      107 	if type = 2 then do;
      108 	     code = error_table_$dirseg;		/* dirs don't have entry points */
      109 	     return;
      110 	end;
      111 	call condition_ ("any_other", catch);		/* Guard against access faults. */
      112 	call hcs_$fs_get_mode (segptr, mode, code);	/* get mode wrt validation level */
      113 	if code ^= 0 then return;			/* don't see how this could happen */
      114 	if mode < 4				/* no read or execute access			*/
      115 	     then do;				/* can't see defs (probably none anyway)	*/
      116 		code = error_table_$moderr;
      117 		return;
      118 	     end;
      119 
      120 	if entry_desc_info.version = entry_desc_info_version_2 then do;
      121 	     if entry_desc_info.object_ptr ^= null then do;/* previously assumed offset 0...		*/
      122 		segptr = entry_desc_info.object_ptr;	/* user knows better...			*/
      123 		def_ptr = segptr;
      124 	     end;
      125 	     if entry_desc_info.bit_count > 0 then bitcnt = entry_desc_info.bit_count;
      126 	end;
      127 
      128 	oi.version_number = object_info_version_2;
      129 	call object_info_$display (segptr, bitcnt, addr (oi), code); /* may need def ptr */
      130 	if code ^= 0 then return;
      131 	def_ptr = oi.defp;				/* now we have ptr to actual defs */
      132 	txp = oi.textp;
      133 
      134 	i = bin (rel (entry_ptr), 18);		/* get offset of input ptr */
      135 	j = bin (rel (oi.textp), 18);			/* get offset of beginning of text */
      136 	if i < j then go to no_defs;			/* If entry above text begin, or */
      137 	if i > j+oi.tlng then go to no_defs;		/* .. if entry below end of text, fail. */
      138 
      139 	if oi.compiler ^= "binder" then		/* this compiler generated all entries */
      140 	     if ^oi.format.standard then go to no_defs;	/* This entry must be in std object. */
      141 	     else;
      142 	else do;					/* consult the bind map for this component */
      143 	     call component_info_$offset (segptr, bin (rel (entry_ptr), 18), addr (ci), code);
      144 	     if code ^= 0 then go to no_defs;		/* offset is illegal. fail. */
      145 	     if ^ci.standard then go to no_defs;	/* Must be a standard object. */
      146 	end;
      147 
      148 	entry_sequence_w2p = addrel (entry_ptr, -1);	/* get ptr to entry sequence info		*/
      149 	
      150 	if ret_info
      151 	then entry_desc_info.flags = entry_sequence_w2.flags;
      152 
      153 	if bin (entry_sequence_w2.def_relp, 18) > oi.dlng then do;
      154 no_defs:	     code = error_table_$nodescr;		/* not in def section			*/
      155 	     return;
      156 	end;
      157 	defp = addrel (oi.defp, entry_sequence_w2.def_relp);	/* get ptr to entry's def		*/
      158 	if ^defp -> definition.new then go to no_defs;	/* Must be new format.			*/
      159 	if ^defp -> definition.entry then go to no_defs;	/* Must have entrypoint flag on. 		*/
      160 	nargs = 0;				/* Assume proc has no args.			*/
      161 	
      162 common:
      163 	if entry_sequence_w2.flags.revision_1		/* descr ptrs are in text if at all.		*/
      164 	then do;
      165 	     if ^entry_sequence_w2.flags.has_descriptors then goto no_defs;
      166 	     np = addrel (entry_ptr, -2);		/*   It has descriptors, so safe to reference	*/
      167 						/*   the descriptor offset now.		*/
      168 	     descpp =  addwordno (segptr, bin (np -> entry_sequence.descr_relp_offset));
      169 	     no_descrs = "0"b;
      170 	end;
      171 	else if defp ^= null then do;			/* see if there are descr ptrs in def. section	*/
      172 	     if ^defp -> definition.argcount then go to no_defs;  /* no parameter info			*/
      173 	     if ^defp -> definition.descriptors
      174 	     then no_descrs = "1"b;
      175 	     else no_descrs = "0"b;
      176 	     descpp = addrel(defp, size(definition));	/* descr array  appended to def		*/
      177 	end;
      178 	else go to OLD_ENTRY_SEQUENCE;		/* defp = null implies that we were entered 	*/
      179 						/* via $text_only or $text_only_info entry point	*/
      180 						/* with version 0 entry sequence in which arg	*/
      181 						/* descriptors are located in definition section. */
      182 						/* Must go through rigor of calling object_info_	*/
      183 						/* in this case, even if given a text entry point.*/
      184 	nargs = bin (descpp ->  parm_desc_ptrs.n_args);	/* Return number of  arguments expected		*/
      185 	num_descs = nargs;
      186 
      187 	if no_descrs then				/* No descriptors, but argcount was available.	*/
      188 	     descps (*) = null;
      189 	else do i = 1 to min (nargs, hbound (descps, 1));	/* Return pointers to descriptors.		*/
      190 						/* ..  which are in the text section		*/
      191 
      192 	     descps (i) = addwordno (txp, bin (descpp -> parm_desc_ptrs.descriptor_relp (i)));
      193 	end;
      194 	return;					/* Success. */
      195 
      196 
      197 
      198 text_only_info: entry (entry_ptr, nargs, descps, entry_desc_info_ptr, code);
      199 
      200  	ret_info = "1"b;
      201 	if entry_desc_info.version ^= entry_desc_info_version_1 &
      202 	   entry_desc_info.version ^= entry_desc_info_version_2  then do;
      203 	     code = error_table_$unimplemented_version;
      204 	     return;
      205 	     end;
      206 	entry_desc_info.flags = "0"b;
      207 
      208 
      209 text_only: entry (entry_ptr, nargs, descps, code);
      210 
      211 /* assume entry ptr points  to a text entry sequence; do no validation */
      212 
      213 	code = 0;
      214 	nargs = -1;
      215 	defp = null;				/* don't want ptr to definition		*/
      216 	txp = ptr (entry_ptr, 0);
      217 	if bin (rel (entry_ptr), 18) = 0 then go to no_defs;
      218 						/* Entry point at seg|0 is not preceded		*/
      219 						/*   by a standard entry sequence.		*/
      220 						/* Entry point at seg|1 is preceded by entry flags*/
      221 						/*   but has no descriptors.			*/
      222 	entry_sequence_w2p = addrel (entry_ptr, -1);	/* get ptr to entry sequence word 2.		*/
      223 
      224 	if ret_info
      225 	then entry_desc_info.flags = entry_sequence_w2.flags;
      226 	go to common;
      227 
      228 catch:	proc (mcptr, condname, wcptr, infoptr, continue);
      229 
      230 dcl (mcptr, wcptr, infoptr) ptr;
      231 dcl  condname char (*);
      232 dcl  continue bit (1) aligned;
      233 
      234 	     if condname = "quit" then go to pass;
      235 	     if condname = "alrm" then go to pass;
      236 	     if condname = "cput" then go to pass;
      237 	     if condname = "program_interrupt" then go to pass;
      238 	     if condname = "finish" then go to pass;
      239 	     if condname = "storage" then go to pass;
      240 	     if condname = "mme2" then do;
      241 pass:		continue = "1"b;
      242 		return;
      243 	     end;
      244 
      245 	     if condname ^= "cleanup" then go to no_defs; /* probably access fault;
      246*						   in any case, forget it */
      247 	     return;
      248 	end catch;
      249 
      250      end get_entry_arg_descs_$info;
      251 
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/20/86  1145.0  get_entry_arg_descs_.pl1          >special_ldd>install>MR12.0-1222>get_entry_arg_descs_.pl1
78           1    05/01/86  0849.8  entry_sequence_info.incl.pl1      >ldd>include>entry_sequence_info.incl.pl1
1-31         2    05/01/86  0849.8  entry_desc_info.incl.pl1          >ldd>include>entry_desc_info.incl.pl1
84           3    11/20/86  1035.2  definition.incl.pl1               >special_ldd>install>MR12.0-1222>definition.incl.pl1
88           4    08/05/77  1022.5  object_info.incl.pl1              >ldd>include>object_info.incl.pl1
89           5    05/06/74  1741.0  component_info.incl.pl1           >ldd>include>component_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
addr                                                   builtin function         dcl 54 ref 129 129 143 143
addrel                                                 builtin function         dcl 54 ref 148 157 166 176 222
addwordno                                              builtin function         dcl 54 ref 168 192
argcount                  1(22)        based           bit(1)                   level 3 packed unaligned dcl 3-12 ref 172
bin                                                    builtin function         dcl 54 ref 97 134 135 143 143 153 168 184 192 217
bit_count                 4            based           fixed bin(24,0)          level 2 dcl 2-34 ref 125 125
bitcnt                          000104 automatic       fixed bin(24,0)          dcl 59 set ref 105* 125* 129*
ci                              000216 automatic       structure                level 1 dcl 5-3 set ref 143 143
code                                   parameter       fixed bin(35,0)          dcl 52 set ref 21 27* 33 105* 106 108* 112* 113 116*
                                                                                  129* 130 143* 144 154* 198 203* 209 213*
compiler                 30     000130 automatic       char(8)                  level 2 dcl 86 set ref 139
component_info_$offset          000026 constant        entry                    external dcl 73 ref 143
condition_                      000030 constant        entry                    external dcl 74 ref 111
condname                               parameter       char                     unaligned dcl 231 ref 228 234 235 236 237 238 239
                                                                                  240 245
continue                               parameter       bit(1)                   dcl 232 set ref 228 241*
def_ptr                         000116 automatic       pointer                  dcl 68 set ref 104* 123* 131*
def_relp                               based           bit(18)                  level 2 packed unaligned dcl 80 ref 153 157
definition                             based           structure                level 1 dcl 3-12 ref 176
defp                            000114 automatic       pointer                  dcl 68 in procedure "get_entry_arg_descs_$info" set
                                                                                  ref 157* 158 159 171 172 173 176 215*
defp                      4     000130 automatic       pointer                  level 2 in structure "oi" dcl 86 in procedure
                                                                                  "get_entry_arg_descs_$info" set ref 131 157
descpp                          000122 automatic       pointer                  dcl 68 set ref 168* 176* 184 192
descps                                 parameter       pointer                  array dcl 51 set ref 21 33 187* 189 192* 198 209
descr_relp_offset                      based           bit(18)                  level 3 packed unaligned dcl 1-22 ref 168
descriptor_relp           0(18)        based           bit(18)                  array level 2 packed unaligned dcl 1-15 ref 192
descriptors               1(23)        based           bit(1)                   level 3 packed unaligned dcl 3-12 ref 173
dlng                     17     000130 automatic       fixed bin(17,0)          level 2 dcl 86 set ref 153
entry                     1(20)        based           bit(1)                   level 3 packed unaligned dcl 3-12 ref 159
entry_desc_info                        based           structure                level 1 dcl 2-34
entry_desc_info_ptr                    parameter       pointer                  dcl 2-49 ref 21 25 25 30 120 121 122 125 125 150 198
                                                                                  201 201 206 224
entry_desc_info_version_1              constant        fixed bin(17,0)          initial dcl 76 ref 25 201
entry_desc_info_version_2              constant        fixed bin(17,0)          initial dcl 2-49 ref 25 120 201
entry_ptr                              parameter       pointer                  dcl 49 ref 21 33 97 103 134 143 143 148 166 198 209
                                                                                  216 217 222
entry_sequence                         based           structure                level 1 dcl 1-22
entry_sequence_w2                      based           structure                level 1 dcl 80
entry_sequence_w2p              000126 automatic       pointer                  dcl 81 set ref 148* 150 153 157 162 165 222* 224
error_table_$dirseg             000014 external static fixed bin(35,0)          dcl 63 ref 108
error_table_$moderr             000012 external static fixed bin(35,0)          dcl 63 ref 116
error_table_$nodescr            000010 external static fixed bin(35,0)          dcl 63 ref 154
error_table_$unimplemented_version
                                000016 external static fixed bin(35,0)          dcl 63 ref 27 203
flags                     1(18)        based           structure                level 2 in structure "definition" packed unaligned
                                                                                  dcl 3-12 in procedure "get_entry_arg_descs_$info"
flags                     0(18)        based           structure                level 2 in structure "entry_sequence_w2" packed
                                                                                  unaligned dcl 80 in procedure
                                                                                  "get_entry_arg_descs_$info" ref 150 224
flags                     1            based           structure                level 2 in structure "entry_desc_info" dcl 2-34
                                                                                  in procedure "get_entry_arg_descs_$info" set ref
                                                                                  30* 150* 206* 224*
format                   24     000130 automatic       structure                level 2 dcl 86
has_descriptors           0(20)        based           bit(1)                   level 3 packed unaligned dcl 80 ref 165
hbound                                                 builtin function         dcl 54 ref 189
hcs_$fs_get_mode                000022 constant        entry                    external dcl 71 ref 112
hcs_$status_mins                000020 constant        entry                    external dcl 70 ref 105
i                               000100 automatic       fixed bin(17,0)          dcl 56 set ref 134* 136 137 189* 192 192*
infoptr                                parameter       pointer                  dcl 230 ref 228
j                               000101 automatic       fixed bin(17,0)          dcl 56 set ref 135* 136 137
mcptr                                  parameter       pointer                  dcl 230 ref 228
min                                                    builtin function         dcl 54 ref 189
mode                            000103 automatic       fixed bin(5,0)           dcl 58 set ref 112* 114
n_args                                 based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 1-15 ref 184
nargs                                  parameter       fixed bin(17,0)          dcl 50 set ref 21 33 95* 160* 184* 185 189 198 209
                                                                                  214*
new                       1(18)        based           bit(1)                   level 3 packed unaligned dcl 3-12 ref 158
no_descrs                       000105 automatic       bit(1)                   unaligned dcl 60 set ref 169* 173* 175* 187
np                              000112 automatic       pointer                  dcl 68 set ref 166* 168
null                                                   builtin function         dcl 54 ref 121 171 187 215
num_descs                       000124 automatic       fixed bin(18,0)          dcl 1-20 set ref 185*
object_info                            based           structure                level 1 dcl 4-6
object_info_$display            000024 constant        entry                    external dcl 72 ref 129
object_info_version_2                  constant        fixed bin(17,0)          initial dcl 4-60 ref 128
object_ptr                2            based           pointer                  level 2 dcl 2-34 ref 121 122
oi                              000130 automatic       structure                level 1 dcl 86 set ref 129 129
parm_desc_ptrs                         based           structure                level 1 dcl 1-15
ptr                                                    builtin function         dcl 54 ref 103 216
rel                                                    builtin function         dcl 54 ref 97 134 135 143 143 217
ret_info                        000106 automatic       bit(1)                   initial unaligned dcl 61 set ref 24* 61* 150 200*
                                                                                  224
revision_1                0(19)        based           bit(1)                   level 3 packed unaligned dcl 80 ref 162
segptr                          000110 automatic       pointer                  dcl 68 set ref 103* 104 105* 112* 122* 123 129* 143*
                                                                                  168
size                                                   builtin function         dcl 54 ref 176
standard                 24(04) 000130 automatic       bit(1)                   level 3 in structure "oi" packed unaligned dcl 86
                                                                                  in procedure "get_entry_arg_descs_$info" set ref
                                                                                  139
standard                 26     000216 automatic       bit(1)                   level 2 in structure "ci" dcl 5-3 in procedure
                                                                                  "get_entry_arg_descs_$info" set ref 145
textp                     2     000130 automatic       pointer                  level 2 dcl 86 set ref 132 135
tlng                     16     000130 automatic       fixed bin(17,0)          level 2 dcl 86 set ref 137
txp                             000120 automatic       pointer                  dcl 68 set ref 132* 192 216*
type                            000102 automatic       fixed bin(2,0)           dcl 57 set ref 105* 107
version                                based           fixed bin(17,0)          level 2 dcl 2-34 ref 25 25 120 201 201
version_number                  000130 automatic       fixed bin(17,0)          level 2 dcl 86 set ref 128*
wcptr                                  parameter       pointer                  dcl 230 ref 228
word1                                  based           structure                level 2 dcl 1-22
word2                     1            based           structure                level 2 dcl 1-22

NAMES DECLARED BY EXPLICIT CONTEXT.
OLD_ENTRY_SEQUENCE              000140 constant        label                    dcl 97 ref 171
catch                           001010 constant        entry                    internal dcl 228 ref 111 111
common                          000466 constant        label                    dcl 162 ref 226
get_entry_arg_descs_            000124 constant        entry                    external dcl 33
get_entry_arg_descs_$info       000053 constant        entry                    external dcl 21
no_defs                         000447 constant        label                    dcl 154 ref 97 136 137 139 144 145 158 159 165 172
                                                                                  217 245
pass                            001061 constant        label                    dcl 241 ref 234 235 236 237 238 239
text_only                       000713 constant        entry                    external dcl 209
text_only_info                  000645 constant        entry                    external dcl 198

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1274        1326    1102        1304
Length      1636    1102        32         273     172           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
get_entry_arg_descs_$info           215 external procedure  is an external procedure.  
catch                                65 internal procedure  is assigned to an entry variable.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
get_entry_arg_descs_$info
                         000100 i                           get_entry_arg_descs_$info
                         000101 j                           get_entry_arg_descs_$info
                         000102 type                        get_entry_arg_descs_$info
                         000103 mode                        get_entry_arg_descs_$info
                         000104 bitcnt                      get_entry_arg_descs_$info
                         000105 no_descrs                   get_entry_arg_descs_$info
                         000106 ret_info                    get_entry_arg_descs_$info
                         000110 segptr                      get_entry_arg_descs_$info
                         000112 np                          get_entry_arg_descs_$info
                         000114 defp                        get_entry_arg_descs_$info
                         000116 def_ptr                     get_entry_arg_descs_$info
                         000120 txp                         get_entry_arg_descs_$info
                         000122 descpp                      get_entry_arg_descs_$info
                         000124 num_descs                   get_entry_arg_descs_$info
                         000126 entry_sequence_w2p          get_entry_arg_descs_$info
                         000130 oi                          get_entry_arg_descs_$info
                         000216 ci                          get_entry_arg_descs_$info

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          tra_ext_1           ext_entry_desc      int_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
component_info_$offset        condition_                    hcs_$fs_get_mode              hcs_$status_mins
object_info_$display

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$dirseg           error_table_$moderr           error_table_$nodescr
error_table_$unimplemented_version


CONSTANTS
001074  aa     760000777777

001075  aa     757777777777

001076  aa     737777777777

001077  aa     677777777777

001100  aa     577777777777

001101  aa     377777777777

000000  aa  155 155 145 062	mme2

000001  aa  143 160 165 164	cput

000002  aa  141 154 162 155	alrm

000003  aa  161 165 151 164	quit

000004  aa     514000000001

000005  aa     526077777777

000006  aa     500000000000

000007  aa     524000000011

000010  aa     404000000043

000011  aa     404000000021

000012  aa     464000000000

000014  aa  143 154 145 141	clea
000015  aa  156 165 160 000	nup

000016  aa  163 164 157 162	stor
000017  aa  141 147 145 000	age

000020  aa  146 151 156 151	fini
000021  aa  163 150 000 000	sh

000022  aa  142 151 156 144	bind
000023  aa  145 162 000 000	er

000024  aa     077777000043
000025  aa     000001000000

000026  aa  141 156 171 137	any_
000027  aa  157 164 150 145	othe
000030  aa  162 000 000 000	r

000031  aa     464100000000
000032  aa     400000000000
000033  aa     400000000000
000034  aa     400000000000

000035  aa  160 162 157 147	prog
000036  aa  162 141 155 137	ram_
000037  aa  151 156 164 145	inte
000040  aa  162 162 165 160	rrup
000041  aa  164 000 000 000	t

BEGIN PROCEDURE get_entry_arg_descs_$info
PROLOGUE SEQUENCE
000042  aa  6 00272 4401 00	sxl0 	pr6|186
						STATEMENT 1 ON LINE 61
000043  aa  6 00106 4501 00	stz  	pr6|70		ret_info
000044  aa  6 00272 7201 00	lxl0 	pr6|186
000045  aa   000000 7100 10	tra  	0,0
MAIN SEQUENCE
ENTRY TO get_entry_arg_descs_$info                          STATEMENT 1 ON LINE 21
get_entry_arg_descs_$info:
	proc (entry_ptr, nargs, descps, entry_desc_info_ptr, code);

000046  at     000005000012
000047  tt     000011000031
000050  tt     000012000010
000051  ta     000046000000
000052  da     000141300000
000053  aa   000340 6270 00	eax7 	224
000054  aa  7 00034 3521 20	epp2 	pr7|28,*
000055  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
000056  aa     000012000000
000057  aa     000000000000
000060  aa  6 00032 3735 20	epp7 	pr6|26,*
000061  aa  7 00012 3715 20	epp5 	pr7|10,*
000062  aa  6 00266 6515 00	spri5	pr6|182
000063  aa   777757 7000 04	tsx0 	-17,ic		000042
						STATEMENT 1 ON LINE 24
 	ret_info = "1"b;

000064  aa   400000 2350 03	lda  	131072,du
000065  aa  6 00106 7551 00	sta  	pr6|70		ret_info
						STATEMENT 1 ON LINE 25
	if entry_desc_info.version ^= entry_desc_info_version_1 &
	   entry_desc_info.version ^= entry_desc_info_version_2  then do;

000066  aa  6 00032 3735 20	epp7 	pr6|26,*
000067  aa  7 00010 3715 20	epp5 	pr7|8,*		entry_desc_info_ptr
000070  aa  5 00000 2361 20	ldq  	pr5|0,*		entry_desc_info.version
000071  aa   000001 1160 07	cmpq 	1,dl
000072  aa   000007 6000 04	tze  	7,ic		000101
000073  aa   000002 1160 07	cmpq 	2,dl
000074  aa   000005 6000 04	tze  	5,ic		000101
						STATEMENT 1 ON LINE 27
	     code = error_table_$unimplemented_version;

000075  aa  6 00044 3701 20	epp4 	pr6|36,*
000076  la  4 00016 2361 20	ldq  	pr4|14,*		error_table_$unimplemented_version
000077  aa  6 00266 7561 20	stq  	pr6|182,*		code
						STATEMENT 1 ON LINE 28
	     return;

000100  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 29
	     end;

						STATEMENT 1 ON LINE 30
	entry_desc_info.flags = "0"b;

000101  aa   001000 2350 04	lda  	512,ic		001101 = 377777777777
000102  aa  5 00000 3535 20	epp3 	pr5|0,*		entry_desc_info_ptr
000103  aa  3 00001 3551 00	ansa 	pr3|1		entry_desc_info.basic_indicator
000104  aa   000774 2350 04	lda  	508,ic		001100 = 577777777777
000105  aa  3 00001 3551 00	ansa 	pr3|1		entry_desc_info.revision_1
000106  aa   000771 2350 04	lda  	505,ic		001077 = 677777777777
000107  aa  3 00001 3551 00	ansa 	pr3|1		entry_desc_info.has_descriptors
000110  aa   000766 2350 04	lda  	502,ic		001076 = 737777777777
000111  aa  3 00001 3551 00	ansa 	pr3|1		entry_desc_info.variable
000112  aa   000763 2350 04	lda  	499,ic		001075 = 757777777777
000113  aa  3 00001 3551 00	ansa 	pr3|1		entry_desc_info.function
000114  aa   000760 2350 04	lda  	496,ic		001074 = 760000777777
000115  aa  3 00001 3551 00	ansa 	pr3|1		entry_desc_info.pad
						STATEMENT 1 ON LINE 33
get_entry_arg_descs_:
	entry (entry_ptr, nargs, descps, code);

000116  aa   000017 7100 04	tra  	15,ic		000135
ENTRY TO get_entry_arg_descs_                               STATEMENT 1 ON LINE 33
get_entry_arg_descs_:
	entry (entry_ptr, nargs, descps, code);

000117  at     000004000012
000120  tt     000011000031
000121  ta     000010000000
000122  ta     000117000000
000123  da     000144300000
000124  aa   000340 6270 00	eax7 	224
000125  aa  7 00034 3521 20	epp2 	pr7|28,*
000126  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
000127  aa     000010000000
000130  aa     000000000000
000131  aa  6 00032 3735 20	epp7 	pr6|26,*
000132  aa  7 00010 3715 20	epp5 	pr7|8,*
000133  aa  6 00266 6515 00	spri5	pr6|182
000134  aa   777706 7000 04	tsx0 	-58,ic		000042
						STATEMENT 1 ON LINE 95
	nargs = -1;

000135  aa   000001 3360 07	lcq  	1,dl
000136  aa  6 00032 3735 20	epp7 	pr6|26,*
000137  aa  7 00004 7561 20	stq  	pr7|4,*		nargs
						STATEMENT 1 ON LINE 97
OLD_ENTRY_SEQUENCE:
	if bin (rel (entry_ptr), 18) = 0 then go to no_defs;

000140  aa  6 00032 3735 20	epp7 	pr6|26,*
000141  aa  7 00002 3715 20	epp5 	pr7|2,*		entry_ptr
000142  aa  5 00000 3715 20	epp5 	pr5|0,*		entry_ptr
000143  aa  5 00000 6351 00	eaa  	pr5|0		entry_ptr
000144  aa   000066 7730 00	lrl  	54
000145  aa   000302 6000 04	tze  	194,ic		000447
						STATEMENT 1 ON LINE 103
	segptr = ptr (entry_ptr, 0);

000146  aa   000000 3314 00	eawp5	0
000147  aa  6 00110 6515 00	spri5	pr6|72		segptr
						STATEMENT 1 ON LINE 104
	def_ptr = segptr;

000150  aa  6 00116 6515 00	spri5	pr6|78		def_ptr
						STATEMENT 1 ON LINE 105
	call hcs_$status_mins (segptr, type, bitcnt, code);

000151  aa  6 00110 3521 00	epp2 	pr6|72		segptr
000152  aa  6 00276 2521 00	spri2	pr6|190
000153  aa  6 00102 3521 00	epp2 	pr6|66		type
000154  aa  6 00300 2521 00	spri2	pr6|192
000155  aa  6 00104 3521 00	epp2 	pr6|68		bitcnt
000156  aa  6 00302 2521 00	spri2	pr6|194
000157  aa  6 00266 3521 20	epp2 	pr6|182,*		code
000160  aa  6 00304 2521 00	spri2	pr6|196
000161  aa  6 00274 6211 00	eax1 	pr6|188
000162  aa   020000 4310 07	fld  	8192,dl
000163  aa  6 00044 3701 20	epp4 	pr6|36,*
000164  la  4 00020 3521 20	epp2 	pr4|16,*		hcs_$status_mins
000165  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 106
	if code ^= 0 then return;

000166  aa  6 00266 2361 20	ldq  	pr6|182,*		code
000167  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 107
	if type = 2 then do;

000170  aa  6 00102 2361 00	ldq  	pr6|66		type
000171  aa   000002 1160 07	cmpq 	2,dl
000172  aa   000005 6010 04	tnz  	5,ic		000177
						STATEMENT 1 ON LINE 108
	     code = error_table_$dirseg;

000173  aa  6 00044 3701 20	epp4 	pr6|36,*
000174  la  4 00014 2361 20	ldq  	pr4|12,*		error_table_$dirseg
000175  aa  6 00266 7561 20	stq  	pr6|182,*		code
						STATEMENT 1 ON LINE 109
	     return;

000176  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 110
	end;

						STATEMENT 1 ON LINE 111
	call condition_ ("any_other", catch);

000177  aa   777627 2370 04	ldaq 	-105,ic		000026 = 141156171137 157164150145
000200  aa  6 00274 7571 00	staq 	pr6|188
000201  aa   162000 2350 03	lda  	58368,du
000202  aa  6 00276 7551 00	sta  	pr6|190
000203  aa   000605 3520 04	epp2 	389,ic		001010 = 000120627000
000204  aa  6 00306 2521 00	spri2	pr6|198		cp.166
000205  aa  6 00310 6521 00	spri6	pr6|200		cp.166
000206  aa  6 00274 3521 00	epp2 	pr6|188
000207  aa  6 00314 2521 00	spri2	pr6|204
000210  aa  6 00306 3521 00	epp2 	pr6|198		cp.166
000211  aa  6 00316 2521 00	spri2	pr6|206
000212  aa   777575 3520 04	epp2 	-131,ic		000007 = 524000000011
000213  aa  6 00320 2521 00	spri2	pr6|208
000214  aa   777572 3520 04	epp2 	-134,ic		000006 = 500000000000
000215  aa  6 00322 2521 00	spri2	pr6|210
000216  aa  6 00312 6211 00	eax1 	pr6|202
000217  aa   010000 4310 07	fld  	4096,dl
000220  aa  6 00044 3701 20	epp4 	pr6|36,*
000221  la  4 00030 3521 20	epp2 	pr4|24,*		condition_
000222  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 112
	call hcs_$fs_get_mode (segptr, mode, code);

000223  aa  6 00110 3521 00	epp2 	pr6|72		segptr
000224  aa  6 00314 2521 00	spri2	pr6|204
000225  aa  6 00103 3521 00	epp2 	pr6|67		mode
000226  aa  6 00316 2521 00	spri2	pr6|206
000227  aa  6 00266 3521 20	epp2 	pr6|182,*		code
000230  aa  6 00320 2521 00	spri2	pr6|208
000231  aa  6 00312 6211 00	eax1 	pr6|202
000232  aa   014000 4310 07	fld  	6144,dl
000233  aa  6 00044 3701 20	epp4 	pr6|36,*
000234  la  4 00022 3521 20	epp2 	pr4|18,*		hcs_$fs_get_mode
000235  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 113
	if code ^= 0 then return;

000236  aa  6 00266 2361 20	ldq  	pr6|182,*		code
000237  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 114
	if mode < 4				/* no read or execute access			*/
	     then do;

000240  aa  6 00103 2361 00	ldq  	pr6|67		mode
000241  aa   000004 1160 07	cmpq 	4,dl
000242  aa   000005 6050 04	tpl  	5,ic		000247
						STATEMENT 1 ON LINE 116
		code = error_table_$moderr;

000243  aa  6 00044 3701 20	epp4 	pr6|36,*
000244  la  4 00012 2361 20	ldq  	pr4|10,*		error_table_$moderr
000245  aa  6 00266 7561 20	stq  	pr6|182,*		code
						STATEMENT 1 ON LINE 117
		return;

000246  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 118
	     end;

						STATEMENT 1 ON LINE 120
	if entry_desc_info.version = entry_desc_info_version_2 then do;

000247  aa  6 00032 3735 20	epp7 	pr6|26,*
000250  aa  7 00010 3715 20	epp5 	pr7|8,*		entry_desc_info_ptr
000251  aa  5 00000 2361 20	ldq  	pr5|0,*		entry_desc_info.version
000252  aa   000002 1160 07	cmpq 	2,dl
000253  aa   000014 6010 04	tnz  	12,ic		000267
						STATEMENT 1 ON LINE 121
	     if entry_desc_info.object_ptr ^= null then do;

000254  aa  5 00000 3535 20	epp3 	pr5|0,*		entry_desc_info_ptr
000255  aa  3 00002 2371 00	ldaq 	pr3|2		entry_desc_info.object_ptr
000256  aa   777546 6770 04	eraq 	-154,ic		000024 = 077777000043 000001000000
000257  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000260  aa   000004 6000 04	tze  	4,ic		000264
						STATEMENT 1 ON LINE 122
		segptr = entry_desc_info.object_ptr;

000261  aa  3 00002 3515 20	epp1 	pr3|2,*		entry_desc_info.object_ptr
000262  aa  6 00110 2515 00	spri1	pr6|72		segptr
						STATEMENT 1 ON LINE 123
		def_ptr = segptr;

000263  aa  6 00116 2515 00	spri1	pr6|78		def_ptr
						STATEMENT 1 ON LINE 124
	     end;

						STATEMENT 1 ON LINE 125
	     if entry_desc_info.bit_count > 0 then bitcnt = entry_desc_info.bit_count;

000264  aa  3 00004 2361 00	ldq  	pr3|4		entry_desc_info.bit_count
000265  aa   000002 6044 04	tmoz 	2,ic		000267
000266  aa  6 00104 7561 00	stq  	pr6|68		bitcnt
						STATEMENT 1 ON LINE 126
	end;

						STATEMENT 1 ON LINE 128
	oi.version_number = object_info_version_2;

000267  aa   000002 2360 07	ldq  	2,dl
000270  aa  6 00130 7561 00	stq  	pr6|88		oi.version_number
						STATEMENT 1 ON LINE 129
	call object_info_$display (segptr, bitcnt, addr (oi), code);

000271  aa  6 00130 3535 00	epp3 	pr6|88		oi
000272  aa  6 00324 2535 00	spri3	pr6|212
000273  aa  6 00110 3521 00	epp2 	pr6|72		segptr
000274  aa  6 00276 2521 00	spri2	pr6|190
000275  aa  6 00104 3521 00	epp2 	pr6|68		bitcnt
000276  aa  6 00300 2521 00	spri2	pr6|192
000277  aa  6 00324 3521 00	epp2 	pr6|212
000300  aa  6 00302 2521 00	spri2	pr6|194
000301  aa  6 00266 3521 20	epp2 	pr6|182,*		code
000302  aa  6 00304 2521 00	spri2	pr6|196
000303  aa  6 00274 6211 00	eax1 	pr6|188
000304  aa   020000 4310 07	fld  	8192,dl
000305  aa  6 00044 3701 20	epp4 	pr6|36,*
000306  la  4 00024 3521 20	epp2 	pr4|20,*		object_info_$display
000307  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 130
	if code ^= 0 then return;

000310  aa  6 00266 2361 20	ldq  	pr6|182,*		code
000311  aa  0 00631 6011 00	tnz  	pr0|409		return_mac
						STATEMENT 1 ON LINE 131
	def_ptr = oi.defp;

000312  aa  6 00134 3735 20	epp7 	pr6|92,*		oi.defp
000313  aa  6 00116 6535 00	spri7	pr6|78		def_ptr
						STATEMENT 1 ON LINE 132
	txp = oi.textp;

000314  aa  6 00132 3715 20	epp5 	pr6|90,*		oi.textp
000315  aa  6 00120 6515 00	spri5	pr6|80		txp
						STATEMENT 1 ON LINE 134
	i = bin (rel (entry_ptr), 18);

000316  aa  6 00032 3535 20	epp3 	pr6|26,*
000317  aa  3 00002 3515 20	epp1 	pr3|2,*		entry_ptr
000320  aa  1 00000 3515 20	epp1 	pr1|0,*		entry_ptr
000321  aa  1 00000 6351 00	eaa  	pr1|0		entry_ptr
000322  aa   000066 7730 00	lrl  	54
000323  aa  6 00100 7561 00	stq  	pr6|64		i
						STATEMENT 1 ON LINE 135
	j = bin (rel (oi.textp), 18);

000324  aa  5 00000 6351 00	eaa  	pr5|0		oi.textp
000325  aa  6 00273 7561 00	stq  	pr6|187
000326  aa   000066 7730 00	lrl  	54
000327  aa  6 00101 7561 00	stq  	pr6|65		j
						STATEMENT 1 ON LINE 136
	if i < j then go to no_defs;

000330  aa  6 00100 1161 00	cmpq 	pr6|64		i
000331  aa   000116 6054 04	tpnz 	78,ic		000447
						STATEMENT 1 ON LINE 137
	if i > j+oi.tlng then go to no_defs;

000332  aa  6 00146 0761 00	adq  	pr6|102		oi.tlng
000333  aa  6 00100 1161 00	cmpq 	pr6|64		i
000334  aa   000113 6040 04	tmi  	75,ic		000447
						STATEMENT 1 ON LINE 139
	if oi.compiler ^= "binder" then		/* this compiler generated all entries */
	     if ^oi.format.standard then go to no_defs;

000335  aa   777465 2370 04	ldaq 	-203,ic		000022 = 142151156144 145162000000
000336  aa  0 00454 2771 00	oraq 	pr0|300		= 000000000000 000000040040
000337  aa  6 00160 1171 00	cmpaq	pr6|112		oi.compiler
000340  aa   000005 6000 04	tze  	5,ic		000345
000341  aa  6 00154 2351 00	lda  	pr6|108		oi.standard
000342  aa   020000 3150 03	cana 	8192,du
000343  aa   000104 6000 04	tze  	68,ic		000447
						STATEMENT 1 ON LINE 141
	     else;

000344  aa   000026 7100 04	tra  	22,ic		000372
						STATEMENT 1 ON LINE 142
	else do;

						STATEMENT 1 ON LINE 143
	     call component_info_$offset (segptr, bin (rel (entry_ptr), 18), addr (ci), code);

000345  aa  6 00273 2361 00	ldq  	pr6|187
000346  aa  6 00326 7561 00	stq  	pr6|214
000347  aa  6 00216 3515 00	epp1 	pr6|142		ci
000350  aa  6 00324 2515 00	spri1	pr6|212
000351  aa  6 00110 3521 00	epp2 	pr6|72		segptr
000352  aa  6 00314 2521 00	spri2	pr6|204
000353  aa  6 00326 3521 00	epp2 	pr6|214
000354  aa  6 00316 2521 00	spri2	pr6|206
000355  aa  6 00324 3521 00	epp2 	pr6|212
000356  aa  6 00320 2521 00	spri2	pr6|208
000357  aa  6 00266 3521 20	epp2 	pr6|182,*		code
000360  aa  6 00322 2521 00	spri2	pr6|210
000361  aa  6 00312 6211 00	eax1 	pr6|202
000362  aa   020000 4310 07	fld  	8192,dl
000363  aa  6 00044 3701 20	epp4 	pr6|36,*
000364  la  4 00026 3521 20	epp2 	pr4|22,*		component_info_$offset
000365  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 144
	     if code ^= 0 then go to no_defs;

000366  aa  6 00266 2361 20	ldq  	pr6|182,*		code
000367  aa   000060 6010 04	tnz  	48,ic		000447
						STATEMENT 1 ON LINE 145
	     if ^ci.standard then go to no_defs;

000370  aa  6 00244 2351 00	lda  	pr6|164		ci.standard
000371  aa   000056 6000 04	tze  	46,ic		000447
						STATEMENT 1 ON LINE 146
	end;

						STATEMENT 1 ON LINE 148
	entry_sequence_w2p = addrel (entry_ptr, -1);

000372  aa  6 00032 3735 20	epp7 	pr6|26,*
000373  aa  7 00002 3521 20	epp2 	pr7|2,*		entry_ptr
000374  aa  2 00000 3521 20	epp2 	pr2|0,*		entry_ptr
000375  aa   777777 0520 03	adwp2	262143,du
000376  aa  6 00126 2521 00	spri2	pr6|86		entry_sequence_w2p
						STATEMENT 1 ON LINE 150
	if ret_info
	then entry_desc_info.flags = entry_sequence_w2.flags;

000377  aa  6 00106 2351 00	lda  	pr6|70		ret_info
000400  aa   000041 6000 04	tze  	33,ic		000441
000401  aa  2 00000 2351 00	lda  	pr2|0		entry_sequence_w2.basic_indicator
000402  aa   000022 7350 00	als  	18
000403  aa  7 00010 3715 20	epp5 	pr7|8,*		entry_desc_info_ptr
000404  aa  5 00000 3715 20	epp5 	pr5|0,*		entry_desc_info_ptr
000405  aa  5 00001 6751 00	era  	pr5|1		entry_desc_info.basic_indicator
000406  aa  0 00002 3751 00	ana  	pr0|2		= 400000000000
000407  aa  5 00001 6551 00	ersa 	pr5|1		entry_desc_info.basic_indicator
000410  aa  2 00000 2351 00	lda  	pr2|0		entry_sequence_w2.revision_1
000411  aa   000022 7350 00	als  	18
000412  aa  5 00001 6751 00	era  	pr5|1		entry_desc_info.revision_1
000413  aa   200000 3750 03	ana  	65536,du
000414  aa  5 00001 6551 00	ersa 	pr5|1		entry_desc_info.revision_1
000415  aa  2 00000 2351 00	lda  	pr2|0		entry_sequence_w2.has_descriptors
000416  aa   000022 7350 00	als  	18
000417  aa  5 00001 6751 00	era  	pr5|1		entry_desc_info.has_descriptors
000420  aa   100000 3750 03	ana  	32768,du
000421  aa  5 00001 6551 00	ersa 	pr5|1		entry_desc_info.has_descriptors
000422  aa  2 00000 2351 00	lda  	pr2|0		entry_sequence_w2.variable
000423  aa   000022 7350 00	als  	18
000424  aa  5 00001 6751 00	era  	pr5|1		entry_desc_info.variable
000425  aa   040000 3750 03	ana  	16384,du
000426  aa  5 00001 6551 00	ersa 	pr5|1		entry_desc_info.variable
000427  aa  2 00000 2351 00	lda  	pr2|0		entry_sequence_w2.function
000430  aa   000022 7350 00	als  	18
000431  aa  5 00001 6751 00	era  	pr5|1		entry_desc_info.function
000432  aa   020000 3750 03	ana  	8192,du
000433  aa  5 00001 6551 00	ersa 	pr5|1		entry_desc_info.function
000434  aa  2 00000 2351 00	lda  	pr2|0		entry_sequence_w2.pad
000435  aa   000022 7350 00	als  	18
000436  aa  5 00001 6751 00	era  	pr5|1		entry_desc_info.pad
000437  aa   017777 3750 03	ana  	8191,du
000440  aa  5 00001 6551 00	ersa 	pr5|1		entry_desc_info.pad
						STATEMENT 1 ON LINE 153
	if bin (entry_sequence_w2.def_relp, 18) > oi.dlng then do;

000441  aa  2 00000 2351 00	lda  	pr2|0		entry_sequence_w2.def_relp
000442  aa  0 00044 3771 00	anaq 	pr0|36		= 777777000000 000000000000
000443  aa  6 00326 7551 00	sta  	pr6|214		entry_sequence_w2.def_relp
000444  aa   000066 7730 00	lrl  	54
000445  aa  6 00147 1161 00	cmpq 	pr6|103		oi.dlng
000446  aa   000005 6044 04	tmoz 	5,ic		000453
						STATEMENT 1 ON LINE 154
no_defs:	     code = error_table_$nodescr;

000447  aa  6 00044 3701 20	epp4 	pr6|36,*
000450  la  4 00010 2361 20	ldq  	pr4|8,*		error_table_$nodescr
000451  aa  6 00266 7561 20	stq  	pr6|182,*		code
						STATEMENT 1 ON LINE 155
	     return;

000452  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 156
	end;

						STATEMENT 1 ON LINE 157
	defp = addrel (oi.defp, entry_sequence_w2.def_relp);

000453  aa  6 00326 2351 00	lda  	pr6|214		entry_sequence_w2.def_relp
000454  aa  6 00134 3515 61	epp1 	pr6|92,*au	oi.defp
000455  aa   000000 0510 03	adwp1	0,du
000456  aa  6 00114 2515 00	spri1	pr6|76		defp
						STATEMENT 1 ON LINE 158
	if ^defp -> definition.new then go to no_defs;

000457  aa  1 00001 2351 00	lda  	pr1|1		definition.new
000460  aa   400000 3150 07	cana 	131072,dl
000461  aa   777766 6000 04	tze  	-10,ic		000447
						STATEMENT 1 ON LINE 159
	if ^defp -> definition.entry then go to no_defs;

000462  aa  1 00001 2351 00	lda  	pr1|1		definition.entry
000463  aa   100000 3150 07	cana 	32768,dl
000464  aa   777763 6000 04	tze  	-13,ic		000447
						STATEMENT 1 ON LINE 160
	nargs = 0;

000465  aa  7 00004 4501 20	stz  	pr7|4,*		nargs
						STATEMENT 1 ON LINE 162
common:
	if entry_sequence_w2.flags.revision_1		/* descr ptrs are in text if at all.		*/
	then do;

000466  aa  6 00126 2351 20	lda  	pr6|86,*		entry_sequence_w2.revision_1
000467  aa   200000 3150 07	cana 	65536,dl
000470  aa   000020 6000 04	tze  	16,ic		000510
						STATEMENT 1 ON LINE 165
	     if ^entry_sequence_w2.flags.has_descriptors then goto no_defs;

000471  aa  6 00126 2351 20	lda  	pr6|86,*		entry_sequence_w2.has_descriptors
000472  aa   100000 3150 07	cana 	32768,dl
000473  aa   777754 6000 04	tze  	-20,ic		000447
						STATEMENT 1 ON LINE 166
	     np = addrel (entry_ptr, -2);

000474  aa  6 00032 3735 20	epp7 	pr6|26,*
000475  aa  7 00002 3521 20	epp2 	pr7|2,*		entry_ptr
000476  aa  2 00000 3521 20	epp2 	pr2|0,*		entry_ptr
000477  aa   777776 0520 03	adwp2	262142,du
000500  aa  6 00112 2521 00	spri2	pr6|74		np
						STATEMENT 1 ON LINE 168
	     descpp =  addwordno (segptr, bin (np -> entry_sequence.descr_relp_offset));

000501  aa  2 00000 2351 00	lda  	pr2|0		entry_sequence.descr_relp_offset
000502  aa   000066 7730 00	lrl  	54
000503  aa  6 00110 3515 66	epp1 	pr6|72,*ql	segptr
000504  aa   000000 0510 03	adwp1	0,du
000505  aa  6 00122 2515 00	spri1	pr6|82		descpp
						STATEMENT 1 ON LINE 169
	     no_descrs = "0"b;

000506  aa  6 00105 4501 00	stz  	pr6|69		no_descrs
						STATEMENT 1 ON LINE 170
	end;

000507  aa   000023 7100 04	tra  	19,ic		000532
						STATEMENT 1 ON LINE 171
	else if defp ^= null then do;

000510  aa  6 00114 2371 00	ldaq 	pr6|76		defp
000511  aa   777313 6770 04	eraq 	-309,ic		000024 = 077777000043 000001000000
000512  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000513  aa   777425 6000 04	tze  	-235,ic		000140
						STATEMENT 1 ON LINE 172
	     if ^defp -> definition.argcount then go to no_defs;

000514  aa  6 00114 3735 20	epp7 	pr6|76,*		defp
000515  aa  7 00001 2351 00	lda  	pr7|1		definition.argcount
000516  aa   020000 3150 07	cana 	8192,dl
000517  aa   777730 6000 04	tze  	-40,ic		000447
						STATEMENT 1 ON LINE 173
	     if ^defp -> definition.descriptors
	     then no_descrs = "1"b;

000520  aa  7 00001 2351 00	lda  	pr7|1		definition.descriptors
000521  aa   010000 3150 07	cana 	4096,dl
000522  aa   000004 6010 04	tnz  	4,ic		000526
000523  aa   400000 2350 03	lda  	131072,du
000524  aa  6 00105 7551 00	sta  	pr6|69		no_descrs
000525  aa   000002 7100 04	tra  	2,ic		000527
						STATEMENT 1 ON LINE 175
	     else no_descrs = "0"b;

000526  aa  6 00105 4501 00	stz  	pr6|69		no_descrs
						STATEMENT 1 ON LINE 176
	     descpp = addrel(defp, size(definition));

000527  aa  7 00000 3521 00	epp2 	pr7|0
000530  aa   000003 0520 03	adwp2	3,du
000531  aa  6 00122 2521 00	spri2	pr6|82		descpp
						STATEMENT 1 ON LINE 177
	end;

						STATEMENT 1 ON LINE 184
	nargs = bin (descpp ->  parm_desc_ptrs.n_args);

000532  aa  6 00122 2351 20	lda  	pr6|82,*		parm_desc_ptrs.n_args
000533  aa   000066 7730 00	lrl  	54
000534  aa  6 00032 3735 20	epp7 	pr6|26,*
000535  aa  7 00004 7561 20	stq  	pr7|4,*		nargs
						STATEMENT 1 ON LINE 185
	num_descs = nargs;

000536  aa  6 00124 7561 00	stq  	pr6|84		num_descs
						STATEMENT 1 ON LINE 187
	if no_descrs then				/* No descriptors, but argcount was available.	*/
	     descps (*) = null;

000537  aa  6 00105 2351 00	lda  	pr6|69		no_descrs
000540  aa   000037 6000 04	tze  	31,ic		000577
000541  aa  6 00042 3715 20	epp5 	pr6|34,*
000542  aa  5 00004 3535 20	epp3 	pr5|4,*
000543  aa  3 00001 2361 00	ldq  	pr3|1
000544  aa   000001 1760 07	sbq  	1,dl
000545  aa  6 00326 7561 00	stq  	pr6|214
000546  aa  3 00002 2361 00	ldq  	pr3|2
000547  aa  6 00326 1761 00	sbq  	pr6|214
000550  aa  6 00326 7561 00	stq  	pr6|214
000551  aa   000001 2360 07	ldq  	1,dl
000552  aa  6 00270 7561 00	stq  	pr6|184
000553  aa   000000 0110 03	nop  	0,du
000554  aa  6 00042 3735 20	epp7 	pr6|34,*
000555  aa  7 00004 3715 20	epp5 	pr7|4,*
000556  aa  5 00003 2361 00	ldq  	pr5|3
000557  aa  5 00001 4021 00	mpy  	pr5|1
000560  aa  6 00273 7561 00	stq  	pr6|187
000561  aa  5 00001 2361 00	ldq  	pr5|1
000562  aa   000001 1760 07	sbq  	1,dl
000563  aa  6 00270 0761 00	adq  	pr6|184
000564  aa  5 00003 4021 00	mpy  	pr5|3
000565  aa  6 00273 1761 00	sbq  	pr6|187
000566  aa   000000 6270 06	eax7 	0,ql
000567  aa   777235 2370 04	ldaq 	-355,ic		000024 = 077777000043 000001000000
000570  aa  6 00032 3535 20	epp3 	pr6|26,*
000571  aa  3 00006 7571 77	staq 	pr3|6,*7		descps
000572  aa  6 00270 2361 00	ldq  	pr6|184
000573  aa  6 00270 0541 00	aos  	pr6|184
000574  aa  6 00326 1161 00	cmpq 	pr6|214
000575  aa   777757 6040 04	tmi  	-17,ic		000554
000576  aa   000044 7100 04	tra  	36,ic		000642
						STATEMENT 1 ON LINE 189
	else do i = 1 to min (nargs, hbound (descps, 1));

000577  aa  6 00042 3715 20	epp5 	pr6|34,*
000600  aa  5 00004 3535 20	epp3 	pr5|4,*
000601  aa  3 00002 1161 00	cmpq 	pr3|2
000602  aa   000002 6040 04	tmi  	2,ic		000604
000603  aa  3 00002 2361 00	ldq  	pr3|2
000604  aa  6 00271 7561 00	stq  	pr6|185
000605  aa   000001 2360 07	ldq  	1,dl
000606  aa  6 00100 7561 00	stq  	pr6|64		i
000607  aa   000000 0110 03	nop  	0,du
000610  aa  6 00100 2361 00	ldq  	pr6|64		i
000611  aa  6 00271 1161 00	cmpq 	pr6|185
000612  aa   000030 6054 04	tpnz 	24,ic		000642
						STATEMENT 1 ON LINE 192
	     descps (i) = addwordno (txp, bin (descpp -> parm_desc_ptrs.descriptor_relp (i)));

000613  aa  6 00042 3735 20	epp7 	pr6|34,*
000614  aa  7 00004 3715 20	epp5 	pr7|4,*
000615  aa  5 00003 2361 00	ldq  	pr5|3
000616  aa  5 00001 4021 00	mpy  	pr5|1
000617  aa  6 00326 7561 00	stq  	pr6|214
000620  aa  5 00003 2361 00	ldq  	pr5|3
000621  aa  6 00100 4021 00	mpy  	pr6|64		i
000622  aa  6 00326 1761 00	sbq  	pr6|214
000623  aa   000000 6270 06	eax7 	0,ql
000624  aa  6 00100 2361 00	ldq  	pr6|64		i
000625  aa   000022 4020 07	mpy  	18,dl
000626  aa  6 00122 3535 20	epp3 	pr6|82,*		descpp
000627  aa  003 100 060 506	csl  	(pr,ql),(pr),fill(0),bool(move)
000630  aa  3 00000 00 0022	descb	pr3|0,18		parm_desc_ptrs.descriptor_relp
000631  aa  6 00056 00 0044	descb	pr6|46,36
000632  aa  6 00056 2351 00	lda  	pr6|46
000633  aa   000066 7730 00	lrl  	54
000634  aa  6 00120 3521 66	epp2 	pr6|80,*ql	txp
000635  aa   000000 0520 03	adwp2	0,du
000636  aa  6 00032 3515 20	epp1 	pr6|26,*
000637  aa  1 00006 2521 77	spri2	pr1|6,*7		descps
						STATEMENT 1 ON LINE 193
	end;

000640  aa  6 00100 0541 00	aos  	pr6|64		i
000641  aa   777747 7100 04	tra  	-25,ic		000610
						STATEMENT 1 ON LINE 194
	return;

000642  aa  0 00631 7101 00	tra  	pr0|409		return_mac
ENTRY TO text_only_info                                     STATEMENT 1 ON LINE 198
text_only_info: entry (entry_ptr, nargs, descps, entry_desc_info_ptr, code);

000643  ta     000046000000
000644  da     000153300000
000645  aa   000340 6270 00	eax7 	224
000646  aa  7 00034 3521 20	epp2 	pr7|28,*
000647  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
000650  aa     000012000000
000651  aa     000000000000
000652  aa  6 00032 3735 20	epp7 	pr6|26,*
000653  aa  7 00012 3715 20	epp5 	pr7|10,*
000654  aa  6 00266 6515 00	spri5	pr6|182
000655  aa   777165 7000 04	tsx0 	-395,ic		000042
						STATEMENT 1 ON LINE 200
 	ret_info = "1"b;

000656  aa   400000 2350 03	lda  	131072,du
000657  aa  6 00106 7551 00	sta  	pr6|70		ret_info
						STATEMENT 1 ON LINE 201
	if entry_desc_info.version ^= entry_desc_info_version_1 &
	   entry_desc_info.version ^= entry_desc_info_version_2  then do;

000660  aa  6 00032 3735 20	epp7 	pr6|26,*
000661  aa  7 00010 3715 20	epp5 	pr7|8,*		entry_desc_info_ptr
000662  aa  5 00000 2361 20	ldq  	pr5|0,*		entry_desc_info.version
000663  aa   000001 1160 07	cmpq 	1,dl
000664  aa   000007 6000 04	tze  	7,ic		000673
000665  aa   000002 1160 07	cmpq 	2,dl
000666  aa   000005 6000 04	tze  	5,ic		000673
						STATEMENT 1 ON LINE 203
	     code = error_table_$unimplemented_version;

000667  aa  6 00044 3701 20	epp4 	pr6|36,*
000670  la  4 00016 2361 20	ldq  	pr4|14,*		error_table_$unimplemented_version
000671  aa  6 00266 7561 20	stq  	pr6|182,*		code
						STATEMENT 1 ON LINE 204
	     return;

000672  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 205
	     end;

						STATEMENT 1 ON LINE 206
	entry_desc_info.flags = "0"b;

000673  aa   000206 2350 04	lda  	134,ic		001101 = 377777777777
000674  aa  5 00000 3535 20	epp3 	pr5|0,*		entry_desc_info_ptr
000675  aa  3 00001 3551 00	ansa 	pr3|1		entry_desc_info.basic_indicator
000676  aa   000202 2350 04	lda  	130,ic		001100 = 577777777777
000677  aa  3 00001 3551 00	ansa 	pr3|1		entry_desc_info.revision_1
000700  aa   000177 2350 04	lda  	127,ic		001077 = 677777777777
000701  aa  3 00001 3551 00	ansa 	pr3|1		entry_desc_info.has_descriptors
000702  aa   000174 2350 04	lda  	124,ic		001076 = 737777777777
000703  aa  3 00001 3551 00	ansa 	pr3|1		entry_desc_info.variable
000704  aa   000171 2350 04	lda  	121,ic		001075 = 757777777777
000705  aa  3 00001 3551 00	ansa 	pr3|1		entry_desc_info.function
000706  aa   000166 2350 04	lda  	118,ic		001074 = 760000777777
000707  aa  3 00001 3551 00	ansa 	pr3|1		entry_desc_info.pad
						STATEMENT 1 ON LINE 209
text_only: entry (entry_ptr, nargs, descps, code);

000710  aa   000014 7100 04	tra  	12,ic		000724
ENTRY TO text_only                                          STATEMENT 1 ON LINE 209
text_only: entry (entry_ptr, nargs, descps, code);

000711  ta     000117000000
000712  da     000161300000
000713  aa   000340 6270 00	eax7 	224
000714  aa  7 00034 3521 20	epp2 	pr7|28,*
000715  aa  2 01046 2721 00	tsp2 	pr2|550		ext_entry_desc
000716  aa     000010000000
000717  aa     000000000000
000720  aa  6 00032 3735 20	epp7 	pr6|26,*
000721  aa  7 00010 3715 20	epp5 	pr7|8,*
000722  aa  6 00266 6515 00	spri5	pr6|182
000723  aa   777117 7000 04	tsx0 	-433,ic		000042
						STATEMENT 1 ON LINE 213
	code = 0;

000724  aa  6 00266 4501 20	stz  	pr6|182,*		code
						STATEMENT 1 ON LINE 214
	nargs = -1;

000725  aa   000001 3360 07	lcq  	1,dl
000726  aa  6 00032 3735 20	epp7 	pr6|26,*
000727  aa  7 00004 7561 20	stq  	pr7|4,*		nargs
						STATEMENT 1 ON LINE 215
	defp = null;

000730  aa   777074 2370 04	ldaq 	-452,ic		000024 = 077777000043 000001000000
000731  aa  6 00114 7571 00	staq 	pr6|76		defp
						STATEMENT 1 ON LINE 216
	txp = ptr (entry_ptr, 0);

000732  aa  7 00002 3521 20	epp2 	pr7|2,*		entry_ptr
000733  aa  2 00000 3525 20	epbp2	pr2|0,*		entry_ptr
000734  aa  6 00120 2521 00	spri2	pr6|80		txp
						STATEMENT 1 ON LINE 217
	if bin (rel (entry_ptr), 18) = 0 then go to no_defs;

000735  aa  7 00002 3715 20	epp5 	pr7|2,*		entry_ptr
000736  aa  5 00000 3715 20	epp5 	pr5|0,*		entry_ptr
000737  aa  5 00000 6351 00	eaa  	pr5|0		entry_ptr
000740  aa   000066 7730 00	lrl  	54
000741  aa   777506 6000 04	tze  	-186,ic		000447
						STATEMENT 1 ON LINE 222
	entry_sequence_w2p = addrel (entry_ptr, -1);

000742  aa   777777 1510 03	adwp5	262143,du
000743  aa  6 00126 6515 00	spri5	pr6|86		entry_sequence_w2p
						STATEMENT 1 ON LINE 224
	if ret_info
	then entry_desc_info.flags = entry_sequence_w2.flags;

000744  aa  6 00106 2351 00	lda  	pr6|70		ret_info
000745  aa   777521 6000 04	tze  	-175,ic		000466
000746  aa  5 00000 2351 00	lda  	pr5|0		entry_sequence_w2.basic_indicator
000747  aa   000022 7350 00	als  	18
000750  aa  7 00010 3535 20	epp3 	pr7|8,*		entry_desc_info_ptr
000751  aa  3 00000 3535 20	epp3 	pr3|0,*		entry_desc_info_ptr
000752  aa  3 00001 6751 00	era  	pr3|1		entry_desc_info.basic_indicator
000753  aa  0 00002 3751 00	ana  	pr0|2		= 400000000000
000754  aa  3 00001 6551 00	ersa 	pr3|1		entry_desc_info.basic_indicator
000755  aa  5 00000 2351 00	lda  	pr5|0		entry_sequence_w2.revision_1
000756  aa   000022 7350 00	als  	18
000757  aa  3 00001 6751 00	era  	pr3|1		entry_desc_info.revision_1
000760  aa   200000 3750 03	ana  	65536,du
000761  aa  3 00001 6551 00	ersa 	pr3|1		entry_desc_info.revision_1
000762  aa  5 00000 2351 00	lda  	pr5|0		entry_sequence_w2.has_descriptors
000763  aa   000022 7350 00	als  	18
000764  aa  3 00001 6751 00	era  	pr3|1		entry_desc_info.has_descriptors
000765  aa   100000 3750 03	ana  	32768,du
000766  aa  3 00001 6551 00	ersa 	pr3|1		entry_desc_info.has_descriptors
000767  aa  5 00000 2351 00	lda  	pr5|0		entry_sequence_w2.variable
000770  aa   000022 7350 00	als  	18
000771  aa  3 00001 6751 00	era  	pr3|1		entry_desc_info.variable
000772  aa   040000 3750 03	ana  	16384,du
000773  aa  3 00001 6551 00	ersa 	pr3|1		entry_desc_info.variable
000774  aa  5 00000 2351 00	lda  	pr5|0		entry_sequence_w2.function
000775  aa   000022 7350 00	als  	18
000776  aa  3 00001 6751 00	era  	pr3|1		entry_desc_info.function
000777  aa   020000 3750 03	ana  	8192,du
001000  aa  3 00001 6551 00	ersa 	pr3|1		entry_desc_info.function
001001  aa  5 00000 2351 00	lda  	pr5|0		entry_sequence_w2.pad
001002  aa   000022 7350 00	als  	18
001003  aa  3 00001 6751 00	era  	pr3|1		entry_desc_info.pad
001004  aa   017777 3750 03	ana  	8191,du
001005  aa  3 00001 6551 00	ersa 	pr3|1		entry_desc_info.pad
						STATEMENT 1 ON LINE 226
	go to common;

001006  aa   777460 7100 04	tra  	-208,ic		000466
						STATEMENT 1 ON LINE 250
     end get_entry_arg_descs_$info;

BEGIN PROCEDURE catch
ENTRY TO catch                                              STATEMENT 1 ON LINE 228
catch:	proc (mcptr, condname, wcptr, infoptr, continue);

001007  da     000166200000
001010  aa   000120 6270 00	eax7 	80
001011  aa  7 00034 3521 20	epp2 	pr7|28,*
001012  aa  2 01050 2721 00	tsp2 	pr2|552		int_entry_desc
001013  aa     000012000000
001014  aa     000000000000
001015  aa  6 00042 3735 20	epp7 	pr6|34,*
001016  aa  7 00002 2361 20	ldq  	pr7|2,*
001017  aa   000002 6040 04	tmi  	2,ic		001021
001020  aa   777777 3760 07	anq  	262143,dl
001021  aa  0 00250 3761 00	anq  	pr0|168		= 000077777777
001022  aa  6 00100 7561 00	stq  	pr6|64
						STATEMENT 1 ON LINE 234
	     if condname = "quit" then go to pass;

001023  aa  6 00032 3715 20	epp5 	pr6|26,*
001024  aa  5 00004 3535 20	epp3 	pr5|4,*
001025  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
001026  aa  3 00000 00 0006	desc9a	pr3|0,ql		condname
001027  aa   776756 00 0004	desc9a	-530,4		000003 = 161165151164
001030  aa   000031 6000 04	tze  	25,ic		001061
						STATEMENT 1 ON LINE 235
	     if condname = "alrm" then go to pass;

001031  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
001032  aa  3 00000 00 0006	desc9a	pr3|0,ql		condname
001033  aa   776751 00 0004	desc9a	-535,4		000002 = 141154162155
001034  aa   000025 6000 04	tze  	21,ic		001061
						STATEMENT 1 ON LINE 236
	     if condname = "cput" then go to pass;

001035  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
001036  aa  3 00000 00 0006	desc9a	pr3|0,ql		condname
001037  aa   776744 00 0004	desc9a	-540,4		000001 = 143160165164
001040  aa   000021 6000 04	tze  	17,ic		001061
						STATEMENT 1 ON LINE 237
	     if condname = "program_interrupt" then go to pass;

001041  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
001042  aa  3 00000 00 0006	desc9a	pr3|0,ql		condname
001043  aa   776774 00 0021	desc9a	-516,17		000035 = 160162157147
001044  aa   000015 6000 04	tze  	13,ic		001061
						STATEMENT 1 ON LINE 238
	     if condname = "finish" then go to pass;

001045  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
001046  aa  3 00000 00 0006	desc9a	pr3|0,ql		condname
001047  aa   776753 00 0006	desc9a	-533,6		000020 = 146151156151
001050  aa   000011 6000 04	tze  	9,ic		001061
						STATEMENT 1 ON LINE 239
	     if condname = "storage" then go to pass;

001051  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
001052  aa  3 00000 00 0006	desc9a	pr3|0,ql		condname
001053  aa   776745 00 0007	desc9a	-539,7		000016 = 163164157162
001054  aa   000005 6000 04	tze  	5,ic		001061
						STATEMENT 1 ON LINE 240
	     if condname = "mme2" then do;

001055  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
001056  aa  3 00000 00 0006	desc9a	pr3|0,ql		condname
001057  aa   776723 00 0004	desc9a	-557,4		000000 = 155155145062
001060  aa   000004 6010 04	tnz  	4,ic		001064
						STATEMENT 1 ON LINE 241
pass:		continue = "1"b;

001061  aa   400000 2350 03	lda  	131072,du
001062  aa  5 00012 7551 20	sta  	pr5|10,*		continue
						STATEMENT 1 ON LINE 242
		return;

001063  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 243
	     end;

						STATEMENT 1 ON LINE 245
	     if condname ^= "cleanup" then go to no_defs;

001064  aa  040 004 106 540	cmpc 	(pr,rl),(ic),fill(040)
001065  aa  3 00000 00 0006	desc9a	pr3|0,ql		condname
001066  aa   776730 00 0007	desc9a	-552,7		000014 = 143154145141
001067  aa   000004 6000 04	tze  	4,ic		001073
001070  aa   777357 3520 04	epp2 	-273,ic		000447 = 600044370120
001071  aa   000001 7270 07	lxl7 	1,dl
001072  aa  0 00657 7101 00	tra  	pr0|431		tra_ext_1
						STATEMENT 1 ON LINE 247
	     return;

001073  aa  0 00631 7101 00	tra  	pr0|409		return_mac
						STATEMENT 1 ON LINE 248
	end catch;

  END PROCEDURE catch
  END PROCEDURE get_entry_arg_descs_$info


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
