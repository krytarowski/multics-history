	COMPILATION LISTING OF SEGMENT change_record_list
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/04/82  1731.5 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* The initial design and implementation of this program was
       12*   by M. D. MacLaren (1974) */
       13 /* All changes since 1975 by M. Asherman:
       14*   Modified to support recovery from interruptions.
       15*   Extended to support stationary type records.
       16*   Modified to avoid wasting first two words of each record component.
       17*   Extended to support transaction mode updates.
       18*   Changed for new comp_array format in file header to avoid csl's. */
       19 /* the following conventions must be observed in manipulating the
       20*   file statistics giving the number_of_allocated_records and the
       21*   number_of_free_blocks:
       22*
       23*   fs_ptr->number_of_free_blocks is reconstructed, using the protected
       24*   variable old_number_of_free_blocks in the allocation logic, and
       25*   using the protected variable old_num_free in the freeing logic.
       26*
       27*   fs_ptr->number_of_allocated_records is always protected.
       28*
       29*   the alternate state statistics are always reconstructed. */
       30 change_record_list:
       31      proc (iocb_ptr, record_action, buff_ptr, abort_exit);
       32 	indx_cb_ptr = iocb_ptr -> iocb.open_data_ptr;
       33 	f_b_ptr = file_base_ptr;
       34 	fs_ptr = indx_cb.file_state_ptr;
       35 	os_ptr = indx_cb.o_s_ptr;
       36 	if record_action = allocate_action
       37 	then do;
       38 		header_size = 2;
       39 		call set_required_block_size;
       40 		call allocate;
       41 		if ^indx_cb.repeating		/* non-recovery execution */
       42 		then addr (seg_array (block_offset)) -> excess_words = required_block_size - needed_block_size;
       43 						/* save min block size info for later
       44*						   attempt to replace tail in compact form */
       45 	     end;
       46 	else if record_action = free_action
       47 	then do;					/* get rid of preceding allocation */
       48 		call find_new_ind_block;		/* locate after image block */
       49 		call free;			/* disposes of allocation */
       50 	     end;					/* done with cleaning up interrupted stat rewrite */
       51 	else if record_action = insert_action
       52 	then if ^file_base.was_stat			/* non-stationary record */
       53 	     then do;				/* requires smaller block header in this case */
       54 		     header_size = 2;		/* block size and record length words */
       55 		     call set_required_block_size;
       56 		     call allocate;			/* finds available block of sufficient size */
       57 		end;
       58 	     else do;				/* make a new stationary record */
       59 		     header_size = stat_header_size;	/* reserve space for lock and counts */
       60 		     call set_required_block_size;
       61 		     call allocate;
       62 		     if ^indx_cb.repeating		/* non-recovery execution */
       63 		     then do;			/* mark record as such */
       64 			     stat_block.ref_count = file_base.old_ref_count;
       65 						/* for initial key or ref count in record_status */
       66 			     block_head.stationary = "1"b;
       67 						/* keeps descriptor valid during rewrites */
       68 			     if file_base.was_transaction
       69 			     then do;
       70 				     stat_block.ref_count_after = file_base.old_ref_count;
       71 				     stat_block.ind_comp = new_rec_des.comp_num;
       72 				     time_stamp_struct.ind_offset = new_rec_des.offset;
       73 				     stat_block.prev_mod = -3;
       74 						/* signifies pre-creation */
       75 				end;
       76 			     else stat_block.time_stamp_words = clock ();
       77 			end;
       78 		end;
       79 	else do;
       80 		call find_old_block;
       81 		if record_action = delete_action
       82 		then if ^file_base.was_stat
       83 		     then call free;		/* completely dispose of record allocation */
       84 		     else do;			/* logically delete the record, but leave around until ref_count diminishes */
       85 			     if ^file_base.is_partial_deletion & ^file_base.out_of_index
       86 						/* key also deleted */
       87 			     then do;
       88 				     new_count = file_base.old_ref_count - 1;
       89 						/* will decrement for
       90*						   deleted key pointing to this record */
       91 				     if ^indx_cb.repeating
       92 						/* protect during recovery */
       93 				     then ind_head.ref_count = new_count;
       94 				end;
       95 			     else new_count = file_base.old_ref_count;
       96 						/* count stays the same */
       97 			     if ^indx_cb.repeating	/* not recovery case */
       98 			     then do;		/* otherwise allocation is protected */
       99 				     block_head.after_applies = "1"b;
      100 				     time_stamp_struct.time_last_modified = clock ();
      101 				     ind_head.prev_desc = -1;
      102 						/* stands for logical deletion */
      103 				     ind_head.prev_mod = file_base.old_modifier;
      104 				     block_head.indirect = "1"b;
      105 				     block_head.after_applies = "0"b;
      106 				end;
      107 			     if file_base.was_ind	/* already in indirect form */
      108 			     then do;		/* dispose of indirect allocation, if any */
      109 				     if file_base.old_ind_desc > 0
      110 						/* additional block does exist */
      111 				     then do;
      112 					     call find_old_ind_block;
      113 					     call free;
      114 					     os_ptr -> number_of_allocated_records = number_of_allocated_records;
      115 						/* don't count ind block as separate */
      116 					end;
      117 				     if new_count <= 0
      118 						/* no more references to this record */
      119 				     then do;	/* dispose of entirely */
      120 					     call find_old_block;
      121 						/* locate fixed portion */
      122 					     call free;
      123 						/* garbage collect */
      124 					end;
      125 				     else os_ptr -> number_of_allocated_records = number_of_allocated_records;
      126 				end;
      127 			     else if new_count <= 0	/* no more references to this compact stat record */
      128 			     then call free;	/* can completely dispose of */
      129 			     else do;		/* logically delete a compact stationary record */
      130 				     required_block_size = minimum_block_size;
      131 				     residue = file_base.prior_block_size - minimum_block_size;
      132 				     go to check_tail;
      133 				end;
      134 			end;
      135 		else do;				/* replace action */
      136 						/* replace the current record image, using
      137*						   buffer pointed to by buff_ptr arg
      138*						   for the case of non-stationary records */
      139 			if ^file_base.was_stat	/* non-stationary type record */
      140 			then do;			/* rewrite a movable record */
      141 				header_size = 2;
      142 				call set_required_block_size;
      143 				residue = prior_block_size - required_block_size;
      144 				if residue < 0
      145 				then do;		/* get a new block */
      146 					call allocate;
      147 					call find_old_block;
      148 						/* restore former location */
      149 					call free;
      150 				     end;
      151 				else do;		/* use old block */
      152 					new_descriptor = old_record_designator;
      153 					block_head.lock_flag = "1"b;
      154 						/* in case of record level synch */
      155 					call copy_buffer;
      156 						/* must do before touching residue */
      157 check_tail:
      158 					if residue >= minimum_block_size
      159 					then do;	/* use first part of block and free residual space */
      160 						if ^indx_cb.repeating
      161 						/* not recovery case */
      162 						then do;
      163 						/* otherwise protect block header */
      164 							block_head.block_size = required_block_size;
      165 						/* make residue allocated block and free it */
      166 							block_offset = block_offset + required_block_size;
      167 							seg_array (block_offset) = 0;
      168 						/* clear flags and first word stuff */
      169 							block_head.block_size = residue;
      170 						     end;
      171 						/* this can't be repeated since the
      172*						   free logic is not repeatable, and it
      173*						   involves subsequent changes to these same
      174*						   locations; i.e. we must consistently
      175*						   protect these values, since we have
      176*						   chosen not to reconstruct them during
      177*						   recovery execution */
      178 						else block_offset = block_offset + required_block_size;
      179 						call free;
      180 					     end;
      181 				     end;
      182 			     end;			/* end of non-stat rewrite case */
      183 
      184 			else /* rewrite a stationary record */
      185 			     /* replace the current image with that pointed
      186*						   to by new_descriptor */
      187 			     if file_base.was_transaction
      188 						/* transaction */
      189 			then if (^file_base.was_ind) & (file_base.old_prev_mod = -3)
      190 						/* compact, pre-created record */
      191 			     then go to compact_case; /* replace after image in compact tail */
      192 			     else do;		/* replace new indirect image */
      193 				     call find_old_ind_block;
      194 						/* locate old new contents */
      195 				     call free;	/* dispose of previous after-image */
      196 				end;
      197 			else if file_base.was_ind	/* indirect record */
      198 			then do;
      199 				block_head.after_applies = "1"b;
      200 				time_stamp_struct.time_last_modified = clock ();
      201 				ind_head.prev_mod = file_base.old_modifier;
      202 				ind_head.prev_desc = file_base.new_descriptor;
      203 				block_head.after_applies = "0"b;
      204 				if file_base.old_ind_desc ^= 0
      205 						/* old block existed */
      206 				then do;		/* dispose of old indirect block */
      207 					call find_old_ind_block;
      208 					call free;/* de-allocates */
      209 				     end;
      210 			     end;			/* end of indirect record rewrite logic */
      211 			else do;			/* rewrite compact stationary type record */
      212 compact_case:
      213 				if file_base.new_descriptor > 0
      214 				then do;
      215 					block_ptr = addr (seg_array (block_offset));
      216 					record_ptr = addr (seg_array (block_offset + stat_header_size - 1));
      217 					call find_new_ind_block;
      218 						/* after image */
      219 					call save_needed_blksz;
      220 					required_block_size = file_base.needed_blksz;
      221 					if (file_base.prior_block_size
      222 					     >= required_block_size /* old alloc big enough */)
      223 					then do;	/* copy back into initial block */
      224 						if ^indx_cb.repeating
      225 						then if file_base.was_transaction
      226 						     then do;
      227 						/* replace compact after image */
      228 							     record_head.record_length =
      229 								file_base.new_record_length;
      230 							     record_head.record =
      231 								addr (seg_array (block_offset + 1))
      232 								-> record_head.record;
      233 							end;
      234 						     else do;
      235 						/* non-TP case */
      236 							     block_ptr -> block_head.after_applies = "1"b;
      237 							     addr (block_ptr -> stat_block.time_stamp_words)
      238 								-> time_stamp_struct.time_last_modified =
      239 								clock ();
      240 							     record_head.record_length =
      241 								file_base.new_record_length;
      242 							     record_head.record =
      243 								addr (seg_array (block_offset + 1))
      244 								-> record_head.record;
      245 						/* copy back into old */
      246 							     block_ptr -> stat_block.prev_mod =
      247 								file_base.old_modifier;
      248 							     block_ptr -> block_head.after_applies = "0"b;
      249 							     addr (block_ptr -> stat_block.time_stamp_words)
      250 								-> time_stamp_struct.time_last_modified =
      251 								clock ();
      252 							end;
      253 						call free;
      254 						/* deallocate after image */
      255 						call find_old_block;
      256 						/* back to header */
      257 						residue = file_base.prior_block_size - required_block_size;
      258 						go to check_tail;
      259 						/* see how much extra */
      260 					     end; /* record left in compact form */
      261 					else call find_old_block;
      262 						/* back to header */
      263 				     end;
      264 						/* convert compact record into
      265*						   indirect form */
      266 				if file_base.was_transaction
      267 				then do;		/* replace after image under TP */
      268 						/* record was created in this
      269*						   transaction, and is being
      270*						   subsequently rewritten, deleted,
      271*						   or rolled back */
      272 					ind_head.prev_desc = -1;
      273 					block_head.indirect = "1"b;
      274 				     end;
      275 				else do;		/* called by rewrite or checkpoint  logic */
      276 					block_head.after_applies = "1"b;
      277 					time_stamp_struct.time_last_modified = clock ();
      278 					ind_head.prev_desc = file_base.new_descriptor;
      279 					block_head.indirect = "1"b;
      280 					stat_block.prev_mod = file_base.old_modifier;
      281 					block_head.after_applies = "0"b;
      282 				     end;
      283 				required_block_size = minimum_block_size;
      284 				residue = file_base.prior_block_size - minimum_block_size;
      285 						/* tail of init block */
      286 				go to check_tail;	/* free tail, if large enough */
      287 			     end;
      288 			os_ptr -> number_of_allocated_records = number_of_allocated_records;
      289 		     end;
      290 	     end;
      291 	os_ptr -> number_of_free_blocks = number_of_free_blocks;
      292 	return;					/* end main code */
      293 
      294 find_old_block:
      295      proc;					/* locate previously existing record */
      296 	comp_num = old_rec_des.comp_num;
      297 	seg_ptr = seg_ptr_array (comp_num);
      298 	block_offset = fixed (old_rec_des.offset, 18);
      299      end find_old_block;
      300 
      301 find_new_ind_block:
      302      proc;					/* locates newly allocated image block */
      303 	comp_num = new_rec_des.comp_num;		/* locate the new allocation */
      304 	block_offset = fixed (new_rec_des.offset, 18);
      305 	seg_ptr = seg_ptr_array (comp_num);		/* logic of rewrite guarantees
      306*						   that this comp is initiated */
      307      end find_new_ind_block;
      308 
      309 find_old_ind_block:
      310      proc;					/* finds old indirect allocation */
      311 	comp_num = old_ind_des.comp_num;
      312 	seg_ptr = seg_ptr_array (comp_num);
      313 	block_offset = fixed (old_ind_des.offset, 18);
      314      end find_old_ind_block;
      315 
      316 set_required_block_size:
      317      proc;
      318 	min_recl = max (file_base.saved_min_cap, new_record_length + file_base.saved_min_res);
      319 	needed_block_size = header_size + 2 * divide (min_recl + 7, 8, 18, 0);
      320 	required_block_size = max (minimum_block_size, needed_block_size);
      321      end set_required_block_size;
      322 
      323 save_needed_blksz:
      324      proc;
      325 	if indx_cb.repeating
      326 	then do;
      327 		call check_file_substate;
      328 		return;
      329 	     end;
      330 	file_base.needed_blksz =
      331 	     6 + addr (seg_array (block_offset)) -> block_head.block_size
      332 	     - addr (seg_array (block_offset)) -> block_head.excess_words;
      333 						/* enforce min block size */
      334 	file_substate = file_substate + 1;
      335      end save_needed_blksz;
      336 
      337 allocate:
      338      proc;					/* grabs a block of space from the free list */
      339 	call find_free_block;
      340 	if need_new_seg
      341 	then do;
      342 		call use_new_segment;		/* creates new component if necessary */
      343 		if indx_cb.repeating		/* recovery in progress */
      344 		then return;			/* protect permanent file variables */
      345 	     end;
      346 	else do;					/* allocate block of space in existing segment */
      347 		rover_seg_ptr = seg_ptr;
      348 		old_rover_comp_num = comp_num;
      349 		if indx_cb.repeating
      350 		then return;			/* protect state during recovery execution */
      351 		rover_comp_num = comp_num;
      352 		is_this_block_free = "0"b;
      353 		if residue < minimum_block_size
      354 		then call allocate_whole_block;
      355 		else call allocate_part_block;	/* frees the residue */
      356 	     end;
      357 	os_ptr -> number_of_allocated_records = number_of_allocated_records + 1;
      358 
      359 copy_buffer:
      360      entry;					/* does the assignment of the record's contents */
      361 	block_offset = fixed (new_rec_des.offset);	/* locate allocated record block */
      362 	record_ptr = addr (seg_array (block_offset + header_size - 1));
      363 	record_head.record_length = new_record_length;	/* set len in block header */
      364 	if buff_ptr ^= null
      365 	then record_head.record = buffer;		/* does the assignment */
      366 	else if block_head.block_size > header_size	/* room for record contents */
      367 	then do;					/* just zero first and last words, in case non-zero */
      368 		seg_array (block_offset + header_size) = 0;
      369 						/* free list thread word */
      370 		seg_array (block_offset + block_head.block_size - 1) = 0;
      371 						/* free block size tail word */
      372 	     end;
      373 	return;					/* end of allocate code */
      374 
      375 find_free_block:
      376      proc;					/* searches free list for block of sufficient size */
      377 	if repeating
      378 	then do;					/* restore non-permanent vars and skip search */
      379 		call check_file_substate;
      380 		comp_num = new_rec_des.comp_num;
      381 		block_offset = fixed (new_rec_des.offset);
      382 		residue = old_residue;
      383 		seg_ptr = get_seg_ptr (iocb_ptr, comp_num);
      384 		return;
      385 	     end;
      386 	need_new_seg = "0"b;			/* will be set if no adequate block */
      387 	seg_ptr = rover_seg_ptr;
      388 	comp_num = rover_comp_num;
      389 	block_offset = rover_offset;
      390 	file_base.old_number_of_free_blocks = number_of_free_blocks;
      391 	search_not_done = "1"b;
      392 	do while (search_not_done);			/* look for suitable block */
      393 	     if block_offset = 0			/* indicates segment is full */
      394 	     then do;				/* try another component */
      395 		     comp_num = comp_link (comp_num);
      396 		     block_offset = init_offset (comp_num);
      397 		     seg_ptr = get_seg_ptr (iocb_ptr, comp_num);
      398 		     go to check_rover;		/* give up search if at starting point */
      399 		end;
      400 	     else do;				/* check this block's size */
      401 		     block_offset = non_neg (block_offset);
      402 		     residue = block_head.block_size - required_block_size;
      403 		     if residue >= 0
      404 		     then do;			/* satisfactory block found */
      405 			     new_rec_des.comp_num = comp_num;
      406 			     new_rec_des.offset = bit (block_offset);
      407 			     old_prev_free_block = prev_free_block;
      408 						/* save for recovery */
      409 			     old_next_free_block = next_free_block;
      410 			     old_residue = residue;
      411 			     search_not_done = "0"b;
      412 			end;
      413 		     else do;			/* block too small -- try next on list */
      414 			     block_offset = next_free_block;
      415 check_rover:
      416 			     if block_offset = rover_offset
      417 			     then if comp_num = rover_comp_num
      418 				then do;		/* back at start--search failed */
      419 					new_rec_des.comp_num = last_comp_num + 1;
      420 					new_rec_des.offset = "0"b;
      421 					need_new_seg = "1"b;
      422 					search_not_done = "0"b;
      423 				     end;
      424 			end;
      425 		end;
      426 	end;
      427 	file_substate = file_substate + 1;
      428 	dcl     search_not_done	 bit (1) aligned;
      429      end find_free_block;
      430 
      431 use_new_segment:
      432      proc;					/* finds new component and allocates record block */
      433 	comp_num = new_rec_des.comp_num;
      434 	call get_new_seg (iocb_ptr, comp_num, seg_ptr, file_substate, abort_exit);
      435 	block_offset = 0;
      436 	old_rover_comp_num = comp_num;
      437 	rover_seg_ptr = seg_ptr;
      438 	call set_new_comp_link;
      439 	if indx_cb.repeating			/* recovery case */
      440 	then return;				/* protect state */
      441 	comp_link (0) = comp_num;
      442 	residue = max_seg_limit - required_block_size - block_offset;
      443 	if residue < minimum_block_size		/* use whole seg */
      444 	then do;
      445 		block_head.block_size = max_seg_limit;	/* whole segment is allocated block */
      446 		seg_limit (comp_num) = max_seg_limit;
      447 		init_offset (comp_num) = 0;
      448 		rover_offset = 0;
      449 	     end;
      450 	else do;
      451 		block_head.block_size = required_block_size;
      452 		block_offset = required_block_size + block_offset;
      453 		is_preceding_block_free = "0"b;
      454 		is_this_block_free = "1"b;
      455 		block_head.block_size = residue;
      456 		next_free_block = 0;
      457 		prev_free_block = 0;
      458 		init_offset (comp_num) = block_offset;
      459 		rover_offset = block_offset;
      460 		seg_limit (comp_num) = block_offset + size (block_head);
      461 		number_of_free_blocks = old_number_of_free_blocks + 1;
      462 	     end;
      463      end use_new_segment;
      464 
      465 set_new_comp_link:
      466      proc;
      467 	if repeating
      468 	then do;
      469 		call check_file_substate;
      470 		return;
      471 	     end;
      472 	is_preceding_block_free = "0"b;
      473 	is_this_block_free = "0"b;
      474 	rover_comp_num = comp_num;
      475 	comp_link (comp_num) = comp_link (0);
      476 	file_substate = file_substate + 1;
      477      end;
      478 
      479 allocate_whole_block:
      480      proc;					/* uses entire block for new record */
      481 	rover_offset = old_next_free_block;
      482 	if old_prev_free_block ^= 0
      483 	then addr (seg_array (non_neg (old_prev_free_block))) -> next_free_block = old_next_free_block;
      484 	else init_offset (comp_num) = old_next_free_block;
      485 	if old_next_free_block ^= 0
      486 	then addr (seg_array (non_neg (old_next_free_block))) -> prev_free_block = old_prev_free_block;
      487 	following_block_offset = block_offset + block_head.block_size;
      488 	if following_block_offset = max_seg_limit
      489 	then seg_limit (comp_num) = max_seg_limit;	/* allocating last block in segment */
      490 	else addr (seg_array (following_block_offset)) -> is_preceding_block_free = "0"b;
      491 						/* set block end */
      492 	number_of_free_blocks = old_number_of_free_blocks - 1;
      493      end allocate_whole_block;
      494 
      495 allocate_part_block:
      496      proc;					/* allocates first part and frees the residual space */
      497 	residue_offset = block_offset + required_block_size;
      498 	rover_offset = residue_offset;
      499 						/* Set links in residue and free block list */
      500 	if old_prev_free_block ^= 0
      501 	then addr (seg_array (non_neg (old_prev_free_block))) -> next_free_block = residue_offset;
      502 	else init_offset (comp_num) = residue_offset;
      503 	if old_next_free_block ^= 0
      504 	then addr (seg_array (non_neg (old_next_free_block))) -> prev_free_block = residue_offset;
      505 	addr (seg_array (residue_offset)) -> prev_free_block = old_prev_free_block;
      506 	addr (seg_array (residue_offset)) -> next_free_block = old_next_free_block;
      507 	block_head.block_size = required_block_size;
      508 						/* set header info for residue of block */
      509 	block_offset = residue_offset;
      510 	is_preceding_block_free = "0"b;
      511 	is_this_block_free = "1"b;
      512 	block_head.block_size = residue;
      513 						/* set block end */
      514 	following_block_offset = block_offset + residue;
      515 	if following_block_offset = max_seg_limit
      516 	then seg_limit (comp_num) = block_offset + size (block_head);
      517 	else seg_array (following_block_offset - 1) = residue;
      518      end allocate_part_block;
      519 
      520 	dcl     residue		 fixed (19);
      521 	dcl     residue_offset	 fixed (18);
      522      end allocate;
      523 
      524 free:
      525      proc;					/* places new block onto the free list */
      526 	call save_old_vars;
      527 	call make_free;				/* does the work in protected procedure--in case called twice */
      528 	return;					/* end of free routine */
      529 
      530 make_free:
      531      proc;
      532 	if repeating
      533 	then do;
      534 		call check_file_substate;
      535 		return;
      536 	     end;
      537 	if prec_block_was_free
      538 	then call merge_preceding_block;
      539 	else call free_this_block;
      540 	if following_block_offset = max_seg_limit
      541 	then seg_limit (comp_num) = block_offset + size (block_head);
      542 						/* last block in segment--set new seg_limit */
      543 	else do;					/* take care of next block */
      544 		p = addr (seg_array (following_block_offset));
      545 		if next_block_was_free
      546 		then call merge_next_block;
      547 		else do;				/* set next block's prior block info */
      548 			p -> is_preceding_block_free = "1"b;
      549 			seg_array (following_block_offset - 1) = former_block_size;
      550 		     end;
      551 	     end;
      552 	number_of_free_blocks = old_num_free + 1 - times_merged;
      553 	os_ptr -> number_of_allocated_records = number_of_allocated_records - 1;
      554 	file_substate = file_substate + 1;
      555      end make_free;
      556 
      557 save_old_vars:
      558      proc;					/* sets permanent block info for crash recovery */
      559 	if repeating
      560 	then do;
      561 		call check_file_substate;
      562 		return;
      563 	     end;
      564 	old_init_offset = init_offset (comp_num);
      565 	old_block_size = block_head.block_size;
      566 	prec_block_was_free = is_preceding_block_free;
      567 	old_num_free = number_of_free_blocks;
      568 	former_rover_comp_num = rover_comp_num;
      569 	former_rover_offset = rover_offset;
      570 	if prec_block_was_free
      571 	then do;
      572 		prev_block_size = seg_array (block_offset - 1);
      573 		former_block_size = prev_block_size + old_block_size;
      574 	     end;
      575 	else former_block_size = old_block_size;
      576 	following_block_offset = block_offset + old_block_size;
      577 	if following_block_offset < max_seg_limit
      578 	then do;
      579 		p = addr (seg_array (following_block_offset));
      580 						/* p-> next block */
      581 		next_block_size = p -> block_head.block_size;
      582 		next_next_free_block = p -> next_free_block;
      583 		next_block_was_free = p -> is_this_block_free;
      584 		if (following_block_offset = old_init_offset) & ^prec_block_was_free
      585 		then next_prev_free_block = non_zero (block_offset);
      586 						/* thread will be changed */
      587 		else next_prev_free_block = p -> prev_free_block;
      588 						/* usual case */
      589 	     end;
      590 	file_substate = file_substate + 1;
      591      end save_old_vars;
      592 
      593 merge_preceding_block:
      594      proc;					/* combines new block with preceding free block */
      595 	times_merged = 1;
      596 	old_block_offset = block_offset;
      597 	block_offset = old_block_offset - prev_block_size;
      598 	call zero_words (addr (seg_array (old_block_offset - 1)), 1 + old_block_size);
      599 	block_head.block_size = prev_block_size + old_block_size;
      600 						/* combined size */
      601 	following_block_offset = block_offset + block_head.block_size;
      602      end merge_preceding_block;
      603 
      604 free_this_block:
      605      proc;					/* puts new block onto the free list */
      606 	times_merged = 0;
      607 	next_free_block = old_init_offset;
      608 	prev_free_block = 0;
      609 	nzbo = non_zero (block_offset);
      610 	init_offset (comp_num) = nzbo;
      611 	if next_free_block ^= 0
      612 	then addr (seg_array (non_neg (next_free_block))) -> prev_free_block = nzbo;
      613 	is_this_block_free = "1"b;
      614 	unspec (block_head.flags) = "0"b;
      615 	call zero_words (addr (seg_array (block_offset + size (block_head))), old_block_size - size (block_head));
      616 	following_block_offset = block_offset + old_block_size;
      617 	return;
      618 	dcl     nzbo		 fixed (18) unsigned;
      619      end free_this_block;
      620 
      621 merge_next_block:
      622      proc;					/* combines new block with following free block */
      623 	times_merged = times_merged + 1;
      624 	block_head.block_size = former_block_size + next_block_size;
      625 						/* Adjust links to-from removed block */
      626 	if next_prev_free_block ^= 0
      627 	then addr (seg_array (non_neg (next_prev_free_block))) -> next_free_block = next_next_free_block;
      628 	else init_offset (comp_num) = next_next_free_block;
      629 	if next_next_free_block ^= 0
      630 	then addr (seg_array (non_neg (next_next_free_block))) -> prev_free_block = next_prev_free_block;
      631 						/* Adjust rover if it designates block being removed from free list */
      632 	if following_block_offset = former_rover_offset
      633 	then if comp_num = former_rover_comp_num
      634 	     then rover_offset = non_zero (block_offset);
      635 						/* Set end of merged block */
      636 	if (following_block_offset + next_block_size) = max_seg_limit
      637 	then do;					/* merged block is last in seg */
      638 		call zero_words (p, size (block_head));
      639 		seg_limit (comp_num) = block_offset + size (block_head);
      640 	     end;
      641 	else do;
      642 		call zero_words (p, next_block_size - 1);
      643 		seg_array (block_offset + block_head.block_size - 1) = block_head.block_size;
      644 	     end;
      645 	return;
      646      end merge_next_block;
      647 
      648 	dcl     p			 ptr;
      649 	dcl     times_merged	 fixed;
      650 	dcl     old_block_offset	 fixed (18);
      651      end free;
      652 
      653 non_neg:
      654      proc (offset) returns (fixed (18));
      655 	if offset = 262143				/* 2**18 - 1 */
      656 	then return (0);				/* stands for offset 0 */
      657 	return (offset);
      658 	dcl     offset		 fixed (18);
      659      end non_neg;
      660 
      661 non_zero:
      662      proc (offset) returns (fixed (18));
      663 	if offset = 0
      664 	then return (262143);
      665 	return (offset);
      666 	dcl     offset		 fixed (18);
      667      end non_zero;
      668 
      669 zero_words:
      670      proc (p, n);
      671 	if n > 0
      672 	then unspec (words) = "0"b;
      673 	return;
      674 
      675 	dcl     words		 (n) fixed based (p);
      676 	dcl     p			 ptr;
      677 	dcl     n			 fixed (19);
      678      end;						/* end zero words */
      679 
      680 check_file_substate:
      681      proc;
      682 	next_substate = next_substate + 1;
      683 	if file_substate = next_substate
      684 	then repeating = "0"b;			/* execution resumes normally */
      685      end check_file_substate;
      686 
      687 /* Declarations */
      688 	dcl     new_count		 fixed (34);
      689 	dcl     os_ptr		 ptr;
      690 	dcl     buff_ptr		 ptr;
      691 	dcl     buffer		 char (new_record_length) based (buff_ptr);
      692 	dcl     iocb_ptr		 ptr;
      693 	dcl     record_action	 fixed;
      694 	dcl     abort_exit		 label;
      695 	dcl     pos_ptr		 ptr;		/* not used in this procedure */
      696 	dcl     header_size		 fixed;
      697 	dcl     min_recl		 fixed (21);
      698 	dcl     block_ptr		 ptr;
      699 	dcl     1 block_head	 based (addr (seg_array (block_offset))),
      700 		2 is_preceding_block_free
      701 				 bit (1) unal,
      702 		2 is_this_block_free bit (1) unal,
      703 		2 block_size	 fixed (19) unal,
      704 		2 flags,
      705 		  3 lock_flag	 bit (1) unal,
      706 		  3 stationary	 bit (1) unal,
      707 		  3 indirect	 bit (1) unal,
      708 		  3 after_applies	 bit (1) unal,
      709 		  3 pad		 bit (6) unal,
      710 		  3 excess_words	 fixed (3) unal,	/* only used in indirect allocations */
      711 		2 prev_free_block	 fixed (18) aligned,
      712 		2 next_free_block	 fixed (18) aligned;
      713 	dcl     1 stat_block	 based (addr (seg_array (block_offset))),
      714 		2 pad		 bit (26) unal,
      715 		2 ref_count_after	 fixed (15) unal,
      716 		2 ind_comp	 fixed (13) unal,
      717 		2 ref_count	 fixed (15) unal,
      718 		2 record_lock	 bit (36) aligned,
      719 		2 modifier	 fixed (35),
      720 		2 time_stamp_words	 fixed (71) aligned,
      721 		2 prev_mod	 fixed (35),
      722 		2 record_length	 fixed (21),
      723 		2 record		 char (0 refer (stat_block.record_length));
      724 	dcl     1 ind_head		 based (addr (seg_array (block_offset))),
      725 		2 pad		 bit (26) unal,
      726 		2 ref_count_after	 fixed (15) unal,
      727 		2 ind_comp	 fixed (13) unal,
      728 		2 ref_count	 fixed (15) unal,
      729 		2 record_lock	 bit (36) aligned,
      730 		2 modifier	 fixed (35),
      731 		2 time_stamp_words	 fixed (71) aligned,
      732 		2 prev_mod	 fixed (35),
      733 		2 prev_desc	 fixed (35);
      734 	dcl     1 time_stamp_struct	 based (addr (stat_block.time_stamp_words)),
      735 		2 ind_offset	 bit (18) unal,
      736 		2 time_last_modified fixed (53) unal;
      737 	dcl     record_ptr		 ptr;
      738 	dcl     1 record_head	 based (record_ptr),
      739 		2 record_length	 fixed (21) aligned,
      740 		2 record		 char (0 refer (record_head.record_length));
      741 	dcl     1 old_rec_des	 like designator_struct aligned based (addr (old_record_designator));
      742 	dcl     1 old_ind_des	 like designator_struct aligned based (addr (file_base.old_ind_desc));
      743 	dcl     1 new_rec_des	 like designator_struct aligned based (addr (new_descriptor));
      744 	dcl     comp_num		 fixed;
      745 	dcl     block_offset	 fixed (18);
      746 	dcl     following_block_offset fixed (18);
      747 	dcl     required_block_size	 fixed (19);
      748 	dcl     residue		 fixed (19);
      749 
  1     1 /* the control block */
  1     2      dcl	   indx_cb_ptr	      ptr;
  1     3      dcl	   1 indx_cb	      based (indx_cb_ptr),	/* except as noted, init by create cb */
  1     4 	     2 fcb_ptr	      ptr,
  1     5 	     2 file_base_ptr      ptr,
  1     6 	     2 node_length	      fixed,		/* number of bytes in node, init by create_seg_ptrs */
  1     7 	     2 half_node_length   fixed,		/* init by create_seg_ptrs */
  1     8 	     2 max_record_size    fixed (21),		/* init by create_seg_ptrs */
  1     9 	     2 seg_ptr_array_ptr  ptr,		/* init by create seg_ptrs */
  1    10 	     2 seg_ptr_array_limit
  1    11 			      fixed,		/* init by create seg_ptrs */
  1    12 	     2 mode	      fixed,
  1    13 	     2 is_sequential_open bit (1) aligned,
  1    14 	     2 is_read_only	      bit (1) aligned,
  1    15 	     2 is_ks_out	      bit (1) aligned,	/* position info */
  1    16 	     2 position_stack_ptr ptr,		/* init by create_position stack */
  1    17 	     2 position_stack_height
  1    18 			      fixed,		/* init by create position stack */
  1    19 	     2 root_position_ptr  ptr,		/* init by create_position_stack */
  1    20 	     2 file_position_ptr  ptr,		/* not init */
  1    21 	     2 change_position_ptr
  1    22 			      ptr,		/* not init */
  1    23 						/* auxiliary variables  */
  1    24 	     2 rover_seg_ptr      ptr,		/* init by create_seg_ptrs */
  1    25 	     2 index_state_ptr    ptr,		/* init by create_seg_ptrs */
  1    26 	     2 old_index_height   fixed,
  1    27 	     2 old_last_comp_num  fixed,
  1    28 	     2 last_change_count  fixed (35),
  1    29 	     2 wait_time	      fixed (35),
  1    30 	     2 old_rover_comp_num fixed,
  1    31 	     2 file_state_ptr     ptr,
  1    32 	     2 o_s_ptr	      ptr,
  1    33 	     2 repeating	      bit (1) aligned,
  1    34 	     2 next_substate      fixed,
  1    35 	     2 file_program_version
  1    36 			      fixed,		/* used for record_lock compatibility */
  1    37 	     2 leave_locked	      bit (1) aligned,	/* indicates use of set_file_lock order */
  1    38 	     2 dup_ok	      bit (1) aligned,	/* if set, duplicate keys may occur */
  1    39 	     2 read_exclu	      bit (1) aligned,	/* set when lock excludes readers */
  1    40 	     2 pos_incorrect      bit (1) aligned,	/* indicates index position is not current */
  1    41 	     2 saved_lock_copy    bit (36) aligned,	/* copy of process lock_id */
  1    42 	     2 min_key_len	      fixed,		/* non-zero only in old programs */
  1    43 	     2 stat	      bit (1) aligned,	/* causes write_record to create stationary records */
  1    44 	     2 current_subset     fixed (34),		/* used with select order */
  1    45 	     2 last_subset	      fixed (34),
  1    46 	     2 subset_count	      fixed (34),		/* count of descriptors in current subset */
  1    47 	     2 temp_iocbp	      ptr,		/* temporary file used to implement select order */
  1    48 	     2 trans	      bit (1) aligned,	/* set if -transaction attachment */
  1    49 	     2 transaction_code   fixed (35),		/* set for control switch only */
  1    50 	     2 tcfp	      ptr,		/* ptr to iocb for transaction control switch--if applicable */
  1    51 	     2 reflp	      ptr,		/* ptr to ref list file, set only in transaction control file */
  1    52 	     2 uid	      bit (36) aligned,	/* used under -transaction */
  1    53 	     2 collection_delay_time
  1    54 			      fixed (35),		/* microseconds to wait before garbage removal */
  1    55 	     2 min_res	      fixed (21),		/* for min_block_size order */
  1    56 	     2 min_cap	      fixed (21),		/* also for min_block_size order */
  1    57 	     2 subset_selected    bit (2) aligned,	/* first bit for select, second
  1    58*						   bit is for exclude */
  1    59 	     2 error,				/* for error_status order */
  1    60 	       3 type	      fixed,		/* only one error type supported now */
  1    61 	       3 requested	      fixed (34),		/* skip arg given to position entry */
  1    62 	       3 received	      fixed (34),		/* actual successful skips */
  1    63 	     2 state_vars,
  1    64 	       3 fixed_state_part,
  1    65 	         4 shared	      bit (1) aligned,
  1    66 	         4 next_record_position
  1    67 			      fixed,		/* 0, 1, or 2 */
  1    68 	         4 current_record_is_valid
  1    69 			      bit (1) aligned,
  1    70 	         4 ready_to_write bit (1) aligned,
  1    71 	         4 at_eof_or_bof,
  1    72 		 5 at_bof	      bit (1) unal,
  1    73 		 5 at_eof	      bit (1) unal,
  1    74 		 5 pad	      bit (36) unal,
  1    75 	         4 outside_index  bit (1) aligned,	/* set after deleting current key or after use of record_status with locate switch */
  1    76 	         4 current_descrip
  1    77 			      fixed (35),		/* needed when outside index */
  1    78 	         4 saved_descrip  fixed (35),		/* for restoring index position */
  1    79 	         4 skip_state     fixed,		/* controls scanning of deleted entries */
  1    80 	       3 new_key	      char (256) var;
  1    81 
  1    82      dcl	   current_t_code	      fixed (35) based (addr (indx_cb.tcfp -> iocb.open_data_ptr -> indx_cb.transaction_code));
  1    83 
  1    84 /* component locator structures */
  1    85      dcl	   seg_ptr_array	      (0:seg_ptr_array_limit) ptr based (seg_ptr_array_ptr);
  1    86      dcl	   seg_ptr	      ptr;
  1    87      dcl	   seg_array	      (0:262143) fixed (19) based (seg_ptr) aligned;
  1    88      dcl	   designator	      fixed (35);
  1    89      dcl	   1 ind_des_structure    based,
  1    90 	     2 comp	      fixed (17) unal,
  1    91 	     2 offset	      bit (18) unal;
  1    92      dcl	   1 stat_structure	      based,
  1    93 	     2 pad	      bit (26) unal,
  1    94 	     2 ref_count_after    fixed (16) unsigned unal,
  1    95 	     2 ind_comp	      fixed (13) unal,
  1    96 	     2 ref_count	      fixed (16) unsigned unal,
  1    97 	     2 record_lock	      bit (36) aligned,
  1    98 	     2 modifier	      fixed (35),
  1    99 	     2 time_stamp_words   fixed (71) aligned,
  1   100 	     2 prev_mod	      fixed (35),
  1   101 	     2 record	      char (1000000) var;
  1   102      dcl	   1 ind_structure	      based,
  1   103 	     2 pad	      bit (26) unal,
  1   104 	     2 ref_count_after    fixed (16) unsigned unal,
  1   105 	     2 ind_comp	      fixed (13) unal,
  1   106 	     2 ref_count	      fixed (16) unsigned unal,
  1   107 	     2 record_lock	      bit (36) aligned,
  1   108 	     2 modifier	      fixed (35),
  1   109 	     2 time_stamp_words   fixed (71) aligned,
  1   110 	     2 prev_mod	      fixed (35),
  1   111 	     2 prev_desc	      fixed (35);
  1   112      dcl	   1 time_stamp_structure based,
  1   113 	     2 ind_offset	      bit (18) unal,
  1   114 	     2 time_last_modified fixed (54) unsigned unal;
  1   115      dcl	   1 record_block_structure
  1   116 			      based,
  1   117 	     2 reserved	      aligned,		/* data used by change_record_list */
  1   118 	       3 pad	      bit (2) unal,
  1   119 	       3 block_size	      fixed (19) unal,
  1   120 	       3 lock_flag	      bit (1) unal,		/* record lock flag */
  1   121 	       3 stationary	      bit (1) unal,
  1   122 	       3 indirect	      bit (1) unal,
  1   123 	       3 after_applies    bit (1) unal,
  1   124 	       3 mbz	      bit (10) unal,
  1   125 	     2 block_tail,				/* structure varies with record type */
  1   126 	       3 record	      char (1000000) var;	/* non-stat record location */
  1   127      dcl	   1 designator_struct    aligned based (addr (designator)),
  1   128 	     2 comp_num	      fixed (17) unal,
  1   129 	     2 offset	      bit (18) unal;
  1   130 
  1   131 /* position and node templates */
  1   132      dcl	   1 position_frame	      based (pos_ptr),	/* ref8 */
  1   133 	     2 parent_position_ptr
  1   134 			      ptr,
  1   135 	     2 son_position_ptr   ptr,
  1   136 	     2 node_ptr	      ptr,
  1   137 	     2 node	      fixed (35),
  1   138 	     2 branch_num	      fixed;
  1   139      dcl	   1 node_block	      based (node_ptr),	/* ref9) */
  1   140 	     2 last_branch_num    fixed,
  1   141 	     2 low_key_pos	      fixed,
  1   142 	     2 scat_space	      fixed,
  1   143 	     2 branch_and_descrip (1 refer (node_block.last_branch_num)),
  1   144 						/* in last element only branch is used */
  1   145 	       3 branch	      fixed (35),
  1   146 	       3 descrip,
  1   147 	         4 key_descrip,
  1   148 		 5 key_pos      fixed (17) unal,
  1   149 		 5 key_length   fixed (17) unal,
  1   150 	         4 record_descrip,
  1   151 		 5 record_designator
  1   152 			      fixed (35);
  1   153      dcl	   keys		      char (4096 /* 4*node_size */) based (node_ptr);
  1   154 
  1   155 /* file base and states */
  1   156      dcl	   f_b_ptr	      ptr;
  1   157      dcl	   1 file_base	      based (f_b_ptr),	/* ref10 */
  1   158 	     2 common_header,
  1   159 	       3 file_code	      fixed (35),
  1   160 	       3 lock_word	      bit (36) aligned,
  1   161 	       3 words	      (2) fixed,
  1   162 	     2 file_version	      fixed,
  1   163 	     2 program_version    fixed,
  1   164 	     2 node_size	      fixed (19),
  1   165 	     2 minimum_key_length fixed,
  1   166 	     2 minimum_block_size fixed (19),
  1   167 	     2 max_seg_limit      fixed (19),
  1   168 	     2 root_node_block,
  1   169 	       3 last_branch_num_root
  1   170 			      fixed,		/* =1 */
  1   171 	       3 word	      fixed,
  1   172 	       3 reserved	      fixed,
  1   173 	       3 only_branch_in_root
  1   174 			      fixed (35),
  1   175 	     2 file_state	      fixed,
  1   176 	     2 change_count	      fixed (34),		/* record state info, ref12 */
  1   177 	     2 old_number_of_free_blocks
  1   178 			      fixed (34),
  1   179 	     2 prior_block_size   fixed (19),
  1   180 	     2 old_record_length  fixed (21),
  1   181 	     2 need_new_seg	      bit (1) aligned,
  1   182 	     2 old_residue	      fixed,
  1   183 	     2 new_last_comp_num  fixed,
  1   184 	     2 old_prev_free_block
  1   185 			      fixed (18),
  1   186 	     2 old_next_free_block
  1   187 			      fixed (18),
  1   188 	     2 new_record_length  fixed (21),
  1   189 	     2 old_record_designator
  1   190 			      fixed (35),
  1   191 	     2 prec_block_was_free
  1   192 			      bit (1) aligned,
  1   193 	     2 next_block_was_free
  1   194 			      bit (1) aligned,
  1   195 	     2 former_block_size  fixed (19),
  1   196 	     2 old_init_offset    fixed (18),
  1   197 	     2 old_block_size     fixed (19),
  1   198 	     2 prev_block_size    fixed (19),
  1   199 	     2 former_rover_comp_num
  1   200 			      fixed,
  1   201 	     2 former_rover_offset
  1   202 			      fixed (18),
  1   203 	     2 next_block_size    fixed (19),
  1   204 	     2 next_prev_free_block
  1   205 			      fixed (18),
  1   206 	     2 next_next_free_block
  1   207 			      fixed (18),
  1   208 	     2 saved_ks_out	      bit (1) aligned,
  1   209 	     2 new_descriptor     fixed (35),
  1   210 	     2 old_last_branch_num
  1   211 			      fixed,
  1   212 	     2 old_low_key_pos    fixed,
  1   213 	     2 old_scat_space     fixed,
  1   214 	     2 old_key_pos	      fixed,
  1   215 	     2 rover_comp_num     fixed,
  1   216 	     2 rover_offset	      fixed (18),
  1   217 	     2 old_key_length     fixed,
  1   218 	     2 b_space	      fixed,
  1   219 	     2 last_b_num	      fixed,
  1   220 	     2 count	      fixed,
  1   221 	     2 first_count	      fixed,
  1   222 	     2 second_count	      fixed,
  1   223 	     2 split_num	      fixed,
  1   224 	     2 must_compact_dest  bit (1) aligned,
  1   225 	     2 first_branch	      fixed (35),
  1   226 	     2 min_source_key_pos fixed,
  1   227 	     2 min_dest_key_pos   fixed,
  1   228 	     2 new_low_key_pos    fixed,
  1   229 	     2 new_scat_space     fixed,
  1   230 	     2 old_seg_lim	      fixed (19),
  1   231 	     2 old_number_of_free_nodes
  1   232 			      fixed,
  1   233 	     2 old_next_node_designator
  1   234 			      fixed (35),
  1   235 	     2 new_index_comp_num fixed,
  1   236 	     2 out_of_index	      bit (1) aligned,
  1   237 	     2 saved_min_res      fixed (21),
  1   238 	     2 saved_min_cap      fixed (21),
  1   239 	     2 was_stat	      bit (1) aligned,
  1   240 	     2 was_ind	      bit (1) aligned,
  1   241 	     2 old_ind_desc	      fixed (35),
  1   242 	     2 after_desc	      fixed (35),
  1   243 	     2 old_ref_count      fixed (34),
  1   244 	     2 new_ref_count      fixed (34),
  1   245 	     2 old_num_free	      fixed (34),
  1   246 	     2 old_file_ch_count  fixed (35),
  1   247 	     2 y_count,				/* for conversion of pre-MR6.9 files */
  1   248 	     2 old_modifier	      fixed (35),
  1   249 	     2 was_transaction    bit (1) aligned,	/* state blocks */
  1   250 	     2 index_state	      fixed,
  1   251 	     2 index_state_blocks (0:1),
  1   252 	       3 words	      (104),
  1   253 	     2 reserved	      (30),		/* this free space might come in handy */
  1   254 	     2 old_prev_mod	      fixed (35),
  1   255 	     2 needed_blksz	      fixed (35),
  1   256 	     2 new_desc_val	      fixed (35),
  1   257 	     2 is_partial_deletion
  1   258 			      bit (1) aligned,
  1   259 	     2 reserved2	      (42),
  1   260 	     2 file_state_blocks  (0:1),
  1   261 	       3 words	      (size (file_state_block)) fixed,
  1   262 						/* component info */
  1   263 	     2 max_comp_num	      fixed,
  1   264 	     2 last_comp_num      fixed,
  1   265 	     2 first_free_comp_num,			/* not yet supported */
  1   266 	     2 comp_table_start   (size (comp_table));	/* start of comp_array */
  1   267 
  1   268      dcl	   1 comp_table	      (0:true_max_comp_num) based (addr (file_base.comp_table_start)) aligned,
  1   269 	     2 seg_limit	      fixed (19),		/* abs value is offset of first free word in seg, max val=max
  1   270*						   seg_limit and this indicates full seg */
  1   271 	     2 comp_link	      fixed (17) unal,
  1   272 	     2 init_offset	      fixed (18) unsigned unal;
  1   273 
  1   274      dcl	   1 file_header	      based (f_b_ptr),
  1   275 	     2 first_three_pages  (3, 1024) fixed,
  1   276 	     2 spare_node	      char (4096) aligned;
  1   277 
  1   278 /* The File State */
  1   279      dcl	   fs_ptr		      ptr;
  1   280      dcl	   1 file_state_block     based (fs_ptr),
  1   281 	     2 file_action	      fixed,
  1   282 	     2 file_substate      fixed,
  1   283 	     2 number_of_keys     fixed (34),
  1   284 	     2 duplicate_keys     fixed (34),		/* 0 if no duplications */
  1   285 	     2 dup_key_bytes      fixed (34),
  1   286 	     2 total_key_length   fixed (34),
  1   287 	     2 number_of_records  fixed (34),
  1   288 	     2 total_record_length
  1   289 			      fixed (34),
  1   290 	     2 number_of_allocated_records
  1   291 			      fixed (34),
  1   292 	     2 number_of_free_blocks
  1   293 			      fixed (34),
  1   294 	     2 words	      (2) fixed;
  1   295 
  1   296 /* The Index State */
  1   297      dcl	   is_ptr		      ptr;
  1   298      dcl	   1 index_state_block    based (is_ptr),	/* if this declaration is changed,
  1   299*						   index_state_blocks must be adjusted */
  1   300 	     2 number_of_nodes    fixed (34),
  1   301 	     2 free_node_designator
  1   302 			      fixed (35),
  1   303 	     2 index_tail_comp_num
  1   304 			      fixed,
  1   305 	     2 index_height	      fixed,
  1   306 	     2 index_action	      fixed,
  1   307 	     2 index_substate     fixed,
  1   308 	     2 current_node	      fixed (35),
  1   309 	     2 change_node	      fixed (35),
  1   310 	     2 fake_node,				/* equivalent to a short node because of storage map. It holds
  1   311*						   the new key, new record descrip, and new branch in a fashion
  1   312*						   convenient for overflow-underflow in change_index. */
  1   313 	       3 fake_head_and_descrip,
  1   314 	         4 word1	      fixed,		/* last_branch_num in real node */
  1   315 	         4 word2	      fixed,		/* low_key_pos in real node */
  1   316 	         4 word3	      fixed,		/* normally scat_space */
  1   317 	         4 word4	      fixed,		/* first branch in real node */
  1   318 	         4 new_key_pos    fixed (17) unal,	/* set by initializefile to denote first char
  1   319*						   in new_key_string, never changed */
  1   320 	         4 new_key_length fixed (17) unal,
  1   321 	         4 new_record_descrip,
  1   322 		 5 new_record_designator
  1   323 			      fixed (35),
  1   324 	         4 new_branch     fixed (35),
  1   325 	       3 new_key_string   char (256),
  1   326 	     2 branch_num_adjust  fixed,
  1   327 	     2 pos_array	      (10),
  1   328 	       3 saved_node	      fixed (35),
  1   329 	       3 saved_branch_num fixed;
  1   330 
  1   331      dcl	   1 old_file_base	      based (f_b_ptr),
  1   332 	     2 words1	      (15) fixed,		/* same in both file versions */
  1   333 	     2 old_file_state_blocks
  1   334 			      (0:1),
  1   335 	       3 words	      (5) fixed,
  1   336 	     2 words2	      (7) fixed,
  1   337 	     2 record_state	      fixed,
  1   338 	     2 record_state_blocks
  1   339 			      (0:1),
  1   340 	       3 words	      (4) fixed,
  1   341 	     2 words3	      (14) fixed,		/* rover info same in both versions */
  1   342 	     2 old_version_index_height
  1   343 			      fixed,
  1   344 	     2 old_version_number_of_nodes
  1   345 			      fixed (34),
  1   346 	     2 words4	      (157) fixed,
  1   347 	     2 old_version_index_tail_comp_num
  1   348 			      fixed,
  1   349 	     2 old_version_free_node_designator
  1   350 			      fixed (35),
  1   351 	     2 words5	      (10) fixed,
  1   352 	     2 old_version_comp_info
  1   353 			      fixed,
  1   354 	     2 word,
  1   355 	     2 x_count	      fixed;		/* always zero in old version files */
  1   356 
  1   357 /* External Procedures */
  1   358      dcl	   clock_		      entry returns (fixed (71));
  1   359      dcl	   alloc_cb_file	      entry (fixed,		/* size of block in words */
  1   360 			      ptr);		/* ptr to block */
  1   361      dcl	   free_cb_file	      entry (fixed, ptr);
  1   362      dcl	   get_seg_ptr	      entry (ptr, fixed) returns (ptr);
  1   363      dcl	   make_designator	      entry (fixed, fixed (18), fixed (35));
  1   364      dcl	   create_seg_ptrs	      entry (ptr);
  1   365      dcl	   free_seg_ptrs	      entry (ptr);
  1   366      dcl	   get_new_seg	      entry (ptr, fixed, ptr, fixed, label);
  1   367      dcl	   free_seg	      entry (ptr, fixed, ptr);
  1   368      dcl	   set_bitcounts	      entry (ptr);
  1   369      dcl	   create_position_stack  entry (ptr);
  1   370      dcl	   extend_position_stack  entry (ptr);
  1   371      dcl	   free_position_stack    entry (ptr);
  1   372      dcl	   change_index	      entry (ptr, label);
  1   373      dcl	   change_record_list     entry (ptr, fixed, ptr, label);
  1   374 
  1   375 /* State Constants */
  2     1      dcl	   bumping_count	      static internal options (constant) init (-14);
  2     2      dcl	   rollback_action	      static options (constant) init (-13);
  2     3      dcl	   adjust_action	      static options (constant) init (-12);
  2     4      dcl	   unshared_opening	      static internal fixed options (constant) init (-11);
  2     5      dcl	   non_eof_delete	      static internal fixed options (constant) init (-10);
  2     6      dcl	   free_action	      static options (constant) init (-10);
  2     7      dcl	   write_trunc	      static internal fixed options (constant) init (-9);
  2     8      dcl	   allocate_action	      static options (constant) init (-9);
  2     9      dcl	   reassigning_key	      static options (constant) init (-8);
  2    10      dcl	   read_exclude	      static options (constant) init (-7);
  2    11      dcl	   adding_record	      static options (constant) init (-6);
  2    12      dcl	   deleting_key	      static options (constant) init (-5);
  2    13      dcl	   adding_key	      static options (constant) init (-4);
  2    14      dcl	   delete_action	      static options (constant) init (-3);
  2    15      dcl	   eof_delete	      static internal fixed options (constant) init (-3);
  2    16      dcl	   replace_action	      static options (constant) init (-2);
  2    17      dcl	   rewrite_action	      static internal fixed options (constant) init (-2);
  2    18      dcl	   insert_action	      static options (constant) init (-1);
  2    19      dcl	   append_action	      static internal fixed options (constant) init (-1);
  2    20      dcl	   truncate_action	      static internal fixed options (constant) init (1);
  2    21      dcl	   must_adjust	      static internal fixed options (constant) init (2);
  2    22      dcl	   must_rollback	      static internal fixed options (constant) init (3);
  1   376 
  1   377 
  1   378 /* Other constants */
  1   379      dcl	   true_max_comp_num      static options (constant) init (1250);
  1   380      dcl	   stat_header_size	      static internal fixed options (constant) init (8);
  1   381 
  1   382 /* builtins */
  1   383      dcl	   (verify, reverse)      builtin;
  1   384      dcl	   addr		      builtin;
  1   385      dcl	   divide		      builtin;
  1   386      dcl	   length		      builtin;
  1   387      dcl	   null		      builtin;
  1   388      dcl	   substr		      builtin;
  1   389      dcl	   size		      builtin;
  1   390      dcl	   abs		      builtin;
  1   391      dcl	   unspec		      builtin;
  1   392      dcl	   fixed		      builtin;
  1   393      dcl	   bit		      builtin;
  1   394      dcl	   max		      builtin;
  1   395      dcl	   min		      builtin;
  1   396      dcl	   rel		      builtin;
  1   397 
      750 
  3     1 
  3     2      dcl	   1 iocb		      aligned based (iocb_ptr),
  3     3 						/* I/O control block. */
  3     4 	     2 iocb_version	      fixed init (1),	/* Version number of structure. */
  3     5 	     2 name	      char (32),		/* I/O name of this block. */
  3     6 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  3     7 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  3     8 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  3     9 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  3    10 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  3    11 	     2 reserved	      bit (72),		/* Reserved for future use. */
  3    12 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  3    13 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  3    14 						/* open(p,mode,not_used,s) */
  3    15 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  3    16 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  3    17 						/* get_line(p,bufptr,buflen,actlen,s) */
  3    18 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  3    19 						/* get_chars(p,bufptr,buflen,actlen,s) */
  3    20 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  3    21 						/* put_chars(p,bufptr,buflen,s) */
  3    22 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  3    23 						/* modes(p,newmode,oldmode,s) */
  3    24 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  3    25 						/* position(p,u1,u2,s) */
  3    26 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  3    27 						/* control(p,order,infptr,s) */
  3    28 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  3    29 						/* read_record(p,bufptr,buflen,actlen,s) */
  3    30 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  3    31 						/* write_record(p,bufptr,buflen,s) */
  3    32 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  3    33 						/* rewrite_record(p,bufptr,buflen,s) */
  3    34 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  3    35 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  3    36 						/* seek_key(p,key,len,s) */
  3    37 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  3    38 						/* read_key(p,key,len,s) */
  3    39 	     2 read_length	      entry (ptr, fixed (21), fixed (35));
  3    40 						/* read_length(p,len,s) */
  3    41 
      751 
      752 	dcl     clock		 builtin;
      753 	dcl     needed_block_size	 fixed (19);
      754      end /* end change_record_list */;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/04/82  1620.7  change_record_list.pl1            >dumps>old>recomp>change_record_list.pl1
750          1    07/19/79  1547.0  vfile_indx.incl.pl1               >ldd>include>vfile_indx.incl.pl1
1-376        2    07/19/79  1547.0  vfile_action_codes.incl.pl1       >ldd>include>vfile_action_codes.incl.pl1
751          3    07/02/81  1905.0  iocbv.incl.pl1                    >ldd>include>iocbv.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
abort_exit                             parameter       label variable           dcl 694 set ref 30 434*
addr                                                   builtin function         dcl 1-384 ref 41 64 66 70 71 71 72 72 72 73 76 91 99
                                                                                  100 100 101 103 104 105 153 164 169 199 200 200
                                                                                  201 202 203 215 216 230 237 242 249 272 273 276
                                                                                  277 277 278 279 280 281 296 298 303 304 311 313
                                                                                  330 330 352 361 362 366 370 380 381 395 396 402
                                                                                  405 406 407 409 414 419 420 433 441 445 446 447
                                                                                  451 453 454 455 456 457 458 460 460 472 473 475
                                                                                  475 482 484 485 487 488 490 500 502 503 505 506
                                                                                  507 510 511 512 515 515 540 540 544 564 565 566
                                                                                  579 598 598 599 601 607 608 610 611 611 611 613
                                                                                  614 615 615 615 615 615 624 626 628 629 638 638
                                                                                  639 639 643 643
after_applies             0(25)        based           bit(1)                   level 3 packed unaligned dcl 699 set ref 99* 105*
                                                                                  199* 203* 236* 248* 276* 281*
allocate_action                 002454 constant        fixed bin(17,0)          initial dcl 2-8 ref 36
bit                                                    builtin function         dcl 1-393 ref 406
block_head                             based           structure                level 1 unaligned dcl 699 set ref 460 515 540 615
                                                                                  615 615 638 638 639
block_offset                    000113 automatic       fixed bin(18,0)          dcl 745 set ref 41 64 66 70 71 72 73 76 91 99 100
                                                                                  101 103 104 105 153 164 166* 166 167 169 178* 178
                                                                                  199 200 201 202 203 215 216 230 242 272 273 276
                                                                                  277 278 279 280 281 298* 304* 313* 330 330 352
                                                                                  361* 362 366 368 370 370 381* 389* 393 396* 401*
                                                                                  401* 402 406 407 409 414* 414 415 435* 442 445 451
                                                                                  452* 452 453 454 455 456 457 458 459 460 460 472
                                                                                  473 487 487 497 507 509* 510 511 512 514 515 515
                                                                                  540 540 565 566 572 576 584* 596 597* 599 601 601
                                                                                  607 608 609* 611 611 613 614 615 615 615 615 615
                                                                                  616 624 632* 638 638 639 639 643 643 643
block_ptr                       000106 automatic       pointer                  dcl 698 set ref 215* 236 237 246 248 249
block_size                0(02)        based           fixed bin(19,0)          level 2 packed unaligned dcl 699 set ref 164* 169*
                                                                                  330 366 370 402 445* 451* 455* 487 507* 512* 565
                                                                                  581 599* 601 624* 643 643
buff_ptr                               parameter       pointer                  dcl 690 ref 30 364 364
buffer                                 based           char                     unaligned dcl 691 ref 364
clock                                                  builtin function         dcl 752 ref 76 100 200 237 249 277
comp_link                 1            based           fixed bin(17,0)          array level 2 packed unaligned dcl 1-268 set ref 395
                                                                                  441* 475* 475
comp_num                               based           fixed bin(17,0)          level 2 in structure "old_rec_des" packed unaligned
                                                                                  dcl 741 in procedure "change_record_list" ref 296
comp_num                        000112 automatic       fixed bin(17,0)          dcl 744 in procedure "change_record_list" set ref
                                                                                  296* 297 303* 305 311* 312 348 351 380* 383* 388*
                                                                                  395* 395 396 397* 405 415 433* 434* 436 441 446
                                                                                  447 458 460 474 475 484 488 502 515 540 564 610
                                                                                  628 632 639
comp_num                               based           fixed bin(17,0)          level 2 in structure "old_ind_des" packed unaligned
                                                                                  dcl 742 in procedure "change_record_list" ref 311
comp_num                               based           fixed bin(17,0)          level 2 in structure "new_rec_des" packed unaligned
                                                                                  dcl 743 in procedure "change_record_list" set ref
                                                                                  71 303 380 405* 419* 433
comp_table                             based           structure                array level 1 dcl 1-268
comp_table_start                       based           fixed bin(17,0)          array level 2 dcl 1-157 set ref 395 396 441 446 447
                                                                                  458 460 475 475 484 488 502 515 540 564 610 628
                                                                                  639
delete_action                   002453 constant        fixed bin(17,0)          initial dcl 2-14 ref 81
designator_struct                      based           structure                level 1 dcl 1-127
divide                                                 builtin function         dcl 1-385 ref 319
excess_words              0(32)        based           fixed bin(3,0)           level 3 packed unaligned dcl 699 set ref 41* 330
f_b_ptr                         000124 automatic       pointer                  dcl 1-156 set ref 33* 51 64 68 70 71 72 81 85 85 88
                                                                                  95 103 107 109 130 131 131 139 143 152 152 157 184
                                                                                  184 184 197 201 202 204 212 220 221 224 228 240
                                                                                  246 257 266 278 280 283 284 284 296 298 303 304
                                                                                  311 313 318 318 318 320 330 340 351 353 361 363
                                                                                  364 380 381 382 386 388 389 390 395 396 405 406
                                                                                  407 409 410 415 415 419 419 420 421 433 441 442
                                                                                  443 445 446 446 447 448 458 459 460 461 474 475
                                                                                  475 481 481 482 482 482 484 484 485 485 485 488
                                                                                  488 488 492 498 500 500 502 503 503 505 506 515
                                                                                  515 537 540 540 545 549 552 564 564 565 566 567
                                                                                  568 568 569 569 570 572 573 573 573 575 575 576
                                                                                  577 581 582 583 584 584 584 587 597 598 599 599
                                                                                  607 610 615 616 624 624 626 626 626 628 628 629
                                                                                  629 629 632 632 632 636 636 639 642
file_base                              based           structure                level 1 unaligned dcl 1-157
file_base_ptr             2            based           pointer                  level 2 dcl 1-3 ref 33
file_state_block                       based           structure                level 1 unaligned dcl 1-280 set ref 395 396 419 441
                                                                                  446 447 458 460 475 475 484 488 502 515 540 564
                                                                                  610 628 639
file_state_ptr           44            based           pointer                  level 2 dcl 1-3 ref 34
file_substate             1            based           fixed bin(17,0)          level 2 dcl 1-280 set ref 334* 334 427* 427 434*
                                                                                  476* 476 554* 554 590* 590 683
fixed                                                  builtin function         dcl 1-392 ref 298 304 313 361 381
flags                     0(22)        based           structure                level 2 packed unaligned dcl 699 set ref 614*
following_block_offset          000114 automatic       fixed bin(18,0)          dcl 746 set ref 487* 488 490 514* 515 517 540 544
                                                                                  549 576* 577 579 584 601* 616* 632 636
former_block_size        34            based           fixed bin(19,0)          level 2 dcl 1-157 set ref 549 573* 575* 624
former_rover_comp_num
                         40            based           fixed bin(17,0)          level 2 dcl 1-157 set ref 568* 632
former_rover_offset      41            based           fixed bin(18,0)          level 2 dcl 1-157 set ref 569* 632
free_action                     002455 constant        fixed bin(17,0)          initial dcl 2-6 ref 46
fs_ptr                          000126 automatic       pointer                  dcl 1-279 set ref 34* 114 125 288 291 334 334 357
                                                                                  390 395 396 419 427 427 434 441 446 447 458 460
                                                                                  461 475 475 476 476 484 488 492 502 515 540 552
                                                                                  553 554 554 564 567 590 590 610 628 639 683
get_new_seg                     000012 constant        entry                    external dcl 1-366 ref 434
get_seg_ptr                     000010 constant        entry                    external dcl 1-362 ref 383 397
header_size                     000104 automatic       fixed bin(17,0)          dcl 696 set ref 38* 54* 59* 141* 319 362 366 368
ind_comp                  1(06)        based           fixed bin(13,0)          level 2 packed unaligned dcl 713 set ref 71*
ind_head                               based           structure                level 1 unaligned dcl 724
ind_offset                             based           bit(18)                  level 2 packed unaligned dcl 734 set ref 72*
indirect                  0(24)        based           bit(1)                   level 3 packed unaligned dcl 699 set ref 104* 273*
                                                                                  279*
indx_cb                                based           structure                level 1 unaligned dcl 1-3
indx_cb_ptr                     000120 automatic       pointer                  dcl 1-2 set ref 32* 33 34 35 41 62 91 97 160 224 297
                                                                                  305 312 325 343 347 348 349 377 387 436 437 439
                                                                                  467 532 559 682 682 683 683
init_offset               1(18)        based           fixed bin(18,0)          array level 2 packed unsigned unaligned dcl 1-268
                                                                                  set ref 396 447* 458* 484* 502* 564 610* 628*
insert_action                   002452 constant        fixed bin(17,0)          initial dcl 2-18 ref 51
iocb                                   based           structure                level 1 dcl 3-2
iocb_ptr                               parameter       pointer                  dcl 692 set ref 30 32 383* 397* 434*
is_partial_deletion     476            based           bit(1)                   level 2 dcl 1-157 ref 85
is_preceding_block_free                based           bit(1)                   level 2 packed unaligned dcl 699 set ref 453* 472*
                                                                                  490* 510* 548* 566
is_this_block_free        0(01)        based           bit(1)                   level 2 packed unaligned dcl 699 set ref 352* 454*
                                                                                  473* 511* 583 613*
last_comp_num                          based           fixed bin(17,0)          level 2 dcl 1-157 ref 419
lock_flag                 0(22)        based           bit(1)                   level 3 packed unaligned dcl 699 set ref 153*
max                                                    builtin function         dcl 1-394 ref 318 320
max_seg_limit            11            based           fixed bin(19,0)          level 2 dcl 1-157 ref 442 445 446 488 488 515 540
                                                                                  577 636
min_recl                        000105 automatic       fixed bin(21,0)          dcl 697 set ref 318* 319
minimum_block_size       10            based           fixed bin(19,0)          level 2 dcl 1-157 ref 130 131 157 283 284 320 353
                                                                                  443
n                                      parameter       fixed bin(19,0)          dcl 677 ref 669 671 671
need_new_seg             23            based           bit(1)                   level 2 dcl 1-157 set ref 340 386* 421*
needed_blksz            474            based           fixed bin(35,0)          level 2 dcl 1-157 set ref 220 330*
needed_block_size               000130 automatic       fixed bin(19,0)          dcl 753 set ref 41 319* 320
new_count                       000100 automatic       fixed bin(34,0)          dcl 688 set ref 88* 91 95* 117 127
new_descriptor           46            based           fixed bin(35,0)          level 2 dcl 1-157 set ref 71 72 152* 202 212 278 303
                                                                                  304 361 380 381 405 406 419 420 433
new_rec_des                            based           structure                level 1 dcl 743
new_record_length        30            based           fixed bin(21,0)          level 2 dcl 1-157 ref 228 240 318 363 364
next_block_size          42            based           fixed bin(19,0)          level 2 dcl 1-157 set ref 581* 624 636 642
next_block_was_free      33            based           bit(1)                   level 2 dcl 1-157 set ref 545 583*
next_free_block           2            based           fixed bin(18,0)          level 2 dcl 699 set ref 409 414 456* 482* 500* 506*
                                                                                  582 607* 611 611* 626*
next_next_free_block     44            based           fixed bin(18,0)          level 2 dcl 1-157 set ref 582* 626 628 629 629*
next_prev_free_block     43            based           fixed bin(18,0)          level 2 dcl 1-157 set ref 584* 587* 626 626* 629
next_substate            51            based           fixed bin(17,0)          level 2 dcl 1-3 set ref 682* 682 683
null                                                   builtin function         dcl 1-387 ref 364
number_of_allocated_records
                         10            based           fixed bin(34,0)          level 2 dcl 1-280 set ref 114* 114 125* 125 288* 288
                                                                                  357* 357 553* 553
number_of_free_blocks
                         11            based           fixed bin(34,0)          level 2 dcl 1-280 set ref 291* 291 390 461* 492*
                                                                                  552* 567
nzbo                            000302 automatic       fixed bin(18,0)          unsigned dcl 618 set ref 609* 610 611
o_s_ptr                  46            based           pointer                  level 2 dcl 1-3 ref 35
offset                                 parameter       fixed bin(18,0)          dcl 658 in procedure "non_neg" ref 653 655 657
offset                    0(18)        based           bit(18)                  level 2 in structure "old_ind_des" packed unaligned
                                                                                  dcl 742 in procedure "change_record_list" ref 313
offset                                 parameter       fixed bin(18,0)          dcl 666 in procedure "non_zero" ref 661 663 665
offset                    0(18)        based           bit(18)                  level 2 in structure "new_rec_des" packed unaligned
                                                                                  dcl 743 in procedure "change_record_list" set ref
                                                                                  72 304 361 381 406* 420*
offset                    0(18)        based           bit(18)                  level 2 in structure "old_rec_des" packed unaligned
                                                                                  dcl 741 in procedure "change_record_list" ref 298
old_block_offset                000251 automatic       fixed bin(18,0)          dcl 650 set ref 596* 597 598 598
old_block_size           36            based           fixed bin(19,0)          level 2 dcl 1-157 set ref 565* 573 575 576 598 599
                                                                                  615 616
old_ind_des                            based           structure                level 1 dcl 742
old_ind_desc            103            based           fixed bin(35,0)          level 2 dcl 1-157 set ref 109 204 311 313
old_init_offset          35            based           fixed bin(18,0)          level 2 dcl 1-157 set ref 564* 584 607
old_modifier            112            based           fixed bin(35,0)          level 2 dcl 1-157 ref 103 201 246 280
old_next_free_block      27            based           fixed bin(18,0)          level 2 dcl 1-157 set ref 409* 481 482 484 485 485*
                                                                                  503 503* 506
old_num_free            107            based           fixed bin(34,0)          level 2 dcl 1-157 set ref 552 567*
old_number_of_free_blocks
                         20            based           fixed bin(34,0)          level 2 dcl 1-157 set ref 390* 461 492
old_prev_free_block      26            based           fixed bin(18,0)          level 2 dcl 1-157 set ref 407* 482 482* 485 500 500*
                                                                                  505
old_prev_mod            473            based           fixed bin(35,0)          level 2 dcl 1-157 ref 184
old_rec_des                            based           structure                level 1 dcl 741
old_record_designator
                         31            based           fixed bin(35,0)          level 2 dcl 1-157 set ref 152 296 298
old_ref_count           105            based           fixed bin(34,0)          level 2 dcl 1-157 ref 64 70 88 95
old_residue              24            based           fixed bin(17,0)          level 2 dcl 1-157 set ref 382 410*
old_rover_comp_num       42            based           fixed bin(17,0)          level 2 dcl 1-3 set ref 348* 436*
open_data_ptr            22            based           pointer                  level 2 dcl 3-2 ref 32
os_ptr                          000102 automatic       pointer                  dcl 689 set ref 35* 114 125 288 291 357 553
out_of_index             76            based           bit(1)                   level 2 dcl 1-157 ref 85
p                               000246 automatic       pointer                  dcl 648 in procedure "free" set ref 544* 548 579*
                                                                                  581 582 583 587 638* 642*
p                                      parameter       pointer                  dcl 676 in procedure "zero_words" ref 669 671
prec_block_was_free      32            based           bit(1)                   level 2 dcl 1-157 set ref 537 566* 570 584
prev_block_size          37            based           fixed bin(19,0)          level 2 dcl 1-157 set ref 572* 573 597 599
prev_desc                 7            based           fixed bin(35,0)          level 2 dcl 724 set ref 101* 202* 272* 278*
prev_free_block           1            based           fixed bin(18,0)          level 2 dcl 699 set ref 407 457* 485* 503* 505* 587
                                                                                  608* 611* 629*
prev_mod                  6            based           fixed bin(35,0)          level 2 in structure "stat_block" dcl 713
                                                                                  in procedure "change_record_list" set ref 73* 246*
                                                                                  280*
prev_mod                  6            based           fixed bin(35,0)          level 2 in structure "ind_head" dcl 724 in procedure
                                                                                  "change_record_list" set ref 103* 201*
prior_block_size         21            based           fixed bin(19,0)          level 2 dcl 1-157 ref 131 143 221 257 284
record                    1            based           char                     level 2 packed unaligned dcl 738 set ref 230* 230
                                                                                  242* 242 364*
record_action                          parameter       fixed bin(17,0)          dcl 693 ref 30 36 46 51 81
record_head                            based           structure                level 1 unaligned dcl 738
record_length                          based           fixed bin(21,0)          level 2 dcl 738 set ref 228* 230 230 240* 242 242
                                                                                  363* 364
record_ptr                      000110 automatic       pointer                  dcl 737 set ref 216* 228 230 240 242 362* 363 364
ref_count                 1(20)        based           fixed bin(15,0)          level 2 in structure "ind_head" packed unaligned
                                                                                  dcl 724 in procedure "change_record_list" set ref
                                                                                  91*
ref_count                 1(20)        based           fixed bin(15,0)          level 2 in structure "stat_block" packed unaligned
                                                                                  dcl 713 in procedure "change_record_list" set ref
                                                                                  64*
ref_count_after           0(26)        based           fixed bin(15,0)          level 2 packed unaligned dcl 713 set ref 70*
repeating                50            based           bit(1)                   level 2 dcl 1-3 set ref 41 62 91 97 160 224 325 343
                                                                                  349 377 439 467 532 559 683*
required_block_size             000115 automatic       fixed bin(19,0)          dcl 747 set ref 41 130* 143 164 166 178 220* 221 257
                                                                                  283* 320* 402 442 451 452 497 507
residue                         000116 automatic       fixed bin(19,0)          dcl 748 in procedure "change_record_list" set ref
                                                                                  131* 143* 144 157 169 257* 284*
residue                         000176 automatic       fixed bin(19,0)          dcl 520 in procedure "allocate" set ref 353 382*
                                                                                  402* 403 410 442* 443 455 512 514 517
residue_offset                  000177 automatic       fixed bin(18,0)          dcl 521 set ref 497* 498 500 502 503 505 506 509
rover_comp_num           53            based           fixed bin(17,0)          level 2 dcl 1-157 set ref 351* 388 415 474* 568
rover_offset             54            based           fixed bin(18,0)          level 2 dcl 1-157 set ref 389 415 448* 459* 481*
                                                                                  498* 569 632*
rover_seg_ptr            32            based           pointer                  level 2 dcl 1-3 set ref 347* 387 437*
saved_min_cap           100            based           fixed bin(21,0)          level 2 dcl 1-157 ref 318
saved_min_res            77            based           fixed bin(21,0)          level 2 dcl 1-157 ref 318
search_not_done                 000206 automatic       bit(1)                   dcl 428 set ref 391* 392 411* 422*
seg_array                              based           fixed bin(19,0)          array dcl 1-87 set ref 41 64 66 70 71 72 73 76 91 99
                                                                                  100 101 103 104 105 153 164 167* 169 199 200 201
                                                                                  202 203 215 216 230 242 272 273 276 277 278 279
                                                                                  280 281 330 330 352 362 366 368* 370* 370 402 407
                                                                                  409 414 445 451 453 454 455 456 457 460 472 473
                                                                                  482 485 487 490 500 503 505 506 507 510 511 512
                                                                                  515 517* 540 544 549* 565 566 572 579 598 598 599
                                                                                  601 607 608 611 611 611 613 614 615 615 615 615
                                                                                  615 624 626 629 638 638 639 643* 643 643
seg_limit                              based           fixed bin(19,0)          array level 2 dcl 1-268 set ref 446* 460* 488* 515*
                                                                                  540* 639*
seg_ptr                         000122 automatic       pointer                  dcl 1-86 set ref 41 64 66 70 71 72 73 76 91 99 100
                                                                                  101 103 104 105 153 164 167 169 199 200 201 202
                                                                                  203 215 216 230 242 272 273 276 277 278 279 280
                                                                                  281 297* 305* 312* 330 330 347 352 362 366 368 370
                                                                                  370 383* 387* 397* 402 407 409 414 434* 437 445
                                                                                  451 453 454 455 456 457 460 472 473 482 485 487
                                                                                  490 500 503 505 506 507 510 511 512 515 517 540
                                                                                  544 549 565 566 572 579 598 598 599 601 607 608
                                                                                  611 611 611 613 614 615 615 615 615 615 624 626
                                                                                  629 638 638 639 643 643 643
seg_ptr_array                          based           pointer                  array dcl 1-85 ref 297 305 312
seg_ptr_array_ptr        10            based           pointer                  level 2 dcl 1-3 ref 297 305 312
size                                                   builtin function         dcl 1-389 ref 395 396 419 441 446 447 458 460 460
                                                                                  475 475 484 488 502 515 515 540 540 564 610 615
                                                                                  615 615 628 638 638 639 639
stat_block                             based           structure                level 1 unaligned dcl 713
stat_header_size                       constant        fixed bin(17,0)          initial dcl 1-380 ref 59 216
stationary                0(23)        based           bit(1)                   level 3 packed unaligned dcl 699 set ref 66*
time_last_modified        0(18)        based           fixed bin(53,0)          level 2 packed unaligned dcl 734 set ref 100* 200*
                                                                                  237* 249* 277*
time_stamp_struct                      based           structure                level 1 packed unaligned dcl 734
time_stamp_words          4            based           fixed bin(71,0)          level 2 dcl 713 set ref 72 76* 100 200 237 249 277
times_merged                    000250 automatic       fixed bin(17,0)          dcl 649 set ref 552 595* 606* 623* 623
unspec                                                 builtin function         dcl 1-391 set ref 614* 671*
was_ind                 102            based           bit(1)                   level 2 dcl 1-157 ref 107 184 197
was_stat                101            based           bit(1)                   level 2 dcl 1-157 ref 51 81 139
was_transaction         113            based           bit(1)                   level 2 dcl 1-157 ref 68 184 224 266
words                                  based           fixed bin(17,0)          array dcl 675 set ref 671*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
abs                                                    builtin function         dcl 1-390
adding_key                             internal static fixed bin(17,0)          initial dcl 2-13
adding_record                          internal static fixed bin(17,0)          initial dcl 2-11
adjust_action                          internal static fixed bin(17,0)          initial dcl 2-3
alloc_cb_file                   000000 constant        entry                    external dcl 1-359
append_action                          internal static fixed bin(17,0)          initial dcl 2-19
bumping_count                          internal static fixed bin(17,0)          initial dcl 2-1
change_index                    000000 constant        entry                    external dcl 1-372
change_record_list              000000 constant        entry                    external dcl 1-373
clock_                          000000 constant        entry                    external dcl 1-358
create_position_stack           000000 constant        entry                    external dcl 1-369
create_seg_ptrs                 000000 constant        entry                    external dcl 1-364
current_t_code                         based           fixed bin(35,0)          dcl 1-82
deleting_key                           internal static fixed bin(17,0)          initial dcl 2-12
designator                             automatic       fixed bin(35,0)          dcl 1-88
eof_delete                             internal static fixed bin(17,0)          initial dcl 2-15
extend_position_stack           000000 constant        entry                    external dcl 1-370
file_header                            based           structure                level 1 unaligned dcl 1-274
free_cb_file                    000000 constant        entry                    external dcl 1-361
free_position_stack             000000 constant        entry                    external dcl 1-371
free_seg                        000000 constant        entry                    external dcl 1-367
free_seg_ptrs                   000000 constant        entry                    external dcl 1-365
ind_des_structure                      based           structure                level 1 packed unaligned dcl 1-89
ind_structure                          based           structure                level 1 unaligned dcl 1-102
index_state_block                      based           structure                level 1 unaligned dcl 1-298
is_ptr                                 automatic       pointer                  dcl 1-297
keys                                   based           char(4096)               unaligned dcl 1-153
length                                                 builtin function         dcl 1-386
make_designator                 000000 constant        entry                    external dcl 1-363
min                                                    builtin function         dcl 1-395
must_adjust                            internal static fixed bin(17,0)          initial dcl 2-21
must_rollback                          internal static fixed bin(17,0)          initial dcl 2-22
node_block                             based           structure                level 1 unaligned dcl 1-139
non_eof_delete                         internal static fixed bin(17,0)          initial dcl 2-5
old_file_base                          based           structure                level 1 unaligned dcl 1-331
pos_ptr                                automatic       pointer                  dcl 695
position_frame                         based           structure                level 1 unaligned dcl 1-132
read_exclude                           internal static fixed bin(17,0)          initial dcl 2-10
reassigning_key                        internal static fixed bin(17,0)          initial dcl 2-9
record_block_structure                 based           structure                level 1 unaligned dcl 1-115
rel                                                    builtin function         dcl 1-396
replace_action                         internal static fixed bin(17,0)          initial dcl 2-16
reverse                                                builtin function         dcl 1-383
rewrite_action                         internal static fixed bin(17,0)          initial dcl 2-17
rollback_action                        internal static fixed bin(17,0)          initial dcl 2-2
set_bitcounts                   000000 constant        entry                    external dcl 1-368
stat_structure                         based           structure                level 1 unaligned dcl 1-92
substr                                                 builtin function         dcl 1-388
time_stamp_structure                   based           structure                level 1 packed unaligned dcl 1-112
true_max_comp_num                      internal static fixed bin(17,0)          initial dcl 1-379
truncate_action                        internal static fixed bin(17,0)          initial dcl 2-20
unshared_opening                       internal static fixed bin(17,0)          initial dcl 2-4
verify                                                 builtin function         dcl 1-383
write_trunc                            internal static fixed bin(17,0)          initial dcl 2-7

NAMES DECLARED BY EXPLICIT CONTEXT.
allocate                        000710 constant        entry                    internal dcl 337 ref 40 56 61 146
allocate_part_block             001512 constant        entry                    internal dcl 495 ref 355
allocate_whole_block            001413 constant        entry                    internal dcl 479 ref 353
change_record_list              000015 constant        entry                    external dcl 30
check_file_substate             002371 constant        entry                    internal dcl 680 ref 327 379 469 534 561
check_rover                     001172 constant        label                    dcl 415 ref 398
check_tail                      000313 constant        label                    dcl 157 ref 132 258 286
compact_case                    000407 constant        label                    dcl 212 ref 184
copy_buffer                     000755 constant        entry                    internal dcl 359 ref 155
find_free_block                 001026 constant        entry                    internal dcl 375 ref 339
find_new_ind_block              000603 constant        entry                    internal dcl 301 ref 48 217
find_old_block                  000565 constant        entry                    internal dcl 294 ref 80 120 147 255 261
find_old_ind_block              000622 constant        entry                    internal dcl 309 ref 112 193 207
free                            001636 constant        entry                    internal dcl 524 ref 49 81 113 122 127 149 179 195
                                                                                  208 253
free_this_block                 002101 constant        entry                    internal dcl 604 ref 539
make_free                       001642 constant        entry                    internal dcl 530 ref 527
merge_next_block                002171 constant        entry                    internal dcl 621 ref 545
merge_preceding_block           002041 constant        entry                    internal dcl 593 ref 537
non_neg                         002332 constant        entry                    internal dcl 653 ref 401 482 485 500 503 611 626 629
non_zero                        002343 constant        entry                    internal dcl 661 ref 584 609 632
save_needed_blksz               000662 constant        entry                    internal dcl 323 ref 219
save_old_vars                   001726 constant        entry                    internal dcl 557 ref 526
set_new_comp_link               001364 constant        entry                    internal dcl 465 ref 438
set_required_block_size         000640 constant        entry                    internal dcl 316 ref 39 55 60 142
use_new_segment                 001216 constant        entry                    internal dcl 431 ref 342
zero_words                      002354 constant        entry                    internal dcl 669 ref 598 615 638 642

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2520        2534    2456        2530
Length      2752    2456        14         201      42           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
change_record_list                  313 external procedure  is an external procedure.  
find_old_block                          internal procedure  shares stack frame of external procedure change_record_list.  
find_new_ind_block                      internal procedure  shares stack frame of external procedure change_record_list.  
find_old_ind_block                      internal procedure  shares stack frame of external procedure change_record_list.  
set_required_block_size                 internal procedure  shares stack frame of external procedure change_record_list.  
save_needed_blksz                       internal procedure  shares stack frame of external procedure change_record_list.  
allocate                                internal procedure  shares stack frame of external procedure change_record_list.  
find_free_block                         internal procedure  shares stack frame of external procedure change_record_list.  
use_new_segment                         internal procedure  shares stack frame of external procedure change_record_list.  
set_new_comp_link                       internal procedure  shares stack frame of external procedure change_record_list.  
allocate_whole_block                    internal procedure  shares stack frame of external procedure change_record_list.  
allocate_part_block                     internal procedure  shares stack frame of external procedure change_record_list.  
free                                    internal procedure  shares stack frame of external procedure change_record_list.  
make_free                               internal procedure  shares stack frame of external procedure change_record_list.  
save_old_vars                           internal procedure  shares stack frame of external procedure change_record_list.  
merge_preceding_block                   internal procedure  shares stack frame of external procedure change_record_list.  
free_this_block                         internal procedure  shares stack frame of external procedure change_record_list.  
merge_next_block                        internal procedure  shares stack frame of external procedure change_record_list.  
non_neg                                 internal procedure  shares stack frame of external procedure change_record_list.  
non_zero                                internal procedure  shares stack frame of external procedure change_record_list.  
zero_words                              internal procedure  shares stack frame of external procedure change_record_list.  
check_file_substate                     internal procedure  shares stack frame of external procedure change_record_list.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
change_record_list       000100 new_count                   change_record_list
                         000102 os_ptr                      change_record_list
                         000104 header_size                 change_record_list
                         000105 min_recl                    change_record_list
                         000106 block_ptr                   change_record_list
                         000110 record_ptr                  change_record_list
                         000112 comp_num                    change_record_list
                         000113 block_offset                change_record_list
                         000114 following_block_offset      change_record_list
                         000115 required_block_size         change_record_list
                         000116 residue                     change_record_list
                         000120 indx_cb_ptr                 change_record_list
                         000122 seg_ptr                     change_record_list
                         000124 f_b_ptr                     change_record_list
                         000126 fs_ptr                      change_record_list
                         000130 needed_block_size           change_record_list
                         000176 residue                     allocate
                         000177 residue_offset              allocate
                         000206 search_not_done             find_free_block
                         000246 p                           free
                         000250 times_merged                free
                         000251 old_block_offset            free
                         000302 nzbo                        free_this_block

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out        return              ext_entry           clock

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_new_seg                   get_seg_ptr

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     30 000010        32 000022        33 000027        34 000031        35 000033        36 000035        38 000040
     39 000042        40 000043        41 000044        45 000056        46 000057        48 000061        49 000062
     50 000063        51 000064        54 000071        55 000073        56 000074        57 000075        59 000076
     60 000100        61 000101        62 000102        64 000105        66 000114        68 000116        70 000122
     71 000131        72 000136        73 000141        75 000143        76 000144        78 000146        80 000147
     81 000150        85 000161        88 000165        91 000170        94 000200        95 000201        97 000203
     99 000206       100 000212       101 000215       103 000220       104 000222       105 000224       107 000226
    109 000230       112 000232       113 000233       114 000234       117 000240       120 000242       122 000243
    124 000244       125 000245       126 000251       127 000252       130 000256       131 000260       132 000263
    134 000264       139 000265       141 000270       142 000272       143 000273       144 000277       146 000300
    147 000301       149 000302       150 000303       152 000304       153 000306       155 000312       157 000313
    160 000317       164 000322       166 000331       167 000333       169 000335       170 000343       178 000344
    179 000346       182 000347       184 000350       193 000357       195 000360       196 000361       197 000362
    199 000364       200 000370       201 000373       202 000376       203 000400       204 000402       207 000404
    208 000405       210 000406       212 000407       215 000411       216 000414       217 000421       219 000422
    220 000423       221 000426       224 000430       228 000435       230 000437       233 000447       236 000450
    237 000452       240 000456       242 000461       246 000471       248 000474       249 000476       253 000502
    255 000503       257 000504       258 000510       261 000511       266 000512       272 000515       273 000521
    274 000524       276 000525       277 000531       278 000534       279 000540       280 000542       281 000544
    283 000546       284 000550       286 000553       288 000554       291 000560       292 000564       294 000565
    296 000566       297 000572       298 000577       299 000602       301 000603       303 000604       304 000610
    305 000613       307 000621       309 000622       311 000623       312 000627       313 000634       314 000637
    316 000640       318 000641       319 000650       320 000655       321 000661       323 000662       325 000663
    327 000666       328 000667       330 000670       334 000705       335 000707       337 000710       339 000711
    340 000712       342 000715       343 000716       345 000722       347 000723       348 000726       349 000730
    351 000733       352 000735       353 000741       355 000746       357 000747       359 000754       361 000756
    362 000762       363 000766       364 000771       366 001006       368 001015       370 001017       373 001025
    375 001026       377 001027       379 001032       380 001033       381 001037       382 001042       383 001044
    384 001060       386 001061       387 001063       388 001065       389 001067       390 001071       391 001074
    392 001076       393 001100       395 001102       396 001110       397 001114       398 001130       401 001131
    402 001133       403 001142       405 001145       406 001151       407 001156       409 001160       410 001164
    411 001166       412 001167       414 001170       415 001172       419 001201       420 001205       421 001207
    422 001211       426 001212       427 001213       429 001215       431 001216       433 001217       434 001223
    435 001244       436 001245       437 001250       438 001252       439 001253       441 001257       442 001263
    443 001267       445 001273       446 001302       447 001307       448 001312       449 001313       451 001314
    452 001323       453 001325       454 001330       455 001333       456 001340       457 001342       458 001344
    459 001352       460 001354       461 001357       463 001363       465 001364       467 001365       469 001370
    470 001371       472 001372       473 001375       474 001400       475 001403       476 001410       477 001412
    479 001413       481 001414       482 001417       484 001437       485 001445       487 001464       488 001473
    490 001503       492 001505       493 001511       495 001512       497 001513       498 001516       500 001520
    502 001537       503 001545       505 001564       506 001571       507 001573       509 001602       510 001604
    511 001606       512 001611       514 001616       515 001621       517 001632       518 001635       524 001636
    526 001637       527 001640       528 001641       530 001642       532 001643       534 001646       535 001647
    537 001650       539 001655       540 001656       544 001671       545 001673       548 001677       549 001701
    552 001705       553 001720       554 001724       555 001725       557 001726       559 001727       561 001732
    562 001733       564 001734       565 001742       566 001750       567 001753       568 001756       569 001760
    570 001762       572 001764       573 001770       574 001772       575 001773       576 001775       577 002000
    579 002002       581 002004       582 002010       583 002012       584 002016       587 002034       590 002036
    591 002040       593 002041       595 002042       596 002044       597 002046       598 002051       599 002062
    601 002073       602 002100       604 002101       606 002102       607 002103       608 002110       609 002112
    610 002116       611 002125       613 002145       614 002151       615 002153       616 002164       617 002170
    621 002171       623 002172       624 002173       626 002204       628 002224       629 002232       632 002251
    636 002267       638 002274       639 002300       640 002307       642 002310       643 002315       645 002331
    653 002332       655 002334       657 002341       661 002343       663 002345       665 002352       669 002354
    671 002356       673 002370       680 002371       682 002372       683 002374       685 002401


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
